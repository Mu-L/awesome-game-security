Project Path: arc_focus-creative-games_hybridclr_c9qfjuq8

Source Tree:

```txt
arc_focus-creative-games_hybridclr_c9qfjuq8
├── LICENSE
├── README.md
├── README_EN.md
├── docs
│   ├── _config.yml
│   ├── images
│   │   ├── architecture.png
│   │   └── logo.jpg
│   └── sponsor
│       ├── weixin.JPG
│       └── zhifubao.JPG
└── hybridclr
    ├── CommonDef.cpp
    ├── CommonDef.h
    ├── Il2CppCompatibleDef.cpp
    ├── Il2CppCompatibleDef.h
    ├── Runtime.cpp
    ├── Runtime.h
    ├── RuntimeApi.cpp
    ├── RuntimeApi.h
    ├── RuntimeConfig.cpp
    ├── RuntimeConfig.h
    ├── generated
    │   ├── AssemblyManifest.cpp
    │   ├── MethodBridge.cpp
    │   └── UnityVersion.h
    ├── interpreter
    │   ├── Engine.cpp
    │   ├── Engine.h
    │   ├── InstrinctDef.h
    │   ├── Instruction.cpp
    │   ├── Instruction.h
    │   ├── Interpreter.cpp
    │   ├── Interpreter.h
    │   ├── InterpreterDefs.cpp
    │   ├── InterpreterDefs.h
    │   ├── InterpreterModule.cpp
    │   ├── InterpreterModule.h
    │   ├── InterpreterUtil.cpp
    │   ├── InterpreterUtil.h
    │   ├── Interpreter_Execute.cpp
    │   ├── MemoryUtil.h
    │   ├── MethodBridge.cpp
    │   └── MethodBridge.h
    ├── metadata
    │   ├── AOTHomologousImage.cpp
    │   ├── AOTHomologousImage.h
    │   ├── Assembly.cpp
    │   ├── Assembly.h
    │   ├── BlobReader.h
    │   ├── ClassFieldLayoutCalculator.cpp
    │   ├── ClassFieldLayoutCalculator.h
    │   ├── Coff.h
    │   ├── ConsistentAOTHomologousImage.cpp
    │   ├── ConsistentAOTHomologousImage.h
    │   ├── CustomAttributeDataWriter.h
    │   ├── Image.cpp
    │   ├── Image.h
    │   ├── InterpreterImage.cpp
    │   ├── InterpreterImage.h
    │   ├── MetadataDef.h
    │   ├── MetadataModule.cpp
    │   ├── MetadataModule.h
    │   ├── MetadataPool.cpp
    │   ├── MetadataPool.h
    │   ├── MetadataReader.h
    │   ├── MetadataUtil.cpp
    │   ├── MetadataUtil.h
    │   ├── MethodBodyCache.cpp
    │   ├── MethodBodyCache.h
    │   ├── Opcodes.cpp
    │   ├── Opcodes.h
    │   ├── PDBImage.cpp
    │   ├── PDBImage.h
    │   ├── RawImage.cpp
    │   ├── RawImage.h
    │   ├── RawImageBase.cpp
    │   ├── RawImageBase.h
    │   ├── SuperSetAOTHomologousImage.cpp
    │   ├── SuperSetAOTHomologousImage.h
    │   ├── Tables.h
    │   ├── VTableSetup.cpp
    │   └── VTableSetup.h
    └── transform
        ├── BasicBlockSpliter.cpp
        ├── BasicBlockSpliter.h
        ├── TemporaryMemoryArena.cpp
        ├── TemporaryMemoryArena.h
        ├── Transform.cpp
        ├── Transform.h
        ├── TransformContext.cpp
        ├── TransformContext.h
        ├── TransformContext_CallCommon.cpp
        ├── TransformContext_Instinct.cpp
        ├── TransformModule.cpp
        └── TransformModule.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Code Philosophy Technology Ltd.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
- [README 中文](./README.md)
- [README English](./README_EN.md)

# HybridCLR

[![license](http://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/focus-creative-games/hybridclr/blob/main/LICENSE)

![logo](./docs/images/logo.jpg)

<br/>
<br/>

HybridCLR是一个**特性完整、零成本、高性能、低内存**的**近乎完美**的Unity全平台原生c#热更新解决方案。

HybridCLR扩充了il2cpp运行时代码，使它由纯[AOT](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) runtime变成AOT+Interpreter 混合runtime，进而原生支持动态加载assembly，从底层彻底支持了热更新。使用HybridCLR技术的游戏不仅能在Android平台，也能在IOS、Consoles、WebGL等所有il2cpp支持的平台上高效运行。

由于HybridCLR对ECMA-335规范 的良好支持以及对Unity开发工作流的高度兼容，Unity项目在接入HybridCLR后，可以几乎无缝地获得C#代码热更新的能力，开发者不需要改变日常开发习惯和要求。HybridCLR首次实现了将Unity平台的全平台代码热更新方案的工程难度降到几乎为零的水平。

欢迎拥抱现代原生C#热更新技术 ！！！

## 文档

- [官方文档](https://www.hybridclr.cn/docs/intro)
- [快速上手](https://www.hybridclr.cn/docs/beginner/quickstart)
- [商业项目案例](https://www.hybridclr.cn/docs/other/businesscase)
- [LeanCLR](https://github.com/focus-creative-games/leanclr)

## 特性

- 近乎完整实现了[ECMA-335规范](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/)，只有极少量的[不支持的特性](https://www.hybridclr.cn/docs/basic/notsupportedfeatures)。
- 零学习和使用成本。对绝大多数开发者来说写代码近乎没有限制。 热更新代码与AOT代码无缝工作，可以随意写继承、**泛型**、**反射**之类的代码。不需要额外写任何特殊代码、没有代码生成
- 完全支持多线程，包含但不限于 volatile、ThreadStatic、async Task等相关功能和特性。这是其他所有热更新方案都不支持的
- 几乎完全兼容Unity的工作流。包括且不限于支持热更新**MonoBehaviour**、ScriptableObject、**DOTS**技术，资源上挂载的热更新脚本可以正确实例化，这是其他所有热更新方案都不支持的
- 执行高效。实现了一个极其高效的寄存器解释器，所有指标都大幅优于其他热更新方案。[性能测试报告](https://www.hybridclr.cn/docs/basic/performance)
- 内存高效。 热更新脚本中定义的类跟普通c#类占用一样的内存空间，远优于其他热更新方案。[内存占用报告](https://www.hybridclr.cn/docs/basic/memory)
- 支持MonoPInvokeCallback，可以与native代码或者其他语言如lua、javascript、python良好交互
- 支持一些il2cpp不支持的特性，如__makeref、 __reftype、__refvalue指令
- 支持独创的 **Differential Hybrid Execution(DHE)** 差分混合执行技术，即可以对AOT dll任意增删改，会智能地让未改动的函数以AOT方式运行，变化或者新增的函数以interpreter模式运行，让热更新的游戏逻辑的运行性能基本达到原生AOT的水平
- 支持 **热重载** 技术，可以100%卸载程序集
- 支持 **热修复** 技术，不需要重启游戏即可无感修复bug
- 支持现代的dll加密技术，有效保障代码安全

## 支持的版本与平台

- 支持2019.4.x、2020.3.x、2021.3.x、2022.3.x、2023.2.x、6000.x.y全系列LTS版本
- 支持所有il2cpp支持的平台
- 支持团结引擎和鸿蒙平台

## 工作原理

HybridCLR从mono的 [mixed mode execution](https://www.mono-project.com/news/2017/11/13/mono-interpreter/) 技术中得到启发，为unity的il2cpp之类的AOT runtime额外提供了interpreter模块，将它们由纯AOT运行时改造为"AOT + Interpreter"混合运行方式。

![icon](docs/images/architecture.png)

更具体地说，HybridCLR做了以下几点工作：

- 实现了一个高效的元数据(dll)解析库
- 改造了元数据管理模块，实现了元数据的动态注册
- 实现了一个IL指令集到自定义的寄存器指令集的compiler
- 实现了一个高效的寄存器解释器
- 额外提供大量的instinct函数，提升解释器性能

## 稳定性状况

HybridCLR已经被广泛验证是非常高效、稳定的Unity热更新解决方案，良好满足大中型商业项目的稳定和性能要求。

目前已经有数千个商业游戏项目接入了HybridCLR，其中有超过千个已经在App Store和Google Player上线，仅仅iOS免费榜前500名中就有近百款使用了HybridCLR。上线的项目中包括MMORPG、重度卡牌、重度塔防之类的游戏。国内绝大多数**Top游戏公司**都已经在使用HybridCLR。

可查看我们已知的头部公司中使用HybridCLR并且已经上线的[项目列表](https://www.hybridclr.cn/docs/other/businesscase)。

## 支持与联系

- 官方1群（3000人）：651188171（满）
- 新手1群（3000人）：428404198（满）
- 新手2群（2000人）：680274677（满）
- 新手3群（2000人）：**920714552（推荐）**
- discord频道：<https://discord.gg/BATfNfJnm2>
- 商业合作邮箱： business#code-philosophy.com
- [商业化支持](https://www.hybridclr.cn/docs/business/intro)

## 相关项目 LeanCLR

hybridclr仅是一个解释器模块，如果你需要一个完整小巧的适合发布到移动和小游戏平台的开源CLR实现，[LeanCLR](https://github.com/focus-creative-games/leanclr) 是当前最合适的方案。

LeanCLR 是一个面向全平台的精益 CLR（Common Language Runtime）实现。LeanCLR 在高度符合 ECMA-335 规范的前提下，提供更紧凑、易嵌入、低内存占用的运行时，实现对移动端、H5 与小游戏等资源受限平台的友好支持。LeanCLR原生支持 AOT + Interpreter 混合执行模式，内置 IL 与 IR 双解释器。

LeanCLR既可以独立嵌入到任何app和游戏项目，发布到任何平台，也可以**替代il2cpp作为Unity（团结引擎）发布到webgl和小游戏平台的运行时**。大幅缩减包体和内存开销。

## 关于作者

**walon** ：**Code Philosophy（代码哲学）** 创始人

毕业于清华大学物理系，2006年CMO金牌，奥数国家集训队成员，保送清华基科班。专注于游戏技术，擅长开发架构和基础技术设施。

## license

HybridCLR is licensed under the [MIT](https://github.com/focus-creative-games/hybridclr/blob/main/LICENSE) license

```

`README_EN.md`:

```md
- [README Chinese](./README.md)
- [README English](./README_EN.md)

# HybridCLR

[![license](http://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/focus-creative-games/hybridclr/blob/main/LICENSE)

![logo](./docs/images/logo.jpg)

<br/>
<br/>

HybridCLR is a **feature-complete, zero-cost, high-performance, low-memory** and **nearly perfect** native C# hot update solution for Unity across all platforms.

HybridCLR extends the il2cpp runtime, transforming it from a pure [AOT](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) runtime into a hybrid AOT+Interpreter runtime, natively supporting dynamic assembly loading and fundamentally enabling hot updates. Games using HybridCLR technology can run efficiently not only on Android but also on iOS, consoles, WebGL, and all platforms supported by il2cpp.

Thanks to HybridCLR's strong support for the ECMA-335 specification and high compatibility with Unity's development workflow, Unity projects can seamlessly gain C# hot update capabilities after integration, without developers needing to change their daily habits or requirements. HybridCLR is the first to reduce the engineering difficulty of full-platform code hot updates for Unity to nearly zero.

Embrace modern native C# hot update technology!

## Documentation

- [Official Documentation](https://www.hybridclr.cn/docs/intro)
- [Quick Start](https://www.hybridclr.cn/docs/beginner/quickstart)
- [Commercial Project Cases](https://www.hybridclr.cn/docs/other/businesscase)
- [LeanCLR](https://github.com/focus-creative-games/leanclr)

## Features

- Nearly complete implementation of the [ECMA-335 specification](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), with only a few [unsupported features](https://www.hybridclr.cn/docs/basic/notsupportedfeatures).
- Zero learning and usage cost. For most developers, there are almost no coding restrictions. Hot update code and AOT code work seamlessly; you can freely use inheritance, **generics**, **reflection**, etc. No need for special code or code generation.
- Full multi-threading support, including but not limited to volatile, ThreadStatic, async Task, and related features. This is not supported by any other hot update solution.

- Almost fully compatible with Unity's workflow, including support for hot update **MonoBehaviour**, ScriptableObject, **DOTS** technology, and correct instantiation of hot update scripts attached to resources. This is not supported by any other hot update solution.
- Efficient execution. Features an extremely efficient register interpreter, outperforming other hot update solutions in all metrics. [Performance Test Report](https://www.hybridclr.cn/docs/basic/performance)
- Memory efficient. Classes defined in hot update scripts occupy the same memory as regular C# classes, far superior to other hot update solutions. [Memory Usage Report](https://www.hybridclr.cn/docs/basic/memory)

- Supports MonoPInvokeCallback for good interaction with native code or other languages like lua, javascript, python.
- Supports some features not supported by il2cpp, such as __makeref, __reftype, __refvalue instructions.
- Supports the original **Differential Hybrid Execution (DHE)** technology, allowing arbitrary addition, deletion, and modification of AOT dlls. Unchanged functions run in AOT mode, changed or new functions run in interpreter mode, making hot update game logic performance nearly native AOT level.

- Supports **hot reload** technology, allowing 100% assembly unloading.
- Supports **hotfix** technology, enabling bug fixes without restarting the game.
- Supports modern dll encryption technology for effective code security.

## Supported Versions and Platforms

- Supports all LTS versions: 2019.4.x, 2020.3.x, 2021.3.x, 2022.3.x, 2023.2.x, 6000.x.y
- Supports all platforms supported by il2cpp
- Supports Unity Engine and HarmonyOS platforms

## How It Works

HybridCLR is inspired by mono's [mixed mode execution](https://www.mono-project.com/news/2017/11/13/mono-interpreter/) technology, providing an interpreter module for Unity's il2cpp and similar AOT runtimes, transforming them from pure AOT runtimes to "AOT + Interpreter" hybrid execution.

## Stability

HybridCLR has been widely validated as a highly efficient and stable Unity hot update solution, meeting the stability and performance requirements of medium and large commercial projects.

Thousands of commercial game projects have integrated HybridCLR, with over a thousand already launched on the App Store and Google Play. Nearly a hundred games in the top 500 free iOS chart use HybridCLR. Released projects include MMORPGs, heavy card games, tower defense, and more. Most top game companies in China are already using HybridCLR.

See our known list of top companies using HybridCLR and already launched [project list](https://www.hybridclr.cn/docs/other/businesscase).

## Support & Contact

- Official Group 1 (3000 members): 651188171 (full)
- Newbie Group 1 (3000 members): 428404198 (full)
- Newbie Group 2 (2000 members): 680274677 (full)
- Newbie Group 3 (2000 members): **920714552 (recommended)**
- Discord channel: <https://discord.gg/BATfNfJnm2>
- Business cooperation email: business#code-philosophy.com
- [Commercial Support](https://www.hybridclr.cn/docs/business/intro)

## LeanCLR Project

HybridCLR is just an interpreter module. If you need a complete, compact, open-source CLR implementation suitable for mobile and mini-game platforms, [LeanCLR](https://github.com/focus-creative-games/leanclr) is currently the best solution.

LeanCLR can be embedded independently into any app or game project and published to any platform. It can also **replace il2cpp as the runtime for Unity (Unity Engine) when publishing to webgl and mini-game platforms**, greatly reducing package size and memory usage.

## About the Author

**walon**: Founder of **Code Philosophy**

Graduated from Tsinghua University, Department of Physics. 2006 CMO gold medalist, member of the national math olympiad training team, admitted to Tsinghua's basic science class. Focused on game technology, skilled in development architecture and core technical infrastructure.

## License

HybridCLR is licensed under the [MIT](https://github.com/focus-creative-games/hybridclr/blob/main/LICENSE) license

- [README Chinese](./README.md)
- [README English](./README_EN.md)
```

`docs/_config.yml`:

```yml
theme: jekyll-theme-slate
```

`hybridclr/CommonDef.cpp`:

```cpp
#include <iostream>

#include "CommonDef.h"


namespace hybridclr
{
    void LogPanic(const char* errMsg)
    {
        std::cerr << "panic:" << std::endl;
        std::cerr << "\t" << errMsg << std::endl;
        exit(1);
    }

    const char* GetAssemblyNameFromPath(const char* assPath)
    {
        const char* last = nullptr;
        for (const char* p = assPath; *p; p++)
        {
            if (*p == '/' || *p == '\\')
            {
                last = p + 1;
            }
        }
        return last ? last : assPath;
    }

    const char* CopyString(const char* src)
    {
        size_t len = std::strlen(src);
        char* dst = (char*)HYBRIDCLR_MALLOC(len + 1);
        std::strcpy(dst, src);
        return dst;
    }

    const char* ConcatNewString(const char* s1, const char* s2)
    {
        size_t len1 = std::strlen(s1);
        size_t len = len1 + std::strlen(s2);
        char* dst = (char*)HYBRIDCLR_MALLOC(len + 1);
        std::strcpy(dst, s1);
        strcpy(dst + len1, s2);
        return dst;
    }

    void* CopyBytes(const void* src, size_t length)
    {
        void* dst = HYBRIDCLR_MALLOC(length);
        std::memcpy(dst, src, length);
        return dst;
    }
}





```

`hybridclr/CommonDef.h`:

```h
#pragma once

#include <stdint.h>
#include <cstring>
#include <memory>

#include "Il2CppCompatibleDef.h"

#include "utils/Memory.h"
#include "utils/StringView.h"
#include "utils/Il2CppHashSet.h"
#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"
#include "vm/GlobalMetadataFileInternals.h"
#include "vm/Exception.h"
#include "vm/Class.h"
#include "icalls/mscorlib/System/Type.h"
#ifdef HYBRIDCLR_UNITY_2021_OR_NEW
#include "icalls/mscorlib/System/RuntimeType.h"
#else
#include "icalls/mscorlib/System/MonoType.h"
#endif

namespace hybridclr
{
    typedef uint8_t byte;

#define TEMP_FORMAT(var, fmt, ...) char var[600]; \
	snprintf(var, sizeof(var), fmt, __VA_ARGS__);

    void LogPanic(const char* errMsg);

    const char* GetAssemblyNameFromPath(const char* assPath);

    const char* CopyString(const char* src);

    const char* ConcatNewString(const char* s1, const char* s2);

	void* CopyBytes(const void* src, size_t length);

	struct CStringHash
	{
		size_t operator()(const char* s) const noexcept
		{
			uint32_t hash = 0;

			for (; *s; ++s)
			{
				hash += *s;
				hash += (hash << 10);
				hash ^= (hash >> 6);
			}

			hash += (hash << 3);
			hash ^= (hash >> 11);
			hash += (hash << 15);

			return hash;
		}
	};

	struct CStringEqualTo
	{
		bool operator()(const char* _Left, const char* _Right) const
		{
			return std::strcmp(_Left, _Right) == 0;
		}
	};

	inline il2cpp::utils::StringView<char> CStringToStringView(const char* str)
	{
		return il2cpp::utils::StringView<char>(str, std::strlen(str));
	}

	inline std::string GetKlassCStringFullName(const Il2CppType* type)
	{
		return GetKlassFullName2(type);
	}

	inline void RaiseNotSupportedException(const char* msg)
	{
		TEMP_FORMAT(errMsg, "hybridclr doesn't support %s", msg);
		return il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetNotSupportedException(errMsg));
	}

	inline void RaiseExecutionEngineException(const char* msg)
	{
		return il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(msg));
	}

	inline void RaiseMethodNotFindException(const Il2CppType* type, const char* methodName)
	{
		if (!type)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException("type not exists"));
		}

		std::string fullName = GetKlassCStringFullName(type);
		TEMP_FORMAT(errMsg, "MethodNotFind %s::%s", fullName.c_str(), methodName);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetMissingMethodException(errMsg));
	}

	inline void AppendTypeName(std::string& s, const Il2CppType* type)
	{
		s.append(GetKlassCStringFullName(type));
	}

	inline std::string GetMethodNameWithSignature(const MethodInfo* method)
	{
		std::string name;
		AppendTypeName(name, method->return_type);
		name.append(" ");
		
		name.append(GetKlassCStringFullName(&method->klass->byval_arg));
		name.append("::");
		name.append(method->name);
		if (method->genericMethod && method->genericMethod->context.method_inst)
		{
			name.append("<");
			const Il2CppGenericInst* gi= method->genericMethod->context.method_inst;
			for (uint32_t i = 0; i < gi->type_argc; i++)
			{
				if (i > 0)
				{
					name.append(",");
				}
				AppendTypeName(name, gi->type_argv[i]);
			}
			name.append(">");
		}
		name.append("(");
		for (uint8_t i = 0; i < method->parameters_count; i++)
		{
			if (i > 0)
			{
				name.append(",");
			}
			AppendTypeName(name, GET_METHOD_PARAMETER_TYPE(method->parameters[i]));
		}
		name.append(")");
		return name;
	}

	inline void RaiseAOTGenericMethodNotInstantiatedException(const MethodInfo* method)
	{
		std::string methodName = GetMethodNameWithSignature(method);
		TEMP_FORMAT(errMsg, "AOT generic method not instantiated in aot. assembly:%s, method:%s", method->klass->image->name, methodName.c_str());
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetMissingMethodException(errMsg));
	}

	inline void RaiseMissingFieldException(const Il2CppType* type, const char* fieldName)
	{
		if (!type)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException("type not exists"));
		}
		std::string stdFullName = GetKlassCStringFullName(type);
		TEMP_FORMAT(errMsg, "field %s::%s not exists", stdFullName.c_str(), fieldName);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetMissingFieldException(errMsg));
	}

}



```

`hybridclr/Il2CppCompatibleDef.cpp`:

```cpp
#include "Il2CppCompatibleDef.h"

#include "vm/Runtime.h"

#include "metadata/MetadataModule.h"
#include "interpreter/InterpreterModule.h"


namespace hybridclr
{
	Il2CppMethodPointer InitAndGetInterpreterDirectlyCallMethodPointerSlow(MethodInfo* method)
	{
		IL2CPP_ASSERT(!method->initInterpCallMethodPointer);
		method->initInterpCallMethodPointer = true;
		bool isAdjustorThunkMethod = IS_CLASS_VALUE_TYPE(method->klass) && hybridclr::metadata::IsInstanceMethod(method);
		if (hybridclr::metadata::MetadataModule::IsImplementedByInterpreter(method))
		{
			method->methodPointerCallByInterp = interpreter::InterpreterModule::GetMethodPointer(method);
			if (isAdjustorThunkMethod)
			{
				method->virtualMethodPointerCallByInterp = interpreter::InterpreterModule::GetAdjustThunkMethodPointer(method);
			}
			else
			{
				method->virtualMethodPointerCallByInterp = method->methodPointerCallByInterp;
			}
			if (method->invoker_method == nullptr
#if HYBRIDCLR_UNITY_2021_OR_NEW
				|| method->invoker_method == il2cpp::vm::Runtime::GetMissingMethodInvoker()
				|| method->has_full_generic_sharing_signature
#endif
				)
			{
				method->invoker_method = hybridclr::interpreter::InterpreterModule::GetMethodInvoker(method);
			}
#if HYBRIDCLR_UNITY_2021_OR_NEW
			if (method->methodPointer == nullptr || method->has_full_generic_sharing_signature)
			{
				method->methodPointer = method->methodPointerCallByInterp;
			}
			if (method->virtualMethodPointer == nullptr || method->has_full_generic_sharing_signature)
			{
				method->virtualMethodPointer = method->virtualMethodPointerCallByInterp;
			}
#else
			if (method->methodPointer == nullptr)
			{
				method->methodPointer = method->virtualMethodPointerCallByInterp;
			}
#endif
			method->isInterpterImpl = true;
		}
		return method->methodPointerCallByInterp;
	}
}
```

`hybridclr/Il2CppCompatibleDef.h`:

```h
#pragma once

#include "il2cpp-config.h"
#include "codegen/il2cpp-codegen-metadata.h"
#include "il2cpp-class-internals.h"

#include "vm/Array.h"
#include "vm/Type.h"
#include "vm/Runtime.h"
#include "vm/GlobalMetadataFileInternals.h"
#include "vm/MetadataAlloc.h"
#include "icalls/mscorlib/System/Type.h"
#include "gc/GarbageCollector.h"

#if HYBRIDCLR_UNITY_2020
#include "icalls/mscorlib/System/MonoType.h"
#elif HYBRIDCLR_UNITY_2021_OR_NEW
#include "icalls/mscorlib/System/RuntimeType.h"
#include "icalls/mscorlib/System/RuntimeTypeHandle.h"
#elif HYBRIDCLR_UNITY_2019
#include "icalls/mscorlib/System/MonoType.h"
#if IL2CPP_SIZEOF_VOID_P == 8
#define PLATFORM_ARCH_64 1
#else
#define PLATFORM_ARCH_64 0
#endif
#elif !defined(HYBRIDCLR_UNITY_VERSION)
#error "please run 'HybridCLR/Generate/All' before building"
#else
#error "unsupported unity version"
#endif

#if IL2CPP_BYTE_ORDER != IL2CPP_LITTLE_ENDIAN
#error "only support litten endian"
#endif

#if	PLATFORM_ARCH_64
#define HYBRIDCLR_ARCH_64 1
#else
#define HYBRIDCLR_ARCH_64 0
#endif

#define PTR_SIZE IL2CPP_SIZEOF_VOID_P

#if HYBRIDCLR_ARCH_64 || HYBRIDCLR_TARGET_X86
#define SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS  1
#else
#define SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS  0
#endif

#ifndef ENABLE_PLACEHOLDER_DLL
#define ENABLE_PLACEHOLDER_DLL 1
#endif

#if IL2CPP_ENABLE_WRITE_BARRIERS
#define HYBRIDCLR_ENABLE_WRITE_BARRIERS 1
#else
#define HYBRIDCLR_ENABLE_WRITE_BARRIERS 0
#endif

#ifndef HYBRIDCLR_ENABLE_PROFILER
#define HYBRIDCLR_ENABLE_PROFILER  IL2CPP_ENABLE_PROFILER
#endif

#ifndef HYBRIDCLR_ENABLE_STRACKTRACE
#define HYBRIDCLR_ENABLE_STRACKTRACE IL2CPP_ENABLE_STACKTRACE_SENTRIES
#endif

#if UNITY_ENGINE_TUANJIE
#define HYBRIDCLR_MALLOC(size) IL2CPP_MALLOC(size, IL2CPP_MEM_META_POOL)
#define HYBRIDCLR_MALLOC_ALIGNED(size, alignment) IL2CPP_MALLOC_ALIGNED(size, alignment, IL2CPP_MEM_META_POOL)
#define HYBRIDCLR_MALLOC_ZERO(size) IL2CPP_MALLOC_ZERO(size, IL2CPP_MEM_META_POOL)
#define HYBRIDCLR_CALLOC(count, size) IL2CPP_CALLOC(count, size, IL2CPP_MEM_META_POOL)
#define HYBRIDCLR_FREE(ptr) IL2CPP_FREE(ptr, IL2CPP_MEM_META_POOL)
#define HYBRIDCLR_FREE_ALIGNED(ptr) IL2CPP_FREE_ALIGNED(ptr, IL2CPP_MEM_META_POOL)
#define HYBRIDCLR_METADATA_MALLOC(size) il2cpp::vm::MetadataMalloc(size, IL2CPP_MSTAT_TYPE)
#define HYBRIDCLR_METADATA_CALLOC(count, size) il2cpp::vm::MetadataCalloc(count, size, IL2CPP_MSTAT_TYPE)
#else
#define HYBRIDCLR_MALLOC(size) IL2CPP_MALLOC(size)
#define HYBRIDCLR_MALLOC_ALIGNED(size, alignment) IL2CPP_MALLOC_ALIGNED(size, alignment)
#define HYBRIDCLR_MALLOC_ZERO(size) IL2CPP_MALLOC_ZERO(size)
#define HYBRIDCLR_CALLOC(count, size) IL2CPP_CALLOC(count, size)
#define HYBRIDCLR_FREE(ptr) IL2CPP_FREE(ptr)
#define HYBRIDCLR_FREE_ALIGNED(ptr) IL2CPP_FREE_ALIGNED(ptr)
#define HYBRIDCLR_METADATA_MALLOC(size) il2cpp::vm::MetadataMalloc(size)
#define HYBRIDCLR_METADATA_CALLOC(count, size) il2cpp::vm::MetadataCalloc(count, size)
#endif


namespace hybridclr
{

	extern const char* g_placeHolderAssemblies[];

	Il2CppMethodPointer InitAndGetInterpreterDirectlyCallMethodPointerSlow(MethodInfo* method);

	inline Il2CppMethodPointer InitAndGetInterpreterDirectlyCallMethodPointer(const MethodInfo* method)
	{
		Il2CppMethodPointer methodPointer = method->methodPointerCallByInterp;
		if (methodPointer)
		{
			return methodPointer;
		}
		if (method->initInterpCallMethodPointer)
		{
			return methodPointer;
		}
		return InitAndGetInterpreterDirectlyCallMethodPointerSlow(const_cast<MethodInfo*>(method));
	}

	inline Il2CppMethodPointer InitAndGetInterpreterDirectlyCallVirtualMethodPointer(const MethodInfo* method)
	{
		Il2CppMethodPointer methodPointer = method->virtualMethodPointerCallByInterp;
		if (methodPointer)
		{
			return methodPointer;
		}
		if (method->initInterpCallMethodPointer)
		{
			return methodPointer;
		}
		InitAndGetInterpreterDirectlyCallMethodPointerSlow(const_cast<MethodInfo*>(method));
		return method->virtualMethodPointerCallByInterp;
	}

	inline void HYBRIDCLR_SET_WRITE_BARRIER(void** ptr)
	{
#if HYBRIDCLR_ENABLE_WRITE_BARRIERS
		il2cpp::gc::GarbageCollector::SetWriteBarrier(ptr);
#endif
	}

	inline void HYBRIDCLR_SET_WRITE_BARRIER(void** ptr, size_t size)
	{
#if HYBRIDCLR_ENABLE_WRITE_BARRIERS
		il2cpp::gc::GarbageCollector::SetWriteBarrier(ptr, size);
#endif
	}
}

#if HYBRIDCLR_UNITY_2019 || HYBRIDCLR_UNITY_2020

inline bool IS_CLASS_VALUE_TYPE(const Il2CppClass* klass)
{
	return klass->valuetype;
}

inline bool IS_CCTOR_FINISH_OR_NO_CCTOR(const Il2CppClass* klass)
{
	return (klass->cctor_finished) || !(klass->has_cctor);
}

inline const Il2CppType* GET_METHOD_PARAMETER_TYPE(const ParameterInfo& param)
{
	return param.parameter_type;
}

inline uint32_t GET_CUSTOM_ATTRIBUTE_TYPE_RANGE_START(const Il2CppCustomAttributeTypeRange& tr)
{
	return tr.start;
}

inline void SET_IL2CPPTYPE_VALUE_TYPE(Il2CppType& type, bool v)
{

}

inline void COPY_IL2CPPTYPE_VALUE_TYPE_FLAG(Il2CppType& dst, const Il2CppType& src)
{

}

#define GET_ARRAY_ELEMENT_ADDRESS load_array_elema
#define VALUE_TYPE_METHOD_POINTER_IS_ADJUST_METHOD 1

namespace hybridclr
{
	inline Il2CppReflectionType* GetReflectionTypeFromName(Il2CppString* name)
	{
		return il2cpp::icalls::mscorlib::System::Type::internal_from_name(name, true, false);
	}

	inline void ConstructDelegate(Il2CppDelegate* delegate, Il2CppObject* target, const MethodInfo* method)
	{
		delegate->method_ptr = InitAndGetInterpreterDirectlyCallVirtualMethodPointer(method);
		delegate->method = method;
		delegate->target = target;
#if HYBRIDCLR_ENABLE_WRITE_BARRIERS
		if (target)
		{
			HYBRIDCLR_SET_WRITE_BARRIER((void**)&delegate->target);
		}
#endif
		//il2cpp::vm::Type::ConstructDelegate(delegate, target, InitAndGetInterpreterDirectlyCallMethodPointer(method), method);
	}

	inline const MethodInfo* GetGenericVirtualMethod(const MethodInfo* result, const MethodInfo* inflateMethod)
	{
		return il2cpp::vm::Runtime::GetGenericVirtualMethod(result, inflateMethod);
	}

	inline void* GetNulllableDataOffset(void* nullableObj, Il2CppClass* nullableClass)
	{
		uint32_t field_offset = nullableClass->fields[0].offset - sizeof(Il2CppObject); // offset of value field
		return (uint8_t*)nullableObj + field_offset;
	}

	inline uint8_t* GetNulllableHasValueOffset(void* nullableObj, Il2CppClass* nullableClass)
	{
		uint32_t field_offset = nullableClass->fields[1].offset - sizeof(Il2CppObject); // offset of has_value field
		return (uint8_t*)nullableObj + field_offset;
	}

	inline Il2CppString* GetKlassFullName(const Il2CppType* type)
	{
		Il2CppReflectionType* refType = il2cpp::icalls::mscorlib::System::Type::internal_from_handle((intptr_t)type);
		return il2cpp::icalls::mscorlib::System::MonoType::getFullName(refType, false, false);
	}

	inline std::string GetKlassFullName2(const Il2CppType* type)
	{
		Il2CppReflectionType* refType = il2cpp::icalls::mscorlib::System::Type::internal_from_handle((intptr_t)type);
		return il2cpp::icalls::mscorlib::System::MonoType::getFullName2(refType, false, false);
	}
}
#elif HYBRIDCLR_UNITY_2021_OR_NEW

inline bool IS_CLASS_VALUE_TYPE(const Il2CppClass* klass)
{
	return klass->byval_arg.valuetype;
}

inline bool IS_CCTOR_FINISH_OR_NO_CCTOR(const Il2CppClass* klass)
{
	return klass->cctor_finished_or_no_cctor;
}

inline const Il2CppType* GET_METHOD_PARAMETER_TYPE(const Il2CppType* param)
{
	return param;
}

inline uint32_t GET_CUSTOM_ATTRIBUTE_TYPE_RANGE_START(const Il2CppCustomAttributeTypeRange& tr)
{
	return tr.startOffset;
}

inline void SET_IL2CPPTYPE_VALUE_TYPE(Il2CppType& type, bool v)
{
	type.valuetype = v;
}

inline void COPY_IL2CPPTYPE_VALUE_TYPE_FLAG(Il2CppType& dst, const Il2CppType& src)
{
	dst.valuetype = src.valuetype;
}

#define GET_ARRAY_ELEMENT_ADDRESS il2cpp_array_addr_with_size
#define VALUE_TYPE_METHOD_POINTER_IS_ADJUST_METHOD 0

namespace hybridclr
{

	inline Il2CppReflectionType* GetReflectionTypeFromName(Il2CppString* name)
	{
		return il2cpp::icalls::mscorlib::System::RuntimeTypeHandle::internal_from_name(name, nullptr, nullptr, true, false, false);
	}

	inline void ConstructDelegate(Il2CppDelegate* delegate, Il2CppObject* target, const MethodInfo* method)
	{
		delegate->target = target;
		delegate->method = method;
		delegate->invoke_impl = InitAndGetInterpreterDirectlyCallVirtualMethodPointer(method);
		delegate->invoke_impl_this = target;
#if HYBRIDCLR_ENABLE_WRITE_BARRIERS
		if (target)
		{
			HYBRIDCLR_SET_WRITE_BARRIER((void**)&delegate->target);
			HYBRIDCLR_SET_WRITE_BARRIER((void**)&delegate->invoke_impl_this);
		}
#endif
	}

	inline const MethodInfo* GetGenericVirtualMethod(const MethodInfo* result, const MethodInfo* inflateMethod)
	{
#if HYBRIDCLR_UNITY_2021
		VirtualInvokeData vid;
		il2cpp::vm::Runtime::GetGenericVirtualMethod(result, inflateMethod, &vid);
		return vid.method;
#else
		return il2cpp::metadata::GenericMethod::GetGenericVirtualMethod(result, inflateMethod);
#endif
	}

	inline void* GetNulllableDataOffset(void* nullableObj, Il2CppClass* nullableClass)
	{
		uint32_t field_offset = nullableClass->fields[1].offset - sizeof(Il2CppObject); // offset of value field
		return (uint8_t*)nullableObj + field_offset;
	}

	inline uint8_t* GetNulllableHasValueOffset(void* nullableObj, Il2CppClass* nullableClass)
	{
		uint32_t field_offset = nullableClass->fields[0].offset - sizeof(Il2CppObject); // offset of has_value field
		return (uint8_t*)nullableObj + field_offset;
	}

	inline Il2CppString* GetKlassFullName(const Il2CppType* type)
	{
		Il2CppReflectionType* refType = il2cpp::icalls::mscorlib::System::Type::internal_from_handle((intptr_t)type);
		return il2cpp::icalls::mscorlib::System::RuntimeType::getFullName((Il2CppReflectionRuntimeType*)refType, false, false);
	}

	inline std::string GetKlassFullName2(const Il2CppType* type)
	{
		Il2CppReflectionType* refType = il2cpp::icalls::mscorlib::System::Type::internal_from_handle((intptr_t)type);
		return il2cpp::icalls::mscorlib::System::RuntimeType::getFullName2((Il2CppReflectionRuntimeType*)refType, false, false);
	}

}
#endif
```

`hybridclr/Runtime.cpp`:

```cpp
#include "Runtime.h"

#include "vm/Exception.h"
#include "vm/String.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "icalls/mscorlib/System.Reflection/Assembly.h"

#include "RuntimeApi.h"
#include "interpreter/InterpreterModule.h"
#include "metadata/MetadataModule.h"
#include "transform/TransformModule.h"


namespace hybridclr
{

	void Runtime::Initialize()
	{
		RuntimeApi::RegisterInternalCalls();
		metadata::MetadataModule::Initialize();
		interpreter::InterpreterModule::Initialize();
		transform::TransformModule::Initialize();
	}
}
```

`hybridclr/Runtime.h`:

```h
#pragma once

#include "CommonDef.h"

namespace hybridclr
{

	class Runtime
	{
	public:
		static void Initialize();
	};
}
```

`hybridclr/RuntimeApi.cpp`:

```cpp
#include "RuntimeApi.h"

#include "codegen/il2cpp-codegen.h"
#include "vm/InternalCalls.h"
#include "vm/Array.h"
#include "vm/Exception.h"
#include "vm/Class.h"

#include "metadata/MetadataModule.h"
#include "metadata/MetadataUtil.h"
#include "interpreter/InterpreterModule.h"
#include "RuntimeConfig.h"

namespace hybridclr
{
	void RuntimeApi::RegisterInternalCalls()
	{
		il2cpp::vm::InternalCalls::Add("HybridCLR.RuntimeApi::LoadMetadataForAOTAssembly(System.Byte[],HybridCLR.HomologousImageMode)", (Il2CppMethodPointer)LoadMetadataForAOTAssembly);
		il2cpp::vm::InternalCalls::Add("HybridCLR.RuntimeApi::GetRuntimeOption(HybridCLR.RuntimeOptionId)", (Il2CppMethodPointer)GetRuntimeOption);
		il2cpp::vm::InternalCalls::Add("HybridCLR.RuntimeApi::SetRuntimeOption(HybridCLR.RuntimeOptionId,System.Int32)", (Il2CppMethodPointer)SetRuntimeOption);
		il2cpp::vm::InternalCalls::Add("HybridCLR.RuntimeApi::PreJitClass(System.Type)", (Il2CppMethodPointer)PreJitClass);
		il2cpp::vm::InternalCalls::Add("HybridCLR.RuntimeApi::PreJitMethod(System.Reflection.MethodInfo)", (Il2CppMethodPointer)PreJitMethod);
	}

	int32_t RuntimeApi::LoadMetadataForAOTAssembly(Il2CppArray* dllBytes, int32_t mode)
	{
		if (!dllBytes)
		{
			il2cpp::vm::Exception::RaiseNullReferenceException();
		}
		return (int32_t)hybridclr::metadata::Assembly::LoadMetadataForAOTAssembly(il2cpp::vm::Array::GetFirstElementAddress(dllBytes), il2cpp::vm::Array::GetByteLength(dllBytes), (hybridclr::metadata::HomologousImageMode)mode);
	}

	int32_t RuntimeApi::GetRuntimeOption(int32_t optionId)
	{
		return hybridclr::RuntimeConfig::GetRuntimeOption((hybridclr::RuntimeOptionId)optionId);
	}

	void RuntimeApi::SetRuntimeOption(int32_t optionId, int32_t value)
	{
		hybridclr::RuntimeConfig::SetRuntimeOption((hybridclr::RuntimeOptionId)optionId, value);
	}

	int32_t PreJitMethod0(const MethodInfo* methodInfo);

	int32_t RuntimeApi::PreJitClass(Il2CppReflectionType* type)
	{
		if (metadata::HasNotInstantiatedGenericType(type->type))
		{
			return false;
		}
		Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type->type, false);
		if (!klass)
		{
			return false;
		}
		metadata::Image* image = metadata::MetadataModule::GetImage(klass->image);
		if (!image)
		{
			image = (metadata::Image*)hybridclr::metadata::AOTHomologousImage::FindImageByAssembly(
				klass->rank ? il2cpp_defaults.corlib->assembly : klass->image->assembly);
			if (!image)
			{
				return false;
			}
		}
		for (uint16_t i = 0; i < klass->method_count; i++)
		{
			const MethodInfo* methodInfo = klass->methods[i];
			PreJitMethod0(methodInfo);
		}
		return true;
	}

	int32_t PreJitMethod0(const MethodInfo* methodInfo)
	{
		if (!methodInfo->isInterpterImpl)
		{
			return false;
		}
		if (methodInfo->klass->is_generic)
		{
			return false;
		}
		if (!methodInfo->is_inflated)
		{
			if (methodInfo->is_generic)
			{
				return false;
			}
		}
		else
		{
			const Il2CppGenericMethod* genericMethod = methodInfo->genericMethod;
			if (metadata::HasNotInstantiatedGenericType(genericMethod->context.class_inst) || metadata::HasNotInstantiatedGenericType(genericMethod->context.method_inst))
			{
				return false;
			}
		}

		return interpreter::InterpreterModule::GetInterpMethodInfo(methodInfo) != nullptr;
	}

	int32_t RuntimeApi::PreJitMethod(Il2CppReflectionMethod* method)
	{
		return PreJitMethod0(method->method);
	}
}

```

`hybridclr/RuntimeApi.h`:

```h
#pragma once

#include <stdint.h>
#include "CommonDef.h"

namespace hybridclr
{
	class RuntimeApi
	{
	public:
		static void RegisterInternalCalls();

		static int32_t LoadMetadataForAOTAssembly(Il2CppArray* dllData, int32_t mode);

		static int32_t GetRuntimeOption(int32_t optionId);
		static void SetRuntimeOption(int32_t optionId, int32_t value);

		static int32_t PreJitClass(Il2CppReflectionType* type);
		static int32_t PreJitMethod(Il2CppReflectionMethod* method);
	};
}
```

`hybridclr/RuntimeConfig.cpp`:

```cpp
#include "RuntimeConfig.h"

#include "vm/Exception.h"

namespace hybridclr
{
	static int32_t s_threadObjectStackSize = 1024 * 128;
	static int32_t s_threadFrameStackSize = 1024 * 2;
	static int32_t s_threadExceptionFlowSize = 512;
	static int32_t s_maxMethodBodyCacheSize = 1024;
	static int32_t s_maxMethodInlineDepth = 3;
	static int32_t s_maxInlineableMethodBodySize = 32;



	int32_t RuntimeConfig::GetRuntimeOption(RuntimeOptionId optionId)
	{
		switch (optionId)
		{	
		case RuntimeOptionId::InterpreterThreadObjectStackSize:
			return s_threadObjectStackSize;
		case RuntimeOptionId::InterpreterThreadFrameStackSize:
			return s_threadFrameStackSize;
		case RuntimeOptionId::InterpreterThreadExceptionFlowSize:
			return s_threadExceptionFlowSize;
		case RuntimeOptionId::MaxMethodBodyCacheSize:
			return s_maxMethodBodyCacheSize;
		case RuntimeOptionId::MaxMethodInlineDepth:
			return s_maxMethodInlineDepth;
		case RuntimeOptionId::MaxInlineableMethodBodySize:
			return s_maxInlineableMethodBodySize;
		default:
		{
			TEMP_FORMAT(optionIdStr, "%d", optionId);
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentException(optionIdStr, "invalid runtime option id"));
			return 0;
		}
		}
	}

	void RuntimeConfig::SetRuntimeOption(RuntimeOptionId optionId, int32_t value)
	{
		switch (optionId)
		{
		case hybridclr::RuntimeOptionId::InterpreterThreadObjectStackSize:
			s_threadObjectStackSize = value;
			break;
		case hybridclr::RuntimeOptionId::InterpreterThreadFrameStackSize:
			s_threadFrameStackSize = value;
			break;
		case hybridclr::RuntimeOptionId::InterpreterThreadExceptionFlowSize:
			s_threadExceptionFlowSize = value;
			break;
		case RuntimeOptionId::MaxMethodBodyCacheSize:
			s_maxMethodBodyCacheSize = value;
			break;
		case RuntimeOptionId::MaxMethodInlineDepth:
			s_maxMethodInlineDepth = value;
			break;
		case RuntimeOptionId::MaxInlineableMethodBodySize:
			s_maxInlineableMethodBodySize = value;
			break;
		default:
		{
			TEMP_FORMAT(optionIdStr, "%d", optionId);
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentException(optionIdStr, "invalid runtime option id"));
			break;
		}
		}
	}

	uint32_t RuntimeConfig::GetInterpreterThreadObjectStackSize()
	{
		return s_threadObjectStackSize;
	}

	uint32_t RuntimeConfig::GetInterpreterThreadFrameStackSize()
	{
		return s_threadFrameStackSize;
	}

	uint32_t RuntimeConfig::GetInterpreterThreadExceptionFlowSize()
	{
		return s_threadExceptionFlowSize;
	}

	int32_t RuntimeConfig::GetMaxMethodBodyCacheSize()
	{
		return s_maxMethodBodyCacheSize;
	}

	int32_t RuntimeConfig::GetMaxMethodInlineDepth()
	{
		return s_maxMethodInlineDepth;
	}

	int32_t RuntimeConfig::GetMaxInlineableMethodBodySize()
	{
		return s_maxInlineableMethodBodySize;
	}

}

```

`hybridclr/RuntimeConfig.h`:

```h
#pragma once

#include "CommonDef.h"

namespace hybridclr
{
	enum class RuntimeOptionId
	{
		InterpreterThreadObjectStackSize = 1,
		InterpreterThreadFrameStackSize = 2,
		InterpreterThreadExceptionFlowSize = 3,
		MaxMethodBodyCacheSize = 4,
		MaxMethodInlineDepth = 5,
		MaxInlineableMethodBodySize = 6,
	};

	class RuntimeConfig
	{

	public:

		static int32_t GetRuntimeOption(RuntimeOptionId optionId);
		static void SetRuntimeOption(RuntimeOptionId optionId, int32_t value);

		static uint32_t GetInterpreterThreadObjectStackSize();
		static uint32_t GetInterpreterThreadFrameStackSize();
		static uint32_t GetInterpreterThreadExceptionFlowSize();
		static int32_t GetMaxMethodBodyCacheSize();
		static int32_t GetMaxMethodInlineDepth();
		static int32_t GetMaxInlineableMethodBodySize();
	};
}




```

`hybridclr/generated/AssemblyManifest.cpp`:

```cpp
#include "../Il2CppCompatibleDef.h"

namespace hybridclr
{
	const char* g_placeHolderAssemblies[] =
	{
		//!!!{{PLACE_HOLDER

		//!!!}}PLACE_HOLDER
		nullptr,
	};
}

```

`hybridclr/generated/MethodBridge.cpp`:

```cpp
#include <codegen/il2cpp-codegen-metadata.h>
#if HYBRIDCLR_UNITY_2023_OR_NEW
#include <codegen/il2cpp-codegen.h>
#elif HYBRIDCLR_UNITY_2022
#include <codegen/il2cpp-codegen-il2cpp.h>
#elif HYBRIDCLR_UNITY_2020 || HYBRIDCLR_UNITY_2021
#include <codegen/il2cpp-codegen-common-big.h>
#else
#include <codegen/il2cpp-codegen-common.h>
#endif

#include "vm/ClassInlines.h"
#include "vm/Object.h"
#include "vm/Class.h"
#include "vm/ScopedThreadAttacher.h"

#include "../metadata/MetadataUtil.h"


#include "../interpreter/InterpreterModule.h"
#include "../interpreter/MethodBridge.h"
#include "../interpreter/Interpreter.h"
#include "../interpreter/MemoryUtil.h"
#include "../interpreter/InstrinctDef.h"

using namespace hybridclr::interpreter;
using namespace hybridclr::metadata;

//!!!{{CODE

const FullName2Signature hybridclr::interpreter::g_fullName2SignatureStub[] = {
	{ nullptr, nullptr},
};


const Managed2NativeMethodInfo hybridclr::interpreter::g_managed2nativeStub[] = 
{

	{nullptr, nullptr},
};


const Native2ManagedMethodInfo hybridclr::interpreter::g_native2managedStub[] = 
{
	{nullptr, nullptr},
};

const NativeAdjustThunkMethodInfo hybridclr::interpreter::g_adjustThunkStub[] = 
{
	{nullptr, nullptr},
};

const ReversePInvokeMethodData hybridclr::interpreter::g_reversePInvokeMethodStub[]
{
    {nullptr, nullptr},
};

const Managed2NativeFunctionPointerCallData hybridclr::interpreter::g_managed2NativeFunctionPointerCallStub[]
{
    {nullptr, nullptr},
};
//!!!}}CODE

```

`hybridclr/generated/UnityVersion.h`:

```h
#pragma once

//!!!{{UNITY_VERSION



//!!!}}UNITY_VERSION
```

`hybridclr/interpreter/Engine.cpp`:

```cpp
#include "Engine.h"

#include "codegen/il2cpp-codegen.h"

#include "Interpreter.h"
#include "MemoryUtil.h"
#include "../metadata/InterpreterImage.h"
#include "../metadata/MetadataModule.h"

namespace hybridclr
{
namespace interpreter
{

#if HYBRIDCLR_ENABLE_STRACKTRACE

#define PUSH_STACK_FRAME(method, rawIp) do { \
	Il2CppStackFrameInfo stackFrameInfo = { method, rawIp }; \
	il2cpp::vm::StackTrace::PushFrame(stackFrameInfo); \
} while(0)

#define POP_STACK_FRAME() do { il2cpp::vm::StackTrace::PopFrame(); } while(0)

#else 
#define PUSH_STACK_FRAME(method, rawIp)
#define POP_STACK_FRAME() 
#endif

	InterpFrame* InterpFrameGroup::EnterFrameFromInterpreter(const MethodInfo* method, StackObject* argBase)
	{
#if HYBRIDCLR_ENABLE_PROFILER
		il2cpp_codegen_profiler_method_enter(method);
#endif
		const InterpMethodInfo* imi = (const InterpMethodInfo*)method->interpData;
		int32_t oldStackTop = _machineState.GetStackTop();
		StackObject* stackBasePtr = _machineState.AllocStackSlot(imi->maxStackSize - imi->argStackObjectSize);
		InterpFrame* newFrame = _machineState.PushFrame();
		*newFrame = { method, argBase, oldStackTop, nullptr, nullptr, nullptr, 0, 0, _machineState.GetLocalPoolBottomIdx() };
		PUSH_STACK_FRAME(method, (uintptr_t)newFrame);
		return newFrame;
	}


	InterpFrame* InterpFrameGroup::EnterFrameFromNative(const MethodInfo* method, StackObject* argBase)
	{
#if HYBRIDCLR_ENABLE_PROFILER
		il2cpp_codegen_profiler_method_enter(method);
#endif
		const InterpMethodInfo* imi = (const InterpMethodInfo*)method->interpData;
		int32_t oldStackTop = _machineState.GetStackTop();
		StackObject* stackBasePtr = _machineState.AllocStackSlot(imi->maxStackSize);
		InterpFrame* newFrame = _machineState.PushFrame();
		*newFrame = { method, stackBasePtr, oldStackTop, nullptr, nullptr, nullptr, 0, 0, _machineState.GetLocalPoolBottomIdx() };

		// if not prepare arg stack. copy from args
		if (imi->args)
		{
			IL2CPP_ASSERT(imi->argCount == metadata::GetActualArgumentNum(method));
			CopyStackObject(stackBasePtr, argBase, imi->argStackObjectSize);
		}
		PUSH_STACK_FRAME(method, (uintptr_t)newFrame);
		return newFrame;
	}

	InterpFrame* InterpFrameGroup::LeaveFrame()
	{
		IL2CPP_ASSERT(_machineState.GetFrameTopIdx() > _frameBaseIdx);
		POP_STACK_FRAME();
		InterpFrame* frame = _machineState.GetTopFrame();
#if HYBRIDCLR_ENABLE_PROFILER
		il2cpp_codegen_profiler_method_exit(frame->method);
#endif
		if (frame->exFlowBase)
		{
			_machineState.SetExceptionFlowTop(frame->exFlowBase);
		}
		_machineState.PopFrame();
		_machineState.SetStackTop(frame->oldStackTop);
		_machineState.SetLocalPoolBottomIdx(frame->oldLocalPoolBottomIdx);
		return _machineState.GetFrameTopIdx() > _frameBaseIdx ? _machineState.GetTopFrame() : nullptr;
	}

	static bool FrameNeedsSkipped(const Il2CppStackFrameInfo& frame)
	{
		const MethodInfo* method = frame.method;
		const Il2CppClass* klass = method->klass;
		return (strcmp(klass->namespaze, "System.Diagnostics") == 0 &&
			(strcmp(klass->name, "StackFrame") == 0 || strcmp(klass->name, "StackTrace") == 0))
			|| (strcmp(klass->namespaze, "UnityEngine") == 0
				&& (strcmp(klass->name, "StackTraceUtility") == 0
					|| strcmp(klass->name, "Debug") == 0
					|| strcmp(klass->name, "Logger") == 0
					|| strcmp(klass->name, "DebugLogHandler") == 0));
	}

	static void SetupStackFrameInfo(const InterpFrame* frame, Il2CppStackFrameInfo& stackFrame)
	{
		const MethodInfo* method = frame->method;
		const InterpMethodInfo* imi = (const InterpMethodInfo*)method->interpData;
		const byte* actualIp = (const byte*)frame->ip;

		stackFrame.method = method;
		stackFrame.raw_ip = (uintptr_t)frame;

		if (!hybridclr::metadata::IsInterpreterMethod(method))
		{
			return;
		}
		
		hybridclr::metadata::InterpreterImage* interpImage = hybridclr::metadata::MetadataModule::GetImage(method);
		if (!interpImage)
		{
			return;
		}

		hybridclr::metadata::PDBImage* pdbImage = interpImage->GetPDBImage();
		if (!pdbImage)
		{
			return;
		}
		pdbImage->SetupStackFrameInfo(method, actualIp, stackFrame);
	}

	void MachineState::CollectFrames(il2cpp::vm::StackFrames* stackFrames)
	{
		if (_frameTopIdx <= 0)
		{
			return;
		}
		size_t insertIndex = 0;
		for (; insertIndex < stackFrames->size(); insertIndex++)
		{
			if (FrameNeedsSkipped((*stackFrames)[insertIndex]))
			{
				break;
			}
		}
		stackFrames->insert(stackFrames->begin() + insertIndex, _frameTopIdx, Il2CppStackFrameInfo());
		for (int32_t i = 0; i < _frameTopIdx; i++)
		{
			SetupStackFrameInfo(_frameBase + i, (*stackFrames)[insertIndex + i]);
		}
	}

	void MachineState::SetupFramesDebugInfo(il2cpp::vm::StackFrames* stackFrames)
	{
		for (Il2CppStackFrameInfo& frame : *stackFrames)
		{
			if (frame.method && hybridclr::metadata::IsInterpreterImplement(frame.method))
			{
				hybridclr::metadata::InterpreterImage* interpImage = hybridclr::metadata::MetadataModule::GetImage(frame.method);
				if (interpImage)
				{
					hybridclr::metadata::PDBImage* pdbImage = interpImage->GetPDBImage();
					if (pdbImage)
					{
						pdbImage->SetupStackFrameInfo(frame.method, (const byte*)(((InterpFrame*)frame.raw_ip)->ip), frame);
					}
				}
			}
		}
	}
}
}


```

`hybridclr/interpreter/Engine.h`:

```h
#pragma once

#include <stack>

#include "../CommonDef.h"

#include "gc/GarbageCollector.h"
#include "vm/Exception.h"
#include "vm/StackTrace.h"

#include "../metadata/MetadataUtil.h"
#include "../RuntimeConfig.h"

#include "InterpreterDefs.h"
#include "MemoryUtil.h"
#include "MethodBridge.h"
#include <algorithm>

namespace hybridclr
{
namespace interpreter
{

	class MachineState
	{
	public:
		MachineState()
		{
			_stackSize = -1;
			_stackBase = nullptr;
			_stackTopIdx = 0;
			_localPoolBottomIdx = -1;

			_frameBase = nullptr;
			_frameCount = -1;
			_frameTopIdx = 0;

			_exceptionFlowBase = nullptr;
			_exceptionFlowCount = -1;
			_exceptionFlowTopIdx = 0;
		}

		~MachineState()
		{
			if (_stackBase)
			{
				//il2cpp::gc::GarbageCollector::FreeFixed(_stackBase);
				il2cpp::gc::GarbageCollector::UnregisterDynamicRoot(this);
				HYBRIDCLR_FREE(_stackBase);
			}
			if (_frameBase)
			{
				HYBRIDCLR_FREE(_frameBase);
			}
			if (_exceptionFlowBase)
			{
				HYBRIDCLR_FREE(_exceptionFlowBase);
			}
		}

		static std::pair<char*, size_t> GetGCRootData(void* root)
		{
			MachineState* machineState = (MachineState*)root;
			if (machineState->_stackBase && machineState->_stackTopIdx > 0)
			{
				return std::make_pair((char*)machineState->_stackBase, machineState->_stackTopIdx * sizeof(StackObject));
			}
			else
			{
				return std::make_pair(nullptr, 0);
			}
		}

		StackObject* AllocArgments(int32_t argCount)
		{
			return AllocStackSlot(argCount);
		}

		StackObject* GetStackBasePtr() const
		{
			return _stackBase;
		}

		int32_t GetStackTop() const
		{
			return _stackTopIdx;
		}

		StackObject* AllocStackSlot(int32_t slotNum)
		{
			if (_stackTopIdx + slotNum > _localPoolBottomIdx)
			{
				if (!_stackBase)
				{
					InitEvalStack();
				}
				if (_stackTopIdx + slotNum > _localPoolBottomIdx)
				{
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetStackOverflowException("AllocStackSlot"));
				}
			}
			StackObject* dataPtr = _stackBase + _stackTopIdx;
			_stackTopIdx += slotNum;
#if DEBUG
			std::memset(dataPtr, 0xEA, slotNum * sizeof(StackObject));
#endif
			return dataPtr;
		}

		void* AllocLocalloc(size_t size)
		{
			IL2CPP_ASSERT(size % 8 == 0);
			int32_t slotNum = (int32_t)(size / 8);
			IL2CPP_ASSERT(slotNum > 0);
			if (_stackTopIdx + slotNum > _localPoolBottomIdx)
			{
				if (!_stackBase)
				{
					InitEvalStack();
				}
				if (_stackTopIdx + slotNum > _localPoolBottomIdx)
				{
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetStackOverflowException("AllocLocalloc"));
				}
			}
			_localPoolBottomIdx -= slotNum;
			return _stackBase + _localPoolBottomIdx;
		}

		void SetStackTop(int32_t oldTop)
		{
			_stackTopIdx = oldTop;
		}

		uint32_t GetFrameTopIdx() const
		{
			return _frameTopIdx;
		}

		int32_t GetLocalPoolBottomIdx() const
		{
			return _localPoolBottomIdx;
		}

		void SetLocalPoolBottomIdx(int32_t idx)
		{
			_localPoolBottomIdx = idx;
		}

		InterpFrame* PushFrame()
		{
			if (_frameTopIdx >= _frameCount)
			{
				if (!_frameBase)
				{
					InitFrames();
				}
				else
				{
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetStackOverflowException("AllocFrame"));
				}
			}
			return _frameBase + _frameTopIdx++;
		}

		void PopFrame()
		{
			IL2CPP_ASSERT(_frameTopIdx > 0);
			--_frameTopIdx;
		}

		void PopFrameN(int32_t count)
		{
			IL2CPP_ASSERT(count > 0 && _frameTopIdx >= count);
			_frameTopIdx -= count;
		}

		InterpFrame* GetTopFrame() const
		{
			if (_frameTopIdx > 0)
			{
				return _frameBase + _frameTopIdx - 1;
			}
			else
			{
				return nullptr;
			}
		}

		ExceptionFlowInfo* AllocExceptionFlow(int32_t count)
		{
			if (_exceptionFlowTopIdx + count >= _exceptionFlowCount)
			{
				if (!_exceptionFlowBase)
				{
					InitExceptionFlows();
				}
				if (_exceptionFlowTopIdx + count >= _exceptionFlowCount)
				{
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException("AllocExceptionFlowZero"));
				}
			}
			ExceptionFlowInfo* efi = _exceptionFlowBase + _exceptionFlowTopIdx;
			_exceptionFlowTopIdx += count;
			return efi;
		}

		uint32_t GetExceptionFlowTopIdx() const
		{
			return _exceptionFlowTopIdx;
		}

		void SetExceptionFlowTopIdx(uint32_t exTopIdx)
		{
			_exceptionFlowTopIdx = exTopIdx;
		}

		void SetExceptionFlowTop(ExceptionFlowInfo* top)
		{
			_exceptionFlowTopIdx = (int32_t)(top - _exceptionFlowBase);
			IL2CPP_ASSERT(_exceptionFlowTopIdx >= 0 && _exceptionFlowTopIdx <= _exceptionFlowCount);
		}

		void PushExecutingImage(const Il2CppImage* image)
		{
			_executingImageStack.push(image);
		}

		void PopExecutingImage()
		{
			_executingImageStack.pop();
		}

		const Il2CppImage* GetTopExecutingImage() const
		{
			if (_executingImageStack.empty())
			{
				return nullptr;
			}
			else
			{
				return _executingImageStack.top();
			}
		}

		void CollectFrames(il2cpp::vm::StackFrames* stackFrames);
		void SetupFramesDebugInfo(il2cpp::vm::StackFrames* stackFrames);

	private:


		void InitEvalStack()
		{
			_stackSize = (int32_t)RuntimeConfig::GetInterpreterThreadObjectStackSize();
			_stackBase = (StackObject*)HYBRIDCLR_MALLOC_ZERO(RuntimeConfig::GetInterpreterThreadObjectStackSize() * sizeof(StackObject));
			_stackTopIdx = 0;
			_localPoolBottomIdx = _stackSize;
			il2cpp::gc::GarbageCollector::RegisterDynamicRoot(this, GetGCRootData);
		}

		void InitFrames()
		{
			_frameBase = (InterpFrame*)HYBRIDCLR_CALLOC(RuntimeConfig::GetInterpreterThreadFrameStackSize(), sizeof(InterpFrame));
			_frameCount = (int32_t)RuntimeConfig::GetInterpreterThreadFrameStackSize();
			_frameTopIdx = 0;
		}

		void InitExceptionFlows()
		{
			_exceptionFlowBase = (ExceptionFlowInfo*)HYBRIDCLR_CALLOC(RuntimeConfig::GetInterpreterThreadExceptionFlowSize(), sizeof(ExceptionFlowInfo));
			_exceptionFlowCount = (int32_t)RuntimeConfig::GetInterpreterThreadExceptionFlowSize();
			_exceptionFlowTopIdx = 0;
		}

		StackObject* _stackBase;
		int32_t _stackSize;
		int32_t _stackTopIdx;
		int32_t _localPoolBottomIdx;

		InterpFrame* _frameBase;
		int32_t _frameTopIdx;
		int32_t _frameCount;

		ExceptionFlowInfo* _exceptionFlowBase;
		int32_t _exceptionFlowTopIdx;
		int32_t _exceptionFlowCount;


		std::stack<const Il2CppImage*> _executingImageStack;
	};

	class ExecutingInterpImageScope
	{
	public:
		ExecutingInterpImageScope(MachineState& state, const Il2CppImage* image) : _state(state)
		{
			_state.PushExecutingImage(image);
		}

		~ExecutingInterpImageScope()
		{
			_state.PopExecutingImage();
		}
		
	private:
		MachineState& _state;
	};

	class InterpFrameGroup
	{
	public:
		InterpFrameGroup(MachineState& ms) : _machineState(ms), _stackBaseIdx(ms.GetStackTop()), _frameBaseIdx(ms.GetFrameTopIdx())
		{

		}

		void CleanUpFrames()
		{
			IL2CPP_ASSERT(_machineState.GetFrameTopIdx() >= _frameBaseIdx);
			uint32_t n = _machineState.GetFrameTopIdx() - _frameBaseIdx;
			if (n > 0)
			{
				for (uint32_t i = 0; i < n; i++)
				{
					LeaveFrame();
				}
			}
		}

		InterpFrame* EnterFrameFromInterpreter(const MethodInfo* method, StackObject* argBase);

		InterpFrame* EnterFrameFromNative(const MethodInfo* method, StackObject* argBase);

		InterpFrame* LeaveFrame();

		void* AllocLoc(size_t originSize, bool fillZero)
		{
			if (originSize == 0)
			{
				return nullptr;
			}
			size_t size = (originSize + 7) & ~(size_t)7;
			void* data = _machineState.AllocLocalloc(size);
			if (fillZero)
			{
				std::memset(data, 0, size);
			}
			return data;
 		}

		size_t GetFrameCount() const { return _machineState.GetFrameTopIdx() - _frameBaseIdx; }
	private:
		MachineState& _machineState;
		int32_t _stackBaseIdx;
		uint32_t _frameBaseIdx;
	};
}
}
```

`hybridclr/interpreter/InstrinctDef.h`:

```h
#pragma once
#include "../CommonDef.h"

namespace hybridclr
{
namespace interpreter
{

	struct HtVector2f
	{
		float x;
		float y;
	};
	static_assert(sizeof(HtVector2f) == 8, "Vector2f");

	struct HtVector3f
	{
		float x;
		float y;
		float z;
	};
	static_assert(sizeof(HtVector3f) == 12, "Vector3f");

	struct HtVector4f
	{
		float x;
		float y;
		float z;
		float w;
	};
	static_assert(sizeof(HtVector4f) == 16, "Vector4f");

	struct HtVector2d
	{
		double x;
		double y;
	};
	static_assert(sizeof(HtVector2d) == 16, "Vector2d");

	struct HtVector3d
	{
		double x;
		double y;
		double z;
	};
	static_assert(sizeof(HtVector3d) == 24, "Vector3d");

	struct HtVector4d
	{
		double x;
		double y;
		double z;
		double w;
	};
	static_assert(sizeof(HtVector4d) == 32, "Vector4d");

	struct HtVector2i
	{
		int32_t x;
		int32_t y;
	};
	static_assert(sizeof(HtVector2i) == 8, "IntVector2i");

	struct HtVector3i
	{
		int32_t x;
		int32_t y;
		int32_t z;
	};
	static_assert(sizeof(HtVector3i) == 12, "IntVector3i");

	struct HtVector4i
	{
		int32_t x;
		int32_t y;
		int32_t z;
		int32_t w;
	};
	static_assert(sizeof(HtVector4i) == 16, "IntVector4i");

#pragma endregion

}
}

```

`hybridclr/interpreter/Instruction.cpp`:

```cpp
#include "Instruction.h"

namespace hybridclr
{
namespace interpreter
{
    uint16_t g_instructionSizes[] =
    {
		0,
        //!!!{{INST_SIZE
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		8,
		16,
		16,
		8,
		8,
		16,
		8,
		16,
		16,
		16,
		8,
		16,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		24,
		16,
		16,
		24,
		8,
		16,
		16,
		16,
		24,
		8,
		16,
		24,
		24,
		24,
		16,
		16,
		24,
		16,
		24,
		24,
		16,
		8,
		16,
		16,
		16,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		16,
		16,
		16,
		24,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		16,
		8,
		16,
		16,
		16,
		8,
		16,
		16,
		16,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		8,
		8,
		8,
		16,
		8,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		8,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		8,
		8,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		8,
		8,
		8,
		8,
		8,
		8,
		16,
		8,
		16,
		16,
		8,
		8,
		16,
		8,
		16,
		16,
		8,
		8,
		8,
		16,
		8,
		8,
		8,
		8,
		8,

        //!!!}}INST_SIZE
    };
}
}
```

`hybridclr/interpreter/Instruction.h`:

```h
#pragma once

#include "../CommonDef.h"

namespace hybridclr
{
namespace interpreter
{

	enum class PrefixFlags
	{
		None = 0,
		Constrained = 0x1,
		No = 0x2,
		ReadOnly = 0x4,
		Tail = 0x8,
		Unaligned = 0x10,
		Volatile = 0x20,
	};

	extern uint16_t g_instructionSizes[];

	enum class HiOpcodeEnum : uint16_t
	{
		None,
		//!!!{{OPCODE
		InitLocals_n_2,
		InitLocals_n_4,
		InitLocals_size_8,
		InitLocals_size_16,
		InitLocals_size_24,
		InitLocals_size_32,
		InitInlineLocals_n_2,
		InitInlineLocals_n_4,
		InitInlineLocals_size_8,
		InitInlineLocals_size_16,
		InitInlineLocals_size_24,
		InitInlineLocals_size_32,
		LdlocVarVar,
		LdlocExpandVarVar_i1,
		LdlocExpandVarVar_u1,
		LdlocExpandVarVar_i2,
		LdlocExpandVarVar_u2,
		LdlocVarVarSize,
		LdlocVarAddress,
		LdcVarConst_1,
		LdcVarConst_2,
		LdcVarConst_4,
		LdcVarConst_8,
		LdnullVar,
		LdindVarVar_i1,
		LdindVarVar_u1,
		LdindVarVar_i2,
		LdindVarVar_u2,
		LdindVarVar_i4,
		LdindVarVar_u4,
		LdindVarVar_i8,
		LdindVarVar_f4,
		LdindVarVar_f8,
		StindVarVar_i1,
		StindVarVar_i2,
		StindVarVar_i4,
		StindVarVar_i8,
		StindVarVar_f4,
		StindVarVar_f8,
		StindVarVar_ref,
		LocalAllocVarVar_n_2,
		LocalAllocVarVar_n_4,
		InitblkVarVarVar,
		CpblkVarVar,
		MemoryBarrier,
		ConvertVarVar_i4_i1,
		ConvertVarVar_i4_u1,
		ConvertVarVar_i4_i2,
		ConvertVarVar_i4_u2,
		ConvertVarVar_i4_i4,
		ConvertVarVar_i4_u4,
		ConvertVarVar_i4_i8,
		ConvertVarVar_i4_u8,
		ConvertVarVar_i4_f4,
		ConvertVarVar_i4_f8,
		ConvertVarVar_u4_i1,
		ConvertVarVar_u4_u1,
		ConvertVarVar_u4_i2,
		ConvertVarVar_u4_u2,
		ConvertVarVar_u4_i4,
		ConvertVarVar_u4_u4,
		ConvertVarVar_u4_i8,
		ConvertVarVar_u4_u8,
		ConvertVarVar_u4_f4,
		ConvertVarVar_u4_f8,
		ConvertVarVar_i8_i1,
		ConvertVarVar_i8_u1,
		ConvertVarVar_i8_i2,
		ConvertVarVar_i8_u2,
		ConvertVarVar_i8_i4,
		ConvertVarVar_i8_u4,
		ConvertVarVar_i8_i8,
		ConvertVarVar_i8_u8,
		ConvertVarVar_i8_f4,
		ConvertVarVar_i8_f8,
		ConvertVarVar_u8_i1,
		ConvertVarVar_u8_u1,
		ConvertVarVar_u8_i2,
		ConvertVarVar_u8_u2,
		ConvertVarVar_u8_i4,
		ConvertVarVar_u8_u4,
		ConvertVarVar_u8_i8,
		ConvertVarVar_u8_u8,
		ConvertVarVar_u8_f4,
		ConvertVarVar_u8_f8,
		ConvertVarVar_f4_i1,
		ConvertVarVar_f4_u1,
		ConvertVarVar_f4_i2,
		ConvertVarVar_f4_u2,
		ConvertVarVar_f4_i4,
		ConvertVarVar_f4_u4,
		ConvertVarVar_f4_i8,
		ConvertVarVar_f4_u8,
		ConvertVarVar_f4_f4,
		ConvertVarVar_f4_f8,
		ConvertVarVar_f8_i1,
		ConvertVarVar_f8_u1,
		ConvertVarVar_f8_i2,
		ConvertVarVar_f8_u2,
		ConvertVarVar_f8_i4,
		ConvertVarVar_f8_u4,
		ConvertVarVar_f8_i8,
		ConvertVarVar_f8_u8,
		ConvertVarVar_f8_f4,
		ConvertVarVar_f8_f8,
		ConvertOverflowVarVar_i4_i1,
		ConvertOverflowVarVar_i4_u1,
		ConvertOverflowVarVar_i4_i2,
		ConvertOverflowVarVar_i4_u2,
		ConvertOverflowVarVar_i4_i4,
		ConvertOverflowVarVar_i4_u4,
		ConvertOverflowVarVar_i4_i8,
		ConvertOverflowVarVar_i4_u8,
		ConvertOverflowVarVar_u4_i1,
		ConvertOverflowVarVar_u4_u1,
		ConvertOverflowVarVar_u4_i2,
		ConvertOverflowVarVar_u4_u2,
		ConvertOverflowVarVar_u4_i4,
		ConvertOverflowVarVar_u4_u4,
		ConvertOverflowVarVar_u4_i8,
		ConvertOverflowVarVar_u4_u8,
		ConvertOverflowVarVar_i8_i1,
		ConvertOverflowVarVar_i8_u1,
		ConvertOverflowVarVar_i8_i2,
		ConvertOverflowVarVar_i8_u2,
		ConvertOverflowVarVar_i8_i4,
		ConvertOverflowVarVar_i8_u4,
		ConvertOverflowVarVar_i8_i8,
		ConvertOverflowVarVar_i8_u8,
		ConvertOverflowVarVar_u8_i1,
		ConvertOverflowVarVar_u8_u1,
		ConvertOverflowVarVar_u8_i2,
		ConvertOverflowVarVar_u8_u2,
		ConvertOverflowVarVar_u8_i4,
		ConvertOverflowVarVar_u8_u4,
		ConvertOverflowVarVar_u8_i8,
		ConvertOverflowVarVar_u8_u8,
		ConvertOverflowVarVar_f4_i1,
		ConvertOverflowVarVar_f4_u1,
		ConvertOverflowVarVar_f4_i2,
		ConvertOverflowVarVar_f4_u2,
		ConvertOverflowVarVar_f4_i4,
		ConvertOverflowVarVar_f4_u4,
		ConvertOverflowVarVar_f4_i8,
		ConvertOverflowVarVar_f4_u8,
		ConvertOverflowVarVar_f8_i1,
		ConvertOverflowVarVar_f8_u1,
		ConvertOverflowVarVar_f8_i2,
		ConvertOverflowVarVar_f8_u2,
		ConvertOverflowVarVar_f8_i4,
		ConvertOverflowVarVar_f8_u4,
		ConvertOverflowVarVar_f8_i8,
		ConvertOverflowVarVar_f8_u8,
		BinOpVarVarVar_Add_i4,
		BinOpVarVarVar_Sub_i4,
		BinOpVarVarVar_Mul_i4,
		BinOpVarVarVar_MulUn_i4,
		BinOpVarVarVar_Div_i4,
		BinOpVarVarVar_DivUn_i4,
		BinOpVarVarVar_Rem_i4,
		BinOpVarVarVar_RemUn_i4,
		BinOpVarVarVar_And_i4,
		BinOpVarVarVar_Or_i4,
		BinOpVarVarVar_Xor_i4,
		BinOpVarVarVar_Add_i8,
		BinOpVarVarVar_Sub_i8,
		BinOpVarVarVar_Mul_i8,
		BinOpVarVarVar_MulUn_i8,
		BinOpVarVarVar_Div_i8,
		BinOpVarVarVar_DivUn_i8,
		BinOpVarVarVar_Rem_i8,
		BinOpVarVarVar_RemUn_i8,
		BinOpVarVarVar_And_i8,
		BinOpVarVarVar_Or_i8,
		BinOpVarVarVar_Xor_i8,
		BinOpVarVarVar_Add_f4,
		BinOpVarVarVar_Sub_f4,
		BinOpVarVarVar_Mul_f4,
		BinOpVarVarVar_Div_f4,
		BinOpVarVarVar_Rem_f4,
		BinOpVarVarVar_Add_f8,
		BinOpVarVarVar_Sub_f8,
		BinOpVarVarVar_Mul_f8,
		BinOpVarVarVar_Div_f8,
		BinOpVarVarVar_Rem_f8,
		BinOpOverflowVarVarVar_Add_i4,
		BinOpOverflowVarVarVar_Sub_i4,
		BinOpOverflowVarVarVar_Mul_i4,
		BinOpOverflowVarVarVar_Add_i8,
		BinOpOverflowVarVarVar_Sub_i8,
		BinOpOverflowVarVarVar_Mul_i8,
		BinOpOverflowVarVarVar_Add_u4,
		BinOpOverflowVarVarVar_Sub_u4,
		BinOpOverflowVarVarVar_Mul_u4,
		BinOpOverflowVarVarVar_Add_u8,
		BinOpOverflowVarVarVar_Sub_u8,
		BinOpOverflowVarVarVar_Mul_u8,
		BitShiftBinOpVarVarVar_Shl_i4_i4,
		BitShiftBinOpVarVarVar_Shr_i4_i4,
		BitShiftBinOpVarVarVar_ShrUn_i4_i4,
		BitShiftBinOpVarVarVar_Shl_i4_i8,
		BitShiftBinOpVarVarVar_Shr_i4_i8,
		BitShiftBinOpVarVarVar_ShrUn_i4_i8,
		BitShiftBinOpVarVarVar_Shl_i8_i4,
		BitShiftBinOpVarVarVar_Shr_i8_i4,
		BitShiftBinOpVarVarVar_ShrUn_i8_i4,
		BitShiftBinOpVarVarVar_Shl_i8_i8,
		BitShiftBinOpVarVarVar_Shr_i8_i8,
		BitShiftBinOpVarVarVar_ShrUn_i8_i8,
		UnaryOpVarVar_Neg_i4,
		UnaryOpVarVar_Not_i4,
		UnaryOpVarVar_Neg_i8,
		UnaryOpVarVar_Not_i8,
		UnaryOpVarVar_Neg_f4,
		UnaryOpVarVar_Neg_f8,
		CheckFiniteVar_f4,
		CheckFiniteVar_f8,
		CompOpVarVarVar_Ceq_i4,
		CompOpVarVarVar_Ceq_i8,
		CompOpVarVarVar_Ceq_f4,
		CompOpVarVarVar_Ceq_f8,
		CompOpVarVarVar_Cgt_i4,
		CompOpVarVarVar_Cgt_i8,
		CompOpVarVarVar_Cgt_f4,
		CompOpVarVarVar_Cgt_f8,
		CompOpVarVarVar_CgtUn_i4,
		CompOpVarVarVar_CgtUn_i8,
		CompOpVarVarVar_CgtUn_f4,
		CompOpVarVarVar_CgtUn_f8,
		CompOpVarVarVar_Clt_i4,
		CompOpVarVarVar_Clt_i8,
		CompOpVarVarVar_Clt_f4,
		CompOpVarVarVar_Clt_f8,
		CompOpVarVarVar_CltUn_i4,
		CompOpVarVarVar_CltUn_i8,
		CompOpVarVarVar_CltUn_f4,
		CompOpVarVarVar_CltUn_f8,
		BranchUncondition_4,
		BranchTrueVar_i4,
		BranchTrueVar_i8,
		BranchFalseVar_i4,
		BranchFalseVar_i8,
		BranchVarVar_Ceq_i4,
		BranchVarVar_Ceq_i8,
		BranchVarVar_Ceq_f4,
		BranchVarVar_Ceq_f8,
		BranchVarVar_CneUn_i4,
		BranchVarVar_CneUn_i8,
		BranchVarVar_CneUn_f4,
		BranchVarVar_CneUn_f8,
		BranchVarVar_Cgt_i4,
		BranchVarVar_Cgt_i8,
		BranchVarVar_Cgt_f4,
		BranchVarVar_Cgt_f8,
		BranchVarVar_CgtUn_i4,
		BranchVarVar_CgtUn_i8,
		BranchVarVar_CgtUn_f4,
		BranchVarVar_CgtUn_f8,
		BranchVarVar_Cge_i4,
		BranchVarVar_Cge_i8,
		BranchVarVar_Cge_f4,
		BranchVarVar_Cge_f8,
		BranchVarVar_CgeUn_i4,
		BranchVarVar_CgeUn_i8,
		BranchVarVar_CgeUn_f4,
		BranchVarVar_CgeUn_f8,
		BranchVarVar_Clt_i4,
		BranchVarVar_Clt_i8,
		BranchVarVar_Clt_f4,
		BranchVarVar_Clt_f8,
		BranchVarVar_CltUn_i4,
		BranchVarVar_CltUn_i8,
		BranchVarVar_CltUn_f4,
		BranchVarVar_CltUn_f8,
		BranchVarVar_Cle_i4,
		BranchVarVar_Cle_i8,
		BranchVarVar_Cle_f4,
		BranchVarVar_Cle_f8,
		BranchVarVar_CleUn_i4,
		BranchVarVar_CleUn_i8,
		BranchVarVar_CleUn_f4,
		BranchVarVar_CleUn_f8,
		BranchJump,
		BranchSwitch,
		NewClassVar,
		NewClassVar_Ctor_0,
		NewClassVar_NotCtor,
		NewValueTypeVar,
		NewValueTypeVar_Ctor_0,
		NewClassInterpVar,
		NewClassInterpVar_Ctor_0,
		NewValueTypeInterpVar,
		AdjustValueTypeRefVar,
		BoxRefVarVar,
		LdvirftnVarVar,
		RetVar_ret_1,
		RetVar_ret_2,
		RetVar_ret_4,
		RetVar_ret_8,
		RetVar_ret_12,
		RetVar_ret_16,
		RetVar_ret_20,
		RetVar_ret_24,
		RetVar_ret_28,
		RetVar_ret_32,
		RetVar_ret_n,
		RetVar_void,
		CallNativeInstance_void,
		CallNativeInstance_ret,
		CallNativeInstance_ret_expand,
		CallNativeStatic_void,
		CallNativeStatic_ret,
		CallNativeStatic_ret_expand,
		CallInterp_void,
		CallInterp_ret,
		CallVirtual_void,
		CallVirtual_ret,
		CallVirtual_ret_expand,
		CallInterpVirtual_void,
		CallInterpVirtual_ret,
		CallInd_void,
		CallInd_ret,
		CallInd_ret_expand,
		CallPInvoke_void,
		CallPInvoke_ret,
		CallPInvoke_ret_expand,
		CallDelegateInvoke_void,
		CallDelegateInvoke_ret,
		CallDelegateInvoke_ret_expand,
		CallDelegateBeginInvoke,
		CallDelegateEndInvoke_void,
		CallDelegateEndInvoke_ret,
		NewDelegate,
		CtorDelegate,
		CallCommonNativeInstance_v_0,
		CallCommonNativeInstance_i1_0,
		CallCommonNativeInstance_u1_0,
		CallCommonNativeInstance_i2_0,
		CallCommonNativeInstance_u2_0,
		CallCommonNativeInstance_i4_0,
		CallCommonNativeInstance_i8_0,
		CallCommonNativeInstance_f4_0,
		CallCommonNativeInstance_f8_0,
		CallCommonNativeInstance_v_i4_1,
		CallCommonNativeInstance_v_i4_2,
		CallCommonNativeInstance_v_i4_3,
		CallCommonNativeInstance_v_i4_4,
		CallCommonNativeInstance_v_i8_1,
		CallCommonNativeInstance_v_i8_2,
		CallCommonNativeInstance_v_i8_3,
		CallCommonNativeInstance_v_i8_4,
		CallCommonNativeInstance_v_f4_1,
		CallCommonNativeInstance_v_f4_2,
		CallCommonNativeInstance_v_f4_3,
		CallCommonNativeInstance_v_f4_4,
		CallCommonNativeInstance_v_f8_1,
		CallCommonNativeInstance_v_f8_2,
		CallCommonNativeInstance_v_f8_3,
		CallCommonNativeInstance_v_f8_4,
		CallCommonNativeInstance_u1_i4_1,
		CallCommonNativeInstance_u1_i4_2,
		CallCommonNativeInstance_u1_i4_3,
		CallCommonNativeInstance_u1_i4_4,
		CallCommonNativeInstance_u1_i8_1,
		CallCommonNativeInstance_u1_i8_2,
		CallCommonNativeInstance_u1_i8_3,
		CallCommonNativeInstance_u1_i8_4,
		CallCommonNativeInstance_u1_f4_1,
		CallCommonNativeInstance_u1_f4_2,
		CallCommonNativeInstance_u1_f4_3,
		CallCommonNativeInstance_u1_f4_4,
		CallCommonNativeInstance_u1_f8_1,
		CallCommonNativeInstance_u1_f8_2,
		CallCommonNativeInstance_u1_f8_3,
		CallCommonNativeInstance_u1_f8_4,
		CallCommonNativeInstance_i4_i4_1,
		CallCommonNativeInstance_i4_i4_2,
		CallCommonNativeInstance_i4_i4_3,
		CallCommonNativeInstance_i4_i4_4,
		CallCommonNativeInstance_i4_i8_1,
		CallCommonNativeInstance_i4_i8_2,
		CallCommonNativeInstance_i4_i8_3,
		CallCommonNativeInstance_i4_i8_4,
		CallCommonNativeInstance_i4_f4_1,
		CallCommonNativeInstance_i4_f4_2,
		CallCommonNativeInstance_i4_f4_3,
		CallCommonNativeInstance_i4_f4_4,
		CallCommonNativeInstance_i4_f8_1,
		CallCommonNativeInstance_i4_f8_2,
		CallCommonNativeInstance_i4_f8_3,
		CallCommonNativeInstance_i4_f8_4,
		CallCommonNativeInstance_i8_i4_1,
		CallCommonNativeInstance_i8_i4_2,
		CallCommonNativeInstance_i8_i4_3,
		CallCommonNativeInstance_i8_i4_4,
		CallCommonNativeInstance_i8_i8_1,
		CallCommonNativeInstance_i8_i8_2,
		CallCommonNativeInstance_i8_i8_3,
		CallCommonNativeInstance_i8_i8_4,
		CallCommonNativeInstance_i8_f4_1,
		CallCommonNativeInstance_i8_f4_2,
		CallCommonNativeInstance_i8_f4_3,
		CallCommonNativeInstance_i8_f4_4,
		CallCommonNativeInstance_i8_f8_1,
		CallCommonNativeInstance_i8_f8_2,
		CallCommonNativeInstance_i8_f8_3,
		CallCommonNativeInstance_i8_f8_4,
		CallCommonNativeInstance_f4_i4_1,
		CallCommonNativeInstance_f4_i4_2,
		CallCommonNativeInstance_f4_i4_3,
		CallCommonNativeInstance_f4_i4_4,
		CallCommonNativeInstance_f4_i8_1,
		CallCommonNativeInstance_f4_i8_2,
		CallCommonNativeInstance_f4_i8_3,
		CallCommonNativeInstance_f4_i8_4,
		CallCommonNativeInstance_f4_f4_1,
		CallCommonNativeInstance_f4_f4_2,
		CallCommonNativeInstance_f4_f4_3,
		CallCommonNativeInstance_f4_f4_4,
		CallCommonNativeInstance_f4_f8_1,
		CallCommonNativeInstance_f4_f8_2,
		CallCommonNativeInstance_f4_f8_3,
		CallCommonNativeInstance_f4_f8_4,
		CallCommonNativeInstance_f8_i4_1,
		CallCommonNativeInstance_f8_i4_2,
		CallCommonNativeInstance_f8_i4_3,
		CallCommonNativeInstance_f8_i4_4,
		CallCommonNativeInstance_f8_i8_1,
		CallCommonNativeInstance_f8_i8_2,
		CallCommonNativeInstance_f8_i8_3,
		CallCommonNativeInstance_f8_i8_4,
		CallCommonNativeInstance_f8_f4_1,
		CallCommonNativeInstance_f8_f4_2,
		CallCommonNativeInstance_f8_f4_3,
		CallCommonNativeInstance_f8_f4_4,
		CallCommonNativeInstance_f8_f8_1,
		CallCommonNativeInstance_f8_f8_2,
		CallCommonNativeInstance_f8_f8_3,
		CallCommonNativeInstance_f8_f8_4,
		CallCommonNativeStatic_v_0,
		CallCommonNativeStatic_i1_0,
		CallCommonNativeStatic_u1_0,
		CallCommonNativeStatic_i2_0,
		CallCommonNativeStatic_u2_0,
		CallCommonNativeStatic_i4_0,
		CallCommonNativeStatic_i8_0,
		CallCommonNativeStatic_f4_0,
		CallCommonNativeStatic_f8_0,
		CallCommonNativeStatic_v_i4_1,
		CallCommonNativeStatic_v_i4_2,
		CallCommonNativeStatic_v_i4_3,
		CallCommonNativeStatic_v_i4_4,
		CallCommonNativeStatic_v_i8_1,
		CallCommonNativeStatic_v_i8_2,
		CallCommonNativeStatic_v_i8_3,
		CallCommonNativeStatic_v_i8_4,
		CallCommonNativeStatic_v_f4_1,
		CallCommonNativeStatic_v_f4_2,
		CallCommonNativeStatic_v_f4_3,
		CallCommonNativeStatic_v_f4_4,
		CallCommonNativeStatic_v_f8_1,
		CallCommonNativeStatic_v_f8_2,
		CallCommonNativeStatic_v_f8_3,
		CallCommonNativeStatic_v_f8_4,
		CallCommonNativeStatic_u1_i4_1,
		CallCommonNativeStatic_u1_i4_2,
		CallCommonNativeStatic_u1_i4_3,
		CallCommonNativeStatic_u1_i4_4,
		CallCommonNativeStatic_u1_i8_1,
		CallCommonNativeStatic_u1_i8_2,
		CallCommonNativeStatic_u1_i8_3,
		CallCommonNativeStatic_u1_i8_4,
		CallCommonNativeStatic_u1_f4_1,
		CallCommonNativeStatic_u1_f4_2,
		CallCommonNativeStatic_u1_f4_3,
		CallCommonNativeStatic_u1_f4_4,
		CallCommonNativeStatic_u1_f8_1,
		CallCommonNativeStatic_u1_f8_2,
		CallCommonNativeStatic_u1_f8_3,
		CallCommonNativeStatic_u1_f8_4,
		CallCommonNativeStatic_i4_i4_1,
		CallCommonNativeStatic_i4_i4_2,
		CallCommonNativeStatic_i4_i4_3,
		CallCommonNativeStatic_i4_i4_4,
		CallCommonNativeStatic_i4_i8_1,
		CallCommonNativeStatic_i4_i8_2,
		CallCommonNativeStatic_i4_i8_3,
		CallCommonNativeStatic_i4_i8_4,
		CallCommonNativeStatic_i4_f4_1,
		CallCommonNativeStatic_i4_f4_2,
		CallCommonNativeStatic_i4_f4_3,
		CallCommonNativeStatic_i4_f4_4,
		CallCommonNativeStatic_i4_f8_1,
		CallCommonNativeStatic_i4_f8_2,
		CallCommonNativeStatic_i4_f8_3,
		CallCommonNativeStatic_i4_f8_4,
		CallCommonNativeStatic_i8_i4_1,
		CallCommonNativeStatic_i8_i4_2,
		CallCommonNativeStatic_i8_i4_3,
		CallCommonNativeStatic_i8_i4_4,
		CallCommonNativeStatic_i8_i8_1,
		CallCommonNativeStatic_i8_i8_2,
		CallCommonNativeStatic_i8_i8_3,
		CallCommonNativeStatic_i8_i8_4,
		CallCommonNativeStatic_i8_f4_1,
		CallCommonNativeStatic_i8_f4_2,
		CallCommonNativeStatic_i8_f4_3,
		CallCommonNativeStatic_i8_f4_4,
		CallCommonNativeStatic_i8_f8_1,
		CallCommonNativeStatic_i8_f8_2,
		CallCommonNativeStatic_i8_f8_3,
		CallCommonNativeStatic_i8_f8_4,
		CallCommonNativeStatic_f4_i4_1,
		CallCommonNativeStatic_f4_i4_2,
		CallCommonNativeStatic_f4_i4_3,
		CallCommonNativeStatic_f4_i4_4,
		CallCommonNativeStatic_f4_i8_1,
		CallCommonNativeStatic_f4_i8_2,
		CallCommonNativeStatic_f4_i8_3,
		CallCommonNativeStatic_f4_i8_4,
		CallCommonNativeStatic_f4_f4_1,
		CallCommonNativeStatic_f4_f4_2,
		CallCommonNativeStatic_f4_f4_3,
		CallCommonNativeStatic_f4_f4_4,
		CallCommonNativeStatic_f4_f8_1,
		CallCommonNativeStatic_f4_f8_2,
		CallCommonNativeStatic_f4_f8_3,
		CallCommonNativeStatic_f4_f8_4,
		CallCommonNativeStatic_f8_i4_1,
		CallCommonNativeStatic_f8_i4_2,
		CallCommonNativeStatic_f8_i4_3,
		CallCommonNativeStatic_f8_i4_4,
		CallCommonNativeStatic_f8_i8_1,
		CallCommonNativeStatic_f8_i8_2,
		CallCommonNativeStatic_f8_i8_3,
		CallCommonNativeStatic_f8_i8_4,
		CallCommonNativeStatic_f8_f4_1,
		CallCommonNativeStatic_f8_f4_2,
		CallCommonNativeStatic_f8_f4_3,
		CallCommonNativeStatic_f8_f4_4,
		CallCommonNativeStatic_f8_f8_1,
		CallCommonNativeStatic_f8_f8_2,
		CallCommonNativeStatic_f8_f8_3,
		CallCommonNativeStatic_f8_f8_4,
		BoxVarVar,
		UnBoxVarVar,
		UnBoxAnyVarVar,
		CastclassVar,
		IsInstVar,
		LdtokenVar,
		MakeRefVarVar,
		RefAnyTypeVarVar,
		RefAnyValueVarVar,
		CpobjVarVar_ref,
		CpobjVarVar_1,
		CpobjVarVar_2,
		CpobjVarVar_4,
		CpobjVarVar_8,
		CpobjVarVar_12,
		CpobjVarVar_16,
		CpobjVarVar_20,
		CpobjVarVar_24,
		CpobjVarVar_28,
		CpobjVarVar_32,
		CpobjVarVar_n_2,
		CpobjVarVar_n_4,
		CpobjVarVar_WriteBarrier_n_2,
		CpobjVarVar_WriteBarrier_n_4,
		LdobjVarVar_ref,
		LdobjVarVar_1,
		LdobjVarVar_2,
		LdobjVarVar_4,
		LdobjVarVar_8,
		LdobjVarVar_12,
		LdobjVarVar_16,
		LdobjVarVar_20,
		LdobjVarVar_24,
		LdobjVarVar_28,
		LdobjVarVar_32,
		LdobjVarVar_n_4,
		StobjVarVar_ref,
		StobjVarVar_1,
		StobjVarVar_2,
		StobjVarVar_4,
		StobjVarVar_8,
		StobjVarVar_12,
		StobjVarVar_16,
		StobjVarVar_20,
		StobjVarVar_24,
		StobjVarVar_28,
		StobjVarVar_32,
		StobjVarVar_n_4,
		StobjVarVar_WriteBarrier_n_4,
		InitobjVar_ref,
		InitobjVar_1,
		InitobjVar_2,
		InitobjVar_4,
		InitobjVar_8,
		InitobjVar_12,
		InitobjVar_16,
		InitobjVar_20,
		InitobjVar_24,
		InitobjVar_28,
		InitobjVar_32,
		InitobjVar_n_2,
		InitobjVar_n_4,
		InitobjVar_WriteBarrier_n_2,
		InitobjVar_WriteBarrier_n_4,
		LdstrVar,
		LdfldVarVar_i1,
		LdfldVarVar_u1,
		LdfldVarVar_i2,
		LdfldVarVar_u2,
		LdfldVarVar_i4,
		LdfldVarVar_u4,
		LdfldVarVar_i8,
		LdfldVarVar_u8,
		LdfldVarVar_size_8,
		LdfldVarVar_size_12,
		LdfldVarVar_size_16,
		LdfldVarVar_size_20,
		LdfldVarVar_size_24,
		LdfldVarVar_size_28,
		LdfldVarVar_size_32,
		LdfldVarVar_n_2,
		LdfldVarVar_n_4,
		LdfldValueTypeVarVar_i1,
		LdfldValueTypeVarVar_u1,
		LdfldValueTypeVarVar_i2,
		LdfldValueTypeVarVar_u2,
		LdfldValueTypeVarVar_i4,
		LdfldValueTypeVarVar_u4,
		LdfldValueTypeVarVar_i8,
		LdfldValueTypeVarVar_u8,
		LdfldValueTypeVarVar_size_8,
		LdfldValueTypeVarVar_size_12,
		LdfldValueTypeVarVar_size_16,
		LdfldValueTypeVarVar_size_20,
		LdfldValueTypeVarVar_size_24,
		LdfldValueTypeVarVar_size_28,
		LdfldValueTypeVarVar_size_32,
		LdfldValueTypeVarVar_n_2,
		LdfldValueTypeVarVar_n_4,
		LdfldaVarVar,
		StfldVarVar_i1,
		StfldVarVar_u1,
		StfldVarVar_i2,
		StfldVarVar_u2,
		StfldVarVar_i4,
		StfldVarVar_u4,
		StfldVarVar_i8,
		StfldVarVar_u8,
		StfldVarVar_ref,
		StfldVarVar_size_8,
		StfldVarVar_size_12,
		StfldVarVar_size_16,
		StfldVarVar_size_20,
		StfldVarVar_size_24,
		StfldVarVar_size_28,
		StfldVarVar_size_32,
		StfldVarVar_n_2,
		StfldVarVar_n_4,
		StfldVarVar_WriteBarrier_n_2,
		StfldVarVar_WriteBarrier_n_4,
		LdsfldVarVar_i1,
		LdsfldVarVar_u1,
		LdsfldVarVar_i2,
		LdsfldVarVar_u2,
		LdsfldVarVar_i4,
		LdsfldVarVar_u4,
		LdsfldVarVar_i8,
		LdsfldVarVar_u8,
		LdsfldVarVar_size_8,
		LdsfldVarVar_size_12,
		LdsfldVarVar_size_16,
		LdsfldVarVar_size_20,
		LdsfldVarVar_size_24,
		LdsfldVarVar_size_28,
		LdsfldVarVar_size_32,
		LdsfldVarVar_n_2,
		LdsfldVarVar_n_4,
		StsfldVarVar_i1,
		StsfldVarVar_u1,
		StsfldVarVar_i2,
		StsfldVarVar_u2,
		StsfldVarVar_i4,
		StsfldVarVar_u4,
		StsfldVarVar_i8,
		StsfldVarVar_u8,
		StsfldVarVar_ref,
		StsfldVarVar_size_8,
		StsfldVarVar_size_12,
		StsfldVarVar_size_16,
		StsfldVarVar_size_20,
		StsfldVarVar_size_24,
		StsfldVarVar_size_28,
		StsfldVarVar_size_32,
		StsfldVarVar_n_2,
		StsfldVarVar_n_4,
		StsfldVarVar_WriteBarrier_n_2,
		StsfldVarVar_WriteBarrier_n_4,
		LdsfldaVarVar,
		LdsfldaFromFieldDataVarVar,
		LdthreadlocalaVarVar,
		LdthreadlocalVarVar_i1,
		LdthreadlocalVarVar_u1,
		LdthreadlocalVarVar_i2,
		LdthreadlocalVarVar_u2,
		LdthreadlocalVarVar_i4,
		LdthreadlocalVarVar_u4,
		LdthreadlocalVarVar_i8,
		LdthreadlocalVarVar_u8,
		LdthreadlocalVarVar_size_8,
		LdthreadlocalVarVar_size_12,
		LdthreadlocalVarVar_size_16,
		LdthreadlocalVarVar_size_20,
		LdthreadlocalVarVar_size_24,
		LdthreadlocalVarVar_size_28,
		LdthreadlocalVarVar_size_32,
		LdthreadlocalVarVar_n_2,
		LdthreadlocalVarVar_n_4,
		StthreadlocalVarVar_i1,
		StthreadlocalVarVar_u1,
		StthreadlocalVarVar_i2,
		StthreadlocalVarVar_u2,
		StthreadlocalVarVar_i4,
		StthreadlocalVarVar_u4,
		StthreadlocalVarVar_i8,
		StthreadlocalVarVar_u8,
		StthreadlocalVarVar_ref,
		StthreadlocalVarVar_size_8,
		StthreadlocalVarVar_size_12,
		StthreadlocalVarVar_size_16,
		StthreadlocalVarVar_size_20,
		StthreadlocalVarVar_size_24,
		StthreadlocalVarVar_size_28,
		StthreadlocalVarVar_size_32,
		StthreadlocalVarVar_n_2,
		StthreadlocalVarVar_n_4,
		StthreadlocalVarVar_WriteBarrier_n_2,
		StthreadlocalVarVar_WriteBarrier_n_4,
		CheckThrowIfNullVar,
		InitClassStaticCtor,
		LdfldaLargeVarVar,
		LdfldLargeVarVar_i1,
		LdfldLargeVarVar_u1,
		LdfldLargeVarVar_i2,
		LdfldLargeVarVar_u2,
		LdfldLargeVarVar_i4,
		LdfldLargeVarVar_u4,
		LdfldLargeVarVar_i8,
		LdfldLargeVarVar_u8,
		LdfldLargeVarVar_size_8,
		LdfldLargeVarVar_size_12,
		LdfldLargeVarVar_size_16,
		LdfldLargeVarVar_size_20,
		LdfldLargeVarVar_size_24,
		LdfldLargeVarVar_size_28,
		LdfldLargeVarVar_size_32,
		LdfldLargeVarVar_n_2,
		LdfldLargeVarVar_n_4,
		LdfldValueTypeLargeVarVar_i1,
		LdfldValueTypeLargeVarVar_u1,
		LdfldValueTypeLargeVarVar_i2,
		LdfldValueTypeLargeVarVar_u2,
		LdfldValueTypeLargeVarVar_i4,
		LdfldValueTypeLargeVarVar_u4,
		LdfldValueTypeLargeVarVar_i8,
		LdfldValueTypeLargeVarVar_u8,
		LdfldValueTypeLargeVarVar_size_8,
		LdfldValueTypeLargeVarVar_size_12,
		LdfldValueTypeLargeVarVar_size_16,
		LdfldValueTypeLargeVarVar_size_20,
		LdfldValueTypeLargeVarVar_size_24,
		LdfldValueTypeLargeVarVar_size_28,
		LdfldValueTypeLargeVarVar_size_32,
		LdfldValueTypeLargeVarVar_n_2,
		LdfldValueTypeLargeVarVar_n_4,
		StfldLargeVarVar_i1,
		StfldLargeVarVar_u1,
		StfldLargeVarVar_i2,
		StfldLargeVarVar_u2,
		StfldLargeVarVar_i4,
		StfldLargeVarVar_u4,
		StfldLargeVarVar_i8,
		StfldLargeVarVar_u8,
		StfldLargeVarVar_ref,
		StfldLargeVarVar_size_8,
		StfldLargeVarVar_size_12,
		StfldLargeVarVar_size_16,
		StfldLargeVarVar_size_20,
		StfldLargeVarVar_size_24,
		StfldLargeVarVar_size_28,
		StfldLargeVarVar_size_32,
		StfldLargeVarVar_n_2,
		StfldLargeVarVar_n_4,
		StfldLargeVarVar_WriteBarrier_n_2,
		StfldLargeVarVar_WriteBarrier_n_4,
		NewArrVarVar,
		GetArrayLengthVarVar,
		GetArrayElementAddressAddrVarVar,
		GetArrayElementAddressCheckAddrVarVar,
		GetArrayElementVarVar_i1,
		GetArrayElementVarVar_u1,
		GetArrayElementVarVar_i2,
		GetArrayElementVarVar_u2,
		GetArrayElementVarVar_i4,
		GetArrayElementVarVar_u4,
		GetArrayElementVarVar_i8,
		GetArrayElementVarVar_u8,
		GetArrayElementVarVar_size_1,
		GetArrayElementVarVar_size_2,
		GetArrayElementVarVar_size_4,
		GetArrayElementVarVar_size_8,
		GetArrayElementVarVar_size_12,
		GetArrayElementVarVar_size_16,
		GetArrayElementVarVar_size_20,
		GetArrayElementVarVar_size_24,
		GetArrayElementVarVar_size_28,
		GetArrayElementVarVar_size_32,
		GetArrayElementVarVar_n,
		SetArrayElementVarVar_i1,
		SetArrayElementVarVar_u1,
		SetArrayElementVarVar_i2,
		SetArrayElementVarVar_u2,
		SetArrayElementVarVar_i4,
		SetArrayElementVarVar_u4,
		SetArrayElementVarVar_i8,
		SetArrayElementVarVar_u8,
		SetArrayElementVarVar_ref,
		SetArrayElementVarVar_size_12,
		SetArrayElementVarVar_size_16,
		SetArrayElementVarVar_n,
		SetArrayElementVarVar_WriteBarrier_n,
		NewMdArrVarVar_length,
		NewMdArrVarVar_length_bound,
		GetMdArrElementVarVar_i1,
		GetMdArrElementVarVar_u1,
		GetMdArrElementVarVar_i2,
		GetMdArrElementVarVar_u2,
		GetMdArrElementVarVar_i4,
		GetMdArrElementVarVar_u4,
		GetMdArrElementVarVar_i8,
		GetMdArrElementVarVar_u8,
		GetMdArrElementVarVar_n,
		GetMdArrElementAddressVarVar,
		SetMdArrElementVarVar_i1,
		SetMdArrElementVarVar_u1,
		SetMdArrElementVarVar_i2,
		SetMdArrElementVarVar_u2,
		SetMdArrElementVarVar_i4,
		SetMdArrElementVarVar_u4,
		SetMdArrElementVarVar_i8,
		SetMdArrElementVarVar_u8,
		SetMdArrElementVarVar_ref,
		SetMdArrElementVarVar_n,
		SetMdArrElementVarVar_WriteBarrier_n,
		ThrowEx,
		RethrowEx,
		LeaveEx,
		LeaveEx_Directly,
		EndFilterEx,
		EndFinallyEx,
		NullableNewVarVar,
		NullableCtorVarVar,
		NullableHasValueVar,
		NullableGetValueOrDefaultVarVar,
		NullableGetValueOrDefaultVarVar_1,
		NullableGetValueVarVar,
		InterlockedCompareExchangeVarVarVarVar_i4,
		InterlockedCompareExchangeVarVarVarVar_i8,
		InterlockedCompareExchangeVarVarVarVar_pointer,
		InterlockedExchangeVarVarVar_i4,
		InterlockedExchangeVarVarVar_i8,
		InterlockedExchangeVarVarVar_pointer,
		NewSystemObjectVar,
		NewVector2,
		NewVector3_2,
		NewVector3_3,
		NewVector4_2,
		NewVector4_3,
		NewVector4_4,
		CtorVector2,
		CtorVector3_2,
		CtorVector3_3,
		CtorVector4_2,
		CtorVector4_3,
		CtorVector4_4,
		ArrayGetGenericValueImpl,
		ArraySetGenericValueImpl,
		NewString,
		NewString_2,
		NewString_3,
		UnsafeEnumCast,
		GetEnumHashCode,
		AssemblyGetExecutingAssembly,
		MethodBaseGetCurrentMethod,

		//!!!}}OPCODE
	};

	struct IRCommon
	{
		HiOpcodeEnum type;
	};

#pragma region instruction
#pragma pack(push, 1)
	//!!!{{INST

	struct IRInitLocals_n_2 : IRCommon
	{
		uint16_t size;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitLocals_n_4 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t size;
	};


	struct IRInitLocals_size_8 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitLocals_size_16 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitLocals_size_24 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitLocals_size_32 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitInlineLocals_n_2 : IRCommon
	{
		uint16_t size;
		uint32_t offset;
	};


	struct IRInitInlineLocals_n_4 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t size;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRInitInlineLocals_size_8 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t offset;
	};


	struct IRInitInlineLocals_size_16 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t offset;
	};


	struct IRInitInlineLocals_size_24 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t offset;
	};


	struct IRInitInlineLocals_size_32 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t offset;
	};


	struct IRLdlocVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdlocExpandVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdlocExpandVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdlocExpandVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdlocExpandVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdlocVarVarSize : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint16_t size;
	};


	struct IRLdlocVarAddress : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdcVarConst_1 : IRCommon
	{
		uint8_t src;
		uint8_t __pad3;
		uint16_t dst;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdcVarConst_2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdcVarConst_4 : IRCommon
	{
		uint16_t dst;
		uint32_t src;
	};


	struct IRLdcVarConst_8 : IRCommon
	{
		uint16_t dst;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
		uint64_t src;
	};


	struct IRLdnullVar : IRCommon
	{
		uint16_t dst;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdindVarVar_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStindVarVar_ref : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLocalAllocVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLocalAllocVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitblkVarVarVar : IRCommon
	{
		uint16_t addr;
		uint16_t value;
		uint16_t size;
	};


	struct IRCpblkVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint16_t size;
	};


	struct IRMemoryBarrier : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i4_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u4_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_i8_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_u8_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f4_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertVarVar_f8_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i4_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u4_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_i8_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_u8_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f4_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRConvertOverflowVarVar_f8_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRBinOpVarVarVar_Add_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Sub_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Mul_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_MulUn_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Div_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_DivUn_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Rem_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_RemUn_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_And_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Or_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Xor_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Add_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Sub_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Mul_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_MulUn_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Div_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_DivUn_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Rem_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_RemUn_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_And_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Or_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Xor_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Add_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Sub_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Mul_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Div_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Rem_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Add_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Sub_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Mul_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Div_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpVarVarVar_Rem_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Add_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Sub_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Mul_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Add_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Sub_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Mul_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Add_u4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Sub_u4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Mul_u4 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Add_u8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Sub_u8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBinOpOverflowVarVarVar_Mul_u8 : IRCommon
	{
		uint16_t ret;
		uint16_t op1;
		uint16_t op2;
	};


	struct IRBitShiftBinOpVarVarVar_Shl_i4_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shr_i4_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_ShrUn_i4_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shl_i4_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shr_i4_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_ShrUn_i4_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shl_i8_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shr_i8_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_ShrUn_i8_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shl_i8_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_Shr_i8_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRBitShiftBinOpVarVarVar_ShrUn_i8_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t value;
		uint16_t shiftAmount;
	};


	struct IRUnaryOpVarVar_Neg_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRUnaryOpVarVar_Not_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRUnaryOpVarVar_Neg_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRUnaryOpVarVar_Not_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRUnaryOpVarVar_Neg_f4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRUnaryOpVarVar_Neg_f8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCheckFiniteVar_f4 : IRCommon
	{
		uint16_t src;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCheckFiniteVar_f8 : IRCommon
	{
		uint16_t src;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCompOpVarVarVar_Ceq_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Ceq_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Ceq_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Ceq_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Cgt_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Cgt_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Cgt_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Cgt_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CgtUn_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CgtUn_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CgtUn_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CgtUn_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Clt_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Clt_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Clt_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_Clt_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CltUn_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CltUn_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CltUn_f4 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRCompOpVarVarVar_CltUn_f8 : IRCommon
	{
		uint16_t ret;
		uint16_t c1;
		uint16_t c2;
	};


	struct IRBranchUncondition_4 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		int32_t offset;
	};


	struct IRBranchTrueVar_i4 : IRCommon
	{
		uint16_t op;
		int32_t offset;
	};


	struct IRBranchTrueVar_i8 : IRCommon
	{
		uint16_t op;
		int32_t offset;
	};


	struct IRBranchFalseVar_i4 : IRCommon
	{
		uint16_t op;
		int32_t offset;
	};


	struct IRBranchFalseVar_i8 : IRCommon
	{
		uint16_t op;
		int32_t offset;
	};


	struct IRBranchVarVar_Ceq_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Ceq_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Ceq_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Ceq_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CneUn_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CneUn_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CneUn_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CneUn_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cgt_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cgt_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cgt_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cgt_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgtUn_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgtUn_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgtUn_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgtUn_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cge_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cge_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cge_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cge_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgeUn_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgeUn_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgeUn_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CgeUn_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Clt_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Clt_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Clt_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Clt_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CltUn_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CltUn_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CltUn_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CltUn_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cle_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cle_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cle_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_Cle_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CleUn_i4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CleUn_i8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CleUn_f4 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchVarVar_CleUn_f8 : IRCommon
	{
		uint16_t op1;
		uint16_t op2;
		uint8_t __pad6;
		uint8_t __pad7;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRBranchJump : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t token;
	};


	struct IRBranchSwitch : IRCommon
	{
		uint16_t value;
		uint32_t caseNum;
		uint32_t caseOffsets;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewClassVar : IRCommon
	{
		uint16_t obj;
		uint32_t managed2NativeMethod;
		uint32_t method;
		uint32_t argIdxs;
	};


	struct IRNewClassVar_Ctor_0 : IRCommon
	{
		uint16_t obj;
		uint32_t method;
	};


	struct IRNewClassVar_NotCtor : IRCommon
	{
		uint16_t obj;
		uint32_t klass;
	};


	struct IRNewValueTypeVar : IRCommon
	{
		uint16_t obj;
		uint32_t managed2NativeMethod;
		uint32_t method;
		uint32_t argIdxs;
	};


	struct IRNewValueTypeVar_Ctor_0 : IRCommon
	{
		uint16_t obj;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRNewClassInterpVar : IRCommon
	{
		uint16_t obj;
		uint16_t argBase;
		uint16_t argStackObjectNum;
		uint16_t ctorFrameBase;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRNewClassInterpVar_Ctor_0 : IRCommon
	{
		uint16_t obj;
		uint16_t ctorFrameBase;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewValueTypeInterpVar : IRCommon
	{
		uint16_t obj;
		uint16_t argBase;
		uint16_t argStackObjectNum;
		uint16_t ctorFrameBase;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRAdjustValueTypeRefVar : IRCommon
	{
		uint16_t data;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRBoxRefVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdvirftnVarVar : IRCommon
	{
		uint16_t resultMethod;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t virtualMethod;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRRetVar_ret_1 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_2 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_4 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_8 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_12 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_16 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_20 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_24 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_28 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_32 : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRetVar_ret_n : IRCommon
	{
		uint16_t ret;
		uint32_t size;
	};


	struct IRRetVar_void : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCallNativeInstance_void : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallNativeInstance_ret : IRCommon
	{
		uint16_t ret;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallNativeInstance_ret_expand : IRCommon
	{
		uint8_t retLocationType;
		uint8_t __pad3;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallNativeStatic_void : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallNativeStatic_ret : IRCommon
	{
		uint16_t ret;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallNativeStatic_ret_expand : IRCommon
	{
		uint8_t retLocationType;
		uint8_t __pad3;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallInterp_void : IRCommon
	{
		uint16_t argBase;
		uint32_t methodInfo;
	};


	struct IRCallInterp_ret : IRCommon
	{
		uint16_t argBase;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t methodInfo;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallVirtual_void : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallVirtual_ret : IRCommon
	{
		uint16_t ret;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallVirtual_ret_expand : IRCommon
	{
		uint8_t retLocationType;
		uint8_t __pad3;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallInterpVirtual_void : IRCommon
	{
		uint16_t argBase;
		uint32_t method;
	};


	struct IRCallInterpVirtual_ret : IRCommon
	{
		uint16_t argBase;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallInd_void : IRCommon
	{
		uint8_t isMethodInfoPointer;
		uint8_t __pad3;
		uint32_t managed2NativeMethod;
		uint32_t managed2NativeFunctionPointerMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallInd_ret : IRCommon
	{
		uint8_t isMethodInfoPointer;
		uint8_t __pad3;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t managed2NativeMethod;
		uint32_t managed2NativeFunctionPointerMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallInd_ret_expand : IRCommon
	{
		uint8_t isMethodInfoPointer;
		uint8_t retLocationType;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t managed2NativeMethod;
		uint32_t managed2NativeFunctionPointerMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};


	struct IRCallPInvoke_void : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t managed2NativeFunctionPointerMethod;
		uint32_t pinvokeMethodPointer;
		uint32_t argIdxs;
	};


	struct IRCallPInvoke_ret : IRCommon
	{
		uint16_t ret;
		uint32_t managed2NativeFunctionPointerMethod;
		uint32_t pinvokeMethodPointer;
		uint32_t argIdxs;
	};


	struct IRCallPInvoke_ret_expand : IRCommon
	{
		uint8_t retLocationType;
		uint8_t __pad3;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t managed2NativeFunctionPointerMethod;
		uint32_t pinvokeMethodPointer;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallDelegateInvoke_void : IRCommon
	{
		uint16_t invokeParamCount;
		uint32_t managed2NativeStaticMethod;
		uint32_t managed2NativeInstanceMethod;
		uint32_t argIdxs;
	};


	struct IRCallDelegateInvoke_ret : IRCommon
	{
		uint16_t ret;
		uint16_t invokeParamCount;
		uint16_t retTypeStackObjectSize;
		uint32_t managed2NativeStaticMethod;
		uint32_t managed2NativeInstanceMethod;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallDelegateInvoke_ret_expand : IRCommon
	{
		uint8_t retLocationType;
		uint8_t __pad3;
		uint16_t ret;
		uint16_t invokeParamCount;
		uint32_t managed2NativeStaticMethod;
		uint32_t managed2NativeInstanceMethod;
		uint32_t argIdxs;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallDelegateBeginInvoke : IRCommon
	{
		uint16_t result;
		uint32_t methodInfo;
		uint32_t argIdxs;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallDelegateEndInvoke_void : IRCommon
	{
		uint16_t asyncResult;
		uint32_t methodInfo;
	};


	struct IRCallDelegateEndInvoke_ret : IRCommon
	{
		uint16_t asyncResult;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t methodInfo;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewDelegate : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t method;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCtorDelegate : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t method;
		uint32_t ctor;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_0 : IRCommon
	{
		uint16_t self;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i1_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_u1_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i2_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_u2_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i4_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i8_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f4_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f8_0 : IRCommon
	{
		uint16_t self;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_i4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_i4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_i4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_i4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_i8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_i8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_i8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_i8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_f4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_f4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_f4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_f4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_f8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_f8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_v_f8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_v_f8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_i4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_u1_i4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_i4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_i4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_u1_i8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_u1_i8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_i8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_i8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_u1_f4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_u1_f4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_f4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_f4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_u1_f8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_u1_f8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_f8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_u1_f8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i4_i4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i4_i4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_i4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_i4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i4_i8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i4_i8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_i8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_i8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i4_f4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i4_f4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_f4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_f4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i4_f8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i4_f8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_f8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i4_f8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i8_i4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i8_i4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_i4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_i4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i8_i8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i8_i8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_i8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_i8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i8_f4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i8_f4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_f4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_f4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_i8_f8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_i8_f8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_f8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_i8_f8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f4_i4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f4_i4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_i4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_i4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f4_i8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f4_i8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_i8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_i8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f4_f4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f4_f4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_f4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_f4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f4_f8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f4_f8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_f8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f4_f8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f8_i4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f8_i4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_i4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_i4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f8_i8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f8_i8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_i8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_i8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f8_f4_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f8_f4_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_f4_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_f4_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeInstance_f8_f8_1 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeInstance_f8_f8_2 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_f8_3 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeInstance_f8_f8_4 : IRCommon
	{
		uint16_t self;
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint8_t __pad14;
		uint8_t __pad15;
		uint32_t method;
		uint8_t __pad20;
		uint8_t __pad21;
		uint8_t __pad22;
		uint8_t __pad23;
	};


	struct IRCallCommonNativeStatic_v_0 : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i1_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i2_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u2_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_0 : IRCommon
	{
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_i4_1 : IRCommon
	{
		uint16_t param0;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_i4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_i4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_i4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_i8_1 : IRCommon
	{
		uint16_t param0;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_i8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_i8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_i8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_f4_1 : IRCommon
	{
		uint16_t param0;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_f4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_f4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_f4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_f8_1 : IRCommon
	{
		uint16_t param0;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_v_f8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_f8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_v_f8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_i4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_i4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_i4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_i4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_i8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_i8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_i8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_i8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_f4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_f4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_f4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_f4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_f8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_f8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_u1_f8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_u1_f8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_i4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_i4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_i4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_i4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_i8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_i8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_i8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_i8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_f4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_f4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_f4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_f4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_f8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_f8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i4_f8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i4_f8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_i4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_i4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_i4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_i4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_i8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_i8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_i8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_i8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_f4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_f4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_f4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_f4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_f8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_f8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_i8_f8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_i8_f8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_i4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_i4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_i4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_i4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_i8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_i8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_i8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_i8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_f4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_f4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_f4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_f4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_f8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_f8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f4_f8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f4_f8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_i4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_i4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_i4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_i4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_i8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_i8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_i8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_i8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_f4_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_f4_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_f4_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_f4_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_f8_1 : IRCommon
	{
		uint16_t param0;
		uint16_t ret;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_f8_2 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t ret;
		uint32_t method;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCallCommonNativeStatic_f8_f8_3 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t ret;
		uint8_t __pad10;
		uint8_t __pad11;
		uint32_t method;
	};


	struct IRCallCommonNativeStatic_f8_f8_4 : IRCommon
	{
		uint16_t param0;
		uint16_t param1;
		uint16_t param2;
		uint16_t param3;
		uint16_t ret;
		uint32_t method;
	};


	struct IRBoxVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRUnBoxVarVar : IRCommon
	{
		uint16_t addr;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRUnBoxAnyVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCastclassVar : IRCommon
	{
		uint16_t obj;
		uint32_t klass;
	};


	struct IRIsInstVar : IRCommon
	{
		uint16_t obj;
		uint32_t klass;
	};


	struct IRLdtokenVar : IRCommon
	{
		uint16_t runtimeHandle;
		uint32_t token;
	};


	struct IRMakeRefVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRRefAnyTypeVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t typedRef;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRefAnyValueVarVar : IRCommon
	{
		uint16_t addr;
		uint16_t typedRef;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCpobjVarVar_ref : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_12 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_16 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_20 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_24 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_28 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_32 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRCpobjVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint16_t size;
	};


	struct IRCpobjVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCpobjVarVar_WriteBarrier_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint16_t size;
	};


	struct IRCpobjVarVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdobjVarVar_ref : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_12 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_16 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_20 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_24 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_28 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_32 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLdobjVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStobjVarVar_ref : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_1 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_2 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_8 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_12 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_16 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_20 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_24 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_28 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_32 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRStobjVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStobjVarVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRInitobjVar_ref : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_1 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_2 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_4 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_8 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_12 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_16 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_20 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_24 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_28 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_32 : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_n_2 : IRCommon
	{
		uint16_t obj;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_n_4 : IRCommon
	{
		uint16_t obj;
		uint32_t size;
	};


	struct IRInitobjVar_WriteBarrier_n_2 : IRCommon
	{
		uint16_t obj;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitobjVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t obj;
		uint32_t size;
	};


	struct IRLdstrVar : IRCommon
	{
		uint16_t dst;
		uint32_t str;
	};


	struct IRLdfldVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
		uint16_t size;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRLdfldValueTypeVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
		uint16_t size;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldaVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t offset;
	};


	struct IRStfldVarVar_i1 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_u1 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_i2 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_u2 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_i4 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_u4 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_i8 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_u8 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_ref : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_8 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_12 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_16 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_20 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_24 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_28 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_size_32 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
	};


	struct IRStfldVarVar_n_2 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
		uint16_t size;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldVarVar_n_4 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldVarVar_WriteBarrier_n_2 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
		uint16_t size;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldVarVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t obj;
		uint16_t offset;
		uint16_t data;
		uint32_t size;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint32_t offset;
	};


	struct IRLdsfldVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint32_t size;
	};


	struct IRStsfldVarVar_i1 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_u1 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_i2 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_u2 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_i4 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_u4 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_i8 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_u8 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_ref : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_8 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_12 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_16 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_20 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_24 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_28 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_size_32 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStsfldVarVar_n_2 : IRCommon
	{
		uint16_t data;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint32_t offset;
	};


	struct IRStsfldVarVar_n_4 : IRCommon
	{
		uint16_t data;
		uint32_t klass;
		uint32_t offset;
		uint32_t size;
	};


	struct IRStsfldVarVar_WriteBarrier_n_2 : IRCommon
	{
		uint16_t data;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint32_t offset;
	};


	struct IRStsfldVarVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t data;
		uint32_t klass;
		uint32_t offset;
		uint32_t size;
	};


	struct IRLdsfldaVarVar : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdsfldaFromFieldDataVarVar : IRCommon
	{
		uint16_t dst;
		uint32_t src;
	};


	struct IRLdthreadlocalaVarVar : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdthreadlocalVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		int32_t offset;
	};


	struct IRLdthreadlocalVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint32_t klass;
		int32_t offset;
		uint32_t size;
	};


	struct IRStthreadlocalVarVar_i1 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_u1 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_i2 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_u2 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_i4 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_u4 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_i8 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_u8 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_ref : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_8 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_12 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_16 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_20 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_24 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_28 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_size_32 : IRCommon
	{
		uint16_t data;
		uint32_t offset;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStthreadlocalVarVar_n_2 : IRCommon
	{
		uint16_t data;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint32_t offset;
	};


	struct IRStthreadlocalVarVar_n_4 : IRCommon
	{
		uint16_t data;
		uint32_t klass;
		uint32_t offset;
		uint32_t size;
	};


	struct IRStthreadlocalVarVar_WriteBarrier_n_2 : IRCommon
	{
		uint16_t data;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint32_t offset;
	};


	struct IRStthreadlocalVarVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t data;
		uint32_t klass;
		uint32_t offset;
		uint32_t size;
	};


	struct IRCheckThrowIfNullVar : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRInitClassStaticCtor : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
		uint64_t klass;
	};


	struct IRLdfldaLargeVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t size;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldLargeVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint32_t size;
	};


	struct IRLdfldValueTypeLargeVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_n_2 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t size;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRLdfldValueTypeLargeVarVar_n_4 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint32_t size;
	};


	struct IRStfldLargeVarVar_i1 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_u1 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_i2 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_u2 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_i4 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_u4 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_i8 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_u8 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_ref : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_8 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_12 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_16 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_20 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_24 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_28 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_size_32 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_n_2 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint16_t size;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_n_4 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint32_t size;
	};


	struct IRStfldLargeVarVar_WriteBarrier_n_2 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint16_t size;
		uint32_t offset;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRStfldLargeVarVar_WriteBarrier_n_4 : IRCommon
	{
		uint16_t obj;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t offset;
		uint32_t size;
	};


	struct IRNewArrVarVar : IRCommon
	{
		uint16_t arr;
		uint16_t size;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRGetArrayLengthVarVar : IRCommon
	{
		uint16_t len;
		uint16_t arr;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRGetArrayElementAddressAddrVarVar : IRCommon
	{
		uint16_t addr;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementAddressCheckAddrVarVar : IRCommon
	{
		uint16_t addr;
		uint16_t arr;
		uint16_t index;
		uint32_t eleKlass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRGetArrayElementVarVar_i1 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_u1 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_i2 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_u2 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_i4 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_u4 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_i8 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_u8 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_1 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_2 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_4 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_8 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_12 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_16 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_20 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_24 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_28 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_size_32 : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRGetArrayElementVarVar_n : IRCommon
	{
		uint16_t dst;
		uint16_t arr;
		uint16_t index;
	};


	struct IRSetArrayElementVarVar_i1 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_u1 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_i2 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_u2 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_i4 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_u4 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_i8 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_u8 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_ref : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_size_12 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_size_16 : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_n : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRSetArrayElementVarVar_WriteBarrier_n : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t ele;
	};


	struct IRNewMdArrVarVar_length : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewMdArrVarVar_length_bound : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t lowerBoundIdxs;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRGetMdArrElementVarVar_i1 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_u1 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_i2 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_u2 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_i4 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_u4 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_i8 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_u8 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementVarVar_n : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t value;
	};


	struct IRGetMdArrElementAddressVarVar : IRCommon
	{
		uint16_t addr;
		uint16_t arr;
		uint16_t lengthIdxs;
	};


	struct IRSetMdArrElementVarVar_i1 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_u1 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_i2 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_u2 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_i4 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_u4 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_i8 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_u8 : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_ref : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_n : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRSetMdArrElementVarVar_WriteBarrier_n : IRCommon
	{
		uint16_t arr;
		uint16_t lengthIdxs;
		uint16_t ele;
	};


	struct IRThrowEx : IRCommon
	{
		uint16_t exceptionObj;
		uint16_t firstHandlerIndex;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRRethrowEx : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRLeaveEx : IRCommon
	{
		uint16_t firstHandlerIndex;
		int32_t target;
	};


	struct IRLeaveEx_Directly : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		int32_t target;
	};


	struct IREndFilterEx : IRCommon
	{
		uint16_t value;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IREndFinallyEx : IRCommon
	{
		uint8_t __pad2;
		uint8_t __pad3;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRNullableNewVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNullableCtorVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t data;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNullableHasValueVar : IRCommon
	{
		uint16_t result;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNullableGetValueOrDefaultVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNullableGetValueOrDefaultVarVar_1 : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint16_t defaultValue;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNullableGetValueVarVar : IRCommon
	{
		uint16_t dst;
		uint16_t obj;
		uint8_t __pad6;
		uint8_t __pad7;
		uint32_t klass;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRInterlockedCompareExchangeVarVarVarVar_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t location;
		uint16_t value;
		uint16_t comparand;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRInterlockedCompareExchangeVarVarVarVar_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t location;
		uint16_t value;
		uint16_t comparand;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRInterlockedCompareExchangeVarVarVarVar_pointer : IRCommon
	{
		uint16_t ret;
		uint16_t location;
		uint16_t value;
		uint16_t comparand;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRInterlockedExchangeVarVarVar_i4 : IRCommon
	{
		uint16_t ret;
		uint16_t location;
		uint16_t value;
	};


	struct IRInterlockedExchangeVarVarVar_i8 : IRCommon
	{
		uint16_t ret;
		uint16_t location;
		uint16_t value;
	};


	struct IRInterlockedExchangeVarVarVar_pointer : IRCommon
	{
		uint16_t ret;
		uint16_t location;
		uint16_t value;
	};


	struct IRNewSystemObjectVar : IRCommon
	{
		uint16_t obj;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRNewVector2 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
	};


	struct IRNewVector3_2 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
	};


	struct IRNewVector3_3 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
		uint16_t z;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewVector4_2 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
	};


	struct IRNewVector4_3 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
		uint16_t z;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewVector4_4 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
		uint16_t z;
		uint16_t w;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCtorVector2 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
	};


	struct IRCtorVector3_2 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
	};


	struct IRCtorVector3_3 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
		uint16_t z;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCtorVector4_2 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
	};


	struct IRCtorVector4_3 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
		uint16_t z;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRCtorVector4_4 : IRCommon
	{
		uint16_t obj;
		uint16_t x;
		uint16_t y;
		uint16_t z;
		uint16_t w;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRArrayGetGenericValueImpl : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t value;
	};


	struct IRArraySetGenericValueImpl : IRCommon
	{
		uint16_t arr;
		uint16_t index;
		uint16_t value;
	};


	struct IRNewString : IRCommon
	{
		uint16_t str;
		uint16_t chars;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRNewString_2 : IRCommon
	{
		uint16_t str;
		uint16_t chars;
		uint16_t startIndex;
		uint16_t length;
		uint8_t __pad10;
		uint8_t __pad11;
		uint8_t __pad12;
		uint8_t __pad13;
		uint8_t __pad14;
		uint8_t __pad15;
	};


	struct IRNewString_3 : IRCommon
	{
		uint16_t str;
		uint16_t c;
		uint16_t count;
	};


	struct IRUnsafeEnumCast : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint16_t srcType;
	};


	struct IRGetEnumHashCode : IRCommon
	{
		uint16_t dst;
		uint16_t src;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRAssemblyGetExecutingAssembly : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	struct IRMethodBaseGetCurrentMethod : IRCommon
	{
		uint16_t ret;
		uint8_t __pad4;
		uint8_t __pad5;
		uint8_t __pad6;
		uint8_t __pad7;
	};


	//!!!}}INST
#pragma pack(pop)

#pragma endregion

}
}
```

`hybridclr/interpreter/Interpreter.cpp`:

```cpp

#include "Interpreter.h"

#include <unordered_map>

#include "vm/GlobalMetadata.h"
#include "vm/MetadataLock.h"
#include "vm/Class.h"

#include "MethodBridge.h"
#include "../metadata/MetadataModule.h"
#include "../metadata/MetadataUtil.h"
#include "../transform/Transform.h"




namespace hybridclr
{
namespace interpreter
{


}
}
```

`hybridclr/interpreter/Interpreter.h`:

```h
#pragma once

#include "InterpreterDefs.h"

namespace hybridclr
{

namespace interpreter
{

	class Interpreter
	{
	public:

		static void Execute(const MethodInfo* methodInfo, StackObject* args, void* ret);

	};

}
}


```

`hybridclr/interpreter/InterpreterDefs.cpp`:

```cpp

#include "../metadata/MetadataUtil.h"

#include "MemoryUtil.h"


namespace hybridclr
{
namespace interpreter
{

}
}
```

`hybridclr/interpreter/InterpreterDefs.h`:

```h
#pragma once
#include "../CommonDef.h"
#include "../metadata/MetadataDef.h"

namespace hybridclr
{
	namespace interpreter
	{

		// from obj or arg
		enum class LocationDataType : uint8_t
		{
			I1,
			U1,
			I2,
			U2,
			U8,
			S_N,  // struct size = 3，5，6，7， > 8, size is described by stackObjectSize
		};

		union StackObject
		{
			uint64_t __u64;
			void* ptr; // can't adjust position. will raise native_invoke init args bugs.
			bool b;
			int8_t i8;
			uint8_t u8;
			int16_t i16;
			uint16_t u16;
			int32_t i32;
			uint32_t u32;
			int64_t i64;
			uint64_t u64;
			float f4;
			double f8;
			Il2CppObject* obj;
			Il2CppString* str;
			Il2CppObject** ptrObj;
		};

		static_assert(sizeof(StackObject) == 8, "require 8 bytes");


		enum class ExceptionFlowType
		{
			Exception,
			Catch,
			Leave,
		};

		struct InterpMethodInfo;

		struct ExceptionFlowInfo
		{
			ExceptionFlowType exFlowType;
			int32_t throwOffset;
			Il2CppException* ex;
			int32_t nextExClauseIndex;
			int32_t leaveTarget;
		};

		struct InterpFrame
		{
			const MethodInfo* method;
			StackObject* stackBasePtr;
			int32_t oldStackTop;
			void* ret;
			byte* ip;

			ExceptionFlowInfo* exFlowBase;
			int32_t exFlowCount;
			int32_t exFlowCapaticy;

			int32_t oldLocalPoolBottomIdx;

			ExceptionFlowInfo* GetCurExFlow() const
			{
				return exFlowCount > 0 ? exFlowBase + exFlowCount - 1 : nullptr;
			}

			ExceptionFlowInfo* GetPrevExFlow() const
			{
				return exFlowCount > 1 ? exFlowBase + exFlowCount - 2 : nullptr;
			}
		};

		struct InterpExceptionClause
		{
			metadata::CorILExceptionClauseType flags;
			int32_t tryBeginOffset;
			int32_t tryEndOffset;
			int32_t handlerBeginOffset;
			int32_t handlerEndOffset;
			int32_t filterBeginOffset;
			Il2CppClass* exKlass;
		};

		struct MethodArgDesc
		{
			bool passbyValWhenInvoke;
			LocationDataType type;
			uint16_t stackObjectSize;
		};

		struct InterpMethodInfo
		{
			byte* codes;
			MethodArgDesc* args;
			uint64_t* resolveDatas;
			const InterpExceptionClause* exClauses;
			uint32_t argStackObjectSize;
			uint32_t retStackObjectSize : 24;
			uint32_t initLocals : 8;
			uint32_t localStackSize; // args + locals StackObject size
			uint32_t maxStackSize; // args + locals + evalstack size
			uint32_t argCount : 8;
			uint32_t codeLength : 24;
			uint32_t localVarBaseOffset;
			uint32_t evalStackBaseOffset;
			uint32_t exClauseCount;
		};
	}
}
```

`hybridclr/interpreter/InterpreterModule.cpp`:

```cpp
#include "InterpreterModule.h"

#include "Interpreter.h"

#include <unordered_map>
#include <unordered_set>

#include "Baselib.h"
#include "vm/GlobalMetadata.h"
#include "vm/MetadataCache.h"
#include "vm/MetadataLock.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/Method.h"

#include "../metadata/MetadataModule.h"
#include "../metadata/MetadataUtil.h"
#include "../metadata/InterpreterImage.h"
#include "../transform/Transform.h"

#include "MethodBridge.h"
#include "InterpreterUtil.h"

namespace hybridclr
{
namespace interpreter
{
	il2cpp::os::ThreadLocalValue InterpreterModule::s_machineState;

	static Il2CppHashMap<const char*, Managed2NativeCallMethod, CStringHash, CStringEqualTo> s_managed2natives;
	static Il2CppHashMap<const char*, Il2CppMethodPointer, CStringHash, CStringEqualTo> s_native2manageds;
	static Il2CppHashMap<const char*, Il2CppMethodPointer, CStringHash, CStringEqualTo> s_adjustThunks;
	static Il2CppHashMap<const char*, const char*, CStringHash, CStringEqualTo> s_fullName2signature;

	static Il2CppHashMap<const MethodInfo*, const ReversePInvokeInfo*, il2cpp::utils::PointerHash<MethodInfo>> s_methodInfo2ReverseInfos;
	static Il2CppHashMap<Il2CppMethodPointer, const ReversePInvokeInfo*, il2cpp::utils::PassThroughHash<Il2CppMethodPointer>> s_methodPointer2ReverseInfos;
	static Il2CppHashMap<const char*, int32_t, CStringHash, CStringEqualTo> s_methodSig2Indexs;
	static std::vector<ReversePInvokeInfo> s_reverseInfos;

	static Il2CppHashMap<const char*, Managed2NativeFunctionPointerCallMethod, CStringHash, CStringEqualTo> s_managed2nativeFunctionPointers;

	static std::unordered_map<void*, bool> s_functionPointerMap;

	static baselib::ReentrantLock s_reversePInvokeMethodLock;

	const MethodInfo* InterpreterModule::GetMethodInfoByReversePInvokeWrapperIndex(int32_t index)
	{
		return s_reverseInfos[index].methodInfo;
	}

	const MethodInfo* InterpreterModule::GetMethodInfoByReversePInvokeWrapperMethodPointer(Il2CppMethodPointer methodPointer)
	{
		auto it = s_methodPointer2ReverseInfos.find(methodPointer);
		return it != s_methodPointer2ReverseInfos.end() ? it->second->methodInfo : nullptr;
	}

	int32_t InterpreterModule::GetWrapperIndexByReversePInvokeWrapperMethodPointer(Il2CppMethodPointer methodPointer)
	{
		auto it = s_methodPointer2ReverseInfos.find(methodPointer);
		return it != s_methodPointer2ReverseInfos.end() ? it->second->index : -1;
	}

	static void InitReversePInvokeInfo()
	{
		for (int32_t i = 0; ; i++)
		{
			const ReversePInvokeMethodData& data = g_reversePInvokeMethodStub[i];
			if (data.methodPointer == nullptr)
			{
				break;
			}
			s_reverseInfos.push_back({ i, data.methodPointer, nullptr });
			auto it = s_methodSig2Indexs.find(data.methodSig);
			if (it == s_methodSig2Indexs.end())
			{
				s_methodSig2Indexs.insert({ data.methodSig, i });
			}
		}
		s_methodInfo2ReverseInfos.resize(s_reverseInfos.size() * 2);
		s_methodPointer2ReverseInfos.resize(s_reverseInfos.size() * 2);
		for (ReversePInvokeInfo& rpi : s_reverseInfos)
		{
			s_methodPointer2ReverseInfos.insert({ rpi.methodPointer, &rpi });
		}
	}

    constexpr int32_t kMaxSignatureNameLength = 1024 * 4;

	Il2CppMethodPointer InterpreterModule::GetReversePInvokeWrapper(const Il2CppImage* image, const MethodInfo* method, Il2CppCallConvention callConvention)
	{
		if (!hybridclr::metadata::IsStaticMethod(method))
		{
			return nullptr;
		}

		{
			il2cpp::os::FastAutoLock lock(&s_reversePInvokeMethodLock);
			auto it = s_methodInfo2ReverseInfos.find(method);
			if (it != s_methodInfo2ReverseInfos.end())
			{
				return it->second->methodPointer;
			}
		}

		char sigName[kMaxSignatureNameLength];
		sigName[0] = 'A' + callConvention;
		ComputeSignature(method, false, sigName + 1, sizeof(sigName) - 2);

		il2cpp::os::FastAutoLock lock(&s_reversePInvokeMethodLock);


		auto it = s_methodInfo2ReverseInfos.find(method);
		if (it != s_methodInfo2ReverseInfos.end())
		{
			return it->second->methodPointer;
		}

		auto it2 = s_methodSig2Indexs.find(sigName);
		if (it2 == s_methodSig2Indexs.end())
		{
			TEMP_FORMAT(methodSigBuf, "GetReversePInvokeWrapper fail. not find wrapper of method:%s", GetMethodNameWithSignature(method).c_str());
			RaiseExecutionEngineException(methodSigBuf);
		}
		int32_t wrapperIndex = it2->second;
		const ReversePInvokeMethodData& data = g_reversePInvokeMethodStub[wrapperIndex];
		if (data.methodPointer == nullptr || std::strcmp(data.methodSig, sigName))
		{
			TEMP_FORMAT(methodSigBuf, "GetReversePInvokeWrapper fail. exceed max wrapper num of method:%s", GetMethodNameWithSignature(method).c_str());
			RaiseExecutionEngineException(methodSigBuf);
		}

		s_methodSig2Indexs[sigName] = wrapperIndex + 1;

		ReversePInvokeInfo& rpi = s_reverseInfos[wrapperIndex];
		rpi.methodInfo = method;
		s_methodInfo2ReverseInfos.insert({ method, &rpi });
		return rpi.methodPointer;
	}

	static void InitMethodBridge()
	{
		for (size_t i = 0; ; i++)
		{
			const Managed2NativeMethodInfo& method = g_managed2nativeStub[i];
			if (!method.signature)
			{
				break;
			}
			s_managed2natives.insert({ method.signature, method.method });
		}
		for (size_t i = 0; ; i++)
		{
			const Native2ManagedMethodInfo& method = g_native2managedStub[i];
			if (!method.signature)
			{
				break;
			}
			s_native2manageds.insert({ method.signature, method.method });
		}

		for (size_t i = 0; ; i++)
		{
			const NativeAdjustThunkMethodInfo& method = g_adjustThunkStub[i];
			if (!method.signature)
			{
				break;
			}
			s_adjustThunks.insert({ method.signature, method.method });
		}
		for (size_t i = 0; ; i++)
		{
			const FullName2Signature& nameSig = g_fullName2SignatureStub[i];
			if (!nameSig.fullName)
			{
				break;
			}
			s_fullName2signature.insert({ nameSig.fullName, nameSig.signature });
		}
		for (size_t i = 0; ; i++)
		{
			const Managed2NativeFunctionPointerCallData& method = g_managed2NativeFunctionPointerCallStub[i];
			if (!method.methodSig)
			{
				break;
			}
			s_managed2nativeFunctionPointers.insert({ method.methodSig, method.methodPointer });
		}
	}

	void InterpreterModule::Initialize()
	{
		InitMethodBridge();
		InitReversePInvokeInfo();
	}

	void InterpreterModule::NotSupportNative2Managed()
	{
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException("NotSupportNative2Managed"));
	}

	void InterpreterModule::NotSupportAdjustorThunk()
	{
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException("NotSupportAdjustorThunk"));
	}

	const char* InterpreterModule::GetValueTypeSignature(const char* fullName)
	{
		auto it = s_fullName2signature.find(fullName);
		return it != s_fullName2signature.end() ? it->second : "$";
	}

	bool InterpreterModule::IsMethodInfoPointer(void* pointer)
	{
		il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);
		return il2cpp::vm::MetadataContains(pointer);
	}

	static void* NotSupportInvoke(Il2CppMethodPointer, const MethodInfo* method, void*, void**)
	{
		char sigName[kMaxSignatureNameLength];
		ComputeSignature(method, true, sigName, sizeof(sigName) - 1);
		TEMP_FORMAT(errMsg, "Invoke method missing. sinature:%s %s.%s::%s", sigName, method->klass->namespaze, method->klass->name, method->name);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(errMsg));
		return nullptr;
	}

	static void NotSupportManaged2NativeFunctionMethod(Il2CppMethodPointer methodPointer, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret)
	{
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException("NotSupportManaged2NativeFunctionMethod"));
	}

	template<typename T>
	const Managed2NativeCallMethod GetManaged2NativeMethod(const T* method, bool forceStatic)
	{
		char sigName[kMaxSignatureNameLength];
		ComputeSignature(method, !forceStatic, sigName, sizeof(sigName) - 1);
		auto it = s_managed2natives.find(sigName);
		return it != s_managed2natives.end() ? it->second : nullptr;
	}

	template<typename T>
	const Il2CppMethodPointer GetNative2ManagedMethod(const T* method, bool forceStatic)
	{
		char sigName[kMaxSignatureNameLength];
		ComputeSignature(method, !forceStatic, sigName, sizeof(sigName) - 1);
		auto it = s_native2manageds.find(sigName);
		return it != s_native2manageds.end() ? it->second : InterpreterModule::NotSupportNative2Managed;
	}

	template<typename T>
	const Il2CppMethodPointer GetNativeAdjustMethodMethod(const T* method, bool forceStatic)
	{
		char sigName[kMaxSignatureNameLength];
		ComputeSignature(method, !forceStatic, sigName, sizeof(sigName) - 1);
		auto it = s_adjustThunks.find(sigName);
		return it != s_adjustThunks.end() ? it->second : InterpreterModule::NotSupportAdjustorThunk;
	}

	static void RaiseMethodNotSupportException(const MethodInfo* method, const char* desc)
	{
		TEMP_FORMAT(errMsg, "%s. %s.%s::%s", desc, method->klass->namespaze, method->klass->name, method->name);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(errMsg));
	}

	static void RaiseMethodNotSupportException(const Il2CppMethodDefinition* method, const char* desc)
	{
		Il2CppClass* klass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeDefinitionIndex(method->declaringType);
		TEMP_FORMAT(errMsg, "%s. %s.%s::%s", desc, klass->namespaze, klass->name, il2cpp::vm::GlobalMetadata::GetStringFromIndex(method->nameIndex));
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(errMsg));
	}

	Il2CppMethodPointer InterpreterModule::GetMethodPointer(const Il2CppMethodDefinition* method)
	{
		Il2CppMethodPointer ncm = GetNative2ManagedMethod(method, false);
		return ncm ? ncm : (Il2CppMethodPointer)NotSupportNative2Managed;
	}

	Il2CppMethodPointer InterpreterModule::GetMethodPointer(const MethodInfo* method)
	{
		Il2CppMethodPointer ncm = GetNative2ManagedMethod(method, false);
		return ncm ? ncm : (Il2CppMethodPointer)NotSupportNative2Managed;
	}

	Il2CppMethodPointer InterpreterModule::GetAdjustThunkMethodPointer(const Il2CppMethodDefinition* method)
	{
		return GetNativeAdjustMethodMethod(method, false);
	}

	Il2CppMethodPointer InterpreterModule::GetAdjustThunkMethodPointer(const MethodInfo* method)
	{
		return GetNativeAdjustMethodMethod(method, false);
	}

	void InterpreterModule::Managed2NativeCallByReflectionInvoke(const MethodInfo* method, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret)
	{
		if (hybridclr::metadata::IsInterpreterImplement(method))
		{
			Interpreter::Execute(method,  localVarBase + argVarIndexs[0], ret);
			return;
		}
		if (method->invoker_method == nullptr)
		{
			char sigName[kMaxSignatureNameLength];
			ComputeSignature(method, true, sigName, sizeof(sigName) - 1);

			TEMP_FORMAT(errMsg, "GetManaged2NativeMethodPointer. sinature:%s not support.", sigName);
			RaiseMethodNotSupportException(method, errMsg);
		}
		if (!InitAndGetInterpreterDirectlyCallMethodPointer(method))
		{
			RaiseAOTGenericMethodNotInstantiatedException(method);
		}
		void* thisPtr;
		uint16_t* argVarIndexBase;
		if (hybridclr::metadata::IsInstanceMethod(method))
		{
			thisPtr = localVarBase[argVarIndexs[0]].obj;
			argVarIndexBase = argVarIndexs + 1;
		}
		else
		{
			thisPtr = nullptr;
			argVarIndexBase = argVarIndexs;
		}
		void* invokeParams[256];
		for (uint8_t i = 0; i < method->parameters_count; i++)
		{
			const Il2CppType* argType = GET_METHOD_PARAMETER_TYPE(method->parameters[i]);
			StackObject* argValue = localVarBase + argVarIndexBase[i];
			if (!argType->byref && hybridclr::metadata::IsValueType(argType))
			{
				invokeParams[i] = argValue;
			}
			else
			{
				invokeParams[i] = argValue->ptr;
			}
		}
#if HYBRIDCLR_UNITY_2021_OR_NEW
		method->invoker_method(method->methodPointerCallByInterp, method, thisPtr, invokeParams, ret);
#else
		void* retObj = method->invoker_method(method->methodPointerCallByInterp, method, thisPtr, invokeParams);
		if (ret)
		{
			const Il2CppType* returnType = method->return_type;
			if (hybridclr::metadata::IsValueType(returnType))
			{
				Il2CppClass* returnKlass = il2cpp::vm::Class::FromIl2CppType(returnType);
				if (il2cpp::vm::Class::IsNullable(returnKlass))
				{
					il2cpp::vm::Object::UnboxNullable((Il2CppObject*)retObj, returnKlass->element_class, ret);
				}
				else
				{
					std::memcpy(ret, il2cpp::vm::Object::Unbox((Il2CppObject*)retObj), il2cpp::vm::Class::GetValueSize(returnKlass, nullptr));
				}
			}
			else
			{
				*(void**)ret = retObj;
			}
		}
#endif
	}

	Managed2NativeCallMethod InterpreterModule::GetManaged2NativeMethodPointer(const MethodInfo* method, bool forceStatic)
	{
		if (method->methodPointerCallByInterp == NotSupportNative2Managed 
#if HYBRIDCLR_UNITY_2021_OR_NEW
			|| method->has_full_generic_sharing_signature
#endif
			)
		{
			return Managed2NativeCallByReflectionInvoke;
		}
		char sigName[kMaxSignatureNameLength];
		ComputeSignature(method, !forceStatic, sigName, sizeof(sigName) - 1);
		auto it = s_managed2natives.find(sigName);
		return it != s_managed2natives.end() ? it->second : Managed2NativeCallByReflectionInvoke;
	}

	Managed2NativeCallMethod InterpreterModule::GetManaged2NativeMethodPointer(const metadata::ResolveStandAloneMethodSig& method)
	{
		char sigName[kMaxSignatureNameLength];
		ComputeSignature(method.returnType, method.params, metadata::IsPrologHasThis(method.flags), sigName, sizeof(sigName) - 1);
		auto it = s_managed2natives.find(sigName);
		return it != s_managed2natives.end() ? it->second : Managed2NativeCallByReflectionInvoke;
	}

	Managed2NativeFunctionPointerCallMethod InterpreterModule::GetManaged2NativeFunctionPointerMethodPointer(const MethodInfo* method, Il2CppCallConvention callConvention)
	{
		char sigName[kMaxSignatureNameLength];
		sigName[0] = 'A' + callConvention;
		ComputeSignature(method, false, sigName + 1, sizeof(sigName) - 1);
		auto it = s_managed2nativeFunctionPointers.find(sigName);
		return it != s_managed2nativeFunctionPointers.end() ? it->second : NotSupportManaged2NativeFunctionMethod;
	}

	Managed2NativeFunctionPointerCallMethod InterpreterModule::GetManaged2NativeFunctionPointerMethodPointer(const metadata::ResolveStandAloneMethodSig& method)
	{
		int32_t callConvention = method.flags & 0x7;
		char sigName[kMaxSignatureNameLength];
		sigName[0] = 'A' + callConvention;
		ComputeSignature(method.returnType, method.params, metadata::IsPrologHasThis(method.flags), sigName + 1, sizeof(sigName) - 1);
		auto it = s_managed2nativeFunctionPointers.find(sigName);
		return it != s_managed2nativeFunctionPointers.end() ? it->second : NotSupportManaged2NativeFunctionMethod;
	}

	static void RaiseExecutionEngineExceptionMethodIsNotFound(const MethodInfo* method)
	{
		if (il2cpp::vm::Method::GetClass(method))
			RaiseExecutionEngineException(il2cpp::vm::Method::GetFullName(method).c_str());
		else
			RaiseExecutionEngineException(il2cpp::vm::Method::GetNameWithGenericTypes(method).c_str());
	}

	#ifdef HYBRIDCLR_UNITY_2021_OR_NEW
	
	static void InterpreterInvoke(Il2CppMethodPointer methodPointer, const MethodInfo* method, void* __this, void** __args, void* __ret)
	{
		InterpMethodInfo* imi = method->interpData ? (InterpMethodInfo*)method->interpData : InterpreterModule::GetInterpMethodInfo(method);
		bool isInstanceMethod = metadata::IsInstanceMethod(method);
		StackObject* args = (StackObject*)alloca(sizeof(StackObject) * imi->argStackObjectSize);
		if (isInstanceMethod)
		{
			if (IS_CLASS_VALUE_TYPE(method->klass))
			{
				__this = (Il2CppObject*)__this + (methodPointer != method->methodPointerCallByInterp);
			}
			args[0].ptr = __this;
		}
		
		MethodArgDesc* argDescs = imi->args + isInstanceMethod;
		ConvertInvokeArgs(args + isInstanceMethod, method, argDescs, __args);
		Interpreter::Execute(method, args, __ret);
	}

	static void InterpreterDelegateInvoke(Il2CppMethodPointer, const MethodInfo* method, void* __this, void** __args, void* __ret)
	{
		Il2CppMulticastDelegate* del = (Il2CppMulticastDelegate*)__this;
		Il2CppDelegate** firstSubDel;
		int32_t subDelCount;
		if (del->delegates)
		{
			firstSubDel = (Il2CppDelegate**)il2cpp::vm::Array::GetFirstElementAddress(del->delegates);
			subDelCount = il2cpp::vm::Array::GetLength(del->delegates);
		}
		else
		{
			firstSubDel = (Il2CppDelegate**)&del;
			firstSubDel[0] = &del->delegate;
			subDelCount = 1;
		}

		for (int32_t i = 0; i < subDelCount; i++)
		{
			Il2CppDelegate* cur = firstSubDel[i];
			const MethodInfo* curMethod = cur->method;
			Il2CppObject* curTarget = cur->target;
			if (curMethod->invoker_method == nullptr)
			{
				RaiseExecutionEngineExceptionMethodIsNotFound(curMethod);
			}
			if (!InitAndGetInterpreterDirectlyCallMethodPointer(curMethod))
			{
				RaiseAOTGenericMethodNotInstantiatedException(curMethod);
			}
			switch ((int)(method->parameters_count - curMethod->parameters_count))
			{
			case 0:
			{
				if (metadata::IsInstanceMethod(curMethod) && !curTarget)
				{
					il2cpp::vm::Exception::RaiseNullReferenceException();
				}
				curTarget += (IS_CLASS_VALUE_TYPE(curMethod->klass));
				curMethod->invoker_method(curMethod->methodPointerCallByInterp, curMethod, curTarget, __args, __ret);
				break;
			}
			case -1:
			{
				IL2CPP_ASSERT(!hybridclr::metadata::IsInstanceMethod(curMethod));
				void** newArgs = (void**)alloca(sizeof(void*) * (size_t)(curMethod->parameters_count + 1));
				newArgs[0] = curTarget;
				for (int k = 0, endK = curMethod->parameters_count; k < endK; k++)
				{
					newArgs[k + 1] = __args[k];
				}
				curMethod->invoker_method(curMethod->methodPointerCallByInterp, curMethod, nullptr, newArgs, __ret);
				break;
			}
			case 1:
			{
				IL2CPP_ASSERT(hybridclr::metadata::IsInstanceMethod(curMethod));
				curTarget = (Il2CppObject*)__args[0];
				if (!curTarget)
				{
					il2cpp::vm::Exception::RaiseNullReferenceException();
				}
				curMethod->invoker_method(curMethod->methodPointerCallByInterp, curMethod, curTarget, __args + 1, __ret);
				break;
			}
			default:
			{
				RaiseExecutionEngineException("bad delegate method");
				break;
			}
			}
		}
	}
	#else
	static void* InterpreterInvoke(Il2CppMethodPointer methodPointer, const MethodInfo* method, void* __this, void** __args)
	{
		InterpMethodInfo* imi = method->interpData ? (InterpMethodInfo*)method->interpData : InterpreterModule::GetInterpMethodInfo(method);
		StackObject* args = (StackObject*)alloca(sizeof(StackObject) * imi->argStackObjectSize);
		bool isInstanceMethod = metadata::IsInstanceMethod(method);
		if (isInstanceMethod)
		{
			if (IS_CLASS_VALUE_TYPE(method->klass))
			{
				__this = (Il2CppObject*)__this + (methodPointer != method->methodPointerCallByInterp);
			}
			args[0].ptr = __this;
		}
		MethodArgDesc* argDescs = imi->args + isInstanceMethod;
		ConvertInvokeArgs(args + isInstanceMethod, method, argDescs, __args);
		if (method->return_type->type == IL2CPP_TYPE_VOID)
		{
			Interpreter::Execute(method, args, nullptr);
			return nullptr;
		}
		else
		{
			StackObject* ret = (StackObject*)alloca(sizeof(StackObject) * imi->retStackObjectSize);
			Interpreter::Execute(method, args, ret);
			return TranslateNativeValueToBoxValue(method->return_type, ret);
		}
	}

	static void* InterpreterDelegateInvoke(Il2CppMethodPointer, const MethodInfo* method, void* __this, void** __args)
	{
		Il2CppMulticastDelegate* del = (Il2CppMulticastDelegate*)__this;
		Il2CppDelegate** firstSubDel;
		int32_t subDelCount;
		if (del->delegates)
		{
			firstSubDel = (Il2CppDelegate**)il2cpp::vm::Array::GetFirstElementAddress(del->delegates);
			subDelCount = il2cpp::vm::Array::GetLength(del->delegates);
		}
		else
		{
			firstSubDel = (Il2CppDelegate**)&del;
			firstSubDel[0] = &del->delegate;
			subDelCount = 1;
		}
		void* ret = nullptr;
		for (int32_t i = 0; i < subDelCount; i++)
		{
			Il2CppDelegate* cur = firstSubDel[i];
			const MethodInfo* curMethod = cur->method;
			Il2CppObject* curTarget = cur->target;
			if (curMethod->invoker_method == nullptr)
			{
				RaiseExecutionEngineExceptionMethodIsNotFound(curMethod);
			}
			if (!InitAndGetInterpreterDirectlyCallMethodPointer(curMethod))
			{
				RaiseAOTGenericMethodNotInstantiatedException(curMethod);
			}
			switch ((int)(method->parameters_count - curMethod->parameters_count))
			{
			case 0:
			{
				if (metadata::IsInstanceMethod(curMethod) && !curTarget)
				{
					il2cpp::vm::Exception::RaiseNullReferenceException();
				}
				curTarget += (IS_CLASS_VALUE_TYPE(curMethod->klass));
				ret = curMethod->invoker_method(curMethod->methodPointerCallByInterp, curMethod, curTarget, __args);
				break;
			}
			case -1:
			{
				IL2CPP_ASSERT(!hybridclr::metadata::IsInstanceMethod(curMethod));
				void** newArgs = (void**)alloca(sizeof(void*) * (size_t)(curMethod->parameters_count + 1));
				newArgs[0] = curTarget;
				for (int k = 0, endK = curMethod->parameters_count; k < endK; k++)
				{
					newArgs[k + 1] = __args[k];
				}
				ret = curMethod->invoker_method(curMethod->methodPointerCallByInterp, curMethod, nullptr, newArgs);
				break;
			}
			case 1:
			{
				IL2CPP_ASSERT(hybridclr::metadata::IsInstanceMethod(curMethod));
				curTarget = (Il2CppObject*)__args[0];
				if (!curTarget)
				{
					il2cpp::vm::Exception::RaiseNullReferenceException();
				}
				ret = curMethod->invoker_method(curMethod->methodPointerCallByInterp, curMethod, curTarget, __args + 1);
				break;
			}
			default:
			{
				RaiseExecutionEngineException("bad delegate method");
				break;
			}
			}
		}
		return ret;
	}
	#endif

	InvokerMethod InterpreterModule::GetMethodInvoker(const Il2CppMethodDefinition* method)
	{
		Il2CppClass* klass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeDefinitionIndex(method->declaringType);
		const char* methodName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(method->nameIndex);
		// special for Delegate::DynamicInvoke
		return !klass || !metadata::IsChildTypeOfMulticastDelegate(klass) || strcmp(methodName, "Invoke") ? InterpreterInvoke : InterpreterDelegateInvoke;
	}

	InvokerMethod InterpreterModule::GetMethodInvoker(const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;
		return !klass || !metadata::IsChildTypeOfMulticastDelegate(klass) || strcmp(method->name, "Invoke") ? InterpreterInvoke : InterpreterDelegateInvoke;
	}

	bool InterpreterModule::IsImplementsByInterpreter(const MethodInfo* method)
	{
		return method->invoker_method == InterpreterDelegateInvoke || method->invoker_method == InterpreterInvoke;
	}

	InterpMethodInfo* InterpreterModule::GetInterpMethodInfo(const MethodInfo* methodInfo)
	{
		il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

		if (methodInfo->interpData)
		{
			return (InterpMethodInfo*)methodInfo->interpData;
		}
		IL2CPP_ASSERT(methodInfo->isInterpterImpl);

		il2cpp::vm::Class::Init(methodInfo->klass);
		InterpMethodInfo* imi = transform::HiTransform::Transform(methodInfo);
		il2cpp::os::Atomic::FullMemoryBarrier();
		const_cast<MethodInfo*>(methodInfo)->interpData = imi;
		return imi;
	}
}
}


```

`hybridclr/interpreter/InterpreterModule.h`:

```h
#pragma once

#include "os/ThreadLocalValue.h"

#include "../CommonDef.h"
#include "MethodBridge.h"
#include "Engine.h"
#include "../metadata/Image.h"

namespace hybridclr
{
namespace interpreter
{

	class InterpreterModule
	{
	public:
		static void Initialize();

		static MachineState& GetCurrentThreadMachineState()
		{
			MachineState* state = nullptr;
			s_machineState.GetValue((void**)&state);
			if (!state)
			{
				state = new MachineState();
				s_machineState.SetValue(state);
			}
			return *state;
		}

		static void FreeThreadLocalMachineState()
		{
			MachineState* state = nullptr;
			s_machineState.GetValue((void**)&state);
			if (state)
			{
				delete state;
				s_machineState.SetValue(nullptr);
			}
		}

		static InterpMethodInfo* GetInterpMethodInfo(const MethodInfo* methodInfo);

		static Il2CppMethodPointer GetMethodPointer(const Il2CppMethodDefinition* method);
		static Il2CppMethodPointer GetMethodPointer(const MethodInfo* method);
		static Il2CppMethodPointer GetAdjustThunkMethodPointer(const Il2CppMethodDefinition* method);
		static Il2CppMethodPointer GetAdjustThunkMethodPointer(const MethodInfo* method);
		static Managed2NativeCallMethod GetManaged2NativeMethodPointer(const MethodInfo* method, bool forceStatic);
		static Managed2NativeCallMethod GetManaged2NativeMethodPointer(const metadata::ResolveStandAloneMethodSig& methodSig);
		static Managed2NativeFunctionPointerCallMethod GetManaged2NativeFunctionPointerMethodPointer(const MethodInfo* method, Il2CppCallConvention callConvention);
		static Managed2NativeFunctionPointerCallMethod GetManaged2NativeFunctionPointerMethodPointer(const metadata::ResolveStandAloneMethodSig& methodSig);

		static InvokerMethod GetMethodInvoker(const Il2CppMethodDefinition* method);
		static InvokerMethod GetMethodInvoker(const MethodInfo* method);

		static bool IsImplementsByInterpreter(const MethodInfo* method);

		static bool HasImplementCallNative2Managed(const MethodInfo* method)
		{
			IL2CPP_ASSERT(method->methodPointerCallByInterp != NotSupportAdjustorThunk);
			return method->methodPointerCallByInterp != (Il2CppMethodPointer)NotSupportNative2Managed;
		}

		static bool HasImplementCallVirtualNative2Managed(const MethodInfo* method)
		{
			IL2CPP_ASSERT(method->virtualMethodPointerCallByInterp != NotSupportNative2Managed);
			return method->virtualMethodPointerCallByInterp != (Il2CppMethodPointer)NotSupportAdjustorThunk;
		}

		static void Managed2NativeCallByReflectionInvoke(const MethodInfo* method, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret);

		static void NotSupportNative2Managed();
		static void NotSupportAdjustorThunk();

		static Il2CppMethodPointer GetReversePInvokeWrapper(const Il2CppImage* image, const MethodInfo* method, Il2CppCallConvention callConvention);
		static const MethodInfo* GetMethodInfoByReversePInvokeWrapperIndex(int32_t index);
		static const MethodInfo* GetMethodInfoByReversePInvokeWrapperMethodPointer(Il2CppMethodPointer methodPointer);
		static int32_t GetWrapperIndexByReversePInvokeWrapperMethodPointer(Il2CppMethodPointer methodPointer);

		static const char* GetValueTypeSignature(const char* fullName);
		
		static bool IsMethodInfoPointer(void* pointer);
	private:
		static il2cpp::os::ThreadLocalValue s_machineState;
	};
}
}

```

`hybridclr/interpreter/InterpreterUtil.cpp`:

```cpp
#include "InterpreterUtil.h"

#include "vm/Object.h"

#include "../metadata/MetadataUtil.h"

namespace hybridclr
{
namespace interpreter
{
	TypeDesc GetValueTypeArgDescBySize(uint32_t size)
	{
		if (size <= 8)
		{
			return { LocationDataType::U8, 1 };
		}
		return { LocationDataType::S_N, (uint32_t)metadata::GetStackSizeByByteSize(size) };
	}

	TypeDesc GetTypeArgDesc(const Il2CppType* type)
	{
		if (type->byref)
		{
			return { LocationDataType::U8, 1 };
		}
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_U1:
			return{ LocationDataType::U1, 1 };
		case IL2CPP_TYPE_I1:
			return{ LocationDataType::I1, 1 };
		case IL2CPP_TYPE_I2:
			return{ LocationDataType::I2, 1 };
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_U2:
			return{ LocationDataType::U2, 1 };
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_R4:
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_FNPTR:
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_BYREF:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_ARRAY:
		case IL2CPP_TYPE_SZARRAY:
		case IL2CPP_TYPE_OBJECT:
		case IL2CPP_TYPE_CLASS:
			return{ LocationDataType::U8, 1 };
		case IL2CPP_TYPE_TYPEDBYREF:
			return GetValueTypeArgDescBySize(sizeof(Il2CppTypedRef));
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
			if (klass->enumtype)
			{
				return GetTypeArgDesc(&klass->castClass->byval_arg);
			}
			return GetValueTypeArgDescBySize(il2cpp::vm::Class::GetValueSize(klass, nullptr));
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* genericClass = type->data.generic_class;
			if (genericClass->type->type == IL2CPP_TYPE_CLASS)
			{
				IL2CPP_ASSERT(!IS_CLASS_VALUE_TYPE(il2cpp::vm::Class::FromIl2CppType(type)));
				return{ LocationDataType::U8, 1 };
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
				IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
				if (klass->enumtype)
				{
					return GetTypeArgDesc(&klass->castClass->byval_arg);
				}
				return GetValueTypeArgDescBySize(il2cpp::vm::Class::GetValueSize(klass, nullptr));
			}
		}
		default:
		{
			RaiseExecutionEngineException("not support arg type");
			return{ LocationDataType::U8, 1 };
		}
		}
	}

	Il2CppObject* TranslateNativeValueToBoxValue(const Il2CppType* type, void* value)
	{
		if (type->byref)
		{
			RaiseExecutionEngineException("TranslateNativeValueToBoxValue can't box ref");
			return nullptr;
		}
		Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
		return il2cpp::vm::Object::Box(klass, value);
	}
}
}
```

`hybridclr/interpreter/InterpreterUtil.h`:

```h
#pragma once

#if HYBRIDCLR_UNITY_2023_OR_NEW
#include "codegen/il2cpp-codegen.h"
#else
#include "codegen/il2cpp-codegen-il2cpp.h"
#endif

#include "InterpreterDefs.h"

namespace hybridclr
{
namespace interpreter
{
	
	struct TypeDesc
	{
		LocationDataType type;
		uint32_t stackObjectSize; //
	};

	IL2CPP_FORCE_INLINE void RuntimeInitClassCCtor(Il2CppClass* klass)
	{
		il2cpp::vm::ClassInlines::InitFromCodegen(klass);
		if (!IS_CCTOR_FINISH_OR_NO_CCTOR(klass))
		{
			il2cpp_codegen_runtime_class_init(klass);
		}
	}

	IL2CPP_FORCE_INLINE void RuntimeInitClassCCtor(const MethodInfo* method)
	{
		RuntimeInitClassCCtor(method->klass);
	}

	IL2CPP_FORCE_INLINE void RuntimeInitClassCCtorWithoutInitClass(Il2CppClass* klass)
	{
		if (!IS_CCTOR_FINISH_OR_NO_CCTOR(klass))
		{
			il2cpp_codegen_runtime_class_init(klass);
		}
	}

	IL2CPP_FORCE_INLINE void RuntimeInitClassCCtorWithoutInitClass(const MethodInfo* method)
	{
		RuntimeInitClassCCtorWithoutInitClass(method->klass);
	}

	inline bool IsNeedExpandLocationType(LocationDataType type)
	{
		return type < LocationDataType::U8;
	}

	TypeDesc GetTypeArgDesc(const Il2CppType* type);

	inline LocationDataType GetLocationDataTypeByType(const Il2CppType* type)
	{
		return GetTypeArgDesc(type).type;
	}

	inline void ExpandLocationData2StackDataByType(void* retValue, LocationDataType type)
	{
		switch (type)
		{
		case LocationDataType::I1:
			*(int32_t*)retValue = *(int8_t*)retValue;
			break;
		case LocationDataType::U1:
			*(int32_t*)retValue = *(uint8_t*)retValue;
			break;
		case LocationDataType::I2:
			*(int32_t*)retValue = *(int16_t*)retValue;
			break;
		case LocationDataType::U2:
			*(int32_t*)retValue = *(uint16_t*)retValue;
			break;
		default:
			break;
		}
	}

	inline void CopyLocationData2StackDataByType(StackObject* dst, StackObject* src, LocationDataType type)
	{
		switch (type)
		{
		case LocationDataType::I1:
			*(int32_t*)dst = *(int8_t*)src;
			break;
		case LocationDataType::U1:
			*(int32_t*)dst = *(uint8_t*)src;
			break;
		case LocationDataType::I2:
			*(int32_t*)dst = *(int16_t*)src;
			break;
		case LocationDataType::U2:
			*(int32_t*)dst = *(uint16_t*)src;
			break;
		default:
			*dst = *src;
			break;
		}
	}

	TypeDesc GetValueTypeArgDescBySize(uint32_t size);
	
	Il2CppObject* TranslateNativeValueToBoxValue(const Il2CppType* type, void* value);


}
}

```

`hybridclr/interpreter/Interpreter_Execute.cpp`:

```cpp

#include "Interpreter.h"

#include <cmath>
#include <algorithm>

#include "vm/Object.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/Array.h"
#include "vm/Image.h"
#include "vm/Exception.h"
#include "vm/Thread.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "metadata/GenericMetadata.h"
#if HYBRIDCLR_UNITY_2020_OR_NEW
#include "vm-utils/icalls/mscorlib/System.Threading/Interlocked.h"
#else
#include "icalls/mscorlib/System.Threading/Interlocked.h"
#endif

#include "../metadata/MetadataModule.h"

#include "Instruction.h"
#include "MethodBridge.h"
#include "InstrinctDef.h"
#include "MemoryUtil.h"
#include "InterpreterModule.h"
#include "InterpreterUtil.h"
#include "gc/WriteBarrier.h"

using namespace hybridclr::metadata;

namespace hybridclr
{
namespace interpreter
{


#pragma region memory

#define LOCAL_ALLOC(size) interpFrameGroup.AllocLoc(size, imi->initLocals)

#pragma endregion

#pragma region arith

	inline bool CheckAddOverflow(int32_t a, int32_t b)
	{
		return b >= 0 ? (INT32_MAX - b < a) : (INT32_MIN - b > a);
	}

	inline bool CheckSubOverflow(int32_t a, int32_t b)
	{
		return b >= 0 ? (INT32_MAX - b < a) : (INT32_MIN - b > a);
	}

	inline bool CheckAddOverflowUn(uint32_t a, uint32_t b)
	{
		return UINT32_MAX - b < a;
	}

	inline bool CheckSubOverflowUn(uint32_t a, uint32_t b)
	{
		return a < b;
	}

	inline bool CheckAddOverflow64(int64_t a, int64_t b)
	{
		return b >= 0 ? (INT64_MAX - b < a) : (INT64_MIN - b > a);
	}

	inline bool CheckSubOverflow64(int64_t a, int64_t b)
	{
		return b < 0 ? (INT64_MAX + b < a) : (INT64_MIN + b > a);
	}

	inline bool CheckAddOverflow64Un(uint64_t a, uint64_t b)
	{
		return UINT64_MAX - b < a;
	}

	inline bool CheckSubOverflow64Un(uint64_t a, uint64_t b)
	{
		return a < b;
	}

	inline bool CheckMulOverflow(int32_t a, int32_t b)
	{
		int64_t c = (int64_t)a * (int64_t)b;
		return c < INT32_MIN || c > INT32_MAX;
	}

	inline bool CheckMulOverflowUn(uint32_t a, uint32_t b)
	{
		return (uint64_t)a * (uint64_t)b > UINT32_MAX;
	}

	inline bool CheckMulOverflow64(int64_t a, int64_t b)
	{
		if (a == 0 || b == 0)
		{
			return false;
		}
		if (a > 0 && b == -1)
		{
			return false;
		}
		if (a < 0 && b == -1)
		{
			return a == INT64_MIN;
		}
		if (a > 0 && b > 0)
		{
			return a > INT64_MAX / b;
		}
		if (a > 0 && b < 0)
		{
			return a > INT64_MIN / b;
		}
		if (a < 0 && b > 0)
		{
			return a < INT64_MIN / b;
		}
		return a < INT64_MAX / b;
	}

	inline bool CheckMulOverflow64Un(uint64_t a, uint64_t b)
	{
		return  a != 0 && b > UINT64_MAX / a;
	}

	inline bool CheckConvertOverflow_i4_i1(int32_t x)
	{
		return ((x < INT8_MIN) || (x > INT8_MAX));
	}

	inline bool CheckConvertOverflow_i4_u1(int32_t x)
	{
		return (uint32_t)x > UINT8_MAX;
	}

	inline bool CheckConvertOverflow_i4_i2(int32_t x)
	{
		return ((x < INT16_MIN) || (x > INT16_MAX));
	}

	inline bool CheckConvertOverflow_i4_u2(int32_t x)
	{
		return (uint32_t)x > UINT16_MAX;
	}

	inline bool CheckConvertOverflow_i4_i4(int32_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_i4_u4(int32_t x)
	{
		return x < 0;
	}

	inline bool CheckConvertOverflow_i4_i8(int32_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_i4_u8(int32_t x)
	{
		return  x < 0;
	}

	inline bool CheckConvertOverflow_u4_i1(uint32_t x)
	{
		return  x > INT8_MAX;
	}

	inline bool CheckConvertOverflow_u4_u1(uint32_t x)
	{
		return  x > UINT8_MAX;
	}

	inline bool CheckConvertOverflow_u4_i2(uint32_t x)
	{
		return x > INT16_MAX;
	}

	inline bool CheckConvertOverflow_u4_u2(uint32_t x)
	{
		return  x > UINT16_MAX;
	}

	inline bool CheckConvertOverflow_u4_i4(uint32_t x)
	{
		return x > INT32_MAX;
	}

	inline bool CheckConvertOverflow_u4_u4(uint32_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_u4_i8(uint32_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_u4_u8(uint32_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_i8_i1(int64_t x)
	{
		return ((x < INT8_MIN) || (x > INT8_MAX));
	}

	inline bool CheckConvertOverflow_i8_u1(int64_t x)
	{
		return (uint64_t)x > UINT8_MAX;
	}

	inline bool CheckConvertOverflow_i8_i2(int64_t x)
	{
		return ((x < INT16_MIN) || (x > INT16_MAX));
	}

	inline bool CheckConvertOverflow_i8_u2(int64_t x)
	{
		return (uint64_t)x > UINT16_MAX;
	}

	inline bool CheckConvertOverflow_i8_i4(int64_t x)
	{
		return ((x < INT32_MIN) || (x > INT32_MAX));
	}

	inline bool CheckConvertOverflow_i8_u4(int64_t x)
	{
		return (uint64_t)x > UINT32_MAX;
	}

	inline bool CheckConvertOverflow_i8_i8(int64_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_i8_u8(int64_t x)
	{
		return x < 0;
	}

	inline bool CheckConvertOverflow_u8_i1(uint64_t x)
	{
		return x > INT8_MAX;
	}

	inline bool CheckConvertOverflow_u8_u1(uint64_t x)
	{
		return  x > UINT8_MAX;
	}

	inline bool CheckConvertOverflow_u8_i2(uint64_t x)
	{
		return x > INT16_MAX;
	}

	inline bool CheckConvertOverflow_u8_u2(uint64_t x)
	{
		return  x > UINT16_MAX;
	}

	inline bool CheckConvertOverflow_u8_i4(uint64_t x)
	{
		return x > INT32_MAX;
	}

	inline bool CheckConvertOverflow_u8_u4(uint64_t x)
	{
		return x > UINT32_MAX;
	}

	inline bool CheckConvertOverflow_u8_i8(uint64_t x)
	{
		return x > INT64_MAX;
	}

	inline bool CheckConvertOverflow_u8_u8(uint64_t x)
	{
		return false;
	}

	inline bool CheckConvertOverflow_f4_i1(float x)
	{
		return x < INT8_MIN || x > INT8_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f4_u1(float x)
	{
		return x < 0 || x > UINT8_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f4_i2(float x)
	{
		return x < INT16_MIN || x > INT16_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f4_u2(float x)
	{
		return x < 0 || x > UINT16_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f4_i4(float x)
	{
		if (isnan(x))
		{
			return true;
		}
		float y = truncf(x);
		return y != (int32_t)x;
	}

	inline bool CheckConvertOverflow_f4_u4(float x)
	{
		if (isnan(x) || x < 0)
		{
			return true;
		}
		float y = truncf(x);
		return y != (uint32_t)x;
	}

	inline bool CheckConvertOverflow_f4_i8(float x)
	{
		if (isnan(x))
		{
			return true;
		}
		float y = truncf(x);
		return y != (int64_t)x;
	}

	inline bool CheckConvertOverflow_f4_u8(float x)
	{
		if (isnan(x) || x < 0)
		{
			return true;
		}
		float y = truncf(x);
		return y != (uint64_t)x;
	}

	inline bool CheckConvertOverflow_f8_i1(double x)
	{
		return x < INT8_MIN || x > INT8_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f8_u1(double x)
	{
		return x < 0 || x > UINT8_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f8_i2(double x)
	{
		return x < INT16_MIN || x > INT16_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f8_u2(double x)
	{
		return x < 0 || x > UINT16_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f8_i4(double x)
	{
		return x < INT32_MIN || x > INT32_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f8_u4(double x)
	{
		return x < 0 || x > UINT32_MAX || isnan(x);
	}

	inline bool CheckConvertOverflow_f8_i8(double x)
	{
		if (isnan(x))
		{
			return true;
		}
		double y = trunc(x);
		return y != (int64_t)x;
	}

	inline bool CheckConvertOverflow_f8_u8(double x)
	{
		if (isnan(x) || x < 0)
		{
			return true;
		}
		double y = trunc(x);
		return y != (uint64_t)x;
	}

	inline int32_t HiDiv(int32_t a, int32_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		else if (a == kIl2CppInt32Min && b == -1)
		{
			il2cpp::vm::Exception::RaiseOverflowException();
		}
		return a / b;
	}

	inline int64_t HiDiv(int64_t a, int64_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		else if (a == kIl2CppInt64Min && b == -1)
		{
			il2cpp::vm::Exception::RaiseOverflowException();
		}
		return a / b;
	}

	inline float HiDiv(float a, float b)
	{
		return a / b;
	}

	inline double HiDiv(double a, double b)
	{
		return a / b;
	}

	inline int32_t HiMulUn(int32_t a, int32_t b)
	{
		return (uint32_t)a * (uint32_t)b;
	}

	inline int64_t HiMulUn(int64_t a, int64_t b)
	{
		return (uint64_t)a * (uint64_t)b;
	}

	inline int32_t HiDivUn(int32_t a, int32_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		return (uint32_t)a / (uint32_t)b;
	}

	inline int64_t HiDivUn(int64_t a, int64_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		return (uint64_t)a / (uint64_t)b;
	}

	inline float HiRem(float a, float b)
	{
		return std::fmod(a, b);
	}

	inline double HiRem(double a, double b)
	{
		return std::fmod(a, b);
	}

	inline int32_t HiRem(int32_t a, int32_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		else if (a == kIl2CppInt32Min && b == -1)
		{
			il2cpp::vm::Exception::RaiseOverflowException();
		}
		return a % b;
	}

	inline int64_t HiRem(int64_t a, int64_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		else if (a == kIl2CppInt64Min && b == -1)
		{
			il2cpp::vm::Exception::RaiseOverflowException();
		}
		return a % b;
	}

	inline uint32_t HiRemUn(int32_t a, int32_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		return (uint32_t)a % (uint32_t)b;
	}

	inline uint64_t HiRemUn(int64_t a, int64_t b)
	{
		if (b == 0)
		{
			il2cpp::vm::Exception::RaiseDivideByZeroException();
		}
		return (uint64_t)a % (uint64_t)b;
	}

	inline uint32_t HiShrUn(int32_t a, int64_t b)
	{
		return (uint32_t)a >> b;
	}

	inline uint32_t HiShrUn(int32_t a, int32_t b)
	{
		return (uint32_t)a >> b;
	}

	inline uint64_t HiShrUn(int64_t a, int32_t b)
	{
		return (uint64_t)a >> b;
	}

	inline uint64_t HiShrUn(int64_t a, int64_t b)
	{
		return (uint64_t)a >> b;
	}


	inline void HiCheckFinite(float x)
	{
		if (std::isinf(x) || std::isnan(x))
		{
			il2cpp::vm::Exception::RaiseOverflowException();
		}
	}

	inline void HiCheckFinite(double x)
	{
		if (std::isinf(x) || std::isnan(x))
		{
			il2cpp::vm::Exception::RaiseOverflowException();
		}
	}

	template<typename T> bool CompareCeq(T a, T b) { return a == b; }
	template<typename T> bool CompareCne(T a, T b) { return a != b; }
	template<typename T> bool CompareCgt(T a, T b) { return a > b; }
	template<typename T> bool CompareCge(T a, T b) { return a >= b; }
	template<typename T> bool CompareClt(T a, T b) { return a < b; }
	template<typename T> bool CompareCle(T a, T b) { return a <= b; }

	inline bool CompareCneUn(int32_t a, int32_t b) { return (uint32_t)a != (uint32_t)b; }
	inline bool CompareCgtUn(int32_t a, int32_t b) { return (uint32_t)a > (uint32_t)b; }
	inline bool CompareCgeUn(int32_t a, int32_t b) { return (uint32_t)a >= (uint32_t)b; }
	inline bool CompareCltUn(int32_t a, int32_t b) { return (uint32_t)a < (uint32_t)b; }
	inline bool CompareCleUn(int32_t a, int32_t b) { return (uint32_t)a <= (uint32_t)b; }

	inline bool CompareCneUn(int64_t a, int64_t b) { return (uint64_t)a != (uint64_t)b; }
	inline bool CompareCgtUn(int64_t a, int64_t b) { return (uint64_t)a > (uint64_t)b; }
	inline bool CompareCgeUn(int64_t a, int64_t b) { return (uint64_t)a >= (uint64_t)b; }
	inline bool CompareCltUn(int64_t a, int64_t b) { return (uint64_t)a < (uint64_t)b; }
	inline bool CompareCleUn(int64_t a, int64_t b) { return (uint64_t)a <= (uint64_t)b; }

	inline bool CompareCneUn(float a, float b) { return a != b; }
	inline bool CompareCgtUn(float a, float b) { return a > b; }
	inline bool CompareCgeUn(float a, float b) { return a >= b; }
	inline bool CompareCltUn(float a, float b) { return a < b; }
	inline bool CompareCleUn(float a, float b) { return a <= b; }

	inline bool CompareCneUn(double a, double b) { return a != b; }
	inline bool CompareCgtUn(double a, double b) { return a > b; }
	inline bool CompareCgeUn(double a, double b) { return a >= b; }
	inline bool CompareCltUn(double a, double b) { return a < b; }
	inline bool CompareCleUn(double a, double b) { return a <= b; }

#pragma endregion

#pragma region object

	inline void INIT_CLASS(Il2CppClass* klass)
	{
		il2cpp::vm::ClassInlines::InitFromCodegen(klass);
	}

	inline void CHECK_NOT_NULL_THROW(const void* ptr)
	{
		if (!ptr)
		{
			il2cpp::vm::Exception::RaiseNullReferenceException();
		}
	}

	inline void CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(Il2CppArray* arr, int64_t index)
	{
		CHECK_NOT_NULL_THROW(arr);
		if (arr->max_length <= (il2cpp_array_size_t)index)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());
		}
	}

	inline void CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(Il2CppArray* arr, int32_t startIndex, int32_t length)
	{
		CHECK_NOT_NULL_THROW(arr);
		if (arr->max_length <= (il2cpp_array_size_t)startIndex || arr->max_length - (il2cpp_array_size_t)startIndex < (il2cpp_array_size_t)length)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());
		}
	}

	inline void CHECK_NOT_NULL_AND_ARRAY_BOUNDARY2(Il2CppArray* arr, int32_t startIndex, int32_t length)
	{
		CHECK_NOT_NULL_THROW(arr);
		if (arr->max_length <= (il2cpp_array_size_t)startIndex || arr->max_length - (il2cpp_array_size_t)startIndex < (il2cpp_array_size_t)length)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentOutOfRangeException(""));
		}
	}

	inline void CHECK_TYPE_MATCH_ELSE_THROW(Il2CppClass* klass1, Il2CppClass* klass2)
	{
		if (klass1 != klass2)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArrayTypeMismatchException());
		}
	}

	inline void CheckArrayElementTypeMatch(Il2CppClass* arrKlass, Il2CppClass* eleKlass)
	{
		if (il2cpp::vm::Class::GetElementClass(arrKlass) != eleKlass)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArrayTypeMismatchException());
		}
	}

	inline void CheckArrayElementTypeCompatible(Il2CppArray* arr, Il2CppObject* ele)
	{
		if (ele && !il2cpp::vm::Class::IsAssignableFrom(arr->klass->element_class, ele->klass))
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArrayTypeMismatchException());
		}
	}

	inline MethodInfo* GET_OBJECT_VIRTUAL_METHOD(Il2CppObject* obj, const MethodInfo* method)
	{
		CHECK_NOT_NULL_THROW(obj);
		const MethodInfo* result;
		if (hybridclr::metadata::IsVirtualMethod(method->flags))
		{
			if (hybridclr::metadata::IsInterface(method->klass->flags))
			{
				result = il2cpp_codegen_get_interface_invoke_data(method->slot, obj, method->klass).method;
			}
			else
			{
				result = il2cpp_codegen_get_virtual_invoke_data(method->slot, obj).method;
			}
			IL2CPP_ASSERT(!method->genericMethod || method->is_inflated);
			if (method->genericMethod && method->genericMethod->context.method_inst/* && method->genericMethod*/) // means it's genericInstance method 或generic method
			{
				result = GetGenericVirtualMethod(result, method);
			}
		}
		else
		{
			result = method;
		}
		return const_cast<MethodInfo*>(result);
	}

#define GET_OBJECT_INTERFACE_METHOD(obj, intfKlass, slot) (MethodInfo*)nullptr

	inline void* HiUnbox(Il2CppObject* obj, Il2CppClass* klass)
	{
		if (il2cpp::vm::Class::IsNullable(klass))
		{
			if (!obj)
			{
				return nullptr;
			}
			klass = il2cpp::vm::Class::GetNullableArgument(klass);
		}
		return UnBox(obj, klass);
	}

	inline void CopyObjectData2StackDataByType(void* dst, void* src, Il2CppClass* klass)
	{
		IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
		Il2CppTypeEnum type = klass->enumtype ? klass->castClass->byval_arg.type : klass->byval_arg.type;
		switch (type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_I1:
			*(int32_t*)dst = *(int8_t*)src;
			break;
		case IL2CPP_TYPE_U1:
			*(int32_t*)dst = *(uint8_t*)src;
			break;
		case IL2CPP_TYPE_I2:
			*(int32_t*)dst = *(int16_t*)src;
			break;
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_CHAR:
			*(int32_t*)dst = *(uint16_t*)src;
			break;
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_R4:
			*(int32_t*)dst = *(int32_t*)src;
			break;
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
			*(int64_t*)dst = *(int64_t*)src;
			break;
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
#if HYBRIDCLR_ARCH_64
			* (int64_t*)dst = *(int64_t*)src;
#else
			* (int32_t*)dst = *(int32_t*)src;
#endif
			break;
		default:
			int32_t dataSize = klass->instance_size - sizeof(Il2CppObject);
			if (dataSize <= sizeof(StackObject))
			{
				*(StackObject*)dst = *(StackObject*)src;
			}
			else
			{
				std::memmove(dst, src, dataSize);
			}
			break;
		}
	}

	inline void HiUnboxAny2StackObject(Il2CppObject* obj, Il2CppClass* klass, void* data)
	{
		if (il2cpp::vm::Class::IsNullable(klass))
		{
#if HYBRIDCLR_UNITY_2021_OR_NEW
			// il2cpp modify argument meaning in 2021
			UnBoxNullable(obj, klass, data);
#else
			UnBoxNullable(obj, klass->element_class, data);
#endif
		}
		else
		{
			CopyObjectData2StackDataByType(data, UnBox(obj, klass), klass);
		}
	}

	inline void HiCastClass(Il2CppObject* obj, Il2CppClass* klass)
	{
		if (obj != nullptr && !il2cpp::vm::Class::IsAssignableFrom(klass, obj->klass))
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidCastException("cast fail"), nullptr);
		}
	}

	inline Il2CppTypedRef MAKE_TYPEDREFERENCE(Il2CppClass* klazz, void* ptr)
	{
		return Il2CppTypedRef{ &klazz->byval_arg, ptr, klazz };
	}

	inline void* RefAnyType(Il2CppTypedRef ref)
	{
		return (void*)ref.type;
	}

	inline void* RefAnyValue(Il2CppTypedRef ref, Il2CppClass* klass)
	{
		if (klass != ref.klass)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidCastException(klass->name));
		}
		return ref.value;
	}

#define MAX_DIMENSION  10

	inline void SetArrayElementWithSize(Il2CppArray* array, uint32_t elementSize, int32_t index, void* value)
	{
		void* __p = (void*) il2cpp_array_addr_with_size (array, elementSize, index);
		memcpy(__p, value, elementSize);
	}
	
	inline Il2CppArray* NewMdArray(Il2CppClass* fullArrKlass, StackObject* lengths, StackObject* lowerBounds)
	{
		il2cpp_array_size_t arrLengths[MAX_DIMENSION];
		il2cpp_array_size_t arrLowerBounds[MAX_DIMENSION];

		switch (fullArrKlass->rank)
		{
		case 1:
		{
			arrLengths[0] = lengths[0].i32;
			if (lowerBounds)
			{
				arrLowerBounds[0] = lowerBounds[0].i32;
			}
			break;
		}
		case 2:
		{
			arrLengths[0] = lengths[0].i32;
			arrLengths[1] = lengths[1].i32;
			if (lowerBounds)
			{
				arrLowerBounds[0] = lowerBounds[0].i32;
				arrLowerBounds[1] = lowerBounds[1].i32;
			}
			break;
		}
		default:
		{
			for (uint8_t i = 0; i < fullArrKlass->rank; i++)
			{
				arrLengths[i] = lengths[i].i32;
				if (lowerBounds)
				{
					arrLowerBounds[i] = lowerBounds[i].i32;
				}
			}
			break;
		}
		}
		return il2cpp::vm::Array::NewFull(fullArrKlass, arrLengths, lowerBounds ? arrLowerBounds : nullptr);
	}

	inline void* GetMdArrayElementAddress(Il2CppArray* arr, StackObject* indexs)
	{
		CHECK_NOT_NULL_THROW(arr);
		Il2CppClass* klass = arr->klass;
		uint32_t eleSize = klass->element_size;
		Il2CppArrayBounds* bounds = arr->bounds;
		char* arrayStart = il2cpp::vm::Array::GetFirstElementAddress(arr);
		switch (klass->rank)
		{
		case 1:
		{
			Il2CppArrayBounds& bound = bounds[0];
			il2cpp_array_size_t idx = (il2cpp_array_size_t)(indexs[0].i32 - bound.lower_bound);
			if (idx < bound.length)
			{
				return arrayStart + (idx * eleSize);
			}
			else
			{
				il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());
			}
			break;
		}
		case 2:
		{
			Il2CppArrayBounds& bound0 = bounds[0];
			il2cpp_array_size_t idx0 = (il2cpp_array_size_t)(indexs[0].i32 - bound0.lower_bound);
			Il2CppArrayBounds& bound1 = bounds[1];
			il2cpp_array_size_t idx1 = (il2cpp_array_size_t)(indexs[1].i32 - bound1.lower_bound);
			if (idx0 < bound0.length && idx1 < bound1.length)
			{
				return arrayStart + ((idx0 * bound1.length) + idx1) * eleSize;
			}
			else
			{
				il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());
			}
			break;
		}
		case 3:
		{
			Il2CppArrayBounds& bound0 = bounds[0];
			il2cpp_array_size_t idx0 = (il2cpp_array_size_t)(indexs[0].i32 - bound0.lower_bound);
			Il2CppArrayBounds& bound1 = bounds[1];
			il2cpp_array_size_t idx1 = (il2cpp_array_size_t)(indexs[1].i32 - bound1.lower_bound);
			Il2CppArrayBounds& bound2 = bounds[2];
			il2cpp_array_size_t idx2 = (il2cpp_array_size_t)(indexs[2].i32 - bound2.lower_bound);
			if (idx0 < bound0.length && idx1 < bound1.length && idx2 < bound2.length)
			{
				return arrayStart + ((idx0 * bound1.length + idx1) * bound2.length + idx2) * eleSize;
			}
			else
			{
				il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());
			}
			break;
		}
		default:
		{
			IL2CPP_ASSERT(klass->rank > 0);
			il2cpp_array_size_t totalIdx = 0;
			for (uint8_t i = 0; i < klass->rank; i++)
			{
				Il2CppArrayBounds& bound = bounds[i];
				il2cpp_array_size_t idx = (il2cpp_array_size_t)(indexs[i].i32 - bound.lower_bound);
				if (idx < bound.length)
				{
					totalIdx = totalIdx * bound.length + idx;
				}
				else
				{
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());
				}
			}
			return arrayStart + totalIdx * eleSize;
		}
		}
	}

	template<typename T> void GetMdArrayElementExpandToStack(Il2CppArray* arr, StackObject* indexs, void* value)
	{
		CHECK_NOT_NULL_THROW(arr);
		*(int32_t*)value = *(T*)GetMdArrayElementAddress(arr, indexs);
	}

	template<typename T> void GetMdArrayElementCopyToStack(Il2CppArray* arr, StackObject* indexs, void* value)
	{
		CHECK_NOT_NULL_THROW(arr);
		*(T*)value = *(T*)GetMdArrayElementAddress(arr, indexs);
	}

	inline void GetMdArrayElementBySize(Il2CppArray* arr, StackObject* indexs, void* value)
	{
		CopyBySize(value, GetMdArrayElementAddress(arr, indexs), arr->klass->element_size);
	}

	inline void SetMdArrayElement(Il2CppArray* arr, StackObject* indexs, void* value)
	{
		CopyBySize(GetMdArrayElementAddress(arr, indexs), value, arr->klass->element_size);
	}

	inline void SetMdArrayElementWriteBarrier(Il2CppArray* arr, StackObject* indexs, void* value)
	{
		void* dst = GetMdArrayElementAddress(arr, indexs);
		uint32_t eleSize = arr->klass->element_size;
		CopyBySize(dst, value, eleSize);
		HYBRIDCLR_SET_WRITE_BARRIER((void**)dst, eleSize);
	}

#pragma endregion

#pragma region nullable


	inline void InitNullableValueType(void* nullableValueTypeObj, void* data, Il2CppClass* klass)
	{
		IL2CPP_ASSERT(klass->castClass->size_inited);
		uint32_t size = klass->castClass->instance_size - sizeof(Il2CppObject);
		void* dataPtr = GetNulllableDataOffset(nullableValueTypeObj, klass);
		std::memmove(dataPtr, data, size);
#if HYBRIDCLR_ENABLE_WRITE_BARRIERS
		if (klass->castClass->has_references)
		{
			HYBRIDCLR_SET_WRITE_BARRIER((void**)dataPtr, size);
		}
#endif
		*GetNulllableHasValueOffset(nullableValueTypeObj, klass) = 1;
	}

	inline void NewNullableValueType(void* nullableValueTypeObj, void* data, Il2CppClass* klass)
	{
		IL2CPP_ASSERT(klass->castClass->size_inited);
		uint32_t size = klass->castClass->instance_size - sizeof(Il2CppObject);
		std::memmove(GetNulllableDataOffset(nullableValueTypeObj, klass), data, size);
		*GetNulllableHasValueOffset(nullableValueTypeObj, klass) = 1;
	}

	inline bool IsNullableHasValue(void* nullableValueObj, Il2CppClass* klass)
	{
		IL2CPP_ASSERT(klass->castClass->size_inited);
		return *(GetNulllableHasValueOffset(nullableValueObj, klass));
	}
	
	inline void GetNullableValueOrDefault2StackDataByType(void* dst, void* nullableValueObj, Il2CppClass* klass)
	{
		Il2CppClass* eleClass = klass->castClass;
		IL2CPP_ASSERT(eleClass->size_inited);
		uint32_t size = eleClass->instance_size - sizeof(Il2CppObject);
		bool notNull = *GetNulllableHasValueOffset(nullableValueObj, klass);
		void* srcData = GetNulllableDataOffset(nullableValueObj, klass);

	LabelGet:
		IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(eleClass));
		switch (eleClass->byval_arg.type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		{
			*(int32_t*)dst = notNull ? *(uint8_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_I1:
		{
			*(int32_t*)dst = notNull ? *(int8_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_U1:
		{
			*(int32_t*)dst = notNull ? *(uint8_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_I2:
		{
			*(int32_t*)dst = notNull ? *(int16_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_CHAR:
		{
			*(int32_t*)dst = notNull ? *(uint16_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		{
			*(int32_t*)dst = notNull ? *(int32_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		{
			*(int64_t*)dst = notNull ? *(int64_t*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_R4:
		{
			*(float*)dst = notNull ? *(float*)srcData : 0;
			break;
		}
		case IL2CPP_TYPE_R8:
		{
			*(double*)dst = notNull ? *(double*)srcData : 0.0;
			break;
		}
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		{
#if HYBRIDCLR_ARCH_64
			* (int64_t*)dst = notNull ? *(int64_t*)srcData : 0;
#else 
			* (int32_t*)dst = notNull ? *(int32_t*)srcData : 0;
#endif
			break;
		}
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_GENERICINST:
		{
			if (eleClass->enumtype)
			{
				eleClass = eleClass->castClass;
				goto LabelGet;
			}
			if (notNull)
			{
				std::memmove(dst, srcData, size);
			}
			else
			{
				std::memset(dst, 0, size);
			}
			break;
		}
		default:
		{
			RaiseExecutionEngineException("GetNullableValueOrDefault2StackDataByType");
		}
		}
	}

	inline void GetNullableValueOrDefault2StackDataByType(void* dst, void* nullableValueObj, void* defaultData, Il2CppClass* klass)
	{
		Il2CppClass* eleClass = klass->castClass;
		IL2CPP_ASSERT(eleClass->size_inited);
		uint32_t size = eleClass->instance_size - sizeof(Il2CppObject);
		void* srcData;
		bool notNull = *GetNulllableHasValueOffset(nullableValueObj, klass);
		if (notNull)
		{
			srcData = GetNulllableDataOffset(nullableValueObj, klass);
		}
		else
		{
			if (defaultData == nullptr)
			{
				il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidOperationException("Nullable object must have a value."));
			}
			srcData = defaultData;
		}
	LabelGet:
		switch (eleClass->byval_arg.type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		{
			*(int32_t*)dst = *(uint8_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_CHAR:
		{
			*(int32_t*)dst = *(uint16_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_I1:
		{
			*(int32_t*)dst = *(int8_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_U1:
		{
			*(int32_t*)dst = *(uint8_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_I2:
		{
			*(int32_t*)dst = *(int16_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_U2:
		{
			*(int32_t*)dst = *(uint16_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		{
			*(int32_t*)dst = *(int32_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		{
			*(int64_t*)dst = *(int64_t*)srcData;
			break;
		}
		case IL2CPP_TYPE_R4:
		{
			*(float*)dst = *(float*)srcData;
			break;
		}
		case IL2CPP_TYPE_R8:
		{
			*(double*)dst = *(double*)srcData;
			break;
		}
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		{
#if HYBRIDCLR_ARCH_64
			* (int64_t*)dst = *(int64_t*)srcData;
#else 
			* (int32_t*)dst = *(int32_t*)srcData;
#endif
			break;
		}
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_GENERICINST:
		{
			if (eleClass->enumtype)
			{
				eleClass = eleClass->castClass;
				goto LabelGet;
			}
			std::memmove(dst, srcData, size);
			break;
		}
		default:
		{
			RaiseExecutionEngineException("GetNullableValue2StackDataByType");
		}
		}
	}

#pragma endregion

#pragma region misc

	// not boxed data

	inline int32_t HiInterlockedCompareExchange(int32_t* location, int32_t newValue, int32_t oldValue)
	{
		return il2cpp::icalls::mscorlib::System::Threading::Interlocked::CompareExchange(location, newValue, oldValue);
	}

	inline int64_t HiInterlockedCompareExchange(int64_t* location, int64_t newValue, int64_t oldValue)
	{
		return il2cpp::icalls::mscorlib::System::Threading::Interlocked::CompareExchange64(location, newValue, oldValue);
	}

	inline void* HiInterlockedCompareExchange(void** location, void* newValue, void* oldValue)
	{
		return il2cpp::icalls::mscorlib::System::Threading::Interlocked::CompareExchange_T(location, newValue, oldValue);
	}

	inline int32_t HiInterlockedExchange(int32_t* location, int32_t newValue)
	{
		return il2cpp::icalls::mscorlib::System::Threading::Interlocked::Exchange(location, newValue);
	}

	inline int64_t HiInterlockedExchange(int64_t* location, int64_t newValue)
	{
		return il2cpp::icalls::mscorlib::System::Threading::Interlocked::Exchange64(location, newValue);
	}

	inline void* HiInterlockedExchange(void** location, void* newValue)
	{
		return il2cpp::icalls::mscorlib::System::Threading::Interlocked::ExchangePointer(location, newValue);
	}

#define MEMORY_BARRIER() il2cpp::os::Atomic::FullMemoryBarrier()


	inline int32_t UnsafeEnumCast(void* src, uint16_t type)
	{
		switch ((Il2CppTypeEnum)type)
		{
		case IL2CPP_TYPE_BOOLEAN: return *(int8_t*)src;
		case IL2CPP_TYPE_CHAR: return *(uint16_t*)src;
		case IL2CPP_TYPE_I1: return *(int8_t*)src;
		case IL2CPP_TYPE_U1: return *(uint8_t*)src;
		case IL2CPP_TYPE_I2: return *(int16_t*)src;
		case IL2CPP_TYPE_U2: return *(uint16_t*)src;
		case IL2CPP_TYPE_I4: return *(int32_t*)src;
		case IL2CPP_TYPE_U4: return *(uint32_t*)src;
		default: RaiseExecutionEngineException("UnsafeEnumCast not support type"); return -1;
		}
	}

	// align with the implementation of Enum::get_hashcode
	inline int32_t GetEnumLongHashCode(void* data)
	{
		int64_t value = *((int64_t*)data);
		return (int32_t)(value & 0xffffffff) ^ (int32_t)(value >> 32);
	}

	inline void ConstructorDelegate2(MethodInfo* ctor, Il2CppDelegate* del, Il2CppObject* target, MethodInfo* method)
	{
#if HYBRIDCLR_UNITY_2021_OR_NEW
		void* ctorArgs[2] = { target, (void*)&method };
		ctor->invoker_method(ctor->methodPointer, ctor, del, ctorArgs, NULL);
#else
		RaiseNotSupportedException("ConstructorDelegate2");
#endif
	}

#pragma endregion

#pragma region function

#define SAVE_CUR_FRAME(nextIp) { \
	frame->ip = nextIp; \
}

#define LOAD_PREV_FRAME() { \
	imi = (const InterpMethodInfo*)frame->method->interpData; \
	ip = frame->ip; \
	ipBase = imi->codes; \
	localVarBase = frame->stackBasePtr; \
}

#define PREPARE_NEW_FRAME_FROM_NATIVE(newMethodInfo, argBasePtr, retPtr) { \
	imi = newMethodInfo->interpData ? (InterpMethodInfo*)newMethodInfo->interpData : InterpreterModule::GetInterpMethodInfo(newMethodInfo); \
	RuntimeInitClassCCtorWithoutInitClass(newMethodInfo); \
	frame = interpFrameGroup.EnterFrameFromNative(newMethodInfo, argBasePtr); \
	frame->ret = retPtr; \
	ip = ipBase = imi->codes; \
	frame->ip = (byte*)ip; \
	localVarBase = frame->stackBasePtr; \
}

#define PREPARE_NEW_FRAME_FROM_INTERPRETER(newMethodInfo, argBasePtr, retPtr) { \
	imi = newMethodInfo->interpData ? (InterpMethodInfo*)newMethodInfo->interpData : InterpreterModule::GetInterpMethodInfo(newMethodInfo); \
	RuntimeInitClassCCtorWithoutInitClass(newMethodInfo); \
	frame = interpFrameGroup.EnterFrameFromInterpreter(newMethodInfo, argBasePtr); \
	frame->ret = retPtr; \
	ip = ipBase = imi->codes; \
	frame->ip = (byte*)ip; \
	localVarBase = frame->stackBasePtr; \
}

#define LEAVE_FRAME() { \
	frame = interpFrameGroup.LeaveFrame(); \
	if (frame) \
	{ \
		LOAD_PREV_FRAME(); \
	}\
	else \
	{ \
		goto ExitEvalLoop; \
	} \
}

#define SET_RET_AND_LEAVE_FRAME(nativeSize, interpSize) { \
	void* _curRet = frame->ret; \
	frame = interpFrameGroup.LeaveFrame(); \
	if (frame) \
	{ \
        Copy##interpSize(_curRet, (void*)(localVarBase + __ret)); \
		LOAD_PREV_FRAME(); \
	}\
	else \
	{ \
        Copy##nativeSize(_curRet, (void*)(localVarBase + __ret)); \
		goto ExitEvalLoop; \
	} \
}

#define CALL_INTERP_VOID(nextIp, methodInfo, argBasePtr) { \
	SAVE_CUR_FRAME(nextIp) \
	PREPARE_NEW_FRAME_FROM_INTERPRETER(methodInfo, argBasePtr, nullptr); \
}

#define CALL_INTERP_RET(nextIp, methodInfo, argBasePtr, retPtr) { \
	SAVE_CUR_FRAME(nextIp) \
	PREPARE_NEW_FRAME_FROM_INTERPRETER(methodInfo, argBasePtr, retPtr); \
}

#pragma endregion

#pragma region delegate

inline void InvokeSingleDelegate(uint16_t invokeParamCount, const MethodInfo * method, Il2CppObject * obj, Managed2NativeCallMethod staticM2NMethod, Managed2NativeCallMethod instanceM2NMethod, uint16_t * argIdxs, StackObject * localVarBase, void* ret)
{
	if (!InitAndGetInterpreterDirectlyCallMethodPointer(method))
	{
		RaiseAOTGenericMethodNotInstantiatedException(method);
	}
	if (!InterpreterModule::HasImplementCallNative2Managed(method))
	{
		instanceM2NMethod = staticM2NMethod = InterpreterModule::Managed2NativeCallByReflectionInvoke;
	}
	StackObject* target;
	switch ((int32_t)invokeParamCount - (int32_t)method->parameters_count)
	{
	case 0:
	{
		if (hybridclr::metadata::IsInstanceMethod(method))
		{
			CHECK_NOT_NULL_THROW(obj);
			target = localVarBase + argIdxs[0];
			target->obj = obj + IS_CLASS_VALUE_TYPE(method->klass);
			instanceM2NMethod(method, argIdxs, localVarBase, ret);
		}
		else
		{
			RuntimeInitClassCCtor(method);
			staticM2NMethod(method, argIdxs + 1, localVarBase, ret);
		}
		break;
	}
	case -1:
	{
		IL2CPP_ASSERT(!hybridclr::metadata::IsInstanceMethod(method));
		target = localVarBase + argIdxs[0];
		target->obj = obj;
		instanceM2NMethod(method, argIdxs, localVarBase, ret);
		break;
	}
	case 1:
	{
		IL2CPP_ASSERT(invokeParamCount == method->parameters_count + 1);
		IL2CPP_ASSERT(hybridclr::metadata::IsInstanceMethod(method));
		target = localVarBase + argIdxs[1];
		CHECK_NOT_NULL_THROW(target->obj);
		staticM2NMethod(method, argIdxs + 1, localVarBase, ret);
		break;
	}
	default:
	{
		RaiseExecutionEngineException("bad delegate");
	}
	}
}

inline Il2CppObject* InvokeDelegateBeginInvoke(const MethodInfo* method, uint16_t* argIdxs, StackObject* localVarBase)
{
	int32_t paramCount = method->parameters_count;
	RuntimeDelegate* del = (RuntimeDelegate*)localVarBase[argIdxs[0]].obj;
	CHECK_NOT_NULL_THROW(del);
	RuntimeDelegate* callBack = (RuntimeDelegate*)localVarBase[argIdxs[paramCount - 1]].obj;
	RuntimeObject* ctx = (RuntimeObject*)localVarBase[argIdxs[paramCount]].obj;
	IL2CPP_ASSERT(paramCount > 0);
	void** newArgs = (void**)alloca(sizeof(void*) * paramCount);
	newArgs[paramCount - 1] = {};
	for (int i = 0; i < paramCount - 2; i++)
	{
		const Il2CppType* argType = GET_METHOD_PARAMETER_TYPE(method->parameters[i]);
		StackObject* argSrc = localVarBase + argIdxs[i+1];
		void** argDst = newArgs + i;
		if (argType->byref)
		{
			argSrc = (StackObject*)argSrc->ptr;
		}
		if (hybridclr::metadata::IsValueType(argType))
		{
			*argDst = il2cpp::vm::Object::Box(il2cpp::vm::Class::FromIl2CppType(argType), argSrc);
		}
		else
		{
			*argDst = argSrc->ptr;
		}
	}
	return (RuntimeObject*)il2cpp_codegen_delegate_begin_invoke((RuntimeDelegate*)del, (void**)newArgs, callBack, ctx);
}

inline void InvokeDelegateEndInvokeVoid(MethodInfo* method, Il2CppAsyncResult* asyncResult)
{
	il2cpp_codegen_delegate_end_invoke(asyncResult, 0);
}

inline void InvokeDelegateEndInvokeRet(MethodInfo* method, Il2CppAsyncResult* asyncResult, void* ret)
{
	Il2CppObject* result = il2cpp_codegen_delegate_end_invoke(asyncResult, 0);
	Il2CppClass* retKlass = il2cpp::vm::Class::FromIl2CppType(method->return_type);
	HiUnboxAny2StackObject(result, retKlass, ret);
}

#pragma endregion

#pragma region exception

constexpr int EXCEPTION_FLOW_INFO_ALLOC_BATCH_NUM = 3;

inline void PushExceptionFlowInfo(InterpFrame* frame, MachineState& machine, const ExceptionFlowInfo& newExFlowInfo)
{
	if (frame->exFlowCount >= frame->exFlowCapaticy)
	{
		ExceptionFlowInfo* newEfi = machine.AllocExceptionFlow(EXCEPTION_FLOW_INFO_ALLOC_BATCH_NUM);
		if (frame->exFlowBase == nullptr)
		{
			frame->exFlowBase = newEfi;
		}
		frame->exFlowCapaticy += EXCEPTION_FLOW_INFO_ALLOC_BATCH_NUM;
	}
	frame->exFlowBase[frame->exFlowCount++] = newExFlowInfo;
}

inline void PopPrevExceptionFlowInfo(InterpFrame* frame, ExceptionFlowInfo** curEx)
{
	if (frame->exFlowCount >= 2)
	{
		frame->exFlowBase[frame->exFlowCount - 2] = frame->exFlowBase[frame->exFlowCount - 1];
		--frame->exFlowCount;
		if (curEx)
		{
			*curEx = frame->exFlowBase + frame->exFlowCount - 1;
		}
	}
}

inline void PopCurExceptionFlowInfo(InterpFrame* frame)
{
	if (frame->exFlowCount >= 1)
	{
		--frame->exFlowCount;
	}
}

#define PREPARE_EXCEPTION(_ex_, _firstHanlderIndex_)  PushExceptionFlowInfo(frame, machine, {ExceptionFlowType::Exception, (int32_t)(ip - ipBase), _ex_, _firstHanlderIndex_, 0});


#define FIND_NEXT_EX_HANDLER_OR_UNWIND() \
while (true) \
{ \
	ExceptionFlowInfo* efi = frame->GetCurExFlow(); \
	IL2CPP_ASSERT(efi && efi->exFlowType == ExceptionFlowType::Exception); \
	IL2CPP_ASSERT(efi->ex); \
	int32_t exClauseNum = (int32_t)imi->exClauseCount; \
	for (; efi->nextExClauseIndex < exClauseNum; ) \
	{ \
		for (ExceptionFlowInfo* prevExFlow; (prevExFlow = frame->GetPrevExFlow()) && efi->nextExClauseIndex >= prevExFlow->nextExClauseIndex ;) {\
			const InterpExceptionClause* prevIec = &imi->exClauses[prevExFlow->nextExClauseIndex - 1]; \
			if (!(prevIec->handlerBeginOffset <= efi->throwOffset && efi->throwOffset < prevIec->handlerEndOffset)) { \
				PopPrevExceptionFlowInfo(frame, &efi);\
			} \
			else \
			{ \
				break; \
			} \
		}\
		const InterpExceptionClause* iec = &imi->exClauses[efi->nextExClauseIndex++]; \
		if (iec->tryBeginOffset <= efi->throwOffset && efi->throwOffset < iec->tryEndOffset) \
		{ \
			switch (iec->flags) \
			{ \
			case CorILExceptionClauseType::Exception: \
			{ \
			if (il2cpp::vm::Class::IsAssignableFrom(iec->exKlass, efi->ex->klass)) \
			{ \
			ip = ipBase + iec->handlerBeginOffset; \
			StackObject* exObj = localVarBase + imi->evalStackBaseOffset; \
			exObj->obj = efi->ex; \
			efi->exFlowType = ExceptionFlowType::Catch;\
			goto LoopStart; \
			} \
			break; \
			} \
			case CorILExceptionClauseType::Filter: \
			{ \
			ip = ipBase + iec->filterBeginOffset; \
			StackObject* exObj = localVarBase + imi->evalStackBaseOffset; \
			exObj->obj = efi->ex; \
			goto LoopStart; \
			} \
			case CorILExceptionClauseType::Finally: \
			{ \
			ip = ipBase + iec->handlerBeginOffset; \
			goto LoopStart; \
			} \
			case CorILExceptionClauseType::Fault: \
			{ \
			ip = ipBase + iec->handlerBeginOffset; \
			goto LoopStart; \
			} \
			default: \
			{ \
				RaiseExecutionEngineException(""); \
			} \
			} \
		} \
	} \
	frame = interpFrameGroup.LeaveFrame(); \
	if (frame) \
	{ \
		LOAD_PREV_FRAME(); \
		PREPARE_EXCEPTION(efi->ex, 0); \
	}\
	else \
	{ \
		lastUnwindException = efi->ex; \
		goto UnWindFail; \
	} \
}


#define THROW_EX(_ex_, _firstHandlerIndex_) { \
	Il2CppException* ex = _ex_; \
	il2cpp::vm::Exception::PrepareExceptionForThrow(ex, const_cast<MethodInfo*>(frame->method));\
	CHECK_NOT_NULL_THROW(ex); \
	PREPARE_EXCEPTION(ex, _firstHandlerIndex_); \
	FIND_NEXT_EX_HANDLER_OR_UNWIND(); \
}
#define RETHROW_EX() { \
	ExceptionFlowInfo* curExFlow = frame->GetCurExFlow(); \
	IL2CPP_ASSERT(curExFlow->exFlowType == ExceptionFlowType::Catch); \
	il2cpp::vm::Exception::Raise(curExFlow->ex, const_cast<MethodInfo*>(frame->method)); \
}

#define CONTINUE_NEXT_FINALLY() { \
ExceptionFlowInfo* efi = frame->GetCurExFlow(); \
IL2CPP_ASSERT(efi && efi->exFlowType == ExceptionFlowType::Leave); \
int32_t exClauseNum = (int32_t)imi->exClauseCount; \
for (; efi->nextExClauseIndex < exClauseNum; ) \
{ \
	const InterpExceptionClause* iec = &imi->exClauses[efi->nextExClauseIndex++]; \
	if (iec->tryBeginOffset <= efi->throwOffset && efi->throwOffset < iec->tryEndOffset) \
	{ \
		if (iec->tryBeginOffset <= efi->leaveTarget && efi->leaveTarget < iec->tryEndOffset) \
		{ \
			break; \
		} \
		switch (iec->flags) \
		{ \
		case CorILExceptionClauseType::Finally: \
		{ \
			ip = ipBase + iec->handlerBeginOffset; \
			goto LoopStart; \
		} \
		case CorILExceptionClauseType::Exception: \
		case CorILExceptionClauseType::Filter: \
		case CorILExceptionClauseType::Fault: \
		{ \
			break; \
		} \
		default: \
		{ \
			RaiseExecutionEngineException(""); \
		} \
		} \
	} \
} \
ip = ipBase + efi->leaveTarget; \
PopCurExceptionFlowInfo(frame); \
}

#define POP_PREV_CATCH_HANDLERS(leaveTarget)\
{ \
	for (ExceptionFlowInfo* prevExFlow; (prevExFlow = frame->GetPrevExFlow()) && prevExFlow->exFlowType == ExceptionFlowType::Catch ;) { \
			const InterpExceptionClause* prevIec = &imi->exClauses[prevExFlow->nextExClauseIndex - 1]; \
			if (!(prevIec->handlerBeginOffset <= leaveTarget && leaveTarget < prevIec->handlerEndOffset)) {	\
					PopPrevExceptionFlowInfo(frame, nullptr); \
			} \
			else \
			{ \
				break; \
			} \
	}\
}

#define LEAVE_EX(target, firstHandlerIndex)  { \
	PushExceptionFlowInfo(frame, machine, {ExceptionFlowType::Leave, (int32_t)(ip - ipBase), nullptr, firstHandlerIndex + 1, target}); \
	const InterpExceptionClause* iec = &imi->exClauses[firstHandlerIndex]; \
	POP_PREV_CATCH_HANDLERS(target); \
	ip = ipBase + iec->handlerBeginOffset; \
}

#define POP_CUR_CATCH_HANDLERS(leaveTarget)\
{ \
	for (ExceptionFlowInfo* prevExFlow; (prevExFlow = frame->GetCurExFlow()) && prevExFlow->exFlowType == ExceptionFlowType::Catch ;) { \
			const InterpExceptionClause* prevIec = &imi->exClauses[prevExFlow->nextExClauseIndex - 1]; \
			if (!(prevIec->handlerBeginOffset <= leaveTarget && leaveTarget < prevIec->handlerEndOffset)) {	\
					PopCurExceptionFlowInfo(frame); \
			} \
			else \
			{ \
				break; \
			} \
	}\
}

#define LEAVE_EX_DIRECTLY(target)  { \
	POP_CUR_CATCH_HANDLERS(target); \
	ip = ipBase + target; \
}

#define ENDFILTER_EX(value) {\
ExceptionFlowInfo* curExFlow = frame->GetCurExFlow(); \
IL2CPP_ASSERT(curExFlow->exFlowType == ExceptionFlowType::Exception); \
if(!(value)) \
{\
    FIND_NEXT_EX_HANDLER_OR_UNWIND();\
} \
else \
{ \
	curExFlow->exFlowType = ExceptionFlowType::Catch;\
}\
}

#define ENDFINALLY_EX() {\
ExceptionFlowInfo* curExFlow = frame->GetCurExFlow(); \
if (curExFlow->exFlowType == ExceptionFlowType::Exception) \
{ \
    FIND_NEXT_EX_HANDLER_OR_UNWIND(); \
} \
else \
{ \
    CONTINUE_NEXT_FINALLY();\
}\
}

#pragma endregion 

const int32_t kMaxRetValueTypeStackObjectSize = 1024;

	void Interpreter::Execute(const MethodInfo* methodInfo, StackObject* args, void* ret)
	{
		MachineState& machine = InterpreterModule::GetCurrentThreadMachineState();
		InterpFrameGroup interpFrameGroup(machine);

		const InterpMethodInfo* imi;
		InterpFrame* frame;
		StackObject* localVarBase;
		byte* ipBase;
		byte* ip;

		Il2CppException* lastUnwindException;
		StackObject* tempRet = nullptr;

		PREPARE_NEW_FRAME_FROM_NATIVE(methodInfo, args, ret);

	LoopStart:
		try
		{
			for (;;)
			{
				switch (*(HiOpcodeEnum*)ip)
				{
					// avoid decrement *ip when compute jump table,  boosts about 5% performance
				case HiOpcodeEnum::None:
				{
					continue;
				}
#pragma region memory
					//!!!{{MEMORY
				case HiOpcodeEnum::InitLocals_n_2:
				{
					uint16_t __size = *(uint16_t*)(ip + 2);
					InitDefaultN(localVarBase, __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitLocals_n_4:
				{
					uint32_t __size = *(uint32_t*)(ip + 4);
					InitDefaultN(localVarBase, __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitLocals_size_8:
				{
					InitDefault8(localVarBase);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitLocals_size_16:
				{
					InitDefault16(localVarBase);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitLocals_size_24:
				{
					InitDefault24(localVarBase);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitLocals_size_32:
				{
					InitDefault32(localVarBase);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitInlineLocals_n_2:
				{
					uint16_t __size = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					InitDefaultN(localVarBase + __offset, __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitInlineLocals_n_4:
				{
					uint32_t __size = *(uint32_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					InitDefaultN(localVarBase + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::InitInlineLocals_size_8:
				{
					uint32_t __offset = *(uint32_t*)(ip + 4);
					InitDefault8(localVarBase + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitInlineLocals_size_16:
				{
					uint32_t __offset = *(uint32_t*)(ip + 4);
					InitDefault16(localVarBase + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitInlineLocals_size_24:
				{
					uint32_t __offset = *(uint32_t*)(ip + 4);
					InitDefault24(localVarBase + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitInlineLocals_size_32:
				{
					uint32_t __offset = *(uint32_t*)(ip + 4);
					InitDefault32(localVarBase + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(uint64_t*)(localVarBase + __dst)) = (*(uint64_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocExpandVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(int8_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocExpandVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(uint8_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocExpandVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(int16_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocExpandVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(uint16_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocVarVarSize:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
					std::memmove((void*)(localVarBase + __dst), (void*)(localVarBase + __src), __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdlocVarAddress:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(void**)(localVarBase + __dst)) = (void*)(localVarBase + __src);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdcVarConst_1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 4);
					uint8_t __src = *(uint8_t*)(ip + 2);
					(*(int32_t*)(localVarBase + __dst)) = __src;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdcVarConst_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = __src;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdcVarConst_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint32_t __src = *(uint32_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = __src;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdcVarConst_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint64_t __src = *(uint64_t*)(ip + 8);
					(*(uint64_t*)(localVarBase + __dst)) = __src;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdnullVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					(*(void**)(localVarBase + __dst)) = nullptr;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(int8_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(uint8_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(int16_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(uint16_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(int32_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (*(uint32_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (*(int64_t*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (*(float*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdindVarVar_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (*(double*)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int8_t*)*(void**)(localVarBase + __dst)) = (*(int8_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int16_t*)*(void**)(localVarBase + __dst)) = (*(int16_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)*(void**)(localVarBase + __dst)) = (*(int32_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)*(void**)(localVarBase + __dst)) = (*(int64_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)*(void**)(localVarBase + __dst)) = (*(float*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)*(void**)(localVarBase + __dst)) = (*(double*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StindVarVar_ref:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(Il2CppObject**)*(void**)(localVarBase + __dst)) = (*(Il2CppObject**)(localVarBase + __src));	HYBRIDCLR_SET_WRITE_BARRIER((void**)(*(void**)(localVarBase + __dst)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LocalAllocVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
					(*(void**)(localVarBase + __dst)) = LOCAL_ALLOC((*(uint16_t*)(localVarBase + __size)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LocalAllocVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
					(*(void**)(localVarBase + __dst)) = LOCAL_ALLOC((*(uint32_t*)(localVarBase + __size)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitblkVarVarVar:
				{
					uint16_t __addr = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
					std::memset((*(void**)(localVarBase + __addr)), (*(uint8_t*)(localVarBase + __value)), (*(uint32_t*)(localVarBase + __size)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpblkVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
					std::memmove((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)), (*(uint32_t*)(localVarBase + __size)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::MemoryBarrier:
				{
					MEMORY_BARRIER();
				    ip += 8;
				    continue;
				}

				//!!!}}MEMORY


#pragma endregion

#pragma region CONVERT
		//!!!{{CONVERT
				case HiOpcodeEnum::ConvertVarVar_i4_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint8_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint16_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint32_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (uint64_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (float)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i4_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (double)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint8_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint16_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint32_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (uint64_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (float)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u4_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (double)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint8_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint16_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint32_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (uint64_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (float)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_i8_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (double)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint8_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint16_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = (uint32_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = (uint64_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (float)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_u8_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (double)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int8_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint8_t, int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int16_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint16_t, int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint32_t, int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int64_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint64_t, int64_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (float)((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f4_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (double)((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int8_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint8_t, int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int16_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint16_t, int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint32_t, int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int64_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint64_t, int64_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = (float)((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertVarVar_f8_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = (double)((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_i1(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_u1(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint8_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_i2(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_u2(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint16_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_i4(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_u4(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint32_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_i8(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i4_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int32_t val = (*(int32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i4_u8(*(int32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (uint64_t)(uint32_t)((*(int32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_i1(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_u1(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint8_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_i2(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_u2(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint16_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_i4(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_u4(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint32_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_i8(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u4_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint32_t val = (*(uint32_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u4_u8(*(uint32_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (uint64_t)((*(uint32_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_i1(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_u1(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint8_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_i2(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_u2(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint16_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_i4(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_u4(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint32_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_i8(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_i8_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    int64_t val = (*(int64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_i8_u8(*(int64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (uint64_t)(uint64_t)((*(int64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_i1(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int8_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_u1(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint8_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_i2(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int16_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_u2(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint16_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_i4(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (int32_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_u4(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = (uint32_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_i8(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (int64_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_u8_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    uint64_t val = (*(uint64_t*)(localVarBase + __src));
				    if (CheckConvertOverflow_u8_u8(*(uint64_t*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = (uint64_t)((*(uint64_t*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_i1(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int8_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_u1(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint8_t, int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_i2(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int16_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_u2(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint16_t, int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_i4(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_u4(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint32_t, int32_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_i8(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int64_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f4_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    float val = (*(float*)(localVarBase + __src));
				    if (CheckConvertOverflow_f4_u8(*(float*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint64_t, int64_t>((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_i1(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int8_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_u1(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint8_t, int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_i2(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int16_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_u2(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint16_t, int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_i4(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_u4(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint32_t, int32_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_i8(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_double_to_int<int64_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ConvertOverflowVarVar_f8_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    double val = (*(double*)(localVarBase + __src));
				    if (CheckConvertOverflow_f8_u8(*(double*)(localVarBase + __src)))
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    (*(int64_t*)(localVarBase + __dst)) = il2cpp_codegen_cast_floating_point<uint64_t, int64_t>((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}

				//!!!}}CONVERT
#pragma endregion

#pragma region ARITH
		//!!!{{ARITH
				case HiOpcodeEnum::BinOpVarVarVar_Add_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __op1)) + (*(int32_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Sub_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __op1)) - (*(int32_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Mul_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __op1)) * (*(int32_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_MulUn_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiMulUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Div_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiDiv((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_DivUn_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiDivUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Rem_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiRem((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_RemUn_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiRemUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_And_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __op1)) & (*(int32_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Or_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __op1)) | (*(int32_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Xor_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __op1)) ^ (*(int32_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Add_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __op1)) + (*(int64_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Sub_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __op1)) - (*(int64_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Mul_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __op1)) * (*(int64_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_MulUn_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiMulUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Div_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiDiv((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_DivUn_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiDivUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Rem_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiRem((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_RemUn_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiRemUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_And_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __op1)) & (*(int64_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Or_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __op1)) | (*(int64_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Xor_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __op1)) ^ (*(int64_t*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Add_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(float*)(localVarBase + __ret)) = (*(float*)(localVarBase + __op1)) + (*(float*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Sub_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(float*)(localVarBase + __ret)) = (*(float*)(localVarBase + __op1)) - (*(float*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Mul_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(float*)(localVarBase + __ret)) = (*(float*)(localVarBase + __op1)) * (*(float*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Div_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(float*)(localVarBase + __ret)) = HiDiv((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Rem_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(float*)(localVarBase + __ret)) = HiRem((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Add_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(double*)(localVarBase + __ret)) = (*(double*)(localVarBase + __op1)) + (*(double*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Sub_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(double*)(localVarBase + __ret)) = (*(double*)(localVarBase + __op1)) - (*(double*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Mul_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(double*)(localVarBase + __ret)) = (*(double*)(localVarBase + __op1)) * (*(double*)(localVarBase + __op2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Div_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(double*)(localVarBase + __ret)) = HiDiv((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpVarVarVar_Rem_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
					(*(double*)(localVarBase + __ret)) = HiRem((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Add_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    int32_t op1 = (*(int32_t*)(localVarBase + __op1));
				    int32_t op2 = (*(int32_t*)(localVarBase + __op2));
				    if ((CheckAddOverflow(op1, op2)) == 0)
				    {
				        (*(int32_t*)(localVarBase + __ret)) = op1 + op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Sub_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    int32_t op1 = (*(int32_t*)(localVarBase + __op1));
				    int32_t op2 = (*(int32_t*)(localVarBase + __op2));
				    if ((CheckSubOverflow(op1, op2)) == 0)
				    {
				        (*(int32_t*)(localVarBase + __ret)) = op1 - op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Mul_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    int32_t op1 = (*(int32_t*)(localVarBase + __op1));
				    int32_t op2 = (*(int32_t*)(localVarBase + __op2));
				    if ((CheckMulOverflow(op1, op2)) == 0)
				    {
				        (*(int32_t*)(localVarBase + __ret)) = op1 * op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Add_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    int64_t op1 = (*(int64_t*)(localVarBase + __op1));
				    int64_t op2 = (*(int64_t*)(localVarBase + __op2));
				    if ((CheckAddOverflow64(op1, op2)) == 0)
				    {
				        (*(int64_t*)(localVarBase + __ret)) = op1 + op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Sub_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    int64_t op1 = (*(int64_t*)(localVarBase + __op1));
				    int64_t op2 = (*(int64_t*)(localVarBase + __op2));
				    if ((CheckSubOverflow64(op1, op2)) == 0)
				    {
				        (*(int64_t*)(localVarBase + __ret)) = op1 - op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Mul_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    int64_t op1 = (*(int64_t*)(localVarBase + __op1));
				    int64_t op2 = (*(int64_t*)(localVarBase + __op2));
				    if ((CheckMulOverflow64(op1, op2)) == 0)
				    {
				        (*(int64_t*)(localVarBase + __ret)) = op1 * op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Add_u4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    uint32_t op1 = (*(uint32_t*)(localVarBase + __op1));
				    uint32_t op2 = (*(uint32_t*)(localVarBase + __op2));
				    if ((CheckAddOverflowUn(op1, op2)) == 0)
				    {
				        (*(uint32_t*)(localVarBase + __ret)) = op1 + op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Sub_u4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    uint32_t op1 = (*(uint32_t*)(localVarBase + __op1));
				    uint32_t op2 = (*(uint32_t*)(localVarBase + __op2));
				    if ((CheckSubOverflowUn(op1, op2)) == 0)
				    {
				        (*(uint32_t*)(localVarBase + __ret)) = op1 - op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Mul_u4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    uint32_t op1 = (*(uint32_t*)(localVarBase + __op1));
				    uint32_t op2 = (*(uint32_t*)(localVarBase + __op2));
				    if ((CheckMulOverflowUn(op1, op2)) == 0)
				    {
				        (*(uint32_t*)(localVarBase + __ret)) = op1 * op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Add_u8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    uint64_t op1 = (*(uint64_t*)(localVarBase + __op1));
				    uint64_t op2 = (*(uint64_t*)(localVarBase + __op2));
				    if ((CheckAddOverflow64Un(op1, op2)) == 0)
				    {
				        (*(uint64_t*)(localVarBase + __ret)) = op1 + op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Sub_u8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    uint64_t op1 = (*(uint64_t*)(localVarBase + __op1));
				    uint64_t op2 = (*(uint64_t*)(localVarBase + __op2));
				    if ((CheckSubOverflow64Un(op1, op2)) == 0)
				    {
				        (*(uint64_t*)(localVarBase + __ret)) = op1 - op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BinOpOverflowVarVarVar_Mul_u8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __op1 = *(uint16_t*)(ip + 4);
					uint16_t __op2 = *(uint16_t*)(ip + 6);
				    uint64_t op1 = (*(uint64_t*)(localVarBase + __op1));
				    uint64_t op2 = (*(uint64_t*)(localVarBase + __op2));
				    if ((CheckMulOverflow64Un(op1, op2)) == 0)
				    {
				        (*(uint64_t*)(localVarBase + __ret)) = op1 * op2;
				    }
				    else
				    {
				        il2cpp::vm::Exception::RaiseOverflowException();
				    }
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shl_i4_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __value)) << (*(int32_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shr_i4_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __value)) >> (*(int32_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_ShrUn_i4_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiShrUn((*(int32_t*)(localVarBase + __value)), (*(int32_t*)(localVarBase + __shiftAmount)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shl_i4_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __value)) << (*(int64_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shr_i4_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = (*(int32_t*)(localVarBase + __value)) >> (*(int64_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_ShrUn_i4_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = HiShrUn((*(int32_t*)(localVarBase + __value)), (*(int64_t*)(localVarBase + __shiftAmount)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shl_i8_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __value)) << (*(int32_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shr_i8_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __value)) >> (*(int32_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_ShrUn_i8_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiShrUn((*(int64_t*)(localVarBase + __value)), (*(int32_t*)(localVarBase + __shiftAmount)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shl_i8_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __value)) << (*(int64_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_Shr_i8_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = (*(int64_t*)(localVarBase + __value)) >> (*(int64_t*)(localVarBase + __shiftAmount));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BitShiftBinOpVarVarVar_ShrUn_i8_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __value = *(uint16_t*)(ip + 4);
					uint16_t __shiftAmount = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __ret)) = HiShrUn((*(int64_t*)(localVarBase + __value)), (*(int64_t*)(localVarBase + __shiftAmount)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnaryOpVarVar_Neg_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = - (*(int32_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnaryOpVarVar_Not_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int32_t*)(localVarBase + __dst)) = ~ (*(int32_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnaryOpVarVar_Neg_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = - (*(int64_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnaryOpVarVar_Not_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(int64_t*)(localVarBase + __dst)) = ~ (*(int64_t*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnaryOpVarVar_Neg_f4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(float*)(localVarBase + __dst)) = - (*(float*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnaryOpVarVar_Neg_f8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					(*(double*)(localVarBase + __dst)) = - (*(double*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CheckFiniteVar_f4:
				{
					uint16_t __src = *(uint16_t*)(ip + 2);
					HiCheckFinite((*(float*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CheckFiniteVar_f8:
				{
					uint16_t __src = *(uint16_t*)(ip + 2);
					HiCheckFinite((*(double*)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}

				//!!!}}ARITH
#pragma endregion

#pragma region COMPARE
		//!!!{{COMPARE
				case HiOpcodeEnum::CompOpVarVarVar_Ceq_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCeq((*(int32_t*)(localVarBase + __c1)), (*(int32_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Ceq_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCeq((*(int64_t*)(localVarBase + __c1)), (*(int64_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Ceq_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCeq((*(float*)(localVarBase + __c1)), (*(float*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Ceq_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCeq((*(double*)(localVarBase + __c1)), (*(double*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Cgt_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgt((*(int32_t*)(localVarBase + __c1)), (*(int32_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Cgt_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgt((*(int64_t*)(localVarBase + __c1)), (*(int64_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Cgt_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgt((*(float*)(localVarBase + __c1)), (*(float*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Cgt_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgt((*(double*)(localVarBase + __c1)), (*(double*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CgtUn_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgtUn((*(int32_t*)(localVarBase + __c1)), (*(int32_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CgtUn_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgtUn((*(int64_t*)(localVarBase + __c1)), (*(int64_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CgtUn_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgtUn((*(float*)(localVarBase + __c1)), (*(float*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CgtUn_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCgtUn((*(double*)(localVarBase + __c1)), (*(double*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Clt_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareClt((*(int32_t*)(localVarBase + __c1)), (*(int32_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Clt_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareClt((*(int64_t*)(localVarBase + __c1)), (*(int64_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Clt_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareClt((*(float*)(localVarBase + __c1)), (*(float*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_Clt_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareClt((*(double*)(localVarBase + __c1)), (*(double*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CltUn_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCltUn((*(int32_t*)(localVarBase + __c1)), (*(int32_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CltUn_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCltUn((*(int64_t*)(localVarBase + __c1)), (*(int64_t*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CltUn_f4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCltUn((*(float*)(localVarBase + __c1)), (*(float*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CompOpVarVarVar_CltUn_f8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __c1 = *(uint16_t*)(ip + 4);
					uint16_t __c2 = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __ret)) = CompareCltUn((*(double*)(localVarBase + __c1)), (*(double*)(localVarBase + __c2)));
				    ip += 8;
				    continue;
				}

				//!!!}}COMPARE
#pragma endregion

#pragma region BRANCH
		//!!!{{BRANCH
				case HiOpcodeEnum::BranchUncondition_4:
				{
					int32_t __offset = *(int32_t*)(ip + 4);
					ip = ipBase + __offset;
				    continue;
				}
				case HiOpcodeEnum::BranchTrueVar_i4:
				{
					uint16_t __op = *(uint16_t*)(ip + 2);
					int32_t __offset = *(int32_t*)(ip + 4);
				    if ((*(int32_t*)(localVarBase + __op)))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 8;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchTrueVar_i8:
				{
					uint16_t __op = *(uint16_t*)(ip + 2);
					int32_t __offset = *(int32_t*)(ip + 4);
				    if ((*(int64_t*)(localVarBase + __op)))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 8;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchFalseVar_i4:
				{
					uint16_t __op = *(uint16_t*)(ip + 2);
					int32_t __offset = *(int32_t*)(ip + 4);
				    if (!(*(int32_t*)(localVarBase + __op)))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 8;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchFalseVar_i8:
				{
					uint16_t __op = *(uint16_t*)(ip + 2);
					int32_t __offset = *(int32_t*)(ip + 4);
				    if (!(*(int64_t*)(localVarBase + __op)))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 8;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Ceq_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCeq((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Ceq_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCeq((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Ceq_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCeq((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Ceq_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCeq((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CneUn_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCneUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CneUn_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCneUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CneUn_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCneUn((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CneUn_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCneUn((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip = ipBase + __offset;
				    }
				    else
				    {
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cgt_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCle((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cgt_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCle((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cgt_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCle((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cgt_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCle((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgtUn_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCleUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgtUn_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCleUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgtUn_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCleUn((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgtUn_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCleUn((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cge_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareClt((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cge_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareClt((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cge_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareClt((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cge_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareClt((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgeUn_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCltUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgeUn_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCltUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgeUn_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCltUn((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CgeUn_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCltUn((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Clt_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCge((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Clt_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCge((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Clt_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCge((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Clt_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCge((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CltUn_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgeUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CltUn_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgeUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CltUn_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgeUn((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CltUn_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgeUn((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cle_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgt((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cle_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgt((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cle_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgt((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_Cle_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgt((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CleUn_i4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgtUn((*(int32_t*)(localVarBase + __op1)), (*(int32_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CleUn_i8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgtUn((*(int64_t*)(localVarBase + __op1)), (*(int64_t*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CleUn_f4:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgtUn((*(float*)(localVarBase + __op1)), (*(float*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchVarVar_CleUn_f8:
				{
					uint16_t __op1 = *(uint16_t*)(ip + 2);
					uint16_t __op2 = *(uint16_t*)(ip + 4);
					int32_t __offset = *(int32_t*)(ip + 8);
				    if (CompareCgtUn((*(double*)(localVarBase + __op1)), (*(double*)(localVarBase + __op2))))
				    {
				        ip += 16;
				    }
				    else
				    {
				        ip = ipBase + __offset;
				    }
				    continue;
				}
				case HiOpcodeEnum::BranchJump:
				{
					uint32_t __token = *(uint32_t*)(ip + 4);
					IL2CPP_ASSERT(false);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BranchSwitch:
				{
				    uint16_t __value = *(uint16_t*)(ip + 2);
				    uint32_t __caseNum = *(uint32_t*)(ip + 4);
				    uint32_t __caseOffsets = *(uint32_t*)(ip + 8);
				    uint32_t __idx = (*(uint32_t*)(localVarBase + __value));
				    if (__idx < __caseNum)
				    {
				        ip = ipBase + ((uint32_t*)&imi->resolveDatas[__caseOffsets])[__idx];
				    }
				    else 
				    {
				        ip += 16;
				    }
				    continue;
				}

				//!!!}}BRANCH
#pragma endregion

#pragma region FUNCTION
		//!!!{{FUNCTION
				case HiOpcodeEnum::NewClassVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					void* __managed2NativeMethod = ((void*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    frame->ip = ip + 2;
				    uint16_t* _argIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
				    Il2CppObject* _obj = il2cpp::vm::Object::New(__method->klass);
				    *(Il2CppObject**)(localVarBase + _argIdxs[0]) = _obj;
				    ((Managed2NativeCallMethod)__managed2NativeMethod)(__method, _argIdxs, localVarBase, nullptr);
				    (*(Il2CppObject**)(localVarBase + __obj)) = _obj;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewClassVar_Ctor_0:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
				    frame->ip = ip + 2;
				    Il2CppObject* _obj = il2cpp::vm::Object::New(__method->klass);
				    ((NativeClassCtor0)(__method->methodPointerCallByInterp))(_obj, __method);
				    (*(Il2CppObject**)(localVarBase + __obj)) = _obj;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewClassVar_NotCtor:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
				    frame->ip = ip + 2;
				    (*(Il2CppObject**)(localVarBase + __obj)) = il2cpp::vm::Object::New(__klass);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewValueTypeVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					void* __managed2NativeMethod = ((void*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    frame->ip = ip + 2;
				    uint16_t* _argIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
				    int32_t _typeSize = GetTypeValueSize(__method->klass);
				    // arg1, arg2, ..., argN, value type, __this
				    StackObject* _frameBasePtr = localVarBase + _argIdxs[0];
				    Il2CppObject* _this = (Il2CppObject*)(_frameBasePtr - GetStackSizeByByteSize(_typeSize));
				    _frameBasePtr->ptr = _this;
				    ((Managed2NativeCallMethod)__managed2NativeMethod)(__method, _argIdxs, localVarBase, nullptr);
				    std::memmove((void*)(localVarBase + __obj), _this, _typeSize);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewValueTypeVar_Ctor_0:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    InitDefaultN((void*)(localVarBase + __obj), __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewClassInterpVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 12)]);
					uint16_t __argBase = *(uint16_t*)(ip + 4);
					uint16_t __argStackObjectNum = *(uint16_t*)(ip + 6);
					uint16_t __ctorFrameBase = *(uint16_t*)(ip + 8);
				    IL2CPP_ASSERT(__obj < __ctorFrameBase);
				    Il2CppObject* _newObj = il2cpp::vm::Object::New(__method->klass);
				    StackObject* _frameBasePtr = (StackObject*)(void*)(localVarBase + __ctorFrameBase);
				    std::memmove(_frameBasePtr + 1, (void*)(localVarBase + __argBase), __argStackObjectNum * sizeof(StackObject)); // move arg
				    _frameBasePtr->obj = _newObj; // prepare this 
				    (*(Il2CppObject**)(localVarBase + __obj)) = _newObj; // set must after move
				    CALL_INTERP_VOID((ip + 16), __method, _frameBasePtr);
				    continue;
				}
				case HiOpcodeEnum::NewClassInterpVar_Ctor_0:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint16_t __ctorFrameBase = *(uint16_t*)(ip + 4);
				    IL2CPP_ASSERT(__obj < __ctorFrameBase);
				    Il2CppObject* _newObj = il2cpp::vm::Object::New(__method->klass);
				    StackObject* _frameBasePtr = (StackObject*)(void*)(localVarBase + __ctorFrameBase);
				    _frameBasePtr->obj = _newObj; // prepare this 
				    (*(Il2CppObject**)(localVarBase + __obj)) = _newObj;
				    CALL_INTERP_VOID((ip + 16), __method, _frameBasePtr);
				    continue;
				}
				case HiOpcodeEnum::NewValueTypeInterpVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 12)]);
					uint16_t __argBase = *(uint16_t*)(ip + 4);
					uint16_t __argStackObjectNum = *(uint16_t*)(ip + 6);
					uint16_t __ctorFrameBase = *(uint16_t*)(ip + 8);
				    IL2CPP_ASSERT(__obj < __ctorFrameBase);
				    StackObject* _frameBasePtr = (StackObject*)(void*)(localVarBase + __ctorFrameBase);
				    std::memmove(_frameBasePtr + 1, (void*)(localVarBase + __argBase), __argStackObjectNum * sizeof(StackObject)); // move arg
				    _frameBasePtr->ptr = (StackObject*)(void*)(localVarBase + __obj);
				    CALL_INTERP_VOID((ip + 16), __method, _frameBasePtr);
				    continue;
				}
				case HiOpcodeEnum::AdjustValueTypeRefVar:
				{
					uint16_t __data = *(uint16_t*)(ip + 2);
				    // ref => fake value type boxed object value. // fake obj = ref(value_type) - sizeof(Il2CppObject)
				    StackObject* _thisSo = ((StackObject*)((void*)(localVarBase + __data)));
				    _thisSo->obj -= 1;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::BoxRefVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(Il2CppObject**)(localVarBase + __dst)) = il2cpp::vm::Object::Box(__klass, (*(void**)(localVarBase + __src)));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdvirftnVarVar:
				{
					uint16_t __resultMethod = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					MethodInfo* __virtualMethod = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(MethodInfo**)(localVarBase + __resultMethod)) = GET_OBJECT_VIRTUAL_METHOD((*(Il2CppObject**)(localVarBase + __obj)), __virtualMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_1:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(1, 8);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_2:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(2, 8);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(4, 8);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(8, 8);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_12:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(12, 12);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_16:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(16, 16);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_20:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(20, 20);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_24:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(24, 24);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_28:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(28, 28);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_32:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    SET_RET_AND_LEAVE_FRAME(32, 32);
				    continue;
				}
				case HiOpcodeEnum::RetVar_ret_n:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 4);
				    std::memmove(frame->ret, (void*)(localVarBase + __ret), __size);
					LEAVE_FRAME();
				    continue;
				}
				case HiOpcodeEnum::RetVar_void:
				{
					LEAVE_FRAME();
				    continue;
				}
				case HiOpcodeEnum::CallNativeInstance_void:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    frame->ip = ip + 2;
				    uint16_t* _resolvedArgIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
				    CHECK_NOT_NULL_THROW((localVarBase + _resolvedArgIdxs[0])->obj);
				    ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(((MethodInfo*)imi->resolveDatas[__methodInfo]), _resolvedArgIdxs, localVarBase, nullptr);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallNativeInstance_ret:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    uint16_t* _resolvedArgIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
				    CHECK_NOT_NULL_THROW((localVarBase + _resolvedArgIdxs[0])->obj);
				    void* _ret = (void*)(localVarBase + __ret);
				    ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(((MethodInfo*)imi->resolveDatas[__methodInfo]), _resolvedArgIdxs, localVarBase, _ret);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallNativeInstance_ret_expand:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 8);
					uint32_t __methodInfo = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					uint8_t __retLocationType = *(uint8_t*)(ip + 2);
				    frame->ip = ip + 2;
				    uint16_t* _resolvedArgIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
				    CHECK_NOT_NULL_THROW((localVarBase + _resolvedArgIdxs[0])->obj);
				    void* _ret = (void*)(localVarBase + __ret);
				    ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(((MethodInfo*)imi->resolveDatas[__methodInfo]), _resolvedArgIdxs, localVarBase, _ret);
				    ExpandLocationData2StackDataByType(_ret, (LocationDataType)__retLocationType);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallNativeStatic_void:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__methodInfo]);
					RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(_resolvedMethod, ((uint16_t*)&imi->resolveDatas[__argIdxs]), localVarBase, nullptr);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallNativeStatic_ret:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__methodInfo]);
					RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    void* _ret = (void*)(localVarBase + __ret);
				    ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(_resolvedMethod, ((uint16_t*)&imi->resolveDatas[__argIdxs]), localVarBase, _ret);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallNativeStatic_ret_expand:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 8);
					uint32_t __methodInfo = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					uint8_t __retLocationType = *(uint8_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__methodInfo]);
					RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    void* _ret = (void*)(localVarBase + __ret);
				    ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(_resolvedMethod, ((uint16_t*)&imi->resolveDatas[__argIdxs]), localVarBase, _ret);
				    ExpandLocationData2StackDataByType(_ret, (LocationDataType)__retLocationType);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallInterp_void:
				{
					MethodInfo* __methodInfo = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint16_t __argBase = *(uint16_t*)(ip + 2);
					if (metadata::IsInstanceMethod(__methodInfo))
					{
						CHECK_NOT_NULL_THROW((localVarBase + __argBase)->obj);
					}
					CALL_INTERP_VOID((ip + 8), __methodInfo, (StackObject*)(void*)(localVarBase + __argBase));
				    continue;
				}
				case HiOpcodeEnum::CallInterp_ret:
				{
					MethodInfo* __methodInfo = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint16_t __argBase = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					if (metadata::IsInstanceMethod(__methodInfo))
					{
						CHECK_NOT_NULL_THROW((localVarBase + __argBase)->obj);
					}
					CALL_INTERP_RET((ip + 16), __methodInfo, (StackObject*)(void*)(localVarBase + __argBase), (void*)(localVarBase + __ret));
				    continue;
				}
				case HiOpcodeEnum::CallVirtual_void:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    uint16_t* _argIdxData = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
					StackObject* _objPtr = localVarBase + _argIdxData[0];
				    MethodInfo* _actualMethod = GET_OBJECT_VIRTUAL_METHOD( _objPtr->obj, ((MethodInfo*)imi->resolveDatas[__methodInfo]));
				    if (IS_CLASS_VALUE_TYPE(_actualMethod->klass))
				    {
				        _objPtr->obj += 1;
				    }
				    if (hybridclr::metadata::IsInterpreterImplement(_actualMethod))
				    {
				        CALL_INTERP_VOID((ip + 16), _actualMethod, _objPtr);
				    }
				    else 
				    {
				        frame->ip = ip + 2;
				        if (!InitAndGetInterpreterDirectlyCallMethodPointer(_actualMethod))
				        {
				            RaiseAOTGenericMethodNotInstantiatedException(_actualMethod);
				        }
				        ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(_actualMethod, _argIdxData, localVarBase, nullptr);
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::CallVirtual_ret:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    uint16_t* _argIdxData = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
					StackObject* _objPtr = localVarBase + _argIdxData[0];
				    MethodInfo* _actualMethod = GET_OBJECT_VIRTUAL_METHOD(_objPtr->obj, ((MethodInfo*)imi->resolveDatas[__methodInfo]));
				    void* _ret = (void*)(localVarBase + __ret);
				    if (IS_CLASS_VALUE_TYPE(_actualMethod->klass))
				    {
				        _objPtr->obj += 1;
				    }
				    if (hybridclr::metadata::IsInterpreterImplement(_actualMethod))
				    {
				        CALL_INTERP_RET((ip + 16), _actualMethod, _objPtr, _ret);
				    }
				    else 
				    {
				        frame->ip = ip + 2;
				        if (!InitAndGetInterpreterDirectlyCallMethodPointer(_actualMethod))
				        {
				            RaiseAOTGenericMethodNotInstantiatedException(_actualMethod);
				        }
				        ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(_actualMethod, _argIdxData, localVarBase, _ret);
				        ip += 16;
				    }
				    continue;
				}
				case HiOpcodeEnum::CallVirtual_ret_expand:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 8);
					uint32_t __methodInfo = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					uint8_t __retLocationType = *(uint8_t*)(ip + 2);
				    uint16_t* _argIdxData = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
					StackObject* _objPtr = localVarBase + _argIdxData[0];
				    MethodInfo* _actualMethod = GET_OBJECT_VIRTUAL_METHOD(_objPtr->obj, ((MethodInfo*)imi->resolveDatas[__methodInfo]));
				    void* _ret = (void*)(localVarBase + __ret);
				    if (IS_CLASS_VALUE_TYPE(_actualMethod->klass))
				    {
				        _objPtr->obj += 1;
				    }
				    if (hybridclr::metadata::IsInterpreterImplement(_actualMethod))
				    {
				        CALL_INTERP_RET((ip + 24), _actualMethod, _objPtr, _ret);
				    }
				    else 
				    {
				        frame->ip = ip + 2;
				        if (!InitAndGetInterpreterDirectlyCallMethodPointer(_actualMethod))
				        {
				            RaiseAOTGenericMethodNotInstantiatedException(_actualMethod);
				        }
				        ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod])(_actualMethod, _argIdxData, localVarBase, _ret);
				        ExpandLocationData2StackDataByType(_ret, (LocationDataType)__retLocationType);
				        ip += 24;
				    }
				    continue;
				}
				case HiOpcodeEnum::CallInterpVirtual_void:
				{
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint16_t __argBase = *(uint16_t*)(ip + 2);
				    StackObject* _argBasePtr = (StackObject*)(void*)(localVarBase + __argBase);
				    MethodInfo* _actualMethod = GET_OBJECT_VIRTUAL_METHOD(_argBasePtr->obj, __method);
				    if (IS_CLASS_VALUE_TYPE(_actualMethod->klass))
				    {
				        _argBasePtr->obj += 1;
				    }
				    CALL_INTERP_VOID((ip + 8), _actualMethod, _argBasePtr);
				    continue;
				}
				case HiOpcodeEnum::CallInterpVirtual_ret:
				{
					MethodInfo* __method = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint16_t __argBase = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    StackObject* _argBasePtr = (StackObject*)(void*)(localVarBase + __argBase);
				    MethodInfo* _actualMethod = GET_OBJECT_VIRTUAL_METHOD(_argBasePtr->obj, __method);
				    if (IS_CLASS_VALUE_TYPE(_actualMethod->klass))
				    {
				        _argBasePtr->obj += 1;
				    }
				    CALL_INTERP_RET((ip + 16), _actualMethod, _argBasePtr, (void*)(localVarBase + __ret));
				    continue;
				}
				case HiOpcodeEnum::CallInd_void:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __managed2NativeFunctionPointerMethod = *(uint32_t*)(ip + 8);
					uint8_t& __isMethodInfoPointer = *(uint8_t*)(ip + 2);
					uint32_t __methodInfo = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
				    frame->ip = ip + 2;
				    Managed2NativeCallMethod _nativeMethodPointer = ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod]);
				    Managed2NativeFunctionPointerCallMethod _nativeMethodPointer2 = ((Managed2NativeFunctionPointerCallMethod)imi->resolveDatas[__managed2NativeFunctionPointerMethod]);
					uint16_t* _argIdxsPtr = (uint16_t*)&imi->resolveDatas[__argIdxs];
					StackObject* _argBasePtr = localVarBase + _argIdxsPtr[0];
					Il2CppMethodPointer _methodPointer = (Il2CppMethodPointer)(localVarBase + __methodInfo)->ptr;
					if (__isMethodInfoPointer == 0)
					{
				        __isMethodInfoPointer = hybridclr::interpreter::InterpreterModule::IsMethodInfoPointer((void*)_methodPointer) ? 1 : 2;
					}
					if (__isMethodInfoPointer == 1)
					{
					    MethodInfo* _method = (MethodInfo*)_methodPointer;
					    if (metadata::IsInstanceMethod(_method))
					    {
				            CHECK_NOT_NULL_THROW(_argBasePtr->obj);
					    }
					    if (IsInterpreterImplement(_method))
					    {
				            CALL_INTERP_VOID((ip + 24), _method, _argBasePtr);
				            continue;
					    }
					    if (!InitAndGetInterpreterDirectlyCallMethodPointer(_method))
					    {
				            RaiseAOTGenericMethodNotInstantiatedException(_method);
					    }
				        _nativeMethodPointer(_method, _argIdxsPtr, localVarBase, nullptr);
				    }
				    else
				    {
				        _nativeMethodPointer2(_methodPointer, _argIdxsPtr, localVarBase, nullptr);
				    }
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallInd_ret:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 8);
					uint32_t __managed2NativeFunctionPointerMethod = *(uint32_t*)(ip + 12);
					uint8_t& __isMethodInfoPointer = *(uint8_t*)(ip + 2);
					uint32_t __methodInfo = *(uint32_t*)(ip + 16);
					uint32_t __argIdxs = *(uint32_t*)(ip + 20);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _ret = (void*)(localVarBase + __ret);
				    Managed2NativeCallMethod _nativeMethodPointer = ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod]);
				    Managed2NativeFunctionPointerCallMethod _nativeMethodPointer2 = ((Managed2NativeFunctionPointerCallMethod)imi->resolveDatas[__managed2NativeFunctionPointerMethod]);
					uint16_t* _argIdxsPtr = (uint16_t*)&imi->resolveDatas[__argIdxs];
					StackObject* _argBasePtr = localVarBase + _argIdxsPtr[0];
					Il2CppMethodPointer _methodPointer = (Il2CppMethodPointer)(localVarBase + __methodInfo)->ptr;
					if (__isMethodInfoPointer == 0)
					{
				        __isMethodInfoPointer = hybridclr::interpreter::InterpreterModule::IsMethodInfoPointer((void*)_methodPointer) ? 1 : 2;
					}
					if (__isMethodInfoPointer == 1)
					{
					    MethodInfo* _method = (MethodInfo*)_methodPointer;
					    if (metadata::IsInstanceMethod(_method))
					    {
				            CHECK_NOT_NULL_THROW(_argBasePtr->obj);
					    }
					    if (IsInterpreterImplement(_method))
					    {
				            CALL_INTERP_RET((ip + 24), _method, _argBasePtr, _ret);
				            continue;
					    }
					    if (!InitAndGetInterpreterDirectlyCallMethodPointer(_method))
					    {
				            RaiseAOTGenericMethodNotInstantiatedException(_method);
					    }
				        _nativeMethodPointer(_method, _argIdxsPtr, localVarBase, _ret);
				    }
				    else
				    {
				        _nativeMethodPointer2(_methodPointer, _argIdxsPtr, localVarBase, _ret);
				    }
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallInd_ret_expand:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 8);
					uint32_t __managed2NativeFunctionPointerMethod = *(uint32_t*)(ip + 12);
					uint8_t& __isMethodInfoPointer = *(uint8_t*)(ip + 2);
					uint32_t __methodInfo = *(uint32_t*)(ip + 16);
					uint32_t __argIdxs = *(uint32_t*)(ip + 20);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					uint8_t __retLocationType = *(uint8_t*)(ip + 3);
				    frame->ip = ip + 2;
				    void* _ret = (void*)(localVarBase + __ret);
				    Managed2NativeCallMethod _nativeMethodPointer = ((Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeMethod]);
				    Managed2NativeFunctionPointerCallMethod _nativeMethodPointer2 = ((Managed2NativeFunctionPointerCallMethod)imi->resolveDatas[__managed2NativeFunctionPointerMethod]);
					uint16_t* _argIdxsPtr = (uint16_t*)&imi->resolveDatas[__argIdxs];
					StackObject* _argBasePtr = localVarBase + _argIdxsPtr[0];
					Il2CppMethodPointer _methodPointer = (Il2CppMethodPointer)(localVarBase + __methodInfo)->ptr;
					if (__isMethodInfoPointer == 0)
					{
				        __isMethodInfoPointer = hybridclr::interpreter::InterpreterModule::IsMethodInfoPointer((void*)_methodPointer) ? 1 : 2;
					}
					if (__isMethodInfoPointer == 1)
					{
					    MethodInfo* _method = (MethodInfo*)_methodPointer;
					    if (metadata::IsInstanceMethod(_method))
					    {
				            CHECK_NOT_NULL_THROW(_argBasePtr->obj);
					    }
					    if (IsInterpreterImplement(_method))
					    {
				            CALL_INTERP_RET((ip + 24), _method, _argBasePtr, _ret);
				            continue;
					    }
					    if (!InitAndGetInterpreterDirectlyCallMethodPointer(_method))
					    {
				            RaiseAOTGenericMethodNotInstantiatedException(_method);
					    }
				        _nativeMethodPointer(_method, _argIdxsPtr, localVarBase, _ret);
				    }
				    else
				    {
				        _nativeMethodPointer2(_methodPointer, _argIdxsPtr, localVarBase, _ret);
				    }
				    ExpandLocationData2StackDataByType(_ret, (LocationDataType)__retLocationType);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallPInvoke_void:
				{
					uint32_t __managed2NativeFunctionPointerMethod = *(uint32_t*)(ip + 4);
					uint32_t __pinvokeMethodPointer = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    frame->ip = ip + 2;
				    Managed2NativeFunctionPointerCallMethod _managed2NativeFuncMethodPointer = ((Managed2NativeFunctionPointerCallMethod)imi->resolveDatas[__managed2NativeFunctionPointerMethod]);
				    Il2CppMethodPointer _pinvokeMethodPointer = ((Il2CppMethodPointer)imi->resolveDatas[__pinvokeMethodPointer]);
					uint16_t* _argIdxsPtr = (uint16_t*)&imi->resolveDatas[__argIdxs];
					StackObject* _argBasePtr = localVarBase + _argIdxsPtr[0];
				    _managed2NativeFuncMethodPointer(_pinvokeMethodPointer, _argIdxsPtr, localVarBase, nullptr);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallPInvoke_ret:
				{
					uint32_t __managed2NativeFunctionPointerMethod = *(uint32_t*)(ip + 4);
					uint32_t __pinvokeMethodPointer = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    void* _ret = (void*)(localVarBase + __ret);
				    Managed2NativeFunctionPointerCallMethod _managed2NativeFuncMethodPointer = ((Managed2NativeFunctionPointerCallMethod)imi->resolveDatas[__managed2NativeFunctionPointerMethod]);
				    Il2CppMethodPointer _pinvokeMethodPointer = ((Il2CppMethodPointer)imi->resolveDatas[__pinvokeMethodPointer]);
					uint16_t* _argIdxsPtr = (uint16_t*)&imi->resolveDatas[__argIdxs];
					StackObject* _argBasePtr = localVarBase + _argIdxsPtr[0];
				    _managed2NativeFuncMethodPointer(_pinvokeMethodPointer, _argIdxsPtr, localVarBase, _ret);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallPInvoke_ret_expand:
				{
					uint32_t __managed2NativeFunctionPointerMethod = *(uint32_t*)(ip + 8);
					uint32_t __pinvokeMethodPointer = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					uint8_t __retLocationType = *(uint8_t*)(ip + 2);
				    frame->ip = ip + 2;
				    void* _ret = (void*)(localVarBase + __ret);
				    Managed2NativeFunctionPointerCallMethod _managed2NativeFuncMethodPointer = ((Managed2NativeFunctionPointerCallMethod)imi->resolveDatas[__managed2NativeFunctionPointerMethod]);
				    Il2CppMethodPointer _pinvokeMethodPointer = ((Il2CppMethodPointer)imi->resolveDatas[__pinvokeMethodPointer]);
					uint16_t* _argIdxsPtr = (uint16_t*)&imi->resolveDatas[__argIdxs];
					StackObject* _argBasePtr = localVarBase + _argIdxsPtr[0];
				    _managed2NativeFuncMethodPointer(_pinvokeMethodPointer, _argIdxsPtr, localVarBase, _ret);
				    ExpandLocationData2StackDataByType(_ret, (LocationDataType)__retLocationType);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallDelegateInvoke_void:
				{
					uint32_t __managed2NativeStaticMethod = *(uint32_t*)(ip + 4);
					uint32_t __managed2NativeInstanceMethod = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
					uint16_t __invokeParamCount = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
					void* _ret = nullptr;
					uint16_t* _resolvedArgIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
					StackObject* _argBasePtr = localVarBase + _resolvedArgIdxs[0];
					Il2CppMulticastDelegate* _del = (Il2CppMulticastDelegate*)_argBasePtr->obj;
					CHECK_NOT_NULL_THROW(_del);
					if (_del->delegates == nullptr)
					{
						const MethodInfo* method = _del->delegate.method;
						Il2CppObject* target = _del->delegate.target;
						if (hybridclr::metadata::IsInterpreterImplement(method))
						{
							switch ((int32_t)__invokeParamCount - (int32_t)method->parameters_count)
							{
							case 0:
							{
								if (hybridclr::metadata::IsInstanceMethod(method))
								{
									CHECK_NOT_NULL_THROW(target);
									target += IS_CLASS_VALUE_TYPE(method->klass);
									_argBasePtr->obj = target;
								}
								else
								{
									_argBasePtr = __invokeParamCount == 0 ? _argBasePtr + 1 : localVarBase + _resolvedArgIdxs[1];
								}
								break;
							}
							case -1:
							{
								_argBasePtr->obj = target;
								break;
							}
							case 1:
							{
								_argBasePtr = localVarBase + _resolvedArgIdxs[1];
								CHECK_NOT_NULL_THROW(_argBasePtr->obj);
								break;
							}
							default:
							{
								RaiseExecutionEngineException("CallInterpDelegate");
							}
							}
							CALL_INTERP_RET((ip + 16), method, _argBasePtr, _ret);
							continue;
						}
						else
						{
							Managed2NativeCallMethod _staticM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeStaticMethod];
							Managed2NativeCallMethod _instanceM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeInstanceMethod];
							InvokeSingleDelegate(__invokeParamCount, method, target, _staticM2NMethod, _instanceM2NMethod, _resolvedArgIdxs, localVarBase, _ret);
						}
					}
					else
					{
						Il2CppArray* dels = _del->delegates;
						Managed2NativeCallMethod _staticM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeStaticMethod];
						Managed2NativeCallMethod _instanceM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeInstanceMethod];
						for (il2cpp_array_size_t i = 0; i < dels->max_length; i++)
						{
							Il2CppMulticastDelegate* subDel = il2cpp_array_get(dels, Il2CppMulticastDelegate *, i);
							IL2CPP_ASSERT(subDel);
							IL2CPP_ASSERT(subDel->delegates == nullptr);
							const MethodInfo* method = subDel->delegate.method;
							Il2CppObject* target = subDel->delegate.target;
							InvokeSingleDelegate(__invokeParamCount, method, target, _staticM2NMethod, _instanceM2NMethod, _resolvedArgIdxs, localVarBase, _ret);
						}
					}
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallDelegateInvoke_ret:
				{
					uint32_t __managed2NativeStaticMethod = *(uint32_t*)(ip + 8);
					uint32_t __managed2NativeInstanceMethod = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __invokeParamCount = *(uint16_t*)(ip + 4);
					uint16_t __retTypeStackObjectSize = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _ret = (void*)(localVarBase + __ret);
					IL2CPP_ASSERT(__retTypeStackObjectSize <= kMaxRetValueTypeStackObjectSize);
					StackObject* _tempRet = tempRet ? tempRet : (tempRet = (StackObject*)alloca(sizeof(StackObject) * kMaxRetValueTypeStackObjectSize));
					uint16_t* _resolvedArgIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
					StackObject* _argBasePtr = localVarBase + _resolvedArgIdxs[0];
					Il2CppMulticastDelegate* _del = (Il2CppMulticastDelegate*)_argBasePtr->obj;
					CHECK_NOT_NULL_THROW(_del);
					if (_del->delegates == nullptr)
					{
						const MethodInfo* method = _del->delegate.method;
						Il2CppObject* target = _del->delegate.target;
						if (hybridclr::metadata::IsInterpreterImplement(method))
						{
							switch ((int32_t)__invokeParamCount - (int32_t)method->parameters_count)
							{
							case 0:
							{
								if (hybridclr::metadata::IsInstanceMethod(method))
								{
									CHECK_NOT_NULL_THROW(target);
									target += IS_CLASS_VALUE_TYPE(method->klass);
									_argBasePtr->obj = target;
								}
								else
								{
									_argBasePtr = __invokeParamCount == 0 ? _argBasePtr + 1 : localVarBase + _resolvedArgIdxs[1];
								}
								break;
							}
							case -1:
							{
								_argBasePtr->obj = target;
								break;
							}
							case 1:
							{
								_argBasePtr = localVarBase + _resolvedArgIdxs[1];
								CHECK_NOT_NULL_THROW(_argBasePtr->obj);
								break;
							}
							default:
							{
								RaiseExecutionEngineException("CallInterpDelegate");
							}
							}
							CALL_INTERP_RET((ip + 24), method, _argBasePtr, _ret);
							continue;
						}
						else
						{
							Managed2NativeCallMethod _staticM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeStaticMethod];
							Managed2NativeCallMethod _instanceM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeInstanceMethod];
							InvokeSingleDelegate(__invokeParamCount, method, target, _staticM2NMethod, _instanceM2NMethod, _resolvedArgIdxs, localVarBase, _tempRet);
						}
					}
					else
					{
						Il2CppArray* dels = _del->delegates;
						Managed2NativeCallMethod _staticM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeStaticMethod];
						Managed2NativeCallMethod _instanceM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeInstanceMethod];
						for (il2cpp_array_size_t i = 0; i < dels->max_length; i++)
						{
							Il2CppMulticastDelegate* subDel = il2cpp_array_get(dels, Il2CppMulticastDelegate *, i);
							IL2CPP_ASSERT(subDel);
							IL2CPP_ASSERT(subDel->delegates == nullptr);
							const MethodInfo* method = subDel->delegate.method;
							Il2CppObject* target = subDel->delegate.target;
							InvokeSingleDelegate(__invokeParamCount, method, target, _staticM2NMethod, _instanceM2NMethod, _resolvedArgIdxs, localVarBase, _tempRet);
						}
					}
					CopyStackObject((StackObject*)_ret, _tempRet, __retTypeStackObjectSize);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallDelegateInvoke_ret_expand:
				{
					uint32_t __managed2NativeStaticMethod = *(uint32_t*)(ip + 8);
					uint32_t __managed2NativeInstanceMethod = *(uint32_t*)(ip + 12);
					uint32_t __argIdxs = *(uint32_t*)(ip + 16);
					uint16_t __ret = *(uint16_t*)(ip + 4);
					uint16_t __invokeParamCount = *(uint16_t*)(ip + 6);
					uint8_t __retLocationType = *(uint8_t*)(ip + 2);
				    frame->ip = ip + 2;
				    void* _ret = (void*)(localVarBase + __ret);
					StackObject _tempRet[1];
					uint16_t* _resolvedArgIdxs = ((uint16_t*)&imi->resolveDatas[__argIdxs]);
					StackObject* _argBasePtr = localVarBase + _resolvedArgIdxs[0];
					Il2CppMulticastDelegate* _del = (Il2CppMulticastDelegate*)_argBasePtr->obj;
					CHECK_NOT_NULL_THROW(_del);
					if (_del->delegates == nullptr)
					{
						const MethodInfo* method = _del->delegate.method;
						Il2CppObject* target = _del->delegate.target;
						if (hybridclr::metadata::IsInterpreterImplement(method))
						{
							switch ((int32_t)__invokeParamCount - (int32_t)method->parameters_count)
							{
							case 0:
							{
								if (hybridclr::metadata::IsInstanceMethod(method))
								{
									CHECK_NOT_NULL_THROW(target);
									target += IS_CLASS_VALUE_TYPE(method->klass);
									_argBasePtr->obj = target;
								}
								else
								{
									_argBasePtr = __invokeParamCount == 0 ? _argBasePtr + 1 : localVarBase + _resolvedArgIdxs[1];
								}
								break;
							}
							case -1:
							{
								_argBasePtr->obj = target;
								break;
							}
							case 1:
							{
								_argBasePtr = localVarBase + _resolvedArgIdxs[1];
								CHECK_NOT_NULL_THROW(_argBasePtr->obj);
								break;
							}
							default:
							{
								RaiseExecutionEngineException("CallInterpDelegate");
							}
							}
							CALL_INTERP_RET((ip + 24), method, _argBasePtr, _ret);
							continue;
						}
						else
						{
							Managed2NativeCallMethod _staticM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeStaticMethod];
							Managed2NativeCallMethod _instanceM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeInstanceMethod];
							InvokeSingleDelegate(__invokeParamCount, method, target, _staticM2NMethod, _instanceM2NMethod, _resolvedArgIdxs, localVarBase, _tempRet);
						}
					}
					else
					{
						Il2CppArray* dels = _del->delegates;
						Managed2NativeCallMethod _staticM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeStaticMethod];
						Managed2NativeCallMethod _instanceM2NMethod = (Managed2NativeCallMethod)imi->resolveDatas[__managed2NativeInstanceMethod];
						for (il2cpp_array_size_t i = 0; i < dels->max_length; i++)
						{
							Il2CppMulticastDelegate* subDel = il2cpp_array_get(dels, Il2CppMulticastDelegate *, i);
							IL2CPP_ASSERT(subDel);
							IL2CPP_ASSERT(subDel->delegates == nullptr);
							const MethodInfo* method = subDel->delegate.method;
							Il2CppObject* target = subDel->delegate.target;
							InvokeSingleDelegate(__invokeParamCount, method, target, _staticM2NMethod, _instanceM2NMethod, _resolvedArgIdxs, localVarBase, _tempRet);
						}
					}
				    CopyLocationData2StackDataByType((StackObject*)_ret, _tempRet, (LocationDataType)__retLocationType);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallDelegateBeginInvoke:
				{
					uint16_t __result = *(uint16_t*)(ip + 2);
					uint32_t __methodInfo = *(uint32_t*)(ip + 4);
					uint32_t __argIdxs = *(uint32_t*)(ip + 8);
				    frame->ip = ip + 2;
					(*(Il2CppObject**)(localVarBase + __result)) = InvokeDelegateBeginInvoke(((MethodInfo*)imi->resolveDatas[__methodInfo]), ((uint16_t*)&imi->resolveDatas[__argIdxs]), localVarBase);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallDelegateEndInvoke_void:
				{
					uint32_t __methodInfo = *(uint32_t*)(ip + 4);
					uint16_t __asyncResult = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    InvokeDelegateEndInvokeVoid(((MethodInfo*)imi->resolveDatas[__methodInfo]), (Il2CppAsyncResult*)(*(Il2CppObject**)(localVarBase + __asyncResult)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallDelegateEndInvoke_ret:
				{
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint16_t __asyncResult = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    InvokeDelegateEndInvokeRet(((MethodInfo*)imi->resolveDatas[__methodInfo]), (Il2CppAsyncResult*)(*(Il2CppObject**)(localVarBase + __asyncResult)), (void*)(localVarBase + __ret));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewDelegate:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __method = *(uint16_t*)(ip + 6);
				    Il2CppDelegate* del = (Il2CppDelegate*)il2cpp::vm::Object::New(__klass);
				    ConstructDelegate(del, (*(Il2CppObject**)(localVarBase + __obj)), (*(MethodInfo**)(localVarBase + __method)));
				    (*(Il2CppObject**)(localVarBase + __dst)) = (Il2CppObject*)del;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CtorDelegate:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					MethodInfo* __ctor = ((MethodInfo*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __method = *(uint16_t*)(ip + 6);
				    Il2CppDelegate* _del = (Il2CppDelegate*)il2cpp::vm::Object::New(__ctor->klass);
				    ConstructorDelegate2(__ctor, _del, (*(Il2CppObject**)(localVarBase + __obj)), (*(MethodInfo**)(localVarBase + __method)));
				    (*(Il2CppObject**)(localVarBase + __dst)) = (Il2CppObject*)_del;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __self = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i1_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int8_t(*_NativeMethod_)(void*, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i2_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int16_t(*_NativeMethod_)(void*, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u2_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint16_t(*_NativeMethod_)(void*, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int32_t, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int64_t, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, float, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, float, float, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, float, float, float, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, double, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, double, double, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_v_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef void(*_NativeMethod_)(void*, double, double, double, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, float, float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_u1_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef uint8_t(*_NativeMethod_)(void*, double, double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, float, float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i4_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int32_t(*_NativeMethod_)(void*, double, double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int32_t, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int64_t, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, float, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, float, float, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, float, float, float, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, double, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, double, double, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_i8_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef int64_t(*_NativeMethod_)(void*, double, double, double, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int32_t, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int64_t, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, float, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, float, float, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, float, float, float, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, double, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, double, double, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f4_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef float(*_NativeMethod_)(void*, double, double, double, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int32_t, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int64_t, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, float, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, float, float, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, float, float, float, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, double, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, double, double, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeInstance_f8_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 16);
					uint16_t __self = *(uint16_t*)(ip + 2);
					uint16_t __param0 = *(uint16_t*)(ip + 4);
					uint16_t __param1 = *(uint16_t*)(ip + 6);
					uint16_t __param2 = *(uint16_t*)(ip + 8);
					uint16_t __param3 = *(uint16_t*)(ip + 10);
					uint16_t __ret = *(uint16_t*)(ip + 12);
				    frame->ip = ip + 2;
				    void* _self = (*(void**)(localVarBase + __self));
				    CHECK_NOT_NULL_THROW(_self);
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    typedef double(*_NativeMethod_)(void*, double, double, double, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_self, (*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 24;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i1_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int8_t(*_NativeMethod_)(MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i2_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int16_t(*_NativeMethod_)(MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u2_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint16_t(*_NativeMethod_)(MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_0:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)(_resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int32_t, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int32_t, int32_t, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int64_t, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int64_t, int64_t, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(float, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(float, float, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(float, float, float, float, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 4);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(double, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(double, double, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_v_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef void(*_NativeMethod_)(double, double, double, double, MethodInfo*);
				    ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(float, float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_u1_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef uint8_t(*_NativeMethod_)(double, double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(float, float, float, float, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i4_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int32_t(*_NativeMethod_)(double, double, double, double, MethodInfo*);
				    *(int32_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int32_t, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int32_t, int32_t, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int64_t, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int64_t, int64_t, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(float, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(float, float, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(float, float, float, float, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(double, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(double, double, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_i8_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef int64_t(*_NativeMethod_)(double, double, double, double, MethodInfo*);
				    *(int64_t*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int32_t, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int32_t, int32_t, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int64_t, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int64_t, int64_t, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(float, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(float, float, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(float, float, float, float, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(double, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(double, double, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f4_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef float(*_NativeMethod_)(double, double, double, double, MethodInfo*);
				    *(float*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int32_t, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int32_t, int32_t, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int32_t, int32_t, int32_t, int32_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int32_t*)(localVarBase + __param0)), (*(int32_t*)(localVarBase + __param1)), (*(int32_t*)(localVarBase + __param2)), (*(int32_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int64_t, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int64_t, int64_t, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_i8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(int64_t, int64_t, int64_t, int64_t, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(int64_t*)(localVarBase + __param0)), (*(int64_t*)(localVarBase + __param1)), (*(int64_t*)(localVarBase + __param2)), (*(int64_t*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f4_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f4_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(float, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f4_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(float, float, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f4_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(float, float, float, float, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(float*)(localVarBase + __param0)), (*(float*)(localVarBase + __param1)), (*(float*)(localVarBase + __param2)), (*(float*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f8_1:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __ret = *(uint16_t*)(ip + 4);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f8_2:
				{
					uint32_t __method = *(uint32_t*)(ip + 8);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __ret = *(uint16_t*)(ip + 6);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(double, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f8_3:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __ret = *(uint16_t*)(ip + 8);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(double, double, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), _resolvedMethod);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CallCommonNativeStatic_f8_f8_4:
				{
					uint32_t __method = *(uint32_t*)(ip + 12);
					uint16_t __param0 = *(uint16_t*)(ip + 2);
					uint16_t __param1 = *(uint16_t*)(ip + 4);
					uint16_t __param2 = *(uint16_t*)(ip + 6);
					uint16_t __param3 = *(uint16_t*)(ip + 8);
					uint16_t __ret = *(uint16_t*)(ip + 10);
				    frame->ip = ip + 2;
				    MethodInfo* _resolvedMethod = ((MethodInfo*)imi->resolveDatas[__method]);
				    RuntimeInitClassCCtorWithoutInitClass(_resolvedMethod);
				    typedef double(*_NativeMethod_)(double, double, double, double, MethodInfo*);
				    *(double*)(void*)(localVarBase + __ret) = ((_NativeMethod_)_resolvedMethod->methodPointerCallByInterp)((*(double*)(localVarBase + __param0)), (*(double*)(localVarBase + __param1)), (*(double*)(localVarBase + __param2)), (*(double*)(localVarBase + __param3)), _resolvedMethod);
				    ip += 16;
				    continue;
				}

				//!!!}}FUNCTION
#pragma endregion

#pragma region OBJECT
		//!!!{{OBJECT
				case HiOpcodeEnum::BoxVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __data = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(Il2CppObject**)(localVarBase + __dst)) = il2cpp::vm::Object::Box(__klass, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::UnBoxVarVar:
				{
					uint16_t __addr = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(void**)(localVarBase + __addr)) = HiUnbox((*(Il2CppObject**)(localVarBase + __obj)), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::UnBoxAnyVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    HiUnboxAny2StackObject((*(Il2CppObject**)(localVarBase + __obj)), __klass, (void*)(localVarBase + __dst));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CastclassVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __klass = *(uint32_t*)(ip + 4);
				    HiCastClass((*(Il2CppObject**)(localVarBase + __obj)), ((Il2CppClass*)imi->resolveDatas[__klass]));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::IsInstVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __klass = *(uint32_t*)(ip + 4);
				    (*(Il2CppObject**)(localVarBase + __obj)) = il2cpp::vm::Object::IsInst((*(Il2CppObject**)(localVarBase + __obj)), ((Il2CppClass*)imi->resolveDatas[__klass]));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdtokenVar:
				{
					uint16_t __runtimeHandle = *(uint16_t*)(ip + 2);
					void* __token = ((void*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
				    (*(void**)(localVarBase + __runtimeHandle)) = __token;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::MakeRefVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __data = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(Il2CppTypedRef*)(localVarBase + __dst)) = MAKE_TYPEDREFERENCE(__klass, (*(void**)(localVarBase + __data)));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::RefAnyTypeVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __typedRef = *(uint16_t*)(ip + 4);
				    (*(void**)(localVarBase + __dst)) = RefAnyType((*(Il2CppTypedRef*)(localVarBase + __typedRef)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::RefAnyValueVarVar:
				{
					uint16_t __addr = *(uint16_t*)(ip + 2);
					uint16_t __typedRef = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(void**)(localVarBase + __addr)) = RefAnyValue((*(Il2CppTypedRef*)(localVarBase + __typedRef)), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_ref:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    void** _dstAddr_ = (void**)((*(void**)(localVarBase + __dst)));
				    *_dstAddr_ = *(void**)(*(void**)(localVarBase + __src));
				    HYBRIDCLR_SET_WRITE_BARRIER(_dstAddr_);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy1((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy2((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy4((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy8((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy12((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy16((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy20((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy24((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy28((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy32((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
					std::memmove((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)), __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 8);
					std::memmove((*(void**)(localVarBase + __dst)), (*(void**)(localVarBase + __src)), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_WriteBarrier_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
				    void* _dstAddr_ = (void*)((*(void**)(localVarBase + __dst)));
				    std::memmove(_dstAddr_, (*(void**)(localVarBase + __src)), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_dstAddr_, __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CpobjVarVar_WriteBarrier_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 8);
				    void* _dstAddr_ = (void*)((*(void**)(localVarBase + __dst)));
				    std::memmove(_dstAddr_, (*(void**)(localVarBase + __src)), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_dstAddr_, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_ref:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					*(void**)(void*)(localVarBase + __dst) = (*(void**)*(void**)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy1((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy2((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy4((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy8((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy12((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy16((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy20((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy24((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy28((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy32((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdobjVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 8);
					std::memmove((void*)(localVarBase + __dst), (*(void**)(localVarBase + __src)), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_ref:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    void** _dstAddr_ = (void**)((*(void**)(localVarBase + __dst)));
				    *_dstAddr_ = (*(Il2CppObject**)(localVarBase + __src));
				    HYBRIDCLR_SET_WRITE_BARRIER(_dstAddr_);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy1((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy2((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy4((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy8((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy12((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy16((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy20((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy24((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy28((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					Copy32((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 8);
					std::memmove((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __src), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StobjVarVar_WriteBarrier_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 8);
				    void* _dstAddr_ = (*(void**)(localVarBase + __dst));
				    std::memmove(_dstAddr_, (void*)(localVarBase + __src), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_dstAddr_, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_ref:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
				    void* _objAddr_ = (*(void**)(localVarBase + __obj));
				    CHECK_NOT_NULL_THROW(_objAddr_);
				    *(void**)_objAddr_ = nullptr;
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_objAddr_);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_1:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault1((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault2((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault4((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault8((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_12:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault12((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_16:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault16((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_20:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault20((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_24:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault24((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_28:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault28((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_32:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					InitDefault32((*(void**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_n_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
					InitDefaultN((*(void**)(localVarBase + __obj)), __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_n_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 4);
					InitDefaultN((*(void**)(localVarBase + __obj)), __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_WriteBarrier_n_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    void* _objAddr_ = (*(void**)(localVarBase + __obj));
				    InitDefaultN(_objAddr_, __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_objAddr_, __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitobjVar_WriteBarrier_n_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 4);
				    void* _objAddr_ = (*(void**)(localVarBase + __obj));
				    InitDefaultN(_objAddr_, __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_objAddr_, __size);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdstrVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint32_t __str = *(uint32_t*)(ip + 4);
				    (*(Il2CppString**)(localVarBase + __dst)) = ((Il2CppString*)imi->resolveDatas[__str]);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(int8_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(uint8_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(int16_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(uint16_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(int32_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(uint32_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int64_t*)(localVarBase + __dst)) = *(int64_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int64_t*)(localVarBase + __dst)) = *(uint64_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy8((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy12((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy16((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy20((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy24((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy28((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy32((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					uint16_t __size = *(uint16_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					uint32_t __size = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __dst)) = *(int8_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __dst)) = *(uint8_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __dst)) = *(int16_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __dst)) = *(uint16_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __dst)) = *(int32_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int32_t*)(localVarBase + __dst)) = *(uint32_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __dst)) = *(int64_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					(*(int64_t*)(localVarBase + __dst)) = *(uint64_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy8((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy12((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy16((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy20((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy24((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy28((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					Copy32((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					uint16_t __size = *(uint16_t*)(ip + 8);
					std::memmove((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
					uint32_t __size = *(uint32_t*)(ip + 8);
					std::memmove((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldaVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __offset = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(void**)(localVarBase + __dst)) = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_i1:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int8_t*)(_fieldAddr_) = (*(int8_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_u1:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint8_t*)(_fieldAddr_) = (*(uint8_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_i2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int16_t*)(_fieldAddr_) = (*(int16_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_u2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint16_t*)(_fieldAddr_) = (*(uint16_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_i4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int32_t*)(_fieldAddr_) = (*(int32_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_u4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint32_t*)(_fieldAddr_) = (*(uint32_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_i8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int64_t*)(_fieldAddr_) = (*(int64_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_u8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint64_t*)(_fieldAddr_) = (*(uint64_t*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_ref:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(Il2CppObject**)(_fieldAddr_) = (*(Il2CppObject**)(localVarBase + __data));HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy8((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_12:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy12((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_16:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy16((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_20:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy20((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_24:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy24((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_28:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy28((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_size_32:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy32((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_n_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
					uint16_t __size = *(uint16_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_n_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
					uint32_t __size = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_WriteBarrier_n_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
					uint16_t __size = *(uint16_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldVarVar_WriteBarrier_n_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __offset = *(uint16_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 6);
					uint32_t __size = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(int8_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(uint8_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(int16_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(uint16_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(int32_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(uint32_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int64_t*)(localVarBase + __dst)) = *(int64_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int64_t*)(localVarBase + __dst)) = *(uint64_t*)(((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy8((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy12((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy16((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy20((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy24((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy28((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy32((void*)(localVarBase + __dst), ((byte*)__klass->static_fields) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 12);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove((void*)(localVarBase + __dst), (((byte*)__klass->static_fields) + __offset), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove((void*)(localVarBase + __dst), (((byte*)__klass->static_fields) + __offset), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_i1:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(int8_t*)(_fieldAddr_) = (*(int8_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_u1:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(uint8_t*)(_fieldAddr_) = (*(uint8_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_i2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(int16_t*)(_fieldAddr_) = (*(int16_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_u2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(uint16_t*)(_fieldAddr_) = (*(uint16_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_i4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(int32_t*)(_fieldAddr_) = (*(int32_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_u4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(uint32_t*)(_fieldAddr_) = (*(uint32_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_i8:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(int64_t*)(_fieldAddr_) = (*(int64_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_u8:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(uint64_t*)(_fieldAddr_) = (*(uint64_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_ref:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    *(Il2CppObject**)(_fieldAddr_) = (*(Il2CppObject**)(localVarBase + __data));HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_8:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy8(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_12:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy12(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_16:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy16(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_20:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy20(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_24:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy24(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_28:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy28(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_size_32:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy32(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_n_2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 12);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_n_4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove(((byte*)__klass->static_fields) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_WriteBarrier_n_2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 12);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StsfldVarVar_WriteBarrier_n_4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)__klass->static_fields) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldaVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(void**)(localVarBase + __dst)) = ((byte*)__klass->static_fields) + __offset;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdsfldaFromFieldDataVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					void* __src = ((void*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
				    (*(void**)(localVarBase + __dst)) = __src;
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalaVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(void**)(localVarBase + __dst)) = (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(int8_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(uint8_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(int16_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(uint16_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(int32_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int32_t*)(localVarBase + __dst)) = *(uint32_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int64_t*)(localVarBase + __dst)) = *(int64_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    (*(int64_t*)(localVarBase + __dst)) = *(uint64_t*)((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy8((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy12((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy16((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy20((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy24((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy28((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy32((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					int32_t __offset = *(int32_t*)(ip + 12);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdthreadlocalVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					int32_t __offset = *(int32_t*)(ip + 8);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove((void*)(localVarBase + __dst), (byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_i1:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(int8_t*)_fieldAddr_ = (*(int8_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_u1:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(uint8_t*)_fieldAddr_ = (*(uint8_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_i2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(int16_t*)_fieldAddr_ = (*(int16_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_u2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(uint16_t*)_fieldAddr_ = (*(uint16_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_i4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(int32_t*)_fieldAddr_ = (*(int32_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_u4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(uint32_t*)_fieldAddr_ = (*(uint32_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_i8:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(int64_t*)_fieldAddr_ = (*(int64_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_u8:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(uint64_t*)_fieldAddr_ = (*(uint64_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_ref:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    *(Il2CppObject**)_fieldAddr_ = (*(Il2CppObject**)(localVarBase + __data));HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_8:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy8((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_12:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy12((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_16:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy16((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_20:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy20((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_24:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy24((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_28:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy28((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_size_32:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 4);
					uint16_t __data = *(uint16_t*)(ip + 2);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    Copy32((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_n_2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 12);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_n_4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    std::memmove((byte*)il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_WriteBarrier_n_2:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
					uint32_t __offset = *(uint32_t*)(ip + 12);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StthreadlocalVarVar_WriteBarrier_n_4:
				{
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 4)]);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 2);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    RuntimeInitClassCCtorWithoutInitClass(__klass);
				    void* _fieldAddr_ = ((byte*)(il2cpp::vm::Thread::GetThreadStaticData(__klass->thread_static_fields_offset))) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CheckThrowIfNullVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InitClassStaticCtor:
				{
					uint64_t __klass = *(uint64_t*)(ip + 8);
				    RuntimeInitClassCCtorWithoutInitClass((Il2CppClass*)(__klass));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldaLargeVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(void**)(localVarBase + __dst)) = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(int8_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(uint8_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(int16_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(uint16_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(int32_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int32_t*)(localVarBase + __dst)) = *(uint32_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int64_t*)(localVarBase + __dst)) = *(int64_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    (*(int64_t*)(localVarBase + __dst)) = *(uint64_t*)((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy8((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy12((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy16((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy20((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy24((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy28((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy32((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __size = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldLargeVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((void*)(localVarBase + __dst), (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int32_t*)(localVarBase + __dst)) = *(int8_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int32_t*)(localVarBase + __dst)) = *(uint8_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int32_t*)(localVarBase + __dst)) = *(int16_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int32_t*)(localVarBase + __dst)) = *(uint16_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int32_t*)(localVarBase + __dst)) = *(int32_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int32_t*)(localVarBase + __dst)) = *(uint32_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int64_t*)(localVarBase + __dst)) = *(int64_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					(*(int64_t*)(localVarBase + __dst)) = *(uint64_t*)((byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy8((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy12((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy16((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy20((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy24((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy28((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					Copy32((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_n_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __size = *(uint16_t*)(ip + 6);
					std::memmove((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::LdfldValueTypeLargeVarVar_n_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint32_t __size = *(uint32_t*)(ip + 12);
					std::memmove((void*)(localVarBase + __dst), (byte*)(void*)(localVarBase + __obj) + __offset, __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_i1:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int8_t*)(_fieldAddr_) = (*(int8_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_u1:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint8_t*)(_fieldAddr_) = (*(uint8_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_i2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int16_t*)(_fieldAddr_) = (*(int16_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_u2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint16_t*)(_fieldAddr_) = (*(uint16_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_i4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int32_t*)(_fieldAddr_) = (*(int32_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_u4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint32_t*)(_fieldAddr_) = (*(uint32_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_i8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(int64_t*)(_fieldAddr_) = (*(int64_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_u8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(uint64_t*)(_fieldAddr_) = (*(uint64_t*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_ref:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    *(Il2CppObject**)(_fieldAddr_) = (*(Il2CppObject**)(localVarBase + __data));HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_8:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy8((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_12:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy12((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_16:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy16((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_20:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy20((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_24:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy24((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_28:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy28((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_size_32:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    Copy32((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_n_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_n_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    std::memmove((uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset, (void*)(localVarBase + __data), __size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_WriteBarrier_n_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
					uint16_t __size = *(uint16_t*)(ip + 6);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::StfldLargeVarVar_WriteBarrier_n_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint32_t __offset = *(uint32_t*)(ip + 8);
					uint16_t __data = *(uint16_t*)(ip + 4);
					uint32_t __size = *(uint32_t*)(ip + 12);
				    CHECK_NOT_NULL_THROW((*(Il2CppObject**)(localVarBase + __obj)));
				    void* _fieldAddr_ = (uint8_t*)(*(Il2CppObject**)(localVarBase + __obj)) + __offset;
				    std::memmove(_fieldAddr_, (void*)(localVarBase + __data), __size);
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_fieldAddr_, (size_t)__size);
				    ip += 16;
				    continue;
				}

				//!!!}}OBJECT
#pragma endregion

#pragma region ARRAY
		//!!!{{ARRAY
				case HiOpcodeEnum::NewArrVarVar:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __size = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(Il2CppArray**)(localVarBase + __arr)) =  il2cpp::vm::Array::NewSpecific(__klass, (*(int32_t*)(localVarBase + __size)));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::GetArrayLengthVarVar:
				{
					uint16_t __len = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
				    CHECK_NOT_NULL_THROW((*(Il2CppArray**)(localVarBase + __arr)));
				    (*(int64_t*)(localVarBase + __len)) = (int64_t)il2cpp::vm::Array::GetLength((*(Il2CppArray**)(localVarBase + __arr)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementAddressAddrVarVar:
				{
					uint16_t __addr = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(void**)(localVarBase + __addr)) = GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), il2cpp::vm::Array::GetElementSize(arr->klass));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementAddressCheckAddrVarVar:
				{
					uint16_t __addr = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
					Il2CppClass* __eleKlass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    CheckArrayElementTypeMatch(arr->klass, __eleKlass);
				    (*(void**)(localVarBase + __addr)) = GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), il2cpp::vm::Array::GetElementSize(arr->klass));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_i1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, int8_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_u1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, uint8_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_i2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, int16_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_u2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, uint16_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_i4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, int32_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_u4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int32_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, uint32_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_i8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int64_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, int64_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_u8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    (*(int64_t*)(localVarBase + __dst)) = il2cpp_array_get(arr, uint64_t, (*(int32_t*)(localVarBase + __index)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy1((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 1));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_2:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy2((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 2));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_4:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy4((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 4));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_8:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy8((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 8));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_12:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy12((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 12));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_16:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy16((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 16));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_20:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy20((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 20));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_24:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy24((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 24));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_28:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy28((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 28));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_size_32:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    Copy32((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), 32));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetArrayElementVarVar_n:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __index = *(uint16_t*)(ip + 6);
				    Il2CppArray* arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(arr, (*(int32_t*)(localVarBase + __index)));
				    int32_t eleSize = il2cpp::vm::Array::GetElementSize(arr->klass);
				    std::memmove((void*)(localVarBase + __dst), GET_ARRAY_ELEMENT_ADDRESS(arr, (*(int32_t*)(localVarBase + __index)), eleSize), eleSize);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_i1:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), int8_t, (*(int32_t*)(localVarBase + __index)), (*(int8_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_u1:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), uint8_t, (*(int32_t*)(localVarBase + __index)), (*(uint8_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_i2:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), int16_t, (*(int32_t*)(localVarBase + __index)), (*(int16_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_u2:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), uint16_t, (*(int32_t*)(localVarBase + __index)), (*(uint16_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_i4:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), int32_t, (*(int32_t*)(localVarBase + __index)), (*(int32_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_u4:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), uint32_t, (*(int32_t*)(localVarBase + __index)), (*(uint32_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_i8:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), int64_t, (*(int32_t*)(localVarBase + __index)), (*(int64_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_u8:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    il2cpp_array_set((*(Il2CppArray**)(localVarBase + __arr)), uint64_t, (*(int32_t*)(localVarBase + __index)), (*(uint64_t*)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_ref:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    CheckArrayElementTypeCompatible((*(Il2CppArray**)(localVarBase + __arr)), (*(Il2CppObject**)(localVarBase + __ele)));
				    il2cpp_array_setref((*(Il2CppArray**)(localVarBase + __arr)), (*(int32_t*)(localVarBase + __index)), (*(Il2CppObject**)(localVarBase + __ele)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_size_12:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    Copy12(GET_ARRAY_ELEMENT_ADDRESS(_arr, (*(int32_t*)(localVarBase + __index)), 12), (void*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_size_16:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    Copy16(GET_ARRAY_ELEMENT_ADDRESS(_arr, (*(int32_t*)(localVarBase + __index)), 16), (void*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_n:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    int32_t _eleSize = il2cpp::vm::Array::GetElementSize(_arr->klass);
				    SetArrayElementWithSize(_arr, _eleSize, (*(int32_t*)(localVarBase + __index)), (void*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetArrayElementVarVar_WriteBarrier_n:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, (*(int32_t*)(localVarBase + __index)));
				    int32_t _eleSize = il2cpp::vm::Array::GetElementSize(_arr->klass);
				    il2cpp_array_setrefwithsize(_arr, _eleSize, (*(int32_t*)(localVarBase + __index)), (void*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewMdArrVarVar_length:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(Il2CppArray**)(localVarBase + __arr)) =  NewMdArray(__klass, (StackObject*)(void*)(localVarBase + __lengthIdxs), nullptr);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewMdArrVarVar_length_bound:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __lowerBoundIdxs = *(uint16_t*)(ip + 6);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(Il2CppArray**)(localVarBase + __arr)) =  NewMdArray(__klass, (StackObject*)(void*)(localVarBase + __lengthIdxs), (StackObject*)(void*)(localVarBase + __lowerBoundIdxs));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_i1:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementExpandToStack<int8_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_u1:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementExpandToStack<uint8_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_i2:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementExpandToStack<int16_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_u2:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementExpandToStack<uint16_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_i4:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementCopyToStack<int32_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_u4:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementCopyToStack<uint32_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_i8:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementCopyToStack<int64_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_u8:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementCopyToStack<uint64_t>((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementVarVar_n:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    GetMdArrayElementBySize((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __value));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetMdArrElementAddressVarVar:
				{
					uint16_t __addr = *(uint16_t*)(ip + 2);
					uint16_t __arr = *(uint16_t*)(ip + 4);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 6);
				    (*(void**)(localVarBase + __addr)) = GetMdArrayElementAddress((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_i1:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(int8_t*)_addr = (*(int8_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_u1:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(uint8_t*)_addr = (*(uint8_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_i2:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(int16_t*)_addr = (*(int16_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_u2:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(uint16_t*)_addr = (*(uint16_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_i4:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(int32_t*)_addr = (*(int32_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_u4:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(uint32_t*)_addr = (*(uint32_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_i8:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(int64_t*)_addr = (*(int64_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_u8:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    *(uint64_t*)_addr = (*(uint64_t*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_ref:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    void* _addr = GetMdArrayElementAddress(_arr, (StackObject*)(void*)(localVarBase + __lengthIdxs));
				    CheckArrayElementTypeCompatible(_arr, (*(Il2CppObject**)(localVarBase + __ele)));
				    *(Il2CppObject**)_addr = (*(Il2CppObject**)(localVarBase + __ele));
				    HYBRIDCLR_SET_WRITE_BARRIER((void**)_addr);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_n:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    SetMdArrayElement((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::SetMdArrElementVarVar_WriteBarrier_n:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __lengthIdxs = *(uint16_t*)(ip + 4);
					uint16_t __ele = *(uint16_t*)(ip + 6);
				    SetMdArrayElementWriteBarrier((*(Il2CppArray**)(localVarBase + __arr)), (StackObject*)(void*)(localVarBase + __lengthIdxs), (void*)(localVarBase + __ele));
				    ip += 8;
				    continue;
				}

				//!!!}}ARRAY
#pragma endregion

#pragma region EXCEPTION
		//!!!{{EXCEPTION
				case HiOpcodeEnum::ThrowEx:
				{
					uint16_t __exceptionObj = *(uint16_t*)(ip + 2);
					uint16_t __firstHandlerIndex = *(uint16_t*)(ip + 4);
					THROW_EX((Il2CppException*)(*(Il2CppObject**)(localVarBase + __exceptionObj)), __firstHandlerIndex);
				    continue;
				}
				case HiOpcodeEnum::RethrowEx:
				{
					RETHROW_EX();
				    continue;
				}
				case HiOpcodeEnum::LeaveEx:
				{
					int32_t __target = *(int32_t*)(ip + 4);
					uint16_t __firstHandlerIndex = *(uint16_t*)(ip + 2);
					LEAVE_EX(__target, __firstHandlerIndex);
				    continue;
				}
				case HiOpcodeEnum::LeaveEx_Directly:
				{
					int32_t __target = *(int32_t*)(ip + 4);
					LEAVE_EX_DIRECTLY(__target);
				    continue;
				}
				case HiOpcodeEnum::EndFilterEx:
				{
					uint16_t __value = *(uint16_t*)(ip + 2);
					ENDFILTER_EX((*(bool*)(localVarBase + __value)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::EndFinallyEx:
				{
					ENDFINALLY_EX();
				    continue;
				}

				//!!!}}EXCEPTION
#pragma endregion

#pragma region instrinct
		//!!!{{INSTRINCT
				case HiOpcodeEnum::NullableNewVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __data = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    NewNullableValueType((void*)(localVarBase + __dst), (void*)(localVarBase + __data), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NullableCtorVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __data = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    InitNullableValueType((*(void**)(localVarBase + __dst)), (void*)(localVarBase + __data), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NullableHasValueVar:
				{
					uint16_t __result = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    (*(uint32_t*)(localVarBase + __result)) = IsNullableHasValue((*(void**)(localVarBase + __obj)), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NullableGetValueOrDefaultVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    GetNullableValueOrDefault2StackDataByType((void*)(localVarBase + __dst), (*(void**)(localVarBase + __obj)), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NullableGetValueOrDefaultVarVar_1:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					uint16_t __defaultValue = *(uint16_t*)(ip + 6);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    GetNullableValueOrDefault2StackDataByType((void*)(localVarBase + __dst), (*(void**)(localVarBase + __obj)), (void*)(localVarBase + __defaultValue), __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NullableGetValueVarVar:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __obj = *(uint16_t*)(ip + 4);
					Il2CppClass* __klass = ((Il2CppClass*)imi->resolveDatas[*(uint32_t*)(ip + 8)]);
				    GetNullableValueOrDefault2StackDataByType((void*)(localVarBase + __dst), (*(void**)(localVarBase + __obj)), nullptr, __klass);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::InterlockedCompareExchangeVarVarVarVar_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __location = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
					uint16_t __comparand = *(uint16_t*)(ip + 8);
				    (*(int32_t*)(localVarBase + __ret)) = HiInterlockedCompareExchange((int32_t*)(*(void**)(localVarBase + __location)), (*(int32_t*)(localVarBase + __value)), (*(int32_t*)(localVarBase + __comparand)));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::InterlockedCompareExchangeVarVarVarVar_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __location = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
					uint16_t __comparand = *(uint16_t*)(ip + 8);
				    (*(int64_t*)(localVarBase + __ret)) = HiInterlockedCompareExchange((int64_t*)(*(void**)(localVarBase + __location)), (*(int64_t*)(localVarBase + __value)), (*(int64_t*)(localVarBase + __comparand)));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::InterlockedCompareExchangeVarVarVarVar_pointer:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __location = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
					uint16_t __comparand = *(uint16_t*)(ip + 8);
				    (*(void**)(localVarBase + __ret)) = HiInterlockedCompareExchange((void**)(*(void**)(localVarBase + __location)), (*(void**)(localVarBase + __value)), (*(void**)(localVarBase + __comparand)));
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::InterlockedExchangeVarVarVar_i4:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __location = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    (*(int32_t*)(localVarBase + __ret)) = HiInterlockedExchange((int32_t*)(*(void**)(localVarBase + __location)), (*(int32_t*)(localVarBase + __value)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InterlockedExchangeVarVarVar_i8:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __location = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    (*(int64_t*)(localVarBase + __ret)) = HiInterlockedExchange((int64_t*)(*(void**)(localVarBase + __location)), (*(int64_t*)(localVarBase + __value)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::InterlockedExchangeVarVarVar_pointer:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
					uint16_t __location = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    (*(void**)(localVarBase + __ret)) = HiInterlockedExchange((void**)(*(void**)(localVarBase + __location)), (*(void**)(localVarBase + __value)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewSystemObjectVar:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
				(*(Il2CppObject**)(localVarBase + __obj)) = il2cpp::vm::Object::New(il2cpp_defaults.object_class);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewVector2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
				    *(HtVector2f*)(void*)(localVarBase + __obj) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y))};
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewVector3_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
				    *(HtVector3f*)(void*)(localVarBase + __obj) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), 0};
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewVector3_3:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
					uint16_t __z = *(uint16_t*)(ip + 8);
				    *(HtVector3f*)(void*)(localVarBase + __obj) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), (*(float*)(localVarBase + __z))};
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewVector4_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
				    *(HtVector4f*)(void*)(localVarBase + __obj) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), 0, 0};
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewVector4_3:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
					uint16_t __z = *(uint16_t*)(ip + 8);
				    *(HtVector4f*)(void*)(localVarBase + __obj) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), (*(float*)(localVarBase + __z)), 0};
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewVector4_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
					uint16_t __z = *(uint16_t*)(ip + 8);
					uint16_t __w = *(uint16_t*)(ip + 10);
				    *(HtVector4f*)(void*)(localVarBase + __obj) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), (*(float*)(localVarBase + __z)), (*(float*)(localVarBase + __w))};
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CtorVector2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
				    *(HtVector2f*)(*(void**)(localVarBase + __obj)) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y))};
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CtorVector3_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
				    *(HtVector3f*)(*(void**)(localVarBase + __obj)) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), 0};
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CtorVector3_3:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
					uint16_t __z = *(uint16_t*)(ip + 8);
				    *(HtVector3f*)(*(void**)(localVarBase + __obj)) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), (*(float*)(localVarBase + __z))};
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CtorVector4_2:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
				    *(HtVector4f*)(*(void**)(localVarBase + __obj)) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), 0, 0};
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::CtorVector4_3:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
					uint16_t __z = *(uint16_t*)(ip + 8);
				    *(HtVector4f*)(*(void**)(localVarBase + __obj)) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), (*(float*)(localVarBase + __z)), 0};
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::CtorVector4_4:
				{
					uint16_t __obj = *(uint16_t*)(ip + 2);
					uint16_t __x = *(uint16_t*)(ip + 4);
					uint16_t __y = *(uint16_t*)(ip + 6);
					uint16_t __z = *(uint16_t*)(ip + 8);
					uint16_t __w = *(uint16_t*)(ip + 10);
				    *(HtVector4f*)(*(void**)(localVarBase + __obj)) = {(*(float*)(localVarBase + __x)), (*(float*)(localVarBase + __y)), (*(float*)(localVarBase + __z)), (*(float*)(localVarBase + __w))};
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::ArrayGetGenericValueImpl:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    int32_t _index = (*(int32_t*)(localVarBase + __index));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, _index);
				    int32_t _eleSize = il2cpp::vm::Array::GetElementSize(_arr->klass);
				    std::memmove((*(void**)(localVarBase + __value)), GET_ARRAY_ELEMENT_ADDRESS(_arr, _index, _eleSize), _eleSize);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::ArraySetGenericValueImpl:
				{
					uint16_t __arr = *(uint16_t*)(ip + 2);
					uint16_t __index = *(uint16_t*)(ip + 4);
					uint16_t __value = *(uint16_t*)(ip + 6);
				    Il2CppArray* _arr = (*(Il2CppArray**)(localVarBase + __arr));
				    int32_t _index = (*(int32_t*)(localVarBase + __index));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY(_arr, _index);
				    int32_t _eleSize = il2cpp::vm::Array::GetElementSize(_arr->klass);
				    il2cpp_array_setrefwithsize(_arr, _eleSize, _index, (*(void**)(localVarBase + __value)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewString:
				{
					uint16_t __str = *(uint16_t*)(ip + 2);
					uint16_t __chars = *(uint16_t*)(ip + 4);
				    Il2CppArray* _chars = (*(Il2CppArray**)(localVarBase + __chars));
				    CHECK_NOT_NULL_THROW(_chars);
				    (*(Il2CppString**)(localVarBase + __str)) = il2cpp::vm::String::NewUtf16((const Il2CppChar*)il2cpp::vm::Array::GetFirstElementAddress(_chars), il2cpp::vm::Array::GetLength(_chars));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::NewString_2:
				{
					uint16_t __str = *(uint16_t*)(ip + 2);
					uint16_t __chars = *(uint16_t*)(ip + 4);
					uint16_t __startIndex = *(uint16_t*)(ip + 6);
					uint16_t __length = *(uint16_t*)(ip + 8);
				    Il2CppArray* _chars = (*(Il2CppArray**)(localVarBase + __chars));
				    int32_t _startIndex = (*(uint32_t*)(localVarBase + __startIndex));
				    int32_t _length = (*(uint32_t*)(localVarBase + __length));
				    CHECK_NOT_NULL_AND_ARRAY_BOUNDARY2(_chars, _startIndex, _length);
				    (*(Il2CppString**)(localVarBase + __str)) = il2cpp::vm::String::NewUtf16(((const Il2CppChar*)il2cpp::vm::Array::GetFirstElementAddress(_chars)) + _startIndex, _length);
				    ip += 16;
				    continue;
				}
				case HiOpcodeEnum::NewString_3:
				{
					uint16_t __str = *(uint16_t*)(ip + 2);
					uint16_t __c = *(uint16_t*)(ip + 4);
					uint16_t __count = *(uint16_t*)(ip + 6);
				    int32_t _count = (*(int32_t*)(localVarBase + __count));
				    if (_count < 0)
				    {
				        il2cpp::vm::Exception::RaiseArgumentOutOfRangeException("new string(char c, int count)");
				    }
				    Il2CppChar _c = (Il2CppChar)(*(uint16_t*)(localVarBase + __c));
				    Il2CppString* _str = (*(Il2CppString**)(localVarBase + __str)) = il2cpp::vm::String::NewSize(_count);
				    std::fill_n(_str->chars, _count, _c);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::UnsafeEnumCast:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
					uint16_t __srcType = *(uint16_t*)(ip + 6);
				    (*(int32_t*)(localVarBase + __dst)) =  UnsafeEnumCast((void*)(localVarBase + __src), __srcType);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::GetEnumHashCode:
				{
					uint16_t __dst = *(uint16_t*)(ip + 2);
					uint16_t __src = *(uint16_t*)(ip + 4);
				    (*(int32_t*)(localVarBase + __dst)) = GetEnumLongHashCode((*(void**)(localVarBase + __src)));
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::AssemblyGetExecutingAssembly:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    (*(Il2CppObject**)(localVarBase + __ret)) = (Il2CppObject*)il2cpp::vm::Reflection::GetAssemblyObject(frame->method->klass->image->assembly);
				    ip += 8;
				    continue;
				}
				case HiOpcodeEnum::MethodBaseGetCurrentMethod:
				{
					uint16_t __ret = *(uint16_t*)(ip + 2);
				    (*(Il2CppObject**)(localVarBase + __ret)) = (Il2CppObject*)il2cpp::vm::Reflection::GetMethodObject(frame->method, nullptr);
				    ip += 8;
				    continue;
				}

				//!!!}}INSTRINCT
#pragma endregion
				default:
					RaiseExecutionEngineException("");
					break;
				}
			}
		ExitEvalLoop:;
		}
		catch (Il2CppExceptionWrapper ex)
		{
			PREPARE_EXCEPTION(ex.ex, 0);
			FIND_NEXT_EX_HANDLER_OR_UNWIND();
		}
		return;
	UnWindFail:
		IL2CPP_ASSERT(lastUnwindException);
		IL2CPP_ASSERT(interpFrameGroup.GetFrameCount() == 0);
		il2cpp::vm::Exception::Raise(lastUnwindException);
	}


}
}


```

`hybridclr/interpreter/MemoryUtil.h`:

```h
#pragma once
#include "InterpreterDefs.h"

namespace hybridclr
{
namespace interpreter
{

	inline void Copy1(void* dst, void* src)
	{
		*(uint8_t*)dst = *(uint8_t*)src;
	}

	inline void Copy2(void* dst, void* src)
	{
		*(uint16_t*)dst = *(uint16_t*)src;
	}

	inline void Copy4(void* dst, void* src)
	{
		*(uint32_t*)dst = *(uint32_t*)src;
	}

	inline void Copy8(void* dst, void* src)
	{
		*(uint64_t*)dst = *(uint64_t*)src;
	}

	inline void Copy12(void* dst, void* src)
	{
		if (dst <= src)
		{
			*(uint64_t*)dst = *(uint64_t*)src;
			*(uint32_t*)((byte*)dst + 8) = *(uint32_t*)((byte*)src + 8);
		}
		else
		{
			*(uint32_t*)((byte*)dst + 8) = *(uint32_t*)((byte*)src + 8);
			*(uint64_t*)dst = *(uint64_t*)src;
		}
	}

	inline void Copy16(void* dst, void* src)
	{
		if (dst <= src)
		{
			*(uint64_t*)dst = *(uint64_t*)src;
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
		}
		else
		{
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)dst = *(uint64_t*)src;
		}
	}

	inline void Copy20(void* dst, void* src)
	{
		if (dst <= src)
		{
			*(uint64_t*)dst = *(uint64_t*)src;
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint32_t*)((byte*)dst + 16) = *(uint32_t*)((byte*)src + 16);
		}
		else
		{
			*(uint32_t*)((byte*)dst + 16) = *(uint32_t*)((byte*)src + 16);
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)dst = *(uint64_t*)src;
		}
	}

	inline void Copy24(void* dst, void* src)
	{
		if (dst <= src)
		{
			*(uint64_t*)dst = *(uint64_t*)src;
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)((byte*)dst + 16) = *(uint64_t*)((byte*)src + 16);
		}
		else
		{
			*(uint64_t*)((byte*)dst + 16) = *(uint64_t*)((byte*)src + 16);
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)dst = *(uint64_t*)src;
		}
	}

	inline void Copy28(void* dst, void* src)
	{
		if (dst <= src)
		{
			*(uint64_t*)dst = *(uint64_t*)src;
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)((byte*)dst + 16) = *(uint64_t*)((byte*)src + 16);
			*(uint32_t*)((byte*)dst + 24) = *(uint32_t*)((byte*)src + 24);
		}
		else
		{
			*(uint32_t*)((byte*)dst + 24) = *(uint32_t*)((byte*)src + 24);
			*(uint64_t*)((byte*)dst + 16) = *(uint64_t*)((byte*)src + 16);
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)dst = *(uint64_t*)src;
		}
	}

	inline void Copy32(void* dst, void* src)
	{
		if (dst <= src)
		{
			*(uint64_t*)dst = *(uint64_t*)src;
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)((byte*)dst + 16) = *(uint64_t*)((byte*)src + 16);
			*(uint64_t*)((byte*)dst + 24) = *(uint64_t*)((byte*)src + 24);
		}
		else
		{
			*(uint64_t*)((byte*)dst + 24) = *(uint64_t*)((byte*)src + 24);
			*(uint64_t*)((byte*)dst + 16) = *(uint64_t*)((byte*)src + 16);
			*(uint64_t*)((byte*)dst + 8) = *(uint64_t*)((byte*)src + 8);
			*(uint64_t*)dst = *(uint64_t*)src;
		}
	}

	inline void CopyStackObject(StackObject* dst, void* vsrc, uint32_t count)
	{
		StackObject* src = (StackObject*)vsrc;
		IL2CPP_ASSERT(dst + count <= src || src + count <= dst);
		switch (count)
		{
		case 8: dst[7] = src[7];
		case 7: dst[6] = src[6];
		case 6: dst[5] = src[5];
		case 5: dst[4] = src[4];
		case 4: dst[3] = src[3];
		case 3: dst[2] = src[2];
		case 2: dst[1] = src[1];
		case 1: *dst = *src; break;
		case 0: break;
		default: std::memcpy(dst, src, count * sizeof(StackObject));
		}
	}

	inline void CopyBySize(void* dst, void* src, uint32_t size)
	{
		switch (size)
		{
		case 1: Copy1(dst, src); break;
		default: std::memmove(dst, src, size); break;
		}
	}

	inline void InitDefault1(void* dst)
	{
		*(uint8_t*)dst = 0;
	}

	inline void InitDefault2(void* dst)
	{
		*(uint16_t*)dst = 0;
	}

	inline void InitDefault4(void* dst)
	{
		*(uint32_t*)dst = 0;
	}

	inline void InitDefault8(void* dst)
	{
		*(uint64_t*)dst = 0;
	}

	inline void InitDefault12(void* dst)
	{
		int32_t* p = (int32_t*)dst;
		p[0] = 0;
		p[1] = 0;
		p[2] = 0;
	}

	inline void InitDefault16(void* dst)
	{
		*(uint64_t*)dst = 0;
		*(uint64_t*)((byte*)dst + 8) = 0;
	}

	inline void InitDefault20(void* dst)
	{
		int32_t* p = (int32_t*)dst;
		p[0] = 0;
		p[1] = 0;
		p[2] = 0;
		p[3] = 0;
		p[4] = 0;
	}

	inline void InitDefault24(void* dst)
	{
		*(uint64_t*)dst = 0;
		*(uint64_t*)((byte*)dst + 8) = 0;
		*(uint64_t*)((byte*)dst + 16) = 0;
	}

	inline void InitDefault28(void* dst)
	{
		int32_t* p = (int32_t*)dst;
		p[0] = 0;
		p[1] = 0;
		p[2] = 0;
		p[3] = 0;
		p[4] = 0;
		p[5] = 0;
		p[6] = 0;
	}

	inline void InitDefault32(void* dst)
	{
		*(uint64_t*)dst = 0;
		*(uint64_t*)((byte*)dst + 8) = 0;
		*(uint64_t*)((byte*)dst + 16) = 0;
		*(uint64_t*)((byte*)dst + 24) = 0;
	}

	inline void InitDefaultN(void* dst, size_t size)
	{
		std::memset(dst, 0, size);
	}
}
}

```

`hybridclr/interpreter/MethodBridge.cpp`:

```cpp
#include "MethodBridge.h"

#include "vm/Object.h"
#include "vm/Class.h"
#include "metadata/GenericMetadata.h"

#include "../metadata/MetadataModule.h"
#include "../metadata/MetadataUtil.h"

#include "Interpreter.h"
#include "InterpreterModule.h"
#include "MemoryUtil.h"

namespace hybridclr
{
namespace interpreter
{

	void ConvertInvokeArgs(StackObject* resultArgs, const MethodInfo* method, MethodArgDesc* argDescs, void** args)
	{
		int32_t dstIdx = 0;
		for (uint8_t i = 0; i < method->parameters_count; i++)
		{
			StackObject* dst = resultArgs + dstIdx;
			MethodArgDesc& argDesc = argDescs[i];
			if (argDesc.passbyValWhenInvoke)
			{
				dst->ptr = args[i];
				++dstIdx;
			}
			else
			{
#if SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS
				CopyStackObject(dst, args[i], argDesc.stackObjectSize);
#else
				std::memcpy(dst, args[i], argDesc.stackObjectSize * sizeof(StackObject));
#endif
				dstIdx += argDesc.stackObjectSize;
			}
		}
	}
	
	static void AppendString(char* sigBuf, size_t bufSize, size_t& pos, const char* str)
	{
		size_t len = std::strlen(str);
		if (pos + len < bufSize)
		{
			std::strcpy(sigBuf + pos, str);
			pos += len;
		}
		else
		{
			RaiseExecutionEngineException("");
		}
	}

	inline void AppendSignatureObjOrRefOrPointer(char* sigBuf, size_t bufSize, size_t& pos)
	{
		AppendString(sigBuf, bufSize, pos, "u");
	}

	inline void AppendSignatureInterpreterValueType(char* sigBuf, size_t bufSize, size_t& pos)
	{
		AppendString(sigBuf, bufSize, pos, "$");
	}

	static void AppendSignature(const Il2CppType* type, char* sigBuf, size_t bufferSize, size_t& pos, bool convertTypeName2SigName = true);

	static bool IsSystemOrUnityAssembly(const Il2CppImage* image)
	{
		const char* assName = image->nameNoExt;
		if (std::strcmp(assName, "mscorlib") == 0)
		{
			return true;
		}
		if (std::strncmp(assName, "System.", 7) == 0)
		{
			return true;
		}
		if (std::strncmp(assName, "UnityEngine.", 12) == 0)
		{
			return true;
		}
		return false;
	}

	static void BuildValueTypeFullName(const Il2CppClass* klass, char* sigBuf, size_t bufferSize, size_t& pos)
	{
		if (klass->declaringType)
		{
			BuildValueTypeFullName(klass->declaringType, sigBuf, bufferSize, pos);
			AppendString(sigBuf, bufferSize, pos, "/");
			AppendString(sigBuf, bufferSize, pos, klass->name);
			return;
		}
		if (!IsSystemOrUnityAssembly(klass->image))
		{
			AppendString(sigBuf, bufferSize, pos, klass->image->nameNoExt);
			AppendString(sigBuf, bufferSize, pos, ":");
		}
		if (klass->namespaze[0])
		{
			AppendString(sigBuf, bufferSize, pos, klass->namespaze);
			AppendString(sigBuf, bufferSize, pos, ".");
		}
		AppendString(sigBuf, bufferSize, pos, klass->name);
	}

	static void BuildGenericValueTypeFullName(const Il2CppType* type, char* sigBuf, size_t bufferSize, size_t& pos)
	{
		const Il2CppType* underlyingGenericType = type->data.generic_class->type;
		const Il2CppClass* underlyingGenericClass = il2cpp::vm::Class::FromIl2CppType(underlyingGenericType);
		BuildValueTypeFullName(underlyingGenericClass, sigBuf, bufferSize, pos);
		AppendString(sigBuf, bufferSize, pos, "<");
		const Il2CppGenericInst* classInst = type->data.generic_class->context.class_inst;
		for (uint32_t i = 0 ; i < classInst->type_argc; ++i)
		{
			if (i != 0)
			{
				AppendString(sigBuf, bufferSize, pos, ",");
			}
			AppendSignature(classInst->type_argv[i], sigBuf, bufferSize, pos, false);
		}
		AppendString(sigBuf, bufferSize, pos, ">");
	}

	static void AppendSignature(const Il2CppType* type, char* sigBuf, size_t bufferSize, size_t& pos, bool convertTypeName2SigName)
	{
		if (type->byref)
		{
			AppendSignatureObjOrRefOrPointer(sigBuf, bufferSize, pos);
			return;
		}
		switch (type->type)
		{
		case IL2CPP_TYPE_VOID: AppendString(sigBuf, bufferSize, pos, "v"); break;
		case IL2CPP_TYPE_BOOLEAN: AppendString(sigBuf, bufferSize, pos, "u1"); break;
		case IL2CPP_TYPE_I1: AppendString(sigBuf, bufferSize, pos, "i1"); break;
		case IL2CPP_TYPE_U1: AppendString(sigBuf, bufferSize, pos, "u1"); break;
		case IL2CPP_TYPE_I2: AppendString(sigBuf, bufferSize, pos, "i2"); break;
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_CHAR: AppendString(sigBuf, bufferSize, pos, "u2"); break;
		case IL2CPP_TYPE_I4: AppendString(sigBuf, bufferSize, pos, "i4"); break;
		case IL2CPP_TYPE_U4: AppendString(sigBuf, bufferSize, pos, "u4"); break;
		case IL2CPP_TYPE_R4: AppendString(sigBuf, bufferSize, pos, "r4"); break;
		case IL2CPP_TYPE_R8: AppendString(sigBuf, bufferSize, pos, "r8"); break;
		case IL2CPP_TYPE_I8: AppendString(sigBuf, bufferSize, pos, "i8"); break;
		case IL2CPP_TYPE_U8: AppendString(sigBuf, bufferSize, pos, "u8"); break;
		case IL2CPP_TYPE_I: AppendString(sigBuf, bufferSize, pos, "i"); break;
		case IL2CPP_TYPE_U: AppendString(sigBuf, bufferSize, pos, "u"); break;
		case IL2CPP_TYPE_TYPEDBYREF:
		{
			IL2CPP_ASSERT(sizeof(Il2CppTypedRef) == sizeof(void*) * 3);
			AppendString(sigBuf, bufferSize, pos, "typedbyref");
			break;
		}
		case IL2CPP_TYPE_VALUETYPE:
		{
			const Il2CppTypeDefinition* typeDef = (const Il2CppTypeDefinition*)type->data.typeHandle;
			if (hybridclr::metadata::IsEnumType(typeDef))
			{
				AppendSignature(il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->elementTypeIndex), sigBuf, bufferSize, pos);
				break;
			}
			if (hybridclr::metadata::IsInterpreterType(typeDef))
			{
				AppendSignatureInterpreterValueType(sigBuf, bufferSize, pos);
				break;
			}
			char tempFullName[1024];
			size_t fullNamePos = 0;
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			BuildValueTypeFullName(klass, tempFullName, sizeof(tempFullName) - 1, fullNamePos);
			tempFullName[fullNamePos] = 0;
			AppendString(sigBuf, bufferSize, pos, convertTypeName2SigName ? InterpreterModule::GetValueTypeSignature(tempFullName) : tempFullName);
			break;
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			const Il2CppType* underlyingGenericType = type->data.generic_class->type;
			if (underlyingGenericType->type == IL2CPP_TYPE_CLASS)
			{
				AppendSignatureObjOrRefOrPointer(sigBuf, bufferSize, pos);
				break;
			}
			const Il2CppTypeDefinition* underlyingTypeDef = (const Il2CppTypeDefinition*)underlyingGenericType->data.typeHandle;
			if (hybridclr::metadata::IsEnumType(underlyingTypeDef))
			{
				AppendSignature(il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(underlyingTypeDef->elementTypeIndex), sigBuf, bufferSize, pos);
				break;
			}
			IL2CPP_ASSERT(underlyingGenericType->type == IL2CPP_TYPE_VALUETYPE);
			if (hybridclr::metadata::IsInterpreterType(underlyingTypeDef))
			{
				AppendSignatureInterpreterValueType(sigBuf, bufferSize, pos);
				break;
			}
			
			char tempFullName[1024];
			size_t fullNamePos = 0;
			BuildGenericValueTypeFullName(type, tempFullName, sizeof(tempFullName) - 1, fullNamePos);
			tempFullName[fullNamePos] = 0;
			AppendString(sigBuf, bufferSize, pos, convertTypeName2SigName ? InterpreterModule::GetValueTypeSignature(tempFullName) : tempFullName);
			break;
		}
		case IL2CPP_TYPE_VAR:
		case IL2CPP_TYPE_MVAR:
		{
			AppendString(sigBuf, bufferSize, pos, "!");
			break;
		}
		default: AppendSignatureObjOrRefOrPointer(sigBuf, bufferSize, pos); break;
		}
	}

	bool ComputeSignature(const Il2CppType* ret, const il2cpp::utils::dynamic_array<const Il2CppType*>& params, bool instanceCall, char* sigBuf, size_t bufferSize)
	{
		size_t pos = 0;
		AppendSignature(ret, sigBuf, bufferSize, pos);

		if (instanceCall)
		{
			AppendSignatureObjOrRefOrPointer(sigBuf, bufferSize, pos);
		}

		for (uint32_t i = 0, paramCount = (uint32_t)params.size(); i < paramCount; i++)
		{
			AppendSignature(params[i], sigBuf, bufferSize, pos);
		}
		sigBuf[pos] = 0;
		return true;
	}

	bool ComputeSignature(const Il2CppMethodDefinition* method, bool call, char* sigBuf, size_t bufferSize)
	{
		size_t pos = 0;
		if (method->genericContainerIndex != kGenericContainerIndexInvalid)
		{
			AppendString(sigBuf, bufferSize, pos, "!");
			return true;
		}

		const Il2CppImage* image = hybridclr::metadata::MetadataModule::GetImage(method)->GetIl2CppImage();

		AppendSignature(hybridclr::metadata::MetadataModule::GetIl2CppTypeFromEncodeIndex(method->returnType), sigBuf, bufferSize, pos);

		if (call && metadata::IsInstanceMethod(method))
		{
			AppendSignatureObjOrRefOrPointer(sigBuf, bufferSize, pos);
		}

		for (uint16_t i = 0; i < method->parameterCount; i++)
		{
			TypeIndex paramTypeIndex = hybridclr::metadata::MetadataModule::GetParameterDefinitionFromIndex(image, method->parameterStart + i)->typeIndex;
			AppendSignature(hybridclr::metadata::MetadataModule::GetIl2CppTypeFromEncodeIndex(paramTypeIndex), sigBuf, bufferSize, pos);
		}
		sigBuf[pos] = 0;
		return true;
	}

	inline bool ContainsGenericParameters(const MethodInfo* method)
	{
		IL2CPP_ASSERT(method->is_inflated);
		auto& ctx = method->genericMethod->context;
		if (ctx.class_inst && il2cpp::metadata::GenericMetadata::ContainsGenericParameters(ctx.class_inst))
		{
			return true;
		}
		if (ctx.method_inst && il2cpp::metadata::GenericMetadata::ContainsGenericParameters(ctx.method_inst))
		{
			return true;
		}
		return false;
	}

	bool ComputeSignature(const MethodInfo* method, bool call, char* sigBuf, size_t bufferSize)
	{
		size_t pos = 0;
		if (method->is_generic || (method->is_inflated && ContainsGenericParameters(method)))
		{
			AppendString(sigBuf, bufferSize, pos, "!");
			return true;
		}

		AppendSignature(method->return_type, sigBuf, bufferSize, pos);

		if (call && metadata::IsInstanceMethod(method))
		{
			AppendSignatureObjOrRefOrPointer(sigBuf, bufferSize, pos);
		}

		for (uint8_t i = 0; i < method->parameters_count; i++)
		{
			AppendSignature(GET_METHOD_PARAMETER_TYPE(method->parameters[i]), sigBuf, bufferSize, pos);
		}
		sigBuf[pos] = 0;
		return true;
	}

}
}

```

`hybridclr/interpreter/MethodBridge.h`:

```h
#pragma once

#include "../CommonDef.h"
#include "InterpreterDefs.h"

namespace hybridclr
{
namespace interpreter
{
	union StackObject;

	typedef void (*Managed2NativeCallMethod)(const MethodInfo* method, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret);
	typedef void (*NativeClassCtor0)(Il2CppObject* obj, const MethodInfo* method);

	struct Managed2NativeMethodInfo
	{
		const char* signature;
		Managed2NativeCallMethod method;
	};

	struct Native2ManagedMethodInfo
	{
		const char* signature;
		Il2CppMethodPointer method;
	};

	struct NativeAdjustThunkMethodInfo
	{
		const char* signature;
		Il2CppMethodPointer method;
	};

	struct FullName2Signature
	{
		const char* fullName;
		const char* signature;
	};

	extern const Managed2NativeMethodInfo g_managed2nativeStub[];
	extern const Native2ManagedMethodInfo g_native2managedStub[];
	extern const NativeAdjustThunkMethodInfo g_adjustThunkStub[];
	extern const FullName2Signature g_fullName2SignatureStub[];


	struct ReversePInvokeInfo
	{
		int32_t index;
		Il2CppMethodPointer methodPointer;
		const MethodInfo* methodInfo;
	};

	struct ReversePInvokeMethodData
	{
		const char* methodSig;
		Il2CppMethodPointer methodPointer;
	};

	extern const ReversePInvokeMethodData g_reversePInvokeMethodStub[];

	typedef void (*PInvokeMethodPointer)(intptr_t method, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret);

	struct PInvokeMethodData
	{
		const char* methodSig;
		PInvokeMethodPointer methodPointer;
	};
	extern const PInvokeMethodData g_PInvokeMethodStub[];


	typedef void (*Managed2NativeFunctionPointerCallMethod)(Il2CppMethodPointer methodPointer, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret);
	struct Managed2NativeFunctionPointerCallData
	{
		const char* methodSig;
		Managed2NativeFunctionPointerCallMethod methodPointer;
	};
	extern const Managed2NativeFunctionPointerCallData g_managed2NativeFunctionPointerCallStub[];
	
	void ConvertInvokeArgs(StackObject* resultArgs, const MethodInfo* method, MethodArgDesc* argDescs, void** args);

	bool ComputeSignature(const MethodInfo* method, bool call, char* sigBuf, size_t bufferSize);
	bool ComputeSignature(const Il2CppMethodDefinition* method, bool call, char* sigBuf, size_t bufferSize);
	bool ComputeSignature(const Il2CppType* ret, const il2cpp::utils::dynamic_array<const Il2CppType*>& params, bool instanceCall, char* sigBuf, size_t bufferSize);
	
	template<typename T> uint64_t N2MAsUint64ValueOrAddress(T& value)
	{
		return sizeof(T) <= 8 ? *(uint64_t*)&value : (uint64_t)&value;
	}

	template<typename T> T& M2NFromValueOrAddress(void* value)
	{
		//return sizeof(T) <= 8 ? *(T*)value : **(T**)value;
		return *(T*)value;
	}
	
}
}
```

`hybridclr/metadata/AOTHomologousImage.cpp`:

```cpp
#include "AOTHomologousImage.h"

#include "vm/MetadataLock.h"
#include "vm/GlobalMetadata.h"
#include "vm/Class.h"
#include "vm/Image.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"
#include "metadata/GenericMetadata.h"

namespace hybridclr
{
namespace metadata
{
	std::vector<AOTHomologousImage*> s_images;


	AOTHomologousImage* AOTHomologousImage::FindImageByAssembly(const Il2CppAssembly* ass)
	{
		il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);
		return FindImageByAssemblyLocked(ass, lock);
	}

	void AOTHomologousImage::RegisterLocked(AOTHomologousImage* image, il2cpp::os::FastAutoLock& lock)
	{
		IL2CPP_ASSERT(FindImageByAssemblyLocked(image->_targetAssembly, lock) == nullptr);
		s_images.push_back(image);
	}

	AOTHomologousImage* AOTHomologousImage::FindImageByAssemblyLocked(const Il2CppAssembly* ass, il2cpp::os::FastAutoLock& lock)
	{
		for (AOTHomologousImage* image : s_images)
		{
			if (image->_targetAssembly == ass)
			{
				return image;
			}
		}
		return nullptr;
	}

	LoadImageErrorCode AOTHomologousImage::Load(const byte* imageData, size_t length)
	{
		LoadImageErrorCode err = InitRawImage(imageData, length);
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}
		err = _rawImage->Load(imageData, length);
		if (err != LoadImageErrorCode::OK)
		{
			delete _rawImage;
			_rawImage = nullptr;
			return err;
		}

		TbAssembly data = _rawImage->ReadAssembly(1);
		const char* assName = _rawImage->GetStringFromRawIndex(data.name);
		const Il2CppAssembly* aotAss = GetLoadedAssembly(assName);
		// FIXME. not free memory.
		if (!aotAss)
		{
			return LoadImageErrorCode::AOT_ASSEMBLY_NOT_FIND;
		}
		if (hybridclr::metadata::IsInterpreterImage(aotAss->image))
		{
			return LoadImageErrorCode::HOMOLOGOUS_ONLY_SUPPORT_AOT_ASSEMBLY;
		}
		_targetAssembly = aotAss;

		return LoadImageErrorCode::OK;
	}

	const Il2CppType* AOTHomologousImage::GetModuleIl2CppType(uint32_t moduleRowIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound)
	{
		IL2CPP_ASSERT(moduleRowIndex == 1);
		const char* typeNameStr = _rawImage->GetStringFromRawIndex(typeName);
		const char* typeNamespaceStr = _rawImage->GetStringFromRawIndex(typeNamespace);

		const Il2CppImage* aotImage = il2cpp::vm::Assembly::GetImage(_targetAssembly);
		Il2CppClass* klass = il2cpp::vm::Class::FromName(aotImage, typeNamespaceStr, typeNameStr);
		if (klass)
		{
			return &klass->byval_arg;
		}
		if (!raiseExceptionIfNotFound)
		{
			return nullptr;
		}
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException(
			CStringToStringView(typeNamespaceStr),
			CStringToStringView(typeNameStr),
			CStringToStringView(aotImage->nameNoExt)));
		return nullptr;
	}
}
}


```

`hybridclr/metadata/AOTHomologousImage.h`:

```h
#pragma once
#include "Image.h"

namespace hybridclr
{
namespace metadata
{
	struct AOTFieldData
	{
		uint32_t typeDefIndex; // rowIndex - 1
		const Il2CppFieldDefinition* fieldDef;
	};

	enum class HomologousImageMode
	{
		CONSISTENT,
		SUPERSET,
	};

	class AOTHomologousImage : public Image
	{
	public:

		static AOTHomologousImage* FindImageByAssembly(const Il2CppAssembly* ass);
		static AOTHomologousImage* FindImageByAssemblyLocked(const Il2CppAssembly* ass, il2cpp::os::FastAutoLock& lock);
		static void RegisterLocked(AOTHomologousImage* image, il2cpp::os::FastAutoLock& lock);

		AOTHomologousImage() : _targetAssembly(nullptr) { }

		const Il2CppAssembly* GetTargetAssembly() const
		{
			return _targetAssembly;
		}

		void SetTargetAssembly(const Il2CppAssembly* targetAssembly)
		{
			_targetAssembly = targetAssembly;
		}

		LoadImageErrorCode Load(const byte* imageData, size_t length);

		const Il2CppType* GetModuleIl2CppType(uint32_t moduleRowIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound) override;
	protected:
		const Il2CppAssembly* _targetAssembly;
	};
}
}
```

`hybridclr/metadata/Assembly.cpp`:

```cpp

#include "Assembly.h"

#include <cstring>
#include <iostream>
#include <vector>

#include "os/File.h"
#include "utils/MemoryMappedFile.h"
#include "vm/Assembly.h"
#include "vm/Image.h"
#include "vm/Class.h"
#include "vm/String.h"
#include "vm/MetadataLock.h"
#include "vm/MetadataCache.h"

#include "Image.h"
#include "MetadataModule.h"
#include "MetadataUtil.h"
#include "ConsistentAOTHomologousImage.h"
#include "SuperSetAOTHomologousImage.h"

namespace hybridclr
{
namespace metadata
{

    std::vector<Il2CppAssembly*> s_placeHolderAssembies;

#if ENABLE_PLACEHOLDER_DLL == 1

    static const char* CreateAssemblyNameWithoutExt(const char* assemblyName)
    {
        const char* extStr = std::strstr(assemblyName, ".dll");
        if (extStr)
        {
            size_t nameLen = extStr - assemblyName;
            char* name = (char*)HYBRIDCLR_MALLOC(nameLen + 1);
            std::strncpy(name, assemblyName, nameLen);
            name[nameLen] = '\0';
            return name;
        }
        else
        {
            return CopyString(assemblyName);
        }
    }

    static Il2CppAssembly* CreatePlaceHolderAssembly(const char* assemblyName)
    {
        auto ass = new (HYBRIDCLR_MALLOC_ZERO(sizeof(Il2CppAssembly))) Il2CppAssembly;
        auto image2 = new (HYBRIDCLR_MALLOC_ZERO(sizeof(Il2CppImage))) Il2CppImage;
        ass->image = image2;
        ass->image->name = CopyString(assemblyName);
        ass->image->nameNoExt = ass->aname.name = CreateAssemblyNameWithoutExt(assemblyName);
        image2->assembly = ass;
        s_placeHolderAssembies.push_back(ass);
        return ass;
    }

    static Il2CppAssembly* FindPlaceHolderAssembly(const char* assemblyNameNoExt)
    {
        for (Il2CppAssembly* ass : s_placeHolderAssembies)
        {
            if (std::strcmp(ass->image->nameNoExt, assemblyNameNoExt) == 0)
            {
                return ass;
            }
        }
        return nullptr;
    }
#else
    static Il2CppAssembly* FindPlaceHolderAssembly(const char* assemblyNameNoExt)
    {
        return nullptr;
    }
#endif

    void Assembly::InitializePlaceHolderAssemblies()
    {
        for (const char** ptrPlaceHolderName = g_placeHolderAssemblies; *ptrPlaceHolderName; ++ptrPlaceHolderName)
        {
            const char* nameWithExtension = ConcatNewString(*ptrPlaceHolderName, ".dll");
            Il2CppAssembly* placeHolderAss = CreatePlaceHolderAssembly(nameWithExtension);
            HYBRIDCLR_FREE((void*)nameWithExtension);
            il2cpp::vm::MetadataCache::RegisterInterpreterAssembly(placeHolderAss);
        }
    }

    static void RunModuleInitializer(Il2CppImage* image)
    {
        Il2CppClass* moduleKlass = il2cpp::vm::Image::ClassFromName(image, "", "<Module>");
        if (!moduleKlass)
        {
            return;
        }
        il2cpp::vm::Runtime::ClassInit(moduleKlass);
    }

    Il2CppAssembly* Assembly::LoadFromBytes(const void* assemblyData, uint64_t length, const void* rawSymbolStoreBytes, uint64_t rawSymbolStoreLength)
    {
        Il2CppAssembly* ass = Create((const byte*)assemblyData, length, (const byte*)rawSymbolStoreBytes, rawSymbolStoreLength);
        RunModuleInitializer(ass->image);
        return ass;
    }

    Il2CppAssembly* Assembly::Create(const byte* assemblyData, uint64_t length, const byte* rawSymbolStoreBytes, uint64_t rawSymbolStoreLength)
    {
        il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

        if (!assemblyData)
        {
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentNullException("rawAssembly is null"));
        }

        uint32_t imageId = InterpreterImage::AllocImageIndex((uint32_t)length);
        if (imageId == kInvalidImageIndex)
        {
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException("InterpreterImage::AllocImageIndex failed"));
        }
        InterpreterImage* image = new InterpreterImage(imageId);
        
        assemblyData = (const byte*)CopyBytes(assemblyData, length);
        LoadImageErrorCode err = image->Load(assemblyData, (size_t)length);

        if (err != LoadImageErrorCode::OK)
        {
            TEMP_FORMAT(errMsg, "LoadImageErrorCode:%d", (int)err);
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetBadImageFormatException(errMsg));
            // when load a bad image, mean a fatal error. we don't clean image on purpose.
        }

        if (rawSymbolStoreBytes)
        {
            rawSymbolStoreBytes = (const byte*)CopyBytes(rawSymbolStoreBytes, rawSymbolStoreLength);
            err = image->LoadPDB(rawSymbolStoreBytes, (size_t)rawSymbolStoreLength);
            if (err != LoadImageErrorCode::OK)
            {
                TEMP_FORMAT(errMsg, "LoadPDB Error:%d", (int)err);
                il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetBadImageFormatException(errMsg));
            }
        }

        TbAssembly data = image->GetRawImage().ReadAssembly(1);
        const char* nameNoExt = image->GetStringFromRawIndex(data.name);

        Il2CppAssembly* ass;
        Il2CppImage* image2;
        if ((ass = FindPlaceHolderAssembly(nameNoExt)) != nullptr)
        {
            if (ass->token)
            {
                RaiseExecutionEngineException("reloading placeholder assembly is not supported!");
            }
            image2 = ass->image;
            HYBRIDCLR_FREE((void*)ass->image->name);
            HYBRIDCLR_FREE((void*)ass->image->nameNoExt);
        }
        else
        {
            ass = new (HYBRIDCLR_MALLOC_ZERO(sizeof(Il2CppAssembly))) Il2CppAssembly;
            image2 = new (HYBRIDCLR_MALLOC_ZERO(sizeof(Il2CppImage))) Il2CppImage;
        }

        image->InitBasic(image2);
        image->BuildIl2CppAssembly(ass);
        ass->image = image2;

        image->BuildIl2CppImage(image2);
        image2->name = ConcatNewString(ass->aname.name, ".dll");
        image2->nameNoExt = ass->aname.name;
        image2->assembly = ass;

        image->InitRuntimeMetadatas();

        il2cpp::vm::MetadataCache::RegisterInterpreterAssembly(ass);
        return ass;
    }

    LoadImageErrorCode Assembly::LoadMetadataForAOTAssembly(const void* dllBytes, uint32_t dllSize, HomologousImageMode mode)
    {
        il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

        AOTHomologousImage* image = nullptr;
        switch (mode)
        {
        case HomologousImageMode::CONSISTENT: image = new ConsistentAOTHomologousImage(); break;
        case HomologousImageMode::SUPERSET: image = new SuperSetAOTHomologousImage(); break;
        default: return LoadImageErrorCode::INVALID_HOMOLOGOUS_MODE;
        }

        LoadImageErrorCode err = image->Load((byte*)CopyBytes(dllBytes, dllSize), dllSize);
        if (err != LoadImageErrorCode::OK)
        {
            delete image;
            return err;
        }

        RawImageBase* rawImage = &image->GetRawImage();
        TbAssembly data = rawImage->ReadAssembly(1);
        const char* assName = rawImage->GetStringFromRawIndex(data.name);
        const Il2CppAssembly* aotAss = il2cpp::vm::Assembly::GetLoadedAssembly(assName);
        // FIXME. not free memory.
        if (!aotAss)
        {
            delete image;
            return LoadImageErrorCode::AOT_ASSEMBLY_NOT_FIND;
        }
        if (hybridclr::metadata::IsInterpreterImage(aotAss->image))
        {
            delete image;
            return LoadImageErrorCode::HOMOLOGOUS_ONLY_SUPPORT_AOT_ASSEMBLY;
        }
        image->SetTargetAssembly(aotAss);
        if (AOTHomologousImage::FindImageByAssemblyLocked(image->GetTargetAssembly(), lock))
        {
            return LoadImageErrorCode::HOMOLOGOUS_ASSEMBLY_HAS_BEEN_LOADED;
        }
        image->InitRuntimeMetadatas();
        AOTHomologousImage::RegisterLocked(image, lock);
        return LoadImageErrorCode::OK;
    }


}
}


```

`hybridclr/metadata/Assembly.h`:

```h
#pragma once

#include "../CommonDef.h"

#include "InterpreterImage.h"
#include "AOTHomologousImage.h"

namespace hybridclr
{
namespace metadata
{

    class Assembly
    {
    public:
        static void InitializePlaceHolderAssemblies();
        static Il2CppAssembly* LoadFromBytes(const void* assemblyData, uint64_t length, const void* rawSymbolStoreBytes, uint64_t rawSymbolStoreLength);
        static LoadImageErrorCode LoadMetadataForAOTAssembly(const void* dllBytes, uint32_t dllSize, HomologousImageMode mode);
    private:
        static Il2CppAssembly* Create(const byte* assemblyData, uint64_t length, const byte* rawSymbolStoreBytes, uint64_t rawSymbolStoreLength);
    };
}
}
```

`hybridclr/metadata/BlobReader.h`:

```h
#pragma once

#include "../CommonDef.h"
#include "MetadataUtil.h"

namespace hybridclr
{
namespace metadata
{

    class BlobReader
    {
    public:
        BlobReader(const byte* buf, uint32_t length) : _buf(buf), _length(length), _readPos(0)
        {

        }

        const byte* GetData() const
        {
            return _buf;
        }

        uint32_t GetLength() const
        {
            return _length;
        }

        uint32_t GetReadPosition() const
        {
            return _readPos;
        }

        const byte* GetDataOfReadPosition() const
        {
            return _buf + _readPos;
        }

        bool IsEmpty() const
        {
            return _readPos >= _length;
        }

        bool NonEmpty() const
        {
            return _readPos < _length;
        }

        int32_t ReadCompressedInt32()
        {
            uint32_t unsignedValue = ReadCompressedUint32();
            uint32_t value = unsignedValue >> 1;
            if (!(unsignedValue & 0x1))
            {
                return value;
            }
            if (value < 0x40)
            {
                return value - 0x40;
            }
            if (value < 0x2000)
            {
                return value - 0x2000;
            }
            if (value < 0x10000000)
            {
                return value - 0x10000000;
            }
            IL2CPP_ASSERT(value < 0x20000000);
            return value - 0x20000000;
        }

        static uint32_t ReadCompressedUint32(const byte* buf, uint32_t& lengthSize)
        {
            uint32_t firstByte = buf[0];
            if (firstByte < 128)
            {
                lengthSize = 1;
                return firstByte;
            }
            else if (firstByte < 192)
            {
                lengthSize = 2;
                return ((firstByte & 0x3f) << 8) | buf[1];
            }
            else if (firstByte < 224)
            {
                lengthSize = 4;
                return ((firstByte & 0x1f) << 24) | (((uint32_t)buf[1]) << 16) | ((uint32_t)buf[2] << 8) | (uint32_t)buf[3];
            }
            else
            {
                RaiseExecutionEngineException("bad metadata data. ReadEncodeLength fail");
                return 0;
            }
        }

        uint32_t ReadCompressedUint32()
        {
            uint32_t lengthSize;
            uint32_t value = ReadCompressedUint32(_buf + _readPos, lengthSize);
            _readPos += lengthSize;
            return value;
        }

        uint8_t ReadByte()
        {
            IL2CPP_ASSERT(_readPos < _length);
            return _buf[_readPos++];
        }

        uint16_t Read16()
        {
            IL2CPP_ASSERT(_readPos + 2 <= _length);
            uint16_t value = GetU2LittleEndian(_buf + _readPos);
            _readPos += 2;
            return value;
        }

        uint32_t Read32()
        {
            IL2CPP_ASSERT(_readPos + 4 <= _length);
            uint32_t value = (uint32_t)GetI4LittleEndian(_buf + _readPos);
            _readPos += 4;
            return value;
        }

        bool TryRead32(uint32_t& value)
        {
            if (_readPos + 4 <= _length)
            {
                value = Read32();
                return true;
            }
            return false;
        }

        uint64_t Read64()
        {
            IL2CPP_ASSERT(_readPos + 8 <= _length);
            uint64_t value = (uint64_t)GetI8LittleEndian(_buf + _readPos);
            _readPos += 8;
            return value;
        }

        float ReadFloat()
        {
            uint32_t x = Read32();
            return *(float*)&x;
        }

        double ReadDouble()
        {
            uint64_t x = Read64();
            return *(double*)&x;
        }

        //template<typename T>
        //T Read()
        //{
        //    IL2CPP_ASSERT(_readPos + sizeof(T) <= _length);
        //    T value = *(T*)(_buf + _readPos);
        //    _readPos += sizeof(T);
        //    return value;
        //}

        uint8_t PeekByte()
        {
            IL2CPP_ASSERT(_readPos < _length);
            return _buf[_readPos];
        }

        void SkipByte()
        {
            IL2CPP_ASSERT(_readPos < _length);
            ++_readPos;
        }

        void SkipBytes(uint32_t len)
        {
            IL2CPP_ASSERT(_readPos + len <= _length);
            const byte* data = _buf + _readPos;
            _readPos += len;
        }

        const byte* GetAndSkipCurBytes(uint32_t len)
        {
            IL2CPP_ASSERT(_readPos + len <= _length);
            const byte* data = _buf + _readPos;
            _readPos += len;
            return data;
        }

    private:
        const byte* const _buf;
        const uint32_t _length;
        uint32_t _readPos;
    };

}
}
```

`hybridclr/metadata/ClassFieldLayoutCalculator.cpp`:

```cpp
#include "ClassFieldLayoutCalculator.h"

#include "metadata/FieldLayout.h"
#include "metadata/GenericMetadata.h"
#include "vm/Field.h"

#include "InterpreterImage.h"

namespace hybridclr
{
namespace metadata
{
    typedef void* voidptr_t;
#define IL2CPP_ALIGN_STRUCT(type) struct type ## AlignStruct {uint8_t pad; type t; };

    IL2CPP_ALIGN_STRUCT(voidptr_t)
        IL2CPP_ALIGN_STRUCT(int8_t)
        IL2CPP_ALIGN_STRUCT(int16_t)
        IL2CPP_ALIGN_STRUCT(int32_t)
        IL2CPP_ALIGN_STRUCT(int64_t)
        IL2CPP_ALIGN_STRUCT(intptr_t)
        IL2CPP_ALIGN_STRUCT(float)
        IL2CPP_ALIGN_STRUCT(double)

#define IL2CPP_ALIGN_OF(type) ((int32_t)offsetof(type ## AlignStruct, t))

    SizeAndAlignment ClassFieldLayoutCalculator::GetTypeSizeAndAlignment(const Il2CppType* type)
    {
        SizeAndAlignment sa = { };
        if (type->byref)
        {
            sa.size = sa.nativeSize = sizeof(voidptr_t);
            sa.alignment = IL2CPP_ALIGN_OF(voidptr_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        }

        switch (type->type)
        {
        case IL2CPP_TYPE_I1:
        case IL2CPP_TYPE_U1:
        case IL2CPP_TYPE_BOOLEAN:
            sa.size = sa.nativeSize = sizeof(int8_t);
            sa.alignment = IL2CPP_ALIGN_OF(int8_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_I2:
        case IL2CPP_TYPE_U2:
        case IL2CPP_TYPE_CHAR:
            sa.size = sa.nativeSize = sizeof(int16_t);
            sa.alignment = IL2CPP_ALIGN_OF(int16_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_I4:
        case IL2CPP_TYPE_U4:
            sa.size = sa.nativeSize = sizeof(int32_t);
            sa.alignment = IL2CPP_ALIGN_OF(int32_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_I8:
        case IL2CPP_TYPE_U8:
            sa.size = sa.nativeSize = sizeof(int64_t);
            sa.alignment = IL2CPP_ALIGN_OF(int64_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_I:
        case IL2CPP_TYPE_U:
            // TODO should we use pointer or int32_t here?
            sa.size = sa.nativeSize = sizeof(intptr_t);
            sa.alignment = IL2CPP_ALIGN_OF(intptr_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_R4:
            sa.size = sa.nativeSize = sizeof(float);
            sa.alignment = IL2CPP_ALIGN_OF(float);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_R8:
            sa.size = sa.nativeSize = sizeof(double);
            sa.alignment = IL2CPP_ALIGN_OF(double);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_PTR:
        case IL2CPP_TYPE_FNPTR:
        case IL2CPP_TYPE_STRING:
        case IL2CPP_TYPE_SZARRAY:
        case IL2CPP_TYPE_ARRAY:
        case IL2CPP_TYPE_CLASS:
        case IL2CPP_TYPE_OBJECT:
            sa.size = sa.nativeSize = sizeof(voidptr_t);
            sa.alignment = IL2CPP_ALIGN_OF(voidptr_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_VAR:
        case IL2CPP_TYPE_MVAR:
            sa.size = sa.nativeSize = 1;
            sa.alignment = 1;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = sa.alignment;
#endif
            return sa;
        case IL2CPP_TYPE_VALUETYPE:
        {
            CalcClassNotStaticFields(type);
            ClassLayoutInfo& classLayout = *_classMap[type];
            sa.size = classLayout.instanceSize - sizeof(Il2CppObject);
            sa.nativeSize = classLayout.nativeSize;
            sa.alignment = classLayout.alignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            sa.naturalAlignment = classLayout.naturalAlignment;
#endif
            return sa;
        }
        case IL2CPP_TYPE_GENERICINST:
        {
            Il2CppGenericClass* gclass = type->data.generic_class;
            //Il2CppClass* container_class = GenericClass::GetTypeDefinition(gclass);
            const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
            if (IsValueType(typeDef))
            {
                CalcClassNotStaticFields(type);
                ClassLayoutInfo& classLayout = *_classMap[type];
                sa.size = classLayout.instanceSize - sizeof(Il2CppObject);
                sa.nativeSize = classLayout.nativeSize;
                sa.alignment = classLayout.alignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
                sa.naturalAlignment = classLayout.naturalAlignment;
#endif
            }
            else
            {
                sa.size = sa.nativeSize = sizeof(voidptr_t);
                sa.alignment = IL2CPP_ALIGN_OF(voidptr_t);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
                sa.naturalAlignment = sa.alignment;
#endif
            }
            return sa;
        }
        default:
            IL2CPP_ASSERT(0);
            break;
        }
        return sa;
    }

    static int32_t AlignTo(int32_t size, int32_t alignment)
    {
        if (size & (alignment - 1))
        {
            size += alignment - 1;
            size &= ~(alignment - 1);
        }

        return size;
    }

    void ClassFieldLayoutCalculator::LayoutFields(int32_t actualParentSize, int32_t parentAlignment, uint8_t packing, std::vector<FieldLayout*>& fields, FieldLayoutData& data)
    {
        //data.classSize = parentSize;
        data.actualClassSize = actualParentSize;
        IL2CPP_ASSERT(parentAlignment <= std::numeric_limits<uint8_t>::max());
        data.minimumAlignment = static_cast<uint8_t>(parentAlignment);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
        data.naturalAlignment = 0;
#endif
        data.nativeSize = 0;
        for (FieldLayout* field : fields)
        {
            SizeAndAlignment sa = GetTypeSizeAndAlignment(field->type);
            field->size = sa.size;// sa.nativeSize > 0 ? sa.nativeSize : sa.size;

            // For fields, we might not want to take the actual alignment of the type - that might account for
            // packing. When a type is used as a field, we should not care about its alignment with packing,
            // instead let's use its natural alignment, without regard for packing. So if it's alignment
            // is less than the compiler's minimum alignment (4 bytes), lets use the natural alignment if we have it.
            uint8_t alignment = sa.alignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            if (alignment < 4 && sa.naturalAlignment != 0)
                alignment = sa.naturalAlignment;
#endif
            if (packing != 0)
                alignment = std::min(sa.alignment, packing);
            int32_t offset = data.actualClassSize;

            offset += alignment - 1;
            offset &= ~(alignment - 1);
            field->offset = offset;

            data.FieldOffsets.push_back(offset);
            data.actualClassSize = offset + std::max(sa.size, (int32_t)1);
            data.minimumAlignment = std::max(data.minimumAlignment, alignment);
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            data.naturalAlignment = std::max({ data.naturalAlignment, sa.alignment, sa.naturalAlignment });
#endif
            data.nativeSize += sa.size;
        }

        data.classSize = AlignTo(data.actualClassSize, data.minimumAlignment);

        // C++ ABI difference between MS and Clang
#if IL2CPP_CXX_ABI_MSVC
        data.actualClassSize = data.classSize;
#endif
    }

    bool ClassFieldLayoutCalculator::IsBlittable(const Il2CppType* type)
    {
        if (type->byref)
        {
            return true;
        }

        switch (type->type)
        {
        case IL2CPP_TYPE_I1:
        case IL2CPP_TYPE_U1:
        case IL2CPP_TYPE_BOOLEAN:
        case IL2CPP_TYPE_I2:
        case IL2CPP_TYPE_U2:
        case IL2CPP_TYPE_CHAR:
        case IL2CPP_TYPE_I4:
        case IL2CPP_TYPE_U4:
        case IL2CPP_TYPE_I8:
        case IL2CPP_TYPE_U8:
        case IL2CPP_TYPE_I:
        case IL2CPP_TYPE_U:
        case IL2CPP_TYPE_R4:
        case IL2CPP_TYPE_R8:
        case IL2CPP_TYPE_PTR:
        case IL2CPP_TYPE_FNPTR:
            return true;
        case IL2CPP_TYPE_STRING:
        case IL2CPP_TYPE_SZARRAY:
        case IL2CPP_TYPE_ARRAY:
        case IL2CPP_TYPE_CLASS:
        case IL2CPP_TYPE_OBJECT:
        case IL2CPP_TYPE_VAR:
        case IL2CPP_TYPE_MVAR:
            return false;
        case IL2CPP_TYPE_VALUETYPE:
        {
            CalcClassNotStaticFields(type);
            ClassLayoutInfo& classLayout = *_classMap[type];
            return classLayout.blittable;
        }
        case IL2CPP_TYPE_GENERICINST:
        {
            const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
            if (IsValueType(typeDef))
            {
                CalcClassNotStaticFields(type);
                ClassLayoutInfo& classLayout = *_classMap[type];
                return classLayout.blittable;
            }
            else
            {
                return false;
            }
        }
        default:
            IL2CPP_ASSERT(0);
            return false;
        }
    }


    inline bool IsRawNormalStaticField(const Il2CppType* type, int32_t offset)
    {
        if ((type->attrs & FIELD_ATTRIBUTE_STATIC) == 0)
            return false;

        if (offset == THREAD_LOCAL_STATIC_MASK)
            return false;

        if ((type->attrs & FIELD_ATTRIBUTE_LITERAL) != 0)
            return false;

        return true;
    }

    inline bool IsRawThreadStaticField(const Il2CppType* type, int32_t offset)
    {
        if ((type->attrs & FIELD_ATTRIBUTE_STATIC) == 0)
            return false;

        if (offset != THREAD_LOCAL_STATIC_MASK)
            return false;

        if ((type->attrs & FIELD_ATTRIBUTE_LITERAL) != 0)
            return false;

        return true;
    }

	void ClassFieldLayoutCalculator::CalcClassNotStaticFields(const Il2CppType* type)
	{
		auto it = _classMap.find(type);
		if (it != _classMap.end())
		{
			return;
		}
		ClassLayoutInfo& layout = *(_classMap[type] = new (HYBRIDCLR_MALLOC_ZERO(sizeof(ClassLayoutInfo))) ClassLayoutInfo());
		layout.type = type;
		const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
        const char* typeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
		std::vector<FieldLayout>& fields = layout.fields;
        fields.resize(typeDef->field_count, {});

        bool isCurAssemblyType = DecodeImageIndex(typeDef->byvalTypeIndex) == _image->GetIndex();
        if ((type->type == IL2CPP_TYPE_VALUETYPE || type->type == IL2CPP_TYPE_CLASS) && !isCurAssemblyType)
        {
            Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
            il2cpp::vm::Class::SetupFields(klass);
            layout.instanceSize = klass->instance_size;
            layout.actualSize = klass->actualSize;
            layout.nativeSize = klass->native_size;
            layout.alignment = klass->minimumAlignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            layout.naturalAlignment = klass->naturalAligment;
#endif
            layout.blittable = il2cpp::vm::Class::IsBlittable(klass);
            return;
        }

        const Il2CppGenericContext* gc = type->type == IL2CPP_TYPE_GENERICINST ? &type->data.generic_class->context : nullptr;
		for (uint16_t i = 0; i < typeDef->field_count; i++)
		{
			Il2CppFieldDefinition* fieldDef = (Il2CppFieldDefinition*)il2cpp::vm::GlobalMetadata::GetFieldDefinitionFromTypeDefAndFieldIndex(typeDef, i);
			const Il2CppType* fieldType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(fieldDef->typeIndex);
            const Il2CppType* inflatedFieldType = gc ? TryInflateIfNeed(fieldType, gc, true) : fieldType;
            FieldLayout& fieldLayout = fields[i];
            fieldLayout.type = inflatedFieldType;
            if (isCurAssemblyType)
            {
                int32_t offset = _image->GetFieldOffset(typeDef, i);
                fieldLayout.offset = offset;
                fieldLayout.isNormalStatic = IsRawNormalStaticField(inflatedFieldType, offset);
                fieldLayout.isThreadStatic = IsRawThreadStaticField(inflatedFieldType, offset);
            }
            else
            {

                Il2CppClass* klass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle((Il2CppMetadataTypeHandle)typeDef);
                il2cpp::vm::Class::SetupFields(klass);
                FieldInfo* fieldInfo = klass->fields + i;
                fieldLayout.offset = fieldInfo->offset;
                fieldLayout.isNormalStatic = il2cpp::vm::Field::IsNormalStatic(fieldInfo);
                fieldLayout.isThreadStatic = il2cpp::vm::Field::IsThreadStatic(fieldInfo);
            } 
		}

        if (il2cpp::metadata::GenericMetadata::ContainsGenericParameters(type)
            || ((type->type == IL2CPP_TYPE_VALUETYPE || type->type == IL2CPP_TYPE_CLASS) && typeDef->genericContainerIndex != kGenericContainerIndexInvalid))
        {
            layout.instanceSize = 0;
            layout.actualSize = 0;
            layout.nativeSize = -1;
            layout.alignment = 1;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            layout.naturalAlignment = 1;
#endif
            layout.blittable = false;
            return;
        }


        TbClassLayout classLayoutData = _image->GetClassLayout(typeDef);
        uint8_t packingSize = (uint8_t)classLayoutData.packingSize;
        int32_t classSize = (int32_t)(classLayoutData.classSize + sizeof(Il2CppObject));


        std::vector<FieldLayout*> instanceFields;
        bool blittable = true;
        for (FieldLayout& field : fields)
        {
            if (IsInstanceField(field.type))
            {
                instanceFields.push_back(&field);
				blittable &= IsBlittable(field.type);
            }
        }
		layout.blittable = blittable;

		// If the type is not blittable, ignore packingSize
        if (!blittable)
        {
            packingSize = 0;
        }
		// packingSize is ignored for auto layout types
        if (!(typeDef->flags & (TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT | TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)))
        {
            packingSize = 0;
        }

        if (typeDef->flags & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
        {
            IL2CPP_ASSERT(IsValueType(typeDef));
            IL2CPP_ASSERT(isCurAssemblyType);
            int32_t instanceSize = IL2CPP_SIZEOF_STRUCT_WITH_NO_INSTANCE_FIELDS + sizeof(Il2CppObject);
            if (classLayoutData.classSize > 0)
			{
                instanceSize = std::max(instanceSize, (int32_t)classLayoutData.classSize + (int32_t)sizeof(Il2CppObject));
			}
            int32_t maxAlignment = 1;
            int32_t nativeSize = 1;
            for (FieldLayout* field : instanceFields)
            {
                SizeAndAlignment sa = GetTypeSizeAndAlignment(field->type);
				bool fieldBlittable = IsBlittable(field->type);
                if (!fieldBlittable && field->offset % PTR_SIZE != 0)
                {
                    TEMP_FORMAT(errMsg, "Type %s is not blittable and has an invalid layout", typeName);
					RaiseExecutionEngineException(errMsg);
                }
                instanceSize = std::max(instanceSize, field->offset + (int32_t)sa.size);

                // compute size of alignment field
				uint8_t actualAlignment = packingSize != 0 ? std::min(packingSize, sa.alignment) : sa.alignment;
				instanceSize = std::max(instanceSize, AlignTo(field->offset, actualAlignment) + (int32_t)sa.size);

                maxAlignment = std::max(maxAlignment, (int32_t)sa.alignment);
                if (packingSize != 0)
                {
					maxAlignment = std::min(maxAlignment, (int32_t)packingSize);
				}
                nativeSize = AlignTo(std::max(nativeSize, field->offset + sa.nativeSize - (int32_t)sizeof(Il2CppObject)), maxAlignment);
            }
            layout.alignment = maxAlignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            // in unity 2021- version, il2cpp force alignment to 1 for explicit layout
            //layout.alignment = 1;
            //IL2CPP_ASSERT(blittable || layout.alignment == PTR_SIZE);
            layout.naturalAlignment = !blittable ? PTR_SIZE : layout.alignment;
#endif
            layout.actualSize = layout.instanceSize = AlignTo(instanceSize, layout.alignment);
            layout.nativeSize = nativeSize;
            if (classLayoutData.classSize > 0)
            {
                layout.actualSize = std::max(layout.actualSize, classSize);
                layout.instanceSize = std::max(layout.instanceSize, classSize);
                layout.nativeSize = std::max((int32_t)classLayoutData.classSize, layout.nativeSize);
            }
        }
        else
        {
            uint8_t parentMinimumAligment;
            int32_t parentActualSize = 0;
            bool isValueType = IsValueType(typeDef);
            if (typeDef->parentIndex != kInvalidIndex)
            {
                if (isValueType)
                {
                    parentMinimumAligment = 1;
                    parentActualSize = sizeof(Il2CppObject);
                }
                else
                {
                    const Il2CppType* parentType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->parentIndex);
                    parentType = TryInflateIfNeed(parentType, gc, true);
                    CalcClassNotStaticFields(parentType);
                    ClassLayoutInfo* parentLayout = GetClassLayoutInfo(parentType);
                    parentActualSize = parentLayout->actualSize;
                    parentMinimumAligment = parentLayout->alignment;
                }
            }
            else
            {
                parentActualSize = sizeof(Il2CppObject);
                parentMinimumAligment = PTR_SIZE;
            }

            FieldLayoutData layoutData;
            LayoutFields(parentActualSize, parentMinimumAligment, packingSize, instanceFields, layoutData);
            if (instanceFields.empty() && isValueType)
            {
                layoutData.classSize = layoutData.actualClassSize = IL2CPP_SIZEOF_STRUCT_WITH_NO_INSTANCE_FIELDS + sizeof(Il2CppObject);
                layoutData.nativeSize = IL2CPP_SIZEOF_STRUCT_WITH_NO_INSTANCE_FIELDS;
            }
            layout.alignment = layoutData.minimumAlignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
            //layout.naturalAlignment = layoutData.naturalAlignment;
            layout.naturalAlignment = blittable ? layout.alignment : PTR_SIZE;
#endif
            layout.actualSize = layoutData.actualClassSize;
            layout.instanceSize = layoutData.classSize;
            layout.nativeSize = AlignTo(layoutData.nativeSize, layout.alignment);

            if (!isValueType)
            {
                layout.nativeSize = -1;
            }
            if (classLayoutData.classSize > 0)
            {
                layout.actualSize = std::max(layout.actualSize, classSize);
                layout.instanceSize = std::max(layout.instanceSize, classSize);
                layout.nativeSize = isValueType ? std::max((int32_t)classLayoutData.classSize, layout.nativeSize) : -1;
            }
        }
	}

	void ClassFieldLayoutCalculator::CalcClassStaticFields(const Il2CppType* type)
	{
        IL2CPP_ASSERT(_classMap.find(type) != _classMap.end());
        ClassLayoutInfo& layout = *_classMap[type];

        std::vector<FieldLayout*> staticFields;
        std::vector<FieldLayout*> threadStaticFields;

        for (FieldLayout& field : layout.fields)
        {
            if (field.isNormalStatic)
            {
                staticFields.push_back(&field);
            }
            else if (field.isThreadStatic)
            {
                threadStaticFields.push_back(&field);
            }
        }
        if (!staticFields.empty())
        {
            FieldLayoutData staticLayoutData;
            LayoutFields(0, 1, 0, staticFields, staticLayoutData);
            layout.staticFieldsSize = staticLayoutData.classSize;
        }
        if (!threadStaticFields.empty())
        {
            FieldLayoutData threadStaticLayoutData;
            LayoutFields(0, 1, 0, threadStaticFields, threadStaticLayoutData);
            layout.threadStaticFieldsSize = threadStaticLayoutData.classSize;
            for (FieldLayout* field : threadStaticFields)
            {
                field->offset = field->offset | THREAD_LOCAL_STATIC_MASK;
            }
        }
	}
}
}
```

`hybridclr/metadata/ClassFieldLayoutCalculator.h`:

```h
#pragma once

#include <vector>

#include "MetadataUtil.h"

namespace hybridclr
{
namespace metadata
{

	struct FieldLayout
	{
		const Il2CppType* type;
		int32_t offset;
		int32_t size;
		bool isNormalStatic;
		bool isThreadStatic;
	};

	struct ClassLayoutInfo
	{
		const Il2CppType* type;
		std::vector<FieldLayout> fields;
		int32_t instanceSize;
		int32_t actualSize;
		int32_t nativeSize;
		uint32_t staticFieldsSize;
		uint32_t threadStaticFieldsSize;
		uint8_t alignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
		uint8_t naturalAlignment;
#endif
		bool blittable;
	};

	struct SizeAndAlignment
	{
		int32_t size;
		int32_t nativeSize;
		uint8_t alignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
		uint8_t naturalAlignment;
#endif
	};

	struct FieldLayoutData
	{
		std::vector<size_t> FieldOffsets;
		int32_t classSize;
		int32_t actualClassSize;
		int32_t nativeSize;
		
		uint8_t minimumAlignment;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
		uint8_t naturalAlignment;
#endif
	};

	class InterpreterImage;

	typedef Il2CppHashMap<const Il2CppType*, ClassLayoutInfo*, il2cpp::metadata::Il2CppTypeHash, il2cpp::metadata::Il2CppTypeEqualityComparer> Il2CppType2ClassLayoutInfoMap;

	class ClassFieldLayoutCalculator
	{
	private:
		InterpreterImage* _image;
		Il2CppType2ClassLayoutInfoMap _classMap;

	public:
		ClassFieldLayoutCalculator(InterpreterImage* image) : _image(image)
		{

		}

		~ClassFieldLayoutCalculator()
		{
			for (auto it : _classMap)
			{
				ClassLayoutInfo* info = it.second;
				info->~ClassLayoutInfo();
				HYBRIDCLR_FREE(info);
			}
		}

		ClassLayoutInfo* GetClassLayoutInfo(const Il2CppType* type)
		{
			auto it = _classMap.find(type);
			return it != _classMap.end() ? it->second : nullptr;
		}

		void CalcClassNotStaticFields(const Il2CppType* type);
		void CalcClassStaticFields(const Il2CppType* type);

		void LayoutFields(int32_t actualParentSize, int32_t parentAlignment, uint8_t packing, std::vector<FieldLayout*>& fields, FieldLayoutData& data);
		SizeAndAlignment GetTypeSizeAndAlignment(const Il2CppType* type);
		bool IsBlittable(const Il2CppType* type);
	};
}
}
```

`hybridclr/metadata/Coff.h`:

```h
#pragma once
#include "../CommonDef.h"


namespace hybridclr
{
namespace metadata
{
    struct PEHeader
    {
        uint16_t matchine;
        uint16_t sections;
        uint32_t timestamp;
        uint32_t ptrSymbolTable;
        uint32_t numSymbols;
        uint16_t optionalHeadersize;
        uint16_t characteristics;
    };

    struct PEDirEntry
    {
        uint32_t rva;
        uint32_t size;
    };

    struct CLIHeader
    {
        uint32_t cb;
        uint16_t majorRuntimeVersion;
        uint16_t minorRuntimeVersion;
        PEDirEntry metaData;
        uint32_t flags;
        uint32_t entryPointToken;
        PEDirEntry resources;
        uint64_t strongNameSignature;
        uint64_t codeManagerTable;
        uint64_t vTableFixups;
        uint64_t exportAddressTableJumps;
        uint64_t managedNativeHeader;
    };


    struct PESectionHeader
    {
        char name[8];
        uint32_t virtualSize;
        uint32_t virtualAddress;
        uint32_t sizeOfRawData;
        uint32_t ptrRawData;
        uint32_t ptrRelocations;
        uint32_t ptrLineNumbers;
        uint16_t numRelocation;
        uint16_t numLineNumber;
        uint32_t characteristics;
    };

    struct MetadataRootPartial
    {
        uint32_t signature;
        uint16_t majorVersion;
        uint16_t minorVersion;
        uint32_t reserved;
        uint32_t length;
        byte    versionFirstByte;
    };

    struct StreamHeader
    {
        uint32_t offset;
        uint32_t size;
        char name[1];
    };

    struct TableStreamHeader
    {
        uint32_t reserved;
        uint8_t majorVersion;
        uint8_t minorVersion;
        uint8_t heapSizes;
        uint8_t reserved2;
        uint64_t valid;
        uint64_t sorted;
        uint32_t rows[1];
        // tables;
    };

    struct CliStream
    {
        const char* name;
        const byte* data;
        uint32_t size;
    };

    struct UserString
    {
        const char* data;
        uint32_t size;
        uint8_t flags;
    };

    struct Blob
    {
        const byte* data;
        uint32_t size;
    };

    struct Table
    {
        const byte* data;
        uint32_t rowMetaDataSize;
        uint32_t rowNum;
        bool vaild;
        bool sorted;
    };
}
}

```

`hybridclr/metadata/ConsistentAOTHomologousImage.cpp`:

```cpp
#include "ConsistentAOTHomologousImage.h"

#include "vm/MetadataLock.h"
#include "vm/GlobalMetadata.h"
#include "vm/Class.h"
#include "vm/Image.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"
#include "metadata/GenericMetadata.h"

namespace hybridclr
{
namespace metadata
{

	void ConsistentAOTHomologousImage::InitRuntimeMetadatas()
	{
		InitTypes();
		InitMethods();
		InitFields();
	}

	void ConsistentAOTHomologousImage::InitTypes()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		uint32_t typeCount = typeDefTb.rowNum;
		_il2cppTypeForTypeDefs.resize(typeCount);
		_typeDefs.resize(typeCount);

		Il2CppImage* image = _targetAssembly->image;
		//if (image->typeCount != typeCount)
		//{
		//	RaiseExecutionEngineException("image metadata not match");
		//}
		for (uint32_t index = 0; index < image->typeCount; index++)
		{
			Il2CppTypeDefinition* typeDef = (Il2CppTypeDefinition*)il2cpp::vm::MetadataCache::GetAssemblyTypeHandle(image, index);
			uint32_t rowIndex = DecodeTokenRowIndex(typeDef->token);
			IL2CPP_ASSERT(rowIndex > 0);
			if (rowIndex > typeCount)
			{
				continue;
			}
			TbTypeDef data = _rawImage->ReadTypeDef(rowIndex);
			uint32_t typeIndex = rowIndex - 1;
			_typeDefs[typeIndex] = typeDef;
			const Il2CppType* il2cppType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->byvalTypeIndex);
			_il2cppTypeForTypeDefs[typeIndex] = il2cppType;

			const char* name1 = _rawImage->GetStringFromRawIndex(data.typeName);
			const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
			if (std::strcmp(name1, name2))
			{
				RaiseExecutionEngineException("metadata type not match");
			}
			const char* namespaze1 = _rawImage->GetStringFromRawIndex(data.typeNamespace);
			const char* namespaze2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->namespaceIndex);
			if (std::strcmp(namespaze1, namespaze2))
			{
				RaiseExecutionEngineException("metadata type not match");
			}
		}
	}

	void ConsistentAOTHomologousImage::InitMethods()
	{
		const Table& methodTb = _rawImage->GetTable(TableType::METHOD);
		_methodDefs.resize(methodTb.rowNum);

		for (Il2CppTypeDefinition* type : _typeDefs)
		{
			for (uint16_t i = 0; i < type->method_count; i++)
			{
				const Il2CppMethodDefinition* methodDef = il2cpp::vm::GlobalMetadata::GetMethodDefinitionFromIndex(type->methodStart + i);
				uint32_t rowIndex = DecodeTokenRowIndex(methodDef->token);
				IL2CPP_ASSERT(rowIndex > 0 && rowIndex <= methodTb.rowNum);
				uint32_t methodIndex = rowIndex - 1;
				IL2CPP_ASSERT(_methodDefs[methodIndex] == nullptr);
				_methodDefs[methodIndex] = methodDef;

				TbMethod methodData = _rawImage->ReadMethod(rowIndex);
				const char* name1 = _rawImage->GetStringFromRawIndex(methodData.name);
				const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex);
				if (std::strcmp(name1, name2))
				{
					RaiseExecutionEngineException("metadata method not match");
				}
			}
		}
	}

	void ConsistentAOTHomologousImage::InitFields()
	{
		const Table& fieldTb = _rawImage->GetTable(TableType::FIELD);
		_fields.resize(fieldTb.rowNum);

		for (size_t i = 0; i < _typeDefs.size(); i++)
		{
			Il2CppTypeDefinition* type = _typeDefs[i];
			for (uint16_t j = 0; j < type->field_count; j++)
			{
				const Il2CppFieldDefinition* fieldDef = il2cpp::vm::GlobalMetadata::GetFieldDefinitionFromTypeDefAndFieldIndex(type, j);
				uint32_t rowIndex = DecodeTokenRowIndex(fieldDef->token);
				IL2CPP_ASSERT(rowIndex > 0);
				uint32_t fieldIndex = rowIndex - 1;
				IL2CPP_ASSERT(_fields[fieldIndex].fieldDef == nullptr);
				if (rowIndex >= fieldTb.rowNum)
				{
					continue;
				}
				_fields[fieldIndex] = { (uint32_t)i, fieldDef };

				TbField fieldData = _rawImage->ReadField(rowIndex);
				const char* name1 = _rawImage->GetStringFromRawIndex(fieldData.name);
				const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(fieldDef->nameIndex);
				if (std::strcmp(name1, name2))
				{
					RaiseExecutionEngineException("metadata field not match");
				}
			}
		}
	}

	MethodBody* ConsistentAOTHomologousImage::GetMethodBody(uint32_t token)
	{
		uint32_t rowIndex = DecodeTokenRowIndex(token);
		IL2CPP_ASSERT(rowIndex > 0);
		TbMethod methodData = _rawImage->ReadMethod(rowIndex);
		MethodBody* body = new (HYBRIDCLR_MALLOC_ZERO(sizeof(MethodBody))) MethodBody();
		ReadMethodBody(*_methodDefs[rowIndex - 1], methodData, *body);
		return body;
	}

	const Il2CppType* ConsistentAOTHomologousImage::GetIl2CppTypeFromRawTypeDefIndex(uint32_t index)
	{
		IL2CPP_ASSERT((size_t)index < _il2cppTypeForTypeDefs.size());
		return _il2cppTypeForTypeDefs[index];
	}

	Il2CppGenericContainer* ConsistentAOTHomologousImage::GetGenericContainerByRawIndex(uint32_t index)
	{
		return (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(index);
	}

	Il2CppGenericContainer* ConsistentAOTHomologousImage::GetGenericContainerByTypeDefRawIndex(int32_t typeDefIndex)
	{
		Il2CppTypeDefinition* type = (Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(typeDefIndex);
		return (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(type->genericContainerIndex);
	}

	const Il2CppMethodDefinition* ConsistentAOTHomologousImage::GetMethodDefinitionFromRawIndex(uint32_t index)
	{
		IL2CPP_ASSERT((size_t)index < _methodDefs.size());
		return _methodDefs[index];
	}

	void ConsistentAOTHomologousImage::ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret)
	{
		IL2CPP_ASSERT(rowIndex > 0);
		AOTFieldData& fd = _fields[rowIndex - 1];
		ret.containerType = _il2cppTypeForTypeDefs[fd.typeDefIndex];
		ret.field = fd.fieldDef;
	}
}
}


```

`hybridclr/metadata/ConsistentAOTHomologousImage.h`:

```h
#pragma once

#include "AOTHomologousImage.h"

namespace hybridclr
{
namespace metadata
{

	class ConsistentAOTHomologousImage : public AOTHomologousImage
	{
	public:
		ConsistentAOTHomologousImage() : AOTHomologousImage() {}

		void InitRuntimeMetadatas() override;

		void InitTypes();
		void InitMethods();
		void InitFields();

		MethodBody* GetMethodBody(uint32_t token) override;
		const Il2CppType* GetIl2CppTypeFromRawTypeDefIndex(uint32_t index) override;
		Il2CppGenericContainer* GetGenericContainerByRawIndex(uint32_t index) override;
		Il2CppGenericContainer* GetGenericContainerByTypeDefRawIndex(int32_t typeDefIndex) override;
		const Il2CppMethodDefinition* GetMethodDefinitionFromRawIndex(uint32_t index) override;
		void ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret) override;
	private:
		std::vector<const Il2CppType*> _il2cppTypeForTypeDefs;
		std::vector<Il2CppTypeDefinition*> _typeDefs;

		std::vector< const Il2CppMethodDefinition*> _methodDefs;

		std::vector<AOTFieldData> _fields;
	};
}
}
```

`hybridclr/metadata/CustomAttributeDataWriter.h`:

```h
#pragma once

#include "BlobReader.h"

#include "../CommonDef.h"

#include "utils/MemoryRead.h"

namespace hybridclr
{
namespace metadata
{
	class CustomAttributeDataWriter
	{
	private:
		uint8_t* _data;
		uint32_t _capacity;
		uint32_t _size;

	public:
		CustomAttributeDataWriter(uint32_t capacity) : _capacity(Round2Exp(capacity)), _size(0)
		{
			_data = (uint8_t*)HYBRIDCLR_MALLOC_ZERO(_capacity);
		}

		~CustomAttributeDataWriter()
		{
			HYBRIDCLR_FREE(_data);
			_data = nullptr;
		}

		uint32_t Size() const { return _size; }

		bool Empty() const { return _size == 0; }

		const uint8_t* Data() const { return _data; }

		const uint8_t* DataAt(uint32_t offset) { return _data + offset; }

		void Reset()
		{
			_size = 0;
		}

		void WriteAttributeCount(uint32_t count)
		{
			WriteCompressedUint32(count);
		}

		void Skip(int32_t skipBytes)
		{
			SureRemainSize(skipBytes);
			_size += skipBytes;
		}

		void WriteMethodIndex(int32_t offset, int32_t methodIndex)
		{
			*(int32_t*)(_data + offset) = methodIndex;
		}

		void WriteByte(uint8_t n)
		{
			SureRemainSize(1);
			_data[_size++] = n;
		}

		void WriteCompressedUint32(uint32_t n)
		{
			SureRemainSize(5);
			uint8_t* buf = _data + _size;
			if (n < 0x80)
			{
				buf[0] = (uint8_t)n;
				++_size;
			}
			else if (n < 0x4000)
			{
				uint32_t v = n | 0x8000;
				buf[0] = uint8_t(v >> 8);
				buf[1] = uint8_t(v);
				_size += 2;
			}
			else if (n < 0x20000000)
			{
				uint32_t v = n | 0xC0000000;
				buf[0] = uint8_t(v >> 24);
				buf[1] = uint8_t(v >> 16);
				buf[2] = uint8_t(v >> 8);
				buf[3] = uint8_t(v);
				_size += 4;
			}
			else if (n < UINT32_MAX - 1)
			{
				buf[0] = 0xF0;
				buf[1] = uint8_t(n);
				buf[2] = uint8_t(n >> 8);
				buf[3] = uint8_t(n >> 16);
				buf[4] = uint8_t(n >> 24);
				_size += 5;
			}
			else if (n == UINT32_MAX - 1)
			{
				buf[0] = 0xFE;
				++_size;
			}
			else
			{
				buf[0] = 0xFF;
				++_size;
			}
		}

		void WriteUint32(uint32_t n)
		{
			WriteData(n);
		}

		void WriteCompressedInt32(int32_t n)
		{
			uint32_t v = n >= 0 ? (n << 1) : (((-(n + 1)) << 1) | 0x1U);
			WriteCompressedUint32(v);
		}

		template<typename T>
		void WriteData(T x)
		{
			int32_t n = sizeof(T);
			SureRemainSize(n);
			std::memcpy(_data + _size, &x, n);
			_size += n;
		}

		void WriteBytes(const uint8_t* data, uint32_t len)
		{
			SureRemainSize(len);
			std::memcpy(_data + _size, data, len);
			_size += len;
		}

		void Write(const CustomAttributeDataWriter& writer)
		{
			SureRemainSize(writer._size);
			std::memcpy(_data + _size, writer._data, writer._size);
			_size += writer._size;
		}

		void Write(BlobReader& reader, int32_t count)
		{
			SureRemainSize(count);
			std::memcpy(_data + _size, reader.GetDataOfReadPosition(), count);
			_size += count;
			reader.SkipBytes(count);
		}

		void PopByte()
		{
			IL2CPP_ASSERT(_size > 0);
			--_size;
		}

		void ReplaceLastByte(byte x)
		{
			IL2CPP_ASSERT(_size > 0);
			_data[_size - 1] = x;
		}

	private:
		uint32_t Round2Exp(uint32_t n)
		{
			uint32_t s = 64;
			for (uint32_t s = 64; ; s *= 2)
			{
				if (s >= n)
				{
					return s;
				}
			}
			return n;
		}

		void SureRemainSize(uint32_t remainSize)
		{
			uint32_t newSize = _size + remainSize;
			if (newSize > _capacity)
			{
				Resize(newSize);
			}
		}

		void Resize(uint32_t newSize)
		{
			_capacity = newSize = Round2Exp(newSize);
			uint8_t* oldData = _data;
			_data = (uint8_t*)HYBRIDCLR_MALLOC(newSize);
			std::memcpy(_data, oldData, _size);
			HYBRIDCLR_FREE(oldData);
		}
	};
}
}
```

`hybridclr/metadata/Image.cpp`:

```cpp
#include "Image.h"

#include "vm/ClassInlines.h"
#include "vm/Image.h"
#include "vm/GlobalMetadata.h"
#include "vm/Type.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/Array.h"
#include "vm/Reflection.h"
#include "vm/MetadataLock.h"
#include "vm/String.h"
#include "metadata/GenericMetadata.h"
#include "icalls/mscorlib/System.Reflection/FieldInfo.h"
#ifdef HYBRIDCLR_UNITY_2021_OR_NEW
#include "icalls/mscorlib/System/RuntimeTypeHandle.h"
#else
#include "icalls/mscorlib/System.Reflection/PropertyInfo.h"
#endif
#include "icalls/mscorlib/System/Type.h"
#include "utils/StringUtils.h"

#include "MetadataUtil.h"
#include "BlobReader.h"
#include "MetadataPool.h"

//!!!{{INCLUDE_RAW_IMAGE_HEADERS


//!!!}}INCLUDE_RAW_IMAGE_HEADERS

namespace hybridclr
{
namespace metadata
{
    LoadImageErrorCode Image::InitRawImage(const void* imageData, size_t length)
    {
        //!!!{{INIT_RAW_IMAGE
		_rawImage = new RawImage();
		return LoadImageErrorCode::OK;

        //!!!}}INIT_RAW_IMAGE
    }

    static const char* s_netstandardRefs[]
    {
        "mscorlib",
        "System",
        "System.Core",
        "System.Numerics",
        "System.Collections",
        "System.Collections.Concurrent",
        "System.Numerics.Vectors",
        "System.Data",
        "System.Configuration",
        "System.IO.Compression",
        "System.Net",
        "System.Security",
        "System.Xml",
        "System.Xml.Linq",
        "System.Xml.Serialization",
        "System.Runtime.Serialization",
        "System.Json",
        "System.Diagnostics.Tracing",
        "System.Net.Http",
        nullptr,
    };

    bool Image::IsValueTypeFromToken(TableType tableType, uint32_t rowIndex)
    {
        switch (tableType)
        {
        case TableType::TYPEREF:
        {
            TbTypeRef r = _rawImage->ReadTypeRef(rowIndex);
            const char* typeNamespace = _rawImage->GetStringFromRawIndex(r.typeNamespace);
            if (std::strcmp(typeNamespace, "System"))
            {
                return false;
            }
            const char* typeName = _rawImage->GetStringFromRawIndex(r.typeName);
            return std::strcmp(typeName, "ValueType") == 0 || std::strcmp(typeName, "Enum") == 0;
        }
        default:
        {
            return false;
        }
        }
    }

    bool Image::IsThreadStaticCtorToken(TableType tableType, uint32_t rowIndex)
    {
        if (tableType != TableType::MEMBERREF)
        {
            return false;
        }
        TbMemberRef data = _rawImage->ReadMemberRef(rowIndex);
        TableType parentTableType = DecodeMemberRefParentType(data.classIdx);
        if (parentTableType != TableType::TYPEREF)
        {
            return false;
        }
        const Il2CppType* type = ReadTypeFromTypeRef(DecodeMemberRefParentRowIndex(data.classIdx));
        const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
        const char* strNamespace = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->namespaceIndex);
        if (std::strcmp(strNamespace, "System"))
        {
            return false;
        }
        const char* strName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
        return std::strcmp(strName, "ThreadStaticAttribute") == 0;
    }

    void Image::ReadMemberRefParentFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex, ResolveMemberRefParent& ret)
    {
        ret.parentType = tableType;
        switch (tableType)
        {
        case hybridclr::metadata::TableType::TYPEREF:
            ret.type = ReadTypeFromTypeRef(rowIndex);
            break;
        case hybridclr::metadata::TableType::TYPEDEF:
            ret.type = ReadTypeFromTypeDef(rowIndex);
            break;
        case hybridclr::metadata::TableType::METHOD:
            RaiseNotSupportedException("ReadMemberRefParentFromToken. from METHOD");
            break;
        case hybridclr::metadata::TableType::MODULEREF:
            RaiseNotSupportedException("ReadMemberRefParentFromToken. from MODULEREF");
            break;
        case hybridclr::metadata::TableType::TYPESPEC:
            ret.type = ReadTypeFromTypeSpec(klassGenericContainer, methodGenericContainer, rowIndex);
            break;
        default:
        {
            RaiseExecutionEngineException("ReadMemberRefParentFromToken. invalid table type");
            break;
        }
        }
    }

#pragma region type

    const Il2CppType* Image::ReadArrayType(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer)
    {
        Il2CppType* arrType = MetadataMallocT<Il2CppType>();;
        arrType->type = IL2CPP_TYPE_ARRAY;
        Il2CppArrayType& type = *MetadataMallocT<Il2CppArrayType>();
        arrType->data.array = &type;

        const Il2CppType* eleType = ReadType(reader, klassGenericContainer, methodGenericContainer);
        type.etype = eleType;
        type.rank = reader.ReadCompressedUint32();
        type.numsizes = reader.ReadCompressedUint32();
        if (type.numsizes > 0)
        {
            type.sizes = (int*)HYBRIDCLR_CALLOC(type.numsizes, sizeof(int));
            for (uint8_t i = 0; i < type.numsizes; i++)
            {
                type.sizes[i] = reader.ReadCompressedUint32();
            }
        }
        else
        {
            type.sizes = nullptr;
        }
        type.numlobounds = reader.ReadCompressedUint32();
        if (type.numlobounds > 0)
        {
            type.lobounds = (int*)HYBRIDCLR_CALLOC(type.numlobounds, sizeof(int));
            for (uint8_t i = 0; i < type.numlobounds; i++)
            {
                type.lobounds[i] = reader.ReadCompressedInt32();
            }
        }
        else
        {
            type.lobounds = nullptr;
        }
        return arrType;
    }

    const Il2CppGenericClass* Image::ReadGenericClass(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer)
    {
        const Il2CppType* genericBase = ReadType(reader, klassGenericContainer, methodGenericContainer);
        IL2CPP_ASSERT(genericBase->type == IL2CPP_TYPE_CLASS || genericBase->type == IL2CPP_TYPE_VALUETYPE);

        uint32_t argc = reader.ReadCompressedUint32();
        IL2CPP_ASSERT(argc > 0 && argc <= 32);
        const Il2CppType* types[32];
        //const Il2CppType** types = (const Il2CppType**)alloca(argc * sizeof(const Il2CppType*));
        for (uint32_t i = 0; i < argc; i++)
        {
            types[i] = ReadType(reader, klassGenericContainer, methodGenericContainer);
        }
        const Il2CppGenericInst* genericInst = il2cpp::vm::MetadataCache::GetGenericInst(types, argc);

        return il2cpp::metadata::GenericMetadata::GetGenericClass(genericBase, genericInst);
    }

    const Il2CppType* Image::ReadType(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer)
    {
        Il2CppType type = {};
        const Il2CppType* underlyingType = nullptr;
    readAgain:
        Il2CppTypeEnum etype = (Il2CppTypeEnum)reader.ReadByte();
        type.type = etype;
        switch (etype)
        {
        case IL2CPP_TYPE_VOID:
            break;
        case IL2CPP_TYPE_BOOLEAN:
        case IL2CPP_TYPE_CHAR:
        case IL2CPP_TYPE_I1:
        case IL2CPP_TYPE_U1:
        case IL2CPP_TYPE_I2:
        case IL2CPP_TYPE_U2:
        case IL2CPP_TYPE_I4:
        case IL2CPP_TYPE_U4:
        case IL2CPP_TYPE_I8:
        case IL2CPP_TYPE_U8:
        case IL2CPP_TYPE_R4:
        case IL2CPP_TYPE_R8:
        case IL2CPP_TYPE_TYPEDBYREF:
        case IL2CPP_TYPE_I:
        case IL2CPP_TYPE_U:
        {
            SET_IL2CPPTYPE_VALUE_TYPE(type, 1);
            break;
        }
        case IL2CPP_TYPE_STRING:
        {
            break;
        }
        case IL2CPP_TYPE_PTR:
        {
            //SET_IL2CPPTYPE_VALUE_TYPE(type, 1);
            type.data.type = ReadType(reader, klassGenericContainer, methodGenericContainer);
            //SET_IL2CPPTYPE_VALUE_TYPE(type, 1);
            break;
        }
        case IL2CPP_TYPE_BYREF:
        {
            //const Il2CppType* underlyingType = ReadType(reader, klassGenericContainer, methodGenericContainer);
            //type = *underlyingType;
            type.byref = 1;
            goto readAgain;
        }
        case IL2CPP_TYPE_VALUETYPE:
        case IL2CPP_TYPE_CLASS:
        {
            uint32_t codedIndex = reader.ReadCompressedUint32(); // 低2位为type, 高位为index
            underlyingType = ReadTypeFromToken(klassGenericContainer, methodGenericContainer, DecodeTypeDefOrRefOrSpecCodedIndexTableType(codedIndex), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(codedIndex));
            break;
        }
        case IL2CPP_TYPE_ARRAY:
        {
            underlyingType = ReadArrayType(reader, klassGenericContainer, methodGenericContainer);
            break;
        }
        case IL2CPP_TYPE_GENERICINST:
        {
            const Il2CppGenericClass* genericClass = ReadGenericClass(reader, klassGenericContainer, methodGenericContainer);
            type.data.generic_class = const_cast<Il2CppGenericClass*>(genericClass);
            COPY_IL2CPPTYPE_VALUE_TYPE_FLAG(type, *genericClass->type);
            break;
        }
        case IL2CPP_TYPE_FNPTR:
        {
            // il2cpp doesn't support FNPTR. il2cpp treats IL2CPP_TYPE_FNPTR as IL2CPP_TYPE_I.
            // so we handle it as IL2CPP_TYPE_I.
            // 
            //MethodRefSig* method = new (HYBRIDCLR_MALLOC(sizeof(MethodRefSig))) MethodRefSig();
            //ReadMethodRefSig(reader, *method);
            //type.data.method = method;
            type.type = IL2CPP_TYPE_I;
            MethodRefSig method = {};
            ReadMethodRefSig(reader, method);
            break;
        }
        case IL2CPP_TYPE_OBJECT:
        {
            break;
        }
        case IL2CPP_TYPE_SZARRAY:
        {
            type.data.type = ReadType(reader, klassGenericContainer, methodGenericContainer);
            break;
        }
        case IL2CPP_TYPE_VAR:
        {
            IL2CPP_ASSERT(!klassGenericContainer || !klassGenericContainer->is_method);
            uint32_t number = reader.ReadCompressedUint32();
            if (klassGenericContainer)
            {
                //IL2CPP_ASSERT(hybridclr::metadata::IsInterpreterIndex(klassGenericContainer->ownerIndex));
                type.data.genericParameterHandle = il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex((Il2CppMetadataGenericContainerHandle)klassGenericContainer, number);
            }
            else
            {
                type.data.__genericParameterIndex = number;
            }
            /*Il2CppGenericParameter* gp = (Il2CppGenericParameter*)type.data.genericParameterHandle;
            IL2CPP_ASSERT(hybridclr::metadata::IsInterpreterIndex(gp->ownerIndex));*/
            break;
        }
        case IL2CPP_TYPE_MVAR:
        {
            IL2CPP_ASSERT(!methodGenericContainer || methodGenericContainer->is_method);
            uint32_t number = reader.ReadCompressedUint32();
            if (methodGenericContainer)
            {
                type.data.genericParameterHandle = il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex((Il2CppMetadataGenericContainerHandle)methodGenericContainer, number);
            }
            else
            {
                // method ref can't resolve at that time
                type.data.__genericParameterIndex = number;
            }
            break;
        }
        case IL2CPP_TYPE_CMOD_REQD:
        {
            ++type.num_mods;
            uint32_t encodeToken = reader.ReadCompressedUint32();
            const Il2CppType* modType = ReadTypeFromToken(nullptr, nullptr, DecodeTypeDefOrRefOrSpecCodedIndexTableType(encodeToken), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(encodeToken));
            if (modType->type != IL2CPP_TYPE_CLASS && modType->type != IL2CPP_TYPE_VALUETYPE)
            {
                goto readAgain;
            }
            IL2CPP_ASSERT(modType->data.typeHandle);
            const Il2CppTypeDefinition* modTypeDef = (const Il2CppTypeDefinition*)modType->data.typeHandle;
            const char* modTypeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(modTypeDef->nameIndex);
            const char* modTypeNamespace = il2cpp::vm::GlobalMetadata::GetStringFromIndex(modTypeDef->namespaceIndex);
            if (std::strcmp(modTypeNamespace, "System.Runtime.InteropServices") == 0)
            {
                if (std::strcmp(modTypeName, "InAttribute") == 0)
                {
                    type.attrs |= PARAM_ATTRIBUTE_IN;
                }
                else if (std::strcmp(modTypeName, "OutAttribute") == 0)
                {
                    type.attrs |= PARAM_ATTRIBUTE_OUT;
                }
                else if (std::strcmp(modTypeName, "OptionalAttribute") == 0)
                {
                    type.attrs |= PARAM_ATTRIBUTE_OPTIONAL;
                }
            }
            goto readAgain;
        }
        case IL2CPP_TYPE_CMOD_OPT:
        {
            ++type.num_mods;
            uint32_t encodeToken = reader.ReadCompressedUint32();
            goto readAgain;
        }
        case IL2CPP_TYPE_INTERNAL:
        {
            RaiseNotSupportedException("Image::ReadType IL2CPP_TYPE_INTERNAL");
            break;
        }
        case IL2CPP_TYPE_MODIFIER:
        {
            RaiseNotSupportedException("Image::ReadType IL2CPP_TYPE_MODIFIER");
            break;
        }
        case IL2CPP_TYPE_SENTINEL:
        {
            break;
        }
        case IL2CPP_TYPE_PINNED:
        {
            type.pinned = true;
            goto readAgain;
        }
        default:
        {
            RaiseBadImageException("Image::ReadType invalid type");
            break;
        }
        }
        if (underlyingType)
        {
            type.type = underlyingType->type;
            type.data = underlyingType->data;
            COPY_IL2CPPTYPE_VALUE_TYPE_FLAG(type, *underlyingType);
        }
        if (type.byref)
        {
            SET_IL2CPPTYPE_VALUE_TYPE(type, 0);
        }
        return MetadataPool::GetPooledIl2CppType(type);
    }

    const Il2CppType* Image::ReadTypeFromResolutionScope(uint32_t scope, uint32_t typeNamespace, uint32_t typeName)
    {
        TableType tokenType;
        uint32_t rawIndex;
        DecodeResolutionScopeCodedIndex(scope, tokenType, rawIndex);
        switch (tokenType)
        {
        case TableType::MODULE:
        {
            return GetModuleIl2CppType(rawIndex, typeNamespace, typeName, true);
        }
        case TableType::MODULEREF:
        {
            RaiseNotSupportedException("Image::ReadTypeFromResolutionScope not support ResolutionScore.MODULEREF");
            break;
        }
        case TableType::ASSEMBLYREF:
        {
            TbAssemblyRef assRef = _rawImage->ReadAssemblyRef(rawIndex);
            return GetIl2CppType(rawIndex, typeNamespace, typeName, true);
        }
        case TableType::TYPEREF:
        {
            const Il2CppType* enClosingType = ReadTypeFromTypeRef(rawIndex);
            IL2CPP_ASSERT(typeNamespace == 0);
            const char* name = _rawImage->GetStringFromRawIndex(typeName);

            void* iter = nullptr;
            Il2CppMetadataTypeHandle enclosingTypeDef = enClosingType->data.typeHandle;
            if (!enclosingTypeDef)
            {
                TEMP_FORMAT(errMsg, "Image::ReadTypeFromResolutionScope ReadTypeFromResolutionScope.TYPEREF enclosingType:%s", name);
                RaiseExecutionEngineException(errMsg);
            }
            for (const Il2CppTypeDefinition* nextTypeDef; (nextTypeDef = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetNestedTypes(enclosingTypeDef, &iter));)
            {
                const char* nestedTypeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(nextTypeDef->nameIndex);
                IL2CPP_ASSERT(nestedTypeName);
                if (!std::strcmp(name, nestedTypeName))
                {
                    return GetIl2CppTypeFromTypeDefinition(nextTypeDef);
                }
            }

            std::string enclosingTypeName = GetKlassCStringFullName(enClosingType);
            TEMP_FORMAT(errMsg, "Image::ReadTypeFromResolutionScope ReadTypeFromResolutionScope.TYPEREF fail. type:%s.%s", enclosingTypeName.c_str(), name);
            RaiseExecutionEngineException(errMsg);
            break;
        }
        default:
        {
            RaiseBadImageException("Image::ReadTypeFromResolutionScope invaild TableType");
            break;
        }
        }
        return nullptr;
    }

    const Il2CppType* Image::ReadTypeFromTypeDef(uint32_t rowIndex)
    {
        return GetIl2CppTypeFromRawTypeDefIndex(rowIndex - 1);
    }

    const Il2CppType* Image::ReadTypeFromTypeRef(uint32_t rowIndex)
    {
        TbTypeRef r = _rawImage->ReadTypeRef(rowIndex);
        return ReadTypeFromResolutionScope(r.resolutionScope, r.typeNamespace, r.typeName);
    }

    const Il2CppType* Image::ReadTypeFromTypeSpec(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex)
    {
        TbTypeSpec r = _rawImage->ReadTypeSpec(rowIndex);
        BlobReader reader = _rawImage->GetBlobReaderByRawIndex(r.signature);
        return ReadType(reader, klassGenericContainer, methodGenericContainer);
    }

    const Il2CppType* Image::ReadTypeFromMemberRefParent(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex)
    {
        ResolveMemberRefParent mrp = {};
        ReadMemberRefParentFromToken(klassGenericContainer, methodGenericContainer, tableType, rowIndex, mrp);
        IL2CPP_ASSERT(mrp.parentType == TableType::TYPEDEF || mrp.parentType == TableType::TYPEREF || mrp.parentType == TableType::TYPESPEC);
        return mrp.type;
    }

    const Il2CppType* Image::ReadTypeFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex)
    {
        switch (tableType)
        {
        case TableType::TYPEDEF:
        {
            return ReadTypeFromTypeDef(rowIndex);
        }
        case TableType::TYPEREF:
        {
            return ReadTypeFromTypeRef(rowIndex);
        }
        case TableType::TYPESPEC:
        {
            return ReadTypeFromTypeSpec(klassGenericContainer, methodGenericContainer, rowIndex);
        }
        default:
        {
            RaiseBadImageException("Image::ReadTypeFromToken invalid TableType");
            return nullptr;
        }
        }
    }

#pragma endregion

    void Image::ReadFieldRefSig(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, FieldRefSig& field)
    {
        field = {};
        uint8_t rawSigType = reader.ReadByte();
        SigType sigType = DecodeSigType(rawSigType);
        IL2CPP_ASSERT(sigType == SigType::FIELD);
        field.type = ReadType(reader, klassGenericContainer, nullptr);
    }

    void Image::ReadMethodRefSig(BlobReader& reader, MethodRefSig& method)
    {
        method = {};
        uint8_t rawSigFlags = reader.ReadByte();
        method.flags = rawSigFlags;
        if (rawSigFlags & (uint8_t)SigType::GENERIC)
        {
            method.genericParamCount = reader.ReadCompressedUint32();
        }
        uint32_t paramCount = reader.ReadCompressedUint32();

        method.returnType = ReadType(reader, nullptr, nullptr);

        bool sentinel = false;
        for (uint32_t readParamNum = 0; readParamNum < paramCount; ++readParamNum)
        {
            const Il2CppType* paramType = ReadType(reader, nullptr, nullptr);
            if (paramType->type == IL2CPP_TYPE_SENTINEL)
            {
                IL2CPP_ASSERT(rawSigFlags & (uint8_t)SigType::VARARG);
                sentinel = true;
                continue;
            }
            method.params.push_back(paramType);
        }
    }

    void Image::ReadMemberRefSig(const Il2CppGenericContainer* klassGenericContainer, TbMemberRef& data, ResolveMemberRefSig& signature)
    {
        BlobReader reader = _rawImage->GetBlobReaderByRawIndex(data.signature);
        uint8_t rawSigFlags = reader.PeekByte();
        SigType sigType = DecodeSigType(rawSigFlags);
        if (sigType == SigType::FIELD)
        {
            signature.memberType = TableType::FIELDPTR;
            ReadFieldRefSig(reader, klassGenericContainer, signature.field);
        }
        else
        {
            signature.memberType = TableType::METHODPTR;
            ReadMethodRefSig(reader, signature.method);
        }
    }


    void Image::ReadMethodRefInfoFromToken(const Il2CppGenericContainer* klassGenericContainer,
        const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex, MethodRefInfo& ret)
    {
        IL2CPP_ASSERT(rowIndex > 0);
        switch (tableType)
        {
        case TableType::METHOD:
        {
            const Il2CppMethodDefinition* methodDef = GetMethodDefinitionFromRawIndex(rowIndex - 1);
            const Il2CppTypeDefinition* typeDef = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(methodDef->declaringType);
            const Il2CppType* type = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->byvalTypeIndex);
            ret.containerType = type;
            ret.methodDef = methodDef;
            IL2CPP_ASSERT(type);
            IL2CPP_ASSERT(methodDef);
            break;
        }
        case TableType::MEMBERREF:
        {
            ReadMethodRefInfoFromMemberRef(klassGenericContainer, methodGenericContainer, rowIndex, ret);
            break;
        }
        case TableType::METHODSPEC:
        {
            TbMethodSpec methodSpec = _rawImage->ReadMethodSpec(rowIndex);

            ret.instantiation = ReadMethodSpecInstantiation(methodSpec.instantiation, klassGenericContainer, methodGenericContainer);
            TableType methodTableType = DecodeMethodDefOrRefCodedIndexTableType(methodSpec.method);
            uint32_t methodRowIndex = DecodeMethodDefOrRefCodedIndexRowIndex(methodSpec.method);
            switch (methodTableType)
            {
            case TableType::METHOD:
            {
                ReadMethodRefInfoFromToken(klassGenericContainer, methodGenericContainer, methodTableType, methodRowIndex, ret);
                break;
            }
            case TableType::MEMBERREF:
            {
                ReadMethodRefInfoFromMemberRef(klassGenericContainer, methodGenericContainer, methodRowIndex, ret);
                break;
            }
            default:
            {
                RaiseBadImageException("Image::ReadMethodRefInfoFromToken METHODSPEC invalid TableType");
                break;
            }
            }
            break;
        }
        default:
        {
            RaiseBadImageException("Image::ReadMethodRefInfoFromToken invalid TableType");
        }
        }
    }

    void Image::ReadResolveMemberRefFromMemberRef(const Il2CppGenericContainer* klassGenericContainer,
        const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex, ResolveMemberRef& ret)
    {
        TbMemberRef data = _rawImage->ReadMemberRef(rowIndex);
        ret.name = _rawImage->GetStringFromRawIndex(data.name);
        ReadMemberRefParentFromToken(klassGenericContainer, methodGenericContainer, DecodeMemberRefParentType(data.classIdx), DecodeMemberRefParentRowIndex(data.classIdx), ret.parent);
        IL2CPP_ASSERT(ret.parent.parentType == TableType::TYPEDEF || ret.parent.parentType == TableType::TYPEREF || ret.parent.parentType == TableType::TYPESPEC);
        ReadMemberRefSig(nullptr, data, ret.signature);
    }

    void Image::ReadMethodRefInfoFromMemberRef(const Il2CppGenericContainer* klassGenericContainer,
        const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex, MethodRefInfo& ret)
    {
        ResolveMemberRef rmr = {};
        ReadResolveMemberRefFromMemberRef(klassGenericContainer, methodGenericContainer, rowIndex, rmr);
        IL2CPP_ASSERT(rmr.parent.parentType == TableType::TYPEDEF || rmr.parent.parentType == TableType::TYPEREF || rmr.parent.parentType == TableType::TYPESPEC);
        IL2CPP_ASSERT(rmr.signature.memberType == TableType::METHODPTR);
        ret.containerType = rmr.parent.type;
        ret.methodDef = ResolveMethodDefinition(rmr.parent.type, rmr.name, rmr.signature.method);
    }

    const Il2CppGenericInst* Image::ReadMethodSpecInstantiation(uint32_t signature, const Il2CppGenericContainer* klassGenericContainer,
        const Il2CppGenericContainer* methodGenericContainer)
    {
        BlobReader reader = _rawImage->GetBlobReaderByRawIndex(signature);
        uint8_t rawSigFlags = reader.ReadByte();
        IL2CPP_ASSERT(rawSigFlags == 0xA);
        uint32_t argCount = reader.ReadCompressedUint32();
        IL2CPP_ASSERT(argCount >= 0 && argCount < 100);
        if (argCount == 0)
        {
            return nullptr;
        }

        IL2CPP_ASSERT(argCount > 0 && argCount <= 32);
        const Il2CppType* types[32];

        //genericInstantiation = (Il2CppGenericInst*)il2cpp::vm::MetadataMalloc(sizeof(Il2CppGenericInst));
        //genericInstantiation->type_argc = argCount;
        //genericInstantiation->type_argv = (const Il2CppType**)il2cpp::vm::MetadataCalloc(argCount, sizeof(Il2CppType*));
        for (uint32_t i = 0; i < argCount; i++)
        {
            const Il2CppType* type = ReadType(reader, klassGenericContainer, methodGenericContainer);
            types[i] = type;
        }
        return il2cpp::vm::MetadataCache::GetGenericInst(types, argCount);
    }

    void Image::ReadFieldRefInfoFromMemberRef(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex, FieldRefInfo& ret)
    {
        ResolveMemberRef rmr = {};
        ReadResolveMemberRefFromMemberRef(klassGenericContainer, methodGenericContainer, rowIndex, rmr);
        IL2CPP_ASSERT(rmr.parent.parentType == TableType::TYPEDEF || rmr.parent.parentType == TableType::TYPEREF || rmr.parent.parentType == TableType::TYPESPEC);
        IL2CPP_ASSERT(rmr.signature.memberType == TableType::FIELDPTR);
        ret.containerType = rmr.parent.type;
        ResolveFieldThrow(rmr.parent.type, rmr.name, rmr.signature.field.type, ret.field);
    }

    void Image::ReadLocalVarSig(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, il2cpp::utils::dynamic_array<const Il2CppType*>& vars)
    {
        uint8_t sig = reader.ReadByte();
        IL2CPP_ASSERT(sig == 0x7);
        uint32_t varCount = reader.ReadCompressedUint32();
        IL2CPP_ASSERT(varCount >= 1 && varCount <= 0xFFFE);
        vars.resize_uninitialized(varCount);
        for (uint32_t i = 0; i < varCount; i++)
        {
            vars[i] = ReadType(reader, klassGenericContainer, methodGenericContainer);
        }
    }

    void Image::ReadStandAloneSig(uint32_t signatureIdx, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, ResolveStandAloneMethodSig& methodSig)
    {
        BlobReader reader = _rawImage->GetBlobReaderByRawIndex(signatureIdx);
        uint8_t sig = reader.ReadByte();
        methodSig.flags = sig;
        uint32_t paramCount = reader.ReadCompressedUint32();
        if (paramCount > 0xFFFE)
        {
            RaiseBadImageException("ReadStandAloneSig exceed max param count");
        }
        methodSig.returnType = ReadType(reader, klassGenericContainer, methodGenericContainer);
        if (paramCount > 0)
        {
            for (uint32_t i = 0; i < paramCount; i++)
            {
                methodSig.params.push_back(ReadType(reader, klassGenericContainer, methodGenericContainer));
            }
        }
        if (reader.NonEmpty())
        {
            RaiseNotSupportedException("ReadStandAloneSig don't support sentinel params");
        }
    }

    Il2CppClass* Image::FindNetStandardExportedType(const char* namespaceStr, const char* nameStr)
    {
        for (const char** ptrAssName = s_netstandardRefs; *ptrAssName; ptrAssName++)
        {
            const Il2CppAssembly* refAss = GetLoadedAssembly(*ptrAssName);
            if (refAss)
            {
                const Il2CppImage* image2 = il2cpp::vm::Assembly::GetImage(refAss);
                Il2CppClass* klass = il2cpp::vm::Class::FromName(image2, namespaceStr, nameStr);
                if (klass)
                {
                    return klass;
                }
            }
        }
        return nullptr;
    }

    const Il2CppType* Image::GetIl2CppType(uint32_t assemblyRefIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound)
    {
        TbAssemblyRef data = _rawImage->ReadAssemblyRef(assemblyRefIndex);
        const char* assName = _rawImage->GetStringFromRawIndex(data.name);
        const char* typeNameStr = _rawImage->GetStringFromRawIndex(typeName);
        const char* typeNamespaceStr = _rawImage->GetStringFromRawIndex(typeNamespace);
        const Il2CppAssembly* refAss = GetLoadedAssembly(assName);
        Il2CppClass* klass = nullptr;
        if (refAss)
        {
            const Il2CppImage* image2 = il2cpp::vm::Assembly::GetImage(refAss);
            klass = il2cpp::vm::Class::FromName(image2, typeNamespaceStr, typeNameStr);
        }
        else if (!refAss && std::strcmp(assName, "netstandard") == 0)
        {
            klass = FindNetStandardExportedType(typeNamespaceStr, typeNameStr);
        }
        if (!klass)
        {
            if (!raiseExceptionIfNotFound)
            {
                return nullptr;
            }
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException(
                CStringToStringView(typeNamespaceStr),
                CStringToStringView(typeNameStr),
                CStringToStringView(assName)));
        }
        return &klass->byval_arg;
    }

    void Image::ReadMethodBody(const Il2CppMethodDefinition& methodDef, const TbMethod& methodData, MethodBody& body)
    {
        uint32_t bodyRVA = methodData.rva;
        if (bodyRVA > 0)
        {
            uint32_t methodImageOffset = 0;
            bool ret = _rawImage->TranslateRVAToImageOffset(bodyRVA, methodImageOffset);
            IL2CPP_ASSERT(ret);
            const byte* bodyStart = _rawImage->GetDataPtrByImageOffset(methodImageOffset);
            byte bodyFlags = *bodyStart;
            byte smallFatFlags = bodyFlags & 0x3;

            if (smallFatFlags == (uint8_t)CorILMethodFormat::Tiny)
            {
                body.flags = (uint32_t)(bodyFlags & 0x3);
                body.ilcodes = bodyStart + 1;
                body.codeSize = (uint8_t)bodyFlags >> 2;
                body.maxStack = 8;
            }
            else
            {
                IL2CPP_ASSERT(smallFatFlags == (uint8_t)CorILMethodFormat::Fat);
                const CorILMethodFatHeader* methodHeader = (const CorILMethodFatHeader*)GetAlignBorder<4>(bodyStart);
                IL2CPP_ASSERT(methodHeader->size == 3);
                body.flags = methodHeader->flags;
                body.ilcodes = bodyStart + methodHeader->size * 4;
                body.codeSize = methodHeader->codeSize;
                body.maxStack = methodHeader->maxStack;

                if (methodHeader->localVarSigToken)
                {
                    TbStandAloneSig sigData = _rawImage->ReadStandAloneSig(DecodeTokenRowIndex(methodHeader->localVarSigToken));

                    BlobReader reader = _rawImage->GetBlobReaderByRawIndex(sigData.signature);
                    ReadLocalVarSig(reader,
                        GetGenericContainerByTypeDefRawIndex(DecodeMetadataIndex(methodDef.declaringType)),
                        GetGenericContainerByRawIndex(DecodeMetadataIndex(methodDef.genericContainerIndex)),
                        body.localVars);
                }
            }
            if (body.flags & (uint8_t)CorILMethodFormat::MoreSects)
            {
                const byte* nextSection = (const byte*)GetAlignBorder<4>(body.ilcodes + body.codeSize);
                while (true)
                {
                    byte kind = *nextSection;
                    if (!(kind & (byte)CorILSecion::EHTable))
                    {
                        IL2CPP_ASSERT(false && "not support kind");
                        break;
                    }
                    if (kind & (byte)CorILSecion::FatFormat)
                    {
                        CorILEHSectionHeaderFat* ehSec = (CorILEHSectionHeaderFat*)nextSection;
                        uint32_t dataSize = (uint32_t)ehSec->dataSize0 | ((uint32_t)ehSec->dataSize1 << 8) | ((uint32_t)ehSec->dataSize2 << 16);
                        IL2CPP_ASSERT(dataSize % 24 == 4);
                        uint32_t ehCount = (dataSize - 4) / 24;
                        body.exceptionClauses.reserve(ehCount);
                        for (uint32_t i = 0; i < ehCount; i++)
                        {
                            CorILEHFat& eh = ehSec->clauses[i];
                            IL2CPP_ASSERT(eh.flags >= (uint32_t)CorILExceptionClauseType::Exception && eh.flags <= (uint32_t)CorILExceptionClauseType::Fault);
                            body.exceptionClauses.push_back({
                                (CorILExceptionClauseType)eh.flags,
                                eh.tryOffset,
                                eh.tryLength,
                                eh.handlerOffset,
                                eh.handlerLength,
                                eh.classTokenOrFilterOffset });
                        }
                        nextSection += dataSize;
                    }
                    else
                    {
                        CorILEHSectionHeaderSmall* ehSec = (CorILEHSectionHeaderSmall*)nextSection;
                        IL2CPP_ASSERT(ehSec->dataSize % 12 == 4);
                        uint32_t ehCount = (ehSec->dataSize - 4) / 12;
                        body.exceptionClauses.reserve(ehCount);
                        for (uint32_t i = 0; i < ehCount; i++)
                        {
                            CorILEHSmall& eh = ehSec->clauses[i];
                            IL2CPP_ASSERT(eh.flags >= 0 && eh.flags <= 4);
                            body.exceptionClauses.push_back({
                                (CorILExceptionClauseType)eh.flags,
                                eh.tryOffset,
                                eh.tryLength,
                                ((uint32_t)eh.handlerOffset1 << 8) + eh.handlerOffset0,
                                eh.handlerLength,
                                eh.classTokenOrFilterOffset });
                        }
                        nextSection += ehSec->dataSize;
                    }
                    if (!(kind & (byte)CorILSecion::MoreSects))
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            body.ilcodes = nullptr;
            body.codeSize = 0;
        }
    }

    const MethodInfo* Image::FindImplMethod(Il2CppClass* klass, const MethodInfo* method)
    {
        il2cpp::vm::Class::Init(klass);
        return il2cpp::vm::Class::GetVirtualMethod(klass, method);
    }


    Il2CppString* Image::GetIl2CppUserStringFromRawIndex(StringIndex index)
    {
        il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);
        Il2CppString* clrStr;
        if (_il2cppStringCache.TryGetValue(index, &clrStr))
        {
            return clrStr;
        }
        else
        {
            Il2CppString* clrStr = _rawImage->GetUserStringBlogByIndex((uint32_t)index);
#if HYBRIDCLR_UNITY_2022_OR_NEW
            _il2cppStringCache.GetOrAdd(index, clrStr);
#else
            _il2cppStringCache.Add(index, clrStr);
#endif
            return clrStr;
        }
    }

    Il2CppClass* Image::GetClassFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext)
    {
        TokenGenericContextType key(token, genericContext);
        auto it = tokenCache.find(key);
        if (it != tokenCache.end())
        {
            return (Il2CppClass*)it->second;
        }

        const Il2CppType* originType = ReadTypeFromToken(klassGenericContainer, methodGenericContainer, DecodeTokenTableType(token), DecodeTokenRowIndex(token));
        const Il2CppType* resultType = genericContext != nullptr ? il2cpp::metadata::GenericMetadata::InflateIfNeeded(originType, genericContext, true) : originType;
        Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(resultType);
        if (!klass)
        {
            TEMP_FORMAT(errMsg, "InterpreterImage::GetClassFromToken token:%u class not exists", token);
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException(errMsg));
        }
        tokenCache.insert({ key, (void*)klass });
        return klass;
    }

    const FieldInfo* Image::GetFieldInfoFromFieldRef(const Il2CppType& type, const Il2CppFieldDefinition* fieldDef)
    {
        Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(&type);
        const char* name = il2cpp::vm::GlobalMetadata::GetStringFromIndex(fieldDef->nameIndex);
        void* iter = nullptr;
        for (const FieldInfo* cur = nullptr; (cur = il2cpp::vm::Class::GetFields(klass, &iter)) != nullptr; )
        {
            if (cur->token == fieldDef->token)
            {
                IL2CPP_ASSERT(std::strcmp(cur->name, name) == 0);
                return cur;
            }
        }
        RaiseMissingFieldException(&type, name);
        return nullptr;
    }

    const MethodInfo* Image::ResolveMethodInfo(const Il2CppType* type, const char* resolveMethodName, const MethodRefSig& resolveSig, const Il2CppGenericInst* genericInstantiation, const Il2CppGenericContext* genericContext)
    {
        if (type->type != IL2CPP_TYPE_ARRAY)
        {
            const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
            const Il2CppGenericContainer* klassGenericContainer = GetGenericContainerFromIl2CppType(type);
            const char* typeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
            for (uint32_t i = 0; i < typeDef->method_count; i++)
            {
                const Il2CppMethodDefinition* methodDef = il2cpp::vm::GlobalMetadata::GetMethodDefinitionFromIndex(typeDef->methodStart + i);
                const char* methodName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex);
                IL2CPP_ASSERT((genericInstantiation ? genericInstantiation->type_argc : 0) == resolveSig.genericParamCount);
                if (std::strcmp(resolveMethodName, methodName) == 0 && IsMatchMethodSig(methodDef, resolveSig, klassGenericContainer))
                {
                    return GetMethodInfo(type, methodDef, genericInstantiation, genericContext);
                }
            }
        }
        else
        {
            IL2CPP_ASSERT(genericInstantiation == nullptr);
            Il2CppClass* arrayKlass = il2cpp::vm::Class::FromIl2CppType(type);
            il2cpp::vm::Class::SetupMethods(arrayKlass);
            const Il2CppType** genericClassInstArgv = genericContext && genericContext->class_inst ? genericContext->class_inst->type_argv : nullptr;
            const Il2CppType** genericMethodInstArgv = genericContext && genericContext->method_inst ? genericContext->method_inst->type_argv : nullptr;

            for (uint16_t i = 0; i < arrayKlass->method_count; i++)
            {
                const MethodInfo* method = arrayKlass->methods[i];
                if (std::strcmp(resolveMethodName, method->name) == 0 && IsMatchMethodSig(method, resolveSig, genericClassInstArgv, genericMethodInstArgv))
                {
                    return method;
                }
            }
        }
        RaiseMethodNotFindException(type, resolveMethodName);
        return nullptr;
    }

    const void* Image::ReadRuntimeHandleFromMemberRef(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext, uint32_t rowIndex)
    {
        ResolveMemberRef rmr = {};
        ReadResolveMemberRefFromMemberRef(klassGenericContainer, methodGenericContainer, rowIndex, rmr);
        if (rmr.signature.memberType == TableType::FIELDPTR)
        {
            const Il2CppFieldDefinition* fieldDef = nullptr;
            ResolveFieldThrow(rmr.parent.type, rmr.name, rmr.signature.field.type, fieldDef);
            if (!fieldDef)
            {
                RaiseMissingFieldException(rmr.parent.type, rmr.name);
            }
            const Il2CppType* parentType = genericContext != nullptr ? il2cpp::metadata::GenericMetadata::InflateIfNeeded(rmr.parent.type, genericContext, true) : rmr.parent.type;
            const FieldInfo* fieldInfo = GetFieldInfoFromFieldRef(*parentType, fieldDef);
            return fieldInfo;
        }
        else if (rmr.signature.memberType == TableType::METHODPTR)
        {
            const Il2CppType* parentType = genericContext != nullptr ? il2cpp::metadata::GenericMetadata::InflateIfNeeded(rmr.parent.type, genericContext, true) : rmr.parent.type;
            return ResolveMethodInfo(parentType, rmr.name, rmr.signature.method, nullptr, genericContext);
        }
        else
        {
            RaiseExecutionEngineException("GetRuntimeHandleFromToken invaild ParentType");
            return nullptr;
        }
    }

    const void* Image::GetRuntimeHandleFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext)
    {
        TableType ttype = DecodeTokenTableType(token);
        uint32_t rowIndex = DecodeTokenRowIndex(token);
        const void* handle = nullptr;
        switch (ttype)
        {
        case hybridclr::metadata::TableType::TYPEREF:
        case hybridclr::metadata::TableType::TYPEDEF:
        case hybridclr::metadata::TableType::TYPESPEC:
        {
            const Il2CppType* type = ReadTypeFromToken(klassGenericContainer, methodGenericContainer, ttype, rowIndex);
            if (genericContext)
            {
                type = TryInflateIfNeed(type, genericContext, true);
            }
            handle = type;
            break;
        }
        case hybridclr::metadata::TableType::FIELD:
        {
            handle = GetFieldInfoFromToken(tokenCache, token, klassGenericContainer, methodGenericContainer, genericContext);
            break;
        }
        case hybridclr::metadata::TableType::METHOD:
        case hybridclr::metadata::TableType::METHODSPEC:
        {
            handle = GetMethodInfoFromToken(tokenCache, token, klassGenericContainer, methodGenericContainer, genericContext);
            break;
        }
        case hybridclr::metadata::TableType::MEMBERREF:
        {
            handle = ReadRuntimeHandleFromMemberRef(klassGenericContainer, methodGenericContainer, genericContext, rowIndex);
            //_token2RuntimeHandleCache.insert({ key, (void*)handle });
            break;
        }
        default:
        {
            RaiseExecutionEngineException("GetRuntimeHandleFromToken invaild TableType");
            return nullptr;
        }
        }
        return handle;
    }

    const FieldInfo* Image::GetFieldInfoFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext)
    {
        TokenGenericContextType key(token, genericContext);
        auto it = tokenCache.find(key);
        if (it != tokenCache.end())
        {
            return (const FieldInfo*)it->second;
        }

        FieldRefInfo fri;
        ReadFieldRefInfoFromToken(klassGenericContainer, methodGenericContainer, DecodeTokenTableType(token), DecodeTokenRowIndex(token), fri);
        if (!fri.field)
        {
            TEMP_FORMAT(errMsg, "token:%d", token);
            RaiseMissingFieldException(fri.containerType, errMsg);
        }
        const Il2CppType* resultType = genericContext != nullptr ? il2cpp::metadata::GenericMetadata::InflateIfNeeded(fri.containerType, genericContext, true) : fri.containerType;
        const FieldInfo* fieldInfo = GetFieldInfoFromFieldRef(*resultType, fri.field);
        il2cpp::vm::Class::Init(fieldInfo->parent);
        tokenCache.insert({ key, (void*)fieldInfo });
        return fieldInfo;
    }


    const MethodInfo* Image::ReadMethodInfoFromToken(const Il2CppGenericContainer* klassGenericContainer,
        const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext, const Il2CppGenericInst* genericInst, TableType tableType, uint32_t rowIndex)
    {
        IL2CPP_ASSERT(rowIndex > 0);
        switch (tableType)
        {
        case TableType::METHOD:
        {
            const Il2CppMethodDefinition* methodDef = GetMethodDefinitionFromRawIndex(rowIndex - 1);
            const Il2CppTypeDefinition* declareType = (Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(methodDef->declaringType);
            const Il2CppType* type = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(declareType->byvalTypeIndex);
            return GetMethodInfo(type, methodDef, genericInst, genericContext);
        }
        case TableType::MEMBERREF:
        {
            ResolveMemberRef rmr = {};
            ReadResolveMemberRefFromMemberRef(klassGenericContainer, methodGenericContainer, rowIndex, rmr);
            IL2CPP_ASSERT(rmr.parent.parentType == TableType::TYPEDEF || rmr.parent.parentType == TableType::TYPEREF || rmr.parent.parentType == TableType::TYPESPEC);
            IL2CPP_ASSERT(rmr.signature.memberType == TableType::METHODPTR);
            if (genericContext)
            {
                rmr.parent.type = TryInflateIfNeed(rmr.parent.type, genericContext, true);
            }
            return ResolveMethodInfo(rmr.parent.type, rmr.name, rmr.signature.method, genericInst, genericContext);
        }
        case TableType::METHODSPEC:
        {
            TbMethodSpec methodSpec = _rawImage->ReadMethodSpec(rowIndex);
            const Il2CppGenericInst* genericInstantiation = ReadMethodSpecInstantiation(methodSpec.instantiation, klassGenericContainer, methodGenericContainer);
            genericInstantiation = TryInflateGenericInst(genericInstantiation, genericContext);

            TableType methodTableType = DecodeMethodDefOrRefCodedIndexTableType(methodSpec.method);
            uint32_t methodRowIndex = DecodeMethodDefOrRefCodedIndexRowIndex(methodSpec.method);
            switch (methodTableType)
            {
            case TableType::METHOD:
            {
                return ReadMethodInfoFromToken(klassGenericContainer, methodGenericContainer, genericContext, genericInstantiation, methodTableType, methodRowIndex);
            }
            case TableType::MEMBERREF:
            {
                return ReadMethodInfoFromToken(klassGenericContainer, methodGenericContainer, genericContext, genericInstantiation, methodTableType, methodRowIndex);
            }
            default:
            {
                RaiseBadImageException("ReadMethodSpec invaild TableType");
                return nullptr;
            }
            }
            break;
        }
        default:
        {
            RaiseBadImageException("ReadMethodInfoFromToken invaild TableType");
            return nullptr;
        }
        }
    }

    const MethodInfo* Image::GetMethodInfoFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext)
    {
        auto key = std::tuple<uint32_t, const Il2CppGenericContext*>(token, genericContext);
        auto it = tokenCache.find(key);
        if (it != tokenCache.end())
        {
            return (const MethodInfo*)it->second;
        }

        const MethodInfo* method = ReadMethodInfoFromToken(klassGenericContainer, methodGenericContainer, genericContext,
            nullptr, DecodeTokenTableType(token), DecodeTokenRowIndex(token));

        IL2CPP_ASSERT(method);
        il2cpp::vm::Class::Init(method->klass);

        tokenCache.insert({ key, (void*)method });
        return method;
    }

    const MethodInfo* Image::GetMethodInfo(const Il2CppType* containerType, const Il2CppMethodDefinition* methodDef, const Il2CppGenericInst* instantiation, const Il2CppGenericContext* genericContext)
    {
        const Il2CppType* finalContainerType = TryInflateIfNeed(containerType, genericContext, true);
        const MethodInfo* method = GetMethodInfoFromMethodDef(containerType, methodDef);
        IL2CPP_ASSERT(method);
        // final genericContext = finalContainerType.class_inst + mri.instantiation
        if (instantiation)
        {
            const Il2CppGenericInst* finalClassIns = finalContainerType->type == IL2CPP_TYPE_GENERICINST ? finalContainerType->data.generic_class->context.class_inst : nullptr;
            const Il2CppGenericInst* finalMethodIns = instantiation;
            Il2CppGenericContext finalGenericContext = { finalClassIns, finalMethodIns };
            method = method->is_inflated ? method->genericMethod->methodDefinition : method;
            method = il2cpp::metadata::GenericMetadata::Inflate(method, &finalGenericContext);
            IL2CPP_ASSERT(method);
        }
        return method;
    }

    void Image::GetStandAloneMethodSigFromToken(uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext, ResolveStandAloneMethodSig& methodSig)
    {
        TbStandAloneSig sas = _rawImage->ReadStandAloneSig(DecodeTokenRowIndex(token));
        ReadStandAloneSig(sas.signature, klassGenericContainer, methodGenericContainer, methodSig);
        if (genericContext)
        {
            methodSig.returnType = TryInflateIfNeed(methodSig.returnType, genericContext, true);
            for (uint32_t i = 0, n = (uint32_t)methodSig.params.size(); i < n; i++)
            {
                methodSig.params[i] = TryInflateIfNeed(methodSig.params[i], genericContext, true);
            }
        }
    }

    void Image::ReadFieldRefInfoFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex, FieldRefInfo& ret)
    {
        IL2CPP_ASSERT(rowIndex > 0);
        if (tableType == TableType::FIELD)
        {
            ReadFieldRefInfoFromFieldDefToken(rowIndex, ret);
        }
        else
        {
            IL2CPP_ASSERT(tableType == TableType::MEMBERREF);
            ReadFieldRefInfoFromMemberRef(klassGenericContainer, methodGenericContainer, rowIndex, ret);
        }
    }
}
}
```

`hybridclr/metadata/Image.h`:

```h
#pragma once

#include <vector>
#include <unordered_map>
#include <tuple>

#include "vm/GlobalMetadataFileInternals.h"
#include "vm/Assembly.h"
#include "gc/GarbageCollector.h"
#include "gc/Allocator.h"
#include "gc/AppendOnlyGCHashMap.h"
#include "utils/Il2CppHashMap.h"

#include "RawImage.h"
#include "VTableSetup.h"
#include "MetadataUtil.h"
#include "PDBImage.h"


namespace hybridclr
{
namespace metadata
{

	typedef std::tuple<uint32_t, const Il2CppGenericContext*> TokenGenericContextType;

	struct TokenGenericContextTypeHash {
		size_t operator()(const TokenGenericContextType x) const noexcept {
			return std::get<0>(x) * 0x9e3779b9 + (size_t)std::get<1>(x);
		}
	};

	struct TokenGenericContextTypeEqual
	{
		bool operator()(const TokenGenericContextType a, const TokenGenericContextType b) const {
			return std::get<0>(a) == std::get<0>(b) && std::get<1>(a) == std::get<1>(b);
		}
	};

	typedef Il2CppHashMap<std::tuple<uint32_t, const Il2CppGenericContext*>, void*, TokenGenericContextTypeHash, TokenGenericContextTypeEqual> Token2RuntimeHandleMap;

	class Image
	{
	public:

		RawImageBase& GetRawImage() const
		{
			return *_rawImage;
		}

		LoadImageErrorCode InitRawImage(const void* imageData, size_t length);

		PDBImage* GetPDBImage() const
		{
			return _pdbImage;
		}

		LoadImageErrorCode LoadPDB(const void* pdbBytes, size_t pdbLength)
		{
			_pdbImage = new PDBImage();
			LoadImageErrorCode err = _pdbImage->Load(pdbBytes, pdbLength);
			if (err != LoadImageErrorCode::OK)
			{
				delete _pdbImage;
				_pdbImage = nullptr;
				return LoadImageErrorCode::PDB_BAD_FILE;
			}
			return LoadImageErrorCode::OK;
		}

		// misc
		bool IsValueTypeFromToken(TableType tableType, uint32_t rowIndex);
		bool IsThreadStaticCtorToken(TableType tableType, uint32_t rowIndex);
		void ReadMemberRefParentFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex, ResolveMemberRefParent& ret);
		const Il2CppType* ReadTypeFromMemberRefParent(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex);

		const Il2CppType* GetIl2CppType(uint32_t assemblyRefIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound);
		// type
		const Il2CppType* ReadType(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer);

		const Il2CppType* ReadTypeFromTypeDef(uint32_t rowIndex);
		const Il2CppType* ReadTypeFromTypeRef(uint32_t rowIndex);
		const Il2CppType* ReadTypeFromTypeSpec(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex);
		const Il2CppType* ReadTypeFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex);

		virtual const Il2CppType* ReadTypeFromResolutionScope(uint32_t scope, uint32_t typeNamespace, uint32_t typeName);

		const Il2CppType* ReadArrayType(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer);
		const Il2CppGenericClass* ReadGenericClass(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer);

		// signature
		void ReadMemberRefSig(const Il2CppGenericContainer* klassGenericContainer, TbMemberRef& data, ResolveMemberRefSig& signature);
		void ReadFieldRefSig(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, FieldRefSig& field);
		void ReadMethodRefSig(BlobReader& reader, MethodRefSig& method);
		const Il2CppGenericInst* ReadMethodSpecInstantiation(uint32_t signatureIdx, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer);
		void ReadLocalVarSig(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, il2cpp::utils::dynamic_array<const Il2CppType*>& vars);
		void ReadStandAloneSig(uint32_t signatureIdx, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, ResolveStandAloneMethodSig& sig);

		// resolve from token
		void ReadResolveMemberRefFromMemberRef(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex, ResolveMemberRef& ret);
		void ReadMethodRefInfoFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex, MethodRefInfo& ret);
		void ReadMethodRefInfoFromMemberRef(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex, MethodRefInfo& ret);
		const MethodInfo* ResolveMethodInfo(const Il2CppType* type, const char* resolveMethodName, const MethodRefSig& resolveSig, const Il2CppGenericInst* genericInstantiation, const Il2CppGenericContext* genericContext);

		const void* ReadRuntimeHandleFromMemberRef(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext, uint32_t rowIndex);

		void ReadFieldRefInfoFromMemberRef(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, uint32_t rowIndex, FieldRefInfo& ret);
		void ReadMethodBody(const Il2CppMethodDefinition& methodDef, const TbMethod& methodData, MethodBody& body);

		Il2CppString* GetIl2CppUserStringFromRawIndex(StringIndex index);
		Il2CppClass* GetClassFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext);
		const FieldInfo* GetFieldInfoFromFieldRef(const Il2CppType& type, const Il2CppFieldDefinition* fieldDef);
		const void* GetRuntimeHandleFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext);
		const MethodInfo* FindImplMethod(Il2CppClass* klass, const MethodInfo* matchMethod);
		const FieldInfo* GetFieldInfoFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext);
		const MethodInfo* ReadMethodInfoFromToken(const Il2CppGenericContainer* klassGenericContainer,
			const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext, const Il2CppGenericInst* genericInst, TableType tableType, uint32_t rowIndex);
		const MethodInfo* GetMethodInfoFromToken(Token2RuntimeHandleMap& tokenCache, uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext);
		const MethodInfo* GetMethodInfo(const Il2CppType* containerType, const Il2CppMethodDefinition* methodDef, const Il2CppGenericInst* instantiation, const Il2CppGenericContext* genericContext);
		void GetStandAloneMethodSigFromToken(uint32_t token, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, const Il2CppGenericContext* genericContext, ResolveStandAloneMethodSig& methodSig);
		void ReadFieldRefInfoFromToken(const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, TableType tableType, uint32_t rowIndex, FieldRefInfo& ret);

		virtual const Il2CppType* GetModuleIl2CppType(uint32_t moduleRowIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound) = 0;
		virtual const Il2CppType* GetIl2CppTypeFromRawTypeDefIndex(uint32_t index) = 0;
		virtual Il2CppGenericContainer* GetGenericContainerByRawIndex(uint32_t index) = 0;
		virtual Il2CppGenericContainer* GetGenericContainerByTypeDefRawIndex(int32_t typeDefIndex) = 0;
		virtual const Il2CppMethodDefinition* GetMethodDefinitionFromRawIndex(uint32_t index) = 0;

		virtual MethodBody* GetMethodBody(uint32_t token) = 0;
		virtual void ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret) = 0;
		virtual void InitRuntimeMetadatas() = 0;
	protected:
		Image() : _rawImage(nullptr), _pdbImage(nullptr)
		{
			il2cpp::vm::AssemblyVector assemblies;
			il2cpp::vm::Assembly::GetAllAssemblies(assemblies);
			for (auto ass : assemblies)
			{
				_nameToAssemblies[ass->image->nameNoExt] = ass;
			}
		}

		virtual ~Image()
		{
			if (_rawImage)
			{
				delete _rawImage;
				_rawImage = nullptr;
			}
			if (_pdbImage)
			{
				delete _pdbImage;
				_pdbImage = nullptr;
			}
		}

		const Il2CppAssembly* GetLoadedAssembly(const char* assemblyName)
		{
			auto it = _nameToAssemblies.find(assemblyName);
			if (it != _nameToAssemblies.end())
			{
				return it->second;
			}
			// relying assembly is loaded after self
			for (const Il2CppAssembly* ass : *il2cpp::vm::Assembly::GetAllAssemblies())
			{
				if (!std::strcmp(ass->image->nameNoExt, assemblyName))
				{
					_nameToAssemblies[ass->image->nameNoExt] = ass;
					return ass;
				}
			}
			return nullptr;
		}

		Il2CppClass* FindNetStandardExportedType(const char* namespaceStr, const char* nameStr);

		RawImageBase* _rawImage;
		PDBImage* _pdbImage;
		Il2CppHashMap<const char*, const Il2CppAssembly*, CStringHash, CStringEqualTo> _nameToAssemblies;
		il2cpp::gc::AppendOnlyGCHashMap<uint32_t, Il2CppString*, il2cpp::utils::PassThroughHash<uint32_t>> _il2cppStringCache;
	};
}
}
```

`hybridclr/metadata/InterpreterImage.cpp`:

```cpp
#include "InterpreterImage.h"

#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

#include "il2cpp-class-internals.h"
#include "vm/GlobalMetadata.h"
#include "vm/Type.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/Array.h"
#include "vm/MetadataLock.h"
#include "vm/MetadataCache.h"
#include "vm/MetadataAlloc.h"
#include "vm/String.h"
#include "vm/Reflection.h"
#include "metadata/FieldLayout.h"
#include "metadata/Il2CppTypeCompare.h"
#include "metadata/GenericMetadata.h"
#if HYBRIDCLR_UNITY_2021_OR_NEW
#include "metadata/CustomAttributeCreator.h"
#endif
#include "os/Atomic.h"
#include "icalls/mscorlib/System/MonoCustomAttrs.h"

#include "MetadataModule.h"
#include "MetadataUtil.h"
#include "ClassFieldLayoutCalculator.h"
#include "MetadataPool.h"

#include "../interpreter/Engine.h"
#include "../interpreter/InterpreterModule.h"

namespace hybridclr
{
namespace metadata
{

	static uint32_t s_nextImageIndexByKind[4] = { (1u << kMetadataImageIndexExtraShiftBitsA), 0, 0, 0};

	InterpreterImage* InterpreterImage::s_images[kMaxMetadataImageCount] = {};

	static int32_t GetImageKindByDllLength(uint32_t dllLength)
	{
		uint32_t maxPossibleIndexValue = dllLength * 4;
		for (int32_t i = 3; i >= 0; i--)
		{
			if (maxPossibleIndexValue <= kMetadataIndexMaskArr[i])
			{
				return i;
			}
		}
		return -1;
	}

	void InterpreterImage::Initialize()
	{
		
	}

	uint32_t InterpreterImage::AllocImageIndex(uint32_t dllLength)
	{
		int32_t kind = GetImageKindByDllLength(dllLength);
		if (kind < 0)
		{
			return kInvalidImageIndex;
		}
		for (int32_t finalKind = kind; finalKind >= 0; finalKind--)
		{
			uint32_t newImageIndex = s_nextImageIndexByKind[finalKind];
			// 255 is preserved for invalid image index when kind is 3
			if (newImageIndex >= kMaxMetadataImageIndexWithoutKind - (finalKind == 3))
			{
				continue;
			}
			s_nextImageIndexByKind[finalKind] += (1u << kMetadataImageIndexExtraShiftBitsArr[finalKind]);
			return newImageIndex | ((uint32_t)finalKind << (kMetadataImageIndexBits - kMetadataKindBits));
		}
		return kInvalidImageIndex;
	}

	void InterpreterImage::RegisterImage(InterpreterImage* image)
	{
		il2cpp::os::Atomic::FullMemoryBarrier();
		IL2CPP_ASSERT(image->GetIndex() > 0);
		s_images[image->GetIndex()] = image;
	}

	void InterpreterImage::InitBasic(Il2CppImage* image)
	{
		SetIl2CppImage(image);
		RegisterImage(this);
	}

	void InterpreterImage::BuildIl2CppAssembly(Il2CppAssembly* ass)
	{
		ass->token = EncodeToken(TableType::ASSEMBLY, 1);
		ass->referencedAssemblyStart = EncodeWithIndex(1);
		ass->referencedAssemblyCount = _rawImage->GetTableRowNum(TableType::ASSEMBLYREF);

		TbAssembly data = _rawImage->ReadAssembly(1);
		auto& aname = ass->aname;
		aname.hash_alg = data.hashAlgId;
		aname.major = data.majorVersion;
		aname.minor = data.minorVersion;
		aname.build = data.buildNumber;
		aname.revision = data.revisionNumber;
		aname.flags = data.flags;
		aname.public_key = _rawImage->GetBlobFromRawIndex(data.publicKey);
		aname.name = _rawImage->GetStringFromRawIndex(data.name);
		aname.culture = _rawImage->GetStringFromRawIndex(data.locale);
	}

	void InterpreterImage::BuildIl2CppImage(Il2CppImage* image2)
	{
		image2->typeCount = _rawImage->GetTableRowNum(TableType::TYPEDEF);
		image2->exportedTypeCount = _rawImage->GetTableRowNum(TableType::EXPORTEDTYPE);
		image2->customAttributeCount = _rawImage->GetTableRowNum(TableType::CUSTOMATTRIBUTE);

#if HYBRIDCLR_UNITY_2019
		image2->typeStart = EncodeWithIndex(0);
		image2->customAttributeStart = EncodeWithIndex(0);
		image2->entryPointIndex = EncodeWithIndexExcept0(_rawImage->GetEntryPointToken());
		image2->exportedTypeStart = EncodeWithIndex(0);
#else
		Il2CppImageGlobalMetadata* metadataImage = (Il2CppImageGlobalMetadata*)HYBRIDCLR_METADATA_MALLOC(sizeof(Il2CppImageGlobalMetadata));
		metadataImage->typeStart = EncodeWithIndex(0);
		metadataImage->customAttributeStart = EncodeWithIndex(0);
		metadataImage->entryPointIndex = EncodeWithIndexExcept0(_rawImage->GetEntryPointToken());
		metadataImage->exportedTypeStart = EncodeWithIndex(0);
		metadataImage->image = image2;
		image2->metadataHandle = reinterpret_cast<Il2CppMetadataImageHandle>(metadataImage);
#endif

		image2->nameToClassHashTable = nullptr;
		image2->codeGenModule = nullptr;

		image2->token = EncodeWithIndex(0); // TODO
		image2->dynamic = 0;
	}

	void InterpreterImage::InitRuntimeMetadatas()
	{
		IL2CPP_ASSERT(_rawImage->GetTable(TableType::EXPORTEDTYPE).rowNum == 0);

		InitGenericParamDefs0();
		InitTypeDefs_0();
		InitMethodDefs0();
		InitGenericParamDefs();
		InitNestedClass(); // must before typedefs1, because parent may be nested class
		InitTypeDefs_1();

		InitGenericParamConstraintDefs();

		InitParamDefs();
		InitMethodDefs();
		InitFieldDefs();
		InitFieldLayouts();
		InitFieldRVAs();
		InitBlittables();
		InitMethodImpls0();
		InitProperties();
		InitEvents();
		InitMethodSemantics();
		InitConsts();
		InitCustomAttributes();
		InitModuleRefs();
		InitImplMaps();
		InitClassLayouts0();
		InitTypeDefs_2();
		InitClassLayouts();
		InitInterfaces();
		InitClass();
		InitVTables();

		Il2CppHashMap<const Il2CppType*, uint32_t, Il2CppTypeHashShallow, Il2CppTypeEqualityComparerShallow> temp;
		_type2Indexs.swap(temp);

		delete _paramRawIndex2ActualParamIndex;
		_paramRawIndex2ActualParamIndex = nullptr;
	}

	void InterpreterImage::InitTypeDefs_0()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		_typesDefines.resize(typeDefTb.rowNum);
		_typeDetails.resize(typeDefTb.rowNum);
		for (uint32_t i = 0, n = typeDefTb.rowNum; i < n; i++)
		{
			Il2CppTypeDefinition& cur = _typesDefines[i];
			TypeDefinitionDetail& typeDetail = _typeDetails[i];
			typeDetail.typeSizes = {};

			uint32_t rowIndex = i + 1;
			TbTypeDef data = _rawImage->ReadTypeDef(rowIndex);

			cur = {};

			cur.genericContainerIndex = kGenericContainerIndexInvalid;
			cur.declaringTypeIndex = kTypeDefinitionIndexInvalid;
			cur.elementTypeIndex = kTypeDefinitionIndexInvalid;

			cur.token = EncodeToken(TableType::TYPEDEF, rowIndex);

			bool isValueType = data.extends && IsValueTypeFromToken(DecodeTypeDefOrRefOrSpecCodedIndexTableType(data.extends), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(data.extends));
			Il2CppType* cppType = MetadataMallocT<Il2CppType>();
			cppType->type = isValueType ? IL2CPP_TYPE_VALUETYPE : IL2CPP_TYPE_CLASS;
			SET_IL2CPPTYPE_VALUE_TYPE(*cppType, isValueType);
			cppType->data.typeHandle = (Il2CppMetadataTypeHandle)&cur;
			cur.byvalTypeIndex = AddIl2CppTypeCache(cppType);
#if HYBRIDCLR_UNITY_2019
			Il2CppType* byRefType = MetadataMallocT<Il2CppType>();
			*byRefType = *cppType;
			byRefType->byref = 1;
			cur.byrefTypeIndex = AddIl2CppTypeCache(byRefType);
#endif

			if (IsInterface(cur.flags))
			{
				cur.interfaceOffsetsStart = EncodeWithIndex(0);
				cur.interface_offsets_count = 0;
				cur.vtableStart = EncodeWithIndex(0);
				cur.vtable_count = 0;
			}
			else
			{
				cur.interfaceOffsetsStart = 0;
				cur.interface_offsets_count = 0;
				cur.vtableStart = 0;
				cur.vtable_count = 0;
			}
		}
	}

	void InterpreterImage::InitTypeDefs_1()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		for (uint32_t i = 0, n = typeDefTb.rowNum; i < n; i++)
		{
			Il2CppTypeDefinition& last = _typesDefines[i > 0 ? i - 1 : 0];
			Il2CppTypeDefinition& cur = _typesDefines[i];
			uint32_t rowIndex = i + 1;
			TbTypeDef data = _rawImage->ReadTypeDef(rowIndex); // token from 1

			cur.flags = data.flags;
			cur.nameIndex = EncodeWithIndex(data.typeName);
			cur.namespaceIndex = EncodeWithIndex(data.typeNamespace);

			cur.fieldStart = EncodeWithIndex(data.fieldList - 1);
			cur.methodStart = EncodeWithIndex(data.methodList - 1);

			if (i > 0)
			{
				last.field_count = (uint16_t)(cur.fieldStart - last.fieldStart);
				last.method_count = (uint16_t)(cur.methodStart - last.methodStart);
			}
			if (i == n - 1)
			{
				cur.field_count = (uint16_t)(_rawImage->GetTableRowNum(TableType::FIELD) - DecodeMetadataIndex(cur.fieldStart));
				cur.method_count = (uint16_t)(_rawImage->GetTableRowNum(TableType::METHOD) - DecodeMetadataIndex(cur.methodStart));
			}

			if (data.extends != 0)
			{
				const Il2CppType* parentType = ReadTypeFromToken(GetGenericContainerByTypeDefinition(&cur), nullptr, DecodeTypeDefOrRefOrSpecCodedIndexTableType(data.extends), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(data.extends));

				if (parentType->type == IL2CPP_TYPE_CLASS || parentType->type == IL2CPP_TYPE_VALUETYPE)
				{
					Il2CppTypeDefinition* parentDef = (Il2CppTypeDefinition*)parentType->data.typeHandle;
					// FIXE ME . check mscorelib
					const char* parentNs = il2cpp::vm::GlobalMetadata::GetStringFromIndex(parentDef->namespaceIndex);
					if (std::strcmp(parentNs, "System") == 0)
					{
						const char* parentName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(parentDef->nameIndex);
						if (std::strcmp(parentName, "Enum") == 0)
						{
							cur.bitfield |= (1 << (il2cpp::vm::kBitIsValueType - 1));
							cur.bitfield |= (1 << (il2cpp::vm::kBitIsEnum - 1));
						}
						else if (std::strcmp(parentName, "ValueType") == 0)
						{
							cur.bitfield |= (1 << (il2cpp::vm::kBitIsValueType - 1));
						}
					}
				}
				cur.parentIndex = AddIl2CppTypeCache(parentType);
			}
			else
			{
				cur.parentIndex = kInvalidIndex;
			}

			cur.elementTypeIndex = kInvalidIndex;
		}
	}

	void InterpreterImage::InitTypeDefs_2()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);

		for (uint32_t i = 0, n = typeDefTb.rowNum; i < n; i++)
		{
			TbTypeDef data = _rawImage->ReadTypeDef(i + 1); // token from 1

			Il2CppTypeDefinition& last = _typesDefines[i > 0 ? i - 1 : 0];
			Il2CppTypeDefinition& cur = _typesDefines[i];
			uint32_t typeIndex = i; // type index start from 0, diff with field index ...

			// enum element_type == 
			if (IsEnumType(&cur))
			{
				cur.elementTypeIndex = _fieldDetails[DecodeMetadataIndex(cur.fieldStart)].fieldDef.typeIndex;
			}

			auto classLayoutRow = _classLayouts.find(typeIndex);
			uint16_t packingSize = 0;
			if (classLayoutRow != _classLayouts.end())
			{
				auto& layoutData = classLayoutRow->second;
				packingSize = layoutData.packingSize;
			}
			else
			{
				cur.bitfield |= (1 << (il2cpp::vm::kClassSizeIsDefault - 1));
			}
			if (packingSize != 0)
			{
				cur.bitfield |= ((uint32_t)il2cpp::vm::GlobalMetadata::ConvertPackingSizeToEnum((uint8_t)packingSize) << (il2cpp::vm::kPackingSize - 1));
			}
			else
			{
				cur.bitfield |= (1 << (il2cpp::vm::kPackingSizeIsDefault - 1));
			}
		}
	}

	void InterpreterImage::InitParamDefs()
	{
		const Table& tb = _rawImage->GetTable(TableType::PARAM);

		// extra 16 for not name params
		_params.reserve(tb.rowNum + 16);
		_paramRawIndex2ActualParamIndex = new std::vector<TypeIndex>(tb.rowNum);
		//for (uint32_t i = 0; i < tb.rowNum; i++)
		//{
		//	uint32_t rowIndex = i + 1;
		//	Il2CppParameterDefinition& pd = _params[i].paramDef;
		//	TbParam data = _rawImage->ReadParam(rowIndex);

		//	pd.nameIndex = EncodeWithIndex(data.name);
		//	pd.token = EncodeToken(TableType::PARAM, rowIndex);
		//	// pd.typeIndex 在InitMethodDefs中解析signature后填充。
		//}
	}


	void InterpreterImage::InitFieldDefs()
	{
		const Table& fieldTb = _rawImage->GetTable(TableType::FIELD);
		_fieldDetails.resize(fieldTb.rowNum);

		for (size_t i = 0; i < _typesDefines.size(); i++)
		{
			Il2CppTypeDefinition& typeDef = _typesDefines[i];
			uint32_t start = DecodeMetadataIndex(typeDef.fieldStart);
			for (uint32_t k = 0; k < typeDef.field_count; k++)
			{
				FieldDetail& fd = _fieldDetails[start + k];
				fd.typeDefIndex = (uint32_t)i;
			}
		}

		for (uint32_t i = 0, n = fieldTb.rowNum; i < n; i++)
		{
			FieldDetail& fd = _fieldDetails[i];
			Il2CppFieldDefinition& cur = fd.fieldDef;

			fd.offset = 0;
			fd.defaultValueIndex = kDefaultValueIndexNull;

			uint32_t rowIndex = i + 1;
			TbField data = _rawImage->ReadField(rowIndex);

			BlobReader br = _rawImage->GetBlobReaderByRawIndex(data.signature);
			FieldRefSig frs;
			ReadFieldRefSig(br, GetGenericContainerByTypeDefRawIndex(DecodeMetadataIndex(fd.typeDefIndex)), frs);
			if (data.flags != 0)
			{
				Il2CppType typeWithAttrs = *frs.type;
				typeWithAttrs.attrs = data.flags;
				frs.type = MetadataPool::GetPooledIl2CppType(typeWithAttrs);
			}

			//cur = {};
			cur.nameIndex = EncodeWithIndex(data.name);
			cur.token = EncodeToken(TableType::FIELD, rowIndex);
			cur.typeIndex = AddIl2CppTypeCache(frs.type);
		}
	}

	void InterpreterImage::InitFieldLayouts()
	{
		const Table& tb = _rawImage->GetTable(TableType::FIELDLAYOUT);
		for (uint32_t i = 0; i < tb.rowNum; i++)
		{
			TbFieldLayout data = _rawImage->ReadFieldLayout(i + 1);
			_fieldDetails[data.field - 1].offset = sizeof(Il2CppObject) + data.offset;
		}
	}

	void InterpreterImage::InitFieldRVAs()
	{
		const Table& tb = _rawImage->GetTable(TableType::FIELDRVA);
		for (uint32_t i = 0; i < tb.rowNum; i++)
		{
			TbFieldRVA data = _rawImage->ReadFieldRVA(i + 1);
			FieldDetail& fd = _fieldDetails[data.field - 1];
			fd.defaultValueIndex = (uint32_t)_fieldDefaultValues.size();

			Il2CppFieldDefaultValue fdv = {};
			fdv.fieldIndex = data.field - 1;
			fdv.typeIndex = fd.fieldDef.typeIndex;

			uint32_t dataImageOffset = (uint32_t)-1;
			bool ret = _rawImage->TranslateRVAToImageOffset(data.rva, dataImageOffset);
			IL2CPP_ASSERT(ret);
#if HYBRIDCLR_UNITY_2021_OR_NEW
			fdv.dataIndex = (DefaultValueDataIndex)EncodeWithIndex(EncodeWithBlobSource(dataImageOffset, BlobSource::RAW_IMAGE));
#else
			fdv.dataIndex = (DefaultValueDataIndex)EncodeWithIndex(dataImageOffset);
#endif
			_fieldDefaultValues.push_back(fdv);
		}
	}

	void InterpreterImage::InitBlittables()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);

		std::vector<bool> computFlags(typeDefTb.rowNum, false);

		for (uint32_t i = 0, n = typeDefTb.rowNum; i < n; i++)
		{
			ComputeBlittable(&_typesDefines[i], computFlags);
		}
	}

	void InterpreterImage::ComputeBlittable(Il2CppTypeDefinition* def, std::vector<bool>& computFlags)
	{
		if (DecodeImageIndex(def->byvalTypeIndex) != GetIndex())
		{
			return;
		}
		uint32_t typeIndex = GetTypeRawIndex(def);
		if (computFlags[typeIndex])
		{
			return;
		}
		computFlags[typeIndex] = true;

		const Il2CppType* type = GetIl2CppTypeFromRawIndex(DecodeMetadataIndex(def->byvalTypeIndex));

		const char* typeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(def->nameIndex);


		bool blittable = false;
		if (type->type == IL2CPP_TYPE_VALUETYPE)
		{
			blittable = true;
			for (int i = 0; i < def->field_count; i++)
			{
				const Il2CppFieldDefinition* field = GetFieldDefinitionFromRawIndex(DecodeMetadataIndex(def->fieldStart + i));
				const Il2CppType* fieldType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(field->typeIndex);
				if (!hybridclr::metadata::IsInstanceField(fieldType))
				{
					continue;
				}

				switch (fieldType->type)
				{
				case IL2CPP_TYPE_BOOLEAN:
				case IL2CPP_TYPE_CHAR:
				case IL2CPP_TYPE_I1:
				case IL2CPP_TYPE_U1:
				case IL2CPP_TYPE_I2:
				case IL2CPP_TYPE_U2:
				case IL2CPP_TYPE_I4:
				case IL2CPP_TYPE_U4:
				case IL2CPP_TYPE_I:
				case IL2CPP_TYPE_U:
				case IL2CPP_TYPE_I8:
				case IL2CPP_TYPE_U8:
				case IL2CPP_TYPE_R4:
				case IL2CPP_TYPE_R8:
				case IL2CPP_TYPE_PTR:
				case IL2CPP_TYPE_FNPTR:
				{
					break;
				}
				case IL2CPP_TYPE_VALUETYPE:
				{
					Il2CppTypeDefinition* fieldDef = (Il2CppTypeDefinition*)fieldType->data.typeHandle;
					ComputeBlittable(fieldDef, computFlags);
					blittable = fieldDef->bitfield & (1 << (il2cpp::vm::kBitIsBlittable - 1));
					break;
				}
				default:
				{
					blittable = false;
				}
				}
				if (!blittable)
				{
					break;
				}
			}
		}
		if (blittable)
		{
			def->bitfield |= (1 << (il2cpp::vm::kBitIsBlittable - 1));
		}
	}

#if HYBRIDCLR_UNITY_2021_OR_NEW
	DefaultValueDataIndex InterpreterImage::ConvertConstValue(CustomAttributeDataWriter& writer, uint32_t blobIndex, const Il2CppType* type)
	{
		Il2CppTypeEnum ttype = type->type;
		if (ttype == IL2CPP_TYPE_CLASS)
		{
			return kDefaultValueIndexNull;
		}

		DefaultValueIndex retIndex = EncodeWithIndex(EncodeWithBlobSource((DefaultValueIndex)writer.Size(), BlobSource::CONVERTED_IL2CPP_FORMAT));

		BlobReader reader = _rawImage->GetBlobReaderByRawIndex(blobIndex);
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		{
			writer.Write(reader, 1);
			break;
		}
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		{
			writer.Write(reader, 2);
			break;
		}
		case IL2CPP_TYPE_I4:
		{
			writer.WriteCompressedInt32((int32_t)reader.Read32());
			break;
		}
		case IL2CPP_TYPE_U4:
		{
			writer.WriteCompressedUint32(reader.Read32());
			break;
		}
		case IL2CPP_TYPE_R4:
		{
			writer.Write(reader, 4);
			break;
		}
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
		{
			writer.Write(reader, 8);
			break;
		}
		case IL2CPP_TYPE_STRING:
		{
			std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8((const Il2CppChar*)reader.GetData(), reader.GetLength() / 2);
			writer.WriteCompressedInt32((int32_t)str.length());
			writer.WriteBytes((const uint8_t*)str.c_str(), (int32_t)str.length());
			break;
		}
		default:
		{
			RaiseExecutionEngineException("not supported const type");
		}
		}
		
		return retIndex;
	}
#endif

	void InterpreterImage::InitConsts()
	{
		const Table& tb = _rawImage->GetTable(TableType::CONSTANT);
		for (uint32_t i = 0; i < tb.rowNum; i++)
		{
			TbConstant data = _rawImage->ReadConstant(i + 1);
			TableType parentType = DecodeHasConstantType(data.parent);
			uint32_t rowIndex = DecodeHashConstantIndex(data.parent);

			Il2CppType tempType = {};
			tempType.type = (Il2CppTypeEnum)data.type;
			const Il2CppType& type = *MetadataPool::GetPooledIl2CppType(tempType);
			TypeIndex dataTypeIndex = AddIl2CppTypeCache(&type);
#if !HYBRIDCLR_UNITY_2021_OR_NEW
			bool isNullValue = type.type == IL2CPP_TYPE_CLASS;
#endif
			switch (parentType)
			{
			case TableType::FIELD:
			{
				FieldDetail& fd = _fieldDetails[rowIndex - 1];
				fd.defaultValueIndex = (uint32_t)_fieldDefaultValues.size();

				Il2CppFieldDefaultValue fdv = {};
				fdv.fieldIndex = rowIndex - 1;
				fdv.typeIndex = dataTypeIndex;
#if HYBRIDCLR_UNITY_2021_OR_NEW
				fdv.dataIndex = ConvertConstValue(_constValues, data.value, &type);
#else
				uint32_t dataImageOffset = _rawImage->GetImageOffsetOfBlob(type.type, data.value);
				fdv.dataIndex = isNullValue ? kDefaultValueIndexNull : (DefaultValueDataIndex)EncodeWithIndex(dataImageOffset);
#endif
				_fieldDefaultValues.push_back(fdv);
				break;
			}
			case TableType::PARAM:
			{
				int32_t actualIndex = (*_paramRawIndex2ActualParamIndex)[rowIndex - 1];
				ParamDetail& fd = _params[actualIndex];
				fd.defaultValueIndex = (uint32_t)_paramDefaultValues.size();

				Il2CppParameterDefaultValue pdv = {};
				pdv.typeIndex = dataTypeIndex;
				pdv.parameterIndex = fd.parameterIndex;
#if HYBRIDCLR_UNITY_2021_OR_NEW
				pdv.dataIndex = ConvertConstValue(_constValues, data.value, &type);
#else
				uint32_t dataImageOffset = _rawImage->GetImageOffsetOfBlob(type.type, data.value);
				pdv.dataIndex = isNullValue ? kDefaultValueIndexNull : (DefaultValueDataIndex)EncodeWithIndex(dataImageOffset);
#endif
				_paramDefaultValues.push_back(pdv);
				break;
			}
			case TableType::PROPERTY:
			{
				RaiseNotSupportedException("not support property const");
				break;
			}
			default:
			{
				RaiseExecutionEngineException("not support const TableType");
				break;
			}
			}
		}
	}

	void InterpreterImage::InitCustomAttributes()
	{
		const Table& tb = _rawImage->GetTable(TableType::CUSTOMATTRIBUTE);
		_tokenCustomAttributes.reserve(tb.rowNum);


		uint32_t threadStaticMethodToken = 0;
		Il2CppCustomAttributeTypeRange* curTypeRange = nullptr;
		for (uint32_t rowIndex = 1; rowIndex <= tb.rowNum; rowIndex++)
		{
			TbCustomAttribute data = _rawImage->ReadCustomAttribute(rowIndex);
			TableType parentType = DecodeHasCustomAttributeCodedIndexTableType(data.parent);
			uint32_t parentRowIndex = DecodeHasCustomAttributeCodedIndexRowIndex(data.parent);
			uint32_t token = EncodeToken(parentType, parentRowIndex);
			if (curTypeRange == nullptr || curTypeRange->token != token)
			{
				IL2CPP_ASSERT(_tokenCustomAttributes.find(token) == _tokenCustomAttributes.end());
				int32_t attributeStartIndex = EncodeWithIndex((int32_t)_customAttribues.size());
				int32_t handleIndex = (int32_t)_customAttributeHandles.size();
				_tokenCustomAttributes[token] = { (int32_t)EncodeWithIndex(handleIndex), false, nullptr, nullptr };
#ifdef HYBRIDCLR_UNITY_2021_OR_NEW
				_customAttributeHandles.push_back({ token, (uint32_t)attributeStartIndex });
#else
				_customAttributeHandles.push_back({ token, attributeStartIndex, 0 });
#endif
				curTypeRange = &_customAttributeHandles[handleIndex];
			}
#if !HYBRIDCLR_UNITY_2021_OR_NEW
			++curTypeRange->count;
#endif
			TableType ctorMethodTableType = DecodeCustomAttributeTypeCodedIndexTableType(data.type);
			uint32_t ctorMethodRowIndex = DecodeCustomAttributeTypeCodedIndexRowIndex(data.type);
			uint32_t ctorMethodToken = EncodeToken(ctorMethodTableType, ctorMethodRowIndex);
			//CustomAttribute ca = { ctorMethodToken, data.value };
			//ca.value = data.value;
			//ReadMethodRefInfoFromToken(nullptr, nullptr, , ca.attrCtorMethod);
			_customAttribues.push_back({ ctorMethodToken, data.value });

			if (parentType == TableType::FIELD)
			{
				// try set thread static flags
				if (threadStaticMethodToken == 0)
				{
					if (IsThreadStaticCtorToken(ctorMethodTableType, ctorMethodRowIndex))
					{
						threadStaticMethodToken = ctorMethodToken;
					}
				}
				if (ctorMethodToken == threadStaticMethodToken)
				{
					IL2CPP_ASSERT(threadStaticMethodToken != 0);
					_fieldDetails[parentRowIndex - 1].offset = THREAD_LOCAL_STATIC_MASK;
				}
			}

		}
		IL2CPP_ASSERT(_tokenCustomAttributes.size() == _customAttributeHandles.size());
#ifdef HYBRIDCLR_UNITY_2021_OR_NEW
		// add extra Il2CppCustomAttributeTypeRange for compute count
		_customAttributeHandles.push_back({ 0, EncodeWithIndex((int32_t)_customAttribues.size()) });
#endif
#if !HYBRIDCLR_UNITY_2022_OR_NEW
		_customAttribtesCaches.resize(_tokenCustomAttributes.size());
#endif
	}

#ifdef HYBRIDCLR_UNITY_2021_OR_NEW

	void InterpreterImage::InitCustomAttributeData(CustomAttributesInfo& cai, const Il2CppCustomAttributeTypeRange& dataRange)
	{
		il2cpp::os::FastAutoLock metaLock(&il2cpp::vm::g_MetadataLock);
		if (cai.inited)
		{
			return;
		}
		BuildCustomAttributesData(cai, dataRange);
		il2cpp::os::Atomic::FullMemoryBarrier();
		cai.inited = true;
	}

	void InterpreterImage::BuildCustomAttributesData(CustomAttributesInfo& cai, const Il2CppCustomAttributeTypeRange& curTypeRange)
	{
		hybridclr::interpreter::ExecutingInterpImageScope scope(hybridclr::interpreter::InterpreterModule::GetCurrentThreadMachineState(), this->_il2cppImage);
		_il2cppFormatCustomDataBlob.Reset();
		const Il2CppCustomAttributeDataRange& nextTypeRange = *(&curTypeRange + 1);
		uint32_t attrCount = nextTypeRange.startOffset - curTypeRange.startOffset;
		IL2CPP_ASSERT(attrCount > 0 && attrCount < 1024);
		_il2cppFormatCustomDataBlob.WriteAttributeCount(attrCount);
		int32_t attrStartOffset = DecodeMetadataIndex(curTypeRange.startOffset);
		int32_t methodIndexDataOffset = _il2cppFormatCustomDataBlob.Size();
		_il2cppFormatCustomDataBlob.Skip(attrCount * sizeof(int32_t));
		for (uint32_t i = 0; i < attrCount; i++)
		{
			const CustomAttribute& ca = _customAttribues[attrStartOffset + (int32_t)i];
			MethodRefInfo mri = {};
			ReadMethodRefInfoFromToken(nullptr, nullptr, DecodeTokenTableType(ca.ctorMethodToken), DecodeTokenRowIndex(ca.ctorMethodToken), mri);
			const MethodInfo* ctorMethod = GetMethodInfoFromMethodDef(mri.containerType, mri.methodDef);
			MethodIndex ctorIndex = il2cpp::vm::GlobalMetadata::GetMethodIndexFromDefinition(mri.methodDef);
			_il2cppFormatCustomDataBlob.WriteMethodIndex(methodIndexDataOffset, ctorIndex);
			methodIndexDataOffset += sizeof(int32_t);
			if (ca.value != 0)
			{
				BlobReader reader = _rawImage->GetBlobReaderByRawIndex(ca.value);
				ConvertILCustomAttributeData2Il2CppFormat(ctorMethod, reader);
			}
			else
			{
				IL2CPP_ASSERT(mri.methodDef->parameterCount == 0);
				_il2cppFormatCustomDataBlob.WriteCompressedUint32(0);
				_il2cppFormatCustomDataBlob.WriteCompressedUint32(0);
				_il2cppFormatCustomDataBlob.WriteCompressedUint32(0);
			}
		}
		void* resultData = HYBRIDCLR_MALLOC(_il2cppFormatCustomDataBlob.Size());
		std::memcpy(resultData, _il2cppFormatCustomDataBlob.Data(), _il2cppFormatCustomDataBlob.Size());
		cai.dataStartPtr = resultData;
		cai.dataEndPtr = (uint8_t*)resultData + _il2cppFormatCustomDataBlob.Size();
	}

	void InterpreterImage::WriteEncodeTypeEnum(CustomAttributeDataWriter& writer, const Il2CppType* type)
	{
		Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
		if (type->type == IL2CPP_TYPE_ENUM || klass->enumtype)
		{
			writer.WriteByte((byte)IL2CPP_TYPE_ENUM);
			int32_t typeIndex = type->type == IL2CPP_TYPE_CLASS || type->type == IL2CPP_TYPE_VALUETYPE ? ((Il2CppTypeDefinition*)type->data.typeHandle)->byvalTypeIndex : AddIl2CppTypeCache(type);
			writer.WriteCompressedInt32(typeIndex);
		}
		else if (klass == il2cpp_defaults.systemtype_class)
		{
			writer.WriteByte((byte)IL2CPP_TYPE_IL2CPP_TYPE_INDEX);
		}
		else
		{
			writer.WriteByte((uint8_t)type->type);
		}
	}

	void InterpreterImage::ConvertBoxedValue(CustomAttributeDataWriter& writer, BlobReader& reader, bool writeType)
	{
		uint64_t obj = 0;
		Il2CppType kind = {};
		ReadCustomAttributeFieldOrPropType(reader, kind);
		ConvertFixedArg(writer, reader, &kind, true);
	}

	void InterpreterImage::ConvertSystemType(CustomAttributeDataWriter& writer, BlobReader& reader, bool writeType)
	{
		if (writeType)
		{
			writer.WriteByte((byte)IL2CPP_TYPE_IL2CPP_TYPE_INDEX);
		}
		Il2CppString* fullName = ReadSerString(reader);
		if (!fullName)
		{
			writer.WriteCompressedInt32(-1);
			return;
		}
		Il2CppReflectionType* type = GetReflectionTypeFromName(fullName);
		if (!type)
		{
			std::string stdTypeName = il2cpp::utils::StringUtils::Utf16ToUtf8(fullName->chars);
			TEMP_FORMAT(errMsg, "CustomAttribute fixed arg type:System.Type fullName:'%s' not find", stdTypeName.c_str());
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException(errMsg));
		}
		Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type->type);
		if (!klass->generic_class && (Il2CppTypeDefinition*)klass->typeMetadataHandle)
		{
			writer.WriteCompressedInt32(((Il2CppTypeDefinition*)klass->typeMetadataHandle)->byvalTypeIndex);
		}
		else
		{
			writer.WriteCompressedInt32(AddIl2CppTypeCache(type->type));
		}
	}

	void InterpreterImage::ConvertFixedArg(CustomAttributeDataWriter& writer, BlobReader& reader, const Il2CppType* type, bool writeType)
	{
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			writer.Write(reader, 1);
			break;
		}
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			writer.Write(reader, 2);
			break;
		}
		case IL2CPP_TYPE_I4:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			writer.WriteCompressedInt32((int32_t)reader.Read32());
			break;
		}
		case IL2CPP_TYPE_U4:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			writer.WriteCompressedUint32(reader.Read32());
			break;
		}
		case IL2CPP_TYPE_R4:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			writer.Write(reader, 4);
			break;
		}
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			writer.Write(reader, 8);
			break;
		}
		case IL2CPP_TYPE_SZARRAY:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			int32_t numElem = (int32_t)reader.Read32();
			writer.WriteCompressedInt32(numElem);
			if (numElem != -1)
			{
				//Il2CppType kind = {};
				//ReadCustomAttributeFieldOrPropType(reader, kind);
				const Il2CppType* eleType = type->data.type;
				WriteEncodeTypeEnum(writer, eleType);
				if (eleType->type == IL2CPP_TYPE_OBJECT)
				{
					// kArrayTypeWithDifferentElements
					writer.WriteByte(1);
					for (uint16_t i = 0; i < numElem; i++)
					{
						ConvertBoxedValue(writer, reader, false);
					}
				}
				else
				{
					// all element type is same.
					writer.WriteByte(0);
					for (uint16_t i = 0; i < numElem; i++)
					{
						ConvertFixedArg(writer, reader, eleType, false);
					}
				}

			}
			break;
		}
		case IL2CPP_TYPE_STRING:
		{
			if (writeType)
			{
				writer.WriteByte((uint8_t)type->type);
			}
			byte b = reader.PeekByte();
			if (b == 0xFF)
			{
				reader.SkipByte();
				writer.WriteCompressedInt32(-1);
			}
			else if (b == 0)
			{
				reader.SkipByte();
				writer.WriteCompressedInt32(0);
			}
			else
			{
				const byte* beginDataPtr = reader.GetDataOfReadPosition();
				uint32_t len = reader.ReadCompressedUint32();
				writer.WriteCompressedInt32((int32_t)len);
				writer.WriteBytes(reader.GetDataOfReadPosition(), len);
				reader.SkipBytes(len);
			}
			break;
		}
		case IL2CPP_TYPE_OBJECT:
		{
			ConvertBoxedValue(writer, reader, writeType);
			break;
		}
		case IL2CPP_TYPE_CLASS:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			if (!klass)
			{
				RaiseExecutionEngineException("type not find");
			}
			if (klass == il2cpp_defaults.object_class)
			{
				ConvertBoxedValue(writer, reader, writeType);
			}
			else if (klass == il2cpp_defaults.systemtype_class)
			{
				ConvertSystemType(writer, reader, writeType);
			}
			else
			{
				TEMP_FORMAT(errMsg, "fixed arg type:%s.%s not support", klass->namespaze, klass->name);
				RaiseNotSupportedException(errMsg);
			}
			break;
		}
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			if (writeType)
			{
				writer.WriteByte((byte)IL2CPP_TYPE_ENUM);
				IL2CPP_ASSERT(klass->enumtype);
				int32_t typeIndex = klass->generic_class ? AddIl2CppTypeCache(type) : ((Il2CppTypeDefinition*)type->data.typeHandle)->byvalTypeIndex;
				writer.WriteCompressedInt32(typeIndex);
			}
			ConvertFixedArg(writer, reader, &klass->element_class->byval_arg, false);
			break;
		}
		case IL2CPP_TYPE_SYSTEM_TYPE:
		{
			ConvertSystemType(writer, reader, true);
			break;
		}
		case IL2CPP_TYPE_BOXED_OBJECT:
		{
			uint8_t fieldOrPropType = reader.ReadByte();
			IL2CPP_ASSERT(fieldOrPropType == 0x51);
			ConvertBoxedValue(writer, reader, writeType);
			break;
		}
		case IL2CPP_TYPE_ENUM:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			IL2CPP_ASSERT(klass->enumtype);
			if (writeType)
			{
				int32_t typeIndex = klass->generic_class ? AddIl2CppTypeCache(type) : ((Il2CppTypeDefinition*)type->data.typeHandle)->byvalTypeIndex;
				writer.WriteCompressedInt32(typeIndex);
			}
			ConvertFixedArg(writer, reader, &klass->element_class->byval_arg, false);
			break;
		}
		default:
		{
			RaiseExecutionEngineException("not support fixed argument type");
		}
		}
	}

	void InterpreterImage::GetFieldDeclaringTypeIndexAndFieldIndexByName(const Il2CppTypeDefinition* declaringType, const char* name, int32_t& typeIndex, int32_t& fieldIndex)
	{
		Il2CppClass* klass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle((Il2CppMetadataTypeHandle)declaringType);
		FieldInfo* field = il2cpp::vm::Class::GetFieldFromName(klass, name);
		if (!field)
		{
			RaiseExecutionEngineException("GetFieldDeclaringTypeIndexAndFieldIndexByName can't find field");
		}
		if (field->parent == klass)
		{
			typeIndex = kTypeDefinitionIndexInvalid;
		}
		else
		{
			klass = field->parent;
			if (klass->generic_class)
			{
				RaiseExecutionEngineException("GetFieldDeclaringTypeIndexAndFieldIndexByName doesn't support field of generic CustomAttribute");
			}
			typeIndex = il2cpp::vm::GlobalMetadata::GetIndexForTypeDefinition(klass);
		}
		fieldIndex = (int32_t)(field - klass->fields);
	}

	void InterpreterImage::GetPropertyDeclaringTypeIndexAndPropertyIndexByName(const Il2CppTypeDefinition* declaringType, const char* name, int32_t& typeIndex, int32_t& fieldIndex)
	{
		Il2CppClass* klass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle((Il2CppMetadataTypeHandle)declaringType);
		const PropertyInfo* propertyInfo = il2cpp::vm::Class::GetPropertyFromName(klass, name);
		if (!propertyInfo)
		{
			RaiseExecutionEngineException("GetFieldDeclaringTypeIndexAndFieldIndexByName can't find field");
		}
		if (propertyInfo->parent == klass)
		{
			typeIndex = kTypeDefinitionIndexInvalid;
		}
		else
		{
			klass = propertyInfo->parent;
			if (klass->generic_class)
			{
				RaiseExecutionEngineException("GetPropertyDeclaringTypeIndexAndPropertyIndexByName doesn't support field of generic CustomAttribute");
			}
			typeIndex = il2cpp::vm::GlobalMetadata::GetIndexForTypeDefinition(klass);
		}
#if UNITY_ENGINE_TUANJIE
		fieldIndex = -1;
		for (int32_t i = 0; i < klass->property_count; i++)
		{
			if (klass->properties[i] == propertyInfo)
			{
				fieldIndex = i;
				break;;
			}
		}
		IL2CPP_ASSERT(fieldIndex != -1);
#else
		fieldIndex = (int32_t)(propertyInfo - klass->properties);
#endif
	}

	void InterpreterImage::ConvertILCustomAttributeData2Il2CppFormat(const MethodInfo* ctorMethod, BlobReader& reader)
	{
		uint16_t prolog = reader.Read16();
		IL2CPP_ASSERT(prolog == 0x0001);
		IL2CPP_ASSERT(!ctorMethod->is_generic);

		_tempCtorArgBlob.Reset();
		for (uint16_t i = 0; i < ctorMethod->parameters_count; i++)
		{
			const Il2CppType* paramType = GET_METHOD_PARAMETER_TYPE(ctorMethod->parameters[i]);
			ConvertFixedArg(_tempCtorArgBlob, reader, paramType, true);
		}

		uint16_t numNamed = reader.Read16();

		uint32_t fieldCount = 0;
		uint32_t propertyCount = 0;
		_tempFieldBlob.Reset();
		_tempPropertyBlob.Reset();
		const Il2CppTypeDefinition* declaringType = GetUnderlyingTypeDefinition(&ctorMethod->klass->byval_arg);
		for (uint16_t idx = 0; idx < numNamed; idx++)
		{
			byte fieldOrPropTypeTag = reader.ReadByte();
			IL2CPP_ASSERT(fieldOrPropTypeTag == 0x53 || fieldOrPropTypeTag == 0x54);
			Il2CppType fieldOrPropType = {};
			ReadCustomAttributeFieldOrPropType(reader, fieldOrPropType);
			Il2CppString* fieldOrPropName = ReadSerString(reader);
			std::string stdStrName = il2cpp::utils::StringUtils::Utf16ToUtf8(fieldOrPropName->chars);
			const char* cstrName = stdStrName.c_str();
			int32_t fieldOrPropertyDeclaringTypeIndex = kTypeIndexInvalid;
			int32_t fieldOrPropertyIndex = 0;
			if (fieldOrPropTypeTag == 0x53)
			{
				++fieldCount;
				ConvertFixedArg(_tempFieldBlob, reader, &fieldOrPropType, true);
				GetFieldDeclaringTypeIndexAndFieldIndexByName(declaringType, cstrName, fieldOrPropertyDeclaringTypeIndex, fieldOrPropertyIndex);
				if (fieldOrPropertyDeclaringTypeIndex == kTypeDefinitionIndexInvalid)
				{
					_tempFieldBlob.WriteCompressedInt32(fieldOrPropertyIndex);
				}
				else
				{
					_tempFieldBlob.WriteCompressedInt32(-fieldOrPropertyIndex - 1);
					_tempFieldBlob.WriteCompressedUint32(fieldOrPropertyDeclaringTypeIndex);
				}
			}
			else
			{
				++propertyCount;
				ConvertFixedArg(_tempPropertyBlob, reader, &fieldOrPropType, true);
				GetPropertyDeclaringTypeIndexAndPropertyIndexByName(declaringType, cstrName, fieldOrPropertyDeclaringTypeIndex, fieldOrPropertyIndex);
				if (fieldOrPropertyDeclaringTypeIndex == kTypeDefinitionIndexInvalid)
				{
					_tempPropertyBlob.WriteCompressedInt32(fieldOrPropertyIndex);
				}
				else
				{
					_tempPropertyBlob.WriteCompressedInt32(-fieldOrPropertyIndex - 1);
					_tempPropertyBlob.WriteCompressedUint32(fieldOrPropertyDeclaringTypeIndex);
				}
			}
		}
		_il2cppFormatCustomDataBlob.WriteCompressedUint32(ctorMethod->parameters_count);
		_il2cppFormatCustomDataBlob.WriteCompressedUint32(fieldCount);
		_il2cppFormatCustomDataBlob.WriteCompressedUint32(propertyCount);
		_il2cppFormatCustomDataBlob.Write(_tempCtorArgBlob);
		_il2cppFormatCustomDataBlob.Write(_tempFieldBlob);
		_il2cppFormatCustomDataBlob.Write(_tempPropertyBlob);
	}
#endif

#if !HYBRIDCLR_UNITY_2021_OR_NEW

	void InterpreterImage::ConstructCustomAttribute(BlobReader& reader, Il2CppObject* obj, const MethodInfo* ctorMethod)
	{
		uint16_t prolog = reader.Read16();
		IL2CPP_ASSERT(prolog == 0x0001);
		if (ctorMethod->parameters_count == 0)
		{
			il2cpp::vm::Runtime::Invoke(ctorMethod, obj, nullptr, nullptr);
		}
		else
		{
			int32_t argSize = sizeof(uint64_t) * ctorMethod->parameters_count;
			uint64_t* argDatas = (uint64_t*)alloca(argSize);
			std::memset(argDatas, 0, argSize);
			void** argPtrs = (void**)alloca(sizeof(void*) * ctorMethod->parameters_count); // same with argDatas
			for (uint8_t i = 0; i < ctorMethod->parameters_count; i++)
			{
				argPtrs[i] = argDatas + i;
				const Il2CppType* paramType = GET_METHOD_PARAMETER_TYPE(ctorMethod->parameters[i]);
				ReadFixedArg(reader, paramType, argDatas + i);
				Il2CppClass* paramKlass = il2cpp::vm::Class::FromIl2CppType(paramType);
				if (!IS_CLASS_VALUE_TYPE(paramKlass))
				{
					argPtrs[i] = (void*)argDatas[i];
				}
			}
			il2cpp::vm::Runtime::Invoke(ctorMethod, obj, argPtrs, nullptr);
			// clear ref. may not need. gc memory barrier
			std::memset(argDatas, 0, argSize);
		}
		uint16_t numNamed = reader.Read16();
		Il2CppClass* klass = obj->klass;
		for (uint16_t idx = 0; idx < numNamed; idx++)
		{
			byte fieldOrPropTypeTag = reader.ReadByte();
			IL2CPP_ASSERT(fieldOrPropTypeTag == 0x53 || fieldOrPropTypeTag == 0x54);
			Il2CppType fieldOrPropType = {};
			ReadCustomAttributeFieldOrPropType(reader, fieldOrPropType);
			Il2CppString* fieldOrPropName = ReadSerString(reader);
			std::string stdStrName = il2cpp::utils::StringUtils::Utf16ToUtf8(fieldOrPropName->chars);
			const char* cstrName = stdStrName.c_str();
			uint64_t value = 0;
			ReadFixedArg(reader, &fieldOrPropType, &value);
			if (fieldOrPropTypeTag == 0x53)
			{
				FieldInfo* field = il2cpp::vm::Class::GetFieldFromName(klass, cstrName);
				if (!field)
				{
					TEMP_FORMAT(errMsg, "CustomAttribute field missing. klass:%s.%s field:%s", klass->namespaze, klass->name, cstrName);
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeInitializationException(errMsg, nullptr));
				}
				IL2CPP_ASSERT(IsTypeEqual(&fieldOrPropType, field->type));
				il2cpp::vm::Field::SetValue(obj, field, &value);
			}
			else
			{
				const PropertyInfo* prop = il2cpp::vm::Class::GetPropertyFromName(klass, cstrName);
				if (!prop)
				{
					TEMP_FORMAT(errMsg, "CustomAttribute property missing. klass:%s property:%s", klass->name, cstrName);
					il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeInitializationException(errMsg, nullptr));
				}
				IL2CPP_ASSERT(IsTypeEqual(&fieldOrPropType, GET_METHOD_PARAMETER_TYPE(prop->set->parameters[0])));
				Il2CppException* ex = nullptr;
				Il2CppClass* propKlass = il2cpp::vm::Class::FromIl2CppType(&fieldOrPropType);
				IL2CPP_ASSERT(propKlass);
				void* args[] = { (IS_CLASS_VALUE_TYPE(propKlass) ? &value : (void*)value) };
				il2cpp::vm::Runtime::Invoke(prop->set, obj, args, &ex);
				if (ex)
				{
					il2cpp::vm::Exception::Raise(ex);
				}
			}
		}
	}

	CustomAttributesCache* InterpreterImage::GenerateCustomAttributesCacheInternal(CustomAttributeIndex index)
	{
		IL2CPP_ASSERT(index != kCustomAttributeIndexInvalid);
		IL2CPP_ASSERT(index < (CustomAttributeIndex)_customAttributeHandles.size());
		CustomAttributesCache* cache = _customAttribtesCaches[index];
		if (cache)
		{
			return cache;
		}

		Il2CppCustomAttributeTypeRange& typeRange = _customAttributeHandles[index];

		hybridclr::interpreter::ExecutingInterpImageScope scope(hybridclr::interpreter::InterpreterModule::GetCurrentThreadMachineState(), this->_il2cppImage);

		cache = (CustomAttributesCache*)IL2CPP_CALLOC(1, sizeof(CustomAttributesCache));
		int32_t count= (int32_t)typeRange.count;
		cache->count = count;
		cache->attributes = (Il2CppObject**)il2cpp::gc::GarbageCollector::AllocateFixed(sizeof(Il2CppObject*) * count, 0);

		int32_t start = DecodeMetadataIndex(GET_CUSTOM_ATTRIBUTE_TYPE_RANGE_START(typeRange));
		for (int32_t i = 0; i < count; i++)
		{
			int32_t attrIndex = start + i;
			IL2CPP_ASSERT(attrIndex >= 0 && attrIndex < (int32_t)_customAttribues.size());
			CustomAttribute& ca = _customAttribues[attrIndex];
			MethodRefInfo mri = {};
			ReadMethodRefInfoFromToken(nullptr, nullptr, DecodeTokenTableType(ca.ctorMethodToken), DecodeTokenRowIndex(ca.ctorMethodToken), mri);
			const MethodInfo* ctorMethod = GetMethodInfoFromMethodDef(mri.containerType, mri.methodDef);
			IL2CPP_ASSERT(ctorMethod);
			Il2CppClass* klass = ctorMethod->klass;
			Il2CppObject* attr = il2cpp::vm::Object::New(klass);
			Il2CppArray* paramArr = nullptr;
			if (ca.value != 0)
			{
				BlobReader reader = _rawImage->GetBlobReaderByRawIndex(ca.value);
				ConstructCustomAttribute(reader, attr, ctorMethod);
			}
			else
			{
				IL2CPP_ASSERT(ctorMethod->parameters_count == 0);
				il2cpp::vm::Runtime::Invoke(ctorMethod, attr, nullptr, nullptr);
			}

			cache->attributes[i] = attr;
			HYBRIDCLR_SET_WRITE_BARRIER((void**)cache->attributes + i);
		}

		il2cpp::os::FastAutoLock metaLock(&il2cpp::vm::g_MetadataLock);
		CustomAttributesCache* original = _customAttribtesCaches[index];
		if (original)
		{
			// A non-NULL return value indicates some other thread already generated this cache.
			// We need to cleanup the resources we allocated
			il2cpp::gc::GarbageCollector::FreeFixed(cache->attributes);
			HYBRIDCLR_FREE(cache);
			return original;
		}
		il2cpp::os::Atomic::FullMemoryBarrier();
		_customAttribtesCaches[index] = cache;
		return cache;
	}
#elif HYBRIDCLR_UNITY_2021
	CustomAttributesCache* InterpreterImage::GenerateCustomAttributesCacheInternal(CustomAttributeIndex index)
	{
		IL2CPP_ASSERT(index != kCustomAttributeIndexInvalid);
		IL2CPP_ASSERT(index < (CustomAttributeIndex)_customAttributeHandles.size());
		CustomAttributesCache* cache = _customAttribtesCaches[index];
		if (cache)
		{
			return cache;
		}

		hybridclr::interpreter::ExecutingInterpImageScope scope(hybridclr::interpreter::InterpreterModule::GetCurrentThreadMachineState(), this->_il2cppImage);

		Il2CppCustomAttributeTypeRange& typeRange = _customAttributeHandles[index];
		void* start;
		void* end;
		std::tie(start, end) = CreateCustomAttributeDataTuple(&typeRange);
		IL2CPP_ASSERT(start && end);

		il2cpp::metadata::CustomAttributeDataReader reader(start, end);

		cache = (CustomAttributesCache*)IL2CPP_CALLOC(1, sizeof(CustomAttributesCache));
		cache->count = (int)reader.GetCount();
		cache->attributes = (Il2CppObject**)il2cpp::gc::GarbageCollector::AllocateFixed(sizeof(Il2CppObject*) * cache->count, 0);

		il2cpp::metadata::CustomAttributeDataIterator iter = reader.GetDataIterator();
		for (int i = 0; i < cache->count; i++)
		{
			Il2CppException* exc = NULL;
			il2cpp::metadata::CustomAttributeCreator creator;
			if (reader.VisitCustomAttributeData(_il2cppImage, &iter, &creator, &exc))
			{
				cache->attributes[i] = creator.GetAttribute(&exc);
				HYBRIDCLR_SET_WRITE_BARRIER((void**)&cache->attributes[i]);
			}

			if (exc != NULL)
			{
				il2cpp::gc::GarbageCollector::FreeFixed(cache->attributes);
				HYBRIDCLR_FREE(cache);
				il2cpp::vm::Exception::Raise(exc);
			}
		}


		il2cpp::os::FastAutoLock metaLock(&il2cpp::vm::g_MetadataLock);
		CustomAttributesCache* original = _customAttribtesCaches[index];
		if (original)
		{
			// A non-NULL return value indicates some other thread already generated this cache.
			// We need to cleanup the resources we allocated
			il2cpp::gc::GarbageCollector::FreeFixed(cache->attributes);
			HYBRIDCLR_FREE(cache);
			return original;
		}
		il2cpp::os::Atomic::FullMemoryBarrier();
		_customAttribtesCaches[index] = cache;
		return cache;
	}
#endif

	void InterpreterImage::InitModuleRefs()
	{
		const Table& moduleRefTb = _rawImage->GetTable(TableType::MODULEREF);
		_moduleRefs.reserve(moduleRefTb.rowNum);
		for (uint32_t rid = 1; rid <= moduleRefTb.rowNum; rid++)
		{
			TbModuleRef moduleRef = _rawImage->ReadModuleRef(rid);
			const char* moduleName = _rawImage->GetStringFromRawIndex(moduleRef.name);
			_moduleRefs.push_back(moduleName);
		}
	}

	void InterpreterImage::InitImplMaps()
	{
		const Table& implMapTb = _rawImage->GetTable(TableType::IMPLMAP);
		_implMapInfos.reserve(implMapTb.rowNum);
		for (uint32_t rid = 1; rid <= implMapTb.rowNum; rid++)
		{
			TbImplMap implMap = _rawImage->ReadImplMap(rid);
			ImplMapInfo info = {};
			info.moduleName = _moduleRefs[DecodeTokenRowIndex(implMap.importScope) - 1];
			info.importName = _rawImage->GetStringFromRawIndex(implMap.importName);
			info.mappingFlags = implMap.mappingFlags;
			uint32_t memberForwardedToken = hybridclr::metadata::ConvertMemberForwardedToken2Token(implMap.memberForwarded);
			_implMapInfos.insert({ memberForwardedToken, info });
		}
	}

	void InterpreterImage::InitMethodDefs0()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		const Table& methodTb = _rawImage->GetTable(TableType::METHOD);

		_methodDefines.resize(methodTb.rowNum);
		for (Il2CppMethodDefinition& md : _methodDefines)
		{
			md.genericContainerIndex = kGenericContainerIndexInvalid;
		}
	}

	void InterpreterImage::InitMethodDefs()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		const Table& methodTb = _rawImage->GetTable(TableType::METHOD);

		for (uint32_t i = 0, n = typeDefTb.rowNum; i < n; i++)
		{
			Il2CppTypeDefinition& typeDef = _typesDefines[i];
			uint32_t rawMethodStart = DecodeMetadataIndex(typeDef.methodStart);

			for (int m = 0; m < typeDef.method_count; m++)
			{
				Il2CppMethodDefinition& md = _methodDefines[rawMethodStart + m];
				md.declaringType = EncodeWithIndex(i);
			}
		}

		int32_t paramTableRowNum = _rawImage->GetTable(TableType::PARAM).rowNum;
		for (uint32_t index = 0; index < methodTb.rowNum; index++)
		{
			Il2CppMethodDefinition& md = _methodDefines[index];
			uint32_t rowIndex = index + 1;
			TbMethod methodData = _rawImage->ReadMethod(rowIndex);

			md.nameIndex = EncodeWithIndex(methodData.name);
			md.parameterStart = methodData.paramList - 1;
			//md.genericContainerIndex = kGenericContainerIndexInvalid;
			md.token = EncodeToken(TableType::METHOD, rowIndex);
			md.flags = methodData.flags;
			md.iflags = methodData.implFlags;
			md.slot = kInvalidIl2CppMethodSlot;
			if (index > 0)
			{
				auto& last = _methodDefines[index - 1];
				last.parameterCount = md.parameterStart - last.parameterStart;
			}
			if (index == methodTb.rowNum - 1)
			{
				md.parameterCount = (int)paramTableRowNum - (int32_t)md.parameterStart;
			}

			//MethodBody& body = _methodBodies[index];
			//ReadMethodBody(md, methodData, body);
		}

		for (uint32_t i = 0, n = typeDefTb.rowNum; i < n; i++)
		{
			Il2CppTypeDefinition& typeDef = _typesDefines[i];
			uint32_t rawMethodStart = DecodeMetadataIndex(typeDef.methodStart);
			bool isInterface = IsInterface(typeDef.flags);
			uint16_t slotIdx = 0;
			for (int m = 0; m < typeDef.method_count; m++)
			{
				Il2CppMethodDefinition& md = _methodDefines[rawMethodStart + m];
				const char* methodName = _rawImage->GetStringFromRawIndex(DecodeMetadataIndex(md.nameIndex));
				if (!std::strcmp(methodName, ".cctor"))
				{
					typeDef.bitfield |= (1 << (il2cpp::vm::kBitHasStaticConstructor - 1));
				}
				if (!std::strcmp(methodName, "Finalize"))
				{
					typeDef.bitfield |= (1 << (il2cpp::vm::kBitHasFinalizer - 1));
				}
				if (isInterface && IsInstanceMethod(&md) && IsVirtualMethod(md.flags))
				{
					md.slot = slotIdx++;
				}
				// TODO 可以考虑优化一下,将 signature在前一步存到暂时不用的 returnType里
				TbMethod methodData = _rawImage->ReadMethod(rawMethodStart + m + 1);

				BlobReader methodSigReader = _rawImage->GetBlobReaderByRawIndex(methodData.signature);
				uint32_t namedParamStart = md.parameterStart;
				uint32_t namedParamCount = md.parameterCount;

				uint32_t actualParamStart = (uint32_t)_params.size();
				ReadMethodDefSig(
					methodSigReader,
					GetGenericContainerByTypeDefinition(&typeDef),
					GetGenericContainerByRawIndex(DecodeMetadataIndex(md.genericContainerIndex)),
					md,
					_params);
				uint32_t actualParamCount = (uint32_t)_params.size() - actualParamStart;
				md.parameterStart = actualParamStart;
				md.parameterCount = actualParamCount;
				if (md.parameterCount >= 256)
				{
					TEMP_FORMAT(errMsg, "method:%s.%s parameter count:%d is too large", _rawImage->GetStringFromRawIndex(DecodeMetadataIndex(typeDef.nameIndex)), methodName, md.parameterCount);
                    RaiseExecutionEngineException(errMsg);
				}
				for (uint32_t paramRowIndex = namedParamStart + 1; paramRowIndex <= namedParamStart + namedParamCount; paramRowIndex++)
				{
					TbParam data = _rawImage->ReadParam(paramRowIndex);
					if (data.sequence > 0)
					{
						int32_t actualParamIndex = actualParamStart + data.sequence - 1;
						ParamDetail& paramDetail = _params[actualParamIndex];
						Il2CppParameterDefinition& pd = paramDetail.paramDef;
						IL2CPP_ASSERT(paramDetail.parameterIndex == data.sequence - 1);
						pd.nameIndex = EncodeWithIndex(data.name);
						pd.token = EncodeToken(TableType::PARAM, paramRowIndex);
						(*_paramRawIndex2ActualParamIndex)[paramRowIndex - 1] = actualParamIndex;
						if (data.flags)
						{
							const Il2CppType* fieldType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(pd.typeIndex);
							Il2CppType* newType = MetadataPool::ShallowCloneIl2CppType(fieldType);
							newType->attrs = data.flags;
							//paramDetail.type = newType;
							pd.typeIndex = AddIl2CppTypeCache(newType);
						}
					}
					else
					{
						// data.sequence == 0  is for returnType.
						// used for parent of CustomeAttributes of ReturnType
						// il2cpp not support ReturnType CustomAttributes. so we just ignore it.
#if SUPPORT_METHOD_RETURN_TYPE_CUSTOM_ATTRIBUTE
						md.returnParameterToken = EncodeToken(TableType::PARAM, paramRowIndex);
#endif
					}
				}
			}
		}
	}

	const il2cpp::utils::dynamic_array<MethodImpl> InterpreterImage::GetTypeMethodImplByTypeDefinition(const Il2CppTypeDefinition* typeDef)
	{
		uint32_t index = (uint32_t)(typeDef - &_typesDefines[0]);
		IL2CPP_ASSERT(index < (uint32_t)_typeDetails.size());
		TypeDefinitionDetail& tdd = _typeDetails[index];
		il2cpp::utils::dynamic_array<MethodImpl> methodImpls(tdd.methodImplCount);

		for (uint32_t i = 0; i < tdd.methodImplCount; i++)
		{
			uint32_t index = tdd.methodImplStart + i;
			TbMethodImpl data = _rawImage->ReadMethodImpl(index + 1);
			Il2CppTypeDefinition& typeDef = _typesDefines[data.classIdx - 1];
			Il2CppGenericContainer* gc = GetGenericContainerByTypeDefinition(&typeDef);
			MethodImpl& impl = methodImpls[i];
			ReadMethodRefInfoFromToken(gc, nullptr, DecodeMethodDefOrRefCodedIndexTableType(data.methodBody), DecodeMethodDefOrRefCodedIndexRowIndex(data.methodBody), impl.body);
			ReadMethodRefInfoFromToken(gc, nullptr, DecodeMethodDefOrRefCodedIndexTableType(data.methodDeclaration), DecodeMethodDefOrRefCodedIndexRowIndex(data.methodDeclaration), impl.declaration);
		}
		return methodImpls;
	}

	void InterpreterImage::InitMethodImpls0()
	{
		const Table& miTb = _rawImage->GetTable(TableType::METHODIMPL);
		for (uint32_t i = 0; i < miTb.rowNum; i++)
		{
			TbMethodImpl data = _rawImage->ReadMethodImpl(i + 1);
			uint32_t typeIndex = data.classIdx - 1;
			TypeDefinitionDetail& tdd = _typeDetails[typeIndex];
			Il2CppTypeDefinition& typeDef = _typesDefines[typeIndex];
			Il2CppGenericContainer* gc = GetGenericContainerByTypeDefinition(&typeDef);
			if (tdd.methodImplCount == 0)
			{
				tdd.methodImplStart = i;
			}
			++tdd.methodImplCount;
			//MethodImpl impl;
			//ReadMethodRefInfoFromToken(gc, nullptr, DecodeMethodDefOrRefCodedIndexTableType(data.methodBody), DecodeMethodDefOrRefCodedIndexRowIndex(data.methodBody), impl.body);
			//ReadMethodRefInfoFromToken(gc, nullptr, DecodeMethodDefOrRefCodedIndexTableType(data.methodDeclaration), DecodeMethodDefOrRefCodedIndexRowIndex(data.methodDeclaration), impl.declaration);
			//tdd.methodImpls.push_back(impl);
		}
	}

	void InterpreterImage::InitProperties()
	{
		const Table& propertyMapTb = _rawImage->GetTable(TableType::PROPERTYMAP);
		const Table& propertyTb = _rawImage->GetTable(TableType::PROPERTY);
		_propeties.reserve(propertyTb.rowNum);

		for (uint32_t rowIndex = 1; rowIndex <= propertyTb.rowNum; rowIndex++)
		{
			TbProperty data = _rawImage->ReadProperty(rowIndex);
			_propeties.push_back({ _rawImage->GetStringFromRawIndex(data.name), data.flags, data.type, 0, 0
				, nullptr
				, { (StringIndex)EncodeWithIndex(data.name), kMethodIndexInvalid, kMethodIndexInvalid, (uint32_t)data.flags, EncodeToken(TableType::PROPERTY, rowIndex)}
				});
		}

		Il2CppTypeDefinition* last = nullptr;
		for (uint32_t rowIndex = 1; rowIndex <= propertyMapTb.rowNum; rowIndex++)
		{
			TbPropertyMap data = _rawImage->ReadPropertyMap(rowIndex);
			Il2CppTypeDefinition* typeDef = &_typesDefines[data.parent - 1];
			typeDef->propertyStart = EncodeWithIndex(data.propertyList); // start from 1
			if (last != nullptr)
			{
				last->property_count = data.propertyList - DecodeMetadataIndex(last->propertyStart);
			}
			last = typeDef;
		}
		if (last)
		{
			last->property_count = propertyTb.rowNum - DecodeMetadataIndex(last->propertyStart) + 1;
		}
#if HYBRIDCLR_UNITY_2019
		for (const Il2CppTypeDefinition& typeDef : _typesDefines)
		{
			if (typeDef.property_count == 0)
			{
				continue;
			}
			for (int32_t start = DecodeMetadataIndex(typeDef.propertyStart), i = 0; i < typeDef.property_count; i++)
			{
				_propeties[start + i - 1].declaringType = &typeDef;
			}
		}
#endif
	}

	void InterpreterImage::InitEvents()
	{
		const Table& eventMapTb = _rawImage->GetTable(TableType::EVENTMAP);
		const Table& eventTb = _rawImage->GetTable(TableType::EVENT);
		_events.reserve(eventTb.rowNum);

		for (uint32_t rowIndex = 1; rowIndex <= eventTb.rowNum; rowIndex++)
		{
			TbEvent data = _rawImage->ReadEvent(rowIndex);
			_events.push_back({ _rawImage->GetStringFromRawIndex(data.name), data.eventFlags, data.eventType, 0, 0, 0
#if HYBRIDCLR_UNITY_2019
				, nullptr
				, { (StringIndex)EncodeWithIndex(data.name), kTypeIndexInvalid, kMethodIndexInvalid, kMethodIndexInvalid, kMethodIndexInvalid, EncodeToken(TableType::EVENT, rowIndex)}
#endif
				});
		}

		Il2CppTypeDefinition* last = nullptr;
		for (uint32_t rowIndex = 1; rowIndex <= eventMapTb.rowNum; rowIndex++)
		{
			TbEventMap data = _rawImage->ReadEventMap(rowIndex);
			Il2CppTypeDefinition* typeDef = &_typesDefines[data.parent - 1];
			typeDef->eventStart = EncodeWithIndex(data.eventList); // start from 1
			if (last != nullptr)
			{
				last->event_count = data.eventList - DecodeMetadataIndex(last->eventStart);
			}
			last = typeDef;
		}
		if (last)
		{
			last->event_count = eventTb.rowNum - DecodeMetadataIndex(last->eventStart) + 1;
		}
#if HYBRIDCLR_UNITY_2019
		for (const Il2CppTypeDefinition& typeDef : _typesDefines)
		{
			if (typeDef.event_count == 0)
			{
				continue;
			}
			for (int32_t start = DecodeMetadataIndex(typeDef.eventStart), i = 0; i < typeDef.event_count; i++)
			{
				EventDetail& ed = _events[start + i - 1];
				ed.declaringType = &typeDef;
				ed.il2cppDefinition.typeIndex = typeDef.byvalTypeIndex;
			}
		}
#endif
	}


	void InterpreterImage::InitMethodSemantics()
	{
		const Table& msTb = _rawImage->GetTable(TableType::METHODSEMANTICS);
		for (uint32_t rowIndex = 1; rowIndex <= msTb.rowNum; rowIndex++)
		{
			TbMethodSemantics data = _rawImage->ReadMethodSemantics(rowIndex);
			uint32_t method = data.method;
			uint16_t semantics = data.semantics;
			TableType tableType = DecodeHasSemanticsCodedIndexTableType(data.association);
			uint32_t propertyOrEventIndex = DecodeHasSemanticsCodedIndexRowIndex(data.association) - 1;
			if (semantics & (uint16_t)MethodSemanticsAttributes::Getter)
			{
				IL2CPP_ASSERT(tableType == TableType::PROPERTY);
				PropertyDetail& pd = _propeties[propertyOrEventIndex];
				pd.getterMethodIndex = method;
#if HYBRIDCLR_UNITY_2019
				pd.il2cppDefinition.get = method - DecodeMetadataIndex(pd.declaringType->methodStart) - 1;
#endif
			}
			if (semantics & (uint16_t)MethodSemanticsAttributes::Setter)
			{
				IL2CPP_ASSERT(tableType == TableType::PROPERTY);
				PropertyDetail& pd = _propeties[propertyOrEventIndex];
				pd.setterMethodIndex = method;
#if HYBRIDCLR_UNITY_2019
				pd.il2cppDefinition.set = method - DecodeMetadataIndex(pd.declaringType->methodStart) - 1;
#endif
			}
			if (semantics & (uint16_t)MethodSemanticsAttributes::AddOn)
			{
				IL2CPP_ASSERT(tableType == TableType::EVENT);
				EventDetail& ed = _events[propertyOrEventIndex];
				ed.addMethodIndex = method;
#if HYBRIDCLR_UNITY_2019
				ed.il2cppDefinition.add = method - DecodeMetadataIndex(ed.declaringType->methodStart) - 1;
#endif
			}
			if (semantics & (uint16_t)MethodSemanticsAttributes::RemoveOn)
			{
				IL2CPP_ASSERT(tableType == TableType::EVENT);
				EventDetail& ed = _events[propertyOrEventIndex];
				ed.removeMethodIndex = method;
#if HYBRIDCLR_UNITY_2019
				ed.il2cppDefinition.remove = method - DecodeMetadataIndex(ed.declaringType->methodStart) - 1;
#endif
			}
			if (semantics & (uint16_t)MethodSemanticsAttributes::Fire)
			{
				IL2CPP_ASSERT(tableType == TableType::EVENT);
				EventDetail& ed = _events[propertyOrEventIndex];
				ed.fireMethodIndex = method;
#if HYBRIDCLR_UNITY_2019
				ed.il2cppDefinition.raise = method - DecodeMetadataIndex(ed.declaringType->methodStart) - 1;
#endif
			}
		}
	}

	struct EnclosingClassInfo
	{
		uint32_t enclosingTypeIndex; // rowIndex - 1
		std::vector<uint32_t> nestedTypeIndexs;
	};

	void InterpreterImage::InitNestedClass()
	{
		const Table& nestedClassTb = _rawImage->GetTable(TableType::NESTEDCLASS);
		_nestedTypeDefineIndexs.reserve(nestedClassTb.rowNum);
		std::vector<EnclosingClassInfo> enclosingTypes;

		for (uint32_t i = 0; i < nestedClassTb.rowNum; i++)
		{
			TbNestedClass data = _rawImage->ReadNestedClass(i + 1);
			Il2CppTypeDefinition& nestedType = _typesDefines[data.nestedClass - 1];
			Il2CppTypeDefinition& enclosingType = _typesDefines[data.enclosingClass - 1];
			if (enclosingType.nested_type_count == 0)
			{
				// 此行代码不能删，用于标识 enclosingTypes的index
				enclosingType.nestedTypesStart = (uint32_t)enclosingTypes.size();
				enclosingTypes.push_back({ data.enclosingClass - 1 });
			}
			++enclosingType.nested_type_count;
			enclosingTypes[enclosingType.nestedTypesStart].nestedTypeIndexs.push_back(data.nestedClass - 1);
			//_nestedTypeDefineIndexs.push_back(data.nestedClass - 1);
			nestedType.declaringTypeIndex = enclosingType.byvalTypeIndex;
		}

		for (auto& enclosingType : enclosingTypes)
		{
			Il2CppTypeDefinition& enclosingTypeDef = _typesDefines[enclosingType.enclosingTypeIndex];
			IL2CPP_ASSERT(enclosingType.nestedTypeIndexs.size() == (size_t)enclosingTypeDef.nested_type_count);
			enclosingTypeDef.nestedTypesStart = (NestedTypeIndex)_nestedTypeDefineIndexs.size();
			enclosingTypeDef.nested_type_count = (uint16_t)enclosingType.nestedTypeIndexs.size();
			_nestedTypeDefineIndexs.insert(_nestedTypeDefineIndexs.end(), enclosingType.nestedTypeIndexs.begin(), enclosingType.nestedTypeIndexs.end());
		}
	}

	void InterpreterImage::InitClassLayouts0()
	{
		const Table& classLayoutTb = _rawImage->GetTable(TableType::CLASSLAYOUT);
		for (uint32_t i = 0; i < classLayoutTb.rowNum; i++)
		{
			TbClassLayout data = _rawImage->ReadClassLayout(i + 1);
			_classLayouts[data.parent - 1] = data;
			if (data.classSize > 0)
			{
				Il2CppTypeDefinitionSizes& typeSizes = _typeDetails[data.parent - 1].typeSizes;
				typeSizes.instance_size = data.classSize + sizeof(Il2CppObject);
			}
		}
	}

	void InterpreterImage::InitClassLayouts()
	{
		ClassFieldLayoutCalculator calculator(this);
		for (Il2CppTypeDefinition& type : _typesDefines)
		{
			const Il2CppType* il2cppType = GetIl2CppTypeFromTypeDefinition(&type);
			calculator.CalcClassNotStaticFields(il2cppType);
		}

		for (TypeDefinitionDetail& type : _typeDetails)
		{
			const Il2CppTypeDefinition* typeDef = GetTypeDefinitionByTypeDetail(&type);
			const Il2CppType* il2cppType = GetIl2CppTypeFromTypeDefinition(typeDef);
			calculator.CalcClassStaticFields(il2cppType);
			ClassLayoutInfo* layout = calculator.GetClassLayoutInfo(il2cppType);

			auto& sizes = type.typeSizes;
			sizes.native_size = layout->nativeSize;
			if (typeDef->genericContainerIndex == kGenericContainerIndexInvalid)
			{
				sizes.static_fields_size = layout->staticFieldsSize;
				sizes.thread_static_fields_size = layout->threadStaticFieldsSize;
			}
			else
			{
				sizes.static_fields_size = 0;
				sizes.thread_static_fields_size = 0;
			}
			if (sizes.instance_size == 0)
			{
				sizes.instance_size = layout->instanceSize;
			}
			int32_t fieldStart = DecodeMetadataIndex(typeDef->fieldStart);
			for (int32_t i = 0, end = typeDef->field_count; i < end ; i++)
			{
				FieldDetail& fd = _fieldDetails[fieldStart + i];
				FieldLayout& fieldLayout = layout->fields[i];
				if (fd.offset == 0)
				{
					fd.offset = fieldLayout.offset;
				}
				else if (fd.offset == THREAD_LOCAL_STATIC_MASK)
				{
					fd.offset = fieldLayout.offset;
				}
				else
				{
					IL2CPP_ASSERT(fd.offset == fieldLayout.offset);
					int a = 0;
				}
			}
		}
	}

	uint32_t InterpreterImage::AddIl2CppTypeCache(const Il2CppType* type)
	{
		auto it = _type2Indexs.find(type);
		if (it != _type2Indexs.end())
		{
			return it->second;
		}
		uint32_t encodeIndex = EncodeWithIndex((uint32_t)_types.size());
		_types.push_back(type);
		_type2Indexs.insert({ type, encodeIndex });
		return encodeIndex;
	}

	uint32_t InterpreterImage::AddIl2CppGenericContainers(Il2CppGenericContainer& geneContainer)
	{
		uint32_t index = (uint32_t)_genericContainers.size();
		_genericContainers.push_back(geneContainer);
		return EncodeWithIndex(index);
	}

	void InterpreterImage::InitClass()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		_classList.resize(typeDefTb.rowNum);
	}

	Il2CppClass* InterpreterImage::GetTypeInfoFromTypeDefinitionRawIndex(uint32_t index)
	{
		IL2CPP_ASSERT(index < _classList.size());
		Il2CppClass* klass = _classList[index];
		if (klass)
		{
			return klass;
		}
		il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);
		klass = _classList[index];
		if (klass)
		{
			return klass;
		}
		klass = il2cpp::vm::GlobalMetadata::FromTypeDefinition(EncodeWithIndex(index));
		IL2CPP_ASSERT(klass->interfaces_count <= klass->interface_offsets_count || _typesDefines[index].interfaceOffsetsStart == 0);
		il2cpp::os::Atomic::FullMemoryBarrier();
		_classList[index] = klass;
		return klass;
	}

	const Il2CppType* InterpreterImage::GetInterfaceFromGlobalOffset(TypeInterfaceIndex globalOffset)
	{
		IL2CPP_ASSERT((uint32_t)globalOffset < (uint32_t)_interfaceDefines.size());

		TypeIndex typeIndex = _interfaceDefines[globalOffset];
		if (typeIndex == kTypeIndexInvalid)
		{
			uint32_t rowIndex = globalOffset + 1;
			TbInterfaceImpl data = _rawImage->ReadInterfaceImpl(rowIndex);
			Il2CppTypeDefinition& typeDef = _typesDefines[data.classIdx - 1];
			const Il2CppType* intType = ReadTypeFromToken(GetGenericContainerByTypeDefinition(&typeDef), nullptr,
				DecodeTypeDefOrRefOrSpecCodedIndexTableType(data.interfaceIdx), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(data.interfaceIdx));
			_interfaceDefines[globalOffset] = typeIndex = DecodeMetadataIndex(AddIl2CppTypeCache(intType));
		}

		return _types[typeIndex];
	}

	const Il2CppType* InterpreterImage::GetInterfaceFromIndex(const Il2CppClass* klass, TypeInterfaceIndex globalOffset)
	{
		return GetInterfaceFromGlobalOffset(globalOffset);
	}

	const Il2CppType* InterpreterImage::GetInterfaceFromOffset(const Il2CppClass* klass, TypeInterfaceIndex offset)
	{
		const Il2CppTypeDefinition* typeDef = (const Il2CppTypeDefinition*)(klass->typeMetadataHandle);
		IL2CPP_ASSERT(typeDef);
		return GetInterfaceFromOffset(typeDef, offset);
	}

	const Il2CppType* InterpreterImage::GetInterfaceFromOffset(const Il2CppTypeDefinition* typeDef, TypeInterfaceIndex offset)
	{
		uint32_t globalOffset = typeDef->interfacesStart + offset;
		return GetInterfaceFromGlobalOffset(globalOffset);
	}

	Il2CppInterfaceOffsetInfo InterpreterImage::GetInterfaceOffsetInfo(const Il2CppTypeDefinition* typeDefine, TypeInterfaceOffsetIndex index)
	{
		uint32_t globalIndex = DecodeMetadataIndex((uint32_t)(typeDefine->interfaceOffsetsStart + index));
		IL2CPP_ASSERT(globalIndex < (uint32_t)_interfaceOffsets.size());

		InterfaceOffsetInfo& offsetPair = _interfaceOffsets[globalIndex];
		return { offsetPair.type, (int32_t)offsetPair.offset };
	}

	Il2CppClass* InterpreterImage::GetNestedTypeFromOffset(const Il2CppTypeDefinition* typeDefine, TypeNestedTypeIndex offset)
	{
		uint32_t globalIndex = typeDefine->nestedTypesStart + offset;
		IL2CPP_ASSERT(globalIndex < (uint32_t)_nestedTypeDefineIndexs.size());
		uint32_t typeDefIndex = _nestedTypeDefineIndexs[globalIndex];
		IL2CPP_ASSERT(typeDefIndex < (uint32_t)_typesDefines.size());
		return il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle((Il2CppMetadataTypeHandle)&_typesDefines[typeDefIndex]);
	}

	Il2CppClass* InterpreterImage::GetNestedTypeFromOffset(const Il2CppClass* klass, TypeNestedTypeIndex offset)
	{
		return GetNestedTypeFromOffset((Il2CppTypeDefinition*)klass->typeMetadataHandle, offset);
	}

	Il2CppTypeDefinition* InterpreterImage::GetNestedTypes(Il2CppTypeDefinition* typeDefinition, void** iter)
	{
		if (_nestedTypeDefineIndexs.empty())
		{
			return nullptr;
		}
		const TypeDefinitionIndex* nestedTypeIndices = (const TypeDefinitionIndex*)(&_nestedTypeDefineIndexs[typeDefinition->nestedTypesStart]);

		if (!*iter)
		{
			if (typeDefinition->nested_type_count == 0)
				return NULL;

			*iter = (void*)(nestedTypeIndices);
			return &_typesDefines[nestedTypeIndices[0]];
		}

		TypeDefinitionIndex* nestedTypeAddress = (TypeDefinitionIndex*)*iter;
		nestedTypeAddress++;
		ptrdiff_t index = nestedTypeAddress - nestedTypeIndices;

		if (index < typeDefinition->nested_type_count)
		{
			*iter = nestedTypeAddress;
			return &_typesDefines[*nestedTypeAddress];
		}

		return NULL;
	}

	const Il2CppAssembly* InterpreterImage::GetReferencedAssembly(int32_t referencedAssemblyTableIndex, const Il2CppAssembly assembliesTable[], int assembliesCount)
	{
		auto& table = _rawImage->GetTable(TableType::ASSEMBLYREF);
		IL2CPP_ASSERT((uint32_t)referencedAssemblyTableIndex < table.rowNum);

		TbAssemblyRef assRef = _rawImage->ReadAssemblyRef(referencedAssemblyTableIndex + 1);
		const char* refAssName = _rawImage->GetStringFromRawIndex(assRef.name);
		const Il2CppAssembly* il2cppAssRef = il2cpp::vm::Assembly::GetLoadedAssembly(refAssName);
		if (!il2cppAssRef)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetDllNotFoundException(refAssName));
		}
		return il2cppAssRef;
	}

	void InterpreterImage::ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret)
	{
		IL2CPP_ASSERT(rowIndex > 0);
		const FieldDetail& fd = GetFieldDetailFromRawIndex(rowIndex - 1);
		ret.containerType = GetIl2CppTypeFromRawTypeDefIndex(DecodeMetadataIndex(fd.typeDefIndex));
		ret.field = &fd.fieldDef;
	}

	void InterpreterImage::GetClassAndMethodGenericContainerFromGenericContainerIndex(GenericContainerIndex idx, const Il2CppGenericContainer*& klassGc, const Il2CppGenericContainer*& methodGc)
	{
		Il2CppGenericContainer* gc = GetGenericContainerByRawIndex(DecodeMetadataIndex(idx));
		IL2CPP_ASSERT(gc);
		if (gc->is_method)
		{
			const Il2CppMethodDefinition* methodDef = GetMethodDefinitionFromRawIndex(DecodeMetadataIndex(gc->ownerIndex));
			klassGc = GetGenericContainerByTypeDefRawIndex(DecodeMetadataIndex(methodDef->declaringType));
			methodGc = GetGenericContainerByRawIndex(DecodeMetadataIndex(methodDef->genericContainerIndex));
		}
		else
		{
			klassGc = gc;
			methodGc = nullptr;
		}
	}

	void InterpreterImage::InitGenericParamConstraintDefs()
	{
		const Table& tb = _rawImage->GetTable(TableType::GENERICPARAMCONSTRAINT);
		_genericConstraints.resize(tb.rowNum, kTypeIndexInvalid);
		for (uint32_t i = 0; i < tb.rowNum; i++)
		{
			uint32_t rowIndex = i + 1;
			TbGenericParamConstraint data = _rawImage->ReadGenericParamConstraint(rowIndex);
			Il2CppGenericParameter& genericParam = _genericParams[data.owner - 1];

			if (genericParam.constraintsCount == 0)
			{
				genericParam.constraintsStart = EncodeWithIndex(i);
			}
			++genericParam.constraintsCount;
			//_genericConstraints[i] == kTypeIndexInvalid;

			//Il2CppType paramCons = {};

			//const Il2CppGenericContainer* klassGc;
			//const Il2CppGenericContainer* methodGc;
			//GetClassAndMethodGenericContainerFromGenericContainerIndex(genericParam.ownerIndex, klassGc, methodGc);

			//ReadTypeFromToken(klassGc, methodGc, DecodeTypeDefOrRefOrSpecCodedIndexTableType(data.constraint), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(data.constraint), paramCons);
			//_genericConstraints[i] = DecodeMetadataIndex(AddIl2CppTypeCache(paramCons));
		}
	}

	void InterpreterImage::InitGenericParamDefs0()
	{
		const Table& tb = _rawImage->GetTable(TableType::GENERICPARAM);
		_genericParams.resize(tb.rowNum);
	}

	void InterpreterImage::InitGenericParamDefs()
	{
		const Table& tb = _rawImage->GetTable(TableType::GENERICPARAM);
		for (uint32_t i = 0; i < tb.rowNum; i++)
		{
			uint32_t rowIndex = i + 1;
			TbGenericParam data = _rawImage->ReadGenericParam(rowIndex);
			Il2CppGenericParameter& paramDef = _genericParams[i];
			paramDef.num = data.number;
			paramDef.flags = data.flags;
			paramDef.nameIndex = EncodeWithIndex(data.name);
			// constraintsStart 和 constrantsCount init at InitGenericParamConstrains() latter

			TableType ownerType = DecodeTypeOrMethodDefCodedIndexTableType(data.owner);
			uint32_t ownerIndex = DecodeTypeOrMethodDefCodedIndexRowIndex(data.owner);
			IL2CPP_ASSERT(ownerIndex > 0);
			Il2CppGenericContainer* geneContainer;
			int32_t interIndex = ownerIndex - 1;
			if (ownerType == TableType::TYPEDEF)
			{
				Il2CppTypeDefinition& typeDef = _typesDefines[interIndex];
				if (typeDef.genericContainerIndex == kGenericContainerIndexInvalid)
				{
					Il2CppGenericContainer c = {};
					c.ownerIndex = EncodeWithIndex(interIndex);
					c.is_method = false;
					typeDef.genericContainerIndex = AddIl2CppGenericContainers(c);
				}
				geneContainer = &_genericContainers[DecodeMetadataIndex(typeDef.genericContainerIndex)];
				paramDef.ownerIndex = typeDef.genericContainerIndex;
			}
			else
			{
				Il2CppMethodDefinition& methodDef = _methodDefines[interIndex];
				if (methodDef.genericContainerIndex == kGenericContainerIndexInvalid)
				{
					Il2CppGenericContainer c = {};
					c.ownerIndex = EncodeWithIndex(interIndex);
					c.is_method = true;
					methodDef.genericContainerIndex = AddIl2CppGenericContainers(c);
				}
				geneContainer = &_genericContainers[DecodeMetadataIndex(methodDef.genericContainerIndex)];
				paramDef.ownerIndex = methodDef.genericContainerIndex;
			}
			if (geneContainer->type_argc == 0)
			{
				geneContainer->genericParameterStart = EncodeWithIndex(i);
			}
			++geneContainer->type_argc;
		}
	}


	void InterpreterImage::InitInterfaces()
	{
		const Table& table = _rawImage->GetTable(TableType::INTERFACEIMPL);

		// interface中只包含直接继承的interface,不包括来自父类的
		// 此interface只在CastClass及Type.GetInterfaces()反射函数中
		// 发挥作用，不在callvir中发挥作用。
		// interfaceOffsets中包含了水平展开的所有interface(包括父类的)
		_interfaceDefines.resize(table.rowNum, kTypeIndexInvalid);
		uint32_t lastClassIdx = 0;
		for (uint32_t i = 0; i < table.rowNum; i++)
		{
			uint32_t rowIndex = i + 1;
			TbInterfaceImpl data = _rawImage->ReadInterfaceImpl(rowIndex);

			Il2CppTypeDefinition& typeDef = _typesDefines[data.classIdx - 1];
			//Il2CppType intType = {};
			//ReadTypeFromToken(GetGenericContainerByTypeDefinition(&typeDef), nullptr,
			//	DecodeTypeDefOrRefOrSpecCodedIndexTableType(data.interfaceIdx), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(data.interfaceIdx), intType);
			//_interfaceDefines[i] = DecodeMetadataIndex(AddIl2CppTypeCache(intType));
			if (typeDef.interfaces_count == 0)
			{
				typeDef.interfacesStart = (InterfacesIndex)i;
			}
			else
			{
				// 必须连续
				IL2CPP_ASSERT(data.classIdx == lastClassIdx);
			}
			++typeDef.interfaces_count;
			lastClassIdx = data.classIdx;
		}
	}

	void InterpreterImage::ComputeVTable(TypeDefinitionDetail* tdd)
	{
		Il2CppTypeDefinition& typeDef = *GetTypeDefinitionByTypeDetail(tdd);
		if (IsInterface(typeDef.flags) || typeDef.interfaceOffsetsStart != 0)
		{
			return;
		}

		if (typeDef.parentIndex != kInvalidIndex)
		{
			const Il2CppType* parentType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef.parentIndex);
			const Il2CppTypeDefinition* parentTypeDef = GetUnderlyingTypeDefinition(parentType);
			if (IsInterpreterType(parentTypeDef) && parentTypeDef->interfaceOffsetsStart == 0)
			{
				IL2CPP_ASSERT(DecodeImageIndex(parentTypeDef->byvalTypeIndex) == this->GetIndex());
				int32_t typeDefIndex = GetTypeRawIndexByEncodedIl2CppTypeIndex(parentTypeDef->byvalTypeIndex);
				ComputeVTable(&_typeDetails[typeDefIndex]);
			}
		}

		const Il2CppType* type = GetIl2CppTypeFromRawIndex(DecodeMetadataIndex(typeDef.byvalTypeIndex));
		VTableSetUp* typeTree = VTableSetUp::BuildByType(_cacheTrees, type);

		uint32_t offsetsStart = (uint32_t)_interfaceOffsets.size();

		auto& vms = typeTree->GetVirtualMethodImpls();
		if (vms.empty())
		{
			tdd->vtable = nullptr;
			tdd->vtableCount = 0;
		}
		else
		{
			tdd->vtable = (VirtualMethodImpl*)HYBRIDCLR_METADATA_CALLOC(vms.size(), sizeof(VirtualMethodImpl));
			tdd->vtableCount = (uint32_t)vms.size();
			std::memcpy(tdd->vtable, &vms[0], vms.size() * sizeof(VirtualMethodImpl));
		}

		auto& interfaceOffsetInfos = typeTree->GetInterfaceOffsetInfos();
		for (auto ioi : interfaceOffsetInfos)
		{
			_interfaceOffsets.push_back({ ioi.type, ioi.offset });
		}

		typeDef.vtableStart = EncodeWithIndex(0);
		typeDef.vtable_count = (uint16_t)vms.size();
		typeDef.interfaceOffsetsStart = EncodeWithIndex(offsetsStart);
		typeDef.interface_offsets_count = (uint16_t)interfaceOffsetInfos.size();

		Il2CppClass* klass = _classList[GetTypeRawIndex(&typeDef)];
		IL2CPP_ASSERT(!klass);
	}

	void InterpreterImage::InitVTables()
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);

		for (TypeDefinitionDetail& td : _typeDetails)
		{
			ComputeVTable(&td);
		}

		for (auto& e : _cacheTrees)
		{
			e.second->~VTableSetUp();
			HYBRIDCLR_FREE(e.second);
		}
		Il2CppType2TypeDeclaringTreeMap temp;
		_cacheTrees.swap(temp);
	}

	// index => MethodDefinition -> DeclaringClass -> index - klass->methodStart -> MethodInfo*
	const MethodInfo* InterpreterImage::GetMethodInfoFromMethodDefinitionRawIndex(uint32_t index)
	{
		IL2CPP_ASSERT((size_t)index <= _methodDefines.size());
		const Il2CppMethodDefinition* methodDefinition = GetMethodDefinitionFromRawIndex(index);
		const Il2CppTypeDefinition* typeDefinition = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(methodDefinition->declaringType);
		int32_t indexInClass = index - DecodeMetadataIndex(typeDefinition->methodStart);
		IL2CPP_ASSERT(indexInClass >= 0 && indexInClass < typeDefinition->method_count);
		Il2CppClass* klass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle((Il2CppMetadataTypeHandle)typeDefinition);
		il2cpp::vm::Class::SetupMethods(klass);
		return klass->methods[indexInClass];
	}

	const MethodInfo* InterpreterImage::GetMethodInfoFromMethodDefinition(const Il2CppMethodDefinition* methodDef)
	{
		uint32_t rawIndex = (uint32_t)(methodDef - &_methodDefines[0]);
		IL2CPP_ASSERT(rawIndex < (uint32_t)_methodDefines.size());
		return GetMethodInfoFromMethodDefinitionRawIndex(rawIndex);
	}

	// typeDef vTableSlot -> type virtual method index -> MethodDefinition*
	const Il2CppMethodDefinition* InterpreterImage::GetMethodDefinitionFromVTableSlot(const Il2CppTypeDefinition* typeDef, int32_t vTableSlot)
	{
		uint32_t typeDefIndex = GetTypeRawIndex(typeDef);
		IL2CPP_ASSERT(typeDefIndex < (uint32_t)_typeDetails.size());
		TypeDefinitionDetail& td = _typeDetails[typeDefIndex];

		IL2CPP_ASSERT(vTableSlot >= 0 && vTableSlot < (int32_t)td.vtableCount);
		VirtualMethodImpl& vmi = td.vtable[vTableSlot];
		return vmi.method;
	}

	const MethodInfo* InterpreterImage::GetMethodInfoFromVTableSlot(const Il2CppClass* klass, int32_t vTableSlot)
	{
		IL2CPP_ASSERT(!klass->generic_class);
		const Il2CppTypeDefinition* typeDef = (Il2CppTypeDefinition*)klass->typeMetadataHandle;
		//const Il2CppMethodDefinition* methodDef = GetMethodDefinitionFromVTableSlot((Il2CppTypeDefinition*)klass->typeMetadataHandle, vTableSlot);
		// FIX ME. why return null?
		//IL2CPP_ASSERT(methodDef);

		uint32_t typeDefIndex = GetTypeRawIndex(typeDef);
		IL2CPP_ASSERT(typeDefIndex < (uint32_t)_typeDetails.size());
		TypeDefinitionDetail& td = _typeDetails[typeDefIndex];

		IL2CPP_ASSERT(vTableSlot >= 0 && vTableSlot < (int32_t)td.vtableCount);
		VirtualMethodImpl& vmi = td.vtable[vTableSlot];
		if (vmi.method)
		{
			if (vmi.method->declaringType == EncodeWithIndex(typeDefIndex))
			{
				return il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodHandle((Il2CppMetadataMethodDefinitionHandle)vmi.method);
			}
			else
			{
				Il2CppClass* implClass = il2cpp::vm::Class::FromIl2CppType(vmi.type);
				IL2CPP_ASSERT(implClass != klass);
				il2cpp::vm::Class::SetupMethods(implClass);
				for (uint32_t i = 0; i < implClass->method_count; i++)
				{
					const MethodInfo* implMethod = implClass->methods[i];
					if (implMethod->token == vmi.method->token)
					{
						return implMethod;
					}
				}
				RaiseExecutionEngineException("not find vtable method");
			}
		}
		return nullptr;
	}

	Il2CppMethodPointer InterpreterImage::GetAdjustorThunk(uint32_t token)
	{
		uint32_t methodIndex = DecodeTokenRowIndex(token) - 1;
		IL2CPP_ASSERT(methodIndex < (uint32_t)_methodDefines.size());
		const Il2CppMethodDefinition* methodDef = &_methodDefines[methodIndex];
		return IsInstanceMethod(methodDef) ? hybridclr::interpreter::InterpreterModule::GetAdjustThunkMethodPointer(methodDef) : nullptr;
	}

	Il2CppMethodPointer InterpreterImage::GetMethodPointer(uint32_t token)
	{
		uint32_t methodIndex = DecodeTokenRowIndex(token) - 1;
		IL2CPP_ASSERT(methodIndex < (uint32_t)_methodDefines.size());
		const Il2CppMethodDefinition* methodDef = &_methodDefines[methodIndex];
		return hybridclr::interpreter::InterpreterModule::GetMethodPointer(methodDef);
	}

	InvokerMethod InterpreterImage::GetMethodInvoker(uint32_t token)
	{
		uint32_t methodIndex = DecodeTokenRowIndex(token) - 1;
		IL2CPP_ASSERT(methodIndex < (uint32_t)_methodDefines.size());
		const Il2CppMethodDefinition* methodDef = &_methodDefines[methodIndex];
		return hybridclr::interpreter::InterpreterModule::GetMethodInvoker(methodDef);
	}


	Il2CppString* InterpreterImage::ReadSerString(BlobReader& reader)
	{
		byte b = reader.PeekByte();
		if (b == 0xFF)
		{
			reader.SkipByte();
			return nullptr;
		}
		else if (b == 0)
		{
			reader.SkipByte();
			return il2cpp::vm::String::Empty();
		}
		else
		{
			uint32_t len = reader.ReadCompressedUint32();
#if !HYBRIDCLR_UNITY_2021_OR_NEW
			return il2cpp::vm::String::NewLen((char*)reader.GetAndSkipCurBytes(len), len);
#else
			char* chars = (char*)reader.GetDataOfReadPosition();
			reader.SkipBytes(len);
			return il2cpp::vm::String::NewLen(chars, len);
#endif
		}
	}

#if HYBRIDCLR_UNITY_2021_OR_NEW
	bool InterpreterImage::ReadUTF8SerString(BlobReader& reader, std::string& s)
	{
		byte b = reader.PeekByte();
		if (b == 0xFF)
		{
			reader.SkipByte();
			return false;
		}
		else if (b == 0)
		{
			reader.SkipByte();
			s.clear();
			return true;
		}
		else
		{
			uint32_t len = reader.ReadCompressedUint32();
			char* chars = (char*)reader.GetDataOfReadPosition();
			reader.SkipBytes(len);
			s.assign(chars, len);
			return true;
		}
	}
#endif

	Il2CppReflectionType* InterpreterImage::ReadSystemType(BlobReader& reader)
	{
		Il2CppString* fullName = ReadSerString(reader);
		if (!fullName)
		{
			return nullptr;
		}
		Il2CppReflectionType* type = GetReflectionTypeFromName(fullName);
		if (!type)
		{
			std::string stdTypeName = il2cpp::utils::StringUtils::Utf16ToUtf8(fullName->chars);
			TEMP_FORMAT(errMsg, "CustomAttribute fixed arg type:System.Type fullName:'%s' not find", stdTypeName.c_str());
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException(errMsg));
		}
		return type;
	}


	Il2CppObject* InterpreterImage::ReadBoxedValue(BlobReader& reader)
	{
		uint64_t obj = 0;
		Il2CppType kind = {};
		ReadCustomAttributeFieldOrPropType(reader, kind);
		ReadFixedArg(reader, &kind, &obj);
		Il2CppClass* valueType = il2cpp::vm::Class::FromIl2CppType(&kind);
		return il2cpp::vm::Object::Box(valueType, &obj);
	}

	void InterpreterImage::ReadFixedArg(BlobReader& reader, const Il2CppType* argType, void* data)
	{
		switch (argType->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		{
			*(byte*)data = reader.ReadByte();
			break;
		}
		case IL2CPP_TYPE_CHAR:
		{
			*(uint16_t*)data = reader.Read16();
			break;
		}
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		{
			*(byte*)data = reader.ReadByte();
			break;
		}
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		{
			*(uint16_t*)data = reader.Read16();
			break;
		}
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		{
			*(uint32_t*)data = reader.Read32();
			break;
		}
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		{
			*(uint64_t*)data = reader.Read64();
			break;
		}
		case IL2CPP_TYPE_R4:
		{
			*(float*)data = reader.ReadFloat();
			break;
		}
		case IL2CPP_TYPE_R8:
		{
			*(double*)data = reader.ReadDouble();
			break;
		}
		case IL2CPP_TYPE_SZARRAY:
		{
			uint32_t numElem = reader.Read32();
			if (numElem != (uint32_t)-1)
			{
				Il2CppClass* arrKlass = il2cpp::vm::Class::FromIl2CppType(argType);
				Il2CppArray* arr = il2cpp::vm::Array::New(il2cpp::vm::Class::GetElementClass(arrKlass), numElem);
				for (uint16_t i = 0; i < numElem; i++)
				{
					ReadFixedArg(reader, argType->data.type, GET_ARRAY_ELEMENT_ADDRESS(arr, i, arr->klass->element_size));
				}
				*(void**)data = arr;
			}
			else
			{
				*(void**)data = nullptr;
			}
			HYBRIDCLR_SET_WRITE_BARRIER((void**)data);
			break;
		}
		case IL2CPP_TYPE_STRING:
		{
			*(Il2CppString**)data = ReadSerString(reader);
			HYBRIDCLR_SET_WRITE_BARRIER((void**)data);
			break;
		}
		case IL2CPP_TYPE_OBJECT:
		{
			*(Il2CppObject**)data = ReadBoxedValue(reader);
			HYBRIDCLR_SET_WRITE_BARRIER((void**)data);
			break;
		}
		case IL2CPP_TYPE_CLASS:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(argType);
			if (!klass)
			{
				RaiseExecutionEngineException("type not find");
			}
			if (klass == il2cpp_defaults.object_class)
			{
				*(Il2CppObject**)data = ReadBoxedValue(reader);
			}
			else if (klass == il2cpp_defaults.systemtype_class)
			{
				*(Il2CppReflectionType**)data = ReadSystemType(reader);
			}
			else
			{
				TEMP_FORMAT(errMsg, "fixed arg type:%s.%s not support", klass->namespaze, klass->name);
				RaiseNotSupportedException(errMsg);
			}
			HYBRIDCLR_SET_WRITE_BARRIER((void**)data);
			break;
		}
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* valueType = il2cpp::vm::Class::FromIl2CppType(argType);
			IL2CPP_ASSERT(valueType->enumtype);
			ReadFixedArg(reader, &valueType->element_class->byval_arg, data);
			break;
		}
		case IL2CPP_TYPE_SYSTEM_TYPE:
		{
			*(Il2CppReflectionType**)data = ReadSystemType(reader);
			HYBRIDCLR_SET_WRITE_BARRIER((void**)data);
			break;
		}
		case IL2CPP_TYPE_BOXED_OBJECT:
		{
			uint8_t fieldOrPropType = reader.ReadByte();
			IL2CPP_ASSERT(fieldOrPropType == 0x51);
			*(Il2CppObject**)data = ReadBoxedValue(reader);
			HYBRIDCLR_SET_WRITE_BARRIER((void**)data);
			break;
		}
		case IL2CPP_TYPE_ENUM:
		{
			Il2CppClass* valueType = il2cpp::vm::Class::FromIl2CppType(argType);
			IL2CPP_ASSERT(valueType->enumtype);
			ReadFixedArg(reader, &valueType->element_class->byval_arg, data);
			break;
		}
		default:
		{
			RaiseExecutionEngineException("not support fixed argument type");
		}
		}
	}

	void InterpreterImage::ReadCustomAttributeFieldOrPropType(BlobReader& reader, Il2CppType& type)
	{
		type.type = (Il2CppTypeEnum)reader.ReadByte();

		switch (type.type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R4:
		case IL2CPP_TYPE_R8:
		case IL2CPP_TYPE_STRING:
		{
			break;
		}
		case IL2CPP_TYPE_SZARRAY:
		{
			Il2CppType eleType = {};
			ReadCustomAttributeFieldOrPropType(reader, eleType);
			type.data.type = MetadataPool::GetPooledIl2CppType(eleType);
			break;
		}
		case IL2CPP_TYPE_ENUM:
		{
			Il2CppString* enumTypeName = ReadSerString(reader);

			Il2CppReflectionType* enumType = GetReflectionTypeFromName(enumTypeName);
			if (!enumType)
			{
				std::string stdStrName = il2cpp::utils::StringUtils::Utf16ToUtf8(enumTypeName->chars);
				TEMP_FORMAT(errMsg, "ReadCustomAttributeFieldOrPropType enum:'%s' not exists", stdStrName.c_str());
				RaiseExecutionEngineException(errMsg);
			}
			type = *enumType->type;
			break;
		}
		case IL2CPP_TYPE_SYSTEM_TYPE:
		{
			type = il2cpp_defaults.systemtype_class->byval_arg;
			break;
		}
		case IL2CPP_TYPE_BOXED_OBJECT:
		{
			type = il2cpp_defaults.object_class->byval_arg;
			break;
		}
		default:
		{
			TEMP_FORMAT(errMsg, "ReadCustomAttributeFieldOrPropType. image:%s unknown type:%d", GetIl2CppImage()->name, (int)type.type);
			RaiseBadImageException(errMsg);
		}
		}
	}

	void InterpreterImage::ReadMethodDefSig(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, Il2CppMethodDefinition& methodDef, std::vector<ParamDetail>& paramArr)
	{
		uint8_t rawSigFlags = reader.ReadByte();

		if (rawSigFlags & (uint8_t)MethodSigFlags::GENERIC)
		{
			//IL2CPP_ASSERT(false);
			uint32_t genParamCount = reader.ReadCompressedUint32();
			Il2CppGenericContainer* gc = GetGenericContainerByRawIndex(DecodeMetadataIndex(methodDef.genericContainerIndex));
			IL2CPP_ASSERT(gc->type_argc == genParamCount);
		}
		uint32_t paramCount = reader.ReadCompressedUint32();
		//IL2CPP_ASSERT(paramCount >= methodDef.parameterCount);

		const Il2CppType* returnType = ReadType(reader, klassGenericContainer, methodGenericContainer);
		methodDef.returnType = AddIl2CppTypeCache(returnType);

		int readParamNum = 0;
		for (; reader.NonEmpty(); )
		{
			ParamDetail curParam = {};
			const Il2CppType* type = ReadType(reader, klassGenericContainer, methodGenericContainer);
			curParam.parameterIndex = readParamNum++;
			curParam.paramDef.typeIndex = AddIl2CppTypeCache(type);
			paramArr.push_back(curParam);
		}
		IL2CPP_ASSERT(readParamNum == (int)paramCount);
	}

	const Il2CppType* InterpreterImage::GetModuleIl2CppType(uint32_t moduleRowIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound)
	{
		IL2CPP_ASSERT(moduleRowIndex == 1);
		uint32_t encodedNamespaceIndex = EncodeWithIndex(typeNamespace);
		uint32_t encodedNameIndex = EncodeWithIndex(typeName);
		for (TypeDefinitionDetail& type : _typeDetails)
		{
			Il2CppTypeDefinition* typeDef = GetTypeDefinitionByTypeDetail(&type);
			if (typeDef->namespaceIndex == encodedNamespaceIndex && typeDef->nameIndex == encodedNameIndex)
			{
				return GetIl2CppTypeFromTypeDefinition(typeDef);
			}
		}
		if (!raiseExceptionIfNotFound)
		{
			return nullptr;
		}
		const char* typeNameStr = _rawImage->GetStringFromRawIndex(typeName);
		const char* typeNamespaceStr = _rawImage->GetStringFromRawIndex(typeNamespace);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException(
			CStringToStringView(typeNamespaceStr),
			CStringToStringView(typeNameStr),
			CStringToStringView(_il2cppImage->nameNoExt)));
		return nullptr;
	}
}
}
```

`hybridclr/metadata/InterpreterImage.h`:

```h
#pragma once

#include <unordered_map>

#if HYBRIDCLR_UNITY_2021_OR_NEW
#include "metadata/CustomAttributeDataReader.h"
#include "CustomAttributeDataWriter.h"
#endif

#include "Image.h"
#include "CustomAttributeDataWriter.h"

namespace hybridclr
{
namespace metadata
{
	struct InterfaceOffsetInfo
	{
		const Il2CppType* type;
		uint32_t offset;
	};


	struct TypeDefinitionDetail
	{
		uint32_t methodImplStart;
		uint32_t methodImplCount;
		uint32_t vtableCount;
		Il2CppTypeDefinitionSizes typeSizes;
		VirtualMethodImpl* vtable;
	};

	struct ParamDetail
	{
		Il2CppParameterDefinition paramDef;
		uint32_t parameterIndex;
		uint32_t defaultValueIndex; // -1 for invalid
	};

	struct FieldDetail
	{
		Il2CppFieldDefinition fieldDef;
		uint32_t typeDefIndex;
		uint32_t offset;
		uint32_t defaultValueIndex; // -1 for invalid
	};

	struct PropertyDetail
	{
		const char* name;
		uint16_t flags;
		uint32_t signatureBlobIndex;
		uint32_t getterMethodIndex; // start from 1;
		uint32_t setterMethodIndex;
		const Il2CppTypeDefinition* declaringType;
		Il2CppPropertyDefinition il2cppDefinition;
	};

	struct EventDetail
	{
		const char* name;
		uint16_t eventFlags;
		uint32_t eventType; // TypeDefOrRef codedIndex
		uint32_t addMethodIndex; // start from 1
		uint32_t removeMethodIndex; // start from 1
		uint32_t fireMethodIndex; // start from 1;
#if HYBRIDCLR_UNITY_2019
		const Il2CppTypeDefinition* declaringType;
		Il2CppEventDefinition il2cppDefinition;
#endif
	};

	struct CustomAttribute
	{
		uint32_t ctorMethodToken;
		uint32_t value;
	};

	struct CustomAttributesInfo
	{
		int32_t typeRangeIndex;
		bool inited;
		void* dataStartPtr;
		void* dataEndPtr;
	};


#if HYBRIDCLR_UNITY_2021_OR_NEW
	enum class BlobSource
	{
		RAW_IMAGE = 0,
		CONVERTED_IL2CPP_FORMAT = 1,
	};
#endif

	struct ImplMapInfo
	{
		const char* moduleName;
		const char* importName;
		uint32_t mappingFlags;
	};

	class InterpreterImage : public Image
	{
	public:

		static void Initialize();

		static uint32_t AllocImageIndex(uint32_t dllLength);

		static void RegisterImage(InterpreterImage* image);

		static InterpreterImage* GetImage(uint32_t imageIndex)
		{
			//os::FastAutoLock lock(&s_imageLock);
			IL2CPP_ASSERT(imageIndex < kMaxMetadataImageCount);
			return s_images[imageIndex];
		}

	private:

		static InterpreterImage* s_images[kMaxMetadataImageCount];

	public:

		InterpreterImage(uint32_t imageIndex) : _index(imageIndex), _inited(false), _il2cppImage(nullptr)
#if HYBRIDCLR_UNITY_2021_OR_NEW
			, _constValues(1024), _il2cppFormatCustomDataBlob(256), _tempCtorArgBlob(256), _tempFieldBlob(256), _tempPropertyBlob(256)
#endif
		{

		}

		LoadImageErrorCode Load(const void* imageData, size_t length)
		{
			if (_inited)
			{
				RaiseExecutionEngineException("image can't be inited again");
			}
			_inited = true;
			LoadImageErrorCode err = InitRawImage(imageData, length);
			if (err != LoadImageErrorCode::OK)
			{
				return err;
			}
			err = _rawImage->Load(imageData, length);
			if (err != LoadImageErrorCode::OK)
			{
				delete _rawImage;
				_rawImage = nullptr;
				return err;
			}
			return LoadImageErrorCode::OK;
		}

		bool IsInitialized() const
		{
			return _inited;
		}

		uint32_t GetIndex() const
		{
			return _index;
		}

		const Il2CppImage* GetIl2CppImage() const
		{
			return _il2cppImage;
		}

		uint32_t EncodeWithIndex(uint32_t rawIndex) const
		{
			return EncodeImageAndMetadataIndex(_index, rawIndex);
		}

		uint32_t EncodeWithIndexExcept0(uint32_t rawIndex) const
		{
			return rawIndex != 0 ? EncodeImageAndMetadataIndex(_index, rawIndex) : 0;
		}

		MethodBody* GetMethodBody(uint32_t token) override
		{
			IL2CPP_ASSERT(DecodeTokenTableType(token) == TableType::METHOD);
			uint32_t rowIndex = DecodeTokenRowIndex(token);
			IL2CPP_ASSERT(rowIndex > 0 && rowIndex <= (uint32_t)_methodDefines.size());


			const Il2CppMethodDefinition* methodDef = &_methodDefines[rowIndex - 1];
			bool isGenericMethod = methodDef->genericContainerIndex != kGenericContainerIndexInvalid || _typesDefines[DecodeMetadataIndex(methodDef->declaringType)].genericContainerIndex != kGenericContainerIndexInvalid;

			TbMethod methodData = _rawImage->ReadMethod(rowIndex);
			MethodBody* resultMethodBody = new (HYBRIDCLR_MALLOC_ZERO(sizeof(MethodBody))) MethodBody();
			ReadMethodBody(*methodDef, methodData, *resultMethodBody);
			return resultMethodBody;
		}

		// type index start from 0, difference with table index...
		Il2CppMetadataTypeHandle GetAssemblyTypeHandleFromRawIndex(AssemblyTypeIndex index) const
		{
			IL2CPP_ASSERT(DecodeImageIndex(index) == 0);
			IL2CPP_ASSERT(index >= 0 && (size_t)index < _typesDefines.size());
			return (Il2CppMetadataTypeHandle)&_typesDefines[index];
		}

		Il2CppMetadataTypeHandle GetAssemblyExportedTypeHandleFromRawIndex(AssemblyTypeIndex index) const
		{
			IL2CPP_ASSERT(DecodeImageIndex(index) == 0);
			IL2CPP_ASSERT(index >= 0 && (size_t)index < _typesDefines.size());
			return (Il2CppMetadataTypeHandle)&_exportedTypeDefines[index];
		}

		const Il2CppTypeDefinitionSizes* GetTypeDefinitionSizesFromRawIndex(TypeDefinitionIndex index)
		{
			IL2CPP_ASSERT((size_t)index < _typeDetails.size());
			return &_typeDetails[index].typeSizes;
		}

		const char* GetStringFromRawIndex(StringIndex index) const
		{
			IL2CPP_ASSERT(DecodeImageIndex(index) == 0);
			return _rawImage->GetStringFromRawIndex(index);
		}

		uint32_t GetTypeRawIndex(const Il2CppTypeDefinition* typeDef) const
		{
			return (uint32_t)(typeDef - &_typesDefines[0]);
		}

		Il2CppTypeDefinition* GetTypeDefinitionByTypeDetail(const TypeDefinitionDetail* typeDetail)
		{
			uint32_t index = (uint32_t)(typeDetail - &_typeDetails[0]);
			return &_typesDefines[index];
		}

		uint32_t GetTypeRawIndexByEncodedIl2CppTypeIndex(int32_t il2cppTypeIndex) const
		{
			return GetTypeRawIndex((const Il2CppTypeDefinition*)_types[DecodeMetadataIndex(il2cppTypeIndex)]->data.typeHandle);
		}

		const Il2CppTypeDefinition* GetTypeFromRawIndex(uint32_t index) const
		{
			IL2CPP_ASSERT((size_t)index < _typesDefines.size());
			return &_typesDefines[index];
		}

		const Il2CppType* GetIl2CppTypeFromRawIndex(uint32_t index) const
		{
			IL2CPP_ASSERT((size_t)index < _types.size());
			return _types[index];
		}

		const Il2CppType* GetIl2CppTypeFromRawTypeDefIndex(uint32_t index) override
		{
			IL2CPP_ASSERT(index < (uint32_t)_typesDefines.size());
			return _types[DecodeMetadataIndex(_typesDefines[index].byvalTypeIndex)];
		}

		const Il2CppFieldDefinition* GetFieldDefinitionFromRawIndex(uint32_t index)
		{
			IL2CPP_ASSERT(index < (uint32_t)_fieldDetails.size());
			return &(_fieldDetails[index].fieldDef);
		}

		const FieldDetail& GetFieldDetailFromRawIndex(uint32_t index)
		{
			IL2CPP_ASSERT(index < (uint32_t)_fieldDetails.size());
			return _fieldDetails[index];
		}

		const Il2CppMethodDefinition* GetMethodDefinitionFromRawIndex(uint32_t index) override
		{
			IL2CPP_ASSERT((size_t)index < _methodDefines.size());
			return &_methodDefines[index];
		}

		MethodIndex GetMethodIndexFromDefinition(const Il2CppMethodDefinition* methodDefine)
		{
			return EncodeWithIndex((uint32_t)(methodDefine - &_methodDefines[0]));
		}

		const Il2CppGenericParameter* GetGenericParameterByGlobalIndex(uint32_t index)
		{
			IL2CPP_ASSERT(index < (uint32_t)_genericParams.size());
			return &_genericParams[index];
		}

		const Il2CppGenericParameter* GetGenericParameterByRawIndex(const Il2CppGenericContainer* container, uint32_t index)
		{
			uint32_t globalIndex = DecodeMetadataIndex(container->genericParameterStart) + index;
			IL2CPP_ASSERT(globalIndex < (uint32_t)_genericParams.size());
			return &_genericParams[globalIndex];
		}

		Il2CppGenericContainer* GetGenericContainerByRawIndex(uint32_t index) override
		{
			if (index != kGenericContainerIndexInvalid)
			{
				IL2CPP_ASSERT(index < (uint32_t)_genericContainers.size());
				return &_genericContainers[index];
			}
			return nullptr;
		}

		Il2CppGenericContainer* GetGenericContainerByTypeDefinition(const Il2CppTypeDefinition* typeDef)
		{
			GenericContainerIndex idx = DecodeMetadataIndex(typeDef->genericContainerIndex);
			if (idx != kGenericContainerIndexInvalid)
			{
				IL2CPP_ASSERT(idx < (GenericContainerIndex)_genericContainers.size());
				return &_genericContainers[idx];
			}
			return nullptr;
		}

		Il2CppGenericContainer* GetGenericContainerByTypeDefRawIndex(int32_t typeDefIndex) override
		{
			IL2CPP_ASSERT(typeDefIndex < (int32_t)_typeDetails.size());
			return GetGenericContainerByTypeDefinition(&_typesDefines[typeDefIndex]);
		}

		const il2cpp::utils::dynamic_array<MethodImpl> GetTypeMethodImplByTypeDefinition(const Il2CppTypeDefinition* typeDef);

		const Il2CppType* GetGenericParameterConstraintFromIndex(GenericParameterConstraintIndex index)
		{
			IL2CPP_ASSERT((size_t)index < _genericConstraints.size());
			TypeIndex typeIndex = _genericConstraints[index];
			if (typeIndex == kTypeIndexInvalid)
			{

				TbGenericParamConstraint data = _rawImage->ReadGenericParamConstraint(index + 1);
				Il2CppGenericParameter& genericParam = _genericParams[data.owner - 1];

				const Il2CppGenericContainer* klassGc;
				const Il2CppGenericContainer* methodGc;
				GetClassAndMethodGenericContainerFromGenericContainerIndex(genericParam.ownerIndex, klassGc, methodGc);

				const Il2CppType* paramCons = ReadTypeFromToken(klassGc, methodGc, DecodeTypeDefOrRefOrSpecCodedIndexTableType(data.constraint), DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(data.constraint));
				_genericConstraints[index] = typeIndex = DecodeMetadataIndex(AddIl2CppTypeCache(paramCons));
			}
			return _types[typeIndex];
		}

		Il2CppClass* GetNestedTypeFromOffset(const Il2CppClass* klass, TypeNestedTypeIndex offset);
		Il2CppClass* GetNestedTypeFromOffset(const Il2CppTypeDefinition* typeDef, TypeNestedTypeIndex offset);

		const MethodInfo* GetMethodInfoFromMethodDefinitionRawIndex(uint32_t index);
		const MethodInfo* GetMethodInfoFromMethodDefinition(const Il2CppMethodDefinition* methodDef);
		const Il2CppMethodDefinition* GetMethodDefinitionFromVTableSlot(const Il2CppTypeDefinition* typeDefine, int32_t vTableSlot);
		const MethodInfo* GetMethodInfoFromVTableSlot(const Il2CppClass* klass, int32_t vTableSlot);

		Il2CppTypeDefinition* GetNestedTypes(Il2CppTypeDefinition* handle, void** iter);

		void GetClassAndMethodGenericContainerFromGenericContainerIndex(GenericContainerIndex idx, const Il2CppGenericContainer*& klassGc, const Il2CppGenericContainer*& methodGc);

		Il2CppMethodPointer GetAdjustorThunk(uint32_t token);
		Il2CppMethodPointer GetMethodPointer(uint32_t token);
		InvokerMethod GetMethodInvoker(uint32_t token);

		const Il2CppParameterDefinition* GetParameterDefinitionFromIndex(uint32_t index)
		{
			IL2CPP_ASSERT((size_t)index < _params.size());
			return &_params[index].paramDef;
		}

		const Il2CppParameterDefaultValue* GetParameterDefaultValueEntryByRawIndex(uint32_t index)
		{
			IL2CPP_ASSERT(index < (uint32_t)_params.size());
			uint32_t defaultValueIndex = _params[index].defaultValueIndex;
			return defaultValueIndex != kDefaultValueIndexNull ? &_paramDefaultValues[defaultValueIndex] : nullptr;
		}

		uint32_t GetFieldOffset(const Il2CppTypeDefinition* typeDef, int32_t fieldIndexInType)
		{
			uint32_t fieldActualIndex = DecodeMetadataIndex(typeDef->fieldStart) + fieldIndexInType;
			IL2CPP_ASSERT(fieldActualIndex < (uint32_t)_fieldDetails.size());
			return _fieldDetails[fieldActualIndex].offset;
		}

		uint32_t GetFieldOffset(TypeDefinitionIndex typeIndex, int32_t fieldIndexInType)
		{
			Il2CppTypeDefinition* typeDef = &_typesDefines[typeIndex];
			return GetFieldOffset(typeDef, fieldIndexInType);
		}

		uint32_t GetFieldOffset(const Il2CppClass* klass, int32_t fieldIndexInType)
		{
			Il2CppTypeDefinition* typeDef = (Il2CppTypeDefinition*)(klass->typeMetadataHandle);
			return GetFieldOffset(typeDef, fieldIndexInType);
		}

		int32_t GetPackingSize(const Il2CppTypeDefinition* typeDef) const
		{
			int32_t typeIndex = GetTypeRawIndex(typeDef);
			auto it = _classLayouts.find(typeIndex);
			return it != _classLayouts.end() ? it->second.packingSize : 0;
		}

		TbClassLayout GetClassLayout(const Il2CppTypeDefinition* typeDef) const
		{
			int32_t typeIndex = GetTypeRawIndex(typeDef);
			auto it = _classLayouts.find(typeIndex);
			return it != _classLayouts.end() ? it->second : TbClassLayout{};
		}

		const Il2CppFieldDefaultValue* GetFieldDefaultValueEntryByRawIndex(uint32_t index)
		{
			IL2CPP_ASSERT(index < (uint32_t)_fieldDetails.size());
			uint32_t fdvIndex = _fieldDetails[index].defaultValueIndex;
			IL2CPP_ASSERT(fdvIndex != kDefaultValueIndexNull);
			return &_fieldDefaultValues[fdvIndex];
		}

#if HYBRIDCLR_UNITY_2021_OR_NEW
		static uint32_t EncodeWithBlobSource(uint32_t index, BlobSource source)
		{
			return (index << 1) | (uint32_t)source;
		}
#endif

		const uint8_t* GetFieldOrParameterDefalutValueByRawIndex(uint32_t index)
		{
#if !HYBRIDCLR_UNITY_2021_OR_NEW
			return _rawImage->GetFieldOrParameterDefalutValueByRawIndex(index);
#else
			BlobSource source = (BlobSource)(index & 0x1);
			uint32_t offset = index >> 1;
			if (source == BlobSource::RAW_IMAGE)
			{
				return _rawImage->GetFieldOrParameterDefalutValueByRawIndex(offset);
			}
			else
			{
				return _constValues.DataAt(offset);
			}
#endif
		}

#if HYBRIDCLR_UNITY_2021_OR_NEW
		DefaultValueDataIndex ConvertConstValue(CustomAttributeDataWriter& writer, uint32_t blobIndex, const Il2CppType* type);
#endif

		Il2CppPropertyDefinition* GetPropertyDefinitionFromIndex(PropertyIndex index)
		{
			IL2CPP_ASSERT(index > 0 && index <= (int32_t)_propeties.size());
			PropertyDetail& pd = _propeties[(uint32_t)index - 1];
			return &pd.il2cppDefinition;
		}

		Il2CppMetadataPropertyInfo GetPropertyInfo(const Il2CppClass* klass, TypePropertyIndex index)
		{
			const Il2CppTypeDefinition* typeDef = (Il2CppTypeDefinition*)klass->typeMetadataHandle;
			IL2CPP_ASSERT(typeDef->propertyStart);
			uint32_t rowIndex = DecodeMetadataIndex(typeDef->propertyStart) + index;
			PropertyDetail& pd = _propeties[rowIndex - 1];
			uint32_t baseMethodIdx = DecodeMetadataIndex(typeDef->methodStart) + 1;
#if UNITY_ENGINE_TUANJIE
			const MethodInfo* getter = pd.getterMethodIndex ? il2cpp::vm::Class::GetOrSetupOneMethod(const_cast<Il2CppClass*>(klass), pd.getterMethodIndex - baseMethodIdx) : nullptr;
			const MethodInfo* setter = pd.setterMethodIndex ? il2cpp::vm::Class::GetOrSetupOneMethod(const_cast<Il2CppClass*>(klass), pd.setterMethodIndex - baseMethodIdx) : nullptr;
#else
			const MethodInfo* getter = pd.getterMethodIndex ? klass->methods[pd.getterMethodIndex - baseMethodIdx] : nullptr;
			const MethodInfo* setter = pd.setterMethodIndex ? klass->methods[pd.setterMethodIndex - baseMethodIdx] : nullptr;
#endif
			return { pd.name, getter, setter, pd.flags, EncodeToken(TableType::PROPERTY, rowIndex) };
		}

#ifdef HYBRIDCLR_UNITY_2019
		const Il2CppEventDefinition* GetEventDefinitionFromIndex(EventIndex index)
		{
			IL2CPP_ASSERT(index > 0 && index <= (int32_t)_events.size());
			EventDetail& pd = _events[index - 1];
			return &pd.il2cppDefinition;
		}
#endif


		Il2CppMetadataEventInfo GetEventInfo(const Il2CppClass* klass, TypeEventIndex index)
		{
			const Il2CppTypeDefinition* typeDef = (Il2CppTypeDefinition*)klass->typeMetadataHandle;
			IL2CPP_ASSERT(typeDef->eventStart);
			uint32_t rowIndex = DecodeMetadataIndex(typeDef->eventStart) + index;
			EventDetail& pd = _events[rowIndex - 1];
			uint32_t baseMethodIdx = DecodeMetadataIndex(typeDef->methodStart) + 1;
#if UNITY_ENGINE_TUANJIE
			const MethodInfo* addOn = pd.addMethodIndex ? il2cpp::vm::Class::GetOrSetupOneMethod(const_cast<Il2CppClass*>(klass), pd.addMethodIndex - baseMethodIdx) : nullptr;
			const MethodInfo* removeOn = pd.removeMethodIndex ? il2cpp::vm::Class::GetOrSetupOneMethod(const_cast<Il2CppClass*>(klass), pd.removeMethodIndex - baseMethodIdx) : nullptr;
			const MethodInfo* raiseOn = pd.fireMethodIndex ? il2cpp::vm::Class::GetOrSetupOneMethod(const_cast<Il2CppClass*>(klass), pd.fireMethodIndex - baseMethodIdx) : nullptr;
#else
			const MethodInfo* addOn = pd.addMethodIndex ? klass->methods[pd.addMethodIndex - baseMethodIdx] : nullptr;
			const MethodInfo* removeOn = pd.removeMethodIndex ? klass->methods[pd.removeMethodIndex - baseMethodIdx] : nullptr;
			const MethodInfo* raiseOn = pd.fireMethodIndex ? klass->methods[pd.fireMethodIndex - baseMethodIdx] : nullptr;
#endif
			return { pd.name, &klass->byval_arg, addOn, removeOn, raiseOn, EncodeToken(TableType::EVENT, rowIndex) };
		}

		const Il2CppAssembly* GetReferencedAssembly(int32_t referencedAssemblyTableIndex, const Il2CppAssembly assembliesTable[], int assembliesCount);

		Il2CppMetadataCustomAttributeHandle GetCustomAttributeTypeToken(uint32_t token)
		{
			auto it = _tokenCustomAttributes.find(token);
			return it != _tokenCustomAttributes.end() ? (Il2CppMetadataCustomAttributeHandle)&_customAttributeHandles[DecodeMetadataIndex(it->second.typeRangeIndex)] : nullptr;
		}

		CustomAttributeIndex GetCustomAttributeIndex(uint32_t token)
		{
			auto it = _tokenCustomAttributes.find(token);
			return it != _tokenCustomAttributes.end() ? it->second.typeRangeIndex : kCustomAttributeIndexInvalid;
		}

#if !HYBRIDCLR_UNITY_2021_OR_NEW
		std::tuple<void*, void*> GetCustomAttributeDataRange(uint32_t token)
		{
			const Il2CppCustomAttributeTypeRange* dataRangeCur = (const Il2CppCustomAttributeTypeRange*)GetCustomAttributeTypeToken(token);
			CustomAttributeIndex curIndex = DecodeMetadataIndex(GET_CUSTOM_ATTRIBUTE_TYPE_RANGE_START(*dataRangeCur));
			CustomAttributeIndex nextIndex = DecodeMetadataIndex(GET_CUSTOM_ATTRIBUTE_TYPE_RANGE_START(*(dataRangeCur + 1)));
			CustomAttribute& curCa = _customAttribues[curIndex];
			CustomAttribute& nextCa = _customAttribues[nextIndex];
			return std::tuple<void*, void*>((void*)_rawImage->GetBlobReaderByRawIndex(curCa.value).GetData(), (void*)_rawImage->GetBlobReaderByRawIndex(nextCa.value).GetData());
		}

		CustomAttributesCache* GenerateCustomAttributesCacheInternal(const Il2CppCustomAttributeTypeRange* typeRange)
		{
			CustomAttributeIndex index = (CustomAttributeIndex)(typeRange - (const Il2CppCustomAttributeTypeRange*)&_customAttributeHandles[0]);
			IL2CPP_ASSERT(index >= 0 && index < (CustomAttributeIndex)_customAttributeHandles.size());
			return GenerateCustomAttributesCacheInternal(index);
		}

		bool HasAttribute(CustomAttributeIndex index, Il2CppClass* attribute)
		{
			const Il2CppCustomAttributeTypeRange* typeRange = &_customAttributeHandles[DecodeMetadataIndex(index)];
			return HasAttribute(typeRange, attribute);
		}

		bool HasAttribute(const Il2CppCustomAttributeTypeRange* typeRange, Il2CppClass* attribute)
		{
			CustomAttributesCache* attrCache = GenerateCustomAttributesCacheInternal(typeRange);
			return HasAttribute(attrCache, attribute);
		}

		bool HasAttributeByToken(uint32_t token, Il2CppClass* attribute)
		{
			CustomAttributeIndex index = GetCustomAttributeIndex(token);
			if (index == kCustomAttributeIndexInvalid)
			{
				return false;
			}
			CustomAttributesCache* attrCache = GenerateCustomAttributesCacheInternal(DecodeMetadataIndex(index));
			return HasAttribute(attrCache, attribute);
		}

		bool HasAttribute(CustomAttributesCache* attrCache, Il2CppClass* attribute)
		{
			for (int i = 0; i < attrCache->count; i++)
			{
				Il2CppObject* attrObj = attrCache->attributes[i];
				if (il2cpp::vm::Class::IsAssignableFrom(attribute, attrObj->klass))
				{
					return true;
				}
			}
			return false;
		}

		CustomAttributesCache* GenerateCustomAttributesCacheInternal(CustomAttributeIndex index);
#else

		void InitCustomAttributeData(CustomAttributesInfo& cai, const Il2CppCustomAttributeTypeRange& dataRange);
			
		il2cpp::metadata::CustomAttributeDataReader CreateCustomAttributeDataReader(Il2CppMetadataCustomAttributeHandle handle)
		{
			const Il2CppCustomAttributeTypeRange* dataRange = (const Il2CppCustomAttributeTypeRange*)handle;
			IL2CPP_ASSERT(_tokenCustomAttributes.find(dataRange->token) != _tokenCustomAttributes.end());
			CustomAttributesInfo& cai = _tokenCustomAttributes[dataRange->token];
			if (!cai.inited)
			{
				InitCustomAttributeData(cai, *dataRange);
			}
#if HYBRIDCLR_UNITY_2022_OR_NEW
			return il2cpp::metadata::CustomAttributeDataReader(_il2cppImage, cai.dataStartPtr, cai.dataEndPtr);
#else
			return il2cpp::metadata::CustomAttributeDataReader(cai.dataStartPtr, cai.dataEndPtr);
#endif
		}

		std::tuple<void*, void*> CreateCustomAttributeDataTuple(const Il2CppCustomAttributeDataRange* dataRange)
		{
			IL2CPP_ASSERT(_tokenCustomAttributes.find(dataRange->token) != _tokenCustomAttributes.end());
			CustomAttributesInfo& cai = _tokenCustomAttributes[dataRange->token];
			if (!cai.inited)
			{
				InitCustomAttributeData(cai, *dataRange);
			}
			return std::tuple<void*, void*>(cai.dataStartPtr, cai.dataEndPtr);
		}

		std::tuple<void*, void*> CreateCustomAttributeDataTupleByToken(uint32_t token)
		{
			const Il2CppCustomAttributeTypeRange* dataRangeCur = (const Il2CppCustomAttributeTypeRange*)GetCustomAttributeTypeToken(token);
			return dataRangeCur ? CreateCustomAttributeDataTuple(dataRangeCur) : std::tuple<void*, void*>(nullptr, nullptr);
		}

#if !HYBRIDCLR_UNITY_2022_OR_NEW
		CustomAttributesCache* GenerateCustomAttributesCacheInternal(const Il2CppCustomAttributeTypeRange* typeRange)
		{
			CustomAttributeIndex index = (CustomAttributeIndex)(typeRange - (const Il2CppCustomAttributeTypeRange*)&_customAttributeHandles[0]);
			IL2CPP_ASSERT(index >= 0 && index < (CustomAttributeIndex)_customAttributeHandles.size());
			return GenerateCustomAttributesCacheInternal(index);
		}

		CustomAttributesCache* GenerateCustomAttributesCacheInternal(CustomAttributeIndex index);
#endif

		void BuildCustomAttributesData(CustomAttributesInfo& cai, const Il2CppCustomAttributeTypeRange& typeRange);
		void ConvertILCustomAttributeData2Il2CppFormat(const MethodInfo* ctorMethod, BlobReader& reader);
		void ConvertFixedArg(CustomAttributeDataWriter& writer, BlobReader& reader, const Il2CppType* type, bool writeType);
		void ConvertBoxedValue(CustomAttributeDataWriter& writer, BlobReader& reader, bool writeType);
		void ConvertSystemType(CustomAttributeDataWriter& writer, BlobReader& reader, bool writeType);
		void WriteEncodeTypeEnum(CustomAttributeDataWriter& writer, const Il2CppType* type);
		void GetFieldDeclaringTypeIndexAndFieldIndexByName(const Il2CppTypeDefinition* declaringType, const char* name, int32_t& typeIndex, int32_t& fieldIndex);
		void GetPropertyDeclaringTypeIndexAndPropertyIndexByName(const Il2CppTypeDefinition* declaringType, const char* name, int32_t& typeIndex, int32_t& fieldIndex);
#endif

		ImplMapInfo* GetImplMapInfo(uint32_t token)
		{
			auto it = _implMapInfos.find(token);
			return it != _implMapInfos.end() ? &it->second : nullptr;
		}

		Il2CppClass* GetTypeInfoFromTypeDefinitionRawIndex(uint32_t index);

		const Il2CppType* GetInterfaceFromGlobalOffset(TypeInterfaceIndex offset);
		const Il2CppType* GetInterfaceFromIndex(const Il2CppClass* klass, TypeInterfaceIndex index);
		const Il2CppType* GetInterfaceFromOffset(const Il2CppClass* klass, TypeInterfaceIndex offset);
		const Il2CppType* GetInterfaceFromOffset(const Il2CppTypeDefinition* typeDefine, TypeInterfaceIndex offset);

		Il2CppInterfaceOffsetInfo GetInterfaceOffsetInfo(const Il2CppTypeDefinition* typeDefine, TypeInterfaceOffsetIndex index);

		uint32_t AddIl2CppTypeCache(const Il2CppType* type);

		uint32_t AddIl2CppGenericContainers(Il2CppGenericContainer& geneContainer);

		const Il2CppType* GetModuleIl2CppType(uint32_t moduleRowIndex, uint32_t typeNamespace, uint32_t typeName, bool raiseExceptionIfNotFound) override;
		void ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret) override;
		void ReadMethodDefSig(BlobReader& reader, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer, Il2CppMethodDefinition& methodDef, std::vector<ParamDetail>& paramArr);

		void InitBasic(Il2CppImage* image);
		void BuildIl2CppImage(Il2CppImage* image);
		void BuildIl2CppAssembly(Il2CppAssembly* assembly);

		void InitRuntimeMetadatas() override;
	protected:

		void InitTypeDefs_0();
		void InitTypeDefs_1();
		void InitTypeDefs_2();
		void InitConsts();

		void InitClass();

		void InitParamDefs();
		void InitGenericParamConstraintDefs();
		void InitGenericParamDefs0();
		void InitGenericParamDefs();
		void InitFieldDefs();
		void InitFieldLayouts();
		void InitFieldRVAs();
		void InitBlittables();
		void InitMethodDefs0();
		void InitMethodDefs();
		void InitMethodImpls0();
		void InitNestedClass();
		void InitClassLayouts0();
		void InitClassLayouts();
		void InitCustomAttributes();
		void InitModuleRefs();
		void InitImplMaps();
		void InitProperties();
		void InitEvents();
		void InitMethodSemantics();
		void InitInterfaces();
		void InitVTables();

		void ComputeBlittable(Il2CppTypeDefinition* def, std::vector<bool>& computFlags);
		void ComputeVTable(TypeDefinitionDetail* tdd);

		void SetIl2CppImage(Il2CppImage* image)
		{
			_il2cppImage = image;
		}

		Il2CppString* ReadSerString(BlobReader& reader);
#if HYBRIDCLR_UNITY_2021_OR_NEW
		bool ReadUTF8SerString(BlobReader& reader, std::string& s);
#endif
		Il2CppReflectionType* ReadSystemType(BlobReader& reader);
		Il2CppObject* ReadBoxedValue(BlobReader& reader);
		void ReadFixedArg(BlobReader& reader, const Il2CppType* argType, void* data);
		void ReadCustomAttributeFieldOrPropType(BlobReader& reader, Il2CppType& type);
#if !HYBRIDCLR_UNITY_2021_OR_NEW
		void ConstructCustomAttribute(BlobReader& reader, Il2CppObject* obj, const MethodInfo* ctorMethod);
#endif


		bool _inited;
		Il2CppImage* _il2cppImage;
		const uint32_t _index;

		std::vector<TypeDefinitionDetail> _typeDetails;
		std::vector<Il2CppTypeDefinition> _typesDefines;
		std::vector<Il2CppTypeDefinition> _exportedTypeDefines;

		std::vector<const Il2CppType*> _types;
		Il2CppHashMap<const Il2CppType*, uint32_t, Il2CppTypeHashShallow, Il2CppTypeEqualityComparerShallow> _type2Indexs;
		std::vector<TypeIndex> _interfaceDefines;
		std::vector<InterfaceOffsetInfo> _interfaceOffsets;

		std::vector<Il2CppMethodDefinition> _methodDefines;

		std::vector<ParamDetail> _params;
		std::vector<int32_t>* _paramRawIndex2ActualParamIndex; // rawIindex = rowIndex - 1; because local function, param list count maybe less than actual method param count
		std::vector<Il2CppParameterDefaultValue> _paramDefaultValues;

		std::vector<Il2CppGenericParameter> _genericParams;
		std::vector<TypeIndex> _genericConstraints; // raw TypeIndex
		std::vector<Il2CppGenericContainer> _genericContainers;

		std::vector<FieldDetail> _fieldDetails;
		std::vector<Il2CppFieldDefaultValue> _fieldDefaultValues;

		std::unordered_map<uint32_t, TbClassLayout> _classLayouts;
		std::vector<uint32_t> _nestedTypeDefineIndexs;

		// runtime data 
		std::vector<Il2CppClass*> _classList;
		Il2CppType2TypeDeclaringTreeMap _cacheTrees;
#if HYBRIDCLR_UNITY_2021_OR_NEW
		CustomAttributeDataWriter _constValues;
#endif


		std::unordered_map<uint32_t, CustomAttributesInfo> _tokenCustomAttributes;
		std::vector<Il2CppCustomAttributeTypeRange> _customAttributeHandles;
#if !HYBRIDCLR_UNITY_2022_OR_NEW
		std::vector<CustomAttributesCache*> _customAttribtesCaches;
#endif
#if HYBRIDCLR_UNITY_2021_OR_NEW
		CustomAttributeDataWriter _il2cppFormatCustomDataBlob;
		CustomAttributeDataWriter _tempCtorArgBlob;
		CustomAttributeDataWriter _tempFieldBlob;
		CustomAttributeDataWriter _tempPropertyBlob;
#endif
		std::vector<CustomAttribute> _customAttribues;

		std::vector<PropertyDetail> _propeties;
		std::vector<EventDetail> _events;

		std::vector<const char*> _moduleRefs;
		std::unordered_map<uint32_t, ImplMapInfo> _implMapInfos;
	};
}
}
```

`hybridclr/metadata/MetadataDef.h`:

```h
#pragma once

#include "il2cpp-config.h"

#include "Coff.h"
#include "Tables.h"

namespace hybridclr
{
namespace metadata
{

	enum class CorILMethodFormat : uint8_t
	{
		Tiny = 0x2,
		Fat = 0x3,
		MoreSects = 0x8,
		InitLocals = 0x10,
	};

	enum class CorILSecion : uint8_t
	{
		EHTable = 0x1,
		OptILTable = 0x2,
		FatFormat = 0x40,
		MoreSects = 0x80,
	};

	enum class CorILExceptionClauseType
	{
		Exception = 0,
		Filter = 1,
		Finally = 2,
		Fault = 4,
	};

	struct CorILMethodFatHeader
	{
		uint16_t flags : 12;
		uint16_t size : 4;
		uint16_t maxStack;
		uint32_t codeSize;
		uint32_t localVarSigToken;
	};

	struct CorILEHSmall
	{
		uint16_t flags;
		uint16_t tryOffset;
		uint8_t tryLength;
		uint8_t handlerOffset0;
		uint8_t handlerOffset1;
		uint8_t handlerLength;
		uint32_t classTokenOrFilterOffset;
	};

	static_assert(sizeof(CorILEHSmall) == 12, "sizeof(CorILEHSmall) != 12");

	struct CorILEHFat
	{
		uint32_t flags;
		uint32_t tryOffset;
		uint32_t tryLength;
		uint32_t handlerOffset;
		uint32_t handlerLength;
		uint32_t classTokenOrFilterOffset;
	};

	static_assert(sizeof(CorILEHFat) == 24, "sizeof(CorILEHFat) != 24");

	struct CorILEHSectionHeaderSmall
	{
		uint8_t kind;
		uint8_t dataSize;
		uint16_t reserved;
		CorILEHSmall clauses[0];
	};

#pragma pack(push, 1)
	struct CorILEHSectionHeaderFat
	{
		uint8_t kind;
		uint8_t dataSize0;
		uint8_t dataSize1;
		uint8_t dataSize2;
		CorILEHFat clauses[0];
	};
#pragma pack(pop)

	const int MAX_TABLE_INDEX = 0x37;
	const int TABLE_NUM = MAX_TABLE_INDEX + 1;

	class TagBits
	{
	public:
		static const uint32_t TypeDefOrRef = 2;
		static const uint32_t HasConstant = 2;
		static const uint32_t HasCustomAttribute = 5;
		static const uint32_t HasFieldMarshal = 1;
		static const uint32_t HasDeclSecurity = 2;
		static const uint32_t MemberRefParent = 3;
		static const uint32_t HasSemantics = 1;
		static const uint32_t MethodDefOrRef = 1;
		static const uint32_t MemberForwarded = 1;
		static const uint32_t Implementation = 2;
		static const uint32_t CustomAttributeType = 3;
		static const uint32_t ResoulutionScope = 2;
		static const uint32_t TypeOrMethodDef = 1;
		static const uint32_t HasCustomDebugInformation = 5;

	};


	const TableType HasCustomAttributeAssociateTables[] = {
		TableType::METHOD,
		TableType::FIELD,
		TableType::TYPEREF,
		TableType::TYPEDEF,
		TableType::PARAM,
		TableType::INTERFACEIMPL,
		TableType::MEMBERREF,
		TableType::MODULE,
		TableType::DECLSECURITY,
		TableType::PROPERTY,
		TableType::EVENT,
		TableType::STANDALONESIG,
		TableType::MODULEREF,
		TableType::TYPESPEC,
		TableType::ASSEMBLY,
		TableType::ASSEMBLYREF,
		TableType::FILE,
		TableType::EXPORTEDTYPE,
		TableType::MANIFESTRESOURCE,
		TableType::GENERICPARAM,
		TableType::GENERICPARAMCONSTRAINT,
		TableType::METHODSPEC,
	};

	const TableType HasCustomDebugInformation[] = {
		TableType::METHOD,
		TableType::FIELD,
		TableType::TYPEREF,
		TableType::TYPEDEF,
		TableType::PARAM,
		TableType::INTERFACEIMPL,
		TableType::MEMBERREF,
		TableType::MODULE,
		TableType::DECLSECURITY,
		TableType::PROPERTY,
		TableType::EVENT,
		TableType::STANDALONESIG,
		TableType::MODULEREF,
		TableType::TYPESPEC,
		TableType::ASSEMBLY,
		TableType::ASSEMBLYREF,
		TableType::FILE,
		TableType::EXPORTEDTYPE,
		TableType::MANIFESTRESOURCE,
		TableType::GENERICPARAM,
		TableType::GENERICPARAMCONSTRAINT,
		TableType::METHODSPEC,
		TableType::DOCUMENT,
		TableType::LOCALSCOPE,
		TableType::LOCALVARIABLE,
		TableType::LOCALCONSTANT,
		TableType::IMPORTSCOPE,
	};

	inline TableType DecodeTokenTableType(uint32_t index)
	{
		return TableType(index >> 24);
	}

	inline uint32_t DecodeTokenRowIndex(uint32_t index)
	{
		return index & 0xFFFFFF;
	}

	struct SectionHeader
	{
		uint32_t virtualAddressBegin;
		uint32_t virtualAddressEnd;
		uint32_t ptrRawDataRelatedToVirtualAddress;
	};

	struct ColumnOffsetSize
	{
		uint32_t size;
		uint16_t offset;
	};

	enum class SigType
	{
		DEFAULT = 0,
		C = 1,
		ST_STDCALL = 2,
		ST_THISCALL = 3,
		ST_FASTCALL = 4,
		VARARG = 5,
		FIELD = 6,
		LOCAL_VAR = 7,
		PROPERTY_NOT_THIS = 8,
		GENERIC = 0x10,
		SENTINEL = 0x41,
	};

	const uint32_t kSigMask = 0x0F;

	inline SigType DecodeSigType(uint8_t rawSigType)
	{
		return (SigType)(rawSigType & kSigMask);
	}

	inline uint8_t DecodeSigFlags(uint8_t rawSigType)
	{
		return (uint8_t)(rawSigType & 0xF0);
	}

	inline uint32_t EncodeToken(TableType type, uint32_t index)
	{
		return ((uint32_t)type << 24) | index;
	}

	inline void DecodeToken(uint32_t token, TableType& type, uint32_t& rowIndex)
	{
		type = (TableType)(token >> 24);
		rowIndex = token & 0xFFFFFF;
	}

	enum class MethodSigFlags
	{
		HAS_THIS = 0x20,
		EXPLICITTHIS = 0x40,
		DEFAULT = 0x0,
		VARARG = 0x5,
		GENERIC = 0x10,
	};

	inline Il2CppTypeEnum GetElementType(Il2CppTypeEnum encodeType)
	{
		return (Il2CppTypeEnum)((uint8_t)encodeType & 0x3f);
	}

	inline TableType DecodeTypeDefOrRefOrSpecCodedIndexTableType(uint32_t encodedToken)
	{
		switch (encodedToken & 0x3)
		{
		case 0: return TableType::TYPEDEF;
		case 1: return TableType::TYPEREF;
		case 2: return  TableType::TYPESPEC;
		default: IL2CPP_ASSERT(false); return (TableType)-1;
		}
	}

	inline uint32_t DecodeTypeDefOrRefOrSpecCodedIndexRowIndex(uint32_t encodedToken)
	{
		return encodedToken >> 2;
	}

	inline uint32_t EncodeTypeDefOrRefOrSpecCodedIndex(TableType type, uint32_t rowIndex)
	{
		uint32_t tableBits;
		switch (type)
		{
		case TableType::TYPEDEF: tableBits = 0; break;
		case TableType::TYPEREF: tableBits = 1; break;
		case TableType::TYPESPEC: tableBits = 2; break;
		default: IL2CPP_ASSERT(0); tableBits = 0; break;
		}
		return (rowIndex << 2) | tableBits;
	}

	inline uint32_t ConvertTypeDefOrRefOrSpecToken2CodedIndex(uint32_t token)
	{
		TableType type;
		uint32_t rowIndex;
		DecodeToken(token, type, rowIndex);

		uint32_t tableBits;
		switch (type)
		{
		case TableType::TYPEDEF: tableBits = 0; break;
		case TableType::TYPEREF: tableBits = 1; break;
		case TableType::TYPESPEC: tableBits = 2; break;
		default: IL2CPP_ASSERT(0); tableBits = 0; break;
		}
		return (rowIndex << 2) | tableBits;
	}

	inline void DecodeResolutionScopeCodedIndex(uint32_t encodedToken, TableType& tokenType, uint32_t& rawIndex)
	{
		switch (encodedToken & 0x3)
		{
		case 0: tokenType = TableType::MODULE; break;
		case 1: tokenType = TableType::MODULEREF; break;
		case 2: tokenType = TableType::ASSEMBLYREF; break;
		case 3: tokenType = TableType::TYPEREF; break;
		}
		rawIndex = encodedToken >> 2;
	}

	inline TableType DecodeTypeOrMethodDefCodedIndexTableType(uint32_t encodeIndex)
	{
		switch (encodeIndex & 0x1)
		{
		case 0: return TableType::TYPEDEF;
		case 1: return TableType::METHOD;
		}
		IL2CPP_ASSERT(false);
		return (TableType)-1;
	}

	inline uint32_t DecodeTypeOrMethodDefCodedIndexRowIndex(uint32_t encodeIndex)
	{
		return encodeIndex >> 1;
	}

	inline TableType DecodeMethodDefOrRefCodedIndexTableType(uint32_t token)
	{
		switch (token & 0x1)
		{
		case 0: return TableType::METHOD;
		case 1: return TableType::MEMBERREF;
		}
		return (TableType)-1;
	}

	inline uint32_t DecodeMethodDefOrRefCodedIndexRowIndex(uint32_t token)
	{
		return token >> 1;
	}

	inline uint32_t EncodeMethodDefOrRefCodedIndex(TableType type, uint32_t rowIndex)
	{
		IL2CPP_ASSERT(type == TableType::METHOD || type == TableType::MEMBERREF);
		return (rowIndex << 1) | (type != TableType::METHOD);
	}

	inline uint32_t ConvertMethodDefOrRefToken2CodedIndex(uint32_t token)
	{
		TableType type;
		uint32_t rowIndex;
		DecodeToken(token, type, rowIndex);
		return EncodeMethodDefOrRefCodedIndex(type, rowIndex);
	}

	inline TableType DecodeMemberRefParentType(uint32_t token)
	{
		switch (token & 0x7)
		{
		case 0: return TableType::TYPEDEF;
		case 1: return TableType::TYPEREF;
		case 2: return TableType::MODULEREF;
		case 3: return TableType::METHOD;
		case 4: return TableType::TYPESPEC;
		default: IL2CPP_ASSERT(false); return (TableType)-1;
		}
	}

	inline uint32_t DecodeMemberRefParentRowIndex(uint32_t token)
	{
		return token >> 3;
	}

	inline TableType DecodeFieldDefOrDefType(uint32_t encodeIndex)
	{
		switch (encodeIndex & 0x1)
		{
		case 0: return TableType::FIELD;
		case 1: return TableType::MEMBERREF;
		}
		return (TableType)-1;
	}

	inline uint32_t DecodeFieldDefOrDefTypeRowIndex(uint32_t encodeIndex)
	{
		return encodeIndex >> 1;
	}

	inline uint32_t EncodeFieldDefOrRefCodedIndex(TableType type, uint32_t rowIndex)
	{
		IL2CPP_ASSERT(type == TableType::FIELD || type == TableType::MEMBERREF);
		return (rowIndex << 1) | (type != TableType::FIELD);
	}

	inline uint32_t ConvertFieldDefOrRefToken2CodedIndex(uint32_t token)
	{
		TableType type;
		uint32_t rowIndex;
		DecodeToken(token, type, rowIndex);
		return EncodeFieldDefOrRefCodedIndex(type, rowIndex);
	}

	inline TableType DecodeMemberRefParentCodedIndexTableType(uint32_t encodeIndex)
	{
		switch ((encodeIndex & 0x7))
		{
		case 0: return TableType::TYPEDEF;
		case 1: return TableType::TYPEREF;
		case 2: return TableType::MODULEREF;
		case 3: return TableType::METHOD;
		case 4: return TableType::TYPESPEC;
		default: IL2CPP_ASSERT(false); return (TableType)-1;
		}
	}

	inline uint32_t DecodeMemberRefParentCodedIndexRowIndex(uint32_t encodeIndex)
	{
		return encodeIndex >> 3;
	}

	inline TableType DecodeHasCustomAttributeCodedIndexTableType(uint32_t codedIndex)
	{
		switch (codedIndex & 0x1f)
		{
		case 0: return TableType::METHOD;
		case 1: return TableType::FIELD;
		case 2: return TableType::TYPEREF;
		case 3: return TableType::TYPEDEF;
		case 4: return TableType::PARAM;
		case 5: return TableType::INTERFACEIMPL;
		case 6: return TableType::MEMBERREF;
		case 7: return TableType::MODULE;
		case 8: return TableType::DECLSECURITY;
		case 9: return TableType::PROPERTY;
		case 10: return TableType::EVENT;
		case 11: return TableType::STANDALONESIG;
		case 12: return TableType::MODULEREF;
		case 13: return TableType::TYPESPEC;
		case 14: return TableType::ASSEMBLY;
		case 15: return TableType::ASSEMBLYREF;
		case 16: return TableType::FILE;
		case 17: return TableType::EXPORTEDTYPE;
		case 18: return TableType::MANIFESTRESOURCE;
		case 19: return TableType::GENERICPARAM;
		case 20: return TableType::GENERICPARAMCONSTRAINT;
		case 21: return TableType::METHODSPEC;
		default: IL2CPP_ASSERT(false); return (TableType)-1;
		}
	}

	inline uint32_t DecodeHasCustomAttributeCodedIndexRowIndex(uint32_t codedIndex)
	{
		return codedIndex >> 5;
	}

	inline TableType DecodeCustomAttributeTypeCodedIndexTableType(uint32_t codeIndex)
	{
		switch (codeIndex & 0x7)
		{
		case 2: return TableType::METHOD;
		case 3: return TableType::MEMBERREF;
		default: IL2CPP_ASSERT(false); return (TableType)-1;
		}
	}

	inline uint32_t DecodeCustomAttributeTypeCodedIndexRowIndex(uint32_t codedIndex)
	{
		return codedIndex >> 3;
	}

	inline uint32_t ConvertMemberForwardedToken2Token(uint32_t memberForwardedToken)
	{
		TableType tableType = memberForwardedToken & 0x1 ? TableType::METHOD : TableType::FIELD;
		uint32_t rowIndex = memberForwardedToken >> 1;
		return EncodeToken(tableType, rowIndex);
	}

	enum class UserStringEncoding
	{
		ASCII = 0,
		Unicode = 1,
	};

	struct ExceptionClause
	{
		CorILExceptionClauseType flags;
		uint32_t tryOffset;
		uint32_t tryLength;
		uint32_t handlerOffsets;
		uint32_t handlerLength;
		uint32_t classTokenOrFilterOffset;
	};

	struct MethodBody
	{
		uint32_t flags;
		uint32_t codeSize;
		const uint8_t* ilcodes;
		uint32_t maxStack;
		std::vector<ExceptionClause> exceptionClauses;
		il2cpp::utils::dynamic_array<const Il2CppType*> localVars;
		// optional data sections
	};



	struct MethodRefInfo
	{
		const Il2CppType* containerType; // maybe generic
		const Il2CppMethodDefinition* methodDef;
		const Il2CppGenericInst* instantiation;
	};

	struct MethodImpl
	{
		MethodRefInfo body;
		MethodRefInfo declaration;
	};

	struct MethodDefSig
	{
		const Il2CppType* classType;
		const char* name;
		uint32_t flags;
		uint32_t genericParamCount;
		const Il2CppType* returnType;
		il2cpp::utils::dynamic_array<const Il2CppType*> params;
	};

	struct MethodRefSig
	{
		uint32_t flags;
		uint32_t genericParamCount;
		const Il2CppType* returnType;
		il2cpp::utils::dynamic_array<const Il2CppType*> params;
	};

	struct FieldRefSig
	{
		const Il2CppType* type;
	};

	struct FieldRefInfo
	{
		const Il2CppType* containerType; // maybe generic
		const Il2CppFieldDefinition* field;
	};

	struct ResolveModuleRef
	{

	};

	struct ResolveMethodDef
	{
		const Il2CppMethodDefinition* methodDef;
	};

	struct ResolveMemberRefParent
	{
		TableType parentType;
		const Il2CppType* type; // TYPEREF, TYPEDEF,TYPESPEC
		ResolveModuleRef moduleRef;
		ResolveMethodDef methodDef;
	};

	struct ResolveMemberRefSig
	{
		TableType memberType; // FIELDPTR OR METHODPTR
		MethodRefSig method;
		FieldRefSig field;
	};

	struct ResolveMemberRef
	{
		ResolveMemberRefParent parent;
		const char* name;
		ResolveMemberRefSig signature;
	};

	struct MemberRefInfo
	{
		TableType memberType;
		MethodRefInfo method;
		FieldRefInfo field;
	};

	struct ResolveStandAloneMethodSig
	{
		int32_t flags;
		const Il2CppType* returnType;
		il2cpp::utils::dynamic_array<const Il2CppType*> params;
	};

	inline TableType DecodeHasConstantType(uint32_t token)
	{
		switch (token & 0x3)
		{
		case 0: return TableType::FIELD;
		case 1: return TableType::PARAM;
		case 2: return TableType::PROPERTY;
		default: IL2CPP_ASSERT(false); return (TableType)-1;
			break;
		}
	}

	inline uint32_t DecodeHashConstantIndex(uint32_t token)
	{
		return token >> 2;
	}

	enum class MethodSemanticsAttributes
	{
		Setter = 0x1,
		Getter = 0x2,
		Other = 0x4,
		AddOn = 0x8,
		RemoveOn = 0x10,
		Fire = 0x20,
	};

	inline TableType DecodeHasSemanticsCodedIndexTableType(uint32_t codedIndex)
	{
		switch (codedIndex & 0x1)
		{
		case 0: return TableType::EVENT;
		case 1: return TableType::PROPERTY;
		}
		return (TableType)-1;
	}

	inline uint32_t DecodeHasSemanticsCodedIndexRowIndex(uint32_t codedIndex)
	{
		return codedIndex >> 1;
	}
}
}
```

`hybridclr/metadata/MetadataModule.cpp`:

```cpp
#include "MetadataModule.h"

#include "os/Atomic.h"
#include "os/Mutex.h"
#include "os/File.h"
#include "vm/Exception.h"
#include "vm/String.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/Image.h"
#include "vm/MetadataLock.h"
#include "utils/Logging.h"
#include "utils/MemoryMappedFile.h"
#include "utils/Memory.h"

#include "../interpreter/InterpreterModule.h"

#include "Assembly.h"
#include "InterpreterImage.h"
#include "ConsistentAOTHomologousImage.h"
#include "SuperSetAOTHomologousImage.h"
#include "MetadataPool.h"

using namespace il2cpp;

namespace hybridclr
{

namespace metadata
{



    void MetadataModule::Initialize()
    {
        MetadataPool::Initialize();
        InterpreterImage::Initialize();
        Assembly::InitializePlaceHolderAssemblies();
    }

    Image* MetadataModule::GetUnderlyingInterpreterImage(const MethodInfo* methodInfo)
    {
        return metadata::IsInterpreterMethod(methodInfo) ? hybridclr::metadata::MetadataModule::GetImage(methodInfo->klass)
            : (metadata::Image*)hybridclr::metadata::AOTHomologousImage::FindImageByAssembly(
                methodInfo->klass->rank ? il2cpp_defaults.corlib->assembly : methodInfo->klass->image->assembly);
    }
}
}

```

`hybridclr/metadata/MetadataModule.h`:

```h
#pragma once

#include "InterpreterImage.h"
#include "AOTHomologousImage.h"
#include "Assembly.h"

namespace hybridclr
{

namespace metadata
{
	class MetadataModule
	{
	public:

		static void Initialize();

		static InterpreterImage* GetImage(uint32_t imageIndex)
		{
			return InterpreterImage::GetImage(imageIndex);
		}

		static InterpreterImage* GetImage(const Il2CppImage* image)
		{
			return GetImage(DecodeImageIndex(image->token));
		}

		static InterpreterImage* GetImage(const Il2CppClass* klass)
		{
			return GetImage(klass->image);
		}

		static InterpreterImage* GetImage(const Il2CppTypeDefinition* typeDef)
		{
			return GetImage(DecodeImageIndex(typeDef->byvalTypeIndex));
		}

		static InterpreterImage* GetImage(const Il2CppMethodDefinition* method)
		{
			return GetImage(DecodeImageIndex(method->nameIndex));
		}

		static InterpreterImage* GetImage(const MethodInfo* method)
		{
			return GetImage(method->klass->image);
		}

		static InterpreterImage* GetImageByEncodedIndex(uint32_t encodedIndex)
		{
			return GetImage(DecodeImageIndex(encodedIndex));
		}
		
		static Image* GetUnderlyingInterpreterImage(const MethodInfo* method);


		static const char* GetStringFromEncodeIndex(StringIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetStringFromRawIndex(DecodeMetadataIndex(index));
		}

		static uint32_t GetTypeEncodeIndex(const Il2CppTypeDefinition* typeDef)
		{
			InterpreterImage* image = GetImage(typeDef);
			return hybridclr::metadata::EncodeImageAndMetadataIndex(image->GetIndex(), image->GetTypeRawIndex(typeDef));
		}

		static Il2CppMetadataTypeHandle GetAssemblyTypeHandleFromRawIndex(const Il2CppImage* image, AssemblyTypeIndex index)
		{
			return GetImage(image)->GetAssemblyTypeHandleFromRawIndex(index);
		}

		static Il2CppMetadataTypeHandle GetAssemblyTypeHandleFromEncodeIndex(AssemblyTypeIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetAssemblyTypeHandleFromRawIndex(DecodeMetadataIndex(index));
		}

		static Il2CppMetadataTypeHandle GetAssemblyExportedTypeHandleFromEncodeIndex(AssemblyTypeIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetAssemblyExportedTypeHandleFromRawIndex(DecodeMetadataIndex(index));
		}

		static const Il2CppTypeDefinitionSizes* GetTypeDefinitionSizesFromEncodeIndex(TypeDefinitionIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetTypeDefinitionSizesFromRawIndex(DecodeMetadataIndex(index));
		}

		static const Il2CppType* GetIl2CppTypeFromEncodeIndex(uint32_t index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			IL2CPP_ASSERT(imageIndex > 0);

			uint32_t rawIndex = DecodeMetadataIndex(index);
			return GetImage(imageIndex)->GetIl2CppTypeFromRawIndex(rawIndex);
		}

		static Il2CppClass* GetTypeInfoFromTypeDefinitionEncodeIndex(TypeDefinitionIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			IL2CPP_ASSERT(imageIndex > 0);

			uint32_t rawIndex = DecodeMetadataIndex(index);
			return GetImage(imageIndex)->GetTypeInfoFromTypeDefinitionRawIndex(rawIndex);
		}

		static const Il2CppFieldDefinition* GetFieldDefinitionFromEncodeIndex(uint32_t index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetFieldDefinitionFromRawIndex(DecodeMetadataIndex(index));
		}

		static const Il2CppMethodDefinition* GetMethodDefinitionFromIndex(MethodIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetMethodDefinitionFromRawIndex(DecodeMetadataIndex(index));
		}

		static uint32_t GetFieldOffset(const Il2CppClass* klass, int32_t fieldIndexInType, FieldInfo* field)
		{
			return GetImage(klass)->GetFieldOffset(klass, fieldIndexInType);
		}

		static const MethodInfo* GetMethodInfoFromMethodDefinitionIndex(uint32_t index)
		{
			uint32_t imageIndex = DecodeImageIndex(index);
			return GetImage(imageIndex)->GetMethodInfoFromMethodDefinitionRawIndex(DecodeMetadataIndex(index));
		}

		static const MethodInfo* GetMethodInfoFromMethodDefinition(const Il2CppMethodDefinition* methodDef)
		{
			uint32_t imageIndex = DecodeImageIndex(methodDef->nameIndex);
			return GetImage(imageIndex)->GetMethodInfoFromMethodDefinition(methodDef);
		}

		static const MethodInfo* GetMethodInfoFromVTableSlot(const Il2CppClass* klass, int32_t vTableSlot)
		{
			return GetImage(klass)->GetMethodInfoFromVTableSlot(klass, vTableSlot);
		}

		static const Il2CppMethodDefinition* GetMethodDefinitionFromVTableSlot(const Il2CppTypeDefinition* typeDefine, int32_t vTableSlot)
		{
			return GetImage(typeDefine)->GetMethodDefinitionFromVTableSlot(typeDefine, vTableSlot);
		}

		static Il2CppMethodPointer GetAdjustorThunk(const Il2CppImage* image, uint32_t token)
		{
			uint32_t imageIndex = DecodeImageIndex(image->token);
			return GetImage(imageIndex)->GetAdjustorThunk(token);
		}

		static Il2CppMethodPointer GetMethodPointer(const Il2CppImage* image, uint32_t token)
		{
			uint32_t imageIndex = DecodeImageIndex(image->token);
			return GetImage(imageIndex)->GetMethodPointer(token);
		}

		static InvokerMethod GetMethodInvoker(const Il2CppImage* image, uint32_t token)
		{
			uint32_t imageIndex = DecodeImageIndex(image->token);
			return GetImage(imageIndex)->GetMethodInvoker(token);
		}

		static const Il2CppParameterDefinition* GetParameterDefinitionFromIndex(const Il2CppImage* image, ParameterIndex index)
		{
			uint32_t imageIndex = DecodeImageIndex(image->token);
			return GetImage(imageIndex)->GetParameterDefinitionFromIndex(index);
		}

		static const Il2CppType* GetInterfaceFromIndex(const Il2CppClass* klass, TypeInterfaceIndex index)
		{
			return GetImage(klass)->GetInterfaceFromIndex(klass, index);
		}

		static const Il2CppType* GetInterfaceFromOffset(const Il2CppClass* klass, TypeInterfaceIndex offset)
		{
			return GetImage(klass)->GetInterfaceFromOffset(klass, offset);
		}

		static const Il2CppType* GetInterfaceFromOffset(const Il2CppTypeDefinition* typeDefine, TypeInterfaceIndex offset)
		{
			return GetImage(typeDefine)->GetInterfaceFromOffset(typeDefine, offset);
		}

		static Il2CppInterfaceOffsetInfo GetInterfaceOffsetInfo(const Il2CppTypeDefinition* typeDefine, TypeInterfaceOffsetIndex index)
		{
			return GetImage(typeDefine)->GetInterfaceOffsetInfo(typeDefine, index);
		}

		static Il2CppClass* GetNestedTypeFromOffset(const Il2CppClass* klass, TypeNestedTypeIndex offset)
		{
			return GetImage(klass)->GetNestedTypeFromOffset(klass, offset);
		}

		static Il2CppClass* GetNestedTypeFromOffset(const Il2CppTypeDefinition* typeDefinition, TypeNestedTypeIndex offset)
		{
			return GetImage(typeDefinition)->GetNestedTypeFromOffset(typeDefinition, offset);
		}

		static Il2CppMetadataTypeHandle GetNestedTypes(Il2CppMetadataTypeHandle handle, void** iter)
		{
			Il2CppTypeDefinition* typeDef = (Il2CppTypeDefinition*)handle;
			return (Il2CppMetadataTypeHandle)(GetImage(typeDef)->GetNestedTypes(typeDef, iter));
		}

		static const Il2CppGenericContainer* GetGenericContainerFromEncodeIndex(uint32_t index)
		{
			return GetImage(DecodeImageIndex(index))->GetGenericContainerByRawIndex(DecodeMetadataIndex(index));

		}

		static const Il2CppFieldDefaultValue* GetFieldDefaultValueEntry(uint32_t index)
		{
			return GetImage(DecodeImageIndex(index))->GetFieldDefaultValueEntryByRawIndex(DecodeMetadataIndex(index));
		}

		static const uint8_t* GetFieldOrParameterDefalutValue(uint32_t index)
		{
			return GetImage(DecodeImageIndex(index))->GetFieldOrParameterDefalutValueByRawIndex(DecodeMetadataIndex(index));
		}

#if HYBRIDCLR_UNITY_2020
		static bool HasAttribute(const Il2CppImage* image, uint32_t token, Il2CppClass* attribute)
		{
			return GetImage(image)->HasAttributeByToken(token, attribute);
		}

		static std::tuple<void*, void*> GetCustomAttributeDataRange(const Il2CppImage* image, uint32_t token)
		{
			return GetImage(image)->GetCustomAttributeDataRange(token);
		}
#endif

		static bool IsImplementedByInterpreter(MethodInfo* method)
		{
			Il2CppClass* klass = method->klass;
			Il2CppClass* parent = klass->parent;
			if (parent != il2cpp_defaults.multicastdelegate_class && parent != il2cpp_defaults.delegate_class)
			{
				return AOTHomologousImage::FindImageByAssembly(klass->image->assembly);
			}
			else
			{
				return strcmp(method->name, "Invoke") == 0;
			}
		}
	private:

	};
}

}
```

`hybridclr/metadata/MetadataPool.cpp`:

```cpp
#include "MetadataPool.h"

#include "utils/MemoryPool.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataLock.h"
#include "vm/GlobalMetadata.h"

#include "MetadataModule.h"

namespace hybridclr
{
namespace metadata
{

	using il2cpp::utils::HashUtils;

	constexpr int kMaxPrimitiveType = (int)IL2CPP_TYPE_OBJECT;

	static bool s_initializedMetadataPool = false;

	static Il2CppType s_primitiveTypes[(int)kMaxPrimitiveType + 1];
	static Il2CppType s_byRefPrimitiveTypes[(int)kMaxPrimitiveType + 1];

	class Il2CppArrayTypeHash
	{
	public:
		size_t operator()(const Il2CppArrayType* t1) const
		{
			return Hash(t1);
		}

		static size_t Hash(const Il2CppArrayType* t1);
	};

	class Il2CppTypeFullHash
	{
	public:
		size_t operator()(const Il2CppType* t1) const
		{
			return Hash(t1);
		}

		static size_t Hash(const Il2CppType* t1)
		{
			size_t hash = t1->type;

			hash = HashUtils::Combine(hash, t1->byref);

			hash = il2cpp::utils::HashUtils::Combine(hash, t1->attrs);
			//hash = il2cpp::utils::HashUtils::Combine(hash, t1->num_mods);
			hash = il2cpp::utils::HashUtils::Combine(hash, t1->pinned);
			//hash = il2cpp::utils::HashUtils::Combine(hash, t1->valuetype);

			switch (t1->type)
			{
			case IL2CPP_TYPE_VALUETYPE:
			case IL2CPP_TYPE_CLASS:
			{
				return HashUtils::Combine(hash, reinterpret_cast<size_t>(t1->data.typeHandle));
			}
			case IL2CPP_TYPE_SZARRAY:
			case IL2CPP_TYPE_PTR:
			{
				return HashUtils::Combine(hash, Hash(t1->data.type));
			}
			case IL2CPP_TYPE_ARRAY:
			{
				const Il2CppArrayType* a = t1->data.array;
				// dont' compute sizes and lobounds
				hash = HashUtils::Combine(hash, Il2CppArrayTypeHash::Hash(a));
				return hash;
			}
			case IL2CPP_TYPE_GENERICINST:
			{
				return HashUtils::Combine(hash, (size_t)t1->data.generic_class);
			}
			case IL2CPP_TYPE_VAR:
			case IL2CPP_TYPE_MVAR:
				return HashUtils::Combine(hash, reinterpret_cast<size_t>(t1->data.genericParameterHandle));
			default:
				return hash;
			}
			return hash;
		}
	};

	size_t Il2CppArrayTypeHash::Hash(const Il2CppArrayType* t1)
	{
		size_t hash = t1->rank;
		hash = HashUtils::Combine(hash, t1->numsizes);
		hash = HashUtils::Combine(hash, t1->numlobounds);
		hash = HashUtils::Combine(hash, Il2CppTypeFullHash::Hash(t1->etype));

		for (uint8_t i = 0; i < t1->numsizes; ++i)
		{
			hash = HashUtils::Combine(hash, t1->sizes[i]);
		}
		for (uint8_t i = 0; i < t1->numlobounds; ++i)
		{
			hash = HashUtils::Combine(hash, t1->lobounds[i]);
		}
		return hash;
	}

	class Il2CppArrayTypeEqualityComparer
	{
	public:
		bool operator()(const Il2CppArrayType* t1, const Il2CppArrayType* t2) const
		{
			return AreEqual(t1, t2);
		}

		static bool AreEqual(const Il2CppArrayType* t1, const Il2CppArrayType* t2);
	};

	class Il2CppTypeFullEqualityComparer
	{
	public:
		bool operator()(const Il2CppType* t1, const Il2CppType* t2) const
		{
			return AreEqual(t1, t2);
		}

		static bool AreEqual(const Il2CppType* t1, const Il2CppType* t2)
		{
			if (t1->type != t2->type)
			{
				return false;
			}

			if (t1->byref != t2->byref
				|| t1->attrs != t2->attrs
				|| t1->pinned != t2->pinned)
			{
				return false;
			}

			switch (t1->type)
			{
			case IL2CPP_TYPE_VALUETYPE:
			case IL2CPP_TYPE_CLASS:
				return t1->data.typeHandle == t2->data.typeHandle;
			case IL2CPP_TYPE_PTR:
			case IL2CPP_TYPE_SZARRAY:
				return AreEqual(t1->data.type, t2->data.type);

			case IL2CPP_TYPE_ARRAY:
			{
				const Il2CppArrayType* a1 = t1->data.array;
				const Il2CppArrayType* a2 = t2->data.array;
				return Il2CppArrayTypeEqualityComparer::AreEqual(a1, a2);
			}
			case IL2CPP_TYPE_GENERICINST:
			{
				return t1->data.generic_class == t2->data.generic_class;
			}
			case IL2CPP_TYPE_VAR:
			case IL2CPP_TYPE_MVAR:
				return t1->data.genericParameterHandle == t2->data.genericParameterHandle;
			default:
				return true;
			}
			return true;
		}
	};

	bool Il2CppArrayTypeEqualityComparer::AreEqual(const Il2CppArrayType* a1, const Il2CppArrayType* a2)
	{
		if (a1->rank != a2->rank || a1->numsizes != a2->numsizes || a1->numlobounds != a2->numlobounds)
		{
			return false;
		}
		for (uint8_t i = 0; i < a1->numsizes; ++i)
		{
			if (a1->sizes[i] != a2->sizes[i])
				return false;
		}
		for (uint8_t i = 0; i < a1->numlobounds; ++i)
		{
			if (a1->lobounds[i] != a2->lobounds[i])
				return false;
		}
		return Il2CppTypeFullEqualityComparer::AreEqual(a1->etype, a2->etype);
	}


	class Il2CppArrayTypeHash2
	{
	public:
		size_t operator()(const Il2CppArrayType* t1) const
		{
			return Hash(t1);
		}

		static size_t Hash(const Il2CppArrayType* t1)
		{
			size_t hash = t1->rank;
			hash = HashUtils::Combine(hash, Il2CppTypeFullHash::Hash(t1->etype));
			return hash;
		}
	};

	class Il2CppArrayTypeEqualityComparer2
	{
	public:
		bool operator()(const Il2CppArrayType* t1, const Il2CppArrayType* t2) const
		{
			return AreEqual(t1, t2);
		}

		static bool AreEqual(const Il2CppArrayType* a1, const Il2CppArrayType* a2)
		{
			if (a1->rank != a2->rank)
			{
				return false;
			}
			return Il2CppTypeFullEqualityComparer::AreEqual(a1->etype, a2->etype);
		}
	};


	typedef Il2CppHashSet<const Il2CppType*, Il2CppTypeFullHash, Il2CppTypeFullEqualityComparer> Il2CppTypeHashSet;
	static Il2CppTypeHashSet* s_Il2CppTypePool = nullptr;

	typedef Il2CppHashSet<const Il2CppArrayType*, Il2CppArrayTypeHash2, Il2CppArrayTypeEqualityComparer2> Il2CppArrayTypeHashSet;
	Il2CppArrayTypeHashSet* s_Il2CppArrayTypePool = nullptr;


	static void InitMetadataPool()
	{
		IL2CPP_ASSERT(!s_initializedMetadataPool);
		s_initializedMetadataPool = true;
		std::memset(s_primitiveTypes, 0, sizeof(s_primitiveTypes));
		std::memset(s_byRefPrimitiveTypes, 0, sizeof(s_byRefPrimitiveTypes));

		for (int i = 0; i <= kMaxPrimitiveType; i++)
		{
			Il2CppType& type = s_primitiveTypes[i];
			type.type = (Il2CppTypeEnum)i;
			bool isValueType = i != IL2CPP_TYPE_OBJECT && i != IL2CPP_TYPE_STRING && i != IL2CPP_TYPE_VOID;
			SET_IL2CPPTYPE_VALUE_TYPE(type, isValueType);

			Il2CppType& byRefType = s_byRefPrimitiveTypes[i];
			byRefType.type = (Il2CppTypeEnum)i;
			byRefType.byref = 1;
		}
		s_Il2CppTypePool = new Il2CppTypeHashSet();
		s_Il2CppArrayTypePool = new Il2CppArrayTypeHashSet();
	}

	static const Il2CppType* TryGetPrimitiveType(const Il2CppType& originalType)
	{
		if (!s_initializedMetadataPool)
		{
			InitMetadataPool();
		}
		if (originalType.attrs || originalType.num_mods || originalType.pinned)
		{
			return nullptr;
		}
		Il2CppTypeEnum type = originalType.type;
		switch (type)
		{
		case IL2CPP_TYPE_VOID:
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R4:
		case IL2CPP_TYPE_R8:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_OBJECT:
			return originalType.byref ? s_byRefPrimitiveTypes + (int)type : s_primitiveTypes + (int)type;
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_CLASS:
		{
			const Il2CppTypeDefinition* typeDef = (const Il2CppTypeDefinition*)originalType.data.typeHandle;
			if (typeDef)
			{
				if (originalType.byref)
				{
#if HYBRIDCLR_UNITY_2019
					return il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->byrefTypeIndex);
#endif
				}
				else
				{
					return il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->byvalTypeIndex);
				}
			}
			return nullptr;
		}
		default:
			return nullptr;
		}
	}

	void MetadataPool::Initialize()
	{
		//InitMetadataPool();

	}

	static bool NeedCache(const Il2CppType& originalType)
	{
		Il2CppTypeEnum type = originalType.type;
		switch (type)
		{
		case IL2CPP_TYPE_VOID:
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R4:
		case IL2CPP_TYPE_R8:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_OBJECT:
			return true;
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_SZARRAY:
			return NeedCache(*originalType.data.type);
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_CLASS:
		{
			return originalType.data.typeHandle == nullptr;
		}
		default:
			return false;
		}
	}

	static Il2CppType* DeepCloneIl2CppType(const Il2CppType& type)
	{
		Il2CppType* newType = MetadataMallocT<Il2CppType>();
		*newType = type;

		return newType;
	}

	const Il2CppType* MetadataPool::GetPooledIl2CppType(const Il2CppType& type)
	{
		const Il2CppType* pooledType = TryGetPrimitiveType(type);
		if (pooledType)
		{
			return pooledType;
		}

		bool needCache = NeedCache(type);

		if (needCache)
		{
			auto it = s_Il2CppTypePool->find(&type);
			if (it != s_Il2CppTypePool->end())
				return *it;
		}
		Il2CppType* newType = DeepCloneIl2CppType(type);
		if (needCache)
		{
			auto ret = s_Il2CppTypePool->insert(newType);
			IL2CPP_ASSERT(ret.second);
		}
		return newType;
	}

	Il2CppType* MetadataPool::ShallowCloneIl2CppType(const Il2CppType* type)
	{
		Il2CppType* newType = MetadataMallocT<Il2CppType>();
		*newType = *type;

		return newType;
	}

	const Il2CppArrayType* MetadataPool::GetPooledIl2CppArrayType(const Il2CppType* elementType, uint32_t rank)
	{
		Il2CppArrayType type = {};
		type.etype = elementType;
		type.rank = rank;

		bool needCache = NeedCache(*elementType);

		if (needCache)
		{
			auto it = s_Il2CppArrayTypePool->find(&type);
			if (it != s_Il2CppArrayTypePool->end())
				return *it;
		}

		Il2CppArrayType* newType = MetadataMallocT<Il2CppArrayType>();
		*newType = type;

		if (needCache)
		{
			auto ret = s_Il2CppArrayTypePool->insert(newType);
			IL2CPP_ASSERT(ret.second);
		}
		return newType;
	}
}
}
```

`hybridclr/metadata/MetadataPool.h`:

```h
#pragma once

#include "../CommonDef.h"

#include "metadata/GenericMetadata.h"
#include "vm/MetadataAlloc.h"

namespace hybridclr
{
namespace metadata
{

	template<typename T>
	T* MetadataMallocT()
	{
		return (T*)HYBRIDCLR_METADATA_MALLOC(sizeof(T));
	}

	template<typename T>
	T* MetadataCallocT(size_t count)
	{
		return (T*)HYBRIDCLR_METADATA_CALLOC(count, sizeof(T));
	}

	class MetadataPool
	{
	public:
		static void Initialize();
		static const Il2CppType* GetPooledIl2CppType(const Il2CppType& type);
		static Il2CppType* ShallowCloneIl2CppType(const Il2CppType* type);
		static const Il2CppArrayType* GetPooledIl2CppArrayType(const Il2CppType* elementType, uint32_t rank);
	};
}
}
```

`hybridclr/metadata/MetadataReader.h`:

```h
#pragma once

#include "MetadataUtil.h"

namespace hybridclr
{
namespace metadata
{
    struct ByteSpan
    {
        const byte* data;
        uint32_t length;
        ByteSpan() : data(nullptr), length(0) {}
        ByteSpan(const byte* data, uint32_t length) : data(data), length(length) {}
    };

    class MetadataReader
    {
    private:
        const byte* _data;
    public:
        MetadataReader(const byte* data) : _data(data) {}
        int16_t ReadInt16()
        {
            int16_t value = GetI2LittleEndian(_data);
            _data += 2;
            return value;
        }

        bool ReadBool()
        {
            return *(_data++) != 0;
        }

        uint8_t ReadUInt8()
        {
            return *(_data++);
        }

        uint16_t ReadUInt16()
        {
            uint16_t value = GetU2LittleEndian(_data);
            _data += 2;
            return value;
        }

        int32_t ReadInt32()
        {
            int32_t value = GetI4LittleEndian(_data);
            _data += 4;
            return value;
        }

        uint32_t ReadUInt32()
        {
            uint32_t value = GetU4LittleEndian(_data);
            _data += 4;
            return value;
        }

        int64_t ReadInt64()
        {
            int64_t value = GetI8LittleEndian(_data);
            _data += 8;
            return value;
        }

        uint64_t ReadUInt64()
        {
            uint64_t value = GetU8LittleEndian(_data);
            _data += 8;
            return value;
        }

        const byte* ReadFixedBytes(int32_t byteCount)
        {
            const byte* value = _data;
            _data += byteCount;
            return value;
        }

        ByteSpan ReadBytes()
        {
            uint32_t byteCount = ReadUInt32();
            const byte* buffer = _data;
            _data += byteCount;
            return ByteSpan(buffer, byteCount);
        }

        const byte* CurrentDataPtr() const
        {
            return _data;
        }
    };
}
}
```

`hybridclr/metadata/MetadataUtil.cpp`:

```cpp
#include "MetadataUtil.h"

#include "vm/GlobalMetadata.h"
#include "vm/GlobalMetadataFileInternals.h"
#include "vm/Type.h"
#include "vm/GlobalMetadata.h"
#include "vm/Class.h"
#include "metadata/Il2CppTypeCompare.h"
#include "metadata/GenericMetadata.h"

#include "Image.h"
#include "MetadataPool.h"

namespace hybridclr
{
namespace metadata
{
	const uint32_t kMetadataImageIndexExtraShiftBitsArr[4] = 
	{
		kMetadataImageIndexExtraShiftBitsA,
		kMetadataImageIndexExtraShiftBitsB,
		kMetadataImageIndexExtraShiftBitsC,
		kMetadataImageIndexExtraShiftBitsD,
	};

	const uint32_t kMetadataIndexMaskArr[4] = 
	{
		kMetadataIndexMaskA,
		kMetadataIndexMaskB,
		kMetadataIndexMaskC,
		kMetadataIndexMaskD,
	};


	uint32_t GetNotZeroBitCount(uint64_t x)
	{
		uint32_t count = 0;
		for (int i = 0; i < 64; i++)
		{
			if (x & ((uint64_t)1 << i))
			{
				++count;
			}
		}
		return count;
	}

	int32_t GetTypeValueSize(const Il2CppType* type)
	{
		if (type->byref)
		{
			return PTR_SIZE;
		}
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
			return 1;
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
			return 2;
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_R4:
			return 4;
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
			return 8;
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_FNPTR:
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_BYREF:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_ARRAY:
		case IL2CPP_TYPE_SZARRAY:
		case IL2CPP_TYPE_OBJECT:
			return PTR_SIZE;
		case IL2CPP_TYPE_TYPEDBYREF:
			return sizeof(Il2CppTypedRef);
		case IL2CPP_TYPE_CLASS:
		{
			IL2CPP_ASSERT(!IS_CLASS_VALUE_TYPE(il2cpp::vm::Class::FromIl2CppType(type)));
			return PTR_SIZE;
		}
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
			return il2cpp::vm::Class::GetValueSize(klass, nullptr);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* genericClass = type->data.generic_class;
			if (genericClass->type->type == IL2CPP_TYPE_CLASS)
			{
				IL2CPP_ASSERT(!IS_CLASS_VALUE_TYPE(il2cpp::vm::Class::FromIl2CppType(type)));
				return PTR_SIZE;
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
				IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
				return il2cpp::vm::Class::GetValueSize(klass, nullptr);
			}
		}
		default:
		{
			TEMP_FORMAT(errMsg, "GetTypeValueSize unknown type:%d", (int)type->type);
			RaiseExecutionEngineException(errMsg);
			return -1;
		}
		}
	}

	bool IsValueType(const Il2CppType* type)
	{
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_R4:
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_TYPEDBYREF:
		case IL2CPP_TYPE_VALUETYPE: return true;
		case IL2CPP_TYPE_GENERICINST: return type->data.generic_class->type->type == IL2CPP_TYPE_VALUETYPE;
		default: return false;
		}
	}

	bool IsTypeSameByTypeIndex(TypeIndex t1, TypeIndex t2)
	{
		const Il2CppType* srcParamType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(t1);
		IL2CPP_ASSERT(srcParamType);
		const Il2CppType* dstParamType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(t2);
		IL2CPP_ASSERT(dstParamType);
		return il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(srcParamType, dstParamType);
	}

	bool IsTypeEqual(const Il2CppType* t1, const Il2CppType* t2)
	{
		return il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(t1, t2);
	}

	bool IsTypeGenericCompatible(const Il2CppType* typeTo, const Il2CppType* typeFrom)
	{
		if (typeTo->type != typeFrom->type)
		{
			return false;
		}
		switch (typeTo->type)
		{
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass1 = il2cpp::vm::Class::FromIl2CppType(typeTo);
			Il2CppClass* klass2 = il2cpp::vm::Class::FromIl2CppType(typeFrom);
			return klass1->instance_size == klass2->instance_size;
		}
		case IL2CPP_TYPE_CLASS:
		{
			Il2CppClass* klass1 = il2cpp::vm::Class::FromIl2CppType(typeTo);
			Il2CppClass* klass2 = il2cpp::vm::Class::FromIl2CppType(typeFrom);
			return il2cpp::vm::Class::IsAssignableFrom(klass1, klass2);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppClass* klass1 = il2cpp::vm::Class::FromIl2CppType(typeTo);
			Il2CppClass* klass2 = il2cpp::vm::Class::FromIl2CppType(typeFrom);
			if (IS_CLASS_VALUE_TYPE(klass1) != IS_CLASS_VALUE_TYPE(klass2))
			{
				return false;
			}
			if (IS_CLASS_VALUE_TYPE(klass1))
			{
				return klass1->instance_size == klass2->instance_size;
			}
			else
			{
				return il2cpp::vm::Class::IsAssignableFrom(klass1, klass2);
			}
			break;
		}
		default: return true;
		}
		return true;
	}

	const Il2CppType* TryInflateIfNeed(const Il2CppType* selfType, const Il2CppGenericContext* genericContext, bool inflateMethodVars)
	{
		// FIXME mEMORY LEAK
		return genericContext ? il2cpp::metadata::GenericMetadata::InflateIfNeeded(selfType, genericContext, inflateMethodVars) : selfType;
	}

	const Il2CppType* TryInflateIfNeed(const Il2CppType* containerType, const Il2CppType* selfType)
	{
		if (IsGenericIns(containerType) /* && IsGenericIns(selfType)*/)
		{
			// TOTO memory leak
			return il2cpp::metadata::GenericMetadata::InflateIfNeeded(selfType, &containerType->data.generic_class->context, true);
		}
		else
		{
			return selfType;
		}
	}

	bool IsSameOverrideType(const Il2CppType* t1, const Il2CppType* t2)
	{
		if (t1->type != t2->type)
		{
			return false;
		}

		if (t1->byref != t2->byref)
		{
			return false;
		}

		switch (t1->type)
		{
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_CLASS:
			return t1->data.typeHandle == t2->data.typeHandle;
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_SZARRAY:
			return IsSameOverrideType(t1->data.type, t2->data.type);

		case IL2CPP_TYPE_ARRAY:
		{
			if (t1->data.array->rank != t2->data.array->rank)
			{
				return false;
			}
			return IsSameOverrideType(t1->data.array->etype, t2->data.array->etype);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			const Il2CppGenericInst* i1 = t1->data.generic_class->context.class_inst;
			const Il2CppGenericInst* i2 = t2->data.generic_class->context.class_inst;

			// this happens when maximum generic recursion is hit
			if (i1 == NULL || i2 == NULL)
			{
				return i1 == i2;
			}

			if (i1->type_argc != i2->type_argc)
				return false;

			if (!IsSameOverrideType(t1->data.generic_class->type, t2->data.generic_class->type))
				return false;

			for (uint32_t i = 0; i < i1->type_argc; ++i)
			{
				if (!IsSameOverrideType(i1->type_argv[i], i2->type_argv[i]))
				{
					return false;
				}
			}

			return true;
		}
		case IL2CPP_TYPE_VAR:
		{
			return t1->data.genericParameterHandle == t2->data.genericParameterHandle;
		}
		case IL2CPP_TYPE_MVAR:
		{
			const Il2CppGenericParameter* gp1 = (const Il2CppGenericParameter*)t1->data.genericParameterHandle;
			const Il2CppGenericParameter* gp2 = (const Il2CppGenericParameter*)t2->data.genericParameterHandle;
			return gp1->num == gp2->num;
		}
		default:
			return true;
		}
		RaiseExecutionEngineException("");
		return false;
	}

	static bool IsGenericMethodSameGenericParamCount(const Il2CppMethodDefinition* method1, const Il2CppMethodDefinition* method2)
	{
		if (method1->genericContainerIndex == kGenericContainerIndexInvalid)
		{
			return method2->genericContainerIndex == kGenericContainerIndexInvalid;
		}
		else
		{
			if (method2->genericContainerIndex == kGenericContainerIndexInvalid)
			{
				return false;
			}
			else
			{
				Il2CppGenericContainer* genericContainer1 = (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(method1->genericContainerIndex);
				Il2CppGenericContainer* genericContainer2 = (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(method2->genericContainerIndex);
				return genericContainer1->type_argc == genericContainer2->type_argc;
			}
		}
	}

	bool IsOverrideMethodIgnoreName(const Il2CppType* type1, const Il2CppMethodDefinition* methodDef1, const Il2CppType* type2, const Il2CppMethodDefinition* methodDef2)
	{
		if (methodDef1->parameterCount != methodDef2->parameterCount)
		{
			return false;
		}
		if (!IsGenericMethodSameGenericParamCount(methodDef1, methodDef2))
		{
			return false;
		}

		const Il2CppType* returnType1 = TryInflateIfNeed(type1, il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(methodDef1->returnType));
		const Il2CppType* returnType2 = TryInflateIfNeed(type2, il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(methodDef2->returnType));


		if (!IsSameOverrideType(returnType1, returnType2))
		{
			return false;
		}

		for (uint32_t i = 0; i < methodDef1->parameterCount; i++)
		{
			const Il2CppParameterDefinition* srcParam = (const Il2CppParameterDefinition*)il2cpp::vm::GlobalMetadata::GetParameterDefinitionFromIndex(methodDef1, methodDef1->parameterStart + i);
			IL2CPP_ASSERT(srcParam);
			const Il2CppParameterDefinition* dstParam = (const Il2CppParameterDefinition*)il2cpp::vm::GlobalMetadata::GetParameterDefinitionFromIndex(methodDef2, methodDef2->parameterStart + i);
			IL2CPP_ASSERT(dstParam);

			const Il2CppType* paramType1 = TryInflateIfNeed(type1, il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(srcParam->typeIndex));
			const Il2CppType* paramType2 = TryInflateIfNeed(type2, il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(dstParam->typeIndex));

			if (!IsSameOverrideType(paramType1, paramType2))
			{
				return false;
			}
		}
		return true;
	}

	bool IsOverrideMethod(const Il2CppType* type1, const Il2CppMethodDefinition* methodDef1, const Il2CppType* type2, const Il2CppMethodDefinition* methodDef2)
	{
		const char* name1 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef1->nameIndex);
		const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef2->nameIndex);
		if (std::strcmp(name1, name2))
		{
			return false;
		}
		return IsOverrideMethodIgnoreName(type1, methodDef1, type2, methodDef2);
	}

	bool IsMatchSigType(const Il2CppType* dstType, const Il2CppType* sigType, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer)
	{
		if (dstType->type != sigType->type)
		{
			return false;
		}

		if (dstType->byref != sigType->byref)
		{
			return false;
		}

		switch (dstType->type)
		{
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_CLASS:
			return dstType->data.typeHandle == sigType->data.typeHandle;
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_SZARRAY:
			return IsMatchSigType(dstType->data.type, sigType->data.type, klassGenericContainer, methodGenericContainer);

		case IL2CPP_TYPE_ARRAY:
		{
			if (dstType->data.array->rank != sigType->data.array->rank)
			{
				return false;
			}
			return IsMatchSigType(dstType->data.array->etype, sigType->data.array->etype, klassGenericContainer, methodGenericContainer);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			const Il2CppGenericInst* i1 = dstType->data.generic_class->context.class_inst;
			const Il2CppGenericInst* i2 = sigType->data.generic_class->context.class_inst;

			// this happens when maximum generic recursion is hit
			if (i1 == NULL || i2 == NULL)
			{
				return i1 == i2;
			}

			if (i1->type_argc != i2->type_argc)
				return false;

			if (!IsMatchSigType(dstType->data.generic_class->type, sigType->data.generic_class->type, klassGenericContainer, methodGenericContainer))
				return false;

			for (uint32_t i = 0; i < i1->type_argc; ++i)
			{
				if (!IsMatchSigType(i1->type_argv[i], i2->type_argv[i], klassGenericContainer, methodGenericContainer))
				{
					return false;
				}
			}

			return true;
		}
		case IL2CPP_TYPE_VAR:
		{
			if ((int32_t)sigType->data.__genericParameterIndex >= klassGenericContainer->type_argc)
			{
				return false;
			}
			Il2CppMetadataGenericParameterHandle sigGph = il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(
				(Il2CppMetadataGenericContainerHandle)klassGenericContainer, sigType->data.__genericParameterIndex);
			return dstType->data.genericParameterHandle == sigGph;
		}
		case IL2CPP_TYPE_MVAR:
		{
			if ((int32_t)sigType->data.__genericParameterIndex >= methodGenericContainer->type_argc)
			{
				return false;
			}
			Il2CppMetadataGenericParameterHandle sigGph = il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(
				(Il2CppMetadataGenericContainerHandle)methodGenericContainer, sigType->data.__genericParameterIndex);
			return dstType->data.genericParameterHandle == sigGph;
		}
		default:
			return true;
		}
		RaiseExecutionEngineException("");
		return false;
	}

	bool IsMatchSigType(const Il2CppType* dstType, const Il2CppType* sigType, const Il2CppType** klassInstArgv, const Il2CppType** methodInstArgv)
	{
		if (dstType->byref != sigType->byref)
		{
			return false;
		}

		if (sigType->type == IL2CPP_TYPE_VAR)
		{
			sigType = klassInstArgv[sigType->data.__genericParameterIndex];
		}
		else if (sigType->type == IL2CPP_TYPE_MVAR)
		{
			sigType = methodInstArgv[sigType->data.__genericParameterIndex];
		}

		if (dstType->type != sigType->type)
		{
			return false;
		}
		switch (sigType->type)
		{
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_CLASS:
			return dstType->data.typeHandle == sigType->data.typeHandle;
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_SZARRAY:
			return IsMatchSigType(dstType->data.type, sigType->data.type, klassInstArgv, methodInstArgv);

		case IL2CPP_TYPE_ARRAY:
		{
			if (dstType->data.array->rank != sigType->data.array->rank)
			{
				return false;
			}
			return IsMatchSigType(dstType->data.array->etype, sigType->data.array->etype, klassInstArgv, methodInstArgv);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			const Il2CppGenericInst* i1 = dstType->data.generic_class->context.class_inst;
			const Il2CppGenericInst* i2 = sigType->data.generic_class->context.class_inst;

			// this happens when maximum generic recursion is hit
			if (i1 == NULL || i2 == NULL)
			{
				return i1 == i2;
			}

			if (i1->type_argc != i2->type_argc)
				return false;

			if (!IsMatchSigType(dstType->data.generic_class->type, sigType->data.generic_class->type, klassInstArgv, methodInstArgv))
				return false;

			for (uint32_t i = 0; i < i1->type_argc; ++i)
			{
				if (!IsMatchSigType(i1->type_argv[i], i2->type_argv[i], klassInstArgv, methodInstArgv))
				{
					return false;
				}
			}

			return true;
		}
		case IL2CPP_TYPE_VAR:
		{
			/*Il2CppMetadataGenericParameterHandle sigGph = il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(
				(Il2CppMetadataGenericContainerHandle)klassGenericContainer, sigType->data.__genericParameterIndex);
			return dstType->data.genericParameterHandle == sigType->data.__genericParameterIndex;*/
			RaiseNotSupportedException("");
			break;
		}
		case IL2CPP_TYPE_MVAR:
		{
			/*Il2CppMetadataGenericParameterHandle sigGph = il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(
				(Il2CppMetadataGenericContainerHandle)methodGenericContainer, sigType->data.__genericParameterIndex);
			return dstType->data.genericParameterHandle == sigGph;*/
			RaiseNotSupportedException("");
			break;
		}
		default: return true;
		}
		RaiseExecutionEngineException("");
		return false;
	}

	bool IsMatchMethodSig(const Il2CppMethodDefinition* methodDef, const MethodRefSig& resolveSig, const Il2CppGenericContainer* klassGenericContainer)
	{
		if (methodDef->parameterCount != (uint16_t)resolveSig.params.size())
		{
			return false;
		}
		Il2CppGenericContainer* methodGenericContainer = nullptr;
		// if generic param not match. return false
		if (methodDef->genericContainerIndex == kGenericContainerIndexInvalid)
		{
			if (resolveSig.genericParamCount)
			{
				return false;
			}
		}
		else
		{
			methodGenericContainer = (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(methodDef->genericContainerIndex);
			if (resolveSig.genericParamCount != methodGenericContainer->type_argc)
			{
				return false;
			}
		}

		const Il2CppType* returnType1 = resolveSig.returnType;
		const Il2CppType* returnType2 = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(methodDef->returnType);
		if (!IsMatchSigType(returnType2, returnType1, klassGenericContainer, methodGenericContainer))
		{
			return false;
		}
		for (uint32_t i = 0; i < methodDef->parameterCount; i++)
		{
			const Il2CppType* paramType1 = resolveSig.params[i];
			const Il2CppParameterDefinition* dstParam = (const Il2CppParameterDefinition*)il2cpp::vm::GlobalMetadata::GetParameterDefinitionFromIndex(methodDef, methodDef->parameterStart + i);
			IL2CPP_ASSERT(dstParam);
			const Il2CppType* paramType2 = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(dstParam->typeIndex);
			if (!IsMatchSigType(paramType2, paramType1, klassGenericContainer, methodGenericContainer))
			{
				return false;
			}
		}
		return true;
	}


	bool IsMatchMethodSig(const MethodInfo* methodDef, const MethodRefSig& resolveSig, const Il2CppGenericContainer* klassGenericContainer)
	{
		if ((size_t)methodDef->parameters_count != resolveSig.params.size())
		{
			return false;
		}
		const Il2CppGenericContainer* methodGenericContainer = GetGenericContainer(methodDef);
		if (methodGenericContainer)
		{
			if (methodGenericContainer->type_argc != resolveSig.genericParamCount)
			{
				return false;
			}
		}
		else
		{
			if (resolveSig.genericParamCount)
			{
				return false;
			}
		}
		const Il2CppType* returnType1 = resolveSig.returnType;
		const Il2CppType* returnType2 = methodDef->return_type;
		if (!IsMatchSigType(returnType2, returnType1, klassGenericContainer, methodGenericContainer))
		{
			return false;
		}
		for (uint32_t i = 0; i < methodDef->parameters_count; i++)
		{
			const Il2CppType* paramType1 = resolveSig.params[i];
			const Il2CppType* paramType2 = GET_METHOD_PARAMETER_TYPE(methodDef->parameters[i]);
			if (!IsMatchSigType(paramType2, paramType1, klassGenericContainer, methodGenericContainer))
			{
				return false;
			}
		}
		return true;
	}

	bool IsMatchMethodSig(const MethodInfo* methodDef, const MethodRefSig& resolveSig, const Il2CppType** klassInstArgv, const Il2CppType** methodInstArgv)
	{
		if ((size_t)methodDef->parameters_count != resolveSig.params.size())
		{
			return false;
		}
		const Il2CppGenericContainer* methodGenericContainer = GetGenericContainer(methodDef);
		if (methodGenericContainer)
		{
			if (methodGenericContainer->type_argc != resolveSig.genericParamCount)
			{
				return false;
			}
		}
		else
		{
			if (resolveSig.genericParamCount)
			{
				return false;
			}
		}
		const Il2CppType* returnType1 = resolveSig.returnType;
		const Il2CppType* returnType2 = methodDef->return_type;
		if (!IsMatchSigType(returnType2, returnType1, klassInstArgv, methodInstArgv))
		{
			return false;
		}
		for (uint32_t i = 0; i < methodDef->parameters_count; i++)
		{
			const Il2CppType* paramType1 = resolveSig.params[i];
			const Il2CppType* paramType2 = GET_METHOD_PARAMETER_TYPE(methodDef->parameters[i]);
			if (!IsMatchSigType(paramType2, paramType1, klassInstArgv, methodInstArgv))
			{
				return false;
			}
		}
		return true;
	}


	const Il2CppMethodDefinition* ResolveMethodDefinition(const Il2CppType* type, const char* resolveMethodName, const MethodRefSig& resolveSig)
	{
		const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
		const Il2CppGenericContainer* klassGenericContainer = GetGenericContainerFromIl2CppType(type);
		const char* typeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
		for (uint32_t i = 0; i < typeDef->method_count; i++)
		{
			const Il2CppMethodDefinition* methodDef = il2cpp::vm::GlobalMetadata::GetMethodDefinitionFromIndex(typeDef->methodStart + i);
			const char* methodName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex);
			if (std::strcmp(resolveMethodName, methodName) == 0 && IsMatchMethodSig(methodDef, resolveSig, klassGenericContainer))
			{
				return methodDef;
			}
		}
		RaiseMethodNotFindException(type, resolveMethodName);
		return nullptr;
	}

	const MethodInfo* GetMethodInfoFromMethodDef(const Il2CppType* type, const Il2CppMethodDefinition* methodDef)
	{
		Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
		il2cpp::vm::Class::SetupMethods(klass);
		void* iter = nullptr;
		for (const MethodInfo* cur = nullptr; (cur = il2cpp::vm::Class::GetMethods(klass, &iter)) != nullptr; )
		{
			if (!cur->is_inflated)
			{
				if ((const Il2CppMethodDefinition*)cur->methodMetadataHandle == methodDef)
				{
					return cur;
				}
			}
			else
			{
				if ((const Il2CppMethodDefinition*)cur->genericMethod->methodDefinition->methodMetadataHandle == methodDef)
				{
					return cur;
				}
			}
		}
		RaiseMethodNotFindException(type, il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex));
		return nullptr;
	}

	bool ResolveField(const Il2CppType* type, const char* resolveFieldName, const Il2CppType* resolveFieldType, const Il2CppFieldDefinition*& retFieldDef)
	{
		const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
		const Il2CppGenericContainer* klassGenericContainer = GetGenericContainerFromIl2CppType(type);
		for (uint16_t i = 0; i < typeDef->field_count; i++)
		{
			const Il2CppFieldDefinition* fieldDef = il2cpp::vm::GlobalMetadata::GetFieldDefinitionFromTypeDefAndFieldIndex(typeDef, i);
			const char* fieldName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(fieldDef->nameIndex);
			const Il2CppType* fieldType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(fieldDef->typeIndex);
			if (std::strcmp(resolveFieldName, fieldName) == 0 && IsMatchSigType(fieldType, resolveFieldType, klassGenericContainer, nullptr))
			{
				retFieldDef = fieldDef;
				return true;
			}
		}
		retFieldDef = nullptr;
		return false;
	}

	const Il2CppGenericContainer* GetGenericContainerFromIl2CppType(const Il2CppType* type)
	{
		switch (type->type)
		{
		case IL2CPP_TYPE_GENERICINST:
		{
			return (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromGenericClass(type->data.generic_class);
		}
		case IL2CPP_TYPE_VALUETYPE:
		case IL2CPP_TYPE_CLASS:
		{
			return (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(((Il2CppTypeDefinition*)type->data.typeHandle)->genericContainerIndex);
		}
		default:
		{
			return nullptr;
		}
		}
	}

	const Il2CppGenericInst* TryInflateGenericInst(const Il2CppGenericInst* inst, const Il2CppGenericContext* genericContext)
	{
		IL2CPP_ASSERT(inst->type_argc > 0);
		const Il2CppType** argv = (const Il2CppType**)alloca(sizeof(Il2CppType*) * inst->type_argc);
		for (uint32_t i = 0; i < inst->type_argc; i++)
		{
			argv[i] = TryInflateIfNeed(inst->type_argv[i], genericContext, true);
		}
		return il2cpp::vm::MetadataCache::GetGenericInst(argv, inst->type_argc);
	}

	bool HasNotInstantiatedGenericType(const Il2CppGenericInst* inst)
	{
		if (inst == nullptr)
		{
			return false;
		}
		for (uint32_t i = 0; i < inst->type_argc; i++)
		{
			if (HasNotInstantiatedGenericType(inst->type_argv[i]))
			{
				return true;
			}
		}
		return false;
	}

	bool HasNotInstantiatedGenericType(const Il2CppType* type)
	{
		switch (type->type)
		{
		case IL2CPP_TYPE_FNPTR:
			return true;
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_SZARRAY: return HasNotInstantiatedGenericType(type->data.type);
		case IL2CPP_TYPE_ARRAY: return HasNotInstantiatedGenericType(type->data.array->etype);
		case IL2CPP_TYPE_CLASS:
		case IL2CPP_TYPE_VALUETYPE:
		{
#if HYBRIDCLR_UNITY_2019
			const Il2CppTypeDefinition* typeDefinition = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeDefinitionFromIl2CppType(type);
#else
			const Il2CppTypeDefinition* typeDefinition = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeHandleFromType(type);
#endif
			return typeDefinition->genericContainerIndex != kGenericContainerIndexInvalid;
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* genericClass = type->data.generic_class;
			return HasNotInstantiatedGenericType(genericClass->context.class_inst);
		}
		case IL2CPP_TYPE_VAR:
        case IL2CPP_TYPE_MVAR:
        {
            return true;
        }
		default: return false;
		}
	}

	const Il2CppType* GetIl2CppTypeFromTypeDefinition(const Il2CppTypeDefinition* typeDef)
	{
		Il2CppType type = {};
		bool isValueType = IsValueType(typeDef);
		type.type = isValueType ? IL2CPP_TYPE_VALUETYPE : IL2CPP_TYPE_CLASS;
		type.data.typeHandle = (Il2CppMetadataTypeHandle)typeDef;
		SET_IL2CPPTYPE_VALUE_TYPE(type, isValueType);
		return MetadataPool::GetPooledIl2CppType(type);
	}
}
}

```

`hybridclr/metadata/MetadataUtil.h`:

```h
#pragma once
#include <tuple>

#include "vm/GlobalMetadata.h"
#include "vm/Exception.h"
#include "utils/HashUtils.h"
#include "metadata/Il2CppTypeHash.h"
#include "metadata/Il2CppTypeCompare.h"

#include "../CommonDef.h"
#include "MetadataDef.h"

namespace hybridclr
{
namespace metadata
{
    class Image;

#pragma region byteorder

    template<int N>
    inline void* GetAlignBorder(const void* pointer)
    {
        uint64_t p = (uint64_t)pointer;
        if (p % N == 0)
        {
            return (void*)pointer;
        }
        else
        {
            return (void*)((p + N - 1) / N * N);
        }
    }

    inline int32_t GetI1(const byte* data)
    {
        return *(int8_t*)data;
    }

    inline uint16_t GetU2LittleEndian(const byte* data)
    {
#if SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS
        uint16_t value = *(uint16_t*)data;
#else
        uint16_t value = (uint16_t)data[0] | ((uint16_t)data[1] << 8);
#endif
        return value;
    }

    inline uint16_t GetI2LittleEndian(const byte* data)
    {
        return (int16_t)GetU2LittleEndian(data);
    }

    inline uint32_t GetU4LittleEndian(const byte* data)
    {
#if SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS
        uint32_t value = *(uint32_t*)data;
#else
        uint32_t value = (uint32_t)data[0]
            | ((uint32_t)data[1] << 8)
            | ((uint32_t)data[2] << 16)
            | ((uint32_t)data[3] << 24);
#endif
        return value;
    }

    inline int32_t GetI4LittleEndian(const byte* data)
    {
        return (int32_t)GetU4LittleEndian(data);
    }

    inline uint64_t GetU8LittleEndian(const byte* data)
    {
#if SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS
        uint64_t value = *(uint64_t*)data;
#else
        uint64_t value = (uint64_t)data[0]
            + ((uint64_t)data[1] << 8)
            + ((uint64_t)data[2] << 16)
            + ((uint64_t)data[3] << 24)
            + ((uint64_t)data[4] << 32)
            + ((uint64_t)data[5] << 40)
            + ((uint64_t)data[6] << 48)
            + ((uint64_t)data[7] << 56);
#endif
        return value;
    }

    inline int64_t GetI8LittleEndian(const byte* data)
    {
        return GetU8LittleEndian(data);
    }

    uint32_t GetNotZeroBitCount(uint64_t x);

#pragma endregion


#pragma region interpreter metadtata index

    const uint32_t kMetadataIndexBits = 22;

    const uint32_t kMetadataKindBits = 2;

    const uint32_t kMetadataKindShiftBits = 32 - kMetadataKindBits;

    const uint32_t kMetadataImageIndexShiftBits = kMetadataIndexBits;

    const uint32_t kMetadataImageIndexExtraShiftBitsA = 6;
    const uint32_t kMetadataImageIndexExtraShiftBitsB = 4;
    const uint32_t kMetadataImageIndexExtraShiftBitsC = 2;
    const uint32_t kMetadataImageIndexExtraShiftBitsD = 0;
    extern const uint32_t kMetadataImageIndexExtraShiftBitsArr[4];

    const uint32_t kMetadataIndexMaskA = (1 << (kMetadataIndexBits + kMetadataImageIndexExtraShiftBitsA)) - 1;
    const uint32_t kMetadataIndexMaskB = (1 << (kMetadataIndexBits + kMetadataImageIndexExtraShiftBitsB)) - 1;
    const uint32_t kMetadataIndexMaskC = (1 << (kMetadataIndexBits + kMetadataImageIndexExtraShiftBitsC)) - 1;
    const uint32_t kMetadataIndexMaskD = (1 << (kMetadataIndexBits + kMetadataImageIndexExtraShiftBitsD)) - 1;
    extern const uint32_t kMetadataIndexMaskArr[4];

    const uint32_t kMetadataImageIndexBits = 32 - kMetadataIndexBits;

    const uint32_t kMaxMetadataImageCount = (1 << kMetadataImageIndexBits);

    const uint32_t kMaxMetadataImageIndexWithoutKind = 1u << (kMetadataImageIndexBits - kMetadataKindBits);

    const uint32_t kInvalidImageIndex = 0;

    const int32_t kInvalidIndex = -1;

    inline int32_t DecodeMetadataKind(uint32_t index)
    {
		return index >> kMetadataKindShiftBits;
	}

    inline uint32_t DecodeImageIndex(int32_t index)
    {
        if (index == kInvalidIndex)
        {
			return 0;
		}
        uint32_t uindex = (uint32_t)index;
        uint32_t kind = uindex >> kMetadataKindShiftBits;
        return (uindex & ~kMetadataIndexMaskArr[kind]) >> kMetadataImageIndexShiftBits;
    }

    inline uint32_t DecodeMetadataIndex(int32_t index)
    {
        if (index == kInvalidIndex)
        {
            return kInvalidIndex;
        }
        uint32_t uindex = (uint32_t)index;
        uint32_t kind = uindex >> kMetadataKindShiftBits;
        return uindex & kMetadataIndexMaskArr[kind];
    }

    inline int32_t EncodeImageAndMetadataIndex(uint32_t imageIndex, int32_t rawIndex)
    {
        if (rawIndex == kInvalidIndex)
        {
			return kInvalidIndex;
		}
        IL2CPP_ASSERT(((imageIndex << kMetadataImageIndexShiftBits) & (uint32_t)rawIndex) == 0);
        return (imageIndex << kMetadataIndexBits) | (uint32_t)rawIndex;
    }

    inline bool IsInterpreterIndex(int32_t index)
    {
        //return DecodeImageIndex(index) != 0;
        return index != kInvalidIndex && ((uint32_t)index & ~kMetadataIndexMaskA) != 0;
    }

    inline bool IsInterpreterType(const Il2CppTypeDefinition* typeDefinition)
    {
        return IsInterpreterIndex(typeDefinition->byvalTypeIndex);
    }

    inline bool IsInterpreterType(const Il2CppClass* klass)
    {
        return IsInterpreterIndex(klass->image->token) && klass->rank == 0;
    }

    inline bool IsInterpreterImage(const Il2CppImage* image)
    {
        return IsInterpreterIndex(image->token);
    }

    inline bool IsPrologHasThis(uint32_t flags)
    {
        return flags & 0x20;
    }

    inline bool IsPrologExplicitThis(uint32_t flags)
    {
        return flags & 0x40;
    }

#pragma endregion


#pragma region method and klass

    inline bool IsInstanceField(const Il2CppType* type)
    {
        return (type->attrs & FIELD_ATTRIBUTE_STATIC) == 0;
    }

    inline bool IsInterpreterMethod(const MethodInfo* method)
    {
        return IsInterpreterType(method->klass);
    }

    inline bool IsInterpreterMethod(const Il2CppMethodDefinition* method)
    {
        return IsInterpreterIndex(method->declaringType);
    }

    inline bool IsInterpreterImplement(const MethodInfo* method)
    {
        return method->isInterpterImpl;
    }

    inline bool IsInstanceMethod(const MethodInfo* method)
    {
        return !(method->flags & METHOD_ATTRIBUTE_STATIC);
    }

    inline bool IsInstanceMethod(const Il2CppMethodDefinition* method)
    {
        return !(method->flags & METHOD_ATTRIBUTE_STATIC);
    }

    inline bool IsStaticMethod(const MethodInfo* method)
    {
        return (method->flags & METHOD_ATTRIBUTE_STATIC);
    }

    inline bool IsPrivateMethod(uint32_t flags)
    {
        return (flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PRIVATE;
    }

    inline bool IsPublicMethod(uint32_t flags)
    {
        return (flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC;
    }

    inline bool IsGenericIns(const Il2CppType* type)
    {
        return type->type == IL2CPP_TYPE_GENERICINST;
    }

    inline bool IsVirtualMethod(uint32_t flags)
    {
        return flags & METHOD_ATTRIBUTE_VIRTUAL;
    }

    inline bool IsAbstractMethod(uint32_t flags)
    {
        return flags & METHOD_ATTRIBUTE_ABSTRACT;
    }

    inline bool IsNewSlot(uint32_t flags)
    {
        return flags & METHOD_ATTRIBUTE_NEW_SLOT;
    }

    inline bool IsSealed(uint32_t flags)
    {
        return flags & METHOD_ATTRIBUTE_FINAL;
    }

    inline bool IsInterface(uint32_t flags)
    {
        return flags & TYPE_ATTRIBUTE_INTERFACE;
    }

	inline bool IsPInvokeMethod(uint32_t flags)
	{
		return flags & METHOD_ATTRIBUTE_PINVOKE_IMPL;
	}

#define IMPLMAP_FLAG_NOT_MANGLE 0x1

#define IMPLMAP_FLAG_CHARSET_MASK 0x6
#define IMPLMAP_FLAG_CHARSET_NOT_SPECIFIED 0x0
#define IMPLMAP_FLAG_CHARSET_ANSI 0x2
#define IMPLMAP_FLAG_CHARSET_UNICODE 0x4
#define IMPLMAP_FLAG_CHARSET_AUTO 0x6

#define IMPLMAP_FLAG_SUPPORTS_LAST_ERROR 0x40

#define IMPLMAP_FLAG_CALLCONV_MASK 0x700
#define IMPLMAP_FLAG_CALLCONV_PLATFORMAPI 0x100
#define IMPLMAP_FLAG_CALLCONV_CDECL 0x200
#define IMPLMAP_FLAG_CALLCONV_STDCALL 0x300
#define IMPLMAP_FLAG_CALLCONV_THISCALL 0x400
#define IMPLMAP_FLAG_CALLCONV_FASTCALL 0x500


	inline bool IsDllImportNoMangle(uint32_t mappingFlags)
	{
		return mappingFlags & IMPLMAP_FLAG_NOT_MANGLE;
	}

    inline Il2CppCharSet GetDllImportCharSet(uint32_t mappingFlags)
    {
        uint32_t charSet = mappingFlags & IMPLMAP_FLAG_CHARSET_MASK;
        switch (charSet)
        {
		case IMPLMAP_FLAG_CHARSET_NOT_SPECIFIED:
			return Il2CppCharSet::CHARSET_NOT_SPECIFIED;
		case IMPLMAP_FLAG_CHARSET_ANSI:
			return Il2CppCharSet::CHARSET_ANSI;
		case IMPLMAP_FLAG_CHARSET_UNICODE:
			return Il2CppCharSet::CHARSET_UNICODE;
        default:
            IL2CPP_ASSERT(false);
			return Il2CppCharSet::CHARSET_NOT_SPECIFIED;
        }
    }

    inline Il2CppCallConvention GetDllImportCallConvention(uint32_t mappingFlags)
    {
		uint32_t callConv = mappingFlags & IMPLMAP_FLAG_CALLCONV_MASK;
        switch (callConv)
        {
        case IMPLMAP_FLAG_CALLCONV_PLATFORMAPI: return Il2CppCallConvention::IL2CPP_CALL_DEFAULT;
		case IMPLMAP_FLAG_CALLCONV_CDECL: return Il2CppCallConvention::IL2CPP_CALL_C;
		case IMPLMAP_FLAG_CALLCONV_STDCALL: return Il2CppCallConvention::IL2CPP_CALL_STDCALL;
		case IMPLMAP_FLAG_CALLCONV_THISCALL: return Il2CppCallConvention::IL2CPP_CALL_THISCALL;
		case IMPLMAP_FLAG_CALLCONV_FASTCALL: return Il2CppCallConvention::IL2CPP_CALL_FASTCALL;
		default:
			IL2CPP_ASSERT(false);
			return Il2CppCallConvention::IL2CPP_CALL_DEFAULT;
        }
    }

    bool IsValueType(const Il2CppType* type);

    inline bool IsValueType(const Il2CppTypeDefinition* typeDef)
    {
        return typeDef->bitfield & (1 << (il2cpp::vm::kBitIsValueType - 1));
    }

    inline bool IsEnumType(const Il2CppTypeDefinition* typeDef)
    {
        return (typeDef->bitfield >> (il2cpp::vm::kBitIsEnum - 1)) & 0x1;
    }

    inline const Il2CppTypeDefinition* GetUnderlyingTypeDefinition(const Il2CppType* type)
    {
        if (IsGenericIns(type))
        {
            return (Il2CppTypeDefinition*)type->data.generic_class->type->data.typeHandle;
        }
        else
        {
            return (Il2CppTypeDefinition*)type->data.typeHandle;
        }
    }

    const Il2CppType* GetIl2CppTypeFromTypeDefinition(const Il2CppTypeDefinition* typeDef);

    inline uint32_t GetActualArgumentNum(const MethodInfo* method)
    {
        return (uint32_t)method->parameters_count + (!(method->flags & METHOD_ATTRIBUTE_STATIC));
    }

    inline bool IsReturnVoidMethod(const MethodInfo* method)
    {
        return method->return_type->type == IL2CPP_TYPE_VOID;
    }

    inline bool IsVoidType(const Il2CppType* type)
    {
        return type->type == IL2CPP_TYPE_VOID;
    }

    inline const MethodInfo* GetUnderlyingMethodInfo(const MethodInfo* method)
    {
        return !method->genericMethod || method->is_generic ? method : method->genericMethod->methodDefinition;
    }

    inline bool IsChildTypeOfMulticastDelegate(const Il2CppClass* klass)
    {
        return klass->parent == il2cpp_defaults.multicastdelegate_class;
    }

    inline int32_t GetActualParamCount(const MethodInfo* methodInfo)
    {
        return IsInstanceMethod(methodInfo) ? (methodInfo->parameters_count + 1) : methodInfo->parameters_count;
    }

    inline int32_t GetFieldOffset(const FieldInfo* fieldInfo)
    {
        Il2CppClass* klass = fieldInfo->parent;
        return IS_CLASS_VALUE_TYPE(klass) ? (fieldInfo->offset - sizeof(Il2CppObject)) : fieldInfo->offset;
    }

    inline int32_t GetThreadStaticFieldOffset(const FieldInfo* fieldInfo)
    {
        return il2cpp::vm::MetadataCache::GetThreadLocalStaticOffsetForField(const_cast<FieldInfo*>(fieldInfo));
    }

    const Il2CppType* TryInflateIfNeed(const Il2CppType* selfType, const Il2CppGenericContext* genericContext, bool inflateMethodVars);
    const Il2CppType* TryInflateIfNeed(const Il2CppType* containerType, const Il2CppType* selfType);

    bool IsTypeSameByTypeIndex(TypeIndex t1, TypeIndex t2);

    bool IsTypeEqual(const Il2CppType* t1, const Il2CppType* t2);

    bool IsTypeGenericCompatible(const Il2CppType* t1, const Il2CppType* t2);

    bool IsOverrideMethod(const Il2CppType* type1, const Il2CppMethodDefinition* method1, const Il2CppType* type2, const Il2CppMethodDefinition* method2);
    bool IsOverrideMethodIgnoreName(const Il2CppType* type1, const Il2CppMethodDefinition* methodDef1, const Il2CppType* type2, const Il2CppMethodDefinition* methodDef2);

    const Il2CppMethodDefinition* ResolveMethodDefinition(const Il2CppType* type, const char* resolveMethodName, const MethodRefSig& resolveSig);

    const MethodInfo* GetMethodInfoFromMethodDef(const Il2CppType* type, const Il2CppMethodDefinition* methodDef);

    bool ResolveField(const Il2CppType* type, const char* resolveFieldName, const Il2CppType* resolveFieldType, const Il2CppFieldDefinition*& retFieldDef);

    inline void ResolveFieldThrow(const Il2CppType* type, const char* resolveFieldName, const Il2CppType* resolveFieldType, const Il2CppFieldDefinition*& retFieldDef)
    {
        if (!ResolveField(type, resolveFieldName, resolveFieldType, retFieldDef))
        {
            RaiseMissingFieldException(type, resolveFieldName);
        }
    }

    const Il2CppGenericContainer* GetGenericContainerFromIl2CppType(const Il2CppType* type);

    inline const Il2CppGenericContainer* GetGenericContainer(const MethodInfo* methodDef)
    {
        return methodDef->is_inflated ?
            (const Il2CppGenericContainer*)methodDef->genericMethod->methodDefinition->genericContainerHandle :
            (const Il2CppGenericContainer*)methodDef->genericContainerHandle;
    }

    bool IsMatchSigType(const Il2CppType* dstType, const Il2CppType* sigType, const Il2CppGenericContainer* klassGenericContainer, const Il2CppGenericContainer* methodGenericContainer);

    bool IsMatchMethodSig(const Il2CppMethodDefinition* methodDef, const MethodRefSig& resolveSig, const Il2CppGenericContainer* klassGenericContainer);
    bool IsMatchMethodSig(const MethodInfo* methodDef, const MethodRefSig& resolveSig, const Il2CppGenericContainer* klassGenericContainer);
    bool IsMatchMethodSig(const MethodInfo* methodDef, const MethodRefSig& resolveSig, const Il2CppType** klassInstArgv, const Il2CppType** methodInstArgv);

    const Il2CppGenericInst* TryInflateGenericInst(const Il2CppGenericInst* inst, const Il2CppGenericContext* genericContext);

	bool HasNotInstantiatedGenericType(const Il2CppType* type);
    bool HasNotInstantiatedGenericType(const Il2CppGenericInst* inst);

#pragma endregion


#pragma region misc

    int32_t GetTypeValueSize(const Il2CppType* type);

    inline int32_t GetTypeValueSize(const Il2CppClass* klass)
    {
        if (IS_CLASS_VALUE_TYPE(klass))
        {
            return il2cpp::vm::Class::GetValueSize((Il2CppClass*)klass, nullptr);
        }
        else
        {
            return sizeof(Il2CppObject*);
        }
    }

    inline int32_t GetStackSizeByByteSize(int32_t size)
    {
        return (size + 7) / 8;
    }

    inline int32_t GetTypeValueStackObjectCount(const Il2CppType* type)
    {
        return (GetTypeValueSize(type) + 7) / 8;
    }

    inline void RaiseBadImageException(const char* msg = nullptr)
    {
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetBadImageFormatException(msg));
    }
#pragma endregion

    class Il2CppTypeHashShallow
    {
    public:
        size_t operator()(const Il2CppType* t1) const
        {
            size_t h = (size_t)t1->data.dummy;
            h = il2cpp::utils::HashUtils::Combine(h, t1->attrs);
            h = il2cpp::utils::HashUtils::Combine(h, (size_t)t1->type);
            h = il2cpp::utils::HashUtils::Combine(h, t1->byref);
            h = il2cpp::utils::HashUtils::Combine(h, t1->pinned);
#if HYBRIDCLR_UNITY_2021_OR_NEW
            h = il2cpp::utils::HashUtils::Combine(h, t1->valuetype);
#endif
            return h;
        }
    };

    class Il2CppTypeEqualityComparerShallow
    {
    public:
        bool operator()(const Il2CppType* t1, const Il2CppType* t2) const
        {
            return (t1->data.dummy == t2->data.dummy)
                && t1->type == t2->type
                && t1->attrs == t2->attrs
                && t1->byref == t2->byref
                && t1->pinned == t2->pinned
#if HYBRIDCLR_UNITY_2021_OR_NEW
                && t1->valuetype == t2->valuetype
#endif
                ;
        }
    };

}
}
```

`hybridclr/metadata/MethodBodyCache.cpp`:

```cpp
#include <unordered_map>

#include "MethodBodyCache.h"

#include "MetadataModule.h"
#include "AOTHomologousImage.h"
#include "Opcodes.h"
#include "MetadataDef.h"

#include "utils/HashUtils.h"
#include "../RuntimeConfig.h"

namespace hybridclr
{
namespace metadata
{
	struct ImageTokenPair
	{
		hybridclr::metadata::Image* image;
		uint32_t token;
	};

	struct ImageTokenPairHash
	{
		size_t operator()(const ImageTokenPair& s) const noexcept
		{
			return il2cpp::utils::HashUtils::Combine((size_t)s.image, (size_t)s.token);
		}
	};

	struct ImageTokenPairEqualTo
	{
		bool operator()(const ImageTokenPair& p1, const ImageTokenPair& p2) const
		{
			return p1.image == p2.image && p1.token == p2.token;
		}
	};

	enum class InlineMode : uint8_t
	{
		None,
		Inlineable,
		NotInlineable,
	};

	struct MethodBodyCacheInfo
	{
		MethodBody* methodBody;
		int32_t accessVersion;
		uint16_t accessCount;
		InlineMode inlineMode;
	};

	constexpr int32_t kMinShrinkMethodBodyCacheInterval = 256;
	static bool s_enableShrinkMethodBodyCache = true;
	static int32_t s_methodBodyCacheVersion = 0;
	static Il2CppHashMap<ImageTokenPair, MethodBodyCacheInfo*, ImageTokenPairHash, ImageTokenPairEqualTo> s_methodBodyCache;


	static MethodBodyCacheInfo* GetOrInitMethodBodyCache(hybridclr::metadata::Image* image, uint32_t token)
	{
		ImageTokenPair key = { image, token };
		auto it = s_methodBodyCache.find(key);
		if (it != s_methodBodyCache.end())
		{
			return it->second;
		}
		MethodBody* methodBody = image->GetMethodBody(token);
		MethodBodyCacheInfo* ci = (MethodBodyCacheInfo*)HYBRIDCLR_MALLOC_ZERO(sizeof(MethodBodyCacheInfo));
		*ci = { methodBody, s_methodBodyCacheVersion, 0, InlineMode::None};
		s_methodBodyCache[key] = ci;
		return ci;
	}

	MethodBody* MethodBodyCache::GetMethodBody(hybridclr::metadata::Image* image, uint32_t token)
	{
		MethodBodyCacheInfo* ci = GetOrInitMethodBodyCache(image, token);
		ci->accessVersion = s_methodBodyCacheVersion;
		++ci->accessCount;
		return ci->methodBody;
	}

	static void ShrinkMethodBodyCache(int32_t shrinkMethodBodyCacheInterval)
	{
		if (s_methodBodyCache.size() <= RuntimeConfig::GetMaxMethodBodyCacheSize())
		{
			return;
		}

		int32_t expiredVersion = s_methodBodyCacheVersion - shrinkMethodBodyCacheInterval;
		for (auto it = s_methodBodyCache.begin(); it != s_methodBodyCache.end(); )
		{
			MethodBodyCacheInfo* ci = it->second;
			// add extra interval when accessCount exceeded 1
			int32_t accessVersion = ci->accessVersion + (ci->accessCount - 1) * shrinkMethodBodyCacheInterval;
			if (accessVersion < expiredVersion)
			{
				if (ci->methodBody)
				{
					ci->methodBody->~MethodBody();
					HYBRIDCLR_FREE(ci->methodBody);
				}
				HYBRIDCLR_FREE(ci);
				s_methodBodyCache.erase(it++);
			}
			else
			{
				++it;
			}
		}
	}

	void MethodBodyCache::EnableShrinkMethodBodyCache(bool shrink)
	{
		s_enableShrinkMethodBodyCache = shrink;
		if (shrink)
		{
			++s_methodBodyCacheVersion;

			int32_t shrinkMethodBodyCacheInterval = std::max(RuntimeConfig::GetMaxMethodBodyCacheSize() / 2, kMinShrinkMethodBodyCacheInterval);
			if (s_methodBodyCacheVersion % shrinkMethodBodyCacheInterval == 0)
			{
				ShrinkMethodBodyCache(shrinkMethodBodyCacheInterval);
			}
		}
	}

	static bool IsILCodeInlineable(const byte* ilcodeStart, uint32_t codeSize)
	{
		const byte* codeEnd = ilcodeStart + codeSize;
		const byte* ip = ilcodeStart;

		while (ip < codeEnd)
		{
			const OpCodeInfo* oc = DecodeOpCodeInfo(ip, codeEnd);
			IL2CPP_ASSERT(oc);
			int32_t opCodeSize = GetOpCodeSize(ip, oc);
			ip += opCodeSize;
			int32_t nextOffset = (int32_t)(ip - ilcodeStart);
			IL2CPP_ASSERT(nextOffset >= 0 && nextOffset <= (int32_t)codeSize);

			switch (oc->flow)
			{
			case FlowType::Branch:
			case FlowType::CondBranch:
			case FlowType::Throw:
			{
				return false;
			}
			default: break;
			}
		}
		IL2CPP_ASSERT(ip == codeEnd);
		return true;
	}

	static bool ComputeInlinable(metadata::Image* image, uint32_t token)
	{
		metadata::MethodBody* methodBody = MethodBodyCache::GetMethodBody(image, token);
		if (methodBody == nullptr || methodBody->ilcodes == nullptr)
		{
			return false;
		}

		if ((int32_t)methodBody->codeSize > RuntimeConfig::GetMaxInlineableMethodBodySize() || !methodBody->exceptionClauses.empty())
		{
			return false;
		}

		return IsILCodeInlineable(methodBody->ilcodes, methodBody->codeSize);
	}

	bool MethodBodyCache::IsInlineable(const MethodInfo* methodInfo)
	{
		IL2CPP_ASSERT(methodInfo->isInterpterImpl);

		metadata::Image* image = MetadataModule::GetUnderlyingInterpreterImage(methodInfo);
		IL2CPP_ASSERT(image);
		MethodBodyCacheInfo* ci = GetOrInitMethodBodyCache(image, methodInfo->token);
		ci->accessVersion = s_methodBodyCacheVersion;
		++ci->accessCount;
		if (ci->inlineMode != InlineMode::None)
		{
			return ci->inlineMode == InlineMode::Inlineable;
		}
		bool inlineable = ComputeInlinable(image, methodInfo->token);
		ci->inlineMode = inlineable ? InlineMode::Inlineable : InlineMode::NotInlineable;
		return inlineable;
	}

	void MethodBodyCache::DisableInline(const MethodInfo* methodInfo)
	{
		IL2CPP_ASSERT(methodInfo->isInterpterImpl);
		metadata::Image* image = MetadataModule::GetUnderlyingInterpreterImage(methodInfo);
		IL2CPP_ASSERT(image);
		MethodBodyCacheInfo* ci = GetOrInitMethodBodyCache(image, methodInfo->token);
		ci->inlineMode = InlineMode::NotInlineable;
	}
}
}
```

`hybridclr/metadata/MethodBodyCache.h`:

```h
#pragma once

#include "Image.h"

namespace hybridclr
{
namespace metadata
{
	class MethodBodyCache
	{
	public:
		static MethodBody* GetMethodBody(hybridclr::metadata::Image* image, uint32_t token);
		static void EnableShrinkMethodBodyCache(bool shrink);

		static bool IsInlineable(const MethodInfo* method);
		static void DisableInline(const MethodInfo* method);
	};
}
}
```

`hybridclr/metadata/Opcodes.cpp`:

```cpp
#include "Opcodes.h"

#include "MetadataUtil.h"

namespace hybridclr
{
namespace metadata
{

	OpCodeInfo g_opcodeInfos[(int)OpcodeEnum::__Count] =
	{
		//!!!{{OPCODE_INFO
		{ OpcodeEnum::NOP, "nop", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::NOP, FlowType::Next, 0 },
		{ OpcodeEnum::BREAK, "break", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::BREAK, FlowType::Break, 0 },
		{ OpcodeEnum::LDARG_0, "ldarg.0", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDARG_0, FlowType::Next, 0 },
		{ OpcodeEnum::LDARG_1, "ldarg.1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDARG_1, FlowType::Next, 1 },
		{ OpcodeEnum::LDARG_2, "ldarg.2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDARG_2, FlowType::Next, 2 },
		{ OpcodeEnum::LDARG_3, "ldarg.3", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDARG_3, FlowType::Next, 3 },
		{ OpcodeEnum::LDLOC_0, "ldloc.0", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDLOC_0, FlowType::Next, 0 },
		{ OpcodeEnum::LDLOC_1, "ldloc.1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDLOC_1, FlowType::Next, 1 },
		{ OpcodeEnum::LDLOC_2, "ldloc.2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDLOC_2, FlowType::Next, 2 },
		{ OpcodeEnum::LDLOC_3, "ldloc.3", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDLOC_3, FlowType::Next, 3 },
		{ OpcodeEnum::STLOC_0, "stloc.0", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STLOC_0, FlowType::Next, 0 },
		{ OpcodeEnum::STLOC_1, "stloc.1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STLOC_1, FlowType::Next, 1 },
		{ OpcodeEnum::STLOC_2, "stloc.2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STLOC_2, FlowType::Next, 2 },
		{ OpcodeEnum::STLOC_3, "stloc.3", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STLOC_3, FlowType::Next, 3 },
		{ OpcodeEnum::LDARG_S, "ldarg.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::LDARG_S, FlowType::Next, 0 },
		{ OpcodeEnum::LDARGA_S, "ldarga.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::LDARGA_S, FlowType::Next, 0 },
		{ OpcodeEnum::STARG_S, "starg.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::STARG_S, FlowType::Next, 0 },
		{ OpcodeEnum::LDLOC_S, "ldloc.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::LDLOC_S, FlowType::Next, 0 },
		{ OpcodeEnum::LDLOCA_S, "ldloca.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::LDLOCA_S, FlowType::Next, 0 },
		{ OpcodeEnum::STLOC_S, "stloc.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::STLOC_S, FlowType::Next, 0 },
		{ OpcodeEnum::LDNULL, "ldnull", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDNULL, FlowType::Next, 0 },
		{ OpcodeEnum::LDC_I4_M1, "ldc.i4.m1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_M1, FlowType::Next, -1 },
		{ OpcodeEnum::LDC_I4_0, "ldc.i4.0", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_0, FlowType::Next, 0 },
		{ OpcodeEnum::LDC_I4_1, "ldc.i4.1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_1, FlowType::Next, 1 },
		{ OpcodeEnum::LDC_I4_2, "ldc.i4.2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_2, FlowType::Next, 2 },
		{ OpcodeEnum::LDC_I4_3, "ldc.i4.3", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_3, FlowType::Next, 3 },
		{ OpcodeEnum::LDC_I4_4, "ldc.i4.4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_4, FlowType::Next, 4 },
		{ OpcodeEnum::LDC_I4_5, "ldc.i4.5", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_5, FlowType::Next, 5 },
		{ OpcodeEnum::LDC_I4_6, "ldc.i4.6", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_6, FlowType::Next, 6 },
		{ OpcodeEnum::LDC_I4_7, "ldc.i4.7", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_7, FlowType::Next, 7 },
		{ OpcodeEnum::LDC_I4_8, "ldc.i4.8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDC_I4_8, FlowType::Next, 8 },
		{ OpcodeEnum::LDC_I4_S, "ldc.i4.s", {}, OutputType::None, ArgType::Data, 1, 255, OpcodeValue::LDC_I4_S, FlowType::Next, 0 },
		{ OpcodeEnum::LDC_I4, "ldc.i4", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDC_I4, FlowType::Next, 0 },
		{ OpcodeEnum::LDC_I8, "ldc.i8", {}, OutputType::None, ArgType::Data, 8, 255, OpcodeValue::LDC_I8, FlowType::Next, 0 },
		{ OpcodeEnum::LDC_R4, "ldc.r4", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDC_R4, FlowType::Next, 0 },
		{ OpcodeEnum::LDC_R8, "ldc.r8", {}, OutputType::None, ArgType::Data, 8, 255, OpcodeValue::LDC_R8, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED99, "unused99", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED99, FlowType::Next, 0 },
		{ OpcodeEnum::DUP, "dup", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::DUP, FlowType::Next, 0 },
		{ OpcodeEnum::POP, "pop", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::POP, FlowType::Next, 0 },
		{ OpcodeEnum::JMP, "jmp", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::JMP, FlowType::Call, 0 },
		{ OpcodeEnum::CALL, "call", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::CALL, FlowType::Call, 0 },
		{ OpcodeEnum::CALLI, "calli", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::CALLI, FlowType::Call, 0 },
		{ OpcodeEnum::RET, "ret", {}, OutputType::None, ArgType::StaticBranch, 0, 255, OpcodeValue::RET, FlowType::Return, 0 },
		{ OpcodeEnum::BR_S, "br.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BR_S, FlowType::Branch, 0 },
		{ OpcodeEnum::BRFALSE_S, "brfalse.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BRFALSE_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BRTRUE_S, "brtrue.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BRTRUE_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BEQ_S, "beq.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BEQ_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGE_S, "bge.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BGE_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGT_S, "bgt.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BGT_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLE_S, "ble.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BLE_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLT_S, "blt.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BLT_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BNE_UN_S, "bne.un.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BNE_UN_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGE_UN_S, "bge.un.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BGE_UN_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGT_UN_S, "bgt.un.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BGT_UN_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLE_UN_S, "ble.un.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BLE_UN_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLT_UN_S, "blt.un.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::BLT_UN_S, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BR, "br", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BR, FlowType::Branch, 0 },
		{ OpcodeEnum::BRFALSE, "brfalse", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BRFALSE, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BRTRUE, "brtrue", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BRTRUE, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BEQ, "beq", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BEQ, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGE, "bge", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BGE, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGT, "bgt", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BGT, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLE, "ble", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BLE, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLT, "blt", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BLT, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BNE_UN, "bne.un", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BNE_UN, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGE_UN, "bge.un", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BGE_UN, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BGT_UN, "bgt.un", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BGT_UN, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLE_UN, "ble.un", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BLE_UN, FlowType::CondBranch, 0 },
		{ OpcodeEnum::BLT_UN, "blt.un", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::BLT_UN, FlowType::CondBranch, 0 },
		{ OpcodeEnum::SWITCH, "switch", {}, OutputType::None, ArgType::Switch, -1, 255, OpcodeValue::SWITCH, FlowType::CondBranch, 0 },
		{ OpcodeEnum::LDIND_I1, "ldind.i1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_I1, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_U1, "ldind.u1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_U1, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_I2, "ldind.i2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_I2, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_U2, "ldind.u2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_U2, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_I4, "ldind.i4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_I4, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_U4, "ldind.u4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_U4, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_I8, "ldind.i8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_I8, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_I, "ldind.i", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_I, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_R4, "ldind.r4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_R4, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_R8, "ldind.r8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_R8, FlowType::Next, 0 },
		{ OpcodeEnum::LDIND_REF, "ldind.ref", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDIND_REF, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_REF, "stind.ref", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_REF, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_I1, "stind.i1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_I1, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_I2, "stind.i2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_I2, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_I4, "stind.i4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_I4, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_I8, "stind.i8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_I8, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_R4, "stind.r4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_R4, FlowType::Next, 0 },
		{ OpcodeEnum::STIND_R8, "stind.r8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_R8, FlowType::Next, 0 },
		{ OpcodeEnum::ADD, "add", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::ADD, FlowType::Next, 0 },
		{ OpcodeEnum::SUB, "sub", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::SUB, FlowType::Next, 0 },
		{ OpcodeEnum::MUL, "mul", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::MUL, FlowType::Next, 0 },
		{ OpcodeEnum::DIV, "div", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::DIV, FlowType::Next, 0 },
		{ OpcodeEnum::DIV_UN, "div.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::DIV_UN, FlowType::Next, 0 },
		{ OpcodeEnum::REM, "rem", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::REM, FlowType::Next, 0 },
		{ OpcodeEnum::REM_UN, "rem.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::REM_UN, FlowType::Next, 0 },
		{ OpcodeEnum::AND, "and", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::AND, FlowType::Next, 0 },
		{ OpcodeEnum::OR, "or", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::OR, FlowType::Next, 0 },
		{ OpcodeEnum::XOR, "xor", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::XOR, FlowType::Next, 0 },
		{ OpcodeEnum::SHL, "shl", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::SHL, FlowType::Next, 0 },
		{ OpcodeEnum::SHR, "shr", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::SHR, FlowType::Next, 0 },
		{ OpcodeEnum::SHR_UN, "shr.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::SHR_UN, FlowType::Next, 0 },
		{ OpcodeEnum::NEG, "neg", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::NEG, FlowType::Next, 0 },
		{ OpcodeEnum::NOT, "not", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::NOT, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_I1, "conv.i1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_I1, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_I2, "conv.i2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_I2, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_I4, "conv.i4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_I4, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_I8, "conv.i8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_I8, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_R4, "conv.r4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_R4, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_R8, "conv.r8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_R8, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_U4, "conv.u4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_U4, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_U8, "conv.u8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_U8, FlowType::Next, 0 },
		{ OpcodeEnum::CALLVIRT, "callvirt", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::CALLVIRT, FlowType::Call, 0 },
		{ OpcodeEnum::CPOBJ, "cpobj", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::CPOBJ, FlowType::Next, 0 },
		{ OpcodeEnum::LDOBJ, "ldobj", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDOBJ, FlowType::Next, 0 },
		{ OpcodeEnum::LDSTR, "ldstr", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDSTR, FlowType::Next, 0 },
		{ OpcodeEnum::NEWOBJ, "newobj", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::NEWOBJ, FlowType::Call, 0 },
		{ OpcodeEnum::CASTCLASS, "castclass", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::CASTCLASS, FlowType::Next, 0 },
		{ OpcodeEnum::ISINST, "isinst", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::ISINST, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_R_UN, "conv.r.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_R_UN, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED58, "unused58", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED58, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED1, "unused1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED1, FlowType::Next, 0 },
		{ OpcodeEnum::UNBOX, "unbox", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::UNBOX, FlowType::Next, 0 },
		{ OpcodeEnum::THROW, "throw", {}, OutputType::None, ArgType::StaticBranch, 0, 255, OpcodeValue::THROW, FlowType::Throw, 0 },
		{ OpcodeEnum::LDFLD, "ldfld", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDFLD, FlowType::Next, 0 },
		{ OpcodeEnum::LDFLDA, "ldflda", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDFLDA, FlowType::Next, 0 },
		{ OpcodeEnum::STFLD, "stfld", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::STFLD, FlowType::Next, 0 },
		{ OpcodeEnum::LDSFLD, "ldsfld", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDSFLD, FlowType::Next, 0 },
		{ OpcodeEnum::LDSFLDA, "ldsflda", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDSFLDA, FlowType::Next, 0 },
		{ OpcodeEnum::STSFLD, "stsfld", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::STSFLD, FlowType::Next, 0 },
		{ OpcodeEnum::STOBJ, "stobj", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::STOBJ, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I1_UN, "conv.ovf.i1.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I1_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I2_UN, "conv.ovf.i2.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I2_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I4_UN, "conv.ovf.i4.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I4_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I8_UN, "conv.ovf.i8.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I8_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U1_UN, "conv.ovf.u1.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U1_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U2_UN, "conv.ovf.u2.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U2_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U4_UN, "conv.ovf.u4.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U4_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U8_UN, "conv.ovf.u8.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U8_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I_UN, "conv.ovf.i.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U_UN, "conv.ovf.u.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U_UN, FlowType::Next, 0 },
		{ OpcodeEnum::BOX, "box", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::BOX, FlowType::Next, 0 },
		{ OpcodeEnum::NEWARR, "newarr", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::NEWARR, FlowType::Next, 0 },
		{ OpcodeEnum::LDLEN, "ldlen", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDLEN, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEMA, "ldelema", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDELEMA, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_I1, "ldelem.i1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_I1, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_U1, "ldelem.u1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_U1, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_I2, "ldelem.i2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_I2, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_U2, "ldelem.u2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_U2, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_I4, "ldelem.i4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_I4, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_U4, "ldelem.u4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_U4, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_I8, "ldelem.i8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_I8, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_I, "ldelem.i", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_I, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_R4, "ldelem.r4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_R4, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_R8, "ldelem.r8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_R8, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM_REF, "ldelem.ref", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::LDELEM_REF, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_I, "stelem.i", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_I, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_I1, "stelem.i1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_I1, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_I2, "stelem.i2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_I2, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_I4, "stelem.i4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_I4, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_I8, "stelem.i8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_I8, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_R4, "stelem.r4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_R4, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_R8, "stelem.r8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_R8, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM_REF, "stelem.ref", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STELEM_REF, FlowType::Next, 0 },
		{ OpcodeEnum::LDELEM, "ldelem", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDELEM, FlowType::Next, 0 },
		{ OpcodeEnum::STELEM, "stelem", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::STELEM, FlowType::Next, 0 },
		{ OpcodeEnum::UNBOX_ANY, "unbox.any", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::UNBOX_ANY, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED5, "unused5", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED5, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED6, "unused6", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED6, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED7, "unused7", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED7, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED8, "unused8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED8, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED9, "unused9", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED9, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED10, "unused10", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED10, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED11, "unused11", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED11, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED12, "unused12", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED12, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED13, "unused13", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED13, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED14, "unused14", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED14, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED15, "unused15", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED15, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED16, "unused16", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED16, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED17, "unused17", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED17, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I1, "conv.ovf.i1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I1, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U1, "conv.ovf.u1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U1, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I2, "conv.ovf.i2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I2, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U2, "conv.ovf.u2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U2, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I4, "conv.ovf.i4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I4, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U4, "conv.ovf.u4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U4, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I8, "conv.ovf.i8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I8, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U8, "conv.ovf.u8", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U8, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED50, "unused50", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED50, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED18, "unused18", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED18, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED19, "unused19", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED19, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED20, "unused20", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED20, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED21, "unused21", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED21, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED22, "unused22", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED22, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED23, "unused23", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED23, FlowType::Next, 0 },
		{ OpcodeEnum::REFANYVAL, "refanyval", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::REFANYVAL, FlowType::Next, 0 },
		{ OpcodeEnum::CKFINITE, "ckfinite", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CKFINITE, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED24, "unused24", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED24, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED25, "unused25", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED25, FlowType::Next, 0 },
		{ OpcodeEnum::MKREFANY, "mkrefany", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::MKREFANY, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED59, "unused59", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED59, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED60, "unused60", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED60, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED61, "unused61", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED61, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED62, "unused62", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED62, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED63, "unused63", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED63, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED64, "unused64", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED64, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED65, "unused65", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED65, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED66, "unused66", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED66, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED67, "unused67", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED67, FlowType::Next, 0 },
		{ OpcodeEnum::LDTOKEN, "ldtoken", {}, OutputType::None, ArgType::Data, 4, 255, OpcodeValue::LDTOKEN, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_U2, "conv.u2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_U2, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_U1, "conv.u1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_U1, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_I, "conv.i", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_I, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_I, "conv.ovf.i", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_I, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_OVF_U, "conv.ovf.u", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_OVF_U, FlowType::Next, 0 },
		{ OpcodeEnum::ADD_OVF, "add.ovf", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::ADD_OVF, FlowType::Next, 0 },
		{ OpcodeEnum::ADD_OVF_UN, "add.ovf.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::ADD_OVF_UN, FlowType::Next, 0 },
		{ OpcodeEnum::MUL_OVF, "mul.ovf", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::MUL_OVF, FlowType::Next, 0 },
		{ OpcodeEnum::MUL_OVF_UN, "mul.ovf.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::MUL_OVF_UN, FlowType::Next, 0 },
		{ OpcodeEnum::SUB_OVF, "sub.ovf", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::SUB_OVF, FlowType::Next, 0 },
		{ OpcodeEnum::SUB_OVF_UN, "sub.ovf.un", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::SUB_OVF_UN, FlowType::Next, 0 },
		{ OpcodeEnum::ENDFINALLY, "endfinally", {}, OutputType::None, ArgType::StaticBranch, 0, 255, OpcodeValue::ENDFINALLY, FlowType::Return, 0 },
		{ OpcodeEnum::LEAVE, "leave", {}, OutputType::None, ArgType::BranchTarget, 4, 255, OpcodeValue::LEAVE, FlowType::Branch, 0 },
		{ OpcodeEnum::LEAVE_S, "leave.s", {}, OutputType::None, ArgType::BranchTarget, 1, 255, OpcodeValue::LEAVE_S, FlowType::Branch, 0 },
		{ OpcodeEnum::STIND_I, "stind.i", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::STIND_I, FlowType::Next, 0 },
		{ OpcodeEnum::CONV_U, "conv.u", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::CONV_U, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED26, "unused26", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED26, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED27, "unused27", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED27, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED28, "unused28", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED28, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED29, "unused29", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED29, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED30, "unused30", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED30, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED31, "unused31", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED31, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED32, "unused32", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED32, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED33, "unused33", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED33, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED34, "unused34", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED34, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED35, "unused35", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED35, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED36, "unused36", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED36, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED37, "unused37", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED37, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED38, "unused38", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED38, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED39, "unused39", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED39, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED40, "unused40", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED40, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED41, "unused41", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED41, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED42, "unused42", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED42, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED43, "unused43", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED43, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED44, "unused44", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED44, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED45, "unused45", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED45, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED46, "unused46", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED46, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED47, "unused47", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED47, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED48, "unused48", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::UNUSED48, FlowType::Next, 0 },
		{ OpcodeEnum::PREFIX7, "prefix7", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX7, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIX6, "prefix6", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX6, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIX5, "prefix5", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX5, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIX4, "prefix4", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX4, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIX3, "prefix3", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX3, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIX2, "prefix2", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX2, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIX1, "prefix1", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIX1, FlowType::Meta, 0 },
		{ OpcodeEnum::PREFIXREF, "prefixref", {}, OutputType::None, ArgType::None, 0, 255, OpcodeValue::PREFIXREF, FlowType::Meta, 0 },
		{ OpcodeEnum::ARGLIST, "arglist", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::ARGLIST, FlowType::Next, 0 },
		{ OpcodeEnum::CEQ, "ceq", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::CEQ, FlowType::Next, 0 },
		{ OpcodeEnum::CGT, "cgt", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::CGT, FlowType::Next, 0 },
		{ OpcodeEnum::CGT_UN, "cgt.un", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::CGT_UN, FlowType::Next, 0 },
		{ OpcodeEnum::CLT, "clt", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::CLT, FlowType::Next, 0 },
		{ OpcodeEnum::CLT_UN, "clt.un", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::CLT_UN, FlowType::Next, 0 },
		{ OpcodeEnum::LDFTN, "ldftn", {}, OutputType::None, ArgType::Data, 4, 254, OpcodeValue::LDFTN, FlowType::Next, 0 },
		{ OpcodeEnum::LDVIRTFTN, "ldvirtftn", {}, OutputType::None, ArgType::Data, 4, 254, OpcodeValue::LDVIRTFTN, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED56, "unused56", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED56, FlowType::Next, 0 },
		{ OpcodeEnum::LDARG, "ldarg", {}, OutputType::None, ArgType::Data, 2, 254, OpcodeValue::LDARG, FlowType::Next, 0 },
		{ OpcodeEnum::LDARGA, "ldarga", {}, OutputType::None, ArgType::Data, 2, 254, OpcodeValue::LDARGA, FlowType::Next, 0 },
		{ OpcodeEnum::STARG, "starg", {}, OutputType::None, ArgType::Data, 2, 254, OpcodeValue::STARG, FlowType::Next, 0 },
		{ OpcodeEnum::LDLOC, "ldloc", {}, OutputType::None, ArgType::Data, 2, 254, OpcodeValue::LDLOC, FlowType::Next, 0 },
		{ OpcodeEnum::LDLOCA, "ldloca", {}, OutputType::None, ArgType::Data, 2, 254, OpcodeValue::LDLOCA, FlowType::Next, 0 },
		{ OpcodeEnum::STLOC, "stloc", {}, OutputType::None, ArgType::Data, 2, 254, OpcodeValue::STLOC, FlowType::Next, 0 },
		{ OpcodeEnum::LOCALLOC, "localloc", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::LOCALLOC, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED57, "unused57", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED57, FlowType::Next, 0 },
		{ OpcodeEnum::ENDFILTER, "endfilter", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::ENDFILTER, FlowType::Return, 0 },
		{ OpcodeEnum::UNALIGNED_, "unaligned.", {}, OutputType::None, ArgType::Data, 1, 254, OpcodeValue::UNALIGNED_, FlowType::Meta, 0 },
		{ OpcodeEnum::VOLATILE_, "volatile.", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::VOLATILE_, FlowType::Meta, 0 },
		{ OpcodeEnum::TAIL_, "tail.", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::TAIL_, FlowType::Meta, 0 },
		{ OpcodeEnum::INITOBJ, "initobj", {}, OutputType::None, ArgType::Data, 4, 254, OpcodeValue::INITOBJ, FlowType::Next, 0 },
		{ OpcodeEnum::CONSTRAINED_, "constrained.", {}, OutputType::None, ArgType::Data, 4, 254, OpcodeValue::CONSTRAINED_, FlowType::Meta, 0 },
		{ OpcodeEnum::CPBLK, "cpblk", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::CPBLK, FlowType::Next, 0 },
		{ OpcodeEnum::INITBLK, "initblk", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::INITBLK, FlowType::Next, 0 },
		{ OpcodeEnum::NO_, "no.", {}, OutputType::None, ArgType::Data, 1, 254, OpcodeValue::NO_, FlowType::Next, 0 },
		{ OpcodeEnum::RETHROW, "rethrow", {}, OutputType::None, ArgType::StaticBranch, 0, 254, OpcodeValue::RETHROW, FlowType::Throw, 0 },
		{ OpcodeEnum::UNUSED, "unused", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED, FlowType::Next, 0 },
		{ OpcodeEnum::SIZEOF, "sizeof", {}, OutputType::None, ArgType::Data, 4, 254, OpcodeValue::SIZEOF, FlowType::Next, 0 },
		{ OpcodeEnum::REFANYTYPE, "refanytype", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::REFANYTYPE, FlowType::Next, 0 },
		{ OpcodeEnum::READONLY_, "readonly.", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::READONLY_, FlowType::Meta, 0 },
		{ OpcodeEnum::UNUSED53, "unused53", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED53, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED54, "unused54", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED54, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED55, "unused55", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED55, FlowType::Next, 0 },
		{ OpcodeEnum::UNUSED70, "unused70", {}, OutputType::None, ArgType::None, 0, 254, OpcodeValue::UNUSED70, FlowType::Next, 0 },
		{ OpcodeEnum::ILLEGAL, "illegal", {}, OutputType::None, ArgType::None, 0, 0, OpcodeValue::ILLEGAL, FlowType::Meta, 0 },
		{ OpcodeEnum::ENDMAC, "endmac", {}, OutputType::None, ArgType::None, 0, 0, OpcodeValue::ENDMAC, FlowType::Meta, 0 },

		//!!!}}OPCODE_INFO
	};

	const OpCodeInfo* DecodeOpCodeInfo(const byte*& ip, const byte* end)
	{
		if (ip >= end)
		{
			return nullptr;
		}
		byte c = *ip;
		if (c < (byte)OpcodeValue::PREFIX7)
		{
			return &g_opcodeInfos[c];
		}
		else if (c == (byte)OpcodeValue::PREFIX1)
		{
			++ip;
			if (ip >= end)
			{
				return nullptr;
			}
			return &g_opcodeInfos[(int)(*ip) + (int)OpcodeEnum::ARGLIST];
		}
		else
		{
			IL2CPP_ASSERT(false && "unknown prefix");
			return nullptr;
		}
	}

	uint32_t GetOpCodeSize(const byte*& ip, const OpCodeInfo* opCodeInfo)
	{
		if (opCodeInfo->inlineType != ArgType::Switch)
		{
			return 1 + opCodeInfo->inlineParam;
		}
		else
		{
			return metadata::GetI4LittleEndian(ip + 1) * 4 + 5;
		}
	}
}
}
```

`hybridclr/metadata/Opcodes.h`:

```h
#pragma once

#include "../CommonDef.h"

namespace hybridclr
{
namespace metadata
{
	enum class OpcodeValue : uint8_t
	{
		//!!!{{OPCODE_VALUE
		NOP = 0,
		BREAK = 1,
		LDARG_0 = 2,
		LDARG_1 = 3,
		LDARG_2 = 4,
		LDARG_3 = 5,
		LDLOC_0 = 6,
		LDLOC_1 = 7,
		LDLOC_2 = 8,
		LDLOC_3 = 9,
		STLOC_0 = 10,
		STLOC_1 = 11,
		STLOC_2 = 12,
		STLOC_3 = 13,
		LDARG_S = 14,
		LDARGA_S = 15,
		STARG_S = 16,
		LDLOC_S = 17,
		LDLOCA_S = 18,
		STLOC_S = 19,
		LDNULL = 20,
		LDC_I4_M1 = 21,
		LDC_I4_0 = 22,
		LDC_I4_1 = 23,
		LDC_I4_2 = 24,
		LDC_I4_3 = 25,
		LDC_I4_4 = 26,
		LDC_I4_5 = 27,
		LDC_I4_6 = 28,
		LDC_I4_7 = 29,
		LDC_I4_8 = 30,
		LDC_I4_S = 31,
		LDC_I4 = 32,
		LDC_I8 = 33,
		LDC_R4 = 34,
		LDC_R8 = 35,
		UNUSED99 = 36,
		DUP = 37,
		POP = 38,
		JMP = 39,
		CALL = 40,
		CALLI = 41,
		RET = 42,
		BR_S = 43,
		BRFALSE_S = 44,
		BRTRUE_S = 45,
		BEQ_S = 46,
		BGE_S = 47,
		BGT_S = 48,
		BLE_S = 49,
		BLT_S = 50,
		BNE_UN_S = 51,
		BGE_UN_S = 52,
		BGT_UN_S = 53,
		BLE_UN_S = 54,
		BLT_UN_S = 55,
		BR = 56,
		BRFALSE = 57,
		BRTRUE = 58,
		BEQ = 59,
		BGE = 60,
		BGT = 61,
		BLE = 62,
		BLT = 63,
		BNE_UN = 64,
		BGE_UN = 65,
		BGT_UN = 66,
		BLE_UN = 67,
		BLT_UN = 68,
		SWITCH = 69,
		LDIND_I1 = 70,
		LDIND_U1 = 71,
		LDIND_I2 = 72,
		LDIND_U2 = 73,
		LDIND_I4 = 74,
		LDIND_U4 = 75,
		LDIND_I8 = 76,
		LDIND_I = 77,
		LDIND_R4 = 78,
		LDIND_R8 = 79,
		LDIND_REF = 80,
		STIND_REF = 81,
		STIND_I1 = 82,
		STIND_I2 = 83,
		STIND_I4 = 84,
		STIND_I8 = 85,
		STIND_R4 = 86,
		STIND_R8 = 87,
		ADD = 88,
		SUB = 89,
		MUL = 90,
		DIV = 91,
		DIV_UN = 92,
		REM = 93,
		REM_UN = 94,
		AND = 95,
		OR = 96,
		XOR = 97,
		SHL = 98,
		SHR = 99,
		SHR_UN = 100,
		NEG = 101,
		NOT = 102,
		CONV_I1 = 103,
		CONV_I2 = 104,
		CONV_I4 = 105,
		CONV_I8 = 106,
		CONV_R4 = 107,
		CONV_R8 = 108,
		CONV_U4 = 109,
		CONV_U8 = 110,
		CALLVIRT = 111,
		CPOBJ = 112,
		LDOBJ = 113,
		LDSTR = 114,
		NEWOBJ = 115,
		CASTCLASS = 116,
		ISINST = 117,
		CONV_R_UN = 118,
		UNUSED58 = 119,
		UNUSED1 = 120,
		UNBOX = 121,
		THROW = 122,
		LDFLD = 123,
		LDFLDA = 124,
		STFLD = 125,
		LDSFLD = 126,
		LDSFLDA = 127,
		STSFLD = 128,
		STOBJ = 129,
		CONV_OVF_I1_UN = 130,
		CONV_OVF_I2_UN = 131,
		CONV_OVF_I4_UN = 132,
		CONV_OVF_I8_UN = 133,
		CONV_OVF_U1_UN = 134,
		CONV_OVF_U2_UN = 135,
		CONV_OVF_U4_UN = 136,
		CONV_OVF_U8_UN = 137,
		CONV_OVF_I_UN = 138,
		CONV_OVF_U_UN = 139,
		BOX = 140,
		NEWARR = 141,
		LDLEN = 142,
		LDELEMA = 143,
		LDELEM_I1 = 144,
		LDELEM_U1 = 145,
		LDELEM_I2 = 146,
		LDELEM_U2 = 147,
		LDELEM_I4 = 148,
		LDELEM_U4 = 149,
		LDELEM_I8 = 150,
		LDELEM_I = 151,
		LDELEM_R4 = 152,
		LDELEM_R8 = 153,
		LDELEM_REF = 154,
		STELEM_I = 155,
		STELEM_I1 = 156,
		STELEM_I2 = 157,
		STELEM_I4 = 158,
		STELEM_I8 = 159,
		STELEM_R4 = 160,
		STELEM_R8 = 161,
		STELEM_REF = 162,
		LDELEM = 163,
		STELEM = 164,
		UNBOX_ANY = 165,
		UNUSED5 = 166,
		UNUSED6 = 167,
		UNUSED7 = 168,
		UNUSED8 = 169,
		UNUSED9 = 170,
		UNUSED10 = 171,
		UNUSED11 = 172,
		UNUSED12 = 173,
		UNUSED13 = 174,
		UNUSED14 = 175,
		UNUSED15 = 176,
		UNUSED16 = 177,
		UNUSED17 = 178,
		CONV_OVF_I1 = 179,
		CONV_OVF_U1 = 180,
		CONV_OVF_I2 = 181,
		CONV_OVF_U2 = 182,
		CONV_OVF_I4 = 183,
		CONV_OVF_U4 = 184,
		CONV_OVF_I8 = 185,
		CONV_OVF_U8 = 186,
		UNUSED50 = 187,
		UNUSED18 = 188,
		UNUSED19 = 189,
		UNUSED20 = 190,
		UNUSED21 = 191,
		UNUSED22 = 192,
		UNUSED23 = 193,
		REFANYVAL = 194,
		CKFINITE = 195,
		UNUSED24 = 196,
		UNUSED25 = 197,
		MKREFANY = 198,
		UNUSED59 = 199,
		UNUSED60 = 200,
		UNUSED61 = 201,
		UNUSED62 = 202,
		UNUSED63 = 203,
		UNUSED64 = 204,
		UNUSED65 = 205,
		UNUSED66 = 206,
		UNUSED67 = 207,
		LDTOKEN = 208,
		CONV_U2 = 209,
		CONV_U1 = 210,
		CONV_I = 211,
		CONV_OVF_I = 212,
		CONV_OVF_U = 213,
		ADD_OVF = 214,
		ADD_OVF_UN = 215,
		MUL_OVF = 216,
		MUL_OVF_UN = 217,
		SUB_OVF = 218,
		SUB_OVF_UN = 219,
		ENDFINALLY = 220,
		LEAVE = 221,
		LEAVE_S = 222,
		STIND_I = 223,
		CONV_U = 224,
		UNUSED26 = 225,
		UNUSED27 = 226,
		UNUSED28 = 227,
		UNUSED29 = 228,
		UNUSED30 = 229,
		UNUSED31 = 230,
		UNUSED32 = 231,
		UNUSED33 = 232,
		UNUSED34 = 233,
		UNUSED35 = 234,
		UNUSED36 = 235,
		UNUSED37 = 236,
		UNUSED38 = 237,
		UNUSED39 = 238,
		UNUSED40 = 239,
		UNUSED41 = 240,
		UNUSED42 = 241,
		UNUSED43 = 242,
		UNUSED44 = 243,
		UNUSED45 = 244,
		UNUSED46 = 245,
		UNUSED47 = 246,
		UNUSED48 = 247,
		PREFIX7 = 248,
		PREFIX6 = 249,
		PREFIX5 = 250,
		PREFIX4 = 251,
		PREFIX3 = 252,
		PREFIX2 = 253,
		PREFIX1 = 254,
		PREFIXREF = 255,
		ARGLIST = 0,
		CEQ = 1,
		CGT = 2,
		CGT_UN = 3,
		CLT = 4,
		CLT_UN = 5,
		LDFTN = 6,
		LDVIRTFTN = 7,
		UNUSED56 = 8,
		LDARG = 9,
		LDARGA = 10,
		STARG = 11,
		LDLOC = 12,
		LDLOCA = 13,
		STLOC = 14,
		LOCALLOC = 15,
		UNUSED57 = 16,
		ENDFILTER = 17,
		UNALIGNED_ = 18,
		VOLATILE_ = 19,
		TAIL_ = 20,
		INITOBJ = 21,
		CONSTRAINED_ = 22,
		CPBLK = 23,
		INITBLK = 24,
		NO_ = 25,
		RETHROW = 26,
		UNUSED = 27,
		SIZEOF = 28,
		REFANYTYPE = 29,
		READONLY_ = 30,
		UNUSED53 = 31,
		UNUSED54 = 32,
		UNUSED55 = 33,
		UNUSED70 = 34,
		ILLEGAL = 0,
		ENDMAC = 0,

		//!!!}}OPCODE_VALUE
	};

	enum class OpcodeEnum
	{
		//!!!{{OPCODE_ENUM
		NOP,
		BREAK,
		LDARG_0,
		LDARG_1,
		LDARG_2,
		LDARG_3,
		LDLOC_0,
		LDLOC_1,
		LDLOC_2,
		LDLOC_3,
		STLOC_0,
		STLOC_1,
		STLOC_2,
		STLOC_3,
		LDARG_S,
		LDARGA_S,
		STARG_S,
		LDLOC_S,
		LDLOCA_S,
		STLOC_S,
		LDNULL,
		LDC_I4_M1,
		LDC_I4_0,
		LDC_I4_1,
		LDC_I4_2,
		LDC_I4_3,
		LDC_I4_4,
		LDC_I4_5,
		LDC_I4_6,
		LDC_I4_7,
		LDC_I4_8,
		LDC_I4_S,
		LDC_I4,
		LDC_I8,
		LDC_R4,
		LDC_R8,
		UNUSED99,
		DUP,
		POP,
		JMP,
		CALL,
		CALLI,
		RET,
		BR_S,
		BRFALSE_S,
		BRTRUE_S,
		BEQ_S,
		BGE_S,
		BGT_S,
		BLE_S,
		BLT_S,
		BNE_UN_S,
		BGE_UN_S,
		BGT_UN_S,
		BLE_UN_S,
		BLT_UN_S,
		BR,
		BRFALSE,
		BRTRUE,
		BEQ,
		BGE,
		BGT,
		BLE,
		BLT,
		BNE_UN,
		BGE_UN,
		BGT_UN,
		BLE_UN,
		BLT_UN,
		SWITCH,
		LDIND_I1,
		LDIND_U1,
		LDIND_I2,
		LDIND_U2,
		LDIND_I4,
		LDIND_U4,
		LDIND_I8,
		LDIND_I,
		LDIND_R4,
		LDIND_R8,
		LDIND_REF,
		STIND_REF,
		STIND_I1,
		STIND_I2,
		STIND_I4,
		STIND_I8,
		STIND_R4,
		STIND_R8,
		ADD,
		SUB,
		MUL,
		DIV,
		DIV_UN,
		REM,
		REM_UN,
		AND,
		OR,
		XOR,
		SHL,
		SHR,
		SHR_UN,
		NEG,
		NOT,
		CONV_I1,
		CONV_I2,
		CONV_I4,
		CONV_I8,
		CONV_R4,
		CONV_R8,
		CONV_U4,
		CONV_U8,
		CALLVIRT,
		CPOBJ,
		LDOBJ,
		LDSTR,
		NEWOBJ,
		CASTCLASS,
		ISINST,
		CONV_R_UN,
		UNUSED58,
		UNUSED1,
		UNBOX,
		THROW,
		LDFLD,
		LDFLDA,
		STFLD,
		LDSFLD,
		LDSFLDA,
		STSFLD,
		STOBJ,
		CONV_OVF_I1_UN,
		CONV_OVF_I2_UN,
		CONV_OVF_I4_UN,
		CONV_OVF_I8_UN,
		CONV_OVF_U1_UN,
		CONV_OVF_U2_UN,
		CONV_OVF_U4_UN,
		CONV_OVF_U8_UN,
		CONV_OVF_I_UN,
		CONV_OVF_U_UN,
		BOX,
		NEWARR,
		LDLEN,
		LDELEMA,
		LDELEM_I1,
		LDELEM_U1,
		LDELEM_I2,
		LDELEM_U2,
		LDELEM_I4,
		LDELEM_U4,
		LDELEM_I8,
		LDELEM_I,
		LDELEM_R4,
		LDELEM_R8,
		LDELEM_REF,
		STELEM_I,
		STELEM_I1,
		STELEM_I2,
		STELEM_I4,
		STELEM_I8,
		STELEM_R4,
		STELEM_R8,
		STELEM_REF,
		LDELEM,
		STELEM,
		UNBOX_ANY,
		UNUSED5,
		UNUSED6,
		UNUSED7,
		UNUSED8,
		UNUSED9,
		UNUSED10,
		UNUSED11,
		UNUSED12,
		UNUSED13,
		UNUSED14,
		UNUSED15,
		UNUSED16,
		UNUSED17,
		CONV_OVF_I1,
		CONV_OVF_U1,
		CONV_OVF_I2,
		CONV_OVF_U2,
		CONV_OVF_I4,
		CONV_OVF_U4,
		CONV_OVF_I8,
		CONV_OVF_U8,
		UNUSED50,
		UNUSED18,
		UNUSED19,
		UNUSED20,
		UNUSED21,
		UNUSED22,
		UNUSED23,
		REFANYVAL,
		CKFINITE,
		UNUSED24,
		UNUSED25,
		MKREFANY,
		UNUSED59,
		UNUSED60,
		UNUSED61,
		UNUSED62,
		UNUSED63,
		UNUSED64,
		UNUSED65,
		UNUSED66,
		UNUSED67,
		LDTOKEN,
		CONV_U2,
		CONV_U1,
		CONV_I,
		CONV_OVF_I,
		CONV_OVF_U,
		ADD_OVF,
		ADD_OVF_UN,
		MUL_OVF,
		MUL_OVF_UN,
		SUB_OVF,
		SUB_OVF_UN,
		ENDFINALLY,
		LEAVE,
		LEAVE_S,
		STIND_I,
		CONV_U,
		UNUSED26,
		UNUSED27,
		UNUSED28,
		UNUSED29,
		UNUSED30,
		UNUSED31,
		UNUSED32,
		UNUSED33,
		UNUSED34,
		UNUSED35,
		UNUSED36,
		UNUSED37,
		UNUSED38,
		UNUSED39,
		UNUSED40,
		UNUSED41,
		UNUSED42,
		UNUSED43,
		UNUSED44,
		UNUSED45,
		UNUSED46,
		UNUSED47,
		UNUSED48,
		PREFIX7,
		PREFIX6,
		PREFIX5,
		PREFIX4,
		PREFIX3,
		PREFIX2,
		PREFIX1,
		PREFIXREF,
		ARGLIST,
		CEQ,
		CGT,
		CGT_UN,
		CLT,
		CLT_UN,
		LDFTN,
		LDVIRTFTN,
		UNUSED56,
		LDARG,
		LDARGA,
		STARG,
		LDLOC,
		LDLOCA,
		STLOC,
		LOCALLOC,
		UNUSED57,
		ENDFILTER,
		UNALIGNED_,
		VOLATILE_,
		TAIL_,
		INITOBJ,
		CONSTRAINED_,
		CPBLK,
		INITBLK,
		NO_,
		RETHROW,
		UNUSED,
		SIZEOF,
		REFANYTYPE,
		READONLY_,
		UNUSED53,
		UNUSED54,
		UNUSED55,
		UNUSED70,
		ILLEGAL,
		ENDMAC,

		//!!!}}OPCODE_ENUM
		__Count,
	};


	enum class FlowType
	{
		Next,
		Branch,
		CondBranch,
		Call,
		Return,
		Meta,
		Throw,
		Break,
	};

	enum class ArgType
	{
		None,
		Data,
		StaticBranch,
		BranchTarget,
		Switch,
	};

	enum class InputType
	{
		None,
	};

	enum class OutputType
	{
		None,
	};

	enum class OpCodeKind
	{
		Primitive,
		ObjModel,
		Macro,
		Prefix,
		Nternal,
	};

	struct OpCodeInfo
	{
		OpcodeEnum id;
		const char name[16];
		InputType intput[3];
		OutputType output;
		ArgType inlineType;
		int32_t inlineParam;
		uint8_t flag;
		OpcodeValue baseOpValue;
		FlowType flow;
		int32_t constValue;
	};

	extern OpCodeInfo g_opcodeInfos[(int)OpcodeEnum::__Count];

	const OpCodeInfo* DecodeOpCodeInfo(const byte*& ip, const byte* end);

	uint32_t GetOpCodeSize(const byte*& ip, const OpCodeInfo* opCodeInfo);
}
}


```

`hybridclr/metadata/PDBImage.cpp`:

```cpp
#include "PDBImage.h"

#include <algorithm>

#include "vm/MetadataLock.h"

#include "../interpreter/InterpreterDefs.h"

#include "BlobReader.h"

namespace hybridclr
{
namespace metadata
{
	constexpr uint32_t kHiddenLine = 0xfeefee;

	LoadImageErrorCode PDBImage::LoadCLIHeader(uint32_t& entryPointToken, uint32_t& metadataRva, uint32_t& metadataSize)
	{
		entryPointToken = 0;
		metadataRva = 0;
		metadataSize = _imageLength;

		_sections.push_back({ 0, _imageLength, 0 });
		return LoadImageErrorCode::OK;
	}

	uint32_t PDBImage::FindILOffsetByIROffset(const il2cpp::utils::dynamic_array<ILMapper>& ilMapper, uint32_t irOffset)
	{
		auto it = std::upper_bound(ilMapper.begin(), ilMapper.end(), irOffset, [](uint32_t irOffset, const ILMapper& mapper) { return irOffset < mapper.irOffset; });
		if (it != ilMapper.begin())
		{
			auto next = it;
			if (next != ilMapper.end())
			{
				IL2CPP_ASSERT(next->irOffset > irOffset);
			}
			--it;
			IL2CPP_ASSERT(it->irOffset <= irOffset);
			return it->ilOffset;
		}
		return 0;
	}

	const PDBImage::SymbolSequencePoint* PDBImage::FindSequencePoint(const il2cpp::utils::dynamic_array<SymbolSequencePoint>& sequencePoints, uint32_t ilOffset)
	{
		auto it = std::upper_bound(sequencePoints.begin(), sequencePoints.end(), ilOffset, [](uint32_t ilOffset, const SymbolSequencePoint& ssp) { return ilOffset < ssp.ilOffset; });
		if (it != sequencePoints.begin())
		{
			auto next = it;
			if (next != sequencePoints.end())
			{
				IL2CPP_ASSERT(next->ilOffset > ilOffset);
			}
			--it;
			IL2CPP_ASSERT(it->ilOffset <= ilOffset);
			return &(*it);
		}
		return nullptr;
	}

	const PDBImage::SymbolDocumentData* PDBImage::GetDocument(uint32_t documentToken)
	{
		const Table& tableMeta = GetTable(TableType::DOCUMENT);
		uint32_t rowIndex = DecodeTokenRowIndex(documentToken);
		if (rowIndex == 0 || rowIndex > tableMeta.rowNum)
		{
			return nullptr;
		}

		auto it = _documents.find(documentToken);
		if (it != _documents.end())
		{
			return it->second;
		}

		TbDocument document = ReadDocument(rowIndex);
		SymbolDocumentData* documentData = new (HYBRIDCLR_MALLOC_ZERO(sizeof(SymbolDocumentData))) SymbolDocumentData();
		BlobReader reader = GetBlobReaderByRawIndex(document.name);
		
		// FIXME. this is a utf-8 char.
		char sep = (char)reader.ReadByte();
		std::string sourceFileNames;
		bool first = true;
		while (reader.NonEmpty())
		{
			if (sep && !first)
			{
				sourceFileNames.push_back(sep);
			}
			uint32_t sourceFileNameIndex = reader.ReadCompressedUint32();
			if (sourceFileNameIndex > 0)
			{
				BlobReader sourceFileNameReader = GetBlobReaderByRawIndex(sourceFileNameIndex);
				sourceFileNames.append((const char*)sourceFileNameReader.GetData(), sourceFileNameReader.GetLength());
			}
			first = false;
		}
		documentData->sourceFiles = CopyString(sourceFileNames.c_str());

		_documents.add(documentToken, documentData);
		return documentData;
	}

	void PDBImage::SetupStackFrameInfo(const MethodInfo* method, const void* ip, Il2CppStackFrameInfo& stackFrame)
	{
		il2cpp::os::FastAutoLock lock(&il2cpp::vm::g_MetadataLock);
		auto it = _methodInfos.find(method);
		if (it == _methodInfos.end())
		{
			return;
		}
		const SymbolMethodInfoData* methodInfoData = it->second;
		const SymbolMethodDefData* methodData = methodInfoData->methodData;
		const hybridclr::interpreter::InterpMethodInfo* imi = (const hybridclr::interpreter::InterpMethodInfo*)method->interpData;
		IL2CPP_ASSERT(ip >= imi->codes && ip < imi->codes + imi->codeLength);
		const byte* actualIp = (const byte*)ip;

		uint32_t irOffset = (uint32_t)((uintptr_t)actualIp - (uintptr_t)imi->codes);
		uint32_t ilOffset = FindILOffsetByIROffset(methodInfoData->ilMapper, irOffset);
		// when call sub interpreter method, ip point to next instruction, so we need to adjust ilOffset.
		if (ilOffset > 0)
		{
			--ilOffset;
		}
		stackFrame.ilOffset = ilOffset;

		const SymbolSequencePoint* ssp = FindSequencePoint(methodData->sequencePoints, ilOffset);
		if (!ssp)
		{
			stackFrame.sourceCodeLineNumber = 0;
			return;
		}

		stackFrame.sourceCodeLineNumber = ssp->line;

		stackFrame.filePath = GetDocumentName(ssp->document);
	}

	void PDBImage::SetMethodDebugInfo(const MethodInfo* method, const il2cpp::utils::dynamic_array<ILMapper>& ilMapper)
	{
		IL2CPP_ASSERT(_methodInfos.find(method) == _methodInfos.end());
		SymbolMethodDefData* methodData = GetMethodDataFromCache(method->token);
		if (!methodData)
		{
			return;
		}

		SymbolMethodInfoData* methodInfoData = new (HYBRIDCLR_MALLOC_ZERO(sizeof(SymbolMethodInfoData))) SymbolMethodInfoData();
		methodInfoData->methodData = methodData;
		methodInfoData->ilMapper = ilMapper;
		_methodInfos.add(method, methodInfoData);
	}


	PDBImage::SymbolMethodDefData* PDBImage::GetMethodDataFromCache(uint32_t methodToken)
	{
		const Table& tableMeta = GetTable(TableType::METHODDEBUGINFORMATION);
		uint32_t rowIndex = hybridclr::metadata::DecodeTokenRowIndex(methodToken);
		if (rowIndex == 0 || rowIndex > tableMeta.rowNum)
		{
			return nullptr;
		}

		auto it = _methods.find(methodToken);
		if (it != _methods.end())
		{
			return it->second;
		}

		SymbolMethodDefData* methodData = new (HYBRIDCLR_MALLOC_ZERO(sizeof(SymbolMethodDefData))) SymbolMethodDefData();

		// see https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md
		TbMethodDebugInformation smb = ReadMethodDebugInformation(rowIndex);
		methodData->document = smb.document;
		if (smb.sequencePoints > 0)
		{
			auto& sequencePoints = methodData->sequencePoints;
			BlobReader reader = GetBlobReaderByRawIndex(smb.sequencePoints);
			uint32_t localSignature = reader.ReadCompressedUint32();
			uint32_t document = smb.document ? smb.document : reader.ReadCompressedUint32();
			int32_t prevStartLine = -1;
			int32_t prevStartColumn = -1;
			while (reader.NonEmpty())
			{
				uint32_t deltaIlOffset = reader.ReadCompressedUint32();
				// document record
				if (deltaIlOffset == 0 && !sequencePoints.empty())
				{
					document = reader.ReadCompressedUint32();
					continue;
				}
				uint32_t deltaLines = reader.ReadCompressedUint32();
				int32_t deltaColumns = deltaLines == 0 ? reader.ReadCompressedUint32() : reader.ReadCompressedInt32();
				
				uint32_t ilOffset = sequencePoints.empty() ? deltaIlOffset : sequencePoints.back().ilOffset + deltaIlOffset;

				SymbolSequencePoint ssp = {};
				ssp.document = document;
				ssp.ilOffset = ilOffset;
				// hidden-sequence-point record
				if (deltaLines == 0 && deltaColumns == 0)
				{
					ssp.line = ssp.endLine = kHiddenLine;
					ssp.column = ssp.endColumn = 0;
				}
				else
				{
					// sequence-point record
					if (prevStartColumn < 0)
					{
						prevStartLine = reader.ReadCompressedUint32();
						prevStartColumn = reader.ReadCompressedUint32();
					}
					else
					{
						prevStartLine += reader.ReadCompressedInt32();
						prevStartColumn += reader.ReadCompressedInt32();
					}
					ssp.line = prevStartLine;
					ssp.endLine = prevStartLine + deltaLines;
					ssp.column = prevStartColumn;
					ssp.endColumn = prevStartColumn + deltaColumns;
				}
				sequencePoints.push_back(ssp);
			}
		}

		_methods.add(methodToken, methodData);
		return methodData;
	}
}
}



```

`hybridclr/metadata/PDBImage.h`:

```h
#pragma once

#include "RawImageBase.h"

namespace hybridclr
{
namespace metadata
{
	struct ILMapper
	{
		uint32_t irOffset;
		uint32_t ilOffset;
	};

	class PDBImage : public RawImageBase
	{
	public:
		PDBImage() : RawImageBase()
		{
		}

		LoadImageErrorCode LoadCLIHeader(uint32_t& entryPointToken, uint32_t& metadataRva, uint32_t& metadataSize) override;

		Il2CppString* GetUserStringBlogByIndex(uint32_t index) const override
		{
			RaiseExecutionEngineException("PDBImage::GetUserStringBlogByIndex Not implemented");
			return nullptr;
		}

		void SetupStackFrameInfo(const MethodInfo* method, const void* ip, Il2CppStackFrameInfo& stackFrame);
		void SetMethodDebugInfo(const MethodInfo* method, const il2cpp::utils::dynamic_array<ILMapper>& ilMapper);
	private:

		struct SymbolDocumentData
		{
			const char* sourceFiles;
		};

		struct SymbolSequencePoint
		{
			uint32_t document;
			uint32_t ilOffset;
			uint32_t line;
			uint32_t column;
			uint32_t endLine;
			uint32_t endColumn;
		};

		struct SymbolMethodDefData
		{
			uint32_t document;
			il2cpp::utils::dynamic_array<SymbolSequencePoint> sequencePoints;
		};

		struct SymbolMethodInfoData
		{
			SymbolMethodDefData* methodData;
			il2cpp::utils::dynamic_array<ILMapper> ilMapper;
		};

		SymbolMethodDefData* GetMethodDataFromCache(uint32_t methodToken);
		static uint32_t FindILOffsetByIROffset(const il2cpp::utils::dynamic_array<ILMapper>& ilMapper, uint32_t irOffset);
		static const SymbolSequencePoint* FindSequencePoint(const il2cpp::utils::dynamic_array<SymbolSequencePoint>& sequencePoints, uint32_t ilOffset);
		const SymbolDocumentData* GetDocument(uint32_t documentToken);
		const char* GetDocumentName(uint32_t documentToken)
		{
			const SymbolDocumentData* document = GetDocument(documentToken);
			return document ? document->sourceFiles : nullptr;
		}

		typedef Il2CppHashMap<uint32_t, SymbolMethodDefData*, il2cpp::utils::PassThroughHash<uint32_t>> SymbolMethodDataMap;
		SymbolMethodDataMap _methods;

		typedef Il2CppHashMap<uint32_t, SymbolDocumentData*, il2cpp::utils::PassThroughHash<uint32_t>> SymbolDocumentDataMap;
		SymbolDocumentDataMap _documents;

		typedef Il2CppHashMap<const MethodInfo*, SymbolMethodInfoData*, il2cpp::utils::PassThroughHash<const MethodInfo*>> SymbolMethodInfoDataMap;
		SymbolMethodInfoDataMap _methodInfos;
	};
}
}
```

`hybridclr/metadata/RawImage.cpp`:

```cpp

#include "RawImage.h"

#include <cstring>
#include <iostream>

#include "MetadataUtil.h"
#include "Opcodes.h"

namespace hybridclr
{
namespace metadata
{

	const int kOptionalHeaderSize32 = 224;
	const int kOptionalHeaderSize64 = 240;
	const int kCliHeaderOffset32 = 208;
	const int kCliHeaderOffset64 = 224;

	LoadImageErrorCode RawImage::LoadCLIHeader(uint32_t& entryPointToken, uint32_t& metadataRva, uint32_t& metadataSize)
	{
		const byte* imageData = _imageData;
		const byte* ptr_lfanew = imageData + 0x3c;
		uint32_t lfanew = *(uint32_t*)ptr_lfanew;
		if (lfanew >= _imageLength)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}

		const byte* ptrSig = imageData + lfanew;
		/*if (ptr_sig[0] != 'P' || ptr_sig[1] != 'E' || ptr_sig[2] != 0 || ptr_sig[3] != 0)*/
		if (std::strncmp((const char*)ptrSig, "PE\0\0", 4))
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}

		PEHeader* peHeader = (PEHeader*)(ptrSig + 4);

		bool isDll = (peHeader->characteristics & 0x2000);
		// std::cout << "load " << (_isDll ? "dll" : "exe") << std::endl;

		// optional size may be 224(32bit matchine) or 240 (64bit)
		if (peHeader->optionalHeadersize != kOptionalHeaderSize32 && peHeader->optionalHeadersize != kOptionalHeaderSize64)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		bool is32BitFormat = peHeader->optionalHeadersize == kOptionalHeaderSize32;


		PESectionHeader* _peSectionHeaders = (PESectionHeader*)((byte*)peHeader + 20 + peHeader->optionalHeadersize);

		for (uint16_t secIdx = 0; secIdx < peHeader->sections; secIdx++)
		{
			const PESectionHeader* ph = _peSectionHeaders + secIdx;
			if ((byte*)ph >= _ptrRawDataEnd)
			{
				return LoadImageErrorCode::BAD_IMAGE;
			}
			_sections.push_back({ ph->virtualAddress, ph->virtualAddress + ph->virtualSize, ph->ptrRawData - ph->virtualAddress });
		}


		const PEDirEntry* ptrCLIHeaderEntry = (PEDirEntry*)(((byte*)peHeader)
			+ 20 /* pe header size */
			+ (is32BitFormat ? kCliHeaderOffset32 : kCliHeaderOffset64) /* pe optional header -> pe header data directories -> cli header */);
		uint32_t cLIHeaderOffset;
		if (!TranslateRVAToImageOffset(ptrCLIHeaderEntry->rva, cLIHeaderOffset))
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		if (cLIHeaderOffset >= _imageLength)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}

		const CLIHeader* ptrCLIHeader = (const CLIHeader*)(imageData + cLIHeaderOffset);
		entryPointToken = ptrCLIHeader->entryPointToken;
		metadataRva = ptrCLIHeader->metaData.rva;
		metadataSize = ptrCLIHeader->metaData.size;

		return LoadImageErrorCode::OK;
	}

}
}
```

`hybridclr/metadata/RawImage.h`:

```h
#pragma once

#include "RawImageBase.h"

namespace hybridclr
{
namespace metadata
{

	class RawImage : public RawImageBase
	{
	public:
		RawImage(): RawImageBase()
		{

		}

		LoadImageErrorCode LoadCLIHeader(uint32_t& entryPointToken, uint32_t& metadataRva, uint32_t& metadataSize) override;


	private:


	};
}
}
```

`hybridclr/metadata/RawImageBase.cpp`:

```cpp
#include "RawImage.h"

namespace hybridclr
{
namespace metadata
{
	LoadImageErrorCode RawImageBase::Load(const void* rawImageData, size_t length)
	{
		_imageData = (const byte*)rawImageData;
		_imageLength = uint32_t(length);
		_ptrRawDataEnd = _imageData + length;

		uint32_t metadataRva = 0;
		uint32_t metadataSize = 0;
		LoadImageErrorCode err = LoadCLIHeader(_entryPointToken, metadataRva, metadataSize);
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}

		err = LoadStreamHeaders(metadataRva, metadataSize);
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}
		err = PostLoadStreams();
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}

#if IL2CPP_DEBUG
		err = ValidateStreams();
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}
#endif
		err = LoadTables();
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}
		err = PostLoadTables();
		if (err != LoadImageErrorCode::OK)
		{
			return err;
		}
		return LoadImageErrorCode::OK;
	}

	LoadImageErrorCode RawImageBase::LoadStreamHeaders(uint32_t metadataRva, uint32_t metadataSize)
	{
		uint32_t metaOffset;
		if (!TranslateRVAToImageOffset(metadataRva, metaOffset))
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		if (metaOffset >= _imageLength)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}

		const MetadataRootPartial* ptrMetaRoot = (const MetadataRootPartial*)(_imageData + metaOffset);
		if (ptrMetaRoot->signature != 0x424A5342)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		//std::cout << "version:" << (const char*)&(ptrMetaRoot->versionFirstByte) << std::endl;
		const byte* ptrMetaData = (const byte*)ptrMetaRoot;

		uint16_t numStreamHeader = *(uint16_t*)(ptrMetaData + 16 + ptrMetaRoot->length + 2);
		const StreamHeader* ptrStreamHeaders = (const StreamHeader*)(ptrMetaData + 16 + ptrMetaRoot->length + 4);

		const StreamHeader* curSH = ptrStreamHeaders;
		const size_t maxStreamNameSize = 16;
		for (int i = 0; i < numStreamHeader; i++)
		{
			//std::cout << "name:" << (char*)curSH->name << ", offset:" << curSH->offset << ", size:" << curSH->size << std::endl;

			if (curSH->offset >= metadataSize)
			{
				return LoadImageErrorCode::BAD_IMAGE;
			}
			CliStream* rs = nullptr;
			CliStream nonStandardStream;
			CliStream pdbStream;
			if (!std::strncmp(curSH->name, "#~", maxStreamNameSize))
			{
				rs = &_streamTables;
			}
			else if (!std::strncmp(curSH->name, "#Strings", maxStreamNameSize))
			{
				rs = &_streamStringHeap;
			}
			else if (!std::strncmp(curSH->name, "#US", maxStreamNameSize))
			{
				rs = &_streamUS;
			}
			else if (!std::strncmp(curSH->name, "#GUID", maxStreamNameSize))
			{
				rs = &_streamGuidHeap;
				if (curSH->size % 16 != 0)
				{
					return LoadImageErrorCode::BAD_IMAGE;
				}
			}
			else if (!std::strncmp(curSH->name, "#Blob", maxStreamNameSize))
			{
				rs = &_streamBlobHeap;
			}
			else if (!std::strncmp(curSH->name, "#-", maxStreamNameSize))
			{
				rs = &nonStandardStream;
			}
			else if (!std::strncmp(curSH->name, "#Pdb", maxStreamNameSize))
			{
				rs = &pdbStream;
			}
			else
			{
				//std::cerr << "unknown stream name:" << curSH->name << std::endl;
				return LoadImageErrorCode::BAD_IMAGE;
			}
			rs->data = ptrMetaData + curSH->offset;
			rs->size = curSH->size;
			rs->name = curSH->name;
			size_t sizeOfStream = 8 + (std::strlen(curSH->name) / 4 + 1) * 4;
			curSH = (const StreamHeader*)((byte*)curSH + sizeOfStream);
		}
		return LoadImageErrorCode::OK;
	}

	LoadImageErrorCode RawImageBase::ValidateStreams() const
	{
		{
			uint32_t stringNum = 0;
			const byte* cur;
			for (cur = _streamStringHeap.data; cur < _streamStringHeap.data + _streamStringHeap.size; )
			{
				++stringNum;
				//std::cout << "#strings.[" << stringNum << "]  " << cur << std::endl;
				cur += std::strlen((const char*)cur) + 1;
			}
			if (cur != _streamStringHeap.data + _streamStringHeap.size)
			{
				//std::cerr << "bad #strings" << std::endl;
				return LoadImageErrorCode::BAD_IMAGE;
			}
			//std::cout << "=== #String. num:" << stringNum << std::endl;
		}


		{
			//std::cout << "=== #GUID. num:" << _streamGuidHeap.size / 16 << std::endl;
		}
		{
			const byte* cur;
			uint32_t usNum = 0;
			uint32_t lengthSize;
			for (cur = _streamUS.data; cur < _streamUS.data + _streamUS.size;)
			{
				++usNum;
				uint32_t stringLength = BlobReader::ReadCompressedUint32(cur, lengthSize);
				cur += lengthSize;
				//std::cout << "#us.[" << usNum << "].size:" << stringLength << std::endl;
				cur += stringLength;
			}
			if (cur != _streamUS.data + _streamUS.size)
			{
				//std::cerr << "bad #US" << std::endl;
				return LoadImageErrorCode::BAD_IMAGE;
			}
			//std::cout << "=== #US. num:" << usNum << std::endl;
		}

		{
			const byte* cur;
			uint32_t blobNum = 0;
			uint32_t lengthSize;
			for (cur = _streamBlobHeap.data; cur < _streamBlobHeap.data + _streamBlobHeap.size;)
			{
				++blobNum;
				uint32_t stringLength = BlobReader::ReadCompressedUint32(cur, lengthSize);
				cur += lengthSize;
				//std::cout << "#blob.[" << blobNum << "].size:" << stringLength << std::endl;
				cur += stringLength;
			}
			if (cur != _streamBlobHeap.data + _streamBlobHeap.size)
			{
				//std::cerr << "bad #Blob" << std::endl;
				return LoadImageErrorCode::BAD_IMAGE;
			}
			//std::cout << "=== #Blob. num:" << blobNum << std::endl;
			return LoadImageErrorCode::OK;
		}

	}

	LoadImageErrorCode RawImageBase::LoadTables()
	{
		const TableStreamHeader* ptrTableHeader = (const TableStreamHeader*)_streamTables.data;
		if (ptrTableHeader->reserved != 0 || ptrTableHeader->majorVersion != 2 || ptrTableHeader->minorVersion != 0)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		if ((ptrTableHeader->heapSizes & ~0x7))
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		_4byteStringIndex = ptrTableHeader->heapSizes & 0x1;
		_4byteGUIDIndex = ptrTableHeader->heapSizes & 0x2;
		_4byteBlobIndex = ptrTableHeader->heapSizes & 0x4;

		uint64_t validMask = ((uint64_t)1 << TABLE_NUM) - 1;
		if (ptrTableHeader->valid & ~validMask)
		{
			return LoadImageErrorCode::BAD_IMAGE;
		}
		// sorted include not exist table, so check is not need.
		//if (ptrTableHeader->sorted & ~validMask)
		//{
		//	return LoadImageErrorCode::BAD_IMAGE;
		//}

		uint32_t validTableNum = GetNotZeroBitCount(ptrTableHeader->valid);
		//std::cout << "valid table num:" << validTableNum << std::endl;
		//printf("#~ size:%0x\n", _streamTables.size);
		const uint32_t* tableRowNums = (uint32_t*)(_streamTables.data + 24);
		const byte* tableDataBegin = _streamTables.data + 24 + 4 * validTableNum;

		{
			int curValidTableIndex = 0;
			for (int i = 0; i <= MAX_TABLE_INDEX; i++)
			{
				uint64_t mask = (uint64_t)1 << i;
				_tables[i] = {};
				if (ptrTableHeader->valid & mask)
				{
					uint32_t rowNum = tableRowNums[curValidTableIndex];
					_tables[i].rowNum = rowNum;
					++curValidTableIndex;
				}
			}
		}

		BuildTableRowMetas();

		int curValidTableIndex = 0;
		const byte* curTableData = tableDataBegin;
		for (int i = 0; i <= MAX_TABLE_INDEX; i++)
		{
			uint64_t mask = (uint64_t)1 << i;
			bool sorted = ptrTableHeader->sorted & mask;
			if (ptrTableHeader->valid & mask)
			{
				uint32_t rowNum = tableRowNums[curValidTableIndex];
				uint32_t totalSize = 0;
				auto& table = _tableRowMetas[i];
				for (auto& col : table)
				{
					col.offset = totalSize;
					totalSize += col.size;
				}
				uint32_t metaDataRowSize = totalSize;
				//uint64_t offset = curTableData - _imageData;
				_tables[i] = { curTableData, metaDataRowSize, rowNum, true, sorted };
				curTableData += metaDataRowSize * rowNum;
				//std::cout << "table:" << i << " ," << curValidTableIndex << ", row_size:" << metaDataRowSize << ", row_num:" << rowNum << std::endl;
				//printf("table:[%d][%d] offset:%0llx row_size:%d row_count:%d\n", i, curValidTableIndex, offset, metaDataRowSize, rowNum);
				++curValidTableIndex;
			}
			else
			{
				_tables[i] = { nullptr, 0, 0, false, sorted };
			}
		}

		return LoadImageErrorCode::OK;
	}

	void RawImageBase::BuildTableRowMetas()
	{
		{
			auto& table = _tableRowMetas[(int)TableType::MODULE];
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputGUIDIndexByte() });
			table.push_back({ ComputGUIDIndexByte() });
			table.push_back({ ComputGUIDIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::TYPEREF];
			table.push_back({ ComputTableIndexByte(TableType::MODULE, TableType::MODULEREF, TableType::ASSEMBLYREF, TableType::TYPEREF, TagBits::ResoulutionScope) });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputStringIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::TYPEDEF];
			table.push_back({ 4 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef) });
			table.push_back({ ComputTableIndexByte(TableType::FIELD) });
			table.push_back({ ComputTableIndexByte(TableType::METHOD) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::FIELDPTR];
			table.push_back({ ComputTableIndexByte(TableType::FIELD) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::FIELD];
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::METHODPTR];
			table.push_back({ ComputTableIndexByte(TableType::METHOD) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::METHOD];
			table.push_back({ 4 });
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
			table.push_back({ ComputTableIndexByte(TableType::PARAM) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::PARAMPTR];
			table.push_back({ ComputTableIndexByte(TableType::PARAM) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::PARAM];
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::INTERFACEIMPL];
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::MEMBERREF];
			table.push_back({ ComputTableIndexByte(TableType::METHOD, TableType::MODULEREF, TableType::TYPEDEF, TableType::TYPEREF, TagBits::MemberRefParent) });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::CONSTANT];
			table.push_back({ 1 });
			table.push_back({ 1 });
			table.push_back({ ComputTableIndexByte(TableType::PARAM, TableType::FIELD, TableType::PROPERTY, TagBits::HasConstant) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::CUSTOMATTRIBUTE];
			table.push_back({ ComputTableIndexByte(HasCustomAttributeAssociateTables, sizeof(HasCustomAttributeAssociateTables) / sizeof(TableType), TagBits::HasCustomAttribute) });
			table.push_back({ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::CustomAttributeType) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::FIELDMARSHAL];
			table.push_back({ ComputTableIndexByte(TableType::FIELD, TableType::PARAM, TagBits::HasFieldMarshal) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::DECLSECURITY];
			table.push_back({ 2 });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF, TableType::METHOD, TableType::ASSEMBLY, TagBits::HasDeclSecurity) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::CLASSLAYOUT];
			table.push_back({ 2 });
			table.push_back({ 4 });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::FIELDLAYOUT];
			table.push_back({ 4 });
			table.push_back({ ComputTableIndexByte(TableType::FIELD) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::STANDALONESIG];
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::EVENTMAP];
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
			table.push_back({ ComputTableIndexByte(TableType::EVENT) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::EVENTPTR];
			table.push_back({ ComputTableIndexByte(TableType::EVENT) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::EVENT];
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::PROPERTYMAP];
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
			table.push_back({ ComputTableIndexByte(TableType::PROPERTY) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::PROPERTYPTR];
			table.push_back({ ComputTableIndexByte(TableType::PROPERTY) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::PROPERTY];
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::METHODSEMANTICS];
			table.push_back({ 2 });
			table.push_back({ ComputTableIndexByte(TableType::METHOD) });
			table.push_back({ ComputTableIndexByte(TableType::EVENT, TableType::PROPERTY, TagBits::HasSemantics) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::METHODIMPL];
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
			table.push_back({ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::MethodDefOrRef) });
			table.push_back({ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::MethodDefOrRef) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::MODULEREF];
			table.push_back({ ComputStringIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::TYPESPEC];
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::IMPLMAP];
			table.push_back({ 2 });
			table.push_back({ ComputTableIndexByte(TableType::FIELD, TableType::METHOD, TagBits::MemberForwarded) });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputTableIndexByte(TableType::MODULEREF) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::FIELDRVA];
			table.push_back({ 4 });
			table.push_back({ ComputTableIndexByte(TableType::FIELD) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::ASSEMBLY];
			table.push_back({ 4 });
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ 4 });
			table.push_back({ ComputBlobIndexByte() });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputStringIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::ASSEMBLYPROCESSOR];
			table.push_back({ 4 });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::ASSEMBLYOS];
			table.push_back({ 4 });
			table.push_back({ 4 });
			table.push_back({ 4 });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::ASSEMBLYREF];
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ 4 });
			table.push_back({ ComputBlobIndexByte() });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::ASSEMBLYREFPROCESSOR];
			table.push_back({ 4 });
			table.push_back({ ComputTableIndexByte(TableType::ASSEMBLYREF) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::ASSEMBLYREFOS];
			table.push_back({ 4 });
			table.push_back({ 4 });
			table.push_back({ 4 });
			table.push_back({ ComputTableIndexByte(TableType::ASSEMBLYREF) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::FILE];
			table.push_back({ 4 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::EXPORTEDTYPE];
			table.push_back({ 4 });
			table.push_back({ 4 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputTableIndexByte(TableType::FILE, TableType::EXPORTEDTYPE, TableType::ASSEMBLY, TagBits::Implementation) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::MANIFESTRESOURCE];
			table.push_back({ 4 });
			table.push_back({ 4 });
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputTableIndexByte(TableType::FILE, TableType::ASSEMBLYREF, TagBits::Implementation) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::NESTEDCLASS];
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::GENERICPARAM];
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF, TableType::METHOD, TagBits::TypeOrMethodDef) });
			table.push_back({ ComputStringIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::METHODSPEC];
			table.push_back({ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::MethodDefOrRef) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::GENERICPARAMCONSTRAINT];
			table.push_back({ ComputTableIndexByte(TableType::GENERICPARAM) });
			table.push_back({ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::DOCUMENT];
			table.push_back({ ComputBlobIndexByte() });
			table.push_back({ ComputGUIDIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
			table.push_back({ ComputGUIDIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::METHODDEBUGINFORMATION];
			table.push_back({ ComputTableIndexByte(TableType::DOCUMENT) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::LOCALSCOPE];
			table.push_back({ ComputTableIndexByte(TableType::METHOD) });
			table.push_back({ ComputTableIndexByte(TableType::IMPORTSCOPE) });
			table.push_back({ ComputTableIndexByte(TableType::LOCALVARIABLE) });
			table.push_back({ ComputTableIndexByte(TableType::LOCALCONSTANT) });
			table.push_back({ 4 });
			table.push_back({ 4 });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::LOCALVARIABLE];
			table.push_back({ 2 });
			table.push_back({ 2 });
			table.push_back({ ComputStringIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::LOCALCONSTANT];
			table.push_back({ ComputStringIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::IMPORTSCOPE];
			table.push_back({ ComputTableIndexByte(TableType::IMPORTSCOPE) });
			table.push_back({ ComputBlobIndexByte() });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::STATEMACHINEMETHOD];
			table.push_back({ ComputTableIndexByte(TableType::METHOD) });
			table.push_back({ ComputTableIndexByte(TableType::METHOD) });
		}
		{
			auto& table = _tableRowMetas[(int)TableType::CUSTOMDEBUGINFORMATION];
			table.push_back({ ComputTableIndexByte(HasCustomDebugInformation, sizeof(HasCustomDebugInformation) / sizeof(TableType), TagBits::HasCustomDebugInformation) });
			table.push_back({ ComputGUIDIndexByte() });
			table.push_back({ ComputBlobIndexByte() });
		}


		for (int i = 0; i < TABLE_NUM; i++)
		{
			auto& table = _tableRowMetas[i];
			if (table.empty())
			{
				IL2CPP_ASSERT(_tables[i].rowNum == 0 && _tables[i].rowMetaDataSize == 0);
			}
			else
			{
				uint32_t totalSize = 0;
				for (auto& col : table)
				{
					col.offset = totalSize;
					totalSize += col.size;
				}
				uint32_t computSize = ComputTableRowMetaDataSize((TableType)i);
				IL2CPP_ASSERT(totalSize == computSize);
			}
		}
	}

	uint32_t RawImageBase::ComputTableRowMetaDataSize(TableType tableIndex) const
	{
		switch (tableIndex)
		{
		case TableType::MODULE: return 2 + ComputStringIndexByte() + ComputGUIDIndexByte() * 3;
		case TableType::TYPEREF: return ComputTableIndexByte(TableType::MODULE, TableType::MODULEREF, TableType::ASSEMBLYREF, TableType::TYPEREF, TagBits::ResoulutionScope)
			+ ComputStringIndexByte() * 2;
		case TableType::TYPEDEF: return 4 + ComputStringIndexByte() * 2
			+ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef)
			+ ComputTableIndexByte(TableType::FIELD)
			+ ComputTableIndexByte(TableType::METHOD);
		case TableType::FIELDPTR: return ComputTableIndexByte(TableType::FIELD);
		case TableType::FIELD: return 2 + ComputStringIndexByte() + ComputBlobIndexByte();
		case TableType::METHODPTR: return ComputTableIndexByte(TableType::METHOD);
		case TableType::METHOD: return 4 + 2 + 2 + ComputStringIndexByte() + ComputBlobIndexByte() + ComputTableIndexByte(TableType::PARAM);
		case TableType::PARAMPTR: return ComputTableIndexByte(TableType::PARAM);
		case TableType::PARAM: return 2 + 2 + ComputStringIndexByte();
		case TableType::INTERFACEIMPL: return ComputTableIndexByte(TableType::TYPEDEF)
			+ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef);
		case TableType::MEMBERREF: return ComputTableIndexByte(TableType::METHOD, TableType::MODULEREF, TableType::TYPEDEF, TableType::TYPEREF, TagBits::MemberRefParent)
			+ ComputStringIndexByte() + ComputBlobIndexByte();
		case TableType::CONSTANT: return 2
			+ ComputTableIndexByte(TableType::PARAM, TableType::FIELD, TableType::PROPERTY, TagBits::HasConstant)
			+ ComputBlobIndexByte();
		case TableType::CUSTOMATTRIBUTE: return ComputTableIndexByte(HasCustomAttributeAssociateTables, sizeof(HasCustomAttributeAssociateTables) / sizeof(TableType), TagBits::HasCustomAttribute)
			+ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::CustomAttributeType)
			+ ComputBlobIndexByte();
		case TableType::FIELDMARSHAL: return ComputTableIndexByte(TableType::FIELD, TableType::PARAM, TagBits::HasFieldMarshal)
			+ ComputBlobIndexByte();
		case TableType::DECLSECURITY: return 2 + ComputTableIndexByte(TableType::TYPEDEF, TableType::METHOD, TableType::ASSEMBLY, TagBits::HasDeclSecurity)
			+ ComputBlobIndexByte();
		case TableType::CLASSLAYOUT: return 2 + 4 + ComputTableIndexByte(TableType::TYPEDEF);
		case TableType::FIELDLAYOUT: return 4 + ComputTableIndexByte(TableType::FIELD);
		case TableType::STANDALONESIG: return ComputBlobIndexByte();
		case TableType::EVENTMAP: return ComputTableIndexByte(TableType::TYPEDEF) + ComputTableIndexByte(TableType::EVENT);
		case TableType::EVENTPTR: return ComputTableIndexByte(TableType::EVENT);
		case TableType::EVENT: return 2
			+ ComputStringIndexByte()
			+ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef);
		case TableType::PROPERTYMAP: return ComputTableIndexByte(TableType::TYPEDEF)
			+ ComputTableIndexByte(TableType::PROPERTY);
		case TableType::PROPERTYPTR: return ComputTableIndexByte(TableType::PROPERTY);
		case TableType::PROPERTY: return 2 + ComputStringIndexByte() + ComputBlobIndexByte();
		case TableType::METHODSEMANTICS: return 2
			+ ComputTableIndexByte(TableType::METHOD)
			+ ComputTableIndexByte(TableType::EVENT, TableType::PROPERTY, TagBits::HasSemantics);
		case TableType::METHODIMPL: return ComputTableIndexByte(TableType::TYPEDEF)
			+ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::MethodDefOrRef)
			+ ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::MethodDefOrRef);
		case TableType::MODULEREF: return ComputStringIndexByte();
		case TableType::TYPESPEC: return ComputBlobIndexByte();
		case TableType::IMPLMAP: return 2
			+ ComputTableIndexByte(TableType::FIELD, TableType::METHOD, TagBits::MemberForwarded)
			+ ComputStringIndexByte()
			+ ComputTableIndexByte(TableType::MODULEREF);
		case TableType::FIELDRVA: return 4 + ComputTableIndexByte(TableType::FIELD);
		case TableType::ENCLOG: return 4 + 4;
		case TableType::ENCMAP: return 4;
		case TableType::ASSEMBLY: return 4 + 4 * 2 + 4
			+ ComputBlobIndexByte()
			+ ComputStringIndexByte() * 2;
		case TableType::ASSEMBLYPROCESSOR: return 4;
		case TableType::ASSEMBLYOS: return 4 + 4 + 4;
		case TableType::ASSEMBLYREF: return 2 * 4 + 4
			+ ComputBlobIndexByte()
			+ ComputStringIndexByte() * 2
			+ ComputBlobIndexByte();
		case TableType::ASSEMBLYREFPROCESSOR: return 4 + ComputTableIndexByte(TableType::ASSEMBLYREF);
		case TableType::ASSEMBLYREFOS: return 4 * 3 + ComputTableIndexByte(TableType::ASSEMBLYREF);
		case TableType::FILE: return 4 + ComputStringIndexByte() + ComputBlobIndexByte();
		case TableType::EXPORTEDTYPE: return 4 + 4
			+ ComputStringIndexByte() * 2
			+ ComputTableIndexByte(TableType::FILE, TableType::EXPORTEDTYPE, TableType::ASSEMBLY, TagBits::Implementation);
		case TableType::MANIFESTRESOURCE: return 4 + 4
			+ ComputStringIndexByte()
			+ ComputTableIndexByte(TableType::FILE, TableType::ASSEMBLYREF, TagBits::Implementation);
		case TableType::NESTEDCLASS: return ComputTableIndexByte(TableType::TYPEDEF) * 2;
		case TableType::GENERICPARAM: return 2 + 2
			+ ComputTableIndexByte(TableType::TYPEDEF, TableType::METHOD, TagBits::TypeOrMethodDef)
			+ ComputStringIndexByte();
		case TableType::METHODSPEC: return ComputTableIndexByte(TableType::METHOD, TableType::MEMBERREF, TagBits::MethodDefOrRef)
			+ ComputBlobIndexByte();
		case TableType::GENERICPARAMCONSTRAINT: return ComputTableIndexByte(TableType::GENERICPARAM)
			+ ComputTableIndexByte(TableType::TYPEDEF, TableType::TYPEREF, TableType::TYPESPEC, TagBits::TypeDefOrRef);
		case TableType::UNUSED8:
		case TableType::UNUSED9:
		case TableType::UNUSED10:
			LogPanic("unused table type");
			return 0;
		case TableType::DOCUMENT: return ComputBlobIndexByte() + ComputGUIDIndexByte() + ComputBlobIndexByte() + ComputGUIDIndexByte();
		case TableType::METHODDEBUGINFORMATION: return ComputTableIndexByte(TableType::DOCUMENT) + ComputBlobIndexByte();
		case TableType::LOCALSCOPE:  return ComputTableIndexByte(TableType::METHOD) + ComputTableIndexByte(TableType::IMPORTSCOPE)
			+ ComputTableIndexByte(TableType::LOCALVARIABLE) + ComputTableIndexByte(TableType::LOCALCONSTANT) + 4 + 4;
		case TableType::LOCALVARIABLE: return 2 + 2 + ComputStringIndexByte();
		case TableType::LOCALCONSTANT: return ComputStringIndexByte() + ComputBlobIndexByte();
		case TableType::IMPORTSCOPE: return ComputTableIndexByte(TableType::IMPORTSCOPE) + ComputBlobIndexByte();
		case TableType::STATEMACHINEMETHOD: return ComputTableIndexByte(TableType::METHOD) * 2;
		case TableType::CUSTOMDEBUGINFORMATION: return ComputTableIndexByte(HasCustomDebugInformation, sizeof(HasCustomDebugInformation) / sizeof(TableType), TagBits::HasCustomDebugInformation)
			+ ComputGUIDIndexByte() + ComputBlobIndexByte();
		default:
			LogPanic("unknown table type");
			return 0;
		}
	}
}
}
```

`hybridclr/metadata/RawImageBase.h`:

```h
#pragma once

#include "../CommonDef.h"

#include "vm/String.h"

#include "MetadataDef.h"
#include "BlobReader.h"
#include "MetadataUtil.h"

namespace hybridclr
{
namespace metadata
{
	enum class LoadImageErrorCode
	{
		OK = 0,
		BAD_IMAGE,
		NOT_IMPLEMENT,
		AOT_ASSEMBLY_NOT_FIND,
		HOMOLOGOUS_ONLY_SUPPORT_AOT_ASSEMBLY,
		HOMOLOGOUS_ASSEMBLY_HAS_BEEN_LOADED,
		INVALID_HOMOLOGOUS_MODE,
		PDB_BAD_FILE,
		UNKNOWN_IMAGE_FORMAT,
		UNSUPPORT_FORMAT_VERSION,
		UNMATCH_FORMAT_VARIANT,
	};

	class RawImageBase
	{
	public:
		RawImageBase() : _imageData(nullptr), _imageLength(0), _ptrRawDataEnd(nullptr),
			_streamStringHeap{}, _streamUS{}, _streamBlobHeap{}, _streamGuidHeap{}, _streamTables{},
			_4byteStringIndex(false), _4byteGUIDIndex(false), _4byteBlobIndex(false)
		{

		}

		virtual ~RawImageBase()
		{
			if (_imageData)
			{
				HYBRIDCLR_FREE((void*)_imageData);
				_imageData = nullptr;
			}
		}
		virtual LoadImageErrorCode Load(const void* imageData, size_t length);
		virtual LoadImageErrorCode PostLoadStreams() { return LoadImageErrorCode::OK; }
		virtual LoadImageErrorCode PostLoadTables() { return LoadImageErrorCode::OK; }

		virtual Il2CppString* GetUserStringBlogByIndex(uint32_t index) const
		{
			IL2CPP_ASSERT(index >= 0 && (uint32_t)index < _streamUS.size);
			const byte* str = _streamUS.data + index;
			uint32_t lengthSize;
			uint32_t stringLength = BlobReader::ReadCompressedUint32(str, lengthSize);
			return CreateUserString((const char*)(str + lengthSize), stringLength);
		}

		const char* GetStringFromRawIndex(StringIndex index) const
		{
			IL2CPP_ASSERT(DecodeImageIndex(index) == 0);
			IL2CPP_ASSERT(index >= 0 && (uint32_t)index < _streamStringHeap.size);
			return (const char*)(_streamStringHeap.data + index);
		}

		const byte* GetBlobFromRawIndex(StringIndex index) const
		{
			IL2CPP_ASSERT(DecodeImageIndex(index) == 0);
			IL2CPP_ASSERT(index == 0 || (index > 0 && (size_t)index < _streamBlobHeap.size));
			return _streamBlobHeap.data + index;
		}

		const uint8_t* GetFieldOrParameterDefalutValueByRawIndex(uint32_t index) const
		{
			return _imageData + index;
		}

		static BlobReader DecodeBlob(const byte* buf)
		{
			uint32_t sizeLength;
			uint32_t length = BlobReader::ReadCompressedUint32(buf, sizeLength);
			return BlobReader(buf + sizeLength, length);
		}

		BlobReader GetBlobReaderByRawIndex(uint32_t rawIndex) const
		{
			IL2CPP_ASSERT(DecodeImageIndex(rawIndex) == 0);
			const byte* buf = _streamBlobHeap.data + rawIndex;
			return DecodeBlob(buf);
		}

		uint32_t GetImageOffsetOfBlob(Il2CppTypeEnum type, uint32_t index) const
		{
			if (type != IL2CPP_TYPE_STRING)
			{
				return (uint32_t)(GetBlobReaderByRawIndex(index).GetData() - _imageData);
			}
			else
			{
				return (uint32_t)(_streamBlobHeap.data + index - _imageData);
			}
		}

		const byte* GetDataPtrByImageOffset(uint32_t imageOffset) const
		{
			IL2CPP_ASSERT(imageOffset < _imageLength);
			return _imageData + imageOffset;
		}


		uint32_t GetEntryPointToken() const
		{
			return _entryPointToken;
		}


		const Table& GetTable(TableType type) const
		{
			return _tables[(int)type];
		}

		uint32_t GetTableRowNum(TableType tableIndex) const
		{
			return _tables[(int)tableIndex].rowNum;
		}

		bool TranslateRVAToImageOffset(uint32_t rvaOffset, uint32_t& imageOffset) const
		{
			for (const SectionHeader& sh : _sections)
			{
				if (sh.virtualAddressBegin <= rvaOffset && rvaOffset < sh.virtualAddressEnd)
				{
					imageOffset = sh.ptrRawDataRelatedToVirtualAddress + rvaOffset;
					return true;
				}
			}
			return false;
		}

		virtual LoadImageErrorCode LoadStreamHeaders(uint32_t metadataRva, uint32_t metadataSize);
		virtual LoadImageErrorCode ValidateStreams() const;
		virtual LoadImageErrorCode LoadTables();

		virtual void BuildTableRowMetas();

		uint32_t ComputTableRowMetaDataSize(TableType tableIndex) const;

		uint32_t ComputStringIndexByte() const
		{
			return _4byteStringIndex ? 4 : 2;
		}

		uint32_t ComputGUIDIndexByte() const
		{
			return _4byteGUIDIndex ? 4 : 2;
		}

		uint32_t ComputBlobIndexByte() const
		{
			return _4byteBlobIndex ? 4 : 2;
		}

		uint32_t ComputTableIndexByte(TableType tableIndex) const
		{
			return _tables[(int)tableIndex].rowNum < 65536 ? 2 : 4;
		}

		uint32_t ComputIndexByte(uint32_t maxRowNum, uint32_t tagBitNum) const
		{
			return (maxRowNum << tagBitNum) < 65536 ? 2 : 4;
		}

		uint32_t ComputTableIndexByte(TableType t1, TableType t2, uint32_t tagBitNum) const
		{
			uint32_t n = GetTableRowNum(t1);
			n = std::max(n, GetTableRowNum(t2));
			return ComputIndexByte(n, tagBitNum);
		}

		uint32_t ComputTableIndexByte(TableType t1, TableType t2, TableType t3, uint32_t tagBitNum) const
		{
			uint32_t n = GetTableRowNum(t1);
			n = std::max(n, GetTableRowNum(t2));
			n = std::max(n, GetTableRowNum(t3));
			return ComputIndexByte(n, tagBitNum);
		}

		uint32_t ComputTableIndexByte(TableType t1, TableType t2, TableType t3, TableType t4, uint32_t tagBitNum) const
		{
			uint32_t n = GetTableRowNum(t1);
			n = std::max(n, GetTableRowNum(t2));
			n = std::max(n, GetTableRowNum(t3));
			n = std::max(n, GetTableRowNum(t4));
			return ComputIndexByte(n, tagBitNum);
		}

		uint32_t ComputTableIndexByte(TableType t1, TableType t2, TableType t3, TableType t4, TableType t5, uint32_t tagBitNum) const
		{
			uint32_t n = GetTableRowNum(t1);
			n = std::max(n, GetTableRowNum(t2));
			n = std::max(n, GetTableRowNum(t3));
			n = std::max(n, GetTableRowNum(t4));
			n = std::max(n, GetTableRowNum(t5));
			return ComputIndexByte(n, tagBitNum);
		}

		uint32_t ComputTableIndexByte(const TableType* ts, int num, uint32_t tagBitNum) const
		{
			uint32_t n = 0;
			for (int i = 0; i < num; i++)
			{
				n = std::max(n, GetTableRowNum(ts[i]));
			}
			return ComputIndexByte(n, tagBitNum);
		}

	protected:
		virtual LoadImageErrorCode LoadCLIHeader(uint32_t& entryPointToken, uint32_t& metadataRva, uint32_t& metadataSize) = 0;

		const byte* GetTableRowPtr(TableType type, uint32_t rawIndex) const
		{
			auto& tb = _tables[(int)type];
			IL2CPP_ASSERT(rawIndex > 0 && rawIndex <= tb.rowNum);
			return tb.data + tb.rowMetaDataSize * (rawIndex - 1);
		}

		const std::vector<ColumnOffsetSize>& GetRowSchema(TableType type) const
		{
			return _tableRowMetas[(int)type];
		}

		uint32_t ReadColumn(const byte* rowPtr, const ColumnOffsetSize& columnMt) const
		{
			return ReadColumn(rowPtr, columnMt.offset, columnMt.size);
		}

		uint32_t ReadColumn(const byte* data, uint32_t offset, uint32_t size) const
		{
			const byte* dataPtr = data + offset;
			switch (size)
			{
			case 1: return *dataPtr;
			case 2: return GetU2LittleEndian(dataPtr);
			case 4: return GetU4LittleEndian(dataPtr);
			default: IL2CPP_ASSERT(false); return 0;
			}
		}

		void ReadColumn(const byte* rowPtr, const ColumnOffsetSize& columnMt, uint8_t& value) const
		{
            IL2CPP_ASSERT(columnMt.size == 1);
			const byte* dataPtr = rowPtr + columnMt.offset;
			value = *dataPtr;
		}

		void ReadColumn(const byte* rowPtr, const ColumnOffsetSize& columnMt, uint32_t& value) const
		{
			IL2CPP_ASSERT(columnMt.size == 2 || columnMt.size == 4);
			const byte* dataPtr = rowPtr + columnMt.offset;
			value = columnMt.size == 2 ? GetU2LittleEndian(dataPtr) : GetU4LittleEndian(dataPtr);
		}

		static Il2CppString* CreateUserString(const char* str, uint32_t length)
		{
			if (length == 0)
			{
				return il2cpp::vm::String::Empty();
			}
			else
			{
				IL2CPP_ASSERT(length % 2 == 1);
				UserStringEncoding charEncoding = (UserStringEncoding)str[length - 1];
				return il2cpp::vm::String::NewUtf16((const Il2CppChar*)str, (length - 1) / 2);
			}
		}

	public:

#define TABLE_BEGIN(name, tableType) virtual Tb##name Read##name(uint32_t rawIndex) \
        { \
        IL2CPP_ASSERT(rawIndex > 0 && rawIndex <= GetTable(tableType).rowNum); \
        const byte* rowPtr = GetTableRowPtr(tableType, rawIndex); \
        auto& rowSchema = GetRowSchema(tableType); \
        uint32_t __fieldIndex = 0; \
        Tb##name __r = {};

#define __F(fieldName) const ColumnOffsetSize& col_##fieldName = rowSchema[__fieldIndex++]; \
        __r.fieldName = ReadColumn(rowPtr, col_##fieldName);

#define TABLE_END return __r; \
        }

#define TABLE1(name, tableType, f1) TABLE_BEGIN(name, tableType) \
__F(f1) \
TABLE_END

#define TABLE2(name, tableType, f1, f2) TABLE_BEGIN(name, tableType) \
__F(f1) \
__F(f2) \
TABLE_END

#define TABLE3(name, tableType, f1, f2, f3) TABLE_BEGIN(name, tableType) \
__F(f1) \
__F(f2) \
__F(f3) \
TABLE_END

#define TABLE4(name, tableType, f1, f2, f3, f4) TABLE_BEGIN(name, tableType) \
__F(f1) \
__F(f2) \
__F(f3) \
__F(f4) \
TABLE_END

#define TABLE5(name, tableType, f1, f2, f3, f4, f5) TABLE_BEGIN(name, tableType) \
__F(f1) \
__F(f2) \
__F(f3) \
__F(f4) \
__F(f5) \
TABLE_END

#define TABLE6(name, tableType, f1, f2, f3, f4, f5, f6) TABLE_BEGIN(name, tableType) \
__F(f1) \
__F(f2) \
__F(f3) \
__F(f4) \
__F(f5) \
__F(f6) \
TABLE_END

	TABLE5(Module, TableType::MODULE, generation, name, mvid, encid, encBaseId)
	TABLE3(TypeRef, TableType::TYPEREF, resolutionScope, typeName, typeNamespace)
	TABLE6(TypeDef, TableType::TYPEDEF, flags, typeName, typeNamespace, extends, fieldList, methodList)
	TABLE1(TypeSpec, TableType::TYPESPEC, signature);
	TABLE4(ImplMap, TableType::IMPLMAP, mappingFlags, memberForwarded, importName, importScope)
	TABLE1(ModuleRef, TableType::MODULEREF, name)
	TABLE3(Field, TableType::FIELD, flags, name, signature)
	TABLE4(GenericParam, TableType::GENERICPARAM, number, flags, owner, name)
	TABLE2(GenericParamConstraint, TableType::GENERICPARAMCONSTRAINT, owner, constraint)
	TABLE3(MemberRef, TableType::MEMBERREF, classIdx, name, signature)
	TABLE1(StandAloneSig, TableType::STANDALONESIG, signature)
	TABLE3(MethodImpl, TableType::METHODIMPL, classIdx, methodBody, methodDeclaration)
	TABLE2(FieldRVA, TableType::FIELDRVA, rva, field)
	TABLE2(FieldLayout, TableType::FIELDLAYOUT, offset, field)
	TABLE4(Constant, TableType::CONSTANT, type, padding, parent, value)
	TABLE2(MethodSpec, TableType::METHODSPEC, method, instantiation)
	TABLE3(CustomAttribute, TableType::CUSTOMATTRIBUTE, parent, type, value)
	TABLE2(PropertyMap, TableType::PROPERTYMAP, parent, propertyList)
	TABLE3(Property, TableType::PROPERTY, flags, name, type)
	TABLE2(EventMap, TableType::EVENTMAP, parent, eventList)
	TABLE3(Event, TableType::EVENT, eventFlags, name, eventType)
	TABLE3(MethodSemantics, TableType::METHODSEMANTICS, semantics, method, association)

	TABLE2(NestedClass, TableType::NESTEDCLASS, nestedClass, enclosingClass)
	TABLE6(Method, TableType::METHOD, rva, implFlags, flags, name, signature, paramList)
	TABLE3(Param, TableType::PARAM, flags, sequence, name)

	TABLE3(ClassLayout, TableType::CLASSLAYOUT, packingSize, classSize, parent)
	TABLE2(InterfaceImpl, TableType::INTERFACEIMPL, classIdx, interfaceIdx)

	TABLE_BEGIN(Assembly, TableType::ASSEMBLY)
	__F(hashAlgId)
	__F(majorVersion)
	__F(minorVersion)
	__F(buildNumber)
	__F(revisionNumber)
	__F(flags)
	__F(publicKey)
	__F(name)
	__F(locale)
	TABLE_END


	TABLE_BEGIN(AssemblyRef, TableType::ASSEMBLYREF)
	__F(majorVersion)
	__F(minorVersion)
	__F(buildNumber)
	__F(revisionNumber)
	__F(flags)
	__F(publicKeyOrToken)
	__F(name)
	__F(locale)
	__F(hashValue)
	TABLE_END

	TABLE4(Document, TableType::DOCUMENT, name, hashAlgorithm, hash, language)
	TABLE2(MethodDebugInformation, TableType::METHODDEBUGINFORMATION, document, sequencePoints)
	TABLE6(LocalScope, TableType::LOCALSCOPE, method, importScope, variables, constants, startOffset, length)
	TABLE3(LocalVariable, TableType::LOCALVARIABLE, attributes, index, name)
	TABLE2(LocalConstant, TableType::LOCALCONSTANT, name, signature)
	TABLE2(ImportScope, TableType::IMPORTSCOPE, parent, imports)
	TABLE2(StateMachineMethod, TableType::STATEMACHINEMETHOD, moveNextMethod, kickoffMethod)
	TABLE3(CustomDebugInformation, TableType::CUSTOMDEBUGINFORMATION, parent, kind, value)


	protected:
		const byte* _imageData;
		uint32_t _imageLength;
		const byte* _ptrRawDataEnd;

		std::vector<SectionHeader> _sections;


		uint32_t _entryPointToken;

		CliStream _streamStringHeap;
		CliStream _streamUS;
		CliStream _streamBlobHeap;
		CliStream _streamGuidHeap;
		CliStream _streamTables;

		bool _4byteStringIndex;
		bool _4byteGUIDIndex;
		bool _4byteBlobIndex;

		Table _tables[TABLE_NUM];
		std::vector<ColumnOffsetSize> _tableRowMetas[TABLE_NUM];
	};
}
}
```

`hybridclr/metadata/SuperSetAOTHomologousImage.cpp`:

```cpp
#include "SuperSetAOTHomologousImage.h"

#include "vm/MetadataLock.h"
#include "vm/GlobalMetadata.h"
#include "vm/Class.h"
#include "vm/Image.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"
#include "metadata/GenericMetadata.h"
#include "MetadataPool.h"

namespace hybridclr
{
namespace metadata
{



	const Il2CppMethodDefinition* FindMatchMethod(const Il2CppTypeDefinition* aotTypeDef, const SuperSetMethodDefDetail& method2, const char* methodName, const MethodRefSig& methodSignature)
	{
		const Il2CppGenericContainer* klassGenContainer = aotTypeDef->genericContainerIndex != kGenericContainerIndexInvalid ?
			(const Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(aotTypeDef->genericContainerIndex) : nullptr;
		for (uint16_t i = 0; i < aotTypeDef->method_count; i++)
		{
			//const MethodInfo* method1 = klass1->methods[i];
			const Il2CppMethodDefinition* aotMethodDef = il2cpp::vm::GlobalMetadata::GetMethodDefinitionFromIndex(aotTypeDef->methodStart + i);
			const char* aotMethodName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(aotMethodDef->nameIndex);
			if (std::strcmp(aotMethodName, methodName))
			{
				continue;
			}
			if (IsMatchMethodSig(aotMethodDef, methodSignature, klassGenContainer))
			{
				return aotMethodDef;
			}
		}
		return nullptr;
	}


	const Il2CppFieldDefinition* FindMatchField(const Il2CppTypeDefinition* aotTypeDef, const SuperSetFieldDefDetail& field2, const char* fieldName, const Il2CppType* fieldType)
	{
		const Il2CppGenericContainer* klassGenContainer = aotTypeDef->genericContainerIndex != kGenericContainerIndexInvalid ?
			(const Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(aotTypeDef->genericContainerIndex) : nullptr;
		for (uint16_t i = 0; i < aotTypeDef->field_count; i++)
		{
			//const FieldInfo* field1 = klass1->fields + i;
			const Il2CppFieldDefinition* aotField = il2cpp::vm::GlobalMetadata::GetFieldDefinitionFromTypeDefAndFieldIndex(aotTypeDef, i);
			const char* aotFieldName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(aotField->nameIndex);
			if (std::strcmp(aotFieldName, fieldName))
			{
				continue;
			}
			const Il2CppType* aotFieldType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(aotField->typeIndex);
			if (IsMatchSigType(aotFieldType, fieldType, klassGenContainer, nullptr))
			{
				return aotField;
			}
		}
		return nullptr;
	}

	void SuperSetAOTHomologousImage::InitRuntimeMetadatas()
	{
		_defaultIl2CppType = &il2cpp_defaults.missing_class->byval_arg;

		std::vector< SuperSetTypeIntermediateInfo> typeIntermediateInfos;
		InitTypes0(typeIntermediateInfos);
		InitNestedClass(typeIntermediateInfos);
		InitTypes1(typeIntermediateInfos);

		InitMethods(typeIntermediateInfos);
		InitFields(typeIntermediateInfos);
	}

	void SuperSetAOTHomologousImage::InitTypes0(std::vector< SuperSetTypeIntermediateInfo>& typeIntermediateInfos)
	{
		const Table& typeDefTb = _rawImage->GetTable(TableType::TYPEDEF);
		uint32_t typeCount = typeDefTb.rowNum;
		typeIntermediateInfos.resize(typeCount);
		_typeDefs.resize(typeCount);
		_aotTypeIndex2TypeDefs.resize(typeCount);
	}

	void SuperSetAOTHomologousImage::InitNestedClass(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos)
	{
		const Table& nestedClassTb = _rawImage->GetTable(TableType::NESTEDCLASS);
		for (uint32_t i = 0; i < nestedClassTb.rowNum; i++)
		{
			TbNestedClass data = _rawImage->ReadNestedClass(i + 1);
			SuperSetTypeIntermediateInfo& nestedType = typeIntermediateInfos[data.nestedClass - 1];
			nestedType.homoParentRowIndex = data.enclosingClass;
		}
	}

	void SuperSetAOTHomologousImage::InitType(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos, SuperSetTypeIntermediateInfo& type)
	{
		if (type.inited)
		{
			return;
		}
		type.inited = true;
		uint32_t rowIndex = (uint32_t)(&type - &typeIntermediateInfos[0] + 1);
		TbTypeDef data = _rawImage->ReadTypeDef(rowIndex);

		type.homoMethodStartIndex = data.methodList;
		type.homoFieldStartIndex = data.fieldList;

		const char* name = _rawImage->GetStringFromRawIndex(data.typeName);
		const char* namespaze = _rawImage->GetStringFromRawIndex(data.typeNamespace);
		if (type.homoParentRowIndex)
		{
			SuperSetTypeIntermediateInfo& parent = typeIntermediateInfos[type.homoParentRowIndex - 1];
			InitType(typeIntermediateInfos, parent);
			const Il2CppTypeDefinition* parentTypeDef = parent.aotTypeDef;
			if (parentTypeDef == nullptr)
			{
				goto labelInitDefault;
			}

			void* iter = nullptr;
			for (const Il2CppTypeDefinition* nextTypeDef; (nextTypeDef = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetNestedTypes((Il2CppMetadataTypeHandle)parentTypeDef, &iter));)
			{
				const char* nestedTypeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(nextTypeDef->nameIndex);
				IL2CPP_ASSERT(nestedTypeName);
				if (!std::strcmp(name, nestedTypeName))
				{
					type.aotTypeDef = nextTypeDef;
					//type.aotTypeIndex = nextTypeDef->byvalTypeIndex;
					type.aotIl2CppType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(nextTypeDef->byvalTypeIndex);
					//type.aotKlass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle((Il2CppMetadataTypeHandle)nextTypeDef);
					return;
				}
			}
		}
		else
		{
			const Il2CppTypeDefinition* aotTypeDef = (const Il2CppTypeDefinition*)il2cpp::vm::Image::TypeHandleFromName(_targetAssembly->image, namespaze, name);
			if (aotTypeDef)
			{
				type.aotTypeDef = aotTypeDef;
				type.aotIl2CppType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(aotTypeDef->byvalTypeIndex);
				//type.aotTypeIndex = type.aotTypeDef->byvalTypeIndex;
				return;
			}
		}
		labelInitDefault:
		type.aotIl2CppType = _defaultIl2CppType;
		//TEMP_FORMAT(msg, "type: %s::%s can't find homologous type in assembly:%s", type.namespaze, type.name, _targetAssembly->aname.name);
		//RaiseExecutionEngineException(msg);
	}

	void SuperSetAOTHomologousImage::InitTypes1(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos)
	{
		for (SuperSetTypeIntermediateInfo& td : typeIntermediateInfos)
		{
			//uint32_t rowIndex = ++index;
			//TbTypeDef data = _rawImage->ReadTypeDef(rowIndex);

			//td.inited = false;
			//td.homoParentRowIndex = 0;
			//td.homoRowIndex = rowIndex;
			//td.homoMethodStartIndex = data.methodList;
			//td.homoFieldStartIndex = data.fieldList;

			//td.name = _rawImage->GetStringFromRawIndex(data.typeName);
			//td.namespaze = _rawImage->GetStringFromRawIndex(data.typeNamespace);
			InitType(typeIntermediateInfos, td);
		}

		uint32_t index = 0;
		for (SuperSetTypeIntermediateInfo& td : typeIntermediateInfos)
		{
			SuperSetTypeDefDetail& type = _typeDefs[index++];
			type.aotIl2CppType = td.aotIl2CppType;
			if (td.aotTypeDef)
			{
				_aotTypeIndex2TypeDefs[il2cpp::vm::GlobalMetadata::GetIndexForTypeDefinition(td.aotTypeDef)] = &type;
			}
		}
	}

	void SuperSetAOTHomologousImage::InitMethods(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos)
	{
		const Table& methodTb = _rawImage->GetTable(TableType::METHOD);
		uint32_t methodCount = methodTb.rowNum;
		_methodDefs.resize(methodCount);
		//_token2MethodDefs.resize(methodCount * 2);
		uint32_t typeCount = (uint32_t)typeIntermediateInfos.size();
		for (SuperSetTypeIntermediateInfo& type : typeIntermediateInfos)
		{
			uint32_t nextTypeIndex = (uint32_t)(&type - &typeIntermediateInfos[0] + 1);
			uint32_t nextTypeMethodStartIndex = nextTypeIndex < typeCount ? typeIntermediateInfos[nextTypeIndex].homoMethodStartIndex : methodCount + 1;


			for (uint32_t i = type.homoMethodStartIndex; i < nextTypeMethodStartIndex ; i++)
			{
				SuperSetMethodDefDetail& method = _methodDefs[i - 1];
				TbMethod data = _rawImage->ReadMethod(i);
				//method.declaringTypeDef = type.aotTypeDef;
				//method.name = _rawImage->GetStringFromRawIndex(data.name);
				if (type.aotTypeDef == nullptr)
				{
					continue;
				}
				MethodRefSig signature = {};
				signature.flags = data.flags;
				BlobReader methodSigReader = _rawImage->GetBlobReaderByRawIndex(data.signature);
				ReadMethodDefSig(methodSigReader, signature);
				const char* methodName = _rawImage->GetStringFromRawIndex(data.name);
				method.aotMethodDef = FindMatchMethod(type.aotTypeDef, method, methodName, signature);
				if (method.aotMethodDef &&
					(type.aotTypeDef->genericContainerIndex != kGenericContainerIndexInvalid
						|| method.aotMethodDef->genericContainerIndex != kGenericContainerIndexInvalid))
				{
					_token2MethodDefs[method.aotMethodDef->token] = &method;
				}
			}
		}
	}

	void SuperSetAOTHomologousImage::ReadMethodDefSig(BlobReader& reader, MethodRefSig& method)
	{
		uint8_t rawSigFlags = reader.ReadByte();

		if (rawSigFlags & (uint8_t)MethodSigFlags::GENERIC)
		{
			//IL2CPP_ASSERT(false);
			method.genericParamCount = reader.ReadCompressedUint32();
			IL2CPP_ASSERT(method.genericParamCount > 0);
		}
		uint32_t paramCount = reader.ReadCompressedUint32();
		//IL2CPP_ASSERT(paramCount >= methodDef.parameterCount);

		method.returnType = ReadType(reader, nullptr, nullptr);

		int readParamNum = 0;
		for (; reader.NonEmpty(); )
		{
			const Il2CppType* paramType = ReadType(reader, nullptr, nullptr);
			method.params.push_back(paramType);
			++readParamNum;
		}
		IL2CPP_ASSERT(readParamNum == (int)paramCount);
	}

	void SuperSetAOTHomologousImage::InitFields(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos)
	{
		const Table& fieldTb = _rawImage->GetTable(TableType::FIELD);
		uint32_t fieldCount = fieldTb.rowNum;
		_fields.resize(fieldTb.rowNum);

		uint32_t typeCount = (uint32_t)typeIntermediateInfos.size();
		for (SuperSetTypeIntermediateInfo& type : typeIntermediateInfos)
		{
			uint32_t nextTypeIndex = (uint32_t)(&type - &typeIntermediateInfos[0] + 1);
			uint32_t nextTypeFieldStartIndex = nextTypeIndex < typeCount ? typeIntermediateInfos[nextTypeIndex].homoFieldStartIndex : fieldCount + 1;
			for (uint32_t i = type.homoFieldStartIndex; i < nextTypeFieldStartIndex; i++)
			{
				SuperSetFieldDefDetail& field = _fields[i - 1];
				//field.homoRowIndex = i;
				TbField data = _rawImage->ReadField(i);
				//field.name = _rawImage->GetStringFromRawIndex(data.name);

				//field.declaringTypeDef = type.aotTypeDef;
				field.declaringIl2CppType = type.aotIl2CppType;
				if (type.aotTypeDef == nullptr)
				{
					continue;
				}

				BlobReader br = _rawImage->GetBlobReaderByRawIndex(data.signature);
				FieldRefSig frs;
				ReadFieldRefSig(br, nullptr, frs);
				if (data.flags)
				{
					Il2CppType* newType = MetadataPool::ShallowCloneIl2CppType(frs.type);
					newType->attrs = data.flags;
					frs.type = newType;
				}

				const char* fieldName = _rawImage->GetStringFromRawIndex(data.name);
				field.aotFieldDef = FindMatchField(type.aotTypeDef, field, fieldName, frs.type);
			}
		}
	}

	MethodBody* SuperSetAOTHomologousImage::GetMethodBody(uint32_t token)
	{
		auto it = _token2MethodDefs.find(token);
		if (it == _token2MethodDefs.end())
		{
			return nullptr;
		}
		SuperSetMethodDefDetail* method = it->second;
		uint32_t rowIndex = (uint32_t)(method - &_methodDefs[0] + 1);
		TbMethod methodData = _rawImage->ReadMethod(rowIndex);
		MethodBody* body = new (HYBRIDCLR_MALLOC_ZERO(sizeof(MethodBody))) MethodBody();
		ReadMethodBody(*method->aotMethodDef, methodData, *body);
		return body;
	}

	const Il2CppType* SuperSetAOTHomologousImage::GetIl2CppTypeFromRawTypeDefIndex(uint32_t index)
	{
		IL2CPP_ASSERT((size_t)index < _typeDefs.size());
		return _typeDefs[index].aotIl2CppType;
	}

	Il2CppGenericContainer* SuperSetAOTHomologousImage::GetGenericContainerByRawIndex(uint32_t index)
	{
		return (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(index);
	}

	Il2CppGenericContainer* SuperSetAOTHomologousImage::GetGenericContainerByTypeDefRawIndex(int32_t typeDefIndex)
	{
		auto it = _aotTypeIndex2TypeDefs.find(typeDefIndex);
		if (it == _aotTypeIndex2TypeDefs.end())
		{
			return nullptr;
		}
		const Il2CppType* type = it->second->aotIl2CppType;
		if (type == nullptr)
		{
			return nullptr;
		}
		const Il2CppTypeDefinition* typeDef = (const Il2CppTypeDefinition*)(type->data.typeHandle);
		return (Il2CppGenericContainer*)il2cpp::vm::GlobalMetadata::GetGenericContainerFromIndex(typeDef->genericContainerIndex);
	}

	const Il2CppMethodDefinition* SuperSetAOTHomologousImage::GetMethodDefinitionFromRawIndex(uint32_t index)
	{
		IL2CPP_ASSERT((size_t)index < _methodDefs.size());
		SuperSetMethodDefDetail& method = _methodDefs[index];
		const Il2CppMethodDefinition* methodDef = method.aotMethodDef;
		if (!methodDef)
		{
			TEMP_FORMAT(errMsg, "method not exist. rowIndex:%d", index);
			RaiseExecutionEngineException(errMsg);
		}
		return methodDef;
	}

	void SuperSetAOTHomologousImage::ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret)
	{
		IL2CPP_ASSERT(rowIndex > 0);
		SuperSetFieldDefDetail& fd = _fields[rowIndex - 1];
		ret.containerType = fd.declaringIl2CppType;
		ret.field = fd.aotFieldDef;
	}

	const Il2CppType* SuperSetAOTHomologousImage::ReadTypeFromResolutionScope(uint32_t scope, uint32_t typeNamespace, uint32_t typeName)
	{
		TableType tokenType;
		uint32_t rawIndex;
		DecodeResolutionScopeCodedIndex(scope, tokenType, rawIndex);
		switch (tokenType)
		{
		case TableType::MODULE:
		{
			const Il2CppType* retType = GetModuleIl2CppType(rawIndex, typeNamespace, typeName, false);
			return retType ? retType : _defaultIl2CppType;
		}
		case TableType::MODULEREF:
		{
			RaiseNotSupportedException("Image::ReadTypeFromResolutionScope not support ResolutionScore.MODULEREF");
			return nullptr;
		}
		case TableType::ASSEMBLYREF:
		{
			const Il2CppType* refType = GetIl2CppType(rawIndex, typeNamespace, typeName, false);
			return refType ? refType : _defaultIl2CppType;
		}
		case TableType::TYPEREF:
		{
			const Il2CppType* enClosingType = ReadTypeFromTypeRef(rawIndex);
			IL2CPP_ASSERT(typeNamespace == 0);
			const char* name = _rawImage->GetStringFromRawIndex(typeName);

			void* iter = nullptr;
			Il2CppMetadataTypeHandle enclosingTypeDef = enClosingType->data.typeHandle;
			if (!enclosingTypeDef)
			{
				//TEMP_FORMAT(errMsg, "Image::ReadTypeFromResolutionScope ReadTypeFromResolutionScope.TYPEREF enclosingType:%s", name);
				//RaiseExecutionEngineException(errMsg);
				return _defaultIl2CppType;
			}
			for (const Il2CppTypeDefinition* nextTypeDef; (nextTypeDef = (const Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetNestedTypes(enclosingTypeDef, &iter));)
			{
				const char* nestedTypeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(nextTypeDef->nameIndex);
				IL2CPP_ASSERT(nestedTypeName);
				if (!std::strcmp(name, nestedTypeName))
				{
					return GetIl2CppTypeFromTypeDefinition(nextTypeDef);
				}
			}
			return _defaultIl2CppType;
		}
		default:
		{
			RaiseBadImageException("Image::ReadTypeFromResolutionScope invaild TableType");
			return nullptr;
		}
		}
	}
}
}


```

`hybridclr/metadata/SuperSetAOTHomologousImage.h`:

```h
#pragma once

#include "AOTHomologousImage.h"
#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"

namespace hybridclr
{
	namespace metadata
	{

		struct SuperSetTypeIntermediateInfo
		{
			bool inited;
			//uint32_t homoRowIndex;
			uint32_t homoParentRowIndex;
			uint32_t homoMethodStartIndex; // start from 1
			uint32_t homoFieldStartIndex; // start from 1
			//const char* name;
			//const char* namespaze;
			//int32_t aotTypeIndex; // il2cpp type index
			const Il2CppType* aotIl2CppType;
			const Il2CppTypeDefinition* aotTypeDef;
			//const Il2CppClass* aotKlass;
		};

		struct SuperSetTypeDefDetail
		{
			//bool inited;
			//uint32_t homoRowIndex;
			//uint32_t homoParentRowIndex;
			//uint32_t homoMethodStartIndex; // start from 1
			//uint32_t homoFieldStartIndex; // start from 1
			//const char* name;
			//const char* namespaze;
			//int32_t aotTypeIndex; // il2cpp type index
			const Il2CppType* aotIl2CppType;
			//const Il2CppTypeDefinition* aotTypeDef;
			//const Il2CppClass* aotKlass;
		};

		struct SuperSetMethodDefDetail
		{
			//uint32_t homoRowIndex; 
			//MethodRefSig signature;
			//const Il2CppTypeDefinition* declaringTypeDef;
			//const Il2CppClass* declaringKlass;
			//const char* name;
			const Il2CppMethodDefinition* aotMethodDef;
		};

		struct SuperSetFieldDefDetail
		{
			//uint32_t homoRowIndex;
			//const char* name;
			//Il2CppType type;
			//const Il2CppTypeDefinition* declaringTypeDef;
			const Il2CppType* declaringIl2CppType;
			const Il2CppFieldDefinition* aotFieldDef;
		};

		class SuperSetAOTHomologousImage : public AOTHomologousImage
		{
		public:
			SuperSetAOTHomologousImage() : AOTHomologousImage() {}

			void InitRuntimeMetadatas() override;

			const Il2CppType* ReadTypeFromResolutionScope(uint32_t scope, uint32_t typeNamespace, uint32_t typeName) override;
			MethodBody* GetMethodBody(uint32_t token) override;
			const Il2CppType* GetIl2CppTypeFromRawTypeDefIndex(uint32_t index) override;
			Il2CppGenericContainer* GetGenericContainerByRawIndex(uint32_t index) override;
			Il2CppGenericContainer* GetGenericContainerByTypeDefRawIndex(int32_t typeDefIndex) override;
			const Il2CppMethodDefinition* GetMethodDefinitionFromRawIndex(uint32_t index) override;
			void ReadFieldRefInfoFromFieldDefToken(uint32_t rowIndex, FieldRefInfo& ret) override;
		private:

			void InitTypes0(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos);
			void InitNestedClass(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos);
			void InitType(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos, SuperSetTypeIntermediateInfo& type);
			void InitTypes1(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos);
			void ReadMethodDefSig(BlobReader& reader, MethodRefSig& method);
			void InitMethods(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos);
			void InitFields(std::vector<SuperSetTypeIntermediateInfo>& typeIntermediateInfos);

			const Il2CppType* _defaultIl2CppType;

			std::vector<SuperSetTypeDefDetail> _typeDefs;
			Il2CppHashMap<int32_t, SuperSetTypeDefDetail*, il2cpp::utils::PassThroughHash<int32_t>> _aotTypeIndex2TypeDefs;

			Il2CppHashMap<uint32_t, SuperSetMethodDefDetail*, il2cpp::utils::PassThroughHash<uint32_t>> _token2MethodDefs;
			std::vector<SuperSetMethodDefDetail> _methodDefs;

			std::vector<SuperSetFieldDefDetail> _fields;
		};
	}
}
```

`hybridclr/metadata/Tables.h`:

```h
#pragma once
#include <stdint.h>

namespace hybridclr
{
namespace metadata
{

    enum class TableType
    {
        MODULE,
        TYPEREF,
        TYPEDEF,
        FIELDPTR,
        FIELD,
        METHODPTR,
        METHOD,
        PARAMPTR,
        PARAM,
        INTERFACEIMPL,
        MEMBERREF, /* 0xa */
        CONSTANT,
        CUSTOMATTRIBUTE,
        FIELDMARSHAL,
        DECLSECURITY,
        CLASSLAYOUT,
        FIELDLAYOUT, /* 0x10 */
        STANDALONESIG,
        EVENTMAP,
        EVENTPTR,
        EVENT,
        PROPERTYMAP,
        PROPERTYPTR,
        PROPERTY,
        METHODSEMANTICS,
        METHODIMPL,
        MODULEREF, /* 0x1a */
        TYPESPEC,
        IMPLMAP,
        FIELDRVA,
        ENCLOG,
        ENCMAP,
        ASSEMBLY, /* 0x20 */
        ASSEMBLYPROCESSOR,
        ASSEMBLYOS,
        ASSEMBLYREF,
        ASSEMBLYREFPROCESSOR,
        ASSEMBLYREFOS,
        FILE,
        EXPORTEDTYPE,
        MANIFESTRESOURCE,
        NESTEDCLASS,
        GENERICPARAM, /* 0x2a */
        METHODSPEC,
        GENERICPARAMCONSTRAINT,
        UNUSED8,
        UNUSED9,
        UNUSED10,
        /* Portable PDB tables */
        DOCUMENT, /* 0x30 */
        METHODDEBUGINFORMATION,
        LOCALSCOPE,
        LOCALVARIABLE,
        LOCALCONSTANT,
        IMPORTSCOPE,
        STATEMACHINEMETHOD,
        CUSTOMDEBUGINFORMATION,
    };


    // 0
    struct TbModule
    {
        uint16_t generation;
        uint32_t name;
        uint32_t mvid;
        uint32_t encid;
        uint32_t encBaseId;
    };

    // 1
    struct TbTypeRef
    {
        uint32_t resolutionScope;
        uint32_t typeName;
        uint32_t typeNamespace;
    };

    // 2
    struct TbTypeDef
    {
        uint32_t flags;
        uint32_t typeName;
        uint32_t typeNamespace;
        uint32_t extends;
        uint32_t fieldList;
        uint32_t methodList;
    };

    // 3 FIELDPTR

    struct TbFieldPtr
    {
        uint32_t field;
    };

    // 4
    struct TbField
    {
        uint32_t flags;
        uint32_t name;
        uint32_t signature;
    };

    // 5 METHODPTR

    struct TbMethodPtr
    {
        uint32_t method;
    };
        
    // 6
    struct TbMethod
    {
        uint32_t rva;
        uint16_t implFlags;
        uint16_t flags;
        uint32_t name;
        uint32_t signature;
        uint32_t paramList;
    };

    // 7 PARAMPTR
    struct TbParamPtr
    {
        uint32_t param;
    };

    // 8
    struct TbParam
    {
        uint16_t flags;
        uint16_t sequence;
        uint32_t name;
    };

    // 9
    struct TbInterfaceImpl
    {
        uint32_t classIdx;
        uint32_t interfaceIdx;
    };

    // 0xa
    struct TbMemberRef
    {
        uint32_t classIdx;
        uint32_t name;
        uint32_t signature;
    };

    struct TbConstant
    {
        uint8_t type;
        uint8_t padding;
        uint32_t parent;
        uint32_t value;
    };

    struct TbCustomAttribute
    {
        uint32_t parent;
        uint32_t type;
        uint32_t value;
    };

    struct TbFieldMarshal
    {
        uint32_t parent;
        uint32_t nativeType;
    };

    struct TbDeclSecurity
    {
        uint16_t action;
        uint32_t parent;
        uint32_t permissionSet;
    };

    struct TbClassLayout
    {
        uint16_t packingSize;
        uint32_t classSize;
        uint32_t parent;
    };

    // 0x10
    struct TbFieldLayout
    {
        uint32_t offset;
        uint32_t field;
    };

    struct TbStandAloneSig
    {
        uint32_t signature;
    };

    struct TbEventMap
    {
        uint32_t parent;
        uint32_t eventList;
    };

    // 0x13 EVENTPTR
    struct TbEventPtr
    {
        uint32_t event;
    };

    // 0x14
    struct TbEvent
    {
        uint16_t eventFlags;
        uint32_t name;
        uint32_t eventType;
    };

    struct TbPropertyMap
    {
        uint32_t parent;
        uint32_t propertyList;
    };

    // PROPERTYPTR
    struct TbPropertyPtr
    {
        uint32_t property;
    };

    struct TbProperty
    {
        uint16_t flags;
        uint32_t name;
        uint32_t type;
    };

    struct TbMethodSemantics
    {
        uint16_t semantics;
        uint32_t method;
        uint32_t association;
    };

    struct TbMethodImpl
    {
        uint32_t classIdx;
        uint32_t methodBody;
        uint32_t methodDeclaration;
    };

    struct TbModuleRef
    {
        uint32_t name;
    };

    struct TbTypeSpec
    {
        uint32_t signature;
    };

    struct TbImplMap
    {
        uint16_t mappingFlags;
        uint32_t memberForwarded;
        uint32_t importName;
        uint32_t importScope;
    };

    struct TbFieldRVA
    {
        uint32_t rva;
        uint32_t field;
    };

    struct TbEncLog
    {
        uint32_t token;
        uint32_t funcCode;
    };

    struct TbEncMap
    {
        uint32_t token;
    };

    struct TbAssembly
    {
        uint32_t hashAlgId;
        uint16_t majorVersion;
        uint16_t minorVersion;
        uint16_t buildNumber;
        uint16_t revisionNumber;
        uint32_t flags;
        uint32_t publicKey;
        uint32_t name;
        uint32_t locale;
    };

    struct TbAssemblyProcessor
    {
        uint32_t processor;
    };

    struct TbAssemblyOS
    {
        uint32_t osPlatformId;
        uint32_t osMajorVersion;
        uint32_t osMinorVersion;
    };

    struct TbAssemblyRef
    {
        uint16_t majorVersion;
        uint16_t minorVersion;
        uint16_t buildNumber;
        uint16_t revisionNumber;
        uint32_t flags;
        uint32_t publicKeyOrToken;
        uint32_t name;
        uint32_t locale;
        uint32_t hashValue;
    };

    struct TbAssemblyRefProcessor
    {
        uint32_t processor;
        uint32_t assemblyRef;
    };

    struct TbAssemblyRefOS
    {
        uint32_t osPlatformId;
        uint32_t osMajorVersion;
        uint32_t osMinorVersion;
        uint32_t assemblyRef;
    };

    struct TbFile
    {
        uint32_t flags;
        uint32_t name;
        uint32_t hashValue;
    };

    struct TbExportedType
    {
        uint32_t flags;
        uint32_t typeDefId;
        uint32_t typeName;
        uint32_t typeNamespace;
        uint32_t implementation;
    };

    struct TbManifestResource
    {
        uint32_t offset;
        uint32_t flags;
        uint32_t name;
        uint32_t implementation;
    };

    struct TbNestedClass
    {
        uint32_t nestedClass;
        uint32_t enclosingClass;
    };

    struct TbGenericParam
    {
        uint16_t number;
        uint16_t flags;
        uint32_t owner;
        uint32_t name;
    };

    struct TbMethodSpec
    {
        uint32_t method;
        uint32_t instantiation;
    };

    struct TbGenericParamConstraint
    {
        uint32_t owner;
        uint32_t constraint;
    };

    struct TbDocument
    {
        uint32_t name;
        uint32_t hashAlgorithm;
        uint32_t hash;
        uint32_t language;
    };

    struct TbMethodDebugInformation
    {
        uint32_t document;
        uint32_t sequencePoints;
    };

    struct TbLocalScope
    {
        uint32_t method;
        uint32_t importScope;
        uint32_t variables;
        uint32_t constants;
        uint32_t startOffset;
        uint32_t length;
    };

    struct TbLocalVariable
    {
        uint16_t attributes;
        uint16_t index;
        uint32_t name;
    };

    struct TbLocalConstant
    {
        uint32_t name;
        uint32_t signature;
    };

    struct TbImportScope
    {
        uint32_t parent;
        uint32_t imports;
    };


    struct TbStateMachineMethod
    {
        uint32_t moveNextMethod;
        uint32_t kickoffMethod;
    };

    struct TbCustomDebugInformation
    {
        uint32_t parent;
		uint32_t kind;
		uint32_t value;
	};

}

}
```

`hybridclr/metadata/VTableSetup.cpp`:

```cpp
#include "VTableSetup.h"

#include <algorithm>

#include "vm/GlobalMetadata.h"
#include "metadata/GenericMetadata.h"

#include "MetadataModule.h"

namespace hybridclr
{
namespace metadata
{
	const Il2CppType* TryInflateIfNeed(const Il2CppType* containerType, const Il2CppType* genericType, const Il2CppType* selfType)
	{
		if (selfType->type == IL2CPP_TYPE_CLASS || selfType->type == IL2CPP_TYPE_VALUETYPE)
		{
			if (genericType->data.typeHandle == selfType->data.typeHandle)
			{
				return containerType;
			}
		}
		return TryInflateIfNeed(containerType, selfType);
	}

	VTableSetUp* VTableSetUp::InflateVts(Il2CppType2TypeDeclaringTreeMap& cache, VTableSetUp* genericType, const Il2CppType* type)
	{
		IL2CPP_ASSERT(genericType->_type->data.typeHandle == type->data.generic_class->type->data.typeHandle);
		VTableSetUp* tdt = new (HYBRIDCLR_MALLOC_ZERO(sizeof(VTableSetUp))) VTableSetUp();
		tdt->_type = type;
		tdt->_typeDef = genericType->_typeDef;
		tdt->_parent = genericType->_parent ? BuildByType(cache, TryInflateIfNeed(type, genericType->_parent->_type)) : nullptr;
		tdt->_name = genericType->_name;

		for (VTableSetUp* gintf : genericType->_interfaces)
		{
			const Il2CppType* intType = TryInflateIfNeed(type, gintf->_type);
			VTableSetUp* intf = BuildByType(cache, intType);
			tdt->_interfaces.push_back(intf);
		}

		for (GenericClassMethod& gcm : genericType->_virtualMethods)
		{
			tdt->_virtualMethods.push_back({ TryInflateIfNeed(type, genericType->_type, gcm.type), gcm.method, gcm.name });
		}

		for (RawInterfaceOffsetInfo& roi : genericType->_interfaceOffsetInfos)
		{
			const Il2CppType* intType = TryInflateIfNeed(type, genericType->_type, roi.type);
			VTableSetUp* intf = BuildByType(cache, intType);
			tdt->_interfaceOffsetInfos.push_back({ intType, intf, roi.offset });
		}

		for (VirtualMethodImpl& vmi : genericType->_methodImpls)
		{
			const Il2CppType* declaringType = vmi.type ? TryInflateIfNeed(type, genericType->_type, vmi.type) : nullptr;
			tdt->_methodImpls.push_back({ vmi.method, declaringType, vmi.slot /*, vmi.name*/});
		}

		return tdt;
	}

	VTableSetUp* VTableSetUp::BuildByType(Il2CppType2TypeDeclaringTreeMap& cache, const Il2CppType* type)
	{
		auto it = cache.find(type);
		if (it != cache.end())
		{
			return it->second;
		}
		if (type->type == IL2CPP_TYPE_GENERICINST)
		{
			const Il2CppType* genericType = type->data.generic_class->type;
			IL2CPP_ASSERT(genericType);
			VTableSetUp* gdt = BuildByType(cache, genericType);
			VTableSetUp* gidt = InflateVts(cache, gdt, type);
			return cache[type] = gidt;
		}
		VTableSetUp* tdt = new (HYBRIDCLR_MALLOC_ZERO(sizeof(VTableSetUp))) VTableSetUp();
		const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
		const char* ns = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->namespaceIndex);
		const char* name = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
		const Il2CppType* parentType = nullptr;
		if (typeDef->parentIndex != kInvalidIndex)
		{
			parentType = il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDef->parentIndex);
		}
		tdt->_type = type;
		tdt->_typeDef = typeDef;
		tdt->_parent = parentType ? BuildByType(cache, parentType) : nullptr;
		tdt->_name = name;

		for (uint32_t i = 0; i < typeDef->interfaces_count; i++)
		{
			const Il2CppType* intType = il2cpp::vm::GlobalMetadata::GetInterfaceFromOffset(typeDef, i);
			VTableSetUp* intf = BuildByType(cache, intType);
			tdt->_interfaces.push_back(intf);
		}

		for (uint32_t i = 0; i < typeDef->method_count; i++)
		{
			const Il2CppMethodDefinition* methodDef = il2cpp::vm::GlobalMetadata::GetMethodDefinitionFromIndex(typeDef->methodStart + i);
			const char* methodName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex);
			if (hybridclr::metadata::IsVirtualMethod(methodDef->flags))
			{
				tdt->_virtualMethods.push_back({ type, methodDef, methodName });
			}
		}
		if (hybridclr::metadata::IsInterface(typeDef->flags))
		{
			tdt->ComputeInterfaceVtables(cache);
		}
		else
		{
			tdt->ComputeVtables(cache);
		}
		cache[type] = tdt;
		return tdt;
	}


	inline bool IsOverrideMethod(const GenericClassMethod& m1, const GenericClassMethod& m2)
	{
		return hybridclr::metadata::IsOverrideMethod(m1.type, m1.method, m2.type, m2.method);
	}


	uint16_t FindLastSameMethod(std::vector<GenericClassMethod>& methods, uint32_t maxIdx, const GenericClassMethod& find, bool notSealed)
	{
		for (uint32_t i = std::min(maxIdx, (uint32_t)methods.size()); i > 0; i--)
		{
			uint32_t idx = i - 1;
			if (methods[idx].method == nullptr)
			{
				continue;
			}
			if (IsOverrideMethod(methods[idx], find))
			{
				return idx;
			}
		}
		return kInvalidIl2CppMethodSlot;
	}


	bool containeTdt(const std::vector<VTableSetUp*>& trees, VTableSetUp* findTree)
	{
		for (VTableSetUp* add : trees)
		{
			if (il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(add->GetType(), findTree->GetType()))
			{
				return true;
			}
		}
		return false;
	}


	bool FindType(const std::vector<RawInterfaceOffsetInfo>& interfaceOffsetInfos, const Il2CppType* type, uint16_t& resultIdx)
	{
		uint16_t idx = 0;
		for (auto& ioi : interfaceOffsetInfos)
		{
			if (il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(type, ioi.type))
			{
				resultIdx = idx;
				return true;
			}
			++idx;
		}
		resultIdx = (uint16_t)-1;
		return false;
	}

	void VTableSetUp::ComputeInterfaceVtables(Il2CppType2TypeDeclaringTreeMap& cache)
	{
		IL2CPP_ASSERT(hybridclr::metadata::IsInterface(_typeDef->flags));

		if (IsInterType())
		{
			uint16_t slotIdx = 0;
			for (auto& vm : _virtualMethods)
			{
				Il2CppMethodDefinition* methodDef = const_cast<Il2CppMethodDefinition*>(vm.method);
				IL2CPP_ASSERT(methodDef->slot == slotIdx);
				slotIdx++;
			}
		}
	}

	void VTableSetUp::ComputeVtables(Il2CppType2TypeDeclaringTreeMap& cache)
	{
		if (IsInterType())
		{
			ComputeInterpTypeVtables(cache);
		}
		else
		{
			ComputAotTypeVtables(cache);
		}

		uint16_t idx = 0;
		for (auto& vmi : _methodImpls)
		{
			IL2CPP_ASSERT(vmi.slot == idx);
			++idx;
		}
	}

	const Il2CppType* VTableSetUp::FindImplType(const Il2CppMethodDefinition* methodDef)
	{
		Il2CppTypeDefinition* declarType = (Il2CppTypeDefinition*)il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(methodDef->declaringType);
		for (VTableSetUp* cur = this; cur; cur = cur->_parent)
		{
			if (declarType == cur->_typeDef)
			{
				return cur->_type;
			}
			for(VTableSetUp* itf : cur->_interfaces)
			{
				if (declarType == itf->_typeDef)
				{
					return itf->_type;
				}
			}
		}
		TEMP_FORMAT(errMsg, "VTableSetUp::FindImplType can't find impl type for method:%s.%s::%s",
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(declarType->namespaceIndex),
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(declarType->nameIndex),
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex)
			);
		RaiseExecutionEngineException(errMsg);
		return nullptr;
	}

	const VTableSetUp* VTableSetUp::FindAncestorTypeTree(const Il2CppType* implType)
	{
		for (VTableSetUp* cur = this; cur; cur = cur->_parent)
		{
			if (il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(cur->_type, implType))
			{
				return cur;
			}
		}
		return nullptr;
	}

	static void RaiseParentOverridedMethodNotFindException(const Il2CppType* type, const char* methodName)
	{
		if (!type)
		{
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetTypeLoadException("type not exists"));
		}

		const Il2CppTypeDefinition* typeDefinition = GetUnderlyingTypeDefinition(type);

		TEMP_FORMAT(errMsg, "VTableSetUp fail. virtual method: %s::%s::%s can't be find in declaring type or parent. It may be stripped by il2cpp",
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDefinition->namespaceIndex), 
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDefinition->nameIndex),
			methodName);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetMissingMethodException(errMsg));
	}

	const GenericClassMethod* VTableSetUp::FindImplMethod(const Il2CppType* containerType, const Il2CppMethodDefinition* methodDef, bool throwExceptionIfNotFind)
	{
		for (VTableSetUp* curTdt = this; curTdt; curTdt = curTdt->_parent)
		{
			for (int idx = (int)curTdt->_virtualMethods.size() - 1; idx >= 0; idx--)
			{
				GenericClassMethod& pvm = curTdt->_virtualMethods[idx];
				if (hybridclr::metadata::IsOverrideMethod(containerType, methodDef, pvm.type, pvm.method))
				{
					return &pvm;
				}
			}
		}
		if (throwExceptionIfNotFind)
		{
			RaiseParentOverridedMethodNotFindException(this->_type, il2cpp::vm::GlobalMetadata::GetStringFromIndex(methodDef->nameIndex));
		}
		return nullptr;
	}

	void VTableSetUp::ComputAotTypeVtables(Il2CppType2TypeDeclaringTreeMap& cache)
	{
		for (uint16_t i = 0; i < _typeDef->interface_offsets_count; i++)
		{
			Il2CppInterfaceOffsetInfo ioi = il2cpp::vm::GlobalMetadata::GetInterfaceOffsetInfo(_typeDef, i);
			_interfaceOffsetInfos.push_back({ ioi.interfaceType, BuildByType(cache, ioi.interfaceType), (uint16_t)ioi.offset });
		}

		int nullVtableSlotCount = 0;
		for (uint16_t i = 0; i < _typeDef->vtable_count; i++)
		{
			const Il2CppMethodDefinition* overideMethodDef = il2cpp::vm::GlobalMetadata::GetMethodDefinitionFromVTableSlot(_typeDef, i);
			if (overideMethodDef == nullptr)
			{
				if (_parent && i < _parent->_typeDef->vtable_count)
				{
					IL2CPP_ASSERT(_parent->_methodImpls[i].method);
					_methodImpls.push_back(_parent->_methodImpls[i]);
				}
				else
				{
					_methodImpls.push_back({ nullptr, nullptr, i /*, nullptr*/});
					++nullVtableSlotCount;
				}
				continue;
			}
			const Il2CppType* implType = FindImplType(overideMethodDef);
			const char* methodName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(overideMethodDef->nameIndex);
			uint16_t slot = i;
			_methodImpls.push_back({ overideMethodDef, implType, slot /*, methodName*/});
		}

		// il2cpp set vtable slot to nullptr if method is abstract, so we fill correct type and method
		if (nullVtableSlotCount > 0)
		{
			for (GenericClassMethod& gcm : _virtualMethods)
			{
				IL2CPP_ASSERT(gcm.method->slot != kInvalidIl2CppMethodSlot);
				VirtualMethodImpl& vmi = _methodImpls[gcm.method->slot];
				if (vmi.method == nullptr)
				{
					vmi.type = _type;
					vmi.method = gcm.method;
					//vmi.name = gcm.name;
					--nullVtableSlotCount;
				}
			}
			for (VTableSetUp* interf : _interfaces)
			{
				bool findInterf = false;
				for (RawInterfaceOffsetInfo& rioi : _interfaceOffsetInfos)
				{
					if (IsTypeEqual(interf->_type, rioi.type))
					{
						for (size_t i = 0; i < interf->_virtualMethods.size(); i++)
						{
							VirtualMethodImpl& vmi = _methodImpls[rioi.offset + i];
							if (vmi.method == nullptr)
							{
								GenericClassMethod& igcm = interf->_virtualMethods[i];
								const GenericClassMethod* implVirtualMethod = FindImplMethod(interf->_type, igcm.method);
								IL2CPP_ASSERT(implVirtualMethod);
								//vmi.name = igcm.name;
								vmi.type = implVirtualMethod->type;
								vmi.method = implVirtualMethod->method;
								--nullVtableSlotCount;
							}
						}
						findInterf = true;
						break;
					}
				}
				IL2CPP_ASSERT(findInterf);
			}
			IL2CPP_ASSERT(nullVtableSlotCount == 0);
		}

		IL2CPP_ASSERT(_typeDef->vtable_count == (uint16_t)_methodImpls.size());
	}

	void VTableSetUp::ApplyOverrideMethod(const GenericClassMethod* overrideParentMethod, const Il2CppMethodDefinition* overrideMethodDef, uint16_t checkOverrideMaxIdx)
	{
		IL2CPP_ASSERT(overrideParentMethod);
		if (overrideParentMethod)
		{
			IL2CPP_ASSERT(overrideParentMethod->method->slot != kInvalidIl2CppMethodSlot);
			//const_cast<Il2CppMethodDefinition*>(vm.method)->slot = overrideParentMethod->method->slot;
			uint16_t slotIdx = overrideParentMethod->method->slot;
			const Il2CppMethodDefinition* overrideAncestorMethod = _parent->_methodImpls[slotIdx].method;
			IL2CPP_ASSERT(overrideAncestorMethod);

			VirtualMethodImpl& curImpl = _methodImpls[slotIdx];
			curImpl.type = _type;
			curImpl.method = overrideMethodDef;
			// search hierarchy methods, find match method. 

			// check override parent virtual methods and
			for (uint16_t idx = 0; idx < checkOverrideMaxIdx; idx++)
			{
				VirtualMethodImpl& vmi = _methodImpls[idx];
				if (vmi.method == overrideAncestorMethod)
				{
					vmi.type = _type;
					vmi.method = overrideMethodDef;
				}
			}
		}
	}

	uint16_t VTableSetUp::FindDefaultOverrideExplicitInterfaceSlot(GenericClassMethod& gcm, const Uin16Set& explicitImplSlots, const std::vector<uint16_t>& implInterfaceOffsetIdxs)
	{
		uint16_t slot = kInvalidIl2CppMethodSlot;
		for (uint16_t interfaceIdx : implInterfaceOffsetIdxs)
		{
			RawInterfaceOffsetInfo& rioi = _interfaceOffsetInfos[interfaceIdx];
			for (uint16_t idx = rioi.offset, end = rioi.offset + (uint16_t)rioi.tree->_virtualMethods.size(); idx < end; idx++)
			{
				if (explicitImplSlots.find(idx) != explicitImplSlots.end())
				{
					continue;
				}
				VirtualMethodImpl& vmi = _methodImpls[idx];
				if (IsOverrideMethod(_type, gcm.method, vmi.type, vmi.method))
				{
					//IL2CPP_ASSERT(impl.body.methodDef->slot == kInvalidIl2CppMethodSlot);
					vmi.type = _type;
					vmi.method = gcm.method;
					slot = idx;
				}
			}
		}
		return slot;
	}

	uint16_t VTableSetUp::FindExplicitOverrideInterfaceSlot(GenericClassMethod& gcm, const Int32ToUin16Map& explicitImplSlots)
	{
		auto it = explicitImplSlots.find(gcm.method->token);
		return it != explicitImplSlots.end() ? it->second : kInvalidIl2CppMethodSlot;
	}

	void VTableSetUp::InitInterfaceVTable(uint16_t& curOffset, std::vector<uint16_t>& implInterfaceOffsetIdxs)
	{
		for (VTableSetUp* intTree : _interfaces)
		{
			const Il2CppType* intType = intTree->_type;
			uint16_t overrideIntIdx;
			if (!FindType(_parent->_interfaceOffsetInfos, intType, overrideIntIdx))
			{
				implInterfaceOffsetIdxs.push_back((uint16_t)_interfaceOffsetInfos.size());
				_interfaceOffsetInfos.push_back({ intType, intTree, curOffset });
				// curOffset += (uint32_t)intTree->_virtualMethods.size();
				for (auto& vm : intTree->_virtualMethods)
				{
					_methodImpls.push_back({ vm.method, intType, curOffset++ /*, vm.name*/});
				}
			}
			else
			{
				implInterfaceOffsetIdxs.push_back(overrideIntIdx);
			}
		}
	}

	static bool IsExpliciteMethodNameMatch(const char* implMethodName, const Il2CppType* targetDeclaringType, const char* targetMethodName)
	{
		// end with .<methodName>
		std::string fullName;
		const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(targetDeclaringType);
		if (typeDef->namespaceIndex != kStringLiteralIndexInvalid)
		{
			fullName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->namespaceIndex);
			fullName += ".";
		}
		const char* typeName = il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDef->nameIndex);
		const char* genericQualifier = strchr(typeName, '`');
		if (genericQualifier)
		{
			fullName.append(typeName, genericQualifier);
		}
		else
		{
			fullName += typeName;
		}

		if (!std::strstr(implMethodName, fullName.c_str()))
		{
			return false;
		}
		
		size_t len1 = std::strlen(implMethodName);
		size_t len2 = std::strlen(targetMethodName);
		if (len1 < len2 + 1)
		{
			return false;
		}
		if (implMethodName[len1 - len2 - 1] != '.')
		{
			return false;
		}
		return strcmp(implMethodName + len1 - len2, targetMethodName) == 0;
	}

	void VTableSetUp::ApplyAOTInterfaceExplicitOverride(const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots,
		const Il2CppType* intfType, const Il2CppType* implType, const Il2CppMethodDefinition* implMethod)
	{
		const char* name1 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(implMethod->nameIndex);
		for (uint16_t interfaceIdx : implInterfaceOffsetIdxs)
		{
			RawInterfaceOffsetInfo& rioi = _interfaceOffsetInfos[interfaceIdx];
			if (!il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(rioi.type, intfType))
			{
				continue;
			}

			for (uint16_t idx = 0, end = (uint16_t)rioi.tree->_virtualMethods.size(); idx < end; idx++)
			{
				GenericClassMethod& rvm = rioi.tree->_virtualMethods[idx];
				const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(rvm.method->nameIndex);
				if (!IsExpliciteMethodNameMatch(name1, intfType, name2))
				{
					continue;
				}
				if (IsOverrideMethodIgnoreName(implType, implMethod, rvm.type, rvm.method))
				{
					uint16_t slot = (uint16_t)(idx + rioi.offset);
					VirtualMethodImpl& ivmi = _methodImpls[slot];
					_explicitImplSlots.insert(slot);
					explicitImplToken2Slots.insert({ implMethod->token, slot });
					ivmi.type = implType;
					ivmi.method = implMethod;
					//ivmi.name = name1;
					return;
				}
			}
		}
	}

	void VTableSetUp::ApplyExplicitOverride(const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots,
		const Il2CppType* declaringType, const Il2CppMethodDefinition* decalringMethod, const Il2CppType* implType, const Il2CppMethodDefinition* implMethod)
	{
		const char* name1 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(decalringMethod->nameIndex);
		for (uint16_t interfaceIdx : implInterfaceOffsetIdxs)
		{
			RawInterfaceOffsetInfo& rioi = _interfaceOffsetInfos[interfaceIdx];
			if (!il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(rioi.type, declaringType))
			{
				continue;
			}

			for (uint16_t idx = 0, end = (uint16_t)rioi.tree->_virtualMethods.size(); idx < end; idx++)
			{
				GenericClassMethod& rvm = rioi.tree->_virtualMethods[idx];
				const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(rvm.method->nameIndex);
				if (std::strcmp(name1, name2))
				{
					continue;
				}
				if (IsOverrideMethodIgnoreName(declaringType, decalringMethod, rvm.type, rvm.method))
				{
					uint16_t slot = (uint16_t)(idx + rioi.offset);
					VirtualMethodImpl& ivmi = _methodImpls[slot];
					_explicitImplSlots.insert(slot);
					explicitImplToken2Slots.insert({ implMethod->token, slot});
					ivmi.type = implType;
					ivmi.method = implMethod;
					//ivmi.name = il2cpp::vm::GlobalMetadata::GetStringFromIndex(implMethod->nameIndex);
					return;
				}
			}
		}
		const VTableSetUp* containerTs = FindAncestorTypeTree(declaringType);
		if (containerTs)
		{
			for (int idx = (int)containerTs->_virtualMethods.size() - 1; idx >= 0; idx--)
			{
				const GenericClassMethod& rvm = containerTs->_virtualMethods[idx];
				const char* name2 = il2cpp::vm::GlobalMetadata::GetStringFromIndex(rvm.method->nameIndex);
				if (std::strcmp(name1, name2) != 0)
				{
					continue;
				}
				if (IsOverrideMethodIgnoreName(declaringType, decalringMethod, rvm.type, rvm.method))
				{
					VirtualMethodImpl& ivmi = _methodImpls[rvm.method->slot];
					_explicitImplSlots.insert(rvm.method->slot);
					explicitImplToken2Slots.insert({ implMethod->token, rvm.method->slot });
					ivmi.type = implType;
					ivmi.method = implMethod;
					//ivmi.name = il2cpp::vm::GlobalMetadata::GetStringFromIndex(implMethod->nameIndex);
					return;
				}
			}
		}
		const Il2CppTypeDefinition* typeDefinition = GetUnderlyingTypeDefinition(declaringType);

		TEMP_FORMAT(errMsg, "VTableSetUp fail. explicit implemented method: %s::%s::%s can't be find in parent or any interface.",
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDefinition->namespaceIndex),
			il2cpp::vm::GlobalMetadata::GetStringFromIndex(typeDefinition->nameIndex),
			name1);
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(errMsg));
	}

	void VTableSetUp::ApplyTypeExplicitImpls(const Il2CppType* type, const VTableSetUp* tree, const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots)
	{
		const Il2CppTypeDefinition* typeDef = GetUnderlyingTypeDefinition(type);
		if (IsInterpreterType(typeDef))
		{
			const il2cpp::utils::dynamic_array<MethodImpl> explicitImpls = MetadataModule::GetImage(typeDef)->GetTypeMethodImplByTypeDefinition(typeDef);
			if (type->type != IL2CPP_TYPE_GENERICINST)
			{
				for (const MethodImpl& mi : explicitImpls)
				{
					ApplyExplicitOverride(implInterfaceOffsetIdxs, explicitImplToken2Slots, mi.declaration.containerType,
						mi.declaration.methodDef, mi.body.containerType, mi.body.methodDef);
				}
			}
			else
			{
				const Il2CppGenericClass* genericClass = type->data.generic_class;
				for (const MethodImpl& mi : explicitImpls)
				{
					const Il2CppType* containerType = il2cpp::metadata::GenericMetadata::InflateIfNeeded(mi.declaration.containerType, &genericClass->context, true);
					const Il2CppType* implType = TryInflateIfNeed(type, type->data.generic_class->type, mi.body.containerType);
					ApplyExplicitOverride(implInterfaceOffsetIdxs, explicitImplToken2Slots, containerType,
						mi.declaration.methodDef, implType, mi.body.methodDef);
				}
			}
		}
		else if (IsInterface(typeDef->flags))
		{
			// we only need process explicit impls in interface.
			// il2cpp doesn't provider any ways to get explicit impls in class.
			// so we can only try to find explicit impls by name matching.
			for (const GenericClassMethod& gcm : tree->_virtualMethods)
			{
				// only try to find explicit impls in private methods
				uint32_t flags = gcm.method->flags;
				if (!IsPrivateMethod(flags) || IsAbstractMethod(flags))
				{
					continue;
				}
				for (VTableSetUp* subIntf : tree->_interfaces)
				{
					ApplyAOTInterfaceExplicitOverride(implInterfaceOffsetIdxs, explicitImplToken2Slots, subIntf->_type,	tree->_type, gcm.method);
				}
			}
		}
	}

	void VTableSetUp::ComputeExplicitImpls(const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots)
	{
		ApplyTypeExplicitImpls(_type, this, implInterfaceOffsetIdxs, explicitImplToken2Slots);
		
		for (uint16_t interfaceIdx : implInterfaceOffsetIdxs)
		{
			RawInterfaceOffsetInfo& rioi = _interfaceOffsetInfos[interfaceIdx];
			ApplyTypeExplicitImpls(rioi.type, rioi.tree, implInterfaceOffsetIdxs, explicitImplToken2Slots);
		}
	}

	void VTableSetUp::ComputeOverrideParentVirtualMethod(uint16_t& curOffset, const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots)
	{
		const uint16_t startOffset = curOffset;
		// override parent virtual methods and interfaces
		for (auto& vm : _virtualMethods)
		{
			IL2CPP_ASSERT(vm.type == _type);
			uint16_t mflags = vm.method->flags;
			if (hybridclr::metadata::IsNewSlot(mflags))
			{
				uint16_t overrideSlotIdx = kInvalidIl2CppMethodSlot;
				if (IsSealed(mflags))
				{
					overrideSlotIdx = FindExplicitOverrideInterfaceSlot(vm, explicitImplToken2Slots);
					if (overrideSlotIdx == kInvalidIl2CppMethodSlot && IsPublicMethod(mflags))
					{
						overrideSlotIdx = FindDefaultOverrideExplicitInterfaceSlot(vm, _explicitImplSlots, implInterfaceOffsetIdxs);
					}
				}
				if (overrideSlotIdx != kInvalidIl2CppMethodSlot)
				{
					const_cast<Il2CppMethodDefinition*>(vm.method)->slot = overrideSlotIdx;
				}
				else
				{
					_methodImpls.push_back({ vm.method, _type, curOffset /*, vm.name*/});
					IL2CPP_ASSERT(vm.method->slot == kInvalidIl2CppMethodSlot || vm.method->slot == curOffset);
					const_cast<Il2CppMethodDefinition*>(vm.method)->slot = curOffset;
					++curOffset;
				}
			}
			else
			{
				// It's impossible to define private virtual method in c#，but it's possible in cli.
				// so sometime can't find override in parent
				const GenericClassMethod* overrideParentMethod = _parent->FindImplMethod(_type, vm.method, false);
				if (overrideParentMethod)
				{
					IL2CPP_ASSERT(overrideParentMethod->method->slot != kInvalidIl2CppMethodSlot);
					const_cast<Il2CppMethodDefinition*>(vm.method)->slot = overrideParentMethod->method->slot;
					ApplyOverrideMethod(overrideParentMethod, vm.method, startOffset);
				}
				else
				{
					IL2CPP_ASSERT(metadata::IsPrivateMethod(mflags));
					_methodImpls.push_back({ vm.method, _type, curOffset /*, vm.name*/});
					IL2CPP_ASSERT(vm.method->slot == kInvalidIl2CppMethodSlot || vm.method->slot == curOffset);
					const_cast<Il2CppMethodDefinition*>(vm.method)->slot = curOffset;
					++curOffset;
				}
			}
		}
	}

	void VTableSetUp::ComputeInterfaceOverrideByParentVirtualMethod(const std::vector<uint16_t>& implInterfaceOffsetIdxs)
	{
		for (uint16_t interfaceIdx : implInterfaceOffsetIdxs)
		{
			RawInterfaceOffsetInfo& rioi = _interfaceOffsetInfos[interfaceIdx];
			auto& interfaceVirtualMethods = rioi.tree->_virtualMethods;
			for (uint16_t idx = 0, end = (uint16_t)interfaceVirtualMethods.size(); idx < end; idx++)
			{
				uint16_t slotIdx = (uint16_t)(rioi.offset + idx);
				if (isExplicitImplInterfaceSlot(slotIdx))
				{
					continue;
				}
				VirtualMethodImpl& vmi = _methodImpls[slotIdx];
				// override by virtual method
				const GenericClassMethod* implVm = FindImplMethod(rioi.type, interfaceVirtualMethods[idx].method, false);
				if (implVm)
				{
					vmi.type = implVm->type;
					vmi.method = implVm->method;
					//vmi.name = implVm->name;
				}
			}
		}
	}

	void VTableSetUp::ComputeInterpTypeVtables(Il2CppType2TypeDeclaringTreeMap& cache)
	{
		uint16_t curOffset = 0;
		if (_parent)
		{
			curOffset = (uint16_t)_parent->_methodImpls.size();
			_methodImpls = _parent->_methodImpls;
			_interfaceOffsetInfos = _parent->_interfaceOffsetInfos;
		}

		std::vector<uint16_t> implInterfaceOffsetIdxs;
		InitInterfaceVTable(curOffset, implInterfaceOffsetIdxs);
		Int32ToUin16Map explicitImplToken2Slots;
		ComputeExplicitImpls(implInterfaceOffsetIdxs, explicitImplToken2Slots);
		ComputeOverrideParentVirtualMethod(curOffset, implInterfaceOffsetIdxs, explicitImplToken2Slots);
		ComputeInterfaceOverrideByParentVirtualMethod(implInterfaceOffsetIdxs);
	}

}
}

```

`hybridclr/metadata/VTableSetup.h`:

```h
#pragma once

#include <vector>

#include "metadata/Il2CppTypeHash.h"
#include "metadata/Il2CppTypeCompare.h"

#include "../CommonDef.h"
#include "MetadataUtil.h"

namespace hybridclr
{
namespace metadata
{
	struct GenericClassMethod
	{
		const Il2CppType* type;
		const Il2CppMethodDefinition* method;
		const char* name; // TODO remove
	};

	struct VirtualMethodImpl
	{
		const Il2CppMethodDefinition* method;
		const Il2CppType* type;
		uint16_t slot;
		//const char* name; //  TODO for debug
	};

	class VTableSetUp;

	struct RawInterfaceOffsetInfo
	{
		const Il2CppType* type;
		VTableSetUp* tree;
		uint32_t offset;
	};

	typedef Il2CppHashMap<const Il2CppType*, VTableSetUp*, il2cpp::metadata::Il2CppTypeHash, il2cpp::metadata::Il2CppTypeEqualityComparer> Il2CppType2TypeDeclaringTreeMap;

	class VTableSetUp
	{
	public:
		typedef Il2CppHashMap<int32_t, uint16_t, il2cpp::utils::PassThroughHash<int32_t>> Int32ToUin16Map;
		typedef Il2CppHashSet<uint16_t, il2cpp::utils::PassThroughHash<uint16_t>> Uin16Set;

		static VTableSetUp* BuildByType(Il2CppType2TypeDeclaringTreeMap& cache, const Il2CppType* type);
		static VTableSetUp* InflateVts(Il2CppType2TypeDeclaringTreeMap& cache, VTableSetUp* genericType, const Il2CppType* type);

		VTableSetUp()
		{

		}

		const VTableSetUp* GetParent() const { return _parent; }
		const Il2CppType* FindImplType(const Il2CppMethodDefinition* methodDef);
		const VTableSetUp* FindAncestorTypeTree(const Il2CppType* implType);
		const GenericClassMethod* FindImplMethod(const Il2CppType* containerType, const Il2CppMethodDefinition* methodDef, bool throwExceptionIfNotFind = true);
		const std::vector<RawInterfaceOffsetInfo>& GetInterfaceOffsetInfos() const { return _interfaceOffsetInfos; }
		const std::vector<VirtualMethodImpl>& GetVirtualMethodImpls() const { return _methodImpls; }
		const Il2CppType* GetType() const { return _type; }
		uint32_t GetTypeIndex() const { return _typeDef->byvalTypeIndex; }
		bool IsInterType() const { return hybridclr::metadata::IsInterpreterType(_typeDef); }
	private:

		void ComputeVtables(Il2CppType2TypeDeclaringTreeMap& cache);
		void ComputAotTypeVtables(Il2CppType2TypeDeclaringTreeMap& cache);
		void InitInterfaceVTable(uint16_t& curOffset, std::vector<uint16_t>& implInterfaceOffsetIdxs);
		void ComputeExplicitImpls(const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots);
		void ApplyTypeExplicitImpls(const Il2CppType* type, const VTableSetUp* tree, const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots);
		void ComputeOverrideParentVirtualMethod(uint16_t& curOffset, const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots);
		void ComputeInterfaceOverrideByParentVirtualMethod(const std::vector<uint16_t>& implInterfaceOffsetIdxs);
		void ComputeInterpTypeVtables(Il2CppType2TypeDeclaringTreeMap& cache);
		void ComputeInterfaceVtables(Il2CppType2TypeDeclaringTreeMap& cache);

		bool isExplicitImplInterfaceSlot(uint16_t slot) const { return _explicitImplSlots.find(slot) != _explicitImplSlots.end(); }
		uint16_t FindDefaultOverrideExplicitInterfaceSlot(GenericClassMethod& gcm, const Uin16Set& explicitImplSlots, const std::vector<uint16_t>& implInterfaceOffsetIdxs);
		uint16_t FindExplicitOverrideInterfaceSlot(GenericClassMethod& gcm, const Int32ToUin16Map& explicitImplSlots);
		void ApplyOverrideMethod(const GenericClassMethod* beOverrideParentMethod, const Il2CppMethodDefinition* overrideMethodDef, uint16_t checkOverrideMaxIdx);
		void ApplyExplicitOverride(const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots, const Il2CppType* declaringType,
			const Il2CppMethodDefinition* decalringMethod, const Il2CppType* implType, const Il2CppMethodDefinition* implMethod);
		void ApplyAOTInterfaceExplicitOverride(const std::vector<uint16_t>& implInterfaceOffsetIdxs, Int32ToUin16Map& explicitImplToken2Slots, const Il2CppType* intfType,
			const Il2CppType* implType, const Il2CppMethodDefinition* implMethod);
		
		VTableSetUp* _parent;
		std::vector<VTableSetUp*> _interfaces;
		std::vector<RawInterfaceOffsetInfo> _interfaceOffsetInfos;

		const Il2CppType* _type;
		const Il2CppTypeDefinition* _typeDef;
		const char* _name; // TODO remove

		std::vector<GenericClassMethod> _virtualMethods;
		std::vector<VirtualMethodImpl> _methodImpls;

		Uin16Set _explicitImplSlots;;
	};
}
}

```

`hybridclr/transform/BasicBlockSpliter.cpp`:

```cpp
#include "BasicBlockSpliter.h"

#include "../metadata/Opcodes.h"
#include "../metadata/MetadataUtil.h"

using namespace hybridclr::metadata;

namespace hybridclr
{
namespace transform
{

	void BasicBlockSpliter::SplitNormal(const byte* ilcodeStart, uint32_t codeSize, Uin32Set& ilOffsets)
	{
		const byte* codeEnd = ilcodeStart + codeSize;
		const byte* ip = ilcodeStart;

		while (ip < codeEnd)
		{
			ilOffsets.insert((uint32_t)(ip - ilcodeStart));
			const OpCodeInfo* oc = DecodeOpCodeInfo(ip, codeEnd);
			IL2CPP_ASSERT(oc);
			int32_t opCodeSize = GetOpCodeSize(ip, oc);
			const byte* nextIp = ip + opCodeSize;
			int32_t nextOffset = (int32_t)(nextIp - ilcodeStart);
			IL2CPP_ASSERT(nextOffset >= 0 && nextOffset <= (int32_t)codeSize);

			switch (oc->inlineType)
			{
			case ArgType::None:
			case ArgType::Data:
			{
				break;
			}
			case ArgType::StaticBranch:
			{
				_splitOffsets.insert(nextOffset);
				break;
			}
			case ArgType::BranchTarget:
			{
				int32_t offset;
				switch (oc->inlineParam)
				{
				case 1:
				{
					offset = GetI1(ip + 1);
					break;
				}
				case 4:
				{
					offset = GetI4LittleEndian(ip + 1);
					break;
				}
				default:
				{
					RaiseExecutionEngineException("invalid BranchTarget param");
					offset = -1;
				}
				}
				// don't split 0 offset br
				if (offset != 0 || (oc->baseOpValue == OpcodeValue::LEAVE || oc->baseOpValue == OpcodeValue::LEAVE_S))
				{
					_splitOffsets.insert(nextOffset);
					_splitOffsets.insert(nextOffset + offset);
				}
				break;
			}
			case ArgType::Switch:
			{
				uint32_t caseNum = GetI4LittleEndian(ip + 1);
				bool splitAny = false;
				for (uint32_t caseIdx = 0; caseIdx < caseNum; caseIdx++)
				{
					int32_t caseOffset = GetI4LittleEndian(ip + 5 + caseIdx * 4);
					if (caseOffset != 0)
					{
						_splitOffsets.insert(nextOffset + caseOffset);
						splitAny = true;
					}
				}
				if (splitAny)
				{
					_splitOffsets.insert(nextOffset);
				}
				break;
			}
			default:
			{
				RaiseExecutionEngineException("unknown inline type");
				nextOffset = -1;
			}
			}
			ip = nextIp;
		}
		IL2CPP_ASSERT(ip == codeEnd);
	}

	void BasicBlockSpliter::SplitExceptionHandles(const byte* ilcodeStart, uint32_t codeSize, const std::vector<metadata::ExceptionClause>& exceptionClauses)
	{
		for (auto& eh : exceptionClauses)
		{
			_splitOffsets.insert(eh.tryOffset);
			_splitOffsets.insert(eh.tryOffset + eh.tryLength);
			_splitOffsets.insert(eh.handlerOffsets);
			_splitOffsets.insert(eh.handlerOffsets + eh.handlerLength);
			if (eh.flags == CorILExceptionClauseType::Filter)
			{
				_splitOffsets.insert(eh.classTokenOrFilterOffset);
			}
		}
	}

	void BasicBlockSpliter::SplitBasicBlocks()
	{
		const byte* ilcodeStart = _body.ilcodes;

		uint32_t codeSize = _body.codeSize;

		Uin32Set ilOffsets(codeSize);
		ilOffsets.insert(codeSize);

		SplitNormal(ilcodeStart, codeSize, ilOffsets);
		SplitExceptionHandles(ilcodeStart, codeSize, _body.exceptionClauses);

		/*if (_splitOffsets.find(0) != _splitOffsets.end())
		{
			_splitOffsets.erase(0);
		}*/
#if DEBUG
		for (uint32_t offset : _splitOffsets)
		{
			IL2CPP_ASSERT(ilOffsets.find(offset) != ilOffsets.end());
		}
		IL2CPP_ASSERT(_splitOffsets.find(codeSize) != _splitOffsets.end());
#endif
	}
}
}
```

`hybridclr/transform/BasicBlockSpliter.h`:

```h
#pragma once

#include <set>

#include "../CommonDef.h"
#include "../metadata/MetadataDef.h"

namespace hybridclr
{
namespace transform
{
	class BasicBlockSpliter
	{
	public:
		typedef Il2CppHashSet<uint32_t, il2cpp::utils::PassThroughHash<uint32_t>> Uin32Set;

		BasicBlockSpliter(const metadata::MethodBody& body) : _body(body) { }

		void SplitBasicBlocks();

		const std::set<uint32_t>& GetSplitOffsets() const { return _splitOffsets; }
	private:
		const metadata::MethodBody& _body;
		std::set<uint32_t> _splitOffsets;

		void SplitNormal(const byte* ilcodeStart, uint32_t codeSize, Uin32Set& ilOffsets);
		void SplitExceptionHandles(const byte* ilcodeStart, uint32_t codeSize, const std::vector<metadata::ExceptionClause>& exceptionClauses);
	};
}
}

```

`hybridclr/transform/TemporaryMemoryArena.cpp`:

```cpp
#include "TemporaryMemoryArena.h"

namespace hybridclr
{
namespace transform
{

	TemporaryMemoryArena::Block TemporaryMemoryArena::AllocBlock(size_t size)
	{
		void* data = HYBRIDCLR_MALLOC(size);
		return { data, size };
	}

	void TemporaryMemoryArena::Begin()
	{
		IL2CPP_ASSERT(_buf == nullptr);
		IL2CPP_ASSERT(_size == 0);
		IL2CPP_ASSERT(_pos == 0);
		RequireSize(kMinBlockSize);
	}

	void TemporaryMemoryArena::End()
	{
		if (_buf)
		{
			HYBRIDCLR_FREE(_buf);
			//_buf = nullptr;
			//_size = _pos = 0;
		}
		for (auto& block : _useOuts)
		{
			HYBRIDCLR_FREE(block.data);
		}
	}
}
}
```

`hybridclr/transform/TemporaryMemoryArena.h`:

```h
#pragma once

#include <stack>
#include <cmath>
#include <vector>

#include "../CommonDef.h"

namespace hybridclr
{
	namespace transform
	{
		const size_t kMinBlockSize = 8 * 1024;

		class TemporaryMemoryArena
		{
		public:

			TemporaryMemoryArena() : _buf(nullptr), _size(0), _pos(0)
			{
				Begin();
			}
			~TemporaryMemoryArena()
			{
				End();
			}

			static size_t AligndSize(size_t size)
			{
				return (size + 7) & ~7;
			}

			template<typename T>
			T* AllocIR()
			{
				const size_t aligndSize = AligndSize(sizeof(T));
				if (_pos + aligndSize <= _size)
				{
					T* ir = (T*)(_buf + _pos);
					*ir = {};
					_pos += aligndSize;
					return ir;
				}

				RequireSize(aligndSize);

				T* ir = (T*)(_buf + _pos);
				*ir = {};
				_pos += aligndSize;
				return ir;
			}

			template<typename T>
			T* NewAny()
			{
				const size_t needSize = AligndSize(sizeof(T));
				if (_pos + needSize <= _size)
				{
					T* ir = new (_buf + _pos) T();
					*ir = {};
					_pos += needSize;
					return ir;
				}

				RequireSize(needSize);

				T* ir = new (_buf + _pos) T();
				*ir = {};
				_pos += needSize;
				return ir;
			}

			template<typename T>
			T* NewNAny(int n)
			{
				if (n > 0)
				{
					size_t bytes = AligndSize(sizeof(T) * n);
					if (_pos + bytes > _size)
					{
						RequireSize(bytes);
					}
					T* ret = new (_buf + _pos) T[n];
					_pos += bytes;
					return ret;
				}
				else
				{
					return nullptr;
				}
			}

			void Begin();

			void End();

		private:
			struct Block
			{
				void* data;
				size_t size;
			};

			void RequireSize(size_t size)
			{
				if (_buf)
				{
					_useOuts.push_back({ (void*)_buf, _size});
				}

				Block newBlock = AllocBlock(std::max(size, kMinBlockSize));
				_buf = (byte*)newBlock.data;
				_size = newBlock.size;
				_pos = 0;
			}

			static Block AllocBlock(size_t size);

			std::vector<Block> _useOuts;

			byte* _buf;
			size_t _size;
			size_t _pos;
		};
	}
}
```

`hybridclr/transform/Transform.cpp`:

```cpp

#include "Transform.h"

#include <unordered_set>

#include "TransformContext.h"

#include "../metadata/MethodBodyCache.h"

namespace hybridclr
{
namespace transform
{

	InterpMethodInfo* HiTransform::Transform(const MethodInfo* methodInfo)
	{
		TemporaryMemoryArena pool;

		metadata::Image* image = metadata::MetadataModule::GetUnderlyingInterpreterImage(methodInfo);
		IL2CPP_ASSERT(image);

		metadata::MethodBodyCache::EnableShrinkMethodBodyCache(false);
		metadata::MethodBody* methodBody = metadata::MethodBodyCache::GetMethodBody(image, methodInfo->token);
		if (methodBody == nullptr || methodBody->ilcodes == nullptr)
		{
			TEMP_FORMAT(errMsg, "Method body is null. %s.%s::%s", methodInfo->klass->namespaze, methodInfo->klass->name, methodInfo->name);
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(errMsg));
		}
		InterpMethodInfo* result = new (HYBRIDCLR_METADATA_MALLOC(sizeof(InterpMethodInfo))) InterpMethodInfo;
		il2cpp::utils::dynamic_array<uint64_t> resolveDatas;
		TransformContext ctx(image, methodInfo, *methodBody, pool, resolveDatas);

		ctx.TransformBody(0, 0, *result);
		metadata::MethodBodyCache::EnableShrinkMethodBodyCache(true);
		return result;
	}
}

}

```

`hybridclr/transform/Transform.h`:

```h
#pragma once

#include "BasicBlockSpliter.h"

#include "../metadata/Image.h"
#include "../interpreter/Instruction.h"
#include "../interpreter/Engine.h"
#include "../interpreter/InterpreterDefs.h"

namespace hybridclr
{
namespace transform
{
	class HiTransform
	{
	public:
		static interpreter::InterpMethodInfo* Transform(const MethodInfo* methodInfo);
	};
}
}
```

`hybridclr/transform/TransformContext.cpp`:

```cpp
#include "TransformContext.h"

#include "metadata/GenericMetadata.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/String.h"
#include "vm/Field.h"
#include "vm/PlatformInvoke.h"
#include "vm/Reflection.h"
#include "vm/Image.h"
#include "vm/Type.h"
#include "vm/GenericClass.h"
#include "utils/StringUtils.h"
#include "utils/StringView.h"

#include "../metadata/MethodBodyCache.h"
#include "../interpreter/InterpreterUtil.h"

namespace hybridclr
{
namespace transform
{
	constexpr int32_t MAX_STACK_SIZE = (2 << 16) - 1;
	constexpr int32_t MAX_VALUE_TYPE_SIZE = (2 << 16) - 1;

	template<typename T>
	void AllocResolvedData(il2cpp::utils::dynamic_array<uint64_t>& resolvedDatas, int32_t size, int32_t& index, T*& buf)
	{
		if (size > 0)
		{
			int32_t oldSize = index = (int32_t)resolvedDatas.size();
			resolvedDatas.resize_initialized(oldSize + size);
			buf = (T*)&resolvedDatas[oldSize];
		}
		else
		{
			index = 0;
			buf = nullptr;
		}
	}

	IRCommon* CreateInitLocals(TemporaryMemoryArena& pool, uint32_t size, int32_t offset)
	{
		if (size > 32)
		{
			if (offset == 0)
			{
				CreateIR(ir, InitLocals_n_4);
				ir->size = size;
				return ir;
			}
			else
			{
				CreateIR(ir, InitInlineLocals_n_4);
				ir->size = size;
				ir->offset = offset;
				return ir;
			}
		}
		if (offset == 0)
		{
			CreateIR(ir, InitLocals_size_8);
			if (size <= 8)
			{
			}
			else if (size <= 16)
			{
				ir->type = HiOpcodeEnum::InitLocals_size_16;
			}
			else if (size <= 24)
			{
				ir->type = HiOpcodeEnum::InitLocals_size_24;
			}
			else
			{
				IL2CPP_ASSERT(size <= 32);
				ir->type = HiOpcodeEnum::InitLocals_size_32;
			}
			return ir;
		}
		else
		{

			CreateIR(ir, InitInlineLocals_size_8);
			ir->offset = offset;
			if (size <= 8)
			{

			}
			else if (size <= 16)
			{
				ir->type = HiOpcodeEnum::InitInlineLocals_size_16;
			}
			else if (size <= 24)
			{
				ir->type = HiOpcodeEnum::InitInlineLocals_size_24;
			}
			else
			{
				IL2CPP_ASSERT(size <= 32);
				ir->type = HiOpcodeEnum::InitInlineLocals_size_32;
			}
			return ir;
		}
	}

	IRCommon* CreateLoadExpandDataToStackVarVar(TemporaryMemoryArena& pool, int32_t dstOffset, int32_t srcOffset, const Il2CppType* type, int32_t size);
	IRCommon* CreateAssignVarVar(TemporaryMemoryArena& pool, int32_t dstOffset, int32_t srcOffset, int32_t size);

	interpreter::IRCommon* CreateClassLdfld(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, const FieldInfo* fieldInfo);

	interpreter::IRCommon* CreateValueTypeLdfld(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, const FieldInfo* fieldInfo);
	interpreter::IRCommon* CreateStfld(TemporaryMemoryArena& pool, int32_t objIdx, const FieldInfo* fieldInfo, int32_t dataIdx);

	interpreter::IRCommon* CreateLdsfld(TemporaryMemoryArena& pool, int32_t dstIdx, const FieldInfo* fieldInfo, uint32_t parent);
	interpreter::IRCommon* CreateStsfld(TemporaryMemoryArena& pool, const FieldInfo* fieldInfo, uint32_t parent, int32_t dataIdx);
	interpreter::IRCommon* CreateLdthreadlocal(TemporaryMemoryArena& pool, int32_t dstIdx, const FieldInfo* fieldInfo, uint32_t parent);
	interpreter::IRCommon* CreateStthreadlocal(TemporaryMemoryArena& pool, const FieldInfo* fieldInfo, uint32_t parent, int32_t dataIdx);

	EvalStackReduceDataType GetEvalStackReduceDataType(const Il2CppType* type)
	{
		if (type->byref)
		{
			return NATIVE_INT_REDUCE_TYPE;
		}
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
			return EvalStackReduceDataType::I4;
		case IL2CPP_TYPE_R4:
			return EvalStackReduceDataType::R4;

		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
			return EvalStackReduceDataType::I8;
		case IL2CPP_TYPE_R8:
			return EvalStackReduceDataType::R8;
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_FNPTR:
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_BYREF:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_CLASS:
		case IL2CPP_TYPE_ARRAY:
		case IL2CPP_TYPE_SZARRAY:
		case IL2CPP_TYPE_OBJECT:
			return NATIVE_INT_REDUCE_TYPE;
		case IL2CPP_TYPE_TYPEDBYREF:
			return EvalStackReduceDataType::Other;
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			return klass->enumtype ? GetEvalStackReduceDataType(&klass->element_class->byval_arg) : EvalStackReduceDataType::Other;
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* genericClass = type->data.generic_class;
			if (genericClass->type->type == IL2CPP_TYPE_CLASS)
			{
				return NATIVE_INT_REDUCE_TYPE;
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
				return klass->enumtype ? GetEvalStackReduceDataType(&klass->element_class->byval_arg) : EvalStackReduceDataType::Other;
			}
		}
		default:
		{
			RaiseExecutionEngineException("GetEvalStackReduceDataType invalid type");
			return EvalStackReduceDataType::Other;
		}
		}
	}

	int32_t GetSizeByReduceType(EvalStackReduceDataType type)
	{
		switch (type)
		{
		case hybridclr::transform::EvalStackReduceDataType::I4:
		case hybridclr::transform::EvalStackReduceDataType::R4:
			return 4;
		case hybridclr::transform::EvalStackReduceDataType::I8:
		case hybridclr::transform::EvalStackReduceDataType::R8:
			return 8;
		default:
		{
			RaiseExecutionEngineException("GetSizeByReduceType not support type");
			return PTR_SIZE;
		}
		}
	}

	LocationDescInfo ComputValueTypeDescInfo(int32_t size, bool hasReference)
	{
#if HYBRIDCLR_ENABLE_WRITE_BARRIERS
		if (hasReference)
		{
			return { LocationDescType::StructContainsRef, size };
		}
#endif
		switch (size)
		{
		case 1: return { LocationDescType::U1, 0 };
		case 2: return { LocationDescType::U2, 0 };
		case 4: return { LocationDescType::I4, 0 };
		case 8: return { LocationDescType::I8, 0 };
		default: return { LocationDescType::S, size };
		}
	}

	LocationDescInfo ComputLocationDescInfo(const Il2CppType* type)
	{
		if (type->byref)
		{
			return { NATIVE_INT_DESC_TYPE, 0 };
		}
		switch (type->type)
		{
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_U1:
			return{ LocationDescType::U1, 0 };
		case IL2CPP_TYPE_I1:
			return{ LocationDescType::I1, 0 };
		case IL2CPP_TYPE_I2:
			return{ LocationDescType::I2, 0 };
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_U2:
			return{ LocationDescType::U2, 0 };
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
		case IL2CPP_TYPE_R4:
			return{ LocationDescType::I4, 0 };
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
		case IL2CPP_TYPE_R8:
			return{ LocationDescType::I8, 0 };
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_FNPTR:
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_BYREF:
			return{ NATIVE_INT_DESC_TYPE, 0 };
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_ARRAY:
		case IL2CPP_TYPE_SZARRAY:
		case IL2CPP_TYPE_OBJECT:
		case IL2CPP_TYPE_CLASS:
			return{ LocationDescType::Ref, 0 };
		case IL2CPP_TYPE_TYPEDBYREF:
			return { LocationDescType::S, sizeof(Il2CppTypedRef) };
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
			if (klass->enumtype)
			{
				return ComputLocationDescInfo(&klass->castClass->byval_arg);
			}
			return ComputValueTypeDescInfo(il2cpp::vm::Class::GetValueSize(klass, nullptr), klass->has_references);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* genericClass = type->data.generic_class;
			if (genericClass->type->type == IL2CPP_TYPE_CLASS)
			{
				IL2CPP_ASSERT(!IS_CLASS_VALUE_TYPE(il2cpp::vm::Class::FromIl2CppType(type)));
				return{ LocationDescType::Ref, 0 };
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
				IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
				if (klass->enumtype)
				{
					return ComputLocationDescInfo(&klass->castClass->byval_arg);
				}
				return ComputValueTypeDescInfo(il2cpp::vm::Class::GetValueSize(klass, nullptr), klass->has_references);
			}
		}
		default:
		{
			RaiseExecutionEngineException("not support arg type");
			return{ NATIVE_INT_DESC_TYPE, 0 };
		}
		}
	}

	IRCommon* CreateLoadExpandDataToStackVarVar(TemporaryMemoryArena& pool, int32_t dstOffset, int32_t srcOffset, const Il2CppType* type, int32_t size)
	{
		if (type->byref)
		{
			CreateIR(ir, LdlocVarVar);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		switch (type->type)
		{
		case Il2CppTypeEnum::IL2CPP_TYPE_I1:
		{
			CreateIR(ir, LdlocExpandVarVar_i1);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		case Il2CppTypeEnum::IL2CPP_TYPE_BOOLEAN:
		case Il2CppTypeEnum::IL2CPP_TYPE_U1:
		{
			CreateIR(ir, LdlocExpandVarVar_u1);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		case Il2CppTypeEnum::IL2CPP_TYPE_I2:
		{
			CreateIR(ir, LdlocExpandVarVar_i2);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_U2:
		{
			CreateIR(ir, LdlocExpandVarVar_u2);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			if (klass->enumtype)
			{
				return CreateLoadExpandDataToStackVarVar(pool, dstOffset, srcOffset, &klass->element_class->byval_arg, size);
			}
			break;
		}
		default: break;
		}
		if (size <= 8)
		{
			CreateIR(ir, LdlocVarVar);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		else
		{
			IL2CPP_ASSERT(size <= MAX_VALUE_TYPE_SIZE);
			CreateIR(ir, LdlocVarVarSize);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			ir->size = size;
			return ir;
		}
	}

	IRCommon* CreateAssignVarVar(TemporaryMemoryArena& pool, int32_t dstOffset, int32_t srcOffset, int32_t size)
	{
		IL2CPP_ASSERT(dstOffset >= 0 && dstOffset < 0x10000);
		IL2CPP_ASSERT(srcOffset >= 0 && srcOffset < 0x10000);
		if (size <= 8)
		{
			CreateIR(ir, LdlocVarVar);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			return ir;
		}
		else
		{
			IL2CPP_ASSERT(size <= MAX_VALUE_TYPE_SIZE);
			CreateIR(ir, LdlocVarVarSize);
			ir->dst = dstOffset;
			ir->src = srcOffset;
			ir->size = size;
			return ir;
		}
	}

    constexpr uint32_t kMaxShortFieldOffset = 0xFFFF;

	interpreter::IRCommon* CreateClassLdfldSmall(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, uint16_t offset, LocationDescInfo desc)
	{
		CreateIR(ir, LdfldVarVar_i1);
		ir->dst = dstIdx;
		ir->obj = objIdx;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::LdfldVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::LdfldVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::LdfldVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::LdfldVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::LdfldVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::LdfldVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdfldVarVar_i4, HiOpcodeEnum::LdfldVarVar_i8);
			return ir;
		}
		case LocationDescType::S:
		case LocationDescType::StructContainsRef:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::LdfldVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::LdfldVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::LdfldVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::LdfldVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::LdfldVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::LdfldVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, LdfldVarVar_n_4);
				irn->dst = dstIdx;
				irn->obj = objIdx;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateClassLdfldLarge(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, uint32_t offset, LocationDescInfo desc)
	{
		CreateIR(ir, LdfldLargeVarVar_i1);
		ir->dst = dstIdx;
		ir->obj = objIdx;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::LdfldLargeVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::LdfldLargeVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::LdfldLargeVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::LdfldLargeVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::LdfldLargeVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::LdfldLargeVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdfldLargeVarVar_i4, HiOpcodeEnum::LdfldLargeVarVar_i8);
			return ir;
		}
		case LocationDescType::S:
		case LocationDescType::StructContainsRef:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::LdfldLargeVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::LdfldLargeVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::LdfldLargeVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::LdfldLargeVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::LdfldLargeVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::LdfldLargeVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, LdfldLargeVarVar_n_4);
				irn->dst = dstIdx;
				irn->obj = objIdx;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}


	interpreter::IRCommon* CreateClassLdfld(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, const FieldInfo* fieldInfo)
	{
		uint32_t offset = GetFieldOffset(fieldInfo);
		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);
		if (offset <= kMaxShortFieldOffset)
		{
			return CreateClassLdfldSmall(pool, dstIdx, objIdx, (uint16_t)offset, desc);
		}
		else
		{
			return CreateClassLdfldLarge(pool, dstIdx, objIdx, offset, desc);
		}
	}

	interpreter::IRCommon* CreateValueTypeLdfldSmall(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, uint16_t offset, LocationDescInfo desc)
	{
		CreateIR(ir, LdfldValueTypeVarVar_i1);
		ir->dst = dstIdx;
		ir->obj = objIdx;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdfldValueTypeVarVar_i4, HiOpcodeEnum::LdfldValueTypeVarVar_i8);
			return ir;
		}
		case LocationDescType::S:
		case LocationDescType::StructContainsRef:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, LdfldValueTypeVarVar_n_4);
				irn->dst = dstIdx;
				irn->obj = objIdx;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateValueTypeLdfldLarge(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, uint32_t offset, LocationDescInfo desc)
	{
		CreateIR(ir, LdfldValueTypeLargeVarVar_i1);
		ir->dst = dstIdx;
		ir->obj = objIdx;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdfldValueTypeLargeVarVar_i4, HiOpcodeEnum::LdfldValueTypeLargeVarVar_i8);
			return ir;
		}
		case LocationDescType::S:
		case LocationDescType::StructContainsRef:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::LdfldValueTypeLargeVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, LdfldValueTypeLargeVarVar_n_4);
				irn->dst = dstIdx;
				irn->obj = objIdx;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateValueTypeLdfld(TemporaryMemoryArena& pool, int32_t dstIdx, int32_t objIdx, const FieldInfo* fieldInfo)
	{
		uint32_t offset = GetFieldOffset(fieldInfo);

		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);
		if (offset <= kMaxShortFieldOffset)
		{
			return CreateValueTypeLdfldSmall(pool, dstIdx, objIdx, (uint16_t)offset, desc);
		}
		else
		{
			return CreateValueTypeLdfldLarge(pool, dstIdx, objIdx, offset, desc);
        }
	}

	interpreter::IRCommon* CreateStfldSmall(TemporaryMemoryArena& pool, int32_t objIdx, const FieldInfo* fieldInfo, int32_t dataIdx, uint16_t offset, LocationDescInfo desc)
	{
		CreateIR(ir, StfldVarVar_i1);
		ir->data = dataIdx;
		ir->obj = objIdx;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = HiOpcodeEnum::StfldVarVar_ref;
			return ir;
		}
		case LocationDescType::S:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::StfldVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::StfldVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::StfldVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::StfldVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::StfldVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::StfldVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, StfldVarVar_n_4);
				irn->data = dataIdx;
				irn->obj = objIdx;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		case LocationDescType::StructContainsRef:
		{
			CreateIR(irn, StfldVarVar_WriteBarrier_n_4);
			irn->data = dataIdx;
			irn->obj = objIdx;
			irn->offset = offset;
			irn->size = desc.size;
			return irn;
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateStfldLarge(TemporaryMemoryArena& pool, int32_t objIdx, const FieldInfo* fieldInfo, int32_t dataIdx, uint32_t offset, LocationDescInfo desc)
	{
		CreateIR(ir, StfldLargeVarVar_i1);
		ir->data = dataIdx;
		ir->obj = objIdx;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = HiOpcodeEnum::StfldLargeVarVar_ref;
			return ir;
		}
		case LocationDescType::S:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::StfldLargeVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::StfldLargeVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::StfldLargeVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::StfldLargeVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::StfldLargeVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::StfldLargeVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, StfldLargeVarVar_n_4);
				irn->data = dataIdx;
				irn->obj = objIdx;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		case LocationDescType::StructContainsRef:
		{
			CreateIR(irn, StfldLargeVarVar_WriteBarrier_n_4);
			irn->data = dataIdx;
			irn->obj = objIdx;
			irn->offset = offset;
			irn->size = desc.size;
			return irn;
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateStfld(TemporaryMemoryArena& pool, int32_t objIdx, const FieldInfo* fieldInfo, int32_t dataIdx)
	{
		uint32_t offset = GetFieldOffset(fieldInfo);

		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);
		if (offset <= kMaxShortFieldOffset)
		{
			return CreateStfldSmall(pool, objIdx, fieldInfo, dataIdx, (uint16_t)offset, desc);
		}
		else
		{
			return CreateStfldLarge(pool, objIdx, fieldInfo, dataIdx, offset,  desc);
        }
	}

	interpreter::IRCommon* CreateLdsfld(TemporaryMemoryArena& pool, int32_t dstIdx, const FieldInfo* fieldInfo, uint32_t parent)
	{
		uint32_t offset = fieldInfo->offset;

		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);

		CreateIR(ir, LdsfldVarVar_i1);
		ir->dst = dstIdx;
		ir->klass = parent;
		ir->offset = offset;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::LdsfldVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::LdsfldVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::LdsfldVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::LdsfldVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::LdsfldVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::LdsfldVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdsfldVarVar_i4, HiOpcodeEnum::LdsfldVarVar_i8);
			return ir;
		}
		case LocationDescType::S:
		case LocationDescType::StructContainsRef:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::LdsfldVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::LdsfldVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::LdsfldVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::LdsfldVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::LdsfldVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::LdsfldVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, LdsfldVarVar_n_4);
				irn->dst = dstIdx;
				irn->klass = parent;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateStsfld(TemporaryMemoryArena& pool, const FieldInfo* fieldInfo, uint32_t parent, int32_t dataIdx)
	{
		uint32_t offset = fieldInfo->offset;


		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);

		CreateIR(ir, StsfldVarVar_i1);
		ir->klass = parent;
		ir->offset = offset;
		ir->data = dataIdx;
		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = HiOpcodeEnum::StsfldVarVar_ref;
			return ir;
		}
		case LocationDescType::S:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::StsfldVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::StsfldVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::StsfldVarVar_size_20;
				return ir;
			}
			case 24: 
			{
				ir->type = HiOpcodeEnum::StsfldVarVar_size_24;
				return ir;
			}
			case 28: 
			{
				ir->type = HiOpcodeEnum::StsfldVarVar_size_28;
				return ir;
			}
			case 32: 
			{
				ir->type = HiOpcodeEnum::StsfldVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, StsfldVarVar_n_4);
				irn->klass = parent;
				irn->offset = offset;
				irn->data = dataIdx;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		case LocationDescType::StructContainsRef:
		{
			CreateIR(irn, StsfldVarVar_WriteBarrier_n_4);
			irn->klass = parent;
			irn->offset = offset;
			irn->data = dataIdx;
			irn->size = desc.size;
			return irn;
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateLdthreadlocal(TemporaryMemoryArena& pool, int32_t dstIdx, const FieldInfo* fieldInfo, uint32_t parent)
	{
		IL2CPP_ASSERT(fieldInfo->offset == THREAD_STATIC_FIELD_OFFSET);
		int32_t offset = GetThreadStaticFieldOffset(fieldInfo);

		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);

		CreateIR(ir, LdthreadlocalVarVar_i1);
		ir->dst = dstIdx;
		ir->klass = parent;
		ir->offset = offset;

		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::LdthreadlocalVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::LdthreadlocalVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::LdthreadlocalVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::LdthreadlocalVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::LdthreadlocalVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::LdthreadlocalVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdthreadlocalVarVar_i4, HiOpcodeEnum::LdthreadlocalVarVar_i8);
			return ir;
		}
		case LocationDescType::S:
		case LocationDescType::StructContainsRef:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::LdthreadlocalVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::LdthreadlocalVarVar_size_16;
				return ir;
			}
			case 20:
			{
				ir->type = HiOpcodeEnum::LdthreadlocalVarVar_size_20;
				return ir;
			}
			case 24:
			{
				ir->type = HiOpcodeEnum::LdthreadlocalVarVar_size_24;
				return ir;
			}
			case 28:
			{
				ir->type = HiOpcodeEnum::LdthreadlocalVarVar_size_28;
				return ir;
			}
			case 32:
			{
				ir->type = HiOpcodeEnum::LdthreadlocalVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, LdthreadlocalVarVar_n_4);
				irn->dst = dstIdx;
				irn->klass = parent;
				irn->offset = offset;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	interpreter::IRCommon* CreateStthreadlocal(TemporaryMemoryArena& pool, const FieldInfo* fieldInfo, uint32_t parent, int32_t dataIdx)
	{
		IL2CPP_ASSERT(fieldInfo->offset == THREAD_STATIC_FIELD_OFFSET);
		int32_t offset = GetThreadStaticFieldOffset(fieldInfo);

		const Il2CppType* type = fieldInfo->type;
		LocationDescInfo desc = ComputLocationDescInfo(type);

		CreateIR(ir, StthreadlocalVarVar_i1);
		ir->klass = parent;
		ir->offset = offset;
		ir->data = dataIdx;

		switch (desc.type)
		{
		case LocationDescType::I1:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_i1;
			return ir;
		}
		case LocationDescType::U1:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_u1;
			return ir;
		}
		case LocationDescType::I2:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_i2;
			return ir;
		}
		case LocationDescType::U2:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_u2;
			return ir;
		}
		case LocationDescType::I4:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_i4;
			return ir;
		}
		case LocationDescType::I8:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_i8;
			return ir;
		}
		case LocationDescType::Ref:
		{
			ir->type = HiOpcodeEnum::StthreadlocalVarVar_ref;
			return ir;
		}
		case LocationDescType::S:
		{
			switch (desc.size)
			{
			case 12:
			{
				ir->type = HiOpcodeEnum::StthreadlocalVarVar_size_12;
				return ir;
			}
			case 16:
			{
				ir->type = HiOpcodeEnum::StthreadlocalVarVar_size_16;
				return ir;
			}
			case 20: 
			{
				ir->type = HiOpcodeEnum::StthreadlocalVarVar_size_20;
				return ir;
			}
			case 24: 
			{
				ir->type = HiOpcodeEnum::StthreadlocalVarVar_size_24;
				return ir;
			}
			case 28: 
			{
				ir->type = HiOpcodeEnum::StthreadlocalVarVar_size_28;
				return ir;
			}
			case 32: 
			{
				ir->type = HiOpcodeEnum::StthreadlocalVarVar_size_32;
				return ir;
			}
			default:
			{
				CreateIR(irn, StthreadlocalVarVar_n_4);
				irn->klass = parent;
				irn->offset = offset;
				irn->data = dataIdx;
				irn->size = desc.size;
				return irn;
			}
			}
		}
		case LocationDescType::StructContainsRef:
		{
			CreateIR(irn, StthreadlocalVarVar_WriteBarrier_n_4);
			irn->klass = parent;
			irn->offset = offset;
			irn->data = dataIdx;
			irn->size = desc.size;
			return irn;
		}
		default:
		{
			RaiseExecutionEngineException("field");
			return ir;
		}
		}
	}

	// TransformContext implements


	HiOpcodeEnum TransformContext::CalcGetMdArrElementVarVarOpcode(const Il2CppType* type)
	{
		LocationDescInfo desc = ComputLocationDescInfo(type);
		switch (desc.type)
		{
		case LocationDescType::I1: return HiOpcodeEnum::GetMdArrElementVarVar_i1;
		case LocationDescType::U1: return HiOpcodeEnum::GetMdArrElementVarVar_u1;
		case LocationDescType::I2: return HiOpcodeEnum::GetMdArrElementVarVar_i2;
		case LocationDescType::U2: return HiOpcodeEnum::GetMdArrElementVarVar_u2;
		case LocationDescType::I4: return HiOpcodeEnum::GetMdArrElementVarVar_i4;
		case LocationDescType::I8: return HiOpcodeEnum::GetMdArrElementVarVar_i8;
		case LocationDescType::Ref: return ARCH_ARGUMENT(HiOpcodeEnum::GetMdArrElementVarVar_i4, HiOpcodeEnum::GetMdArrElementVarVar_i8);
		case LocationDescType::S:
		case LocationDescType::StructContainsRef: return HiOpcodeEnum::GetMdArrElementVarVar_n;
		default:
		{
			RaiseExecutionEngineException("CalcGetMdArrElementVarVarOpcode");
			return (HiOpcodeEnum)0;
		}
		}
	}

	TransformContext::TransformContext(hybridclr::metadata::Image* image, const MethodInfo* methodInfo, metadata::MethodBody& body, TemporaryMemoryArena& pool, il2cpp::utils::dynamic_array<uint64_t>& resolveDatas)
		: image(image), methodInfo(methodInfo), body(body), pool(pool), resolveDatas(resolveDatas),
		actualParamCount(0), ip2bb(nullptr), curbb(nullptr), args(nullptr), locals(nullptr), evalStack(nullptr),
		evalStackTop(0), evalStackBaseOffset(0), curStackSize(0), maxStackSize(0),
		nextFlowIdx(0), ipBase(nullptr), ip(nullptr), ipOffset(0), ir2offsetMap(nullptr),
		prefixFlags(0), shareMethod(nullptr), totalIRSize(0), totalArgSize(0), totalArgLocalSize(0), initLocals(false)
	{

	}

	TransformContext::~TransformContext()
	{
		for (IRBasicBlock* bb : irbbs)
		{
			bb->~IRBasicBlock();
		}
		if (ir2offsetMap)
		{
			delete ir2offsetMap;
		}
	}

	uint32_t TransformContext::GetOrAddResolveDataIndex(const void* ptr)
	{
		auto it = ptr2DataIdxs.find(ptr);
		if (it != ptr2DataIdxs.end())
		{
			return it->second;
		}
		else
		{
			uint32_t newIndex = (uint32_t)resolveDatas.size();
			resolveDatas.push_back((uint64_t)ptr);
			ptr2DataIdxs.insert({ ptr, newIndex });
			return newIndex;
		}
	}

	void TransformContext::PushStackByType(const Il2CppType* type)
	{
		int32_t byteSize = GetTypeValueSize(type);
		int32_t stackSize = GetStackSizeByByteSize(byteSize);
		evalStack[evalStackTop].reduceType = GetEvalStackReduceDataType(type);
		evalStack[evalStackTop].byteSize = byteSize;
		evalStack[evalStackTop].locOffset = GetEvalStackNewTopOffset();
		evalStackTop++;
		curStackSize += stackSize;
		maxStackSize = std::max(curStackSize, maxStackSize);
		IL2CPP_ASSERT(maxStackSize < MAX_STACK_SIZE);
	}

	void TransformContext::PushStackByReduceType(EvalStackReduceDataType t)
	{
		int32_t byteSize = GetSizeByReduceType(t);
		int32_t stackSize = GetStackSizeByByteSize(byteSize);
		evalStack[evalStackTop].reduceType = t;
		evalStack[evalStackTop].byteSize = byteSize;
		evalStack[evalStackTop].locOffset = GetEvalStackNewTopOffset();
		evalStackTop++; curStackSize += stackSize;
		maxStackSize = std::max(curStackSize, maxStackSize);
		IL2CPP_ASSERT(maxStackSize < MAX_STACK_SIZE);
	}

	void TransformContext::DuplicateStack()
	{
		IL2CPP_ASSERT(evalStackTop > 0);
		EvalStackVarInfo& oldTop = evalStack[evalStackTop - 1];
		int32_t stackSize = GetStackSizeByByteSize(oldTop.byteSize);
		EvalStackVarInfo& newTop = evalStack[evalStackTop++];
		newTop.reduceType = oldTop.reduceType;
		newTop.byteSize = oldTop.byteSize;
		newTop.locOffset = curStackSize;
		curStackSize += stackSize;
		maxStackSize = std::max(curStackSize, maxStackSize);
		IL2CPP_ASSERT(maxStackSize < MAX_STACK_SIZE);
	}

	void TransformContext::PopStack()
	{
		IL2CPP_ASSERT(evalStackTop > 0);
		--evalStackTop;
		curStackSize = evalStack[evalStackTop].locOffset;
	}

	void TransformContext::PopStackN(int32_t n)
	{
		IL2CPP_ASSERT(evalStackTop >= n && n >= 0);
		if (n > 0)
		{
			evalStackTop -= n;
			curStackSize = evalStack[evalStackTop].locOffset;
		}
	}

	void TransformContext::PopAllStack()
	{
		if (evalStackTop > 0)
		{
			evalStackTop = 0;
			curStackSize = evalStackBaseOffset;
		}
		else
		{
			IL2CPP_ASSERT(curStackSize == evalStackBaseOffset);
		}
	}

	void TransformContext::InsertMemoryBarrier()
	{
		if (prefixFlags & (int32_t)PrefixFlags::Volatile)
		{
			CreateAddIR(_mb, MemoryBarrier);
		}
	}

	void TransformContext::ResetPrefixFlags()
	{
		prefixFlags = 0;
	}

	void TransformContext::Add_ldind(HiOpcodeEnum opCode, EvalStackReduceDataType dataType)
	{
		CreateAddIR(ir, LdindVarVar_i1);
		ir->type = opCode;
		ir->dst = ir->src = GetEvalStackTopOffset();
		PopStack();
		PushStackByReduceType(dataType);
		InsertMemoryBarrier();
		ResetPrefixFlags();
		ip++;
	}

	void TransformContext::Add_stind(HiOpcodeEnum opCode)
	{
		IL2CPP_ASSERT(evalStackTop >= 2);
		InsertMemoryBarrier();
		ResetPrefixFlags();
		CreateAddIR(ir, StindVarVar_i1);
		ir->type = opCode;
		ir->dst = evalStack[evalStackTop - 2].locOffset;
		ir->src = evalStack[evalStackTop - 1].locOffset;
		PopStackN(2);
		ip++;
	}

	void TransformContext::PushOffset(int32_t* offsetPtr)
	{
		IL2CPP_ASSERT(splitOffsets.find(*(offsetPtr)) != splitOffsets.end());
		relocationOffsets.push_back(offsetPtr);
	}

	void TransformContext::PushBranch(int32_t targetOffset)
	{
		IL2CPP_ASSERT(splitOffsets.find(targetOffset) != splitOffsets.end());
		IRBasicBlock* targetBb = ip2bb[targetOffset];
		if (!targetBb->inPending)
		{
			targetBb->inPending = true;
			FlowInfo* fi = pool.NewAny<FlowInfo>();
			fi->offset = targetOffset;
			fi->curStackSize = curStackSize;
			if (evalStackTop > 0)
			{
				fi->evalStack.insert(fi->evalStack.end(), evalStack, evalStack + evalStackTop);
			}
			else
			{
				IL2CPP_ASSERT(curStackSize == evalStackBaseOffset);
			}
			pendingFlows.push_back(fi);
		}
	}

	bool TransformContext::FindNextFlow()
	{
		for (; nextFlowIdx < (int32_t)pendingFlows.size(); )
		{
			FlowInfo* fi = pendingFlows[nextFlowIdx++];
			IRBasicBlock* nextBb = ip2bb[fi->offset];
			if (!nextBb->visited)
			{
				ip = ipBase + fi->offset;
				if (!fi->evalStack.empty()) {

					std::memcpy(evalStack, &fi->evalStack[0], sizeof(EvalStackVarInfo) * fi->evalStack.size());
				}
				curStackSize = fi->curStackSize;
				IL2CPP_ASSERT(curStackSize >= evalStackBaseOffset);
				evalStackTop = (int32_t)fi->evalStack.size();
				return true;
			}
		}
		return false;
	}

	void TransformContext::AddInst(IRCommon* ir)
	{
		IL2CPP_ASSERT(ir->type != HiOpcodeEnum::None);
		curbb->insts.push_back(ir);
		if (ir2offsetMap)
		{
			ir2offsetMap->insert({ ir, ipOffset });
		}
	}

	void TransformContext::AddInst_ldarg(int32_t argIdx)
	{
		ArgVarInfo& __arg = args[argIdx];
		IRCommon* ir = CreateLoadExpandDataToStackVarVar(pool, GetEvalStackNewTopOffset(), __arg.argLocOffset, __arg.type, GetTypeValueSize(__arg.type));
		AddInst(ir);
		PushStackByType(__arg.type);
	}

	bool TransformContext::IsCreateNotNullObjectInstrument(IRCommon* ir)
	{
		switch (ir->type)
		{
		case HiOpcodeEnum::BoxVarVar:
		{
			IRBoxVarVar* irBox = (IRBoxVarVar*)ir;
			Il2CppClass* klass = ((Il2CppClass*)resolveDatas[irBox->klass]);
			return IS_CLASS_VALUE_TYPE(klass) && !il2cpp::vm::Class::IsNullable(klass);
		}
		case HiOpcodeEnum::NewSystemObjectVar:
		case HiOpcodeEnum::NewString:
		case HiOpcodeEnum::NewString_2:
		case HiOpcodeEnum::NewString_3:
		case HiOpcodeEnum::CtorDelegate:
		case HiOpcodeEnum::NewDelegate:
			//case HiOpcodeEnum::NewClassInterpVar_Ctor_0:
			//case HiOpcodeEnum::NewClassInterpVar:
			//case HiOpcodeEnum::NewClassVar:
			//case HiOpcodeEnum::NewClassVar_Ctor_0:
			//case HiOpcodeEnum::NewClassVar_NotCtor:
		case HiOpcodeEnum::NewMdArrVarVar_length:
		case HiOpcodeEnum::NewMdArrVarVar_length_bound:
		case HiOpcodeEnum::NewArrVarVar:
		case HiOpcodeEnum::LdsfldaFromFieldDataVarVar:
		case HiOpcodeEnum::LdsfldaVarVar:
		case HiOpcodeEnum::LdthreadlocalaVarVar:
		case HiOpcodeEnum::LdlocVarAddress:
			return true;
		default:
			return false;
		}
	}

	void TransformContext::RemoveLastInstrument()
	{
		IL2CPP_ASSERT(!curbb->insts.empty());
		curbb->insts.pop_back();
	}

	void TransformContext::AddInst_ldarga(int32_t argIdx)
	{
		IL2CPP_ASSERT(argIdx < actualParamCount);
		ArgVarInfo& argInfo = args[argIdx];
		CreateAddIR(ir, LdlocVarAddress);
		ir->dst = GetEvalStackNewTopOffset();
		ir->src = argInfo.argLocOffset;
		PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
	}

	void TransformContext::AddInst_starg(int32_t argIdx)
	{
		IL2CPP_ASSERT(argIdx < actualParamCount);
		ArgVarInfo& __arg = args[argIdx];
		IRCommon* ir = CreateAssignVarVar(pool, __arg.argLocOffset, GetEvalStackTopOffset(), GetTypeValueSize(__arg.type));
		AddInst(ir);
		PopStack();
	}

	void TransformContext::CreateAddInst_ldloc(int32_t locIdx)
	{
		LocVarInfo& __loc = locals[locIdx];
		IRCommon* ir = CreateLoadExpandDataToStackVarVar(pool, GetEvalStackNewTopOffset(), __loc.locOffset, __loc.type, GetTypeValueSize(__loc.type));
		AddInst(ir);
		PushStackByType(__loc.type);
	}

	void TransformContext::CreateAddInst_stloc(int32_t locIdx)
	{
		LocVarInfo& __loc = locals[locIdx];
		IRCommon* ir = CreateAssignVarVar(pool, __loc.locOffset, GetEvalStackTopOffset(), GetTypeValueSize(__loc.type));
		AddInst(ir);
		PopStack();
	}

	void TransformContext::CreateAddInst_ldloca(int32_t locIdx)
	{
		CreateAddIR(ir, LdlocVarAddress);
		LocVarInfo& __loc = locals[locIdx];
		ir->dst = GetEvalStackNewTopOffset();
		ir->src = __loc.locOffset;
		PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
	}

	void TransformContext::CreateAddInst_ldc4(int32_t c, EvalStackReduceDataType rtype)
	{
		CreateAddIR(ir, LdcVarConst_4);
		ir->dst = GetEvalStackNewTopOffset();
		ir->src = c;
		PushStackByReduceType(rtype);
	}

	void TransformContext::CreateAddInst_ldc8(int64_t c, EvalStackReduceDataType rtype)
	{
		CreateAddIR(ir, LdcVarConst_8);
		ir->dst = GetEvalStackNewTopOffset();
		ir->src = c;
		PushStackByReduceType(rtype);
	}

	void TransformContext::Add_brtruefalse(bool c, int32_t targetOffset)
	{
		EvalStackVarInfo& top = evalStack[evalStackTop - 1];
		IRCommon* lastIR = GetLastInstrument();
		if (lastIR == nullptr || !IsCreateNotNullObjectInstrument(lastIR))
		{
			if (top.byteSize <= 4)
			{
				CreateAddIR(ir, BranchTrueVar_i4);
				ir->type = c ? HiOpcodeEnum::BranchTrueVar_i4 : HiOpcodeEnum::BranchFalseVar_i4;
				ir->op = top.locOffset;
				ir->offset = targetOffset;
				PushOffset(&ir->offset);
			}
			else
			{
				CreateAddIR(ir, BranchTrueVar_i8);
				ir->type = c ? HiOpcodeEnum::BranchTrueVar_i8 : HiOpcodeEnum::BranchFalseVar_i8;
				ir->op = top.locOffset;
				ir->offset = targetOffset;
				PushOffset(&ir->offset);
			}
		}
		else
		{
			// optimize instrument sequence like` box T!; brtrue`
			// this optimization is not semanticly equals to origin instrument because may ommit `Class::InitRuntime`.
			// but it's ok in most occasions.
			RemoveLastInstrument();
			if (c)
			{
				// brtrue always true, replace with br
				CreateAddIR(ir, BranchUncondition_4);
				ir->offset = targetOffset;
				PushOffset(&ir->offset);
			}
			else
			{
				// brfalse always false, run throughtly.
			}
		}
		PopStack();
		PushBranch(targetOffset);
	}

	void TransformContext::Add_bc(int32_t ipOffset, int32_t brOffset, int32_t opSize, HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8)
	{
		int32_t targetOffset = ipOffset + brOffset + opSize;
		EvalStackVarInfo& op1 = evalStack[evalStackTop - 2];
		EvalStackVarInfo& op2 = evalStack[evalStackTop - 1];
		IRBranchVarVar_Ceq_i4* ir = pool.AllocIR<IRBranchVarVar_Ceq_i4>();
		ir->type = (HiOpcodeEnum)0;
		ir->op1 = op1.locOffset;
		ir->op2 = op2.locOffset;
		ir->offset = targetOffset;
		PushOffset(&ir->offset);
		switch (op1.reduceType)
		{
		case EvalStackReduceDataType::I4:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				ir->type = opI4;
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				CreateAddIR(irConv, ConvertVarVar_i4_i8);
				irConv->dst = irConv->src = op1.locOffset;
				ir->type = opI8;
				break;
			}
			default:
			{
				IL2CPP_ASSERT(false && "I4 not match");
				break;
			}
			}
			break;
		}
		case EvalStackReduceDataType::I8:
		{
			IL2CPP_ASSERT(op2.reduceType == EvalStackReduceDataType::I8);
			ir->type = opI8;
			break;
		}
		case EvalStackReduceDataType::R4:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::R4:
			{
				ir->type = opR4;
				break;
			}
			default:
			{
				IL2CPP_ASSERT(false && "R4 not match");
				break;
			}
			}
			break;
		}
		case EvalStackReduceDataType::R8:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::R8:
			{
				ir->type = opR8;
				break;
			}
			default:
			{
				IL2CPP_ASSERT(false && "R8 not match");
				break;
			}
			}
			break;
		}
		default:
		{
			IL2CPP_ASSERT(false && "nothing match");
		}
		}
		AddInst(ir);
		PopStackN(2);
		PushBranch(targetOffset);
	}

	void TransformContext::Add_conv(int32_t dstTypeSize, EvalStackReduceDataType dstReduceType, HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8)
	{
		IL2CPP_ASSERT(evalStackTop > 0);
		EvalStackVarInfo& top = evalStack[evalStackTop - 1];
		//if (top.reduceType != dstReduceType)
		{
			CreateIR(ir, ConvertVarVar_i4_u4);
			ir->type = (HiOpcodeEnum)0;
			ir->dst = ir->src = GetEvalStackTopOffset();
			switch (top.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				ir->type = opI4;
				AddInst(ir);
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				ir->type = opI8;
				AddInst(ir);
				break;
			}
			case EvalStackReduceDataType::R4:
			{
				ir->type = opR4;
				AddInst(ir);
				break;
			}
			case EvalStackReduceDataType::R8:
			{
				ir->type = opR8;
				AddInst(ir);
				break;
			}
			default:
			{
				RaiseExecutionEngineException("conv");
				break;
			}
			}
		}

		top.reduceType = dstReduceType;
		top.byteSize = dstTypeSize;
		ip++;
	}

	void TransformContext::Add_conv_ovf(int32_t dstTypeSize, EvalStackReduceDataType dstReduceType, HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8)
	{
		IL2CPP_ASSERT(evalStackTop > 0);
		EvalStackVarInfo& top = evalStack[evalStackTop - 1];
		//if (top.reduceType != dstReduceType)
		{
			CreateIR(ir, ConvertOverflowVarVar_i4_u4);
			ir->type = (HiOpcodeEnum)0;
			ir->dst = ir->src = GetEvalStackTopOffset();
			switch (top.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				ir->type = opI4;
				AddInst(ir);
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				ir->type = opI8;
				AddInst(ir);
				break;
			}
			case EvalStackReduceDataType::R4:
			{
				ir->type = opR4;
				AddInst(ir);
				break;
			}
			case EvalStackReduceDataType::R8:
			{
				ir->type = opR8;
				AddInst(ir);
				break;
			}
			default:
			{
				RaiseExecutionEngineException("conv_ovf");
				break;
			}
			}
		}

		top.reduceType = dstReduceType;
		top.byteSize = dstTypeSize;
		ip++;
	}

	void TransformContext::Add_binop(HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8)
	{
		IL2CPP_ASSERT(evalStackTop >= 2);
		EvalStackVarInfo& op1 = evalStack[evalStackTop - 2];
		EvalStackVarInfo& op2 = evalStack[evalStackTop - 1];
		CreateIR(ir, BinOpVarVarVar_Add_i4);
		ir->op1 = op1.locOffset;
		ir->op2 = op2.locOffset;
		ir->ret = op1.locOffset;
		EvalStackReduceDataType resultType;
		switch (op1.reduceType)
		{
		case EvalStackReduceDataType::I4:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				resultType = EvalStackReduceDataType::I4;
				ir->type = opI4;
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				CreateAddIR(irConv, ConvertVarVar_i4_i8);
				irConv->dst = irConv->src = op1.locOffset;
				ir->type = opI8;
				resultType = EvalStackReduceDataType::I8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("Add_bin_op I4 op unknown");
				resultType = (EvalStackReduceDataType)-1;
			}
			}
			break;
		}
		case EvalStackReduceDataType::I8:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				CreateAddIR(irConv, ConvertVarVar_i4_i8);
				irConv->dst = irConv->src = op2.locOffset;
				resultType = EvalStackReduceDataType::I8;
				ir->type = opI8;
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				resultType = EvalStackReduceDataType::I8;
				ir->type = opI8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("Add_bin_op I8 op unknown");
				resultType = (EvalStackReduceDataType)-1;
				break;
			}
			}
			break;
		}
		case EvalStackReduceDataType::R4:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::R4:
			{
				resultType = EvalStackReduceDataType::R4;
				ir->type = opR4;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("Add_bin_op R4 op unknown");
				resultType = (EvalStackReduceDataType)-1;
				break;
			}
			}
			break;
		}
		case EvalStackReduceDataType::R8:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::R8:
			{
				resultType = EvalStackReduceDataType::R8;
				ir->type = opR8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("Add_bin_op R8 op unknown");
				resultType = (EvalStackReduceDataType)-1;
				break;
			}
			}
			break;
		}
		default:
		{
			RaiseExecutionEngineException("Add_bin_op unknown");
			resultType = (EvalStackReduceDataType)-1;
			break;
		}
		}
		PopStack();
		op1.reduceType = resultType;
		op1.byteSize = GetSizeByReduceType(resultType);
		AddInst(ir);
		ip++;
	}

	void TransformContext::Add_shiftop(HiOpcodeEnum opI4I4, HiOpcodeEnum opI4I8, HiOpcodeEnum opI8I4, HiOpcodeEnum opI8I8)
	{
		IL2CPP_ASSERT(evalStackTop >= 2);
		EvalStackVarInfo& op1 = evalStack[evalStackTop - 2];
		EvalStackVarInfo& op2 = evalStack[evalStackTop - 1];
		CreateAddIR(ir, BitShiftBinOpVarVarVar_Shr_i4_i4);
		ir->ret = op1.locOffset;
		ir->value = op1.locOffset;
		ir->shiftAmount = op2.locOffset;
		switch (op1.reduceType)
		{
		case EvalStackReduceDataType::I4:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				ir->type = opI4I4;
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				ir->type = opI4I8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("shitf i4");
			}
			}
			break;
		}
		case EvalStackReduceDataType::I8:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				ir->type = opI8I4;
				break;
			}
			case EvalStackReduceDataType::I8:
			{

				ir->type = opI8I8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("shitf i8");
				break;
			}
			}
			break;
		}
		default:
		{
			RaiseExecutionEngineException("shitf i");
			break;
		}
		}
		PopStack();
		ip++;
	}

	void TransformContext::Add_compare(HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8)
	{
		IL2CPP_ASSERT(evalStackTop >= 2);
		EvalStackVarInfo& op1 = evalStack[evalStackTop - 2];
		EvalStackVarInfo& op2 = evalStack[evalStackTop - 1];
		CreateIR(ir, CompOpVarVarVar_Ceq_i4);
		ir->c1 = op1.locOffset;
		ir->c2 = op2.locOffset;
		ir->ret = op1.locOffset;
		switch (op1.reduceType)
		{
		case EvalStackReduceDataType::I4:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				ir->type = opI4;
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				CreateAddIR(irConv, ConvertVarVar_i4_i8);
				irConv->dst = irConv->src = op1.locOffset;
				ir->type = opI8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("compare i4");
				break;
			}
			}
			break;
		}
		case EvalStackReduceDataType::I8:
		{
			switch (op2.reduceType)
			{
			case EvalStackReduceDataType::I4:
			{
				CreateAddIR(irConv, ConvertVarVar_i4_i8);
				irConv->dst = irConv->src = op2.locOffset;
				ir->type = opI8;
				break;
			}
			case EvalStackReduceDataType::I8:
			{
				ir->type = opI8;
				break;
			}
			default:
			{
				RaiseExecutionEngineException("compare i8");
				break;
			}
			}
			break;
		}
		case EvalStackReduceDataType::R4:
		{
			if (op2.reduceType == EvalStackReduceDataType::R4)
			{
				ir->type = opR4;
			}
			else
			{
				RaiseExecutionEngineException("compare r4");
			}
			break;
		}
		case EvalStackReduceDataType::R8:
		{
			if (op2.reduceType == EvalStackReduceDataType::R8)
			{
				ir->type = opR8;
			}
			else
			{
				RaiseExecutionEngineException("compare r8");
			}
			break;
		}
		default:
		{
			RaiseExecutionEngineException("compare");
			break;
		}
		}
		PopStackN(2);
		AddInst(ir);
		PushStackByReduceType(EvalStackReduceDataType::I4);
	}

	void TransformContext::Add_ldelem(EvalStackReduceDataType resultType, HiOpcodeEnum opI4)
	{
		IL2CPP_ASSERT(evalStackTop >= 2);
		EvalStackVarInfo& arr = evalStack[evalStackTop - 2];
		EvalStackVarInfo& index = evalStack[evalStackTop - 1];

		CreateAddIR(ir, GetArrayElementVarVar_i1);
		ir->type = opI4;
		ir->arr = arr.locOffset;
		ir->index = index.locOffset;
		ir->dst = arr.locOffset;

		PopStackN(2);
		PushStackByReduceType(resultType);
		ip++;
	}

	void TransformContext::Add_stelem(HiOpcodeEnum opI4)
	{
		IL2CPP_ASSERT(evalStackTop >= 3);
		EvalStackVarInfo& arr = evalStack[evalStackTop - 3];
		EvalStackVarInfo& index = evalStack[evalStackTop - 2];
		EvalStackVarInfo& ele = evalStack[evalStackTop - 1];

		CreateAddIR(ir, SetArrayElementVarVar_i1);
		ir->type = opI4;
		ir->arr = arr.locOffset;
		ir->index = index.locOffset;
		ir->ele = ele.locOffset;

		PopStackN(3);
		ip++;
	}

	static int GetTypeSize(const Il2CppType* type)
	{
		if (type->byref)
		{
			return PTR_SIZE;
		}

		switch (type->type)
		{
		case IL2CPP_TYPE_I1:
		case IL2CPP_TYPE_U1:
		case IL2CPP_TYPE_BOOLEAN:
			return 1;
		case IL2CPP_TYPE_I2:
		case IL2CPP_TYPE_U2:
		case IL2CPP_TYPE_CHAR:
			return 2;
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
			return 4;
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
			return 8;
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
			return PTR_SIZE;
		case IL2CPP_TYPE_R4:
			return 4;
		case IL2CPP_TYPE_R8:
			return 8;
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_FNPTR:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_SZARRAY:
		case IL2CPP_TYPE_ARRAY:
		case IL2CPP_TYPE_CLASS:
		case IL2CPP_TYPE_OBJECT:
		case IL2CPP_TYPE_VAR:
		case IL2CPP_TYPE_MVAR:
			return PTR_SIZE;
		case IL2CPP_TYPE_VALUETYPE:
			if (il2cpp::vm::Type::IsEnum(type))
			{
				return GetTypeSize(il2cpp::vm::Class::GetEnumBaseType(il2cpp::vm::Type::GetClass(type)));
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Type::GetClass(type);
				return il2cpp::vm::Class::GetValueSize(klass, nullptr);
			}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* gclass = type->data.generic_class;

			if (gclass->type->type == IL2CPP_TYPE_CLASS)
			{
				IL2CPP_ASSERT(!IS_CLASS_VALUE_TYPE(il2cpp::vm::Class::FromIl2CppType(type)));
				return PTR_SIZE;
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
				IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
				if (klass->enumtype)
				{
					return GetTypeSize(il2cpp::vm::Class::GetEnumBaseType(klass));
				}
				else
				{
					return il2cpp::vm::Class::GetValueSize(il2cpp::vm::Class::FromIl2CppType(type), nullptr);
				}
			}
		}
		default:
			IL2CPP_ASSERT(0);
			break;
		}
		return 0;
	}

	static int CalculateParameterSize(const MethodInfo* methodInfo)
	{
		int totalParameterSize = 0;
		for (uint8_t i = 0; i < methodInfo->parameters_count; i++)
		{
			const Il2CppType* paramType = GET_METHOD_PARAMETER_TYPE(methodInfo->parameters[i]);
			totalParameterSize += GetTypeSize(paramType);
		}
		return totalParameterSize;
	}

	static Il2CppMethodPointer ResolvePInvokeMethod(const MethodInfo* methodInfo, Il2CppCallConvention& callingConvention)
	{
		metadata::InterpreterImage* interpImage = metadata::MetadataModule::GetImage(methodInfo);
		if (!interpImage)
		{
			return nullptr;
		}
		hybridclr::metadata::ImplMapInfo* implMap = interpImage->GetImplMapInfo(methodInfo->token);
		if (!implMap)
		{
			return nullptr;
		}

		uint32_t mappingFlags = implMap->mappingFlags;
		bool isNotMangle = hybridclr::metadata::IsDllImportNoMangle(mappingFlags);
		Il2CppCharSet charSet = hybridclr::metadata::GetDllImportCharSet(mappingFlags);
		callingConvention = hybridclr::metadata::GetDllImportCallConvention(mappingFlags);

		Il2CppNativeString nativeModuleName = il2cpp::utils::StringUtils::Utf8ToNativeString(implMap->moduleName);
		int parameterSize = CalculateParameterSize(methodInfo);

		const PInvokeArguments pinvokeArgs =
		{
			il2cpp::utils::StringView<Il2CppNativeChar>(nativeModuleName.c_str(), nativeModuleName.length()),
			il2cpp::utils::StringView<char>(implMap->importName, std::strlen(implMap->importName)),
			callingConvention,
			charSet,
			parameterSize,
			isNotMangle,
		};
		Il2CppMethodPointer methodPointer = il2cpp::vm::PlatformInvoke::Resolve(pinvokeArgs);
		return methodPointer;
	}

	bool TransformContext::FindFirstLeaveHandlerIndex(const std::vector<ExceptionClause>& exceptionClauses, uint32_t leaveOffset, uint32_t targetOffset, uint16_t& index)
	{
		index = 0;
		for (const ExceptionClause& ec : exceptionClauses)
		{
			if (ec.flags == CorILExceptionClauseType::Finally)
			{
				if (ec.tryOffset <= leaveOffset && leaveOffset < ec.tryOffset + ec.tryLength)
					return !(ec.tryOffset <= targetOffset && targetOffset < ec.tryOffset + ec.tryLength);
			}
			++index;
		}
		return false;
	}

	bool TransformContext::IsLeaveInTryBlock(const std::vector<ExceptionClause>& exceptionClauses, uint32_t leaveOffset)
	{
		for (const ExceptionClause& ec : exceptionClauses)
		{
			if (ec.tryOffset <= leaveOffset && leaveOffset < ec.tryOffset + ec.tryLength)
			{
				return true;
			}
			if (ec.handlerOffsets <= leaveOffset && leaveOffset < ec.handlerOffsets + ec.handlerLength)
			{
				return false;
			}
		}
		return false;
	}

	void TransformContext::Add_leave(uint32_t targetOffset)
	{
		uint32_t leaveOffset = (uint32_t)(ip - ipBase);
		uint16_t firstHandlerIndex;
		if (FindFirstLeaveHandlerIndex(body.exceptionClauses, leaveOffset, targetOffset, firstHandlerIndex))
		{
			CreateAddIR(ir, LeaveEx);
			ir->target = targetOffset;
			ir->firstHandlerIndex = firstHandlerIndex;
			PushOffset(&ir->target);
		}
		else if (!IsLeaveInTryBlock(body.exceptionClauses, leaveOffset))
		{
			CreateAddIR(ir, LeaveEx_Directly);
			ir->target = targetOffset;
			PushOffset(&ir->target);
		}
		else
		{
			CreateAddIR(ir, BranchUncondition_4);
			ir->offset = targetOffset;
			PushOffset(&ir->offset);
		}
		PopAllStack();
		PushBranch(targetOffset);
	}

	uint16_t TransformContext::FindFirstThrowHandlerIndex(const std::vector<ExceptionClause>& exceptionClauses, uint32_t throwOffset)
	{
		uint16_t index = 0;
		for (const ExceptionClause& ec : exceptionClauses)
		{
			if (ec.flags == CorILExceptionClauseType::Finally || ec.flags == CorILExceptionClauseType::Exception || ec.flags == CorILExceptionClauseType::Filter)
			{
				if (ec.tryOffset <= throwOffset && throwOffset < ec.tryOffset + ec.tryLength)
					return index;
			}
			++index;
		}
		return index;
	}

	inline const Il2CppType* InflateIfNeeded(const Il2CppType* type, const Il2CppGenericContext* context, bool inflateMethodVars)
	{
		if (context == nullptr)
		{
			return type;
		}
		else
		{
			return il2cpp::metadata::GenericMetadata::InflateIfNeeded(type, context, inflateMethodVars);
		}
	}

#pragma region conv

#define CI_conv(dstTypeName, dstReduceType, dstTypeSize)   \
	Add_conv(dstTypeSize, EvalStackReduceDataType::dstReduceType, \
		HiOpcodeEnum::ConvertVarVar_i4_##dstTypeName,\
		HiOpcodeEnum::ConvertVarVar_i8_##dstTypeName,\
		HiOpcodeEnum::ConvertVarVar_f4_##dstTypeName,\
		HiOpcodeEnum::ConvertVarVar_f8_##dstTypeName);

#define CI_conv_un(dstTypeName, dstReduceType, dstTypeSize)   \
	Add_conv(dstTypeSize, EvalStackReduceDataType::dstReduceType, \
		HiOpcodeEnum::ConvertVarVar_u4_##dstTypeName,\
		HiOpcodeEnum::ConvertVarVar_u8_##dstTypeName,\
		HiOpcodeEnum::ConvertVarVar_f4_##dstTypeName,\
		HiOpcodeEnum::ConvertVarVar_f8_##dstTypeName);

#define CI_conv_ovf(dstTypeName, dstReduceType, dstTypeSize)   \
	Add_conv_ovf(dstTypeSize, EvalStackReduceDataType::dstReduceType, \
		HiOpcodeEnum::ConvertOverflowVarVar_i4_##dstTypeName,\
		HiOpcodeEnum::ConvertOverflowVarVar_i8_##dstTypeName,\
		HiOpcodeEnum::ConvertOverflowVarVar_f4_##dstTypeName,\
		HiOpcodeEnum::ConvertOverflowVarVar_f8_##dstTypeName);

#define CI_conv_un_ovf(dstTypeName, dstReduceType, dstTypeSize)   \
	Add_conv_ovf(dstTypeSize, EvalStackReduceDataType::dstReduceType, \
		HiOpcodeEnum::ConvertOverflowVarVar_u4_##dstTypeName,\
		HiOpcodeEnum::ConvertOverflowVarVar_u8_##dstTypeName,\
		HiOpcodeEnum::ConvertOverflowVarVar_f4_##dstTypeName,\
		HiOpcodeEnum::ConvertOverflowVarVar_f8_##dstTypeName);


#pragma endregion

#pragma region branch

#define CI_branch1(opName) IL2CPP_ASSERT(evalStackTop >= 2); \
brOffset = GetI1(ip+1); \
if (brOffset != 0) \
{\
	Add_bc(ipOffset, brOffset, 2, HiOpcodeEnum::BranchVarVar_##opName##_i4, HiOpcodeEnum::BranchVarVar_##opName##_i8, HiOpcodeEnum::BranchVarVar_##opName##_f4, HiOpcodeEnum::BranchVarVar_##opName##_f8); \
}\
else\
{\
	PopStackN(2);\
}\
ip += 2;

#define CI_branch4(opName) IL2CPP_ASSERT(evalStackTop >= 2); \
brOffset = GetI4LittleEndian(ip + 1); \
if (brOffset != 0) \
{ \
	Add_bc(ipOffset, brOffset, 5, HiOpcodeEnum::BranchVarVar_##opName##_i4, HiOpcodeEnum::BranchVarVar_##opName##_i8, HiOpcodeEnum::BranchVarVar_##opName##_f4, HiOpcodeEnum::BranchVarVar_##opName##_f8); \
}\
else \
{\
	PopStackN(2);\
}\
ip += 5;

#define PopBranch() { \
if (FindNextFlow()) \
{ \
    continue; \
} \
else \
{ \
    goto finish_transform; \
} \
}

#pragma endregion

#pragma region binop
#define CI_binOp(op) Add_binop(HiOpcodeEnum::BinOpVarVarVar_##op##_i4, HiOpcodeEnum::BinOpVarVarVar_##op##_i8, HiOpcodeEnum::BinOpVarVarVar_##op##_f4, HiOpcodeEnum::BinOpVarVarVar_##op##_f8);
#define CI_binOpUn(op) Add_binop(HiOpcodeEnum::BinOpVarVarVar_##op##_i4, HiOpcodeEnum::BinOpVarVarVar_##op##_i8, (HiOpcodeEnum)0, (HiOpcodeEnum)0);
#define CI_binOpOvf(op) Add_binop(HiOpcodeEnum::BinOpOverflowVarVarVar_##op##_i4, HiOpcodeEnum::BinOpOverflowVarVarVar_##op##_i8, (HiOpcodeEnum)0, (HiOpcodeEnum)0);
#define CI_binOpUnOvf(op) Add_binop(HiOpcodeEnum::BinOpOverflowVarVarVar_##op##_u4, HiOpcodeEnum::BinOpOverflowVarVarVar_##op##_u8, (HiOpcodeEnum)0, (HiOpcodeEnum)0);
#pragma endregion

#pragma region shiftop
#define	CI_binOpShift(op) Add_shiftop(HiOpcodeEnum::BitShiftBinOpVarVarVar_##op##_i4_i4, HiOpcodeEnum::BitShiftBinOpVarVarVar_##op##_i4_i8, HiOpcodeEnum::BitShiftBinOpVarVarVar_##op##_i8_i4, HiOpcodeEnum::BitShiftBinOpVarVarVar_##op##_i8_i8);
#pragma endregion

#define CI_compare(op) Add_compare(HiOpcodeEnum::CompOpVarVarVar_##op##_i4, HiOpcodeEnum::CompOpVarVarVar_##op##_i8, HiOpcodeEnum::CompOpVarVarVar_##op##_f4, HiOpcodeEnum::CompOpVarVarVar_##op##_f8);

#define CI_ldele(eleType, resultType) Add_ldelem(EvalStackReduceDataType::resultType, HiOpcodeEnum::GetArrayElementVarVar_##eleType);
#define CI_stele(eleType) Add_stelem(HiOpcodeEnum::SetArrayElementVarVar_##eleType);

	static const MethodInfo* FindRedirectCreateString(const MethodInfo* shareMethod)
	{
		int32_t paramCount = shareMethod->parameters_count;
		void* iter = nullptr;
		for (const MethodInfo* searchMethod; (searchMethod = il2cpp::vm::Class::GetMethods(il2cpp_defaults.string_class, &iter)) != nullptr;)
		{
			if (searchMethod->parameters_count != paramCount || std::strcmp(searchMethod->name, "CreateString"))
			{
				continue;
			}
			bool sigMatch = true;
			for (uint8_t i = 0; i < paramCount; i++)
			{
				if (!IsTypeEqual(GET_METHOD_PARAMETER_TYPE(searchMethod->parameters[i]), GET_METHOD_PARAMETER_TYPE(shareMethod->parameters[i])))
				{
					sigMatch = false;
					break;
				}
			}
			if (sigMatch)
			{
				return searchMethod;
			}
		}
		return nullptr;
	}

	static bool ShouldBeInlined(const MethodInfo* method, int32_t depth)
	{
		if (depth >= RuntimeConfig::GetMaxMethodInlineDepth())
		{
			return false;
		}
		return metadata::MethodBodyCache::IsInlineable(method);
	}


	void TransformContext::TransformBody(int32_t depth, int32_t localVarOffset, interpreter::InterpMethodInfo& result)
	{
		TransformBodyImpl(depth, localVarOffset);
		BuildInterpMethodInfo(result);
	}

	void TransformContext::TransformBodyImpl(int32_t depth, int32_t localVarOffset)
	{
#pragma region header

		const Il2CppGenericContext* genericContext = methodInfo->is_inflated ? &methodInfo->genericMethod->context : nullptr;
		const Il2CppGenericContainer* klassContainer = GetGenericContainerFromIl2CppType(&methodInfo->klass->byval_arg);
		const Il2CppGenericContainer* methodContainer = methodInfo->is_inflated ?
			(const Il2CppGenericContainer*)methodInfo->genericMethod->methodDefinition->genericContainerHandle :
			(const Il2CppGenericContainer*)methodInfo->genericContainerHandle;

		BasicBlockSpliter bbc(body);
		bbc.SplitBasicBlocks();


		splitOffsets = bbc.GetSplitOffsets();

		ip2bb = pool.NewNAny<IRBasicBlock*>(body.codeSize + 1);
		uint32_t lastSplitBegin = 0;

		for (uint32_t offset : splitOffsets)
		{
			IRBasicBlock* bb = pool.NewAny<IRBasicBlock>();
			bb->visited = false;
			bb->ilOffset = lastSplitBegin;
			irbbs.push_back(bb);
			for (uint32_t idx = lastSplitBegin; idx < offset; idx++)
			{
				ip2bb[idx] = bb;
			}
			lastSplitBegin = offset;
		}
		IRBasicBlock* endBb = pool.NewAny<IRBasicBlock>();
		*endBb = { true, false, body.codeSize, 0 };
		ip2bb[body.codeSize] = endBb;
		irbbs.push_back(endBb);

		curbb = irbbs[0];

		IL2CPP_ASSERT(lastSplitBegin == body.codeSize);

		bool instanceCall = IsInstanceMethod(methodInfo);
		actualParamCount = methodInfo->parameters_count + instanceCall;

		args = pool.NewNAny<ArgVarInfo>(actualParamCount);
		locals = pool.NewNAny<LocVarInfo>((int)body.localVars.size());
		evalStack = pool.NewNAny<EvalStackVarInfo>(body.maxStack + 100);

		nextFlowIdx = 0;

		totalArgSize = 0;
		{
			int32_t idx = 0;
			if (instanceCall)
			{
				ArgVarInfo& self = args[0];
				self.klass = methodInfo->klass;
				self.type = IS_CLASS_VALUE_TYPE(self.klass) ? &self.klass->this_arg : &self.klass->byval_arg;
				self.argOffset = idx;
				self.argLocOffset = localVarOffset + totalArgSize;
				totalArgSize += GetTypeValueStackObjectCount(self.type);
				idx = 1;
			}

			for (uint32_t i = 0; i < methodInfo->parameters_count; i++)
			{
				ArgVarInfo& arg = args[idx + i];
				arg.type = GET_METHOD_PARAMETER_TYPE(methodInfo->parameters[i]);
				arg.klass = il2cpp::vm::Class::FromIl2CppType(arg.type);
				arg.argOffset = idx + i;
				arg.argLocOffset = localVarOffset + totalArgSize;
				il2cpp::vm::Class::SetupFields(arg.klass);
				totalArgSize += GetTypeValueStackObjectCount(arg.type);
			}
		}

		totalArgLocalSize = totalArgSize;
		for (size_t i = 0; i < body.localVars.size(); i++)
		{
			LocVarInfo& local = locals[i];
			local.type = InflateIfNeeded(body.localVars[i], genericContext, true);
			local.klass = il2cpp::vm::Class::FromIl2CppType(local.type);
			il2cpp::vm::Class::SetupFields(local.klass);
			local.locOffset = localVarOffset + totalArgLocalSize;
			totalArgLocalSize += GetTypeValueStackObjectCount(local.type);
		}

		evalStackBaseOffset = localVarOffset + totalArgLocalSize;
		int32_t totalLocalSize = totalArgLocalSize - totalArgSize;

		maxStackSize = evalStackBaseOffset;
		curStackSize = evalStackBaseOffset;



		ipBase = body.ilcodes;
		ip = body.ilcodes;
		ipOffset = 0;

		evalStackTop = 0;
		prefixFlags = 0;

		int32_t argIdx = 0;
		int32_t varKst = 0;
		int64_t varKst8 = 0;
		int32_t brOffset = 0;

		shareMethod = nullptr;

		Token2RuntimeHandleMap tokenCache(64);

		bool inMethodInlining = depth > 0;

		hybridclr::metadata::PDBImage* pdbImage = image->GetPDBImage();
		ir2offsetMap = pdbImage && !inMethodInlining ? new IR2OffsetMap(body.codeSize) : nullptr;

		if (inMethodInlining)
		{
			if (instanceCall)
			{
				if (std::strcmp(methodInfo->name, ".ctor"))
				{
					CreateAddIR(irCheckNull, CheckThrowIfNullVar);
					irCheckNull->obj = args[0].argLocOffset;
				}
			}
			else
			{
				if (!IS_CCTOR_FINISH_OR_NO_CCTOR(methodInfo->klass))
				{
					CreateAddIR(irInitStaticCtor, InitClassStaticCtor);
					irInitStaticCtor->klass = (uint64_t)methodInfo->klass;
				}
			}
		}

		initLocals = (body.flags & (uint32_t)CorILMethodFormat::InitLocals) != 0;
		// init local vars
		if (initLocals && totalLocalSize > 0)
		{
			AddInst(CreateInitLocals(pool, totalLocalSize * sizeof(StackObject), locals[0].locOffset));
		}

		exClauses.resize_initialized(body.exceptionClauses.size());
		int clauseIdx = 0;
		for (ExceptionClause& ec : body.exceptionClauses)
		{
			InterpExceptionClause* iec = &exClauses[clauseIdx++];
			iec->flags = ec.flags;
			iec->tryBeginOffset = ec.tryOffset;
			iec->tryEndOffset = ec.tryOffset + ec.tryLength;
			iec->handlerBeginOffset = ec.handlerOffsets;
			iec->handlerEndOffset = ec.handlerOffsets + ec.handlerLength;
			PushOffset(&iec->tryBeginOffset);
			PushOffset(&iec->tryEndOffset);
			PushOffset(&iec->handlerBeginOffset);
			PushOffset(&iec->handlerEndOffset);
			if (ec.flags == CorILExceptionClauseType::Exception)
			{
				iec->filterBeginOffset = 0;
				iec->exKlass = image->GetClassFromToken(tokenCache, ec.classTokenOrFilterOffset, klassContainer, methodContainer, genericContext);
			}
			else if (ec.flags == CorILExceptionClauseType::Filter)
			{
				iec->filterBeginOffset = ec.classTokenOrFilterOffset;
				PushOffset(&iec->filterBeginOffset);
				iec->exKlass = nullptr;
			}
			else
			{
				IL2CPP_ASSERT(ec.classTokenOrFilterOffset == 0);
				iec->filterBeginOffset = 0;
				iec->exKlass = nullptr;
			}

			switch (ec.flags)
			{
			case CorILExceptionClauseType::Exception:
			{
				IRBasicBlock* bb = ip2bb[iec->handlerBeginOffset];
				IL2CPP_ASSERT(!bb->inPending);
				bb->inPending = true;
				FlowInfo* fi = pool.NewAny<FlowInfo>();
				fi->offset = ec.handlerOffsets;
				fi->curStackSize = evalStackBaseOffset + 1;
				fi->evalStack.push_back({ NATIVE_INT_REDUCE_TYPE, PTR_SIZE, evalStackBaseOffset });
				pendingFlows.push_back(fi);
				break;
			}
			case CorILExceptionClauseType::Filter:
			{
				IRBasicBlock* bb = ip2bb[iec->filterBeginOffset];
				IL2CPP_ASSERT(!bb->inPending);
				bb->inPending = true;
				{
					FlowInfo* fi = pool.NewAny<FlowInfo>();
					IL2CPP_ASSERT(ec.classTokenOrFilterOffset);
					fi->offset = ec.classTokenOrFilterOffset;
					fi->curStackSize = evalStackBaseOffset + 1;
					fi->evalStack.push_back({ NATIVE_INT_REDUCE_TYPE, PTR_SIZE, evalStackBaseOffset });
					pendingFlows.push_back(fi);
				}
				{
					FlowInfo* fi = pool.NewAny<FlowInfo>();
					IL2CPP_ASSERT(ec.handlerOffsets);
					fi->offset = ec.handlerOffsets;
					fi->curStackSize = evalStackBaseOffset + 1;
					fi->evalStack.push_back({ NATIVE_INT_REDUCE_TYPE, PTR_SIZE, evalStackBaseOffset });
					pendingFlows.push_back(fi);
				}

				break;
			}
			case CorILExceptionClauseType::Fault:
			case CorILExceptionClauseType::Finally:
			{
				IRBasicBlock* bb = ip2bb[iec->handlerBeginOffset];
				IL2CPP_ASSERT(!bb->inPending);
				bb->inPending = true;
				FlowInfo* fi = pool.NewAny<FlowInfo>();
				fi->offset = ec.handlerOffsets;
				fi->curStackSize = evalStackBaseOffset;
				pendingFlows.push_back(fi);
				break;
			}
			default:
			{
				RaiseExecutionEngineException("");
			}
			}
		}

#pragma endregion

		IRBasicBlock* lastBb = nullptr;
		for (;;)
		{
			ipOffset = (uint32_t)(ip - ipBase);
			curbb = ip2bb[ipOffset];
			if (curbb != lastBb)
			{
				if (curbb && !curbb->visited)
				{
					curbb->visited = true;
					lastBb = curbb;
				}
				else
				{
					PopBranch();
				}
			}

			switch ((OpcodeValue)*ip)
			{
			case OpcodeValue::NOP:
			{
				ip++;
				continue;
			}
			case OpcodeValue::BREAK:
			{
				ip++;
				continue;
			}
			case OpcodeValue::LDARG_0:
			{
				AddInst_ldarg(0);
				ip++;
				continue;
			}
			case OpcodeValue::LDARG_1:
			{
				AddInst_ldarg(1);
				ip++;
				continue;
			}
			case OpcodeValue::LDARG_2:
			{
				AddInst_ldarg(2);
				ip++;
				continue;
			}
			case OpcodeValue::LDARG_3:
			{
				AddInst_ldarg(3);
				ip++;
				continue;
			}

			case OpcodeValue::LDLOC_0:
			{
				CreateAddInst_ldloc(0);
				ip++;
				continue;
			}
			case OpcodeValue::LDLOC_1:
			{
				CreateAddInst_ldloc(1);
				ip++;
				continue;
			}
			case OpcodeValue::LDLOC_2:
			{
				CreateAddInst_ldloc(2);
				ip++;
				continue;
			}
			case OpcodeValue::LDLOC_3:
			{
				CreateAddInst_ldloc(3);
				ip++;
				continue;
			}
			case OpcodeValue::STLOC_0:
			{
				CreateAddInst_stloc(0);
				ip++;
				continue;
			}
			case OpcodeValue::STLOC_1:
			{
				CreateAddInst_stloc(1);
				ip++;
				continue;
			}
			case OpcodeValue::STLOC_2:
			{
				CreateAddInst_stloc(2);
				ip++;
				continue;
			}
			case OpcodeValue::STLOC_3:
			{
				CreateAddInst_stloc(3);
				ip++;
				continue;
			}
			case OpcodeValue::LDARG_S:
			{
				argIdx = ip[1];
				AddInst_ldarg(argIdx);
				ip += 2;
				continue;
			}
			case OpcodeValue::LDARGA_S:
			{
				argIdx = ip[1];
				AddInst_ldarga(argIdx);
				ip += 2;
				continue;
			}
			case OpcodeValue::STARG_S:
			{
				argIdx = ip[1];
				AddInst_starg(argIdx);
				ip += 2;
				continue;
			}
			case OpcodeValue::LDLOC_S:
			{
				argIdx = ip[1];
				CreateAddInst_ldloc(argIdx);
				ip += 2;
				continue;
			}
			case OpcodeValue::LDLOCA_S:
			{
				argIdx = ip[1];
				CreateAddInst_ldloca(argIdx);
				ip += 2;
				continue;
			}
			case OpcodeValue::STLOC_S:
			{
				argIdx = ip[1];
				CreateAddInst_stloc(argIdx);
				ip += 2;
				continue;
			}
			case OpcodeValue::LDNULL:
			{
				CreateAddIR(ir, LdnullVar);
				ir->dst = curStackSize;
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_M1:
			{
				CreateAddInst_ldc4(-1, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_0:
			{
				CreateAddInst_ldc4(0, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_1:
			{
				CreateAddInst_ldc4(1, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_2:
			{
				CreateAddInst_ldc4(2, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_3:
			{
				CreateAddInst_ldc4(3, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_4:
			{
				CreateAddInst_ldc4(4, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_5:
			{
				CreateAddInst_ldc4(5, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_6:
			{
				CreateAddInst_ldc4(6, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_7:
			{
				CreateAddInst_ldc4(7, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_8:
			{
				CreateAddInst_ldc4(8, EvalStackReduceDataType::I4);
				ip++;
				continue;
			}
			case OpcodeValue::LDC_I4_S:
			{
				varKst = GetI1(ip + 1);
				CreateAddInst_ldc4(varKst, EvalStackReduceDataType::I4);
				ip += 2;
				continue;
			}
			case OpcodeValue::LDC_I4:
			{
				varKst = GetI4LittleEndian(ip + 1);
				CreateAddInst_ldc4(varKst, EvalStackReduceDataType::I4);
				ip += 5;
				continue;
			}
			case OpcodeValue::LDC_I8:
			{
				varKst8 = GetI8LittleEndian(ip + 1);
				CreateAddInst_ldc8(varKst8, EvalStackReduceDataType::I8);
				ip += 9;
				continue;
			}
			case OpcodeValue::LDC_R4:
			{
				varKst = GetI4LittleEndian(ip + 1);
				CreateAddInst_ldc4(varKst, EvalStackReduceDataType::R4);
				ip += 5;
				continue;
			}
			case OpcodeValue::LDC_R8:
			{
				varKst8 = GetI8LittleEndian(ip + 1);
				CreateAddInst_ldc8(varKst8, EvalStackReduceDataType::R8);
				ip += 9;
				continue;
			}
			case OpcodeValue::DUP:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				EvalStackVarInfo& __eval = evalStack[evalStackTop - 1];
				IRCommon* ir = CreateAssignVarVar(pool, GetEvalStackNewTopOffset(), __eval.locOffset, __eval.byteSize);
				AddInst(ir);
				DuplicateStack();
				ip++;
				continue;
			}
			case OpcodeValue::POP:
			{
				PopStack();
				ip++;
				continue;
			}
			case OpcodeValue::JMP:
			{
				/*  auto& x = ir.jump;
					x.type = IRType::Jmp;
					x.methodToken = GetI4LittleEndian(ip + 1);
					irs.push_back(ir);
					ip += 5;*/
				RaiseNotSupportedException("not support jmp");
				continue;
			}
			case OpcodeValue::CALL:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				ip += 5;
				shareMethod = const_cast<MethodInfo*>(image->GetMethodInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(shareMethod);
			}

		LabelCall:
			{
				if (TryAddInstinctInstruments(shareMethod))
				{
					continue;
				}

#if HYBRIDCLR_UNITY_2021_OR_NEW
				if (!shareMethod->has_full_generic_sharing_signature)
#endif
				{
					if (!InitAndGetInterpreterDirectlyCallMethodPointer(shareMethod))
					{
						RaiseAOTGenericMethodNotInstantiatedException(shareMethod);
					}
				}

				bool resolvedIsInstanceMethod = IsInstanceMethod(shareMethod);
				int32_t resolvedTotalArgNum = shareMethod->parameters_count + resolvedIsInstanceMethod;
				int32_t needDataSlotNum = (resolvedTotalArgNum + 3) / 4;
				int32_t callArgEvalStackIdxBase = evalStackTop - resolvedTotalArgNum;
				uint32_t methodDataIndex = GetOrAddResolveDataIndex(shareMethod);

				if (hybridclr::metadata::IsInterpreterImplement(shareMethod))
				{
					uint16_t argBaseOffset = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);

					if (hybridclr::metadata::IsPInvokeMethod(shareMethod->flags))
					{
						Il2CppCallConvention callingConvention;
						Il2CppMethodPointer pinvokeMethodPointer = ResolvePInvokeMethod(shareMethod, callingConvention);
						if (!pinvokeMethodPointer)
						{
							TEMP_FORMAT(errMsg, "resolve PInvoke method fail. %s.%s::%s", methodInfo->klass->namespaze, methodInfo->klass->name, methodInfo->name);
							RaiseExecutionEngineException(errMsg);
						}
						Managed2NativeFunctionPointerCallMethod managed2NativeFunctionPointerMethod = InterpreterModule::GetManaged2NativeFunctionPointerMethodPointer(shareMethod, callingConvention);
						uint32_t pinvokeMethodPointerIdx = GetOrAddResolveDataIndex((void*)pinvokeMethodPointer);
						uint32_t managed2NativeFunctionPointerMethodIdx = GetOrAddResolveDataIndex((void*)managed2NativeFunctionPointerMethod);

						int32_t argIdxDataIndex;
						uint16_t* __argIdxs;
						AllocResolvedData(resolveDatas, needDataSlotNum, argIdxDataIndex, __argIdxs);

						IL2CPP_ASSERT(!resolvedIsInstanceMethod);

						for (uint8_t i = 0; i < shareMethod->parameters_count; i++)
						{
							int32_t curArgIdx = i;
							__argIdxs[curArgIdx] = evalStack[callArgEvalStackIdxBase + curArgIdx].locOffset;
						}
						if (IsReturnVoidMethod(shareMethod))
						{
							CreateAddIR(ir, CallPInvoke_void);
							ir->pinvokeMethodPointer = pinvokeMethodPointerIdx;
							ir->managed2NativeFunctionPointerMethod = managed2NativeFunctionPointerMethodIdx;
							ir->argIdxs = argIdxDataIndex;
						}
						else
						{
							interpreter::LocationDataType locDataType = GetLocationDataTypeByType(shareMethod->return_type);
							if (interpreter::IsNeedExpandLocationType(locDataType))
							{
								CreateAddIR(ir, CallPInvoke_ret_expand);
								ir->pinvokeMethodPointer = pinvokeMethodPointerIdx;
								ir->managed2NativeFunctionPointerMethod = managed2NativeFunctionPointerMethodIdx;
								ir->argIdxs = argIdxDataIndex;
								ir->ret = argBaseOffset;
								ir->retLocationType = (uint8_t)locDataType;
							}
							else
							{
								CreateAddIR(ir, CallPInvoke_ret);
								ir->pinvokeMethodPointer = pinvokeMethodPointerIdx;
								ir->managed2NativeFunctionPointerMethod = managed2NativeFunctionPointerMethodIdx;
								ir->argIdxs = argIdxDataIndex;
								ir->ret = argBaseOffset;
							}
						}
					}
					else if (ShouldBeInlined(shareMethod, depth) && TransformSubMethodBody(*this, shareMethod, depth + 1, argBaseOffset))
					{

					}
					else
					{
						if (IsReturnVoidMethod(shareMethod))
						{
							CreateAddIR(ir, CallInterp_void);
							ir->methodInfo = methodDataIndex;
							ir->argBase = argBaseOffset;
						}
						else
						{
							CreateAddIR(ir, CallInterp_ret);
							ir->methodInfo = methodDataIndex;
							ir->argBase = argBaseOffset;
							ir->ret = argBaseOffset;
						}
					}
					PopStackN(resolvedTotalArgNum);
					if (!IsReturnVoidMethod(shareMethod))
					{
						PushStackByType(shareMethod->return_type);
					}
					continue;
				}
#if HYBRIDCLR_UNITY_2021_OR_NEW
				if (!shareMethod->has_full_generic_sharing_signature)
#endif
				{
					if (TryAddCallCommonInstruments(shareMethod, methodDataIndex))
					{
						continue;
					}
				}



				Managed2NativeCallMethod managed2NativeMethod = InterpreterModule::GetManaged2NativeMethodPointer(shareMethod, false);
				IL2CPP_ASSERT(managed2NativeMethod);
				uint32_t managed2NativeMethodDataIdx = GetOrAddResolveDataIndex((void*)managed2NativeMethod);

				int32_t argIdxDataIndex;
				uint16_t* __argIdxs;
				AllocResolvedData(resolveDatas, needDataSlotNum, argIdxDataIndex, __argIdxs);

				if (resolvedIsInstanceMethod)
				{
					__argIdxs[0] = GetEvalStackOffset(callArgEvalStackIdxBase);
				}

				for (uint8_t i = 0; i < shareMethod->parameters_count; i++)
				{
					int32_t curArgIdx = i + resolvedIsInstanceMethod;
					__argIdxs[curArgIdx] = evalStack[callArgEvalStackIdxBase + curArgIdx].locOffset;
				}

				PopStackN(resolvedTotalArgNum);

				if (!IsReturnVoidMethod(shareMethod))
				{
					PushStackByType(shareMethod->return_type);
					interpreter::LocationDataType locDataType = GetLocationDataTypeByType(shareMethod->return_type);
					if (interpreter::IsNeedExpandLocationType(locDataType))
					{
						CreateAddIR(ir, CallNativeInstance_ret_expand);
						ir->type = resolvedIsInstanceMethod ? HiOpcodeEnum::CallNativeInstance_ret_expand : HiOpcodeEnum::CallNativeStatic_ret_expand;
						ir->managed2NativeMethod = managed2NativeMethodDataIdx;
						ir->methodInfo = methodDataIndex;
						ir->argIdxs = argIdxDataIndex;
						ir->ret = GetEvalStackTopOffset();
						ir->retLocationType = (uint8_t)locDataType;
					}
					else
					{
						CreateAddIR(ir, CallNativeInstance_ret);
						ir->type = resolvedIsInstanceMethod ? HiOpcodeEnum::CallNativeInstance_ret : HiOpcodeEnum::CallNativeStatic_ret;
						ir->managed2NativeMethod = managed2NativeMethodDataIdx;
						ir->methodInfo = methodDataIndex;
						ir->argIdxs = argIdxDataIndex;
						ir->ret = GetEvalStackTopOffset();
					}
				}
				else
				{
					CreateAddIR(ir, CallNativeInstance_void);
					ir->type = resolvedIsInstanceMethod ? HiOpcodeEnum::CallNativeInstance_void : HiOpcodeEnum::CallNativeStatic_void;
					ir->managed2NativeMethod = managed2NativeMethodDataIdx;
					ir->methodInfo = methodDataIndex;
					ir->argIdxs = argIdxDataIndex;
				}
				continue;
			}
			case OpcodeValue::CALLVIRT:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				ip += 5;
				shareMethod = image->GetMethodInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
			}
		LabelCallVir:
			{
				IL2CPP_ASSERT(shareMethod);
				IL2CPP_ASSERT(hybridclr::metadata::IsInstanceMethod(shareMethod));
				if ((!metadata::IsVirtualMethod(shareMethod->flags)) || metadata::IsSealed(shareMethod->flags))
				{
					goto LabelCall;
				}

				int32_t resolvedTotalArgNum = shareMethod->parameters_count + 1;
				int32_t callArgEvalStackIdxBase = evalStackTop - resolvedTotalArgNum;
				uint32_t methodDataIndex = GetOrAddResolveDataIndex(shareMethod);

				bool isMultiDelegate = IsChildTypeOfMulticastDelegate(shareMethod->klass);
				if (!isMultiDelegate && IsInterpreterMethod(shareMethod) && !IsInterface(shareMethod->klass->flags))
				{
					PopStackN(resolvedTotalArgNum);

					uint16_t argBaseOffset = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);
					if (IsReturnVoidMethod(shareMethod))
					{
						CreateAddIR(ir, CallInterpVirtual_void);
						ir->method = methodDataIndex;
						ir->argBase = argBaseOffset;
					}
					else
					{
						CreateAddIR(ir, CallInterpVirtual_ret);
						ir->method = methodDataIndex;
						ir->argBase = argBaseOffset;
						ir->ret = argBaseOffset;
						PushStackByType(shareMethod->return_type);
					}
					continue;
				}

				Managed2NativeCallMethod managed2NativeMethod = InterpreterModule::GetManaged2NativeMethodPointer(shareMethod, false);
				IL2CPP_ASSERT(managed2NativeMethod);
				uint32_t managed2NativeMethodDataIdx = GetOrAddResolveDataIndex((void*)managed2NativeMethod);


				int32_t needDataSlotNum = (resolvedTotalArgNum + 3) / 4;
				int32_t argIdxDataIndex;
				uint16_t* __argIdxs;
				AllocResolvedData(resolveDatas, needDataSlotNum, argIdxDataIndex, __argIdxs);

				__argIdxs[0] = GetEvalStackOffset(callArgEvalStackIdxBase);
				for (uint8_t i = 0; i < shareMethod->parameters_count; i++)
				{
					int32_t curArgIdx = i + 1;
					__argIdxs[curArgIdx] = evalStack[callArgEvalStackIdxBase + curArgIdx].locOffset;
				}

				PopStackN(resolvedTotalArgNum);

				const Il2CppType* returnType = shareMethod->return_type;
				int32_t retIdx;

				if (returnType->type != IL2CPP_TYPE_VOID)
				{
					PushStackByType(returnType);
					retIdx = GetEvalStackTopOffset();
				}
				else
				{
					retIdx = -1;
				}
				if (isMultiDelegate)
				{
					if (std::strcmp(shareMethod->name, "Invoke") == 0)
					{
						Managed2NativeCallMethod staticManaged2NativeMethod = InterpreterModule::GetManaged2NativeMethodPointer(shareMethod, true);
						IL2CPP_ASSERT(staticManaged2NativeMethod);
						uint32_t staticManaged2NativeMethodDataIdx = GetOrAddResolveDataIndex((void*)staticManaged2NativeMethod);
						if (retIdx < 0)
						{
							CreateAddIR(ir, CallDelegateInvoke_void);
							ir->managed2NativeStaticMethod = staticManaged2NativeMethodDataIdx;
							ir->managed2NativeInstanceMethod = managed2NativeMethodDataIdx;
							ir->argIdxs = argIdxDataIndex;
							ir->invokeParamCount = shareMethod->parameters_count;
						}
						else
						{
							interpreter::TypeDesc retDesc = GetTypeArgDesc(returnType);
							if (IsNeedExpandLocationType(retDesc.type))
							{
								CreateAddIR(ir, CallDelegateInvoke_ret_expand);
								ir->managed2NativeStaticMethod = staticManaged2NativeMethodDataIdx;
								ir->managed2NativeInstanceMethod = managed2NativeMethodDataIdx;
								ir->argIdxs = argIdxDataIndex;
								ir->ret = retIdx;
								ir->invokeParamCount = shareMethod->parameters_count;
								ir->retLocationType = (uint8_t)retDesc.type;
							}
							else
							{
								CreateAddIR(ir, CallDelegateInvoke_ret);
								ir->managed2NativeStaticMethod = staticManaged2NativeMethodDataIdx;
								ir->managed2NativeInstanceMethod = managed2NativeMethodDataIdx;
								ir->argIdxs = argIdxDataIndex;
								ir->ret = retIdx;
								ir->retTypeStackObjectSize = retDesc.stackObjectSize;
								ir->invokeParamCount = shareMethod->parameters_count;
							}
						}
						continue;
					}
					Il2CppMethodPointer directlyCallMethodPointer = InitAndGetInterpreterDirectlyCallMethodPointer(shareMethod);
					if (std::strcmp(shareMethod->name, "BeginInvoke") == 0)
					{
						if (IsInterpreterMethod(shareMethod) || directlyCallMethodPointer == nullptr)
						{
							CreateAddIR(ir, CallDelegateBeginInvoke);
							ir->methodInfo = methodDataIndex;
							ir->result = retIdx;
							ir->argIdxs = argIdxDataIndex;
							continue;
						}
					}
					else if (std::strcmp(shareMethod->name, "EndInvoke") == 0)
					{
						if (IsInterpreterMethod(shareMethod) || directlyCallMethodPointer == nullptr)
						{
							if (retIdx < 0)
							{
								CreateAddIR(ir, CallDelegateEndInvoke_void);
								ir->methodInfo = methodDataIndex;
								ir->asyncResult = __argIdxs[1];
							}
							else
							{
								CreateAddIR(ir, CallDelegateEndInvoke_ret);
								ir->methodInfo = methodDataIndex;
								ir->asyncResult = __argIdxs[1];
								ir->ret = retIdx;
							}
							continue;
						}
					}
				}

				if (retIdx < 0)
				{
					CreateAddIR(ir, CallVirtual_void);
					ir->managed2NativeMethod = managed2NativeMethodDataIdx;
					ir->methodInfo = methodDataIndex;
					ir->argIdxs = argIdxDataIndex;
				}
				else
				{
					interpreter::LocationDataType locDataType = GetLocationDataTypeByType(returnType);
					if (IsNeedExpandLocationType(locDataType))
					{
						CreateAddIR(ir, CallVirtual_ret_expand);
						ir->managed2NativeMethod = managed2NativeMethodDataIdx;
						ir->methodInfo = methodDataIndex;
						ir->argIdxs = argIdxDataIndex;
						ir->ret = retIdx;
						ir->retLocationType = (uint8_t)locDataType;
					}
					else
					{
						CreateAddIR(ir, CallVirtual_ret);
						ir->managed2NativeMethod = managed2NativeMethodDataIdx;
						ir->methodInfo = methodDataIndex;
						ir->argIdxs = argIdxDataIndex;
						ir->ret = retIdx;
					}
				}
				continue;
			}
			case OpcodeValue::CALLI:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);

				ResolveStandAloneMethodSig methodSig;
				image->GetStandAloneMethodSigFromToken(token, klassContainer, methodContainer, genericContext, methodSig);
				if (IsPrologExplicitThis(methodSig.flags))
				{
					RaiseNotSupportedException("not support StandAloneMethodSig flags:EXPLICITTHIS");
				}

				int32_t methodIdx = GetEvalStackTopOffset();
				//uint32_t methodDataIndex = GetOrAddResolveDataIndex(shareMethod);
				Managed2NativeCallMethod managed2NativeMethod = InterpreterModule::GetManaged2NativeMethodPointer(methodSig);
				Managed2NativeFunctionPointerCallMethod managed2NativeFunctionPointerMethod = InterpreterModule::GetManaged2NativeFunctionPointerMethodPointer(methodSig);
				IL2CPP_ASSERT(managed2NativeMethod);
				uint32_t managed2NativeMethodDataIdx = GetOrAddResolveDataIndex((void*)managed2NativeMethod);
				uint32_t managed2NativeFunctionPointerMethodDataIdx = GetOrAddResolveDataIndex((void*)managed2NativeFunctionPointerMethod);
				bool hasThis = metadata::IsPrologHasThis(methodSig.flags);

				int32_t resolvedTotalArgNum = (int32_t)methodSig.params.size() + hasThis;
				int32_t needDataSlotNum = (resolvedTotalArgNum + 3) / 4;
				int32_t argIdxDataIndex;
				uint16_t* __argIdxs;

				// we need at least one slot for argBasePtr when resolvedTotalArgNum == 0
				AllocResolvedData(resolveDatas, std::max(needDataSlotNum, 1), argIdxDataIndex, __argIdxs);

				int32_t callArgEvalStackIdxBase = evalStackTop - resolvedTotalArgNum - 1 /*funtion ptr*/;

				// CallInd need know the argBasePtr when resolvedTotalArgNum == 0
				if (needDataSlotNum == 0)
				{
					__argIdxs[0] = evalStack[callArgEvalStackIdxBase].locOffset;
				}

				if (hasThis)
				{
					__argIdxs[0] = evalStack[callArgEvalStackIdxBase].locOffset;
				}

				for (size_t i = 0; i < methodSig.params.size(); i++)
				{
					size_t curArgIdx = i + hasThis;
					__argIdxs[curArgIdx] = evalStack[callArgEvalStackIdxBase + curArgIdx].locOffset;
				}

				PopStackN(resolvedTotalArgNum + 1);

				if (!IsVoidType(methodSig.returnType))
				{
					PushStackByType(methodSig.returnType);
					interpreter::LocationDataType locDataType = GetLocationDataTypeByType(methodSig.returnType);
					if (interpreter::IsNeedExpandLocationType(locDataType))
					{
						CreateAddIR(ir, CallInd_ret_expand);
						ir->managed2NativeMethod = managed2NativeMethodDataIdx;
						ir->managed2NativeFunctionPointerMethod = managed2NativeFunctionPointerMethodDataIdx;
						ir->methodInfo = methodIdx;
						ir->argIdxs = argIdxDataIndex;
						ir->ret = GetEvalStackTopOffset();
						ir->retLocationType = (uint8_t)locDataType;
					}
					else
					{
						CreateAddIR(ir, CallInd_ret);
						ir->managed2NativeMethod = managed2NativeMethodDataIdx;
						ir->managed2NativeFunctionPointerMethod = managed2NativeFunctionPointerMethodDataIdx;
						ir->methodInfo = methodIdx;
						ir->argIdxs = argIdxDataIndex;
						ir->ret = GetEvalStackTopOffset();
					}
				}
				else
				{
					CreateAddIR(ir, CallInd_void);
					ir->managed2NativeMethod = managed2NativeMethodDataIdx;
					ir->managed2NativeFunctionPointerMethod = managed2NativeFunctionPointerMethodDataIdx;
					ir->methodInfo = methodIdx;
					ir->argIdxs = argIdxDataIndex;
				}

				ip += 5;
				continue;
			}
			case OpcodeValue::RET:
			{
				bool isVoidReturnType = methodInfo->return_type->type == IL2CPP_TYPE_VOID;
				if (inMethodInlining)
				{
					if (!isVoidReturnType)
					{
						uint16_t retVarIdx = GetEvalStackTopOffset();
						if (retVarIdx != localVarOffset)
						{
							IRCommon* ir = CreateAssignVarVar(pool, localVarOffset, retVarIdx, GetTypeValueSize(methodInfo->return_type));
							AddInst(ir);
						}
					}
				}
				else if (isVoidReturnType)
				{
					CreateAddIR(ir, RetVar_void);
				}
				else
				{
					// ms.ret = nullptr;
					IL2CPP_ASSERT(evalStackTop == 1);
					int32_t size = GetTypeValueSize(methodInfo->return_type);
					switch (size)
					{
					case 1:
					{
						CreateAddIR(ir, RetVar_ret_1);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 2:
					{
						CreateAddIR(ir, RetVar_ret_2);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 4:
					{
						CreateAddIR(ir, RetVar_ret_4);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 8:
					{
						CreateAddIR(ir, RetVar_ret_8);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 12:
					{
						CreateAddIR(ir, RetVar_ret_12);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 16:
					{
						CreateAddIR(ir, RetVar_ret_16);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 20:
					{
						CreateAddIR(ir, RetVar_ret_20);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 24:
					{
						CreateAddIR(ir, RetVar_ret_24);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 28:
					{
						CreateAddIR(ir, RetVar_ret_28);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					case 32:
					{
						CreateAddIR(ir, RetVar_ret_32);
						ir->ret = GetEvalStackTopOffset();
						break;
					}
					default:
					{
						CreateAddIR(ir, RetVar_ret_n);
						ir->ret = GetEvalStackTopOffset();
						ir->size = size;
						break;
					}
					}
				}
				ip++;
				PopBranch();
				continue;
			}
			case OpcodeValue::BR_S:
			{
				brOffset = GetI1(ip + 1);
				if (brOffset != 0)
				{
					int32_t targetOffset = ipOffset + brOffset + 2;
					CreateAddIR(ir, BranchUncondition_4);
					ir->offset = targetOffset;
					PushOffset(&ir->offset);

					PushBranch(targetOffset);
					PopBranch();
				}
				else
				{
					ip += 2;
				}
				continue;
			}
			case OpcodeValue::LEAVE_S:
			{
				brOffset = GetI1(ip + 1);
				int32_t targetOffset = ipOffset + brOffset + 2;
				Add_leave((uint32_t)targetOffset);
				PopBranch();
				continue;
			}
			case OpcodeValue::BRFALSE_S:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				brOffset = GetI1(ip + 1);
				if (brOffset != 0)
				{
					int32_t targetOffset = ipOffset + brOffset + 2;
					Add_brtruefalse(false, targetOffset);
				}
				else
				{
					PopStack();
				}
				ip += 2;
				continue;
			}
			case OpcodeValue::BRTRUE_S:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				brOffset = GetI1(ip + 1);
				if (brOffset != 0)
				{
					int32_t targetOffset = ipOffset + brOffset + 2;
					Add_brtruefalse(true, targetOffset);
				}
				else
				{
					PopStack();
				}
				ip += 2;
				continue;
			}
			case OpcodeValue::BEQ_S:
			{
				CI_branch1(Ceq);
				continue;
			}
			case OpcodeValue::BGE_S:
			{
				CI_branch1(Cge);
				continue;
			}
			case OpcodeValue::BGT_S:
			{
				CI_branch1(Cgt);
				continue;
			}
			case OpcodeValue::BLE_S:
			{
				CI_branch1(Cle);
				continue;
			}
			case OpcodeValue::BLT_S:
			{
				CI_branch1(Clt);
				continue;
			}
			case OpcodeValue::BNE_UN_S:
			{
				CI_branch1(CneUn);
				continue;
			}
			case OpcodeValue::BGE_UN_S:
			{
				CI_branch1(CgeUn);
				continue;
			}
			case OpcodeValue::BGT_UN_S:
			{
				CI_branch1(CgtUn);
				continue;
			}
			case OpcodeValue::BLE_UN_S:
			{
				CI_branch1(CleUn);
				continue;
			}
			case OpcodeValue::BLT_UN_S:
			{
				CI_branch1(CltUn);
				continue;
			}
			case OpcodeValue::BR:
			{
				brOffset = GetI4LittleEndian(ip + 1);
				if (brOffset != 0)
				{
					int32_t targetOffset = ipOffset + brOffset + 5;
					CreateAddIR(ir, BranchUncondition_4);
					ir->offset = targetOffset;
					PushOffset(&ir->offset);

					PushBranch(targetOffset);
					PopBranch();
				}
				else
				{
					ip += 5;
				}
				continue;
			}
			case OpcodeValue::LEAVE:
			{
				brOffset = GetI4LittleEndian(ip + 1);
				int32_t targetOffset = ipOffset + brOffset + 5;
				Add_leave((uint32_t)targetOffset);
				PopBranch();
				continue;
			}
			case OpcodeValue::BRFALSE:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				brOffset = GetI4LittleEndian(ip + 1);
				if (brOffset != 0)
				{
					int32_t targetOffset = ipOffset + brOffset + 5;
					Add_brtruefalse(false, targetOffset);
				}
				else
				{
					PopStack();
				}
				ip += 5;
				continue;
			}
			case OpcodeValue::BRTRUE:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				brOffset = GetI4LittleEndian(ip + 1);
				if (brOffset != 0)
				{
					int32_t targetOffset = ipOffset + brOffset + 5;
					Add_brtruefalse(true, targetOffset);
				}
				else
				{
					PopStack();
				}
				ip += 5;
				continue;
			}

			case OpcodeValue::BEQ:
			{
				CI_branch4(Ceq);
				continue;
			}
			case OpcodeValue::BGE:
			{
				CI_branch4(Cge);
				continue;
			}
			case OpcodeValue::BGT:
			{
				CI_branch4(Cgt);
				continue;
			}
			case OpcodeValue::BLE:
			{
				CI_branch4(Cle);
				continue;
			}
			case OpcodeValue::BLT:
			{
				CI_branch4(Clt);
				continue;
			}
			case OpcodeValue::BNE_UN:
			{
				CI_branch4(CneUn);
				continue;
			}
			case OpcodeValue::BGE_UN:
			{
				CI_branch4(CgeUn);
				continue;
			}
			case OpcodeValue::BGT_UN:
			{
				CI_branch4(CgtUn);
				continue;
			}
			case OpcodeValue::BLE_UN:
			{
				CI_branch4(CleUn);
				continue;
			}
			case OpcodeValue::BLT_UN:
			{
				CI_branch4(CltUn);
				continue;
			}
			case OpcodeValue::SWITCH:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				CreateIR(ir, BranchSwitch);

				uint32_t switchValue = GetEvalStackTopOffset();
				uint32_t n = (uint32_t)GetI4LittleEndian(ip + 1);
				ir->value = GetEvalStackTopOffset();
				ir->caseNum = n;

				int32_t* caseOffsets;
				AllocResolvedData(resolveDatas, (n + 1) / 2, *(int32_t*)&ir->caseOffsets, caseOffsets);
				PopStack();

				uint32_t instrSize = 1 + (n + 1) * 4;
				const byte* caseOffsetIp = ip + 5;

				// remove this instrument if all target is same to default.
				uint32_t nextInstrumentOffset = ipOffset + instrSize;
				bool anyNotDefaultCase = false;
				for (uint32_t caseIdx = 0; caseIdx < n; caseIdx++)
				{
					int32_t targetOffset = (int32_t)(nextInstrumentOffset + GetI4LittleEndian(caseOffsetIp + caseIdx * 4));
					caseOffsets[caseIdx] = targetOffset;
					//PushOffset(caseOffsets + caseIdx);
					if (targetOffset != nextInstrumentOffset)
					{
						anyNotDefaultCase = true;
						PushBranch(targetOffset);
					}
				}
				if (anyNotDefaultCase)
				{
					switchOffsetsInResolveData.push_back({ ir->caseOffsets, n });
					AddInst(ir);
				}
				ip += instrSize;
				continue;
			}
			case OpcodeValue::LDIND_I1:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_i1, EvalStackReduceDataType::I4);
				continue;
			}
			case OpcodeValue::LDIND_U1:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_u1, EvalStackReduceDataType::I4);
				continue;
			}
			case OpcodeValue::LDIND_I2:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_i2, EvalStackReduceDataType::I4);
				continue;
			}
			case OpcodeValue::LDIND_U2:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_u2, EvalStackReduceDataType::I4);
				continue;
			}
			case OpcodeValue::LDIND_I4:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_i4, EvalStackReduceDataType::I4);
				continue;
			}
			case OpcodeValue::LDIND_U4:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_u4, EvalStackReduceDataType::I4);
				continue;
			}
			case OpcodeValue::LDIND_I8:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_i8, EvalStackReduceDataType::I8);
				continue;
			}
			case OpcodeValue::LDIND_I:
			{
				Add_ldind(ARCH_ARGUMENT(HiOpcodeEnum::LdindVarVar_i4, HiOpcodeEnum::LdindVarVar_i8), NATIVE_INT_REDUCE_TYPE);
				continue;
			}
			case OpcodeValue::LDIND_R4:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_f4, EvalStackReduceDataType::R4);
				continue;
			}
			case OpcodeValue::LDIND_R8:
			{
				Add_ldind(HiOpcodeEnum::LdindVarVar_f8, EvalStackReduceDataType::R8);
				continue;
			}
			case OpcodeValue::LDIND_REF:
			{
				Add_ldind(ARCH_ARGUMENT(HiOpcodeEnum::LdindVarVar_i4, HiOpcodeEnum::LdindVarVar_i8), NATIVE_INT_REDUCE_TYPE);
				continue;
			}
			case OpcodeValue::STIND_REF:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_ref);
				continue;
			}
			case OpcodeValue::STIND_I1:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_i1);
				continue;
			}
			case OpcodeValue::STIND_I2:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_i2);
				continue;
			}
			case OpcodeValue::STIND_I4:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_i4);
				continue;
			}
			case OpcodeValue::STIND_I8:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_i8);
				continue;
			}
			case OpcodeValue::STIND_R4:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_f4);
				continue;
			}
			case OpcodeValue::STIND_R8:
			{
				Add_stind(HiOpcodeEnum::StindVarVar_f8);
				continue;
			}
			case OpcodeValue::ADD:
			{
				CI_binOp(Add);
				continue;
			}
			case OpcodeValue::SUB:
			{
				CI_binOp(Sub);
				continue;
			}
			case OpcodeValue::MUL:
			{
				CI_binOp(Mul);
				continue;
			}
			case OpcodeValue::DIV:
			{
				CI_binOp(Div);
				continue;
			}
			case OpcodeValue::DIV_UN:
			{
				CI_binOpUn(DivUn);
				continue;
			}
			case OpcodeValue::REM:
			{
				CI_binOp(Rem);
				continue;
			}
			case OpcodeValue::REM_UN:
			{
				CI_binOpUn(RemUn);
				continue;
			}
			case OpcodeValue::AND:
			{
				CI_binOpUn(And);
				continue;
			}
			case OpcodeValue::OR:
			{
				CI_binOpUn(Or);
				continue;
			}
			case OpcodeValue::XOR:
			{
				CI_binOpUn(Xor);
				continue;
			}
			case OpcodeValue::SHL:
			{
				CI_binOpShift(Shl);
				continue;
			}
			case OpcodeValue::SHR:
			{
				CI_binOpShift(Shr);
				continue;
			}
			case OpcodeValue::SHR_UN:
			{
				CI_binOpShift(ShrUn);
				continue;
			}
			case OpcodeValue::NEG:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				EvalStackVarInfo& op = evalStack[evalStackTop - 1];
				CreateAddIR(ir, UnaryOpVarVar_Neg_i4);
				ir->dst = ir->src = op.locOffset;

				switch (op.reduceType)
				{
				case EvalStackReduceDataType::I4:
				{
					ir->type = HiOpcodeEnum::UnaryOpVarVar_Neg_i4;
					break;
				}
				case EvalStackReduceDataType::I8:
				{
					ir->type = HiOpcodeEnum::UnaryOpVarVar_Neg_i8;
					break;
				}
				case EvalStackReduceDataType::R4:
				{
					ir->type = HiOpcodeEnum::UnaryOpVarVar_Neg_f4;
					break;
				}
				case EvalStackReduceDataType::R8:
				{
					ir->type = HiOpcodeEnum::UnaryOpVarVar_Neg_f8;
					break;
				}
				default:
				{
					RaiseExecutionEngineException("NEG not suppport type");
					break;
				}
				}
				ip++;
				continue;
			}
			case OpcodeValue::NOT:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				EvalStackVarInfo& op = evalStack[evalStackTop - 1];
				CreateAddIR(ir, UnaryOpVarVar_Not_i4);
				ir->dst = ir->src = op.locOffset;

				switch (op.reduceType)
				{
				case EvalStackReduceDataType::I4:
				{
					ir->type = HiOpcodeEnum::UnaryOpVarVar_Not_i4;
					break;
				}
				case EvalStackReduceDataType::I8:
				{
					ir->type = HiOpcodeEnum::UnaryOpVarVar_Not_i8;
					break;
				}
				default:
				{
					RaiseExecutionEngineException("NOT not suppport type");
					break;
				}
				}
				ip++;
				continue;
			}
			case OpcodeValue::CONV_I1:
			{
				CI_conv(i1, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_I2:
			{
				CI_conv(i2, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_I4:
			{
				CI_conv(i4, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_I8:
			{
				CI_conv(i8, I8, 8);
				continue;
			}
			case OpcodeValue::CONV_R4:
			{
				CI_conv(f4, R4, 4);
				continue;
			}
			case OpcodeValue::CONV_R8:
			{
				CI_conv(f8, R8, 8);
				continue;
			}
			case OpcodeValue::CONV_U4:
			{
				CI_conv(u4, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_U8:
			{
				CI_conv(u8, I8, 8);
				continue;
			}
			case OpcodeValue::CPOBJ:
			{
				IL2CPP_ASSERT(evalStackTop >= 2);
				EvalStackVarInfo& dst = evalStack[evalStackTop - 2];
				EvalStackVarInfo& src = evalStack[evalStackTop - 1];

				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(objKlass);
				if (IS_CLASS_VALUE_TYPE(objKlass))
				{
					uint32_t size = GetTypeValueSize(objKlass);
					if (!HYBRIDCLR_ENABLE_WRITE_BARRIERS || !objKlass->has_references)
					{
						switch (size)
						{
						case 1:
						{
							CreateAddIR(ir, CpobjVarVar_1);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 2:
						{
							CreateAddIR(ir, CpobjVarVar_2);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 4:
						{
							CreateAddIR(ir, CpobjVarVar_4);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 8:
						{
							CreateAddIR(ir, CpobjVarVar_8);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 12:
						{
							CreateAddIR(ir, CpobjVarVar_12);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 16:
						{
							CreateAddIR(ir, CpobjVarVar_16);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						default:
						{
							CreateAddIR(ir, CpobjVarVar_n_4);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							ir->size = size;
							break;
						}
						}
					}
					else
					{
						CreateAddIR(ir, CpobjVarVar_WriteBarrier_n_4);
						ir->dst = dst.locOffset;
						ir->src = src.locOffset;
						ir->size = size;
					}
				}
				else
				{
					CreateAddIR(ir, CpobjVarVar_ref);
					ir->dst = dst.locOffset;
					ir->src = src.locOffset;
				}

				PopStackN(2);
				ip += 5;
				continue;
			}
			case OpcodeValue::LDOBJ:
			{
				IL2CPP_ASSERT(evalStackTop >= 1);
				EvalStackVarInfo& top = evalStack[evalStackTop - 1];

				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(objKlass);
				LocationDescInfo desc = ComputLocationDescInfo(&objKlass->byval_arg);

				switch (desc.type)
				{
				case LocationDescType::I1:
				{
					CreateAddIR(ir, LdindVarVar_i1);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::U1:
				{
					CreateAddIR(ir, LdindVarVar_u1);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::I2:
				{
					CreateAddIR(ir, LdindVarVar_i2);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::U2:
				{
					CreateAddIR(ir, LdindVarVar_u2);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::I4:
				{
					CreateAddIR(ir, LdindVarVar_i4);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::I8:
				{
					CreateAddIR(ir, LdindVarVar_i8);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::Ref:
				{
					CreateAddIR(ir, LdobjVarVar_ref);
					ir->dst = ir->src = top.locOffset;
					break;
				}
				case LocationDescType::S:
				case LocationDescType::StructContainsRef:
				{
					uint32_t size = GetTypeValueSize(objKlass);
					switch (size)
					{
					case 1:
					{
						CreateAddIR(ir, LdobjVarVar_1);
						ir->dst = ir->src = top.locOffset;
						break;
					}
					case 2:
					{
						CreateAddIR(ir, LdobjVarVar_2);
						ir->dst = ir->src = top.locOffset;
						break;
					}
					case 4:
					{
						CreateAddIR(ir, LdobjVarVar_4);
						ir->dst = ir->src = top.locOffset;
						break;
					}
					case 8:
					{
						CreateAddIR(ir, LdobjVarVar_8);
						ir->dst = ir->src = top.locOffset;
						break;
					}
					case 12:
					{
						CreateAddIR(ir, LdobjVarVar_12);
						ir->dst = ir->src = top.locOffset;
						break;
					}
					case 16:
					{
						CreateAddIR(ir, LdobjVarVar_16);
						ir->dst = ir->src = top.locOffset;
						break;
					}
					default:
					{
						CreateAddIR(ir, LdobjVarVar_n_4);
						ir->dst = ir->src = top.locOffset;
						ir->size = size;
						break;
					}
					}
					break;
				}
				default:
				{
					RaiseExecutionEngineException("field");
				}
				}

				PopStack();
				PushStackByType(&objKlass->byval_arg);
				InsertMemoryBarrier();
				ResetPrefixFlags();
				ip += 5;
				continue;
			}
			case OpcodeValue::LDSTR:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppString* str = image->GetIl2CppUserStringFromRawIndex(DecodeTokenRowIndex(token));
				uint32_t dataIdx = GetOrAddResolveDataIndex(str);

				CreateAddIR(ir, LdstrVar);
				ir->dst = GetEvalStackNewTopOffset();
				ir->str = dataIdx;
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

				ip += 5;
				continue;
			}
			case OpcodeValue::NEWOBJ:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				ip += 5;
				// TODO token cache optimistic
				shareMethod = const_cast<MethodInfo*>(image->GetMethodInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(shareMethod);
				IL2CPP_ASSERT(!std::strcmp(shareMethod->name, ".ctor"));
				IL2CPP_ASSERT(hybridclr::metadata::IsInstanceMethod(shareMethod));
				if (TryAddInstinctCtorInstruments(shareMethod))
				{
					continue;
				}
				Il2CppClass* klass = shareMethod->klass;
				uint8_t paramCount = shareMethod->parameters_count;
				if (klass == il2cpp_defaults.string_class)
				{
					const MethodInfo* searchMethod = FindRedirectCreateString(shareMethod);
					if (searchMethod)
					{
						// insert nullptr to eval stack
						int32_t thisIdx = evalStackTop - paramCount;
						for (int32_t i = evalStackTop; i > thisIdx; i--)
						{
							evalStack[i] = evalStack[i - 1];
						}
						// locOffset of this is not important. You only need make sure the value is not equal to nullptr.
						evalStack[thisIdx] = { NATIVE_INT_REDUCE_TYPE, PTR_SIZE, GetEvalStackOffset(thisIdx) };
						++evalStackTop;
						shareMethod = searchMethod;
						goto LabelCall;
					}
				}

				if (!InitAndGetInterpreterDirectlyCallMethodPointer(shareMethod))
				{
					RaiseAOTGenericMethodNotInstantiatedException(shareMethod);
				}

				int32_t callArgEvalStackIdxBase = evalStackTop - shareMethod->parameters_count;
				IL2CPP_ASSERT(callArgEvalStackIdxBase >= 0);
				uint16_t objIdx = GetEvalStackOffset(callArgEvalStackIdxBase);

				int32_t resolvedTotalArgNum = shareMethod->parameters_count + 1;

				uint32_t methodDataIndex = GetOrAddResolveDataIndex(shareMethod);

				if (IsInterpreterImplement(shareMethod))
				{
					if (IS_CLASS_VALUE_TYPE(klass))
					{
						CreateAddIR(ir, NewValueTypeInterpVar);
						ir->obj = GetEvalStackOffset(callArgEvalStackIdxBase);
						ir->method = methodDataIndex;
						ir->argBase = ir->obj;
						ir->argStackObjectNum = curStackSize - ir->argBase;
						// IL2CPP_ASSERT(ir->argStackObjectNum > 0); may 0
						PopStackN(shareMethod->parameters_count);
						PushStackByType(&klass->byval_arg);
						ir->ctorFrameBase = GetEvalStackNewTopOffset();
						maxStackSize = std::max(maxStackSize, curStackSize + ir->argStackObjectNum + 1);
					}
					else
					{
						if (shareMethod->parameters_count == 0)
						{
							CreateAddIR(ir, NewClassInterpVar_Ctor_0);
							ir->obj = GetEvalStackNewTopOffset();
							ir->method = methodDataIndex;
							PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
							ir->ctorFrameBase = GetEvalStackNewTopOffset();
							maxStackSize = std::max(maxStackSize, curStackSize + 1); // 1 for __this
						}
						else
						{
							CreateAddIR(ir, NewClassInterpVar);
							ir->obj = GetEvalStackOffset(callArgEvalStackIdxBase);
							ir->method = methodDataIndex;
							ir->argBase = ir->obj;
							ir->argStackObjectNum = curStackSize - ir->argBase;
							IL2CPP_ASSERT(ir->argStackObjectNum > 0);
							PopStackN(shareMethod->parameters_count);
							PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
							ir->ctorFrameBase = GetEvalStackNewTopOffset();
							maxStackSize = std::max(maxStackSize, curStackSize + ir->argStackObjectNum + 1); // 1 for __this
						}
					}
					IL2CPP_ASSERT(maxStackSize < MAX_STACK_SIZE);
					continue;
				}

				int32_t needDataSlotNum = (resolvedTotalArgNum + 3) / 4;
				Managed2NativeCallMethod managed2NativeMethod = InterpreterModule::GetManaged2NativeMethodPointer(shareMethod, false);
				IL2CPP_ASSERT((void*)managed2NativeMethod);
				//uint32_t managed2NativeMethodDataIdx = GetOrAddResolveDataIndex(managed2NativeMethod);



				int32_t argIdxDataIndex;
				uint16_t* __argIdxs;
				AllocResolvedData(resolveDatas, needDataSlotNum, argIdxDataIndex, __argIdxs);
				//
				// arg1, arg2, arg3 ..., argN, obj or valuetype, __this(= obj or ref valuetype)
				// obj on new top
				PushStackByType(&klass->byval_arg);
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				__argIdxs[0] = GetEvalStackTopOffset(); // this

				for (uint8_t i = 0; i < shareMethod->parameters_count; i++)
				{
					int32_t curArgIdx = i + 1;
					__argIdxs[curArgIdx] = evalStack[callArgEvalStackIdxBase + i].locOffset;
				}
				PopStackN(resolvedTotalArgNum + 1); // args + obj + this
				PushStackByType(&klass->byval_arg);
				CreateAddIR(ir, NewClassVar);
				ir->type = IS_CLASS_VALUE_TYPE(shareMethod->klass) ? HiOpcodeEnum::NewValueTypeVar : HiOpcodeEnum::NewClassVar;
				ir->managed2NativeMethod = GetOrAddResolveDataIndex((void*)managed2NativeMethod);
				ir->method = methodDataIndex;
				ir->argIdxs = argIdxDataIndex;
				ir->obj = objIdx;

				continue;
			}
			case OpcodeValue::CASTCLASS:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(objKlass);

				if (il2cpp::vm::Class::IsNullable(objKlass))
				{
					objKlass = il2cpp::vm::Class::GetNullableArgument(objKlass);
				}
				uint32_t klassDataIdx = GetOrAddResolveDataIndex(objKlass);

				CreateAddIR(ir, CastclassVar);
				ir->obj = GetEvalStackTopOffset();
				ir->klass = klassDataIdx;
				ip += 5;
				continue;
			}
			case OpcodeValue::ISINST:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(objKlass);

				if (il2cpp::vm::Class::IsNullable(objKlass))
				{
					objKlass = il2cpp::vm::Class::GetNullableArgument(objKlass);
				}
				uint32_t klassDataIdx = GetOrAddResolveDataIndex(objKlass);

				CreateAddIR(ir, IsInstVar);
				ir->obj = GetEvalStackTopOffset();
				ir->klass = klassDataIdx;
				ip += 5;
				continue;
			}
			case OpcodeValue::CONV_R_UN:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				EvalStackVarInfo& top = evalStack[evalStackTop - 1];
				switch (top.reduceType)
				{
				case EvalStackReduceDataType::I4:
				{
					CreateAddIR(ir, ConvertVarVar_u4_f8);
					ir->dst = ir->src = GetEvalStackTopOffset();
					break;
				}
				case EvalStackReduceDataType::I8:
				{
					CreateAddIR(ir, ConvertVarVar_u8_f8);
					ir->dst = ir->src = GetEvalStackTopOffset();
					break;
				}
				default:
				{
					RaiseExecutionEngineException("");
					break;
				}
				}
				top.reduceType = EvalStackReduceDataType::R8;
				top.byteSize = 8;
				ip++;
				continue;
			}
			case OpcodeValue::UNBOX:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				//if (il2cpp::vm::Class::IsNullable(objKlass))
				//{
				//    objKlass = il2cpp::vm::Class::GetNullableArgument(objKlass);
				//}
				CreateAddIR(ir, UnBoxVarVar);
				ir->addr = ir->obj = GetEvalStackTopOffset();
				ir->klass = GetOrAddResolveDataIndex(objKlass);

				PopStack();
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

				ip += 5;
				continue;
			}
			case OpcodeValue::THROW:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				CreateAddIR(ir, ThrowEx);
				ir->exceptionObj = GetEvalStackTopOffset();
				ir->firstHandlerIndex = FindFirstThrowHandlerIndex(body.exceptionClauses, ipOffset);
				PopAllStack();
				PopBranch();
				continue;
			}
			case OpcodeValue::LDFLD:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				FieldInfo* fieldInfo = const_cast<FieldInfo*>(image->GetFieldInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(fieldInfo);
				// ldfld obj may be obj or or valuetype or ref valuetype....
				EvalStackVarInfo& obj = evalStack[evalStackTop - 1];
				uint16_t topIdx = GetEvalStackTopOffset();
				IRCommon* ir = obj.reduceType != NATIVE_INT_REDUCE_TYPE && IS_CLASS_VALUE_TYPE(fieldInfo->parent) ? CreateValueTypeLdfld(pool, topIdx, topIdx, fieldInfo) : CreateClassLdfld(pool, topIdx, topIdx, fieldInfo);
				AddInst(ir);
				PopStack();
				PushStackByType(fieldInfo->type);

				InsertMemoryBarrier();
				ResetPrefixFlags();

				ip += 5;
				continue;
			}
			case OpcodeValue::LDFLDA:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				FieldInfo* fieldInfo = const_cast<FieldInfo*>(image->GetFieldInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(fieldInfo);

				uint16_t topIdx = GetEvalStackTopOffset();
				uint32_t fieldOffset = GetFieldOffset(fieldInfo);
				if (fieldOffset <= kMaxShortFieldOffset)
				{
					CreateAddIR(ir, LdfldaVarVar);
					ir->dst = topIdx;
					ir->obj = topIdx;
					ir->offset = (uint16_t)fieldOffset;
				}
				else
				{
					CreateAddIR(ir, LdfldaLargeVarVar);
					ir->dst = topIdx;
					ir->obj = topIdx;
					ir->offset = fieldOffset;
				}

				PopStack();
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				ip += 5;
				continue;
			}
			case OpcodeValue::STFLD:
			{
				InsertMemoryBarrier();
				ResetPrefixFlags();

				IL2CPP_ASSERT(evalStackTop >= 2);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				FieldInfo* fieldInfo = const_cast<FieldInfo*>(image->GetFieldInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(fieldInfo);

				IRCommon* ir = CreateStfld(pool, GetEvalStackOffset_2(), fieldInfo, GetEvalStackOffset_1());
				AddInst(ir);
				PopStackN(2);
				ip += 5;
				continue;
			}
			case OpcodeValue::LDSFLD:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				FieldInfo* fieldInfo = const_cast<FieldInfo*>(image->GetFieldInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(fieldInfo);
				uint32_t parentIndex = GetOrAddResolveDataIndex(fieldInfo->parent);
				uint16_t dstIdx = GetEvalStackNewTopOffset();
				IRCommon* ir = fieldInfo->offset != THREAD_STATIC_FIELD_OFFSET ?
					CreateLdsfld(pool, dstIdx, fieldInfo, parentIndex)
					: CreateLdthreadlocal(pool, dstIdx, fieldInfo, parentIndex);
				AddInst(ir);
				PushStackByType(fieldInfo->type);

				InsertMemoryBarrier();
				ResetPrefixFlags();

				ip += 5;
				continue;
			}
			case OpcodeValue::LDSFLDA:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				FieldInfo* fieldInfo = const_cast<FieldInfo*>(image->GetFieldInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(fieldInfo);

				uint16_t dstIdx = GetEvalStackNewTopOffset();
				if (fieldInfo->offset != THREAD_STATIC_FIELD_OFFSET)
				{
					bool ldfldFromFieldData = false;
					if (hybridclr::metadata::IsInterpreterType(fieldInfo->parent))
					{
						const FieldDetail& fieldDet = hybridclr::metadata::MetadataModule::GetImage(fieldInfo->parent)
							->GetFieldDetailFromRawIndex(hybridclr::metadata::DecodeTokenRowIndex(fieldInfo->token - 1));
						if (fieldDet.defaultValueIndex != kDefaultValueIndexNull)
						{
							ldfldFromFieldData = true;
							CreateAddIR(ir, LdsfldaFromFieldDataVarVar);
							ir->dst = dstIdx;
							ir->src = GetOrAddResolveDataIndex(il2cpp::vm::Field::GetData(fieldInfo));
						}
					}
					if (!ldfldFromFieldData)
					{
						CreateAddIR(ir, LdsfldaVarVar);
						ir->dst = dstIdx;
						ir->klass = GetOrAddResolveDataIndex(fieldInfo->parent);
						ir->offset = fieldInfo->offset;
					}
				}
				else
				{
					CreateAddIR(ir, LdthreadlocalaVarVar);
					ir->dst = dstIdx;
					ir->klass = GetOrAddResolveDataIndex(fieldInfo->parent);
					ir->offset = GetThreadStaticFieldOffset(fieldInfo);
				}
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

				ip += 5;
				continue;
			}
			case OpcodeValue::STSFLD:
			{
				InsertMemoryBarrier();
				ResetPrefixFlags();
				IL2CPP_ASSERT(evalStackTop >= 1);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				FieldInfo* fieldInfo = const_cast<FieldInfo*>(image->GetFieldInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(fieldInfo);

				uint32_t klassIndex = GetOrAddResolveDataIndex(fieldInfo->parent);
				uint16_t dataIdx = GetEvalStackTopOffset();
				IRCommon* ir = fieldInfo->offset != THREAD_STATIC_FIELD_OFFSET ?
					CreateStsfld(pool, fieldInfo, klassIndex, dataIdx)
					: CreateStthreadlocal(pool, fieldInfo, klassIndex, dataIdx);
				AddInst(ir);

				PopStack();
				ip += 5;
				continue;
			}
			case OpcodeValue::STOBJ:
			{
				InsertMemoryBarrier();
				ResetPrefixFlags();

				IL2CPP_ASSERT(evalStackTop >= 2);
				EvalStackVarInfo& dst = evalStack[evalStackTop - 2];
				EvalStackVarInfo& src = evalStack[evalStackTop - 1];

				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);

				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);

				IL2CPP_ASSERT(objKlass);
				if (IS_CLASS_VALUE_TYPE(objKlass))
				{
					uint32_t size = GetTypeValueSize(objKlass);
					if (!HYBRIDCLR_ENABLE_WRITE_BARRIERS || !objKlass->has_references)
					{
						switch (size)
						{
						case 1:
						{
							CreateAddIR(ir, StobjVarVar_1);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 2:
						{
							CreateAddIR(ir, StobjVarVar_2);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 4:
						{
							CreateAddIR(ir, StobjVarVar_4);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 8:
						{
							CreateAddIR(ir, StobjVarVar_8);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 12:
						{
							CreateAddIR(ir, StobjVarVar_12);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						case 16:
						{
							CreateAddIR(ir, StobjVarVar_16);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							break;
						}
						default:
						{
							CreateAddIR(ir, StobjVarVar_n_4);
							ir->dst = dst.locOffset;
							ir->src = src.locOffset;
							ir->size = size;
							break;
						}
						}
					}
					else
					{
						CreateAddIR(ir, StobjVarVar_WriteBarrier_n_4);
						ir->dst = dst.locOffset;
						ir->src = src.locOffset;
						ir->size = size;
					}
				}
				else
				{
					CreateAddIR(ir, StobjVarVar_ref);
					ir->dst = dst.locOffset;
					ir->src = src.locOffset;
				}

				PopStackN(2);
				ip += 5;
				continue;
			}
			case OpcodeValue::CONV_OVF_I1_UN:
			{
				CI_conv_un_ovf(i1, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_I2_UN:
			{
				CI_conv_un_ovf(i2, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_I4_UN:
			{
				CI_conv_un_ovf(i4, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_I8_UN:
			{
				CI_conv_un_ovf(i8, I8, 8);
				continue;
			}
			case OpcodeValue::CONV_OVF_U1_UN:
			{
				CI_conv_un_ovf(u1, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_U2_UN:
			{
				CI_conv_un_ovf(u2, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_U4_UN:
			{
				CI_conv_un_ovf(u4, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_U8_UN:
			{
				CI_conv_un_ovf(u8, I8, 8);
				continue;
			}
			case OpcodeValue::CONV_OVF_I_UN:
			{
#if HYBRIDCLR_ARCH_64
				CI_conv_un_ovf(i8, I8, 8);
#else
				CI_conv_un_ovf(i4, I4, 4);
#endif
				continue;
			}
			case OpcodeValue::CONV_OVF_U_UN:
			{
#if HYBRIDCLR_ARCH_64
				CI_conv_un_ovf(u8, I8, 8);
#else
				CI_conv_un_ovf(u4, I4, 4);
#endif
				continue;
			}
			case OpcodeValue::BOX:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				/*	if (il2cpp::vm::Class::IsNullable(objKlass))
					{
						objKlass = il2cpp::vm::Class::GetNullableArgument(objKlass);
					}*/
				PopStack();
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				if (IS_CLASS_VALUE_TYPE(objKlass))
				{
					CreateAddIR(ir, BoxVarVar);
					ir->dst = ir->data = GetEvalStackTopOffset();
					ir->klass = GetOrAddResolveDataIndex(objKlass);
				}
				else
				{
					// ignore class
				}

				ip += 5;
				continue;
			}
			case OpcodeValue::NEWARR:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				EvalStackVarInfo& varSize = evalStack[evalStackTop - 1];
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* eleKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(eleKlass);
				Il2CppClass* arrKlass = il2cpp::vm::Class::GetArrayClass(eleKlass, 1);
				uint32_t arrKlassIndex = GetOrAddResolveDataIndex(arrKlass);

				CreateAddIR(ir, NewArrVarVar);
				ir->arr = ir->size = varSize.locOffset;
				ir->klass = arrKlassIndex;

				PopStack();
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

				ip += 5;
				continue;
			}
			case OpcodeValue::LDLEN:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				CreateAddIR(ir, GetArrayLengthVarVar);
				ir->arr = ir->len = GetEvalStackTopOffset();
				PopStack();
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

				ip++;
				continue;
			}
			case OpcodeValue::LDELEMA:
			{
				IL2CPP_ASSERT(evalStackTop >= 2);
				EvalStackVarInfo& arr = evalStack[evalStackTop - 2];
				EvalStackVarInfo& index = evalStack[evalStackTop - 1];

				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* eleKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				uint32_t eleKlassIndex = GetOrAddResolveDataIndex(eleKlass);

				if ((prefixFlags & (int32_t)PrefixFlags::ReadOnly) || IS_CLASS_VALUE_TYPE(eleKlass))
				{
					CreateAddIR(ir, GetArrayElementAddressAddrVarVar);
					ir->arr = ir->addr = arr.locOffset;
					ir->index = index.locOffset;
				}
				else
				{
					CreateAddIR(ir, GetArrayElementAddressCheckAddrVarVar);
					ir->arr = ir->addr = arr.locOffset;
					ir->index = index.locOffset;
					ir->eleKlass = eleKlassIndex;
				}
				ResetPrefixFlags();
				PopStackN(2);
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				ip += 5;
				continue;
			}
			case OpcodeValue::LDELEM_I1:
			{
				CI_ldele(i1, I4);
				continue;
			}
			case OpcodeValue::LDELEM_U1:
			{
				CI_ldele(u1, I4);
				continue;
			}
			case OpcodeValue::LDELEM_I2:
			{
				CI_ldele(i2, I4);
				continue;
			}
			case OpcodeValue::LDELEM_U2:
			{
				CI_ldele(u2, I4);
				continue;
			}
			case OpcodeValue::LDELEM_I4:
			{
				CI_ldele(i4, I4);
				continue;
			}
			case OpcodeValue::LDELEM_U4:
			{
				CI_ldele(u4, I4);
				continue;
			}
			case OpcodeValue::LDELEM_I8:
			{
				CI_ldele(i8, I8);
				continue;
			}
			case OpcodeValue::LDELEM_I:
			{
#if HYBRIDCLR_ARCH_64
				CI_ldele(i8, I8);
#else
				CI_ldele(i4, I4);
#endif
				continue;
			}
			case OpcodeValue::LDELEM_R4:
			{
				CI_ldele(i4, R4);
				continue;
			}
			case OpcodeValue::LDELEM_R8:
			{
				CI_ldele(i8, R8);
				continue;
			}
			case OpcodeValue::LDELEM_REF:
			{
#if HYBRIDCLR_ARCH_64
				CI_ldele(i8, I8);
#else
				CI_ldele(i4, I4);
#endif
				continue;
			}
			case OpcodeValue::STELEM_I:
			{
#if HYBRIDCLR_ARCH_64
				CI_stele(i8)
#else
				CI_stele(i4)
#endif
					continue;
			}
			case OpcodeValue::STELEM_I1:
			{
				CI_stele(i1);
				continue;
			}
			case OpcodeValue::STELEM_I2:
			{
				CI_stele(i2);
				continue;
			}
			case OpcodeValue::STELEM_I4:
			{
				CI_stele(i4);
				continue;
			}
			case OpcodeValue::STELEM_I8:
			{
				CI_stele(i8);
				continue;
			}
			case OpcodeValue::STELEM_R4:
			{
				CI_stele(i4);
				continue;
			}
			case OpcodeValue::STELEM_R8:
			{
				CI_stele(i8);
				continue;
			}
			case OpcodeValue::STELEM_REF:
			{
				CI_stele(ref);
				continue;
			}

#define CI_ldele0(eleType) \
CreateAddIR(ir,  GetArrayElementVarVar_##eleType); \
ir->arr = arr.locOffset; \
ir->index = index.locOffset; \
ir->dst = arr.locOffset;


			case OpcodeValue::LDELEM:
			{
				IL2CPP_ASSERT(evalStackTop >= 2);
				EvalStackVarInfo& arr = evalStack[evalStackTop - 2];
				EvalStackVarInfo& index = evalStack[evalStackTop - 1];

				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				const Il2CppType* eleType = &objKlass->byval_arg;

				IL2CPP_ASSERT(index.reduceType == EvalStackReduceDataType::I4 || index.reduceType == EvalStackReduceDataType::I8);
				bool isIndexInt32Type = index.reduceType == EvalStackReduceDataType::I4;
				LocationDescInfo desc = ComputLocationDescInfo(eleType);
				switch (desc.type)
				{
				case LocationDescType::I1: { CI_ldele0(i1); break; }
				case LocationDescType::U1: { CI_ldele0(u1); break; }
				case LocationDescType::I2: { CI_ldele0(i2); break; }
				case LocationDescType::U2: { CI_ldele0(u2); break; }
				case LocationDescType::I4: { CI_ldele0(i4); break; }
				case LocationDescType::I8: { CI_ldele0(i8); break; }
				case LocationDescType::Ref:
				{
					if (HYBRIDCLR_ARCH_64)
					{
						CI_ldele0(i8);
					}
					else
					{
						CI_ldele0(i4);
					}
					break;
				}
				case LocationDescType::S:
				case LocationDescType::StructContainsRef:
				{
					CreateAddIR(ir, GetArrayElementVarVar_size_1);
					ir->arr = arr.locOffset;
					ir->index = index.locOffset;
					ir->dst = arr.locOffset;
					uint32_t size = il2cpp::vm::Class::GetValueSize(objKlass, nullptr);
					switch (size)
					{
					case 1:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_1;
						break;
					}
					case 2:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_2;
						break;
					}
					case 4:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_4;
						break;
					}
					case 8:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_8;
						break;
					}
					case 12:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_12;
						break;
					}
					case 16:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_16;
						break;
					}
					case 20:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_20;
						break;
					}
					case 24:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_24;
						break;
					}
					case 28:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_28;
						break;
					}
					case 32:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_size_32;
						break;
					}
					default:
					{
						ir->type = HiOpcodeEnum::GetArrayElementVarVar_n;
					}
					}
					break;
				}
				default:
				{
					RaiseExecutionEngineException("ldelem not support type");
				}
				}
				PopStackN(2);
				PushStackByType(eleType);

				ip += 5;
				continue;
			}


#define CI_stele0(eleType) \
CreateAddIR(ir, SetArrayElementVarVar_##eleType); \
ir->arr = arr.locOffset; \
ir->index = index.locOffset; \
ir->ele = ele.locOffset; 

			case OpcodeValue::STELEM:
			{
				IL2CPP_ASSERT(evalStackTop >= 3);
				EvalStackVarInfo& arr = evalStack[evalStackTop - 3];
				EvalStackVarInfo& index = evalStack[evalStackTop - 2];
				EvalStackVarInfo& ele = evalStack[evalStackTop - 1];

				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				const Il2CppType* eleType = &objKlass->byval_arg;

				IL2CPP_ASSERT(index.reduceType == EvalStackReduceDataType::I4 || index.reduceType == EvalStackReduceDataType::I8);
				bool isIndexInt32Type = index.reduceType == EvalStackReduceDataType::I4;
				LocationDescInfo desc = ComputLocationDescInfo(eleType);
				switch (desc.type)
				{
				case LocationDescType::I1: { CI_stele0(i1); break; }
				case LocationDescType::U1: { CI_stele0(u1); break; }
				case LocationDescType::I2: { CI_stele0(i2); break; }
				case LocationDescType::U2: { CI_stele0(u2); break; }
				case LocationDescType::I4: { CI_stele0(i4); break; }
				case LocationDescType::I8: { CI_stele0(i8); break; }
				case LocationDescType::Ref: { CI_stele0(ref); break; }
				case LocationDescType::S:
				{
					uint32_t size = il2cpp::vm::Class::GetValueSize(objKlass, nullptr);
					switch (size)
					{
					case 12:
					{
						CreateAddIR(ir, SetArrayElementVarVar_size_12);
						ir->arr = arr.locOffset;
						ir->index = index.locOffset;
						ir->ele = ele.locOffset;
						break;
					}
					case 16:
					{
						CreateAddIR(ir, SetArrayElementVarVar_size_16);
						ir->arr = arr.locOffset;
						ir->index = index.locOffset;
						ir->ele = ele.locOffset;
						break;
					}
					default:
					{
						CreateAddIR(ir, SetArrayElementVarVar_n);
						ir->arr = arr.locOffset;
						ir->index = index.locOffset;
						ir->ele = ele.locOffset;
						break;
					}
					}
					break;
				}
				case LocationDescType::StructContainsRef:
				{
					CreateAddIR(ir, SetArrayElementVarVar_WriteBarrier_n);
					ir->arr = arr.locOffset;
					ir->index = index.locOffset;
					ir->ele = ele.locOffset;
					break;
				}
				default:
				{
					RaiseExecutionEngineException("stelem not support type");
				}
				}
				PopStackN(3);

				ip += 5;
				continue;
			}
			case OpcodeValue::UNBOX_ANY:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(objKlass);

				if (IS_CLASS_VALUE_TYPE(objKlass))
				{
					CreateAddIR(ir, UnBoxAnyVarVar);
					ir->dst = ir->obj = GetEvalStackTopOffset();
					ir->klass = GetOrAddResolveDataIndex(objKlass);

					PopStack();
					PushStackByType(&objKlass->byval_arg);
				}
				else
				{
					CreateAddIR(ir, CastclassVar);
					ir->obj = GetEvalStackTopOffset();
					ir->klass = GetOrAddResolveDataIndex(objKlass);
				}

				ip += 5;
				continue;
			}
			case OpcodeValue::CONV_OVF_I1:
			{
				CI_conv_ovf(i1, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_U1:
			{
				CI_conv_ovf(u1, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_I2:
			{
				CI_conv_ovf(i2, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_U2:
			{
				CI_conv_ovf(u2, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_I4:
			{
				CI_conv_ovf(i4, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_U4:
			{
				CI_conv_ovf(u4, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_OVF_I8:
			{
				CI_conv_ovf(i8, I8, 8);
				continue;
			}
			case OpcodeValue::CONV_OVF_U8:
			{
				CI_conv_ovf(u8, I8, 8);
				continue;
			}
			case OpcodeValue::REFANYVAL:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				CreateAddIR(ir, RefAnyValueVarVar);
				ir->addr = ir->typedRef = GetEvalStackTopOffset();
				ir->klass = GetOrAddResolveDataIndex(objKlass);
				PopStack();
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				ip += 5;
				continue;
			}
			case OpcodeValue::CKFINITE:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				EvalStackVarInfo& top = evalStack[evalStackTop - 1];
				switch (top.reduceType)
				{
				case EvalStackReduceDataType::R4:
				{
					CreateAddIR(ir, CheckFiniteVar_f4);
					ir->src = GetEvalStackTopOffset();
					break;
				}
				case EvalStackReduceDataType::R8:
				{
					CreateAddIR(ir, CheckFiniteVar_f8);
					ir->src = GetEvalStackTopOffset();
					break;
				}
				default:
				{
					RaiseExecutionEngineException("CKFINITE invalid reduceType");
					break;
				}
				}

				ip++;
				continue;
			}
			case OpcodeValue::MKREFANY:
			{
				IL2CPP_ASSERT(evalStackTop > 0);
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
				IL2CPP_ASSERT(objKlass);
				CreateAddIR(ir, MakeRefVarVar);
				ir->dst = ir->data = GetEvalStackTopOffset();
				ir->klass = GetOrAddResolveDataIndex(objKlass);
				PopStack();

				Il2CppType typedRef = {};
				typedRef.type = IL2CPP_TYPE_TYPEDBYREF;
				PushStackByType(&typedRef);

				ip += 5;
				continue;
			}
			case OpcodeValue::LDTOKEN:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				void* runtimeHandle = (void*)image->GetRuntimeHandleFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);

				CreateAddIR(ir, LdtokenVar);
				ir->runtimeHandle = GetEvalStackNewTopOffset();
				ir->token = GetOrAddResolveDataIndex(runtimeHandle);
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				ip += 5;
				continue;
			}
			case OpcodeValue::CONV_U2:
			{
				CI_conv(u2, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_U1:
			{
				CI_conv(u1, I4, 4);
				continue;
			}
			case OpcodeValue::CONV_I:
			{
#if HYBRIDCLR_ARCH_64
				CI_conv(i8, I8, 8);
#else
				CI_conv(i4, I4, 4);
#endif
				continue;
			}
			case OpcodeValue::CONV_OVF_I:
			{
#if HYBRIDCLR_ARCH_64
				CI_conv_ovf(i8, I8, 8);
#else
				CI_conv_ovf(i4, I4, 4);
#endif
				continue;
			}
			case OpcodeValue::CONV_OVF_U:
			{
#if HYBRIDCLR_ARCH_64
				CI_conv_ovf(u8, I8, 8);
#else
				CI_conv_ovf(u4, I4, 4);
#endif
				continue;
			}
			case OpcodeValue::ADD_OVF:
			{
				CI_binOpOvf(Add);
				continue;
			}
			case OpcodeValue::ADD_OVF_UN:
			{
				CI_binOpUnOvf(Add);
				continue;
			}
			case OpcodeValue::MUL_OVF:
			{
				CI_binOpOvf(Mul);
				continue;
			}
			case OpcodeValue::MUL_OVF_UN:
			{
				CI_binOpUnOvf(Mul);
				continue;
			}
			case OpcodeValue::SUB_OVF:
			{
				CI_binOpOvf(Sub);
				continue;
			}
			case OpcodeValue::SUB_OVF_UN:
			{
				CI_binOpUnOvf(Sub);
				continue;
			}
			case OpcodeValue::ENDFINALLY:
			{
				CreateAddIR(ir, EndFinallyEx);
				PopBranch();
				continue;
			}
			case OpcodeValue::STIND_I:
			{
				Add_stind(ARCH_ARGUMENT(HiOpcodeEnum::StindVarVar_i4, HiOpcodeEnum::StindVarVar_i8));
				continue;
			}
			case OpcodeValue::CONV_U:
			{
#if HYBRIDCLR_ARCH_64
				CI_conv(u8, I8, 8);
#else
				CI_conv(u4, I4, 4);
#endif
				continue;
			}
			case OpcodeValue::PREFIX7:
			case OpcodeValue::PREFIX6:
			case OpcodeValue::PREFIX5:
			case OpcodeValue::PREFIX4:
			case OpcodeValue::PREFIX3:
			case OpcodeValue::PREFIX2:
			{
				ip++;
				continue;
			}
			case OpcodeValue::PREFIX1:
			{
				// This is the prefix for all the 2-byte opcodes.
				// Figure out the second byte of the 2-byte opcode.
				byte ops = *(ip + 1);

				switch ((OpcodeValue)ops)
				{

				case OpcodeValue::ARGLIST:
				{
					RaiseExecutionEngineException("");
					ip += 2;
					continue;
				}
				case OpcodeValue::CEQ:
				{
					CI_compare(Ceq);
					ip += 2;
					continue;
				}
				case OpcodeValue::CGT:
				{
					CI_compare(Cgt);
					ip += 2;
					continue;
				}
				case OpcodeValue::CGT_UN:
				{
					CI_compare(CgtUn);
					ip += 2;
					continue;
				}
				case OpcodeValue::CLT:
				{
					CI_compare(Clt);
					ip += 2;
					continue;
				}
				case OpcodeValue::CLT_UN:
				{
					CI_compare(CltUn);
					ip += 2;
					continue;
				}
				case OpcodeValue::LDFTN:
				{
					uint32_t methodToken = (uint32_t)GetI4LittleEndian(ip + 2);
					MethodInfo* methodInfo = const_cast<MethodInfo*>(image->GetMethodInfoFromToken(tokenCache, methodToken, klassContainer, methodContainer, genericContext));
					IL2CPP_ASSERT(methodInfo);
					CreateAddIR(ir, LdcVarConst_8);
					ir->dst = GetEvalStackNewTopOffset();
					ir->src = (uint64_t)methodInfo;
					PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
					ip += 6;
					continue;
				}
				case OpcodeValue::LDVIRTFTN:
				{
					IL2CPP_ASSERT(evalStackTop > 0);
					uint32_t methodToken = (uint32_t)GetI4LittleEndian(ip + 2);
					MethodInfo* methodInfo = const_cast<MethodInfo*>(image->GetMethodInfoFromToken(tokenCache, methodToken, klassContainer, methodContainer, genericContext));
					IL2CPP_ASSERT(methodInfo);

					CreateAddIR(ir, LdvirftnVarVar);
					ir->resultMethod = ir->obj = GetEvalStackTopOffset();
					ir->virtualMethod = GetOrAddResolveDataIndex(methodInfo);

					PopStack();
					PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
					ip += 6;
					continue;
				}
				case OpcodeValue::UNUSED56:
				{
					ip += 2;
					continue;
				}
				case OpcodeValue::LDARG:
				{
					argIdx = GetU2LittleEndian(ip + 2);
					AddInst_ldarg(argIdx);
					ip += 4;
					continue;
				}
				case OpcodeValue::LDARGA:
				{
					argIdx = GetU2LittleEndian(ip + 2);
					AddInst_ldarga(argIdx);
					ip += 4;
					continue;
				}
				case OpcodeValue::STARG:
				{
					argIdx = GetU2LittleEndian(ip + 2);
					AddInst_starg(argIdx);
					ip += 4;
					continue;
				}
				case OpcodeValue::LDLOC:
				{
					argIdx = GetU2LittleEndian(ip + 2);
					CreateAddInst_ldloc(argIdx);
					ip += 4;
					continue;
				}
				case OpcodeValue::LDLOCA:
				{
					argIdx = GetU2LittleEndian(ip + 2);
					CreateAddInst_ldloca(argIdx);
					ip += 4;
					continue;
				}
				case OpcodeValue::STLOC:
				{
					argIdx = GetU2LittleEndian(ip + 2);
					CreateAddInst_stloc(argIdx);
					ip += 4;
					continue;
				}
				case OpcodeValue::LOCALLOC:
				{
					IL2CPP_ASSERT(evalStackTop > 0);
					EvalStackVarInfo& top = evalStack[evalStackTop - 1];

					switch (top.reduceType)
					{
					case EvalStackReduceDataType::I4:
					case EvalStackReduceDataType::I8: // FIXE ME
					{
						CreateAddIR(ir, LocalAllocVarVar_n_4);
						ir->dst = ir->size = GetEvalStackTopOffset();
						break;
					}
					default:
					{
						RaiseExecutionEngineException("LOCALLOC invalid reduceType");
						break;
					}
					}
					PopStack();
					PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

					ip += 2;
					continue;
				}
				case OpcodeValue::UNUSED57:
				{
					ip += 2;
					continue;
				}
				case OpcodeValue::ENDFILTER:
				{
					CreateAddIR(ir, EndFilterEx);
					ir->value = GetEvalStackTopOffset();
					PopAllStack();

					PopBranch();
					continue;
				}
				case OpcodeValue::UNALIGNED_:
				{
					// Nothing to do here.
					prefixFlags |= (int32_t)PrefixFlags::Unaligned;
					uint8_t alignment = ip[2];
					IL2CPP_ASSERT(alignment == 1 || alignment == 2 || alignment == 4);
					ip += 3;
					continue;
				}
				case OpcodeValue::VOLATILE_:
				{
					// Set a flag that causes a memory barrier to be associated with the next load or store.
					//CI_volatileFlag = true;
					prefixFlags |= (int32_t)PrefixFlags::Volatile;
					ip += 2;
					continue;
				}
				case OpcodeValue::TAIL_:
				{
					prefixFlags |= (int32_t)PrefixFlags::Tail;
					ip += 2;
					continue;
				}
				case OpcodeValue::INITOBJ:
				{
					IL2CPP_ASSERT(evalStackTop > 0);
					uint32_t token = (uint32_t)GetI4LittleEndian(ip + 2);
					Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
					if (IS_CLASS_VALUE_TYPE(objKlass))
					{
						uint32_t objSize = GetTypeValueSize(objKlass);
						if ((HYBRIDCLR_ENABLE_WRITE_BARRIERS && objKlass->has_references))
						{
							CreateAddIR(ir, InitobjVar_WriteBarrier_n_4);
							ir->obj = GetEvalStackTopOffset();
							ir->size = objSize;
						}
						else
						{
							bool convert = false;
							switch (objSize)
							{
							case 1:
							{
								CreateAddIR(ir, InitobjVar_1);
								ir->obj = GetEvalStackTopOffset();
								convert = true;
								break;
							}
							case 2:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 2)
								{
									CreateAddIR(ir, InitobjVar_2);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 4:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 4)
								{
									CreateAddIR(ir, InitobjVar_4);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 8:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 8)
								{
									CreateAddIR(ir, InitobjVar_8);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 12:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 4)
								{
									CreateAddIR(ir, InitobjVar_12);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 16:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 8)
								{
									CreateAddIR(ir, InitobjVar_16);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 20:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 4)
								{
									CreateAddIR(ir, InitobjVar_20);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 24:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 8)
								{
									CreateAddIR(ir, InitobjVar_24);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 28:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 4)
								{
									CreateAddIR(ir, InitobjVar_28);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							case 32:
							{
								if (SUPPORT_MEMORY_NOT_ALIGMENT_ACCESS || objKlass->minimumAlignment >= 8)
								{
									CreateAddIR(ir, InitobjVar_32);
									ir->obj = GetEvalStackTopOffset();
									convert = true;
								}
								break;
							}
							}
							if (!convert)
							{
								CreateAddIR(ir, InitobjVar_n_4);
								ir->obj = GetEvalStackTopOffset();
								ir->size = objSize;
							}
						}
					}
					else
					{
						CreateAddIR(ir, InitobjVar_ref);
						ir->obj = GetEvalStackTopOffset();
					}
					PopStack();

					ip += 6;
					break;
				}
				case OpcodeValue::CONSTRAINED_:
				{
					uint32_t typeToken = (uint32_t)GetI4LittleEndian(ip + 2);
					Il2CppClass* conKlass = image->GetClassFromToken(tokenCache, typeToken, klassContainer, methodContainer, genericContext);
					IL2CPP_ASSERT(conKlass);
					ip += 6;

					IL2CPP_ASSERT(*ip == (uint8_t)OpcodeValue::CALLVIRT);
					uint32_t methodToken = (uint32_t)GetI4LittleEndian(ip + 1);
					ip += 5;

					// TODO token cache optimistic
					shareMethod = const_cast<MethodInfo*>(image->GetMethodInfoFromToken(tokenCache, methodToken, klassContainer, methodContainer, genericContext));
					IL2CPP_ASSERT(shareMethod);


					int32_t resolvedTotalArgNum = shareMethod->parameters_count + 1;

					int32_t selfIdx = evalStackTop - resolvedTotalArgNum;
					EvalStackVarInfo& self = evalStack[selfIdx];
					if (IS_CLASS_VALUE_TYPE(conKlass))
					{
						// impl in self
						const MethodInfo* implMethod = image->FindImplMethod(conKlass, shareMethod);
						if (implMethod->klass == conKlass)
						{
							shareMethod = implMethod;
							goto LabelCall;
						}
						else if (conKlass->enumtype && !std::strcmp(shareMethod->name, "GetHashCode"))
						{
							Il2CppTypeEnum typeEnum = conKlass->element_class->byval_arg.type;
							self.reduceType = EvalStackReduceDataType::I4;
							if (typeEnum == IL2CPP_TYPE_I8 || typeEnum == IL2CPP_TYPE_U8)
							{
								CreateAddIR(ir, GetEnumHashCode);
								ir->dst = ir->src = self.locOffset;
							}
							else
							{
								CreateAddIR(ir, LdindVarVar_i1);
								ir->dst = ir->src = self.locOffset;
								switch (conKlass->element_class->byval_arg.type)
								{
								case IL2CPP_TYPE_U1: ir->type = HiOpcodeEnum::LdindVarVar_u1; break;
								case IL2CPP_TYPE_I1: ir->type = HiOpcodeEnum::LdindVarVar_i1; break;
								case IL2CPP_TYPE_U2: ir->type = HiOpcodeEnum::LdindVarVar_u2; break;
								case IL2CPP_TYPE_I2: ir->type = HiOpcodeEnum::LdindVarVar_u2; break;
								case IL2CPP_TYPE_U4: ir->type = HiOpcodeEnum::LdindVarVar_u4; break;
								case IL2CPP_TYPE_I4: ir->type = HiOpcodeEnum::LdindVarVar_i4; break;
								case IL2CPP_TYPE_CHAR: ir->type = HiOpcodeEnum::LdindVarVar_u2; break;
								case IL2CPP_TYPE_BOOLEAN: ir->type = HiOpcodeEnum::LdindVarVar_i1; break;
								default:
									IL2CPP_ASSERT(false && "GetHashCode");
									break;
								}
							}
						}
						else
						{
							CreateAddIR(ir, BoxRefVarVar);
							ir->dst = ir->src = self.locOffset;
							ir->klass = GetOrAddResolveDataIndex(conKlass);

							self.reduceType = NATIVE_INT_REDUCE_TYPE;
							self.byteSize = GetSizeByReduceType(self.reduceType);
							goto LabelCallVir;
						}
					}
					else
					{
#if HYBRIDCLR_ARCH_64
						CreateAddIR(ir, LdindVarVar_i8);
#else
						CreateAddIR(ir, LdindVarVar_i4);
#endif
						ir->dst = ir->src = self.locOffset;
						self.reduceType = NATIVE_INT_REDUCE_TYPE;
						self.byteSize = GetSizeByReduceType(self.reduceType);
						goto LabelCallVir;
					}
					continue;
				}
				case OpcodeValue::CPBLK:
				{
					// we don't sure dst or src is volatile. so insert memory barrier ahead and end.
					IL2CPP_ASSERT(evalStackTop >= 3);
					InsertMemoryBarrier();
					ResetPrefixFlags();
					CreateAddIR(ir, CpblkVarVar);
					ir->dst = GetEvalStackOffset_3();
					ir->src = GetEvalStackOffset_2();
					ir->size = GetEvalStackOffset_1();
					PopStackN(3);
					InsertMemoryBarrier();
					ResetPrefixFlags();
					ip += 2;
					continue;
				}
				case OpcodeValue::INITBLK:
				{
					IL2CPP_ASSERT(evalStackTop >= 3);
					InsertMemoryBarrier();
					ResetPrefixFlags();
					CreateAddIR(ir, InitblkVarVarVar);
					ir->addr = GetEvalStackOffset_3();
					ir->value = GetEvalStackOffset_2();
					ir->size = GetEvalStackOffset_1();
					PopStackN(3);
					ip += 2;
					continue;
				}
				case OpcodeValue::NO_:
				{
					uint8_t checkType = ip[2];
					// {typecheck:0x1} | {rangecheck:0x2} | {nullcheck:0x4}
					IL2CPP_ASSERT(checkType < 8);
					ip += 3;
					continue;
				}
				case OpcodeValue::RETHROW:
				{
					CreateAddIR(ir, RethrowEx);
					AddInst(ir);
					PopAllStack();
					PopBranch();
					continue;
				}
				case OpcodeValue::UNUSED:
				{
					ip += 2;
					continue;
				}
				case OpcodeValue::SIZEOF:
				{
					uint32_t token = (uint32_t)GetI4LittleEndian(ip + 2);
					Il2CppClass* objKlass = image->GetClassFromToken(tokenCache, token, klassContainer, methodContainer, genericContext);
					IL2CPP_ASSERT(objKlass);
					int32_t typeSize = GetTypeValueSize(&objKlass->byval_arg);
					CreateAddInst_ldc4(typeSize, EvalStackReduceDataType::I4);
					ip += 6;
					continue;
				}
				case OpcodeValue::REFANYTYPE:
				{
					IL2CPP_ASSERT(evalStackTop > 0);
					CreateAddIR(ir, RefAnyTypeVarVar);
					ir->dst = ir->typedRef = GetEvalStackOffset_1();
					PopStack();
					PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);

					ip += 2;
					continue;
				}
				case OpcodeValue::READONLY_:
				{
					prefixFlags |= (int32_t)PrefixFlags::ReadOnly;
					ip += 2;
					// generic md array also can follow readonly
					//IL2CPP_ASSERT(*ip == (byte)OpcodeValue::LDELEMA && "According to the ECMA spec, READONLY may only precede LDELEMA");
					continue;
				}
				case OpcodeValue::UNUSED53:
				case OpcodeValue::UNUSED54:
				case OpcodeValue::UNUSED55:
				case OpcodeValue::UNUSED70:
				{
					ip += 2;
					continue;
				}
				default:
				{
					//UNREACHABLE();
					RaiseExecutionEngineException("not support instruction");
					continue;
				}
				}
				continue;
			}
			case OpcodeValue::PREFIXREF:
			{
				ip++;
				continue;
			}
			default:
			{
				RaiseExecutionEngineException("not support instruction");
				continue;
			}
			}
			ip++;
		}
	finish_transform:


		totalIRSize = 0;
		for (IRBasicBlock* bb : irbbs)
		{
			bb->codeOffset = totalIRSize;
			for (IRCommon* ir : bb->insts)
			{
				totalIRSize += g_instructionSizes[(int)ir->type];
			}
		}
		endBb->codeOffset = totalIRSize;

		for (int32_t* relocOffsetPtr : relocationOffsets)
		{
			int32_t relocOffset = *relocOffsetPtr;
			IL2CPP_ASSERT(splitOffsets.find(relocOffset) != splitOffsets.end());
			*relocOffsetPtr = ip2bb[relocOffset]->codeOffset;
		}

		for (auto switchOffsetPair : switchOffsetsInResolveData)
		{
			int32_t* offsetStartPtr = (int32_t*)&resolveDatas[switchOffsetPair.first];
			for (int32_t i = 0; i < switchOffsetPair.second; i++)
			{
				int32_t relocOffset = offsetStartPtr[i];
				IL2CPP_ASSERT(splitOffsets.find(relocOffset) != splitOffsets.end());
				offsetStartPtr[i] = ip2bb[relocOffset]->codeOffset;
			}
		}
	}

	void TransformContext::BuildInterpMethodInfo(interpreter::InterpMethodInfo& result)
	{
		il2cpp::utils::dynamic_array<hybridclr::metadata::ILMapper>* ilMappers;
		if (ir2offsetMap)
		{
			ilMappers = new il2cpp::utils::dynamic_array<hybridclr::metadata::ILMapper>();
			ilMappers->reserve(ir2offsetMap->size());
		}
		else
		{
			ilMappers = nullptr;
		}
		byte* tranCodes = (byte*)HYBRIDCLR_METADATA_MALLOC(totalIRSize);

		uint32_t tranOffset = 0;
		for (IRBasicBlock* bb : irbbs)
		{
			//bb->codeOffset = tranOffset;
			for (IRCommon* ir : bb->insts)
			{
				if (ilMappers)
				{
					auto it = ir2offsetMap->find(ir);
					if (it != ir2offsetMap->end())
					{
						hybridclr::metadata::ILMapper ilMapper;
						ilMapper.irOffset = tranOffset;
						ilMapper.ilOffset = it->second;
						ilMappers->push_back(ilMapper);
					}
				}
				uint32_t irSize = g_instructionSizes[(int)ir->type];
				std::memcpy(tranCodes + tranOffset, &ir->type, irSize);
				tranOffset += irSize;
			}
		}
		IL2CPP_ASSERT(tranOffset == totalIRSize);

		for (FlowInfo* fi : pendingFlows)
		{
			fi->~FlowInfo();
		}

		MethodArgDesc* argDescs;
		if (actualParamCount > 0)
		{
			argDescs = (MethodArgDesc*)HYBRIDCLR_METADATA_CALLOC(actualParamCount, sizeof(MethodArgDesc));
			for (int32_t i = 0; i < actualParamCount; i++)
			{
				const Il2CppType* argType = args[i].type;
				TypeDesc typeDesc = GetTypeArgDesc(argType);
				MethodArgDesc& argDesc = argDescs[i];
				argDesc.type = typeDesc.type;
				IL2CPP_ASSERT(typeDesc.stackObjectSize < 0x10000);
				argDesc.stackObjectSize = (uint16_t)typeDesc.stackObjectSize;
				argDesc.passbyValWhenInvoke = argType->byref || !IsValueType(argType);
			}
		}
		else
		{
			argDescs = nullptr;
		}

		result.args = argDescs;
		result.argCount = actualParamCount;
		result.argStackObjectSize = totalArgSize;
		result.retStackObjectSize = IsVoidType(methodInfo->return_type) ? 0 : GetTypeArgDesc(methodInfo->return_type).stackObjectSize;
		result.codes = tranCodes;
		result.codeLength = totalIRSize;
		result.evalStackBaseOffset = evalStackBaseOffset;
		result.localVarBaseOffset = totalArgSize;
		result.localStackSize = totalArgLocalSize;
		result.maxStackSize = maxStackSize;
		result.initLocals = initLocals;

		if (resolveDatas.empty())
		{
			result.resolveDatas = nullptr;
		}
		else
		{
			//result.resolveData = (uint8_t*)HYBRIDCLR_MALLOC(resolveDatas.size() * sizeof(uint8_t));
			size_t dataSize = resolveDatas.size() * sizeof(uint64_t);
			uint64_t* data = (uint64_t*)HYBRIDCLR_METADATA_MALLOC(dataSize);
			std::memcpy(data, resolveDatas.data(), dataSize);
			result.resolveDatas = data;
		}
		if (exClauses.empty())
		{
			result.exClauses = nullptr;
			result.exClauseCount = 0;
		}
		else
		{
			size_t dataSize = exClauses.size() * sizeof(InterpExceptionClause);
			InterpExceptionClause* data = (InterpExceptionClause*)HYBRIDCLR_METADATA_MALLOC(dataSize);
			std::memcpy(data, exClauses.data(), dataSize);
			result.exClauses = data;
			result.exClauseCount = (uint32_t)exClauses.size();
		}

		if (ilMappers)
		{
			image->GetPDBImage()->SetMethodDebugInfo(methodInfo, *ilMappers);
		}
	}

	bool TransformContext::TransformSubMethodBody(TransformContext& callingCtx, const MethodInfo* methodInfo, int32_t depth, int32_t localVarOffset)
	{
		metadata::Image* image = metadata::MetadataModule::GetUnderlyingInterpreterImage(methodInfo);
		IL2CPP_ASSERT(image);

		metadata::MethodBody* methodBody = metadata::MethodBodyCache::GetMethodBody(image, methodInfo->token);
		if (methodBody == nullptr || methodBody->ilcodes == nullptr)
		{
			TEMP_FORMAT(errMsg, "Method body is null. %s.%s::%s", methodInfo->klass->namespaze, methodInfo->klass->name, methodInfo->name);
			il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetExecutionEngineException(errMsg));
		}

		TransformContext ctx(image, methodInfo, *methodBody, callingCtx.pool, callingCtx.resolveDatas);

		try
		{
			ctx.TransformBodyImpl(depth, localVarOffset);
			callingCtx.maxStackSize = std::max(callingCtx.maxStackSize, ctx.maxStackSize);
			callingCtx.curbb->insts.insert(callingCtx.curbb->insts.end(), ctx.curbb->insts.begin(), ctx.curbb->insts.end());
			return true;
		}
		catch (Il2CppExceptionWrapper&)
		{
			//LOG_ERROR("TransformSubMethodBody failed: %s", ex.what());
			metadata::MethodBodyCache::DisableInline(methodInfo);
			return false;
		}

		return false;
	}

}
}
```

`hybridclr/transform/TransformContext.h`:

```h
#pragma once

#include <unordered_set>
#include <set>

#include "TemporaryMemoryArena.h"

#include "../metadata/Image.h"
#include "../interpreter/Instruction.h"
#include "../interpreter/Engine.h"
#include "../metadata/MetadataUtil.h"
#include "../metadata/Opcodes.h"
#include "../metadata/MetadataModule.h"
#include "../interpreter/Instruction.h"
#include "../interpreter/Interpreter.h"
#include "../interpreter/InterpreterModule.h"

#include "Transform.h"

namespace hybridclr
{
namespace transform
{
	using namespace hybridclr::metadata;
	using namespace hybridclr::interpreter;

	struct IRBasicBlock
	{
		bool visited;
		bool inPending;
		uint32_t ilOffset;
		uint32_t codeOffset;
		std::vector<interpreter::IRCommon*> insts;
	};

	struct ArgVarInfo
	{
		const Il2CppType* type;
		Il2CppClass* klass;
		int32_t argOffset; // StackObject index
		int32_t argLocOffset;
	};

	struct LocVarInfo
	{
		const Il2CppType* type;
		Il2CppClass* klass;
		int32_t locOffset;
	};

	enum class EvalStackReduceDataType
	{
		I4,
		I8,
		R4,
		R8,
		Other,
	};

	struct EvalStackVarInfo
	{
		EvalStackReduceDataType reduceType;
		int32_t byteSize;
		int32_t locOffset;
	};

#if HYBRIDCLR_ARCH_64
#define NATIVE_INT_OP opI8
	constexpr EvalStackReduceDataType NATIVE_INT_REDUCE_TYPE = EvalStackReduceDataType::I8;
#else
#define NATIVE_INT_OP opI4
	constexpr EvalStackReduceDataType NATIVE_INT_REDUCE_TYPE = EvalStackReduceDataType::I4;
#endif

#define CreateIR(varName, typeName) IR##typeName* varName = pool.AllocIR<IR##typeName>(); varName->type = HiOpcodeEnum::typeName;
#define CreateAddIR(varName, typeName) IR##typeName* varName = pool.AllocIR<IR##typeName>(); varName->type = HiOpcodeEnum::typeName; curbb->insts.push_back(varName); if (ir2offsetMap) { ir2offsetMap->add(varName, ipOffset); }

	enum class LocationDescType
	{
		I1,
		U1,
		I2,
		U2,
		I4,
		I8,
		Ref,
		S,
		StructContainsRef,
	};

#if HYBRIDCLR_ARCH_64
#define NATIVE_INT_DESC_TYPE LocationDescType::I8
#define ARCH_ARGUMENT(x32, x64) x64
#else
#define NATIVE_INT_DESC_TYPE LocationDescType::I4
#define ARCH_ARGUMENT(x32, x64) x32
#endif

	struct LocationDescInfo
	{
		LocationDescType type;
		int32_t size;
	};

	struct FlowInfo
	{
		uint32_t curStackSize;
		uint32_t offset;
		il2cpp::utils::dynamic_array<EvalStackVarInfo> evalStack;
	};

	typedef Il2CppHashMap<IRCommon*, uint32_t, il2cpp::utils::PointerHash<IRCommon>> IR2OffsetMap;

	LocationDescInfo ComputLocationDescInfo(const Il2CppType* type);

	class TransformContext
	{
	private:
		metadata::Image* image;
		const MethodInfo* methodInfo;
		metadata::MethodBody& body;


		TemporaryMemoryArena& pool;

		int32_t actualParamCount;

		std::set<uint32_t> splitOffsets;
		IRBasicBlock** ip2bb;
		IRBasicBlock* curbb;

		ArgVarInfo* args;
		LocVarInfo* locals;
		EvalStackVarInfo* evalStack;
		int32_t evalStackTop;
		int32_t evalStackBaseOffset;
		int32_t maxStackSize;
		int32_t curStackSize;

		il2cpp::utils::dynamic_array<uint64_t>& resolveDatas;
		Il2CppHashMap<uint32_t, uint32_t, il2cpp::utils::PassThroughHash<uint32_t>> token2DataIdxs;
		Il2CppHashMap<const void*, uint32_t, il2cpp::utils::PassThroughHash<const void*>> ptr2DataIdxs;
		std::vector<int32_t*> relocationOffsets;
		std::vector<std::pair<int32_t, int32_t>> switchOffsetsInResolveData;
		std::vector<FlowInfo*> pendingFlows;
		int32_t nextFlowIdx;

		const byte* ipBase;
		const byte* ip;
		uint32_t ipOffset;
		IR2OffsetMap* ir2offsetMap;

		int32_t prefixFlags;

		const MethodInfo* shareMethod;

		std::vector<IRBasicBlock*> irbbs;
		il2cpp::utils::dynamic_array<InterpExceptionClause> exClauses;

		uint32_t totalIRSize;
		int32_t totalArgSize;
		int32_t totalArgLocalSize;
		bool initLocals;

	public:

		TransformContext(hybridclr::metadata::Image* image, const MethodInfo* methodInfo, metadata::MethodBody& body, TemporaryMemoryArena& pool, il2cpp::utils::dynamic_array<uint64_t>& resolveDatas);
		~TransformContext();

		static void InitializeInstinctHandlers();

		uint32_t GetOrAddResolveDataIndex(const void* ptr);

		TemporaryMemoryArena& GetPool() const
		{
			return pool;
		}

		int32_t GetEvalStackTop() const
		{
			return evalStackTop;
		}

		IRBasicBlock* GetCurbb() const
		{
			return curbb;
		}

		uint32_t GetIpOffset() const
		{
			return ipOffset;
		}

		IR2OffsetMap* GetIr2offsetMap() const
		{
			return ir2offsetMap;
		}

		int32_t GetArgOffset(int32_t idx) const
		{
			return args[idx].argOffset;
		}

		int32_t GetArgLocOffset(int32_t idx) const
		{
			return args[idx].argLocOffset;
		}

		int32_t GetLocOffset(int32_t idx) const
		{
			return locals[idx].locOffset;
		}

		int32_t GetEvalStackOffset(int32_t idx) const
		{
			return idx < evalStackTop ? evalStack[idx].locOffset : curStackSize;
		}

		int32_t GetEvalStackTopOffset() const
		{
			return evalStackTop > 0 ? evalStack[evalStackTop - 1].locOffset : curStackSize;
		}

		int32_t GetEvalStackNewTopOffset() const
		{
			return curStackSize;
		}

		int32_t GetEvalStackOffset_5() const
		{
			return evalStack[evalStackTop - 5].locOffset;
		}

		int32_t GetEvalStackOffset_4() const
		{
			return evalStack[evalStackTop - 4].locOffset;
		}

		int32_t GetEvalStackOffset_3() const
		{
			return evalStack[evalStackTop - 3].locOffset;
		}

		int32_t GetEvalStackOffset_2() const
		{
			return evalStack[evalStackTop - 2].locOffset;
		}

		int32_t GetEvalStackOffset_1() const
		{
			return evalStack[evalStackTop - 1].locOffset;
		}

		void PushStackByType(const Il2CppType* type);

		void PushStackByReduceType(EvalStackReduceDataType t);

		void DuplicateStack();

		void PopStack();

		void PopStackN(int32_t n);

		void PopAllStack();

		void InsertMemoryBarrier();

		void ResetPrefixFlags();

		void Add_ldind(HiOpcodeEnum opCode, EvalStackReduceDataType dataType);

		void Add_stind(HiOpcodeEnum opCode);

		void PushOffset(int32_t* offsetPtr);

		void PushBranch(int32_t targetOffset);

		bool FindNextFlow();

		void AddInst(IRCommon* ir);

		void AddInst_ldarg(int32_t argIdx);

		bool IsCreateNotNullObjectInstrument(IRCommon* ir);

		IRCommon* GetLastInstrument()
		{
			return curbb->insts.empty() ? nullptr : curbb->insts.back();
		}

		void RemoveLastInstrument();

		void AddInst_ldarga(int32_t argIdx);

		void AddInst_starg(int32_t argIdx);

		void CreateAddInst_ldloc(int32_t locIdx);

		void CreateAddInst_stloc(int32_t locIdx);

		void CreateAddInst_ldloca(int32_t locIdx);

		void CreateAddInst_ldc4(int32_t c, EvalStackReduceDataType rtype);

		void CreateAddInst_ldc8(int64_t c, EvalStackReduceDataType rtype);

		void Add_brtruefalse(bool c, int32_t targetOffset);

		void Add_bc(int32_t ipOffset, int32_t brOffset, int32_t opSize, HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8);

		void Add_conv(int32_t dstTypeSize, EvalStackReduceDataType dstReduceType, HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8);

		void Add_conv_ovf(int32_t dstTypeSize, EvalStackReduceDataType dstReduceType, HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8);

		void Add_binop(HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8);

		void Add_shiftop(HiOpcodeEnum opI4I4, HiOpcodeEnum opI4I8, HiOpcodeEnum opI8I4, HiOpcodeEnum opI8I8);

		void Add_compare(HiOpcodeEnum opI4, HiOpcodeEnum opI8, HiOpcodeEnum opR4, HiOpcodeEnum opR8);

		void Add_ldelem(EvalStackReduceDataType resultType, HiOpcodeEnum opI4);
		void Add_stelem(HiOpcodeEnum opI4);

		bool FindFirstLeaveHandlerIndex(const std::vector<ExceptionClause>& exceptionClauses, uint32_t leaveOffset, uint32_t targetOffset, uint16_t& index);

		bool IsLeaveInTryBlock(const std::vector<ExceptionClause>& exceptionClauses, uint32_t leaveOffset);

		void Add_leave(uint32_t targetOffset);

		uint16_t FindFirstThrowHandlerIndex(const std::vector<ExceptionClause>& exceptionClauses, uint32_t throwOffset);

		bool TryAddInstinctInstruments(const MethodInfo* method)
		{
			return TryAddInstinctInstrumentsByName(method) || TryAddArrayInstinctInstruments(method);
		}

		bool TryAddInstinctInstrumentsByName(const MethodInfo* method);
		bool TryAddArrayInstinctInstruments(const MethodInfo* method);

		bool TryAddInstinctCtorInstruments(const MethodInfo* method);

		bool TryAddCallCommonInstruments(const MethodInfo* method, uint32_t methodDataIndex)
		{
			bool resolvedIsInstanceMethod = IsInstanceMethod(method);
			bool add = resolvedIsInstanceMethod ? TryAddCallCommonInstanceInstruments(method, methodDataIndex)
				: TryAddCallCommonStaticInstruments(method, methodDataIndex);
			if (add)
			{
				int32_t resolvedTotalArgNum = method->parameters_count + resolvedIsInstanceMethod;
				PopStackN(resolvedTotalArgNum);
				if (method->return_type->type != IL2CPP_TYPE_VOID)
				{
					PushStackByType(method->return_type);
				}
				return true;
			}
			return false;
		}

		bool TryAddCallCommonInstanceInstruments(const MethodInfo* method, uint32_t methodDataIndex);
		bool TryAddCallCommonStaticInstruments(const MethodInfo* method, uint32_t methodDataIndex);


		HiOpcodeEnum CalcGetMdArrElementVarVarOpcode(const Il2CppType* type);

		void TransformBody(int32_t depth, int32_t localVarOffset, interpreter::InterpMethodInfo& result);

	private:
		void TransformBodyImpl(int32_t depth, int32_t localVarOffset);
		void BuildInterpMethodInfo(interpreter::InterpMethodInfo& result);
		static bool TransformSubMethodBody(TransformContext& callingCtx, const MethodInfo* subMethod, int32_t depth, int32_t localVarOffset);
	};
}
}
```

`hybridclr/transform/TransformContext_CallCommon.cpp`:

```cpp
#include "TransformContext.h"

#include "../interpreter/MethodBridge.h"

namespace hybridclr
{
namespace transform
{
	enum class ArgCommonType
	{
		VOID,
		I1,
		U1,
		I2,
		U2,
		I4,
		I8,
		R4,
		R8,
		I,
		U,
		STRUCT,
		NOT_SUPPORT,
	};

#if HYBRIDCLR_ARCH_64
#define NATIVE_INT_COMMON_TYPE ArgCommonType::I8
#else
#define NATIVE_INT_COMMON_TYPE ArgCommonType::I4
#endif


	static ArgCommonType ComputValueTypeArgCommonType(const Il2CppClass* klass)
	{
		return ArgCommonType::STRUCT;
	}


	static ArgCommonType ComputArgCommonType(const Il2CppType* type)
	{
		if (type->byref)
		{
			return NATIVE_INT_COMMON_TYPE;
		}
		switch (type->type)
		{
		case IL2CPP_TYPE_VOID:
			return ArgCommonType::VOID;
		case IL2CPP_TYPE_BOOLEAN:
		case IL2CPP_TYPE_U1:
			return ArgCommonType::U1;
		case IL2CPP_TYPE_I1:
			return ArgCommonType::I1;
		case IL2CPP_TYPE_I2:
			return ArgCommonType::I2;
		case IL2CPP_TYPE_CHAR:
		case IL2CPP_TYPE_U2:
			return ArgCommonType::U2;
		case IL2CPP_TYPE_I4:
		case IL2CPP_TYPE_U4:
			return ArgCommonType::I4;
		case IL2CPP_TYPE_R4:
			return ArgCommonType::R4;
		case IL2CPP_TYPE_I8:
		case IL2CPP_TYPE_U8:
			return ArgCommonType::I8;
		case IL2CPP_TYPE_R8:
			return ArgCommonType::R8;
		case IL2CPP_TYPE_I:
		case IL2CPP_TYPE_U:
		case IL2CPP_TYPE_FNPTR:
		case IL2CPP_TYPE_PTR:
		case IL2CPP_TYPE_BYREF:
		case IL2CPP_TYPE_STRING:
		case IL2CPP_TYPE_ARRAY:
		case IL2CPP_TYPE_SZARRAY:
		case IL2CPP_TYPE_OBJECT:
		case IL2CPP_TYPE_CLASS:
			return NATIVE_INT_COMMON_TYPE;
		case IL2CPP_TYPE_TYPEDBYREF:
			return ArgCommonType::NOT_SUPPORT;
		case IL2CPP_TYPE_VALUETYPE:
		{
			Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
			IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
			if (klass->enumtype)
			{
				return ComputArgCommonType(&klass->castClass->byval_arg);
			}
			return ComputValueTypeArgCommonType(klass);
		}
		case IL2CPP_TYPE_GENERICINST:
		{
			Il2CppGenericClass* genericClass = type->data.generic_class;
			if (genericClass->type->type == IL2CPP_TYPE_CLASS)
			{
				IL2CPP_ASSERT(!IS_CLASS_VALUE_TYPE(il2cpp::vm::Class::FromIl2CppType(type)));
				return NATIVE_INT_COMMON_TYPE;
			}
			else
			{
				Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
				IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
				if (klass->enumtype)
				{
					return ComputArgCommonType(&klass->castClass->byval_arg);
				}
				return ComputValueTypeArgCommonType(klass);
			}
		}
		default:
		{
			RaiseExecutionEngineException("not support arg type");
			return ArgCommonType::NOT_SUPPORT;
		}
		}
	}

	ArgCommonType ComputMethodArgHomoType(const MethodInfo* method)
	{
		ArgCommonType homoType = ComputArgCommonType(GET_METHOD_PARAMETER_TYPE(method->parameters[0]));
		if (homoType == ArgCommonType::NOT_SUPPORT)
		{
			return homoType;
		}
		for (uint8_t i = 1; i < method->parameters_count; i++)
		{
			ArgCommonType pt = ComputArgCommonType(GET_METHOD_PARAMETER_TYPE(method->parameters[i]));
			if (pt != homoType)
			{
				return ArgCommonType::NOT_SUPPORT;
			}
		}
		return homoType;
	}

	constexpr int MAX_COMMON_PARAM_NUM = 4;

	bool TransformContext::TryAddCallCommonInstanceInstruments(const MethodInfo* method, uint32_t methodDataIndex)
	{
		const Il2CppType* returnType = method->return_type;
		int32_t paramCount = shareMethod->parameters_count;
		int32_t resolvedTotalArgdNum = paramCount + 1;
		int32_t callArgEvalStackIdxBase = evalStackTop - resolvedTotalArgdNum;
		uint16_t argBaseOffset = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);

		ArgCommonType actRet = ComputArgCommonType(returnType);
		if (actRet == ArgCommonType::NOT_SUPPORT || actRet == ArgCommonType::STRUCT)
		{
			return false;
		}
		if (paramCount == 0)
		{
			// (void,u1,i1,i2,u2,i4, i8, f4, f8, v2, v3, v4} func(object x);
			if (actRet == ArgCommonType::VOID)
			{
				CreateAddIR(ir, CallCommonNativeInstance_v_0);
				ir->method = methodDataIndex;
				ir->self = argBaseOffset;
				return true;
			}

			CreateAddIR(ir, CallCommonNativeInstance_i1_0);
			ir->method = methodDataIndex;
			ir->self = argBaseOffset;
			ir->ret = argBaseOffset;
			switch (actRet)
			{
			case ArgCommonType::I1:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_i1_0;
				break;
			}
			case ArgCommonType::U1:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_u1_0;
				break;
			}
			case ArgCommonType::I2:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_i2_0;
				break;
			}
			case ArgCommonType::U2:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_u2_0;
				break;
			}
			case ArgCommonType::I4:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_i4_0;
				break;
			}
			case ArgCommonType::I8:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_i8_0;
				break;
			}
			case ArgCommonType::R4:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_f4_0;
				break;
			}
			case ArgCommonType::R8:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeInstance_f8_0;
				break;
			}
			default:
				RaiseExecutionEngineException("TryAddCallCommonInstanceInstruments. unknown ArgCommonType ");
				break;
			}

			return true;
		}

		if (paramCount > MAX_COMMON_PARAM_NUM)
		{
			return false;
		}

		ArgCommonType actParam = ComputMethodArgHomoType(method);
		if (actParam == ArgCommonType::NOT_SUPPORT)
		{
			return false;
		}

#define SWITCH_INSTANCE_VOID(argType, argNum) \
switch (argNum) \
{\
case 1:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_v_##argType##_1);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	return true;\
}\
case 2:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_v_##argType##_2);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
	return true;\
}\
case 3:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_v_##argType##_3);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
	ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 3);\
	return true;\
}\
case 4:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_v_##argType##_4);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
	ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 3);\
	ir->param3 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 4);\
	return true;\
}\
default: return false;\
}

		// (void, u1, i4, i8, f4, f8} func(object this, T x1, ,, T xN); T={i4,i8,f4,f8}, N =[1,4]
		if (actRet == ArgCommonType::VOID)
		{
			switch (actParam)
			{
			case hybridclr::transform::ArgCommonType::I4:
			{
				SWITCH_INSTANCE_VOID(i4, paramCount);
				break;
			}
			case hybridclr::transform::ArgCommonType::I8:
			{
				SWITCH_INSTANCE_VOID(i8, paramCount);
				break;
			}
			case hybridclr::transform::ArgCommonType::R4:
			{
				SWITCH_INSTANCE_VOID(f4, paramCount);
				break;
			}
			case hybridclr::transform::ArgCommonType::R8:
			{
				SWITCH_INSTANCE_VOID(f8, paramCount);
				break;
			}
			default:
				return false;
			}
		}

#define SWITCH_INSTANCE_RET(retType, argType, argNum) \
switch (argNum) \
{\
case 1:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_##retType##_##argType##_1);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->ret = argBaseOffset;\
	return true;\
}\
case 2:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_##retType##_##argType##_2);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
	ir->ret = argBaseOffset;\
	return true;\
}\
case 3:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_##retType##_##argType##_3);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
	ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 3);\
	ir->ret = argBaseOffset;\
	return true;\
}\
case 4:\
{\
	CreateAddIR(ir, CallCommonNativeInstance_##retType##_##argType##_4);\
	ir->method = methodDataIndex;\
	ir->self = argBaseOffset;\
	ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
	ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
	ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 3);\
	ir->param3 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 4);\
	ir->ret = argBaseOffset;\
	return true;\
}\
default: return false;\
}

#define SWTCH_INSTANCE_RET2(retType) \
switch (actParam)\
{\
case hybridclr::transform::ArgCommonType::I4:\
{\
	SWITCH_INSTANCE_RET(retType, i4, paramCount);\
	break;\
}\
case hybridclr::transform::ArgCommonType::I8:\
{\
	SWITCH_INSTANCE_RET(retType, i8, paramCount);\
	break;\
}\
case hybridclr::transform::ArgCommonType::R4:\
{\
	SWITCH_INSTANCE_RET(retType, f4, paramCount);\
	break;\
}\
case hybridclr::transform::ArgCommonType::R8:\
{\
	SWITCH_INSTANCE_RET(retType, f8, paramCount);\
	break;\
}\
default:\
	return false;\
}

		switch (actRet)
		{
		case ArgCommonType::U1:
		{
			SWTCH_INSTANCE_RET2(u1);
			break;
		}
		case ArgCommonType::I4:
		{
			SWTCH_INSTANCE_RET2(i4);
			break;
		}
		case ArgCommonType::I8:
		{
			SWTCH_INSTANCE_RET2(i8);
			break;
		}
		case ArgCommonType::R4:
		{
			SWTCH_INSTANCE_RET2(f4);
			break;
		}
		case ArgCommonType::R8:
		{
			SWTCH_INSTANCE_RET2(f8);
			break;
		}
		default:break;
		}

		return false;
	}

	bool TransformContext::TryAddCallCommonStaticInstruments(const MethodInfo* method, uint32_t methodDataIndex)
	{
		const Il2CppType* returnType = method->return_type;
		int32_t paramCount = shareMethod->parameters_count;
		int32_t resolvedTotalArgdNum = paramCount;
		int32_t callArgEvalStackIdxBase = evalStackTop - resolvedTotalArgdNum;
		uint16_t argBaseOffset = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);

		ArgCommonType actRet = ComputArgCommonType(returnType);
		if (actRet == ArgCommonType::NOT_SUPPORT || actRet == ArgCommonType::STRUCT)
		{
			return false;
		}
		if (paramCount == 0)
		{
			// (void,u1,i1,i2,u2,i4, i8, f4, f8, v2, v3, v4} func();
			if (actRet == ArgCommonType::VOID)
			{
				CreateAddIR(ir, CallCommonNativeStatic_v_0);
				ir->method = methodDataIndex;
				return true;
			}

			CreateAddIR(ir, CallCommonNativeStatic_i1_0);
			ir->method = methodDataIndex;
			ir->ret = argBaseOffset;
			switch (actRet)
			{
			case ArgCommonType::I1:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_i1_0;
				break;
			}
			case ArgCommonType::U1:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_u1_0;
				break;
			}
			case ArgCommonType::I2:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_i2_0;
				break;
			}
			case ArgCommonType::U2:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_u2_0;
				break;
			}
			case ArgCommonType::I4:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_i4_0;
				break;
			}
			case ArgCommonType::I8:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_i8_0;
				break;
			}
			case ArgCommonType::R4:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_f4_0;
				break;
			}
			case ArgCommonType::R8:
			{
				ir->type = HiOpcodeEnum::CallCommonNativeStatic_f8_0;
				break;
			}
			default:
				RaiseExecutionEngineException("TryAddCallCommonStaticInstruments. unknown ArgCommonType ");
				break;
			}

			return true;
		}

		if (paramCount > MAX_COMMON_PARAM_NUM)
		{
			return false;
		}

		ArgCommonType actParam = ComputMethodArgHomoType(method);
		if (actParam == ArgCommonType::NOT_SUPPORT)
		{
			return false;
		}

#define SWITCH_STATIC_VOID(argType, argNum) \
	switch (argNum) \
	{\
	case 1:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_v_##argType##_1);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		return true;\
	}\
	case 2:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_v_##argType##_2);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
		return true;\
	}\
	case 3:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_v_##argType##_3);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
		ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
		return true;\
	}\
	case 4:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_v_##argType##_4);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
		ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
		ir->param3 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 3);\
		return true;\
	}\
	default: return false;\
	}

		// (void, u1, i4, i8, f4, f8} func(object this, T x1, ,, T xN); T={i4,i8,f4,f8}, N =[1,4]
		if (actRet == ArgCommonType::VOID)
		{
			switch (actParam)
			{
			case hybridclr::transform::ArgCommonType::I4:
			{
				SWITCH_STATIC_VOID(i4, paramCount);
				break;
			}
			case hybridclr::transform::ArgCommonType::I8:
			{
				SWITCH_STATIC_VOID(i8, paramCount);
				break;
			}
			case hybridclr::transform::ArgCommonType::R4:
			{
				SWITCH_STATIC_VOID(f4, paramCount);
				break;
			}
			case hybridclr::transform::ArgCommonType::R8:
			{
				SWITCH_STATIC_VOID(f8, paramCount);
				break;
			}
			default:
				return false;
			}
		}

#define SWITCH_STATIC_RET(retType, argType, argNum) \
	switch (argNum) \
	{\
	case 1:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_##retType##_##argType##_1);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->ret = argBaseOffset;\
		return true;\
	}\
	case 2:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_##retType##_##argType##_2);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
		ir->ret = argBaseOffset;\
		return true;\
	}\
	case 3:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_##retType##_##argType##_3);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
		ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
		ir->ret = argBaseOffset;\
		return true;\
	}\
	case 4:\
	{\
		CreateAddIR(ir, CallCommonNativeStatic_##retType##_##argType##_4);\
		ir->method = methodDataIndex;\
		ir->param0 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);\
		ir->param1 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 1);\
		ir->param2 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 2);\
		ir->param3 = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase + 3);\
		ir->ret = argBaseOffset;\
		return true;\
	}\
	default: return false;\
	}

#define SWTCH_STATIC_RET2(retType) \
	switch (actParam)\
	{\
	case hybridclr::transform::ArgCommonType::I4:\
	{\
		SWITCH_STATIC_RET(retType, i4, paramCount);\
		break;\
	}\
	case hybridclr::transform::ArgCommonType::I8:\
	{\
		SWITCH_STATIC_RET(retType, i8, paramCount);\
		break;\
	}\
	case hybridclr::transform::ArgCommonType::R4:\
	{\
		SWITCH_STATIC_RET(retType, f4, paramCount);\
		break;\
	}\
	case hybridclr::transform::ArgCommonType::R8:\
	{\
		SWITCH_STATIC_RET(retType, f8, paramCount);\
		break;\
	}\
	default:\
		return false;\
	}

		switch (actRet)
		{
		case ArgCommonType::U1:
		{
			SWTCH_STATIC_RET2(u1);
			break;
		}
		case ArgCommonType::I4:
		{
			SWTCH_STATIC_RET2(i4);
			break;
		}
		case ArgCommonType::I8:
		{
			SWTCH_STATIC_RET2(i8);
			break;
		}
		case ArgCommonType::R4:
		{
			SWTCH_STATIC_RET2(f4);
			break;
		}
		case ArgCommonType::R8:
		{
			SWTCH_STATIC_RET2(f8);
			break;
		}
		default: break;
		}
		return false;
	}
}
}
```

`hybridclr/transform/TransformContext_Instinct.cpp`:

```cpp
#include "TransformContext.h"

#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"
#include "utils/StringUtils.h"

namespace hybridclr
{
namespace transform
{
	struct NamespaceAndName
	{
		const char* namespaze;
		const char* name;
	};

	struct NamespaceAndNameHash
	{
		size_t operator()(const NamespaceAndName& pair) const
		{
			size_t h = il2cpp::utils::StringUtils::Hash(pair.namespaze);
			h = il2cpp::utils::HashUtils::Combine(h, il2cpp::utils::StringUtils::Hash(pair.name));
			return h;
		}
	};

	struct NamespaceAndNameEquals
	{
		bool operator()(const NamespaceAndName& p1, const NamespaceAndName& p2) const
		{
			return !strcmp(p1.namespaze, p2.namespaze)
				&& !strcmp(p1.name, p2.name);
		}
	};

	struct NamespaceAndNameAndMethod
	{
		const char* namespaze;
		const char* name;
		const char* method;
	};

	struct NamespaceAndNameAndMethodHash
	{
		size_t operator()(const NamespaceAndNameAndMethod& pair) const
		{
			size_t h = il2cpp::utils::StringUtils::Hash(pair.namespaze);
			h = il2cpp::utils::HashUtils::Combine(h, il2cpp::utils::StringUtils::Hash(pair.name));
			h = il2cpp::utils::HashUtils::Combine(h, il2cpp::utils::StringUtils::Hash(pair.method));
			return h;
		}
	};

	struct NamespaceAndNameAndMethodEquals
	{
		bool operator()(const NamespaceAndNameAndMethod& p1, const NamespaceAndNameAndMethod& p2) const
		{
			return !strcmp(p1.namespaze, p2.namespaze)
				&& !strcmp(p1.name, p2.name)
				&& !strcmp(p1.method, p2.method);
		}
	};

	typedef bool (*InstinctHandler)(TransformContext& ctx, const MethodInfo* method);

	typedef Il2CppHashMap<NamespaceAndNameAndMethod, InstinctHandler, NamespaceAndNameAndMethodHash, NamespaceAndNameAndMethodEquals> InstinctHandlerMap;

	static InstinctHandlerMap s_instinctHandlerMap;

	typedef Il2CppHashMap<NamespaceAndName, InstinctHandler, NamespaceAndNameHash, NamespaceAndNameEquals> CtorInstinctHandlerMap;
	static CtorInstinctHandlerMap s_ctorInstinctHandlerMap;

#define IHCreateAddIR(varName, typeName) IR##typeName* varName = ctx.GetPool().AllocIR<IR##typeName>(); varName->type = HiOpcodeEnum::typeName; ctx.AddInst(varName);


	static bool IH_object_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		ctx.PopStack();
		auto& insts = ctx.GetCurbb()->insts;
		if (!insts.empty())
		{
			IRCommon* last = insts.back();
			if (last->type != HiOpcodeEnum::LdlocVarVar)
			{
				return true;
			}
			IRLdlocVarVar* ldthis = (IRLdlocVarVar*)last;
			if (ldthis->dst == ctx.GetEvalStackNewTopOffset())
			{
				// pop ldthis
				insts.pop_back();
			}
		}
		return true;
	}

	static bool IH_Nullable_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		if (method->parameters_count != 1)
		{
			return false;
		}
		Il2CppClass* klass = method->klass;
		il2cpp::vm::Class::SetupFields(klass);
		il2cpp::vm::Class::SetupFields(klass->castClass);

		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
		IHCreateAddIR(ir, NullableCtorVarVar);
		ir->dst = ctx.GetEvalStackOffset_2();
		ir->data = ctx.GetEvalStackOffset_1();
		ir->klass = ctx.GetOrAddResolveDataIndex(klass);

		ctx.PopStackN(2);
		return true;
	}

	static bool IH_Nullable_GetValueOrDefault(TransformContext& ctx, const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;
		il2cpp::vm::Class::SetupFields(klass);
		il2cpp::vm::Class::SetupFields(klass->castClass);
		uint32_t classIndirectIndex = ctx.GetOrAddResolveDataIndex(klass);
		uint16_t topOffset = ctx.GetEvalStackTopOffset();
		if (method->parameters_count == 0)
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 1);
			IHCreateAddIR(ir, NullableGetValueOrDefaultVarVar);
			ir->dst = topOffset;
			ir->obj = topOffset;
			ir->klass = classIndirectIndex;

			// pop this, push value
			ctx.PopStack();
			ctx.PushStackByType(&klass->castClass->byval_arg);
			return true;
		}
		else if (method->parameters_count == 1)
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
			IHCreateAddIR(ir, NullableGetValueOrDefaultVarVar_1);
			ir->dst = ir->obj = ctx.GetEvalStackOffset_2();
			ir->defaultValue = topOffset;
			ir->klass = classIndirectIndex;

			// pop this, default value then push value
			ctx.PopStackN(2);
			ctx.PushStackByType(&klass->castClass->byval_arg);
			return true;
		}
		return false;
	}

	static bool IH_Nullable_get_HasValue(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 1);
		Il2CppClass* klass = method->klass;
		il2cpp::vm::Class::SetupFields(klass);
		il2cpp::vm::Class::SetupFields(klass->castClass);
		uint32_t classIndirectIndex = ctx.GetOrAddResolveDataIndex(klass);
		uint16_t topOffset = ctx.GetEvalStackTopOffset();

		IHCreateAddIR(ir, NullableHasValueVar);
		ir->result = topOffset;
		ir->obj = topOffset;
		ir->klass = classIndirectIndex;

		// pop this, push value
		ctx.PopStack();
		ctx.PushStackByReduceType(EvalStackReduceDataType::I4);
		return true;
	}

	static bool IH_Nullable_get_Value(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 1);
		Il2CppClass* klass = method->klass;
		il2cpp::vm::Class::SetupFields(klass);
		il2cpp::vm::Class::SetupFields(klass->castClass);
		uint32_t classIndirectIndex = ctx.GetOrAddResolveDataIndex(klass);
		uint16_t topOffset = ctx.GetEvalStackTopOffset();

		IHCreateAddIR(ir, NullableGetValueVarVar);
		ir->dst = topOffset;
		ir->obj = topOffset;
		ir->klass = classIndirectIndex;

		// pop this, push value
		ctx.PopStack();
		ctx.PushStackByType(&klass->castClass->byval_arg);
		return true;
	}

	static bool IH_Array_GetGenericValueImpl(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
		uint16_t topOffset = ctx.GetEvalStackTopOffset();
		IHCreateAddIR(ir, ArrayGetGenericValueImpl);
		ir->arr = ctx.GetEvalStackOffset_3();
		ir->index = ctx.GetEvalStackOffset_2();
		ir->value = ctx.GetEvalStackOffset_1();
		ctx.PopStackN(3);
		return true;
	}

	static bool IH_Array_SetGenericValueImpl(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
		uint16_t topOffset = ctx.GetEvalStackTopOffset();
		IHCreateAddIR(ir, ArraySetGenericValueImpl);
		ir->arr = ctx.GetEvalStackOffset_3();
		ir->index = ctx.GetEvalStackOffset_2();
		ir->value = ctx.GetEvalStackOffset_1();
		ctx.PopStackN(3);
		return true;
	}

	static bool IH_Interlocked_CompareExchange(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
		uint16_t retIdx = ctx.GetEvalStackOffset_3();
		uint16_t locationIdx = retIdx;
		uint16_t valueIdx = ctx.GetEvalStackOffset_2();
		uint16_t comparandIdx = ctx.GetEvalStackOffset_1();

		IHCreateAddIR(ir, InterlockedCompareExchangeVarVarVarVar_pointer);
		ir->ret = retIdx;
		ir->location = locationIdx;
		ir->value = valueIdx;
		ir->comparand = comparandIdx;

		const Il2CppType* paramType = GET_METHOD_PARAMETER_TYPE(method->parameters[1]);
		if (!paramType->byref)
		{
			Il2CppClass* paramKlass = il2cpp::vm::Class::FromIl2CppType(paramType);
			if (IS_CLASS_VALUE_TYPE(paramKlass))
			{
				uint32_t valueSize = GetTypeValueSize(paramKlass);
				if (valueSize == 4)
				{
					ir->type = HiOpcodeEnum::InterlockedCompareExchangeVarVarVarVar_i4;
				}
				else if (valueSize == 8)
				{
					ir->type = HiOpcodeEnum::InterlockedCompareExchangeVarVarVarVar_i8;
				}
				else
				{
					RaiseExecutionEngineException("not support System.Threading.Interlocked.CompareExchange");
				}
			}
		}
		ctx.PopStackN(3);
		ctx.PushStackByType(paramType);

		return true;
	}

	static bool IH_Interlocked_Exchange(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
		uint16_t retIdx = ctx.GetEvalStackOffset_2();
		uint16_t locationIdx = retIdx;
		uint16_t valueIdx = ctx.GetEvalStackOffset_1();

		IHCreateAddIR(ir, InterlockedExchangeVarVarVar_pointer);
		ir->ret = retIdx;
		ir->location = locationIdx;
		ir->value = valueIdx;

		const Il2CppType* paramType = GET_METHOD_PARAMETER_TYPE(method->parameters[1]);
		if (!paramType->byref)
		{
			Il2CppClass* paramKlass = il2cpp::vm::Class::FromIl2CppType(paramType);
			if (IS_CLASS_VALUE_TYPE(paramKlass))
			{
				uint32_t valueSize = GetTypeValueSize(paramKlass);
				if (valueSize == 4)
				{
					ir->type = HiOpcodeEnum::InterlockedExchangeVarVarVar_i4;
				}
				else if (valueSize == 8)
				{
					ir->type = HiOpcodeEnum::InterlockedExchangeVarVarVar_i8;
				}
				else
				{
					RaiseExecutionEngineException("not support System.Threading.Interlocked.Exchange");
				}
			}
		}
		ctx.PopStackN(2);
		ctx.PushStackByType(paramType);
		return true;
	}

	static bool IH_JitHelpers_UnsafeEnumCast(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 1);
		IHCreateAddIR(ir, UnsafeEnumCast);
		ir->dst = ctx.GetEvalStackTopOffset();
		ir->src = ctx.GetEvalStackTopOffset();
		const Il2CppType* srcType = method->genericMethod->context.method_inst->type_argv[0];
		if (srcType->type == IL2CPP_TYPE_VALUETYPE || srcType->type == IL2CPP_TYPE_GENERICINST)
		{
			Il2CppClass* srcKlass = il2cpp::vm::Class::FromIl2CppType(srcType);
			if (!srcKlass->enumtype)
			{
				RaiseExecutionEngineException("not support UnsafeEnumCast src type");
			}
			ir->srcType = (uint16_t)srcKlass->castClass->byval_arg.type;
		}
		else
		{
			ir->srcType = (uint16_t)srcType->type;
		}
		ctx.PopStack();
		ctx.PushStackByReduceType(EvalStackReduceDataType::I4);
		return true;
	}

	static bool IH_JitHelpers_UnsafeCast(TransformContext& ctx, const MethodInfo* method)
	{
		return true;
	}

	static bool IH_JitHelpers_UnsafeEnumCastLong(TransformContext& ctx, const MethodInfo* method)
	{
		return true;
	}

	static bool IH_Assembly_GetExecutingAssembly(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 0);
		IHCreateAddIR(ir, AssemblyGetExecutingAssembly);
		ir->ret = ctx.GetEvalStackNewTopOffset();
		ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
		return true;
	}

	static bool IH_MethodBase_GetCurrentMethod(TransformContext& ctx, const MethodInfo* method)
	{
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 0);
		IHCreateAddIR(ir, MethodBaseGetCurrentMethod);
		ir->ret = ctx.GetEvalStackNewTopOffset();
		ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
		return true;
	}

	static bool IH_UnityEngine_Vector2_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		if (method->parameters_count != 2)
		{
			return false;
		}
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
		IHCreateAddIR(ir, CtorVector2);
		ir->obj = ctx.GetEvalStackOffset_3();
		ir->x = ctx.GetEvalStackOffset_2();
		ir->y = ctx.GetEvalStackOffset_1();
		ctx.PopStackN(3);
		return true;
	}

	static bool IH_UnityEngine_Vector3_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		switch (method->parameters_count)
		{
		case 2:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
			IHCreateAddIR(ir, CtorVector3_2);
			ir->obj = ctx.GetEvalStackOffset_3();
			ir->x = ctx.GetEvalStackOffset_2();
			ir->y = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(3);
			return true;
		}
		case 3:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 4);
			IHCreateAddIR(ir, CtorVector3_3);
			ir->obj = ctx.GetEvalStackOffset_4();
			ir->x = ctx.GetEvalStackOffset_3();
			ir->y = ctx.GetEvalStackOffset_2();
			ir->z = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(4);
			return true;
		}
		default: return false;
		}
	}

	static bool IH_UnityEngine_Vector4_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		switch (method->parameters_count)
		{
		case 2:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
			IHCreateAddIR(ir, CtorVector4_2);
			ir->obj = ctx.GetEvalStackOffset_3();
			ir->x = ctx.GetEvalStackOffset_2();
			ir->y = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(3);
			return true;
		}
		case 3:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 4);
			IHCreateAddIR(ir, CtorVector4_3);
			ir->obj = ctx.GetEvalStackOffset_4();
			ir->x = ctx.GetEvalStackOffset_3();
			ir->y = ctx.GetEvalStackOffset_2();
			ir->z = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(4);
			return true;
		}
		case 4:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 5);
			IHCreateAddIR(ir, CtorVector4_4);
			ir->obj = ctx.GetEvalStackOffset_5();
			ir->x = ctx.GetEvalStackOffset_4();
			ir->y = ctx.GetEvalStackOffset_3();
			ir->z = ctx.GetEvalStackOffset_2();
			ir->w = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(5);
			return true;
		}
		default: return false;
		}
	}

	static bool IH_ByReference_get_Value(TransformContext& ctx, const MethodInfo* method)
	{
		// ByReference<T>.Value equals to *this
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 1);

		IHCreateAddIR(ir, LdindVarVar_i1);
		ir->type = ARCH_ARGUMENT(HiOpcodeEnum::LdindVarVar_i4, HiOpcodeEnum::LdindVarVar_i8);
		ir->dst = ir->src = ctx.GetEvalStackTopOffset();
		ctx.PopStack();
		ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
		return true;
	}

	static const MethodInfo* FindZeroArgumentCtor(Il2CppClass* klass)
	{
		il2cpp::vm::Class::Init(klass);
		for (uint16_t i = 0; i < klass->method_count; i++)
		{
            const MethodInfo* method = klass->methods[i];
			if (!std::strcmp(method->name, ".ctor") && method->parameters_count == 0)
			{
				return method;
            }
		}
		return nullptr;
    }

	static bool IH_Activator_CreateInstance(TransformContext& ctx, const MethodInfo* method)
	{
		if (!method->is_inflated || method->genericMethod->context.method_inst->type_argc != 1 || method->parameters_count != 0)
		{
			return false;
		}
		const Il2CppType* instType = method->genericMethod->context.method_inst->type_argv[0];
		Il2CppClass* instanceKlass = il2cpp::vm::Class::FromIl2CppType(instType);
		if (instanceKlass == nullptr)
		{
			return false;
		}
		if (IS_CLASS_VALUE_TYPE(instanceKlass))
		{
			if (instanceKlass->castClass->byval_arg.type < IL2CPP_TYPE_I4)
			{
				return false;
			}
			IHCreateAddIR(ir, NewValueTypeVar_Ctor_0);
			uint32_t objSize = GetTypeValueSize(instanceKlass);
			ir->obj = ctx.GetEvalStackNewTopOffset();
			ir->size = objSize;
			ctx.PushStackByType(&instanceKlass->byval_arg);
			return true;
		}
		else
		{
			return false;
			/*
			const MethodInfo* ctorMethod = FindZeroArgumentCtor(instanceKlass);
			if (ctorMethod == nullptr)
			{
				return false;
			}
			if (!InitAndGetInterpreterDirectlyCallMethodPointer(ctorMethod))
			{
				RaiseAOTGenericMethodNotInstantiatedException(ctorMethod);
			}
			//return false;
			IHCreateAddIR(ir, NewClassVar_Ctor_0);
			ir->method = ctx.GetOrAddResolveDataIndex(ctorMethod);
			ir->obj = ctx.GetEvalStackNewTopOffset();
			ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
			*/
		}
	}


	struct InstinctHandlerInfo
	{
		const char* namespaze;
		const char* name;
		const char* method;
		InstinctHandler handler;
	};

	static InstinctHandlerInfo s_instinctHandlerInfos[] =
	{
		{"System", "Object", ".ctor", IH_object_ctor},
		{"System", "Nullable`1", ".ctor", IH_Nullable_ctor},
		{"System", "Nullable`1", "GetValueOrDefault", IH_Nullable_GetValueOrDefault},
		{"System", "Nullable`1", "get_HasValue", IH_Nullable_get_HasValue},
		{"System", "Nullable`1", "get_Value", IH_Nullable_get_Value},
		{"System", "Array", "GetGenericValueImpl", IH_Array_GetGenericValueImpl},
		{"System", "Array", "SetGenericValueImpl", IH_Array_SetGenericValueImpl},
		{"System.Threading", "Interlocked", "CompareExchange", IH_Interlocked_CompareExchange},
		{"System.Threading", "Interlocked", "Exchange", IH_Interlocked_Exchange},
		{"System.Runtime.CompilerServices", "JitHelpers", "UnsafeEnumCast", IH_JitHelpers_UnsafeEnumCast},
		{"System.Runtime.CompilerServices", "JitHelpers", "UnsafeCast", IH_JitHelpers_UnsafeCast},
		{"System.Runtime.CompilerServices", "JitHelpers", "UnsafeEnumCastLong", IH_JitHelpers_UnsafeEnumCastLong},
		{"System.Reflection", "Assembly", "GetExecutingAssembly", IH_Assembly_GetExecutingAssembly},
		{"System.Reflection", "MethodBase", "GetCurrentMethod", IH_MethodBase_GetCurrentMethod},
		{"UnityEngine", "Vector2", ".ctor", IH_UnityEngine_Vector2_ctor},
		{"UnityEngine", "Vector3", ".ctor", IH_UnityEngine_Vector3_ctor},
		{"UnityEngine", "Vector4", ".ctor", IH_UnityEngine_Vector4_ctor},
		{"System", "ByReference`1", "get_Value", IH_ByReference_get_Value},
		{"System", "Activator", "CreateInstance", IH_Activator_CreateInstance},
	};

	struct CtorInstinctHandlerInfo
	{
		const char* namespaze;
		const char* name;
		InstinctHandler handler;
	};

	static bool CIH_Object(TransformContext& ctx, const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;
		IHCreateAddIR(ir, NewSystemObjectVar);
		ir->obj = ctx.GetEvalStackNewTopOffset();
		ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
		return true;
	}

	static bool CIH_String(TransformContext& ctx, const MethodInfo* method)
	{
		switch (method->parameters_count)
		{
		case 1:
		{
			const Il2CppType* paramType = GET_METHOD_PARAMETER_TYPE(method->parameters[0]);
			if (paramType->type == IL2CPP_TYPE_SZARRAY && paramType->data.type->type == IL2CPP_TYPE_CHAR)
			{
				// new string(char[])
				IHCreateAddIR(ir, NewString);
				ir->str = ctx.GetEvalStackTopOffset();
				ir->chars = ctx.GetEvalStackTopOffset();
				return true;
			}
			return false;
		}
		case 2:
		{
			const Il2CppType* paramType1 = GET_METHOD_PARAMETER_TYPE(method->parameters[0]);
			const Il2CppType* paramType2 = GET_METHOD_PARAMETER_TYPE(method->parameters[1]);
			if (paramType1->type == IL2CPP_TYPE_CHAR && paramType2->type == IL2CPP_TYPE_I4)
			{
				IHCreateAddIR(ir, NewString_3);
				ir->str = ctx.GetEvalStackOffset_2();
				ir->c = ctx.GetEvalStackOffset_2();
				ir->count = ctx.GetEvalStackOffset_1();
				ctx.PopStack();
				return true;
			}
			return false;
		}
		case 3:
		{
			// new string(char[] chars, int startIndex, int length)
			const Il2CppType* paramType1 = GET_METHOD_PARAMETER_TYPE(method->parameters[0]);
			const Il2CppType* paramType2 = GET_METHOD_PARAMETER_TYPE(method->parameters[1]);
			const Il2CppType* paramType3 = GET_METHOD_PARAMETER_TYPE(method->parameters[2]);
			if (paramType1->type == IL2CPP_TYPE_SZARRAY && paramType1->data.type->type == IL2CPP_TYPE_CHAR
				&& paramType2->type == IL2CPP_TYPE_I4 && paramType3->type == IL2CPP_TYPE_I4)
			{
				IHCreateAddIR(ir, NewString_2);
				ir->str = ctx.GetEvalStackOffset_3();
				ir->chars = ctx.GetEvalStackOffset_3();
				ir->startIndex = ctx.GetEvalStackOffset_2();
				ir->length = ctx.GetEvalStackOffset_1();
				ctx.PopStackN(2);
				return true;
			}
			return false;
		}
		default: return false;
		}
	}

	static bool CIH_Nullable(TransformContext& ctx, const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;
		IL2CPP_ASSERT(IS_CLASS_VALUE_TYPE(klass));
		IL2CPP_ASSERT(ctx.GetEvalStackTop() > 0);
		il2cpp::vm::Class::SetupFields(klass);
		il2cpp::vm::Class::SetupFields(klass->castClass);
		IHCreateAddIR(ir, NullableNewVarVar);
		ir->dst = ir->data = ctx.GetEvalStackTopOffset();
		ir->klass = ctx.GetOrAddResolveDataIndex(klass);
		ctx.PopStack();
		ctx.PushStackByType(&klass->byval_arg);
		return true;
	}

	static bool CIH_MdArray(TransformContext& ctx, const MethodInfo* method)
	{
		uint8_t paramCount = method->parameters_count;
		Il2CppClass* klass = method->klass;
		if (klass->rank == paramCount)
		{
			IHCreateAddIR(ir, NewMdArrVarVar_length);
			ir->lengthIdxs = ctx.GetEvalStackOffset(ctx.GetEvalStackTop() - paramCount);
			ctx.PopStackN(paramCount);
			ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
			ir->arr = ctx.GetEvalStackTopOffset();
			ir->klass = ctx.GetOrAddResolveDataIndex(klass);
		}
		else if (klass->rank * 2 == paramCount)
		{
			IHCreateAddIR(ir, NewMdArrVarVar_length_bound);
			ir->lengthIdxs = ctx.GetEvalStackOffset(ctx.GetEvalStackTop() - paramCount);
			ir->lowerBoundIdxs = ctx.GetEvalStackOffset(ctx.GetEvalStackTop() - klass->rank);
			ctx.PopStackN(paramCount);
			ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
			ir->arr = ctx.GetEvalStackTopOffset();
			ir->klass = ctx.GetOrAddResolveDataIndex(klass);
		}
		else
		{
			RaiseExecutionEngineException("not support array ctor");
		}
		return true;
	}

	static bool CIH_Delegate(TransformContext& ctx, const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
#if HYBRIDCLR_UNITY_2021_OR_NEW
		const MethodInfo* ctor = il2cpp::vm::Class::GetMethodFromName(method->klass, ".ctor", 2);
		if (ctor && ctor->methodPointer && !ctor->isInterpterImpl)
		{
			IHCreateAddIR(ir, CtorDelegate);
			ir->dst = ir->obj = ctx.GetEvalStackOffset_2();
			ir->ctor = ctx.GetOrAddResolveDataIndex(ctor);
			ir->method = ctx.GetEvalStackOffset_1();
		}
		else
		{
			IHCreateAddIR(ir, NewDelegate);
			ir->dst = ir->obj = ctx.GetEvalStackOffset_2();
			ir->klass = ctx.GetOrAddResolveDataIndex(klass);
			ir->method = ctx.GetEvalStackOffset_1();
		}
#else
		IHCreateAddIR(ir, NewDelegate);
		ir->dst = ir->obj = ctx.GetEvalStackOffset_2();
		ir->klass = ctx.GetOrAddResolveDataIndex(klass);
		ir->method = ctx.GetEvalStackOffset_1();
#endif
		ctx.PopStackN(2);
		ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
		return true;
	}

	static bool CIH_UnityEngine_Vector2_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		if (method->parameters_count != 2)
		{
			return false;
		}
		IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
		IHCreateAddIR(ir, NewVector2);
		ir->obj = ir->x = ctx.GetEvalStackOffset_2();
		ir->y = ctx.GetEvalStackOffset_1();
		ctx.PopStackN(2);
		ctx.PushStackByType(&method->klass->byval_arg);
		return true;
	}

	static bool CIH_UnityEngine_Vector3_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		switch (method->parameters_count)
		{
		case 2:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
			IHCreateAddIR(ir, NewVector3_2);
			ir->obj = ir->x = ctx.GetEvalStackOffset_2();
			ir->y = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(2);
			ctx.PushStackByType(&method->klass->byval_arg);
			return true;
		}
		case 3:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
			IHCreateAddIR(ir, NewVector3_3);
			ir->obj = ir->x = ctx.GetEvalStackOffset_3();
			ir->y = ctx.GetEvalStackOffset_2();
			ir->z = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(3);
			ctx.PushStackByType(&method->klass->byval_arg);
			return true;
		}
		default: return false;
		}
	}

	static bool CIH_UnityEngine_Vector4_ctor(TransformContext& ctx, const MethodInfo* method)
	{
		switch (method->parameters_count)
		{
		case 2:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 2);
			IHCreateAddIR(ir, NewVector4_2);
			ir->obj = ir->x = ctx.GetEvalStackOffset_2();
			ir->y = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(2);
			ctx.PushStackByType(&method->klass->byval_arg);
			return true;
		}
		case 3:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 3);
			IHCreateAddIR(ir, NewVector4_3);
			ir->obj = ir->x = ctx.GetEvalStackOffset_3();
			ir->y = ctx.GetEvalStackOffset_2();
			ir->z = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(3);
			ctx.PushStackByType(&method->klass->byval_arg);
			return true;
		}
		case 4:
		{
			IL2CPP_ASSERT(ctx.GetEvalStackTop() >= 4);
			IHCreateAddIR(ir, NewVector4_4);
			ir->obj = ir->x = ctx.GetEvalStackOffset_4();
			ir->y = ctx.GetEvalStackOffset_3();
			ir->z = ctx.GetEvalStackOffset_2();
			ir->w = ctx.GetEvalStackOffset_1();
			ctx.PopStackN(4);
			ctx.PushStackByType(&method->klass->byval_arg);
			return true;
		}
		default: return false;
		}
	}

	static bool CIH_ByReference(TransformContext& ctx, const MethodInfo* method)
	{
		// new ByReference<T>(ref T value) don't need to do anything
		Il2CppClass* klass = method->klass;
		IL2CPP_ASSERT(ctx.GetEvalStackTop() > 0);
		ctx.PopStack();
		ctx.PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
		return true;
	}

	static CtorInstinctHandlerInfo s_ctorInstinctHandlerInfos[] =
	{
		{"System", "Object", CIH_Object},
		{"System", "String", CIH_String},
		{"System", "Nullable`1", CIH_Nullable},

		{"UnityEngine", "Vector2", CIH_UnityEngine_Vector2_ctor},
		{"UnityEngine", "Vector3", CIH_UnityEngine_Vector3_ctor},
		{"UnityEngine", "Vector4", CIH_UnityEngine_Vector4_ctor},

		{"System", "ByReference`1", CIH_ByReference},
	};
	
	void TransformContext::InitializeInstinctHandlers()
	{
		for (InstinctHandlerInfo& handler : s_instinctHandlerInfos)
		{
			NamespaceAndNameAndMethod nnm = { handler.namespaze, handler.name, handler.method };
			s_instinctHandlerMap.add(nnm, handler.handler);
		}
		for (CtorInstinctHandlerInfo& handler : s_ctorInstinctHandlerInfos)
		{
			NamespaceAndName nnm = { handler.namespaze, handler.name };
			s_ctorInstinctHandlerMap.add(nnm, handler.handler);
		}
	}
	
	bool TransformContext::TryAddInstinctCtorInstruments(const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;

		if (klass->byval_arg.type == IL2CPP_TYPE_ARRAY)
		{
			return CIH_MdArray(*this, method);
		}

		if (IsChildTypeOfMulticastDelegate(method->klass))
		{
			return CIH_Delegate(*this, method);
		}

		NamespaceAndName key = { klass->namespaze, klass->name };
		auto it = s_ctorInstinctHandlerMap.find(key);
		if (it != s_ctorInstinctHandlerMap.end())
		{
			return (it->second)(*this, method);
		}
		return false;
	}

	bool TransformContext::TryAddInstinctInstrumentsByName(const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;
		const char* namespaceName = klass->namespaze;
		const char* klassName = klass->name;
		const char* methodName = method->name;
		uint32_t paramCount = method->parameters_count;

		NamespaceAndNameAndMethod key = { namespaceName, klassName, methodName };
		auto it = s_instinctHandlerMap.find(key);
		if (it == s_instinctHandlerMap.end())
		{
			return false;
		}
		return (it->second)(*this, method);
	}

	bool TransformContext::TryAddArrayInstinctInstruments(const MethodInfo* method)
	{
		Il2CppClass* klass = method->klass;

		// warn! can't change to else if. because namespace == system
		if (klass->byval_arg.type == IL2CPP_TYPE_ARRAY)
		{
			const char* methodName = method->name;
			int32_t paramCount = method->parameters_count + 1;
			const Il2CppType* eleType = &klass->element_class->byval_arg;
			LocationDescInfo desc = ComputLocationDescInfo(eleType);
			if (strcmp(methodName, "Get") == 0)
			{
				CreateAddIR(ir, GetMdArrElementVarVar_n);
				ir->type = CalcGetMdArrElementVarVarOpcode(eleType);
				ir->arr = GetEvalStackOffset(evalStackTop - paramCount);
				ir->lengthIdxs = ir->arr + 1;
				PopStackN(paramCount);
				PushStackByType(eleType);
				ir->value = GetEvalStackTopOffset();
				return true;
			}
			else if (strcmp(methodName, "Address") == 0)
			{
				CreateAddIR(ir, GetMdArrElementAddressVarVar);
				ir->arr = GetEvalStackOffset(evalStackTop - paramCount);
				ir->lengthIdxs = ir->arr + 1;
				PopStackN(paramCount);
				PushStackByReduceType(NATIVE_INT_REDUCE_TYPE);
				ir->addr = GetEvalStackTopOffset();
				return true;
			}
			else if (strcmp(methodName, "Set") == 0)
			{
				CreateAddIR(ir, SetMdArrElementVarVar_n);
				switch (desc.type)
				{
				case LocationDescType::I1: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_i1; break;
				case LocationDescType::U1: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_u1; break;
				case LocationDescType::I2: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_i2; break;
				case LocationDescType::U2: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_u2; break;
				case LocationDescType::I4: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_i4; break;
				case LocationDescType::I8: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_i8; break;
				case LocationDescType::Ref: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_ref; break;
				case LocationDescType::S: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_n; break;
				case LocationDescType::StructContainsRef: ir->type = HiOpcodeEnum::SetMdArrElementVarVar_WriteBarrier_n; break;
				default: RaiseExecutionEngineException("not support array element type"); break;
				}
				ir->arr = GetEvalStackOffset(evalStackTop - paramCount);
				ir->lengthIdxs = ir->arr + 1;
				ir->ele = GetEvalStackTopOffset();
				PopStackN(paramCount);
				return true;
			}
		}
		return false;
	}

}
}
```

`hybridclr/transform/TransformModule.cpp`:

```cpp
#include "TransformModule.h"
#include "TransformContext.h"

namespace hybridclr
{
namespace transform
{
	void TransformModule::Initialize()
	{
		TransformContext::InitializeInstinctHandlers();
	}
}
}
```

`hybridclr/transform/TransformModule.h`:

```h
#pragma once

namespace hybridclr
{
namespace transform
{
	class TransformModule
	{
	public:
		static void Initialize();
	};
}
}
```