Project Path: arc_Fewnity_Counter-Strike-Nintendo-DS_pramko_r

Source Tree:

```txt
arc_Fewnity_Counter-Strike-Nintendo-DS_pramko_r
├── Counter-Strike-nds
│   ├── Asset cs
│   │   ├── 157442340_preview_de_dust2_radar_spectate.png
│   │   ├── 157442340_preview_de_dust2_radar_spectate.psd
│   │   ├── 256DustParts0.fbx
│   │   ├── 256DustParts1.fbx
│   │   ├── 256DustParts2.fbx
│   │   ├── 256DustParts3.1.fbx
│   │   ├── 256DustParts3.2.fbx
│   │   ├── 256DustParts3.3.fbx
│   │   ├── 256DustParts3.fbx
│   │   ├── 256DustParts4.fbx
│   │   ├── 256DustParts5.fbx
│   │   ├── 256DustParts6.fbx
│   │   ├── Atlas.bmp
│   │   ├── Atlas.psd
│   │   ├── Atlas256.psd
│   │   ├── Atlas256Final.psd
│   │   ├── AtlasNew.psd
│   │   ├── AtlasNewFinal - Copie.psd
│   │   ├── AtlasNewFinal.psd
│   │   ├── Audio
│   │   │   ├── 2017-cs-global-offensive-bomb-c4-no-music.mp3
│   │   │   ├── bomb-c4-explode-sound-effect-csgo.mp3
│   │   │   ├── bomb-has-been-defused-csgo-sound-effect.mp3
│   │   │   ├── bomb-has-been-planted-sound-effect-csgo.mp3
│   │   │   ├── counter-terrorist-win-csgo-sound-effect.mp3
│   │   │   ├── planting-c4-bomb-sound-effect-csgo.mp3
│   │   │   └── terrorists-win-csgo-sound-effect.mp3
│   │   ├── CheckMark.bmp
│   │   ├── Data opti.txt
│   │   ├── Dust.3ds
│   │   ├── Dust.blend
│   │   ├── Dust.blend1
│   │   ├── Dust1.3ds
│   │   ├── Dust1.fbx
│   │   ├── Dust2.3ds
│   │   ├── Dust2.fbx
│   │   ├── DustPart0.3ds
│   │   ├── DustPart1.3ds
│   │   ├── DustPart2.3ds
│   │   ├── DustPart3.1.3ds
│   │   ├── DustPart3.2.3ds
│   │   ├── DustPart3.3.3ds
│   │   ├── DustPart3.3ds
│   │   ├── DustPart4.3ds
│   │   ├── DustPart5.3ds
│   │   ├── DustPart6.3ds
│   │   ├── DustParts.blend
│   │   ├── DustParts.blend1
│   │   ├── DustParts0.fbx
│   │   ├── DustParts1.fbx
│   │   ├── DustParts2.fbx
│   │   ├── DustParts3.fbx
│   │   ├── DustParts4.fbx
│   │   ├── DustParts5.fbx
│   │   ├── DustParts6.fbx
│   │   ├── DustPartsTest.blend
│   │   ├── DustPartsTest.blend1
│   │   ├── DustPartsTest256.blend
│   │   ├── DustPartsTest256.blend1
│   │   ├── Economy.png
│   │   ├── Economy2.png
│   │   ├── GIGN.blend
│   │   ├── GIGN.blend1
│   │   ├── GIGNNew.3ds
│   │   ├── GIGNNew.blend
│   │   ├── GIGNNew.blend1
│   │   ├── GIGNNew.fbx
│   │   ├── GIGNNewFinal.blend
│   │   ├── GIGNNewFinal.blend1
│   │   ├── GIGNNewFinal.fbx
│   │   ├── GunImages
│   │   │   ├── ak47.bin
│   │   │   ├── ak47.bmp
│   │   │   ├── aug.bin
│   │   │   ├── aug.bmp
│   │   │   ├── awp.bin
│   │   │   ├── awp.bmp
│   │   │   ├── c4.bin
│   │   │   ├── c4.bmp
│   │   │   ├── deagle.bin
│   │   │   ├── deagle.bmp
│   │   │   ├── elite.bin
│   │   │   ├── elite.bmp
│   │   │   ├── famas.bin
│   │   │   ├── famas.bmp
│   │   │   ├── fivesevent.bin
│   │   │   ├── fivesevent.bmp
│   │   │   ├── flashthrowed.bin
│   │   │   ├── flashthrowed.bmp
│   │   │   ├── fraggrenade.bin
│   │   │   ├── fraggrenade.bmp
│   │   │   ├── g3sg1.bin
│   │   │   ├── g3sg1.bmp
│   │   │   ├── galil.bin
│   │   │   ├── galil.bmp
│   │   │   ├── glock18.bin
│   │   │   ├── glock18.bmp
│   │   │   ├── knifect.bin
│   │   │   ├── knifect.bmp
│   │   │   ├── m249.bin
│   │   │   ├── m249.bmp
│   │   │   ├── m3super90.bin
│   │   │   ├── m3super90.bmp
│   │   │   ├── m4a1.bin
│   │   │   ├── m4a1.bmp
│   │   │   ├── mac10.bin
│   │   │   ├── mac10.bmp
│   │   │   ├── mp5.bin
│   │   │   ├── mp5.bmp
│   │   │   ├── p228.bin
│   │   │   ├── p228.bmp
│   │   │   ├── p90.bin
│   │   │   ├── p90.bmp
│   │   │   ├── scout.bin
│   │   │   ├── scout.bmp
│   │   │   ├── sg550.bin
│   │   │   ├── sg550.bmp
│   │   │   ├── sg552.bin
│   │   │   ├── sg552.bmp
│   │   │   ├── smokegrenade.bin
│   │   │   ├── smokegrenade.bmp
│   │   │   ├── tmp.bin
│   │   │   ├── tmp.bmp
│   │   │   ├── ump45.bin
│   │   │   ├── ump45.bmp
│   │   │   ├── uspsilencer.bin
│   │   │   ├── uspsilencer.bmp
│   │   │   ├── xm104.bin
│   │   │   └── xm104.bmp
│   │   ├── MapPointUI.bmp
│   │   ├── MapRepeatTextures.blend
│   │   ├── MapRepeatTextures.blend1
│   │   ├── MapToDraw.PNG
│   │   ├── MapToDraw.psd
│   │   ├── MapUI.bmp
│   │   ├── MapUI2.bmp
│   │   ├── MapUI3.bmp
│   │   ├── Player.3ds
│   │   ├── Sounds
│   │   │   ├── ak47-1.wav
│   │   │   ├── aug-1.wav
│   │   │   ├── awp1.wav
│   │   │   ├── c4_explode1.wav
│   │   │   ├── deagle-1.wav
│   │   │   ├── debris1.wav
│   │   │   ├── elite_fire.wav
│   │   │   ├── famas-1.wav
│   │   │   ├── fiveseven-1.wav
│   │   │   ├── g3sg1-1.wav
│   │   │   ├── galil-1.wav
│   │   │   ├── glock18-2.wav
│   │   │   ├── grenade_hit1.wav
│   │   │   ├── he_bounce-1.wav
│   │   │   ├── knife_hit1.wav
│   │   │   ├── knife_hitwall1.wav
│   │   │   ├── m249-1.wav
│   │   │   ├── m3-1.wav
│   │   │   ├── m4a1_unsil-1.wav
│   │   │   ├── mac10-1.wav
│   │   │   ├── mp5-1.wav
│   │   │   ├── p228-1.wav
│   │   │   ├── p90-1.wav
│   │   │   ├── scout_fire-1.wav
│   │   │   ├── sg550-1.wav
│   │   │   ├── sg552-1.wav
│   │   │   ├── sg_explode.wav
│   │   │   ├── tmp-1.wav
│   │   │   ├── ump45-1.wav
│   │   │   ├── usp1.wav
│   │   │   ├── xm1014-1.wav
│   │   │   └── zoom.wav
│   │   ├── Stairs.3ds
│   │   ├── TestUI.bmp
│   │   ├── TestUI2.bmp
│   │   ├── TestUI3.bmp
│   │   ├── WhiteScare.bmp
│   │   ├── WhiteScareRounded.bmp
│   │   ├── bomb.3ds
│   │   ├── bomb.blend
│   │   ├── bomb.blend1
│   │   ├── bomb.fbx
│   │   ├── crosshair2.bmp
│   │   ├── dustNew2.fbx
│   │   ├── explosion.3ds
│   │   ├── explosion.fbx
│   │   ├── grenade.3ds
│   │   ├── grenade.blend
│   │   ├── grenade.blend1
│   │   ├── grenade.fbx
│   │   ├── map.blend
│   │   ├── map.blend1
│   │   ├── map.fbx
│   │   ├── muzzle.bmp
│   │   ├── muzzle.psd
│   │   ├── plane.3ds
│   │   ├── plane.blend
│   │   ├── plane.fbx
│   │   ├── player_shadow.bmp
│   │   ├── repeat.3ds
│   │   ├── repeat.fbx
│   │   ├── scopeImage.bmp
│   │   ├── shadow_plane.fbx
│   │   ├── smokeSphere.3ds
│   │   ├── smokeSphere.blend
│   │   ├── smokeSphere.blend1
│   │   ├── smokeSphere.fbx
│   │   ├── terrorist_skin1.psd
│   │   ├── text_bmp.bin
│   │   ├── text_bmp.bmp
│   │   ├── tutorialMap.blend
│   │   ├── tutorialMap.blend1
│   │   ├── tutorialMapShadowed.3ds
│   │   ├── tutorialMapShadowed.fbx
│   │   ├── tutorialMapUnShadowed.3ds
│   │   ├── tutorialMapUnShadowed.fbx
│   │   ├── tutorial_dust2_image.bin
│   │   └── tutorial_map_image.bin
│   ├── Counter Strike DS package sample
│   │   ├── PUT FILES IN THE SAME FOLDER
│   │   └── READ BEFORE INSTALL.txt
│   ├── Counter Strike DS package sample Emulator
│   │   ├── READ BEFORE INSTALL.txt
│   │   └── counter_strike_sd.raw
│   ├── Makefile
│   ├── audio
│   │   ├── BombBip.wav
│   │   ├── BombExplode.wav
│   │   ├── BombHasBeenDefused.wav
│   │   ├── BombHasBeenPlanted.wav
│   │   ├── BombPlanting.wav
│   │   ├── CounterTerroristWin.wav
│   │   ├── TerroristsWin.wav
│   │   ├── ak47.wav
│   │   ├── aug.wav
│   │   ├── awp.wav
│   │   ├── concrete_ct_1.wav
│   │   ├── concrete_ct_2.wav
│   │   ├── concrete_ct_3.wav
│   │   ├── concrete_ct_4.wav
│   │   ├── deagle.wav
│   │   ├── death.wav
│   │   ├── detonate.wav
│   │   ├── elite.wav
│   │   ├── famas.wav
│   │   ├── fire_loop.wav
│   │   ├── fiveseven.wav
│   │   ├── flashbang_bounce.wav
│   │   ├── flashbang_explode.wav
│   │   ├── flesh_impact.wav
│   │   ├── g3sg1.wav
│   │   ├── galil.wav
│   │   ├── glock18.wav
│   │   ├── grenade_hit1.wav
│   │   ├── headshot1.wav
│   │   ├── hegrenade_bounce.wav
│   │   ├── hegrenade_explose.wav
│   │   ├── hit_helmet.wav
│   │   ├── keyboard_sound.wav
│   │   ├── knife_hit1.wav
│   │   ├── knife_hit_player.wav
│   │   ├── knife_hit_wall.wav
│   │   ├── knife_hitwall1.wav
│   │   ├── land.wav
│   │   ├── m249.wav
│   │   ├── m3.wav
│   │   ├── m4a1.wav
│   │   ├── mac10.wav
│   │   ├── molotov_detonate.wav
│   │   ├── mp5.wav
│   │   ├── p228.wav
│   │   ├── p90.wav
│   │   ├── ric.wav
│   │   ├── scope.wav
│   │   ├── scout.wav
│   │   ├── sg550.wav
│   │   ├── sg552.wav
│   │   ├── smoke_emit.wav
│   │   ├── tmp.wav
│   │   ├── ump45.wav
│   │   ├── usp.wav
│   │   ├── xm1014.wav
│   │   └── zoom.wav
│   ├── counter_strike_music.raw
│   ├── data
│   │   ├── Atlas.bin
│   │   ├── CheckMark.bin
│   │   ├── DustPart0.bin
│   │   ├── DustPart1.bin
│   │   ├── DustPart2.bin
│   │   ├── DustPart3.bin
│   │   ├── DustPart3_1_3ds.bin
│   │   ├── DustPart3_2_3ds.bin
│   │   ├── DustPart3_3_3ds.bin
│   │   ├── DustPart4.bin
│   │   ├── DustPart5.bin
│   │   ├── DustPart6.bin
│   │   ├── GIGNAnimNea.bin
│   │   ├── GIGNNew.bin
│   │   ├── Ground.bin
│   │   ├── JumpArrow.bin
│   │   ├── MapPointUI.bin
│   │   ├── MapUI.bin
│   │   ├── Mapold.bin
│   │   ├── QuitButton.bin
│   │   ├── WhiteScareRounded.bin
│   │   ├── ak47.bin
│   │   ├── aug.bin
│   │   ├── awp.bin
│   │   ├── bomb.bin
│   │   ├── bomb_logo.bin
│   │   ├── c4.bin
│   │   ├── crosshair2.bin
│   │   ├── deagle.bin
│   │   ├── defuser.bin
│   │   ├── dust2_map_image.bin
│   │   ├── elite.bin
│   │   ├── explosion.bin
│   │   ├── explosion_3ds.bin
│   │   ├── famas.bin
│   │   ├── fivesevent.bin
│   │   ├── flashthrowed.bin
│   │   ├── fraggrenade.bin
│   │   ├── g3sg1.bin
│   │   ├── galil.bin
│   │   ├── gign_skin1.bin
│   │   ├── glock18.bin
│   │   ├── grenade_3ds.bin
│   │   ├── gun.bin
│   │   ├── gun1.bin
│   │   ├── gun2.bin
│   │   ├── gunFixed.bin
│   │   ├── kevlar.bin
│   │   ├── kevlar_helmet.bin
│   │   ├── knifect.bin
│   │   ├── m249.bin
│   │   ├── m3super90.bin
│   │   ├── m4a1.bin
│   │   ├── mac10.bin
│   │   ├── mp5.bin
│   │   ├── muzzle.bin
│   │   ├── p228.bin
│   │   ├── p90.bin
│   │   ├── plane.bin
│   │   ├── playerAnimNea.bin
│   │   ├── player_shadow.bin
│   │   ├── reload.bin
│   │   ├── repeat.bin
│   │   ├── road.bin
│   │   ├── scopeImage.bin
│   │   ├── scout.bin
│   │   ├── sg550.bin
│   │   ├── sg552.bin
│   │   ├── skin_adventurer.bin
│   │   ├── skin_man.bin
│   │   ├── skin_soldier.bin
│   │   ├── smokeSphere.bin
│   │   ├── smokegrenade.bin
│   │   ├── terrorist_skin1.bin
│   │   ├── text_bmp.bin
│   │   ├── tmp.bin
│   │   ├── tutorialMapShadowed_3ds.bin
│   │   ├── tutorialMapUnShadowed_3ds.bin
│   │   ├── tutorial_map_image.bin
│   │   ├── ump45.bin
│   │   ├── uspsilencer.bin
│   │   ├── wall.bin
│   │   ├── wallWindow.bin
│   │   └── xm1014.bin
│   ├── icon.bmp
│   ├── licenses
│   │   └── mit.txt
│   └── source
│       ├── ai
│       │   ├── ai.c
│       │   ├── ai.h
│       │   └── data
│       │       ├── ai_data.c
│       │       └── ai_data.h
│       ├── collisions
│       │   ├── collisions.c
│       │   ├── collisions.h
│       │   ├── raycast.c
│       │   └── raycast.h
│       ├── debug
│       │   ├── debug.c
│       │   └── debug.h
│       ├── graphics
│       │   ├── camera.c
│       │   ├── camera.h
│       │   ├── draw3d.c
│       │   ├── draw3d.h
│       │   ├── ui.c
│       │   └── ui.h
│       ├── inputs
│       │   ├── input.c
│       │   ├── input.h
│       │   ├── keyboard.c
│       │   └── keyboard.h
│       ├── main.c
│       ├── main.h
│       ├── map
│       │   ├── map.c
│       │   └── map.h
│       ├── network
│       │   ├── network.c
│       │   ├── network.h
│       │   ├── security.c
│       │   └── security.h
│       ├── party
│       │   ├── party.c
│       │   ├── party.h
│       │   ├── tutorial.c
│       │   └── tutorial.h
│       ├── player
│       │   ├── movements.c
│       │   ├── movements.h
│       │   ├── player.c
│       │   └── player.h
│       ├── save
│       │   ├── saveManager.c
│       │   ├── saveManager.h
│       │   ├── stats.c
│       │   └── stats.h
│       ├── sounds
│       │   ├── sounds.c
│       │   └── sounds.h
│       └── weapons
│           ├── data
│           │   ├── equipment_data.c
│           │   ├── equipment_data.h
│           │   ├── grenade_data.c
│           │   ├── grenade_data.h
│           │   ├── gun_data.c
│           │   └── gun_data.h
│           ├── equipment.c
│           ├── equipment.h
│           ├── grenade.c
│           ├── grenade.h
│           ├── gun.c
│           └── gun.h
└── README.md

```

`Counter-Strike-nds/Asset cs/Data opti.txt`:

```txt
17859 vertices
3988 faces
9889 triangles
dust.fbx 316ko
dust.3ds 485ko

Opti 1
DustParts0.fxb 55ko
DustParts1.fxb 48ko
DustParts2.fxb 72ko
DustParts3.fxb 70ko
DustParts4.fxb 42ko
DustParts5.fxb 66ko
DustParts6.fxb 55ko

ZONE 2 CPU 55%
ZONE 3 CPU 73%
ZONE 5 CPU 59%

Opti 2
14853 vertices
3348 faces
8395 triangles

DustParts0.fxb 52ko
DustParts1.fxb 42ko
DustParts2.fxb 68ko
DustParts3.fxb 65ko
DustParts4.fxb 38ko
DustParts5.fxb 61ko
DustParts6.fxb 52ko

Avant PARTOUT CPU 90-100%

//Création de zones
ZONE 2 CPU 55%
ZONE 3 CPU 73%
ZONE 5 CPU 59%

//Simplification de la carte
ZONE 2 CPU 42%
ZONE 3 CPU 60%
ZONE 5 CPU 42%

//Optimisation textures
13240 vertices
3113 faces
7694 triangles

//Optimisation textures
9995 vertices
2711 faces
6265 triangles



Avant lower tunnels CPU 54
Maintenant CPU 39


Avant upper tunnels CPU 49
Maintenant CPU 34

Avant outside tunnels CPU 39
Maintenant CPU 38

Avant t ramp CPU 39 but with missing zone
Maintenant CPU 44

Avant t spawn CPU 48
Maintenant CPU 40

Avant outside long CPU 47
Maintenant CPU 33


```

`Counter-Strike-nds/Counter Strike DS package sample Emulator/READ BEFORE INSTALL.txt`:

```txt
- For EACH new update, replace all files with new files.

- I have no sound

On Emulator
You need to enable DLDI SD card and put the counter_strike_sd.raw file as SD card
Melon DS supports DLDI : https://melonds.kuribo64.net/downloads.php
```

`Counter-Strike-nds/Counter Strike DS package sample/READ BEFORE INSTALL.txt`:

```txt
-For EACH new update, replace all the files with the new files.


- If the game can't load :

Try to put the soundbank.bin file in the root (root example : C:/soundbank.bin) of you sd card, or try another linker (R4, M3...)
Or for Nintendo 2DS/3DS, try to put all the files in "roms/nds"


- If the game crash with a 2DS/3DS :

Go in the game settings and uncheck "Use Rumble Pack" and check "3DS mode".
```

`Counter-Strike-nds/Makefile`:

```
#---------------------------------------------------------------------------------
.SUFFIXES:
#---------------------------------------------------------------------------------

ifeq ($(strip $(DEVKITARM)),)
$(error "Please set DEVKITARM in your environment. export DEVKITARM=<path to>devkitARM")
endif

include $(DEVKITARM)/ds_rules

#---------------------------------------------------------------------------------
# TARGET is the name of the output
# BUILD is the directory where object files & intermediate files will be placed
# SOURCES is a list of directories containing source code
# INCLUDES is a list of directories containing extra header files
# DATA is a list of directories containing binary files embedded using bin2o
# GRAPHICS is a list of directories containing image files to be converted with grit
# AUDIO is a list of directories containing audio to be converted by maxmod
# ICON is the image used to create the game icon, leave blank to use default rule
# NITRO is a directory that will be accessible via NitroFS
#---------------------------------------------------------------------------------
TARGET   := $(shell basename $(CURDIR))
BUILD    := build
SOURCES  := source $(wildcard source/*) $(wildcard source/*/*)
INCLUDES := include $(dir $(wildcard source/*)) $(dir $(wildcard source/*/*))
DATA     := data
GRAPHICS :=
AUDIO    := audio
ICON     :=

# specify a directory which contains the nitro filesystem
# this is relative to the Makefile
# NITRO    := nitrofiles

# These set the information text in the nds file
GAME_TITLE	:=	Counter Strike
GAME_SUBTITLE1	:=	Fewnity
GAME_SUBTITLE2	:=	Fewnity

#---------------------------------------------------------------------------------
# options for code generation
#---------------------------------------------------------------------------------
ARCH := -marm -mthumb-interwork -march=armv5te -mtune=arm946e-s

CFLAGS   := -g -Wall -O3\
            $(ARCH) $(INCLUDE) -DARM9
CXXFLAGS := $(CFLAGS) -fno-rtti -fno-exceptions
ASFLAGS  := -g $(ARCH)
LDFLAGS   = -specs=ds_arm9.specs -g $(ARCH) -Wl,-Map,$(notdir $*.map)

#---------------------------------------------------------------------------------
# any extra libraries we wish to link with the project (order is important)
#---------------------------------------------------------------------------------
LIBS := -lNE -lfat -lnds9 -ldswifi9 -lm

# automatigically add libraries for NitroFS
#ifneq ($(strip $(NITRO)),)
#LIBS := -lfilesystem -lfat $(LIBS)
#endif
# automagically add maxmod library
ifneq ($(strip $(AUDIO)),)
LIBS := -lmm9 $(LIBS)
endif

#---------------------------------------------------------------------------------
# list of directories containing libraries, this must be the top level containing
# include and lib
#---------------------------------------------------------------------------------
LIBDIRS := ../libs $(LIBNDS) $(PORTLIBS) $(DEVKITPRO)/nitro-engine

#---------------------------------------------------------------------------------
# no real need to edit anything past this point unless you need to add additional
# rules for different file extensions
#---------------------------------------------------------------------------------
ifneq ($(BUILD),$(notdir $(CURDIR)))
#---------------------------------------------------------------------------------

export OUTPUT := $(CURDIR)/$(TARGET)

export VPATH := $(CURDIR)/$(subst /,,$(dir $(ICON)))\
                $(foreach dir,$(SOURCES),$(CURDIR)/$(dir))\
                $(foreach dir,$(DATA),$(CURDIR)/$(dir))\
                $(foreach dir,$(GRAPHICS),$(CURDIR)/$(dir))

export DEPSDIR := $(CURDIR)/$(BUILD)

CFILES   := $(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.c)))
CPPFILES := $(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.cpp)))
SFILES   := $(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.s)))
PNGFILES := $(foreach dir,$(GRAPHICS),$(notdir $(wildcard $(dir)/*.png)))
BINFILES := $(foreach dir,$(DATA),$(notdir $(wildcard $(dir)/*.*))) soundbank.bin

# prepare NitroFS directory
#ifneq ($(strip $(NITRO)),)
  #export NITRO_FILES := $(CURDIR)/$(NITRO)
#endif

# get audio list for maxmod
export AUDIOFILES := $(foreach dir,$(notdir $(wildcard $(AUDIO)/*.*)),$(CURDIR)/$(AUDIO)/$(dir))

#---------------------------------------------------------------------------------
# use CXX for linking C++ projects, CC for standard C
#---------------------------------------------------------------------------------
ifeq ($(strip $(CPPFILES)),)
#---------------------------------------------------------------------------------
  export LD := $(CC)
#---------------------------------------------------------------------------------
else
#---------------------------------------------------------------------------------
  export LD := $(CXX)
#---------------------------------------------------------------------------------
endif
#---------------------------------------------------------------------------------

export OFILES_BIN   :=	$(addsuffix .o,$(BINFILES))

export OFILES_SOURCES := $(CPPFILES:.cpp=.o) $(CFILES:.c=.o) $(SFILES:.s=.o)

export OFILES := $(PNGFILES:.png=.o) $(OFILES_BIN) $(OFILES_SOURCES)

export HFILES := $(PNGFILES:.png=.h) $(addsuffix .h,$(subst .,_,$(BINFILES)))

export INCLUDE  := $(foreach dir,$(INCLUDES),-iquote $(CURDIR)/$(dir))\
                   $(foreach dir,$(LIBDIRS),-I$(dir)/include)\
                   -I$(CURDIR)/$(BUILD)
export LIBPATHS := $(foreach dir,$(LIBDIRS),-L$(dir)/lib)

ifeq ($(strip $(ICON)),)
  icons := $(wildcard *.bmp)

  ifneq (,$(findstring $(TARGET).bmp,$(icons)))
    export GAME_ICON := $(CURDIR)/$(TARGET).bmp
  else
    ifneq (,$(findstring icon.bmp,$(icons)))
      export GAME_ICON := $(CURDIR)/icon.bmp
    endif
  endif
else
  ifeq ($(suffix $(ICON)), .grf)
    export GAME_ICON := $(CURDIR)/$(ICON)
  else
    export GAME_ICON := $(CURDIR)/$(BUILD)/$(notdir $(basename $(ICON))).grf
  endif
endif

.PHONY: $(BUILD) clean

#---------------------------------------------------------------------------------
$(BUILD):
	@mkdir -p $@
	@$(MAKE) --no-print-directory -C $(BUILD) -f $(CURDIR)/Makefile

#---------------------------------------------------------------------------------
clean:
	@echo clean ...
	@rm -fr $(BUILD) $(TARGET).elf $(TARGET).nds $(SOUNDBANK)

#---------------------------------------------------------------------------------
else

#---------------------------------------------------------------------------------
# main targets
#---------------------------------------------------------------------------------
$(OUTPUT).nds: $(OUTPUT).elf $(GAME_ICON)
$(OUTPUT).elf: $(OFILES)

# source files depend on generated headers
$(OFILES_SOURCES) : $(HFILES)

# need to build soundbank first
$(OFILES): $(SOUNDBANK)

#---------------------------------------------------------------------------------
# rule to build solution from music files
#---------------------------------------------------------------------------------
#$(SOUNDBANK) : $(MODFILES)

soundbank.bin:	$(AUDIOFILES)
#---------------------------------------------------------------------------------
	@mmutil $^ -osoundbank.bin -hsoundbank.h -d

#---------------------------------------------------------------------------------
%.bin.o %_bin.h : %.bin
#---------------------------------------------------------------------------------
	@echo $(notdir $<)
	@$(bin2o)

#---------------------------------------------------------------------------------
# This rule creates assembly source files using grit
# grit takes an image file and a .grit describing how the file is to be processed
# add additional rules like this for each image extension
# you use in the graphics folders
#---------------------------------------------------------------------------------
%.s %.h: %.png %.grit
#---------------------------------------------------------------------------------
	grit $< -fts -o$*

#---------------------------------------------------------------------------------
# Convert non-GRF game icon to GRF if needed
#---------------------------------------------------------------------------------
$(GAME_ICON): $(notdir $(ICON))
#---------------------------------------------------------------------------------
	@echo convert $(notdir $<)
	@grit $< -g -gt -gB4 -gT FF00FF -m! -p -pe 16 -fh! -ftr

-include $(DEPSDIR)/*.d

#---------------------------------------------------------------------------------------
endif
#---------------------------------------------------------------------------------------
```

`Counter-Strike-nds/data/skin_adventurer.bin`:

```bin
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FcccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÙJèÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆè[[[[[[ÆÆÆÆÆÆÆÆÆÆÆÆ)![[[[]WÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆ[[[[[[[[ÆÆ[[[[[[[[[[[[[[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆ[[[[[[[[[[[[[[[[[[[[[[[[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F464646u:¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fv>464646ccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆ[[[[[[[[[[[[[[[[[ÆÆÆ[[[[[[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆ[[[[[[[ÆÆÆÆ[[[[[ÆÆÆÆ[[[[[[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆñ5[^S6ÆÆÆ[[[[[[[[[ÙJÆ[[[[[[[[[[[[[[[[ÆÆÆW^S[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆÆ[]O^SWÆ3:[[[[[[[[[--[[[[[[[--[[[[[[[[[®-ÆW^S]O[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆ[=K]O^SW[[[[[[[[[[[--[[[[[[[--[[[[[[[[[[[W^S]O[èÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆÆ[]O]O^SW[[[[[[[[[[[[[[[=K=K=K[[[[[[[[[[[[[[[W^S]O[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸FccccccccccccÆÆÆÆÆ[[[]O^SW[[[[[[[[[[=K[[œo\[=K=K=Kœoœk[[[[[[[[[[[[[W^S]O[[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc46464646464646464646464646464646464646464646464646464646464646464646464646ccccccccccccÆÆÆ[[[[[[~W[[[[[[[[[[[=O=Kœoœoœoœoœoœoœoœoœo~_[[[[[[[[[[[WW[[[[[·FÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ccccccccccccÆ[[[[[[[[[[[[[[[[[œo[[[=Kœoœoœoœoœo”N”N”N”Nœo[[[œo[[[[[[[[[[[[[[[[[ÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccccccccccc[[[[[[[[[[[[[[[[[[œoœk[œoœoœoœoœoœoœo”N”N×Vœoœoœo[œoœo[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccccccccccc[[[[[[[[[[[[[[[[[[œoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœo[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccccccccccc[[[[[[[[[[[[[[[[[[œoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœo[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccccccccccc[[[[[[[[[[[[[[[[[[œoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœoœo[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc[[[[[[[[[[ccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[ccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸F[[[[[[[[[¸F----¸F¸F¸F¸F¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F---ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸FK[[[[[[[K¸F----¸F¸F¸F¸F¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F---ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸FKK[[[[[[K¸F----¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸FKK~W[[[[KKúJ----¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸F¸F¸FK[[[KKKKÑ)---¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸F¸F¸F¸FK[^WKK¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccc[[[[[[[[[[[[[[[[[[[cccc¸F¸F¸F¸F¸F¸F¸F¸F¸F----¸F¸F¸F¸F¸F<OØF¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!-No!o!o!o!o!o!--ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F---T6¸F¸F¸F¸F¸F¸Fu:¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F-----o!o!o!o!o!o!o!o!-----ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸B¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!-----------Mo!--ccccccccccccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸Fu:¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F---¸F¸F¸F¸F¸F¸F¸Fu:¸F¸F¸F¸F¸Fv>--¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F--v>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F--¸F¸F¸F¸F¸F¸F¸F¸F¸F--o!o!o!o!o!o!o!o!o!o!o!o!o!o!--cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F--¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F--¸F¸F¸F¸F¸F¸F¸F¸F¸F-·Bo!o!o!o!o!N!N!N!N!o!o!o!o!o!U:-cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F·B¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F--¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F-¸F¸F¸F¸F¸F¸F¸F¸F¸F-¸Fo!o!o!N!------o!o!o!o!¸F-cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸F¸F–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F-¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F-¸F¸F¸F¸F¸F¸F¸F¸F¸F—>¸Fo!o!o!--------o!o!o!¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F–>–>¸F¸F¸F–>–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸F¸F¸F¸F¸Fo!o!o!--------o!o!o!¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F–>–>–>–>–>–>–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>–>¸F¸F¸F¸F¸F¸F¸Fo!o!o!-------o!o!o!o!¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸B·B–>·B·B–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fv>v>v>v>v>v>v>v>¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸B–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>–>–>–>–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸F–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>–>¸F¸F–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸B¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>–>–>–>–>–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc46464646464646—B¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F·B46464646464646¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F—B·B¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F–>¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fxoxoxoxo¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc-----------------xoxoxoxo----------------------------------cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fccccccccc-----------------xoxoxoxo----------------------------------cccccccccccccccccccccccccccc¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸F¸Fcccccccccccccccccc-------------------ccccccccccccccccccccccccccccccccccccccccccccccccccccccc464646464646464646464646464646464646464646464646464646464646464646464646cccccccccccccccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc464646464646464646464646464646464646464646464646464646464646464646464646cccccccccccccccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccccccccccccccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccc[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[cccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccc-------------------cccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccc[[[[[[[[[cccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccc[[[[[[[[[cccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[cccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[cccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:ccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[ccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[ccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[ccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Í-Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[ccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Í-Í-Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccc[[[[[[[[[ccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Í-Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Í-Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:0:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:o!Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:6Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:6o!Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:6Q:o!Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:o!Q:°)o!Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:%Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:´F´FR:´F´F´F´F´F´FÍ-Í-Í-Í-Í-Í-Í-î1Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:o!o!Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Í-´F´Fo!´Fo!°)´F´F´F´FQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccÍ-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccÍ-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-cccccccccccccccccccccccccccccccccccccQ:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:Q:cccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccÍ-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-cccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccÍ-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-Í-cccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆccccccccccccccc--------------------------------------cccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆÆcccccccccccccccccccccccccccccccccc---------ccccccccccccccccccccccccccccccccccccccccccccccc--------------------------------------cccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------ccccccccccccccccccccccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------ccccccccccccccccccccccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------ccccccccccccccccccccccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------ccccccccccccccccccccccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------ccccccccccccccccccccccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------ccccccccccccccccccccccccccccccccccccccccccccccccccccc---------cccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc----------cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
```

`Counter-Strike-nds/licenses/mit.txt`:

```txt
Copyright <YEAR> <COPYRIGHT HOLDER>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Counter-Strike-nds/source/ai/ai.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "ai.h"
#include "raycast.h"
#include "data/ai_data.h"
#include "gun.h"
#include "party.h"
#include "map.h"
#include "sounds.h"
#include "movements.h"
#include "equipment.h"
#include "collisions.h"
#include "grenade.h"
#include "player.h"

// Bots names list
const char *botsNames[BOTS_NAMES_COUNT];

// Avoid multiple bot with the same name
bool botsNamesTaken[BOTS_NAMES_COUNT];

// Matrices for path finding
PathLength *AllMatricesLength;

// Current matrices size for the current map (MatricesSize * MatricesSize)
int MatricesSize = 0;
// Waypoint count for the current map
int waypointsSize = 0;
// Matrices count for the current map
int MatriceCount = 0;

// Timer to check the player's distance between the bot and the player
int checkPlayerDistanceFromAiTimer = 1;
Waypoint Waypoints[maxPoint]; // TODO replace this by a malloc

/**
 * @brief Reset botsNamesTaken list
 */
void ResetTakenBotsNames()
{
    for (int nameIndex = 0; nameIndex < BOTS_NAMES_COUNT; nameIndex++)
    {
        botsNamesTaken[nameIndex] = false;
    }
}

/**
 * @brief Copy one matrix to another matrix array
 *
 * @param size Size of the matrix
 * @param matrix Matrix to copy
 * @param index Index of the destination matrix
 */
void copyArrayToAllMatricesLength(int size, int matrix[size][size], int index)
{
    // Alloc memory for the matrix (create a list of int*)
    AllMatricesLength[index].matrixOneLength = malloc(size * sizeof(int *));
    for (int i = 0; i < size; i++)
    {
        // Alloc memory for the matrix (create a list of int)
        AllMatricesLength[index].matrixOneLength[i] = malloc(size * sizeof(int));
        memcpy(AllMatricesLength[index].matrixOneLength[i], matrix[i], sizeof(int) * size);
    }
}

/**
 * @brief Free all matrices from memory
 *
 * @param size Size of matrices
 */
void freeAllMatricesLength(int size)
{
    for (int i = 0; i < MatriceCount; i++)
    {
        if (AllMatricesLength[i].matrixOneLength)
        {
            for (int i2 = 0; i2 < size; i2++)
            {
                free(AllMatricesLength[i].matrixOneLength[i2]);
            }
            free(AllMatricesLength[i].matrixOneLength);
        }
    }
}

/**
 * @brief Get the Waypoints list
 *
 * @return Waypoint*
 */
Waypoint *GetWaypoints()
{
    return Waypoints;
}

/**
 * @brief Get the Nearest Waypoint object
 *
 * @param x x Position (float version)
 * @param y y position (float version)
 * @param z z position (float version)
 * @return * Get id of the nearest waypoint
 */
int getNearestWaypoint(float x, float y, float z)
{
    int nearestWaypointId = -1;
    int distance = 99999;
    // Check every waypoint
    for (int waypointIndex = 0; waypointIndex < waypointsSize; waypointIndex++)
    {
        // Calculate the distance between waypoint position and the position given
        int currentDistance = sqrtf(powf((Waypoints[waypointIndex].x - x), 2.0) + powf((Waypoints[waypointIndex].y - y), 2.0) + powf((Waypoints[waypointIndex].z - z), 2.0));
        if (currentDistance < distance)
        {
            nearestWaypointId = waypointIndex;
            distance = currentDistance;
        }
    }
    return nearestWaypointId;
}

/**
 * @brief Get the distance bewteen a player and the waypoint
 *
 * @param player1Index
 * @param waypointIndex
 * @return int distance between the player and the waypoint
 */
int GetDistanceBewteenPlayerAndWaypoint(int playerIndex, int waypointIndex)
{
    Player *player1 = &AllPlayers[playerIndex];
    return sqrtf(powf((player1->position.x - Waypoints[waypointIndex].x), 2.0) + powf((player1->position.y - Waypoints[waypointIndex].y), 2.0) + powf((player1->position.z - Waypoints[waypointIndex].z), 2.0));
}

/**
 * @brief Get the distance bewteen two players
 *
 * @param player1Index
 * @param player2Index
 * @return int distance between players
 */
int GetDistanceBewteenTwoPlayers(int player1Index, int player2Index)
{
    Player *player1 = &AllPlayers[player1Index];
    Player *player2 = &AllPlayers[player2Index];
    return sqrtf(powf((player1->position.x - player2->position.x), 2.0) + powf((player1->position.y - player2->position.y), 2.0) + powf((player1->position.z - player2->position.z), 2.0));
}

/**
 * @brief Create a Waypoint object
 *
 * @param id Waypoint id
 * @param x x Position (float version)
 * @param y y Position (float version)
 * @param z z Position (float version)
 * @param edgeCount Waypoint's edge count
 * @param edge Edge list
 */
void CreateWaypoint(int id, float x, float y, float z, int edgeCount, int *edge)
{
    Waypoints[id].x = x;
    Waypoints[id].y = y;
    Waypoints[id].z = z;
    Waypoints[id].edgeCount = edgeCount;

    Waypoints[id].edge = malloc(edgeCount * sizeof(int));
    memcpy(Waypoints[id].edge, edge, sizeof(int) * edgeCount);
}

/**
 * @brief Free the Waypoints' edges lists from memory
 *
 */
void freeWaypoint()
{
    for (int i = 0; i < waypointsSize; i++)
    {
        // If the edge list is not null
        if (Waypoints[i].edge)
            free(Waypoints[i].edge);
    }
}

/**
 * @brief Start checking for the shortest path between the nearest waypoint and the waypoint given
 *
 * @param playerIndex Player's index to apply the check
 * @param finalWaypointIndex final waypoint index (end of the path)
 */
void StartChecking(int playerIndex, int finalWaypointIndex)
{
    Player *player = &AllPlayers[playerIndex];
    int startWaypoint = getNearestWaypoint(player->position.x, player->position.y, player->position.z);

    // Check if we realy need to check a new path before checking
    if (player->PathCount == 0 || (player->Path[0] != startWaypoint || player->Path[player->PathCount - 1] != finalWaypointIndex))
    {
        CheckPathWaypoint(playerIndex, startWaypoint, finalWaypointIndex);
    }
}

/**
 * @brief Check the shortest path bewteen two waypoints
 *
 * @param playerIndex Player's index to apply the check
 * @param startWaypointIndex final waypoint index (start of the path)
 * @param finalWaypointIndex final waypoint index (end of the path)
 */
void CheckPathWaypoint(int playerIndex, int startWaypointIndex, int finalWaypointIndex)
{
    // Find the path length (ex : pathLength = 4 so the path is composed of 4 waypoints)
    int pathLength = 0;
    for (int matriceIndex = 0; matriceIndex < MatriceCount; matriceIndex++)
    {
        if (AllMatricesLength[matriceIndex].matrixOneLength[startWaypointIndex][finalWaypointIndex] != 0)
        {
            pathLength = matriceIndex;
            break;
        }
    }

    // All waypoints ids are in the path list
    int Path[pathLength + 2];
    int currentWaypoint = startWaypointIndex;
    int PathCount = 0;
    if (startWaypointIndex == finalWaypointIndex)
    {
        Path[0] = currentWaypoint;
        PathCount = 1;
    }
    else if (pathLength == 0) // If the length is 1 (pathLength = path length - 1), path contains the start waypoint and the final waypoint.
    {
        Path[0] = currentWaypoint;
        Path[1] = finalWaypointIndex;
        PathCount = 2;
    }
    else
    {
        // If the path is not finished yet
        while (PathCount != pathLength)
        {
            // Add verified waypoint to the path
            Path[PathCount] = currentWaypoint;
            PathCount++;
            do
            {
                // Take a random connected point from the last tested waypoint
                int NextWaypoint = rand() % Waypoints[currentWaypoint].edgeCount;

                // if the random connected point can reach the final point with (pathLength - Path.Count) movement
                if (AllMatricesLength[pathLength - PathCount].matrixOneLength[Waypoints[currentWaypoint].edge[NextWaypoint]][finalWaypointIndex] != 0)
                {
                    currentWaypoint = Waypoints[currentWaypoint].edge[NextWaypoint];
                    break;
                }
            } while (true);
        }

        // Finalise the path
        Path[PathCount] = currentWaypoint;
        PathCount++;
        Path[PathCount] = finalWaypointIndex;
        PathCount++;

        Player *player = &AllPlayers[playerIndex];
        for (int i = 0; i < PathCount; i++)
        {
            player->Path[i] = Path[i];
        }
        player->PathCount = PathCount;
        player->CurrentPath = 0;
    }
}

/**
 * @brief Call this every frame to check what AI can do
 */
void AiCheckForAction()
{
    // Check every 5 frames the distance between the player and a bot
    checkPlayerDistanceFromAiTimer--;

    if (checkPlayerDistanceFromAiTimer % 5 == 0)
    {
        int currentAiToCheck = checkPlayerDistanceFromAiTimer / 5;
        if (checkPlayerDistanceFromAiTimer == 0)
            checkPlayerDistanceFromAiTimer = 25 + 1;

        Player *playerToCheck = &AllPlayers[currentAiToCheck];
        // If current AI is in game, not dead, does not planting the bomb, and raycast cycle is finished
        if (playerToCheck->isAi && playerToCheck->Id != UNUSED && !playerToCheck->IsDead && !playerToCheck->isPlantingBomb)
        {
            // Check current target distance with current ia
            int randomPlayerToCheck = playerToCheck->target;
            int distancePlayers = 999;

            if (randomPlayerToCheck != NO_PLAYER)
                distancePlayers = GetDistanceBewteenTwoPlayers(randomPlayerToCheck, currentAiToCheck);

            int shootDistance = 20;
            if (playerToCheck->AllGunsInInventory[playerToCheck->currentGunInInventory] < GunCount)
            {
                shootDistance = AllGuns[playerToCheck->AllGunsInInventory[playerToCheck->currentGunInInventory]].maxBotShootDisance;
            }
            // If current AI has no target
            if (playerToCheck->lastSeenTarget == NO_PLAYER && randomPlayerToCheck == NO_PLAYER)
            {
                int scannedPlayerCount = 1;
                playerToCheck->allPlayerScanned[currentAiToCheck] = true;
                // Check every players distances to set a new target if the distance is small enough
                while (scannedPlayerCount < MaxPlayer)
                {
                    // Take a random unscanned player
                    randomPlayerToCheck = rand() % MaxPlayer;
                    if (playerToCheck->allPlayerScanned[randomPlayerToCheck])
                        continue;

                    // Mark current player has scanned to avoid multiple check
                    scannedPlayerCount++;
                    playerToCheck->allPlayerScanned[randomPlayerToCheck] = true;

                    // Check distance if current scanned player is not in spectator team and the same team of the current AI, and if the scanned player is in game
                    if (AllPlayers[randomPlayerToCheck].Team == SPECTATOR || AllPlayers[randomPlayerToCheck].Team == playerToCheck->Team || AllPlayers[randomPlayerToCheck].IsDead || AllPlayers[randomPlayerToCheck].invincibilityTimer > 0 || AllPlayers[randomPlayerToCheck].Id == UNUSED)
                    {
                        continue;
                    }
                    else
                    {
                        distancePlayers = GetDistanceBewteenTwoPlayers(randomPlayerToCheck, currentAiToCheck);
                        if (distancePlayers < shootDistance)
                            break;
                    }
                }
                // Reset scanned players list
                for (int playerIndex = 0; playerIndex < MaxPlayer; playerIndex++)
                {
                    playerToCheck->allPlayerScanned[playerIndex] = false;
                }
            }

            if (distancePlayers < shootDistance) // Is a player is near, set this player as target
            {
                float xSide1, zSide1, xSide2, zSide2;
                GetRotationForCullingAI(currentAiToCheck, playerToCheck->Angle, &xSide1, &zSide1, &xSide2, &zSide2);
                // Field of view end coordinates
                xSide1 = (xSide1 * 500 + playerToCheck->position.x) * 8192.0;
                zSide1 = (zSide1 * 500 + playerToCheck->position.z) * 8192.0;
                xSide2 = (xSide2 * 500 + playerToCheck->position.x) * 8192.0;
                zSide2 = (zSide2 * 500 + playerToCheck->position.z) * 8192.0;

                bool inFov = PointInTriangleInt(AllPlayers[randomPlayerToCheck].PlayerModel->x, AllPlayers[randomPlayerToCheck].PlayerModel->z, playerToCheck->PlayerModel->x, playerToCheck->PlayerModel->z, xSide1, zSide1, xSide2, zSide2);
                if (distancePlayers < 4)
                    inFov = true;
                // Check if the target is visible
                prepareAiRaycast(currentAiToCheck, randomPlayerToCheck, true);
                float hitDistance = 0;
                if (Raycast(currentAiToCheck, 0, &hitDistance) != NO_PLAYER && inFov)
                {
                    playerToCheck->target = randomPlayerToCheck;
                    playerToCheck->lastSeenTarget = randomPlayerToCheck;
                }
                else // If player is behind a wall
                {
                    playerToCheck->justCheking = false;
                    playerToCheck->target = NO_PLAYER;
                    int randomWait = 40 + rand() % 20;

                    playerToCheck->GunWaitCount = -randomWait;

                    // If bot finished his path, get a new one if no player is found
                    // TODO get a random one or to a nearest last seen player position waypoint
                    if (playerToCheck->lastSeenTarget != NO_PLAYER)
                    {
                        Player *lastSeenTargetPlayer = &AllPlayers[playerToCheck->lastSeenTarget];
                        int nearestWaypoint = getNearestWaypoint(lastSeenTargetPlayer->position.x, lastSeenTargetPlayer->position.y, lastSeenTargetPlayer->position.z);
                        StartChecking(currentAiToCheck, nearestWaypoint);
                        playerToCheck->lastSeenTarget = NO_PLAYER;
                    }
                    else if (playerToCheck->PathCount == 0) // If path is finished and no player detected
                    {
                        // If bomb is dropped and if the player is a terrorist
                        if (bombDropped && playerToCheck->Team == TERRORISTS)
                        {
                            // Get the nearest waypoint of the dropped bomb
                            int nearestWaypoint = getNearestWaypoint(droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.y, droppedBombPositionAndRotation.z);

                            // If the player is already at the nearest waypoint, go to the bomb position
                            if (playerToCheck->LastWayPoint == nearestWaypoint)
                            {
                                playerToCheck->searchForDroppedBomb = true;
                            }
                            else // Or go to the  nearest waypoint
                            {
                                StartChecking(currentAiToCheck, nearestWaypoint);
                            }
                        }
                        else
                        {
                            GetRandomPoint(currentAiToCheck);
                            if (playerToCheck->Team == COUNTERTERRORISTS && BombPlanted && currentDefuserIndex == NO_PLAYER)
                            {
                                SetDefuser(currentAiToCheck);
                            }
                        }
                    }
                }
            }
            else if (playerToCheck->lastSeenTarget != NO_PLAYER)
            {
                Player *lastSeenTargetPlayer = &AllPlayers[playerToCheck->lastSeenTarget];
                int nearestWaypoint = getNearestWaypoint(lastSeenTargetPlayer->position.x, lastSeenTargetPlayer->position.y, lastSeenTargetPlayer->position.z);
                StartChecking(currentAiToCheck, nearestWaypoint);
                playerToCheck->target = NO_PLAYER;
                playerToCheck->lastSeenTarget = NO_PLAYER;
                if (random() % 2 == 0)
                {
                    if (playerToCheck->Team == COUNTERTERRORISTS && BombPlanted && currentDefuserIndex == NO_PLAYER)
                    {
                        SetDefuser(currentAiToCheck);
                    }
                }
            }
            else if (playerToCheck->PathCount == 0)
            {
                playerToCheck->target = NO_PLAYER;
                playerToCheck->lastSeenTarget = NO_PLAYER;

                if (playerToCheck->haveBomb)
                {
                    float distanceA = GetDistanceBewteenPlayerAndWaypoint(currentAiToCheck, 14);
                    float distanceB = GetDistanceBewteenPlayerAndWaypoint(currentAiToCheck, 29);

                    // if (random() % 2 == 0)
                    if (distanceA < distanceB)
                    {
                        StartChecking(currentAiToCheck, 14); // Bomb site A
                    }
                    else
                    {
                        StartChecking(currentAiToCheck, 29); // Bomb site B
                    }
                }
                else if (bombDropped && playerToCheck->Team == TERRORISTS)
                {
                    // Get the nearest waypoint of the dropped bomb
                    int nearestWaypoint = getNearestWaypoint(droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.y, droppedBombPositionAndRotation.z);

                    // If the player is already at the nearest waypoint, go to the bomb position
                    if (playerToCheck->LastWayPoint == nearestWaypoint)
                    {
                        playerToCheck->searchForDroppedBomb = true;
                    }
                    else // Or go to the  nearest waypoint
                    {
                        StartChecking(currentAiToCheck, nearestWaypoint);
                    }
                }
                else if (playerToCheck->Team == COUNTERTERRORISTS && BombPlanted && currentDefuserIndex == NO_PLAYER)
                {
                    SetDefuser(currentAiToCheck);
                }
                else
                {
                    // TODO move to a random waypoint or stay some seconds
                    GetRandomPoint(currentAiToCheck);
                }
            }
        }
    }
}

void GetRandomPoint(int currentAiToCheck)
{
    if (IsExplode || (BombPlanted && ((BombSeconds <= 5 && AllPlayers[currentAiToCheck].Team == TERRORISTS) || (BombSeconds <= 3 && AllPlayers[currentAiToCheck].Team == COUNTERTERRORISTS)))) // Run away from the bomb
    {
        StartChecking(currentAiToCheck, random() % waypointsSize);
    }
    else
    {
        int site = random() % 2;

        if (bombPlantedAt == 14)
            site = 0;
        else if (bombPlantedAt == 29)
            site = 1;

        Site siteRef = allMaps[currentMap].AllBombsTriggersCollisions[site];

        StartChecking(currentAiToCheck, siteRef.nearWaypoints[random() % siteRef.nearWaypointCount]);
    }
}

/**
 * @brief Set the a Random Defuser
 */
void SetRandomDefuser()
{
    if (currentDefuserIndex == NO_PLAYER)
    {
        // Check if there is an AI is able to defuse the bomb
        bool canAffectDefuser = false;
        for (int playerIndex = 1; playerIndex < MaxPlayer; playerIndex++)
        {
            Player *player = &AllPlayers[playerIndex];
            if (player->Team == COUNTERTERRORISTS && !player->IsDead && player->target == NO_PLAYER && player->Id != UNUSED)
            {
                canAffectDefuser = true;
                break;
            }
        }

        if (canAffectDefuser)
        {
            // Take a random one and the bot will go to the bomb and defuse it
            int newDefuser = (random() % 5) + 1;
            Player *defuserPlayer = &AllPlayers[newDefuser];
            while (defuserPlayer->Team != COUNTERTERRORISTS || defuserPlayer->IsDead || defuserPlayer->target != NO_PLAYER || defuserPlayer->Id == UNUSED)
            {
                defuserPlayer = &AllPlayers[newDefuser];

                newDefuser = (random() % 5) + 1;
            }
            defuserPlayer->PathCount = -1;
            defuserPlayer->lastSeenTarget = NO_PLAYER;
            SetDefuser(newDefuser);
        }
    }
}

/**
 * @brief Force a bot to be a defuser and check a path to the bomb
 *
 * @param defuserIndex player index
 */
void SetDefuser(int defuserIndex)
{
    StartChecking(defuserIndex, bombPlantedAt);
    currentDefuserIndex = defuserIndex;
}

/**
 * @brief Check if AI can shoot his target
 *
 */
void checkAiShoot()
{
    for (int i = 1; i < MaxPlayer; i++)
    {
        Player *player = &AllPlayers[i];
        if (player->target != NO_PLAYER && player->isAi && !player->IsDead)
        {
            Player *targetPlayer = &AllPlayers[player->target];

            // Get the direction to shoot the target
            Vector3 Direction;
            Direction.x = targetPlayer->PlayerModel->x - player->PlayerModel->x;
            Direction.y = targetPlayer->PlayerModel->y - (player->PlayerModel->y + CameraOffsetYMultiplied);
            Direction.z = targetPlayer->PlayerModel->z - player->PlayerModel->z;
            player->AngleDestination = atan2f(Direction.x, Direction.z) * 512.0 / (M_TWOPI) + 256.0;

            if (player->AllGunsInInventory[player->currentGunInInventory] < GunCount && !player->isReloading && player->GunWaitCount >= getPlayerCurrentGun(player).fireRate)
            {
                if (((player->currentGunInInventory == 1 || player->currentGunInInventory == 2) && player->AllAmmoMagazine[player->currentGunInInventory - 1].AmmoCount > 0) || getPlayerCurrentGun(player).isKnife)
                {
                    if (!getPlayerCurrentGun(player).isKnife)
                    {
                        player->AllAmmoMagazine[player->currentGunInInventory - 1].AmmoCount--;
                        // Gun sound
                        int Panning, Volume;
                        GetPanning(player->Id, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, getPlayerCurrentGun(player).MaxSoundDistance);
                        Play3DSound(getPlayerCurrentGun(player).gunSound, Volume, Panning, player);
                    }

                    // Animations
                    setGunRecoil(player);

                    for (int shootIndex = 0; shootIndex < getPlayerCurrentGun(player).bulletCountPerShoot; shootIndex++)
                    {
                        // Make a racast to shoot the target
                        prepareAiRaycast(i, player->target, false);
                        player->GunWaitCount = 0;
                        float hitDistance = 0;
                        if (Raycast(i, shootIndex, &hitDistance) != NO_PLAYER) // If shoot hit the target, apply damage
                        {
                            makeHit(i, player->target, hitDistance, shootIndex);
                        }
                    }
                }
                else
                {
                    // If AI do not have ammo, reload gun or change gun
                    if (player->AllAmmoMagazine[player->currentGunInInventory - 1].AmmoCount == 0 && player->AllAmmoMagazine[player->currentGunInInventory - 1].TotalAmmoCount == 0)
                    {
                        // Change gun
                        ChangeGunInInventory(i, 1);
                    }
                    else
                    {
                        // Reload
                        startReloadGun(i);
                    }
                }
            }
        }
    }
}

/**
 * @brief Check if bot can buy a weapon
 *
 * @param playerIndex
 */
void CheckShopForBot(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    if (player->Id != UNUSED && player->isAi)
    {
        if (player->armor == 0)
        {
            if (player->Money >= allEquipments[3].Price)
            {
                player->Money -= allEquipments[3].Price;
                player->armor = 100;
                player->haveHeadset = true;
            }
            else if (player->Money >= allEquipments[2].Price)
            {
                player->Money -= allEquipments[2].Price;
                player->armor = 100;
            }
        }

        if (player->Team == COUNTERTERRORISTS)
        {
            // Buy only counter terrorist gun

            // Take a random gun category
            int random = 1 + rand() % 3;

            if (cheapestGunsCostCounter[random] <= player->Money && player->AllGunsInInventory[2] == EMPTY) // If bot has enough money, buy a random gun from this category
            {
                findGun(random, playerIndex);
            }
            else if (cheapestGunsCostCounter[0] <= player->Money && player->AllGunsInInventory[1] == EMPTY) // If bot has enough money, buy a random gun from pistols category
            {
                findGun(0, playerIndex);
            }
        }
        else
        {
            // Buy only terrorist gun

            // Take a random gun category
            int random = 1 + rand() % 3;

            if (cheapestGunsCostTerrorists[random] <= player->Money && player->AllGunsInInventory[2] == EMPTY) // If bot has enough money, buy a random gun from this category
            {
                findGun(random, playerIndex);
            }
            else if (cheapestGunsCostTerrorists[0] <= player->Money && player->AllGunsInInventory[1] == EMPTY) // If bot has enough money, buy a random gun from pistols category
            {
                findGun(0, playerIndex);
            }
        }
    }
}

/**
 * @brief Check if bots can buy a weapon
 */
void checkShopForBots()
{
    for (int i = 1; i < MaxPlayer; i++)
    {
        CheckShopForBot(i);
    }
}
```

`Counter-Strike-nds/source/ai/ai.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef AI_H_ /* Include guard */
#define AI_H_

#include "../main.h"

typedef struct
{
    float x;
    float y;
    float z;
    int edgeCount;
    int *edge;
} Waypoint;

typedef struct
{
    int **matrixOneLength;
} PathLength;

#define BOTS_NAMES_COUNT 46
extern const char *botsNames[BOTS_NAMES_COUNT];
extern bool botsNamesTaken[BOTS_NAMES_COUNT];
extern PathLength *AllMatricesLength;
extern int MatriceCount;
extern int waypointsSize;
extern int MatricesSize;

void StartChecking(int playerIndex, int FinalWaypoint);
void GetRandomPoint(int currentAiToCheck);
void CreateWaypoint(int id, float x, float y, float z, int edgeCount, int *edge);
void CheckPathWaypoint(int playerIndex, int StartWaypoint, int FinalWaypoint);
int GetDistanceBewteenTwoPlayers(int player1Index, int player2Index);
int GetDistanceBewteenPlayerAndWaypoint(int playerIndex, int waypointIndex);
void copyArrayToAllMatricesLength(int size, int matrix[size][size], int index);
int getNearestWaypoint(float x, float y, float z);
void ResetTakenBotsNames();
void CheckShopForBot(int playerId);
void checkShopForBots();
void AiCheckForAction();
void checkAiShoot();
void SetDefuser(int defuserIndex);
void SetRandomDefuser();
void freeAllMatricesLength(int size);
void freeWaypoint();

Waypoint *GetWaypoints();

#endif // AI_H_
```

`Counter-Strike-nds/source/ai/data/ai_data.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

// TODO : Load data from a JSON file

#include "ai_data.h"
#include "map.h"

/**
 * @brief Set bots names list
 */
void loadBotsNames()
{
    int index = 0;
    botsNames[index++] = "Albert";
    botsNames[index++] = "Allen";
    botsNames[index++] = "Bert";
    botsNames[index++] = "Bob";
    botsNames[index++] = "Cecil";
    botsNames[index++] = "Clarence";
    botsNames[index++] = "Elliot";
    botsNames[index++] = "Elmer";
    botsNames[index++] = "Ernie";
    botsNames[index++] = "Eugene";
    botsNames[index++] = "Fergus";
    botsNames[index++] = "Ferris";
    botsNames[index++] = "Frank";
    botsNames[index++] = "Frasier";
    botsNames[index++] = "Fred";
    botsNames[index++] = "George";
    botsNames[index++] = "Graham";
    botsNames[index++] = "Harvey";
    botsNames[index++] = "Irwin";
    botsNames[index++] = "Larry";
    botsNames[index++] = "Lester";
    botsNames[index++] = "Marvin";
    botsNames[index++] = "Neil";
    botsNames[index++] = "Niles";
    botsNames[index++] = "Oliver";
    botsNames[index++] = "Opie";
    botsNames[index++] = "Ryan";
    botsNames[index++] = "Toby";
    botsNames[index++] = "Ulric";
    botsNames[index++] = "Ulysses";
    botsNames[index++] = "Uri";
    botsNames[index++] = "Waldo";
    botsNames[index++] = "Wally";
    botsNames[index++] = "Walt";
    botsNames[index++] = "Wesley";
    botsNames[index++] = "Yanni";
    botsNames[index++] = "Yogi";
    botsNames[index++] = "Yuri";
    botsNames[index++] = "Brandon";
    botsNames[index++] = "Josh";
    botsNames[index++] = "Greg";
    botsNames[index++] = "Steve";
    botsNames[index++] = "Xavier";
    botsNames[index++] = "Joe";
    botsNames[index++] = "Vladimir";
    botsNames[index++] = "Kurt";
}

/**
 * @brief Created with the Unity project, needed for path finding
 * Each waypoint is connected to some waypoints
 *
 * @param mapToLoad Map index to load
 */
void CreateWaypoints(int mapToLoad)
{
    if (waypointsSize != 0)
        freeWaypoint();

    if (mapToLoad == DUST2)
    {
        waypointsSize = 58;

        int edge0[3] = {55, 4, 20};
        CreateWaypoint(0, -0.8, 0.0727, 5.94, 3, edge0);
        int edge1[3] = {56, 2, 32};
        CreateWaypoint(1, 1.588759, 0.0727, -13.34, 3, edge1);
        int edge2[3] = {1, 3, 57};
        CreateWaypoint(2, 24.565, 0.0727, -13.38, 3, edge2);
        int edge3[2] = {2, 9};
        CreateWaypoint(3, 37.474, 3.3017, -13.38, 2, edge3);
        int edge4[2] = {0, 5};
        CreateWaypoint(4, -10.82, 0.4764, 4.41, 2, edge4);
        int edge5[2] = {4, 6};
        CreateWaypoint(5, -15.714, 0.4764, 8.416, 2, edge5);
        int edge6[2] = {5, 7};
        CreateWaypoint(6, -15.714, 2.099, 11.648, 2, edge6);
        int edge7[2] = {6, 8};
        CreateWaypoint(7, -17.208, 2.103, 13.19, 2, edge7);
        int edge8[2] = {7, 21};
        CreateWaypoint(8, -20.2982, 4.1082, 13.15, 2, edge8);
        int edge9[3] = {3, 10, 54};
        CreateWaypoint(9, 47.92, 3.3017, -17.4, 3, edge9);
        int edge10[2] = {9, 11};
        CreateWaypoint(10, 47.92, 6.502, -30.298, 2, edge10);
        int edge11[2] = {10, 12};
        CreateWaypoint(11, 43.91, 6.502, -34.19, 2, edge11);
        int edge12[2] = {11, 13};
        CreateWaypoint(12, 40.44, 6.502, -30.322, 2, edge12);
        int edge13[3] = {12, 14, 15};
        CreateWaypoint(13, 40.44, 5.71, -28.29, 3, edge13);
        int edge14[1] = {13};
        CreateWaypoint(14, 41.02, 5.7171, -20.18, 1, edge14);
        int edge15[2] = {13, 16};
        CreateWaypoint(15, 21.45, 5.71, -24.71, 2, edge15);
        int edge16[2] = {15, 17};
        CreateWaypoint(16, 19.26, 5.71, -4.494, 2, edge16);
        int edge17[2] = {16, 18};
        CreateWaypoint(17, 21.03, 3.3012, 1.58, 2, edge17);
        int edge18[2] = {17, 19};
        CreateWaypoint(18, 6.953, 3.3012, 3.8, 2, edge18);
        int edge19[4] = {42, 20, 18, 46};
        CreateWaypoint(19, 6.953, 3.3012, 30.92, 4, edge19);
        int edge20[3] = {0, 19, 46};
        CreateWaypoint(20, 1.65, 3.3012, 21.326, 3, edge20);
        int edge21[3] = {8, 22, 53};
        CreateWaypoint(21, -30.27, 4.1082, 13.15, 3, edge21);
        int edge22[2] = {21, 23};
        CreateWaypoint(22, -38.8, 4.1082, 5.94, 2, edge22);
        int edge23[2] = {22, 24};
        CreateWaypoint(23, -38.275, 4.1082, -4.496, 2, edge23);
        int edge24[3] = {23, 25, 28};
        CreateWaypoint(24, -38.275, 3.3068, -6.1201, 3, edge24);
        int edge25[3] = {24, 26, 28};
        CreateWaypoint(25, -36.513, 3.3068, -18.07, 3, edge25);
        int edge26[2] = {25, 27};
        CreateWaypoint(26, -36.513, 4.1038, -20.6286, 2, edge26);
        int edge27[1] = {26};
        CreateWaypoint(27, -36.513, 4.1038, -26.5, 1, edge27);
        int edge28[4] = {24, 25, 29, 30};
        CreateWaypoint(28, -27.67, 3.3068, -13.19, 4, edge28);
        int edge29[1] = {28};
        CreateWaypoint(29, -27.17, 3.3068, -26.79, 1, edge29);
        int edge30[2] = {28, 31};
        CreateWaypoint(30, -22.02, 3.3068, -13.19, 2, edge30);
        int edge31[2] = {30, 32};
        CreateWaypoint(31, -17.385, 3.3068, -16.984, 2, edge31);
        int edge32[2] = {1, 31};
        CreateWaypoint(32, -7.695, -0.234, -16.36, 2, edge32);
        int edge33[4] = {36, 34, 54, 38};
        CreateWaypoint(33, 49.579, 3.3017, 18.17, 4, edge33);
        int edge34[2] = {33, 35};
        CreateWaypoint(34, 52.7995, 4.9118, 18.17, 2, edge34);
        int edge35[1] = {34};
        CreateWaypoint(35, 54.39, 4.9118, 26.67, 1, edge35);
        int edge36[2] = {33, 37};
        CreateWaypoint(36, 47.88, 3.3017, 21.315, 2, edge36);
        int edge37[1] = {36};
        CreateWaypoint(37, 47.88, -1.5331, 34.2316, 1, edge37);
        int edge38[2] = {33, 39};
        CreateWaypoint(38, 40.04, 3.3017, 17.9, 2, edge38);
        int edge39[2] = {38, 40};
        CreateWaypoint(39, 27.17, 3.3017, 18.47, 2, edge39);
        int edge40[2] = {39, 41};
        CreateWaypoint(40, 29.22, 3.3017, 32.01, 2, edge40);
        int edge41[3] = {40, 42, 43};
        CreateWaypoint(41, 22.81, 3.3017, 38, 3, edge41);
        int edge42[2] = {41, 19};
        CreateWaypoint(42, 15.47, 3.3017, 30.54, 2, edge42);
        int edge43[3] = {44, 47, 41};
        CreateWaypoint(43, 16.63, 3.3017, 60.19, 3, edge43);
        int edge44[2] = {45, 43};
        CreateWaypoint(44, 12.42, 3.3017, 55.01, 2, edge44);
        int edge45[2] = {46, 44};
        CreateWaypoint(45, 0.87, 3.3017, 55.01, 2, edge45);
        int edge46[3] = {19, 20, 45};
        CreateWaypoint(46, 0.83, 3.3017, 34.08, 3, edge46);
        int edge47[2] = {43, 48};
        CreateWaypoint(47, 11.65, 3.3017, 60.19, 2, edge47);
        int edge48[2] = {47, 49};
        CreateWaypoint(48, -1.254, 6.529, 60.19, 2, edge48);
        int edge49[2] = {50, 48};
        CreateWaypoint(49, -24.84, 6.529, 61.69, 2, edge49);
        int edge50[2] = {49, 51};
        CreateWaypoint(50, -37.03, 6.529, 56.829, 2, edge50);
        int edge51[2] = {50, 52};
        CreateWaypoint(51, -37.03, 3.278, 43.903, 2, edge51);
        int edge52[2] = {51, 53};
        CreateWaypoint(52, -30.061, 3.278, 28.464, 2, edge52);
        int edge53[2] = {52, 21};
        CreateWaypoint(53, -30.061, 4.1094, 26.966, 2, edge53);
        int edge54[2] = {33, 9};
        CreateWaypoint(54, 49.97, 3.3017, 2.61, 2, edge54);
        int edge55[2] = {0, 56};
        CreateWaypoint(55, 3.08, 0.0727, 0.82, 2, edge55);
        int edge56[2] = {1, 55};
        CreateWaypoint(56, 1.01, 0.0727, -2.04, 2, edge56);
        int edge57[1] = {2};
        CreateWaypoint(57, 19.58, 0.0727, -19.42, 1, edge57);
    }
    else if (mapToLoad == TUTORIAL)
    {
        waypointsSize = 14;

        int edge0[3] = {1, 10, 2};
        CreateWaypoint(0, 9, 0.55, -5, 3, edge0);
        int edge1[3] = {0, 10, 3};
        CreateWaypoint(1, 9, 0.55, -8, 3, edge1);
        int edge2[5] = {10, 0, 3, 11, 4};
        CreateWaypoint(2, 4.5, 0.55, -5, 5, edge2);
        int edge3[5] = {10, 1, 2, 11, 5};
        CreateWaypoint(3, 4.5, 0.55, -8, 5, edge3);
        int edge4[5] = {11, 12, 5, 6, 2};
        CreateWaypoint(4, 0, 0.55, -5, 5, edge4);
        int edge5[5] = {11, 4, 12, 7, 3};
        CreateWaypoint(5, 0, 0.55, -8, 5, edge5);
        int edge6[4] = {13, 12, 7, 4};
        CreateWaypoint(6, -4.5, 0.55, -5, 4, edge6);
        int edge7[4] = {12, 6, 13, 5};
        CreateWaypoint(7, -4.5, 0.55, -8, 4, edge7);
        int edge8[3] = {9, 6, 13};
        CreateWaypoint(8, -9, 0.55, -5, 3, edge8);
        int edge9[3] = {13, 8, 7};
        CreateWaypoint(9, -9, 0.55, -8, 3, edge9);
        int edge10[4] = {0, 1, 2, 3};
        CreateWaypoint(10, 7, 0.55, -6.5, 4, edge10);
        int edge11[4] = {3, 2, 5, 4};
        CreateWaypoint(11, 2, 0.55, -6.5, 4, edge11);
        int edge12[4] = {4, 5, 7, 6};
        CreateWaypoint(12, -2, 0.55, -6.5, 4, edge12);
        int edge13[4] = {7, 6, 8, 9};
        CreateWaypoint(13, -7, 0.55, -6.5, 4, edge13);
    }
}

/**
 * @brief Created with the Unity project, needed for path finding.
 * Why I'm dooing that? See https://en.wikipedia.org/wiki/Adjacency_matrix
 * Every matrices are the same size and are filled with 0 or 1.
 * 0 means that the two waypoints are not connected with a path of x length, 1 means that they are.
 * Ex : matrix2 list all waypoints connected with a path of 2 length.
 *
 * @param mapToLoad Map index to load
 */
void createLengthMatrices(int mapToLoad)
{
    freeAllMatricesLength(MatricesSize);
    if (AllMatricesLength)
        free(AllMatricesLength);

    if (mapToLoad == DUST2)
    {
        MatriceCount = 15;
        AllMatricesLength = malloc(MatriceCount * sizeof(PathLength));
        MatricesSize = 58;
        int matrix1[58][58] = {
            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
        copyArrayToAllMatricesLength(58, matrix1, 0);

        int matrix2[58][58] = {
            {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}};
        copyArrayToAllMatricesLength(58, matrix2, 1);

        int matrix3[58][58] = {
            {0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}};
        copyArrayToAllMatricesLength(58, matrix3, 2);

        int matrix4[58][58] = {
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}};
        copyArrayToAllMatricesLength(58, matrix4, 3);

        int matrix5[58][58] = {
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}};
        copyArrayToAllMatricesLength(58, matrix5, 4);

        int matrix6[58][58] = {
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0},
            {0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
            {1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}};
        copyArrayToAllMatricesLength(58, matrix6, 5);

        int matrix7[58][58] = {
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0},
            {0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1},
            {0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1},
            {0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
            {1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1},
            {0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}};
        copyArrayToAllMatricesLength(58, matrix7, 6);

        int matrix8[58][58] = {
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
            {1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1},
            {1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1},
            {0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0},
            {1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}};
        copyArrayToAllMatricesLength(58, matrix8, 7);

        int matrix9[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
            {1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}};
        copyArrayToAllMatricesLength(58, matrix9, 8);

        int matrix10[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1},
            {1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0},
            {1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
            {1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}};
        copyArrayToAllMatricesLength(58, matrix10, 9);

        int matrix11[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1},
            {1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0}};
        copyArrayToAllMatricesLength(58, matrix11, 10);

        int matrix12[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1}};
        copyArrayToAllMatricesLength(58, matrix12, 11);

        int matrix13[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0}};
        copyArrayToAllMatricesLength(58, matrix13, 12);

        int matrix14[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}};
        copyArrayToAllMatricesLength(58, matrix14, 13);

        int matrix15[58][58] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}};
        copyArrayToAllMatricesLength(58, matrix15, 14);
    }
    else if (mapToLoad == TUTORIAL)
    {
        MatriceCount = 5;
        MatricesSize = 14;
        AllMatricesLength = malloc(MatriceCount * sizeof(PathLength));

        int matrix1[14][14] = {
            {0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0},
            {0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0},
            {0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0},
            {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0}};
        copyArrayToAllMatricesLength(14, matrix1, 0);

        int matrix2[14][14] = {
            {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0},
            {1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0},
            {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0},
            {1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1},
            {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1},
            {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1}};
        copyArrayToAllMatricesLength(14, matrix2, 1);

        int matrix3[14][14] = {
            {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1}};
        copyArrayToAllMatricesLength(14, matrix3, 2);

        int matrix4[14][14] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}};
        copyArrayToAllMatricesLength(14, matrix4, 3);

        int matrix5[14][14] = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}};
        copyArrayToAllMatricesLength(14, matrix5, 4);
    }
}

```

`Counter-Strike-nds/source/ai/data/ai_data.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef AI_DATA_H_ /* Include guard */
#define AI_DATA_H_

#include "ai.h"

void loadBotsNames();
void CreateWaypoints(int mapToLoad);
void createLengthMatrices(int mapToLoad);

#endif // AI_DATA_H_
```

`Counter-Strike-nds/source/collisions/collisions.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

//#include "main.h"
#include "collisions.h"
#include "raycast.h"
#include "network.h"
#include "ai.h"
#include "gun.h"
#include "player.h"
#include "sounds.h"
#include "movements.h"
#include "map.h"
#include "party.h"

// All spawned grenades are here
PhysicalGrenade *grenades[GrenadeCount];
// Map index to load (for loading collisions)
int mapToSet = 0;

/**
 * @brief Add all trigger zones for occlusion culling
 *
 */
void CalculateAllTriggerColBoxs(int mapToLoad)
{
    Map *map = &allMaps[mapToLoad];
    int currentZone = 0;

    if (mapToLoad == DUST2)
    {
        // All occlusion culling zones data (a zone will show one or multiple zones)
        map->zonesCount = 21;
        map->AllZones = malloc(map->zonesCount * sizeof(Zone));

        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 4;
        map->AllZones[currentZone].visibleMapPart[2] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 1;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 1;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 2;
        map->AllZones[currentZone].ZoneCount = 2;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 1;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 3;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 3;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 4;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 1;
        map->AllZones[currentZone].visibleMapPart[2] = 2;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 5;
        map->AllZones[currentZone].ZoneCount = 4;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 1;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].visibleMapPart[3] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 6;
        map->AllZones[currentZone].ZoneCount = 4;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 3;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].visibleMapPart[3] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 7;
        map->AllZones[currentZone].ZoneCount = 2;
        map->AllZones[currentZone].visibleMapPart[0] = 4;
        map->AllZones[currentZone].visibleMapPart[1] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 8;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 4;
        map->AllZones[currentZone].visibleMapPart[1] = 5;
        map->AllZones[currentZone].visibleMapPart[2] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 9;
        map->AllZones[currentZone].ZoneCount = 2;
        map->AllZones[currentZone].visibleMapPart[0] = 5;
        map->AllZones[currentZone].visibleMapPart[1] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 10;
        map->AllZones[currentZone].ZoneCount = 2;
        map->AllZones[currentZone].visibleMapPart[0] = 5;
        map->AllZones[currentZone].visibleMapPart[1] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 11;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 2;
        map->AllZones[currentZone].visibleMapPart[1] = 3;
        map->AllZones[currentZone].visibleMapPart[2] = 5;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 12;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 3;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 13;
        map->AllZones[currentZone].ZoneCount = 4;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 2;
        map->AllZones[currentZone].visibleMapPart[2] = 3;
        map->AllZones[currentZone].visibleMapPart[3] = 5;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 14;
        map->AllZones[currentZone].ZoneCount = 5;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 2;
        map->AllZones[currentZone].visibleMapPart[2] = 3;
        map->AllZones[currentZone].visibleMapPart[3] = 4;
        map->AllZones[currentZone].visibleMapPart[4] = 5;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 15;
        map->AllZones[currentZone].ZoneCount = 4;
        map->AllZones[currentZone].visibleMapPart[0] = 2;
        map->AllZones[currentZone].visibleMapPart[1] = 3;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].visibleMapPart[3] = 5;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 16;
        map->AllZones[currentZone].ZoneCount = 4;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 2;
        map->AllZones[currentZone].visibleMapPart[2] = 3;
        map->AllZones[currentZone].visibleMapPart[3] = 5;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 17;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 2;
        map->AllZones[currentZone].visibleMapPart[2] = 3;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 18;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 1;
        map->AllZones[currentZone].visibleMapPart[2] = 3;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 19;
        map->AllZones[currentZone].ZoneCount = 3;
        map->AllZones[currentZone].visibleMapPart[0] = 3;
        map->AllZones[currentZone].visibleMapPart[1] = 4;
        map->AllZones[currentZone].visibleMapPart[2] = 6;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 20;
        map->AllZones[currentZone].ZoneCount = 4;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 3;
        map->AllZones[currentZone].visibleMapPart[2] = 4;
        map->AllZones[currentZone].visibleMapPart[3] = 6;
        map->AllZones[currentZone].id = currentZone;

        // Add occlusion culling triggers
        CalculateTriggerColBox(-9.52357, 57.34258, 15.70023, 20.76961, 0);
        CalculateTriggerColBox(-32.8, 31.70565, 25.39098, 32.87455, 1);
        CalculateTriggerColBox(-30.03613, 9.913523, 7.458398, 9.875763, 2);
        CalculateTriggerColBox(-12.07624, 8.24, 20.75247, 13, 3);
        CalculateTriggerColBox(-38.87369, 3.970799, 9.822498, 15.72273, 4);
        CalculateTriggerColBox(-31.71968, 57.28525, 27.55163, 17.77374, 5);
        CalculateTriggerColBox(10.59276, 58.97986, 23.88577, 17.49506, 6);
        CalculateTriggerColBox(22.83467, 41.8413, 16.72676, 16.5031, 7);
        CalculateTriggerColBox(27.63166, 29.56198, 6.307827, 7.687183, 8);
        CalculateTriggerColBox(29.65833, 17.5136, 11.42418, 16.10892, 9);
        CalculateTriggerColBox(47.04734, 20.07397, 22.30289, 42.11788, 10);
        CalculateTriggerColBox(31.25437, -19.58616, 52.12261, 37.01623, 11);
        CalculateTriggerColBox(11.91049, 2.419476, 25.90689, 6.575387, 12);
        CalculateTriggerColBox(-13.12243, -19.91082, 15.07712, 12.67715, 13);
        CalculateTriggerColBox(-11.61234, -19.34598, 18.0973, 11.54748, 14);
        CalculateTriggerColBox(-7.77587, -16.08564, 25.74453, 30.01518, 15);
        CalculateTriggerColBox(-31.87811, -8.83736, 22.03724, 15.51862, 16);
        CalculateTriggerColBox(-31.87811, -28.16135, 22.03724, 23.0819, 17);
        CalculateTriggerColBox(-24.4092, 11.52498, 3.830673, 6.652855, 18);
        CalculateTriggerColBox(0.2512362, 31.8348, 16.78329, 36.75443, 19);
        CalculateTriggerColBox(3.534717, 9.606822, 9.155338, 8.084706, 20);

        map->occlusionZoneCount = 7;
        map->AllOcclusionZone = malloc(map->occlusionZoneCount * sizeof(OcclusionZone));

        // Add clipping zones
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[0].angles[0].x = -11.1;
        map->AllOcclusionZone[0].angles[0].y = 83.1;

        map->AllOcclusionZone[0].angles[1].x = -46.5;
        map->AllOcclusionZone[0].angles[1].y = 83.1;

        map->AllOcclusionZone[0].angles[2].x = -46.5;
        map->AllOcclusionZone[0].angles[2].y = 20.7;

        map->AllOcclusionZone[0].angles[3].x = -11.1;
        map->AllOcclusionZone[0].angles[3].y = 20.7;
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[1].angles[0].x = -6.8;
        map->AllOcclusionZone[1].angles[0].y = 25.4;

        map->AllOcclusionZone[1].angles[1].x = -45.8;
        map->AllOcclusionZone[1].angles[1].y = 25.4;

        map->AllOcclusionZone[1].angles[2].x = -45.8;
        map->AllOcclusionZone[1].angles[2].y = -5.39;

        map->AllOcclusionZone[1].angles[3].x = -6.8;
        map->AllOcclusionZone[1].angles[3].y = -5.39;
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[2].angles[0].x = -4.1;
        map->AllOcclusionZone[2].angles[0].y = 3.5;

        map->AllOcclusionZone[2].angles[1].x = -54.8;
        map->AllOcclusionZone[2].angles[1].y = 3.5;

        map->AllOcclusionZone[2].angles[2].x = -54.8;
        map->AllOcclusionZone[2].angles[2].y = -43;

        map->AllOcclusionZone[2].angles[3].x = -4.1;
        map->AllOcclusionZone[2].angles[3].y = -43;
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[3].angles[0].x = 36;
        map->AllOcclusionZone[3].angles[0].y = 12.6;

        map->AllOcclusionZone[3].angles[1].x = -9.1;
        map->AllOcclusionZone[3].angles[1].y = 12.6;

        map->AllOcclusionZone[3].angles[2].x = -9.1;
        map->AllOcclusionZone[3].angles[2].y = -34.9;

        map->AllOcclusionZone[3].angles[3].x = 36;
        map->AllOcclusionZone[3].angles[3].y = -34.9;
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[4].angles[0].x = 15.54;
        map->AllOcclusionZone[4].angles[0].y = 68.4;

        map->AllOcclusionZone[4].angles[1].x = -13;
        map->AllOcclusionZone[4].angles[1].y = 68.4;

        map->AllOcclusionZone[4].angles[2].x = -13;
        map->AllOcclusionZone[4].angles[2].y = 4.43;

        map->AllOcclusionZone[4].angles[3].x = 15.54;
        map->AllOcclusionZone[4].angles[3].y = 4.43;
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[5].angles[0].x = 58.3;
        map->AllOcclusionZone[5].angles[0].y = 42;

        map->AllOcclusionZone[5].angles[1].x = 29.4;
        map->AllOcclusionZone[5].angles[1].y = 42;

        map->AllOcclusionZone[5].angles[2].x = 29.4;
        map->AllOcclusionZone[5].angles[2].y = -38.1;

        map->AllOcclusionZone[5].angles[3].x = 58.3;
        map->AllOcclusionZone[5].angles[3].y = -38.1;
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[6].angles[0].x = 37.2;
        map->AllOcclusionZone[6].angles[0].y = 66.2;

        map->AllOcclusionZone[6].angles[1].x = 7.3;
        map->AllOcclusionZone[6].angles[1].y = 66.2;

        map->AllOcclusionZone[6].angles[2].x = 7.3;
        map->AllOcclusionZone[6].angles[2].y = 7.8;

        map->AllOcclusionZone[6].angles[3].x = 37.2;
        map->AllOcclusionZone[6].angles[3].y = 7.8;
    }
    else if (mapToLoad == TUTORIAL)
    {
        // All occlusion culling zones data (a zone will show one or multiple zones)
        map->zonesCount = 2;
        map->AllZones = malloc(map->zonesCount * sizeof(Zone));

        map->AllZones[currentZone].ZoneCount = 2;
        map->AllZones[currentZone].visibleMapPart[0] = 0;
        map->AllZones[currentZone].visibleMapPart[1] = 1;
        map->AllZones[currentZone].id = currentZone;

        currentZone = 1;
        map->AllZones[currentZone].ZoneCount = 2;
        map->AllZones[currentZone].visibleMapPart[0] = 1;
        map->AllZones[currentZone].visibleMapPart[1] = 0;
        map->AllZones[currentZone].id = currentZone;

        // Add occlusion culling triggers
        CalculateTriggerColBox(0, 2, 22.7, 22.7, 0);
        CalculateTriggerColBox(0, 2, 22.7, 22.7, 1);

        map->shadowCollisionBoxCount = 3;
        map->AllShadowCollisionBox = malloc(map->shadowCollisionBoxCount * sizeof(CollisionBox));

        // Add shadow collision boxes
        CalculateShadowColBox(0, 4.5, 11.65236, 22.7, 9, 3.395271, 0);
        CalculateShadowColBox(7.583056, 4.5, 1.242216, 7.533887, 9, 24.21557, 1);
        CalculateShadowColBox(-1.585769, 1.017356, 1.17581, 2.752997, 2.034714, 2.829585, 2);

        map->occlusionZoneCount = 2;
        map->AllOcclusionZone = malloc(map->occlusionZoneCount * sizeof(OcclusionZone));

        // Add clipping zones
        /////////////////////////////////////////////////////
        map->AllOcclusionZone[0].angles[0].x = 11.335;
        map->AllOcclusionZone[0].angles[0].y = 13.278;

        map->AllOcclusionZone[0].angles[1].x = -11.332;
        map->AllOcclusionZone[0].angles[1].y = 13.278;

        map->AllOcclusionZone[0].angles[2].x = -11.332;
        map->AllOcclusionZone[0].angles[2].y = -9.395;

        map->AllOcclusionZone[0].angles[3].x = 11.335;
        map->AllOcclusionZone[0].angles[3].y = 9.395;

        map->AllOcclusionZone[1].angles[0].x = 11.335;
        map->AllOcclusionZone[1].angles[0].y = 13.278;

        map->AllOcclusionZone[1].angles[1].x = -11.332;
        map->AllOcclusionZone[1].angles[1].y = 13.278;

        map->AllOcclusionZone[1].angles[2].x = -11.332;
        map->AllOcclusionZone[1].angles[2].y = -9.395;

        map->AllOcclusionZone[1].angles[3].x = 11.335;
        map->AllOcclusionZone[1].angles[3].y = 9.395;
    }

    // Convert map limits to a int format
    for (int i = 0; i < map->occlusionZoneCount; i++)
    {
        for (int i2 = 0; i2 < 4; i2++)
        {
            map->AllOcclusionZone[i].anglesInt[i2].x = map->AllOcclusionZone[i].angles[i2].x * 4096.0;
            map->AllOcclusionZone[i].anglesInt[i2].y = map->AllOcclusionZone[i].angles[i2].y * 4096.0;
        }
    }
}

/**
 * @brief Add walls for collisions for dust2 map.
 * Generated with the Unity project
 */
void LoadAllCollisions(int mapToLoad)
{
    if (mapToLoad == DUST2)
    {
        mapToSet = DUST2;
        allMaps[mapToLoad].CollisionsCount = 211;
        allMaps[mapToLoad].AllWallsCollisions = malloc(allMaps[mapToLoad].CollisionsCount * sizeof(Wall));
        CreateWall(9.38846, -1.4, -8.007592, 35.77919, 1, 33.08558, 3, 0);
        CreateWall(3.991, 0.285, 4.786, 2.423, 2.423, 2.423, 3, 1);
        CreateWall(5.41, 1.107, 5.980854, 0.4, 4, 30.68171, 3, 2);
        CreateWall(-1.4, 1.8, 38.985, 13, 1, 34.67, 4, 3);
        CreateWall(-10.31409, -1.03, 5.18, 17.45819, 1, 7, 1, 4);
        CreateWall(-1.654, 2.288648, 16.47623, 0.8, 6.477295, 19.37246, 4, 5);
        CreateWall(-1.654, 2.05, 2.617579, 0.8, 6, 1.884841, 3, 6);
        CreateWall(24.42, 1.8, 29.52468, 37.5, 1, 67.90935, -1, 7);
        CreateWall(48.3451, 1.8, 1.665, 9.130207, 1, 38.67, 5, 8);
        CreateWall(40.63582, 1.8, -14.36, 5.668356, 1, 7, 5, 9);
        CreateWall(44.5, 5.04, -33.965, 15, 1, 6.67, 5, 10);
        CreateWall(47.75, -3.04, 37.732, 9, 1, 7, 5, 11);
        CreateWall(40.68, 4.23, -23.46, 5.7, 1, 11.2, 5, 12);
        CreateWall(27.58, 4.225, -24.69, 20, 1, 9, 3, 13);
        CreateWall(21.51, 4.225, -12.405, 7, 1, 15.17, 3, 14);
        CreateWall(-30.05, 1.8, -16.65, 24.67, 1, 34, 2, 15);
        CreateWall(-37.12021, 2.6, -30.795, 9.679577, 1, 19.67, 2, 16);
        CreateWall(-38.66, 2.6065, 3.923, 10, 1, 16.17, 1, 17);
        CreateWall(-26.975, 2.6065, 10.75, 12.67, 1, 11.5, 1, 18);
        CreateWall(-31.85, 2.6065, 21.645, 16.8, 1, 9.97, 1, 19);
        CreateWall(-31.85, 1.8, 35.88, 16.8, 1, 16, 0, 20);
        CreateWall(-36.76, 5.03, 60.475, 6.5, 1, 6.67, 0, 21);
        CreateWall(-42.78, 5.03, 58.6, 5, 1, 10, 0, 22);
        CreateWall(-22.91243, 5.03, 53.76, 20.59513, 1, 19, 0, 23);
        CreateWall(-7.165, 5.03, 61.57, 11.17, 1, 10, 4, 24);
        CreateWall(-15.974, 0.591, 13.66, 3.7, 1, 3.37, 1, 25);
        CreateWall(55.00196, 3.415, 23.80224, 3.714117, 1, 17.83263, 5, 26);
        CreateWall(4.846629, 2.989377, -0.481, 0.9097431, 7.831755, 2.423, 3, 27);
        CreateWall(-0.8933716, 2.709331, -0.481, 0.9097431, 7.271662, 2.423, 3, 28);
        CreateWall(0.6405261, 1.114704, 0.3353194, 2.150795, 4.082407, 0.6293912, 3, 29);
        CreateWall(3.354151, 1.114704, -1.250537, 2.145238, 4.082407, 0.6865859, 3, 30);
        CreateWall(4.053317, 1.114704, -0.5631354, 0.6353655, 4.082407, 0.3297293, 3, 31);
        CreateWall(-0.1147662, 1.114704, -0.41167, 0.6778869, 4.082407, 0.3050682, 3, 32);
        CreateWall(-10.94747, 2.889332, -4.495358, 19.35818, 7.631665, 12.90928, -1, 33);
        CreateWall(-1.26794, 2.889332, -23.5255, 12.94932, 7.631665, 2.408997, 3, 34);
        CreateWall(-11.71794, 4.209399, -25.88165, 12.94932, 10.2718, 3.561691, 2, 35);
        CreateWall(-19.24169, 4.209399, -28.2181, 2.751635, 10.2718, 1.161465, 2, 36);
        CreateWall(-16.24241, 3.05695, -12.16243, 2.29025, 3.088099, 2.408759, 2, 37);
        CreateWall(-20.628, 4.339704, -12.831, 0.6293912, 4.082407, 2.150795, 2, 38);
        CreateWall(-21.486, 4.339704, -16.268, 0.3297293, 4.082407, 0.6353655, 2, 39);
        CreateWall(-22.215, 4.339704, -15.521, 0.6293912, 4.082407, 2.150795, 2, 40);
        CreateWall(-21.352, 4.339704, -12.076, 0.3297293, 4.082407, 0.6353655, 2, 41);
        CreateWall(-17.98957, 2.909, -11.5547, 1.207145, 1.2, 1.211931, 2, 42);
        CreateWall(-21.42, 5.894331, -11.297, 2.423, 7.271662, 0.9097431, 2, 43);
        CreateWall(-21.42, 5.894331, -17.06, 2.423, 7.271662, 0.9097431, 2, 44);
        CreateWall(-21.41365, 5.894331, -21.33369, 1.604465, 7.271662, 8.111914, 2, 45);
        CreateWall(-21.41365, 5.894331, -8.338291, 1.604465, 7.271662, 5.283774, 2, 46);
        CreateWall(-21.41365, 5.894331, -29.9949, 1.604465, 7.271662, 4.181724, 2, 47);
        CreateWall(-20.05958, 4.082152, -26.64717, 3.652607, 3.647305, 2.424164, 2, 48);
        CreateWall(-23.02708, 3.912082, -27.25182, 1.616625, 3.231766, 1.284817, 2, 49);
        CreateWall(-23.02901, 4.519009, -25.66659, 1.620493, 1.219922, 1.21636, 2, 50);
        CreateWall(-23.8313, 3.102336, -25.47028, 3.225069, 1.615268, 1.608994, 2, 51);
        CreateWall(9.870321, 1.493199, -8.82, 8.488289, 4.839397, 1, 3, 52);
        CreateWall(19.71741, 1.488101, -10.13818, 11.26746, 4.849592, 1.627839, 3, 53);
        CreateWall(34.23705, 3.871293, -0.4494247, 19.34229, 9.615976, 20.9745, -1, 54);
        CreateWall(8.829233, 0.6898834, -10.13725, 1.602546, 3.232767, 1.615795, 3, 55);
        CreateWall(7.217544, 0.2866741, -16.19459, 2.415168, 2.426349, 2.424468, 3, 56);
        CreateWall(6.816122, 2.310524, -16.59494, 1.612324, 1.596437, 1.616609, 3, 57);
        CreateWall(18.91403, 1.488101, -23.54818, 11.28471, 4.849592, 1, 3, 58);
        CreateWall(9.246572, 1.488101, -20.25092, 8.058916, 4.849592, 5.70549, 3, 59);
        CreateWall(24.96741, 1.488101, -20.2333, 0.8, 4.849592, 5.66225, 3, 60);
        CreateWall(26.58551, 0.4672852, -18.67, 2.418206, 2.457632, 2.39, 3, 61);
        CreateWall(29.00651, 1.064285, -18.67, 2.418206, 2.457632, 2.39, 3, 62);
        CreateWall(26.98624, 2.499154, -19.01415, 1.618732, 1.627894, 1.629699, 3, 63);
        CreateWall(31.60709, 2.795956, -20.02006, 12.55215, 5.453778, 0.4001274, 3, 64);
        CreateWall(40.56831, 3.903672, -17.60006, 6.194584, 3.238344, 0.4001274, 5, 65);
        CreateWall(37.69, 3.903672, -18.81139, 0.4001274, 3.238344, 2.822779, 5, 66);
        CreateWall(43.73696, 3.752151, -23.85887, 0.4140491, 3.541387, 12.91774, 5, 67);
        CreateWall(25.17, 4.305497, -15.58066, 0.4001274, 2.434694, 9.287472, 3, 68);
        CreateWall(38.68263, 5.510857, -19.60757, 1.611956, 1.60449, 3.610546, 5, 69);
        CreateWall(38.68263, 7.150856, -19.01406, 1.611956, 1.60449, 1.619928, 5, 70);
        CreateWall(42.71363, 5.530857, -22.65006, 1.611956, 1.60449, 1.619928, 5, 71);
        CreateWall(27.79171, 7.936794, -32.73777, 19.3618, 6.416366, 8.091341, 3, 72);
        CreateWall(27.78882, 7.936794, -28.30295, 7.260923, 6.416366, 0.8257637, 3, 73);
        CreateWall(15.6907, 7.936794, -13.78543, 4.817293, 6.416366, 29.87009, 3, 74);
        CreateWall(18.42, 7.936794, -20.63499, 1, 6.416366, 7.24859, 3, 75);
        CreateWall(44.73563, 3.656087, -19.84385, 1.611956, 2.038029, 1.555517, 5, 76);
        CreateWall(54.45702, 6.858232, -27.74011, 4.934025, 8.573491, 20.66022, 5, 77);
        CreateWall(44.79, 6.858232, -37.25, 15, 8.573491, 1, 5, 78);
        CreateWall(43.12514, 3.871293, -10.13021, 3.204861, 9.615976, 3.212919, 5, 79);
        CreateWall(43.12514, 3.871293, 9.217745, 3.204861, 9.615976, 3.228837, 5, 80);
        CreateWall(55.61611, 4.50092, -5.702986, 2.438217, 2.458159, 2.414028, 5, 81);
        CreateWall(55.15685, 5.471698, 5.165548, 6.338552, 6.415167, 19.35178, 5, 82);
        CreateWall(58.07824, 5.471698, 7.948711, 2.521341, 6.415167, 50.76546, 5, 83);
        CreateWall(56.02677, 4.719615, 15.67324, 1.615543, 1.62077, 1.627525, 5, 84);
        CreateWall(55.63088, 6.345802, 31.40095, 2.447762, 4.873144, 2.418945, 5, 85);
        CreateWall(47.67071, 6.720139, 36.50803, 13.9532, 8.840049, 7.817391, 5, 86);
        CreateWall(37.47268, 6.720139, 35.01363, 3.218556, 8.840049, 1.644658, 5, 87);
        CreateWall(38.30424, 6.720139, 36.66363, 4.881684, 8.840049, 1.644658, 5, 88);
        CreateWall(47.88821, -0.1699834, 41.53085, 8.275005, 4.7418, 1.703053, 5, 89);
        CreateWall(43.52215, 0.2628939, 31.01274, 0.8107128, 5.686295, 19.40301, 5, 90);
        CreateWall(44.72398, -1.73808, 39.10096, 1.634037, 1.618159, 3.295925, 5, 91);
        CreateWall(51.18998, -1.73808, 35.84166, 1.634037, 1.618159, 3.231308, 5, 92);
        CreateWall(51.18998, -0.1290795, 36.23938, 1.634037, 1.618159, 1.610428, 5, 93);
        CreateWall(52.32014, 0.8512607, 29.83927, 0.6802864, 6.955806, 20.27887, 5, 94);
        CreateWall(52.32679, 3.286222, 15.67575, 0.6669998, 2.08588, 1.603443, 5, 95);
        CreateWall(33.44603, 6.720139, 36.03182, 4.826495, 8.840049, 29.46829, 6, 96);
        CreateWall(22.95895, 6.720139, 21.99475, 3.240649, 8.840049, 24.45416, 6, 97);
        CreateWall(30.64663, 5.934331, 33.42, 0.9097431, 7.271662, 2.423, 6, 98);
        CreateWall(24.90663, 5.934331, 33.42, 0.9097431, 7.271662, 2.423, 6, 99);
        CreateWall(26.44053, 4.339704, 32.63532, 2.150795, 4.082407, 0.6293912, 6, 100);
        CreateWall(29.15415, 4.339704, 34.19246, 2.145238, 4.082407, 0.6865859, 6, 101);
        CreateWall(29.85332, 4.339704, 33.49086, 0.6353655, 4.082407, 0.3297293, 6, 102);
        CreateWall(25.68523, 4.339704, 33.37033, 0.6778869, 4.082407, 0.3050682, 6, 103);
        CreateWall(29.813, 3.51, 24.547, 2.423, 2.423, 2.423, 6, 104);
        CreateWall(24.90663, 5.934331, 22.13, 0.9097431, 7.271662, 2.423, 6, 105);
        CreateWall(30.64663, 5.934331, 22.13, 0.9097431, 7.271662, 2.423, 6, 106);
        CreateWall(26.37633, 6.720139, 57.01281, 10.12095, 8.840049, 13.31212, 6, 107);
        CreateWall(24.96766, 5.934331, 50.29894, 0.8096883, 7.271662, 0.6728878, 6, 108);
        CreateWall(30.61666, 5.934331, 50.29894, 0.8096883, 7.271662, 0.6728878, 6, 109);
        CreateWall(21.266, 5.934331, 57.22, 0.6728878, 7.271662, 0.8096883, 6, 110);
        CreateWall(21.266, 5.934331, 62.85, 0.6728878, 7.271662, 0.8096883, 6, 111);
        CreateWall(15.38498, 6.720139, 65.11506, 13.95091, 8.840049, 3.702241, 6, 112);
        CreateWall(-18.70116, 6.720139, 67.90365, 54.33317, 8.840049, 2.839417, 0, 113);
        CreateWall(-20.62166, 9.071501, 66.18, 7.271675, 5.883001, 1, 0, 114);
        CreateWall(-33.51166, 9.071501, 66.18, 7.271675, 5.883001, 1, 0, 115);
        CreateWall(19.46931, 6.720139, 16.87856, 9.941291, 8.840049, 23.40178, -1, 116);
        CreateWall(11.42511, 6.720139, 16.45395, 6.092877, 8.840049, 22.55255, -1, 117);
        CreateWall(8.43699, 6.720139, 43.91084, 12.90911, 8.840049, 19.34007, -1, 118);
        CreateWall(15.2, 6.720139, 43.90626, 1, 8.840049, 7.272514, 6, 119);
        CreateWall(9.832866, 6.720139, 33.91, 10.07427, 8.840049, 1, 4, 120);
        CreateWall(3.994344, 3.108447, 33.42598, 1.615686, 1.604893, 1.623959, 4, 121);
        CreateWall(-5.272417, 5.538648, 25.75, 4.824834, 6.477295, 4, 4, 122);
        CreateWall(-5.272417, 5.538648, 36.227, 4.824834, 6.477295, 4, 4, 123);
        CreateWall(-6.90057, 6.730637, 46.3273, 11.26114, 8.861274, 20.97461, -1, 124);
        CreateWall(-7.831, 5.3, 30.99, 1, 6, 6.5, 4, 125);
        CreateWall(5.074815, 4.301765, 56.40557, 13.1601, 4.062151, 0.7663727, 4, 126);
        CreateWall(0.24, 7.568765, 47.13827, 3.5, 4.062151, 12.90346, 4, 127);
        CreateWall(-0.4394904, 4.314489, 43.90987, 1.612981, 4.03266, 3.21767, 4, 128);
        CreateWall(-11.73649, 7.54249, 64.4865, 1.612981, 4.03266, 4.060944, 0, 129);
        CreateWall(-11.92781, 7.54249, 56.60429, 1.995615, 4.03266, 2.005371, 0, 130);
        CreateWall(-14.16297, 7.145098, 55.19912, 3.225281, 3.237878, 3.219673, 0, 131);
        CreateWall(-13.34894, 7.145098, 52.7741, 1.610119, 3.237878, 1.614204, 0, 132);
        CreateWall(-11.92781, 7.54249, 62.85986, 1.995615, 4.03266, 0.8165054, 0, 133);
        CreateWall(-44.83156, 7.54249, 62.85986, 0.8431206, 4.03266, 0.8165054, 0, 134);
        CreateWall(-44.84383, 7.54249, 57.21986, 0.8676491, 4.03266, 0.8165054, 0, 135);
        CreateWall(-45.35478, 7.54249, 59.61, 1.089561, 4.03266, 15, 0, 136);
        CreateWall(-42.46, 5.924819, 39.06439, 5, 7.268002, 29.11122, 0, 137);
        CreateWall(-40.176, 5.523045, 55.21048, 0.4, 1.619911, 3.189045, 0, 138);
        CreateWall(-38.76395, 4.321394, 25.75254, 2.419907, 2.425211, 2.422911, 0, 139);
        CreateWall(-25.86095, 3.515394, 41.48711, 2.419907, 2.425211, 4.835773, 0, 140);
        CreateWall(-31.50165, 7.140826, 45.92187, 3.236599, 3.233137, 3.219515, 0, 141);
        CreateWall(-32.31604, 6.330677, 48.3438, 1.60783, 1.614568, 1.621651, 0, 142);
        CreateWall(-33.318, 4.250121, 50.35683, 0.4, 4.165757, 12.89635, 0, 143);
        CreateWall(-29.05922, 4.250121, 44.11132, 8.917554, 4.165757, 0.4053345, 0, 144);
        CreateWall(-24.24499, 6.744021, 40.68601, 0.8298302, 8.882464, 7.251068, 0, 145);
        CreateWall(-18.16362, 6.744021, 35.00214, 11.37258, 8.882464, 24.24732, 0, 146);
        CreateWall(-17.38598, 8.345907, 47.44, 7.268031, 5.678691, 1, 0, 147);
        CreateWall(-25.05, 7.125232, 19.71861, 7.251068, 8.120045, 6.440567, 1, 148);
        CreateWall(-35.55, 7.125232, 19.71861, 7.251068, 8.120045, 6.440567, 1, 149);
        CreateWall(-37.39254, 7.125231, 23.74257, 5.316154, 8.120045, 1.612665, 0, 150);
        CreateWall(-20.57564, 3.187231, 15.68, 12.98743, 8.120045, 1.612665, 1, 151);
        CreateWall(-38.3665, 5.120971, 14.08765, 9.724064, 4.111524, 4.898634, 1, 152);
        CreateWall(-43.49247, 5.120971, 8.41167, 0.5960007, 4.111524, 6.454079, 1, 153);
        CreateWall(-41.58795, 5.120971, 1.959855, 3.235893, 4.111524, 12.92029, 1, 154);
        CreateWall(-34.34674, 4.740863, 0.3402195, 4.858311, 4.87174, 9.681019, 1, 155);
        CreateWall(-30.24487, 4.740863, 2.731868, 3.448055, 4.87174, 4.779274, 1, 156);
        CreateWall(-19.33138, 5.148415, 5.109592, 21.90529, 4.056636, 6.620091, 1, 157);
        CreateWall(-8.102446, 3.298522, 11.64577, 12.11511, 7.756417, 6.451536, -1, 158);
        CreateWall(-9.72221, 0.6884941, 7.204192, 2.422421, 2.419012, 2.422384, 1, 159);
        CreateWall(-17.38029, 0.2831234, 2.711911, 3.224581, 1.60827, 1.728946, 1, 160);
        CreateWall(-19.47366, 1.283146, 5.166797, 0.9559011, 3.613672, 6.495212, 1, 161);
        CreateWall(-19.01047, 1.429199, 10.02323, 3.239193, 4.145567, 3.21852, 1, 162);
        CreateWall(-25.45899, 5.416459, -2.911342, 6.440163, 6.200087, 6.407383, 2, 163);
        CreateWall(-34.32658, 3.935917, -5.298461, 1.617161, 3.239004, 1.625077, 2, 164);
        CreateWall(-42.02054, 5.132627, -21.06406, 0.8790817, 5.646835, 33.14563, 2, 165);
        CreateWall(-41.19003, 5.970626, -28.69818, 0.7959557, 5.646835, 7.276354, 2, 166);
        CreateWall(-41.38817, 5.129626, -11.3631, 0.4163437, 5.646835, 0.7861614, 2, 167);
        CreateWall(-41.38817, 5.129626, -16.9751, 0.4163437, 5.646835, 0.7861614, 2, 168);
        CreateWall(-39.97736, 3.099399, -20.8255, 3.224247, 1.623342, 0.3831959, 2, 169);
        CreateWall(-33.71442, 3.099399, -20.83454, 2.830128, 1.623342, 0.4012718, 2, 170);
        CreateWall(-33.92458, 3.504645, -19.42433, 2.409798, 2.433834, 2.412289, 2, 171);
        CreateWall(-32.10999, 3.099732, -25.9817, 0.4169121, 1.624008, 11.07064, 2, 172);
        CreateWall(-29.48116, 3.909713, -23.45477, 1.612955, 3.243968, 1.615158, 2, 173);
        CreateWall(-40.17027, 4.314253, -31.31842, 1.213169, 2.440887, 1.210466, 2, 174);
        CreateWall(-40.78803, 4.711897, -38.37749, 1.635225, 3.236175, 1.613446, 2, 175);
        CreateWall(-37.95386, 4.711897, -39.17149, 4.044044, 3.236175, 1.613446, 2, 176);
        CreateWall(-37.14289, 5.310734, -37.17551, 2.42997, 4.433849, 2.441495, 2, 177);
        CreateWall(-29.07345, 4.917582, -33.95314, 13.76087, 5.220153, 4.064755, 2, 178);
        CreateWall(-26.675, 5.129626, -31.92304, 0.7861614, 5.646835, 0.8204193, 2, 179);
        CreateWall(-32.3, 5.129626, -31.92304, 0.7861614, 5.646835, 0.8204193, 2, 180);
        CreateWall(-40.78566, 3.90744, -21.84602, 1.629536, 1.62726, 1.619009, 2, 181);
        CreateWall(15.65053, 3.52211, -1.713665, 4.895332, 2.395253, 5.782387, 3, 182);
        CreateWall(12.46407, 3.925133, 1.150944, 1.617191, 3.201298, 1.618112, 3, 183);
        CreateWall(5.992119, 5.469345, -0.4590559, 14.66269, 6.289724, 1.618112, 3, 184);
        CreateWall(23.35082, 3.525312, 3.975177, 2.418831, 2.389922, 2.420465, 3, 185);
        CreateWall(23.75113, 6.332403, -9.739486, 1.617455, 3.222512, 1.611141, 3, 186);
        CreateWall(21.54216, 3.514502, -2.880072, 0.4025955, 2.410711, 3.235695, 3, 187);
        CreateWall(-19.39825, 3.717201, -23.05369, 2.410248, 2.821984, 2.427719, 2, 188);
        CreateWall(-17.58567, 3.108061, -23.05369, 1.205088, 1.603703, 2.427719, 2, 189);
        CreateWall(-11.74238, 1.165568, -22.24077, 1.60723, 2.26469, 1.611542, 2, 190);
        CreateWall(-10.12338, 0.5635681, -23.04477, 1.60723, 2.26469, 1.611542, 2, 191);
        CreateWall(-10.12338, 0.371568, -21.43977, 1.60723, 2.26469, 1.611542, 2, 192);
        CreateWall(-24.23902, 2.723958, -26.694, 0.8139538, 0.8524289, 0.8340797, 2, 193);
        CreateWall(-17.78772, 2.671109, -21.45288, 0.8073368, 0.7361269, 0.775835, 2, 194);
        CreateWall(32.64186, 3.912763, 11.63979, 3.213718, 3.226475, 3.216652, 6, 195);
        CreateWall(35.05, 3.102, 10.828, 1.62, 1.62, 1.62, 5, 196);
        CreateWall(23.153, 3.307, -4.994, 2.82, 2, 1, 3, 197);
        CreateWall(-20.6154, 4.318905, 9.235, 3.226804, 1.613811, 1.6, 1, 198);
        CreateWall(8.033, 2.504, 0.538, 4.05, 0.4, 1.222159, 3, 199);
        CreateWall(18.112, 2.504, 28.781, 4.05, 0.4, 1.222159, 6, 200);
        CreateWall(15.9, 2.504, 43.898, 1.222159, 0.4, 4.05, 6, 201);
        CreateWall(-21.4125, 8.321119, -26.54848, 1.607979, 0.8150377, 4.404967, 2, 202);
        CreateWall(-25.052, 2.665476, -24.29729, 0.8, 0.7450484, 0.7311573, 2, 203);
        CreateWall(51.25, -0.15, 40.724, 1.77, 4.7418, 1.703053, 5, 204);
        CreateWall(43.89105, 0.4453565, 40.36826, 1.712103, 3.551087, 0.9915719, 5, 205);
        CreateWall(56.639, 4.118, 26.56685, 1.222159, 0.4, 4.037703, 5, 206);
        CreateWall(-20.6154, 6.148234, 9.235, 3.226804, 2.025973, 1.6, 1, 207);
        CreateWall(-21.006, 6.454825, 14.67238, 0.8, 1.41279, 0.415242, 1, 208);
        CreateWall(-21.006, 6.713649, 14.14657, 0.8, 0.895143, 0.8783064, 1, 209);
        CreateWall(-2.28019, 2.288647, 25.35139, 2.052381, 6.477295, 1.62215, 4, 210);
    }
    else if (mapToLoad == TUTORIAL)
    {
        mapToSet = TUTORIAL;
        allMaps[mapToLoad].CollisionsCount = 8;
        allMaps[mapToLoad].AllWallsCollisions = malloc(allMaps[mapToLoad].CollisionsCount * sizeof(Wall));
        CreateWall(0, -1.5, 2, 22.7, 1, 22.7, 0, 0);
        CreateWall(-0.002059221, 0.227705, 1.943192, 2.450016, 2.451308, 2.462128, 0, 1);
        CreateWall(1.890654, -0.321328, 1.942942, 1.352347, 1.353242, 1.352881, 0, 2);
        CreateWall(0, -0.95, -6.720729, 22.7, 1, 5.33, 0, 3);
        CreateWall(-11.84, 3.77, 2, 1, 10, 22.7, 0, 4);
        CreateWall(11.84, 3.77, 2, 1, 10, 22.7, 0, 5);
        CreateWall(0, 3.77, -9.9, 22.7, 10, 1, 0, 6);
        CreateWall(0, 3.77, 13.785, 22.7, 10, 1, 0, 7);
    }
}

/**
 * @brief Add stairs for dust 2 map
 * Generated with the Unity project
 */
void LoadAllStairs(int mapToLoad)
{
    if (mapToLoad == DUST2)
    {
        mapToSet = DUST2;
        allMaps[mapToLoad].StairsCount = 31;
        allMaps[mapToLoad].AllStairs = malloc(allMaps[mapToLoad].StairsCount * sizeof(Stairs));
        CreateStairs(-1.257, 5.2, 8.419, 21.325, 0, 3.211, 2, 0);
        CreateStairs(-1.252, -0.85, 3.576, 6.8, 0, 0.388, 1, 1);
        CreateStairs(5.3, 6.45, 21.313, 56.32, 3.24, 3.24, 1, 2);
        CreateStairs(41.98, 45.06, 10.7, 21.311, 3.24, 3.24, 2, 3);
        CreateStairs(24.558, 37.4724, -20.03, -10.9489, 0, 3.2112, 3, 4);
        CreateStairs(42.87, 44.44, -17.4, -11.755, 3.24, 3.24, 2, 5);
        CreateStairs(50.37, 56.8304, -17.4011, -4.494, 3.237, 4.8242, 3, 6);
        CreateStairs(43.93, 51.99, -30.31, -17.403, 3.228, 6.451, 0, 7);
        CreateStairs(43.93, 51.99, 21.315, 34.231, -1.613, 3.217, 0, 8);
        CreateStairs(49.58, 52.804, 16.485, 19.704, 3.228, 4.829, 3, 9);
        CreateStairs(18.111, 21.33, -4.495, 0.33, 3.237, 5.64, 0, 10);
        CreateStairs(37.48, 43.51, -30.31, -28.293, 5.647, 6.46, 0, 11);
        CreateStairs(37.13, 38.37, -28.69, -20.22, 5.632, 5.632, 2, 12);
        CreateStairs(18.89, 24.98, -20.98, -19.1, 5.632, 5.632, 3, 13);
        CreateStairs(-17.385, -7.699999, -23.885, -10.9489, 0, 3.211, 1, 14);
        CreateStairs(-38.35, -35.131, -20.628, -19.037, 3.237, 4.026, 0, 15);
        CreateStairs(-39.974, -36.749, -6.12, -4.495998, 3.237, 4.026, 2, 16);
        CreateStairs(-34.28, -33.04, 4.909999, 13.38, 4.02, 4.02, 2, 17);
        CreateStairs(-32.48, -28.09, 15.51, 17.13, 4.02, 4.02, 3, 18);
        CreateStairs(-39.972, -23.841, 26.966, 28.46, 3.228, 4.019, 0, 19);
        CreateStairs(-39.97, -33.52, 43.904, 56.818, 3.23, 6.449, 2, 20);
        CreateStairs(-1.248, 11.659, 56.79, 66.49001, 3.227, 6.441, 1, 21);
        CreateStairs(-33.96, -32.95, 56.824, 63.264, 6.44, 6.44, 0, 22);
        CreateStairs(-40.67, -39.49, 56.824, 63.264, 6.44, 6.44, 0, 23);
        CreateStairs(-13.74, -12.56, 56.824, 63.264, 6.44, 6.44, 0, 24);
        CreateStairs(-44.813, -12.546, 63.2688, 66.496, 6.454, 7.255, 2, 25);
        CreateStairs(-17.383, -14.166, 8.419, 11.642, 0.4100001, 2.006, 2, 26);
        CreateStairs(-20.3, -17.214, 11.644, 14.868, 2.073, 4.018, 1, 27);
        CreateStairs(-20.585, -18.3, -25.084, -23.196, 6.058, 6.893, 0, 28);
        CreateStairs(-22.7, -22.23, -27.867, -26.293, 6.457, 6.843, 3, 29);
        CreateStairs(-23.845, -22.226, -26.263, -25.927, 6.052, 6.439, 0, 30);
    }
    else if (mapToLoad == TUTORIAL)
    {
        mapToSet = TUTORIAL;
        allMaps[mapToLoad].StairsCount = 1;
        allMaps[mapToLoad].AllStairs = malloc(allMaps[mapToLoad].StairsCount * sizeof(Stairs));
        CreateStairs(-11.344, 11.336, -3.7246, -3.15, -0.071, 0.471, 0, 0);
    }
}

/**
 * @brief Set bomb zone
 *
 * @param mapToLoad Map index to load (see mapEnum enum in map.h)
 */
void LoadAllBombZones(int mapToLoad)
{
    if (mapToLoad == DUST2)
    {
        // Set the number of bomb zones
        allMaps[mapToLoad].BombsTriggersCollisionsCount = 2;
        allMaps[mapToLoad].AllBombsTriggersCollisions = malloc(allMaps[mapToLoad].BombsTriggersCollisionsCount * sizeof(Site));

        int nearWaypoints0[12] = {2, 3, 9, 10, 11, 12, 13, 14, 15, 16, 17, 57};
        SetBombZone(40.8, -20.8, 5, 5, 0, 14, 12, nearWaypoints0); // A
        int nearWaypoints1[10] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 30};
        SetBombZone(-28.03, -27.07, 4.46785, 4.578236, 1, 29, 10, nearWaypoints1); // B
    }
    else if (mapToLoad == TUTORIAL)
    {
        // Set the number of bomb zones
        allMaps[mapToLoad].BombsTriggersCollisionsCount = 1;
        allMaps[mapToLoad].AllBombsTriggersCollisions = malloc(allMaps[mapToLoad].BombsTriggersCollisionsCount * sizeof(Site));

        int nearWaypoints0[14] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
        SetBombZone(-8.21, -1.59, 4, 4, 0, 0, 14, nearWaypoints0); // A
    }
}
/**
 * @brief Create a stairs
 *
 * @param xSideA
 * @param xSideB
 * @param zSideA
 * @param zSideB
 * @param startY Start y position of the stairs
 * @param endY End y position of the stairs
 * @param direction Stairs direction
 * @param index Stairs index
 */
void CreateStairs(float xSideA, float xSideB, float zSideA, float zSideB, float startY, float endY, int direction, int index)
{
    Stairs *newStairs = &allMaps[mapToSet].AllStairs[index];
    newStairs->xSideA = xSideA;
    newStairs->xSideB = xSideB;
    newStairs->zSideA = zSideA;
    newStairs->zSideB = zSideB;
    newStairs->startY = startY;
    newStairs->endY = endY;
    newStairs->direction = direction;
}

/**
 * @brief Create a Wall
 *
 * @param xPos x position (float version)
 * @param yPos y position (float version)
 * @param zPos z position (float version)
 * @param xSize x size value (float version)
 * @param ySize y size value (float version)
 * @param zSize z size value (float version)
 * @param Zone Wall zone
 * @param index Wall index
 */
void CreateWall(float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, int Zone, int index)
{
    Wall *newWall = &allMaps[mapToSet].AllWallsCollisions[index];
    // Create wall pointers
    newWall->WallModel = NE_ModelCreate(NE_Static);
    newWall->WallPhysics = NE_PhysicsCreate(NE_BoundingBox);
    newWall->WallPhysics->physicsgroupCount = 2;
    newWall->WallPhysics->physicsgroup[1] = 1;
    NE_ModelSetCoord(newWall->WallModel, xPos, yPos, zPos);               // Set wall model position
    NE_PhysicsSetModel(newWall->WallPhysics, (void *)newWall->WallModel); // Physics object and Model assigned to it
    NE_PhysicsSetSize(newWall->WallPhysics, xSize, ySize, zSize);         // Set physics size
    // Set wall position
    newWall->position.x = xPos * 8192.0;
    newWall->position.y = yPos * 8192.0;
    newWall->position.z = zPos * 8192.0;
    newWall->ZoneCollision = Zone;
    // Calculate a box from wall size values for raycasting
    newWall->WallCollisionBox.BoxXRangeA = newWall->position.x + newWall->WallPhysics->xsize;
    newWall->WallCollisionBox.BoxXRangeB = newWall->position.x - newWall->WallPhysics->xsize;
    newWall->WallCollisionBox.BoxYRangeA = newWall->position.y + newWall->WallPhysics->ysize;
    newWall->WallCollisionBox.BoxYRangeB = newWall->position.y - newWall->WallPhysics->ysize;
    newWall->WallCollisionBox.BoxZRangeA = newWall->position.z + newWall->WallPhysics->zsize;
    newWall->WallCollisionBox.BoxZRangeB = newWall->position.z - newWall->WallPhysics->zsize;

    // Disable physics
    NE_PhysicsEnable(newWall->WallPhysics, false);
}

/**
 * @brief Calculate a box from physics values for raycasting
 *
 * @param playerIndex Player index
 */
void CalculatePlayerColBox(int playerIndex)
{
    CalculatePlayerPosition(playerIndex);
    Player *player = &AllPlayers[playerIndex];

    float xSize = player->xSize;
    float ySize = player->ySize;
    float zSize = player->zSize;
    // Get min/max of the box
    player->PlayerCollisionBox.BoxXRangeA = (player->position.x + xSize) * 4096.0;
    player->PlayerCollisionBox.BoxXRangeB = (player->position.x - xSize) * 4096.0;
    player->PlayerCollisionBox.BoxYRangeA = (player->position.y + ySize) * 4096.0;
    player->PlayerCollisionBox.BoxYRangeB = (player->position.y - ySize) * 4096.0;
    player->PlayerCollisionBox.BoxZRangeA = (player->position.z + zSize) * 4096.0;
    player->PlayerCollisionBox.BoxZRangeB = (player->position.z - zSize) * 4096.0;
}

/**
 * @brief Calculate a box from physics values for raycasting
 *
 * @param position Position of the box
 * @param size Size of the box
 */
CollisionBox CalculateColBox(Vector3 position, Vector3 size)
{
    CollisionBox box;
    // Get min/max of the box
    box.BoxXRangeA = (position.x + size.x);
    box.BoxXRangeB = (position.x - size.x);
    box.BoxYRangeA = (position.y + size.y);
    box.BoxYRangeB = (position.y - size.y);
    box.BoxZRangeA = (position.z + size.z);
    box.BoxZRangeB = (position.z - size.z);
    return box;
}

/**
 * @brief Calculate a box for trigger for occlusion culling
 *
 * @param xPos x position (float version)
 * @param zPos z position (float version)
 * @param xSize x size value (float version)
 * @param zSize z size value (float version)
 * @param triggerId Trigger Id
 */
void CalculateTriggerColBox(float xPos, float zPos, float xSize, float zSize, int triggerId)
{
    CollisionBox2D *trigger = &allMaps[mapToSet].AllZones[triggerId].collisionBox;
    // Get min/max of the box
    trigger->BoxXRangeA = xPos + xSize / 2.0;
    trigger->BoxXRangeB = xPos - xSize / 2.0;
    trigger->BoxZRangeA = zPos + zSize / 2.0;
    trigger->BoxZRangeB = zPos - zSize / 2.0;
}

/**
 * @brief Calculate a box for shadows
 *
 * @param xPos x position (float version)
 * @param yPos y position (float version)
 * @param zPos z position (float version)
 * @param xSize x size value (float version)
 * @param ySize y size value (float version)
 * @param zSize z size value (float version)
 * @param triggerId Trigger Id
 */
void CalculateShadowColBox(float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, int collisionBoxIndex)
{
    CollisionBox *collisionBox = &allMaps[mapToSet].AllShadowCollisionBox[collisionBoxIndex];
    // Get min/max of the box
    collisionBox->BoxXRangeA = xPos + xSize / 2.0;
    collisionBox->BoxXRangeB = xPos - xSize / 2.0;
    collisionBox->BoxYRangeA = yPos + ySize / 2.0;
    collisionBox->BoxYRangeB = yPos - ySize / 2.0;
    collisionBox->BoxZRangeA = zPos + zSize / 2.0;
    collisionBox->BoxZRangeB = zPos - zSize / 2.0;
}

/**
 * @brief Set bomb zone of the map
 *
 * @param xPos x position (float version)
 * @param zPos z position (float version)
 * @param xSize x size value (float version)
 * @param zSize z size value (float version)
 * @param triggerId Trigger Id
 * @param waypoint
 */
void SetBombZone(float xPos, float zPos, float xSize, float zSize, int triggerId, int waypoint, int nearWaypointCount, int nearWaypoint[nearWaypointCount])
{
    Site *site = &allMaps[mapToSet].AllBombsTriggersCollisions[triggerId];
    site->collisionBox.BoxXRangeA = xPos + xSize / 2.0;
    site->collisionBox.BoxXRangeB = xPos - xSize / 2.0;
    site->collisionBox.BoxZRangeA = zPos + zSize / 2.0;
    site->collisionBox.BoxZRangeB = zPos - zSize / 2.0;
    site->waypoint = waypoint;

    allMaps[mapToSet].AllBombsTriggersCollisions[triggerId].nearWaypoints = (int *)malloc(nearWaypointCount * sizeof(int));
    allMaps[mapToSet].AllBombsTriggersCollisions[triggerId].nearWaypointCount = nearWaypointCount;

    for (int i = 0; i < nearWaypointCount; i++)
    {
        allMaps[mapToSet].AllBombsTriggersCollisions[triggerId].nearWaypoints[i] = nearWaypoint[i];
    }
}

/**
 * @brief Set bomb defuse zone with bomb position
 *
 * @param xPos x position (float version)
 * @param zPos z position (float version)
 * @param defuseZoneCollisions CollisionBox2D
 */
void SetBombDefuseZone(float xPos, float zPos, CollisionBox2D *defuseZoneCollisions)
{
    defuseZoneCollisions->BoxXRangeA = xPos + 1;
    defuseZoneCollisions->BoxXRangeB = xPos - 1;
    defuseZoneCollisions->BoxZRangeA = zPos + 1;
    defuseZoneCollisions->BoxZRangeB = zPos - 1;
}

/**
 * @brief Set bomb defuse zone with bomb position
 *
 * @param xPos x position (float version)
 * @param zPos z position (float version)
 * @param defuseZoneCollisions CollisionBox2D
 */
void SetCollisionBox(float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, CollisionBoxF *collisionBox)
{
    collisionBox->BoxXRangeA = xPos + xSize;
    collisionBox->BoxXRangeB = xPos - xSize;
    collisionBox->BoxYRangeA = yPos + ySize;
    collisionBox->BoxYRangeB = yPos - ySize;
    collisionBox->BoxZRangeA = zPos + zSize;
    collisionBox->BoxZRangeB = zPos - zSize;
}

/**
 * @brief Set bomb taking zone with bomb position when the bomb is dropped
 *
 * @param xPos x position (float version)
 * @param zPos z position (float version)
 * @param defuseZoneCollisions CollisionBox2D
 */
void SetBombTakingZone(float xPos, float zPos, CollisionBox2D *defuseZoneCollisions)
{
    defuseZoneCollisions->BoxXRangeA = xPos + 0.8;
    defuseZoneCollisions->BoxXRangeB = xPos - 0.8;
    defuseZoneCollisions->BoxZRangeA = zPos + 0.8;
    defuseZoneCollisions->BoxZRangeB = zPos - 0.8;
}

/**
 * @brief Check in which zone the player is
 *
 * @param playerIndex player to check index
 */
void checkPlayerOcclusionZone(int playerIndex)
{
    // If the player is the same zone, do nothing
    if (AllPlayers[playerIndex].CurrentOcclusionZone < allMaps[currentMap].zonesCount && AllPlayers[playerIndex].position.x <= allMaps[currentMap].AllZones[AllPlayers[playerIndex].CurrentOcclusionZone].collisionBox.BoxXRangeA && AllPlayers[playerIndex].position.x >= allMaps[currentMap].AllZones[AllPlayers[playerIndex].CurrentOcclusionZone].collisionBox.BoxXRangeB && AllPlayers[playerIndex].position.z <= allMaps[currentMap].AllZones[AllPlayers[playerIndex].CurrentOcclusionZone].collisionBox.BoxZRangeA && AllPlayers[playerIndex].position.z >= allMaps[currentMap].AllZones[AllPlayers[playerIndex].CurrentOcclusionZone].collisionBox.BoxZRangeB)
    {
    }
    else
    {
        // Or find the new zone

        // Check occlusion zones
        for (int TriggersIndex = 0; TriggersIndex < allMaps[currentMap].zonesCount; TriggersIndex++)
        {
            if (AllPlayers[playerIndex].position.x <= allMaps[currentMap].AllZones[TriggersIndex].collisionBox.BoxXRangeA && AllPlayers[playerIndex].position.x >= allMaps[currentMap].AllZones[TriggersIndex].collisionBox.BoxXRangeB && AllPlayers[playerIndex].position.z <= allMaps[currentMap].AllZones[TriggersIndex].collisionBox.BoxZRangeA && AllPlayers[playerIndex].position.z >= allMaps[currentMap].AllZones[TriggersIndex].collisionBox.BoxZRangeB)
            {
                AllPlayers[playerIndex].CurrentOcclusionZone = TriggersIndex;
                break;
            }
        }
    }
}

/**
 * @brief Check if player is in a shadow zone
 *
 * @param playerIndex player to check index
 */
void checkPlayerShadow(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    float correctedPlayerYValue = player->position.y + player->ySize / 2.0;
    // If the player is the same zone, do nothing
    if (player->currentShadowCollBox < allMaps[currentMap].shadowCollisionBoxCount && player->position.x <= allMaps[currentMap].AllShadowCollisionBox[player->currentShadowCollBox].BoxXRangeA && player->position.x >= allMaps[currentMap].AllShadowCollisionBox[player->currentShadowCollBox].BoxXRangeB && correctedPlayerYValue <= allMaps[currentMap].AllShadowCollisionBox[player->currentShadowCollBox].BoxYRangeA && correctedPlayerYValue >= allMaps[currentMap].AllShadowCollisionBox[player->currentShadowCollBox].BoxYRangeB && player->position.z <= allMaps[currentMap].AllShadowCollisionBox[player->currentShadowCollBox].BoxZRangeA && player->position.z >= allMaps[currentMap].AllShadowCollisionBox[player->currentShadowCollBox].BoxZRangeB)
    {
        player->inShadow = true;
    }
    else
    {
        // Or find the new zone
        player->inShadow = false;
        //  Check occlusion zones
        for (int shadowIndex = 0; shadowIndex < allMaps[currentMap].shadowCollisionBoxCount; shadowIndex++)
        {
            if (player->position.x <= allMaps[currentMap].AllShadowCollisionBox[shadowIndex].BoxXRangeA && player->position.x >= allMaps[currentMap].AllShadowCollisionBox[shadowIndex].BoxXRangeB && correctedPlayerYValue <= allMaps[currentMap].AllShadowCollisionBox[shadowIndex].BoxYRangeA && correctedPlayerYValue >= allMaps[currentMap].AllShadowCollisionBox[shadowIndex].BoxYRangeB && player->position.z <= allMaps[currentMap].AllShadowCollisionBox[shadowIndex].BoxZRangeA && player->position.z >= allMaps[currentMap].AllShadowCollisionBox[shadowIndex].BoxZRangeB)
            {
                player->inShadow = true;
                player->currentShadowCollBox = shadowIndex;
                return;
            }
        }
    }
}

/**
 * @brief Check where the bomb is
 *
 * @return int Waypoint index where the bomb is
 */
int checkBombZoneWaypoint()
{
    for (int TriggersIndex = 0; TriggersIndex < allMaps[currentMap].BombsTriggersCollisionsCount; TriggersIndex++)
    {
        Site *site = &allMaps[currentMap].AllBombsTriggersCollisions[TriggersIndex];
        if (localPlayer->position.x <= site->collisionBox.BoxXRangeA && localPlayer->position.x >= site->collisionBox.BoxXRangeB && localPlayer->position.z <= site->collisionBox.BoxZRangeA && localPlayer->position.z >= site->collisionBox.BoxZRangeB)
        {
            return site->waypoint;
        }
    }
    return -1;
}

/**
 * @brief Check all zones (triggers for occlusion culling, bomb pland and defuse trigger)
 *
 * @param bombDefuseZone
 * @param CanPutBomb
 * @param canDefuseBomb
 */
void CheckZones(CollisionBox2D bombDefuseZone, bool *CanPutBomb, bool *canDefuseBomb)
{
    // Check players occlusion zones and shadows zones
    for (int i = 0; i < MaxPlayer; i++)
    {
        if (AllPlayers[i].Id != UNUSED)
        {
            checkPlayerOcclusionZone(i);
            checkPlayerShadow(i);
        }
    }

    if (!bombDropped)
    {
        // Check bomb zones
        for (int TriggersIndex = 0; TriggersIndex < allMaps[currentMap].BombsTriggersCollisionsCount; TriggersIndex++)
        {
            Site *site = &allMaps[currentMap].AllBombsTriggersCollisions[TriggersIndex];
            if (localPlayer->position.x <= site->collisionBox.BoxXRangeA && localPlayer->position.x >= site->collisionBox.BoxXRangeB && localPlayer->position.z <= site->collisionBox.BoxZRangeA && localPlayer->position.z >= site->collisionBox.BoxZRangeB)
            {
                *CanPutBomb = true;
                break;
            }
        }

        if (localPlayer->position.x <= bombDefuseZone.BoxXRangeA && localPlayer->position.x >= bombDefuseZone.BoxXRangeB && localPlayer->position.z <= bombDefuseZone.BoxZRangeA && localPlayer->position.z >= bombDefuseZone.BoxZRangeB)
            *canDefuseBomb = true;
    }
    else
    {
        *canDefuseBomb = false;
        *CanPutBomb = false;
    }
}

/**
 * @brief Check if players is on the dropped bomb to take it
 *
 * @param bombDefuseZone
 */
void checkTakingBombZone(CollisionBox2D bombDefuseZone)
{
    if (!bombDropped)
        return;

    for (int i = 0; i < MaxPlayer; i++)
    {
        // Check only for the local player in online mode
        if (i != 0 && Connection != OFFLINE)
            break;

        Player *player = &AllPlayers[i];
        if (player->IsDead || player->Id == UNUSED || player->Team == COUNTERTERRORISTS)
            continue;

        // If the player is on the bomb
        if (player->position.x <= bombDefuseZone.BoxXRangeA && player->position.x >= bombDefuseZone.BoxXRangeB && player->position.z <= bombDefuseZone.BoxZRangeA && player->position.z >= bombDefuseZone.BoxZRangeB)
        {
            // Add the bomb in the player's inventory
            player->haveBomb = true;
            SetGunInInventoryForNonLocalPlayer(i, 28, 8);
            bombDropped = false;

            // Send the message to the server
            SendGetDroppedBomb = true;
            // Force player to send position
            SendPosition = true;
            SendPositionData = 0;

            // Disable bomb finding for all other player
            for (int playerIndex2 = 0; playerIndex2 < MaxPlayer; playerIndex2++)
            {
                Player *player2 = &AllPlayers[playerIndex2];
                player2->searchForDroppedBomb = false;
            }
            break;
        }
    }
}

/**
 * @brief Check if local player is in the shop zone
 *
 */
void checkShopZone()
{
    if (localPlayer->position.x <= shopZone.BoxXRangeA && localPlayer->position.x >= shopZone.BoxXRangeB && localPlayer->position.y <= shopZone.BoxYRangeA && localPlayer->position.y >= shopZone.BoxYRangeB && localPlayer->position.z <= shopZone.BoxZRangeA && localPlayer->position.z >= shopZone.BoxZRangeB)
    {
        isInShopZone = true;
    }
    else if (isInShopZone)
    {
        isInShopZone = false;
        if (currentMenu == SHOP || currentMenu == SHOPCATEGORIES)
        {
            initGameMenu();
        }
    }
}

// Last stairs where the player was
int LastStairs = 0;

/**
 * @brief check if local player is on a ramp/stairs
 *
 * @param canJump
 * @param isInDownStairs
 */
void CheckStairs(int *canJump, bool *isInDownStairs)
{
    bool firstScan = true;
    // To optimize, start scan on old stairs to avoid checking all other stairs
    for (int i = LastStairs; i < allMaps[currentMap].StairsCount; i++)
    {
        Stairs *stairs = &allMaps[currentMap].AllStairs[i];
        // If the localplayer is on a stairs
        if (localPlayer->position.z >= stairs->zSideA && localPlayer->position.z <= stairs->zSideB && localPlayer->position.x >= stairs->xSideA && localPlayer->position.x <= stairs->xSideB)
        {
            // Get the player y position
            float yVal = 0;
            if (stairs->direction == 0)
                yVal = map(localPlayer->position.z, stairs->zSideA, stairs->zSideB, stairs->endY, stairs->startY);
            else if (stairs->direction == 1)
                yVal = map(localPlayer->position.x, stairs->xSideA, stairs->xSideB, stairs->endY, stairs->startY);
            else if (stairs->direction == 2)
                yVal = map(localPlayer->position.z, stairs->zSideA, stairs->zSideB, stairs->startY, stairs->endY);
            else
                yVal = map(localPlayer->position.x, stairs->xSideA, stairs->xSideB, stairs->startY, stairs->endY);

            if (localPlayer->position.y < yVal && yVal - localPlayer->position.y < 3)
            {
                // Stop player Y movements
                if (localPlayer->PlayerPhysic->yspeed < 100)
                    localPlayer->PlayerPhysic->yspeed = 0;

                // Change the player position
                localPlayer->position.y = yVal;
                NE_ModelSetCoord(localPlayer->PlayerModel, localPlayer->position.x, localPlayer->position.y, localPlayer->position.z);
                // Player will be able to jump because he is touching the ground
                *canJump = 10;
            }
            if (localPlayer->position.y == yVal)
                *isInDownStairs = true;

            LastStairs = i;
            break;
        }
        // If there is no stairs found on the first scan, restard a scan and check all stairs
        if (firstScan)
        {
            firstScan = false;
            LastStairs = 0;
            i = 0;
        }
    }
}

/**
 * @brief Check if a player is in a zone for occlusion culling
 *
 * @param zone Zone data
 * @param posx x player position (Int version)
 * @param posz x player position (Int version)
 * @return true
 * @return false
 */
bool checkZoneForOcclusion(OcclusionZone *zone, int posx, int posz)
{
    if (zone->anglesInt[0].x >= posx && zone->anglesInt[2].x <= posx)
    {
        if (zone->anglesInt[0].y >= posz && zone->anglesInt[2].y <= posz)
        {
            return true;
        }
    }
    return false;
}

/**
 * @brief Check if grenade is on a ramp
 *
 * @param grenade Grenade data
 * @return true
 * @return false
 */
bool CheckStairsForGrenades(PhysicalGrenade *grenade)
{
    bool firstScan = true;
    for (int i = grenade->LastStairs; i < allMaps[currentMap].StairsCount; i++)
    {
        float xpos = grenade->Model->x / 4096.0;
        float ypos = grenade->Model->y / 4096.0;
        float zpos = grenade->Model->z / 4096.0;
        Stairs *stairs = &allMaps[currentMap].AllStairs[i];
        // If the grenade is on a stairs
        if (zpos >= stairs->zSideA && zpos <= stairs->zSideB && xpos >= stairs->xSideA && xpos <= stairs->xSideB)
        {
            // Get the grenade y position
            float yVal = 0;
            if (stairs->direction == 0)
            {
                yVal = map(zpos, stairs->zSideA, stairs->zSideB, stairs->endY, stairs->startY);
            }
            else if (stairs->direction == 1)
            {
                yVal = map(xpos, stairs->xSideA, stairs->xSideB, stairs->endY, stairs->startY);
            }
            else if (stairs->direction == 2)
            {
                yVal = map(zpos, stairs->zSideA, stairs->zSideB, stairs->startY, stairs->endY);
            }
            else
            {
                yVal = map(xpos, stairs->xSideA, stairs->xSideB, stairs->startY, stairs->endY);
            }

            if (ypos < yVal && yVal - ypos < 3)
            {
                // Stop player Y movements
                if (grenade->Physic->yspeed < 100)
                    grenade->Physic->yspeed = 0;

                // Change the grenade position
                NE_ModelSetCoord(grenade->Model, xpos, yVal - 0.6, zpos);

                if (stairs->startY != stairs->endY)
                {
                    // Make the grenade roll to the bottom of the ramp
                    if (stairs->direction == 0)
                    {
                        grenade->Physic->zspeed += 15;
                    }
                    else if (stairs->direction == 1)
                    {
                        grenade->Physic->xspeed += 15;
                    }
                    else if (stairs->direction == 2)
                    {
                        grenade->Physic->zspeed -= 15;
                    }
                    else
                    {
                        grenade->Physic->xspeed -= 15;
                    }
                }
            }
            grenade->LastStairs = i;
            return true;
        }
        // If there is no stairs found on the first scan, restard a scan and check all stairs
        if (firstScan)
        {
            firstScan = false;
            grenade->LastStairs = 0;
            i = 0;
        }
    }
    return false;
}

// Optimized Min function
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
// Optimized Max function
#define MAX(a, b) (((a) > (b)) ? (a) : (b))

/**
 * @brief Get the distance bewteen the start position and the hitted object
 *
 * @param corner1 Positon of the bottom left corner of the object to hit
 * @param corner2 Positon of the top right corner of the object to hit
 * @param dirfrac Direction
 * @param startPosition Start position of the raycast
 * @param t Distance found
 * @return Object hitted? True : Yes, False : no
 */
bool getHitDistance(Vector3Int corner1, Vector3Int corner2, Vector3 dirfrac, Vector3Int startPosition, float *t)
{
    int t1 = (corner1.x - startPosition.x) * dirfrac.x;
    int t2 = (corner2.x - startPosition.x) * dirfrac.x;
    int t3 = (corner1.y - startPosition.y) * dirfrac.y;
    int t4 = (corner2.y - startPosition.y) * dirfrac.y;
    int t5 = (corner1.z - startPosition.z) * dirfrac.z;
    int t6 = (corner2.z - startPosition.z) * dirfrac.z;

    int tmin = MAX(MAX(MIN(t1, t2), MIN(t3, t4)), MIN(t5, t6));
    int tmax = MIN(MIN(MAX(t1, t2), MAX(t3, t4)), MAX(t5, t6));

    // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us, if tmin > tmax, ray doesn't intersect AABB
    if (tmax < 0 || tmin > tmax)
    {
    }
    else
    {
        if (*t > tmin)
        {
            *t = tmin;
            return true;
        }
    }
    return false;
}

/**
 * @brief Raycast function
 *
 * @param p1x
 * @param p1y
 * @param p2x
 * @param p2y
 * @param p3x
 * @param p3y
 * @return float
 */
float sign(float p1x, float p1y, float p2x, float p2y, float p3x, float p3y)
{
    return (p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y);
}

/**
 * @brief Check if a point is in a 2D triangle
 *
 * @param px x position (float position) of the point to check
 * @param py y position (float position) of the point to check
 * @param p1x x position (float version) of the corner 1 of the triangle
 * @param p1y y position (float version) of the corner 1 of the triangle
 * @param p2x x position (float version) of the corner 2 of the triangle
 * @param p2y y position (float version) of the corner 2 of the triangle
 * @param p3x x position (float version) of the corner 3 of the triangle
 * @param p3y y position (float version) of the corner 3 of the triangle
 * @return is the point in the triangle?
 */
bool PointInTriangle(float px, float py, float p1x, float p1y, float p2x, float p2y, float p3x, float p3y)
{
    float d1, d2, d3;
    bool has_neg, has_pos;

    d1 = sign(px, py, p1x, p1y, p2x, p2y);
    d2 = sign(px, py, p2x, p2y, p3x, p3y);
    d3 = sign(px, py, p3x, p3y, p1x, p1y);

    has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(has_neg && has_pos);
}

/**
 * @brief  Raycast function int version
 *
 * @param p1x
 * @param p1y
 * @param p2x
 * @param p2y
 * @param p3x
 * @param p3y
 * @return int
 */
int signInt(int p1x, int p1y, int p2x, int p2y, int p3x, int p3y)
{
    return (p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y);
}

/**
 * @brief Check if a point is in a 2D triangle (Int version, better performance)
 *
 * @param px x position (int position) of the point to check
 * @param py y position (int position) of the point to check
 * @param p1x x position (int version) of the corner 1 of the triangle
 * @param p1y y position (int version) of the corner 1 of the triangle
 * @param p2x x position (int version) of the corner 2 of the triangle
 * @param p2y y position (int version) of the corner 2 of the triangle
 * @param p3x x position (int version) of the corner 3 of the triangle
 * @param p3y y position (int version) of the corner 3 of the triangle
 * @return is the point in the triangle?
 */
bool PointInTriangleInt(int px, int py, int p1x, int p1y, int p2x, int p2y, int p3x, int p3y)
{
    int d1, d2, d3;
    bool has_neg, has_pos;

    d1 = sign(px, py, p1x, p1y, p2x, p2y);
    d2 = sign(px, py, p2x, p2y, p3x, p3y);
    d3 = sign(px, py, p3x, p3y, p1x, p1y);

    has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(has_neg && has_pos);
}
```

`Counter-Strike-nds/source/collisions/collisions.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef COLLISION_H_ /* Include guard */
#define COLLISION_H_
#include "../main.h"

extern PhysicalGrenade *grenades[GrenadeCount];
extern int LastStairs;

void LoadAllCollisions(int mapToLoad); /**/
void LoadAllStairs(int mapToLoad);     /**/
void CalculatePlayerColBox(int PlayerId);
void CalculateTriggerColBox(float xPos, float zPos, float xSize, float zSize, int TriggerId);
void CalculateShadowColBox(float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, int collisionBoxIndex);
void SetBombZone(float xPos, float zPos, float xSize, float zSize, int TriggerId, int waypoint, int nearWaypointCount, int nearWaypoint[nearWaypointCount]);
void SetBombDefuseZone(float xPos, float zPos, CollisionBox2D *DefuseZoneCollisions);
void SetBombTakingZone(float xPos, float zPos, CollisionBox2D *DefuseZoneCollisions);
void checkTakingBombZone(CollisionBox2D bombDefuseZone);
void LoadMap(int mapToLoad);
void LoadAllBombZones(int mapToLoad);
void loadMapModels(int mapToLoad);
void UnLoadMap(int mapToUnload);
CollisionBox CalculateColBox(Vector3 position, Vector3 size);

void CheckZones(CollisionBox2D bombDefuseZone, bool *CanPutBomb, bool *canDefuseBomb);
void getValuesForRaycast(Vector3Int StartPosition, Vector3Int EndPosition, float *x, float *y, float *z);
int checkBombZoneWaypoint();
void checkPlayerOcclusionZone(int playerIndex);
void CheckStairs(int *CanJump, bool *isInDownStairs);
void CreateStairs(float xSideA, float xSideB, float zSideA, float zSideB, float startY, float endY, int direction, int index);
void CreateWall(float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, int Zone, int index);
void SetPlayerForCollisions();
bool CheckStairsForGrenades(PhysicalGrenade *grenade);
void CalculateAllTriggerColBoxs(int mapToLoad);
bool getHitDistance(Vector3Int corner1, Vector3Int corner2, Vector3 dirfrac, Vector3Int startPosition, float *t);
bool PointInTriangle(float px, float py, float p1x, float p1y, float p2x, float p2y, float p3x, float p3y);
float sign(float p1x, float p1y, float p2x, float p2y, float p3x, float p3y);
bool checkZoneForOcclusion(OcclusionZone *zone, int posx, int posz);
int signInt(int p1x, int p1y, int p2x, int p2y, int p3x, int p3y);
bool PointInTriangleInt(int px, int py, int p1x, int p1y, int p2x, int p2y, int p3x, int p3y);
void checkShopZone();
void SetCollisionBox(float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, CollisionBoxF *collisionBox);

#endif // COLLISION_H_
```

`Counter-Strike-nds/source/collisions/raycast.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)
#include "raycast.h"
#include "collisions.h"
#include "network.h"
#include "ai.h"
#include "gun.h"
#include "sounds.h"
#include "movements.h"
#include "map.h"
#include "party.h"
#include "player.h"

/**
 * @brief Prepare a raycast for Ai, store values for the incomming raycast call
 *
 * @param fromPlayerIndex player index who is making the raycast
 * @param toPlayerIndex player index to shoot
 * @param checkVisibility true : just check if player to shoot is visible, false : apply damage to player if he is visible
 */
void prepareAiRaycast(int fromPlayerIndex, int toPlayerIndex, bool checkVisibility)
{
    Player *shooterPlayer = &AllPlayers[fromPlayerIndex];
    Player *targetPlayer = &AllPlayers[toPlayerIndex];

    // Get distance between shooter and target players
    float distance2D = sqrtf(powf(targetPlayer->PlayerModel->x - shooterPlayer->PlayerModel->x, 2.0) + powf(targetPlayer->PlayerModel->z - shooterPlayer->PlayerModel->z, 2.0));
    // Get shoot direction
    Vector3 Direction;
    Direction.x = targetPlayer->PlayerModel->x - shooterPlayer->PlayerModel->x;
    Direction.y = targetPlayer->PlayerModel->y - (shooterPlayer->PlayerModel->y + CameraOffsetYMultiplied);
    Direction.z = targetPlayer->PlayerModel->z - shooterPlayer->PlayerModel->z;

    float tempAngle = atan2f(Direction.x, Direction.z) * 512.0 / (M_TWOPI) + 256.0;
    float CameraAngleToGrenadeDirection = atan2f(distance2D, Direction.y) * 512.0 / (M_TWOPI); // Change var name

    float x2, y2, z2;
    // Is the gun is a shotgun, reduce accuracy
    if (getPlayerCurrentGun(shooterPlayer).bulletCountPerShoot != 1 && !checkVisibility)
    {
        float xOffset = ((rand() % 100) - 50) / 3.0;
        float yOffset2 = ((rand() % 100) - 50) / 3.0;
        UpdateLookRotationAI(CameraAngleToGrenadeDirection + yOffset2, tempAngle + xOffset, &x2, &y2, &z2);
    }
    else
    {
        UpdateLookRotationAI(CameraAngleToGrenadeDirection, tempAngle, &x2, &y2, &z2);
    }

    if (!checkVisibility)
    {
        // Reduce accuracy
        // Lower accuracy if target is moving
        // And lower accuracy if shooter is flahsed
        int coef = 1;
        if (shooterPlayer->flashed)
            coef = 3;

        if ((targetPlayer->isAi && targetPlayer->target != NO_PLAYER) || (!targetPlayer->isAi && targetPlayer->PlayerPhysic->xspeed + targetPlayer->PlayerPhysic->yspeed + targetPlayer->PlayerPhysic->zspeed == 0))
        {
            // Better accuracy if target is not moving
            x2 += ((rand() % 150) - 75) / 1300.0 * coef * (1 - getPlayerCurrentGun(shooterPlayer).inaccuracyReductionForBot);
            y2 += ((rand() % 220) - 110) / 1300.0 * coef * (1 - getPlayerCurrentGun(shooterPlayer).inaccuracyReductionForBot);
            z2 += ((rand() % 150) - 75) / 1300.0 * coef * (1 - getPlayerCurrentGun(shooterPlayer).inaccuracyReductionForBot);
        }
        else
        {
            x2 += ((rand() % 150) - 75) / 700.0 * coef * (1 - getPlayerCurrentGun(shooterPlayer).inaccuracyReductionForBot);
            y2 += ((rand() % 220) - 110) / 700.0 * coef * (1 - getPlayerCurrentGun(shooterPlayer).inaccuracyReductionForBot);
            z2 += ((rand() % 150) - 75) / 700.0 * coef * (1 - getPlayerCurrentGun(shooterPlayer).inaccuracyReductionForBot);
        }
    }

    CalculatePlayerPosition(fromPlayerIndex);
    setRaycastValues(shooterPlayer, x2, y2, z2);

    shooterPlayer->justCheking = checkVisibility;
}

/**
 * @brief Get camera angles value to do a raycast between the start position and the end position
 *
 * @param StartPosition Start position of the raycast
 * @param EndPosition End position of the raycast
 * @param x out : x angle
 * @param y out : y angle
 * @param z out : z angle
 */
void getValuesForRaycast(Vector3Int StartPosition, Vector3Int EndPosition, float *x, float *y, float *z)
{
    // Get distance between shooter and target players
    float distance2D = sqrtf(powf(EndPosition.x - StartPosition.x, 2.0) + powf(EndPosition.z - StartPosition.z, 2.0));
    // Get shoot direction
    Vector3 Direction;
    Direction.x = EndPosition.x - StartPosition.x;
    Direction.y = EndPosition.y - StartPosition.y;
    Direction.z = EndPosition.z - StartPosition.z;

    float tempAngle = atan2f(Direction.x, Direction.z) * 512.0 / (M_TWOPI) + 256.0; // TODO Change var name
    float CameraAngleDirection = atan2f(distance2D, Direction.y) * 512.0 / (M_TWOPI);

    UpdateLookRotationAI(CameraAngleDirection, tempAngle, x, y, z);
}

/**
 * @brief Set raycast values
 *
 * @param shooterPlayer
 * @param xRot x rotation
 * @param yRot y rotation
 * @param zRot z rotation
 */
void setRaycastValues(Player *shooterPlayer, float xRot, float yRot, float zRot)
{
    shooterPlayer->startRaycastPosition.x = shooterPlayer->position.x;
    shooterPlayer->startRaycastPosition.y = shooterPlayer->position.y;
    shooterPlayer->startRaycastPosition.z = shooterPlayer->position.z;

    shooterPlayer->startRaycastRotation.x = xRot;
    shooterPlayer->startRaycastRotation.y = yRot;
    shooterPlayer->startRaycastRotation.z = zRot;
    shooterPlayer->startGunIdRaycast = getPlayerCurrentGunIndex(shooterPlayer);
}

/**
 * @brief Make a raycast from a shooter player
 *
 * @param playerIndex index of the shooter
 * @param distance distance of the hit (output)
 * @return int Index of player hitted
 */
int Raycast(int playerIndex, int currentShootIndex, float *distance)
{
    Player *shooterPlayer = &AllPlayers[playerIndex];

    shooterPlayer->IsHeadShot[currentShootIndex] = false;
    shooterPlayer->IsLegShot[currentShootIndex] = false;
    int HitPlayerIndex = NO_PLAYER;

    // Get an array of all walls to test
    int WallCountToTest = 0;
    int AllWallsToCheck[wallCount];
    for (int i2 = 0; i2 < allMaps[currentMap].CollisionsCount; i2++)
    {
        // If the wall raycast is not affecting all zones:
        if (getMapWalls()[i2].ZoneCollision != -1)
        {
            for (int i3 = 0; i3 < allMaps[currentMap].AllZones[shooterPlayer->CurrentOcclusionZone].ZoneCount; i3++)
            {
                // If the wall is in the visible zone
                if (allMaps[currentMap].AllZones[shooterPlayer->CurrentOcclusionZone].visibleMapPart[i3] == getMapWalls()[i2].ZoneCollision)
                {
                    // Add the wall to the array
                    AllWallsToCheck[WallCountToTest] = i2;
                    WallCountToTest++;
                    break;
                }
            }
        }
        else
        {
            // Add the wall to the array
            AllWallsToCheck[WallCountToTest] = i2;
            WallCountToTest++;
        }
    }

    // Check who is the nearest object, a wall or a player?

    float t = 99999 * 8192;
    float tPlayer = 99999 * 10000;
    int nearestWallIndex = NO_PLAYER;
    int nearestPlayerIndex = NO_PLAYER;

    // Get shoot direction
    Vector3 dirfrac;
    dirfrac.x = 1.0f / shooterPlayer->startRaycastRotation.x;
    dirfrac.y = 1.0f / shooterPlayer->startRaycastRotation.y;
    dirfrac.z = 1.0f / shooterPlayer->startRaycastRotation.z;

    // Get int version * 2 of the start position for wall checking (I have no idea why I need to multiply this by 2 lol (8192 = 4096*2))
    Vector3Int startPosition;
    startPosition.x = shooterPlayer->startRaycastPosition.x * 8192;
    startPosition.y = (shooterPlayer->startRaycastPosition.y + CameraOffsetY) * 8192;
    startPosition.z = shooterPlayer->startRaycastPosition.z * 8192;

    for (int wallIndex = 0; wallIndex < WallCountToTest; wallIndex++)
    {
        // Get both opposite corners of the wall
        Vector3Int corner1;
        Vector3Int corner2;

        int WallIndex = AllWallsToCheck[wallIndex];
        corner1.x = getMapWalls()[WallIndex].WallCollisionBox.BoxXRangeA;
        corner1.y = getMapWalls()[WallIndex].WallCollisionBox.BoxYRangeA;
        corner1.z = getMapWalls()[WallIndex].WallCollisionBox.BoxZRangeA;

        corner2.x = getMapWalls()[WallIndex].WallCollisionBox.BoxXRangeB;
        corner2.y = getMapWalls()[WallIndex].WallCollisionBox.BoxYRangeB;
        corner2.z = getMapWalls()[WallIndex].WallCollisionBox.BoxZRangeB;
        // check if this hitted wall is nearest than the current found nearest wall
        float newWallDistance = t;
        if (getHitDistance(corner1, corner2, dirfrac, startPosition, &newWallDistance))
        {
            if (newWallDistance < t)
            {
                t = newWallDistance;
                nearestWallIndex = WallIndex;
            }
        }
    }

    // ScanForGrenade

    // Get int version of the start position for player checking
    startPosition.x = shooterPlayer->startRaycastPosition.x * 4096;
    startPosition.y = (shooterPlayer->startRaycastPosition.y + CameraOffsetY) * 4096;
    startPosition.z = shooterPlayer->startRaycastPosition.z * 4096;
    if (shooterPlayer->ScanForGrenade != EMPTY)
    {
        if (grenades[shooterPlayer->ScanForGrenade] != NULL)
        {
            // debugValue3 = 1;
            Vector3 grenadePos;
            grenadePos.x = grenades[shooterPlayer->ScanForGrenade]->Model->x;
            grenadePos.y = grenades[shooterPlayer->ScanForGrenade]->Model->y;
            grenadePos.z = grenades[shooterPlayer->ScanForGrenade]->Model->z;
            Vector3 grenadeSize;
            grenadeSize.x = grenades[shooterPlayer->ScanForGrenade]->Physic->xsize;
            grenadeSize.y = grenades[shooterPlayer->ScanForGrenade]->Physic->ysize;
            grenadeSize.z = grenades[shooterPlayer->ScanForGrenade]->Physic->zsize;

            CollisionBox box = CalculateColBox(grenadePos, grenadeSize);

            //  Get both opposite corners of the wall
            Vector3Int corner1;
            Vector3Int corner2;

            corner1.x = box.BoxXRangeA;
            corner1.y = box.BoxYRangeA;
            corner1.z = box.BoxZRangeA;

            corner2.x = box.BoxXRangeB;
            corner2.y = box.BoxYRangeB;
            corner2.z = box.BoxZRangeB;

            // check if this hitted wall is nearest than the current found nearest wall
            float newPlayerDistance = tPlayer;
            if (getHitDistance(corner1, corner2, dirfrac, startPosition, &newPlayerDistance))
            {
                if (newPlayerDistance < tPlayer)
                {
                    tPlayer = newPlayerDistance;
                    // nearestWallIndex = NO_PLAYER;
                    nearestPlayerIndex = shooterPlayer->ScanForGrenade;
                }
            }
        }
    }
    else
    {
        for (int PlayerIndex = 0; PlayerIndex < MaxPlayer; PlayerIndex++)
        {
            Player *testedPlayer = &AllPlayers[PlayerIndex];

            if (testedPlayer->Id != UNUSED && PlayerIndex != playerIndex && !testedPlayer->IsDead)
            {
                // Calculate for each player the collision box
                CalculatePlayerColBox(PlayerIndex);

                // Get both opposite corners of the player
                Vector3Int corner1;
                Vector3Int corner2;
                corner1.x = testedPlayer->PlayerCollisionBox.BoxXRangeA;
                corner1.y = testedPlayer->PlayerCollisionBox.BoxYRangeA;
                corner1.z = testedPlayer->PlayerCollisionBox.BoxZRangeA;

                corner2.x = testedPlayer->PlayerCollisionBox.BoxXRangeB;
                corner2.y = testedPlayer->PlayerCollisionBox.BoxYRangeB;
                corner2.z = testedPlayer->PlayerCollisionBox.BoxZRangeB;

                float newPlayerDistance = tPlayer;
                // check if this hitted player is nearest than the current found nearest player
                if (getHitDistance(corner1, corner2, dirfrac, startPosition, &newPlayerDistance))
                {
                    // If the found player is an AI in the same team and the player is too near
                    if (shooterPlayer->isAi && shooterPlayer->Team == testedPlayer->Team && newPlayerDistance < 1)
                    {
                        continue;
                    }
                    if (newPlayerDistance < tPlayer)
                    {
                        tPlayer = newPlayerDistance;
                        nearestPlayerIndex = PlayerIndex;
                    }
                }
            }
        }
    }

    if (tPlayer * 2.0 < t)
    {
        t = tPlayer * 2.0;
    }
    else
    {
        nearestPlayerIndex = NO_PLAYER;
    }

    if (shooterPlayer->ScanForGrenade == EMPTY && (nearestPlayerIndex != NO_PLAYER || nearestWallIndex != NO_PLAYER))
    {
        // Turn distance into float distance scale
        t /= 8192.0;
        t -= 0.2;
        *distance = t * 50;
        if (!shooterPlayer->justCheking)
        {
            //  Create wall shot flash position
            Vector3 hitPosition;
            hitPosition.x = shooterPlayer->startRaycastPosition.x + shooterPlayer->startRaycastRotation.x * t;
            hitPosition.y = shooterPlayer->startRaycastPosition.y + CameraOffsetY + shooterPlayer->startRaycastRotation.y * t;
            hitPosition.z = shooterPlayer->startRaycastPosition.z + shooterPlayer->startRaycastRotation.z * t;

            if (!AllGuns[shooterPlayer->startGunIdRaycast].isKnife)
            {
                // Check a free wall shot flash slot
                int flashIndex = 0;
                for (int i = 0; i < FLASH_MODELS_COUNT; i++)
                {
                    if (ShowWallHitFlash[i] == 0)
                    {
                        flashIndex = i;
                        break;
                    }
                }

                ShowWallHitFlash[flashIndex] = 3;

                // Create wall hit flash rotation
                Vector2 Direction1D;
                Direction1D.y = hitPosition.y - shooterPlayer->position.y - CameraOffsetY + y;
                Direction1D.x = 1;
                normalize2D(&Direction1D);

                Vector3 Direction;
                Direction.x = hitPosition.x - shooterPlayer->position.x;
                Direction.y = hitPosition.y - shooterPlayer->position.y;
                Direction.z = hitPosition.z - shooterPlayer->position.z;
                normalize(&Direction);

                // Set wall hit flash angles
                int FinalAngleY = atan2f(Direction.x, Direction.z) * 512.0 / (M_TWOPI) + 384;
                int FinalAngleZ = atan2f(Direction1D.y, 1) * 512.0 / (M_TWOPI) + 128;
                NE_ModelSetRot(flashModels[flashIndex], 0, FinalAngleY, FinalAngleZ);

                //   Set wall hot flash position
                NE_ModelSetCoord(flashModels[flashIndex], hitPosition.x, hitPosition.y, hitPosition.z);

                if (!applyRules)
                {
                    SendWallHit = true;
                    WallHitXPos[currentShootIndex] = hitPosition.x * 4096;
                    WallHitYPos[currentShootIndex] = hitPosition.y * 4096;
                    WallHitZPos[currentShootIndex] = hitPosition.z * 4096;
                }
            }
            else
            {
                PlayBasicSound(AllGuns[shooterPlayer->startGunIdRaycast].gunSound);
            }

            if (nearestPlayerIndex != NO_PLAYER && (!AllGuns[shooterPlayer->startGunIdRaycast].isKnife || t <= 1))
            {

                if (AllPlayers[nearestPlayerIndex].Team != shooterPlayer->Team || allPartyModes[currentPartyMode].teamDamage)
                    HitPlayerIndex = nearestPlayerIndex;

                AllPlayers[nearestPlayerIndex].mapVisivilityTimer = 300;

                // Check if the hit is a headshot
                if (hitPosition.y - AllPlayers[nearestPlayerIndex].position.y >= 0.64)
                {
                    shooterPlayer->IsHeadShot[currentShootIndex] = true;
                }
                else if (hitPosition.y - AllPlayers[nearestPlayerIndex].position.y <= 0.2) // Check if the hit is a legshot
                {
                    shooterPlayer->IsLegShot[currentShootIndex] = true;
                }
            }
        }
        else
        {
            if (nearestPlayerIndex != NO_PLAYER)
            {
                if (AllPlayers[nearestPlayerIndex].Team != shooterPlayer->Team)
                    HitPlayerIndex = nearestPlayerIndex;

                if (AllGuns[shooterPlayer->startGunIdRaycast].isKnife)
                {
                    // If the target is too far
                    if (t <= 1)
                    {
                        // Walk to the target
                        shooterPlayer->tooFar = true;
                        Player *targetPlayer = &AllPlayers[nearestPlayerIndex];
                        int nearestWaypoint = getNearestWaypoint(targetPlayer->position.x, targetPlayer->position.y, targetPlayer->position.z);
                        StartChecking(playerIndex, nearestWaypoint);
                    }
                    else
                        shooterPlayer->tooFar = false;
                }
            }
        }
    }
    else if (shooterPlayer->ScanForGrenade != EMPTY)
    {
        HitPlayerIndex = nearestPlayerIndex;
    }

    return HitPlayerIndex;
}
```

`Counter-Strike-nds/source/collisions/raycast.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef RAYCAST_H_ /* Include guard */
#define RAYCAST_H_
#include "../main.h"

void prepareAiRaycast(int fromPlayerIndex, int toPlayerIndex, bool checkVisibility);
void getValuesForRaycast(Vector3Int StartPosition, Vector3Int EndPosition, float *x, float *y, float *z);
void setRaycastValues(Player *shooterPlayer, float xRot, float yRot, float zRot);
int Raycast(int playerIndex, int currentShootIndex, float *distance);

#endif // RAYCAST_H_
```

`Counter-Strike-nds/source/debug/debug.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "debug.h"
#include "input.h"

// File system
#include <fat.h>

#include <NEMain.h>

// File
FILE *debugFile;

// Enable debug text at top screen?
bool isDebugTopScreen = false;
// Enable debug text at bottom screen?
bool isDebugBottomScreen = false;
bool isDebugMode = true;

void initDebug()
{
    if (isDebugMode)
    {
        // Set debug mode if keys are pressed
        if (keys & KEY_START)
            isDebugTopScreen = true;

        if (keys & KEY_SELECT)
        {
            isDebugBottomScreen = true;
            //  Init debug console
            consoleDemoInit();
        }
    }
}

/**
 * @brief Print a message in the file
 *
 * @param text
 */
void debugPrint(const char *text)
{
    // Open the file
    if (debugFile == NULL)
    {
        debugFile = fopen("fat:/debug_cs.log", "a");
    }

    // Print the message and a new line
    fprintf(debugFile, text);
    fprintf(debugFile, "\n");

    // Close the file
    if (debugFile != NULL)
    {
        fclose(debugFile);
    }
}

/**
 * @brief Print Nitro Engine error in debug mode
 *
 * @param text Text to print
 */
void error_handler(const char *text)
{
    // Simple handler. You could write this to a file instead, for example.
    printf(text);

    // Write in the file
    // debugPrint(text);
}
```

`Counter-Strike-nds/source/debug/debug.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef DEBUG_H_ /* Include guard */
#define DEBUG_H_
#include "main.h"

// Text colors
#define RED "\x1B[31m"
#define GREEN "\x1B[32m"
#define YELLOW "\x1B[33m"
#define BLUE "\x1B[34m"
#define MAGENTA "\x1B[35m"
#define CYAN "\x1B[36m"
#define WHITE "\x1B[37m"

void debugPrint(const char *text);
void error_handler(const char *text);
void initDebug();

extern bool isDebugTopScreen;
extern bool isDebugBottomScreen;
extern bool isDebugMode;

#endif // DEBUG_H_
```

`Counter-Strike-nds/source/graphics/camera.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "camera.h"
#include "party.h"
#include "map.h"

// Speed of the camera to recenter the camera after using camera offset
int speedAimingReCenter = 3;
int speedAimingReCenterTimer = 10;

/**
 * @brief Check if player can be used for camera view
 *
 * @param left Way (true - left, false - right)
 * @param Found Found player (true - found, false - not found)
 * @param FirstFound First found player index
 * @param i Player index
 */
void checkCameraPlayerView(bool left, bool *Found, int *FirstFound, int i)
{
    Player *player = &AllPlayers[i];
    if (!player->IsDead && player->Id != UNUSED && (allPartyModes[currentPartyMode].canSeeOtherTeamView || player->Team == localPlayer->Team))
    {
        if (*FirstFound == NO_PLAYER)
            *FirstFound = i;

        if ((i < CurrentCameraPlayer && left) || (!left && i > CurrentCameraPlayer))
        {
            SetCurrentCameraPlayer(i);
            ShowMuzzle = 0;
            *Found = true;
        }
    }
}

/**
 * @brief Add screen shake for explosion
 */
void addExplosionScreenShake()
{
    if (IsExplode)
    {
        BombExplosionScale++;
        int Scale = 4096 * BombExplosionScale;
        NE_ModelScaleI(Model[10], Scale, Scale, Scale);

        xOffset = (rand() % ScreenShakeAmount + ScreenShakeMinAmount) / 100.0;
        if (rand() % 2 == 0)
            xOffset = -xOffset;

        yOffset = (rand() % ScreenShakeAmount + ScreenShakeMinAmount) / 100.0;
        if (rand() % 2 == 0)
            yOffset = -yOffset;

        speedAimingReCenter = 2;
        speedAimingReCenterTimer = 8;
    }
}

/**
 * @brief Reduce screen shake
 *
 */
void reduceScreenShake()
{
    // Screen shake
    if (xOffset >= 0.005)
        xOffset -= 0.005;
    else if (xOffset < -0.005)
        xOffset += 0.005;

    // Reduce yOffset with more affinity
    for (int i = 0; i < speedAimingReCenter; i++)
    {
        if (yOffset >= 0.0025)
            yOffset -= 0.0025;
        else if (yOffset < -0.0025)
            yOffset += 0.0025;
    }

    // Increase the speed reduction of the screen shake
    if (speedAimingReCenterTimer > 0)
    {
        speedAimingReCenterTimer--;
        if (speedAimingReCenterTimer == 0)
        {
            speedAimingReCenterTimer = 8;
            if (speedAimingReCenter < 5)
                speedAimingReCenter++;
        }
    }
}

/**
 * @brief Set camera position to look at the map
 *
 */
void setCameraMapPosition()
{
    Vector3 *pos = &allMaps[currentMap].cameraPosition;
    Vector3 *lookPos = &allMaps[currentMap].cameraLookPosition;
    NE_CameraSet(Camera,
                 pos->x, pos->y, pos->z,
                 lookPos->x, lookPos->y, lookPos->z,
                 0, 1, 0);
}

/**
 * @brief Change player's camera view
 *
 * @param left Way (true - left, false - right)
 */
void changeCameraPlayerView(bool left)
{
    bool Found = false;
    int FirstFound = NO_PLAYER;

    // Find first player available for view
    if (left)
    {
        for (int i = MaxPlayer - 1; i > 0; i--)
        {
            checkCameraPlayerView(left, &Found, &FirstFound, i);
            if (Found)
                break;
        }
    }
    else
    {
        for (int i = 1; i < MaxPlayer; i++)
        {
            checkCameraPlayerView(left, &Found, &FirstFound, i);
            if (Found)
                break;
        }
    }

    // Set new camera view
    if (!Found && FirstFound != NO_PLAYER)
    {
        if (CurrentCameraPlayer != FirstFound)
        {
            ShowMuzzle = 0;
            SetCurrentCameraPlayer(FirstFound);
        }
    }
}
```

`Counter-Strike-nds/source/graphics/camera.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef CAMERA_H_ /* Include guard */
#define CAMERA_H_
//#include "main.h"

void checkCameraPlayerView(bool left, bool *Found, int *FirstFound, int i);
void addExplosionScreenShake();
void reduceScreenShake();
void changeCameraPlayerView(bool left);
void setCameraMapPosition();

extern int speedAimingReCenter;
extern int speedAimingReCenterTimer;

#endif // CAMERA_H_
```

`Counter-Strike-nds/source/graphics/draw3d.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "grenade.h"
#include "collisions.h"
#include "ui.h"
#include "map.h"
#include "draw3d.h"
#include "party.h"

int t1x = 0;
int t1z = 0;
int t2x = 0;
int t2z = 0;
// Text material
NE_Material *TextMaterial = NULL;
// All palettes
NE_Palette *Palettes[17]; // 0 MapUI, 1 Map atlas, 2 text, 3 player, 4 gun sprite, 5 map point

// All materials used for the top screen
NE_Material *TopScreenSpritesMaterials[6];

// All materials used for the bottom screen
NE_Material *BottomScreenSpritesMaterials[9];

void initGraphics()
{
    // create Materials
    GroundMaterial = NE_MaterialCreate();
    GroundMaterialShadowed = NE_MaterialCreate();
    PlayerMaterial = NE_MaterialCreate();
    PlayerMaterialTerrorist = NE_MaterialCreate();
    PlayerShadowMaterial = NE_MaterialCreate();
    TopScreenSpritesMaterials[0] = NE_MaterialCreate();
    TopScreenSpritesMaterials[2] = NE_MaterialCreate();
    TopScreenSpritesMaterials[3] = NE_MaterialCreate();
    TopScreenSpritesMaterials[4] = NE_MaterialCreate();
    TopScreenSpritesMaterials[5] = NE_MaterialCreate();

    BottomScreenSpritesMaterials[0] = NE_MaterialCreate();
    BottomScreenSpritesMaterials[2] = NE_MaterialCreate();
    BottomScreenSpritesMaterials[3] = NE_MaterialCreate();
    BottomScreenSpritesMaterials[4] = NE_MaterialCreate();
    BottomScreenSpritesMaterials[5] = NE_MaterialCreate();

    // Create palettes
    Palettes[0] = NE_PaletteCreate();
    Palettes[2] = NE_PaletteCreate();
    Palettes[1] = NE_PaletteCreate();
    Palettes[3] = NE_PaletteCreate();
    Palettes[5] = NE_PaletteCreate();
    Palettes[6] = NE_PaletteCreate();
    Palettes[7] = NE_PaletteCreate();
    Palettes[8] = NE_PaletteCreate();
    Palettes[9] = NE_PaletteCreate();
    Palettes[11] = NE_PaletteCreate();
    Palettes[12] = NE_PaletteCreate();
    Palettes[13] = NE_PaletteCreate();
    Palettes[14] = NE_PaletteCreate();
    Palettes[15] = NE_PaletteCreate();
    Palettes[16] = NE_PaletteCreate();

    // Load .bin textures

    // Load font
    TextMaterial = NE_MaterialCreate();
    NE_MaterialTexLoadBMPtoRGB256(TextMaterial, Palettes[2], (void *)text_bmp_bin, true); // Load bmp font format

    // Create font
    NE_TextInit(0,            // Font slot
                TextMaterial, // Image
                8, 8);        // Size of one character (x, y)

    NE_MaterialTexLoadBMPtoRGB256(PlayerMaterial, Palettes[3], (void *)gign_skin1_bin, 0);
    NE_MaterialTexLoadBMPtoRGB256(PlayerMaterialTerrorist, Palettes[13], (void *)terrorist_skin1_bin, 0);

    NE_MaterialTexLoadBMPtoRGB256(GroundMaterial, Palettes[1], (void *)Atlas_bin, 1);
    NE_MaterialTexClone(GroundMaterial, GroundMaterialShadowed);

    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[0], Palettes[9], (void *)QuitButton_bin, 1);
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[2], Palettes[5], (void *)MapPointUI_bin, 1);
    NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[5], Palettes[16], (void *)bomb_logo_bin, 1);
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[4], Palettes[7], (void *)CheckMark_bin, 1);
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[5], Palettes[6], (void *)WhiteScareRounded_bin, 1);

    // Load .bmp textures top screen
    NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[0], Palettes[8], (void *)crosshair2_bin, 1);

    NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[2], Palettes[11], (void *)muzzle_bin, 1);
    NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[3], Palettes[12], (void *)scopeImage_bin, 1);
    NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[4], Palettes[14], (void *)MapUI_bin, 0);
    NE_MaterialTexLoadBMPtoRGB256(PlayerShadowMaterial, Palettes[15], (void *)player_shadow_bin, 1);

    // Create crosshair sprite
    TopScreenSprites[0] = NE_SpriteCreate();
    NE_SpriteSetPos(TopScreenSprites[0], ScreenCenterWidth - 20 / 2, ScreenCenterHeight - 20 / 2);
    NE_SpriteSetSize(TopScreenSprites[0], 20, 20);
    NE_SpriteSetPriority(TopScreenSprites[0], 10);
    NE_SpriteSetMaterial(TopScreenSprites[0], TopScreenSpritesMaterials[0]);

    // Create map sprite
    TopScreenSprites[1] = NE_SpriteCreate();
    NE_SpriteSetSize(TopScreenSprites[1], 170, 177);
    NE_SpriteSetPriority(TopScreenSprites[1], 2);
    NE_SpriteSetMaterial(TopScreenSprites[1], TopScreenSpritesMaterials[4]);

    // Create quit button
    BottomScreenSprites[0] = NE_SpriteCreate();
    NE_SpriteSetSize(BottomScreenSprites[0], 20, 20);
    NE_SpriteSetPriority(BottomScreenSprites[0], 0);
    NE_SpriteSetMaterial(BottomScreenSprites[0], BottomScreenSpritesMaterials[0]);
    NE_SpriteSetPos(BottomScreenSprites[0], 236, 2);
    NE_SpriteVisible(BottomScreenSprites[0], false);

    // Create models
    for (int i = 7; i < 7 + 4; i++)
    {
        if (i == 8) // Model 8 is unused
            continue;

        Model[i] = NE_ModelCreate(NE_Static);
        NE_ModelSetMaterial(Model[i], GroundMaterial);
        NE_ModelScaleI(Model[i], 4096, 4096, 4096);
        NE_ModelSetCoord(Model[i], 0, 1.5 + 0.8, 0);
        Model[i]->rx = 128;
        Model[i]->ry = 256;
    }

    // Load bomb model
    NE_ModelLoadStaticMesh(Model[7], (u32 *)bomb_bin);

    // Load flash models
    for (int i = 0; i < FLASH_MODELS_COUNT; i++)
    {
        flashModels[i] = NE_ModelCreate(NE_Static);

        if (i == 0)
            NE_ModelLoadStaticMesh(flashModels[i], (u32 *)plane_bin);
        else
            NE_ModelClone(flashModels[i],  // Destination
                          flashModels[0]); // Source model

        NE_ModelSetMaterial(flashModels[i], TopScreenSpritesMaterials[2]);
        NE_ModelScaleI(flashModels[i], 4096, 4096, 4096);
    }

    createPlayerShadow();

    // Load explision effect model
    NE_ModelLoadStaticMesh(Model[10], (u32 *)explosion_bin);
    Model[10]->rx = 0;
    Model[10]->ry = 256;
    NE_ModelScaleI(Model[10], 0, 0, 0);
}

/**
 * @brief Create shadow for each players
 *
 */
void createPlayerShadow()
{
    // Player shadow
    for (int i = 1; i < MaxPlayer; i++)
    {
        AllPlayers[i].PlayerShadow = NE_ModelCreate(NE_Static);
        NE_ModelScaleI(AllPlayers[i].PlayerShadow, 4096 * 2, 4096 * 2, 4096 * 2);
        NE_ModelSetMaterial(AllPlayers[i].PlayerShadow, PlayerShadowMaterial);
        NE_ModelLoadStaticMesh(AllPlayers[i].PlayerShadow, (u32 *)plane_bin);
        NE_ModelSetCoord(AllPlayers[i].PlayerShadow, 4, -0.845, -13);
    }
}

/**
 * @brief Enanble or disable two screens refresh mode
 *
 * @param value
 */
void SetTwoScreenMode(bool value)
{
    if (AlwaysUpdateBottomScreen && !value && UpdateBottomScreenFrameCount == 0)
    {
        NeedChangeScreen = true;
    }
    else if (!AlwaysUpdateBottomScreen && value)
    {
        NeedChangeScreen = true;
    }
}

/**
 * @brief Draw top screen 3D then UI
 *
 */
void Draw3DScene(void)
{
    // Set camera for drawing
    NE_CameraUse(Camera);

    // Reset polygons Alpha/Light/Effect
    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

    Map *map = &allMaps[currentMap];

    // render 3D if map insn't at screen
    if (!isShowingMap)
    {
        // Field of view end coordinates
        t1x = (xWithoutYForOcclusionSide1 * 500 + AllPlayers[CurrentCameraPlayer].position.x) * 8192.0;
        t1z = (zWithoutYForOcclusionSide1 * 500 + AllPlayers[CurrentCameraPlayer].position.z) * 8192.0;
        t2x = (xWithoutYForOcclusionSide2 * 500 + AllPlayers[CurrentCameraPlayer].position.x) * 8192.0;
        t2z = (zWithoutYForOcclusionSide2 * 500 + AllPlayers[CurrentCameraPlayer].position.z) * 8192.0;

        // Draw map
        for (int i = 0; i < map->AllZones[AllPlayers[CurrentCameraPlayer].CurrentOcclusionZone].ZoneCount; i++)
        {
            bool inFov = false; // Is the map part in the field of view of the player?

            // Force to render the map part where the player is
            if (checkZoneForOcclusion(&map->AllOcclusionZone[map->AllZones[AllPlayers[CurrentCameraPlayer].CurrentOcclusionZone].visibleMapPart[i]], AllPlayers[CurrentCameraPlayer].PlayerModel->x, AllPlayers[CurrentCameraPlayer].PlayerModel->z))
                inFov = true;
            else
            {
                // Check if the map part is in the field of view of the player
                for (int i2 = 0; i2 < 4; i2++)
                {
                    if (PointInTriangleInt(map->AllOcclusionZone[map->AllZones[AllPlayers[CurrentCameraPlayer].CurrentOcclusionZone].visibleMapPart[i]].anglesInt[i2].x, map->AllOcclusionZone[map->AllZones[AllPlayers[CurrentCameraPlayer].CurrentOcclusionZone].visibleMapPart[i]].anglesInt[i2].y, AllPlayers[CurrentCameraPlayer].PlayerModel->x, AllPlayers[CurrentCameraPlayer].PlayerModel->z, t1x, t1z, t2x, t2z))
                    {
                        inFov = true;
                        break;
                    }
                }
            }

            // Render map model if needed
            if (inFov)
            {
                if (!map->models[map->AllZones[AllPlayers[CurrentCameraPlayer].CurrentOcclusionZone].visibleMapPart[i]].shadowed) // Set the model light like normal
                {
                    GroundMaterial->diffuse = RGB15(0, 0, 0);
                    GroundMaterial->emission = RGB15(11, 11, 11);
                    GroundMaterial->specular = RGB15(7, 7, 7);
                }
                else // Set the model light like shadowed
                {
                    GroundMaterial->diffuse = RGB15(1, 1, 1);
                    GroundMaterial->emission = RGB15(3, 3, 3);
                    GroundMaterial->specular = RGB15(3, 3, 3);
                }
                NE_ModelDraw(map->models[map->AllZones[AllPlayers[CurrentCameraPlayer].CurrentOcclusionZone].visibleMapPart[i]].Model);
            }
        }

        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

        // Draw grenades and their effects
        for (int i = 0; i < GrenadeCount; i++)
        {
            if (grenades[i] != NULL)
            {
                //  Draw grenade
                if (grenades[i]->isVisible)
                {
                    // Grenade clipping
                    bool inFov = PointInTriangleInt(grenades[i]->Model->x, grenades[i]->Model->z, AllPlayers[CurrentCameraPlayer].PlayerModel->x, AllPlayers[CurrentCameraPlayer].PlayerModel->z, t1x, t1z, t2x, t2z);

                    // Draw grenade if in field of view
                    if (inFov)
                    {
                        NE_PolyFormat(30, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                        NE_ModelDraw(grenades[i]->Model);
                    }
                }

                // Alpha 0 is wireframe mode, put to 1 to see the grenade
                if (grenades[i]->effectAlpha <= 0)
                    grenades[i]->effectAlpha = 1;

                // Set polygons alpha
                NE_PolyFormat(grenades[i]->effectAlpha, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                // Draw effect if timer effect is on
                if (grenades[i]->EffectTimer != 0)
                {
                    if ((grenades[i]->GrenadeType == SMOKE && isInFullSmoke) || grenades[i]->GrenadeType == FLASH)
                        continue;
                    NE_ModelDraw(grenades[i]->EffectModel);
                }
            }
        }
        isInFullSmoke = false;

        // Reset polygons Alpha/Light/Effect
        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

        // If bomb is planted, draw bomb
        if (BombPlanted || bombDropped)
            NE_ModelDraw(Model[7]);

        // Show wall bullet hit flash
        for (int i = 0; i < FLASH_MODELS_COUNT; i++)
        {
            if (ShowWallHitFlash[i] != 0)
            {
                ShowWallHitFlash[i]--;
                NE_ModelDraw(flashModels[i]);
            }
        }

        // Draw bomb explosion
        if (IsExplode)
        {
            // Calculate explosion effect alpha
            int ExplosionAlpha = 31 - (int)(BombExplosionScale / 1.2);
            if (ExplosionAlpha < 0)
            {
                ExplosionAlpha = 0;
                IsExplode = false;
            }
            // Set polygons alpha
            NE_PolyFormat(ExplosionAlpha, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

            // Draw explosion
            NE_ModelDraw(Model[10]);
        }

        DrawPlayers();
    }

    // Draw UI
    drawTopScreenUI();
}

/**
 * @brief Draws players
 *
 */
void DrawPlayers()
{
    if (UpdateBottomScreenFrameCount != 0)
        return;

    Map *map = &allMaps[currentMap];

    // for each players
    for (int playerIndex = 1; playerIndex < MaxPlayer; playerIndex++)
    {
        Player *player = &AllPlayers[playerIndex];
        // Check if he is not dead, in game and if the camera is not on this player
        if (AllPlayers[playerIndex].Id != UNUSED && !AllPlayers[playerIndex].IsDead && CurrentCameraPlayer != playerIndex)
        {
            for (int i3 = 0; i3 < allMaps[currentMap].AllZones[AllPlayers[playerIndex].CurrentOcclusionZone].ZoneCount; i3++)
            {
                // If the player is in a visible map part
                if (checkZoneForOcclusion(&map->AllOcclusionZone[allMaps[currentMap].AllZones[AllPlayers[playerIndex].CurrentOcclusionZone].visibleMapPart[i3]], AllPlayers[CurrentCameraPlayer].PlayerModel->x, AllPlayers[CurrentCameraPlayer].PlayerModel->z))
                {
                    // Get if the player is in the field of view of the camera
                    bool inFov = PointInTriangleInt(AllPlayers[playerIndex].PlayerModel->x, AllPlayers[playerIndex].PlayerModel->z, AllPlayers[CurrentCameraPlayer].PlayerModel->x, AllPlayers[CurrentCameraPlayer].PlayerModel->z, t1x, t1z, t2x, t2z);

                    if (inFov)
                    {
                        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                        // Draw player's skin
                        NE_ModelDraw(AllPlayers[playerIndex].PlayerModel);

                        // Draw player's shadow
                        if (player->isAi || fabs(player->position.y - player->lerpDestination.y) < 0.05)
                        {
                            NE_PolyFormat(15, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                            NE_ModelDraw(AllPlayers[playerIndex].PlayerShadow);
                        }
                    }
                    break;
                }
            }
        }
    }
}

/**
 * @brief Draw game top screen when a game is not launched
 *
 */
void Draw3DSceneNotInGame(void)
{
    // Set camera for drawing
    NE_CameraUse(Camera);

    // Reset polygons Alpha/Light/Effect
    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

    Map *map = &allMaps[currentMap];

    // Draw map
    if (currentMap == DUST2)
    {
        NE_ModelDraw(map->models[2].Model);
        NE_ModelDraw(map->models[3].Model);
    }
    else if (currentMap == TUTORIAL)
    {
        for (int i = 0; i < 2; i++)
        {
            // Set the model light like normal
            if (!map->models[i].shadowed)
            {
                GroundMaterial->diffuse = RGB15(0, 0, 0);
                GroundMaterial->emission = RGB15(11, 11, 11);
                GroundMaterial->specular = RGB15(7, 7, 7);
            }
            else // Set the model light like shadowed
            {
                GroundMaterial->diffuse = RGB15(1, 1, 1);
                GroundMaterial->emission = RGB15(3, 3, 3);
                GroundMaterial->specular = RGB15(3, 3, 3);
            }
            NE_ModelDraw(map->models[i].Model);
        }
    }

    NE_2DViewInit();
    // Draw keyboard input screen if needed
    if (isShowingKeyBoard)
    {
        drawKeyboardInput();
    }
}
```

`Counter-Strike-nds/source/graphics/draw3d.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef DRAW3D_H_ /* Include guard */
#define DRAW3D_H_

void initGraphics();
void Draw3DScene(void);
void DrawPlayers();
void Draw3DSceneNotInGame(void);
void createPlayerShadow();
void SetTwoScreenMode(bool value);

extern NE_Palette *Palettes[17];
extern NE_Material *TopScreenSpritesMaterials[6];
extern NE_Material *BottomScreenSpritesMaterials[9];

#endif // DRAW3D_H_
```

`Counter-Strike-nds/source/graphics/ui.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "ui.h"
#include "movements.h"
#include "collisions.h"
#include "keyboard.h"
#include "network.h"
#include "party.h"
#include "player.h"
#include "input.h"
#include "ai.h"
#include "map.h"
#include "sounds.h"
#include "gun.h"
#include "equipment.h"
#include "grenade.h"
#include "tutorial.h"
#include "keyboard.h"
#include "draw3d.h"
#include "stats.h"
#include "debug.h"

enum shopCategory ShopCategory = PISTOLS; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades

// Unused (Server list)
int selectedServer = 0;
int serverListOffset = 0;

// Current selected map in the map list menu
int currentSelectionMap = DUST2;

// Is showin the map in game
bool isShowingMap = false;
// Is showing the keyboard
bool isShowingKeyBoard = false;
// Is the gamepad in left mode
bool isLeftControls = false;

// Function to call to render the menu
void (*renderFunction)();
// Function to call after closing a menu
void (*onCloseMenu)();
// Function to call after closing a menu to open the last opened menu
void (*lastOpenedMenu)();
// Have to call the onCloseMenu function?
bool haveToCallOnCloseMenu = false;
// Is the menu using the quit button?
bool useQuitButton = false;
// Number of checkbox in the menu to render
int checkBoxToShow = 0;
// Number of Slider in the menu to render
int sliderToShow = 0;
// Current controls page (settings)
int controlsPage = 0; // [0,2]
// Error text to display
char errorText[ERROR_TEXT_LENGTH];

// Dialog text
char *dialogText = "";
// Game event notification text
char gameEventNotificationText[30] = "";
// Kill notification text
char killText[33] = "";

// for debug
int trace = 0;
float debugValue1 = -1;
float debugValue2 = -1;
float debugValue3 = -1;

// Is showing the final score of the party
bool showFinalScore = false;
// 0 Kill text, 1 connection/disconnection
int notificationType = 0;
// Show ping option
bool showPing = false;
// Number of frame remaining to show the shoot friend message
int showShootFriendMessage = 0;

float cursorTransparency = 1;

void *AllocateLargestFreeBlock(size_t *Size)
{
    size_t s0, s1;
    void *p;

    s0 = ~(size_t)0 ^ (~(size_t)0 >> 1);

    while (s0 && (p = malloc(s0)) == NULL)
        s0 >>= 1;

    if (p)
        free(p);

    s1 = s0 >> 1;

    while (s1)
    {
        if ((p = malloc(s0 + s1)) != NULL)
        {
            s0 += s1;
            free(p);
        }
        s1 >>= 1;
    }

    while (s0 && (p = malloc(s0)) == NULL)
        s0 ^= s0 & -s0;

    *Size = s0;
    return p;
}

size_t GetFreeSize()
{
    size_t total = 0;
    void *pFirst = NULL;
    void *pLast = NULL;

    for (;;)
    {
        size_t largest;
        void *p = AllocateLargestFreeBlock(&largest);

        if (largest < sizeof(void *))
        {
            if (p != NULL)
                free(p);
            break;
        }

        *(void **)p = NULL;

        total += largest;

        if (pFirst == NULL)
            pFirst = p;

        if (pLast != NULL)
            *(void **)pLast = p;

        pLast = p;
    }

    while (pFirst != NULL)
    {
        void *p = *(void **)pFirst;
        free(pFirst);
        pFirst = p;
    }

    return total;
}

void SetCheckBoxToShow(int value)
{
    checkBoxToShow = value;
}

void SetSliderToShow(int value)
{
    sliderToShow = value;
}

enum shopCategory GetShopCategory()
{
    return ShopCategory;
}

/**
 * @brief  Print a long text in a box
 *
 * @param minX Left border position (in characters)
 * @param maxX Right border position (in characters)
 * @param y Top position (in lines)
 * @param text Text to print
 * @return int The number of lines printed
 */
int printLongText(int minX, int maxX, int y, char *text)
{
    // TempText is a line of text
    char tempText[maxX - minX];
    tempText[0] = '\0';

    // Store the text in ptrText to avoid modifying the original text (because of strtok)
    char ptrText[strlen(text) + 1];
    strcpy(ptrText, text);

    // Cut the text every spaces
    char *ptr = strtok(ptrText, " ");
    int currentLine = 0;
    // While there is still text to cut
    while (ptr != NULL)
    {
        // If the tempText with the next word to add is too long, print the tempText and start a new line
        int TempTextLen = strlen(tempText);
        if (TempTextLen > 0 && TempTextLen + 1 + strlen(ptr) > maxX - minX)
        {
            // Get the middle positon of the text in the box
            int fixedXPos = centerPositionOfAText(minX, maxX, TempTextLen);
            NE_TextPrint(0,                          // Font slot
                         fixedXPos, y + currentLine, // Coordinates x(column), y(row)
                         NE_White,                   // Color
                         tempText);

            for (int i = 0; i < TempTextLen; i++)
                tempText[i] = '\0';

            currentLine++;
        }

        // Copy the next word to print in the tempText variable
        sprintf(tempText + strlen(tempText), ptr);
        sprintf(tempText + strlen(tempText), " ");

        // Check for a new word
        ptr = strtok(NULL, " ");
    }

    // Print the last line
    int fixedXPos = centerPositionOfAText(minX, maxX, strlen(tempText));
    NE_TextPrint(0,                          // Font slot
                 fixedXPos, y + currentLine, // Coordinates x(column), y(row)
                 NE_White,                   // Color
                 tempText);

    return currentLine + 1;
}

/**
 * @brief Print a long text in a box
 *
 * @param minX Left border position (in characters)
 * @param maxX Right border position (in characters)
 * @param y Top position (in lines)
 * @param text Text to print
 * @return int The number of lines printed
 */
int printLongConstChar(int minX, int maxX, int y, const char *text)
{
    return printLongText(minX, maxX, y, (char *)text);
}

/**
 * @brief Get the middle positon of a text in a box
 *
 * @param xMin Left border position (in characters)
 * @param xMax Right border position (in characters)
 * @param textLength Text length (in characters)
 * @return int The middle position of the text (in characters)
 */
int centerPositionOfAText(int xMin, int xMax, int textLength)
{
    return xMin + ceil((xMax - xMin) / 2.0) - floor(textLength / 2.0);
}

/**
 * @brief Set dialog text
 *
 * @param text
 */
void setDialogText(char *text)
{
    // Copy the text to another text variable
    dialogText = text;
}

/**
 * @brief Draw the dialog box
 *
 */
void showDialog()
{
    // If the text is not empty and a menu is not on the top screen
    if (strlen(dialogText) > 0 && !isShowingKeyBoard && !isShowingMap)
    {
        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
        int ligneCount = printLongText(1, 30, 1, dialogText);
        NE_PolyFormat(20, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
        NE_2DDrawQuad(0, 0, 256, (ligneCount + 2) * 8, 1, RGB15(0, 0, 0));
    }
}

/**
 * @brief  To call before changing the menu
 *
 * @param menuToShow Menu to show
 */
void startChangeMenu(enum UiMenu menuToShow)
{
    // Reset UI
    SetButtonToShow(0);
    SetCheckBoxToShow(0);
    SetSliderToShow(0);
    isShowingKeyBoard = false;

    // Call the on close function
    if (haveToCallOnCloseMenu)
    {
        haveToCallOnCloseMenu = false;
        onCloseMenu();
    }

    // Re enable all buttons
    for (int i = 0; i < ButtonCount; i++)
    {
        AllButtons[i].isHidden = false;
    }

    // Set current menu
    currentMenu = menuToShow;

    // Refresh the screen
    UpdateBottomScreenFrameCount += 8;
}

/**
 * @brief Open a menu
 *
 * @param menuId Menu id to open
 */
void ChangeMenu(int menuId)
{
    // call the function to init the menu
    if (menuId == GAME)
    {
        initGameMenu();
    }
    else if (menuId == SCORE_BOARD) // Score board screen
    {
        initScoreMenu();
    }
    else if (menuId == SHOPCATEGORIES) // Shop categories
    {
        initShopCategoriesMenu();
    }
    else if (menuId == SETTINGS) // Settings menu
    {
        initSettingsMenu();
    }
    else if (menuId == QUIT) // Quit menu
    {
        initQuitMenu();
    }
    else if (menuId == SHOP) // SHOP
    {
        initShopMenu();
    }
    else if (menuId == CONTROLLER) // Game pad menu
    {
        initControllerMenu();
    }
    else if (menuId == MAIN) // Main menu
    {
        initMainMenu();
    }
    else if (menuId == CHANGENAME) // Change name menu
    {
        initChangeNameMenu();
    }
    else if (menuId == CHAT) // Online chat
    {
        initChatMenu();
    }
    else if (menuId == CONTROLSSETTINGS) // Controls settings
    {
        initControlsSettingsMenu();
    }
    else if (menuId == CONTROLSCHANGE) // Controls customization
    {
        initControlsChangeMenu();
    }
    else if (menuId == MAP_SELECTION_IMAGE)
    {
        initSelectionMapImageMenu();
    }
    else if (menuId == MAP_SELECTION_LIST)
    {
        initSelectionMapListMenu();
    }
    else if (menuId == PARTY_MODE_SELECTION_LIST)
    {
    }
    else if (menuId == FINAL_SCORE)
    {
        initFinalScoreMenu();
    }
    else if (menuId == JOIN_CREATE_PARTY)
    {
        initJoinCreatePartyMenu();
    }
    else if (menuId == ENTER_CODE)
    {
        initEnterCodeMenu();
    }
}

/**
 * @brief Open the shop category
 *
 * @param categoryId
 */
void OpenShopCategory(int categoryId)
{
    SetSelectedGunShop(-1);
    ShopCategory = categoryId;
    initShopMenu();
    ChangeShopElement(0);
}

/**
 * @brief Disable or enable the map
 *
 */
void changeMapState()
{
    isShowingMap = !isShowingMap;
    ForceUpdateLookRotation(localPlayer->cameraAngle);
}

/**
 * @brief Close the map
 *
 */
void closeMap()
{
    isShowingMap = false;
}

/**
 * @brief Buy a weapon (In online the game will send a packet to the server)
 *
 * @param unused
 */
void BuyWeapon(int unused)
{
    PlayBasicSound(SFX_KEYBOARD_SOUND);
    DisableAim();
    if (Connection != OFFLINE)
    {
        SetSendBuyWeapon(true);
    }
    else
    {
        buyGun();
    }
}

/**
 * @brief Change the selected element in the shop
 *
 * @param Left
 */
void ChangeShopElement(int Left)
{
    int Selected = GetSelectedGunShop();
    bool FoundNewGun = false;
    int FirstGunFound = -1;
    if (Left == 0)
    {
        // Go to the next element of the same category and team
        for (int i = 0; i < GunCount + equipementCount + shopGrenadeCount; i++)
        {
            if ((ShopCategory < EQUIPMENT && i < GunCount && (AllGuns[i].gunCategory == ShopCategory && (AllPlayers[0].Team == AllGuns[i].team || AllGuns[i].team == -1))) || (ShopCategory == GRENADES && i >= GunCount && i < GunCount + shopGrenadeCount && (AllPlayers[0].Team == GetAllGrenades()[i - GunCount].team || GetAllGrenades()[i - GunCount].team == -1)) || (ShopCategory == EQUIPMENT && i >= GunCount + shopGrenadeCount && !allEquipments[i - GunCount - shopGrenadeCount].isHided && (AllPlayers[0].Team == allEquipments[i - GunCount - shopGrenadeCount].team || allEquipments[i - GunCount - shopGrenadeCount].team == -1)))
            {
                if (FirstGunFound == -1)
                    FirstGunFound = i;

                if (i > Selected)
                {
                    Selected = i;
                    FoundNewGun = true;
                    break;
                }
            }
        }
    }
    else
    {
        // Go to the next element of the same category and team
        for (int i = GunCount + equipementCount + shopGrenadeCount - 1; i > -1; i--)
        {
            if ((ShopCategory < EQUIPMENT && i < GunCount && (AllGuns[i].gunCategory == ShopCategory && (AllPlayers[0].Team == AllGuns[i].team || AllGuns[i].team == -1))) || (ShopCategory == GRENADES && i >= GunCount && i < GunCount + shopGrenadeCount && (AllPlayers[0].Team == GetAllGrenades()[i - GunCount].team || GetAllGrenades()[i - GunCount].team == -1)) || (ShopCategory == EQUIPMENT && i >= GunCount + shopGrenadeCount && !allEquipments[i - GunCount - shopGrenadeCount].isHided && (AllPlayers[0].Team == allEquipments[i - GunCount - shopGrenadeCount].team || allEquipments[i - GunCount - shopGrenadeCount].team == -1)))
            {
                if (FirstGunFound == -1)
                    FirstGunFound = i;

                if (i < Selected)
                {
                    Selected = i;
                    FoundNewGun = true;
                    break;
                }
            }
        }
    }

    if (!FoundNewGun)
        Selected = FirstGunFound;

    // Update the texture
    NE_PaletteDelete(Palettes[10]);
    NE_MaterialDelete(BottomScreenSpritesMaterials[6]);
    BottomScreenSpritesMaterials[6] = NE_MaterialCreate();
    Palettes[10] = NE_PaletteCreate();
    if (ShopCategory < EQUIPMENT)
        NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], AllGuns[Selected].texture, 1);
    else if (ShopCategory == GRENADES)
        NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], GetAllGrenades()[Selected - GunCount].texture, 1);
    else if (ShopCategory == EQUIPMENT)
        NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], allEquipments[Selected - GunCount - shopGrenadeCount].texture, 1);

    SetSelectedGunShop(Selected);

    // Refresh the screen
    SetUpdateBottomScreenOneFrame(4);
}

void AskGameMode()
{
    if (allMaps[currentSelectionMap].forcePartyMode == -1)
    {
        initPartyModeSelectionMenu();
    }
    else
    {
        StartSinglePlayer(allMaps[currentSelectionMap].forcePartyMode);
    }
}

/**
 * @brief Change map in the map selection screen
 *
 * @param Left
 */
void ChangeMap(int Left)
{
    if (Left == 0)
    {
        currentSelectionMap++;
        if (currentSelectionMap == MAP_COUNT)
            currentSelectionMap = 0;
    }
    else
    {
        currentSelectionMap--;
        if (currentSelectionMap == -1)
            currentSelectionMap = MAP_COUNT - 1;
    }

    // Update texture
    NE_PaletteDelete(Palettes[10]);
    NE_MaterialDelete(BottomScreenSpritesMaterials[6]);
    BottomScreenSpritesMaterials[6] = NE_MaterialCreate();
    Palettes[10] = NE_PaletteCreate();
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], allMaps[currentSelectionMap].image, 1);
}

void setQuitButton(bool value)
{
    useQuitButton = value;
    // Set button sprite
    NE_SpriteVisible(BottomScreenSprites[0], value);
}

/**
 * @brief Set local player team (In online the game will send a packet to the server)
 *
 * @param i
 */
void SetTeam(int i)
{
    if (applyRules)
    {
        AllPlayers[0].Team = i;
        UpdateBottomScreenFrameCount += 8;
    }
    else if (!applyRules)
    {
        SetWaitForTeamResponse(true);
        AllButtons[1].isHidden = true;
        AllButtons[2].isHidden = true;
        SetTempTeam(i);
        SetSendTeam(true);
    }
}

/**
 * @brief Change the controls page in the settings controls menu
 *
 * @param isLeft
 */
void changeControlsPage(int isLeft)
{
    if (!isLeft)
    {
        controlsPage++;
        if (controlsPage == CONTROLS_PAGE_COUNT)
        {
            controlsPage = 0;
        }
    }
    else
    {
        controlsPage--;
        if (controlsPage == -1)
        {
            controlsPage = CONTROLS_PAGE_COUNT - 1;
        }
    }
    // Refresh the menu
    initControlsChangeMenu();
}

/**
 * @brief Show party event notification
 *
 * @param event Event type see TextEnum in ui.h
 */
void showPartyEventText(int event)
{
    if (event == TERRORISTS_WIN)
    {
        strncpy(gameEventNotificationText, "Terrorists win", 30);
        PlayBasicSound(SFX_TERRORISTSWIN);
    }
    else if (event == COUNTER_TERRORISTS_WIN)
    {
        strncpy(gameEventNotificationText, "Counter-Terrorists win", 30);
        PlayBasicSound(SFX_COUNTERTERRORISTWIN);
    }
    else if (event == BOMB_PLANTED)
    {
        strncpy(gameEventNotificationText, "Bomb has been planted", 30);
        PlayBasicSound(SFX_BOMBHASBEENPLANTED);
    }
    else if (event == BOMB_DEFUSED)
    {
        strncpy(gameEventNotificationText, "Bomb has been defused", 30);
        PlayBasicSound(SFX_BOMBHASBEENDEFUSED);
    }

    // Set the timer
    textToShowTimer = 360; // 6sec * 60 frames
}

/**
 * @brief Show kill text between two players
 *
 * @param killerIndex Killer index
 * @param deadPlayerIndex Dead player index
 */
void showKillText(int killerIndex, int deadPlayerIndex)
{
    sprintf(killText, "{%d%s {2killed {%d%s", (int)AllPlayers[killerIndex].Team, AllPlayers[killerIndex].name, (int)AllPlayers[deadPlayerIndex].Team, AllPlayers[deadPlayerIndex].name);

    KillTextShowTimer = 240;
    notificationType = 0;
}

/**
 * @brief Show connected notification
 *
 * @param connectedPlayerIndex Player index
 */
void showConnectedText(int connectedPlayerIndex)
{
    sprintf(killText, "%s connected", AllPlayers[connectedPlayerIndex].name);

    KillTextShowTimer = 240;
    notificationType = 1;
}

/**
 * @brief Show disconnected notification
 *
 * @param disconnectedPlayerIndex Player index
 */
void showDisconnectedText(int disconnectedPlayerIndex)
{
    sprintf(killText, "%s disconnected", AllPlayers[disconnectedPlayerIndex].name);

    KillTextShowTimer = 240;
    notificationType = 1;
}

/**
 * @brief Start input scan for the controls menu
 *
 * @param inputIndex Input index to scan
 */
void startScanForInput(int inputIndex)
{
    stopScanForInput();

    if (inputs[inputIndex].value != -1) // Unassign input
    {
        inputs[inputIndex].value = -1;
        inputs[inputIndex].nameIndex = 12;
    }
    else if (inputs[inputIndex].nameIndex != 13) // if the input to scan is not in scan mode, start scan for it
    {
        scanForInput = true;
        currentInputScanned = inputIndex;
        inputs[inputIndex].nameIndex = 13;
    }
}

/**
 * @brief Stop input scan for the controls menu
 *
 */
void stopScanForInput()
{
    // Disable current scanning input
    if (inputs[currentInputScanned].nameIndex == 14 || inputs[currentInputScanned].nameIndex == 13)
    {
        inputs[currentInputScanned].nameIndex = 12;
    }

    scanForInput = false;
}

/**
 * @brief Set keyboard mode button text
 *
 */
void updateKeyboardModeButton()
{
    if (isAzerty)
    {
        AllButtons[2].text = "Azerty";
    }
    else
    {
        AllButtons[2].text = "Qwerty";
    }
}

/**
 * @brief Draw keyboard
 *
 */
void drawKeyboardInput()
{
    NE_2DDrawQuad(0, 0, ScreenWidth, ScreenHeightFixed, 3, RGB15(3, 3, 3)); // Background
    if (currentMenu == CHANGENAME)
    {
        NE_TextPrint(0,        // Font slot
                     11, 2,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Change name");

        char editedName[21];

        sprintf(editedName, "%s", tempText);

        int nameLength = strlen(editedName);
        for (int i = nameLength; i < maxInputLength; i++)
        {
            sprintf(editedName + nameLength, "_");
            nameLength++;
        }

        NE_TextPrint(0,        // Font slot
                     10, 12,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     editedName);
    }
    else if (currentMenu == ENTER_CODE)
    {
        NE_TextPrint(0,        // Font slot
                     11, 2,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Enter code");

        char code[21];

        sprintf(code, "%s", tempText);

        int codeLength = strlen(code);
        for (int i = codeLength; i < maxInputLength; i++)
        {
            sprintf(code + codeLength, "_");
            codeLength++;
        }

        NE_TextPrint(0,        // Font slot
                     14, 12,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     code);
    }
}

/**
 * @brief Draw top screen
 *
 */
void drawTopScreenUI()
{
    Player *selectPlayer = &AllPlayers[CurrentCameraPlayer];

    // Set view in 2D mode
    NE_2DViewInit();

    // Only for debug
    int TextYOffset = 0;
    if (!isDebugTopScreen)
        TextYOffset = -3;

    for (int i = 1; i < MaxPlayer; i++)
        if (AllPlayers[i].mapVisivilityTimer > 0)
            AllPlayers[i].mapVisivilityTimer--;

    if (isShowingKeyBoard)
    {
        drawKeyboardInput();
    }
    else if (isShowingMap)
    {
        NE_2DDrawQuad(0, 0, ScreenWidth, ScreenHeightFixed, 3, RGB15(0, 0, 0)); // Background

        // Calculate map position
        float mapXPos = map(selectPlayer->position.x, -46, 57.5, -170, 170);
        float mapYPos = map(selectPlayer->position.z, -41, 67, -177, 177);

        // Set map position and draw sprite
        NE_SpriteSetPos(TopScreenSprites[1], ScreenCenterWidth - 170 / 2 + (mapXPos * zWithoutYForMap - mapYPos * xWithoutYForMap) / 2, ScreenCenterHeight - 177 / 2 + 2 + (mapYPos * zWithoutYForMap + mapXPos * xWithoutYForMap) / 2);
        NE_SpriteSetRot(TopScreenSprites[1], (int)selectPlayer->Angle);
        NE_SpriteDraw(TopScreenSprites[1]);

        for (int i = 1; i < MaxPlayer; i++)
        {
            // Draw other player if he is alive, visible or in the same team as the local player or if the local player is dead in a cusual party mode
            if (AllPlayers[i].Id != UNUSED && AllPlayers[i].Team != SPECTATOR && !AllPlayers[i].IsDead && (AllPlayers[i].Team == localPlayer->Team || AllPlayers[i].mapVisivilityTimer > 0 || (currentPartyMode == 1 && localPlayer->IsDead)))
            {
                // Calculate other players points
                float xPos2 = map(AllPlayers[i].position.x, -46, 57.5, -170, 170);
                float ypos2 = map(AllPlayers[i].position.z, -41, 67, -177, 177);
                float xPoint = ScreenCenterWidth - ((xPos2 - mapXPos) * zWithoutYForMap + (ypos2 - mapYPos) * -xWithoutYForMap) / 2.0;
                float yPoint = ScreenCenterHeight + ((ypos2 - mapYPos) * -zWithoutYForMap + (xPos2 - mapXPos) * -xWithoutYForMap) / 2.0;
                float finalXPoint1 = xPoint - 4, finalYPoint1 = yPoint - 2;
                float finalXPoint2 = xPoint + 2, finalYPoint2 = yPoint + 4;

                // Set point color and draw it
                if (AllPlayers[i].Team == AllPlayers[0].Team)
                    NE_2DDrawTexturedQuadColor(finalXPoint1, finalYPoint1, finalXPoint2, finalYPoint2, 1, BottomScreenSpritesMaterials[2], RGB15(0, 31, 31)); // Friends points
                else
                    NE_2DDrawTexturedQuadColor(finalXPoint1, finalYPoint1, finalXPoint2, finalYPoint2, 1, BottomScreenSpritesMaterials[2], RGB15(31, 0, 0)); // Enemies points
            }
        }

        if (bombDropped)
        {
            float bombXPos = map(droppedBombPositionAndRotation.x, -46, 57.5, -170, 170);
            float bombYpos = map(droppedBombPositionAndRotation.z, -41, 67, -177, 177);
            float bombXPoint = ScreenCenterWidth - ((bombXPos - mapXPos) * zWithoutYForMap + (bombYpos - mapYPos) * -xWithoutYForMap) / 2.0;
            float bombYPoint = ScreenCenterHeight + ((bombYpos - mapYPos) * -zWithoutYForMap + (bombXPos - mapXPos) * -xWithoutYForMap) / 2.0;
            float bombFinalXPoint1 = bombXPoint - 4, bombFinalYPoint1 = bombYPoint - 2;
            float bombFinalXPoint2 = bombXPoint + 4, bombFinalYPoint2 = bombYPoint + 4;

            NE_2DDrawTexturedQuadColor(bombFinalXPoint1, bombFinalYPoint1, bombFinalXPoint2, bombFinalYPoint2, 1, TopScreenSpritesMaterials[5], RGB15(31, 0, 0)); // Bomb
        }

        NE_2DDrawTexturedQuadColor(ScreenCenterWidth - 4, ScreenCenterHeight - 2, ScreenCenterWidth + 2, ScreenCenterHeight + 4, 1, BottomScreenSpritesMaterials[2], RGB15(0, 31, 0)); // Background
    }
    else
    {
        // Draw teams indicators
        if (!isInTutorial && currentMap != TUTORIAL)
        {
            int counterCount = 0;
            int terroristCount = 0;
            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Team == SPECTATOR || AllPlayers[i].Id == UNUSED)
                    continue;

                // Add an offset (right or left position for the point)
                int xoffset = 28 + terroristCount * 8;

                // Set grey color for dead players
                int color = ColorTerroristsTeam;
                if (AllPlayers[i].Team == COUNTERTERRORISTS)
                {
                    color = ColorCounterTeam;
                    xoffset = -32 + counterCount * -8;
                    counterCount++;
                }
                else
                {
                    terroristCount++;
                }

                // If the player is dead, set the color to grey
                if (AllPlayers[i].IsDead)
                    color = RGB15(7, 7, 7);

                // Draw point
                NE_2DDrawQuad(ScreenCenterWidth + xoffset, 4, ScreenCenterWidth + 3 + xoffset, 7, 1, color);
                NE_2DDrawQuad(ScreenCenterWidth - 1 + xoffset, 5, ScreenCenterWidth - 1 + 5 + xoffset, 6, 1, color);
                NE_2DDrawQuad(ScreenCenterWidth + 1 + xoffset, 3, ScreenCenterWidth + 2 + xoffset, 8, 1, color);
            }
        }

        // if (true)
        if (isDebugTopScreen)
        {
            // DEBUG show player position
            char PositionText[30];
            sprintf(PositionText, "%f %f %f", localPlayer->position.x, localPlayer->position.y, localPlayer->position.z);
            NE_TextPrint(0,        // Font slot
                         1, 0,     // Coordinates x(column), y(row)
                         NE_White, // Color
                         PositionText);

            // DEBUG show CPU usage
            char CPU[40];

            // sprintf(CPU, "CPU: %d%%, Mem: %d%%", NE_GetCPUPercent(), NE_TextureFreeMemPercent());
            // sprintf(CPU, "%0.3f %0.3f %0.3f", debugValue1, debugValue2, debugValue3);
            // sprintf(CPU, "FREE MEM %d", GetFreeSize());
            sprintf(CPU, "CON %d", Connection);
            // sprintf(CPU, "%0.3f %0.3f %0.3f", debugValue1, debugValue2, debugValue3);
            //  sprintf(CPU, "%d %d", AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].isDualGun, selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]);

            NE_TextPrint(0,        // Font slot
                         1, 1,     // Coordinates x(column), y(row)
                         NE_White, // Color
                         CPU);

            char CPU2[120] = "";
            for (int i = 0; i < MaxPlayer; i++)
            {
                sprintf(CPU2 + strlen(CPU2), "%s %d %d\n", AllPlayers[i].name, AllPlayers[i].Health, AllPlayers[i].armor);
                //  sprintf(CPU2 + strlen(CPU2), "%s %d %d\n", AllPlayers[i].name, AllPlayers[i].Health, AllPlayers[i].armor);
                // sprintf(CPU2 + strlen(CPU2), "%s t%d i%d i%d\n", AllPlayers[i].name, AllPlayers[i].Team, AllPlayers[i].Id, AllPlayers[i].client.id);
                // sprintf(CPU2 + strlen(CPU2), "%s %d %d\n", AllPlayers[i].name, AllPlayers[i].target, AllPlayers[i].lastSeenTarget);
            }

            NE_TextPrint(0,        // Font slot
                         0, 9,     // Coordinates x(column), y(row)
                         NE_White, // Color
                         CPU2);

            // DEBUG show map zone to show
            char Occlusion[20];
            sprintf(Occlusion, "Zone to show: ");
            for (int i = 0; i < allMaps[currentMap].AllZones[localPlayer->CurrentOcclusionZone].ZoneCount; i++)
                sprintf(Occlusion + strlen(Occlusion), "%d ", allMaps[currentMap].AllZones[localPlayer->CurrentOcclusionZone].visibleMapPart[i]);

            NE_TextPrint(0,        // Font slot
                         1, 2,     // Coordinates x(column), y(row)
                         NE_White, // Color
                         Occlusion);
        }

        if (!BombPlanted)
        {
            if (!allPartyModes[currentPartyMode].infiniteTimer && (!localPlayer->IsDead || roundState == TRAINING) && !partyFinished)
            {
                char Timer[30];
                int timerXOffset = 0;
                if (roundState == TRAINING && Connection != OFFLINE)
                {
                    if (PlayerCount != 1)
                    {
                        char forceLaunchText[31];
                        sprintf(forceLaunchText, "Start to vote force launch %d/%d", playerWantToStart, playerWantToStartLimite);
                        int backgroundSize = strlen(forceLaunchText) * 8;
                        int backgroundOffset = 8; // 1*8
                        NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                        NE_2DDrawQuad(backgroundOffset - 1, (6 + TextYOffset) * 8 - 1, backgroundOffset + backgroundSize, (7 + TextYOffset) * 8 + 1, 1, RGB15(3, 3, 3));
                        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                        NE_TextPrint(0,                  // Font slot
                                     1, 6 + TextYOffset, // Coordinates x(column), y(row)
                                     NE_White,           // Color
                                     forceLaunchText);
                    }

                    sprintf(Timer, "Waiting for players ");

                    NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    NE_2DDrawQuad(ScreenCenterWidth - 105, 8, ScreenCenterWidth + 104, 16, 1, RGB15(3, 3, 3));
                    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    timerXOffset = 10;
                }
                else
                {
                    NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    NE_2DDrawQuad(ScreenCenterWidth - 25, 8, ScreenCenterWidth + 24, 16, 1, RGB15(3, 3, 3));
                    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    strncpy(Timer, "", 30);
                }

                // Show party timer if bomb is not planted
                sprintf(Timer + strlen(Timer), "%02d::%02d", PartyMinutes, PartySeconds);

                if (isDebugTopScreen)
                    sprintf(Timer + strlen(Timer), " State: %d", roundState);

                NE_TextPrint(0,                                  // Font slot
                             13 - timerXOffset, 4 + TextYOffset, // Coordinates x(column), y(row)
                             NE_White,                           // Color
                             Timer);
            }

            // Show planting bomb animation
            if (localPlayer->bombTimer < bombPlantingTime && localPlayer->bombTimer > 0 && !localPlayer->IsDead)
            {
                // Draw Background
                NE_PolyFormat(20, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                NE_2DDrawQuad(ScreenWidthDivided4, 155, ScreenWidth - mapInt(localPlayer->bombTimer, -2, bombPlantingTime - 0, ScreenWidthDivided4 * 3, ScreenWidthDivided4), 170, 1, RGB15(3, 3, 3));
                NE_PolyFormat(24, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                NE_2DDrawQuad(84, 140, 176, 155, 1, RGB15(3, 3, 3));
                NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                // Show planting text
                char plantingText[12];
                sprintf(plantingText, "Planting...");
                NE_TextPrint(0,        // Font slot
                             11, 18,   // Coordinates x(column), y(row)
                             NE_White, // Color
                             plantingText);
            }
        }
        else
        {
            // Show defusing bomb animation
            if (localPlayer->bombTimer < bombDefuseTime && localPlayer->bombTimer > 0 && !localPlayer->IsDead)
            {
                // Draw Background
                NE_PolyFormat(20, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                NE_2DDrawQuad(ScreenWidthDivided4, 155, ScreenWidth - mapInt(localPlayer->bombTimer, -2, bombDefuseTime, ScreenWidth / 4 * 3, ScreenWidthDivided4), 170, 1, RGB15(3, 3, 3));
                NE_PolyFormat(24, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                NE_2DDrawQuad(84, 140, 176, 155, 1, RGB15(3, 3, 3));
                NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                // Show defusing text
                char defusingText[12];
                sprintf(defusingText, "Defusing...");
                NE_TextPrint(0,        // Font slot
                             11, 18,   // Coordinates x(column), y(row)
                             NE_White, // Color
                             defusingText);
            }
        }

        if (!allPartyModes[currentPartyMode].noScore)
        {
            NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
            NE_2DDrawQuad(ScreenCenterWidth - 25, 0, ScreenCenterWidth + 24, 8, 1, RGB15(3, 3, 3));
            NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
            // Show party score
            char PartyScore[15];
            //  CountersT score
            sprintf(PartyScore, "%02d  ", CounterScore);

            NE_TextPrint(0,                   // Font slot
                         13, 3 + TextYOffset, // Coordinates x(column), y(row)
                         ColorCounterTeam,    // Color
                         PartyScore);

            // Terrosists score
            sprintf(PartyScore, "%02d", TerroristsScore);

            NE_TextPrint(0,                   // Font slot
                         17, 3 + TextYOffset, // Coordinates x(column), y(row)
                         ColorTerroristsTeam, // Color
                         PartyScore);
        }

        if (Connection != OFFLINE && showPing)
        {
            char PING[8];
            sprintf(PING, "Ping %d", ping);
            // DEBUG for player show ping
            int backgroundSize = strlen(PING) * 8;
            int backgroundOffset = 0; // 1 * 8
            NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
            NE_2DDrawQuad(backgroundOffset, 0, backgroundOffset + backgroundSize, (1) * 8 + 1, 1, RGB15(3, 3, 3));
            NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

            NE_TextPrint(0,        // Font slot
                         0, 0,     // Coordinates x(column), y(row)
                         NE_White, // Color
                         PING);
        }

        // Show event text
        if (textToShowTimer > 0)
        {
            int backgroundSize = strlen(gameEventNotificationText) * 8;
            int backgroundOffset = 1;
            NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
            NE_2DDrawQuad(backgroundOffset, (7 + TextYOffset) * 8 - 1, backgroundOffset + backgroundSize, (8 + TextYOffset) * 8 + 1, 1, RGB15(3, 3, 3));
            NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

            NE_TextPrint(0,                  // Font slot
                         0, 7 + TextYOffset, // Coordinates x(column), y(row)
                         NE_White,           // Color
                         gameEventNotificationText);
        }

        // Show kill text
        if (KillTextShowTimer > 0)
        {
            int currentLine = 0;
            if (notificationType == 0)
            {
                char DamageText[50];
                sprintf(DamageText, killText);

                char *ptr = strtok(DamageText, "{");

                while (ptr != NULL)
                {
                    if (strncmp(ptr, "1", 1) == 0)
                    {
                        NE_TextPrint(0,                            // Font slot
                                     currentLine, 8 + TextYOffset, // Coordinates x(column), y(row)
                                     ColorCounterTeamLiter,        // Color
                                     ptr + 1);
                    }
                    else if (strncmp(ptr, "0", 1) == 0)
                    {
                        NE_TextPrint(0,                            // Font slot
                                     currentLine, 8 + TextYOffset, // Coordinates x(column), y(row)
                                     ColorTerroristsTeam,          // Color
                                     ptr + 1);
                    }
                    else
                    {
                        NE_TextPrint(0,                            // Font slot
                                     currentLine, 8 + TextYOffset, // Coordinates x(column), y(row)
                                     NE_White,                     // Color
                                     ptr + 1);
                    }

                    currentLine += strlen(ptr) - 1;
                    ptr = strtok(NULL, "{");
                }
            }
            else if (notificationType == 1)
            {
                NE_TextPrint(0,                  // Font slot
                             0, 8 + TextYOffset, // Coordinates x(column), y(row)
                             RGB15(31, 31, 31),  // Color
                             killText);

                currentLine = strlen(killText);
            }

            int backgroundSize = currentLine * 8;
            int backgroundOffset = 0;
            NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
            NE_2DDrawQuad(backgroundOffset, (8 + TextYOffset) * 8 - 1, backgroundOffset + backgroundSize, (9 + TextYOffset) * 8 + 1, 1, RGB15(3, 3, 3));
            NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
        }

        if (redHealthTextCounter != 0)
        {
            redHealthTextCounter--;
        }

        if (showShootFriendMessage != 0)
        {
            showShootFriendMessage--;
            NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
            NE_2DDrawQuad(31, 160, 224, 168, 1, RGB15(11, 0, 0));
            NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

            NE_TextPrint(0,        // Font slot
                         4, 20,    // Coordinates x(column), y(row)
                         NE_White, // Color
                         "Don't shoot your friends!");
        }

        if (selectPlayer->Team != SPECTATOR)
        {
            if (!selectPlayer->IsDead)
            {
                if (CurrentCameraPlayer != 0)
                {
                    int selectedPlayerNameLength = strlen(selectPlayer->name);
                    int backgroundSize = selectedPlayerNameLength * 8;
                    int textPosition = maxCharAtScreenDivided2 - selectedPlayerNameLength / 2;
                    int backgroundOffset = textPosition * 8;
                    NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    NE_2DDrawQuad(backgroundOffset, 168, backgroundOffset + backgroundSize, 176, 1, RGB15(3, 3, 3));
                    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                    char ViewedBotName[21] = "";
                    sprintf(ViewedBotName, "%s", selectPlayer->name);
                    NE_TextPrint(0,                // Font slot
                                 textPosition, 21, // Coordinates x(column), y(row)
                                 NE_White,         // Color
                                 ViewedBotName);
                }

                // Show gun ammo
                if (selectPlayer->currentGunInInventory == 1 || selectPlayer->currentGunInInventory == 2)
                {
                    char AmmoText[16];
                    sprintf(AmmoText, "%d/%d", selectPlayer->AllAmmoMagazine[selectPlayer->currentGunInInventory - 1].AmmoCount, selectPlayer->AllAmmoMagazine[selectPlayer->currentGunInInventory - 1].TotalAmmoCount);

                    int backgroundSize = strlen(AmmoText) * 8;
                    int backgroundOffset = 8;
                    NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    NE_2DDrawQuad(backgroundOffset - 1, 175, backgroundOffset + backgroundSize, 184, 1, RGB15(3, 3, 3));
                    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                    NE_TextPrint(0,        // Font slot
                                 1, 22,    // Coordinates x(column), y(row)
                                 NE_White, // Color
                                 AmmoText);
                }

                // Show health
                char HealthText[16];
                sprintf(HealthText, "+%d arm:%d", selectPlayer->Health, selectPlayer->armor);

                int backgroundSize = strlen(HealthText) * 8;
                int backgroundOffset = 8;
                NE_PolyFormat(13, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                NE_2DDrawQuad(backgroundOffset - 1, 183, backgroundOffset + backgroundSize, 193, 1, RGB15(3, 3, 3));
                NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                // Print white text
                if (redHealthTextCounter == 0)
                {
                    NE_TextPrint(0,        // Font slot
                                 1, 23,    // Coordinates x(column), y(row)
                                 NE_White, // Color
                                 HealthText);
                }
                else // Print red text after taking damage
                {
                    int ColorAmount = 31 - redHealthTextCounter / 2;
                    NE_TextPrint(0,                                   // Font slot
                                 1, 23,                               // Coordinates x(column), y(row)
                                 RGB15(31, ColorAmount, ColorAmount), // Color
                                 HealthText);
                }
            }

            if (CurrentScopeLevel == 0) // Draw gun if player doesn't aim with his gun
            {
                // Draw cross air
                NE_SpriteSetParams(TopScreenSprites[0], cursorTransparency * 31, 0, NE_White);
                NE_SpriteDraw(TopScreenSprites[0]);
                NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

                //  Draw gun
                if (!selectPlayer->IsDead)
                {
                    // Set new gun position with head bobbing
                    if (selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory] >= GunCount || !AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].isKnife) // TODO Remove first condition?
                    {
                        rightGunX = GunPositionX + selectPlayer->rightGunXRecoil + sinf(selectPlayer->BobbingOffset) * 4;
                        rightGunY = GunPositionY + 4 + selectPlayer->rightGunYRecoil + cosf(selectPlayer->BobbingOffset * 2) * 6;
                        leftGunX = -selectPlayer->leftGunXRecoil + sinf(selectPlayer->BobbingOffset) * 4;
                        leftGunY = GunPositionY + 4 + selectPlayer->leftGunYRecoil + cosf(selectPlayer->BobbingOffset * 2) * 6;
                    }
                    else
                    {
                        rightGunX = GunPositionX - selectPlayer->rightGunXRecoil + GunMaxRecoil * 1.15 + sinf(selectPlayer->BobbingOffset) * 4;
                        rightGunY = GunPositionY + 4 - selectPlayer->rightGunYRecoil + GunMaxRecoil * 1.4 + cosf(selectPlayer->BobbingOffset * 2) * 6;
                    }

                    if (selectPlayer->isReloading && selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory] < GunCount)
                    {
                        float valueToAdd = sinf((float)selectPlayer->GunReloadWaitCount / (float)AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].ReloadTime * M_PI) * 70;
                        rightGunY += valueToAdd;
                        leftGunY += valueToAdd;
                    }
                    int lightCoef = 31 * selectPlayer->lightCoef;
                    NE_2DDrawTexturedQuadColor(rightGunX, rightGunY, rightGunX + 96, rightGunY + 96, 1, TopScreenSpritesMaterials[1], RGB15(lightCoef, lightCoef, lightCoef));
                    if (selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory] < GunCount && AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].isDualGun)
                    {
                        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_FRONT, NE_MODULATION); // Polygon is inverted for mirroring, so we need to invert the culling
                        NE_2DDrawTexturedQuadColor(leftGunX + 96, leftGunY, leftGunX, leftGunY + 96, 1, TopScreenSpritesMaterials[1], RGB15(lightCoef, lightCoef, lightCoef));
                        NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    }
                }

                // Draw gun muzzle flash
                if (selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory] < GunCount && ShowMuzzle > 0 && !AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].isKnife)
                {
                    NE_PolyFormat(10 * ShowMuzzle, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
                    if (selectPlayer->isRightGun)
                        NE_2DDrawTexturedQuad(rightGunX + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].xMuzzleFlashOffset, rightGunY + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].yMuzzleFlashOffset, rightGunX + 40 + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].xMuzzleFlashOffset, rightGunY + 42 + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].yMuzzleFlashOffset, 2, TopScreenSpritesMaterials[2]); // Gun muzzle flash
                    else
                        NE_2DDrawTexturedQuad(leftGunX + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].xMuzzleFlashOffset + 30, leftGunY + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].yMuzzleFlashOffset, leftGunX + 70 + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].xMuzzleFlashOffset, leftGunY + 42 + AllGuns[selectPlayer->AllGunsInInventory[selectPlayer->currentGunInInventory]].yMuzzleFlashOffset, 2, TopScreenSpritesMaterials[2]); // Gun muzzle flash
                }
            }
            else // Draw scope screen when aiming
            {
                NE_2DDrawQuad(0, 0, 46, 196, 1, RGB15(1, 1, 1));                                        // Left border
                NE_2DDrawQuad(ScreenWidth - 46, 0, ScreenWidth, 196, 1, RGB15(1, 1, 1));                // Right border
                NE_2DDrawQuad(0, 0, ScreenWidth, 12, 1, RGB15(1, 1, 1));                                // Top border
                NE_2DDrawQuad(0, ScreenHeight - 12, ScreenWidth, ScreenHeightFixed, 1, RGB15(1, 1, 1)); // Bottom border

                NE_PolyFormat(10, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);                      // Set alpha
                NE_2DDrawQuad(ScreenCenterWidth, 0, ScreenCenterWidth, 196, 1, NE_Black);           // Top to bottom line
                NE_2DDrawQuad(0, ScreenCenterHeight, ScreenWidth, ScreenCenterHeight, 1, NE_Black); // Left to Right line

                NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION); // Set alpha
                // Draw scope image
                NE_2DDrawTexturedQuad(ScreenCenterWidth - 82, ScreenCenterHeight - 84, ScreenCenterWidth + 82, ScreenCenterHeight + 84, 1, TopScreenSpritesMaterials[3]); // Circle
            }
        }

        float totalDis = 0;
        int totalEndAnimation = 0;
        for (int i = 0; i < GrenadeCount; i++)
        {
            if (grenades[i] != NULL && grenades[i]->GrenadeType == SMOKE && grenades[i]->Timer == 0)
            {
                // Calculate distances
                float smokeDistance = sqrtf(powf(selectPlayer->PlayerModel->x - grenades[i]->Model->x, 2.0) + powf(selectPlayer->PlayerModel->y - grenades[i]->Model->y, 2.0) + powf(selectPlayer->PlayerModel->z - grenades[i]->Model->z, 2.0)) / 26000.0; // fFor smoke detection

                // Set a minimum limit to the smoke detection distance
                if (smokeDistance > 1)
                {
                    smokeDistance = 1;
                }
                // Invert distance (more distance decrease the value)
                smokeDistance = map(1 - smokeDistance, 0, 0.2, 0, 1);
                totalDis += smokeDistance;
                totalEndAnimation += grenades[i]->EffectTimer;

                if (totalDis >= 1)
                {
                    totalDis = 1;
                    isInFullSmoke = true;
                    break;
                }
            }
        }

        // If player is in a smoke area
        if (totalDis > 0)
        {
            if (totalEndAnimation > 20)
            {
                totalEndAnimation = 20;
            }

            // Calculate smoke screen alpha
            totalEndAnimation = map(totalEndAnimation, 0, 20, 31, 0);
            int finalAlpha = 31 * totalDis - totalEndAnimation;
            if (finalAlpha < 0)
                finalAlpha = 0;

            NE_PolyFormat(finalAlpha, 1, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION); // Set alpha
            // Draw smoke screen
            NE_2DDrawQuad(0, 0, ScreenWidth, ScreenHeightFixed, 0, RGB15(9, 9, 9));
        }
    }
    showDialog();
    for (int i = 0; i < MaxPlayer; i++)
    {
        Player *player = &AllPlayers[i];

        // If player is flashed, show white screen
        if (player->flashed)
        {
            if (player->IsDead || player->Id == NO_PLAYER)
            {
                player->flashed = false;
                player->flashAnimation = 0;
                continue;
            }

            player->flashAnimation += flashAnimationSpeed;

            int alpha = 31;
            if (player->flashAnimation < flashAnimationSpeed * 5.0)
            {
                alpha = (int)((player->flashAnimation / (flashAnimationSpeed * 5.0)) * 31.0);
            }
            else if (player->flashAnimation >= flashAnimationSpeed * 120.0)
            {
                alpha = map(player->flashAnimation, flashAnimationSpeed * 120.0, 1, 31, 0);
            }
            if (alpha < 1)
                alpha = 1;

            if (!isShowingMap && !isShowingKeyBoard && selectPlayer == player)
            {
                NE_PolyFormat(alpha, 1, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION); // Set alpha
                NE_2DDrawQuad(0, 0, ScreenWidth, ScreenHeightFixed, 0, RGB15(31, 31, 31));
            }

            if (player->flashAnimation >= 1)
            {
                player->flashed = false;
                player->flashAnimation = 0;
            }
        }
    }
    if (KillTextShowTimer > 0)
        KillTextShowTimer--;

    if (textToShowTimer > 0)
        textToShowTimer--;

    // Reduce muzzle timer
    if (ShowMuzzle > 0)
        ShowMuzzle--;
}

/**
 * @brief Draw bottom screen UI
 *
 */
void drawBottomScreenUI()
{
    // Set view in 2D mode
    NE_2DViewInit();

    if (isShowingKeyBoard)
    {
        drawKeyBoard();
    }
    else
    {
        // Draw quit button
        NE_SpriteDraw(BottomScreenSprites[0]);

        // Draw menu background
        NE_2DDrawQuad(0, 0, 256, 196, 20, RGB15(3, 3, 3));

        // Draw the menu
        renderFunction();

        // Draw menu elements
        drawButtons();
        drawCheckboxs();
        drawSliders();
    }
    // Change screen update mode (30 fps with 2 screens update or 60 fps with main game screen update)
    if (NeedChangeScreen)
    {
        NeedChangeScreen = false;
        AlwaysUpdateBottomScreen = !AlwaysUpdateBottomScreen;
        UpdateBottomScreenFrameCount = 4;
    }
}

/**
 * @brief Init in game menu
 *
 */
void initGameMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(GAME);

    renderFunction = &drawGameMenu;

    lastOpenedMenu = &initGameMenu;

    setQuitButton(false);

    // Show score button
    AllButtons[0].xPos = 80;
    AllButtons[0].yPos = 104;
    AllButtons[0].xSize = 100;
    AllButtons[0].ySize = 24;
    AllButtons[0].OnClick = &initScoreMenu;
    AllButtons[0].xTextPos = 12;
    AllButtons[0].yTextPos = 14;
    if (localPlayer->Team == SPECTATOR)
        AllButtons[0].text = "Choose team";
    else
        AllButtons[0].text = "Show score";

    // Open shop categories button
    AllButtons[1].xPos = 80;
    AllButtons[1].yPos = 72;
    AllButtons[1].xSize = 100;
    AllButtons[1].ySize = 24;
    AllButtons[1].OnClick = &initShopCategoriesMenu;
    AllButtons[1].xTextPos = 12;
    AllButtons[1].yTextPos = 10;
    AllButtons[1].text = "Open shop";

    // Settings button
    AllButtons[2].xPos = 80;
    AllButtons[2].yPos = 136;
    AllButtons[2].xSize = 100;
    AllButtons[2].ySize = 24;
    AllButtons[2].OnClick = &initSettingsMenu;
    AllButtons[2].xTextPos = 12;
    AllButtons[2].yTextPos = 18;
    AllButtons[2].text = "Settings";

    // Quit game button
    AllButtons[3].xPos = 80;
    AllButtons[3].yPos = 168;
    AllButtons[3].xSize = 100;
    AllButtons[3].ySize = 24;
    AllButtons[3].OnClick = &initQuitMenu;
    AllButtons[3].xTextPos = 12;
    AllButtons[3].yTextPos = 22;
    AllButtons[3].text = "Quit game";

    // Game pad button
    AllButtons[4].xPos = 80;
    AllButtons[4].yPos = 40;
    AllButtons[4].xSize = 100;
    AllButtons[4].ySize = 24;
    AllButtons[4].OnClick = &initControllerMenu;
    AllButtons[4].xTextPos = 13;
    AllButtons[4].yTextPos = 6;
    AllButtons[4].text = "Gamepad";

    if (AllPlayers[0].Team == SPECTATOR)
    {
        AllButtons[1].isHidden = true;
        AllButtons[4].isHidden = true;
    }
    if (isInTutorial)
    {
        AllButtons[0].isHidden = true;
        AllButtons[1].isHidden = true;
    }

    SetButtonToShow(5);
}

/**
 * @brief Init score menu
 *
 */
void initScoreMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(SCORE_BOARD);

    renderFunction = &drawScoreMenu;

    lastOpenedMenu = &initGameMenu;

    setQuitButton(true);

    if (AllPlayers[0].Team == -1)
    {
        // Join counter button
        AllButtons[0].xPos = 18; // 128-20-90
        AllButtons[0].yPos = 169;
        AllButtons[0].xSize = 90;
        AllButtons[0].ySize = 20;
        AllButtons[0].OnClick = &SetTeam;
        AllButtons[0].parameter = COUNTERTERRORISTS;
        AllButtons[0].xTextPos = 6;
        AllButtons[0].yTextPos = 22;
        AllButtons[0].text = "Join";

        // Join terrorists button
        AllButtons[1].xPos = 148; // 128+20
        AllButtons[1].yPos = 169;
        AllButtons[1].xSize = 90;
        AllButtons[1].ySize = 20;
        AllButtons[1].OnClick = &SetTeam;
        AllButtons[1].parameter = TERRORISTS;
        AllButtons[1].xTextPos = 22;
        AllButtons[1].yTextPos = 22;
        AllButtons[1].text = "Join";

        SetButtonToShow(2);
    }
    else
        SetButtonToShow(0);

    showFinalScore = false;
}

/**
 * @brief Init final score menu
 *
 */
void initFinalScoreMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(FINAL_SCORE);

    renderFunction = &drawScoreMenu;

    lastOpenedMenu = &initMainMenu;

    setQuitButton(true);

    totalFinishedParty++;

    if ((CounterScore > TerroristsScore && localPlayer->Team == COUNTERTERRORISTS) || (TerroristsScore > CounterScore && localPlayer->Team == TERRORISTS))
    {
        totalWins++;
    }

    uiTimer = 8;
    actionOfUiTimer = SAVE;

    showFinalScore = true;
}

/**
 * @brief Init shop categories menu
 *
 */
void initShopCategoriesMenu()
{
    if (!localPlayer->IsDead && (shopDisableTimer != 0 || !allPartyModes[currentPartyMode].limitedShopByZoneAndTimer) && isInShopZone)
    {
        SetTwoScreenMode(false);

        startChangeMenu(SHOPCATEGORIES);

        renderFunction = &drawShopCategoriesMenu;

        lastOpenedMenu = &initGameMenu;

        setQuitButton(true);

        for (int buttonIndex = 0; buttonIndex < 6; buttonIndex++)
        {
            // Set all categories buttons
            AllButtons[buttonIndex].xPos = (ScreenWidth / 2) * (buttonIndex / 3);
            AllButtons[buttonIndex].yPos = ((198 - 23) / 3) * (buttonIndex % 3) + 23;
            AllButtons[buttonIndex].xSize = ScreenWidth / 2;
            AllButtons[buttonIndex].ySize = (198 - 23) / 3;
            AllButtons[buttonIndex].OnClick = &OpenShopCategory;
            AllButtons[buttonIndex].parameter = buttonIndex;
            AllButtons[buttonIndex].text = "";
        }
        SetButtonToShow(6);
    }
}

/**
 * @brief Init settings menu
 *
 */
void initSettingsMenu()
{
    SetTwoScreenMode(true);

    startChangeMenu(SETTINGS);

    renderFunction = &drawSettingsMenu;

    if (Connection == UNSELECTED)
        lastOpenedMenu = &initMainMenu;
    else
        lastOpenedMenu = &initGameMenu;

    setQuitButton(true);

    // Set rumble checkbox
    AllCheckBoxs[0].xPos = 58;
    AllCheckBoxs[0].yPos = 56;
    AllCheckBoxs[0].xSize = 20;
    AllCheckBoxs[0].ySize = 20;
    AllCheckBoxs[0].value = &useRumble;

    // Set show ping checkbox
    AllCheckBoxs[1].xPos = 180;
    AllCheckBoxs[1].yPos = 56;
    AllCheckBoxs[1].xSize = 20;
    AllCheckBoxs[1].ySize = 20;
    AllCheckBoxs[1].value = &showPing;

    // Set change name button
    AllButtons[0].xPos = 15;
    AllButtons[0].yPos = 88;
    AllButtons[0].xSize = 100;
    AllButtons[0].ySize = 24;
    AllButtons[0].OnClick = &initChangeNameMenu;
    AllButtons[0].xTextPos = 3;
    AllButtons[0].yTextPos = 12;
    AllButtons[0].text = "Change name";

    // Set change controls button
    AllButtons[1].xPos = 140;
    AllButtons[1].yPos = 88;
    AllButtons[1].xSize = 100;
    AllButtons[1].ySize = 24;
    AllButtons[1].OnClick = &initControlsSettingsMenu;
    AllButtons[1].xTextPos = 20;
    AllButtons[1].yTextPos = 12;
    AllButtons[1].text = "Controls";

    AllButtons[2].xPos = 140;
    AllButtons[2].yPos = 137;
    AllButtons[2].xSize = 100;
    AllButtons[2].ySize = 23;
    AllButtons[2].OnClick = &changeKeyboardMode;
    AllButtons[2].xTextPos = 21;
    AllButtons[2].yTextPos = 18;
    updateKeyboardModeButton();

    AllSliders[0].xPos = 20;
    AllSliders[0].yPos = 158;
    AllSliders[0].xSize = 100;
    AllSliders[0].min = 0;
    AllSliders[0].max = 1;
    AllSliders[0].step = 0.1;
    AllSliders[0].value = &cursorTransparency;

    SetSliderToShow(1);
    SetButtonToShow(3);
    SetCheckBoxToShow(2);
}

/**
 * @brief Init change name menu
 *
 */
void initChangeNameMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(CHANGENAME);
    onCloseMenu = &unloadChangeNameMenu;
    haveToCallOnCloseMenu = true;
    renderFunction = &drawChangeNameMenu;

    setQuitButton(true);

    isShowingKeyBoard = true;
    returnToMenuOnCancel = SETTINGS;
    returnToMenuOnSucces = SETTINGS;
    keyboardAction = KEYBOARD_ACTION_CHANGE_NAME;
    onKeyboardCloseSucces = &ChangeMenu;
    onKeyboardCloseCancel = &ChangeMenu;
    maxInputLength = 13;
    minInputLength = 1;
    SetCanChangeCase(true);

    isUpperCase = false;
    strncpy(tempText, localPlayer->name, 21);
}

/**
 * @brief Init quit menu
 *
 */
void initQuitMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(QUIT);

    renderFunction = &drawQuitMenu;

    setQuitButton(false);

    // No button
    AllButtons[0].xPos = ScreenWidth - 80 - 40;
    AllButtons[0].yPos = 98;
    AllButtons[0].xSize = 80;
    AllButtons[0].ySize = 20;
    AllButtons[0].OnClick = &initGameMenu;
    AllButtons[0].xTextPos = 21;
    AllButtons[0].yTextPos = 13;
    AllButtons[0].text = "No";

    // Yes button
    AllButtons[1].xPos = 40;
    AllButtons[1].yPos = 98;
    AllButtons[1].xSize = 80;
    AllButtons[1].ySize = 20;
    AllButtons[1].OnClick = &QuitParty;
    AllButtons[1].xTextPos = 9;
    AllButtons[1].yTextPos = 13;
    AllButtons[1].text = "Yes";

    SetButtonToShow(2);
}

/**
 * @brief Init shop menu
 *
 */
void initShopMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(SHOP);

    renderFunction = &drawShopMenu;

    onCloseMenu = &unloadShopMenu;
    haveToCallOnCloseMenu = true;

    lastOpenedMenu = &initShopCategoriesMenu;

    BottomScreenSpritesMaterials[6] = NE_MaterialCreate();
    Palettes[10] = NE_PaletteCreate();
    if (ShopCategory < EQUIPMENT)
        NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], AllGuns[GetSelectedGunShop()].texture, 1);
    else if (ShopCategory == GRENADES)
        NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], GetAllGrenades()[GetSelectedGunShop() - GunCount].texture, 1);
    else if (ShopCategory == EQUIPMENT)
        NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], GetAllGrenades()[GetSelectedGunShop() - GunCount - shopGrenadeCount].texture, 1);
    setQuitButton(true);

    // Buy button
    AllButtons[0].xPos = 88;
    AllButtons[0].yPos = 170;
    AllButtons[0].xSize = 80;
    AllButtons[0].ySize = 20;
    AllButtons[0].OnClick = &BuyWeapon;
    AllButtons[0].parameter = 0;
    AllButtons[0].xTextPos = 14;
    AllButtons[0].yTextPos = 22;
    AllButtons[0].text = "Buy!";

    // Left button
    AllButtons[1].xPos = 48;
    AllButtons[1].yPos = 170;
    AllButtons[1].xSize = 30;
    AllButtons[1].ySize = 20;
    AllButtons[1].OnClick = &ChangeShopElement;
    AllButtons[1].parameter = 1;
    AllButtons[1].xTextPos = 7;
    AllButtons[1].yTextPos = 22;
    AllButtons[1].text = "<-";

    // Right button
    AllButtons[2].xPos = 88 + 80 + 10;
    AllButtons[2].yPos = 170;
    AllButtons[2].xSize = 30;
    AllButtons[2].ySize = 20;
    AllButtons[2].OnClick = &ChangeShopElement;
    AllButtons[2].parameter = 0;
    AllButtons[2].xTextPos = 23;
    AllButtons[2].yTextPos = 22;
    AllButtons[2].text = "->";

    SetButtonToShow(3);
}

/**
 * @brief Init game pad menu
 *
 */
void initControllerMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(CONTROLLER);

    renderFunction = &drawControllerMenu;

    onCloseMenu = &unloadControllerMenu;
    haveToCallOnCloseMenu = true;
    lastOpenedMenu = &initGameMenu;

    setQuitButton(true);

    BottomScreenSpritesMaterials[7] = NE_MaterialCreate();
    Palettes[14] = NE_PaletteCreate();
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[7], Palettes[14], (void *)JumpArrow_bin, 1);

    BottomScreenSpritesMaterials[8] = NE_MaterialCreate();
    Palettes[15] = NE_PaletteCreate();
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[8], Palettes[15], (void *)reload_bin, 1);

    int buttonXPosition = 2;
    int mapButtonXPosition = 2;
    int mapTextXPosition = 1;
    int textXPosition = 2;
    if (isLeftControls)
    {
        buttonXPosition = 218; // 256 - 36 - 2
        mapButtonXPosition = 193;
        mapTextXPosition = 25;
        textXPosition = 29;
    }

    // Jump button
    AllButtons[0].xPos = buttonXPosition;
    AllButtons[0].yPos = 30;
    AllButtons[0].xSize = 36;
    AllButtons[0].ySize = 36;
    AllButtons[0].OnClick = &SetNeedJump;
    AllButtons[0].parameter = 0;
    AllButtons[0].text = "";

    // Reload button
    AllButtons[1].xPos = buttonXPosition;
    AllButtons[1].yPos = 72;
    AllButtons[1].xSize = 36;
    AllButtons[1].ySize = 36;
    AllButtons[1].OnClick = &startReloadGun;
    AllButtons[1].parameter = 0;
    AllButtons[1].text = "";

    // Right button
    AllButtons[2].xPos = buttonXPosition;
    AllButtons[2].yPos = 114;
    AllButtons[2].xSize = 36;
    AllButtons[2].ySize = 36;
    AllButtons[2].OnClick = &ChangeGunInInventoryForLocalPlayer;
    AllButtons[2].parameter = 0;
    AllButtons[2].xTextPos = textXPosition;
    AllButtons[2].yTextPos = 16;
    AllButtons[2].text = ">";

    // Left button
    AllButtons[3].xPos = buttonXPosition;
    AllButtons[3].yPos = 156;
    AllButtons[3].xSize = 36;
    AllButtons[3].ySize = 36;
    AllButtons[3].OnClick = &ChangeGunInInventoryForLocalPlayer;
    AllButtons[3].parameter = 1;
    AllButtons[3].xTextPos = textXPosition;
    AllButtons[3].yTextPos = 21;
    AllButtons[3].text = "<";

    // Map button
    AllButtons[4].xPos = mapButtonXPosition;
    AllButtons[4].yPos = 2;
    AllButtons[4].xSize = 36;
    AllButtons[4].ySize = 20;
    AllButtons[4].OnClick = &changeMapState;
    AllButtons[4].parameter = 0;
    AllButtons[4].xTextPos = mapTextXPosition;
    AllButtons[4].yTextPos = 1;
    AllButtons[4].text = "Map";
    if (currentMap == TUTORIAL)
        AllButtons[4].isHidden = true;
    else
        AllButtons[4].isHidden = false;

    SetButtonToShow(5);
}

/**
 * @brief Init main menu
 *
 */
void initMainMenu()
{
    SetTwoScreenMode(true);

    startChangeMenu(MAIN);

    renderFunction = &drawMainMenu;

    lastOpenedMenu = &initMainMenu;

    if (Connection != OFFLINE && Connection != UNSELECTED)
    {
        SendLeave = true;
    }
    Connection = UNSELECTED;

    setQuitButton(false);

    removeAllPlayers();

    if (isInTutorial)
    {
        endTutorial();
        uiTimer = 8;
        actionOfUiTimer = SAVE;
    }

    // Single player button
    AllButtons[0].xPos = 40;
    AllButtons[0].yPos = 40;
    AllButtons[0].xSize = ScreenWidth - 80;
    AllButtons[0].ySize = 24;
    AllButtons[0].OnClick = &initSelectionMapImageMenu;
    AllButtons[0].parameter = 0;
    AllButtons[0].xTextPos = 10;
    AllButtons[0].yTextPos = 6;
    AllButtons[0].text = "Single Player";

    // Multiplayer button
    AllButtons[1].xPos = 40;
    AllButtons[1].yPos = 87;
    AllButtons[1].xSize = ScreenWidth - 80;
    AllButtons[1].ySize = 24;
    AllButtons[1].OnClick = &initJoinCreatePartyMenu;
    AllButtons[1].isHidden = false;
    AllButtons[1].xTextPos = 11;
    AllButtons[1].yTextPos = 12;
    AllButtons[1].text = "Multiplayer";

    // Settings button
    AllButtons[2].xPos = 40;
    AllButtons[2].yPos = 135;
    AllButtons[2].xSize = ScreenWidth - 80;
    AllButtons[2].ySize = 24;
    AllButtons[2].OnClick = &initSettingsMenu;
    AllButtons[2].xTextPos = 12;
    AllButtons[2].yTextPos = 18;
    AllButtons[2].text = "Settings";

    AllButtons[3].xPos = 76;
    AllButtons[3].yPos = 170;
    AllButtons[3].xSize = ScreenWidth - 160;
    AllButtons[3].ySize = 20;
    AllButtons[3].OnClick = &initStatsMenu;
    AllButtons[3].xTextPos = 13;
    AllButtons[3].yTextPos = 22;
    AllButtons[3].text = "Stats";

    launchMusic();

    SetButtonToShow(4);
}

/**
 * @brief Init chat menu (TODO)
 *
 */
void initChatMenu()
{
    // To Fill
}

/**
 * @brief Init controls settings menu
 *
 */
void initControlsSettingsMenu()
{

    SetTwoScreenMode(true);

    startChangeMenu(CONTROLSSETTINGS);

    renderFunction = &drawControlsSettingsMenu;

    lastOpenedMenu = &initSettingsMenu;

    setQuitButton(true);

    // Set rumble checkbox
    AllCheckBoxs[0].xPos = 58;
    AllCheckBoxs[0].yPos = 56;
    AllCheckBoxs[0].xSize = 20;
    AllCheckBoxs[0].ySize = 20;
    AllCheckBoxs[0].value = &isLeftControls;

    // Set change controls button
    AllButtons[0].xPos = 140;
    AllButtons[0].yPos = 40;
    AllButtons[0].xSize = 100;
    AllButtons[0].ySize = 32;
    AllButtons[0].OnClick = &initControlsChangeMenu;
    AllButtons[0].xTextPos = 17;
    AllButtons[0].yTextPos = 6;
    AllButtons[0].text = "";

    AllSliders[0].xPos = 140;
    AllSliders[0].yPos = 148;
    AllSliders[0].xSize = 100;
    AllSliders[0].min = MIN_SENSITIVITY;
    AllSliders[0].max = MAX_SENSITIVITY;
    AllSliders[0].step = 0.1;
    AllSliders[0].value = &sensitivity;

    AllSliders[1].xPos = 20;
    AllSliders[1].yPos = 148;
    AllSliders[1].xSize = 100;
    AllSliders[1].min = MIN_SENSITIVITY;
    AllSliders[1].max = MAX_SENSITIVITY;
    AllSliders[1].step = 0.1;
    AllSliders[1].value = &buttonsSensitivity;

    SetSliderToShow(2);
    SetButtonToShow(1);
    SetCheckBoxToShow(1);
}

/**
 * @brief Init controls change menu
 *
 */
void initControlsChangeMenu()
{
    SetTwoScreenMode(true);

    startChangeMenu(CONTROLSCHANGE);

    renderFunction = &drawControlsChangeMenu;

    lastOpenedMenu = &initControlsSettingsMenu;

    onCloseMenu = &unloadControlsChangeMenu;
    haveToCallOnCloseMenu = true;

    setQuitButton(true);

    // Set change controls button
    AllButtons[0].xPos = 15;
    AllButtons[0].yPos = 167;
    AllButtons[0].xSize = 100;
    AllButtons[0].ySize = 24;
    AllButtons[0].OnClick = &changeControlsPage;
    AllButtons[0].parameter = 1;
    AllButtons[0].xTextPos = 7;
    AllButtons[0].yTextPos = 22;
    AllButtons[0].text = "<-";

    AllButtons[1].xPos = 140;
    AllButtons[1].yPos = 167;
    AllButtons[1].xSize = 100;
    AllButtons[1].ySize = 24;
    AllButtons[1].OnClick = &changeControlsPage;
    AllButtons[1].parameter = 0;
    AllButtons[1].xTextPos = 23;
    AllButtons[1].yTextPos = 22;
    AllButtons[1].text = "->";

    // Set change controls button
    AllButtons[2].xPos = 15;
    AllButtons[2].yPos = 40;
    AllButtons[2].xSize = 100;
    AllButtons[2].ySize = 24;
    AllButtons[2].OnClick = &startScanForInput;
    if (controlsPage == 0)
    {
        AllButtons[2].parameter = FIRE_BUTTON;
        AllButtons[2].xTextPos = 6;
        AllButtons[2].yTextPos = 4;
        AllButtons[2].text = "Fire";

        AllButtons[3].parameter = JUMP_BUTTON;
        AllButtons[3].xTextPos = 22;
        AllButtons[3].yTextPos = 4;
        AllButtons[3].text = "Jump";

        AllButtons[4].parameter = LEFT_BUTTON;
        AllButtons[4].xTextPos = 4;
        AllButtons[4].yTextPos = 9;
        AllButtons[4].text = "Move left";

        AllButtons[5].parameter = RIGHT_BUTTON;
        AllButtons[5].xTextPos = 19;
        AllButtons[5].yTextPos = 9;
        AllButtons[5].text = "Move right";

        AllButtons[6].parameter = UP_BUTTON;
        AllButtons[6].xTextPos = 3;
        AllButtons[6].yTextPos = 14;
        AllButtons[6].text = "Move forward";

        AllButtons[7].parameter = DOWN_BUTTON;
        AllButtons[7].xTextPos = 18;
        AllButtons[7].yTextPos = 14;
        AllButtons[7].text = "Move backward";

        SetButtonToShow(8);
    }
    else if (controlsPage == 1)
    {
        AllButtons[2].parameter = LOOK_LEFT_BUTTON;
        AllButtons[2].xTextPos = 4;
        AllButtons[2].yTextPos = 4;
        AllButtons[2].text = "Look left";

        AllButtons[3].parameter = LOOK_RIGHT_BUTTON;
        AllButtons[3].xTextPos = 19;
        AllButtons[3].yTextPos = 4;
        AllButtons[3].text = "Look right";

        AllButtons[4].parameter = LOOK_UP_BUTTON;
        AllButtons[4].xTextPos = 5;
        AllButtons[4].yTextPos = 9;
        AllButtons[4].text = "Look up";

        AllButtons[5].parameter = LOOK_DOWN_BUTTON;
        AllButtons[5].xTextPos = 19;
        AllButtons[5].yTextPos = 9;
        AllButtons[5].text = "Look down";

        AllButtons[6].parameter = DEFUSE_BUTTON;
        AllButtons[6].xTextPos = 5;
        AllButtons[6].yTextPos = 14;
        AllButtons[6].text = "Defuse";

        AllButtons[7].parameter = SCOPE_BUTTON;
        AllButtons[7].xTextPos = 21;
        AllButtons[7].yTextPos = 14;
        AllButtons[7].text = "Scope";

        SetButtonToShow(8);
    }
    else if (controlsPage == 2)
    {
        AllButtons[2].parameter = LEFT_GUN;
        AllButtons[2].xTextPos = 1;
        AllButtons[2].yTextPos = 4;
        AllButtons[2].text = "Previous weapon";

        AllButtons[3].parameter = RIGHT_GUN;
        AllButtons[3].xTextPos = 18;
        AllButtons[3].yTextPos = 4;
        AllButtons[3].text = "Next weapon";

        SetButtonToShow(4);
    }

    AllButtons[3].xPos = 140;
    AllButtons[3].yPos = 40;
    AllButtons[3].xSize = 100;
    AllButtons[3].ySize = 24;
    AllButtons[3].OnClick = &startScanForInput;

    // Set change controls button
    AllButtons[4].xPos = 15;
    AllButtons[4].yPos = 80;
    AllButtons[4].xSize = 100;
    AllButtons[4].ySize = 24;
    AllButtons[4].OnClick = &startScanForInput;

    AllButtons[5].xPos = 140;
    AllButtons[5].yPos = 80;
    AllButtons[5].xSize = 100;
    AllButtons[5].ySize = 24;
    AllButtons[5].OnClick = &startScanForInput;

    // Set change controls button
    AllButtons[6].xPos = 15;
    AllButtons[6].yPos = 120;
    AllButtons[6].xSize = 100;
    AllButtons[6].ySize = 24;
    AllButtons[6].OnClick = &startScanForInput;

    AllButtons[7].xPos = 140;
    AllButtons[7].yPos = 120;
    AllButtons[7].xSize = 100;
    AllButtons[7].ySize = 24;
    AllButtons[7].OnClick = &startScanForInput;
}

/**
 * @brief Init map slection with image menu
 *
 */
void initSelectionMapImageMenu()
{
    SetTwoScreenMode(true);

    startChangeMenu(MAP_SELECTION_IMAGE);

    renderFunction = &drawSelectionMapImageMenu;

    lastOpenedMenu = &initMainMenu;

    onCloseMenu = &unloadSelectionMapImageMenu;
    haveToCallOnCloseMenu = true;

    setQuitButton(true);

    BottomScreenSpritesMaterials[6] = NE_MaterialCreate();
    Palettes[10] = NE_PaletteCreate();
    NE_MaterialTexLoadBMPtoRGB256(BottomScreenSpritesMaterials[6], Palettes[10], allMaps[currentSelectionMap].image, 1);

    // Set change controls button
    AllButtons[0].xPos = 35;
    AllButtons[0].yPos = 164;
    AllButtons[0].xSize = 40;
    AllButtons[0].ySize = 32;
    AllButtons[0].OnClick = &ChangeMap;
    AllButtons[0].parameter = 0;
    AllButtons[0].xTextPos = 6;
    AllButtons[0].yTextPos = 22;
    AllButtons[0].text = "<-";

    AllButtons[1].xPos = 256 - 35 - 40;
    AllButtons[1].yPos = 164;
    AllButtons[1].xSize = 40;
    AllButtons[1].ySize = 32;
    AllButtons[1].OnClick = &ChangeMap;
    AllButtons[1].parameter = 1;
    AllButtons[1].xTextPos = 24;
    AllButtons[1].yTextPos = 22;
    AllButtons[1].text = "->";

    AllButtons[2].xPos = 256 / 2 - 40;
    AllButtons[2].yPos = 164;
    AllButtons[2].xSize = 80;
    AllButtons[2].ySize = 32;
    AllButtons[2].OnClick = &AskGameMode;
    AllButtons[2].xTextPos = 14;
    AllButtons[2].yTextPos = 22;
    AllButtons[2].text = "Start";

    SetButtonToShow(3);
}

/**
 * @brief Init map selection as basic list (not implemented, maybe to remove)
 *
 */
void initSelectionMapListMenu()
{
    SetTwoScreenMode(true);

    startChangeMenu(MAP_SELECTION_LIST);

    renderFunction = &drawSelectionMapListMenu;

    lastOpenedMenu = &initSelectionMapImageMenu;

    setQuitButton(true);

    // Set change controls button
    AllButtons[0].xPos = 40;
    AllButtons[0].yPos = 40;
    AllButtons[0].xSize = 100;
    AllButtons[0].ySize = 32;
    AllButtons[0].OnClick = &initControlsChangeMenu;
    AllButtons[0].xTextPos = 5;
    AllButtons[0].yTextPos = 6;
    AllButtons[0].text = "<-";

    AllButtons[1].xPos = 140;
    AllButtons[1].yPos = 40;
    AllButtons[1].xSize = 100;
    AllButtons[1].ySize = 32;
    AllButtons[1].OnClick = &initControlsChangeMenu;
    AllButtons[1].xTextPos = 17;
    AllButtons[1].yTextPos = 6;
    AllButtons[1].text = "->";

    SetButtonToShow(2);
}

/**
 * @brief Init online error menu
 *
 */
void initPartyModeSelectionMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(PARTY_MODE_SELECTION_LIST);

    renderFunction = &drawPartyModeSelectionMenu;
    lastOpenedMenu = &initSelectionMapImageMenu;

    // Single player button
    AllButtons[0].xPos = 40;
    AllButtons[0].yPos = 56;
    AllButtons[0].xSize = ScreenWidth - 80;
    AllButtons[0].ySize = 24;
    AllButtons[0].OnClick = &StartSinglePlayer;
    AllButtons[0].parameter = 1;
    AllButtons[0].xTextPos = 13;
    AllButtons[0].yTextPos = 8;
    AllButtons[0].text = "Casual";

    // Multiplayer button
    AllButtons[1].xPos = 40;
    AllButtons[1].yPos = 119;
    AllButtons[1].xSize = ScreenWidth - 80;
    AllButtons[1].ySize = 24;
    AllButtons[1].OnClick = &StartSinglePlayer;
    AllButtons[1].parameter = 0;
    AllButtons[1].isHidden = false;
    AllButtons[1].xTextPos = 11;
    AllButtons[1].yTextPos = 16;
    AllButtons[1].text = "Competitive";

    SetButtonToShow(2);
    setQuitButton(true);
}

/**
 * @brief Init multiplayer menu
 *
 */
void initJoinCreatePartyMenu()
{
    SetTwoScreenMode(true);

    startChangeMenu(JOIN_CREATE_PARTY);

    renderFunction = &drawJoinCreatePartyMenu;

    lastOpenedMenu = &initMainMenu;

    setQuitButton(true);

    // Set change controls button
    AllButtons[0].xPos = 36;
    AllButtons[0].yPos = 44;
    AllButtons[0].xSize = 190;
    AllButtons[0].ySize = 32;
    AllButtons[0].OnClick = &JoinParty;
    AllButtons[0].parameter = JOIN_RANDOM_PARTY;
    AllButtons[0].xTextPos = 7;
    AllButtons[0].yTextPos = 7;
    AllButtons[0].text = "Join a random party";

    AllButtons[1].xPos = 36;
    AllButtons[1].yPos = 92;
    AllButtons[1].xSize = 190;
    AllButtons[1].ySize = 32;
    AllButtons[1].OnClick = &initEnterCodeMenu;
    AllButtons[1].xTextPos = 6;
    AllButtons[1].yTextPos = 13;
    AllButtons[1].text = "Join a private party";

    AllButtons[2].xPos = 36;
    AllButtons[2].yPos = 140;
    AllButtons[2].xSize = 190;
    AllButtons[2].ySize = 32;
    AllButtons[2].OnClick = &JoinParty;
    AllButtons[2].parameter = CREATE_PRIVATE_PARTY;
    AllButtons[2].xTextPos = 5;
    AllButtons[2].yTextPos = 19;
    AllButtons[2].text = "Create a private party";

    SetButtonToShow(3);
}

/**
 * @brief Init enter code menu
 *
 */
void initEnterCodeMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(ENTER_CODE);

    renderFunction = &drawEnterCodeMenu;

    isShowingKeyBoard = true;
    returnToMenuOnCancel = JOIN_CREATE_PARTY;
    returnToMenuOnSucces = 2;
    keyboardAction = KEYBOARD_ACTION_ENTER_CODE;

    onKeyboardCloseCancel = &ChangeMenu;
    onKeyboardCloseSucces = &JoinParty;

    maxInputLength = 5;
    minInputLength = 5;
    SetCanChangeCase(false);
    isUpperCase = true;
    strncpy(tempText, "", 21);
}

/**
 * @brief Init online error menu
 *
 */
void initOnlineErrorMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(ONLINE_ERROR);

    renderFunction = &drawOnlineErrorMenu;
    lastOpenedMenu = &initMainMenu;

    setQuitButton(true);
}

void initStatsMenu()
{
    SetTwoScreenMode(false);

    startChangeMenu(STATS);

    renderFunction = &drawStatsMenu;
    lastOpenedMenu = &initMainMenu;

    setQuitButton(true);
}

/**
 * @brief Draw game menu
 *
 */
void drawGameMenu()
{
    // Print texts
    NE_TextPrint(0,        // Font slot
                 12, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Main menu");

    if (isPrivate)
    {
        char PartyCodeText[30] = "Party code: ";
        sprintf(PartyCodeText + strlen(PartyCodeText), "%s ", partyCode);
        printLongText(10, 23, 3, PartyCodeText);
    }
}

/**
 * @brief Draw score menu
 *
 */
void drawScoreMenu()
{
    if (!WaitForTeamResponse && localPlayer->Team == SPECTATOR)
        ButtonToShow = 2;
    else if (!WaitForTeamResponse) /////////////////////////////////////////////////////////////////////////////////////////////CHECK THIS
        ButtonToShow = 0;

    // Draw white bars
    NE_2DDrawQuad(0, 25, 256, 28, 19, RGB15(31, 31, 31));
    NE_2DDrawQuad(126, 28, 130, 180, 19, RGB15(31, 31, 31));
    if (!showFinalScore)
    {
        NE_TextPrint(0,        // Font slot
                     11, 1,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Score table");
    }
    else
    {
        NE_TextPrint(0,        // Font slot
                     9, 1,     // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Party finished");
    }

    // Counter terrorists text
    char CounterScoreText[30] = "Counter t";
    int offset = 0;
    if (!allPartyModes[currentPartyMode].noScore)
    {
        sprintf(CounterScoreText + strlen(CounterScoreText), ": %d ", CounterScore);
    }
    else
    {
        offset = 2;
    }
    NE_TextPrint(0,             // Font slot
                 1 + offset, 4, // Coordinates x(column), y(row)
                 NE_White,      // Color
                 CounterScoreText);

    // Show each counter terrorists player
    int Count1 = 0;
    for (int i = 0; i < MaxPlayer; i++)
    {
        if (AllPlayers[i].Team == COUNTERTERRORISTS)
        {
            int y = 6 + Count1 * 4;

            char playerName[PLAYER_MAX_LENGTH];

            sprintf(playerName, AllPlayers[i].name);
            NE_TextPrint(0,        // Font slot
                         1, y,     // Coordinates x(column), y(row)
                         NE_White, // Color
                         playerName);

            char playerValues[PLAYER_MAX_LENGTH];
            sprintf(playerValues, "Kills:  %d", AllPlayers[i].KillCount);
            NE_TextPrint(0,                 // Font slot
                         1, y + 1,          // Coordinates x(column), y(row)
                         RGB15(17, 17, 17), // Color
                         playerValues);
            sprintf(playerValues, "Deaths: %d", AllPlayers[i].DeathCount);
            NE_TextPrint(0,                 // Font slot
                         1, y + 2,          // Coordinates x(column), y(row)
                         RGB15(17, 17, 17), // Color
                         playerValues);

            Count1++;
        }
    }

    // Counter terrorists text
    char TerroristsScoreText[30] = "Terrorists";
    if (!allPartyModes[currentPartyMode].noScore)
    {
        sprintf(TerroristsScoreText + strlen(TerroristsScoreText), ": %d ", TerroristsScore);
    }

    NE_TextPrint(0,              // Font slot
                 17 + offset, 4, // Coordinates x(column), y(row)
                 NE_White,       // Color
                 TerroristsScoreText);

    // Show each terrorists player
    int Count2 = 0;
    for (int i = 0; i < MaxPlayer; i++)
    {
        if (AllPlayers[i].Team == TERRORISTS)
        {
            int y = 6 + Count2 * 4;

            char playerName[PLAYER_MAX_LENGTH];
            // sprintf(playerName, "id: %d", AllPlayers[i].Id);
            sprintf(playerName, AllPlayers[i].name);
            NE_TextPrint(0,        // Font slot
                         17, y,    // Coordinates x(column), y(row)
                         NE_White, // Color
                         playerName);

            char playerValues[PLAYER_MAX_LENGTH];
            sprintf(playerValues, "Kills:  %d", AllPlayers[i].KillCount);
            NE_TextPrint(0,                 // Font slot
                         17, y + 1,         // Coordinates x(column), y(row)
                         RGB15(17, 17, 17), // Color
                         playerValues);
            sprintf(playerValues, "Deaths: %d", AllPlayers[i].DeathCount);
            NE_TextPrint(0,                 // Font slot
                         17, y + 2,         // Coordinates x(column), y(row)
                         RGB15(17, 17, 17), // Color
                         playerValues);

            Count2++;
        }
    }
}

/**
 * @brief Draw shop categories menu
 *
 */
void drawShopCategoriesMenu()
{
    // Draw white bars
    NE_2DDrawQuad(ScreenCenterWidth - 1, 23, ScreenCenterWidth + 1, ScreenHeightFixed, 0, RGB15(31, 31, 31));
    NE_2DDrawQuad(0, (198 - 23) / 3 - 1 + 23, ScreenWidth, (198 - 23) / 3 + 2 + 23, 0, RGB15(31, 31, 31));
    NE_2DDrawQuad(0, (198 - 23) / 3 * 2 - 1 + 23, ScreenWidth, (198 - 23) / 3 * 2 + 2 + 23, 0, RGB15(31, 31, 31));

    // Show texts
    NE_TextPrint(0,        // Font slot
                 14, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Shop");

    char MoneyText[30];
    sprintf(MoneyText, "%d$", localPlayer->Money);
    NE_TextPrint(0,        // Font slot
                 1, 1,     // Coordinates x(column), y(row)
                 NE_White, // Color
                 MoneyText);

    NE_TextPrint(0,        // Font slot
                 4, 6,     // Coordinates x(column), y(row)
                 NE_White, // Color
                 "PISTOLS");

    NE_TextPrint(0,        // Font slot
                 5, 13,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "HEAVY");

    NE_TextPrint(0,        // Font slot
                 6, 21,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "SMG");

    NE_TextPrint(0,        // Font slot
                 21, 6,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "RIFLES");

    NE_TextPrint(0,        // Font slot
                 20, 13,   // Coordinates x(column), y(row)
                 NE_White, // Color
                 "EQUIPMENT");

    NE_TextPrint(0,        // Font slot
                 20, 21,   // Coordinates x(column), y(row)
                 NE_White, // Color
                 "GRENADES");
}

/**
 * @brief Draw settings menu
 *
 */
void drawSettingsMenu()
{
    NE_TextPrint(0,        // Font slot
                 12, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Settings");

    NE_TextPrint(0,        // Font slot
                 18, 16,   // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Keyboard mode");

    printLongText(1, 16, 3, "Use Rumble Pak (causes crash on DSi/3DS)");
    printLongText(17, 32, 4, "Show ping");

    char gamePadSensitivityText[29];
    sprintf(gamePadSensitivityText, "Crosshair transparency: %d%%", (int)(*AllSliders[0].value * 100));
    printLongText(1, 16, 15, gamePadSensitivityText);
}

/**
 * @brief Draw quit menu
 *
 */
void drawQuitMenu()
{
    if (isInTutorial)
    {
        NE_TextPrint(0,        // Font slot
                     7, 3,     // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Skip the tutorial?");
    }
    else
    {
        NE_TextPrint(0,        // Font slot
                     4, 3,     // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Are you sure want to quit\n            the game?");
    }
}

/**
 * @brief Draw shop menu
 *
 */
void drawShopMenu()
{
    NE_2DDrawQuad(160, 26, 255, 144, 1, RGB15(4, 4, 4));                                   // Draw gun details background
    NE_2DDrawTexturedQuad(26, 26, 118 + 26, 118 + 26, 1, BottomScreenSpritesMaterials[6]); // Draw gun

    // Title
    NE_TextPrint(0,        // Font slot
                 14, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Shop");

    char MoneyText[30];
    sprintf(MoneyText, "%d$", localPlayer->Money);
    NE_TextPrint(0,        // Font slot
                 1, 1,     // Coordinates x(column), y(row)
                 NE_White, // Color
                 MoneyText);

    if (GetShopCategory() < 4) // If current shop category is guns
    {
        // Gun name
        printLongConstChar(21, 31, 4, AllGuns[SelectedGunShop].name);

        // Gun damage
        NE_TextPrint(0,        // Font slot
                     21, 7,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Damage");
        char DamageText[4];

        sprintf(DamageText, "%d", AllGuns[SelectedGunShop].Damage);
        NE_TextPrint(0,        // Font slot
                     21, 8,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     DamageText);

        // Gun fire rate
        NE_TextPrint(0,        // Font slot
                     21, 11,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Fire rate");
        char FireRateText[10];
        sprintf(FireRateText, "%d RPM", (int)(1.0 / (AllGuns[SelectedGunShop].fireRate / 3600.0)));
        NE_TextPrint(0,        // Font slot
                     21, 12,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     FireRateText);

        // Gun price
        NE_TextPrint(0,        // Font slot
                     21, 15,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Price");
        char PriceText[7];
        sprintf(PriceText, "%d$", AllGuns[SelectedGunShop].Price);
        NE_TextPrint(0,        // Font slot
                     21, 16,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     PriceText);
    }
    else if (GetShopCategory() == 4) // If current shop category is equipements
    {
        // Gun name
        printLongConstChar(21, 31, 4, allEquipments[SelectedGunShop - GunCount - shopGrenadeCount].name);

        // Gun price
        NE_TextPrint(0,        // Font slot
                     21, 15,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Price");

        char PriceText[7];
        sprintf(PriceText, "%d$", allEquipments[SelectedGunShop - GunCount - shopGrenadeCount].Price);
        NE_TextPrint(0,        // Font slot
                     21, 16,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     PriceText);

        // Print description
        printLongConstChar(21, 31, 7, allEquipments[SelectedGunShop - GunCount - shopGrenadeCount].description);
    }
    else if (GetShopCategory() == 5) // If current shop category is grenades
    {
        // Gun name
        printLongConstChar(21, 31, 4, AllGrenades[SelectedGunShop - GunCount].name);

        // Gun price
        NE_TextPrint(0,        // Font slot
                     21, 15,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     "Price");

        char PriceText[7];
        sprintf(PriceText, "%d$", AllGrenades[SelectedGunShop - GunCount].Price);
        NE_TextPrint(0,        // Font slot
                     21, 16,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     PriceText);

        // Print description
        printLongConstChar(21, 31, 7, AllGrenades[SelectedGunShop - GunCount].description);
    }
}

/**
 * @brief Draw gamepad menu
 *
 */
void drawControllerMenu()
{
    if (!isLeftControls)
    {
        NE_2DDrawQuad(40, 30, 255, 194, 1, RGB15(4, 4, 4));                                        // touch pad area
        NE_2DDrawTexturedQuad(4, 32, 4 + 36 - 4, 30 + 36 - 2, 1, BottomScreenSpritesMaterials[7]); // Jump button
        NE_2DDrawTexturedQuad(4, 74, 4 + 36 - 4, 72 + 36 - 2, 1, BottomScreenSpritesMaterials[8]); // Reload button
    }
    else
    {
        NE_2DDrawQuad(0, 30, 215, 194, 1, RGB15(4, 4, 4));                                             // touch pad area
        NE_2DDrawTexturedQuad(220, 32, 220 + 36 - 4, 30 + 36 - 2, 1, BottomScreenSpritesMaterials[7]); // Jump button
        NE_2DDrawTexturedQuad(220, 74, 220 + 36 - 4, 72 + 36 - 2, 1, BottomScreenSpritesMaterials[8]); // Reload button
    }

    // Print texts
    NE_TextPrint(0,        // Font slot
                 13, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Gamepad");
}

/**
 * @brief Draw main menu
 *
 */
void drawMainMenu()
{

    // Print texts
    NE_TextPrint(0,        // Font slot
                 10, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 GAME_NAME);

    NE_TextPrint(0,        // Font slot
                 1, 22,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 GAME_VERSION);

    NE_TextPrint(0,        // Font slot
                 24, 22,   // Coordinates x(column), y(row)
                 NE_White, // Color
                 DEV_NAME);
}

/**
 * @brief Draw change name menu
 *
 */
void drawChangeNameMenu()
{
    // Nothing here
}

/**
 * @brief Draw chat menu (TODO)
 *
 */
void drawChatMenu()
{
    // Nothing here
}

/**
 * @brief Draw controls settings menu
 *
 */
void drawControlsSettingsMenu()
{
    // Print texts
    NE_TextPrint(0,        // Font slot
                 12, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Controls");

    printLongText(2, 15, 4, "Left-handed gamepad");
    printLongText(20, 28, 6, "Change controls");

    // Print texts
    NE_TextPrint(0,        // Font slot
                 13, 11,   // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Camera");

    char gamePadSensitivityText[26];
    sprintf(gamePadSensitivityText, "Gamepad sensitivity: %0.1f", *AllSliders[0].value);
    printLongText(16, 32, 13, gamePadSensitivityText);

    char buttonsSensitivityText[33];
    sprintf(buttonsSensitivityText, "Button sensitivity: %0.1f", *AllSliders[1].value);
    printLongText(2, 16, 13, buttonsSensitivityText);
}

/**
 * @brief Draw controls change menu
 *
 */
void drawControlsChangeMenu()
{
    // Print texts
    NE_TextPrint(0,        // Font slot
                 9, 1,     // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Change controls");

    if (ButtonToShow >= 3)
        // Print texts
        NE_TextPrint(0,        // Font slot
                     3, 6,     // Coordinates x(column), y(row)
                     NE_White, // Color
                     inputsNames[inputs[0 + (controlsPage * 6)].nameIndex]);

    if (ButtonToShow >= 4)
        // Print texts
        NE_TextPrint(0,        // Font slot
                     19, 6,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     inputsNames[inputs[1 + (controlsPage * 6)].nameIndex]);

    if (ButtonToShow >= 5)
        // Print texts
        NE_TextPrint(0,        // Font slot
                     3, 11,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     inputsNames[inputs[2 + (controlsPage * 6)].nameIndex]);

    if (ButtonToShow >= 6)
        // Print texts
        NE_TextPrint(0,        // Font slot
                     19, 11,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     inputsNames[inputs[3 + (controlsPage * 6)].nameIndex]);

    if (ButtonToShow >= 7)
        // Print texts
        NE_TextPrint(0,        // Font slot
                     3, 16,    // Coordinates x(column), y(row)
                     NE_White, // Color
                     inputsNames[inputs[4 + (controlsPage * 6)].nameIndex]);

    if (ButtonToShow >= 8)
        // Print texts
        NE_TextPrint(0,        // Font slot
                     19, 16,   // Coordinates x(column), y(row)
                     NE_White, // Color
                     inputsNames[inputs[5 + (controlsPage * 6)].nameIndex]);
}

/**
 * @brief Draw map selection with image menu
 *
 */
void drawSelectionMapImageMenu()
{
    // Print texts
    NE_TextPrint(0,        // Font slot
                 11, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Select map");

    NE_2DDrawTexturedQuad(0 + 32, 20, 192 + 32, 139 + 20, 3, BottomScreenSpritesMaterials[6]); // Draw map image

    // Text background
    NE_PolyFormat(15, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);
    NE_2DDrawQuad(0 + 32, 20, 192 + 32, 16 + 20, 2, RGB15(0, 0, 0));
    NE_PolyFormat(31, 0, NE_LIGHT_0, NE_CULL_BACK, NE_MODULATION);

    // Print map name
    printLongConstChar(4, 31 - 4, 3, allMaps[currentSelectionMap].name);
}

/**
 * @brief Draw map selection with list menu (not implemented, maybe to remove)
 *
 */
void drawSelectionMapListMenu()
{
    // Print texts
    NE_TextPrint(0,        // Font slot
                 11, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Select map");
}

/**
 * @brief Draw online error menu
 *
 */
void drawPartyModeSelectionMenu()
{
    NE_TextPrint(0,        // Font slot
                 7, 1,     // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Select a game mode");
}

/**
 * @brief Draw multiplayer menu
 *
 */
void drawJoinCreatePartyMenu()
{
    // Print texts
    NE_TextPrint(0,        // Font slot
                 11, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Multiplayer");

    NE_TextPrint(0,        // Font slot
                 4, 23,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 DISCORD_LINK);
}

/**
 * @brief Draw enter code menu
 *
 */
void drawEnterCodeMenu()
{
    // Nothing here
}

/**
 * @brief Draw online error menu
 *
 */
void drawOnlineErrorMenu()
{
    NE_TextPrint(0,        // Font slot
                 11, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Information:");

    printLongText(2, 30, 5, errorText);
}

void drawStatsMenu()
{
    NE_TextPrint(0,        // Font slot
                 11, 1,    // Coordinates x(column), y(row)
                 NE_White, // Color
                 "Statistics:");

    char botKillCountText[26];
    sprintf(botKillCountText, "Bots killed: %d", totalBotsKillCount);
    printLongText(0, 33, 5, botKillCountText);

    char onlineKillCountText[26];
    sprintf(onlineKillCountText, "Online players killed: %d", totalOnlinePlayersKillCount);
    printLongText(0, 33, 8, onlineKillCountText);

    char timerText[26];
    sprintf(timerText, "Time played: %02dh:%02dm", totalPlayedHours, totalPlayedMinutes);
    printLongText(0, 33, 11, timerText);

    char deathCountText[26];
    sprintf(deathCountText, "Death count: %d", totalDeathCount);
    printLongText(0, 33, 14, deathCountText);

    char partyCountText[26];
    sprintf(partyCountText, "Finished parties: %d", totalFinishedParty);
    printLongText(0, 33, 17, partyCountText);

    char winCountText2[26];
    sprintf(winCountText2, "Victories: %d", totalWins);
    printLongText(0, 33, 20, winCountText2);
}

/**
 * @brief Draw every buttons of the menu
 *
 */
void drawButtons()
{
    for (int i = 0; i < ButtonToShow; i++)
    {
        if (!AllButtons[i].isHidden)
        {
            int ButtonXPosition = AllButtons[i].xPos, ButtonYPosition = AllButtons[i].yPos, ButtonXSize = AllButtons[i].xSize, ButtonYSize = AllButtons[i].ySize;
            NE_2DDrawQuad(ButtonXPosition, ButtonYPosition, ButtonXPosition + ButtonXSize, ButtonYPosition + ButtonYSize, 1, RGB15(5, 5, 5)); // Button background

            NE_TextPrint(0,                                              // Font slot
                         AllButtons[i].xTextPos, AllButtons[i].yTextPos, // Coordinates x(column), y(row)
                         NE_White,                                       // Color
                         AllButtons[i].text);
        }
    }
}

/**
 * @brief Draw every checkboxs of the menu
 *
 */
void drawCheckboxs()
{
    for (int i = 0; i < checkBoxToShow; i++)
    {
        int CheckBoxXPosition = AllCheckBoxs[i].xPos, CheckBoxYPosition = AllCheckBoxs[i].yPos, CheckBoxXSize = AllCheckBoxs[i].xSize, CheckBoxYSize = AllCheckBoxs[i].ySize;
        NE_2DDrawTexturedQuadColor(CheckBoxXPosition - 3, CheckBoxYPosition - 3, CheckBoxXPosition + CheckBoxXSize + 3, CheckBoxYPosition + CheckBoxYSize + 3, 2, BottomScreenSpritesMaterials[5], RGB15(4, 4, 4)); // Border
        NE_2DDrawTexturedQuadColor(CheckBoxXPosition - 1, CheckBoxYPosition - 1, CheckBoxXPosition + CheckBoxXSize + 1, CheckBoxYPosition + CheckBoxYSize + 1, 1, BottomScreenSpritesMaterials[5], RGB15(5, 5, 5)); // Background
        if (*AllCheckBoxs[i].value)
            NE_2DDrawTexturedQuadColor(CheckBoxXPosition, CheckBoxYPosition, CheckBoxXPosition + CheckBoxXSize, CheckBoxYPosition + CheckBoxYSize, 0, BottomScreenSpritesMaterials[4], RGB15(31, 31, 31)); // CheckMark
    }
}

/**
 * @brief Draw every sliders of the menu
 *
 */
void drawSliders()
{
    for (int i = 0; i < sliderToShow; i++)
    {
        int SliderXPosition = AllSliders[i].xPos, SliderYPosition = AllSliders[i].yPos, SliderXSize = AllSliders[i].xSize;
        NE_2DDrawQuad(SliderXPosition - 1, SliderYPosition - 2, SliderXPosition + SliderXSize + 1, SliderYPosition + 2, 2, RGB15(5, 5, 5));

        int sliderHandXPos = (int)map(*AllSliders[i].value, AllSliders[i].min, AllSliders[i].max, AllSliders[i].xPos, AllSliders[i].xPos + AllSliders[i].xSize);
        NE_2DDrawTexturedQuadColor(sliderHandXPos - 10, SliderYPosition - 10, sliderHandXPos + 10, SliderYPosition + 10, 1, BottomScreenSpritesMaterials[5], RGB15(7, 7, 7));
    }
}

/**
 * @brief Unload the shop menu
 *
 */
void unloadShopMenu()
{
    // Delete shop gun preview image
    NE_MaterialDelete(BottomScreenSpritesMaterials[6]);
    NE_PaletteDelete(Palettes[10]);
}

/**
 * @brief Unload the gamepad menu
 *
 */
void unloadControllerMenu()
{
    closeMap();

    // Delete button images
    NE_MaterialDelete(BottomScreenSpritesMaterials[7]);
    NE_PaletteDelete(Palettes[14]);
    NE_MaterialDelete(BottomScreenSpritesMaterials[8]);
    NE_PaletteDelete(Palettes[15]);
}

/**
 * @brief Unload the selection map with image menu
 *
 */
void unloadSelectionMapImageMenu()
{
    // Delete shop gun preview image
    NE_MaterialDelete(BottomScreenSpritesMaterials[6]);
    NE_PaletteDelete(Palettes[10]);
}

/**
 * @brief Unload change name menu
 *
 */
void unloadChangeNameMenu()
{
    SendPlayerName = true;
}

/**
 * @brief Unloads controls change menu
 *
 */
void unloadControlsChangeMenu()
{
    stopScanForInput();
}
```

`Counter-Strike-nds/source/graphics/ui.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef UI_H_ /* Include guard */
#define UI_H_
#include <NEMain.h>
#include "main.h"

#define DISCORD_LINK "Discord : dsc.gg/fewnity"
#define DEV_NAME "Fewnity"
#define GAME_NAME "Counter Strike"

#define maxCharAtScreen 32
#define maxCharAtScreenDivided2 16 // 32/2
#define ScreenWidth 256
#define ScreenWidthDivided4 64
#define ScreenHeight 192
#define ScreenHeightFixed 196
#define ScreenCenterWidth 128 // 256/2
#define ScreenCenterHeight 96 // 192/2

#define ButtonCount 8
#define CheckBoxCount 3
#define SliderCount 2

#define ColorTerroristsTeam RGB15(26, 26, 13)
#define ColorCounterTeam RGB15(14, 20, 29)
#define ColorCounterTeamLiter RGB15(19, 25, 31)
#define maxCharAtLine 32
#define CONTROLS_PAGE_COUNT 3

#define ERROR_TEXT_LENGTH 100
#define PLAYER_MAX_LENGTH 14

extern int selectedServer;
extern enum shopCategory ShopCategory;
extern bool isShowingMap;
extern bool isShowingKeyBoard;
extern bool isLeftControls;
extern bool useQuitButton;
extern void (*lastOpenedMenu)();
extern int checkBoxToShow;
extern int sliderToShow;
extern int trace;
extern int currentSelectionMap;
extern float debugValue1;
extern float debugValue2;
extern float debugValue3;
extern char errorText[ERROR_TEXT_LENGTH];
extern bool showFinalScore;
extern bool showPing;
extern int showShootFriendMessage;
extern float cursorTransparency;

enum UiMenu
{
    GAME = 0,
    // NIFI_MULTIPLAYER = 1, // Unused
    SCORE_BOARD = 2,
    SHOPCATEGORIES = 3,
    SETTINGS = 4,
    QUIT = 5,
    SHOP = 6,
    CONTROLLER = 7,
    MAIN = 8,
    // MULTIPLAYER_NIFI_WIFI = 9,
    CHANGENAME = 10,
    CHAT = 11,
    CONTROLSSETTINGS = 12,
    CONTROLSCHANGE = 12,
    MAP_SELECTION_IMAGE = 13,
    MAP_SELECTION_LIST = 14,
    PARTY_MODE_SELECTION_LIST = 15,
    FINAL_SCORE = 16,
    JOIN_CREATE_PARTY = 17,
    ENTER_CODE = 18,
    ONLINE_ERROR = 19,
    STATS = 20,
};

enum shopCategory
{
    PISTOLS = 0,
    HEAVY = 1,
    SGM = 2,
    RIFLES = 3,
    EQUIPMENT = 4,
    GRENADES = 5
};

enum TextEnum
{
    TERRORISTS_WIN = 0,
    COUNTER_TERRORISTS_WIN = 1,
    BOMB_PLANTED = 2,
    BOMB_DEFUSED = 3,
};

typedef struct //
{
    int xPos;
    int yPos;
    int xSize;
    int ySize;
    bool *value;
} CheckBox;

typedef struct //
{
    int xPos;
    int yPos;
    int xSize;
    int ySize;
    float *value;
    float min;
    float max;
    float step;
} Slider;

typedef struct //
{
    const char *text;
    int xTextPos;
    int yTextPos;

    int xPos;
    int yPos;
    int xSize;
    int ySize;
    int parameter;
    bool isHidden;
    void (*OnClick)(int);
} Button;

enum shopCategory GetShopCategory();
int GetWeaponCountVar();
void SetCheckBoxToShow(int value);
void startChangeMenu(enum UiMenu menuToShow);
void ChangeMenu(int menuId);
void SetPlayerForUI();
int printLongText(int minX, int maxX, int y, char *text);
int printLongConstChar(int minX, int maxX, int y, const char *text);
void SetTeam(int i);
void OpenShopCategory(int categoryId);
void ChangeShopElement(int Left);
void BuyWeapon(int unused);
void Jump();
void changeServer(int up);
void showPartyEventText(int event);
void showKillText(int killerIndex, int deadPlayerIndex);
void showConnectedText(int connectedPlayerIndex);
void showDisconnectedText(int disconnectedPlayerIndex);
int centerPositionOfAText(int xMin, int xMax, int textLength);
void stopScanForInput();

void changeMapState();
void closeMap();
void setQuitButton(bool value);
void startScanForInput(int inputIndex);
void showDialog();
void setDialogText(char *text);

void initGameMenu();
void initScoreMenu();
void initShopCategoriesMenu();
void initSettingsMenu();
void initChangeNameMenu();
void initQuitMenu();
void initShopMenu();
void initControllerMenu();
void initMainMenu();
void initChatMenu();
void initControlsSettingsMenu();
void initControlsChangeMenu();
void initSelectionMapImageMenu();
void initSelectionMapListMenu();
void initPartyModeSelectionMenu();
void initFinalScoreMenu();
void initJoinCreatePartyMenu();
void initEnterCodeMenu();
void initOnlineErrorMenu();
void initStatsMenu();

void drawKeyboardInput();

void drawTopScreenUI();
void drawBottomScreenUI();
void drawButtons();
void drawCheckboxs();
void drawSliders();
void drawGameMenu();
void drawGameFinishedMenu();
void drawScoreMenu();
void drawShopCategoriesMenu();
void drawSettingsMenu();
void drawQuitMenu();
void drawShopMenu();
void drawControllerMenu();
void drawMainMenu();
void drawServersMenu();
void drawChangeNameMenu();
void drawChatMenu();
void drawControlsSettingsMenu();
void drawControlsChangeMenu();
void drawSelectionMapImageMenu();
void drawSelectionMapListMenu();
void drawPartyModeSelectionMenu();
void drawJoinCreatePartyMenu();
void drawEnterCodeMenu();
void drawOnlineErrorMenu();
void drawStatsMenu();

void unloadShopMenu();
void unloadControllerMenu();
void unloadSelectionMapImageMenu();
void unloadChangeNameMenu();
void unloadEnterCodeMenu();
void unloadControlsChangeMenu();

#endif // UI_H_
```

`Counter-Strike-nds/source/inputs/input.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "input.h"
#include "ui.h"
#include "movements.h"
#include "keyboard.h"
#include "gun.h"
#include "tutorial.h"

// Last position of the style / finger
Vector2 LastTouch;
// Held keys
uint32 keys = 0;
// Pressed keys
uint32 keysdown = 0;
// Released keys
uint32 keysup = 0;
// Position of the style / finger
touchPosition touch;

// Game pad areas
int gamepadTouchAreaX1 = GAMEPAD_TOUCH_AREA_X1_RIGHT_HANDLED;
int gamepadTouchAreaX2 = GAMEPAD_TOUCH_AREA_X2_RIGHT_HANDLED;
int gamepadTouchAreaY1 = 30;
int gamepadTouchAreaY2 = 194;

// Game pad sensitivity
float sensitivity = DEFAULT_SENSITIVITY;
float buttonsSensitivity = DEFAULT_SENSITIVITY;

// Current used slider index
int currentSlider = -1;

// Angles added to the player/camera when the stylus is moved
int xAngleAdded = 0;
int yAngleAdded = 0;

// All inputs data
Input inputs[INPUT_COUNT];
// Is scnanning for inputs?
bool scanForInput = false;
// Current input index scanned
int currentInputScanned = 0;
// All inputs names
const char *inputsNames[INPUT_NAMES_COUNT];

void initInputs()
{
    // Set default inputs
    inputs[FIRE_BUTTON].value = KEY_L;
    inputs[FIRE_BUTTON].nameIndex = 9;
    inputs[JUMP_BUTTON].value = KEY_R;
    inputs[JUMP_BUTTON].nameIndex = 8;

    inputs[LEFT_BUTTON].value = KEY_LEFT;
    inputs[LEFT_BUTTON].nameIndex = 5;
    inputs[RIGHT_BUTTON].value = KEY_RIGHT;
    inputs[RIGHT_BUTTON].nameIndex = 4;
    inputs[UP_BUTTON].value = KEY_UP;
    inputs[UP_BUTTON].nameIndex = 6;
    inputs[DOWN_BUTTON].value = KEY_DOWN;
    inputs[DOWN_BUTTON].nameIndex = 7;
    inputs[LOOK_LEFT_BUTTON].value = KEY_Y;
    inputs[LOOK_LEFT_BUTTON].nameIndex = 11;
    inputs[LOOK_RIGHT_BUTTON].value = KEY_A;
    inputs[LOOK_RIGHT_BUTTON].nameIndex = 0;
    inputs[LOOK_UP_BUTTON].value = KEY_X;
    inputs[LOOK_UP_BUTTON].nameIndex = 10;
    inputs[LOOK_DOWN_BUTTON].value = KEY_B;
    inputs[LOOK_DOWN_BUTTON].nameIndex = 1;

    inputs[DEFUSE_BUTTON].value = KEY_SELECT;
    inputs[DEFUSE_BUTTON].nameIndex = 2;
    inputs[SCOPE_BUTTON].value = KEY_START;
    inputs[SCOPE_BUTTON].nameIndex = 3;

    inputs[LEFT_GUN].value = -1; // Unasigned
    inputs[LEFT_GUN].nameIndex = 12;
    inputs[RIGHT_GUN].value = -1; // Unasigned
    inputs[RIGHT_GUN].nameIndex = 12;

    // Set inputs names list
    inputsNames[0] = "A";
    inputsNames[1] = "B";
    inputsNames[2] = "Select";
    inputsNames[3] = "Start";
    inputsNames[4] = "Right";
    inputsNames[5] = "Left";
    inputsNames[6] = "Up";
    inputsNames[7] = "Down";
    inputsNames[8] = "R";
    inputsNames[9] = "L";
    inputsNames[10] = "X";
    inputsNames[11] = "Y";
    inputsNames[12] = "Unassigned";
    inputsNames[13] = "Scanning...";
    inputsNames[14] = "Already used";
}

/**
 * @brief Read keys, touch screen and keyboard
 *
 */
void readKeys()
{
    scanKeys();
    keys = keysHeld();
    keysdown = keysDown();
    keysup = keysUp();
    touchRead(&touch);

    readKeyboard();
}

/**
 * @brief Read the touch screen
 *
 * @param touch
 * @param NeedChangeScreen
 * @param AlwaysUpdateBottomScreen
 * @param ButtonToShow
 * @param UpdateBottomScreenFrameCount
 * @param SendTeam
 * @param forceCheck
 */
void ReadTouchScreen(touchPosition touch, bool *NeedChangeScreen, bool *AlwaysUpdateBottomScreen, int *ButtonToShow, int *UpdateBottomScreenFrameCount, bool *SendTeam, bool forceCheck)
{
    if ((*UpdateBottomScreenFrameCount == 0 && uiTimer == 0) || forceCheck)
    {
        for (int i = 0; i < checkBoxToShow; i++)
        {
            // Check checkboxs
            if ((keysdown & KEY_TOUCH && touch.px >= AllCheckBoxs[i].xPos && touch.px <= AllCheckBoxs[i].xPos + AllCheckBoxs[i].xSize && touch.py >= AllCheckBoxs[i].yPos && touch.py <= AllCheckBoxs[i].yPos + AllCheckBoxs[i].ySize))
            {
                *AllCheckBoxs[i].value = !*AllCheckBoxs[i].value;
                *UpdateBottomScreenFrameCount += 8;
                if (currentMenu == CONTROLSSETTINGS) // Update screen button (map menu)
                {
                    if (i == 0)
                    {
                        UpdateGamepadArea();
                    }
                }
                return;
            }
        }

        if (keys & KEY_TOUCH)
        {
            if (keysdown & KEY_TOUCH && currentSlider == -1)
            {
                // Check if the player is just touching a slider
                for (int i = 0; i < sliderToShow; i++)
                {
                    if ((touch.px >= AllSliders[i].xPos && touch.px <= AllSliders[i].xPos + AllSliders[i].xSize && touch.py >= AllSliders[i].yPos - 10 && touch.py <= AllSliders[i].yPos + 10))
                    {
                        currentSlider = i;
                        break;
                    }
                }
            }
            if (currentSlider != -1)
            {
                // Check used slider value
                if ((touch.px >= AllSliders[currentSlider].xPos && touch.px <= AllSliders[currentSlider].xPos + AllSliders[currentSlider].xSize && touch.py >= AllSliders[currentSlider].yPos - 10 && touch.py <= AllSliders[currentSlider].yPos + 10))
                {
                    *AllSliders[currentSlider].value = map(touch.px, AllSliders[currentSlider].xPos, AllSliders[currentSlider].xPos + AllSliders[currentSlider].xSize, AllSliders[currentSlider].min, AllSliders[currentSlider].max);
                }
                return;
            }
        }
        else
        {
            currentSlider = -1;
        }

        // Check for all buttons click
        for (int i = 0; i < *ButtonToShow; i++)
        {
            if (!AllButtons[i].isHidden && (keysdown & KEY_TOUCH && touch.px >= AllButtons[i].xPos && touch.px <= AllButtons[i].xPos + AllButtons[i].xSize && touch.py >= AllButtons[i].yPos && touch.py <= AllButtons[i].yPos + AllButtons[i].ySize))
            {
                AllButtons[i].OnClick(AllButtons[i].parameter);
                return;
            }
        }

        // Check back button click
        if (useQuitButton && keysdown & KEY_TOUCH && touch.px >= 236 && touch.px <= 236 + 20 && touch.py >= 1 && touch.py <= 1 + 20)
        {
            if (currentMenu == SETTINGS)
            {
                uiTimer = 8;
                actionOfUiTimer = SAVE;
            }
            lastOpenedMenu();
            return;
        }

        if (!localPlayer->IsDead && currentMenu == CONTROLLER && keys & KEY_TOUCH && touch.px >= gamepadTouchAreaX1 && touch.px <= gamepadTouchAreaX2 && touch.py >= gamepadTouchAreaY1 && touch.py <= gamepadTouchAreaY2)
        {
            // Check if the player want to enable scope
            if (keysdown & KEY_TOUCH)
            {
                if (GetDoubleTapTimer() > 0)
                    SetAim();

                SetDoubleTapTimer(11);
            }
            else if (LastTouch.x != -1)
            {
                // Move the camera with the stylus

                int xAngleToAdd = 0;
                int yAngleToAdd = 0;

                if (LastTouch.x != touch.px)
                    xAngleToAdd = LastTouch.x - touch.px;

                if (LastTouch.y != touch.py)
                    yAngleToAdd = touch.py - LastTouch.y;

                xAngleToAdd = fmin(xAngleToAdd, 50);
                yAngleToAdd = fmin(yAngleToAdd, 50);

                // Total of angle added / removed to the camera
                xAngleAdded = abs(xAngleToAdd);
                yAngleAdded = abs(yAngleToAdd);

                // if (xAngleToAdd + yAngleToAdd < 50) // Security to avoid touch screen stylus teleportation
                AddAnglesToPlayer(xAngleToAdd / 2.0, yAngleToAdd / 2.0);
            }

            LastTouch.x = touch.px;
            LastTouch.y = touch.py;
        }
        else
        {
            LastTouch.x = -1;
            LastTouch.y = -1;
        }
    }
}

/**
 * @brief Update gamepad area
 *
 */
void UpdateGamepadArea()
{
    if (isLeftControls)
    {
        gamepadTouchAreaX1 = GAMEPAD_TOUCH_AREA_X1_LEFT_HANDLED;
        gamepadTouchAreaX2 = GAMEPAD_TOUCH_AREA_X2_LEFT_HANDLED;
    }
    else
    {
        gamepadTouchAreaX1 = GAMEPAD_TOUCH_AREA_X1_RIGHT_HANDLED;
        gamepadTouchAreaX2 = GAMEPAD_TOUCH_AREA_X2_RIGHT_HANDLED;
    }
}

/**
 * @brief Scan of input (for input settings)
 *
 */
void ScanForInput()
{
    if (scanForInput)
    {
        for (int i = 0; i < 12; i++)
        {
            if (keysdown & BIT(i))
            {
                bool canChange = true;

                // Check if input is already used
                for (int j = 0; j < INPUT_COUNT; j++)
                {
                    if (inputs[j].value == BIT(i))
                    {
                        canChange = false;
                        break;
                    }
                }

                // If the input is available, change it
                if (canChange)
                {
                    inputs[currentInputScanned].value = BIT(i);
                    inputs[currentInputScanned].nameIndex = i;
                }
                else // If the input is already used, change the input text to already used
                {
                    inputs[currentInputScanned].value = -1;
                    inputs[currentInputScanned].nameIndex = 14;
                }

                // Is the player is in the tutorial, update the text
                if (isInTutorial && inputs[currentInputScanned].value != -1)
                {
                    updateTutorialDialogText();
                }
                scanForInput = false;
                break;
            }
        }
    }
}

/**
 * @brief Check if the input is pressed
 *
 * @param buttonName
 * @return true
 * @return false
 */
bool isKeyDown(enum inputButtons buttonName)
{
    return keysdown & inputs[buttonName].value && inputs[buttonName].value != -1;
}

/**
 * @brief Check if the input is released
 *
 * @param buttonName
 * @return true
 * @return false
 */
bool isKeyUp(enum inputButtons buttonName)
{
    return keysup & inputs[buttonName].value && inputs[buttonName].value != -1;
}

/**
 * @brief Check if the input is held
 *
 * @param buttonName
 * @return true
 * @return false
 */
bool isKey(enum inputButtons buttonName)
{
    return keys & inputs[buttonName].value && inputs[buttonName].value != -1;
}
```

`Counter-Strike-nds/source/inputs/input.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef INPUT_H_ /* Include guard */
#define INPUT_H_

#include "main.h"

#define GAMEPAD_TOUCH_AREA_X1_RIGHT_HANDLED 40
#define GAMEPAD_TOUCH_AREA_X1_LEFT_HANDLED 0
#define GAMEPAD_TOUCH_AREA_X2_RIGHT_HANDLED 255
#define GAMEPAD_TOUCH_AREA_X2_LEFT_HANDLED 215
#define MIN_SENSITIVITY 0.1
#define DEFAULT_SENSITIVITY 2
#define MAX_SENSITIVITY 4

void initInputs();
void readKeys();
void ReadTouchScreen(touchPosition touch, bool *NeedChangeScreen, bool *AlwaysUpdateBottomScreen, int *ButtonToShow, int *UpdateBottomScreenOneFrame, bool *SendTeam, bool forceCheck);
void ScanForInput();
bool isKeyDown(enum inputButtons buttonName);
bool isKeyUp(enum inputButtons buttonName);
bool isKey(enum inputButtons buttonName);
void UpdateGamepadArea();

extern touchPosition touch;
extern uint32 keys;
extern uint32 keysdown;
extern uint32 keysup;
extern int gamepadTouchAreaX1;
extern int gamepadTouchAreaX2;
extern int gamepadTouchAreaY1;
extern int gamepadTouchAreaY2;
extern float sensitivity;
extern float buttonsSensitivity;
extern int xAngleAdded;
extern int yAngleAdded;
extern Input inputs[INPUT_COUNT];
extern bool scanForInput;
extern int currentInputScanned;
extern const char *inputsNames[INPUT_NAMES_COUNT];

#endif // INPUT_H_
```

`Counter-Strike-nds/source/inputs/keyboard.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "keyboard.h"
#include "sounds.h"
#include "ui.h"
#include "saveManager.h"
#include "input.h"
#include "network.h"

#define KEY_COUNT 39
#define OTHER_KEY_COUNT 5

// Loaded keys data
Key allKeys[KEY_COUNT];
OtherKey allOtherKeys[OTHER_KEY_COUNT];

// Temporary char array
char tempText[21];

// Is the keyboard in upper case
bool isUpperCase = false;

// Param to pass to the function to call if the keyboard is cancelled
int returnToMenuOnCancel = -1;
// Param to pass to the function to call if the keyboard is confirmed
int returnToMenuOnSucces = -1;
// Is the keyboard in azerty mode
bool isAzerty = false;

// function to call if the keyboard is cancelled
void (*onKeyboardCloseSucces)();
// function to call if the keyboard is confirmed
void (*onKeyboardCloseCancel)();

// What the keyboard used for?
int keyboardAction = -1;

// Max length of the text to enable the confirm button
int maxInputLength = 20;
// Min length of the text to enable the confirm button
int minInputLength = 1;

/**
 * @brief Set can change keyboard case
 *
 * @param value enable(true) or disable(false)
 */
void SetCanChangeCase(bool value)
{
    allOtherKeys[SHITF_KEY_INDEX].visible = value;
}

/**
 * @brief Set keyboard mode to azerty or qwerty
 *
 */
void changeKeyboardMode()
{
    // Change the keyboard mode
    isAzerty = !isAzerty;
    // Update setting text
    if (isAzerty)
    {
        AllButtons[2].text = "Azerty";
    }
    else
    {
        AllButtons[2].text = "Qwerty";
    }
    // Refresh screen
    UpdateBottomScreenFrameCount += 8;
    initKeyboard();
}

/**
 * @brief Init keyboard
 *
 */
void initKeyboard()
{
    // Reset values
    for (int i = 0; i < KEY_COUNT; i++)
    {
        allKeys[i].visible = true;
    }

    for (int i = 0; i < OTHER_KEY_COUNT; i++)
    {
        allOtherKeys[i].visible = true;
    }

    int index = 0;
    int yOffset = 4;
    int yOffset2 = 6;

    //
    strncpy(allKeys[index].letter, "1", 2);
    strncpy(allKeys[index].letterUpperCase, "1", 2);
    allKeys[index].xPos = 2 + 3 * 0;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "2", 2);
    strncpy(allKeys[index].letterUpperCase, "2", 2);
    allKeys[index].xPos = 2 + 3 * 1;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "3", 2);
    strncpy(allKeys[index].letterUpperCase, "3", 2);
    allKeys[index].xPos = 2 + 3 * 2;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "4", 2);
    strncpy(allKeys[index].letterUpperCase, "4", 2);
    allKeys[index].xPos = 2 + 3 * 3;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "5", 2);
    strncpy(allKeys[index].letterUpperCase, "5", 2);
    allKeys[index].xPos = 2 + 3 * 4;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "6", 2);
    strncpy(allKeys[index].letterUpperCase, "6", 2);
    allKeys[index].xPos = 2 + 3 * 5;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "7", 2);
    strncpy(allKeys[index].letterUpperCase, "7", 2);
    allKeys[index].xPos = 2 + 3 * 6;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "8", 2);
    strncpy(allKeys[index].letterUpperCase, "8", 2);
    allKeys[index].xPos = 2 + 3 * 7;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "9", 2);
    strncpy(allKeys[index].letterUpperCase, "9", 2);
    allKeys[index].xPos = 2 + 3 * 8;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    strncpy(allKeys[index].letter, "0", 2);
    strncpy(allKeys[index].letterUpperCase, "0", 2);
    allKeys[index].xPos = 2 + 3 * 9;
    allKeys[index].yPos = 2 + 3 * (yOffset - 1);
    index++;

    //
    if (isAzerty)
    {
        strncpy(allKeys[index].letter, "a", 2);
        strncpy(allKeys[index].letterUpperCase, "A", 2);
    }
    else
    {
        strncpy(allKeys[index].letter, "q", 2);
        strncpy(allKeys[index].letterUpperCase, "Q", 2);
    }
    allKeys[index].xPos = 1 + 3 * 0;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    if (isAzerty)
    {
        strncpy(allKeys[index].letter, "z", 2);
        strncpy(allKeys[index].letterUpperCase, "Z", 2);
    }
    else
    {
        strncpy(allKeys[index].letter, "w", 2);
        strncpy(allKeys[index].letterUpperCase, "W", 2);
    }
    allKeys[index].xPos = 1 + 3 * 1;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "e", 2);
    strncpy(allKeys[index].letterUpperCase, "E", 2);
    allKeys[index].xPos = 1 + 3 * 2;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "r", 2);
    strncpy(allKeys[index].letterUpperCase, "R", 2);
    allKeys[index].xPos = 1 + 3 * 3;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "t", 2);
    strncpy(allKeys[index].letterUpperCase, "T", 2);
    allKeys[index].xPos = 1 + 3 * 4;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "y", 2);
    strncpy(allKeys[index].letterUpperCase, "Y", 2);
    allKeys[index].xPos = 1 + 3 * 5;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "u", 2);
    strncpy(allKeys[index].letterUpperCase, "U", 2);
    allKeys[index].xPos = 1 + 3 * 6;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "i", 2);
    strncpy(allKeys[index].letterUpperCase, "I", 2);
    allKeys[index].xPos = 1 + 3 * 7;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "o", 2);
    strncpy(allKeys[index].letterUpperCase, "O", 2);
    allKeys[index].xPos = 1 + 3 * 8;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    strncpy(allKeys[index].letter, "p", 2);
    strncpy(allKeys[index].letterUpperCase, "P", 2);
    allKeys[index].xPos = 1 + 3 * 9;
    allKeys[index].yPos = 1 + 3 * (yOffset + 0);
    index++;

    // ROW 2
    if (isAzerty)
    {
        strncpy(allKeys[index].letter, "q", 2);
        strncpy(allKeys[index].letterUpperCase, "Q", 2);
    }
    else
    {
        strncpy(allKeys[index].letter, "a", 2);
        strncpy(allKeys[index].letterUpperCase, "A", 2);
    }
    allKeys[index].xPos = 2 + 3 * 0;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "s", 2);
    strncpy(allKeys[index].letterUpperCase, "S", 2);
    allKeys[index].xPos = 2 + 3 * 1;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "d", 2);
    strncpy(allKeys[index].letterUpperCase, "D", 2);
    allKeys[index].xPos = 2 + 3 * 2;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "f", 2);
    strncpy(allKeys[index].letterUpperCase, "F", 2);
    allKeys[index].xPos = 2 + 3 * 3;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "g", 2);
    strncpy(allKeys[index].letterUpperCase, "G", 2);
    allKeys[index].xPos = 2 + 3 * 4;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "h", 2);
    strncpy(allKeys[index].letterUpperCase, "H", 2);
    allKeys[index].xPos = 2 + 3 * 5;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "j", 2);
    strncpy(allKeys[index].letterUpperCase, "J", 2);
    allKeys[index].xPos = 2 + 3 * 6;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "k", 2);
    strncpy(allKeys[index].letterUpperCase, "K", 2);
    allKeys[index].xPos = 2 + 3 * 7;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    strncpy(allKeys[index].letter, "l", 2);
    strncpy(allKeys[index].letterUpperCase, "L", 2);
    allKeys[index].xPos = 2 + 3 * 8;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    if (isAzerty)
    {
        strncpy(allKeys[index].letter, "m", 2);
        strncpy(allKeys[index].letterUpperCase, "M", 2);
    }
    else
    {
        strncpy(allKeys[index].letter, "?", 2);
        strncpy(allKeys[index].letterUpperCase, "?", 2);
    }
    allKeys[index].xPos = 2 + 3 * 9;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 1);
    index++;

    // ROW 3
    if (isAzerty)
    {
        strncpy(allKeys[index].letter, "w", 2);
        strncpy(allKeys[index].letterUpperCase, "W", 2);
    }
    else
    {
        strncpy(allKeys[index].letter, "z", 2);
        strncpy(allKeys[index].letterUpperCase, "Z", 2);
    }
    allKeys[index].xPos = 3 + 3 * 0;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, "x", 2);
    strncpy(allKeys[index].letterUpperCase, "X", 2);
    allKeys[index].xPos = 3 + 3 * 1;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, "c", 2);
    strncpy(allKeys[index].letterUpperCase, "C", 2);
    allKeys[index].xPos = 3 + 3 * 2;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, "v", 2);
    strncpy(allKeys[index].letterUpperCase, "V", 2);
    allKeys[index].xPos = 3 + 3 * 3;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, "b", 2);
    strncpy(allKeys[index].letterUpperCase, "B", 2);
    allKeys[index].xPos = 3 + 3 * 4;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, "n", 2);
    strncpy(allKeys[index].letterUpperCase, "N", 2);
    allKeys[index].xPos = 3 + 3 * 5;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    if (isAzerty)
    {
        strncpy(allKeys[index].letter, "?", 2);
        strncpy(allKeys[index].letterUpperCase, "?", 2);
    }
    else
    {
        strncpy(allKeys[index].letter, "m", 2);
        strncpy(allKeys[index].letterUpperCase, "M", 2);
    }
    allKeys[index].xPos = 3 + 3 * 6;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, ".", 2);
    strncpy(allKeys[index].letterUpperCase, ".", 2);
    allKeys[index].xPos = 3 + 3 * 7;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    strncpy(allKeys[index].letter, "!", 2);
    strncpy(allKeys[index].letterUpperCase, "!", 2);
    allKeys[index].xPos = 3 + 3 * 8;
    allKeys[index].yPos = 1 + 2 * (yOffset2 + 2);
    index++;

    index = 0;
    strncpy(allOtherKeys[index].name, "space", 8);
    allOtherKeys[index].xPos = 14;
    allOtherKeys[index].yPos = 1 + 2 * (yOffset2 + 3);
    allOtherKeys[index].xCenter = 19;
    allOtherKeys[index].xSize = 30;
    allOtherKeys[index].ySize = 2;
    allOtherKeys[index].visible = false;
    allOtherKeys[index].OnClick = &makeSpace;
    index++;

    strncpy(allOtherKeys[index].name, "del", 8);
    allOtherKeys[index].xPos = 23;
    allOtherKeys[index].yPos = 1 + 2 * (yOffset2 + 3);
    allOtherKeys[index].xCenter = 11;
    allOtherKeys[index].xSize = 30;
    allOtherKeys[index].ySize = 2;
    allOtherKeys[index].OnClick = &makeDelete;
    index++;

    strncpy(allOtherKeys[index].name, "caps", 8);
    allOtherKeys[index].xPos = 6;
    allOtherKeys[index].yPos = 1 + 2 * (yOffset2 + 3);
    allOtherKeys[index].xCenter = 19;
    allOtherKeys[index].xSize = 30;
    allOtherKeys[index].ySize = 2;
    allOtherKeys[index].OnClick = &shiftKeyboard;
    index++;

    strncpy(allOtherKeys[index].name, "confirm", 8);
    allOtherKeys[index].xPos = 23;
    allOtherKeys[index].yPos = 2 + 2 * (yOffset2 + 4);
    allOtherKeys[index].xCenter = 26;
    allOtherKeys[index].xSize = 34;
    allOtherKeys[index].ySize = 2;
    allOtherKeys[index].OnClick = &confirmKeyboard;
    index++;

    strncpy(allOtherKeys[index].name, "cancel", 8);
    allOtherKeys[index].xPos = 10;
    allOtherKeys[index].yPos = 2 + 2 * (yOffset2 + 4);
    allOtherKeys[index].xCenter = 22;
    allOtherKeys[index].xSize = 30;
    allOtherKeys[index].ySize = 2;
    allOtherKeys[index].OnClick = &cancelKeyboard;
    index++;
}

/**
 * @brief Draw keyboard
 *
 */
void drawKeyBoard()
{
    // Screen background
    NE_2DDrawQuad(0, 0, 256, 196, 20, RGB15(3, 3, 3));
    // Keyboard background
    NE_2DDrawQuad(0, 80, 256, 168, 19, RGB15(4, 4, 4));

    // Draw every keys
    for (int i = 0; i < KEY_COUNT; i++)
    {
        if (allKeys[i].visible)
        {
            // Print text
            if (isUpperCase)
            {
                NE_TextPrint(0,                                // Font slot
                             allKeys[i].xPos, allKeys[i].yPos, // Coordinates x(column), y(row)
                             NE_White,                         // Color
                             allKeys[i].letterUpperCase);
            }
            else
            {
                NE_TextPrint(0,                                // Font slot
                             allKeys[i].xPos, allKeys[i].yPos, // Coordinates x(column), y(row)
                             NE_White,                         // Color
                             allKeys[i].letter);
            }
            float xPos = allKeys[i].xPos * 8;
            float yPos = allKeys[i].yPos * 8;
            NE_2DDrawQuad((xPos)-6, (yPos)-3, (xPos) + 13, (yPos) + 12, 11, RGB15(7, 7, 7));
            NE_2DDrawQuad((xPos)-5, (yPos)-2, (xPos) + 12, (yPos) + 11, 10, RGB15(6, 6, 6));
        }
    }

    // Draw every specials keys
    for (int i = 0; i < OTHER_KEY_COUNT; i++)
    {
        if (allOtherKeys[i].visible)
        {
            // Print text
            NE_TextPrint(0,                                          // Font slot
                         allOtherKeys[i].xPos, allOtherKeys[i].yPos, // Coordinates x(column), y(row)
                         NE_White,                                   // Color
                         allOtherKeys[i].name);
            float xPos = allOtherKeys[i].xPos * 8;
            float yPos = allOtherKeys[i].yPos * 8;
            NE_2DDrawQuad(xPos - allOtherKeys[i].xSize - 1 + allOtherKeys[i].xCenter, yPos - allOtherKeys[i].ySize - 1, xPos + allOtherKeys[i].xSize + 1 + allOtherKeys[i].xCenter, yPos + 12, 11, RGB15(7, 7, 7));
            NE_2DDrawQuad(xPos - allOtherKeys[i].xSize + allOtherKeys[i].xCenter, yPos - allOtherKeys[i].ySize, xPos + allOtherKeys[i].xSize + allOtherKeys[i].xCenter, yPos + 11, 10, RGB15(6, 6, 6));
        }
    }
}

/**
 * @brief Read keyboard inputs
 *
 */
void readKeyboard()
{
    if (isShowingKeyBoard && uiTimer == 0)
    {
        // Read keys
        for (int i = 0; i < KEY_COUNT; i++)
        {
            float xPos = allKeys[i].xPos * 8;
            float yPos = allKeys[i].yPos * 8;
            if ((keysdown & KEY_TOUCH && allKeys[i].visible && touch.px >= xPos - 6 && touch.px <= xPos + 13 && touch.py >= yPos - 4 && touch.py <= yPos + 8))
            {
                int tempTextLength = strlen(tempText);
                if (tempTextLength < maxInputLength)
                {
                    if (isUpperCase)
                        sprintf(tempText + tempTextLength, allKeys[i].letterUpperCase);
                    else
                        sprintf(tempText + tempTextLength, allKeys[i].letter);
                }
                PlayBasicSound(SFX_KEYBOARD_SOUND);
                break;
            }
        }

        // Read specials keys
        for (int i = 0; i < OTHER_KEY_COUNT; i++)
        {
            float xPos = allOtherKeys[i].xPos * 8;
            float yPos = allOtherKeys[i].yPos * 8;
            if ((keysdown & KEY_TOUCH && allOtherKeys[i].visible && touch.px >= xPos - allOtherKeys[i].xSize + allOtherKeys[i].xCenter && touch.px <= xPos + allOtherKeys[i].xSize + allOtherKeys[i].xCenter && touch.py >= yPos - 4 && touch.py <= yPos + 8))
            {
                allOtherKeys[i].OnClick();
                PlayBasicSound(SFX_KEYBOARD_SOUND);
                break;
            }
        }
    }
}

/**
 * @brief Delete a char from the input string
 *
 */
void makeDelete()
{
    int tempTextLength = strlen(tempText);
    if (tempTextLength > 0)
        tempText[tempTextLength - 1] = '\0';
}

/**
 * @brief Add a space in the input string
 *
 */
void makeSpace()
{
    int tempTextLength = strlen(tempText);
    if (tempTextLength < maxInputLength)
        sprintf(tempText + tempTextLength, " ");
}

/**
 * @brief Confirm the input string
 *
 */
void confirmKeyboard()
{
    // if the input string length is respected
    if (strlen(tempText) >= minInputLength && strlen(tempText) <= maxInputLength)
    {

        isShowingKeyBoard = false;
        isUpperCase = false;
        if (keyboardAction == KEYBOARD_ACTION_CHANGE_NAME) // Set player name
        {
            strncpy(localPlayer->name, tempText, PLAYER_MAX_LENGTH);
            uiTimer = 8;
            actionOfUiTimer = SAVE;
        }
        else if (keyboardAction == KEYBOARD_ACTION_ENTER_CODE) // Set online party code
        {
            for (int i = 0; i < 5; i++)
            {
                partyCode[i] = tempText[i];
            }
        }

        // Call the succes function
        onKeyboardCloseSucces(returnToMenuOnSucces);
    }
}

/**
 * @brief Cancel the input string
 *
 */
void cancelKeyboard()
{
    strncpy(tempText, "", 21);
    isShowingKeyBoard = false;
    isUpperCase = false;

    if (keyboardAction == KEYBOARD_ACTION_ENTER_CODE) // Empty the online party code
    {
        strncpy(partyCode, "", PARTY_CODE_LENGTH);
    }

    // Call the cancel function
    onKeyboardCloseCancel(returnToMenuOnCancel);
}

/**
 * @brief Change the keyboard to case
 *
 */
void shiftKeyboard()
{
    isUpperCase = !isUpperCase;

    // Refresh screen
    UpdateBottomScreenFrameCount += 8;
}
```

`Counter-Strike-nds/source/inputs/keyboard.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef KEYBOARD_H_ /* Include guard */
#define KEYBOARD_H_

//#include <NEMain.h>
#include "main.h"

enum keyboardActionEnum
{
    KEYBOARD_ACTION_CHANGE_NAME = 0,
    KEYBOARD_ACTION_ENTER_CODE = 1,
};

extern char tempText[21];
extern int returnToMenuOnCancel;
extern int returnToMenuOnSucces;
extern bool isAzerty;
extern void (*onKeyboardCloseSucces)();
extern void (*onKeyboardCloseCancel)();
extern int keyboardAction;
extern int maxInputLength;
extern int minInputLength;
extern bool isUpperCase;

#define SHITF_KEY_INDEX 2

void initKeyboard();
void drawKeyBoard();
void readKeyboard();
void makeSpace();
void makeDelete();
void confirmKeyboard();
void cancelKeyboard();
void shiftKeyboard();
void changeKeyboardMode();
void SetCanChangeCase(bool value);

#endif // KEYBOARD_H_
```

`Counter-Strike-nds/source/main.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "collisions.h"
#include "raycast.h"
#include "movements.h"
#include "sounds.h"
#include "main.h"
#include "network.h"
#include "debug.h"
#include "ui.h"
#include "gun.h"
#include "grenade.h"
#include "equipment.h"
#include "ai.h"
#include "ai/data/ai_data.h"
#include "map.h"
#include "party.h"
#include "keyboard.h"
#include "draw3d.h"
#include "saveManager.h"
#include "input.h"
#include "player.h"
#include "tutorial.h"
#include "stats.h"
#include "camera.h"

//
//////Level
// Whole level 3D models and physics
NE_Model *Model[13]; ////////////REMOVE OR CHANGE THIS
// Models for wall flashs for guns
NE_Model *flashModels[FLASH_MODELS_COUNT];

// Materials
NE_Material *GroundMaterial = NULL;
NE_Material *GroundMaterialShadowed = NULL;

//
//////Players
Player AllPlayers[MaxPlayer];
// Player values
int PlayerCount = 0;
// Old local player position
float OldxPos, OldyPos, OldzPos = 0;
// Timer for the player's jump
int CanJump = 0;
// CanJumpRealTimer is used wait a little bit of time before the player can jump
int CanJumpRealTimer = 2;

// Number of frame when the player is in the air
int frameCountDuringAir = 0;
// Is the player on stairs?
bool isOnStairs = false;
// Is the player descending stairs?
bool isInDownStairs = false;
// Ask jump from UI button
bool NeedJump = false;

// Head bobing speed
float BobbingSpeed = 0.07;

// Materials
NE_Material *PlayerMaterial = NULL;
NE_Material *PlayerMaterialTerrorist = NULL;
NE_Material *PlayerShadowMaterial = NULL;

//////Guns
// Number if frame of showing the muzzle flash at screen
int ShowMuzzle = 0;
// Number of frame of showing the wall shit flash (it's a list because it's possible to have more than one at the same time)
int ShowWallHitFlash[FLASH_MODELS_COUNT] = {0, 0, 0, 0, 0, 0};
// Guns sprites positions
int rightGunX = 0;
int rightGunY = 0;
int leftGunX = 0;
int leftGunY = 0;

// All scopes data
Scope AllScopeLevels[2];
// Current scope level used by the player
int CurrentScopeLevel = 0;

// Gun recoil values
int GunMaxRecoil = 16;
int GunMinRecoil = 6;

//
//////Camera
NE_Camera *Camera = NULL;
// [-1;1] values, 3D position of a point in a sphere by using player and camera angle to get the point
float x = 0, y = 0, z = 0;
// [-1;1] values, 2D position of a point in a sphere by using player and camera angle to get the point
float xWithoutY = 0, zWithoutY = 0, xWithoutYForAudio = 0, zWithoutYForAudio = 0, xWithoutYForMap = 0, zWithoutYForMap = 0, xWithoutYForOcclusionSide1 = 0, zWithoutYForOcclusionSide1 = 0, xWithoutYForOcclusionSide2 = 0, zWithoutYForOcclusionSide2 = 0;
// camera view offset
float xOffset = 0, yOffset = 0;
// Camera angle
// float CameraAngleY = 128;

// Current player's view index for the camera
int CurrentCameraPlayer = 0;
// Need to update the sphere positions values of the camera
bool NeedUpdateViewRotation = false;

// Animations
#define DEATH_ANIMATION_SPEED 0.025
// [0 ; 1] progression of the death animation
float deathCameraAnimation = 0;
// Offset of the death animation camera
float deathCameraYOffset = 0;

// Raycasting
// Index of all hitted client (for raycasting)
int hittedClient[FLASH_MODELS_COUNT] = {NO_PLAYER, NO_PLAYER, NO_PLAYER, NO_PLAYER, NO_PLAYER, NO_PLAYER};

// TODO replace by Vector3Int array
// Positions of all wall hit flashs
int WallHitXPos[FLASH_MODELS_COUNT] = {0, 0, 0, 0, 0, 0};
int WallHitYPos[FLASH_MODELS_COUNT] = {0, 0, 0, 0, 0, 0};
int WallHitZPos[FLASH_MODELS_COUNT] = {0, 0, 0, 0, 0, 0};
// Distance of all hits
float hitDistance[FLASH_MODELS_COUNT] = {0, 0, 0, 0, 0, 0};

// Other
// Is the player is fully in a smoke area?
bool isInFullSmoke = false;

// Retain the team of the player to send to the server
int tempTeam = 0;

// All sprites used for the top screen
NE_Sprite *TopScreenSprites[2]; // 0 Map, 1 crosshair
// All sprites used for the bottom screen
NE_Sprite *BottomScreenSprites[1];
// All checkboxes used for the bottom screen
CheckBox AllCheckBoxs[CheckBoxCount];
// All sliders used for the bottom screen
Slider AllSliders[SliderCount];
// All buttons used for the bottom screen
Button AllButtons[ButtonCount];

// Timer to draw the event text
int textToShowTimer = 0;
// Timer to draw the kill event text
int KillTextShowTimer = 0;
// Selected gun in the shop
int SelectedGunShop = 0;

// Is 30 fps mode enabled with bottom screen refresh?
bool AlwaysUpdateBottomScreen = false;
// Ask to enable 30 fps mode with bottom screen refresh
bool NeedChangeScreen = false;
// Number of frame for 30 fps mode
int UpdateBottomScreenFrameCount = 0;
// Button to show count
int ButtonToShow = 0;
// Number of frame to show the health bar with red color
int redHealthTextCounter = 0;
// Number of frame for aiming activation
int doubleTapTimer = 0;

//
//////Party
// Current opened menu
int currentMenu = -1; // 0 Main menu //1 Map //2 Score //3 Shop categories //4 Settings //5 Quit //6 Shop
// Is party started?
bool PartyStarted = false;
// Need to apply game rules? (true in solo mode, false in online mode)
bool applyRules = false;
// Number of lose of terrorists team
int LoseCountTerrorists = 0;
// Number of lose of counter terrorists team
int LoseCountCounterTerrorists = 0;

// Timer to change party timer
int changeSecondTimer = 60;
int changeMinuteTimer = 60;

// Is the bomb set? TODO : maybe to replace by the existing var BombPlanted
bool bombSet = false;

//
//////Bomb
// Bomb bip timer frame count
int bombBipTimer = 120;
// Bomb position (w = angle)
Vector4 BombPosition;
// Is the bomb planted?
bool BombPlanted = false;
// Is the bomb defused?
bool BombDefused = false;
// Will the bomb explode?
bool BombWillExplode = false;
// Trigger area to defuse the bomb
CollisionBox2D bombDefuseZone;
// Bomb effect scale
int BombExplosionScale = 0;
// Is the bomb exploding?
bool IsExplode = false;

// Timer before disable the shop
int shopDisableTimer = SHOP_DISABLE_TIMER;
// Trigger for the shop zone
CollisionBoxF shopZone;
// Is the player in the shop zone
bool isInShopZone = false;

// Rumble pack timer
int RumbleTimer = 0;
// Is rumble enabled?
bool useRumble = false;

// Connection type (offline for solo)
enum connectionType Connection = UNSELECTED;

// Local player pointer
Player *localPlayer = &AllPlayers[0];

// Wait before doing some action (for example, save the party), we want to wait to avoid a screen refresh at the same time and cause a visual bug
int uiTimer = 0;
// Action to do after the ui timer
enum actionAfterUiTimer actionOfUiTimer = SAVE;

// Is the player using bomb? (planting or defusing)
bool isUsingBomb = false;
// Can the player change gun?
bool canChangeGun = true;
// Can the player shoot?
bool canShoot = true;

// How many players want to start the party (vote)
int playerWantToStart = 0;
// How many players are needed to start the party (vote)
int playerWantToStartLimite = 0;

/**
 * @brief Init the game (launch the engine, load textures, sounds, 3D models, init keyboard...)
 *
 * @return int Result
 */
int main(void)
{
	irqEnable(IRQ_HBLANK);
	irqSet(IRQ_VBLANK, NE_VBLFunc);
	irqSet(IRQ_HBLANK, NE_HBLFunc);

	// Init random
	srand(time(NULL));

	// Init
	NE_InitDual3D();
	// Anti aliasing
	NE_AntialiasEnable(true);

	// Error debug handler for Nitro Engine
	NE_DebugSetHandler(error_handler);

	NE_SetFov(70);											  // Set FOV
	NE_ClippingPlanesSetI(floattof32(0.1), floattof32(90.0)); // Set render distance

	readKeys();

	initDebug();

	// Init fat file system
	if (!fatInitDefault())
	{
		// iprintf("Warning: fatInit failure!\n");
	}

	initInputs();

	// Init default player name
	strcpy(localPlayer->name, "Player");

	// Load save file
	Load();

	// Init rumble pack
	isRumbleInserted();

	/*if (!nitroFSInit(NULL))
	{
		iprintf("nitroFSInit failure!\n");
	}*/

	// Init sound system
	initSoundSystem();
	// Init keyboard
	initKeyboard();

	// Set bots names
	loadBotsNames();

	// Load guns/grenades/equipments data
	initGuns();
	initGrenades();
	initEquipments();

	// Load maps data
	LoadMapTextures();
	SetMapCameraPosition();
	AddAllSpawnPoints();
	SetMapNames();
	SetMapPartyMode();

	// Camera
	Camera = NE_CameraCreate();
	ForceUpdateLookRotation(localPlayer->cameraAngle);

	// Set start camera position to look the map
	setCameraMapPosition();

	initGraphics();

	// Load the default map
	LoadMap(currentMap);

	// load party modes
	AddAllPartyModes();

	// Set scope levels
	AllScopeLevels[0].scopeCount = 2;
	AllScopeLevels[0].fov[0] = 20;
	AllScopeLevels[0].fov[1] = 7;
	AllScopeLevels[0].Speed = 140;

	AllScopeLevels[1].scopeCount = 1;
	AllScopeLevels[1].fov[0] = 20;
	AllScopeLevels[1].Speed = 140;

	// Set all player ID to UNUSED
	for (int i = 0; i < MaxPlayer; i++)
	{
		AllPlayers[i].Id = UNUSED;
		AllPlayers[i].Team = SPECTATOR;
	}

	// Lights
	NE_LightSet(0, RGB15(31, 31, 31), -0.5, -0.5, -0.5);

	// Set background color
	NE_ClearColorSet(RGB15(17, 26, 29), 31, 63); // Blue sky

	if (isDebugMode)
	{
		// DEBUG show connection mode
		printf("A : Offline mode\n");				 // 0
		printf("B : %s\n", DEBUG_IP_1_STRING);		 // 1
		printf("Y : %s\n", ONLINE_SERVER_IP_STRING); // 2
		printf("X : %s\n", DEBUG_IP_2_STRING);		 // 3
	}

	// Check if we need to start the tutorial
	if (!tutorialDone)
	{
		// Load sounds
		loadSounds();
		isInTutorial = true;
		currentSelectionMap = TUTORIAL;
		StartSinglePlayer(2);
	}
	else
	{
		initMainMenu();
	}

	// Loop to start parties
	while (true)
	{
		checkStartGameLoop();
	}

	return 0;
}

/**
 * @brief Loop to check if the player want to start a party
 *
 */
void checkStartGameLoop()
{
	checkMusicSteaming();

	// Play without internet
	if (Connection == OFFLINE)
	{
		prepareParty(0);

		// Unload old map and load new one
		if (currentMap != currentSelectionMap)
		{
			UnLoadMap(currentMap);
			currentMap = currentSelectionMap;
			LoadMap(currentMap);
		}

		AddNewPlayer(0, true, false);

		// Add bots
		if (currentPartyMode != 2)
		{
			for (int i = 1; i < MaxPlayer; i++)
				AddNewPlayer(i, false, true);
		}

		if (isInTutorial)
		{
			AllPlayers[0].Team = TERRORISTS;
		}
		else
		{
			while (AllPlayers[0].Team == SPECTATOR)
			{
				readKeys();

				ReadTouchScreen(touch, &NeedChangeScreen, &AlwaysUpdateBottomScreen, &ButtonToShow, &UpdateBottomScreenFrameCount, &SendTeam, true);
				UpdateEngineNotInGame();

				if (Connection == UNSELECTED)
					return;
			}

			SetNeedChangeScreen(true);
		}

		initControllerMenu();

		// Set randomly players in a team

		int rnd = AllPlayers[0].Team;
		for (int i = 0; i < PlayerCount; i++) // TODO replace
		{
			if (rnd != i % 2)
			{
				AllPlayers[i].Team = COUNTERTERRORISTS;
			}
			else
			{
				AllPlayers[i].Team = TERRORISTS;
			}
			UpdatePlayerTexture(i);
		}
		AllPlayers[2].Team = AllPlayers[1].Team;
		UpdatePlayerTexture(2);

		setPlayersPositionAtSpawns();

		checkShopForBots();

		while (Connection == OFFLINE)
		{
			// Play game code
			GameLoop();
			UpdateEngine();
		}
	}
	else if (Connection != UNSELECTED)
	{
		// FOR ONLINE
		JoinParty(JOIN_RANDOM_PARTY);
	}
	else
	{
		readKeys();
		// For debug, rapid party start
		if (isDebugMode && currentMenu == MAIN)
		{
			if ((keysdown & KEY_A) == KEY_A)
				Connection = OFFLINE;
			else if ((keysdown & KEY_B) == KEY_B)
				Connection = DEBUG_IP_1;
			else if ((keysdown & KEY_Y) == KEY_Y)
				Connection = ONLINE_SERVER_IP;
			else if ((keysdown & KEY_X) == KEY_X)
				Connection = DEBUG_IP_2;
		}
		ReadTouchScreen(touch, &NeedChangeScreen, false, &ButtonToShow, &UpdateBottomScreenFrameCount, &SendTeam, true);
		UpdateEngineNotInGame();
	}
}

/**
 * @brief Join an online party
 *
 * @param option Join option see JoinType enum in network.h
 */
void JoinParty(int option)
{
	if (Connection == UNSELECTED)
	{
		Connection = ONLINE_SERVER_IP;
	}
	// WIFI CODE
	prepareParty(1);

	// END WIFI CODE
	initNetwork(option);
}

// Getters / setters

int GetCurrentMenu()
{
	return currentMenu;
}

void SetCurrentMenu(int value)
{
	currentMenu = value;
}

int GetUpdateBottomScreenOneFrame()
{
	return UpdateBottomScreenFrameCount;
}

void SetUpdateBottomScreenOneFrame(int value)
{
	UpdateBottomScreenFrameCount = value;
}

int GetButtonToShow()
{
	return ButtonToShow;
}

void SetButtonToShow(int value)
{
	ButtonToShow = value;
}

void SetWaitForTeamResponse(bool value)
{
	WaitForTeamResponse = value;
}

Grenade *GetAllGrenades()
{
	return AllGrenades;
}

CheckBox *GetCheckBoxs()
{
	return AllCheckBoxs;
}

NE_Sprite **GetSpritesTop()
{
	return TopScreenSprites;
}

NE_Sprite **GetSpritesBottom()
{
	return BottomScreenSprites;
}

NE_Material **GetBottomScreenSpritesMaterials()
{
	return BottomScreenSpritesMaterials;
}

NE_Palette **GetPalettes()
{
	return Palettes;
}

bool GetAlwaysUpdateBottomScreen()
{
	return AlwaysUpdateBottomScreen;
}

void SetAlwaysUpdateBottomScreen(bool value)
{
	AlwaysUpdateBottomScreen = value;
}

bool GetNeedChangeScreen()
{
	return NeedChangeScreen;
}

bool GetIsDebugTopScreen()
{
	return isDebugTopScreen;
}

void SetIsDebugTopScreen(bool value)
{
	isDebugTopScreen = value;
}

void SetNeedChangeScreen(bool value)
{
	NeedChangeScreen = value;
}

void SetSendTeam(bool Value)
{
	SendTeam = Value;
}

void SetTempTeam(int Value)
{
	tempTeam = Value;
}

int GetTempTeam()
{
	return tempTeam;
}

void SetPing(int Value)
{
	ping = Value;
}
int GetPing()
{
	return ping;
}

void SetCounterScore(int Value)
{
	CounterScore = Value;
}
int GetCounterScore()
{
	return CounterScore;
}

void SetTerroristsScore(int Value)
{
	TerroristsScore = Value;
}
int GetTerroristsScore()
{
	return TerroristsScore;
}

void SetTextToShowTimer(int Value)
{
	textToShowTimer = Value;
}
int GetTextToShowTimer()
{
	return textToShowTimer;
}

void SetNeedJump()
{
	if (!localPlayer->IsDead && roundState != WAIT_START)
		NeedJump = true;
}

void SetSelectedGunShop(int Value)
{
	SelectedGunShop = Value;
}

int GetSelectedGunShop()
{
	return SelectedGunShop;
}

void SetCurrentCameraPlayer(int Value)
{
	CurrentCameraPlayer = Value;
	UpdateGunTexture();
}

int GetCurrentCameraPlayer()
{
	return CurrentCameraPlayer;
}

void SetSendBuyWeapon(bool Value)
{
	SendBuyWeapon = Value;
}

void SetNeedUpdateViewRotation(bool Value)
{
	NeedUpdateViewRotation = Value;
}

bool GetNeedUpdateViewRotation()
{
	return NeedUpdateViewRotation;
}

void SetSendPosition(bool Value)
{
	SendPosition = Value;
}

bool GetSendPosition()
{
	return SendPosition;
}

void SetCameraAngleY(float Value)
{
	localPlayer->cameraAngle = Value;
}

float GetCameraAngleY()
{
	return localPlayer->cameraAngle;
}

int GetCurrentScopeLevel()
{
	return CurrentScopeLevel;
}

void SetDoubleTapTimer(int Value)
{
	doubleTapTimer = Value;
}

int GetDoubleTapTimer()
{
	return doubleTapTimer;
}

/**
 * @brief Reduce the rumble timer every frame
 *
 */
void reduceRumbleTimer()
{
	// If rumble timer is on, reduce it
	if (useRumble && RumbleTimer != 0)
	{
		RumbleTimer--;
		// If timer = 0, disable rumble
		if (RumbleTimer == 0)
			setRumble(false);
	}
}

/**
 * @brief Reduce double tap timer every frame for aiming from the gamepad
 *
 */
void reduceDoubleTapTimer()
{
	// Reduce double tab timer
	if (doubleTapTimer > 0)
		doubleTapTimer--;
}

/**
 * @brief Game loop
 *
 */
void GameLoop()
{
	// Read keys
	readKeys();

	reduceRumbleTimer();

	// Get local player position
	CalculatePlayerPosition(0);

	// Check if player can defuse or plant the bomb
	bool CanPutBomb = false, canDefuseBomb = false;
	CheckZones(bombDefuseZone, &CanPutBomb, &canDefuseBomb);

	checkTakingBombZone(bombDefuseZone);

	// Check if the player is in the shop zone
	if (allPartyModes[currentPartyMode].limitedShopByZoneAndTimer)
		checkShopZone(); // Check
	else
		isInShopZone = true; // Enable shop zone every where

	UpdateGrenades();

	reduceDoubleTapTimer();

	// Check touchscreen input for menus
	ReadTouchScreen(touch, &NeedChangeScreen, &AlwaysUpdateBottomScreen, &ButtonToShow, &UpdateBottomScreenFrameCount, &SendTeam, false);

	if (isInTutorial)
		checkTutorial();

	// If local player is not a spectator
	if (localPlayer->Team != SPECTATOR)
	{
		// Change gun in inventory if needed
		if (isKeyDown(LEFT_GUN))
		{
			ChangeGunInInventoryForLocalPlayer(1);
		}
		else if (isKeyDown(RIGHT_GUN))
		{
			ChangeGunInInventoryForLocalPlayer(0);
		}

		// Check input and rotate player
		RotatePlayer(&NeedUpdateViewRotation, &SendPosition, &localPlayer->cameraAngle);

		// Update look rotation value
		if (NeedUpdateViewRotation || CurrentCameraPlayer != 0)
		{
			UpdateLookRotation(localPlayer->cameraAngle);
			NeedUpdateViewRotation = false;
		}

		isInDownStairs = false;
		// Check if the player is on a stairs
		CheckStairs(&CanJump, &isInDownStairs);

		// Reduce jump timer
		if (CanJump > 0)
			CanJump--;

		// Check for jump
		if (roundState != WAIT_START && !localPlayer->IsDead)
		{
			// CanJumpRealTimer is used wait a little bit of time before the player can jump
			// Set CanJumpReal timer
			if (localPlayer->PlayerPhysic->yspeed == 0 && CanJumpRealTimer > 0)
				CanJumpRealTimer--;
			else if (localPlayer->PlayerPhysic->yspeed != 0)
				CanJumpRealTimer = 2;

			// If player is in the air, increase the frameCountDuringAir
			if (CanJumpRealTimer != 0 && !isInDownStairs)
				frameCountDuringAir++;
			else if ((CanJumpRealTimer == 0 || isInDownStairs) && frameCountDuringAir > 20) // Make jump land sound if the player was more than 0,33 secs in the air
			{
				frameCountDuringAir = 0;
				Play2DSound(SFX_LAND, 140);
				NeedJump = false;
			}
			else
				frameCountDuringAir = 0;

			// If the player can jump and if jump input is down
			if ((isKeyDown(JUMP_BUTTON) || NeedJump) && (CanJumpRealTimer == 0 || CanJump > 0))
			{
				// Apply force on the player
				NeedJump = false;
				localPlayer->PlayerPhysic->yspeed = JumpForce;
				CanJump = 0;
			}
		}

		// Set aiming view
		if (isKeyDown(SCOPE_BUTTON))
		{
			SetAim();
		}

		Player *playerWithView = &AllPlayers[CurrentCameraPlayer];
		float cameraFinalY = playerWithView->position.y + CameraOffsetY;

		// Set camera position
		NE_CameraSet(Camera,
					 playerWithView->position.x, cameraFinalY - deathCameraYOffset, playerWithView->position.z,
					 playerWithView->position.x + x + xOffset, cameraFinalY + y + yOffset + deathCameraYOffset, playerWithView->position.z + z + xOffset,
					 0, 1, 0);
	}

	reduceScreenShake();

	// Check for each players
	for (int i = 0; i < MaxPlayer; i++)
	{
		Player *player = &AllPlayers[i];
		if (player->Id == UNUSED)
			continue;

		// Check if the playe is in a shadow
		if (player->inShadow)
		{
			// Reduce player light intensity
			if (player->lightCoef > 0.7)
				player->lightCoef -= 0.05;
		}
		else
		{
			// Increase player light intensity
			if (player->lightCoef < 1)
				player->lightCoef += 0.05;
		}

		// Respawn player if needed
		if (player->NeedRespawn)
		{
			// Reduce timer
			player->RespawnTimer--;
			// If timer is 0, respawn player
			if (player->RespawnTimer == 0)
			{
				player->NeedRespawn = false;
				setPlayerPositionAtSpawns(i);
				resetPlayer(i);
				CheckShopForBot(i);
			}
		}

		// Reduce invincibility timer
		if (player->invincibilityTimer > 0)
		{
			player->invincibilityTimer--;
		}

		// Change gun sprite position to normal position if needed
		if (player->rightGunXRecoil > GunMinRecoil)
			player->rightGunXRecoil--;
		if (player->rightGunYRecoil > GunMinRecoil)
			player->rightGunYRecoil--;

		if (player->leftGunXRecoil > GunMinRecoil)
			player->leftGunXRecoil--;
		if (player->leftGunYRecoil > GunMinRecoil)
			player->leftGunYRecoil--;

		// Gun timer
		if (getPlayerCurrentGunIndex(player) < GunCount && player->GunWaitCount < getPlayerCurrentGun(player).fireRate)
			player->GunWaitCount++;

		// Gun reload timer
		if (player->isReloading)
		{
			if (getPlayerCurrentGunIndex(player) < GunCount && player->GunReloadWaitCount < getPlayerCurrentGun(player).ReloadTime)
				player->GunReloadWaitCount++;

			// If reload timer is ended, reload gun and stop reloading
			if (player->GunReloadWaitCount == getPlayerCurrentGun(player).ReloadTime)
			{
				player->isReloading = false;
				ReloadGun(i);
			}
		}
	}

	// Check if the player want to vote
	if (roundState == TRAINING && Connection != OFFLINE && PlayerCount != 1 && (keysdown & KEY_START))
	{
		SendVoteStartNow = true;
	}

	if (localPlayer->Team != SPECTATOR && !localPlayer->IsDead && roundState != WAIT_START)
	{
		if (shopDisableTimer > 0 && roundState != TRAINING && allPartyModes[currentPartyMode].limitedShopByZoneAndTimer)
		{
			shopDisableTimer--;
			if (shopDisableTimer == 0 && (currentMenu == SHOP || currentMenu == SHOPCATEGORIES))
			{
				initGameMenu();
			}
		}

		// Avoid game soft lock if the player pass through the map
		if (localPlayer->position.y <= -5 && Connection == OFFLINE)
		{
			setPlayerPositionAtSpawns(0);
		}

		// Gun shoot
		if (canShoot && !localPlayer->isReloading && ((getPlayerCurrentGunIndex(localPlayer) < GunCount && ((isKey(FIRE_BUTTON) && getPlayerCurrentGun(localPlayer).holdFireButton) || (isKeyDown(FIRE_BUTTON) && !getPlayerCurrentGun(localPlayer).holdFireButton)) && localPlayer->GunWaitCount >= getPlayerCurrentGun(localPlayer).fireRate)) && !isUsingBomb)
		{
			if (((localPlayer->currentGunInInventory == 1 || localPlayer->currentGunInInventory == 2) && localPlayer->AllAmmoMagazine[localPlayer->currentGunInInventory - 1].AmmoCount > 0) || getPlayerCurrentGun(localPlayer).isKnife)
			{
				if (!getPlayerCurrentGun(localPlayer).isKnife)
				{
					localPlayer->AllAmmoMagazine[localPlayer->currentGunInInventory - 1].AmmoCount--;
					// Gun sound
					PlayBasicSound(getPlayerCurrentGun(localPlayer).gunSound);
				}

				// Reset gun timer
				localPlayer->GunWaitCount = 0;

				// Reduce aiming accuracy
				if (yOffset < 0.1)
					yOffset += (rand() % 2 + 2) / 100.0;
				else if (yOffset < 0.16)
					yOffset += (rand() % 2 + 2) / 150.0;
				else
					yOffset += (rand() % 2 + 2) / 200.0;

				speedAimingReCenter = 1;
				speedAimingReCenterTimer = 8;

				// Set gun sprite offset position
				setGunRecoil(localPlayer);

				// Do multiple raycast if needed
				for (int i = 0; i < getPlayerCurrentGun(localPlayer).bulletCountPerShoot; i++)
				{
					if (getPlayerCurrentGun(localPlayer).bulletCountPerShoot != 1)
					{
						float xShoot, yShoot, zShoot;
						float xOffset = ((rand() % 100) - 50) / 3.0;
						float yOffset2 = ((rand() % 100) - 50) / 3.0;
						UpdateLookRotationAI(localPlayer->cameraAngle + yOffset2, localPlayer->Angle + xOffset, &xShoot, &yShoot, &zShoot);
						setRaycastValues(localPlayer, xShoot, yShoot + yOffset, zShoot);
					}
					else
					{
						setRaycastValues(localPlayer, x, y + yOffset, z);
					}

					// Raycast
					hittedClient[i] = Raycast(0, i, &hitDistance[i]);
					if (hittedClient[i] != NO_PLAYER)
					{
						makeHit(0, hittedClient[i], hitDistance[i], i);

						// If the player shoots a friend, show the warning message
						if (allPartyModes[currentPartyMode].teamDamage && AllPlayers[hittedClient[i]].Team == localPlayer->Team)
							showShootFriendMessage = 240;
					}
				}

				// Send shoot on network
				SendShoot = true;
			}
			else
			{
				startReloadGun(0);
			}
		}
		else if (getPlayerCurrentGunIndex(localPlayer) >= GunCount + shopGrenadeCount && isKey(FIRE_BUTTON) && !isLocalPlayerMoving())
		{
			if (getPlayerCurrentGunIndex(localPlayer) == GunCount + shopGrenadeCount && CanPutBomb && roundState == PLAYING && !BombPlanted && (CanJumpRealTimer == 0 || CanJump > 0))
			{
				isUsingBomb = true;
				// On bomb planting make a sound
				if (localPlayer->bombTimer == bombPlantingTime)
				{
					PlayBasicSound(SFX_BOMBPLANTING);
					SendBombPlacing = true;
				}
				localPlayer->bombTimer--;
				// Set bomb position when planted
				if (localPlayer->bombTimer == 0)
				{
					BombPosition.x = localPlayer->position.x;
					BombPosition.y = localPlayer->position.y - 0.845;
					BombPosition.z = localPlayer->position.z;
					BombPosition.r = localPlayer->Angle;

					bombPlantedAt = checkBombZoneWaypoint();

					if (applyRules)
					{
						bombSet = true;
						if (roundState == PLAYING)
						{
							PartyMinutes = allPartyModes[currentPartyMode].bombWaitingMinutesDuration;
							PartySeconds = allPartyModes[currentPartyMode].bombWaitingSecondsDuration;
						}
					}
					else
					{
						SendBombPlace = true;
					}

					localPlayer->haveBomb = false;
					SetGunInInventory(-1, 8);
					NE_ModelSetCoord(Model[7], BombPosition.x, BombPosition.y, BombPosition.z);
					NE_ModelSetCoord(Model[10], BombPosition.x, BombPosition.y, BombPosition.z);
					Model[7]->rz = BombPosition.r;
					BombSeconds = allPartyModes[currentPartyMode].bombWaitingSecondsDuration;

					bombBipTimer = 120;
					BombPlanted = true;
					SetBombDefuseZone(BombPosition.x, BombPosition.z, &bombDefuseZone); // Remove?
					showPartyEventText(2);

					SetRandomDefuser();
				}
			}
		}
		else if (getPlayerCurrentGunIndex(localPlayer) < GunCount + shopGrenadeCount && getPlayerCurrentGunIndex(localPlayer) >= GunCount && isKeyDown(FIRE_BUTTON) && !isUsingBomb) // Launch grenade
		{
			int grenadeType = AllGrenades[getPlayerCurrentGunIndex(localPlayer) - GunCount].type;
			PhysicalGrenade *newGrenade = CreateGrenade(grenadeType, localPlayer->Id);
			if (newGrenade != NULL)
			{
				lanchGrenade(newGrenade, x, y, z, localPlayer->PlayerModel->x, localPlayer->PlayerModel->y, localPlayer->PlayerModel->z);

				localPlayer->AllGunsInInventory[localPlayer->currentGunInInventory] = EMPTY;
				ChangeGunInInventoryForLocalPlayer(1);

				SendGrenade = true;
				// Force player to send position
				SendPosition = true;
				SendPositionData = 0;
			}
		}
		else if (isKey(DEFUSE_BUTTON) && canDefuseBomb && (roundState == PLAYING || roundState == END_ROUND) && !BombDefused && BombPlanted && localPlayer->Team == COUNTERTERRORISTS && !isLocalPlayerMoving()) // Defuse bomb
		{
			isUsingBomb = true;
			// On bomb defuse make a sound
			if (localPlayer->bombTimer == bombDefuseTime)
			{
				PlayBasicSound(SFX_BOMBPLANTING);
				SendBombPlacing = true;
			}
			localPlayer->bombTimer--;
			// Set bomb when defused
			if (localPlayer->bombTimer == 0)
			{
				BombDefused = true;

				if (applyRules)
				{
					CounterScore++;

					if (LoseCountTerrorists > 0)
						LoseCountTerrorists--;

					if (LoseCountCounterTerrorists < 4)
						LoseCountCounterTerrorists++;

					addMoneyToTeam(allPartyModes[currentPartyMode].loseTheRoundMoney, TERRORISTS);
					addMoneyToTeam(allPartyModes[currentPartyMode].winTheRoundBombMoney, COUNTERTERRORISTS);

					showPartyEventText(3);
					setEndRound();
					CheckAfterRound();
				}
				else
				{
					SendBombDefused = true;
				}
			}
		}
		else
		{
			isUsingBomb = false;
			if (localPlayer->Team == COUNTERTERRORISTS)
			{
				if (!BombDefused && BombPlanted) // Set timer
					localPlayer->bombTimer = bombDefuseTime;
				else
				{
					localPlayer->bombTimer = 0;
				}
			}
			else if (localPlayer->Team == TERRORISTS)
			{
				if (!BombPlanted) // Set timer
					localPlayer->bombTimer = bombPlantingTime;
				else
				{
					localPlayer->bombTimer = 0;
				}
			}
		}

		// Reset player speed
		localPlayer->PlayerPhysic->xspeed = 0;
		localPlayer->PlayerPhysic->zspeed = 0;

		// Player movements
		bool NeedBobbing = false;
		int CurrentSpeed = defaultWalkSpeed;
		if (getPlayerCurrentGunIndex(localPlayer) < GunCount)
			CurrentSpeed = getPlayerCurrentGun(localPlayer).WalkSpeed;

		if (roundState != WAIT_START && !localPlayer->IsDead)
			MovePlayer(CurrentSpeed, xWithoutY, zWithoutY, &NeedBobbing);

		// Gun headbobing
		if (NeedBobbing && (CanJumpRealTimer == 0 || CanJump > 0))
		{
			ApplyGunWalkAnimation(0);
		}
	}
	else
	{
		if (localPlayer->IsDead)
		{
			if (keysdown & KEY_LEFT)
			{
				changeCameraPlayerView(false);
			}
			else if (keysdown & KEY_RIGHT)
			{
				changeCameraPlayerView(true);
			}

			if (deathCameraAnimation < 1)
			{
				deathCameraAnimation += DEATH_ANIMATION_SPEED;
				deathCameraYOffset = (1 - cosf(deathCameraAnimation * M_PI / 2.0)) * 1.4;
			}

			if (CurrentCameraPlayer != 0)
				deathCameraYOffset = 0;
		}

		// Reset player speed
		localPlayer->PlayerPhysic->xspeed = localPlayer->PlayerPhysic->yspeed = localPlayer->PlayerPhysic->zspeed = 0;
	}

	if (applyRules)
	{
		if (roundState == PLAYING)
		{
			for (int i = 1; i < MaxPlayer; i++)
			{
				Player *player = &AllPlayers[i];
				if (player->Id == UNUSED)
					continue;

				if (player->isPlantingBomb)
				{
					if (player->Team == TERRORISTS)
					{
						// On bomb planting make a sound
						if (player->bombTimer == bombPlantingTime)
						{
							int Panning, Volume;
							GetPanning(player->Id, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.10);
							Play3DSound(SFX_BOMBPLANTING, Volume, Panning, player);
						}
						player->bombTimer--;
						// Set bomb position when planted
						if (player->bombTimer == 0)
						{
							CalculatePlayerPosition(i);
							BombPosition.x = player->position.x;
							BombPosition.y = player->position.y - 0.845;
							BombPosition.z = player->position.z;
							BombPosition.r = player->Angle;

							BombPlanted = true;
							bombSet = true;
							player->isPlantingBomb = false;
							bombPlantedAt = player->LastWayPoint;

							PartyMinutes = allPartyModes[currentPartyMode].bombWaitingMinutesDuration;
							PartySeconds = allPartyModes[currentPartyMode].bombWaitingSecondsDuration;

							BombSeconds = allPartyModes[currentPartyMode].bombWaitingSecondsDuration;
							player->haveBomb = false;
							SetGunInInventoryForNonLocalPlayer(i, EMPTY, 8);
							NE_ModelSetCoord(Model[7], BombPosition.x, BombPosition.y, BombPosition.z);
							NE_ModelSetCoord(Model[10], BombPosition.x, BombPosition.y, BombPosition.z);
							Model[7]->rz = BombPosition.r;
							bombBipTimer = 120;
							SetBombDefuseZone(BombPosition.x, BombPosition.z, &bombDefuseZone);
							showPartyEventText(2);
							SetRandomDefuser();
						}
					}
					else
					{
						if (!BombDefused)
						{
							// On bomb defuse make a sound
							if (player->bombTimer == bombDefuseTime)
							{
								int Panning, Volume;
								GetPanning(player->Id, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.10);
								Play3DSound(SFX_BOMBPLANTING, Volume, Panning, player);
							}
							player->bombTimer--;
							// Set bomb when defused
							if (player->bombTimer == 0)
							{
								BombDefused = true;
								player->isPlantingBomb = false;
								currentDefuserIndex = NO_PLAYER;
								CounterScore++;

								if (LoseCountTerrorists > 0)
									LoseCountTerrorists--;

								if (LoseCountCounterTerrorists < 4)
									LoseCountCounterTerrorists++;

								addMoneyToTeam(allPartyModes[currentPartyMode].loseTheRoundMoney, TERRORISTS);
								addMoneyToTeam(allPartyModes[currentPartyMode].winTheRoundBombMoney, COUNTERTERRORISTS);

								showPartyEventText(3);
								setEndRound();
								CheckAfterRound();
							}
						}
					}
				}
			}
		}

		partyTimerTick();
	}
	else
	{
		partyTimerTickOnline();
	}

	// Make bomb sounds
	if (BombPlanted && !BombDefused)
	{
		if (bombBipTimer > 0)
			bombBipTimer--;

		if (bombBipTimer == 0 && BombSeconds > 0 && !BombWillExplode)
		{
			// make bib sound
			int Panning, Volume;
			GetPanningByPosition(&Panning, &Volume, BombPosition, xWithoutYForAudio, zWithoutYForAudio, 0.12);
			Play3DSound(SFX_BOMBBIP, Volume, Panning, NULL);
			bombBipTimer = (BombSeconds / 40.0) * 120.0 + 5;
			if (bombBipTimer > 50)
			{
				SetRandomDefuser();
			}
		}
		else if (bombBipTimer == 0 && BombSeconds == 0 && !BombWillExplode)
		{
			// Make detonate sound
			int Panning, Volume;
			GetPanningByPosition(&Panning, &Volume, BombPosition, xWithoutYForAudio, zWithoutYForAudio, 0.15);
			Play3DSound(SFX_DETONATE, Volume, Panning, NULL);
			bombBipTimer = 120;
			BombWillExplode = true;
		}
		else if (bombBipTimer == 0 && BombWillExplode)
		{
			// Make explosion sound
			PlayBasicSound(SFX_BOMBEXPLODE);
			BombPlanted = false;
			IsExplode = true;

			rumble(2);

			if (applyRules)
			{
				BombWillExplode = false;
				// Apply explosion damage to all players
				for (int i = 0; i < MaxPlayer; i++)
				{
					Player *player = &AllPlayers[i];
					if (player->IsDead || player->Id == NO_PLAYER)
						continue;

					float Distance = (float)sqrt(pow(player->PlayerModel->x - BombPosition.x * 4096.0, 2.0) + pow(player->PlayerModel->y - BombPosition.y * 4096.0, 2.0) + pow(player->PlayerModel->z - BombPosition.z * 4096.0, 2.0)) / 8096.0;
					if (Distance > 19)
						Distance = 0;

					if (Distance > 0)
					{
						int newHealh = player->Health - (int)map(Distance, 0.3, 19, 200, 0);
						setPlayerHealth(i, newHealh);
						checkAfterDamage(NO_PLAYER, i, false);
					}
				}
			}
		}
	}

	addExplosionScreenShake();

	// Loop using "AllPlayers" array for updating non local player (online players or bots) position smoothly
	SetOnlinelPlayersPositions();

	if (roundState != WAIT_START)
	{
		AiCheckForAction();

		checkAiShoot();
	}
}

/**
 * @brief Check if the local player is moving
 *
 * @return true
 * @return false
 */
bool isLocalPlayerMoving()
{
	return localPlayer->PlayerPhysic->xspeed + localPlayer->PlayerPhysic->yspeed + localPlayer->PlayerPhysic->zspeed != 0;
}

/**
 * @brief Update game engine for drawing (when not in party)
 *
 */
void UpdateEngineNotInGame()
{
	ScanForInput();

	increaseFrameCount();

	if (UpdateBottomScreenFrameCount > 8)
		UpdateBottomScreenFrameCount--;

	// Draw UI and 3D
	if (!isDebugBottomScreen)
	{
		NE_ProcessDual(Draw3DSceneNotInGame, drawBottomScreenUI);
	}
	else
	{
		NE_Process(Draw3DSceneNotInGame); // For debug
	}

	if (uiTimer > 0)
	{
		uiTimer--;
		if (uiTimer == 0)
		{
			if (actionOfUiTimer == SAVE)
			{
				Save();
			}
		}
	}

	NE_WaitForVBL(NE_CAN_SKIP_VBL);
}

/**
 * @brief Increase the frame count (used for the server to know the speed of actions)
 *
 */
void increaseFrameCount()
{
	frameCount++;
	if (frameCount == 2013265920)
	{
		frameCount = 0;
	}
	statsTimer();
}

/**
 * @brief Reset frame count
 *
 */
void resetFrameCount()
{
	frameCount = 0;
}

/**
 * @brief Update game engine for drawing
 *
 */
void UpdateEngine()
{
	ScanForInput();

	increaseFrameCount();

	if (!isDebugBottomScreen)
	{
		// Draw 3D objects and sprites
		if (!AlwaysUpdateBottomScreen && UpdateBottomScreenFrameCount == 0)
			NE_Process(Draw3DScene);
		else
		{
			if (UpdateBottomScreenFrameCount > 0)
				UpdateBottomScreenFrameCount--;

			NE_ProcessDual(Draw3DScene, drawBottomScreenUI);
		}
	}
	else
	{
		if (UpdateBottomScreenFrameCount > 0)
			UpdateBottomScreenFrameCount--;

		NE_Process(Draw3DScene); // For debug
	}

	if (uiTimer > 0)
	{
		uiTimer--;
		if (uiTimer == 0)
		{
			if (actionOfUiTimer == SAVE)
			{
				Save();
			}
		}
	}

	// Update physics and animations
	if (localPlayer->Id != UNUSED && localPlayer->Team != SPECTATOR)
		NE_PhysicsUpdate(localPlayer->PlayerPhysic);

	NE_WaitForVBL(NE_CAN_SKIP_VBL);
}

/**
 * @brief Change value "scale" ex map(128, 0,255,0,1024) = 512.0
 *
 * @param x The number to map
 * @param in_min The lower bound of the value’s current range
 * @param in_max The upper bound of the value’s current range
 * @param out_min The lower bound of the value’s target range
 * @param out_max The upper bound of the value’s target range
 * @return double The mapped value
 */
double map(double x, double in_min, double in_max, double out_min, double out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

/**
 * @brief Change value "scale" ex map(128, 0,255,0,1024) = 512
 *
 * @param x The number to map
 * @param in_min The lower bound of the value’s current range
 * @param in_max The upper bound of the value’s current range
 * @param out_min The lower bound of the value’s target range
 * @param out_max The upper bound of the value’s target range
 * @return int The mapped value
 */
int mapInt(int x, int in_min, int in_max, int out_min, int out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

/**
 * @brief Enable rumble for an amount of frame
 *
 * @param timer Frame count
 */
void rumble(int timer)
{
	if (useRumble)
	{
		setRumble(true);
		RumbleTimer = timer;
	}
}

/**
 * @brief Drop the bomb
 *
 * @param HittedClient Hitted client pointer
 * @param hittedPlayerIndex Hitted client index
 */
void dropBomb(Player *HittedClient, int hittedPlayerIndex)
{
	bombDropped = true;
	HittedClient->haveBomb = false;
	SetGunInInventoryForNonLocalPlayer(hittedPlayerIndex, EMPTY, 8);
	//  Set the position of the dropped bomb (so the player position)
	droppedBombPositionAndRotation.x = HittedClient->position.x;
	droppedBombPositionAndRotation.y = HittedClient->position.y - 0.845;
	droppedBombPositionAndRotation.z = HittedClient->position.z;
	droppedBombPositionAndRotation.r = HittedClient->Angle;
	NE_ModelSetCoord(Model[7], droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.y, droppedBombPositionAndRotation.z);
	Model[7]->rz = droppedBombPositionAndRotation.r;
	SetBombTakingZone(droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.z, &bombDefuseZone); // Set zone for taking the bomb
}

/**
 * @brief Set need respawn for a player
 *
 * @param player Player pointer
 */
void setNeedRespawn(Player *player)
{
	player->RespawnTimer = allPartyModes[currentPartyMode].trainingRespawnSecondsDuration * 60;
	player->NeedRespawn = true;
}
```

`Counter-Strike-nds/source/main.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef MAIN_H_ /* Include guard */
#define MAIN_H_
#include <NEMain.h>

#include <fat.h>
#include <filesystem.h>

#include "saveManager.h"
#include "ui.h"
#include "grenade.h"

// Math functions
#include <math.h>

// Wifi
#include <dswifi9.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

// Sound system
#include <maxmod9.h>
#include "soundbank.h"

// 3D models
#include "playerAnimNea_bin.h"
#include "GIGNAnimNea_bin.h"
#include "GIGNNew_bin.h"
#include "DustPart0_bin.h"
#include "DustPart1_bin.h"
#include "DustPart2_bin.h"
#include "DustPart3_bin.h"

#include "DustPart4_bin.h"
#include "DustPart5_bin.h"
#include "DustPart6_bin.h"
#include "bomb_bin.h"
#include "plane_bin.h"
#include "repeat_bin.h"
#include "explosion_bin.h"
#include "smokeSphere_bin.h"

#include "tutorialMapUnShadowed_3ds_bin.h"
#include "tutorialMapShadowed_3ds_bin.h"

#include "grenade_3ds_bin.h"

// Textures
#include "MapUI_bin.h"
#include "bomb_logo_bin.h"
#include "MapPointUI_bin.h"
#include "CheckMark_bin.h"
#include "WhiteScareRounded_bin.h"
#include "QuitButton_bin.h"
#include "scopeImage_bin.h"
#include "player_shadow_bin.h"

#include "reload_bin.h"
#include "JumpArrow_bin.h"

// Player skins
#include "skin_soldier_bin.h"
#include "skin_adventurer_bin.h"
#include "skin_man_bin.h"
#include "gign_skin1_bin.h"
#include "terrorist_skin1_bin.h"

// crosshairs
#include "crosshair2_bin.h"

// Terrain texture
#include "Atlas_bin.h"

// Gun sprites and 3D models
#include "gun_bin.h"
#include "gun1_bin.h"
#include "gun2_bin.h"
#include "gunFixed_bin.h"

#include "knifect_bin.h"
#include "deagle_bin.h"
#include "elite_bin.h"
#include "fivesevent_bin.h"
#include "glock18_bin.h"
#include "p228_bin.h"
#include "uspsilencer_bin.h"
#include "m3super90_bin.h"
#include "xm1014_bin.h"
#include "mac10_bin.h"
#include "mp5_bin.h"
#include "m249_bin.h"
#include "p90_bin.h"
#include "tmp_bin.h"
#include "ump45_bin.h"
#include "ak47_bin.h"
#include "aug_bin.h"
#include "famas_bin.h"
#include "galil_bin.h"
#include "m4a1_bin.h"
#include "sg552_bin.h"
#include "sg550_bin.h"
#include "scout_bin.h"
#include "g3sg1_bin.h"
#include "awp_bin.h"
#include "fraggrenade_bin.h"
#include "smokegrenade_bin.h"
#include "flashthrowed_bin.h"
#include "c4_bin.h"
#include "kevlar_bin.h"
#include "kevlar_helmet_bin.h"
#include "defuser_bin.h"

#include "muzzle_bin.h"

// Font
#include "text_bmp_bin.h"

//////All defines
#define Degres90 128

#define JumpForce 620
#define MaxPlayer 6
#define RaycastDistance 40
#define RayAccuracy 4

#define GunPositionX 160 // 256-96
#define GunPositionY 96	 // 192-96

//#define OcclusionZonesCount 21

#define bombDefuseTime 600	 // 10 secs
#define bombPlantingTime 210 // 3,5 secs

#define maxPoint 58
#define maxPath 15
#define ScreenShakeAmount 5
#define ScreenShakeMinAmount 3

#define inventoryCapacity 9
#define GunCount 25

#define GrenadeCount 20

#define InventoryGrenadeStartPosition 3
#define InventoryEquipementStartPosition 7

#define defaultWalkSpeed 220
#define flashAnimationSpeed 0.0035

#define DEFAULTTERRORISTGUN 4
#define DEFAULTCOUNTERTERRORISTGUN 6
#define wallCount 210

#define WaypointA 14
#define WaypointB 29

#define NO_PLAYER -1
#define EMPTY -1
#define UNUSED -1

//#define StairsCount 31
#define grenadeBoughtLength 5

#define CameraOffsetY 0.7
#define CameraOffsetYMultiplied 2867.20 // 0.7 * 4096

#define FLASH_MODELS_COUNT 6

#define INPUT_COUNT 14
#define INPUT_NAMES_COUNT 15
#define SHOP_DISABLE_TIMER 900

#define GAME_VERSION "1.0.0"

enum connectionType
{
	UNSELECTED,
	OFFLINE,
	DEBUG_IP_2,
	DEBUG_IP_1,
	ONLINE_SERVER_IP,
	LOCAL,
};

enum inputButtons
{
	FIRE_BUTTON = 0,
	JUMP_BUTTON = 1,

	LEFT_BUTTON = 2,
	RIGHT_BUTTON = 3,
	UP_BUTTON = 4,
	DOWN_BUTTON = 5,
	LOOK_LEFT_BUTTON = 6,
	LOOK_RIGHT_BUTTON = 7,
	LOOK_UP_BUTTON = 8,
	LOOK_DOWN_BUTTON = 9,

	DEFUSE_BUTTON = 10,
	SCOPE_BUTTON = 11,

	LEFT_GUN = 12,
	RIGHT_GUN = 13,
};

enum teamEnum
{
	SPECTATOR = -1,
	BOTH = -1,
	TERRORISTS = 0,
	COUNTERTERRORISTS = 1
};

enum actionAfterUiTimer
{
	SAVE
};

//////All structs

typedef struct
{
	int value;
	// enum KEYPAD_BITS value;
	//  const char *name;
	int nameIndex;
} Input;

// 3D point with angle
typedef struct
{
	float x;
	float y;
	float z;
	int r;
} Vector4;

// 3D point
typedef struct
{
	float x;
	float y;
	float z;
} Vector3;
// 3D point
typedef struct
{
	int x;
	int y;
	int z;
} Vector3Int;

// 2D point
typedef struct
{
	float x;
	float y;
} Vector2;

typedef struct
{
	int x;
	int y;
} Vector2Int;

typedef struct // Physics values for raycasting
{
	int BoxXRangeA;
	int BoxXRangeB;
	int BoxYRangeA;
	int BoxYRangeB;
	int BoxZRangeA;
	int BoxZRangeB;
} CollisionBox;

typedef struct // Physics values for raycasting
{
	float BoxXRangeA;
	float BoxXRangeB;
	float BoxYRangeA;
	float BoxYRangeB;
	float BoxZRangeA;
	float BoxZRangeB;
} CollisionBoxF;

typedef struct // 2D area (box) values for trigger
{
	float BoxXRangeA;
	float BoxXRangeB;
	float BoxZRangeA;
	float BoxZRangeB;
} CollisionBox2D;

typedef struct // Physics values for raycasting
{
	int waypoint;
	int *nearWaypoints;
	int nearWaypointCount;
	CollisionBox2D collisionBox;
} Site;

typedef struct // 2D area (box) values for trigger
{
	Vector2 angles[4];
	Vector2Int anglesInt[4];
} OcclusionZone;

typedef struct //
{
	int AmmoCount;
	int TotalAmmoCount;
} AmmoMagazine;

typedef struct // Player values
{
	int Id;

	Vector3 position;
	Vector3 lerpDestination;
	float cameraAngle;
	float Angle;
	float AngleDestination;

	// int IsCounter;
	enum teamEnum Team;
	int Money;
	int Health;
	int KillCount;
	int DeathCount;
	int GunWaitCount;
	int GunReloadWaitCount;
	bool isReloading;
	int currentGunInInventory;
	AmmoMagazine AllAmmoMagazine[2];
	int AllGunsInInventory[inventoryCapacity];
	int grenadeBought[grenadeBoughtLength];
	int armor;		  //
	bool haveHeadset; //
	int spawnAt;

	float flashAnimation;
	bool flashed;

	CollisionBox PlayerCollisionBox; //
	NE_Model *PlayerModel;			 //
	NE_Model *PlayerShadow;			 //
	NE_Physics *PlayerPhysic;		 //
	bool IsDead;					 //
	bool haveDefuseKit;				 //
	bool haveBomb;					 //
	bool isPlantingBomb;			 //
	int bombTimer;					 //
	int rightGunXRecoil;			 //
	int rightGunYRecoil;			 //
	int leftGunXRecoil;				 //
	int leftGunYRecoil;				 //
	bool isRightGun;				 // For dual guns, 0 right, 1 left

	// AI
	int Path[maxPath];
	bool isAi;			//
	int PathCount;		//
	int CurrentPath;	//
	int LastWayPoint;	//
	int target;			//
	int lastSeenTarget; //
	bool justCheking;
	bool canCancelNextCheck;
	bool tooFar;
	bool searchForDroppedBomb;

	// Raycasting
	bool IsHeadShot[FLASH_MODELS_COUNT];
	bool IsLegShot[FLASH_MODELS_COUNT];

	int ScanForGrenade;

	Vector3 startRaycastPosition;
	Vector3 startRaycastRotation;
	int startGunIdRaycast;

	int CurrentOcclusionZone; //

	int invincibilityTimer;

	int RespawnTimer;			  //
	bool NeedRespawn;			  //
	float BobbingOffset;		  //
	bool HasBobbed;				  //
	int Step;					  //
	char name[PLAYER_MAX_LENGTH]; //
	bool allPlayerScanned[MaxPlayer];
	float xSize;
	float ySize;
	float zSize;
	bool inShadow;
	int currentShadowCollBox;
	float lightCoef;
	int mapVisivilityTimer;
} Player;

typedef struct // 2D area (box) values for trigger with stairs start height, final height and direction
{
	float xSideA;
	float xSideB;
	float zSideA;
	float zSideB;
	float startY;
	float endY;
	int direction;
} Stairs;

typedef struct // Physics values for raycasting
{
	Vector3Int position;
	int ZoneCollision;
	CollisionBox WallCollisionBox;
	NE_Model *WallModel;
	NE_Physics *WallPhysics;
} Wall;

typedef struct //
{
	int id;
	int ZoneCount;
	int visibleMapPart[5];
	CollisionBox2D collisionBox;
} Zone;

typedef struct //
{
	int scopeCount;
	int fov[2];
	int Speed;
} Scope;

typedef struct //
{
	void *texture;
	char letter[2];
	char letterUpperCase[2];
	int xPos;
	int yPos;
	bool visible;
} Key;

typedef struct //
{
	void *texture;
	char name[8];
	int xPos;
	int yPos;
	int xSize;
	int xCenter;
	int ySize;
	bool visible;
	void (*OnClick)();
} OtherKey;

extern float flashaAnimation;
extern bool flashed;
extern int ShowMuzzle;
extern int rightGunX;
extern int rightGunY;
extern int leftGunX;
extern int leftGunY;
extern int rightGunXRecoil;
extern int rightGunYRecoil;
extern int GunMaxRecoil;
extern int GunMinRecoil;
extern bool isInFullSmoke;
extern int redHealthTextCounter;

extern bool BombPlanted;
extern int bombTimer;
extern int CurrentScopeLevel;

extern int KillTextShowTimer;

extern NE_Sprite *TopScreenSprites[2];
extern NE_Camera *Camera;
extern NE_Material *PlayerMaterial;
extern NE_Material *PlayerMaterialTerrorist;
extern NE_Material *PlayerShadowMaterial;

extern int textToShowTimer;
extern int CurrentCameraPlayer;

extern bool NeedChangeScreen;
extern bool AlwaysUpdateBottomScreen;
extern int UpdateBottomScreenFrameCount;
extern Player AllPlayers[MaxPlayer];
extern int SelectedGunShop;
extern bool WaitForTeamResponse;
extern Button AllButtons[ButtonCount];
extern CheckBox AllCheckBoxs[CheckBoxCount];
extern Slider AllSliders[SliderCount];
extern int ButtonToShow;
extern int currentMenu;
extern NE_Sprite *BottomScreenSprites[1];
extern NE_Material *GroundMaterial;
extern NE_Material *GroundMaterialShadowed;
extern float xWithoutYForMap;
extern float zWithoutYForMap;
extern float xWithoutYForOcclusionSide1;
extern float zWithoutYForOcclusionSide1;
extern float xWithoutYForOcclusionSide2;
extern float zWithoutYForOcclusionSide2;
extern int WallHitXPos[FLASH_MODELS_COUNT];
extern int WallHitYPos[FLASH_MODELS_COUNT];
extern int WallHitZPos[FLASH_MODELS_COUNT];
extern float hitDistance[FLASH_MODELS_COUNT];

extern int tempTeam;

extern float OldxPos, OldyPos, OldzPos;
extern int hittedClient[FLASH_MODELS_COUNT];
extern float xOffset, yOffset;
extern int PlayerCount;
extern float deathCameraYOffset;
extern float deathCameraAnimation;
extern int BombExplosionScale;
extern bool IsExplode;
extern int bombBipTimer;
extern bool BombDefused;
extern NE_Model *Model[13];
extern NE_Model *flashModels[FLASH_MODELS_COUNT];
extern bool BombWillExplode;
extern CollisionBox2D bombDefuseZone;
extern float x, y, z;
extern float xWithoutY, zWithoutY, xWithoutYForAudio, zWithoutYForAudio;
extern Vector4 BombPosition;
extern int ShowWallHitFlash[FLASH_MODELS_COUNT];
extern bool applyRules;
extern float BobbingSpeed;

extern int doubleTapTimer;
extern Scope AllScopeLevels[2];
extern bool PartyStarted;
extern enum connectionType Connection;
extern Player *localPlayer;

extern int uiTimer;
extern enum actionAfterUiTimer actionOfUiTimer;
extern int RumbleTimer;
extern Site AllBombsTriggersCollisions[2];
extern bool useRumble;
extern int shopDisableTimer;
extern CollisionBoxF shopZone;
extern bool isInShopZone;
extern bool NeedUpdateViewRotation;
extern int changeSecondTimer;
extern int changeMinuteTimer;
extern int LoseCountTerrorists;
extern int LoseCountCounterTerrorists;
extern bool bombSet;
extern int frameCountDuringAir;
extern bool NeedJump;
extern bool canChangeGun;
extern bool canShoot;
extern int playerWantToStart;
extern int playerWantToStartLimite;

//////All functions
void GameLoop();
double map(double x, double in_min, double in_max, double out_min, double out_max);
int mapInt(int x, int in_min, int in_max, int out_min, int out_max);
void JoinParty(int option);
void setNeedRespawn(Player *player);
void increaseFrameCount();
void resetFrameCount();

Stairs *GetStairs();
Wall *GetWalls();
Player *GetPlayers();
Button *GetButtons();
CheckBox *GetCheckBoxs();
NE_Sprite **GetSpritesTop();
NE_Sprite **GetSpritesBottom();
NE_Material **GetBottomScreenSpritesMaterials();
NE_Palette **GetPalettes();

void checkStartGameLoop();
int GetCurrentMenu();
void SetCurrentMenu(int value);
int GetUpdateBottomScreenOneFrame();
void SetUpdateBottomScreenOneFrame(int value);
int GetButtonToShow();
void SetButtonToShow(int value);

void SetWaitForTeamResponse(bool value);
void dropBomb(Player *HittedClient, int hittedPlayerIndex);

bool GetAlwaysUpdateBottomScreen();
bool GetNeedUpdateViewRotation();
bool GetSendPosition();
float GetCameraAngleY();
int GetCurrentScopeLevel();
void SetCameraAngleY(float Value);
void SetAlwaysUpdateBottomScreen(bool value);
void SetSendPosition(bool Value);
bool GetNeedChangeScreen();
void SetDoubleTapTimer(int Value);
int GetDoubleTapTimer();
void SetNeedChangeScreen(bool value);
void SetSendTeam(bool Value);
void SetTempTeam(int Value);
int GetTempTeam();
void UpdateEngineNotInGame();
void UpdateEngine();
Grenade *GetAllGrenades();
void SetNeedJump();
void SetSelectedGunShop(int Value);
int GetSelectedGunShop();
void SetCurrentCameraPlayer(int Value);
int GetCurrentCameraPlayer();
void SetSendBuyWeapon(bool Value);
void SetNeedUpdateViewRotation(bool Value);
void setPlayersPositionAtSpawns();

void rumble(int timer);
bool isLocalPlayerMoving();

#endif // MAIN_H_
```

`Counter-Strike-nds/source/map/map.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "map.h"
#include "collisions.h"
#include "party.h"
#include "data/ai_data.h"
#include "camera.h"

// Maps data
Map allMaps[MAP_COUNT];

/**
 * @brief Unload a map
 *
 * @param mapToUnload Map index to unload
 */
void UnLoadMap(int mapToUnload)
{
    // Destroy all collisions (models and physics)
    for (int i = 0; i < allMaps[mapToUnload].CollisionsCount; i++)
    {
        NE_PhysicsDelete(allMaps[mapToUnload].AllWallsCollisions[i].WallPhysics);
        NE_ModelDelete(allMaps[mapToUnload].AllWallsCollisions[i].WallModel);
    }

    // Destroy all map models
    for (int i = 0; i < allMaps[mapToUnload].occlusionZoneCount; i++)
    {
        NE_ModelDelete(allMaps[mapToUnload].models[i].Model);
    }

    // Free all used memory used by the map
    if (allMaps[mapToUnload].AllWallsCollisions != NULL)
        free(allMaps[mapToUnload].AllWallsCollisions);

    if (allMaps[mapToUnload].models != NULL)
        free(allMaps[mapToUnload].models);

    if (allMaps[mapToUnload].AllStairs != NULL)
        free(allMaps[mapToUnload].AllStairs);

    for (int i = 0; i < allMaps[mapToUnload].BombsTriggersCollisionsCount; i++)
    {
        free(allMaps[mapToUnload].AllBombsTriggersCollisions[i].nearWaypoints);
    }

    if (allMaps[mapToUnload].AllBombsTriggersCollisions != NULL)
        free(allMaps[mapToUnload].AllBombsTriggersCollisions);

    if (allMaps[mapToUnload].AllZones != NULL)
        free(allMaps[mapToUnload].AllZones);

    if (allMaps[mapToUnload].AllShadowCollisionBox != NULL)
        free(allMaps[mapToUnload].AllShadowCollisionBox);

    LastStairs = 0;

    // Destroy grenades
    for (int i = 0; i < GrenadeCount; i++)
    {
        DeleteGrenade(i);
    }
}

/**
 * @brief Load a map
 *
 * @param mapToLoad Map index to load
 */
void LoadMap(int mapToLoad)
{
    CreateWaypoints(mapToLoad);
    createLengthMatrices(mapToLoad);

    LoadAllCollisions(mapToLoad);
    CalculateAllTriggerColBoxs(mapToLoad);
    LoadAllStairs(mapToLoad);

    LoadAllBombZones(mapToLoad);
    loadMapModels(mapToLoad);
    setCameraMapPosition();
}

/**
 * @brief Load map images for the map list
 *
 */
void LoadMapTextures()
{
    allMaps[DUST2].image = (void *)dust2_map_image_bin;
    allMaps[TUTORIAL].image = (void *)tutorial_map_image_bin;
}

/**
 * @brief Set maps names
 *
 */
void SetMapNames()
{
    allMaps[DUST2].name = "Dust II";
    allMaps[TUTORIAL].name = "Training (unfinished)";
}

/**
 * @brief Set maps party mode (-1 = no party mode forced)
 *
 */
void SetMapPartyMode()
{
    allMaps[DUST2].forcePartyMode = -1;
    allMaps[TUTORIAL].forcePartyMode = 2;
}

/**
 * @brief Set the map camera position (used when the player is not in game)
 *
 */
void SetMapCameraPosition()
{
    // DUST2
    allMaps[DUST2].cameraPosition.x = -3;
    allMaps[DUST2].cameraPosition.y = 8;
    allMaps[DUST2].cameraPosition.z = -14;

    allMaps[DUST2].cameraLookPosition.x = -12;
    allMaps[DUST2].cameraLookPosition.y = 3.2;
    allMaps[DUST2].cameraLookPosition.z = -16;

    // TUTORIAL
    allMaps[TUTORIAL].cameraPosition.x = -12;
    allMaps[TUTORIAL].cameraPosition.y = 8;
    allMaps[TUTORIAL].cameraPosition.z = -5;

    allMaps[TUTORIAL].cameraLookPosition.x = -3;
    allMaps[TUTORIAL].cameraLookPosition.y = 3.2;
    allMaps[TUTORIAL].cameraLookPosition.z = -0;
}

/**
 * @brief Set maps spawns positions
 *
 */
void AddAllSpawnPoints()
{
    // DUST2
    AddSpawnPoint(DUST2, TERRORISTS, 0, -3, 6.43, 65);
    AddSpawnPoint(DUST2, TERRORISTS, 1, -6, 6.43, 65);
    AddSpawnPoint(DUST2, TERRORISTS, 2, -9, 6.43, 65);
    AddSpawnPoint(DUST2, TERRORISTS, 3, -3, 6.43, 62.5);
    AddSpawnPoint(DUST2, TERRORISTS, 4, -6, 6.43, 62.5);
    AddSpawnPoint(DUST2, TERRORISTS, 5, -9, 6.43, 62.5);

    AddSpawnPoint(DUST2, COUNTERTERRORISTS, 0, 16, 0, -22);
    AddSpawnPoint(DUST2, COUNTERTERRORISTS, 1, 19.5, 0, -22);
    AddSpawnPoint(DUST2, COUNTERTERRORISTS, 2, 23, 0, -22);
    AddSpawnPoint(DUST2, COUNTERTERRORISTS, 3, 16, 0, -19.5);
    AddSpawnPoint(DUST2, COUNTERTERRORISTS, 4, 19.5, 0, -22);
    AddSpawnPoint(DUST2, COUNTERTERRORISTS, 5, 23, 0, -22);

    SetAngles(DUST2, 0, -256);

    // TUTORIAL
    AddSpawnPoint(TUTORIAL, 0, 0, 0, 0, 0);

    AddSpawnPoint(TUTORIAL, 1, 0, 0, 0, 0);

    SetAngles(TUTORIAL, 0, 0);
}

/**
 * @brief Load map models
 *
 * @param mapToLoad
 */
void loadMapModels(int mapToLoad)
{
    Map *map = &allMaps[mapToLoad];

    Vector3 mapPos;
    Vector3Int Scale;
    int mapPartCount = 0;

    // Set map position, scale and parts count,
    if (mapToLoad == DUST2)
    {
        mapPartCount = 7;
        mapPos.x = 0;
        mapPos.y = 1.5 + 0.8;
        mapPos.z = 0;
        Scale.x = Scale.y = Scale.z = 4096;
    }
    else if (mapToLoad == TUTORIAL)
    {
        mapPartCount = 2;
        mapPos.x = 0;
        mapPos.y = -1.5 + 0.5;
        mapPos.z = 0;
        Scale.x = Scale.y = Scale.z = 2048;
    }

    // Set for each map parts, position, rotation and scale
    for (int i = 0; i < mapPartCount; i++)
    {
        map->models[i].Model = NE_ModelCreate(NE_Static);
        NE_ModelSetMaterial(map->models[i].Model, GroundMaterial);
        NE_ModelScaleI(map->models[i].Model, Scale.x, Scale.y, Scale.z);
        NE_ModelSetCoord(map->models[i].Model, mapPos.x, mapPos.y, mapPos.z);
        map->models[i].Model->rx = 128;
        map->models[i].Model->ry = 256;
    }

    // Set for each map parts, the model and the position
    if (mapToLoad == DUST2)
    {
        NE_ModelLoadStaticMesh(map->models[0].Model, (u32 *)DustPart0_bin);
        map->models[0].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[1].Model, (u32 *)DustPart1_bin);
        map->models[1].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[2].Model, (u32 *)DustPart2_bin);
        map->models[2].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[3].Model, (u32 *)DustPart3_bin);
        map->models[3].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[4].Model, (u32 *)DustPart4_bin);
        map->models[4].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[5].Model, (u32 *)DustPart5_bin);
        map->models[5].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[6].Model, (u32 *)DustPart6_bin);
        map->models[6].shadowed = false;
    }
    else if (mapToLoad == TUTORIAL)
    {
        NE_ModelLoadStaticMesh(map->models[0].Model, (u32 *)tutorialMapUnShadowed_3ds_bin);
        map->models[0].shadowed = false;
        NE_ModelLoadStaticMesh(map->models[1].Model, (u32 *)tutorialMapShadowed_3ds_bin);
        map->models[1].shadowed = true;
    }
}

Wall *getMapWalls()
{
    return allMaps[currentMap].AllWallsCollisions;
}

int getMapWallsCount()
{
    return allMaps[currentMap].CollisionsCount;
}

/**
 * @brief Set map name
 *
 * @param mapIndex Map index
 * @param name Name
 */
void SetName(int mapIndex, const char *name)
{
    allMaps[mapIndex].name = name;
}

/**
 * @brief Set the spawn angle
 *
 * @param mapIndex Map index
 * @param terroristsAngle Spawn angle for terrorists
 * @param CounterAngle Spawn angle for counter terrorists
 */
void SetAngles(int mapIndex, float terroristsAngle, float CounterAngle)
{
    allMaps[mapIndex].startPlayerAngleTerrorists = terroristsAngle;
    allMaps[mapIndex].startPlayerAngleCounterTerrorists = CounterAngle;
}

/**
 * @brief Add a spawn point to the map
 *
 * @param mapIndex Map index
 * @param team Spawn point team
 * @param index Spawn point index
 * @param x X position
 * @param y Y position
 * @param z Z position
 */
void AddSpawnPoint(int mapIndex, int team, int index, float x, float y, float z)
{
    Map *map = &allMaps[mapIndex];
    if (team == TERRORISTS)
    {
        map->allTerroristsSpawns[index].x = x;
        map->allTerroristsSpawns[index].y = y;
        map->allTerroristsSpawns[index].z = z;
    }
    else
    {
        map->allCounterTerroristsSpawns[index].x = x;
        map->allCounterTerroristsSpawns[index].y = y;
        map->allCounterTerroristsSpawns[index].z = z;
    }
}

```

`Counter-Strike-nds/source/map/map.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef MAP_H_ /* Include guard */
#define MAP_H_

#include "../main.h"

#include "dust2_map_image_bin.h"
#include "tutorial_map_image_bin.h"

enum mapEnum
{
    DUST2 = 0,
    TUTORIAL = 1
};

typedef struct //
{
    NE_Model *Model;
    bool shadowed;
} MapModel;

typedef struct //
{
    const char *name;
    Vector3 allTerroristsSpawns[6];
    Vector3 allCounterTerroristsSpawns[6];
    float startPlayerAngleTerrorists;
    float startPlayerAngleCounterTerrorists;
    int CollisionsCount;
    Wall *AllWallsCollisions;

    int StairsCount;
    Stairs *AllStairs;

    int zonesCount;
    Zone *AllZones;
    int BombsTriggersCollisionsCount;
    Site *AllBombsTriggersCollisions;
    int occlusionZoneCount;
    OcclusionZone *AllOcclusionZone;
    int shadowCollisionBoxCount;
    CollisionBox *AllShadowCollisionBox;

    MapModel *models;
    void *image;
    int forcePartyMode;

    Vector3 cameraPosition;
    Vector3 cameraLookPosition;
} Map;

#define MAP_COUNT 2
extern Map allMaps[MAP_COUNT];

void AddAllSpawnPoints();
void AddSpawnPoint(int mapIndex, int team, int index, float x, float y, float z);
void SetAngles(int mapIndex, float terroristsAngle, float CounterAngle);
Wall *getMapWalls();
int getMapWallsCount();
void LoadMapTextures();
void LoadMap(int mapToLoad);
void UnLoadMap(int mapToUnload);
void SetMapNames();
void SetMapPartyMode();
void SetMapCameraPosition();

#endif // MAP_H_
```

`Counter-Strike-nds/source/network/network.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "../main.h"
#include "sounds.h"
#include "movements.h"
#include "grenade.h"
#include "gun.h"
#include "ui.h"
#include "collisions.h"
#include "network.h"
#include "party.h"
#include "player.h"
#include "security.h"
#include "camera.h"

#include <dswifi9.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

// Current ping of the nintendo ds
int ping = 0;

// Socket
int my_socket = 0;

// Retain if the game needs to send a packet
bool SendPosition = false;
int SendPositionData = 3;
bool SendShoot = false;
bool SendLeave = false;
bool SendGrenade = false;
bool SendBombPlacing = false;
bool SendBombPlace = false;
bool SendBombDefused = false;
bool SendPing = false;
bool SendTeam = false;
bool WaitForTeamResponse = false;
bool SendBuyWeapon = false;
bool SendWallHit = false;
bool SendSelectedGun = false;
bool SendPlayerName = false;
bool SendVoteStartNow = false;
bool SendKeyResponse = false;
bool SendGetDroppedBomb = false;
bool SendReloaded = false;

// Retain if the player is just connected
bool firstConnection = true;

// For security, we need to retain the number of frame showed
int frameCount = 0;
// Timeout timer for the connection
int timeOut = 0;

// Join type to send to the server
enum JoinType partyOption = JOIN_RANDOM_PARTY;

// Party code to send to the server or to receive from the server
char partyCode[PARTY_CODE_LENGTH];

// Is the party private?
bool isPrivate = false;

char Values[1024] = "";     // Store all the values received from the wifi and wainting for treatment
char TempValues[1024] = ""; // Store values that can't be treated yet

void initNetwork(int option)
{
    // See Wifi_CheckInit to replace my_socket == 0 by !Wifi_CheckInit()
    // Call Wifi_InitDefault only once (by checking if the socket was already used), or the wifi will not work after that
    if (my_socket == 0 && !Wifi_InitDefault(WFC_CONNECT))
    {
        Connection = UNSELECTED;
        initMainMenu();
    }
    else // Then connect to server
    {
        my_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (Connection == DEBUG_IP_1)
        {
            connectToServer(DEBUG_IP_1_STRING, false, my_socket, option);
        }
        else if (Connection == ONLINE_SERVER_IP)
        {
            connectToServer(ONLINE_SERVER_IP_STRING, false, my_socket, option);
        }
        else if (Connection == DEBUG_IP_2)
        {
            connectToServer(DEBUG_IP_2_STRING, false, my_socket, option);
        }
        else if (Connection == LOCAL)
        {
            connectToServer("", true, my_socket, option); // Local mode (Android phone with the android server version (unreleased))
        }

        Connection = UNSELECTED;
    }
}

/**
 * @brief Connect the game to a server, with an url.
 *
 *
 * @param url Url of the server
 * @param LocalMode Used to connect on a localserver on an android phone
 * @param my_socket socket
 * @param option (JOIN_RANDOM_PARTY, JOIN_PARTY_CODE, JOIN_PRIVATE_PARTY)
 */
void connectToServer(char *url, bool LocalMode, int my_socket, enum JoinType option)
{
    partyOption = option;
    struct hostent *myhost;
    if (LocalMode)
    {
        // Get ip adress of the phone
        struct in_addr gateway;
        Wifi_GetIPInfo(&gateway, NULL, NULL, NULL);

        // Find the IP address of the server, with gethostbyname
        char GatewayChar[22] = "";
        sprintf(GatewayChar, "%s", inet_ntoa(gateway));
        myhost = gethostbyname(GatewayChar);
    }
    else // Find the IP address of the server, with gethostbyname
        myhost = gethostbyname(url);

    // Tell the socket to connect to the IP address we found, on port 6003 or 1080 for android phone
    struct sockaddr_in sain;
    sain.sin_family = AF_INET;
    if (!LocalMode)
        sain.sin_port = htons(SERVER_PORT);
    else
        sain.sin_port = htons(LOCAL_SERVER_PORT);
    sain.sin_addr.s_addr = *((unsigned long *)(myhost->h_addr_list[0]));

    // Connect to the server
    connect(my_socket, (struct sockaddr *)&sain, sizeof(sain));

    // Set socked in non block mode
    int blockmode = 1;
    ioctl(my_socket, FIONBIO, &blockmode);
    resetNetworkVariables();

    // Launch the read data service
    ReadServerData();
}

/**
 * @brief Reset network send values variables (call before connecting to a new server)
 *
 */
void resetNetworkVariables()
{
    SendShoot = false;
    SendLeave = false;
    SendGrenade = false;
    SendBombPlacing = false;
    SendBombPlace = false;
    SendBombDefused = false;
    SendPing = false;
    SendTeam = false;
    WaitForTeamResponse = false;
    SendBuyWeapon = false;
    SendWallHit = false;
    SendSelectedGun = false;
    SendPlayerName = false;
    SendVoteStartNow = false;
    SendKeyResponse = false;
    SendGetDroppedBomb = false;
    SendReloaded = false;
}

void treatData()
{
    int StartPosition, EndPosition;
    // printf("a:%s\n", Values);

    // If a complete packet is detected
    while ((StartPosition = strstr(Values, "{") - Values + 1) > 0 && (EndPosition = strstr(Values + StartPosition, "}") - Values) > 0)
    {
        char currentPacket[256] = "";
        strncpy(currentPacket, Values + StartPosition, EndPosition - StartPosition);

        //   Start spliting incoming data
        char *ptr = strtok(currentPacket, ";");
        int SplitCount = 0;
        char arr[10][64] = {0};

        // Split data
        while (ptr != NULL)
        {
            strcpy(arr[SplitCount], ptr);
            SplitCount++;
            ptr = strtok(NULL, ";");
        }

        // Check packet info
        if (strcmp(arr[REQUEST_NAME_INDEX], "POS") == 0) // Player position update
        {
            // Get target player id
            int PlayerIdInt = intParse(arr[1]);

            float XFloat = floatParse(arr[2]);
            float YFloat = floatParse(arr[3]);
            float ZFloat = floatParse(arr[4]);
            // Change scale
            XFloat /= 4096.0;
            YFloat /= 4096.0;
            ZFloat /= 4096.0;

            int AngleInt = intParse(arr[5]);
            int CameraAngleInt = intParse(arr[6]);

            // If new position is for the local player
            if (localPlayer->Id == PlayerIdInt)
            {
                // Set new position and teleport player
                localPlayer->position.x = XFloat;
                localPlayer->position.y = YFloat;
                localPlayer->position.z = ZFloat;
                localPlayer->Angle = AngleInt;
                localPlayer->PlayerPhysic->xspeed = 0;
                localPlayer->PlayerPhysic->yspeed = 0;
                localPlayer->PlayerPhysic->zspeed = 0;
                NE_ModelSetCoord(localPlayer->PlayerModel, localPlayer->position.x, localPlayer->position.y, localPlayer->position.z);
                ForceUpdateLookRotation(localPlayer->cameraAngle);
            }
            else
            {
                // Find player with unique ID to update his informations
                for (int i = 1; i < MaxPlayer; i++)
                    if (AllPlayers[i].Id == PlayerIdInt)
                    {
                        // If player has no position, teleport the player to new updated position (0 default position)
                        if (AllPlayers[i].lerpDestination.x == 0)
                        {
                            AllPlayers[i].position.x = XFloat;
                            AllPlayers[i].position.y = YFloat;
                            AllPlayers[i].position.z = ZFloat;
                            AllPlayers[i].Angle = AngleInt;
                        }

                        // Set player destination
                        AllPlayers[i].lerpDestination.x = XFloat;
                        AllPlayers[i].lerpDestination.y = YFloat;
                        AllPlayers[i].lerpDestination.z = ZFloat;

                        AllPlayers[i].AngleDestination = AngleInt;

                        // if (CurrentCameraPlayer == i)
                        // CameraAngleY = CameraAngleInt;
                        AllPlayers[i].cameraAngle = CameraAngleInt;
                        break;
                    }
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "WALLHIT") == 0) // Wall hit position update for hit flash at wall animation
        {
            int flashIndex = 0;
            for (int i = 0; i < FLASH_MODELS_COUNT; i++)
            {
                if (ShowWallHitFlash[i] == 0)
                {
                    flashIndex = i;
                    break;
                }
            }

            // Set animation timer
            ShowWallHitFlash[flashIndex] = 3;

            float XFloat = floatParse(arr[1]);
            float YFloat = floatParse(arr[2]);
            float ZFloat = floatParse(arr[3]);

            // Change scale
            XFloat /= 4096.0;
            YFloat /= 4096.0;
            ZFloat /= 4096.0;

            // Set effect position
            NE_ModelSetCoord(flashModels[flashIndex], XFloat, YFloat, ZFloat);

            // Get wall hit flash direction
            Vector2 Direction1D;
            Direction1D.y = YFloat - AllPlayers[CurrentCameraPlayer].position.y - CameraOffsetY + y;
            Direction1D.x = 1;
            normalize2D(&Direction1D);

            Vector3 Direction;
            Direction.x = XFloat - AllPlayers[CurrentCameraPlayer].position.x;
            Direction.y = YFloat - AllPlayers[CurrentCameraPlayer].position.y;
            Direction.z = ZFloat - AllPlayers[CurrentCameraPlayer].position.z;
            normalize(&Direction);

            // Set wall hit angle
            int FinalAngleY = atan2f(Direction.x, Direction.z) * 512.0 / (M_TWOPI) + 384;
            int FinalAngleZ = atan2f(Direction1D.y, 1) * 512.0 / (M_TWOPI) + 128;
            NE_ModelSetRot(flashModels[flashIndex], 0, FinalAngleY, FinalAngleZ);

            // Make 3D sound
            int Panning, Volume;
            Vector4 SoundPos;
            SoundPos.x = XFloat;
            SoundPos.y = YFloat;
            SoundPos.z = ZFloat;
            GetPanningByPosition(&Panning, &Volume, SoundPos, xWithoutYForAudio, zWithoutYForAudio, 0.15);
            Play3DSound(SFX_RIC, Volume, Panning, NULL);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SHOOT") == 0) // Shoot from a player
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            // Get gun id
            int ParsedGunId = intParse(arr[2]);

            // Make a sound
            int Panning, Volume;
            GetPanning(ParsedPlayerId, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, AllGuns[ParsedGunId].MaxSoundDistance);
            Player *player = NULL;
            int index = UNUSED;
            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == ParsedPlayerId)
                {
                    player = &AllPlayers[i];
                    index = i;
                    break;
                }
            }
            if (player != NULL)
            {
                if (player->currentGunInInventory == 1 || player->currentGunInInventory == 2)
                    player->AllAmmoMagazine[player->currentGunInInventory - 1].AmmoCount--;

                if (CurrentCameraPlayer == index)
                {
                    setGunRecoil(player);
                }

                if (ParsedGunId < GunCount)
                    Play3DSound(AllGuns[ParsedGunId].gunSound, Volume, Panning, player);
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "TimerA") == 0) // Timer changes
        {
            // Parse seconds and minutes texts to int
            PartyMinutes = intParse(arr[1]);
            PartySeconds = intParse(arr[2]);

            if (firstConnection)
            {
                BombSeconds = PartySeconds;
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "PING") == 0) // Get ping request from server
        {
            // Parse ping text to int
            ping = intParse(arr[1]);
            SendPing = true;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "CURGUN") == 0) // Set current gun in inventory
        {
            int PlayerIdInt = intParse(arr[1]);

            // Find player to set health
            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == PlayerIdInt)
                {
                    int newGun = intParse(arr[2]);
                    AllPlayers[i].currentGunInInventory = newGun;
                    if (i == CurrentCameraPlayer)
                        UpdateGunTexture();

                    break;
                }
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "HITSOUND") == 0) // Make a hit sound
        {
            int PlayerId = intParse(arr[2]);
            int HitType = intParse(arr[3]);

            int Panning, Volume;
            if (PlayerId != localPlayer->Id)
                GetPanning(PlayerId, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.10);
            else
            {
                Panning = 128;
                Volume = 255;

                xOffset = (rand() % ScreenShakeAmount + ScreenShakeMinAmount) / 100.0;
                if (rand() % 2 == 0)
                    xOffset = -xOffset;

                yOffset = (rand() % ScreenShakeAmount + ScreenShakeMinAmount) / 100.0;
                if (rand() % 2 == 0)
                    yOffset = -yOffset;

                redHealthTextCounter = 62;
            }

            Player *player = NULL;
            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == PlayerId)
                {
                    player = &AllPlayers[i];
                    break;
                }
            }

            if (HitType == 0)
                Play3DSound(SFX_FLESH_IMPACT, Volume, Panning, player); // Check with kevlar
            else if (HitType == 1)
                Play3DSound(SFX_HEADSHOT1, Volume, Panning, player);
            else if (HitType == 2)
                Play3DSound(SFX_FLESH_IMPACT, Volume, Panning, player);
            else
                Play3DSound(SFX_KNIFE_HIT_PLAYER, Volume, Panning, player);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETID") == 0) // Add player
        {
            int ParsedId = intParse(arr[1]);

            // Spawn player
            AddNewPlayer(ParsedId, true, false);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETMAP") == 0) // Set the map
        {
            // Parse map id text to int
            int newMapId = intParse(arr[1]);

            UnLoadMap(currentMap);
            currentMap = newMapId;
            LoadMap(currentMap);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETMODE") == 0) // Set the party mode
        {
            // Parse mode id text to int
            currentPartyMode = intParse(arr[1]);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "TEAM") == 0) // Change team
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            // Get Team value
            int ParsedIsCounter = intParse(arr[2]);

            // Find player and affect new value
            for (int i = 0; i < MaxPlayer; i++)
                if (AllPlayers[i].Id == ParsedPlayerId)
                {
                    AllPlayers[i].Team = ParsedIsCounter;
                    UpdatePlayerTexture(i);
                    break;
                }

            // Update screen if team screen is opened
            if (currentMenu == SCORE_BOARD)
            {
                UpdateBottomScreenFrameCount += 8;
            }
            else if (currentMenu == GAME)
            {
                initGameMenu();
            }

            // TODO check this
            if (localPlayer->Id == ParsedPlayerId)
            {
                if (roundState != TRAINING)
                    changeCameraPlayerView(false);

                if (ParsedIsCounter != -1)
                {
                    AllButtons[0].isHidden = false;
                }
                AllButtons[1].isHidden = false;
                AllButtons[2].isHidden = false;
                WaitForTeamResponse = false;
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "BOMBPLACE") == 0) // Bomb place update
        {
            // Convert chars into ints
            int XInt = intParse(arr[1]);
            int YInt = intParse(arr[2]);
            int ZInt = intParse(arr[3]);
            int AngleInt = intParse(arr[4]);
            int dropped = intParse(arr[5]);

            if (dropped == 1)
            {
                // Change values scale and set bomb position and angle value
                droppedBombPositionAndRotation.x = XInt / 4096.0;
                droppedBombPositionAndRotation.y = YInt / 4096.0;
                droppedBombPositionAndRotation.z = ZInt / 4096.0;
                droppedBombPositionAndRotation.r = AngleInt;

                // Set bomb 3D model position and angle value
                NE_ModelSetCoord(Model[7], droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.y, droppedBombPositionAndRotation.z);
                // NE_ModelSetCoord(Model[10], droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.y, droppedBombPositionAndRotation.z);
                Model[7]->rz = droppedBombPositionAndRotation.r;

                SetBombTakingZone(droppedBombPositionAndRotation.x, droppedBombPositionAndRotation.z, &bombDefuseZone); // Set zone for taking the bomb
                bombDropped = true;
            }
            else
            {
                // Change values scale and set bomb position and angle value
                BombPosition.x = XInt / 4096.0;
                BombPosition.y = YInt / 4096.0;
                BombPosition.z = ZInt / 4096.0;
                BombPosition.r = AngleInt;

                // Set bomb 3D model position and angle value
                NE_ModelSetCoord(Model[7], BombPosition.x, BombPosition.y, BombPosition.z);
                NE_ModelSetCoord(Model[10], BombPosition.x, BombPosition.y, BombPosition.z);
                Model[7]->rz = BombPosition.r;

                BombSeconds = allPartyModes[currentPartyMode].bombWaitingSecondsDuration;

                bombBipTimer = 120;
                BombPlanted = true;
                SetBombDefuseZone(BombPosition.x, BombPosition.z, &bombDefuseZone);
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "VOTERESULT") == 0) // Get the current vote values
        {
            int VoteTypeInt = intParse(arr[1]);

            if (VoteTypeInt == 0)
            {
                playerWantToStart = intParse(arr[2]);
                playerWantToStartLimite = intParse(arr[3]);
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "CONFIRM") == 0) // Confirm shop gun buy, or set player gun from server command
        {
            // Convert chars into ints
            int ConfirmTypeInt = intParse(arr[1]);
            int ConfirmArgumentInt = intParse(arr[2]);
            int ConfirmInventoryIndexInt = intParse(arr[3]);
            int ConfirmResultInt = intParse(arr[4]); // 0 Error, 1 Okay

            if (ConfirmTypeInt == 0) // Set gun in inventory
            {
                if (ConfirmResultInt == 0) // Error
                {
                }
                else if (ConfirmResultInt == 1) // Okay
                {
                    DisableAim();
                    SetGunInInventory(ConfirmArgumentInt, ConfirmInventoryIndexInt);
                    setSelectedGunInInventory(0, ConfirmInventoryIndexInt);
                }
                else if (ConfirmResultInt == 2) // Not an error
                {
                }
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETMONEY") == 0) // Set player money
        {
            // Parse money text to int
            int ParsedMoney = intParse(arr[1]);
            setPlayerMoney(0, ParsedMoney);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SCORE") == 0) // Party score changes
        {
            // Parse scores texts to int
            CounterScore = intParse(arr[1]);
            TerroristsScore = intParse(arr[2]);

            // Update screen if team screen is opened
            if (currentMenu == SCORE_BOARD)
                UpdateBottomScreenFrameCount += 8;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SCRBOARD") == 0) // Score board score changes
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            // Find player with unique ID to update his informations
            for (int i = 0; i < MaxPlayer; i++)
                if (AllPlayers[i].Id == ParsedPlayerId)
                {
                    AllPlayers[i].KillCount = intParse(arr[2]);
                    AllPlayers[i].DeathCount = intParse(arr[3]);
                    break;
                }

            // Update screen if team screen is opened
            if (currentMenu == SCORE_BOARD)
                UpdateBottomScreenFrameCount += 8;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETSHOPZONE") == 0) // Update the shop zone
        {
            shopDisableTimer = SHOP_DISABLE_TIMER;
            setShopZone(localPlayer);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "PartyRound") == 0) // Round state changes
        {
            // Parse text to int
            int tempRoundState = intParse(arr[1]);

            roundState = tempRoundState;

            // Reset some values on new round
            if (roundState == WAIT_START)
            {
                onNewRoundStart();
                NE_SpriteVisible(TopScreenSprites[0], true);

                StopReloading(0);
                ResetGunsAmmo(0);
                if (CurrentCameraPlayer != 0)
                {
                    SetCurrentCameraPlayer(0);
                }
                for (int i = 0; i < MaxPlayer; i++)
                    AllPlayers[i].IsDead = FALSE;

                deathCameraAnimation = 0;
                deathCameraYOffset = 0;
                redHealthTextCounter = 0;
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "LEAVE") == 0) // When a player leave
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            // Find player
            for (int i = 0; i < MaxPlayer; i++)
                if (AllPlayers[i].Id == ParsedPlayerId)
                {
                    AllPlayers[i].Id = UNUSED;
                    PlayerCount--;
                    NE_ModelDelete(AllPlayers[i].PlayerModel);
                    if (i == 0)
                    {
                        NE_PhysicsDelete(AllPlayers[i].PlayerPhysic);
                    }
                    else
                    {
                        showDisconnectedText(i);
                    }
                    AllPlayers[i].KillCount = 0;
                    AllPlayers[i].Team = SPECTATOR;
                    AllPlayers[i].DeathCount = 0;
                    if (currentMenu == SCORE_BOARD)
                        initScoreMenu();

                    if (CurrentCameraPlayer == i)
                    {
                        SetCurrentCameraPlayer(0);
                    }

                    break;
                }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETHEALTH") == 0) // Set player health
        {
            int PlayerIdInt = intParse(arr[1]);

            // Find player to set health
            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == PlayerIdInt)
                {
                    int newHealth = intParse(arr[2]);
                    setPlayerHealth(i, newHealth);
                    AllPlayers[i].armor = intParse(arr[3]);

                    int haveHeadset = intParse(arr[4]);
                    AllPlayers[i].haveHeadset = haveHeadset == 1 ? true : false;
                    break;
                }
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETBOMB") == 0) // Set/remove the bomb of a player
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            // Get gun id
            int haveBomb = intParse(arr[2]);

            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == ParsedPlayerId && haveBomb == 1)
                {
                    AllPlayers[i].haveBomb = true;
                    bombDropped = false;
                    SetGunInInventoryForNonLocalPlayer(i, 28, 8);
                }
                else
                {
                    AllPlayers[i].haveBomb = false;
                    SetGunInInventoryForNonLocalPlayer(i, EMPTY, 8);
                }
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "RELOADED") == 0) // Reload the gun of a player
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            int Reset = intParse(arr[2]);

            if (Reset == 0)
            {
                ReloadGun(ParsedPlayerId);
            }
            else if (Reset == 1)
            {
                ResetGunsAmmo(ParsedPlayerId);
            }
            else if (Reset == 2)
            {
                int GunId = intParse(arr[4]);
                ResetGunAmmo(ParsedPlayerId, GunId);
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETNAME") == 0) // Get a player name
        {
            // Get player id
            int ParsedPlayerId = intParse(arr[1]);

            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == ParsedPlayerId)
                {
                    strcpy(AllPlayers[i].name, arr[2]);
                    if (i != 0 && !firstConnection)
                        showConnectedText(i);
                    break;
                }
            }

            // Update screen if team screen is opened
            if (currentMenu == 2)
                UpdateBottomScreenFrameCount += 8;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "SETCODE") == 0) // Get the party code
        {
            strcpy(partyCode, arr[1]);
            isPrivate = true;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "ERROR") == 0) // Show text from server
        {
            int errorId = intParse(arr[1]);
            if (errorId == Ban)
            {
                strcpy(errorText, "You are banned!");
            }
            else if (errorId == WrongVersion)
            {
                strcpy(errorText, "You are using an old version of the game, please update your game.");
            }
            else if (errorId == MacAddressMissing)
            {
                strcpy(errorText, "Your Nintendo DS doesn't have a MAC address.");
            }
            else if (errorId == WrongSecurityKey)
            {
                strcpy(errorText, "You are using a modified game.");
            }
            else if (errorId == ServerFull)
            {
                strcpy(errorText, "The server is currently full, please try again later.");
            }
            else if (errorId == ServerStopped)
            {
                strcpy(errorText, "The server is currently under maintenance.");
            }
            else if (errorId == SaveCorrupted)
            {
                strcpy(errorText, "Your save is corrupted.");
            }
            else if (errorId == IncorrectCode)
            {
                strcpy(errorText, "The code is incorrect.");
            }
            else if (errorId == KickTeamKill)
            {
                strcpy(errorText, "You have been kicked (Team kill).");
            }
            else
            {
                strcpy(errorText, "An error has occurred!");
            }

            initOnlineErrorMenu();
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "TEXT") == 0) // Show text from server
        {
            int ParsedTextId = intParse(arr[1]);

            showPartyEventText(ParsedTextId);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "TEXTPLAYER") == 0) // Show text about a player from server
        {
            int ParsedPlayerId = intParse(arr[1]);

            int KillerIdInt = intParse(arr[2]);
            // int TextIdInt = intParse(arr[3]); unused

            int killerPlayerIndex = NO_PLAYER;
            int killedPlayerIndex = NO_PLAYER;

            if (KillerIdInt != NO_PLAYER)
            {
                // Find player with unique ID to update his informations
                for (int i = 0; i < MaxPlayer; i++)
                {
                    if (AllPlayers[i].Id == KillerIdInt)
                    {
                        killerPlayerIndex = i;
                        break;
                    }
                }
            }

            if (ParsedPlayerId != NO_PLAYER)
            {
                for (int i = 0; i < MaxPlayer; i++)
                {
                    if (AllPlayers[i].Id == ParsedPlayerId)
                    {
                        killedPlayerIndex = i;
                        break;
                    }
                }
            }

            if (killerPlayerIndex != NO_PLAYER && killerPlayerIndex != NO_PLAYER)
                showKillText(killerPlayerIndex, killedPlayerIndex);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "BOMBPLACING") == 0) // Bomb placing sound
        {
            int ParsedPlayerId = intParse(arr[1]);

            int Panning, Volume;
            GetPanning(ParsedPlayerId, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.10);

            Play3DSound(SFX_BOMBPLANTING, Volume, Panning, GetPlayer(ParsedPlayerId));
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "BOMBDEFUSE") == 0) // Bomb defuse sound
        {
            BombDefused = true;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "ADDRANGE") == 0) // Add multiples non local players
        {
            for (int i = 1; i < SplitCount; i++)
            {
                int FoundId = intParse(arr[i]);
                AddNewPlayer(FoundId, false, false);
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "ENDGAME") == 0) // End the party
        {
            partyFinished = true;
            initFinalScoreMenu();
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "ENDUPDATE") == 0) // End the update party sequence
        {
            firstConnection = false;
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "INVTORY") == 0) // Get the inventory of a player
        {
            int ParsedPlayerId = intParse(arr[1]);

            int FoundPlayer = UNUSED;
            for (int i = 0; i < MaxPlayer; i++)
            {
                if (AllPlayers[i].Id == ParsedPlayerId)
                {
                    FoundPlayer = i;
                    for (int i2 = 2; i2 < SplitCount; i2++)
                    {
                        int FoundGunId = intParse(arr[i2]);
                        SetGunInInventoryForNonLocalPlayer(i, FoundGunId, i2 - 2);
                    }
                    break;
                }
            }
            // If the current player camera is looked by the local player, update the gun texture
            if (FoundPlayer == CurrentCameraPlayer)
            {
                UpdateGunTexture();
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "AMMO") == 0) // Get the ammo count of a player
        {
            int ParsedPlayerId = intParse(arr[1]);
            int FoundPlayer = UNUSED;
            for (int playerIndex = 0; playerIndex < MaxPlayer; playerIndex++)
            {
                if (AllPlayers[playerIndex].Id == ParsedPlayerId)
                {
                    FoundPlayer = playerIndex;
                    for (int i2 = 0; i2 < 2; i2++)
                    {
                        int AmmoCountInt = intParse(arr[2 + i2 * 2]);
                        int TotalAmmoCountInt = intParse(arr[2 + i2 * 2 + 1]);

                        AllPlayers[FoundPlayer].AllAmmoMagazine[i2].AmmoCount = AmmoCountInt;
                        AllPlayers[FoundPlayer].AllAmmoMagazine[i2].TotalAmmoCount = TotalAmmoCountInt;
                    }
                    break;
                }
            }
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "KEY") == 0) // Get the key from the server
        {
            SendKeyResponse = true;
            serverKey = intParse(arr[1]);
        }
        else if (strcmp(arr[REQUEST_NAME_INDEX], "GRENADE") == 0) // Spawn a player's grenade
        {
            // Convert chars into ints
            float XDirection = floatParse(arr[1]);
            float YDirection = floatParse(arr[2]);
            float ZDirection = floatParse(arr[3]);
            int XInt = intParse(arr[4]);
            int YInt = intParse(arr[5]);
            int ZInt = intParse(arr[6]);
            int GrenadeType = intParse(arr[7]);

            PhysicalGrenade *newGrenade = CreateGrenade(GrenadeType, 0);
            if (newGrenade != NULL)
            {
                lanchGrenade(newGrenade, XDirection, YDirection, ZDirection, XInt, YInt, ZInt);
            }
        }

        // Clear "TempValues"
        for (int i = 0; i < sizeof(TempValues); i++)
            TempValues[i] = '\0';
        // Values[strlen(Values)] = '\0';
        //  Add all characters after current data packet to "TempValues"
        strcat(TempValues, Values + EndPosition + 1);
        // Copy "TempValues" to "Values"
        strcpy(Values, TempValues);
    }
}

/**
 * @brief Read data from the game server
 *
 */
void ReadServerData()
{
    // All temp variable for incoming data
    int recvd_len = 0;
    char incoming_buffer[64];

    // Read a maximum of 64 char in one loop
    while ((recvd_len = recv(my_socket, incoming_buffer, 63, 0)) != 0) // if recv returns 0, the socket has been closed. (Sometimes yes, sometimes not, lol)
    {
        if (recvd_len > 0)
        {
            // printf("\n{%d %s}\n", recvd_len, wirelessData);
            timeOut = 0;
            incoming_buffer[recvd_len] = 0; // null-terminate
            // add incoming_buffer to Values
            strncat(Values, incoming_buffer, recvd_len);
            treatData();
        }
        else if (recvd_len == -1)
        {
            // If the recv() returns -1 for too long, the socket has been closed.
            timeOut++;
            if (timeOut == 400)
            {
                break;
            }
        }

        if (localPlayer->Id != UNUSED)
        {
            // Play game code
            GameLoop();
        }

        UpdateEngine();
        sendDataToServer();
    }
    shutdown(my_socket, 0); // good practice to shutdown the socket.
    closesocket(my_socket);
    Connection = UNSELECTED;
    if (!partyFinished && currentMenu != ONLINE_ERROR)
    {
        initMainMenu();
    }
    partyFinished = false;
    isPrivate = false;
    firstConnection = true;
    OnPartyQuit();
}

/**
 * @brief Send data to the server
 *
 */
void sendDataToServer()
{
    // Check if position need to be updated for other player
    if (localPlayer->position.x != OldxPos || localPlayer->position.y != OldyPos || localPlayer->position.z != OldzPos)
    {
        OldxPos = localPlayer->position.x;
        OldyPos = localPlayer->position.y;
        OldzPos = localPlayer->position.z;
        SendPosition = true;
    }

    char InfoToSend[1024] = "";

    // Send shoot data for sound/animation for clients
    if (SendLeave)
    {
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", LEAVE);
        SendLeave = false;
    }

    // Send position one in two
    if (SendPositionData > 0)
        SendPositionData--;

    // If local player need to be updated for other player (59 bytes)
    if (localPlayer->Id != -1 && SendPosition && SendPositionData == 0)
    {
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d;%d;%d;%d;%0.0f}", POS, localPlayer->PlayerModel->x, localPlayer->PlayerModel->y, localPlayer->PlayerModel->z, (int)localPlayer->Angle, localPlayer->cameraAngle);

        SendPosition = false;
        SendPositionData = 4;
    }

    // Send grenade launch
    if (SendGrenade)
    {
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%f;%f;%f}", GRENADE, x, y, z);
        SendGrenade = false;
    }

    // Send bomb placement data
    if (SendBombPlace)
    {
        SendBombPlace = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d;%d;%d;%d}", BOMBPLACE, (int)(BombPosition.x * 4096.0), (int)(BombPosition.y * 4096.0), (int)(BombPosition.z * 4096.0), BombPosition.r);
    }

    // Send bomb defuse data
    if (SendBombDefused)
    {
        SendBombDefused = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", BOMBDEFUSE);
    }

    // Send bomb planting data
    if (SendBombPlacing)
    {
        SendBombPlacing = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", BOMBPLACING);
    }

    // Send team data
    if (SendTeam)
    {
        SendTeam = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d}", TEAM, tempTeam);
        tempTeam = -1;
    }

    // Send ping reply
    if (SendPing)
    {
        SendPing = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", PING);
    }

    // Send buy weapon request data
    if (SendBuyWeapon)
    {
        SendBuyWeapon = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d}", BUY, GetSelectedGunShop());
    }

    // Send gun reloaded data
    if (SendReloaded)
    {
        SendReloaded = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", RELOADED);
    }

    // Send selected gun
    if (SendSelectedGun)
    {
        SendSelectedGun = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d}", CURGUN, localPlayer->currentGunInInventory);
    }

    // Send shoot data for sound/animation for clients
    if (SendShoot)
    {
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", SHOOT);
        SendShoot = false;
    }

    // Check if the game needs to send hitted clients
    bool sendHitClient = false;
    for (int i = 0; i < FLASH_MODELS_COUNT; i++)
    {
        if (hittedClient[i] != NO_PLAYER)
        {
            sendHitClient = true;
            break;
        }
    }

    // Send hit data
    if (sendHitClient)
    {
        sprintf(InfoToSend + strlen(InfoToSend), "{%d", HIT);
        for (int i = 0; i < FLASH_MODELS_COUNT; i++)
        {
            if (hittedClient[i] != -1)
            {
                sprintf(InfoToSend + strlen(InfoToSend), ";%d;%d;%d;%f", AllPlayers[hittedClient[i]].Id, localPlayer->IsHeadShot[i], localPlayer->IsLegShot[i], hitDistance[i]);
                hittedClient[i] = NO_PLAYER;
            }
        }
        sprintf(InfoToSend + strlen(InfoToSend), "}");
    }

    // Send vote
    if (SendVoteStartNow)
    {
        SendVoteStartNow = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;0}", VOTE);
    }

    // Send wall hit data
    if (SendWallHit)
    {
        SendWallHit = false;
        for (int i = 0; i < getPlayerCurrentGun(localPlayer).bulletCountPerShoot; i++)
        {
            sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d;%d;%d}", WALLHIT, WallHitXPos[i], WallHitYPos[i], WallHitZPos[i]);
        }
    }

    // Send local player name
    if (SendPlayerName)
    {
        SendPlayerName = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%s}", SETNAME, localPlayer->name);
    }

    // Send security key response
    if (SendKeyResponse)
    {
        SendKeyResponse = false;

        u8 macAddress[6];
        Wifi_GetData(WIFIGETDATA_MACADDRESS, 6, macAddress);

        sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d;%02X%02X%02X%02X%02X%02X;%s;%s}", KEY, getKeyResponse(serverKey), macAddress[0], macAddress[1], macAddress[2], macAddress[3], macAddress[4], macAddress[5], localPlayer->name, GAME_VERSION);

        if (partyOption == JOIN_PRIVATE_PARTY)
            sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d;%s}", PARTY, partyOption, partyCode);
        else
            sprintf(InfoToSend + strlen(InfoToSend), "{%d;%d}", PARTY, partyOption);
    }

    // Send get bomb dropped event
    if (SendGetDroppedBomb)
    {
        SendGetDroppedBomb = false;
        sprintf(InfoToSend + strlen(InfoToSend), "{%d}", GETBOMB);
    }

    // Get string data length
    int InfoLentgh = strlen(InfoToSend);
    if (InfoLentgh != 0)
    {
        // Send the current frame
        char tmp[20];
        sprintf(tmp, "{%d;%d}", FRAME, frameCount);
        send(my_socket, tmp, strlen(tmp), 0); // Send data to server

        send(my_socket, InfoToSend, InfoLentgh, 0); // Send data to server

        // sendto(my_socket, InfoToSend, InfoLentgh, 0, (struct sockaddr *)&sain, sizeof(sain)); //UDP
    }
}

/**
 * @brief Parse a string to an int
 *
 * @param charToParse
 * @return int
 */
int intParse(char *charToParse)
{
    int result = 0;
    sscanf(charToParse, "%d", &result);
    return result;
}

/**
 * @brief Parse a string to a float
 *
 * @param charToParse
 * @return int
 */
float floatParse(char *charToParse)
{
    float result = 0;
    sscanf(charToParse, "%f", &result);
    return result;
}

/**
 * @brief Get player from id
 *
 * @param id
 * @return Player*
 */
Player *GetPlayer(int id)
{
    for (int i = 0; i < MaxPlayer; i++)
    {
        if (AllPlayers[i].Id == id)
            return &AllPlayers[i];
    }
    return NULL;
}
```

`Counter-Strike-nds/source/network/network.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef NETWORK_H_ /* Include guard */
#define NETWORK_H_

#define PARTY_CODE_LENGTH 5
enum ErrorType
{
    Ban = 0,
    WrongVersion = 1,
    MacAddressMissing = 2,
    WrongSecurityKey = 3,
    ServerFull = 4,
    ServerStopped = 5,
    SaveCorrupted = 6,
    IncorrectCode = 7,
    KickTeamKill = 8
};

enum JoinType
{
    JOIN_RANDOM_PARTY = 0,
    CREATE_PRIVATE_PARTY = 1,
    JOIN_PRIVATE_PARTY = 2
};

enum RequestType
{
    PING = 0,
    STPEP = 1,
    WALLHIT = 2,
    BOMBPLACE = 3,
    BOMBPLACING = 4,
    BOMBDEFUSE = 5,
    CURGUN = 6,
    LEAVE = 7,
    VOTE = 8,
    GRENADE = 9,
    POS = 10,
    SETNAME = 11,
    SHOOT = 12,
    HIT = 13,
    PARTY = 14,
    BUY = 15,
    TEAM = 16,
    KEY = 17,
    SETID = 18,
    TIMER = 19,
    SETMAP = 20,
    SETMODE = 21,
    VOTERESULT = 22,
    CONFIRM = 23,
    SETMONEY = 24,
    SCORE = 25,
    SCRBOARD = 26,
    SETSHOPZONE = 27,
    PARTYROUND = 28,
    SETHEALTH = 29,
    SETBOMB = 30,
    SETCODE = 31,
    HITSOUND = 32,
    ERROR = 33,
    TEXT = 34,
    TEXTPLAYER = 35,
    ADDRANGE = 36,
    ENDGAME = 37,
    ENDUPDATE = 38,
    INVTORY = 39,
    GETBOMB = 40,
    FRAME = 41,
    RELOADED = 42,
    STATUS = 43,
};

#define REQUEST_NAME_INDEX 0

#define DEBUG_IP_1_STRING ""
#define DEBUG_IP_2_STRING ""
#define ONLINE_SERVER_IP_STRING "cs.fewnity.com"
#define SERVER_PORT 6003
#define LOCAL_SERVER_PORT 1080 // For the android server version (but this is not used)

extern int ping;
extern char partyCode[PARTY_CODE_LENGTH];
extern bool isPrivate;

// Socket
extern int my_socket;

// Write part
extern bool SendPosition;
extern int SendPositionData;
extern bool SendShoot;
extern bool SendGrenade;
extern bool SendBombPlacing;
extern bool SendBombPlace;
extern bool SendBombDefused;
extern bool SendPing;
extern bool SendLeave;
extern bool SendTeam;
extern bool WaitForTeamResponse;
extern bool SendBuyWeapon;
extern bool SendWallHit;
extern bool SendSelectedGun;
extern bool SendPlayerName;
extern bool SendVoteStartNow;
extern bool SendGetDroppedBomb;
extern bool SendReloaded;

extern int timeOut;
extern int frameCount;

void SetPlayer();
void initNetwork(int option);
void connectToServer(char *url, bool LocalMode, int my_socket, enum JoinType option);
void ReadServerListData();
void ReadServerData();
void connectFromServerList(int unused);
Player *GetPlayer(int id);
void resetNetworkVariables();
void treatData();
void sendDataToServer();
int intParse(char *charToParse);
float floatParse(char *charToParse);

#endif // NETWORK_H_
```

`Counter-Strike-nds/source/network/security.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "../main.h"
#include "security.h"

// For random system
#include <time.h>

// Key sent by the server
int serverKey = 0;

// For debug, set to true to simulate an wrong key
bool failKey = false;

// Public version
/**
 * @brief Get a key response from the server key
 *
 * @param key Server key
 * @return int Key response
 */
int getKeyResponse(int key)
{
    // Here there is a security key generator from a server key
    // Secret code, create you own
    // Same code as the server's security code
    // Generate a key from a base key, this new key is used to check if the game is an official version
    return -1;
}

```

`Counter-Strike-nds/source/network/security.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef DEBUG_H_ /* Include guard */
#define DEBUG_H_

extern int serverKey;

int getKeyResponse(int key);

#endif // DEBUG_H_
```

`Counter-Strike-nds/source/party/party.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "party.h"
#include "ai.h"
#include "player.h"
#include "tutorial.h"
#include "gun.h"
#include "stats.h"
#include "camera.h"
#include "sounds.h"

// Party modes data
PartyMode allPartyModes[3];

// Waypoint where the bomb is planted
int bombPlantedAt = -1;
// Current player that is a defuser
int currentDefuserIndex = -1;
// Position of the dropped bomb (if any)
Vector4 droppedBombPositionAndRotation;
// Is the bomb dropped?
bool bombDropped = false;

// Party minutes timer
int PartyMinutes = 0;
// Party seconds timer
int PartySeconds = 0;
// Bomb seconds timer
int BombSeconds = 0;
// Current round state
enum RoundState roundState = TRAINING;
// Score of Counter Terrorists
int CounterScore = 0;
// Score of Terrorists
int TerroristsScore = 0;
// Party mode (index of allPartyModes)
int currentPartyMode = 2;
// Current map (index of allMaps)
int currentMap = 0;
// Is the party finished?
bool partyFinished = false;

/**
 * @brief Load party modes datas
 *
 */
void AddAllPartyModes()
{
    // Competitive
    AddPartyMode(0, true, 30, 800, 16000, 3250, 3500, 1400, 500, 300, 300, 800, 300, true, true, false);
    allPartyModes[0].trainingMinutesDuration = 0;
    // allPartyModes[0].trainingSecondsDuration = 20;
    allPartyModes[0].trainingSecondsDuration = 0;

    allPartyModes[0].startRoundMinutesDuration = 0;
    allPartyModes[0].startRoundSecondsDuration = 15;

    allPartyModes[0].roundMinutesDuration = 1;
    allPartyModes[0].roundSecondsDuration = 55;

    allPartyModes[0].endRoundMinutesDuration = 0;
    allPartyModes[0].endRoundSecondsDuration = 5;

    allPartyModes[0].bombWaitingMinutesDuration = 0;
    allPartyModes[0].bombWaitingSecondsDuration = 40;

    allPartyModes[0].trainingRespawnMinutesDuration = 0;
    allPartyModes[0].trainingRespawnSecondsDuration = 5;

    allPartyModes[0].spawnWithArmor = false;

    allPartyModes[0].infiniteMoney = false;
    allPartyModes[0].infiniteTimer = false;
    allPartyModes[0].limitedShopByZoneAndTimer = true;
    allPartyModes[0].noScore = false;
    allPartyModes[0].infiniteGunAmmo = false;

    // Casual
    AddPartyMode(1, false, 15, 1000, 10000, 2700, 2700, 2400, 0, 200, 200, 200, 0, false, false, true);
    // AddPartyMode(1, false, 2, 1000, 10000, 2700, 2700, 2400, 0, 200, 200, 200, 0, false, false, true);
    // allPartyModes[1].trainingMinutesDuration = 2;
    // allPartyModes[1].trainingSecondsDuration = 20;
    allPartyModes[1].trainingMinutesDuration = 0;
    allPartyModes[1].trainingSecondsDuration = 0;

    allPartyModes[1].startRoundMinutesDuration = 0;
    allPartyModes[1].startRoundSecondsDuration = 15;

    allPartyModes[1].roundMinutesDuration = 2;
    allPartyModes[1].roundSecondsDuration = 15;

    allPartyModes[1].endRoundMinutesDuration = 0;
    allPartyModes[1].endRoundSecondsDuration = 5;

    allPartyModes[1].bombWaitingMinutesDuration = 0;
    allPartyModes[1].bombWaitingSecondsDuration = 40;

    allPartyModes[1].trainingRespawnMinutesDuration = 0;
    allPartyModes[1].trainingRespawnSecondsDuration = 5;

    allPartyModes[1].spawnWithArmor = true;

    allPartyModes[1].infiniteMoney = false;
    allPartyModes[1].infiniteTimer = false;
    allPartyModes[1].limitedShopByZoneAndTimer = true;
    allPartyModes[1].noScore = false;
    allPartyModes[1].infiniteGunAmmo = false;

    // Training
    AddPartyMode(2, false, 0, 10000, 10000, 0, 0, 0, 0, 0, 0, 0, 0, false, false, false);

    allPartyModes[2].trainingMinutesDuration = 0;
    allPartyModes[2].trainingSecondsDuration = 0;

    allPartyModes[2].startRoundMinutesDuration = 0;
    allPartyModes[2].startRoundSecondsDuration = 0;

    allPartyModes[2].roundMinutesDuration = 0;
    allPartyModes[2].roundSecondsDuration = 0;

    allPartyModes[2].endRoundMinutesDuration = 0;
    allPartyModes[2].endRoundSecondsDuration = 0;

    allPartyModes[2].bombWaitingMinutesDuration = 0;
    allPartyModes[2].bombWaitingSecondsDuration = 40;

    allPartyModes[2].trainingRespawnMinutesDuration = 0;
    allPartyModes[2].trainingRespawnSecondsDuration = 2;

    allPartyModes[2].spawnWithArmor = true;

    allPartyModes[2].infiniteMoney = true;
    allPartyModes[2].infiniteTimer = true;
    allPartyModes[2].limitedShopByZoneAndTimer = false;
    allPartyModes[2].noScore = true;
    allPartyModes[2].infiniteGunAmmo = true;
}

/**
 * @brief "Constructor" of a party mode
 *
 * @param index Index of the party mode
 * @param MiddlePartyTeamSwap If true, at the middle of the party, teams will swap
 * @param MaxRound Number of rounds in the party
 * @param StartMoney Starting money of the players
 * @param MaxMoney Maximum money of the players
 * @param WinTheRoundMoney Money won by winners of the round
 * @param WinTheRoundBombMoney Money won by winners of the round if the bomb is planted
 * @param LoseTheRoundMoney Money won by losers of the round
 * @param LoseIncrease
 * @param DefuseBombMoneyBonus Money won by defuser of the round
 * @param PlantBombMoneyBonus Money won by planter of the round
 * @param PlantedBombLoseMoneyBonus
 * @param KillPenalties Money lost by each kill
 * @param NoMoneyOnTimeEnd If true, the players will not win money when the time is over
 * @param TeamDamage If true, players in same teams will take damage from each other
 * @param CanSeeOtherTeamView If true, players in other teams can see each other
 */
void AddPartyMode(int index, bool MiddlePartyTeamSwap, int MaxRound, int StartMoney, int MaxMoney, int WinTheRoundMoney, int WinTheRoundBombMoney, int LoseTheRoundMoney, int LoseIncrease, int DefuseBombMoneyBonus, int PlantBombMoneyBonus, int PlantedBombLoseMoneyBonus, int KillPenalties, bool NoMoneyOnTimeEnd, bool TeamDamage, bool CanSeeOtherTeamView)
{
    PartyMode *newPartyMode = &allPartyModes[index];
    newPartyMode->middlePartyTeamSwap = MiddlePartyTeamSwap;
    newPartyMode->maxRound = MaxRound;
    newPartyMode->startMoney = StartMoney;
    newPartyMode->maxMoney = MaxMoney;
    newPartyMode->winTheRoundMoney = WinTheRoundMoney;
    newPartyMode->winTheRoundBombMoney = WinTheRoundBombMoney;
    newPartyMode->loseTheRoundMoney = LoseTheRoundMoney;
    newPartyMode->loseIncrease = LoseIncrease;
    newPartyMode->defuseBombMoneyBonus = DefuseBombMoneyBonus;
    newPartyMode->plantBombMoneyBonus = PlantBombMoneyBonus;
    newPartyMode->plantedBombLoseMoneyBonus = PlantedBombLoseMoneyBonus;
    newPartyMode->killPenalties = KillPenalties;
    newPartyMode->noMoneyOnTimeEnd = NoMoneyOnTimeEnd;
    newPartyMode->teamDamage = TeamDamage;
    newPartyMode->canSeeOtherTeamView = CanSeeOtherTeamView;
}

/**
 * @brief To call on each new round
 *
 */
void onNewRoundStart()
{
    // Reset some values
    bombDropped = false;
    bombSet = false;
    bombPlantedAt = -1;
    BombPlanted = false;
    BombDefused = false;
    bombBipTimer = 0;
    BombWillExplode = false;
    IsExplode = false;
    BombExplosionScale = 0;
    currentDefuserIndex = NO_PLAYER;

    // Delete grenades
    DeleteAllGrenade();
    // Disable player aim
    DisableAim();
}

/**
 * @brief Party tick
 *
 */
void partyTimerTick()
{
    if (!partyFinished)
    {
        // Reduce seconds every 60 frames
        changeSecondTimer--;
        if (changeSecondTimer == 0)
        {
            // Reduce bomb seconds
            if (BombPlanted && !BombDefused && BombSeconds > 0 && !isInTutorial)
                BombSeconds--;

            if (!allPartyModes[currentPartyMode].infiniteTimer)
            {
                // Reduce seconds
                PartySeconds--;
                if (PartySeconds == -1)
                {
                    // Reduce minutes
                    PartyMinutes--;
                    PartySeconds = 59;

                    if (PartyMinutes == -1) // At the end of the round timer
                    {
                        // Change round state
                        if (!PartyStarted)
                        {
                            // Start party
                            PartyStarted = true;
                            onNewRoundStart();

                            // Set new timer
                            PartyMinutes = allPartyModes[currentPartyMode].startRoundMinutesDuration;
                            PartySeconds = allPartyModes[currentPartyMode].startRoundSecondsDuration;
                            shopDisableTimer = SHOP_DISABLE_TIMER;
                            roundState = WAIT_START;

                            // Reset players
                            for (int i = 0; i < MaxPlayer; i++)
                            {
                                if (AllPlayers[i].Id == UNUSED)
                                    continue;
                                resetPlayer(i);
                                setPlayerMoney(i, allPartyModes[currentPartyMode].startMoney);
                                AllPlayers[i].KillCount = 0;
                                AllPlayers[i].DeathCount = 0;
                            }

                            // Update screen if needed
                            if (currentMenu == SCORE_BOARD)
                                UpdateBottomScreenFrameCount += 8;

                            // Buy guns for guns
                            checkShopForBots();
                            // Give the bomb to a player
                            setBombForARandomPlayer();
                            // Set players position to their spawns
                            setPlayersPositionAtSpawns();
                            // Put a weapons in the hands of each player
                            setNewRoundHandWeapon();
                        }
                        else if (roundState == WAIT_START)
                        {
                            // Start round
                            // Set new timer
                            PartyMinutes = allPartyModes[currentPartyMode].roundMinutesDuration;
                            PartySeconds = allPartyModes[currentPartyMode].roundSecondsDuration;
                            roundState = PLAYING;
                        }
                        else if (roundState == PLAYING)
                        {
                            // Stop the round
                            setEndRound();

                            if (bombSet)
                            {
                                TerroristsScore++;

                                if (LoseCountCounterTerrorists > 0)
                                    LoseCountCounterTerrorists--;

                                if (LoseCountTerrorists < 4)
                                    LoseCountTerrorists++;

                                addMoneyToTeam(allPartyModes[currentPartyMode].winTheRoundBombMoney, TERRORISTS);
                                addMoneyToTeam(allPartyModes[currentPartyMode].loseTheRoundMoney + allPartyModes[currentPartyMode].loseIncrease * LoseCountTerrorists, COUNTERTERRORISTS);

                                showPartyEventText(0);
                            }
                            else
                            {
                                CounterScore++;

                                if (LoseCountTerrorists > 0)
                                    LoseCountTerrorists--;

                                if (LoseCountCounterTerrorists < 4)
                                    LoseCountCounterTerrorists++;

                                if (!allPartyModes[currentPartyMode].noMoneyOnTimeEnd)
                                {
                                    addMoneyToTeam(allPartyModes[currentPartyMode].loseTheRoundMoney, TERRORISTS);
                                }
                                addMoneyToTeam(allPartyModes[currentPartyMode].winTheRoundBombMoney, COUNTERTERRORISTS);

                                showPartyEventText(1);
                            }

                            CheckAfterRound();
                        }
                        else if (roundState == END_ROUND)
                        {
                            // Restart round
                            onNewRoundStart();
                            PartyMinutes = allPartyModes[currentPartyMode].startRoundMinutesDuration;
                            PartySeconds = allPartyModes[currentPartyMode].startRoundSecondsDuration;
                            roundState = WAIT_START;
                            onNewRoundStart();

                            for (int i = 0; i < MaxPlayer; i++)
                            {
                                resetPlayer(i);
                            }
                            checkShopForBots();
                            setBombForARandomPlayer();
                            setPlayersPositionAtSpawns();
                            setNewRoundHandWeapon();
                            shopDisableTimer = SHOP_DISABLE_TIMER;
                        }
                        else if (roundState == END)
                        {
                            partyFinished = true;
                            initFinalScoreMenu();
                            // initGameFinishedMenu();
                        }
                    }
                }
            }
            changeSecondTimer = 60;
        }
    }
}

/**
 * @brief End the round
 *
 */
void setEndRound()
{
    PartyMinutes = allPartyModes[currentPartyMode].endRoundMinutesDuration;
    PartySeconds = allPartyModes[currentPartyMode].endRoundSecondsDuration;
    roundState = END_ROUND;
    currentDefuserIndex = NO_PLAYER;
}

/**
 * @brief Party tick online (no game rules gestion)
 *
 */
void partyTimerTickOnline()
{
    if (!partyFinished)
    {
        changeSecondTimer--;
        if (changeSecondTimer == 0)
        {
            // Reduce bomb seconds
            if (BombPlanted && !BombDefused && BombSeconds > 0)
                BombSeconds--;

            changeSecondTimer = 60;
        }
    }
}

/**
 * @brief Set party as finished
 *
 */
void finishParty()
{
    // Set end timer
    PartyMinutes = allPartyModes[currentPartyMode].endRoundMinutesDuration;
    PartySeconds = allPartyModes[currentPartyMode].endRoundSecondsDuration;
    roundState = END;
}

/**
 * @brief Check the party score to do some event (swap teams, finish the party)
 *
 */
void CheckAfterRound()
{
    int scoreFloor = floor(allPartyModes[currentPartyMode].maxRound / 2.0);
    int totalScore = TerroristsScore + CounterScore;
    // Check if a team won
    if (TerroristsScore == scoreFloor + 1 || CounterScore == scoreFloor + 1 || totalScore == allPartyModes[currentPartyMode].maxRound)
    {
        finishParty();
    }
    else if (allPartyModes[currentPartyMode].middlePartyTeamSwap && totalScore == scoreFloor) // Or check team swap
    {
        // Swap team
        for (int i = 0; i < MaxPlayer; i++)
        {
            Player *player = &AllPlayers[i];

            if (player->Id == UNUSED)
                continue;

            if (player->Team == TERRORISTS)
            {
                player->Team = COUNTERTERRORISTS;
            }
            else if (player->Team == COUNTERTERRORISTS)
            {
                player->Team = TERRORISTS;
            }

            UpdatePlayerTexture(i);
            player->Money = allPartyModes[currentPartyMode].startMoney;
        }
        // Reset lose count money bonus
        LoseCountCounterTerrorists = 0;
        LoseCountTerrorists = 0;
        // Swap score
        int TempsScoreTerrorists = TerroristsScore;
        TerroristsScore = CounterScore;
        CounterScore = TempsScoreTerrorists;
    }
}

/**
 * @brief Return the number of players and of dead players in both teams
 *
 * @param TerroristsCount Out number of terrosits
 * @param CounterTerroristsCount Out number of counter terrorists
 * @param TerroristDeadCount Out number of dead terrosits
 * @param CounterDeadCount Out number of dead counter terrorists
 */
void CheckTeamDeathCount(int *TerroristsCount, int *CounterTerroristsCount, int *TerroristDeadCount, int *CounterDeadCount)
{
    // Reset values
    *CounterDeadCount = 0;
    *TerroristDeadCount = 0;
    *TerroristsCount = 0;
    *CounterTerroristsCount = 0;

    for (int iPlayer = 0; iPlayer < MaxPlayer; iPlayer++)
    {
        Player *player = &AllPlayers[iPlayer];
        if (player->Id == UNUSED)
            continue;

        if (player->Team == COUNTERTERRORISTS)
        {
            if (player->IsDead) // If a counter is dead, add one to counter dead count
                *CounterDeadCount = *CounterDeadCount + 1;

            *CounterTerroristsCount = *CounterTerroristsCount + 1;
        }
        else if (player->Team == TERRORISTS) // If a terrorist is dead, add one to terrorist dead count
        {
            if (player->IsDead)
                *TerroristDeadCount = *TerroristDeadCount + 1;

            *TerroristsCount = *TerroristsCount + 1;
        }
    }
}

/**
 * @brief Check player health after damage
 *
 * @param shooterPlayerIndex Shooter player index
 * @param hittedPlayerIndex Hitted player index
 * @param CheckScore Need to check score
 */
void checkAfterDamage(int shooterPlayerIndex, int hittedPlayerIndex, bool CheckScore)
{
    Player *HittedClient = &AllPlayers[hittedPlayerIndex];
    Player *killerClient = NULL;
    if (shooterPlayerIndex != NO_PLAYER)
        killerClient = &AllPlayers[shooterPlayerIndex];

    if (HittedClient->Health <= 0 && !HittedClient->IsDead)
    {
        //  Set client has dead
        killPlayer(HittedClient);

        if (killerClient == localPlayer)
        {
            if (applyRules)
            {
                totalBotsKillCount++;
            }
            else
            {
                totalOnlinePlayersKillCount++;
            }
        }

        // Reset raycast values on death
        if (hittedPlayerIndex == 0)
        {
            DisableAim();
        }

        if (HittedClient->haveBomb)
        {
            dropBomb(HittedClient, hittedPlayerIndex);
        }

        HittedClient->target = NO_PLAYER;
        HittedClient->bombTimer = 0;
        HittedClient->isPlantingBomb = false;

        // If the killed player was a defuser, free the defuser place for other bots
        if (&AllPlayers[currentDefuserIndex] == HittedClient)
            currentDefuserIndex = NO_PLAYER;

        // Increase player death count
        HittedClient->DeathCount++;

        // If the killer kills the right target, set current target as "null"
        if (killerClient != NULL && killerClient->target == HittedClient->Id)
        {
            killerClient->target = NO_PLAYER;
            killerClient->lastSeenTarget = NO_PLAYER;
        }
        // Stop dead player movements
        if (HittedClient->isAi)
        {
            HittedClient->justCheking = false;
            HittedClient->lastSeenTarget = NO_PLAYER;
            HittedClient->PathCount = 0;
        }

        // If the killer is not null
        if (shooterPlayerIndex != NO_PLAYER)
        {
            // Show a text to show with is the killer
            showKillText(shooterPlayerIndex, hittedPlayerIndex);
            // Add penalties if the killer is in the same team as the dead player
            if (allPartyModes[currentPartyMode].teamDamage && HittedClient->Team == killerClient->Team)
            {
                killerClient->KillCount--;
                reducePlayerMoney(shooterPlayerIndex, allPartyModes[currentPartyMode].killPenalties);
            }
            else
            {
                // Increase killer kill count
                killerClient->KillCount++;
                // if (AllShopElements[killerClient.AllGunsInInventory[killerClient.currentGunInInventory]] is Gun)
                // AddMoneyTo(killerClient, ((Gun)AllShopElements[killerClient.AllGunsInInventory[killerClient.currentGunInInventory]]).KillMoneyBonus[killerClient.ClientParty.PartyType]);
            }
        }

        // Update bottom screen if scoreboard is showed
        if (currentMenu == SCORE_BOARD)
            UpdateBottomScreenFrameCount += 8;

        if (currentPartyMode == 2)
        {
            setNeedRespawn(HittedClient);
        }

        if (!CheckScore)
            return;

        if (roundState == PLAYING)
        {
            // Check if all a team is dead
            int CounterDeadCount = 0, TerroristDeadCount = 0, CounterTerroristsCount = 0, TerroristsCount = 0;

            CheckTeamDeathCount(&TerroristsCount, &CounterTerroristsCount, &TerroristDeadCount, &CounterDeadCount);
            // If all counter terrorists are dead
            if (CounterDeadCount == CounterTerroristsCount)
            {
                // Add a point to terrorists teams
                TerroristsScore++;

                // Set kill bonus count for each teams
                if (LoseCountTerrorists > 0)
                    LoseCountTerrorists--;

                if (LoseCountCounterTerrorists < 4)
                    LoseCountCounterTerrorists++;

                // Add money to teams
                addMoneyToTeam(allPartyModes[currentPartyMode].winTheRoundMoney, TERRORISTS);
                addMoneyToTeam(allPartyModes[currentPartyMode].loseTheRoundMoney + allPartyModes[currentPartyMode].loseIncrease * LoseCountCounterTerrorists, COUNTERTERRORISTS);

                // Set round to finished round state
                setEndRound();
                showPartyEventText(0);
                CheckAfterRound();
            }
            else if (TerroristDeadCount == TerroristsCount && !bombSet)
            {
                // Add a point to counter terrorists teams
                CounterScore++;

                // Set kill bonus count for each teams
                if (LoseCountCounterTerrorists > 0)
                    LoseCountCounterTerrorists--;

                if (LoseCountTerrorists < 4)
                    LoseCountTerrorists++;

                // Add money to teams
                addMoneyToTeam(allPartyModes[currentPartyMode].winTheRoundMoney, COUNTERTERRORISTS);
                addMoneyToTeam(allPartyModes[currentPartyMode].loseTheRoundMoney + allPartyModes[currentPartyMode].loseIncrease * LoseCountTerrorists, TERRORISTS);

                // Set round to finished round state
                setEndRound();
                showPartyEventText(1);
                CheckAfterRound();
            }
        }
        else if (roundState == TRAINING) // If the party is in training mode
        {
            setNeedRespawn(HittedClient);
        }
    }
}

/**
 * @brief Quit party
 *
 * @param option Unused
 */
void QuitParty(int option)
{
    initMainMenu();
    OnPartyQuit();
}

/**
 * @brief Event on quit party
 *
 */
void OnPartyQuit()
{
    setCameraMapPosition();
    DisableAim();
    uiTimer = 8;
    actionOfUiTimer = SAVE;
}

/**
 * @brief Start a single player party
 *
 */
void StartSinglePlayer(int partyMode)
{
    Connection = OFFLINE;
    currentPartyMode = partyMode;
}

/**
 * @brief Prepare party to start a new one
 *
 * @param multiplayerMode true for an online party
 * mode 0 single player, 1 online, 2 nifi
 */
void prepareParty(/*bool multiplayerMode*/ int mode)
{
    if (mode == 0)
    {
        applyRules = true;
        PartyStarted = false;
    }
    else
    {
        applyRules = false;
        PartyStarted = true;
        SetNeedChangeScreen(true);
    }

    bombDropped = false;
    bombSet = false;
    BombDefused = false;
    BombPlanted = false;
    bombPlantedAt = -1;

    partyFinished = false;
    initScoreMenu();
    textToShowTimer = 0;
    if (mode == 0 || mode == 2)
    {
        ResetTakenBotsNames();
        roundState = TRAINING;
        localPlayer->CurrentOcclusionZone = 15;
        TerroristsScore = 0;
        CounterScore = 0;
        PartySeconds = allPartyModes[currentPartyMode].trainingSecondsDuration;
        PartyMinutes = allPartyModes[currentPartyMode].trainingMinutesDuration;
        changeSecondTimer = 1;
        changeMinuteTimer = 60;
        bombBipTimer = 0;
        BombWillExplode = false;
        currentDefuserIndex = NO_PLAYER;
    }
    SetCurrentCameraPlayer(0);
    DisableAim();
    resetFrameCount();
    stopMusic();
}
```

`Counter-Strike-nds/source/party/party.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef PARTY_H_ /* Include guard */
#define PARTY_H_

#include "main.h"

enum RoundState
{
    TRAINING = -1,
    WAIT_START = 0,
    PLAYING = 1,
    END_ROUND = 2,
    END = 3,
};

enum PartyModeName
{
    NO_DEFAULT_PARTY_MODE = -1,
    COMPETITIVE = 0,
    OCCASIONAL = 1,
    TUTORIAL_TRAINING = 2
};

typedef struct //
{
    bool middlePartyTeamSwap;
    int maxRound;
    int startMoney;
    int maxMoney;

    int winTheRoundMoney;
    int winTheRoundBombMoney;
    int loseTheRoundMoney;
    int loseIncrease;
    int defuseBombMoneyBonus;
    int plantBombMoneyBonus;

    int plantedBombLoseMoneyBonus;
    int killPenalties;

    bool teamDamage;
    bool canSeeOtherTeamView;
    bool noMoneyOnTimeEnd;

    int trainingMinutesDuration;
    int trainingSecondsDuration;

    int startRoundMinutesDuration;
    int startRoundSecondsDuration;

    int roundMinutesDuration;
    int roundSecondsDuration;

    int endRoundMinutesDuration;
    int endRoundSecondsDuration;

    int bombWaitingMinutesDuration;
    int bombWaitingSecondsDuration;

    int trainingRespawnMinutesDuration;
    int trainingRespawnSecondsDuration;

    bool spawnWithArmor;
    bool infiniteMoney;
    bool infiniteTimer;
    bool noScore;
    bool limitedShopByZoneAndTimer;
    bool infiniteGunAmmo;
} PartyMode;

extern PartyMode allPartyModes[3];
extern int currentDefuserIndex;
extern int bombPlantedAt;
extern int PartyMinutes;
extern int PartySeconds;
extern enum RoundState roundState;
extern int CounterScore;
extern int TerroristsScore;
extern int BombSeconds;
extern Vector4 droppedBombPositionAndRotation;
extern bool bombDropped;
extern int currentPartyMode;
extern int currentMap;
extern bool partyFinished;

void AddAllPartyModes();
void AddPartyMode(int index, bool MiddlePartyTeamSwap, int MaxRound, int StartMoney, int MaxMoney, int WinTheRoundMoney, int WinTheRoundBombMoney, int LoseTheRoundMoney, int LoseIncrease, int DefuseBombMoneyBonus, int PlantBombMoneyBonus, int PlantedBombLoseMoneyBonus, int KillPenalties, bool NoMoneyOnTimeEnd, bool TeamDamage, bool CanSeeOtherTeamView);
void partyTimerTick();
void partyTimerTickOnline();
void CheckTeamDeathCount(int *TerroristsCount, int *CounterTerroristsCount, int *TerroristDeadCount, int *CounterDeadCount);
void CheckAfterRound();
void finishParty();
void onNewRoundStart();
void setEndRound();
void checkAfterDamage(int shooterPlayerIndex, int hittedPlayerIndex, bool CheckScore);
void QuitParty(int option);
void OnPartyQuit();
void StartSinglePlayer(int partyMode);
void prepareParty(/*bool multiplayerMode*/ int mode);

#endif // PARTY_H_
```

`Counter-Strike-nds/source/party/tutorial.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "tutorial.h"
#include "input.h"
#include "party.h"
#include "player.h"
#include "map.h"
#include "movements.h"

// Current tutorial step
enum TutorialTextEnum tutorialStep = -1;
// Is the player in the tutorial ?
bool isInTutorial = false;
// Is the player done the tutorial ?
bool tutorialDone = false;
// Timer to wait before the next tutorial step
int tutorialTimer = 0;
// Value to increment to pass to the next tutorial step
float tutorialAddedValue = 0;
// Tutorial text
char tutorialText[100] = "";

/**
 * @brief Get the tutorial text and put the text in the tutorialText variable
 *
 */
void getTutorialText()
{
    switch (tutorialStep)
    {
    case TextWelcome:
        sprintf(tutorialText, "Welcome to Counter Strike");
        return;

    case TextLookAround:
        sprintf(tutorialText, "Look around with the stylus");
        return;

    case TextMovePlayer:
        sprintf(tutorialText, "Move your player with %s %s %s %s", inputsNames[inputs[UP_BUTTON].nameIndex], inputsNames[inputs[DOWN_BUTTON].nameIndex], inputsNames[inputs[LEFT_BUTTON].nameIndex], inputsNames[inputs[RIGHT_BUTTON].nameIndex]);
        return;

    case TextJump:
        sprintf(tutorialText, "Jump with %s", inputsNames[inputs[JUMP_BUTTON].nameIndex]);
        return;

    case TextShoot:
        sprintf(tutorialText, "Shoot with %s", inputsNames[inputs[FIRE_BUTTON].nameIndex]);
        return;

    case TextReload:
        sprintf(tutorialText, "Reload with the reload button on the gamepad");
        return;

    case TextChangeGun:
        sprintf(tutorialText, "Change weapons with the left/right arrows on the gamepad");
        return;

    case TextPlantBomb:
        sprintf(tutorialText, "Plant the bomb with %s on the red cross", inputsNames[inputs[FIRE_BUTTON].nameIndex]);
        return;

    case TextDefuseBomb:
        sprintf(tutorialText, "Defuse the bomb with %s", inputsNames[inputs[DEFUSE_BUTTON].nameIndex]);
        return;

    case TextEnd:
        sprintf(tutorialText, "Tutorial finished!");
        return;

    case TextEmpty:
        return;
    }
    strcpy(tutorialText, "");
}

/**
 * @brief Check if a step is done and if so, go to the next step or end the tutorial
 *
 */
void checkTutorial()
{
    if (tutorialTimer > 0)
        tutorialTimer--;

    switch (tutorialStep)
    {
    case TextEmpty:
        nextStep();
        roundState = PLAYING;
        canChangeGun = false;
        canShoot = false;
        localPlayer->AllAmmoMagazine[0].AmmoCount = 1;
        tutorialTimer = 280;
        break;

    case TextWelcome:
        if (tutorialTimer == 0)
        {
            nextStep();
        }
        break;

    case TextLookAround:
        tutorialAddedValue += xAngleAdded + yAngleAdded;
        if (tutorialAddedValue >= 800)
        {
            nextStep();
        }
        break;

    case TextMovePlayer:
        tutorialAddedValue += xSpeedAdded + zSpeedAdded;
        if (tutorialAddedValue >= 110000)
        {
            nextStep();
        }
        break;

    case TextJump:
        if ((isKeyDown(JUMP_BUTTON) || NeedJump))
        {
            nextStep();
            canShoot = true;
        }
        break;

    case TextShoot:
        if ((isKeyDown(FIRE_BUTTON)))
        {
            nextStep();
        }
        break;

    case TextReload:
        if (localPlayer->AllAmmoMagazine[0].AmmoCount != 0)
        {
            nextStep();
            setSelectedGunInInventory(0, 0);
            canChangeGun = true;
        }
        else
        {
            canShoot = false;
        }
        break;

    case TextChangeGun:
        if (localPlayer->currentGunInInventory == 1)
        {
            nextStep();
            SetGunInInventory(28, 8);
            setSelectedGunInInventory(0, 8);
            canChangeGun = false;
        }
        break;

    case TextPlantBomb:
        if (BombPlanted)
        {
            nextStep();
            localPlayer->Team = COUNTERTERRORISTS;
        }
        break;

    case TextDefuseBomb:
        if (BombDefused)
        {
            nextStep();
            tutorialTimer = 280;
        }
        break;

    case TextEnd:
        if (tutorialTimer == 0)
        {
            nextStep();
            initMainMenu();
        }
        break;
    }
}

/**
 * @brief Go to next step of the tutorial
 *
 */
void nextStep()
{
    tutorialStep++;
    updateTutorialDialogText();
    tutorialAddedValue = 0;
}

/**
 * @brief Show/update the tutorial dialog text
 *
 */
void updateTutorialDialogText()
{
    getTutorialText();
    setDialogText(tutorialText);
}

/**
 * @brief Finish the tutorial
 *
 */
void endTutorial()
{
    tutorialStep = -1;
    setDialogText("");
    canChangeGun = true;
    canShoot = true;
    tutorialDone = true;
    isInTutorial = false;
    currentSelectionMap = DUST2;
}
```

`Counter-Strike-nds/source/party/tutorial.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef TUTORIAL_H_ /* Include guard */
#define TUTORIAL_H_

#include "main.h"

enum TutorialTextEnum
{
    TextEmpty = -1,
    TextWelcome = 0,
    TextLookAround = 1,
    TextMovePlayer = 2,
    TextJump = 3,
    TextShoot = 4,
    TextReload = 5,
    TextChangeGun = 6,
    TextPlantBomb = 7,
    TextDefuseBomb = 8,
    TextEnd = 9
};

extern enum TutorialTextEnum tutorialStep;
extern bool isInTutorial;
extern bool tutorialDone;

void getTutorialText();
void checkTutorial();
void nextStep();
void endTutorial();
void updateTutorialDialogText();

#endif // TUTORIAL_H_
```

`Counter-Strike-nds/source/player/movements.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "movements.h"
//#include "main.h"
#include "ai.h"
#include "ui.h"
#include "party.h"
#include "input.h"
#include "sounds.h"
#include "network.h"
#include <math.h>

int xSpeedAdded = 0;
int zSpeedAdded = 0;
int fovCheckAngle = 80;

/**
 * @brief Move player according to his speed and direction
 *
 * @param CurrentSpeed Speed
 * @param xWithoutY X direction
 * @param zWithoutY Z direction
 * @param NeedBobbing Need to bobbing
 */
void MovePlayer(int CurrentSpeed, float xWithoutY, float zWithoutY, bool *NeedBobbing)
{
    // Move forward/backward
    if (isKey(UP_BUTTON))
    {
        localPlayer->PlayerPhysic->xspeed += CurrentSpeed * xWithoutY * 2;
        localPlayer->PlayerPhysic->zspeed += CurrentSpeed * zWithoutY * 2;
        *NeedBobbing = true;
    }
    else if (isKey(DOWN_BUTTON))
    {
        localPlayer->PlayerPhysic->xspeed += -CurrentSpeed * xWithoutY * 2;
        localPlayer->PlayerPhysic->zspeed += -CurrentSpeed * zWithoutY * 2;
        *NeedBobbing = true;
    }

    // Move left/right
    if (isKey(RIGHT_BUTTON))
    {
        localPlayer->PlayerPhysic->xspeed += CurrentSpeed * -zWithoutY * 2;
        localPlayer->PlayerPhysic->zspeed += CurrentSpeed * xWithoutY * 2;
        *NeedBobbing = true;
    }
    else if (isKey(LEFT_BUTTON))
    {
        localPlayer->PlayerPhysic->xspeed += CurrentSpeed * zWithoutY * 2;
        localPlayer->PlayerPhysic->zspeed += CurrentSpeed * -xWithoutY * 2;
        *NeedBobbing = true;
    }

    // Total of speed
    xSpeedAdded = abs(localPlayer->PlayerPhysic->xspeed);
    zSpeedAdded = abs(localPlayer->PlayerPhysic->zspeed);
}

/**
 * @brief Add angle to local player
 *
 * @param xAngleToAdd X angle to add
 * @param yAngleToAdd Y angle to add
 */
void AddAnglesToPlayer(float xAngleToAdd, float yAngleToAdd)
{
    float AngleSpeed = 1;

    // If the player is scoping, the angle speed is lower
    if (GetCurrentScopeLevel() == 1)
        AngleSpeed = 0.5;
    else if (GetCurrentScopeLevel() == 2)
        AngleSpeed = 0.25;

    // Muliply with the sensitivity for the angle speed
    AngleSpeed *= sensitivity;

    // Add angle to the player
    if (xAngleToAdd != 0)
    {
        localPlayer->Angle += AngleSpeed * xAngleToAdd;
        SetNeedUpdateViewRotation(true);
        SetSendPosition(true);
    }

    // Add angle to the camera
    if (yAngleToAdd != 0)
    {
        float NewyAngle = GetCameraAngleY() + AngleSpeed * yAngleToAdd;
        if (NewyAngle > 10 && NewyAngle < 246)
        {
            SetCameraAngleY(NewyAngle);
            SetNeedUpdateViewRotation(true);
            SetSendPosition(true);
        }
    }
}

/**
 * @brief Rotate player with physicals key
 *
 * @param NeedUpdateViewRotation
 * @param SendPosition
 * @param CameraAngleY
 * @param CurrentScopeLevel
 */
void RotatePlayer(bool *NeedUpdateViewRotation, bool *SendPosition, float *CameraAngleY)
{
    float AngleSpeed = 1 * buttonsSensitivity;

    // If the player is scoping, the angle speed is lower
    if (GetCurrentScopeLevel() == 1)
        AngleSpeed *= 0.5;
    else if (GetCurrentScopeLevel() == 2)
        AngleSpeed *= 0.25;

    // Change player rotation
    if (isKey(LOOK_RIGHT_BUTTON))
    {
        localPlayer->Angle -= AngleSpeed;
        *NeedUpdateViewRotation = true;
        *SendPosition = true;
    }
    else if (isKey(LOOK_LEFT_BUTTON))
    {
        localPlayer->Angle += AngleSpeed;
        *NeedUpdateViewRotation = true;
        *SendPosition = true;
    }

    // Change camera rotation
    if (isKey(LOOK_UP_BUTTON) && *CameraAngleY > 9)
    {
        *CameraAngleY -= AngleSpeed;
        *NeedUpdateViewRotation = true;
    }
    else if (isKey(LOOK_DOWN_BUTTON) && *CameraAngleY < 245)
    {
        *CameraAngleY += AngleSpeed;
        *NeedUpdateViewRotation = true;
    }
}

int updateRate = 0;

/**
 * @brief Force to update the view rotation
 *
 * @param CameraAngleY Camera angle
 */
void ForceUpdateLookRotation(float CameraAngleY)
{
    updateRate = 0;
    UpdateLookRotation(CameraAngleY);
}

void stepSound(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];

    if (playerIndex == 0) // do a 2d sound
    {
        DoStepSound(110, 128, 0);
    }
    else // Do a 3d sound
    {
        int Panning, Volume;
        GetPanning(player->Id, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.11);
        DoStepSound(Volume, Panning, playerIndex);
    }
}

/**
 * @brief Apply animation when the player is moving
 *
 * @param playerIndex Player index
 */
void ApplyGunWalkAnimation(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];

    player->BobbingOffset += BobbingSpeed;

    // Do sound every half bobbing cycle
    if (!player->HasBobbed && player->BobbingOffset >= M_PI)
    {
        stepSound(playerIndex);

        player->HasBobbed = true;
    }
    else if (player->BobbingOffset >= M_TWOPI)
    {
        player->BobbingOffset = 0;
        stepSound(playerIndex);

        player->HasBobbed = false;
    }
}

/**
 * @brief Update look values for local player
 *
 * @param CameraAngleY Camera angle
 */
void UpdateLookRotation(float CameraAngleY)
{
    // Math formula to get a point position on sphere from the middle of the sphere with 2 angle
    float TempS = AllPlayers[GetCurrentCameraPlayer()].Angle / 512.0 * M_TWOPI;
    float TempT = (384 - CameraAngleY) / 512.0 * M_TWOPI;

    double cosTempT = cos(TempT);
    double cosTempS = cos(TempS);
    double SinTempS = sin(TempS);

    x = SinTempS * cosTempT;
    y = -sin(TempT);
    z = cosTempS * cosTempT;

    xWithoutY = -SinTempS;
    zWithoutY = -cosTempS;

    // Values for map
    if (isShowingMap)
    {
        float TempSForMap = (AllPlayers[GetCurrentCameraPlayer()].Angle) / 512.0 * M_TWOPI;
        xWithoutYForMap = -sin(TempSForMap);
        zWithoutYForMap = -cos(TempSForMap);
    }

    // Values for audio and occlusions
    if (updateRate == 0)
    {
        float TempSside1 = (AllPlayers[GetCurrentCameraPlayer()].Angle - 80) / 512.0 * M_TWOPI;
        float TempSside2 = (AllPlayers[GetCurrentCameraPlayer()].Angle + 80) / 512.0 * M_TWOPI;

        float TempSForAudio = (AllPlayers[GetCurrentCameraPlayer()].Angle - 128) / 512.0 * M_TWOPI;

        xWithoutYForAudio = -sin(TempSForAudio);
        zWithoutYForAudio = -cos(TempSForAudio);

        xWithoutYForOcclusionSide1 = -sin(TempSside1);
        zWithoutYForOcclusionSide1 = -cos(TempSside1);
        xWithoutYForOcclusionSide2 = -sin(TempSside2);
        zWithoutYForOcclusionSide2 = -cos(TempSside2);

        updateRate = 2;
    }
    updateRate--;
}

/**
 * @brief  Update look values for non local player
 *
 * @param CameraAngleY Camera angle
 * @param angle Angle of the player
 * @param x out x value
 * @param y out y value
 * @param z out z value
 */
void UpdateLookRotationAI(float CameraAngleY, float angle, float *x, float *y, float *z)
{
    // Math formula to get a point position on sphere from the middle of the sphere with 2 angle
    float TempS = angle / 512.0 * M_TWOPI;
    float TempT = (384 - CameraAngleY) / 512.0 * M_TWOPI;

    double cosTempT = cos(TempT);
    double cosTempS = cos(TempS);
    double SinTempS = sin(TempS);

    *x = SinTempS * cosTempT;
    *y = -sin(TempT);
    *z = cosTempS * cosTempT;
}

/**
 * @brief Update look values FOR culling for non local player
 *
 * @param playerIndex Player index
 * @param angle Angle of the player
 * @param xSide1 out x value for side 1
 * @param zSide1 out z value for side 1
 * @param xSide2 out x value for side 2
 * @param zSide2 out z value for side 2
 */
void GetRotationForCullingAI(int playerIndex, float angle, float *xSide1, float *zSide1, float *xSide2, float *zSide2)
{
    float TempSside1 = (AllPlayers[playerIndex].Angle - 100) / 512.0 * M_TWOPI;
    float TempSside2 = (AllPlayers[playerIndex].Angle + 100) / 512.0 * M_TWOPI;

    *xSide1 = -sin(TempSside1);
    *zSide1 = -cos(TempSside1);

    *xSide2 = -sin(TempSside2);
    *zSide2 = -cos(TempSside2);
}

float Speed = 0.05;
/**
 * @brief Normalize vector3
 *
 * @param p Vector3
 */
void normalize(Vector3 *p)
{
    float w = sqrtf(p->x * p->x + p->y * p->y + p->z * p->z);
    p->x /= w;
    p->y /= w;
    p->z /= w;
}

/**
 * @brief Normalize vector2 2D
 *
 * @param p Vector2
 */
void normalize2D(Vector2 *p)
{
    float w = sqrtf(p->x * p->x + p->y * p->y);
    p->x /= w;
    p->y /= w;
}

/**
 * @brief Normalize vector2 1D
 *
 * @param p Vector2
 */
void normalize1D(Vector2 *p)
{
    float w = sqrtf(p->x * p->x);
    p->x /= w;
}

/**
 * @brief Set non local player position
 *
 */
void SetOnlinelPlayersPositions()
{
    // Loop using "AllPlayers" array for updating non local player position smoothly
    for (int i = 1; i < MaxPlayer; i++)
    {
        Player *player = &AllPlayers[i];

        if (player->Id == UNUSED || player->IsDead)
            continue;

        // If a player is spawned
        if (!player->isAi)
        {
            float Speed = 0.1;
            float Dis = fabs(player->position.x - player->lerpDestination.x) + fabs(player->position.y - player->lerpDestination.y) + fabs(player->position.z - player->lerpDestination.z);

            if (Dis < 4.0)
            {
                // Smoothing player position
                if (player->position.x != player->lerpDestination.x)                                                    // If player x position is not the same as x destination
                    player->position.x = player->position.x + Speed * (player->lerpDestination.x - player->position.x); // Move player with lerp system

                if (player->position.y != player->lerpDestination.y)                                                    // If player y position is not the same as y destination
                    player->position.y = player->position.y + Speed * (player->lerpDestination.y - player->position.y); // Move player with lerp system

                if (player->position.z != player->lerpDestination.z)                                                    // If player y position is not the same as z destination
                    player->position.z = player->position.z + Speed * (player->lerpDestination.z - player->position.z); // Move player with lerp system

                if (abs(player->AngleDestination - player->Angle) > 90)
                {
                    player->Angle = player->AngleDestination;
                }
                else
                {
                    // Smoothing player angle
                    float AngleAddAmout = Speed * (player->AngleDestination - player->Angle);
                    player->Angle = player->Angle + AngleAddAmout;
                }

                if (Dis > 0.05)
                    ApplyGunWalkAnimation(i);
            }
            else
            {
                player->position.x = player->lerpDestination.x;
                player->position.y = player->lerpDestination.y;
                player->position.z = player->lerpDestination.z;

                player->Angle = player->AngleDestination;
            }

            // Set new player position and angle
            NE_ModelSetCoord(player->PlayerModel, player->position.x, player->position.y, player->position.z);
            NE_ModelSetCoord(player->PlayerShadow, player->position.x, player->position.y - 0.845, player->position.z);
            player->PlayerModel->ry = player->Angle;
        }
        else if (player->PathCount != 0 && (player->target == NO_PLAYER || player->tooFar) && roundState != WAIT_START)
        {
            float Speed = 0.087;
            int CurPath = player->CurrentPath;
            int Ok = 0;

            Vector3 Direction;
            Direction.x = GetWaypoints()[player->Path[CurPath]].x - player->position.x;
            Direction.y = GetWaypoints()[player->Path[CurPath]].y - 0.1 - player->position.y;
            Direction.z = GetWaypoints()[player->Path[CurPath]].z - player->position.z;
            Vector2 Direction2D;
            Direction2D.x = GetWaypoints()[player->Path[CurPath]].x - GetWaypoints()[player->Path[CurPath - 1]].x;
            Direction2D.y = GetWaypoints()[player->Path[CurPath]].z - GetWaypoints()[player->Path[CurPath - 1]].z;
            normalize(&Direction);
            normalize2D(&Direction2D);

            // Smoothing player position
            if (player->position.x - 0.1 > GetWaypoints()[player->Path[CurPath]].x || player->position.x + 0.1 < GetWaypoints()[player->Path[CurPath]].x)
                player->position.x += Direction.x * Speed;
            else
                Ok++;

            // TODO remplace -0.1 by a player offset vector 3
            if (player->position.y - 0.1 > GetWaypoints()[player->Path[CurPath]].y - 0.1 || player->position.y + 0.1 < GetWaypoints()[player->Path[CurPath]].y - 0.1)
                player->position.y += Direction.y * Speed;

            if (player->position.z - 0.1 > GetWaypoints()[player->Path[CurPath]].z || player->position.z + 0.1 < GetWaypoints()[player->Path[CurPath]].z)
                player->position.z += Direction.z * Speed;
            else
                Ok++;

            if (Ok == 2) // if the player reach the waypoint
            {
                if (CurPath < player->PathCount - 1)
                {
                    // Go to next waypoint
                    player->CurrentPath++;
                }
                else
                {
                    // if the player is at the end of the path
                    if (applyRules)
                    {
                        player->LastWayPoint = player->Path[CurPath];
                        // Plant/defuse the bomb if needed
                        if (player->haveBomb || (player->Team == COUNTERTERRORISTS && BombPlanted && !BombDefused && bombPlantedAt == player->LastWayPoint))
                        {
                            if (player->LastWayPoint == 14 || player->LastWayPoint == 29) // TOTO Replace 14 and 29 by bomb point define
                            {
                                player->isPlantingBomb = true;
                                if (!BombDefused && BombPlanted) // Set timer
                                    player->bombTimer = bombDefuseTime;
                                else if (!BombPlanted) // Set timer
                                    player->bombTimer = bombPlantingTime;
                            }
                        }
                    }
                    player->PathCount = 0;
                }
            }
            else
            {
                // Move player
                ApplyGunWalkAnimation(i);
                NE_ModelSetCoord(player->PlayerModel, player->position.x, player->position.y, player->position.z);
                NE_ModelSetCoord(player->PlayerShadow, player->position.x, player->position.y - 0.845, player->position.z);

                float FinalAngle = atan2f(Direction2D.x, Direction2D.y) * 512.0 / (M_TWOPI) + 256.0;
                player->Angle = FinalAngle;
                player->PlayerModel->ry = player->Angle;
            }
        }
        else //?
        {
            Vector3 positionToGo;

            if (player->tooFar)
            {
                Player *targetPlayer = &AllPlayers[player->target];
                positionToGo.x = targetPlayer->position.x;
                positionToGo.y = targetPlayer->position.y;
                positionToGo.z = targetPlayer->position.z;
            }
            else if (player->searchForDroppedBomb)
            {
                positionToGo.x = droppedBombPositionAndRotation.x;
                positionToGo.y = droppedBombPositionAndRotation.y + 0.845;
                positionToGo.z = droppedBombPositionAndRotation.z;
            }
            else
            {
                player->Angle = player->AngleDestination;
                player->PlayerModel->ry = player->AngleDestination;
                continue;
            }

            float Speed = 0.087;
            int Ok = 0;

            Vector3 Direction;
            Direction.x = positionToGo.x - player->position.x;
            Direction.y = positionToGo.y - player->position.y;
            Direction.z = positionToGo.z - player->position.z;

            normalize(&Direction);

            // Smoothing player position
            if (player->position.x - 0.7 > positionToGo.x || player->position.x + 0.7 < positionToGo.x)
                player->position.x += Direction.x * Speed;
            else
                Ok++;

            if (player->position.y - 0.1 > positionToGo.y || player->position.y + 0.1 < positionToGo.y)
                player->position.y += Direction.y * Speed;

            if (player->position.z - 0.7 > positionToGo.z || player->position.z + 0.7 < positionToGo.z)
                player->position.z += Direction.z * Speed;
            else
                Ok++;

            NE_ModelSetCoord(player->PlayerModel, player->position.x, player->position.y, player->position.z);
            NE_ModelSetCoord(player->PlayerShadow, player->position.x, player->position.y - 0.845, player->position.z);

            player->Angle = player->AngleDestination;
            player->PlayerModel->ry = player->AngleDestination;
        }
    }
}
```

`Counter-Strike-nds/source/player/movements.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef MOVEMENTS_H_ /* Include guard */
#define MOVEMENTS_H_

//#include <NEMain.h>
#include "main.h"

extern int updateRate;
extern int xSpeedAdded;
extern int zSpeedAdded;

void MovePlayer(int CurrentSpeed, float xWithoutY, float zWithoutY, bool *NeedBobbing); /**/
void RotatePlayer(bool *NeedUpdateViewRotation, bool *SendPosition, float *CameraAngleY);
void AddAnglesToPlayer(float xAngleToAdd, float yAngleToAdd);
void UpdateLookRotation(float CameraAngleY);
void UpdateLookRotationAI(float CameraAngleY, float angle, float *x, float *y, float *z);
void GetRotationForCullingAI(int playerIndex, float angle, float *xSide1, float *zSide1, float *xSide2, float *zSide2);
void SetOnlinelPlayersPositions();
void normalize(Vector3 *p);
void normalize2D(Vector2 *p);
void normalize1D(Vector2 *p);
void ForceUpdateLookRotation(float CameraAngleY);
void ApplyGunWalkAnimation(int playerIndex);

#endif // MOVEMENTS_H_
```

`Counter-Strike-nds/source/player/player.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "player.h"
#include "party.h"
#include "ai.h"
#include "gun.h"
#include "map.h"
#include "equipment.h"
#include "collisions.h"
#include "sounds.h"
#include "stats.h"
#include "network.h"

/**
 * @brief Kill a player
 *
 * @param player Player pointer
 */
void killPlayer(Player *player)
{
    player->Health = 0;
    // Set client has dead
    player->IsDead = true;
    if (player == localPlayer && (currentMenu == SHOP || currentMenu == SHOPCATEGORIES))
    {
        initGameMenu();
    }
    if (player == localPlayer)
    {
        totalDeathCount++;
    }
}

/**
 * @brief Hit a player (Apply damage)
 *
 * @param hitBy Shooter player index
 * @param playerHit Hitted player index
 * @param distance Hit distance
 */
void makeHit(int hitBy, int playerHit, float distance, int shootIndex)
{
    Player *hittedPlayer = &AllPlayers[playerHit];
    Player *shooterPlayer = &AllPlayers[hitBy];

    int hitType = 0;
    int Damage = (int)(AllGuns[shooterPlayer->startGunIdRaycast].Damage * pow(AllGuns[shooterPlayer->startGunIdRaycast].DamageFalloff, distance / 500.0));
    // Apply more or less damage with the location of the bullet
    if (shooterPlayer->IsHeadShot[shootIndex])
    {
        hitType = 1;
        Damage *= 4;
    }
    else if (shooterPlayer->IsLegShot[shootIndex])
    {
        hitType = 2;
        Damage /= 2.0;
    }

    // Reduce damage when clients are in the same team
    if (hittedPlayer->Team == shooterPlayer->Team)
    {
        Damage = (int)(Damage / 3.0);
    }

    if (shooterPlayer->startGunIdRaycast < GunCount && AllGuns[shooterPlayer->startGunIdRaycast].isKnife)
        hitType = 3;

    bool makeHeadSetSound = false;
    // If an armor was touched
    if ((hitType == 0 && hittedPlayer->armor != 0) || (hitType == 1 && hittedPlayer->haveHeadset))
    {
        // Reduce damage of the bullet
        int oldDamage = Damage;
        Damage = (int)(Damage * AllGuns[shooterPlayer->startGunIdRaycast].penetration / 100.0);
        // Remove headset
        if (hitType == 1)
        {
            hittedPlayer->haveHeadset = false;
            makeHeadSetSound = true;
        }
        else // Or reduce armor durability
        {
            hittedPlayer->armor -= oldDamage - Damage;
            if (hittedPlayer->armor < 0)
                hittedPlayer->armor = 0;
        }
    }

    // Set hitted player life
    setPlayerHealth(playerHit, hittedPlayer->Health - Damage);
    checkAfterDamage(hitBy, playerHit, true);

    if (!hittedPlayer->IsDead && hittedPlayer->target == NO_PLAYER && hittedPlayer != localPlayer)
    {
        hittedPlayer->target = hitBy;
        hittedPlayer->lastSeenTarget = hitBy;
        if (hittedPlayer->GunWaitCount >= 0)
        {
            int randomWait = 40 + rand() % 20;

            hittedPlayer->GunWaitCount = -randomWait;
        }
        // hittedPlayer->GunWaitCount = -60;
    }

    // Get sound volume and panning
    int Panning, Volume;
    GetPanning(hittedPlayer->Id, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.10);

    if (playerHit == 0)
    {
        rumble(1);
    }

    if (hittedPlayer == localPlayer)
    {
        redHealthTextCounter = 62;

        xOffset = (rand() % ScreenShakeAmount + ScreenShakeMinAmount) / 100.0;
        if (rand() % 2 == 0)
            xOffset = -xOffset;

        yOffset = (rand() % ScreenShakeAmount + ScreenShakeMinAmount) / 100.0;
        if (rand() % 2 == 0)
            yOffset = -yOffset;
    }

    // Play sounds
    if (hitType == 0)
        Play3DSound(SFX_FLESH_IMPACT, Volume, Panning, hittedPlayer); // TODO Check kevlar sound
    else if (hitType == 1)
    {
        if (!makeHeadSetSound)
            Play3DSound(SFX_HEADSHOT1, Volume, Panning, hittedPlayer);
        else
            Play3DSound(SFX_HIT_HELMET, Volume, Panning, hittedPlayer);
    }
    else if (hitType == 2)
        Play3DSound(SFX_FLESH_IMPACT, Volume, Panning, hittedPlayer);
    else
        Play3DSound(SFX_KNIFE_HIT_PLAYER, Volume, Panning, hittedPlayer);
}

/**
 * @brief Buy select gun from shop for local player
 *
 */
void buyGun()
{
    int grenadeIndex = GetSelectedGunShop() - GunCount;
    int equipmentIndex = GetSelectedGunShop() - GunCount - shopGrenadeCount;
    if (ShopCategory < EQUIPMENT && AllGuns[GetSelectedGunShop()].Price <= localPlayer->Money)
    {
        // Check if the player already have this gun
        if (localPlayer->AllGunsInInventory[1] == GetSelectedGunShop() || localPlayer->AllGunsInInventory[2] == GetSelectedGunShop())
        {
        }
        else
        {
            if (!allPartyModes[currentPartyMode].infiniteMoney)
            {
                reducePlayerMoney(0, AllGuns[GetSelectedGunShop()].Price);
            }

            // Set inventory slot
            if (ShopCategory == PISTOLS)
            {
                SetGunInInventory(GetSelectedGunShop(), 1);
                setSelectedGunInInventory(0, 1);
            }
            else
            {
                SetGunInInventory(GetSelectedGunShop(), 2);
                setSelectedGunInInventory(0, 2);
            }
        }
    }
    else if (ShopCategory == GRENADES && AllGrenades[grenadeIndex].Price <= localPlayer->Money)
    {
        // Search for the first empty slot for grenade
        for (int grenadeCheckIndex = InventoryGrenadeStartPosition; grenadeCheckIndex < InventoryEquipementStartPosition; grenadeCheckIndex++)
        {
            if (localPlayer->AllGunsInInventory[grenadeCheckIndex] == -1 && localPlayer->grenadeBought[grenadeIndex] < AllGrenades[grenadeIndex].maxQuantity[currentPartyMode])
            {
                localPlayer->AllGunsInInventory[grenadeCheckIndex] = GetSelectedGunShop();
                if (currentPartyMode != 2)
                    localPlayer->grenadeBought[grenadeIndex]++;

                if (!allPartyModes[currentPartyMode].infiniteMoney)
                {
                    reducePlayerMoney(0, AllGrenades[grenadeIndex].Price);
                }
                setSelectedGunInInventory(0, grenadeCheckIndex);
                break;
            }
        }
    }
    else if (ShopCategory == EQUIPMENT && allEquipments[equipmentIndex].Price <= localPlayer->Money)
    {
        bool canBuy = true;

        switch (allEquipments[equipmentIndex].type)
        {
        case DEFUSER:
            if (localPlayer->haveDefuseKit)
            {
                canBuy = false;
            }
            else
            {
                localPlayer->haveDefuseKit = true;
            }
            break;

        case KEVLAR_VEST:
            if (localPlayer->armor == 100)
            {
                canBuy = false;
            }
            else
            {
                localPlayer->armor = 100;
            }
            break;

        case KEVLAR_VEST_AND_HELMET:
            if (localPlayer->haveHeadset)
            {
                canBuy = false;
            }
            else
            {
                localPlayer->armor = 100;
                localPlayer->haveHeadset = true;
            }
            break;

        case C4:
            canBuy = false;
            break;
        }

        if (!allPartyModes[currentPartyMode].infiniteMoney && canBuy)
        {
            reducePlayerMoney(0, allEquipments[equipmentIndex].Price);
        }
    }
}

/**
 * @brief Set on new round the most powerful gun in the hand or the bomb
 *
 */
void setNewRoundHandWeapon()
{
    for (int playerIndex = 0; playerIndex < MaxPlayer; playerIndex++)
    {
        Player *player = &AllPlayers[playerIndex];
        if (player->Id == UNUSED)
            continue;

        if (playerIndex == 0 && player->haveBomb)
        {
            player->currentGunInInventory = 8;
        }
        else if (getPlayerCurrentGunIndex(player) == EMPTY)
        {
            player->currentGunInInventory = 1;
            if (getPlayerCurrentGunIndex(player) == EMPTY)
            {
                player->currentGunInInventory = 0;
            }
        }

        if (playerIndex == 0)
            UpdateGunTexture();
    }
}

/**
 * @brief Set a gun to the local player
 *
 * @param Value Gun id
 * @param inventoryIndex Inventory slot index
 */
void SetGunInInventory(int Value, int inventoryIndex)
{
    localPlayer->AllGunsInInventory[inventoryIndex] = Value;
    if (getPlayerCurrentGunIndex(localPlayer) == UNUSED) // If the player has no guns in hands
        ChangeGunInInventoryForLocalPlayer(0);           // Switch to a gun in inventory
    else
    {
        // Refresh the gun texture and reset ammo
        ResetGunAmmo(0, inventoryIndex);
        UpdateGunTexture();
    }
}

/**
 * @brief  Set a gun to a player
 *
 * @param playerIndex Player index
 * @param Value Gun id
 * @param inventoryIndex Inventory slot index
 */
void SetGunInInventoryForNonLocalPlayer(int playerIndex, int Value, int inventoryIndex)
{
    AllPlayers[playerIndex].AllGunsInInventory[inventoryIndex] = Value;
    if (playerIndex == 0 && getPlayerCurrentGunIndex(localPlayer) == UNUSED) // If the player has no guns in hands
        ChangeGunInInventoryForLocalPlayer(0);                               // Switch to a gun in inventory
    else                                                                     // Reset ammo
        ResetGunAmmo(playerIndex, inventoryIndex);
}

/**
 * @brief Change current gun of the local player
 *
 * @param Left Way (1 - left, 0 - right)
 */
void ChangeGunInInventoryForLocalPlayer(int Left)
{
    DisableAim();
    ChangeGunInInventory(0, Left);
}

/**
 * @brief Change current gun of a player
 *
 * @param playerIndex Player index
 * @param Left Way (1 - left, 0 - right)
 */
void ChangeGunInInventory(int playerIndex, int Left)
{
    Player *player = &AllPlayers[playerIndex];

    // Retain the current gun in inventory if there is no other gun in the inventory
    int oldCurrentGun = player->currentGunInInventory;
    // Find a gun in the inventory
    do
    {
        if (Left == 1)
        {
            player->currentGunInInventory--;
            if (player->currentGunInInventory == -1)
                player->currentGunInInventory = inventoryCapacity - 1;
        }
        else
        {
            player->currentGunInInventory++;
            if (player->currentGunInInventory == inventoryCapacity)
                player->currentGunInInventory = 0;
        }
    } while (getPlayerCurrentGunIndex(player) == EMPTY);

    // If no another gun was found, use the old gun index
    if (playerIndex == 0 && !canChangeGun && player->AllGunsInInventory[oldCurrentGun] != -1)
    {
        player->currentGunInInventory = oldCurrentGun;
        return;
    }

    if (oldCurrentGun != player->currentGunInInventory)
    {
        setSelectedGunInInventory(playerIndex, player->currentGunInInventory);
    }
}

/**
 * @brief Set the Selected Gun In Inventory object
 *
 * @param playerIndex
 * @param gunIndex
 */
void setSelectedGunInInventory(int playerIndex, int gunIndex)
{
    Player *player = &AllPlayers[playerIndex];
    if (player->AllGunsInInventory[gunIndex] != EMPTY)
    {
        player->currentGunInInventory = gunIndex;
        // Stop the reloading animation/action
        StopReloading(playerIndex);
        if (playerIndex == 0)
        {
            // Send to the server
            SendSelectedGun = true;
            // Update gun texture at screen
            UpdateGunTexture();
        }
    }
}

/**
 * @brief Set player health
 *
 * @param playerIndex Player index
 * @param health New health
 */
void setPlayerHealth(int playerIndex, int health)
{
    Player *player = &AllPlayers[playerIndex];
    if (player->Id == NO_PLAYER)
        return;

    player->Health = health;

    // if the player is dead
    if (player->Health <= 0)
    {
        if (!applyRules)
        {
            killPlayer(player);
        }

        // If died player is the local player
        if (playerIndex == 0)
        {
            DisableAim();
            // Do death sound
            PlayBasicSound(SFX_DEATH);
            // Hide crosshair
            NE_SpriteVisible(TopScreenSprites[0], false);
        }
        else
        {
            // Do death sound
            int Panning, Volume;
            GetPanning(player->Id, &Panning, &Volume, xWithoutYForAudio, zWithoutYForAudio, 0.10);
            Play3DSound(SFX_DEATH, Volume, Panning, player);
        }
    }
    else if (player->Health == 100)
    {
        // Re enable crosshair
        if (playerIndex == 0)
        {
            NE_SpriteVisible(TopScreenSprites[0], true);
            deathCameraAnimation = 0;
            deathCameraYOffset = 0;
            redHealthTextCounter = 0;
        }

        player->IsDead = FALSE;
    }
}

/**
 * @brief Delete all players
 *
 */
void removeAllPlayers()
{
    PlayerCount = 0;
    for (int i = 0; i < MaxPlayer; i++)
    {
        Player *player = &AllPlayers[i];
        player->Id = UNUSED;
        player->Team = SPECTATOR;

        // Delete model
        if (player->PlayerModel != NULL)
        {
            NE_ModelDelete(player->PlayerModel);
        }
        // Delete physics component
        if (player->PlayerPhysic != NULL)
        {
            NE_PhysicsDelete(player->PlayerPhysic);
        }
    }
}

/**
 * @brief Set players position to their spawn points
 *
 */
void setPlayersPositionAtSpawns()
{
    int currentCounter = 0;
    int currentTerrorist = 0;

    for (int i = 0; i < PlayerCount; i++)
    {
        Player *player = &AllPlayers[i];
        Map *map = &allMaps[currentMap];
        if (player->Team == TERRORISTS)
        {
            // Set player position to a terrorists spawn
            player->PlayerModel->x = map->allTerroristsSpawns[currentTerrorist].x * 4096.0;
            player->PlayerModel->y = map->allTerroristsSpawns[currentTerrorist].y * 4096.0;
            player->PlayerModel->z = map->allTerroristsSpawns[currentTerrorist].z * 4096.0;
            // Add this for non AI players
            player->lerpDestination.x = map->allTerroristsSpawns[currentTerrorist].x;
            player->lerpDestination.y = map->allTerroristsSpawns[currentTerrorist].y;
            player->lerpDestination.z = map->allTerroristsSpawns[currentTerrorist].z;
            currentTerrorist++;

            player->Angle = map->startPlayerAngleTerrorists;
            player->AngleDestination = map->startPlayerAngleTerrorists;
            player->spawnAt = currentTerrorist;
        }
        else if (player->Team == COUNTERTERRORISTS)
        {
            // Set player position to a counter terrorists spawn
            player->PlayerModel->x = map->allCounterTerroristsSpawns[currentCounter].x * 4096.0;
            player->PlayerModel->y = map->allCounterTerroristsSpawns[currentCounter].y * 4096.0;
            player->PlayerModel->z = map->allCounterTerroristsSpawns[currentCounter].z * 4096.0;
            // Add this for non AI players
            player->lerpDestination.x = map->allCounterTerroristsSpawns[currentCounter].x;
            player->lerpDestination.y = map->allCounterTerroristsSpawns[currentCounter].y;
            player->lerpDestination.z = map->allCounterTerroristsSpawns[currentCounter].z;
            currentCounter++;

            player->Angle = map->startPlayerAngleCounterTerrorists;
            player->AngleDestination = map->startPlayerAngleCounterTerrorists;
            player->spawnAt = currentCounter;
        }
        CalculatePlayerPosition(i);
        if (i == 0)
        {
            setShopZone(player);
        }
    }
    NeedUpdateViewRotation = true;
}

/**
 * @brief Set shop zone for a player
 *
 * @param player Player pointer
 */
void setShopZone(Player *player)
{
    SetCollisionBox(player->position.x, player->position.y, player->position.z, 4, 3, 4, &shopZone);
}

/**
 * @brief Get player position and set it to float
 *
 * @param PlayerIndex Player index
 */
void CalculatePlayerPosition(int PlayerIndex)
{
    Player *player = &AllPlayers[PlayerIndex];
    player->position.x = player->PlayerModel->x / 4096.0;
    player->position.y = player->PlayerModel->y / 4096.0;
    player->position.z = player->PlayerModel->z / 4096.0;
}

/**
 * @brief Set a player position to his spawn point
 *
 * @param playerIndex Player index
 */
void setPlayerPositionAtSpawns(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    Map *map = &allMaps[currentMap];
    if (player->Team == TERRORISTS)
    {
        // Set player position to a terrorists spawn
        player->PlayerModel->x = map->allTerroristsSpawns[player->spawnAt].x * 4096.0;
        player->PlayerModel->y = map->allTerroristsSpawns[player->spawnAt].y * 4096.0;
        player->PlayerModel->z = map->allTerroristsSpawns[player->spawnAt].z * 4096.0;
        // Add this for non AI players
        player->lerpDestination.x = map->allTerroristsSpawns[player->spawnAt].x;
        player->lerpDestination.y = map->allTerroristsSpawns[player->spawnAt].y;
        player->lerpDestination.z = map->allTerroristsSpawns[player->spawnAt].z;

        player->Angle = map->startPlayerAngleTerrorists;
        player->AngleDestination = map->startPlayerAngleTerrorists;
    }
    else if (player->Team == COUNTERTERRORISTS)
    {
        // Set player position to a counter terrorists spawn
        player->PlayerModel->x = map->allCounterTerroristsSpawns[player->spawnAt].x * 4096.0;
        player->PlayerModel->y = map->allCounterTerroristsSpawns[player->spawnAt].y * 4096.0;
        player->PlayerModel->z = map->allCounterTerroristsSpawns[player->spawnAt].z * 4096.0;
        // Add this for non AI players
        player->lerpDestination.x = map->allCounterTerroristsSpawns[player->spawnAt].x;
        player->lerpDestination.y = map->allCounterTerroristsSpawns[player->spawnAt].y;
        player->lerpDestination.z = map->allCounterTerroristsSpawns[player->spawnAt].z;

        player->Angle = map->startPlayerAngleCounterTerrorists;
        player->AngleDestination = map->startPlayerAngleCounterTerrorists;
    }
    CalculatePlayerPosition(playerIndex);
    if (playerIndex == 0)
    {
        setShopZone(player);
    }
    NeedUpdateViewRotation = true;
}

/**
 * @brief Change player skin texture
 *
 * @param playerIndex Player index
 */
void UpdatePlayerTexture(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    if (player->Team == COUNTERTERRORISTS)
        NE_ModelSetMaterial(player->PlayerModel, PlayerMaterial); // Set counter terrorists texture
    else if (player->Team == TERRORISTS)
        NE_ModelSetMaterial(player->PlayerModel, PlayerMaterialTerrorist); // Set terrorists texture
}

/**
 * @brief Add new player to party
 *
 * @param NewId Id of the player
 * @param IsLocalPlayer Is a local player?
 * @param isAI Is an AI?
 */
int AddNewPlayer(int NewId, bool IsLocalPlayer, bool isAI)
{
    for (int i = 1; i < MaxPlayer; i++)
    {
        if (IsLocalPlayer)
            i = 0;
        // printf("STEP 1\n");
        Player *player = &AllPlayers[i];

        // Check for an empty player slot
        if (player->Id == UNUSED)
        {
            // strcpy(player->client.sendBuffer, "");
            //  Create player (3d model, physics, animations)

            // Set player collision size
            player->xSize = 0.35;
            player->ySize = 0.9;
            player->zSize = 0.35;
            player->cameraAngle = 128;

            // Set default weapon in his hand
            player->currentGunInInventory = 1;

            // Init inventory
            player->AllGunsInInventory[0] = 0;
            player->AllGunsInInventory[1] = 1;
            for (int i2 = 2; i2 < inventoryCapacity; i2++)
            {
                player->AllGunsInInventory[i2] = EMPTY;
            }
            ResetGunsAmmo(i);

            player->rightGunXRecoil = GunMinRecoil;
            player->rightGunYRecoil = GunMinRecoil;
            player->leftGunXRecoil = GunMinRecoil;
            player->leftGunYRecoil = GunMinRecoil;

            if (IsLocalPlayer)
            {
                player->PlayerModel = NE_ModelCreate(NE_Static);
                player->PlayerPhysic = NE_PhysicsCreate(NE_BoundingBox);
                NE_PhysicsSetModel(player->PlayerPhysic, (void *)player->PlayerModel); // Physics object and Model assigned to it
                NE_PhysicsEnable(player->PlayerPhysic, IsLocalPlayer);
                NE_PhysicsSetGravity(player->PlayerPhysic, 0.0065);
                NE_PhysicsSetSize(player->PlayerPhysic, player->xSize * 2.0, player->ySize * 2.0, player->zSize * 2.0);
                NE_PhysicsSetFriction(player->PlayerPhysic, 1);
                NE_PhysicsOnCollision(player->PlayerPhysic, NE_ColBounce);
                NE_PhysicsSetBounceEnergy(player->PlayerPhysic, 0);
                UpdateGunTexture();
            }
            else
            {
                // player->PlayerModel = NE_ModelCreate(NE_Animated); // ANIMATED VERSION
                player->PlayerModel = NE_ModelCreate(NE_Static);
                // NE_ModelLoadNEA(player->PlayerModel, (u32 *)playerAnimNea_bin); // ANIMATED VERSION

                if (i == 1)
                    NE_ModelLoadStaticMesh(player->PlayerModel, (u32 *)GIGNNew_bin);
                else
                    NE_ModelClone(player->PlayerModel,        // Destination
                                  AllPlayers[1].PlayerModel); // Source model

                // NE_ModelLoadNEA(player->PlayerModel, (u32 *)GIGNAnimNea_bin);
                NE_ModelSetMaterial(player->PlayerModel, PlayerMaterial);
                NE_ModelScaleI(player->PlayerModel, 2048, 2090, 2048); // 2048 <- 4096 * 0.5 ANIMATED VERSION
                // NE_ModelScaleI(player->PlayerModel, 700, 700, 700); // 2048 <- 4096 * 0.5 STATIC VERSION
                //  NE_ModelAnimInterpolate(player->PlayerModel, false);
                //  NE_ModelAnimStart(player->PlayerModel, 0, 0, 5, NE_ANIM_LOOP, 3);

                // Select a random name
                if (isAI)
                {
                    player->PathCount = 0;
                    player->CurrentPath = 0;
                    player->LastWayPoint = 0;
                    int botName;
                    do
                    {
                        botName = rand() % 10;
                    } while (botsNamesTaken[botName]);
                    botsNamesTaken[botName] = true;
                    strcpy(player->name, botsNames[botName]);
                }
                else
                {
                    strcpy(player->name, "Player");
                }
            }

            NE_ModelSetCoord(player->PlayerModel, 0, -100, -2);
            player->lerpDestination.x = 0;
            player->lerpDestination.y = -100;
            player->lerpDestination.z = -2;
            player->position.x = 0;
            player->position.y = -100;
            player->position.z = -2;

            player->Id = NewId;

            setPlayerHealth(i, 100);
            player->isAi = isAI;

            // Init raycasting values
            player->ScanForGrenade = EMPTY;
            player->target = NO_PLAYER;
            player->lastSeenTarget = NO_PLAYER;
            player->justCheking = false;

            setPlayerMoney(i, allPartyModes[currentPartyMode].startMoney);

            player->KillCount = 0;
            player->DeathCount = 0;
            player->GunWaitCount = 0;
            player->GunReloadWaitCount = 0;
            player->isReloading = false;
            player->haveDefuseKit = false;
            player->haveBomb = false;
            player->isPlantingBomb = false;
            player->bombTimer = 0;

            player->BobbingOffset = 0;
            player->HasBobbed = false;
            player->Step = 0;

            player->RespawnTimer = 0;
            player->NeedRespawn = false;
            player->CurrentOcclusionZone = 0;
            player->Team = SPECTATOR;

            player->lightCoef = 1;
            player->currentShadowCollBox = 0;
            player->inShadow = false;
            player->mapVisivilityTimer = 0;

            if (allPartyModes[currentPartyMode].spawnWithArmor)
            {
                player->armor = 100;
                player->haveHeadset = true;
            }
            else
            {
                player->armor = 0;
                player->haveHeadset = false;
            }

            PlayerCount++;
            return i;
        }
    }
    return -1;
    // If code running here, this is not normal lol XD
    // No player slot available
}

/**
 * @brief Set the bomb to a random terrorist
 *
 */
void setBombForARandomPlayer()
{
    int TerroristCount = 0;

    // Remove the bomb of all terrorists
    for (int i = 0; i < MaxPlayer; i++)
    {
        SetGunInInventoryForNonLocalPlayer(i, EMPTY, 8);
        AllPlayers[i].haveBomb = false;
        // Get the number of terrorists in game
        if (AllPlayers[i].Id != UNUSED && AllPlayers[i].Team == TERRORISTS)
        {
            TerroristCount++;
        }
    }

    // If the local player is a terrorists
    if (localPlayer->Team == TERRORISTS)
    {
        // Give the bomb to the local player
        localPlayer->haveBomb = true;
        SetGunInInventory(28, 8);
        return;
    }

    // Or give the bomb to a random terrorist
    int giveBombTo = rand() % TerroristCount;
    TerroristCount = 0;

    for (int i = 1; i < MaxPlayer; i++)
    {
        Player *player = &AllPlayers[i];
        if (player->Id != UNUSED && player->Team == TERRORISTS)
        {
            if (giveBombTo == TerroristCount)
            {
                player->haveBomb = true;
                SetGunInInventoryForNonLocalPlayer(i, 28, 8);
                break;
            }
            TerroristCount++;
        }
    }
}

void onMoneyUpdated(int playerIndex)
{
    // Refresh the screen if needed
    if (playerIndex == 0)
    {
        if (currentMenu == SHOP || currentMenu == SHOPCATEGORIES)
            UpdateBottomScreenFrameCount += 8;
    }
}

/**
 * @brief Give money to a team
 *
 * @param Money Money to give (if negative, the function will do nothing)
 * @param Team Team see teamEnum
 */
void addMoneyToTeam(int Money, enum teamEnum Team)
{
    if (Money <= 0)
        return;

    for (int i = 0; i < MaxPlayer; i++)
    {
        Player *player = &AllPlayers[i];
        if (player->Team == Team)
        {
            addPlayerMoney(i, Money);
        }
    }
}

/**
 * @brief Set player money
 *
 * @param playerIndex Player index
 * @param Money Money (if negative, money will be 0)
 */
void setPlayerMoney(int playerIndex, int Money)
{
    if (Money < 0)
        Money = 0;

    Player *player = &AllPlayers[playerIndex];
    player->Money = Money;

    if (player->Money > allPartyModes[currentPartyMode].maxMoney)
        player->Money = allPartyModes[currentPartyMode].maxMoney;

    onMoneyUpdated(playerIndex);
}

/**
 * @brief Give money to a player
 *
 * @param playerIndex Player index
 * @param Money Money to give (if negative, the function will do nothing)
 */
void addPlayerMoney(int playerIndex, int Money)
{
    if (Money <= 0)
        return;

    Player *player = &AllPlayers[playerIndex];
    player->Money += Money;
    if (player->Money > allPartyModes[currentPartyMode].maxMoney)
        player->Money = allPartyModes[currentPartyMode].maxMoney;

    onMoneyUpdated(playerIndex);
}

/**
 * @brief Reduce player money
 *
 * @param playerIndex Player index
 * @param Money Money to reduce (if negative, the function will do nothing)
 */
void reducePlayerMoney(int playerIndex, int Money)
{
    if (Money <= 0)
        return;

    Player *player = &AllPlayers[playerIndex];
    player->Money -= Money;
    if (player->Money < 0)
        player->Money = 0;

    onMoneyUpdated(playerIndex);
}

/**
 * @brief Reset a player (Reset inventory, ammo, health, armor)
 *
 * @param index Player index
 */
void resetPlayer(int index)
{
    Player *player = &AllPlayers[index];

    StopReloading(index);

    for (int i = 0; i < grenadeBoughtLength; i++)
    {
        player->grenadeBought[i] = 0;
    }

    if (player->IsDead || (allPartyModes[currentPartyMode].middlePartyTeamSwap && TerroristsScore + CounterScore == floor(allPartyModes[currentPartyMode].maxRound / 2.0)) || TerroristsScore + CounterScore == 0)
    {
        player->haveDefuseKit = false;
        player->armor = 0;
        player->haveHeadset = false;

        if (player->Team == TERRORISTS)
            player->AllGunsInInventory[1] = DEFAULTTERRORISTGUN;
        else if (player->Team == COUNTERTERRORISTS)
            player->AllGunsInInventory[1] = DEFAULTCOUNTERTERRORISTGUN;

        for (int i = 2; i < inventoryCapacity - 1; i++)
        {
            player->AllGunsInInventory[i] = EMPTY;
        }
    }

    setPlayerHealth(index, 100);
    if (allPartyModes[currentPartyMode].spawnWithArmor)
    {
        player->armor = 100;
        player->haveHeadset = true;
    }

    if (roundState == TRAINING)
    {
        player->invincibilityTimer = 60 * 5; // 5 seconds
        player->currentGunInInventory = 1;
    }
    player->isPlantingBomb = false; //
    player->bombTimer = 0;

    ResetGunsAmmo(index);
    if (index == 0)
    {
        SetCurrentCameraPlayer(0);
        frameCountDuringAir = 0;
    }
    else
    {
        player->PathCount = 0;
        player->target = NO_PLAYER;
        player->lastSeenTarget = NO_PLAYER;
    }
}
```

`Counter-Strike-nds/source/player/player.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef PLAYER_H_ /* Include guard */
#define PLAYER_H_

#include "main.h"

void killPlayer(Player *player);
void makeHit(int hitBy, int playerHit, float distance, int shootIndex);
void buyGun();
void CalculatePlayerPosition(int PlayerIndex);
void setPlayerPositionAtSpawns(int playerIndex);
void setNewRoundHandWeapon();
void SetGunInInventory(int Value, int inventoryIndex);
void SetGunInInventoryForNonLocalPlayer(int playerIndex, int Value, int inventoryIndex);
void ChangeGunInInventoryForLocalPlayer(int Left);
void ChangeGunInInventory(int playerIndex, int Left);
void setSelectedGunInInventory(int playerIndex, int gunIndex);
void playerUpdate();
void removeAllPlayers();
int AddNewPlayer(int NewId, bool IsLocalPlayer, bool isAI);
void UpdatePlayerTexture(int playerIndex);
void setPlayerHealth(int playerIndex, int health);
void resetPlayer(int index);
void reducePlayerMoney(int playerIndex, int Money);
void addPlayerMoney(int playerIndex, int Money);
void setPlayerMoney(int playerIndex, int Money);
void addMoneyToTeam(int Money, enum teamEnum Team);
void setBombForARandomPlayer();
void setShopZone(Player *player);

#endif // PLAYER_H_
```

`Counter-Strike-nds/source/save/saveManager.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "saveManager.h"
#include "keyboard.h"
#include "input.h"
#include "tutorial.h"
#include "stats.h"

// File system
#include <fat.h>
#include <stdio.h>
#include <math.h>

// For random system
#include <time.h>

// File system
FILE *savefile;

/**
 * @brief Save data
 *
 */
void Save()
{
    savefile = fopen("fat:/counter_strike_ds.sav", "wb"); // Try to read or create a save on DS

    if (savefile == NULL) // If there is no file, try to create in another location (3DS/2DS)
    {
        savefile = fopen("counter_strike_ds.sav", "wb"); // Try to read or create a save on 3DS/2DS
        if (savefile == NULL)                            // If there is no file, try to create in another location (SD)
        {
            savefile = fopen("sd:/counter_strike_ds.sav", "wb"); // Try to read or create a save on the sd card
        }
    }

    char saveText[512];
    sprintf(saveText, "game_version %s\n", GAME_VERSION);
    sprintf(saveText + strlen(saveText), "player_name %s\n", localPlayer->name);
    sprintf(saveText + strlen(saveText), "use_rumble %d\n", useRumble);
    sprintf(saveText + strlen(saveText), "is_azerty %d\n", isAzerty);
    sprintf(saveText + strlen(saveText), "is_left_controls %d\n", isLeftControls);
    sprintf(saveText + strlen(saveText), "sensitivity %f\n", sensitivity);
    sprintf(saveText + strlen(saveText), "tutorial_done %d\n", tutorialDone);
    sprintf(saveText + strlen(saveText), "show_ping %d\n", showPing);
    sprintf(saveText + strlen(saveText), "inputs %d\n", INPUT_COUNT);
    for (int i = 0; i < INPUT_COUNT; i++)
    {
        sprintf(saveText + strlen(saveText), "k%d %d\n", i, inputs[i].value);
    }
    sprintf(saveText + strlen(saveText), "cursor_transparency %f\n", cursorTransparency);
    sprintf(saveText + strlen(saveText), "buttons_sensitivity %f\n", buttonsSensitivity);

    // Stats
    sprintf(saveText + strlen(saveText), "total_bots_kill_count %d\n", totalBotsKillCount);
    sprintf(saveText + strlen(saveText), "total_online_players_kill_count %d\n", totalOnlinePlayersKillCount);
    sprintf(saveText + strlen(saveText), "total_death_count %d\n", totalDeathCount);
    sprintf(saveText + strlen(saveText), "total_finished_party %d\n", totalFinishedParty);
    sprintf(saveText + strlen(saveText), "total_played_seconds %d\n", totalPlayedSeconds);
    sprintf(saveText + strlen(saveText), "total_played_minutes %d\n", totalPlayedMinutes);
    sprintf(saveText + strlen(saveText), "total_played_hours %d\n", totalPlayedHours);
    sprintf(saveText + strlen(saveText), "total_wins %d\n", totalWins);

    if (savefile != NULL)
    {
        fwrite(saveText, 1, strlen(saveText), savefile);
        fclose(savefile);
    }
}

/**
 * @brief Load data
 *
 */
void Load()
{
    savefile = fopen("fat:/counter_strike_ds.sav", "rb"); // Try to read a save on DS
    if (savefile == NULL)                                 // If there is no file, try to read in another location (3DS/2DS)
    {
        savefile = fopen("counter_strike_ds.sav", "rb"); // Try to read a save on 3DS / 2DS
        if (savefile == NULL)                            // If there is no file, try to read in another location (SD)
        {
            savefile = fopen("sd:/counter_strike_ds.sav", "rb"); // Try to read a save on the sd card
        }
    }

    if (savefile != NULL)
    {
        int inputsFound = 14;
        int inputCount = 0;
        while (1)
        {
            char word[128];
            // read the next word of the file
            int res = fscanf(savefile, "%s", word);

            if (res == EOF)
                break; // EOF = End Of File. Quit the loop.

            if (strcmp(word, "game_version") == 0) // Read save game version
            {
                int tmpX;
                int tmpY;
                int tmpZ;
                fscanf(savefile, "%d.%d.%d", &tmpX, &tmpY, &tmpZ);
            }
            else if (strcmp(word, "player_name") == 0) // Read player name
            {
                fscanf(savefile, "%s", localPlayer->name);
            }
            else if (strcmp(word, "use_rumble") == 0) // Read use rumble
            {
                int tmpUseRumble;
                fscanf(savefile, "%d", &tmpUseRumble);
                useRumble = tmpUseRumble;
            }
            else if (strcmp(word, "is_azerty") == 0) // Read is azerty
            {
                int tmpIsAzerty;
                fscanf(savefile, "%d", &tmpIsAzerty);
                isAzerty = tmpIsAzerty;
            }
            else if (strcmp(word, "is_left_controls") == 0) // Read is left controls
            {
                int tmpIsLeftControls;
                fscanf(savefile, "%d", &tmpIsLeftControls);
                isLeftControls = tmpIsLeftControls;
            }
            else if (strcmp(word, "sensitivity") == 0) // Read sensitivity
            {
                float tmpSensitivity;
                fscanf(savefile, "%f", &tmpSensitivity);
                sensitivity = tmpSensitivity;
            }
            else if (strcmp(word, "tutorial_done") == 0) // Read tutorial done
            {
                int tmpTutorialDone;
                fscanf(savefile, "%d", &tmpTutorialDone);
                tutorialDone = tmpTutorialDone;
            }
            else if (strcmp(word, "show_ping") == 0) //
            {
                int tmpShowPing;
                fscanf(savefile, "%d", &tmpShowPing);
                showPing = tmpShowPing;
            }
            else if (strcmp(word, "inputs") == 0) //
            {
                int tmpinputsFound;
                fscanf(savefile, "%d", &tmpinputsFound);
                inputsFound = tmpinputsFound;
            }
            else if (strcmp(word, "cursor_transparency") == 0)
            {
                float tmpcursorTransparency;
                fscanf(savefile, "%f", &tmpcursorTransparency);
                cursorTransparency = tmpcursorTransparency;
            }
            else if (strcmp(word, "buttons_sensitivity") == 0)
            {
                float tmpbuttonsSensitivity;
                fscanf(savefile, "%f", &tmpbuttonsSensitivity);
                buttonsSensitivity = tmpbuttonsSensitivity;
            }
            else if (strcmp(word, "total_bots_kill_count") == 0)
            {
                int tmptotalBotsKillCount;
                fscanf(savefile, "%d", &tmptotalBotsKillCount);
                totalBotsKillCount = tmptotalBotsKillCount;
            }
            else if (strcmp(word, "total_online_players_kill_count") == 0)
            {
                int tmptotalOnlinePlayersKillCount;
                fscanf(savefile, "%d", &tmptotalOnlinePlayersKillCount);
                totalOnlinePlayersKillCount = tmptotalOnlinePlayersKillCount;
            }
            else if (strcmp(word, "total_death_count") == 0)
            {
                int tmptotalDeathCount;
                fscanf(savefile, "%d", &tmptotalDeathCount);
                totalDeathCount = tmptotalDeathCount;
            }
            else if (strcmp(word, "total_finished_party") == 0)
            {
                int tmptotalFinishedParty;
                fscanf(savefile, "%d", &tmptotalFinishedParty);
                totalFinishedParty = tmptotalFinishedParty;
            }
            else if (strcmp(word, "total_played_seconds") == 0)
            {
                int tmptotalPlayedSeconds;
                fscanf(savefile, "%d", &tmptotalPlayedSeconds);
                totalPlayedSeconds = tmptotalPlayedSeconds;
            }
            else if (strcmp(word, "total_played_minutes") == 0)
            {
                int tmptotalPlayedMinutes;
                fscanf(savefile, "%d", &tmptotalPlayedMinutes);
                totalPlayedMinutes = tmptotalPlayedMinutes;
            }
            else if (strcmp(word, "total_played_hours") == 0)
            {
                int tmptotalPlayedHours;
                fscanf(savefile, "%d", &tmptotalPlayedHours);
                totalPlayedHours = tmptotalPlayedHours;
            }
            else if (strcmp(word, "total_wins") == 0)
            {
                int tmptotalWins;
                fscanf(savefile, "%d", &tmptotalWins);
                totalWins = tmptotalWins;
            }
            else if (inputsFound != inputCount) // Read inputs
            {
                char inputIndex[13];
                sprintf(inputIndex, "k%d", inputCount);
                if (strcmp(word, inputIndex) == 0)
                {
                    int tmpInput;
                    fscanf(savefile, "%d", &tmpInput);
                    inputs[inputCount].value = tmpInput;
                    if (tmpInput == -1)
                    {
                        inputs[inputCount].nameIndex = 12;
                    }
                    else
                    {
                        for (int i = 0; i < 12; i++)
                        {
                            if (tmpInput == BIT(i))
                            {
                                inputs[inputCount].nameIndex = i;
                                break;
                            }
                        }
                    }
                }
                inputCount++;
            }
        }
        fclose(savefile);
    }
    else
    {
        strncpy(localPlayer->name, "Player", PLAYER_MAX_LENGTH);
        Save();
    }
}
```

`Counter-Strike-nds/source/save/saveManager.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef SAVEMANAGER_H_ /* Include guard */
#define SAVEMANAGER_H_

//#include "main.h"

void Save();
void Load();

#endif // SAVEMANAGER_H_
```

`Counter-Strike-nds/source/save/stats.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "stats.h"
#include "network.h"

int totalBotsKillCount = 0;
int totalOnlinePlayersKillCount = 0;
int totalDeathCount = 0;
int totalFinishedParty = 0;
int totalPlayedSeconds = 0;
int totalPlayedMinutes = 0;
int totalPlayedHours = 0;
int totalWins = 0;

void statsTimer()
{
    if (frameCount % 60 == 0 && Connection != UNSELECTED)
    {
        totalPlayedSeconds++;
        if (totalPlayedSeconds == 60)
        {
            totalPlayedSeconds = 0;
            totalPlayedMinutes++;
        }
        if (totalPlayedMinutes == 60)
        {
            totalPlayedMinutes = 0;
            totalPlayedHours++;
        }
    }
}
```

`Counter-Strike-nds/source/save/stats.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef STATS_H_ /* Include guard */
#define STATS_H_

extern int totalBotsKillCount;
extern int totalOnlinePlayersKillCount;
extern int totalDeathCount;
extern int totalFinishedParty;
extern int totalWins;
extern int totalPlayedSeconds;
extern int totalPlayedMinutes;
extern int totalPlayedHours;

void statsTimer();

#endif // DEBUG_H_
```

`Counter-Strike-nds/source/sounds/sounds.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "sounds.h"
#include "player.h"
#include <maxmod9.h>
#include <fat.h>
#include <filesystem.h>

// Music remaining time
int musicLength = 0;
// Is music playing
bool isMusicPlaying = false;
// Are sounds loaded
bool soundsLoaded = false;
// Are sound bank file loaded
bool soundBankLoaded = false;
// Is music file is accessible
bool musicFilePresent = false;

// Music file
FILE *musicFile = NULL;

/**
 * @brief Stream callback for maxmod
 *
 * @param length remaining streaming time
 * @param dest
 * @param format
 * @return mm_word
 */
mm_word stream(mm_word length, mm_addr dest, mm_stream_formats format)
{
    if (musicFile)
    {
        size_t samplesize;
        switch (format)
        {
        case MM_STREAM_8BIT_MONO:
            samplesize = 1;
            break;
        case MM_STREAM_8BIT_STEREO:
            samplesize = 2;
            break;
        case MM_STREAM_16BIT_MONO:
            samplesize = 2;
            break;
        case MM_STREAM_16BIT_STEREO:
            samplesize = 4;
            break;
        default:
            samplesize = 2;
            break;
        }

        int res = fread(dest, samplesize, length, musicFile);

        if (res)
        {
            length = res;
        }
        else
        {
            mmStreamClose();
            fclose(musicFile);
            length = 0;
        }
    }
    musicLength = length;
    return length;
}

/**
 * @brief Check if music is finished to restart the music
 *
 */
void checkMusicSteaming()
{
    if (isMusicPlaying)
    {
        // If the music is finished, restart it
        if (musicLength == 0)
        {
            loadMusic();
        }
        else // Or update stream
        {
            mmStreamUpdate();
        }
    }
}

/**
 * @brief Init sound system and load sound bank and music
 *
 */
void initSoundSystem()
{
    // Init sound system
    // mmInitDefaultMem((mm_addr)soundbank_bin);
    mm_ds_system sys;

    // number of modules in your soundbank (defined in output header)
    sys.mod_count = MSL_NSONGS;

    // number of samples in your soundbank (defined in output header)
    sys.samp_count = MSL_NSAMPS;

    // memory bank, allocate BANKSIZE (or NSONGS+NSAMPS) words
    sys.mem_bank = malloc(MSL_BANKSIZE * 4);

    // select fifo channel
    sys.fifo_channel = FIFO_MAXMOD;

    // initialize maxmod
    mmInit(&sys);

    //
    if (access("fat:/counter_strike_music.raw", F_OK) == 0 || access("counter_strike_music.raw", F_OK) == 0 || access("sd:/counter_strike_music.raw", F_OK) == 0)
    {
        musicFilePresent = true;
    }
    else
    {
        musicFilePresent = false;
    }

    if (access("fat:/soundbank.bin", F_OK) == 0 || access("soundbank.bin", F_OK) == 0 || access("sd:/soundbank.bin", F_OK) == 0)
    {
        // Load sound back
        mmSoundBankInFiles("soundbank.bin");
        soundBankLoaded = true;
    }
    else
    {
        // file doesn't exist
        soundBankLoaded = false;
    }
}

/**
 * @brief Start the music
 *
 */
void launchMusic()
{
    if (!isMusicPlaying)
    {
        isMusicPlaying = true;
        unloadSounds();
        loadMusic();
    }
}

/**
 * @brief Close music stream
 *
 */
void closeMusicSteam()
{
    if (musicFile)
    {
        mmStreamClose();
        fclose(musicFile);
    }
}

/**
 * @brief Load music file and open stream
 *
 */
void loadMusic()
{
    if (!musicFilePresent)
        return;

    closeMusicSteam();
    // open file
    musicFile = fopen("fat:/counter_strike_music.raw", "rb");
    if (musicFile == NULL)
    {
        musicFile = fopen("counter_strike_music.raw", "rb");
        if (musicFile == NULL)
        {
            musicFile = fopen("sd:/counter_strike_music.raw", "rb");
        }
    }

    // Open stream
    if (musicFile)
    {
        mm_stream mystream;
        mystream.buffer_length = 1024;
        mystream.callback = stream;
        mystream.timer = MM_TIMER1;
        mystream.manual = true;
        mystream.sampling_rate = 32000;
        mystream.format = MM_STREAM_8BIT_MONO;
        mmStreamOpen(&mystream);
    }
}

/**
 * @brief Stop music, close stream and load sounds
 *
 */
void stopMusic()
{
    if (isMusicPlaying)
    {
        closeMusicSteam();
        isMusicPlaying = FALSE;
        loadSounds();
    }
}

/**
 * @brief Load sounds from the sound bank and stop the music
 *
 */
void loadSounds()
{
    stopMusic();

    if (soundsLoaded || !soundBankLoaded)
    {
        return;
    }

    soundsLoaded = true;

    // Load sound effects
    for (int i = 0; i < MSL_NSAMPS; i++)
    {
        mmLoadEffect(i);
    }
}

/**
 * @brief Unload sounds
 *
 */
void unloadSounds()
{
    if (!soundsLoaded || !soundBankLoaded)
    {
        return;
    }

    soundsLoaded = false;

    // Unload sound effects
    for (int i = 0; i < MSL_NSAMPS; i++)
    {
        mmUnloadEffect(i);
    }
}

/**
 * @brief Play a step sound
 *
 * @param Volume Volume
 * @param Panning Panning (0-255) (left-right)
 * @param playerIndex Player index
 */
void DoStepSound(int Volume, int Panning, int playerIndex)
{
    if (!soundBankLoaded)
        return;

    if (Volume > 0)
    {
        mm_sfxhand mysound;

        // Play random sound
        if (AllPlayers[playerIndex].Step == 0)
            mysound = mmEffect(SFX_CONCRETE_CT_1);
        else if (AllPlayers[playerIndex].Step == 1)
            mysound = mmEffect(SFX_CONCRETE_CT_2);
        else if (AllPlayers[playerIndex].Step == 2)
            mysound = mmEffect(SFX_CONCRETE_CT_3);
        else
            mysound = mmEffect(SFX_CONCRETE_CT_4);

        // Set panning and volume
        mmEffectPanning(mysound, Panning);
        mmEffectVolume(mysound, Volume);
        AllPlayers[playerIndex].mapVisivilityTimer = 300;

        AllPlayers[playerIndex].Step++;
        if (AllPlayers[playerIndex].Step == 4)
            AllPlayers[playerIndex].Step = 0;
    }
}

/**
 * @brief Get panning between the local player and a player
 *
 * @param PlayerId Player index
 * @param OutPanning Out Panning (0-255) (left-right)
 * @param OutVolume Out Volume
 * @param xWithoutYForAudio
 * @param zWithoutYForAudio
 * @param MaxSoundDistance Max sound distance
 */
void GetPanning(int PlayerId, int *OutPanning, int *OutVolume, float xWithoutYForAudio, float zWithoutYForAudio, float MaxSoundDistance)
{
    // float MaxSoundDistance = 0.15; //0 = 0 meter; 0.05 = 7.65 meters; 1 = 255 meters
    float CenterOffset = 10;
    float Panning = -1;

    // With players positions, calculate volume and panning
    for (int i = 1; i < MaxPlayer; i++)
        if (AllPlayers[i].Id == PlayerId)
        {
            if (CurrentCameraPlayer != 0 && CurrentCameraPlayer != i)
                CalculatePlayerPosition(CurrentCameraPlayer);
            CalculatePlayerPosition(i);
            float Dis = sqrtf(powf(AllPlayers[CurrentCameraPlayer].position.x - AllPlayers[i].position.x, 2.0) + powf(AllPlayers[CurrentCameraPlayer].position.y - AllPlayers[i].position.y, 2.0) + powf(AllPlayers[CurrentCameraPlayer].position.z - AllPlayers[i].position.z, 2.0));
            *OutVolume = (int)fmax(255 - (Dis * 2.0) / MaxSoundDistance, 0);
            Panning = (xWithoutYForAudio * (AllPlayers[i].position.x - AllPlayers[CurrentCameraPlayer].position.x)) + (zWithoutYForAudio * (AllPlayers[i].position.z - AllPlayers[CurrentCameraPlayer].position.z));
            break;
        }

    // Panning ajustements
    if (Panning > CenterOffset)
        Panning = CenterOffset;
    else if (Panning < -CenterOffset)
        Panning = -CenterOffset;

    Panning += CenterOffset;
    Panning /= CenterOffset * 2.0;
    Panning *= 255.0;

    // return panning
    *OutPanning = (int)Panning;
}

/**
 * @brief
 * @brief Get panning between the camera and position
 *
 * @param OutPanning Out Panning (0-255) (left-right)
 * @param OutVolume Out Volume (0-255)
 * @param PositionB Position
 * @param xWithoutYForAudio
 * @param zWithoutYForAudio
 * @param MaxSoundDistance Max sound distance
 */
void GetPanningByPosition(int *OutPanning, int *OutVolume, Vector4 PositionB, float xWithoutYForAudio, float zWithoutYForAudio, float MaxSoundDistance)
{
    // float MaxSoundDistance = 0.15; //0 = 0 meter; 0.05 = 7.65 meters; 1 = 255 meters
    float CenterOffset = 10;
    float Panning = -1;

    if (CurrentCameraPlayer != 0)
        CalculatePlayerPosition(CurrentCameraPlayer);

    // With players positions, calculate volume and panning
    float Dis = sqrtf(powf(AllPlayers[CurrentCameraPlayer].position.x - PositionB.x, 2.0) + powf(AllPlayers[CurrentCameraPlayer].position.y - PositionB.y, 2.0) + powf(AllPlayers[CurrentCameraPlayer].position.z - PositionB.z, 2.0));
    *OutVolume = (int)fmax(255 - (Dis * 2.0) / MaxSoundDistance, 0);
    Panning = (xWithoutYForAudio * (PositionB.x - AllPlayers[CurrentCameraPlayer].position.x)) + (zWithoutYForAudio * (PositionB.z - AllPlayers[CurrentCameraPlayer].position.z));

    // Panning ajustements
    if (Panning > CenterOffset)
        Panning = CenterOffset;
    else if (Panning < -CenterOffset)
        Panning = -CenterOffset;

    Panning += CenterOffset;
    Panning /= CenterOffset * 2.0;
    Panning *= 255.0;

    // return panning
    *OutPanning = (int)Panning;
}

/**
 * @brief Play a sound in 3D space
 *
 * @param sound Sound to play
 * @param Volume Volume (0-255)
 * @param Panning Panning (0-255) (left-right)
 * @param player Player pointer
 */
void Play3DSound(mm_word sound, int Volume, int Panning, Player *player)
{
    if (!soundBankLoaded)
        return;

    // If the volume is 0, don't play the sound
    if (Volume > 0)
    {
        mm_sfxhand mysound = mmEffect(sound);

        // Set effect panning and volume
        mmEffectPanning(mysound, Panning);
        mmEffectVolume(mysound, Volume);
    }

    // Show the player on the map if the sound is loud
    if (Volume >= 25 && player != NULL)
        player->mapVisivilityTimer = 300;
}

/**
 * @brief Play a sound in 2D space
 *
 * @param sound Sound to play
 * @param Volume Volume (0-255)
 */
void Play2DSound(mm_word sound, int Volume)
{
    if (!soundBankLoaded)
        return;

    // If the volume is 0, don't play the sound
    if (Volume > 0)
    {
        mm_sfxhand mysound = mmEffect(sound);

        // Set effeft volume
        mmEffectVolume(mysound, Volume);
    }
}

/**
 * @brief Play a sound
 *
 * @param sound Sound to play
 */
void PlayBasicSound(mm_word sound)
{
    if (!soundBankLoaded)
        return;

    mmEffect(sound);
}

```

`Counter-Strike-nds/source/sounds/sounds.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef SOUNDS_H_ /* Include guard */
#define SOUNDS_H_

#include "main.h"

void DoStepSound(int Volume, int Panning, int playerIndex);
void GetPanning(int PlayerId, int *OutPanning, int *OutVolume, float xWithoutYForAudio, float zWithoutYForAudio, float MaxSoundDistance);
void GetPanningByPosition(int *OutPanning, int *OutVolume, Vector4 PositionB, float xWithoutYForAudio, float zWithoutYForAudio, float MaxSoundDistance);
void Play3DSound(mm_word sound, int Volume, int Panning, Player *player);
void Play2DSound(mm_word sound, int Volume);
void PlayBasicSound(mm_word sound);
void initSoundSystem();
void loadSounds();
void unloadSounds();
void launchMusic();
void loadMusic();
void stopMusic();
void checkMusicSteaming();

extern int musicLength;
extern bool isMusicPlaying;
extern bool soundsLoaded;

extern bool soundBankLoaded;
extern bool musicFilePresent;

#endif // SOUNDS_H_
```

`Counter-Strike-nds/source/weapons/data/equipment_data.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "equipment.h"

/**
 * @brief Load equipments data
 * Data source : https://counterstrike.fandom.com/wiki/Category:Equipment
 * @param equipment
 */
void LoadEquipments()
{
    int equipmentIndex = 0;

    // C4
    allEquipments[equipmentIndex].type = C4;                // Set equipment type
    allEquipments[equipmentIndex].Price = 0;                // Set equipment price
    allEquipments[equipmentIndex].texture = (void *)c4_bin; // Set equipment texture for shop
    allEquipments[equipmentIndex].team = TERRORISTS;        // Set equipment team
    allEquipments[equipmentIndex].isHided = true;           // Set if the equipment is hided from shop
    allEquipments[equipmentIndex].name = "";                // Set equipment name
    allEquipments[equipmentIndex].description = "";         // Set equipment description
    equipmentIndex++;

    // Defusekit
    allEquipments[equipmentIndex].type = DEFUSER;
    allEquipments[equipmentIndex].Price = 400;
    allEquipments[equipmentIndex].texture = (void *)defuser_bin;
    allEquipments[equipmentIndex].team = COUNTERTERRORISTS;
    allEquipments[equipmentIndex].name = "Defuse kit";
    allEquipments[equipmentIndex].description = "Decrease the defuse time of bombs by half";
    equipmentIndex++;

    // Kevlar vest
    allEquipments[equipmentIndex].type = KEVLAR_VEST;
    allEquipments[equipmentIndex].Price = 650;
    allEquipments[equipmentIndex].texture = (void *)kevlar_bin;
    allEquipments[equipmentIndex].team = BOTH;
    allEquipments[equipmentIndex].name = "Kevlar vest";
    allEquipments[equipmentIndex].description = "The Kevlar Vest protects the chest";
    equipmentIndex++;

    // Kevlar vest and helmet
    allEquipments[equipmentIndex].type = KEVLAR_VEST_AND_HELMET;
    allEquipments[equipmentIndex].Price = 1000;
    allEquipments[equipmentIndex].texture = (void *)kevlar_helmet_bin;
    allEquipments[equipmentIndex].team = BOTH;
    allEquipments[equipmentIndex].name = "Kevlar + helmet";
    allEquipments[equipmentIndex].description = "Protects the chest and the head";
    equipmentIndex++;
}

```

`Counter-Strike-nds/source/weapons/data/equipment_data.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef EQUIPMENT_DATA_H_ /* Include guard */
#define EQUIPMENT_DATA_H_

void LoadEquipments();

#endif // EQUIPMENT_DATA_H_
```

`Counter-Strike-nds/source/weapons/data/grenade_data.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "grenade.h"

/**
 * @brief Load grenades data
 * Data source : https://counterstrike.fandom.com/wiki/Category:Grenades
 * @param equipment
 */
void LoadGrenades()
{
    int grenadeIndex = 0;

    AllGrenades[grenadeIndex].type = EXPLOSIVE;
    AllGrenades[grenadeIndex].Price = 300;
    AllGrenades[grenadeIndex].texture = (void *)fraggrenade_bin;
    AllGrenades[grenadeIndex].team = BOTH;
    AllGrenades[grenadeIndex].collisionSound = SFX_HEGRENADE_BOUNCE;
    AllGrenades[grenadeIndex].finalSound = SFX_HEGRENADE_EXPLOSE;
    AllGrenades[grenadeIndex].maxQuantity[0] = 1;
    AllGrenades[grenadeIndex].maxQuantity[1] = 1;
    AllGrenades[grenadeIndex].maxQuantity[2] = 1;
    AllGrenades[grenadeIndex].name = "Explosive grenade";
    AllGrenades[grenadeIndex].description = "The explosive grenade administers high damage";
    grenadeIndex++;

    AllGrenades[grenadeIndex].type = SMOKE;
    AllGrenades[grenadeIndex].Price = 300;
    AllGrenades[grenadeIndex].texture = (void *)smokegrenade_bin;
    AllGrenades[grenadeIndex].team = BOTH;
    AllGrenades[grenadeIndex].collisionSound = SFX_FLASHBANG_BOUNCE; // PAS BON?
    AllGrenades[grenadeIndex].finalSound = SFX_SMOKE_EMIT;
    AllGrenades[grenadeIndex].maxQuantity[0] = 1;
    AllGrenades[grenadeIndex].maxQuantity[1] = 1;
    AllGrenades[grenadeIndex].maxQuantity[2] = 1;
    AllGrenades[grenadeIndex].name = "Smoke grenade";
    AllGrenades[grenadeIndex].description = "The smoke grenade creates an area smoke screen.";
    grenadeIndex++;

    AllGrenades[grenadeIndex].type = FLASH;
    AllGrenades[grenadeIndex].Price = 200;
    AllGrenades[grenadeIndex].texture = (void *)flashthrowed_bin;
    AllGrenades[grenadeIndex].team = BOTH;
    AllGrenades[grenadeIndex].collisionSound = SFX_FLASHBANG_BOUNCE;
    AllGrenades[grenadeIndex].finalSound = SFX_FLASHBANG_EXPLODE;
    AllGrenades[grenadeIndex].maxQuantity[0] = 2;
    AllGrenades[grenadeIndex].maxQuantity[1] = 1;
    AllGrenades[grenadeIndex].maxQuantity[2] = 1;
    AllGrenades[grenadeIndex].name = "Flash";
    AllGrenades[grenadeIndex].description = "The flashbang grenade temporarily blinds anybody";
    grenadeIndex++;
}

```

`Counter-Strike-nds/source/weapons/data/grenade_data.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef GRENADE_DATA_H_ /* Include guard */
#define GRENADE_DATA_H_

void LoadGrenades();

#endif // GRENADE_DATA_H_
```

`Counter-Strike-nds/source/weapons/data/gun_data.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "gun.h"

#define HEAVY_WEAPON_WALK_SPEED 175
#define MEDIUM_HIGH_WEAPON_WALK_SPEED 180
#define MEDIUM_MEDIUM_WEAPON_WALK_SPEED 185
#define MEDIUM_WEAPON_WALK_SPEED 195
#define LIGHT_WEAPON_WALK_SPEED 210

/**
 * @brief Load guns data
 * Data source : https://counterstrike.fandom.com/wiki/Category:Weapons
 * @param equipment
 */
void LoadGuns()
{
    int gunIndex = 0;

    // Knife
    AllGuns[gunIndex].fireRate = 24; // 60 * 0.4
    AllGuns[gunIndex].DamageFalloff = 1;
    AllGuns[gunIndex].Damage = 40;
    AllGuns[gunIndex].texture = (void *)knifect_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].gunSound = SFX_KNIFE_HIT_WALL;
    AllGuns[gunIndex].WalkSpeed = 220;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = -1; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;      // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].ReloadTime = 0;   // 2.1 * 60
    AllGuns[gunIndex].isKnife = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.07;
    AllGuns[gunIndex].penetration = 85;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 3;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "Knife";
    gunIndex++;

    // Desert Eagle
    AllGuns[gunIndex].fireRate = 13; // 1 / 267 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.81;
    AllGuns[gunIndex].Damage = 53;
    AllGuns[gunIndex].texture = (void *)deagle_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 650;
    AllGuns[gunIndex].gunSound = SFX_DEAGLE;
    AllGuns[gunIndex].WalkSpeed = LIGHT_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = PISTOLS; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;           // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 7;
    AllGuns[gunIndex].MaxAmmoCount = 35;
    AllGuns[gunIndex].ReloadTime = 132; // 2.2 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 11;
    AllGuns[gunIndex].yMuzzleFlashOffset = 7;
    AllGuns[gunIndex].isBigGun = false;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 75;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "Desert Eagle";
    gunIndex++;

    // Dual Berettas
    AllGuns[gunIndex].fireRate = 5; // 1 / 750 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.75;
    AllGuns[gunIndex].Damage = 43;
    AllGuns[gunIndex].texture = (void *)elite_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 800;
    AllGuns[gunIndex].gunSound = SFX_ELITE;
    AllGuns[gunIndex].WalkSpeed = LIGHT_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = PISTOLS; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS;     // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 120;
    AllGuns[gunIndex].ReloadTime = 226; // 3.77 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 14;
    AllGuns[gunIndex].yMuzzleFlashOffset = 3;
    AllGuns[gunIndex].isBigGun = false;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 52;
    AllGuns[gunIndex].isDualGun = true;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "Dual Berettas";
    gunIndex++;

    // Five SeveN
    AllGuns[gunIndex].fireRate = 9; // 1 / 400 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.885;
    AllGuns[gunIndex].Damage = 24;
    AllGuns[gunIndex].texture = (void *)fivesevent_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 750;
    AllGuns[gunIndex].gunSound = SFX_FIVESEVEN;
    AllGuns[gunIndex].WalkSpeed = LIGHT_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = PISTOLS;    // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = COUNTERTERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 20;
    AllGuns[gunIndex].MaxAmmoCount = 100;
    AllGuns[gunIndex].ReloadTime = 192; // 3.2 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 16;
    AllGuns[gunIndex].yMuzzleFlashOffset = 10;
    AllGuns[gunIndex].isBigGun = false;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 75;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "Five SeveN";
    gunIndex++;

    // Glock-18
    AllGuns[gunIndex].fireRate = 9; // 1 / 400 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.75;
    AllGuns[gunIndex].Damage = 24;
    AllGuns[gunIndex].texture = (void *)glock18_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 400;
    AllGuns[gunIndex].gunSound = SFX_GLOCK18;
    AllGuns[gunIndex].WalkSpeed = LIGHT_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = PISTOLS; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS;     // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 20;
    AllGuns[gunIndex].MaxAmmoCount = 120;
    AllGuns[gunIndex].ReloadTime = 136; // 2.27 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 17;
    AllGuns[gunIndex].yMuzzleFlashOffset = 9;
    AllGuns[gunIndex].isBigGun = false;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 52;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "Glock-18";
    gunIndex++;

    // P228
    AllGuns[gunIndex].fireRate = 9; // 1 / 400 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.8;
    AllGuns[gunIndex].Damage = 31;
    AllGuns[gunIndex].texture = (void *)p228_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 600;
    AllGuns[gunIndex].gunSound = SFX_P228;
    AllGuns[gunIndex].WalkSpeed = LIGHT_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = PISTOLS; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;           // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 13;
    AllGuns[gunIndex].MaxAmmoCount = 52;
    AllGuns[gunIndex].ReloadTime = 162; // 2.7 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 19;
    AllGuns[gunIndex].yMuzzleFlashOffset = 10;
    AllGuns[gunIndex].isBigGun = false;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 62.5;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "P228";
    gunIndex++;

    // USP
    AllGuns[gunIndex].fireRate = 9; // 1 / 400 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.79;
    AllGuns[gunIndex].Damage = 29;
    AllGuns[gunIndex].texture = (void *)uspsilencer_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 500;
    AllGuns[gunIndex].gunSound = SFX_USP;
    AllGuns[gunIndex].WalkSpeed = LIGHT_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = PISTOLS;    // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = COUNTERTERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 12;
    AllGuns[gunIndex].MaxAmmoCount = 100;
    AllGuns[gunIndex].ReloadTime = 162; // 2.7 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 9;
    AllGuns[gunIndex].yMuzzleFlashOffset = 6;
    AllGuns[gunIndex].isBigGun = false;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 50;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "USP";
    gunIndex++;

    // M3
    AllGuns[gunIndex].fireRate = 53; // 1 / 68 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.7;
    AllGuns[gunIndex].Damage = 171 / 6; // 1 shoot is 6 bullets
    AllGuns[gunIndex].texture = (void *)m3super90_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 1700;
    AllGuns[gunIndex].gunSound = SFX_M3;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_HIGH_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = HEAVY; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;         // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 8;
    AllGuns[gunIndex].MaxAmmoCount = 48;
    AllGuns[gunIndex].ReloadTime = 276; // 4.6 * 60 from empty
    AllGuns[gunIndex].xMuzzleFlashOffset = -1;
    AllGuns[gunIndex].yMuzzleFlashOffset = 3;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 50;
    AllGuns[gunIndex].bulletCountPerShoot = 6;
    AllGuns[gunIndex].maxBotShootDisance = 14;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "M3";
    gunIndex++;

    // XM1014
    AllGuns[gunIndex].fireRate = 15; // 1 / 240 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.7;
    AllGuns[gunIndex].Damage = 114 / 6; // 1 shoot is 6 bullets
    AllGuns[gunIndex].texture = (void *)xm1014_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 3000;
    AllGuns[gunIndex].gunSound = SFX_XM1014;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_HIGH_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = HEAVY; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;         // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 7;
    AllGuns[gunIndex].MaxAmmoCount = 32;
    AllGuns[gunIndex].ReloadTime = 168; // 2.8 * 60 from empty
    AllGuns[gunIndex].xMuzzleFlashOffset = -8;
    AllGuns[gunIndex].yMuzzleFlashOffset = 1;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 50;
    AllGuns[gunIndex].bulletCountPerShoot = 6;
    AllGuns[gunIndex].maxBotShootDisance = 14;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "XM1014";
    gunIndex++;

    // M249
    AllGuns[gunIndex].fireRate = 5; // 1 / 750 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.97;
    AllGuns[gunIndex].Damage = 35;
    AllGuns[gunIndex].texture = (void *)m249_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 5750;
    AllGuns[gunIndex].gunSound = SFX_M249;
    AllGuns[gunIndex].WalkSpeed = HEAVY_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = HEAVY; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;         // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 100;
    AllGuns[gunIndex].MaxAmmoCount = 200;
    AllGuns[gunIndex].ReloadTime = 342; // 5.7 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 4;
    AllGuns[gunIndex].yMuzzleFlashOffset = -2;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 75;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 20;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "M249";
    gunIndex++;

    // MAC-10
    AllGuns[gunIndex].fireRate = 4; // 1 / 857  * 3600
    AllGuns[gunIndex].DamageFalloff = 0.82;
    AllGuns[gunIndex].Damage = 28;
    AllGuns[gunIndex].texture = (void *)mac10_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 1400;
    AllGuns[gunIndex].gunSound = SFX_MAC10;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = SGM; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 100;
    AllGuns[gunIndex].ReloadTime = 156; // 2.6 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 11;
    AllGuns[gunIndex].yMuzzleFlashOffset = 10;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 47.5;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 17;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "MAC-10";
    gunIndex++;

    // MP5
    AllGuns[gunIndex].fireRate = 5; // 1 / 750 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.84;
    AllGuns[gunIndex].Damage = 25;
    AllGuns[gunIndex].texture = (void *)mp5_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 1500;
    AllGuns[gunIndex].gunSound = SFX_MP5;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = SGM; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;       // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 120;
    AllGuns[gunIndex].ReloadTime = 180; // 3 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 1;
    AllGuns[gunIndex].yMuzzleFlashOffset = 5;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 50;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 17;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "MP5";
    gunIndex++;

    // P90
    AllGuns[gunIndex].fireRate = 4; // 1 / 857 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.885;
    AllGuns[gunIndex].Damage = 25;
    AllGuns[gunIndex].texture = (void *)p90_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 2350;
    AllGuns[gunIndex].gunSound = SFX_P90;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = SGM; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;       // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 50;
    AllGuns[gunIndex].MaxAmmoCount = 100;
    AllGuns[gunIndex].ReloadTime = 198; // 3.3 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 5;
    AllGuns[gunIndex].yMuzzleFlashOffset = 6;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 75;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 17;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "P90";
    gunIndex++;

    // TMP
    AllGuns[gunIndex].fireRate = 4; // 1 / 857  * 3600
    AllGuns[gunIndex].DamageFalloff = 0.85;
    AllGuns[gunIndex].Damage = 19;
    AllGuns[gunIndex].texture = (void *)tmp_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 1250;
    AllGuns[gunIndex].gunSound = SFX_TMP;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = SGM; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;       // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 120;
    AllGuns[gunIndex].ReloadTime = 126; // 2.1 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 2;
    AllGuns[gunIndex].yMuzzleFlashOffset = 1;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 50;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 17;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "TMP";
    gunIndex++;

    // UMP-45
    AllGuns[gunIndex].fireRate = 6; // 1 / 571   * 3600
    AllGuns[gunIndex].DamageFalloff = 0.75;
    AllGuns[gunIndex].Damage = 29;
    AllGuns[gunIndex].texture = (void *)ump45_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 1250;
    AllGuns[gunIndex].gunSound = SFX_UMP45;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = SGM; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;       // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 25;
    AllGuns[gunIndex].MaxAmmoCount = 100;
    AllGuns[gunIndex].ReloadTime = 210; // 3.5 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 6;
    AllGuns[gunIndex].yMuzzleFlashOffset = 7;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 50;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 17;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "UMP-45";
    gunIndex++;

    // AK-47
    AllGuns[gunIndex].fireRate = 6; // 1 / 600 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.98;
    AllGuns[gunIndex].Damage = 35;
    AllGuns[gunIndex].texture = (void *)ak47_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 2500;
    AllGuns[gunIndex].gunSound = SFX_AK47;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = RIFLES; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS;    // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 205; // 2.43 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 2;
    AllGuns[gunIndex].yMuzzleFlashOffset = 2;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 77.5;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 23;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "AK-47";
    gunIndex++;

    // AUG
    AllGuns[gunIndex].fireRate = 6; // 1 / 666 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.96;
    AllGuns[gunIndex].Damage = 31;
    AllGuns[gunIndex].texture = (void *)aug_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 3500;
    AllGuns[gunIndex].gunSound = SFX_AUG;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = 1;
    AllGuns[gunIndex].gunCategory = RIFLES;     // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = COUNTERTERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 228; // 3.8 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -2;
    AllGuns[gunIndex].yMuzzleFlashOffset = 0;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 70;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 23;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0.5;
    AllGuns[gunIndex].name = "AUG";
    gunIndex++;

    // FAMAS
    AllGuns[gunIndex].fireRate = 6; // 1 / 666 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.96;
    AllGuns[gunIndex].Damage = 29;
    AllGuns[gunIndex].texture = (void *)famas_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 2250;
    AllGuns[gunIndex].gunSound = SFX_FAMAS;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = RIFLES;     // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = COUNTERTERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 25;
    AllGuns[gunIndex].MaxAmmoCount = 75;
    AllGuns[gunIndex].ReloadTime = 228; // 3.8 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -2;
    AllGuns[gunIndex].yMuzzleFlashOffset = 0;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 70;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 23;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "FAMAS";
    gunIndex++;

    // Galil
    AllGuns[gunIndex].fireRate = 6; // 1 / 666 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.98;
    AllGuns[gunIndex].Damage = 29;
    AllGuns[gunIndex].texture = (void *)galil_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 2000;
    AllGuns[gunIndex].gunSound = SFX_GALIL;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = RIFLES; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS;    // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 35;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 198; // 3.3 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 0;
    AllGuns[gunIndex].yMuzzleFlashOffset = 1;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 77;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 23;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "Galil";
    gunIndex++;

    // M4A1
    AllGuns[gunIndex].fireRate = 6; // 1 / 666 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.97;
    AllGuns[gunIndex].Damage = 31;
    AllGuns[gunIndex].texture = (void *)m4a1_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 3100;
    AllGuns[gunIndex].gunSound = SFX_M4A1;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = -1;
    AllGuns[gunIndex].gunCategory = RIFLES;     // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = COUNTERTERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 184; // 3.07 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -3;
    AllGuns[gunIndex].yMuzzleFlashOffset = 3;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 70;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 23;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0;
    AllGuns[gunIndex].name = "M4A1";
    gunIndex++;

    // SG 552
    AllGuns[gunIndex].fireRate = 6; // 1 / 666 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.955;
    AllGuns[gunIndex].Damage = 32;
    AllGuns[gunIndex].texture = (void *)sg552_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 3500;
    AllGuns[gunIndex].gunSound = SFX_SG552;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = 1;
    AllGuns[gunIndex].gunCategory = RIFLES; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS;    // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 174; // 2.9 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = 0;
    AllGuns[gunIndex].yMuzzleFlashOffset = 4;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 70;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 32;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0.6;
    AllGuns[gunIndex].name = "SG 552";
    gunIndex++;

    // SG 550
    AllGuns[gunIndex].fireRate = 15; // 1 / 240  * 3600
    AllGuns[gunIndex].DamageFalloff = 0.98;
    AllGuns[gunIndex].Damage = 69;
    AllGuns[gunIndex].texture = (void *)sg550_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 4200;
    AllGuns[gunIndex].gunSound = SFX_SG550;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = 1;
    AllGuns[gunIndex].gunCategory = RIFLES;     // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = COUNTERTERRORISTS; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 30;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 228; // 3.8 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -8;
    AllGuns[gunIndex].yMuzzleFlashOffset = 2;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 72.5;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 32;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0.6;
    AllGuns[gunIndex].name = "SG 550";
    gunIndex++;

    // Scout
    AllGuns[gunIndex].fireRate = 75; // 1 / 48   * 3600
    AllGuns[gunIndex].DamageFalloff = 0.98;
    AllGuns[gunIndex].Damage = 74;
    AllGuns[gunIndex].texture = (void *)scout_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 2750;
    AllGuns[gunIndex].gunSound = SFX_SCOUT;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = 0;
    AllGuns[gunIndex].gunCategory = RIFLES; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;          // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 10;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 174; // 2.9 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -4;
    AllGuns[gunIndex].yMuzzleFlashOffset = 3;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 85;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 32;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0.6;
    AllGuns[gunIndex].name = "Scout";
    gunIndex++;

    // G3SG1
    AllGuns[gunIndex].fireRate = 15; // 1 / 240 * 3600
    AllGuns[gunIndex].DamageFalloff = 0.98;
    AllGuns[gunIndex].Damage = 79;
    AllGuns[gunIndex].texture = (void *)g3sg1_bin;
    AllGuns[gunIndex].holdFireButton = true;
    AllGuns[gunIndex].Price = 5000;
    AllGuns[gunIndex].gunSound = SFX_G3SG1;
    AllGuns[gunIndex].WalkSpeed = MEDIUM_MEDIUM_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = 1;
    AllGuns[gunIndex].gunCategory = RIFLES; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = TERRORISTS;    // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 20;
    AllGuns[gunIndex].MaxAmmoCount = 90;
    AllGuns[gunIndex].ReloadTime = 282; // 4.7 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -4;
    AllGuns[gunIndex].yMuzzleFlashOffset = 4;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 82.5;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 32;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0.6;
    AllGuns[gunIndex].name = "G3SG1";
    gunIndex++;

    // AWP
    AllGuns[gunIndex].fireRate = 88; // 1 / 41  * 3600
    AllGuns[gunIndex].DamageFalloff = 0.99;
    AllGuns[gunIndex].Damage = 115;
    AllGuns[gunIndex].texture = (void *)awp_bin;
    AllGuns[gunIndex].holdFireButton = false;
    AllGuns[gunIndex].Price = 4750;
    AllGuns[gunIndex].gunSound = SFX_AWP;
    AllGuns[gunIndex].WalkSpeed = HEAVY_WEAPON_WALK_SPEED;
    AllGuns[gunIndex].scopeId = 0;
    AllGuns[gunIndex].gunCategory = RIFLES; // 0 pistols, 1 Heavy, 2 sgm, 3 rifles, 4 equipment, 5 grenades
    AllGuns[gunIndex].team = BOTH;          // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    AllGuns[gunIndex].MagazineCapacity = 10;
    AllGuns[gunIndex].MaxAmmoCount = 30;
    AllGuns[gunIndex].ReloadTime = 222; // 3.7 * 60
    AllGuns[gunIndex].xMuzzleFlashOffset = -7;
    AllGuns[gunIndex].yMuzzleFlashOffset = 3;
    AllGuns[gunIndex].isBigGun = true;
    AllGuns[gunIndex].MaxSoundDistance = 0.25;
    AllGuns[gunIndex].penetration = 97.5;
    AllGuns[gunIndex].bulletCountPerShoot = 1;
    AllGuns[gunIndex].maxBotShootDisance = 36;
    AllGuns[gunIndex].inaccuracyReductionForBot = 0.7;
    AllGuns[gunIndex].name = "AWP";
    gunIndex++;
}

```

`Counter-Strike-nds/source/weapons/data/gun_data.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef GUNS_DATA_H_ /* Include guard */
#define GUNS_DATA_H_

void LoadGuns();

#endif // GUNS_DATA_H_
```

`Counter-Strike-nds/source/weapons/equipment.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#include "main.h"
#include "equipment.h"
#include "data/equipment_data.h"

// Cost of the cheapest equipment
int cheapestEquipmentCost = 9999;

// Loaded equipment data
Equipment allEquipments[equipementCount];

void initEquipments()
{
    LoadEquipments();
}
```

`Counter-Strike-nds/source/weapons/equipment.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef EQUIPMENT_H_ /* Include guard */
#define EQUIPMENT_H_

//#include <NEMain.h>
//#include "main.h"

#define equipementCount 4 // 4 (bomb, defuser, kevlar, kevlar & headset)

enum EQUIPMENT_ENUM
{
    C4 = 0,
    DEFUSER = 1,
    KEVLAR_VEST = 2,
    KEVLAR_VEST_AND_HELMET = 3
};

typedef struct //
{
    void *texture;            // Equipment texture for shop
    int Price;                // Equipment price
    const char *name;         // Equipment name
    const char *description;  // Equipment description
    enum teamEnum team;       // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    bool isHided;             // Is hided from shop?
    enum EQUIPMENT_ENUM type; // Equipment type
} Equipment;

extern Equipment allEquipments[equipementCount];

void initEquipments();

#endif // EQUIPMENT_H_
```

`Counter-Strike-nds/source/weapons/grenade.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

//#include "main.h"
#include "main.h"
#include "grenade.h"
#include "data/grenade_data.h"
#include "sounds.h"
#include "raycast.h"
#include "collisions.h"
#include "player.h"
#include "party.h"

#define HE_GRENADE_DAMAGE 98
#define MOLOTOV_DURATION 480 // 8sec * 60 frames
#define SMOKE_DURATION 1080  // 18sec * 60 frames
#define HE_GRENADE_TIMER 126 // 2.1sec * 60 frames
#define FLASH_TIMER 120      // 2sec * 60 frames

int cheapestGrenadeCost = 9999;
Grenade AllGrenades[shopGrenadeCount];

/**
 * @brief Load grenades data
 *
 * @param grenades
 */
void initGrenades()
{
    LoadGrenades();

    for (int i = 0; i < shopGrenadeCount; i++)
    {
        if (AllGrenades[i].Price < cheapestGrenadeCost)
        {
            cheapestGrenadeCost = AllGrenades[i].Price;
        }
    }
}

/**
 * @brief Create a grenade
 *
 * @param id Grenade type
 * @param ownerId Player id who sent the grenade
 * @return PhysicalGrenade* Pointer of the new grenade (null if not created)
 */
PhysicalGrenade *CreateGrenade(int id, int ownerId)
{
    for (int i = 0; i < GrenadeCount; i++)
    {
        // If a slot is free
        if (grenades[i] == NULL)
        {
            // Alloc memory for the new grenade
            grenades[i] = malloc(sizeof(PhysicalGrenade));

            PhysicalGrenade *grenade = grenades[i];

            // Create the model and apply material
            grenade->Model = NE_ModelCreate(NE_Static);
            NE_ModelLoadStaticMesh(grenade->Model, (u32 *)grenade_3ds_bin);
            NE_ModelSetMaterial(grenade->Model, GroundMaterial);

            // Set scale and rotation
            NE_ModelScaleI(grenade->Model, 8, 8, 8);
            grenade->Model->rx = 128;
            grenade->Model->ry = 256;

            // Enable physics
            grenade->Physic = NE_PhysicsCreate(NE_BoundingBox);
            NE_PhysicsSetModel(grenade->Physic, (void *)grenade->Model);
            NE_PhysicsEnable(grenade->Physic, true);
            NE_PhysicsSetGravity(grenade->Physic, 0.0065);
            NE_PhysicsSetSize(grenade->Physic, 0.5, 0.5, 0.5);
            grenade->Physic->physicsgroup[0] = 1;
            grenade->Physic->physicsgroupCount = 1;
            NE_PhysicsSetFriction(grenade->Physic, 3);
            NE_PhysicsOnCollision(grenade->Physic, NE_ColBounce);
            NE_PhysicsSetBounceEnergy(grenade->Physic, 30);

            grenade->GrenadeType = id;

            // Set default values
            grenade->LastStairs = 0;
            grenade->isVisible = true;
            grenade->ownerId = ownerId;
            grenade->lastCollisionTimer = 0;
            grenade->effectAlpha = 30;

            if (grenade->GrenadeType == EXPLOSIVE) // If the grenade is an explosive grenade
            {
                // Create the explosion model and apply material
                grenade->EffectModel = NE_ModelCreate(NE_Static);
                NE_ModelLoadStaticMesh(grenade->EffectModel, (u32 *)explosion_bin);
                NE_ModelSetMaterial(grenade->EffectModel, GroundMaterial);

                // Set scale and rotation
                NE_ModelScaleI(grenade->EffectModel, 0, 0, 0);
                grenade->EffectModel->rx = 0;
                grenade->EffectModel->ry = 256;

                // Set grenade values
                grenade->Timer = 240;      // 4s * 60 frames
                grenade->EffectTimer = 30; // 0,5s * 60 frames
            }
            else if (grenade->GrenadeType == SMOKE) // If the grenade is a smoke grenade
            {
                // Create the explosion model and apply material
                grenade->EffectModel = NE_ModelCreate(NE_Static);
                NE_ModelLoadStaticMesh(grenade->EffectModel, (u32 *)smokeSphere_bin);
                NE_ModelSetMaterial(grenade->EffectModel, GroundMaterial);

                // Set scale and rotation
                NE_ModelScaleI(grenade->EffectModel, 0, 0, 0);
                grenade->EffectModel->rx = -128;

                // Set grenade values
                grenade->Timer = 480;
                grenade->EffectTimer = 1080;
            }
            else if (grenade->GrenadeType == FLASH) // If the grenade is a flash grenade
            {
                // Set grenade values
                grenade->Timer = 480;
                grenade->EffectTimer = 1;
            }

            // Return the new grenade
            return grenade;
        }
    }
    // The grenade array is full
    return NULL;
}

/**
 * @brief Launch a grenade
 *
 * @param grenade Grenade pointer
 * @param xDirection X direction of the grenade (INT value)
 * @param yDirection Y direction of the grenade (INT value)
 * @param zDirection Z direction of the grenade (INT value)
 * @param xPosition X position of the grenade (INT value)
 * @param yPosition Y position of the grenade (INT value)
 * @param zPosition Z position of the grenade (INT value)
 */
void lanchGrenade(PhysicalGrenade *grenade, float xDirection, float yDirection, float zDirection, int xPosition, int yPosition, int zPosition)
{
    grenade->Physic->xspeed = xDirection * 2200;
    grenade->Physic->yspeed = yDirection * 2500;
    grenade->Physic->zspeed = zDirection * 2200;

    grenade->Model->x = xPosition + xDirection * 4096;
    grenade->Model->y = yPosition + 0.7 * 4096 + yDirection * 4096;
    grenade->Model->z = zPosition + zDirection * 4096;
}

/**
 * @brief Delete all spawned grenades
 *
 */
void DeleteAllGrenade()
{
    for (int i = 0; i < GrenadeCount; i++)
    {
        DeleteGrenade(i);
    }
}

/**
 * @brief Delete a spawned grenade
 *
 * @param grenadeIndex Grenade index
 */
void DeleteGrenade(int grenadeIndex)
{
    PhysicalGrenade *grenade = grenades[grenadeIndex];
    if (grenade != NULL)
    {
        // Delete the model
        NE_ModelDelete(grenade->Model);
        grenade->Model = NULL;
        // Delete the physics component
        NE_PhysicsDelete(grenade->Physic);
        grenade->Physic = NULL;

        // Delete the effect model
        if (grenade->EffectModel != NULL && (grenade->GrenadeType == EXPLOSIVE || grenade->GrenadeType == SMOKE))
        {
            NE_ModelDelete(grenade->EffectModel);
            grenade->EffectModel = NULL;
        }

        // Free the grenade
        free(grenades[grenadeIndex]);
        grenades[grenadeIndex] = NULL;
    }
}

/**
 * @brief Update all spawned grenades
 *
 */
void UpdateGrenades()
{
    for (int i = 0; i < GrenadeCount; i++)
    {
        PhysicalGrenade *grenade = grenades[i];

        if (grenade == NULL)
            continue;

        // If the physics component is enabled
        if (grenade->Physic->enabled)
        {
            bool isOnStairs = CheckStairsForGrenades(grenade);
            int totalSpeed = abs(grenade->Physic->xspeed) + abs(grenade->Physic->yspeed) + abs(grenade->Physic->zspeed);
            if (totalSpeed == 0 && !isOnStairs) // If the grenade is not moving and is not on stairs
            {
                // Disable the physics component
                NE_PhysicsEnable(grenade->Physic, false);
                // Start Smoke or flash effect
                if (grenade->GrenadeType == SMOKE || grenade->GrenadeType == FLASH)
                {
                    grenade->Timer = 20;
                }
            }
            else
            {
                // Update the physics component
                NE_PhysicsUpdate(grenade->Physic);

                // If the grenade collide with a wall
                if (grenade->Physic->iscollidingTrigger && grenade->lastCollisionTimer == 0)
                {
                    // Do a collision sound
                    grenade->lastCollisionTimer = 10;
                    PlayBasicSound(AllGrenades[0].collisionSound);
                }
                else if (grenade->lastCollisionTimer > 0)
                    grenade->lastCollisionTimer--;
            }

            // Rotate the grenade
            totalSpeed /= 15.0;
            if (totalSpeed >= 6)
                totalSpeed = 6;

            grenade->Model->rx += totalSpeed;
            grenade->Model->ry += totalSpeed;
        }

        // If the timer is 0
        if (grenade->Timer == 0)
        {
            if (grenade->GrenadeType == EXPLOSIVE)
            {
                // Do an explosion

                // Set explosion scale
                int Scale = 1024 * (30 - grenade->EffectTimer);
                NE_ModelScaleI(grenade->EffectModel, Scale, Scale, Scale);

                grenade->effectAlpha = grenade->EffectTimer;

                // At the beginning of the explosion
                if (grenade->EffectTimer == 30 && Connection == OFFLINE)
                {
                    for (int playerIndex = 0; playerIndex < MaxPlayer; playerIndex++)
                    {
                        Player *player = &AllPlayers[playerIndex];
                        if (player->IsDead || player->Id == NO_PLAYER || player->Team == BOTH)
                            continue;

                        // Get the distance between the grenade and the player
                        float Distance = (float)sqrt(pow(player->PlayerModel->x - grenade->Model->x, 2.0) + pow(player->PlayerModel->y - grenade->Model->y, 2.0) + pow(player->PlayerModel->z - grenade->Model->z, 2.0)) / 8096.0;

                        // Set a maximum distance
                        if (Distance > 4)
                            Distance = 0;

                        if (Distance > 0)
                        {
                            // Apply damage
                            int newHealh = player->Health - (int)map(Distance, 0.3, 4, 100, 0);
                            setPlayerHealth(playerIndex, newHealh);
                            checkAfterDamage(NO_PLAYER, playerIndex, false);
                        }
                    }
                }
            }
            else if (grenade->GrenadeType == SMOKE)
            {
                // Do a smoke effect
                int coef = grenade->EffectTimer;
                int Scale = 0;
                int alpha = 31;
                if (coef <= 90)
                    alpha = coef / 3.0;
                if (coef < 1040)
                    coef = 1040;

                // if (coef >= 1040)
                Scale = 5 * (1080 - coef);

                // Set effect alpha and scale
                grenade->effectAlpha = alpha;
                NE_ModelScaleI(grenade->EffectModel, Scale, Scale, Scale);
            }
            else if (grenade->GrenadeType == FLASH)
            {
                // Do a flash effect
                for (int playerIndex = 0; playerIndex < MaxPlayer; playerIndex++)
                {
                    Player *player = &AllPlayers[playerIndex];
                    if (player->IsDead || player->Id == NO_PLAYER)
                        continue;

                    // Check if the flash grenade is visible at screen (the code may be difficult to understand, but it works (but not very well ahah))

                    // Get the distance between the grenade and the player
                    float distance3D = sqrtf(powf(player->PlayerModel->x - grenade->Model->x, 2.0) + powf(player->PlayerModel->y - grenade->Model->y, 2.0) + powf(player->PlayerModel->z - grenade->Model->z, 2.0)); // For vertical flash detection (Include player Y positon)
                    float distance2D = sqrtf(powf(player->PlayerModel->x - grenade->Model->x, 2.0) + powf(player->PlayerModel->z - grenade->Model->z, 2.0));                                                         // For horizontal flash detection

                    // Get direction of grenade
                    Vector3 Direction;
                    Direction.x = grenade->Model->x - player->PlayerModel->x;
                    Direction.y = grenade->Model->y - (player->PlayerModel->y + CameraOffsetY * 4096.0);
                    Direction.z = grenade->Model->z - player->PlayerModel->z;

                    // Calculate angle direction (camera & player angles to have the grenade at the center of the screen)
                    float PlayerAngleToGrenadeDirection = atan2f(Direction.x, Direction.z) * 512.0 / (M_TWOPI) + 256.0;
                    float CameraAngleToGrenadeDirection = atan2f(distance2D, Direction.y) * 512.0 / (M_TWOPI);

                    // Use exponential to increase/decrease angle offset more quickly when the player is close to the grenade
                    float horizontalExpDistance = exp(4000.0 / distance2D);
                    if (horizontalExpDistance > 8.5333)
                        horizontalExpDistance = 8.5333;

                    float verticalExpDistance = exp(4000.0 / distance3D);
                    if (verticalExpDistance > 8.5333)
                        verticalExpDistance = 8.5333;

                    // Add offsets from center angles and fix angles (limit angles from 0 to 512 max)
                    // For horizontal check
                    float fixedHorizontalExpDistance = 60.0 * horizontalExpDistance;
                    int xAngleFinalSideA = (int)(PlayerAngleToGrenadeDirection + fixedHorizontalExpDistance) % 512;
                    if (xAngleFinalSideA < 0)
                    {
                        xAngleFinalSideA = 512 + xAngleFinalSideA;
                    }

                    int xAngleFinalSideB = (int)(PlayerAngleToGrenadeDirection + fixedHorizontalExpDistance) % 512;
                    if (xAngleFinalSideB < 0)
                    {
                        xAngleFinalSideB = 512 + xAngleFinalSideB;
                    }

                    // For vertical check
                    float fixedVerticalExpDistance = 50.0 * verticalExpDistance;
                    int xAngleFinalVerticalSideA = (int)(CameraAngleToGrenadeDirection + fixedVerticalExpDistance) % 512;
                    int xAngleFinalVerticalSideB = (int)(CameraAngleToGrenadeDirection - fixedVerticalExpDistance) % 512;

                    // Fix player angle (limit the angle from 0 to 512 max)
                    int fixePlayerAngle = (int)AllPlayers[CurrentCameraPlayer].Angle % 512; // TODO MAYBE USE player->Angle
                    if (fixePlayerAngle < 0)
                        fixePlayerAngle = 512 + fixePlayerAngle;

                    // Temp var
                    bool isAtScreenHorizontalSideA = false;
                    bool isAtScreenHorizontalSideB = false;
                    bool isAtScreenVerticalSideA = false;
                    bool isAtScreenVerticalSideB = false;

                    // Check top and bottom side with camera rotation
                    if (xAngleFinalVerticalSideA >= AllPlayers[CurrentCameraPlayer].cameraAngle)
                        isAtScreenVerticalSideA = true;

                    if (xAngleFinalVerticalSideB <= AllPlayers[CurrentCameraPlayer].cameraAngle)
                        isAtScreenVerticalSideB = true;

                    if (horizontalExpDistance < 4)
                    {
                        // Check left and right side with fixed player rotation
                        if (xAngleFinalSideA > xAngleFinalSideB)
                        {
                            if (xAngleFinalSideA >= fixePlayerAngle)
                                isAtScreenHorizontalSideA = true;

                            if (xAngleFinalSideB <= fixePlayerAngle)
                                isAtScreenHorizontalSideB = true;
                        }
                        else // Change conditions if values AngleB is greater than AngleA
                        {
                            if (xAngleFinalSideA <= fixePlayerAngle)
                                isAtScreenHorizontalSideA = true;

                            if (xAngleFinalSideB <= fixePlayerAngle)
                                isAtScreenHorizontalSideB = true;

                            // If in this case both are false, the player is looking at the grenade (horizontal)
                            if (!isAtScreenHorizontalSideA && !isAtScreenHorizontalSideB)
                            {
                                isAtScreenHorizontalSideA = true;
                                isAtScreenHorizontalSideB = true;
                            }
                        }
                    }
                    else
                    {
                        isAtScreenHorizontalSideA = true;
                        isAtScreenHorizontalSideB = true;
                    }
                    Vector3Int playerCameraPos = {(int)player->PlayerModel->x, (int)player->PlayerModel->y + CameraOffsetYMultiplied, (int)player->PlayerModel->z};
                    Vector3Int grenadeCameraPos = {(int)grenade->Model->x, (int)grenade->Model->y, (int)grenade->Model->z};

                    float x2 = 0, y2 = 0, z2 = 0;
                    getValuesForRaycast(playerCameraPos, grenadeCameraPos, &x2, &y2, &z2);
                    setRaycastValues(player, x2, y2, z2);
                    player->ScanForGrenade = i;
                    float hitDistance = 0;
                    int foundGrenade = Raycast(playerIndex, 0, &hitDistance);
                    player->ScanForGrenade = EMPTY;

                    // Merge all check variables into one
                    player->flashed = isAtScreenHorizontalSideA && isAtScreenHorizontalSideB && isAtScreenVerticalSideA && isAtScreenVerticalSideB && foundGrenade != EMPTY;
                    player->flashAnimation = 0;
                }
            }

            grenade->EffectTimer--;

            // Destroy the grenade at the end of the effect
            if (grenade->EffectTimer == 0)
            {
                DeleteGrenade(i);
            }
        }
        else if (grenade->Timer == 1)
        {
            // Play the effect sound
            PlayBasicSound(AllGrenades[grenade->GrenadeType].finalSound);

            // Set effect model positon
            if (grenade->GrenadeType == SMOKE || grenade->GrenadeType == EXPLOSIVE)
            {
                grenade->EffectModel->x = grenade->Model->x;
                grenade->EffectModel->y = grenade->Model->y;
                grenade->EffectModel->z = grenade->Model->z;
            }

            grenade->Timer--;
            // Hide the grenade
            grenade->isVisible = false;
        }
        else
        {
            grenade->Timer--;
        }
    }
}

```

`Counter-Strike-nds/source/weapons/grenade.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef GRENADE_H_ /* Include guard */
#define GRENADE_H_

//#include <NEMain.h>
#include <maxmod9.h>
//#include "main.h"
//#include "main.h"
#define shopGrenadeCount 3

enum GRENADE_ENUM
{
    EXPLOSIVE = 0,
    SMOKE = 1,
    FLASH = 2
};

typedef struct //
{
    void *texture;
    int Price;
    const char *name;
    const char *description;
    enum GRENADE_ENUM type;
    int maxQuantity[3];
    mm_word collisionSound;
    mm_word finalSound;
    int team; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
} Grenade;

typedef struct
{
    NE_Model *Model;
    NE_Physics *Physic;
    NE_Model *EffectModel;
    int GrenadeType;
    int Timer;
    int EffectTimer;
    int effectAlpha;        //
    bool isVisible;         //
    int lastCollisionTimer; //
    int LastStairs;         //
    int ownerId;            //
} PhysicalGrenade;

extern Grenade AllGrenades[shopGrenadeCount];

void initGrenades();
PhysicalGrenade *CreateGrenade(int id, int ownerId);
void DeleteGrenade(int grenadeIndex);
void lanchGrenade(PhysicalGrenade *grenade, float xDirection, float yDirection, float zDirection, int xPosition, int yPosition, int zPosition);
void UpdateGrenades();
void DeleteAllGrenade();

#endif // GRENADE_H_
```

`Counter-Strike-nds/source/weapons/gun.c`:

```c
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

//#include "main.h"
#include "gun.h"
#include "data/gun_data.h"
#include "sounds.h"
#include "ui.h"
#include "party.h"
#include "network.h"
#include "equipment.h"
#include "player.h"
#include "draw3d.h"

// Loaded guns data
Gun AllGuns[GunCount];

// Cheapest gun of each category for counters terrorists
int cheapestGunsCostCounter[4];
// Cheapest gun of each category for terrorists
int cheapestGunsCostTerrorists[4];
// Gun count for each category for counters terrorists
int gunCountCounter[4];
// Gun count for each category for terrorists
int gunCountTerrorists[4];

/**
 * @brief Load guns data
 *
 */
void initGuns()
{
    LoadGuns();
    // Reset cheapest guns cost list
    for (int i = 0; i < 4; i++)
    {
        cheapestGunsCostTerrorists[i] = 9999;
        cheapestGunsCostCounter[i] = 9999;
    }

    // Get cheapest and gun count for each category
    for (int i = 1; i < GunCount; i++)
    {
        Gun *gun = &AllGuns[i];

        if (gun->team == COUNTERTERRORISTS || gun->team == BOTH)
        {
            gunCountCounter[gun->gunCategory]++;
            // If the current gun price is lower than the cheapest gun
            if (gun->Price < cheapestGunsCostCounter[gun->gunCategory])
            {
                // Set the new cheapest gun price
                cheapestGunsCostCounter[gun->gunCategory] = gun->Price;
            }
        }
        if (gun->team == TERRORISTS || gun->team == BOTH)
        {
            gunCountTerrorists[gun->gunCategory]++;
            // If the current gun price is lower than the cheapest gun
            if (gun->Price < cheapestGunsCostTerrorists[gun->gunCategory])
            {
                // Set the new cheapest gun price
                cheapestGunsCostTerrorists[gun->gunCategory] = gun->Price;
            }
        }
    }
}

/**
 * @brief Reload the current gun of a player
 *
 * @param playerIndex Index of the player to reload
 */
void ReloadGun(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    // Check if the weapon in the player hands is a gun
    if (player->currentGunInInventory == 1 || player->currentGunInInventory == 2)
    {
        int ammoIndex = player->currentGunInInventory - 1;
        // Get how many ammo are missing
        int missingAmmoCount = getPlayerCurrentGun(player).MagazineCapacity - player->AllAmmoMagazine[ammoIndex].AmmoCount;
        if (missingAmmoCount < player->AllAmmoMagazine[ammoIndex].TotalAmmoCount)
        {
            player->AllAmmoMagazine[ammoIndex].AmmoCount += missingAmmoCount;
            if (!allPartyModes[currentPartyMode].infiniteGunAmmo)
                player->AllAmmoMagazine[ammoIndex].TotalAmmoCount -= missingAmmoCount;
        }
        else
        {
            player->AllAmmoMagazine[ammoIndex].AmmoCount += player->AllAmmoMagazine[ammoIndex].TotalAmmoCount;
            player->AllAmmoMagazine[ammoIndex].TotalAmmoCount = 0;
        }
    }
    if (player == localPlayer)
    {
        SendReloaded = true;
    }
}

/**
 * @brief Set the aim to the local player
 *
 */
void SetAim()
{
    doubleTapTimer = 0;
    if (getPlayerCurrentGunIndex(localPlayer) < GunCount && getPlayerCurrentGun(localPlayer).scopeId != -1)
    {
        if (CurrentScopeLevel < AllScopeLevels[getPlayerCurrentGun(localPlayer).scopeId].scopeCount)
        {
            // Change fov
            CurrentScopeLevel++;
            NE_SetFov(AllScopeLevels[getPlayerCurrentGun(localPlayer).scopeId].fov[CurrentScopeLevel - 1]);
            // Make scope sound
            PlayBasicSound(SFX_SCOPE);
        }
        else
        {
            DisableAim();
        }
    }
}

/**
 * @brief Apply gun y offset
 *
 */
void applyGunAnimation()
{
    // Set gun sprite offset position
    if (yOffset < 0.1)
        yOffset += (rand() % 2 + 2) / 100.0;
    else if (yOffset < 0.16)
        yOffset += (rand() % 2 + 2) / 150.0;
    else
        yOffset += (rand() % 2 + 2) / 200.0;
}

/**
 * @brief Disable aiming
 *
 */
void DisableAim()
{
    CurrentScopeLevel = 0;
    // Set default fov
    // TODO make const value
    NE_SetFov(70);
}

int getPlayerCurrentGunIndex(Player *player)
{
    return player->AllGunsInInventory[player->currentGunInInventory];
}

Gun getPlayerCurrentGun(Player *player)
{
    return AllGuns[player->AllGunsInInventory[player->currentGunInInventory]];
}

/**
 * @brief Buy a random gun of a category for a player
 *
 * @param gunCategory Gun category to buy
 * @param playerIndex Index of the player to buy the gun for
 */
void findGun(int gunCategory, int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    int gunFound = -1;
    while (gunFound == -1)
    {
        int random2;
        // Get a random index from the gun count of the category
        if (player->Team == COUNTERTERRORISTS)
        {
            random2 = rand() % gunCountCounter[gunCategory];
        }
        else
        {
            random2 = rand() % gunCountTerrorists[gunCategory];
        }

        int count = 0;
        for (int i2 = 0; i2 < GunCount; i2++)
        {
            if (AllGuns[i2].gunCategory == gunCategory && (AllGuns[i2].team == player->Team || AllGuns[i2].team == BOTH))
            {
                // if the player has enough money
                if (count == random2 && AllGuns[i2].Price <= player->Money)
                {
                    // Return the gun index
                    gunFound = i2;
                    break;
                }
                else
                    count++;
            }
        }
    }

    // Reduce money
    reducePlayerMoney(playerIndex, AllGuns[gunFound].Price);

    // Set the gun in the inventory
    if (gunCategory == 0)
    {
        AllPlayers[playerIndex].AllGunsInInventory[1] = gunFound;
        AllPlayers[playerIndex].currentGunInInventory = 1;
    }
    else
    {
        AllPlayers[playerIndex].AllGunsInInventory[2] = gunFound;
        AllPlayers[playerIndex].currentGunInInventory = 2;
    }

    // Reset new gun ammo
    ResetGunsAmmo(playerIndex);

    // Set the gun texture at screen
    if (playerIndex == 0)
    {
        UpdateGunTexture();
    }
}

/**
 * @brief Reset gun ammo (set ammo to max capacity)
 *
 * @param playerIndex Index of the player to reset the ammo for
 * @param inventoryIndex Index of the inventory to reset the ammo for
 */
void ResetGunAmmo(int playerIndex, int inventoryIndex)
{
    if (inventoryIndex < 1 || inventoryIndex > 2)
        return;

    Player *player = &AllPlayers[playerIndex];

    // Set the ammo to max capacity
    int ammoIndex = inventoryIndex - 1;
    player->AllAmmoMagazine[ammoIndex].AmmoCount = AllGuns[AllPlayers[playerIndex].AllGunsInInventory[inventoryIndex]].MagazineCapacity;
    player->AllAmmoMagazine[ammoIndex].TotalAmmoCount = AllGuns[AllPlayers[playerIndex].AllGunsInInventory[inventoryIndex]].MaxAmmoCount;
}

/**
 * @brief
 *
 * @param playerIndex
 */
void ResetGunsAmmo(int playerIndex)
{
    Player *player = &AllPlayers[playerIndex];
    for (int ammoIndex = 0; ammoIndex < 2; ammoIndex++)
    {
        int inventoryIndex = ammoIndex + 1;
        if (player->AllGunsInInventory[inventoryIndex] != -1)
        {
            // Set the ammo to max capacity
            player->AllAmmoMagazine[ammoIndex].AmmoCount = AllGuns[AllPlayers[playerIndex].AllGunsInInventory[inventoryIndex]].MagazineCapacity;
            player->AllAmmoMagazine[ammoIndex].TotalAmmoCount = AllGuns[AllPlayers[playerIndex].AllGunsInInventory[inventoryIndex]].MaxAmmoCount;
        }
    }
}

/**
 * @brief Set gun recoil
 *
 * @param player Player pointer to set the recoil for
 */
void setGunRecoil(Player *player)
{
    // If the gun is a dual gun, swap the recoil
    if (getPlayerCurrentGun(player).isDualGun)
        player->isRightGun = !player->isRightGun;
    else
        player->isRightGun = true;

    // Set the recoil
    if (player->isRightGun)
    {
        player->rightGunXRecoil = GunMaxRecoil;
        player->rightGunYRecoil = GunMaxRecoil;
    }
    else
    {
        player->leftGunXRecoil = GunMaxRecoil;
        player->leftGunYRecoil = GunMaxRecoil;
    }

    // Set muzzle flash and rumble
    if (player == &AllPlayers[CurrentCameraPlayer])
    {
        ShowMuzzle = 3;
        rumble(1);
    }
}

/**
 * @brief Stop gun reloading
 *
 * @param playerIndx Player index
 */
void StopReloading(int playerIndx)
{
    AllPlayers[playerIndx].isReloading = false;
}

/**
 * @brief Start gun reloading
 *
 * @param playerIndx Player index
 */
void startReloadGun(int playerIndx)
{
    if (playerIndx == 0)
    {
        DisableAim();
    }
    Player *player = &AllPlayers[playerIndx];
    if (player->currentGunInInventory == 1 || player->currentGunInInventory == 2)
    {
        if (!player->isReloading && getPlayerCurrentGun(player).MagazineCapacity != player->AllAmmoMagazine[player->currentGunInInventory - 1].AmmoCount && player->AllAmmoMagazine[player->currentGunInInventory - 1].TotalAmmoCount != 0)
        {
            player->GunReloadWaitCount = 0;
            player->isReloading = true;
        }
    }
}

/**
 * @brief Update weapons/grenades texture
 *
 */
void UpdateGunTexture()
{
    Player *viewedPlayer = &AllPlayers[CurrentCameraPlayer];
    if (viewedPlayer->AllGunsInInventory[viewedPlayer->currentGunInInventory] != EMPTY)
    {
        // unload old texture
        if (TopScreenSpritesMaterials[1] != NULL)
        {
            NE_MaterialDelete(TopScreenSpritesMaterials[1]);
            NE_PaletteDelete(Palettes[4]);
        }

        // Reserve memory for new texture
        TopScreenSpritesMaterials[1] = NE_MaterialCreate();
        Palettes[4] = NE_PaletteCreate();

        //  Load new texture
        if (getPlayerCurrentGunIndex(viewedPlayer) < GunCount)
            NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[1], Palettes[4], getPlayerCurrentGun(viewedPlayer).texture, 1); // Load gun texture
        else if (getPlayerCurrentGunIndex(viewedPlayer) < GunCount + shopGrenadeCount)
            NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[1], Palettes[4], AllGrenades[getPlayerCurrentGunIndex(viewedPlayer) - GunCount].texture, 1); // Load grenade texture
        else
            NE_MaterialTexLoadBMPtoRGB256(TopScreenSpritesMaterials[1], Palettes[4], allEquipments[getPlayerCurrentGunIndex(viewedPlayer) - GunCount - shopGrenadeCount].texture, 1); // Load equipment texture
    }
}
```

`Counter-Strike-nds/source/weapons/gun.h`:

```h
// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021-2022, Fewnity - Grégory Machefer
//
// This file is part of Counter Strike Nintendo DS Multiplayer Edition (CS:DS)

#ifndef GUN_H_ /* Include guard */
#define GUN_H_

#include "main.h"

typedef struct //
{
    int fireRate;
    void *texture;
    float DamageFalloff;
    int Damage;
    float penetration;
    bool holdFireButton;
    int Price;
    const char *name;
    bool isKnife;
    mm_word gunSound;
    int WalkSpeed;
    int scopeId;
    int gunCategory;
    enum teamEnum team; // 0 for terrorist only, 1 for counter terrorists only, -1 for both teams
    int MagazineCapacity;
    int MaxAmmoCount;
    int ReloadTime;
    float MaxSoundDistance;
    int xMuzzleFlashOffset;
    int yMuzzleFlashOffset;
    bool isBigGun;
    bool isDualGun;
    int bulletCountPerShoot;
    int maxBotShootDisance;
    float inaccuracyReductionForBot; //[0;1]
} Gun;

extern int cheapestGunsCostCounter[4];
extern int cheapestGunsCostTerrorists[4];
extern int gunCountCounter[4];
extern int gunCountTerrorists[4];
extern Gun AllGuns[GunCount];

void initGuns();
void ReloadGun(int playerId);
void SetAim();
void DisableAim();
void ResetGunAmmo(int playerId, int inventoryIndex);
void ResetGunsAmmo(int playerId);
void findGun(int gunCategory, int playerIndex);
Gun getPlayerCurrentGun(Player *player);
int getPlayerCurrentGunIndex(Player *player);
void setGunRecoil(Player *player);
void UpdateGunTexture();
void startReloadGun(int playerIndx);
void StopReloading(int playerIndx);

#endif // GUN_H_
```

`README.md`:

```md
# Counter Strike Nintendo DS
**Counter Strike demake on Nintendo DS with online multiplayer** (Works on **emulator** and on **real hardware**).

For **multiplayer** on **emulator**, please use [melonDS](https://melonds.kuribo64.net/downloads.php).<br/>
There is no emulator with **online** support on **Android** at this time.<br/>
**Ad hoc (Ni-Fi) multiplayer** is not supported (I'm looking for help with that!)<br/>

![image](https://user-images.githubusercontent.com/39272935/176778790-14707835-d15d-473b-baeb-3cb51864b004.png)
![image](https://user-images.githubusercontent.com/39272935/176778935-59555499-c40e-4325-83f8-8d89778a75af.png)

## How to install the game

### On DS flashcard
1. Put the .nds on the microSD card
2. Put soundbank.bin and counter_strike_music.raw on the root of the microSD card

### On DSi/3DS SD card
1. Install [TWiLight Menu++](https://wiki.ds-homebrew.com/twilightmenu/installing)
2. Put the .nds on the SD card
3. Put soundbank.bin and counter_strike_music.raw on the root of the SD card
4. In TWiLight Menu++, find the game and press Y on it
5. Set **Run in** to **DS mode*

### On emulator (melonDS) :
To have sounds and music, you need to use a virtual SD card, because sounds and music are not included in the .nds file.

- Set in the DLDI settings (**Config**->**Emu settings**->**DLDI**) the counter_strike_sd.raw file as SD card. Or create your own [here](https://melonds.kuribo64.net/board/thread.php?pid=2902) and put soundbank.bin and counter_strike_music.raw in the virtual SD card

## Network Setup
- Create a Wi-Fi network without a password or with WEP security. You can use your Android phone, a compatible router, or a Linux/MacOS computer with Wi-Fi adapter to do a hotspot
### On DS
1. Start a game that **supports online multiplayer** like **Mario Kart DS**
2. Open the **Wi-Fi setup** and select an available Wi-Fi slot
3. Search for an access point and add your Wi-Fi

### On DSi
1. Open **System Settings**
2. Open **Internet**
3. Open **Connection Settings**
4. Select an available Wi-Fi slot (it must be Connection 1, 2, or 3!)
5. Search for an access point and add your Wi-Fi

### On 3DS
1. Open **Settings**
2. Open **Internet Settings**
3. Open the **Nintendo DS Connection** menu and select an available Wi-Fi slot
4. Search for an access point and add your Wi-Fi

## How to compile the game
1. Install [DevKitPro](https://github.com/devkitPro/installer/releases/latest) and check the **NDS Development** option
2. Download the modified version of Nitro Engine [here](https://github.com/Fewnity/nitro-engine) and put the folder like this : **"C:\devkitPro\nitro-engine"**
3. Compile the engine (Open a **CMD**, write **"cd C:\devkitPro\nitro-engine"** then **"make"**)
4. Put the game source code folder in **"C:\devkitPro\nitro-engine\examples"**
5. Compile the game (Open a **CMD**, write **"cd C:\devkitPro\nitro-engine\examples\Counter-Strike-nds"** then **"make"**)
6. Copy the **Counter-Strike-nds.nds** from the project folder and the **soundbank.bin** file from the build folder

Note : To avoid coding collisions, path finding..., there is an Unity project to export code : https://github.com/Fewnity/Counter-Strike-DS-Unity-Project

## TODO
- [ ] Ad hoc (Ni-Fi) multiplayer : **Difficult**
- [ ] Disable sleep mode in multiplayer : **?**
- [ ] Add fall damage : **Easy**
- [ ] Smoke doesn't affect bots at this time : **Easy**
- [ ] Online chat (empty menu already exists) : **Medium**
- [ ] Create a NitroFS version for sounds and musics (and keep the FAT version for better compatibility) : **Medium**
- [ ] Put data in JSON files (weapons/equipments/bots names/ai waypoints) : **Medium**
- [ ] Add Wingman mode : **Medium**
- [ ] Add input profiles : **Medium**
- [ ] Possibility to change cursor : **Medium**
- [ ] Add bot difficulty : **Medium/Difficult**
- [ ] Translate system : **Medium/Difficult**
- [ ] Add more maps : **Difficult**
- [ ] Optimise the map with a tiled textures system instead of duplicate model faces : **Difficult**

```