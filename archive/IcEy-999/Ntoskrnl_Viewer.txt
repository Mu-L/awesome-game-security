Project Path: arc_IcEy-999_Ntoskrnl_Viewer_tt1deca5

Source Tree:

```txt
arc_IcEy-999_Ntoskrnl_Viewer_tt1deca5
├── Release
│   ├── 0
│   ├── CES.exe
│   ├── Ceydbg_drive.sys
│   ├── d_test.png
│   ├── d_test2.png
│   ├── win10_test.png
│   ├── win11_test.png
│   └── x_test.png
├── Ring 0
│   ├── 0
│   ├── CeyDbg.h
│   ├── Ceydbg_drive.inf
│   ├── Ceydbg_drive.sln
│   ├── Ceydbg_drive.vcxproj
│   ├── Ceydbg_drive.vcxproj.filters
│   ├── Ceydbg_drive.vcxproj.user
│   └── main.c
├── Ring 3
│   ├── CES
│   │   ├── CES.vcxproj
│   │   ├── CES.vcxproj.filters
│   │   ├── CES.vcxproj.user
│   │   ├── Ceydbg.h
│   │   ├── DriveRelated.cpp
│   │   ├── PdbRelated.cpp
│   │   ├── function.cpp
│   │   └── main.cpp
│   └── IC_Ntoskrnl_Viewer.sln
└── readme.md

```

`Release/0`:

```
0

```

`Ring 0/0`:

```
0

```

`Ring 0/CeyDbg.h`:

```h
#pragma once
#include <ntddk.h>


#define my_device_name  L"\\Device\\CEYDBG"//设备名
#define my_link_name L"\\??\\CEYDBG"//符号链接名

#define GET_BASE CTL_CODE(FILE_DEVICE_UNKNOWN,0x99f,METHOD_NEITHER,FILE_ANY_ACCESS)//
#define GET_VALUE CTL_CODE(FILE_DEVICE_UNKNOWN,0x99e,METHOD_NEITHER,FILE_ANY_ACCESS)//读0x80字节数据

```

`Ring 0/Ceydbg_drive.inf`:

```inf
;
; Ceydbg_drive.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Ceydbg_drive.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
Ceydbg_drive_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Ceydbg_drive.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Ceydbg_drive.DeviceDesc%=Ceydbg_drive_Device, Root\Ceydbg_drive ; TODO: edit hw-id

[Ceydbg_drive_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Ceydbg_drive.sys

;-------------- Service installation
[Ceydbg_drive_Device.NT.Services]
AddService = Ceydbg_drive,%SPSVCINST_ASSOCSERVICE%, Ceydbg_drive_Service_Inst

; -------------- Ceydbg_drive driver install sections
[Ceydbg_drive_Service_Inst]
DisplayName    = %Ceydbg_drive.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Ceydbg_drive.sys

;
;--- Ceydbg_drive_Device Coinstaller installation ------
;

[Ceydbg_drive_Device.NT.CoInstallers]
AddReg=Ceydbg_drive_Device_CoInstaller_AddReg
CopyFiles=Ceydbg_drive_Device_CoInstaller_CopyFiles

[Ceydbg_drive_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Ceydbg_drive_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Ceydbg_drive_Device.NT.Wdf]
KmdfService =  Ceydbg_drive, Ceydbg_drive_wdfsect
[Ceydbg_drive_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Ceydbg_drive Installation Disk"
Ceydbg_drive.DeviceDesc = "Ceydbg_drive Device"
Ceydbg_drive.SVCDESC = "Ceydbg_drive Service"

```

`Ring 0/Ceydbg_drive.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ceydbg_drive", "Ceydbg_drive.vcxproj", "{41D81868-F233-40EF-B0A3-2C87249A529B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|ARM.ActiveCfg = Debug|ARM
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|ARM.Build.0 = Debug|ARM
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|ARM.Deploy.0 = Debug|ARM
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|ARM64.Build.0 = Debug|ARM64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|x64.ActiveCfg = Debug|x64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|x64.Build.0 = Debug|x64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|x64.Deploy.0 = Debug|x64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|x86.ActiveCfg = Debug|Win32
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|x86.Build.0 = Debug|Win32
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Debug|x86.Deploy.0 = Debug|Win32
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|ARM.ActiveCfg = Release|ARM
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|ARM.Build.0 = Release|ARM
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|ARM.Deploy.0 = Release|ARM
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|ARM64.ActiveCfg = Release|ARM64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|ARM64.Build.0 = Release|ARM64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|ARM64.Deploy.0 = Release|ARM64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|x64.ActiveCfg = Release|x64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|x64.Build.0 = Release|x64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|x64.Deploy.0 = Release|x64
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|x86.ActiveCfg = Release|Win32
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|x86.Build.0 = Release|Win32
		{41D81868-F233-40EF-B0A3-2C87249A529B}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {778E39BB-48C3-450A-A33D-BA876F13C46B}
	EndGlobalSection
EndGlobal

```

`Ring 0/Ceydbg_drive.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{41D81868-F233-40EF-B0A3-2C87249A529B}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Ceydbg_drive</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Ceydbg_drive.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CeyDbg.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Ring 0/Ceydbg_drive.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Ceydbg_drive.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CeyDbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Ring 0/Ceydbg_drive.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Ring 0/main.c`:

```c
#include"CeyDbg.h"

PDEVICE_OBJECT mydevice = NULL;
NTSTATUS Unload(PDRIVER_OBJECT main) {
	DbgPrint("now exit!\n");
	UNICODE_STRING symbolLinkName;
	DbgPrint("DriverUnload\n");
	if (main->DeviceObject)
		IoDeleteDevice(main->DeviceObject);
	RtlInitUnicodeString(&symbolLinkName, my_link_name);
	IoDeleteSymbolicLink(&symbolLinkName);
}
NTSTATUS CreateCompleteRoutine(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
{
	NTSTATUS Status;

	DbgPrint("创建\n");
	Status = STATUS_SUCCESS;
	pIrp->IoStatus.Status = Status;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
NTSTATUS myfun(PDEVICE_OBJECT mydevice, PIRP irp)
{
	
	NTSTATUS status = STATUS_SUCCESS;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
	ULONG xh_code = stack->Parameters.DeviceIoControl.IoControlCode;
	ULONG buffer_lenth = 0;

	


	switch (xh_code)
	{
	case GET_BASE:
	{
		//DWORD64  k = &KeNumberProcessors;
		DWORD64 base = (DWORD64)KdDebuggerEnabled;
		irp->IoStatus.Status = status;
		PUCHAR buffer2 = stack->Parameters.DeviceIoControl.Type3InputBuffer;//可以写到应用
		PUCHAR buffer3 = irp->UserBuffer;//可以从应用读到
		//memcpy(&test, buffer3, sizeof(int));
		int test = 0;
		memcpy(buffer2, &base, sizeof(DWORD64));
		DbgPrint("get!:%d", test);
		irp->IoStatus.Information = 8;
		break;
	}
	case GET_VALUE:
	{
		//DbgBreakPoint();
		DWORD64 add = 0;
		irp->IoStatus.Status = status;
		PUCHAR buffer2 = stack->Parameters.DeviceIoControl.Type3InputBuffer;//可以写到应用
		PUCHAR buffer3 = irp->UserBuffer;//可以从应用读到
		memcpy(&add, buffer3, sizeof(DWORD64));
		ULONG il = stack->Parameters.DeviceIoControl.InputBufferLength;
		//ULONG ol = stack->Parameters.DeviceIoControl.OutputBufferLength;
		_try{
		memcpy(buffer2, add, il); 
		irp->IoStatus.Information = il;
		}
		_except(1) {
			//memset(buffer2, 0, il);
			irp->IoStatus.Information = 0;
		}
		
		break;
	}
	default:
		irp->IoStatus.Information = 0; break;
	}
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
NTSTATUS DriverEntry(PDRIVER_OBJECT main, PUNICODE_STRING ei) {



	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING device_name, device_link_name;//设备名，符号链接名
	RtlInitUnicodeString(&device_name, my_device_name);//初始化设备名
	RtlInitUnicodeString(&device_link_name, my_link_name);//初始化符号链接名
	status = IoCreateDevice(main, 200, &device_name, FILE_DEVICE_UNKNOWN, 0, 1, &mydevice);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("无法创建设备!\n");
		return status;
	}
	status = IoCreateSymbolicLink(&device_link_name, &device_name);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("无法创建符号链接！\n");
		IoDeleteDevice(mydevice);
		return status;
	}
	DbgPrint("创建成功！\n");
	main->DriverUnload = Unload;
	main->MajorFunction[IRP_MJ_CREATE] = CreateCompleteRoutine;
	main->MajorFunction[IRP_MJ_DEVICE_CONTROL] = myfun;
}


```

`Ring 3/CES/CES.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriveRelated.cpp" />
    <ClCompile Include="function.cpp" />
    <ClCompile Include="PdbRelated.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Ceydbg.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{41d29491-30b5-4ae2-88b5-1c2c3029d4af}</ProjectGuid>
    <RootNamespace>CES</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Ring 3/CES/CES.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="function.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="DriveRelated.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="PdbRelated.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Ceydbg.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Ring 3/CES/CES.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Ring 3/CES/Ceydbg.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <Windows.h>
#include <DbgHelp.h>
#pragma comment(lib, "DbgHelp.lib")
#pragma comment(lib, "Urlmon.lib")


extern int Update_Flag;
extern int Answer_Num;
extern int Root;

struct GUID_StreamData
{
	int ver;
	int date;
	int age;
	GUID guid;
};

struct PdbInfo
{
	DWORD	Signature;
	GUID	Guid;
	DWORD	Age;
	char	PdbFileName[1];
};

typedef struct _Pdb_Task
{
	char szDllDir[MAX_PATH];
	char szDllBaseName[MAX_PATH];
	char szSymbolServerUrl[1024];//Pdb 下载路径

	char szPdbPath[MAX_PATH];//Pdb加载路径
	char szDllFullPath[MAX_PATH];//
	HANDLE hProcess; //当前进程句柄
	DWORD64 kenhandle;//符号句柄
	HANDLE My_Drive;//驱动句柄
	DWORD64 Ntoskrnl_Base;//nt内核基址


}Pdb_Task, * PPdb_Task;

typedef struct _Command {
	int Type;//读？还是写之类的命令类型

	DWORD64 Address;//操作地址
	int width;//字节 1 ，字 2 ，双字 4 ，四字 8
	UCHAR Parameter[10][50];//提供10个50长度的空间放 命令和参数，第一个是命令，其余的是参数
	int Parameter_Num;//实用参数个数，不计第一个命令
	DWORD64 OutPut_Len;//输出长度
}Command, * PCommand;

extern Pdb_Task Pdbfile; //pdb_information

extern DWORD  error;//error_code

extern LPCSTR Ntoskrnl_Path;
extern CHAR Current_Path[MAX_PATH];

extern DWORD64 Ntoskrnl_Base_bf;//内核基址，需要通过KdDebuggerEnabled地址获得
extern PBYTE Ntoskrnl_Image;//read Ntoskrnl.exe add

extern UCHAR Cin_Command[2048];//输入的总命令

#define DEVICE_NAME L"\\\\.\\CEYDBG" //符号链接名
#define GET_BASE CTL_CODE(FILE_DEVICE_UNKNOWN,0x99f,METHOD_NEITHER,FILE_ANY_ACCESS)//初始化，通过偏移计算内核基址
#define GET_VALUE CTL_CODE(FILE_DEVICE_UNKNOWN,0x99e,METHOD_NEITHER,FILE_ANY_ACCESS)//读0x80字节数据





void Error_Out(int E_C);
int Read_Memory(PPdb_Task Pdbfile, PCommand Task,int width);
BOOL CALLBACK EnumSymProc(PSYMBOL_INFO pSymInfo, ULONG SymbolSize, PVOID UserContext);
int CheckPdb_X(PCSTR Pdbname);

void Load_Drive();
BOOL Install_Drive();
BOOL Start_Drive();
BOOL Stop_Drive();
BOOL Unload_Drive();

void Read_Ntoskrnl_Image();
DWORD Get_Ntoskrnl_Pdb();
void Load_Pdb();

void Ascii_To_Unicode(IN char* a, IN OUT WCHAR* u);
```

`Ring 3/CES/DriveRelated.cpp`:

```cpp
#include"Ceydbg.h"

DWORD64 Ntoskrnl_Base_bf = { 0 };//内核基址，需要通过KdDebuggerEnabled地址获得
WCHAR Drive_Name[50] = L"CEYDBG";
WCHAR Drive_File_Name[50] = L"Ceydbg_drive.sys";
int Answer_Num = 0;

// 安装驱动
BOOL Install_Drive() {
    WCHAR Drive_Path[MAX_PATH] = { 0 };
    GetCurrentDirectoryW(MAX_PATH, Drive_Path);
    lstrcatW(Drive_Path, L"\\");
    lstrcatW(Drive_Path, Drive_File_Name);
    // 打开服务控制管理器数据库
    SC_HANDLE schSCManager = OpenSCManagerW(
        NULL,                   // 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
        NULL,                   // 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
        SC_MANAGER_ALL_ACCESS   // 所有权限
    );
    if (schSCManager == NULL) {
        DWORD64 e = GetLastError();
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    // 创建服务对象，添加至服务控制管理器数据库
    SC_HANDLE schService = CreateServiceW(
        schSCManager,               // 服务控件管理器数据库的句柄
        Drive_Name,                // 要安装的服务的名称
        Drive_Name,                // 用户界面程序用来标识服务的显示名称
        SERVICE_ALL_ACCESS,         // 对服务的访问权限：所有全权限
        SERVICE_KERNEL_DRIVER,      // 服务类型：驱动服务
        SERVICE_DEMAND_START,       // 服务启动选项：进程调用 StartService 时启动
        SERVICE_ERROR_IGNORE,       // 如果无法启动：忽略错误继续运行
        Drive_Path,                    // 驱动文件绝对路径，如果包含空格需要多加双引号
        NULL,                       // 服务所属的负载订购组：服务不属于某个组
        NULL,                       // 接收订购组唯一标记值：不接收
        NULL,                       // 服务加载顺序数组：服务没有依赖项
        NULL,                       // 运行服务的账户名：使用 LocalSystem 账户
        NULL                        // LocalSystem 账户密码
    );
    if (schService == NULL) {
        DWORD64 E = GetLastError();
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        if (E == 1073)
            return TRUE;
        return FALSE;
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    return TRUE;
}

//运行
BOOL Start_Drive() {

    // 打开服务控制管理器数据库
    SC_HANDLE schSCManager = OpenSCManager(
        NULL,                   // 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
        NULL,                   // 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
        SC_MANAGER_ALL_ACCESS   // 所有权限
    );
    if (schSCManager == NULL) {
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    // 打开服务
    SC_HANDLE hs = OpenService(
        schSCManager,           // 服务控件管理器数据库的句柄
        Drive_Name,            // 要打开的服务名
        SERVICE_ALL_ACCESS      // 服务访问权限：所有权限
    );
    if (hs == NULL) {
        CloseServiceHandle(hs);
        CloseServiceHandle(schSCManager);
        return FALSE;
    }
    if (StartService(hs, 0, 0) == 0) {
        CloseServiceHandle(hs);
        CloseServiceHandle(schSCManager);
        return FALSE;
    }


    CloseServiceHandle(hs);
    CloseServiceHandle(schSCManager);
    return TRUE;
}

// 停止
BOOL Stop_Drive() {

    // 打开服务控制管理器数据库
    SC_HANDLE schSCManager = OpenSCManager(
        NULL,                   // 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
        NULL,                   // 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
        SC_MANAGER_ALL_ACCESS   // 所有权限
    );
    if (schSCManager == NULL) {
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    // 打开服务
    SC_HANDLE hs = OpenService(
        schSCManager,           // 服务控件管理器数据库的句柄
        Drive_Name,            // 要打开的服务名
        SERVICE_ALL_ACCESS      // 服务访问权限：所有权限
    );
    if (hs == NULL) {
        CloseServiceHandle(hs);
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    // 如果服务正在运行
    SERVICE_STATUS status;
    if (QueryServiceStatus(hs, &status) == 0) {
        CloseServiceHandle(hs);
        CloseServiceHandle(schSCManager);
        return FALSE;
    }
    if (status.dwCurrentState != SERVICE_STOPPED &&
        status.dwCurrentState != SERVICE_STOP_PENDING
        ) {
        // 发送关闭服务请求
        if (ControlService(
            hs,                         // 服务句柄
            SERVICE_CONTROL_STOP,       // 控制码：通知服务应该停止
            &status                     // 接收最新的服务状态信息
        ) == 0) {
            CloseServiceHandle(hs);
            CloseServiceHandle(schSCManager);
            return FALSE;
        }

        // 判断超时
        INT timeOut = 0;
        while (status.dwCurrentState != SERVICE_STOPPED) {
            timeOut++;
            QueryServiceStatus(hs, &status);
            Sleep(50);
        }
        if (timeOut > 80) {
            CloseServiceHandle(hs);
            CloseServiceHandle(schSCManager);
            return FALSE;
        }
    }

    CloseServiceHandle(hs);
    CloseServiceHandle(schSCManager);
    return TRUE;
}

// 卸载驱动
BOOL Unload_Drive() {

    // 打开服务控制管理器数据库
    SC_HANDLE schSCManager = OpenSCManager(
        NULL,                   // 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
        NULL,                   // 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
        SC_MANAGER_ALL_ACCESS   // 所有权限
    );
    if (schSCManager == NULL) {
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    // 打开服务
    SC_HANDLE hs = OpenService(
        schSCManager,           // 服务控件管理器数据库的句柄
        Drive_Name,            // 要打开的服务名
        SERVICE_ALL_ACCESS      // 服务访问权限：所有权限
    );
    if (hs == NULL) {
        CloseServiceHandle(hs);
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    // 删除服务
    if (DeleteService(hs) == 0) {
        CloseServiceHandle(hs);
        CloseServiceHandle(schSCManager);
        return FALSE;
    }

    CloseServiceHandle(hs);
    CloseServiceHandle(schSCManager);
    return TRUE;
}

// 加载驱动
void Load_Drive() {
    DWORD lent = 0;
    Pdbfile.My_Drive = CreateFile(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, NULL);
    if (Pdbfile.My_Drive == INVALID_HANDLE_VALUE)
    {
        Error_Out(1);
    }
    int test = 1000;
    if (!DeviceIoControl(Pdbfile.My_Drive, GET_BASE, &Ntoskrnl_Base_bf, sizeof(DWORD64), &test, 4, &lent, NULL))
        Error_Out(1);
    CheckPdb_X("KdDebuggerEnabled");
    if (Answer_Num == 0)
        Error_Out(1);
}
```

`Ring 3/CES/PdbRelated.cpp`:

```cpp
#include"Ceydbg.h"

Pdb_Task Pdbfile = { 0 }; //pdb_information

LPCSTR Ntoskrnl_Path = "C:\\Windows\\System32\\ntoskrnl.exe";

PBYTE Ntoskrnl_Image = { 0 };//read Ntoskrnl.exe add




//road Ntoskrnl.exe
void Read_Ntoskrnl_Image() {
	HANDLE Ntoskrnl_H = CreateFileA(Ntoskrnl_Path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);//载入文件
	if (Ntoskrnl_H == INVALID_HANDLE_VALUE)//是否成功载入文件
		Error_Out(2);
	char rdos[sizeof(IMAGE_DOS_HEADER)];//临时dos指针空间
	char rpe[sizeof(IMAGE_NT_HEADERS)];//临时NT空间
	DWORD NumberOfBytesRW = 0;
	if (ReadFile(Ntoskrnl_H, rdos, sizeof(IMAGE_DOS_HEADER), &NumberOfBytesRW, NULL) == FALSE)
		Error_Out(2);
	PIMAGE_DOS_HEADER rdoshead = (PIMAGE_DOS_HEADER)rdos;//DOS头指针（临时）
	SetFilePointer(Ntoskrnl_H, rdoshead->e_lfanew, NULL, FILE_BEGIN);//下一次读PE头
	if (ReadFile(Ntoskrnl_H, rpe, sizeof(IMAGE_NT_HEADERS), &NumberOfBytesRW, NULL) == FALSE)
		Error_Out(2);
	PIMAGE_NT_HEADERS rpehead = (PIMAGE_NT_HEADERS)rpe;
	Ntoskrnl_Image = (PBYTE)malloc(rpehead->OptionalHeader.SizeOfImage);
	SetFilePointer(Ntoskrnl_H, 0, NULL, FILE_BEGIN);//下一次读PE头
	if (ReadFile(Ntoskrnl_H, Ntoskrnl_Image, rpehead->OptionalHeader.SizeOfHeaders, &NumberOfBytesRW, NULL) == FALSE)
		Error_Out(2);
	rdoshead = (PIMAGE_DOS_HEADER)Ntoskrnl_Image;
	rpehead = (PIMAGE_NT_HEADERS)(rdoshead->e_lfanew + Ntoskrnl_Image);


	IMAGE_SECTION_HEADER* pSectionHeader = IMAGE_FIRST_SECTION(rpehead);//取区段信息
	for (int i = 0; i < rpehead->FileHeader.NumberOfSections; i++, pSectionHeader++)//读区段数据,模仿镜像加载
	{
		SetFilePointer(Ntoskrnl_H, pSectionHeader->PointerToRawData, NULL, FILE_BEGIN);//设置下次读取地址
		//ALIGN(sectionsize, sectionalign);//对齐读取大小
		if (ReadFile(Ntoskrnl_H, Ntoskrnl_Image + pSectionHeader->VirtualAddress, pSectionHeader->SizeOfRawData, &NumberOfBytesRW, NULL) == FALSE)
			Error_Out(2);
	}
}

//get pdb in Current Directory
DWORD Get_Ntoskrnl_Pdb()
{
	PPdb_Task Pdb = &Pdbfile;

	GetCurrentDirectoryA(MAX_PATH, Current_Path);
	strcpy(Pdb->szDllBaseName, "ntoskrnl.exe");
	//strcpy(Pdb->szDllDir, szDllFullPath);
	//Pdb->szDllDir[GetBaseName(szDllFullPath) - szDllFullPath] = NULL;

	strcpy(Pdb->szSymbolServerUrl, "https://msdl.microsoft.com/download/symbols/");//设置pdb服务器

	strcpy(Pdb->szDllFullPath, Ntoskrnl_Path);//ntoskrnl.exe路径

	strcpy(Pdb->szPdbPath, Current_Path);//get pdb path

	if (Pdb->szPdbPath[strlen(Pdb->szPdbPath) - 1] != '\\')
	{
		strcat(Pdb->szPdbPath, "\\");
	}


	// get pdb info from debug info directory
	//PBYTE FileBuffer = NULL;
	Read_Ntoskrnl_Image();//读文件到内存
	IMAGE_DOS_HEADER* pDos = (IMAGE_DOS_HEADER*)Ntoskrnl_Image;
	IMAGE_NT_HEADERS* pNT = (IMAGE_NT_HEADERS*)(Ntoskrnl_Image + pDos->e_lfanew);
	IMAGE_FILE_HEADER* pFile = &pNT->FileHeader;
	IMAGE_OPTIONAL_HEADER64* pOpt64 = (IMAGE_OPTIONAL_HEADER64*)(&pNT->OptionalHeader);

	IMAGE_DATA_DIRECTORY* pDataDir = nullptr;
	pDataDir = &pOpt64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	IMAGE_DEBUG_DIRECTORY* pDebugDir = (IMAGE_DEBUG_DIRECTORY*)(Ntoskrnl_Image + pDataDir->VirtualAddress);
	if (!pDataDir->Size || IMAGE_DEBUG_TYPE_CODEVIEW != pDebugDir->Type)
	{
		// invalid debug dir
		free(Ntoskrnl_Image);
		Error_Out(2);
	}
	PdbInfo* pdb_info = (PdbInfo*)(Ntoskrnl_Image + pDebugDir->AddressOfRawData);
	if (pdb_info->Signature != 0x53445352)
	{
		// invalid debug dir
		free(Ntoskrnl_Image);
		Error_Out(2);
	}

	// sometimes pdb_info->PdbFileName is a abs path, sometimes is just a base name.
	// In first case, we have to calc its base name.
	strcat(Pdb->szPdbPath, pdb_info->PdbFileName);//get pdb name

	// download pdb

	//判断文件是否存在
	WIN32_FIND_DATAA wfd;
	HANDLE hFind = FindFirstFileA(Pdb->szPdbPath, &wfd);
	if (INVALID_HANDLE_VALUE != hFind)
	{
		//已经有pdb文件了
		if (Update_Flag != 1)//系统更新了？要重新下载pdb，置Update_Flag==1
		{

			free(Ntoskrnl_Image);
			FindClose(hFind);//不需要重新下载
			return 0;
		}
	}

	wchar_t w_GUID[100] = { 0 };
	if (!StringFromGUID2(pdb_info->Guid, w_GUID, 100))
	{
		free(Ntoskrnl_Image);
		Error_Out(2);
	}
	char a_GUID[100]{ 0 };//get debug_guid
	size_t l_GUID = 0;
	if (wcstombs_s(&l_GUID, a_GUID, w_GUID, sizeof(a_GUID)) || !l_GUID)
	{
		free(Ntoskrnl_Image);
		Error_Out(2);
	}

	char guid_filtered[256] = { 0 };
	for (UINT i = 0; i != l_GUID; ++i)
	{
		if ((a_GUID[i] >= '0' && a_GUID[i] <= '9') || (a_GUID[i] >= 'A' && a_GUID[i] <= 'F') || (a_GUID[i] >= 'a' && a_GUID[i] <= 'f'))
		{
			guid_filtered[strlen(guid_filtered)] = a_GUID[i];
		}
	}

	char age[3] = { 0 };
	_itoa_s(pdb_info->Age, age, 10);

	// url
	char url[1024] = { 0 };
	strcpy(url, Pdb->szSymbolServerUrl);
	strcat(url, pdb_info->PdbFileName);
	url[strlen(url)] = '/';
	strcat(url, guid_filtered);
	strcat(url, age);
	url[strlen(url)] = '/';
	strcat(url, pdb_info->PdbFileName);

	// download
	HRESULT hr = URLDownloadToFileA(NULL, url, Pdb->szPdbPath, NULL, NULL);
	if (FAILED(hr))
	{
		free(Ntoskrnl_Image);
		Error_Out(2);
	}

	free(Ntoskrnl_Image);
	return 0;
}

//load pdb file and exe
void Load_Pdb() {


	Pdbfile.hProcess = OpenProcess(FILE_ALL_ACCESS, 0, GetCurrentProcessId());

	SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);
	if (!SymInitialize(Pdbfile.hProcess, Pdbfile.szPdbPath, TRUE))
	{
		// SymInitialize failed
		error = GetLastError();
		printf("SymInitialize returned error : %d\n", error);
		system("pause");
		Error_Out(2);
	}
	//TCHAR  szImageName[MAX_PATH] = TEXT("foo.dll");
	DWORD64 dwBaseAddr = 0;

	Pdbfile.kenhandle = SymLoadModuleEx(Pdbfile.hProcess,    // target process 
		NULL,        // handle to image - not used
		Ntoskrnl_Path, // name of image file
		NULL,        // name of module - not required
		dwBaseAddr,  // base address - not required
		0,           // size of image - not required
		NULL,        // MODLOAD_DATA used for special cases 
		0);        // flags - not required

	if (Pdbfile.kenhandle == NULL)
	{
		error = GetLastError();
		printf("SymLoadModuleEx error : %d\n", error);
		system("pause");
		Error_Out(2);
	}
}

```

`Ring 3/CES/function.cpp`:

```cpp
#include "Ceydbg.h"
//E_C:
//0:About Drive install、unload、start、stop
//1:About Drive Symbolic link
//2:About PDB Load
void Error_Out(int E_C) {
	printf("error : %d\n",E_C);
	system("pause");
	exit(0);
}

void Ascii_To_Unicode(IN char *a,IN OUT WCHAR *u) {
	int l = strlen(a);
	for (int i = 0; i < l; i++)
		memcpy(u + i, a + i, 1);
}

int Ascii_To_LONG_LONG(IN char* a, IN OUT PDWORD64 add)
{
	int len = strlen(a);
	if (len > 16)
		return 0;
	PBYTE offset = (PBYTE)add;
	int flag = 0;
	//字符串转8字节地址
	for (int i = 0; i < len; i++)
	{
		if (a[i] >= 0x30 && a[i] <= 0x39)
			a[i] -= 0x30;
		else if (a[i] == 'a' || a[i] == 'A')
			a[i] = 0xa;
		else if (a[i] == 'b' || a[i] == 'B')
			a[i] = 0xb;
		else if (a[i] == 'c' || a[i] == 'C')
			a[i] = 0xc;
		else if (a[i] == 'd' || a[i] == 'D')
			a[i] = 0xd;
		else if (a[i] == 'e' || a[i] == 'E')
			a[i] = 0xe;
		else if (a[i] == 'f' || a[i] == 'F')
			a[i] = 0xf;
		else
			return 0;
	}
	for (int i = 0; i < len; i++)
	{
		if (flag == 0)
		{
			memcpy(offset, &(a[i]), 1);
			flag = 1;
		}
		else
		{
			*add = *add << 4;
			*(offset) += a[i];
		}
	}
	return 1;


}



int Complete_Command(PPdb_Task Pdbfile,PCommand Task) {
	DWORD64 Default_Len = 0x80;
	
	if (Task->OutPut_Len != 0)
		Default_Len = Task->OutPut_Len * Task->width;
	
	
	PBYTE buffer = (PBYTE)malloc(Default_Len);
	DWORD lent = 0;
	if (!DeviceIoControl(Pdbfile->My_Drive, GET_VALUE, buffer, Default_Len, &(Task->Address), 16, &lent, NULL))
		return 0;
	if (lent == 0)
	{
		printf(" Cannot read!\n");
		return 1;
	}
	
	switch (Task->width) {//宽度输出
	case 1: {

		for (int i = 0; i < Default_Len; i++)
		{
			if (i % 0x10 == 0)
			{
				printf(" \n %p   ", Task->Address);
				Task->Address += 0x10;
			}
			printf(" %02x", buffer[i]);
		}
		printf("\n");
		break;
	}
	case 2: {
		for (int i = 0; i < Default_Len; i = i + 2)
		{
			if (i % 0x10 == 0)
			{
				printf(" \n %p   ", Task->Address);
				Task->Address += 0x10;
			}
			USHORT out = *(USHORT*)(buffer + i);
			printf(" %04x", out);
		}
		printf("\n");
		break;
	}
	case 4: {
		for (int i = 0; i < Default_Len; i = i + 4)
		{
			if (i % 0x10 == 0)
			{
				printf(" \n %p   ", Task->Address);
				Task->Address += 0x10;
			}
			ULONG out = *(ULONG*)(buffer + i);
			printf(" %08x", out);
		}
		printf("\n");
		break;
	}
	case 8: {
		for (int i = 0; i < Default_Len; i = i + 8)
		{
			if (i % 0x10 == 0)
			{
				printf(" \n %p   ", Task->Address);
				Task->Address += 0x10;
			}
			DWORD64 out = *(DWORD64 *)(buffer + i);
			printf(" %16p", out);
		}
		printf("\n");
		break;
	}
	}

	free(buffer);
	return 1;

}

int Read_Memory(PPdb_Task Pdbfile, PCommand Task, int width) {
	if (Task->Parameter_Num > 2)
		return 0;
	DWORD64 Out_Len = 0;
	if (Task->Parameter[2][0] == 'l')
	{

		if (!Ascii_To_LONG_LONG((char*)&(Task->Parameter[2][1]), &Out_Len))
			return 0;
		if (Out_Len > 0x100)
		{
			printf("\n too long!\n");
			return 0;
		}
		Task->OutPut_Len = Out_Len;
	}
	else if (Task->Parameter[2][0] != 0)
		return 0;


	int Pdb_Or_Add = 0;//0：地址 1：符号
	Task->width = width;
	int len = strlen((char*)&(Task->Parameter[1]));
	//判断是 符号 还是 地址
	for (int i = 0; i < len; i++)
	{
		if (Task->Parameter[1][i] == 'a' || Task->Parameter[1][i] == 'b' || Task->Parameter[1][i] == 'c' || Task->Parameter[1][i] == 'd' || Task->Parameter[1][i] == 'e' || Task->Parameter[1][i] == 'f' || Task->Parameter[1][i] == 'A' || Task->Parameter[1][i] == 'B' || Task->Parameter[1][i] == 'C' || Task->Parameter[1][i] == 'D' || Task->Parameter[1][i] == 'E' || Task->Parameter[1][i] == 'F')
			continue;
		if (Task->Parameter[1][i] < '0' || Task->Parameter[1][i] >'9')
		{
			Pdb_Or_Add = 1;
			break;
		}
	}

	if (Pdb_Or_Add == 1)
	{
		//查询的是符号
		for (int i = 0; i < len; i++)
			if (Task->Parameter[1][i] == '*') //不接受 多个查询
				return 0;
		SYMBOL_INFOW Information = { 0 };
		WCHAR un[256] = { 0 };
		Ascii_To_Unicode((char*)&(Task->Parameter[1]), un);
		SymFromNameW(Pdbfile->hProcess, un, &Information);
		if (Information.Address == 0)
			return 0;
		Task->Address = Information.Address + Pdbfile->Ntoskrnl_Base;
		return Complete_Command(Pdbfile, Task);
	}
	else
	{

		//if (Root == 0)//通过地址都内存需要root！！
		//	return 0;
		//输入的是地址
		DWORD64 add = 0;

		if (!Ascii_To_LONG_LONG((char*)(Task->Parameter[1]), &add))
			return 0;

		Task->Address = add;
		return Complete_Command(Pdbfile, Task);

	}



}

BOOL CALLBACK EnumSymProc(PSYMBOL_INFO pSymInfo, ULONG SymbolSize, PVOID UserContext)
{
	UNREFERENCED_PARAMETER(UserContext);
	/*printf("%S : %P\n",pSymInfo->Name,pSymInfo->Address+ Ntoskrnl_Base);*/
	if (strcmp(pSymInfo->Name, "KdDebuggerEnabled") == 0 && Pdbfile.Ntoskrnl_Base == 0)
	{
		Pdbfile.Ntoskrnl_Base = Ntoskrnl_Base_bf - pSymInfo->Address;
		Answer_Num++;
		return TRUE;
	}

	printf(" %p  %s \n", pSymInfo->Address + Pdbfile.Ntoskrnl_Base, pSymInfo->Name);
	return TRUE;
}

int CheckPdb_X(PCSTR Pdbname) {
	if (!SymEnumSymbols(Pdbfile.hProcess,     // Process handle from SymInitialize.
		Pdbfile.kenhandle,   // Base address of module.
		Pdbname,        // Name of symbols to match.
		EnumSymProc, // Symbol handler procedure.
		NULL)) // User context.
	{
		return 0;
	}
	return 1;
}



```

`Ring 3/CES/main.cpp`:

```cpp

#include"Ceydbg.h"
using namespace std;

int Update_Flag = 0;
int Root = 0;//Root 权限
DWORD  error;//error_code
CHAR Current_Path[MAX_PATH] = { 0 };
UCHAR Cin_Command[2048] = { 0 };//输入的总命令



//Process incoming commands
int Process_Command(PUCHAR C) {
	DWORD64 Parameter = { 0 };
	Command Task = { 0 };
	int state = 0;
	int Cin_Parameter = 0;
	int Cin_Parameter_Offset = 0;

	//通过空格分割命令 Distinguish parameters by spaces
	for (int i = 0; C[i] != 0x00; i++)
	{
		if (C[i] == 0x20)
			continue;
		memcpy(&(Task.Parameter[Cin_Parameter][Cin_Parameter_Offset]), &C[i], 1);
		Cin_Parameter_Offset++;
		if (C[i + 1] == 0x20 || C[i + 1] == 0)
		{
			
			if (Cin_Parameter_Offset == 256)
				break;//Parameter too long

			//strcat((char*)&(Task.Parameter[Cin_Parameter]), "\n");

			Cin_Parameter++;
			Cin_Parameter_Offset = 0;
			if (Cin_Parameter == 10)
				break;//Command too long 
		}
	}
	Task.Parameter_Num = Cin_Parameter - 1;


	//处理命令 like windbg
	//此处可更新 renewable
	if (Task.Parameter[0][0] == 'd')
	{
		if (strcmp((char*)&(Task.Parameter[0]), "db") == 0)//同windbg
			return Read_Memory(&Pdbfile, &Task, 1);

		if (strcmp((char*)&(Task.Parameter[0]), "dw") == 0)//同windbg
			return Read_Memory(&Pdbfile, &Task, 2);

		if (strcmp((char*)&(Task.Parameter[0]), "dd") == 0)//同windbg
			return Read_Memory(&Pdbfile, &Task, 4);

		if (strcmp((char*)&(Task.Parameter[0]), "dq") == 0)//同windbg
			return Read_Memory(&Pdbfile, &Task, 8);
	}

	if (strcmp((char*)&(Task.Parameter[0]), "x") == 0)//同windbg
		return CheckPdb_X((char*)&(Task.Parameter[1]));

	//退出 quit
	if (strcmp((char*)&(Task.Parameter[0]), "quit") == 0)
	{
		CloseHandle(Pdbfile.My_Drive);
		if (!Stop_Drive())
			Error_Out(0);
		if (!Unload_Drive())
			Error_Out(0);
		return -1;
	}

	//if (strcmp((char*)&(Task.Parameter[0]), "root") == 0)
	//{
	//	Root = 1;
	//	printf("\n Warning : ROOT\n");
	//	return 1;
	//}

	return state;
}


int main() {

	//驱动是否已经安装
	Pdbfile.My_Drive = CreateFile(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, NULL);
	if (Pdbfile.My_Drive != INVALID_HANDLE_VALUE)
	{
		CloseHandle(Pdbfile.My_Drive);
		memset(&(Pdbfile.My_Drive), 0, sizeof(HANDLE));
	}
	else
	{
		//Install_Drive
		memset(&(Pdbfile.My_Drive), 0, sizeof(HANDLE));
		if (!Install_Drive())
			Error_Out(0);
		if (!Start_Drive())
			Error_Out(0);
	}
	
	//判断是否下载了pdb文件，没有就下载
	Get_Ntoskrnl_Pdb();
	//加载pdb文件和exe
	Load_Pdb();
	//连接驱动
	Load_Drive();



	int State = 1;
	while (1) {
		rewind(stdin);
		State = 1;

		memset(&Cin_Command, 0, 2048);
		printf("\nic>");
		scanf_s("%[^\n]", Cin_Command, 2048);

		State = Process_Command(Cin_Command);
		if (State == 0)
			printf(" Command Error!\n");
		if (State == -1)
			return 0;
	}
    system("pause");

}
```

`Ring 3/IC_Ntoskrnl_Viewer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31105.61
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CES", "CES\CES.vcxproj", "{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Debug|x64.ActiveCfg = Debug|x64
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Debug|x64.Build.0 = Debug|x64
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Debug|x86.ActiveCfg = Debug|Win32
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Debug|x86.Build.0 = Debug|Win32
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Release|x64.ActiveCfg = Release|x64
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Release|x64.Build.0 = Release|x64
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Release|x86.ActiveCfg = Release|Win32
		{41D29491-30B5-4AE2-88B5-1C2C3029D4AF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {97BD3681-6F7C-4CFA-B2E8-AA34BCF69DC0}
	EndGlobalSection
EndGlobal

```

`readme.md`:

```md
# ReadMe

## 本项目含三个模块 The project includes three modules：

1.驱动模块 Drive module

2.用户模块 User module

3.成品模块（驱动已签名）Finished module (driver signed)



## 功能 function：

可在不开启测试模式和WinDbg本地调试的情况下，以符号化的形式浏览本地内存！

You can browse local memory in symbolic form without turning on test mode and WinDbg local debugging!

不管是否为导出函数、未导出函数、系统内核变量、标志，只要在PDB文件中的符号，都能浏览其内存。

No matter whether it is an exported function, an unexported function, a system kernel variable, or a flag, as long as the symbol in the pdb file is displayed, its memory can be browsed.

只支持X64系统，理论上支持任何版本（只要微软公开了此版本的PDB）

It only supports x64 system, and theoretically supports any version (as long as Microsoft discloses this version of PDB)

###### Windows 10:

![image](https://github.com/IcEy-999/IC_Ntoskrnl_Viewer/blob/main/Release/win10_test.png)

###### Windows 11:

![image](https://github.com/IcEy-999/IC_Ntoskrnl_Viewer/blob/main/Release/win11_test.png)



## 目前已实现的命令 Currently implemented commands：

### “db” "dw" "dd" "dq"，这四种功能同WinDbg，例如 

### "db" "dw" "dd" "dq", these four functions are the same as WinDbg, for example:：

![image](https://github.com/IcEy-999/IC_Ntoskrnl_Viewer/blob/main/Release/d_test.png)

### “d”也可以通过地址读取内存：（读取非法地址时会报错）


### (“D ”you can also read the memory through the address: (an error will be reported when reading the illegal address)



![image](https://github.com/IcEy-999/IC_Ntoskrnl_Viewer/blob/main/Release/d_test2.png)





### “x” 同WinDbg Same as WinDbg：

![image](https://github.com/IcEy-999/IC_Ntoskrnl_Viewer/blob/main/Release/x_test.png)





### 退出需要通过命令"quit"。

### Exit requires the command "quit".

不然驱动无法正常卸载！

Otherwise, the driver cannot be uninstalled normally!





## 此次更新 This update：

###### 由于有PG、读写权限的原因，测试版先不提供写功能。

###### (Due to PG and read / write permission, the beta does not provide write function.)

###### 测试版 只支持X64系统，理论上支持任何版本（只要微软公开了此版本的PDB）

###### (The beta version only supports x64 system, and theoretically supports any version (as long as Microsoft discloses this version of PDB))





以后可能会更新 “eb、ew、ed、eq”命令。

The commands "EB, EW, ED, EQ" may be updated later.


会逐渐向 windbg本地调试可实现的功能靠近！

It will gradually approach the functions that WinDbg local debugging can achieve!

```