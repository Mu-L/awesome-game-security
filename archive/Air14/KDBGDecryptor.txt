Project Path: arc_Air14_KDBGDecryptor_srb5p5e3

Source Tree:

```txt
arc_Air14_KDBGDecryptor_srb5p5e3
├── KDBGDecryptor
│   ├── KDBGDecryptor.vcxproj
│   ├── KDBGDecryptor.vcxproj.filters
│   ├── main.cpp
│   ├── main.h
│   └── ntosp.h
├── KDBGDecryptor.sln
└── README.md

```

`KDBGDecryptor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30225.117
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KDBGDecryptor", "KDBGDecryptor\KDBGDecryptor.vcxproj", "{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|ARM.ActiveCfg = Debug|ARM
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|ARM.Build.0 = Debug|ARM
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|ARM.Deploy.0 = Debug|ARM
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|ARM64.Build.0 = Debug|ARM64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|x64.ActiveCfg = Debug|x64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|x64.Build.0 = Debug|x64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|x64.Deploy.0 = Debug|x64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|x86.ActiveCfg = Debug|Win32
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|x86.Build.0 = Debug|Win32
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Debug|x86.Deploy.0 = Debug|Win32
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|ARM.ActiveCfg = Release|ARM
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|ARM.Build.0 = Release|ARM
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|ARM.Deploy.0 = Release|ARM
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|ARM64.ActiveCfg = Release|ARM64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|ARM64.Build.0 = Release|ARM64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|ARM64.Deploy.0 = Release|ARM64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|x64.ActiveCfg = Release|x64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|x64.Build.0 = Release|x64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|x64.Deploy.0 = Release|x64
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|x86.ActiveCfg = Release|Win32
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|x86.Build.0 = Release|Win32
		{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B40530CF-7D9B-4AF8-8563-1CF6B8A3C703}
	EndGlobalSection
EndGlobal

```

`KDBGDecryptor/KDBGDecryptor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B5F13A0D-4B15-4015-AB91-35F5D88CBD19}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>KDBGDecrypter</RootNamespace>
    <ProjectName>KDBGDecryptor</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
    <ClInclude Include="ntosp.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KDBGDecryptor/KDBGDecryptor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntosp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KDBGDecryptor/main.cpp`:

```cpp
#include "main.h"

// Decoding using KdDecodeDataBlock
#define DECODE_LOUD 0

// Decoding by copying encrypted kdbg struct and then decoding it by using KiWaitNever and KiWaitAlways
#define DECODE_STEALTH 1

ULONG KernelImageSize = 0;
PVOID KernelBase = 0;
PKDDEBUGGER_DATA64 KDGB = 0;
INT64(*KdDecodeDataBlock)();

extern "C"
NTSTATUS DriverEntry(PDRIVER_OBJECT pDrviver, PUNICODE_STRING pRegistry)
{
	UNREFERENCED_PARAMETER(pDrviver);
	UNREFERENCED_PARAMETER(pRegistry);

	pDrviver->DriverUnload = DriverUnload;
	pDrviver->MajorFunction[IRP_MJ_CREATE] = CreateClose;
	pDrviver->MajorFunction[IRP_MJ_CLOSE] = CreateClose;

	do 
	{
		if (GetKDBG(KDGB, DECODE_STEALTH) == FALSE)
		{
			DbgPrint("Couldn't decode kdbg\r\n");
			break;
		}

		DbgPrint("Kernel base address: %p\r\n", KernelBase);
		DbgPrint("Kernel base address from kdbg struct: %p\r\n", KDGB->KernBase);

	} while (FALSE);

	return STATUS_SUCCESS;
}

VOID DriverUnload(PDRIVER_OBJECT pDrviver)
{
	UNREFERENCED_PARAMETER(pDrviver);
}

NTSTATUS CreateClose(PDEVICE_OBJECT pDevice, PIRP pIrp)
{
	UNREFERENCED_PARAMETER(pIrp);
	UNREFERENCED_PARAMETER(pDevice);
	return STATUS_SUCCESS;
}

BOOL GetKernelModule(CHAR* Name, ULONG& ImageSize, PVOID& ImageBase)
{
	ULONG Bytes;
	NTSTATUS Status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &Bytes);
	PSYSTEM_MODULE_INFORMATION pMods = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, Bytes, 'XXXX');

	RtlSecureZeroMemory(pMods, Bytes);

	Status = ZwQuerySystemInformation(SystemModuleInformation, pMods, Bytes, &Bytes);
	if (!NT_SUCCESS(Status))
	{
		ExFreePoolWithTag(pMods, 'XXXX');
		return FALSE;
	}

	PSYSTEM_MODULE_ENTRY pMod = pMods->Modules;
	for (ULONG i = 0; i < pMods->ModulesCount; i++)
	{
		if (strstr((PCSZ)pMod[i].FullPathName, Name) != NULL)
		{
			if (pMod[i].ImageSize != NULL)
			{
				ImageSize = pMod[i].ImageSize;
				ImageBase = pMod[i].ImageBase;
				ExFreePoolWithTag(pMods, 'XXXX');

				return TRUE;
			}
		}

	}

	ExFreePoolWithTag(pMods, 'XXXX');
	return FALSE;
}

BOOL GetKiWaitVariables(PVOID& Kwn, PVOID& Kwa)
{
	UCHAR* KeSetTimerExAddress = (UCHAR*)RtlFindExportedRoutineByName(KernelBase, "KeSetTimerEx");

	// KiWaitNever
	PVOID KiWaitNeverAddress = (KeSetTimerExAddress + 0x1C + 0x7) + (*(UINT32*)(KeSetTimerExAddress + 0x1C + 0x3));

	// KiWaitAlways
	PVOID KiWaitAlwaysAddress = (KeSetTimerExAddress + 0x26 + 0x7) + (*(UINT32*)(KeSetTimerExAddress + 0x26 + 0x3));

	// Check if KiWaitAlways and KiWaitNever are in range of kernel image address space
	if (!(KernelBase < KiWaitAlwaysAddress && KiWaitAlwaysAddress < (UCHAR*)KernelBase + KernelImageSize && KernelBase < KiWaitNeverAddress && KiWaitNeverAddress < (UCHAR*)KernelBase + KernelImageSize))
	{
		return FALSE;
	}

	Kwa = KiWaitAlwaysAddress;
	Kwn = KiWaitNeverAddress;

	return TRUE;
}

VOID DecryptKDBG(PVOID KiWaitNever, PVOID KiWaitAlways, PVOID KdpDataBlockEncodedAddress, PKDDEBUGGER_DATA64& kdbg)
{
	if (*(UCHAR*)KdpDataBlockEncodedAddress)
	{
		for (int i = 0; i < 112; i++)
		{
			*(UINT64*)kdbg = *(UINT64*)KiWaitAlways ^ _byteswap_uint64((UINT64)KdpDataBlockEncodedAddress ^ _rotl64(*(UINT64*)KiWaitNever ^ *(UINT64*)kdbg, *(UCHAR*)KiWaitNever));
			kdbg = (PKDDEBUGGER_DATA64)(((char*)kdbg) + 8);
		}
		kdbg = (PKDDEBUGGER_DATA64)((char*)kdbg - 896);
	}
}

BOOL GetKDBG(PKDDEBUGGER_DATA64& kdbg, UCHAR decodingOption)
{

	if (GetKernelModule("ntoskrnl.exe", KernelImageSize, KernelBase) == FALSE)
	{
		DbgPrint("Couldn't get kernel image base and size\r\n");
		return FALSE;
	}

	UCHAR* KdDecodeDataBlockAddress = (UCHAR*)find_signature(KernelBase, KernelImageSize, "\x48\x83\xEC\x28\x80\x3D\x00\x00\x00\x00\x00\x74\x13\x48\x8D", "xxxxxx?????xxxx");

	PVOID KdDebuggerDataAddress = (*(UINT32*)(KdDecodeDataBlockAddress + 0xD + 0x3)) + (KdDecodeDataBlockAddress + 0xD + 0x7);

	// Check if kdbg is in range of kernel image address space
	if ((UINT64)KdDebuggerDataAddress < (UINT64)KernelBase || (UINT64)KdDebuggerDataAddress > (UINT64)KernelBase + KernelImageSize)
	{
		DbgPrint("KdDebuggerData beyond kernel image address space (some bad calculation happened)\r\n");
		return FALSE;
	}

	// Call KdDecodeDataBlockAddress to decode kdbg. It's encrypted with assist of 2 variables: KiWaitAlways and KiWaitNever
	if (decodingOption == DECODE_LOUD)
	{
		KdDecodeDataBlock = (INT64(*)(void))KdDecodeDataBlockAddress;
		KdDecodeDataBlock();

		kdbg = (PKDDEBUGGER_DATA64)KdDebuggerDataAddress;
	}

	// Copy encrypted kdbg and then decode it
	else
	{
		PVOID KiWaitNever = 0;
		PVOID KiWaitAlways = 0;

		if (GetKiWaitVariables(KiWaitNever, KiWaitAlways) == FALSE)
		{
			return FALSE;
		}

		PVOID KdpDataBlockEncodedAddress = (KdDecodeDataBlockAddress + 0x4 + 0x7) + (*(UINT32*)(KdDecodeDataBlockAddress + 0x4 + 0x2));

		kdbg = (PKDDEBUGGER_DATA64)ExAllocatePoolWithTag(NonPagedPool, sizeof(KDDEBUGGER_DATA64), 'XXXX');

		RtlZeroMemory(kdbg, sizeof(KDDEBUGGER_DATA64));
		RtlCopyMemory(kdbg, KdDebuggerDataAddress, sizeof(KDDEBUGGER_DATA64));

		DecryptKDBG(KiWaitNever, KiWaitAlways, KdpDataBlockEncodedAddress, kdbg);
	}

	// Check if kdbg KerenelBase is equal base address of kernel image
	if ((PVOID)kdbg->KernBase != KernelBase)
	{
		DbgPrint("KdDebuggerData unencrypted or bad calculation happened\r\n");
		return FALSE;
	}

	return TRUE;
}

void* find_signature(void* memory, size_t size, const char* pattern, const char* mask)
{
	size_t sig_length = strlen(mask);
	if (sig_length > size) return nullptr;

	for (size_t i = 0; i < size - sig_length; i++)
	{
		bool found = true;
		for (size_t j = 0; j < sig_length; j++)
			found &= mask[j] == '?' || pattern[j] == *((char*)memory + i + j);

		if (found)
			return (char*)memory + i;
	}
	return nullptr;
}
```

`KDBGDecryptor/main.h`:

```h
#pragma once
#include <ntddk.h>
#include <minwindef.h>
#include "ntosp.h"


BOOL GetKernelModule(CHAR* Name, ULONG& ImageSize, PVOID& ImageBase);

BOOL GetKiWaitVariables(PVOID& kwn, PVOID& kwa);

BOOL GetKDBG(PKDDEBUGGER_DATA64 &kdbg, UCHAR decodingOption);

NTSTATUS CreateClose(PDEVICE_OBJECT pDevice, PIRP irp);

VOID DecryptKDBG(PVOID KiWaitNever, PVOID KiWaitAlways, PVOID KdpDataBlockEncodedAddress, PKDDEBUGGER_DATA64& kdbg);

VOID DriverUnload(PDRIVER_OBJECT pDrviver);

void* find_signature(void* memory, size_t size, const char* pattern, const char* mask);
```

`KDBGDecryptor/ntosp.h`:

```h
#pragma once
#include <ntddk.h>

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemExtendedProcessInformation = 6,
    SystemProcessorPerformanceInformation = 8,
    SystemModuleInformation = 11,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45,
    SystemFullProcessInformation = 148
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE {
    PVOID 	Reserved1;
    PVOID 	Reserved2;
    PVOID 	ImageBaseAddress;
    ULONG 	ImageSize;
    ULONG 	Flags;
    unsigned short 	Id;
    unsigned short 	Rank;
    unsigned short 	Unknown;
    unsigned short 	NameOffset;
    unsigned char 	Name[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_ENTRY {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG                       ModulesCount;
    SYSTEM_MODULE_ENTRY         Modules[1];
    ULONG                       Count;
    SYSTEM_MODULE 	            Sys_Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct DBGKD_DEBUG_DATA_HEADER64 {
    struct LIST_ENTRY64 {
        struct LIST_ENTRY64* Flink;
        struct LIST_ENTRY64* Blink;
    } List;
    UINT32           OwnerTag;
    UINT32           Size;
} DBGKD_DEBUG_DATA_HEADER64;

typedef struct KDDEBUGGER_DATA64 {
    DBGKD_DEBUG_DATA_HEADER64 Header;

    UINT64 KernBase;
    UINT64 BreakpointWithStatus;
    UINT64 SavedContext;
    UINT16 ThCallbackStack;
    UINT16 NextCallback;
    UINT16 FramePointer;
    UINT16 PaeEnabled : 1;
    UINT64 KiCallUserMode;
    UINT64 KeUserCallbackDispatcher;
    UINT64 PsLoadedModuleList;
    UINT64 PsActiveProcessHead;
    UINT64 PspCidTable;
    UINT64 ExpSystemResourcesList;
    UINT64 ExpPagedPoolDescriptor;
    UINT64 ExpNumberOfPagedPools;
    UINT64 KeTimeIncrement;
    UINT64 KeBugCheckCallbackListHead;
    UINT64 KiBugcheckData;
    UINT64 IopErrorLogListHead;
    UINT64 ObpRootDirectoryObject;
    UINT64 ObpTypeObjectType;
    UINT64 MmSystemCacheStart;
    UINT64 MmSystemCacheEnd;
    UINT64 MmSystemCacheWs;
    UINT64 MmPfnDatabase;
    UINT64 MmSystemPtesStart;
    UINT64 MmSystemPtesEnd;
    UINT64 MmSubsectionBase;
    UINT64 MmNumberOfPagingFiles;
    UINT64 MmLowestPhysicalPage;
    UINT64 MmHighestPhysicalPage;
    UINT64 MmNumberOfPhysicalPages;
    UINT64 MmMaximumNonPagedPoolInBytes;
    UINT64 MmNonPagedSystemStart;
    UINT64 MmNonPagedPoolStart;
    UINT64 MmNonPagedPoolEnd;
    UINT64 MmPagedPoolStart;
    UINT64 MmPagedPoolEnd;
    UINT64 MmPagedPoolInformation;
    UINT64 MmPageSize;
    UINT64 MmSizeOfPagedPoolInBytes;
    UINT64 MmTotalCommitLimit;
    UINT64 MmTotalCommittedPages;
    UINT64 MmSharedCommit;
    UINT64 MmDriverCommit;
    UINT64 MmProcessCommit;
    UINT64 MmPagedPoolCommit;
    UINT64 MmExtendedCommit;
    UINT64 MmZeroedPageListHead;
    UINT64 MmFreePageListHead;
    UINT64 MmStandbyPageListHead;
    UINT64 MmModifiedPageListHead;
    UINT64 MmModifiedNoWritePageListHead;
    UINT64 MmAvailablePages;
    UINT64 MmResidentAvailablePages;
    UINT64 PoolTrackTable;
    UINT64 NonPagedPoolDescriptor;
    UINT64 MmHighestUserAddress;
    UINT64 MmSystemRangeStart;
    UINT64 MmUserProbeAddress;
    UINT64 KdPrintCircularBuffer;
    UINT64 KdPrintCircularBufferEnd;
    UINT64 KdPrintWritePointer;
    UINT64 KdPrintRolloverCount;
    UINT64 MmLoadedUserImageList;

    /* NT 5.1 Addition */

    UINT64 NtBuildLab;
    UINT64 KiNormalSystemCall;

    /* NT 5.0 hotfix addition */

    UINT64 KiProcessorBlock;
    UINT64 MmUnloadedDrivers;
    UINT64 MmLastUnloadedDriver;
    UINT64 MmTriageActionTaken;
    UINT64 MmSpecialPoolTag;
    UINT64 KernelVerifier;
    UINT64 MmVerifierData;
    UINT64 MmAllocatedNonPagedPool;
    UINT64 MmPeakCommitment;
    UINT64 MmTotalCommitLimitMaximum;
    UINT64 CmNtCSDVersion;

    /* NT 5.1 Addition */

    UINT64 MmPhysicalMemoryBlock;
    UINT64 MmSessionBase;
    UINT64 MmSessionSize;
    UINT64 MmSystemParentTablePage;

    /* Server 2003 addition */

    UINT64 MmVirtualTranslationBase;
    UINT16 OffsetKThreadNextProcessor;
    UINT16 OffsetKThreadTeb;
    UINT16 OffsetKThreadKernelStack;
    UINT16 OffsetKThreadInitialStack;
    UINT16 OffsetKThreadApcProcess;
    UINT16 OffsetKThreadState;
    UINT16 OffsetKThreadBStore;
    UINT16 OffsetKThreadBStoreLimit;
    UINT16 SizeEProcess;
    UINT16 OffsetEprocessPeb;
    UINT16 OffsetEprocessParentCID;
    UINT16 OffsetEprocessDirectoryTableBase;
    UINT16 SizePrcb;
    UINT16 OffsetPrcbDpcRoutine;
    UINT16 OffsetPrcbCurrentThread;
    UINT16 OffsetPrcbMhz;
    UINT16 OffsetPrcbCpuType;
    UINT16 OffsetPrcbVendorString;
    UINT16 OffsetPrcbProcStateContext;
    UINT16 OffsetPrcbNumber;
    UINT16 SizeEThread;
    UINT64 KdPrintCircularBufferPtr;
    UINT64 KdPrintBufferSize;
    UINT64 KeLoaderBlock;
    UINT16 SizePcr;
    UINT16 OffsetPcrSelfPcr;
    UINT16 OffsetPcrCurrentPrcb;
    UINT16 OffsetPcrContainedPrcb;
    UINT16 OffsetPcrInitialBStore;
    UINT16 OffsetPcrBStoreLimit;
    UINT16 OffsetPcrInitialStack;
    UINT16 OffsetPcrStackLimit;
    UINT16 OffsetPrcbPcrPage;
    UINT16 OffsetPrcbProcStateSpecialReg;
    UINT16 GdtR0Code;
    UINT16 GdtR0Data;
    UINT16 GdtR0Pcr;
    UINT16 GdtR3Code;
    UINT16 GdtR3Data;
    UINT16 GdtR3Teb;
    UINT16 GdtLdt;
    UINT16 GdtTss;
    UINT16 Gdt64R3CmCode;
    UINT16 Gdt64R3CmTeb;
    UINT64 IopNumTriageDumpDataBlocks;
    UINT64 IopTriageDumpDataBlocks;

    /* Longhorn addition */

    UINT64 VfCrashDataBlock;
    UINT64 MmBadPagesDetected;
    UINT64 MmZeroedPageSingleBitErrorsDetected;

    /* Windows 7 addition */

    UINT64 EtwpDebuggerData;
    UINT16 OffsetPrcbContext;
    UCHAR PAD[0x40];
} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;

extern "C"
NTKERNELAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

extern "C"
NTKERNELAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
    _In_ PVOID ImageBase,
    _In_ PCCH RoutineNam
);
```

`README.md`:

```md
# KDBGDecryptor
A simple example how to decrypt kernel debugger data block with two different methods:

1. By calling KdDecodeBlockData 
2. By copying encrypted kdbg struct from memory and then decrypting it with KiWaitNever and KiWaitAlways (more stealthy)

This sample was tested on Windows 20H2 (build 19042)
```