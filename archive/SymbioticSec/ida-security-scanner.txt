Project Path: arc_SymbioticSec_ida-security-scanner_xcq97ea2

Source Tree:

```txt
arc_SymbioticSec_ida-security-scanner_xcq97ea2
├── LICENSE
├── README.md
├── __init__.py
├── ai_prompts.py
├── ai_provider.py
├── code-rules.yaml
├── config.py
├── ida-plugin.json
├── img
│   ├── Interface.png
│   ├── ai-config.png
│   ├── ia-response.png
│   └── scan-possibilities.png
├── scanner.py
├── symbiotic-logo.jpg
├── symbiotic_ida_plugin.py
└── viewer.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2025

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IDA Security Scanner

<p align="center">
  <img src="https://img.shields.io/badge/IDA%20Pro-9.1%2B-blue?style=for-the-badge" alt="IDA Pro 9.1+"/>
  <img src="https://img.shields.io/badge/Python-3.10%2B-green?style=for-the-badge" alt="Python 3.10+"/>
</p>

<p align="center">
  <b>Automated vulnerability detection in IDA Pro using SAST rules on decompiled code</b>
</p>

---

<p align="center">
  <img src="img/Interface.png" alt="IDA Security Scanner Interface" width="800"/>
</p>

---

## What is IDA Security Scanner?

IDA Security Scanner bridges the gap between **binary reverse engineering** and **static code analysis**. Instead of manually hunting for vulnerabilities in decompiled code, this plugin:

1. **Extracts pseudocode** from IDA's Hex-Rays decompiler
2. **Runs SAST rules** via [opengrep](https://github.com/opengrep/opengrep) on the C-like output
3. **Displays results** in an interactive UI directly inside IDA
4. **Provides AI explanations** (optional) for each finding

Perfect for **vulnerability research**, **CTF challenges**, and **security audits**.

---

## Installation

### 1. Copy the plugin folder

```bash
# macOS
cp -r symbiotic /Applications/IDA*/Contents/MacOS/plugins/

# Windows
xcopy symbiotic %IDADIR%\plugins\symbiotic\ /E /I

# Linux
cp -r symbiotic ~/.idapro/plugins/
```

### 2. Install opengrep

Download the **opengrep** binary from the official releases:

**https://github.com/opengrep/opengrep/releases**

Rename the binary to `opengrep-core` and place it in the IDA **plugins folder** (same location as the plugin):

```bash
# macOS
mv opengrep /Applications/IDA*/Contents/MacOS/plugins/opengrep-core

# Windows
move opengrep.exe %IDADIR%\plugins\opengrep-core.exe

# Linux
mv opengrep ~/.idapro/plugins/opengrep-core
```

> **Note**: The plugin expects the binary at `plugins/opengrep-core` by default. You can change this path in the plugin settings.

### 3. Configure AI (Optional)

See the [AI Integration](#-ai-integration) section below.

---

## Usage

| Shortcut | Action |
|----------|--------|
| `Ctrl+Shift+S` | Scan **current function** |
| `Ctrl+Shift+L` | Scan **ALL functions** |
| `Ctrl+Shift+A` | **Ask AI** about selected finding |

<p align="center">
  <img src="img/scan-possibilities.png" alt="Scan Options" width="600"/>
</p>

---

## Detection Rules

IDA Security Scanner uses **YAML-based rules** powered by [opengrep](https://github.com/opengrep/opengrep) (a semgrep fork). Rules are defined in `code-rules.yaml`.

### Adding Custom Rules

**Why add custom rules?**
- Target **specific vulnerability patterns** for your audit
- Detect **proprietary API misuse** in embedded systems
- Create rules for **CTF-specific patterns**
- Hunt for **known CVE patterns** in binaries

**How to add a rule:**

Edit `code-rules.yaml` and add your pattern:

```yaml
rules:
  # Example: Detect dangerous gets() usage
  - id: BUFFER_OVERFLOW_GETS
    languages: [c]
    message: "Buffer overflow: gets() has no bounds checking"
    pattern: gets($BUF)
    severity: CRITICAL

  # Example: Detect potential integer overflow
  - id: INTEGER_OVERFLOW
    languages: [c]
    message: "Potential integer overflow in malloc size calculation"
    pattern: malloc($X * $Y)
    severity: WARNING

  # Example: Detect hardcoded credentials
  - id: HARDCODED_PASSWORD
    languages: [c]
    message: "Hardcoded password detected"
    pattern-regex: '(password|passwd|pwd)\s*=\s*"[^"]+"'
    severity: HIGH
```

**Pattern syntax reference:** See [opengrep/semgrep documentation](https://semgrep.dev/docs/writing-rules/pattern-syntax/)

**See the full rules file:** [`code-rules.yaml`](code-rules.yaml)

---

## AI Integration

IDA Security Scanner can use **LLM APIs** to provide detailed explanations of detected vulnerabilities and suggest exploitation paths.

### Quick Setup

1. **Copy the example configuration:**
   ```bash
   cp .env.example .env
   ```

2. **Edit `.env`** with your API credentials (see below)

3. **Use `Ctrl+Shift+A`** on any finding to get AI analysis

### Supported Providers

| Provider | Documentation | How to get API Key |
|----------|---------------|-------------------|
| **OpenAI** | [platform.openai.com](https://platform.openai.com/docs) | [Get API Key](https://platform.openai.com/api-keys) |
| **Anthropic (Claude)** | [docs.anthropic.com](https://docs.anthropic.com/) | [Get API Key](https://console.anthropic.com/settings/keys) |
| **Google Gemini** | [ai.google.dev](https://ai.google.dev/docs) | Requires OpenAI-compatible proxy |
| **Local Models** | Via [Ollama](https://ollama.ai/), [LM Studio](https://lmstudio.ai/) | Use OpenAI-compatible endpoint |

### Configuration Example

```bash
# .env file
AI_PROVIDER=openai
AI_API_KEY=sk-your-api-key-here
AI_MODEL=gpt-5.2
AI_BASE_URL=https://api.openai.com/v1  # Optional, for custom endpoints
```

<p align="center">
  <img src="img/ai-config.png" alt="AI Configuration" width="500"/>
</p>

### AI Response Example

<p align="center">
  <img src="img/ia-response.png" alt="AI Response" width="700"/>
</p>

---

## Features

- **Automatic Vulnerability Detection** — Scans decompiled functions for dangerous patterns
- **YAML-based Rules** — Easy to customize and extend with your own patterns
- **Interactive UI** — Filter by severity, function name, add custom tags
- **AI Analysis** — Get detailed explanations via LLM integration
- **Persistent State** — Tags and notes survive between IDA sessions
- **Fast Scanning** — Leverages opengrep's optimized pattern matching

---

## Credits

- [opengrep](https://github.com/opengrep/opengrep) — Static analysis engine (semgrep fork)
- [IDA Pro](https://hex-rays.com/) — Reverse engineering platform

---

## License

MIT License — See [LICENSE](LICENSE) for details.

```

`__init__.py`:

```py
# IDA Security Scanner - Package
# Security vulnerability scanner for IDA Pro

from .config import SymbioticConfig, configure_symbiotic
from .scanner import SymbioticScanner
from .viewer import SymbioticResultsViewer
from .ai_provider import AIProvider
from .ai_prompts import explain_vulnerability, generate_poc, analyze_function

__all__ = [
    "SymbioticConfig", 
    "SymbioticScanner", 
    "SymbioticResultsViewer",
    "AIProvider",
    "configure_symbiotic",
    "explain_vulnerability",
    "generate_poc",
    "analyze_function"
]

```

`ai_prompts.py`:

```py
"""
AI Prompts Module
Security analysis prompts for LLM-based vulnerability analysis.
"""

from .ai_provider import AIProvider


def explain_vulnerability(provider: AIProvider, vuln_title: str, 
                          vuln_cwe: str, code_snippet: str) -> str:
    """Generate AI explanation of a vulnerability."""
    prompt = f"""You are a security researcher analyzing decompiled binary code from IDA Pro.

**Vulnerability Report:**
- Title: {vuln_title}
- CWE: {vuln_cwe}

**Flagged Code:**
```c
{code_snippet}
```

**CRITICAL: First, assess if this is a REAL vulnerability or a FALSE POSITIVE.**

Analyze the code carefully:
- Is the vulnerability actually exploitable in this context?
- Are there any mitigations, bounds checks, or safe usages visible?
- Could this be a safe pattern that just looks similar to a vulnerability?

**Your response MUST start with one of these verdicts:**
- `[CONFIRMED VULNERABILITY]` - if the code is genuinely vulnerable
- `[LIKELY FALSE POSITIVE]` - if this appears to be incorrectly flagged

Then provide:
1. **Verdict Explanation**: Why you classified it this way
2. **Technical Analysis**: Detailed explanation of the code behavior
3. **If CONFIRMED**: Attack vector, impact, and fix recommendation
4. **If FALSE POSITIVE**: Why the static analyzer incorrectly flagged this

Format with markdown. Be precise and technical."""

    return provider.call(prompt, temperature=0.3)


def generate_poc(provider: AIProvider, vuln_title: str,
                 vuln_cwe: str, code_snippet: str, func_name: str) -> str:
    """Generate proof-of-concept exploit for a vulnerability."""
    prompt = f"""You are creating a proof-of-concept exploit for educational purposes.

**Target Vulnerability:**
- Function: {func_name}
- Title: {vuln_title}
- CWE: {vuln_cwe}

**Vulnerable Code:**
```c
{code_snippet}
```

**Instructions:**
1. Create a minimal PoC that demonstrates the vulnerability
2. Show input that would trigger the bug
3. Explain what happens when the PoC runs
4. Include Python/C code if applicable

This is for security research only. Format with markdown code blocks."""

    return provider.call(prompt, temperature=0.5)


def analyze_function(provider: AIProvider, pseudocode: str, func_name: str) -> str:
    """Analyze a function for security issues."""
    prompt = f"""You are a security researcher analyzing decompiled code from IDA Pro.

**Function: {func_name}**

```c
{pseudocode}
```

**Analyze this function for:**
1. Security vulnerabilities (buffer overflows, format strings, injections, etc.)
2. Interesting security-relevant behavior
3. Potential attack vectors
4. Cryptographic operations or sensitive data handling

Provide a detailed security analysis. Format with markdown."""

    return provider.call(prompt, temperature=0.4)

```

`ai_provider.py`:

```py
"""
AI Provider Module - OpenAI Client
Simple wrapper using OpenAI client for calling LLM providers.
"""

import os

DEFAULT_MODEL = "claude-sonnet-4-5"

try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    print("[Symbiotic] Warning: openai not installed. Run: pip install openai")


class AIProvider:
    """Universal AI Provider using OpenAI client."""

    def __init__(self, model: str = None, api_key: str = None, api_base: str = None):
        """
        Initialize AI Provider.

        Args:
            model: Model name (e.g., "claude-sonnet-4-5", "claude-haiku-4-5")
            api_key: API key for the provider
            api_base: Custom API base URL (for proxies like Symbiotic)
        """
        self.model = model or DEFAULT_MODEL
        # Remove provider prefix if present (e.g., "openai/claude-sonnet-4.5" -> "claude-sonnet-4.5")
        if "/" in self.model:
            self.model = self.model.split("/", 1)[1]
        self.api_key = api_key
        self.api_base = api_base
        self.client = None

        if OPENAI_AVAILABLE and api_key and api_base:
            self.client = OpenAI(base_url=api_base, api_key=api_key)

    def call(self, prompt: str, temperature: float = 0.7, max_tokens: int = 8192) -> str:
        """Call the LLM with given prompt."""
        if not OPENAI_AVAILABLE:
            return "Error: openai not installed. Run: pip install openai"

        if not self.client:
            return "Error: AI not configured. Check API key and base URL."

        try:
            print(f"[Symbiotic AI] Calling {self.model} (base: {self.api_base or 'default'})")

            response = self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": prompt}],
                temperature=temperature,
                max_tokens=max_tokens,
            )
            return response.choices[0].message.content

        except Exception as e:
            return f"Error calling {self.model}: {e}"


def get_provider(model: str = None, api_key: str = None, api_base: str = None) -> AIProvider:
    """Factory function to get AI provider."""
    return AIProvider(model=model, api_key=api_key, api_base=api_base)

```

`code-rules.yaml`:

```yaml
rules:
# ============================================================================
# IDA Security Scanner - Detection Rules
# SAST rules for IDA Pro decompiled C code
# ============================================================================

# ---------------------------
# Buffer Overflow: gets()
# ---------------------------
- id: BUFFER_OVERFLOW_GETS
  languages: [c]
  message: |
    CRITICAL: gets() - Buffer Overflow
    
    The gets() function reads input without ANY size limit.
    There is NO safe way to use this function.
  metadata:
    cwe: 'CWE-120'
    title: "gets() Buffer Overflow"
  pattern: gets($BUF)
  severity: CRITICAL

# ---------------------------
# Buffer Overflow: scanf %s
# ---------------------------
- id: BUFFER_OVERFLOW_SCANF
  languages: [c]
  message: |
    CRITICAL: scanf("%s") - Unbounded Input
    
    The %s format specifier without width limit reads until whitespace.
    Fix: Use width specifier like scanf("%255s", buf).
  metadata:
    cwe: 'CWE-120'
    title: "scanf %s Unbounded"
  pattern: scanf("%s", $BUF)
  severity: CRITICAL

# ---------------------------
# Format String: printf(argv[N])
# ---------------------------
- id: FORMAT_STRING_ARGV
  languages: [c]
  message: |
    CRITICAL: Format String Attack
    
    Command-line argument used directly as format string.
    Attacker can use %x to leak stack, %n to write memory.
  metadata:
    cwe: 'CWE-134'
    title: "Format String"
  pattern-either:
  - pattern: printf(argv[$N])
  - pattern: fprintf($FD, argv[$N])
  - pattern: sprintf($DST, argv[$N])
  severity: CRITICAL

# ---------------------------
# Command Injection: strcat + system
# ---------------------------
- id: COMMAND_INJECTION_STRCAT
  languages: [c]
  message: |
    HIGH: Command Injection - strcat() then system()
    
    Data is concatenated to a command string then executed.
    Shell metacharacters (;|`$) can inject arbitrary commands.
  metadata:
    cwe: 'CWE-78'
    title: "Command Injection"
  pattern: |
    strcat($CMD, ...);
    ...
    system($CMD);
  severity: HIGH

# ---------------------------
# Command Injection: sprintf + system
# ---------------------------
- id: COMMAND_INJECTION_SPRINTF
  languages: [c]
  message: |
    HIGH: Command Injection - sprintf() then system()
    
    Command built with sprintf() then executed with system().
  metadata:
    cwe: 'CWE-78'
    title: "Command Injection"
  pattern: |
    sprintf($CMD, ...);
    ...
    system($CMD);
  severity: HIGH

# ---------------------------
# Privilege Escalation: setreuid + system
# ---------------------------
- id: PRIVESC_SETREUID
  languages: [c]
  message: |
    HIGH: Privilege Escalation
    
    setreuid() followed by system() call.
    Common in SUID binaries - target for exploitation.
  metadata:
    cwe: 'CWE-269'
    title: "Privilege Escalation"
  pattern: |
    setreuid(...);
    ...
    system(...);
  severity: HIGH

# ---------------------------
# Privilege Escalation: setuid + system
# ---------------------------
- id: PRIVESC_SETUID
  languages: [c]
  message: |
    HIGH: Privilege Escalation
    
    setuid() followed by system() call.
  metadata:
    cwe: 'CWE-269'
    title: "Privilege Escalation"
  pattern: |
    setuid(...);
    ...
    system(...);
  severity: HIGH

# ---------------------------
# Backdoor Pattern
# ---------------------------
- id: BACKDOOR_SHELL
  languages: [c]
  message: |
    MEDIUM: Potential Backdoor
    
    execve() spawning a shell detected.
    Could be admin functionality, CTF target, or actual backdoor.
  metadata:
    cwe: 'CWE-506'
    title: "Shell Backdoor"
  pattern-either:
  - pattern: execve("/bin/bash", ...)
  - pattern: execve("/bin/sh", ...)
  severity: MEDIUM

# ---------------------------
# Dangerous strcpy
# ---------------------------
- id: DANGEROUS_STRCPY
  languages: [c]
  message: |
    MEDIUM: Unsafe strcpy()
    
    strcpy() does not check destination buffer size.
    Consider using strncpy() or strlcpy().
  metadata:
    cwe: 'CWE-120'
    title: "Unsafe strcpy"
  pattern: strcpy($DST, $SRC)
  severity: MEDIUM

# ---------------------------
# Dangerous sprintf
# ---------------------------
- id: DANGEROUS_SPRINTF
  languages: [c]
  message: |
    MEDIUM: Unsafe sprintf()
    
    sprintf() does not check destination buffer size.
    Consider using snprintf().
  metadata:
    cwe: 'CWE-120'
    title: "Unsafe sprintf"
  pattern: sprintf($DST, $FMT, ...)
  severity: MEDIUM

```

`config.py`:

```py
"""
Configuration Module
Manages opengrep-core and AI configuration for IDA plugin
"""

import os

# Configuration file paths
# PLUGIN_DIR = where this plugin lives (symbiotic folder)
# PLUGINS_DIR = IDA plugins folder (parent, where .env goes)
PLUGIN_DIR = os.path.dirname(__file__)
PLUGINS_DIR = os.path.dirname(PLUGIN_DIR)
ENV_FILE = os.path.join(PLUGINS_DIR, ".env")


def load_env_file(env_path):
    """Load variables from .env file"""
    env_vars = {}
    if os.path.exists(env_path):
        try:
            with open(env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        env_vars[key.strip()] = value.strip()
        except Exception as e:
            print(f"[Symbiotic] Failed to load .env: {e}")
    else:
        print(f"[Symbiotic] Warning: .env not found at {env_path}")
    return env_vars


class SymbioticConfig:
    """Manage opengrep and AI configuration"""

    def __init__(self):
        self.opengrep_path = os.path.join(PLUGINS_DIR, "opengrep-core")
        rules_in_plugin = os.path.join(PLUGIN_DIR, "code-rules.yaml")
        rules_in_plugins = os.path.join(PLUGINS_DIR, "code-rules.yaml")
        self.rules_path = rules_in_plugin if os.path.exists(rules_in_plugin) else rules_in_plugins

        self.ai_model = "gemini/gemini-3-flash"
        self.ai_api_key = ""
        self.ai_api_base = ""

        self.load()

    def load(self):
        """Load configuration from .env file"""
        env_vars = load_env_file(ENV_FILE)
        if env_vars:
            self.ai_model = env_vars.get("AI_MODEL", "gemini/gemini-3-flash")
            self.ai_api_key = env_vars.get("AI_API_KEY", "")
            self.ai_api_base = env_vars.get("AI_API_BASE", "")
            
            print(f"[Symbiotic] Config loaded: model={self.ai_model}, api_base={self.ai_api_base or '(none)'}")

    def is_configured(self):
        """Check if scanner is configured"""
        return bool(self.opengrep_path and os.path.exists(self.opengrep_path))
    
    def is_ai_configured(self):
        """Check if AI is configured"""
        return bool(self.ai_api_key)

    def get_status_string(self):
        """Return configuration status string"""
        opengrep_exists = "[OK]" if self.opengrep_path and os.path.exists(self.opengrep_path) else "[X]"
        rules_exists = "[OK]" if self.rules_path and os.path.exists(self.rules_path) else "[X]"
        ai_status = "[OK]" if self.is_ai_configured() else "[X]"
        api_key_display = self.ai_api_key[:10] + "..." if self.ai_api_key else "(not set)"
        api_base_display = self.ai_api_base if self.ai_api_base else "(direct)"
        status = "[OK] Configured" if self.is_configured() else "[X] Not configured"
        
        return f"""Scanner Configuration:
  Opengrep Path: {self.opengrep_path or '(not set)'}
  Rules Path:    {self.rules_path or '(not set)'}
  Opengrep:      {opengrep_exists}
  Rules:         {rules_exists}
  
AI Configuration:
  Model:         {self.ai_model}
  API Key:       {api_key_display}
  API Base:      {api_base_display}
  AI Features:   {ai_status}
  
Status: {status}"""


def configure_symbiotic(config):
    """Configuration dialog using IDA dialogs"""
    import ida_kernwin
    
    def show_main_menu():
        return f"""Symbiotic Configuration
{'='*40}
{config.get_status_string()}
{'='*40}

Configure scanner paths below.
AI is configured via .env file."""

    while True:
        result = ida_kernwin.ask_buttons(
            "Scanner", 
            "Done", 
            "", 
            1, 
            show_main_menu()
        )
        
        if result == 1:
            configure_scanner(config)
        else:
            break

    return config.is_configured()


def configure_scanner(config):
    """Scanner configuration submenu"""
    import ida_kernwin
    
    while True:
        menu = f"""Scanner Configuration
{'='*40}
Opengrep: {config.opengrep_path or '(not set)'}
Rules:    {config.rules_path or '(not set)'}
{'='*40}"""
        
        result = ida_kernwin.ask_buttons("Opengrep Path", "Rules Path", "Back", 1, menu)
        
        if result == 1:
            new_path = ida_kernwin.ask_file(0, config.opengrep_path or "", "Select opengrep-core binary")
            if new_path:
                config.opengrep_path = new_path
        elif result == 2:
            new_path = ida_kernwin.ask_file(0, config.rules_path or "", "Select rules YAML file")
            if new_path:
                config.rules_path = new_path
        else:
            break

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "ida-security-scanner",
    "entryPoint": "symbiotic_ida_plugin.py",
    "version": "0.1.2",
    "idaVersions": [
      "9.1",
      "9.2"
    ],
    "platforms": [
      "windows-x86_64",
      "linux-x86_64",
      "macos-x86_64",
      "macos-aarch64"
    ],
    "categories": [
      "vulnerability-research-and-exploit-development",
      "decompilation"
    ],
    "keywords": [
      "security",
      "vulnerability",
      "sast",
      "scanner",
      "opengrep"
    ],
    "description": "Security scanner combining IDA decompilation with SAST rules to detect vulnerabilities in pseudocode",
    "pythonDependencies": [
      "litellm>=1.0.0",
      "python-dotenv>=1.0.0"
    ],
    "license": "MIT",
    "urls": {
      "repository": "https://github.com/SymbioticSec/ida-security-scanner"
    },
    "logoPath": "symbiotic-logo.jpg",
    "authors": [
      {
        "name": "Symbiotic Security",
        "email": "anthony.bondu@symbioticsec.ai"
      }
    ]
  }
}
```

`scanner.py`:

```py
"""
Scanner Module
Scans code using opengrep-core
"""

import os
import subprocess
import tempfile
import json
import threading

import idaapi
import ida_hexrays
import ida_funcs
import idautils
import idc
import ida_kernwin
import ida_lines


class ScanThread(threading.Thread):
    """Background thread for scanning"""
    
    def __init__(self, scanner, scan_func, *args):
        super().__init__()
        self.scanner = scanner
        self.scan_func = scan_func
        self.args = args
        self.result = None
        self.error = None
        
    def run(self):
        try:
            self.result = self.scan_func(*self.args)
        except Exception as e:
            self.error = str(e)


class SymbioticScanner:
    """Scanner using opengrep-core with cancel support"""

    def __init__(self, config):
        self.config = config
        self._pseudocode_cache = {}  # Cache pseudocode for line mapping
        self._cancel_requested = False
        self._current_process = None

    def cancel_scan(self):
        """Request cancellation of current scan"""
        self._cancel_requested = True
        if self._current_process:
            try:
                self._current_process.terminate()
                print("[Symbiotic] Scan cancelled by user")
            except:
                pass

    def is_cancelled(self):
        """Check if cancel was requested"""
        return self._cancel_requested

    def reset_cancel(self):
        """Reset cancel flag for new scan"""
        self._cancel_requested = False
        self._current_process = None

    def extract_pseudocode(self, ea):
        """Extract pseudocode from a function at given address and build line→EA mapping"""
        try:
            cfunc = ida_hexrays.decompile(ea)
            if cfunc:
                code = str(cfunc)
                code_lines = code.split('\n')
                
                line_ea_map = {}
                try:
                    sv = cfunc.get_pseudocode()

                    for line_idx in range(len(sv)):
                        sl = sv[line_idx]
                        line_text = ida_lines.tag_remove(sl.line)

                        found_ea = idaapi.BADADDR
                        for item_ea, items in cfunc.eamap.items():
                            if item_ea != idaapi.BADADDR:
                                for item in items:
                                    if hasattr(item, 'loc') and item.loc:
                                        if item.loc.line == line_idx:
                                            found_ea = item_ea
                                            break
                                if found_ea != idaapi.BADADDR:
                                    break
                        
                        line_ea_map[line_idx] = found_ea

                except Exception as e:
                    print(f"[Symbiotic] EA mapping error: {e}")

                self._pseudocode_cache[ea] = {
                    'lines': code_lines,
                    'line_ea_map': line_ea_map,
                    'cfunc': cfunc
                }
                return code
        except Exception as e:
            print(f"[Symbiotic] Failed to decompile function at {hex(ea)}: {e}")
        return None

    def get_pseudocode_line(self, ea, line_number):
        """Get specific line from cached pseudocode"""
        if ea in self._pseudocode_cache:
            cache = self._pseudocode_cache[ea]
            lines = cache.get('lines', []) if isinstance(cache, dict) else cache
            if 0 < line_number <= len(lines):
                return lines[line_number - 1]
        return None

    def get_line_ea(self, func_ea, relative_line):
        """Get the EA (address) for a specific relative line in a function's pseudocode"""
        if func_ea in self._pseudocode_cache:
            cache = self._pseudocode_cache[func_ea]
            if isinstance(cache, dict):
                line_ea_map = cache.get('line_ea_map', {})
                return line_ea_map.get(relative_line, idaapi.BADADDR)
        return idaapi.BADADDR

    def extract_function_code(self, ea):
        """Extract disassembly code from a function"""
        func = ida_funcs.get_func(ea)
        if not func:
            return None

        lines = []
        for head in idautils.Heads(func.start_ea, func.end_ea):
            disasm = idc.GetDisasm(head)
            if disasm:
                lines.append(disasm)

        return "\n".join(lines)

    def create_temp_file(self, code, filename="code.c"):
        """Create a temporary file with the code"""
        temp_dir = tempfile.mkdtemp(prefix="symbiotic_")
        temp_file = os.path.join(temp_dir, filename)

        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(code)

        return temp_dir, temp_file

    def scan_code(self, code, language="c"):
        """Scan code using opengrep-core"""
        print("[Symbiotic] Preparing opengrep scan...")

        extensions = {
            "c": "code.c",
            "cpp": "code.cpp",
        }
        filename = extensions.get(language, "code.c")

        temp_dir, temp_file = self.create_temp_file(code, filename)

        try:
            cmd = [self.config.opengrep_path, "-json"]

            if self.config.rules_path and os.path.exists(self.config.rules_path):
                cmd.extend(["-rules", self.config.rules_path])
            else:
                print("[Symbiotic] ERROR: No rules file configured!")
                return {"error": "No rules file configured"}

            cmd.extend(["-lang", language, temp_file])

            print(f"[Symbiotic] Executing: {' '.join(cmd)}")

            self._current_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='ignore'
            )
            
            try:
                stdout, stderr = self._current_process.communicate(timeout=300)
            except subprocess.TimeoutExpired:
                self._current_process.kill()
                return {"error": "Scan timeout (>300s)"}
            
            if self._cancel_requested:
                return {"error": "Scan cancelled by user"}

            output = stdout if stdout else ""
            stderr_out = stderr if stderr else ""

            if stderr_out:
                print(f"[Symbiotic] Stderr: {stderr_out[:500]}")

            source_lines = code.split('\n')
            converted_output = self._convert_opengrep_output(output, source_lines)
            
            return {
                "success": True,
                "output": converted_output,
                "raw_output": output,
                "stderr": stderr,
                "temp_dir": temp_dir,
                "scanner": "opengrep",
                "source_lines": source_lines
            }

        except subprocess.TimeoutExpired:
            return {"error": "Scan timeout (>300s)"}
        except Exception as e:
            import traceback
            traceback.print_exc()
            return {"error": f"Scan failed: {str(e)}"}

    def _convert_opengrep_output(self, raw_output, source_lines=None):
        """Convert opengrep JSON output to our expected format"""
        try:
            if not raw_output or not raw_output.strip():
                print("[Symbiotic] No output from opengrep")
                return json.dumps({"fail_results": []})
            
            json_start = raw_output.find('{')
            if json_start == -1:
                print("[Symbiotic] No JSON found in output")
                return json.dumps({"fail_results": []})

            json_output = raw_output[json_start:]
            data = json.loads(json_output)
            results = data.get("results", [])
            print(f"[Symbiotic] Found {len(results)} results in opengrep output")
            
            fail_results = []
            for r in results:
                check_id = r.get("check_id", "UNKNOWN")
                extra = r.get("extra", {})
                metadata = extra.get("metadata", {})

                start_info = r.get("start", {})
                end_info = r.get("end", {})
                start_line = start_info.get("line", 0)
                end_line = end_info.get("line", start_line)

                snippet = ""
                if source_lines and start_line > 0:
                    snippet_lines = source_lines[start_line - 1:end_line]
                    snippet = "\n".join(snippet_lines)
                
                vuln = {
                    "rule_id": check_id,
                    "title": metadata.get("title", extra.get("message", check_id)),
                    "severity": metadata.get("severity", "MEDIUM").upper() if metadata.get("severity") else "MEDIUM",
                    "description": extra.get("message", ""),
                    "snippet": snippet,
                    "cwe": metadata.get("cwe", ""),
                    "owasp": metadata.get("owasp", ""),
                    "impact": metadata.get("impact", ""),
                    "impact_level": metadata.get("impact_level", "MEDIUM"),
                    "likelihood_level": metadata.get("likelihood_level", "MEDIUM"),
                    "confidence_level": metadata.get("confidence_level", "MEDIUM"),
                    "references": metadata.get("references", []),
                    "location": {
                        "start_line": start_line,
                        "end_line": end_line,
                        "path": r.get("path", "")
                    }
                }
                fail_results.append(vuln)
                print(f"[Symbiotic]   - {check_id}: {metadata.get('title', 'Unknown')} @ line {start_line}")
            
            return json.dumps({"fail_results": fail_results})
        except json.JSONDecodeError as e:
            print(f"[Symbiotic] JSON parse error: {e}")
            print(f"[Symbiotic] Raw output: {raw_output[:1000] if raw_output else 'empty'}")
            return json.dumps({"fail_results": []})
        except Exception as e:
            print(f"[Symbiotic] Error converting output: {e}")
            import traceback
            traceback.print_exc()
            return json.dumps({"fail_results": []})

    def scan_function(self, ea):
        """Scan a function at given address"""
        func_name = idc.get_func_name(ea)
        print(f"[Symbiotic] Scanning function: {func_name} at {hex(ea)}")

        code = self.extract_pseudocode(ea)
        if code:
            print(f"[Symbiotic] Extracted pseudocode ({len(code)} chars)")
            result = self.scan_code(code, "c")
        else:
            print("[Symbiotic] Pseudocode not available, using disassembly")
            code = self.extract_function_code(ea)
            if code:
                result = self.scan_code(code, "c")
            else:
                return {"error": "Failed to extract code from function"}

        result["function_name"] = func_name
        result["address"] = hex(ea)
        result["scan_type"] = "single_function"

        self.annotate_findings(result, ea)

        return result

    def scan_function_async(self, ea, callback):
        """Scan function in background thread"""
        func_name = idc.get_func_name(ea)
        print(f"[Symbiotic] Scanning function (async): {func_name} at {hex(ea)}")

        code = self.extract_pseudocode(ea)
        if not code:
            print("[Symbiotic] Pseudocode not available, using disassembly")
            code = self.extract_function_code(ea)
            if not code:
                callback({"error": "Failed to extract code from function"})
                return None

        print(f"[Symbiotic] Extracted code ({len(code)} chars)")

        def _scan_and_callback():
            result = self.scan_code(code, "c")
            result["function_name"] = func_name
            result["address"] = hex(ea)
            result["scan_type"] = "single_function"

            def _annotate_and_show():
                self.annotate_findings(result, ea)
                callback(result)
            
            ida_kernwin.execute_sync(_annotate_and_show, ida_kernwin.MFF_FAST)
        
        thread = threading.Thread(target=_scan_and_callback)
        thread.start()
        return thread

    def scan_all_functions(self):
        """Scan all functions in the binary"""
        print("\n" + "=" * 70)
        print("[Symbiotic] SCAN ALL FUNCTIONS")
        print("=" * 70)

        all_funcs = []
        for func_ea in idautils.Functions():
            func = ida_funcs.get_func(func_ea)
            if func:
                func_name = idc.get_func_name(func_ea)
                all_funcs.append((func_ea, func_name))

        total_funcs = len(all_funcs)
        print(f"[Symbiotic] Found {total_funcs} functions to scan")

        all_code = []
        func_line_map = {}
        current_line = 1

        for func_ea, func_name in all_funcs:
            code = self.extract_pseudocode(func_ea)
            if code:
                lines = code.count('\n') + 1
                func_line_map[func_ea] = {
                    "name": func_name,
                    "start_line": current_line,
                    "end_line": current_line + lines - 1
                }
                all_code.append(f"// Function: {func_name} @ {hex(func_ea)}")
                all_code.append(code)
                all_code.append("")
                current_line += lines + 2

        if not all_code:
            return {"error": "No functions could be decompiled"}

        combined_code = "\n".join(all_code)
        print(f"[Symbiotic] Combined {len(all_code)} functions ({len(combined_code)} chars)")

        result = self.scan_code(combined_code, "c")
        result["total_functions"] = total_funcs
        result["functions_scanned"] = len(func_line_map)
        result["scan_type"] = "all_functions"
        result["func_line_map"] = func_line_map

        # Annotate functions
        self.annotate_all_functions(result, func_line_map)

        return result

    def scan_all_functions_async(self, callback):
        """Scan all functions in background thread"""
        print("\n" + "=" * 70)
        print("[Symbiotic] SCAN ALL FUNCTIONS (async)")
        print("=" * 70)

        all_funcs = []
        for func_ea in idautils.Functions():
            func = ida_funcs.get_func(func_ea)
            if func:
                func_name = idc.get_func_name(func_ea)
                all_funcs.append((func_ea, func_name))

        total_funcs = len(all_funcs)
        print(f"[Symbiotic] Found {total_funcs} functions to scan")

        all_code = []
        func_line_map = {}
        current_line = 1

        for i, (func_ea, func_name) in enumerate(all_funcs):
            if i % 5 == 0:
                ida_kernwin.replace_wait_box(f"Decompiling function {i+1}/{total_funcs}...")
            
            code = self.extract_pseudocode(func_ea)
            if code:
                lines = code.count('\n') + 1
                func_line_map[func_ea] = {
                    "name": func_name,
                    "start_line": current_line,
                    "end_line": current_line + lines - 1
                }
                all_code.append(f"// Function: {func_name} @ {hex(func_ea)}")
                all_code.append(code)
                all_code.append("")
                current_line += lines + 2

        if not all_code:
            callback({"error": "No functions could be decompiled"})
            return None

        combined_code = "\n".join(all_code)
        print(f"[Symbiotic] Combined {len(func_line_map)} functions ({len(combined_code)} chars)")

        ida_kernwin.replace_wait_box("Running opengrep scan...")

        def _scan_and_callback():
            result = self.scan_code(combined_code, "c")
            result["total_functions"] = total_funcs
            result["functions_scanned"] = len(func_line_map)
            result["scan_type"] = "all_functions"
            result["func_line_map"] = func_line_map

            def _annotate_and_show():
                self.annotate_all_functions(result, func_line_map)
                callback(result)
            
            ida_kernwin.execute_sync(_annotate_and_show, ida_kernwin.MFF_FAST)
        
        thread = threading.Thread(target=_scan_and_callback)
        thread.start()
        return thread

    def annotate_findings(self, scan_result, func_addr=None):
        """Annotate IDA with vulnerability findings"""
        try:
            output = scan_result.get("output", "")
            if not output:
                return

            data = json.loads(output)
            findings = data.get("fail_results", [])

            if not findings:
                print("[Symbiotic] No vulnerabilities to annotate")
                return

            for finding in findings:
                title = finding.get("title", "Vulnerability")
                cwe = finding.get("cwe", "")
                
                comment = f"[VULN] {title}"
                if cwe:
                    comment += f" ({cwe})"

                if func_addr:
                    existing = idc.get_func_cmt(func_addr, 0) or ""
                    if comment not in existing:
                        new_comment = f"{existing}\n{comment}" if existing else comment
                        idc.set_func_cmt(func_addr, new_comment, 0)
                        idc.set_color(func_addr, idc.CIC_FUNC, 0xFF6B6B)
                        print(f"[Symbiotic]   [OK] Annotated function at {hex(func_addr)}")

            print("[Symbiotic] [OK] IDA annotations complete!")

        except Exception as e:
            print(f"[Symbiotic] Annotation error: {e}")

    def annotate_all_functions(self, scan_result, func_line_map):
        """Annotate all functions with their vulnerabilities"""
        try:
            output = scan_result.get("output", "")
            if not output:
                return

            data = json.loads(output)
            findings = data.get("fail_results", [])

            if not findings:
                return

            func_vulns = {}
            for finding in findings:
                loc = finding.get("location", {})
                vuln_line = loc.get("start_line", 0)

                for func_ea, info in func_line_map.items():
                    if info["start_line"] <= vuln_line <= info["end_line"]:
                        if func_ea not in func_vulns:
                            func_vulns[func_ea] = []
                        func_vulns[func_ea].append(finding)
                        break

            for func_ea, vulns in func_vulns.items():
                func_name = func_line_map[func_ea]["name"]
                func_start_line = func_line_map[func_ea]["start_line"]

                try:
                    cfunc = ida_hexrays.decompile(func_ea)
                    if cfunc:
                        sv = cfunc.get_pseudocode()
                        eamap = cfunc.get_eamap()
                        
                        for v in vulns:
                            title = v.get("title", "Vulnerability")
                            cwe = v.get("cwe", "")
                            snippet = v.get("snippet", "")
                            
                            cmt_text = f"VULN: {title}"
                            if cwe:
                                cmt_text += f" ({cwe})"

                            target_ea = None
                            if snippet:
                                snippet_clean = snippet.strip().split('\n')[0].strip()
                                for line_idx in range(len(sv)):
                                    line_text = ida_lines.tag_remove(sv[line_idx].line)
                                    if snippet_clean in line_text:
                                        for ea_addr, items in eamap.items():
                                            if ea_addr != idaapi.BADADDR:
                                                target_ea = ea_addr
                                                break
                                        break
                            
                            if target_ea and target_ea in eamap:
                                nearest_ea = eamap[target_ea][0].ea

                                if cfunc.has_orphan_cmts():
                                    cfunc.del_orphan_cmts()
                                    cfunc.save_user_cmts()

                                tl = idaapi.treeloc_t()
                                tl.ea = nearest_ea
                                success = False
                                for itp in range(idaapi.ITP_SEMI, idaapi.ITP_COLON):
                                    tl.itp = itp
                                    cfunc.set_user_cmt(tl, cmt_text)
                                    cfunc.save_user_cmts()
                                    cfunc.refresh_func_ctext()
                                    if not cfunc.has_orphan_cmts():
                                        success = True
                                        print(f"[Symbiotic]   Added comment @ {hex(nearest_ea)}: {cmt_text[:40]}...")
                                        break
                                    cfunc.del_orphan_cmts()
                                    cfunc.save_user_cmts()
                                
                                if not success:
                                    print(f"[Symbiotic]   Warning: Comment became orphaned")
                                    
                except Exception as e:
                    print(f"[Symbiotic] Inline comment error: {e}")

                comments = []
                for v in vulns:
                    title = v.get("title", "Vulnerability")
                    cwe = v.get("cwe", "")
                    snippet = v.get("snippet", "").strip().split('\n')[0][:60]
                    comment = f"// [VULN] {title}"
                    if cwe:
                        comment += f" ({cwe})"
                    if snippet:
                        comment += f" @ {snippet}"
                    comments.append(comment)

                existing = idc.get_func_cmt(func_ea, 0) or ""
                if "[VULN]" in existing:
                    existing = "\n".join([l for l in existing.split("\n") if "[VULN]" not in l])
                new_comment = existing + "\n" + "\n".join(comments) if existing.strip() else "\n".join(comments)
                idc.set_func_cmt(func_ea, new_comment.strip(), 0)
                idc.set_color(func_ea, idc.CIC_FUNC, 0xFF6B6B)

                print(f"[Symbiotic]   [OK] Annotated {func_name} with {len(vulns)} vuln(s)")

            print(f"[Symbiotic] [OK] Annotated {len(func_vulns)} vulnerable functions!")

        except Exception as e:
            print(f"[Symbiotic] Annotation error: {e}")
            import traceback
            traceback.print_exc()

```

`symbiotic_ida_plugin.py`:

```py
"""
IDA Security Scanner Plugin
Scans decompiled pseudocode for security vulnerabilities using opengrep-core.
Features AI analysis for explanations, PoC generation, and function analysis.
"""

import os
import sys

import idaapi
import ida_hexrays
import ida_kernwin
import ida_funcs
import idc

PLUGIN_DIR = os.path.dirname(__file__)
PARENT_DIR = os.path.dirname(PLUGIN_DIR)
if PARENT_DIR not in sys.path:
    sys.path.insert(0, PARENT_DIR)
if PLUGIN_DIR not in sys.path:
    sys.path.insert(0, PLUGIN_DIR)

from config import SymbioticConfig, configure_symbiotic
from scanner import SymbioticScanner
from viewer import SymbioticResultsViewer

# Load version from ida-plugin.json
import json
try:
    with open(os.path.join(PLUGIN_DIR, "ida-plugin.json"), "r") as f:
        VERSION = json.load(f).get("plugin", {}).get("version", "0.0.1")
except:
    VERSION = "0.1.2"


class ScanCurrentFunctionAction(ida_kernwin.action_handler_t):
    """Action handler for scanning current function"""
    
    def __init__(self, plugin):
        ida_kernwin.action_handler_t.__init__(self)
        self.plugin = plugin

    def activate(self, ctx):
        ea = ida_kernwin.get_screen_ea()
        self.plugin.scan_current_function(ea)
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class ScanAllFunctionsAction(ida_kernwin.action_handler_t):
    """Action handler for scanning all functions"""
    
    def __init__(self, plugin):
        ida_kernwin.action_handler_t.__init__(self)
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.scan_all_functions()
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class ConfigureAction(ida_kernwin.action_handler_t):
    """Action handler for configuration"""
    
    def __init__(self, plugin):
        ida_kernwin.action_handler_t.__init__(self)
        self.plugin = plugin

    def activate(self, ctx):
        configure_symbiotic(self.plugin.config)
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class AskAIAction(ida_kernwin.action_handler_t):
    """Action handler for Ask AI about current function"""
    
    def __init__(self, plugin):
        ida_kernwin.action_handler_t.__init__(self)
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.ask_ai_about_function()
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class SymbioticPlugin(idaapi.plugin_t):
    """Main IDA Plugin class"""
    
    flags = idaapi.PLUGIN_KEEP
    comment = "Symbiotic Security Scanner - Scan code for vulnerabilities"
    help = "Use Ctrl+Shift+S to scan current function, Ctrl+Shift+L to scan all"
    wanted_name = "Symbiotic"
    wanted_hotkey = ""

    def init(self):
        """Initialize the plugin"""
        print(f"\n[Symbiotic] Security Scanner v{VERSION} loading...")
        
        self.config = SymbioticConfig()
        self.scanner = SymbioticScanner(self.config)
        self._scanning = False

        # Check for decompiler
        if not ida_hexrays.init_hexrays_plugin():
            print("[Symbiotic] Warning: Hex-Rays decompiler not available")

        # Print status
        print(f"[Symbiotic] Opengrep: {self.config.opengrep_path}")
        print(f"[Symbiotic] Rules: {self.config.rules_path}")
        ai_status = "[OK]" if self.config.is_ai_configured() else "[X] Not set"
        print(f"[Symbiotic] Gemini AI: {ai_status}")
        status = "[OK] Configured" if self.config.is_configured() else "[X] Not configured"
        print(f"[Symbiotic] Status: {status}")

        # Register actions
        self._register_actions()

        print(f"[Symbiotic] v{VERSION} loaded successfully!")
        print("[Symbiotic] Shortcuts: Ctrl+Shift+S (scan), Ctrl+Shift+L (scan all), Ctrl+Shift+A (ask AI)")
        
        return idaapi.PLUGIN_KEEP

    def _register_actions(self):
        """Register all plugin actions"""
        # Scan Current Function
        action_desc = ida_kernwin.action_desc_t(
            "symbiotic:scan_current",
            "Symbiotic: Scan Current Function",
            ScanCurrentFunctionAction(self),
            "Ctrl+Shift+S",
            "Scan the current function for vulnerabilities",
            -1
        )
        ida_kernwin.register_action(action_desc)
        ida_kernwin.attach_action_to_menu("Edit/Plugins/", "symbiotic:scan_current", ida_kernwin.SETMENU_APP)

        # Scan All Functions
        action_desc = ida_kernwin.action_desc_t(
            "symbiotic:scan_all",
            "Symbiotic: Scan ALL Functions",
            ScanAllFunctionsAction(self),
            "Ctrl+Shift+L",
            "Scan all functions in the binary",
            -1
        )
        ida_kernwin.register_action(action_desc)
        ida_kernwin.attach_action_to_menu("Edit/Plugins/", "symbiotic:scan_all", ida_kernwin.SETMENU_APP)

        # Configuration
        action_desc = ida_kernwin.action_desc_t(
            "symbiotic:configure",
            "Symbiotic: Configuration",
            ConfigureAction(self),
            "",
            "Configure Symbiotic Scanner",
            -1
        )
        ida_kernwin.register_action(action_desc)
        ida_kernwin.attach_action_to_menu("Edit/Plugins/", "symbiotic:configure", ida_kernwin.SETMENU_APP)

        # Ask AI about function
        action_desc = ida_kernwin.action_desc_t(
            "symbiotic:ask_ai",
            "Symbiotic: Ask AI About Function",
            AskAIAction(self),
            "Ctrl+Shift+A",
            "Ask AI to analyze the current function",
            -1
        )
        ida_kernwin.register_action(action_desc)
        ida_kernwin.attach_action_to_menu("Edit/Plugins/", "symbiotic:ask_ai", ida_kernwin.SETMENU_APP)


    def run(self, arg):
        """Run plugin - Show dialog with options"""
        msg = f"""Symbiotic Security Scanner v{VERSION}

Choose an action:"""

        result = ida_kernwin.ask_buttons(
            "Scan Current Function",
            "Scan ALL Functions",
            "Configuration",
            ida_kernwin.ASKBTN_BTN2,
            msg
        )

        if result == ida_kernwin.ASKBTN_BTN1:
            if not self.config.is_configured():
                ida_kernwin.warning("Please configure Symbiotic Scanner first!")
                configure_symbiotic(self.config)
            else:
                ea = ida_kernwin.get_screen_ea()
                self.scan_current_function(ea)

        elif result == ida_kernwin.ASKBTN_BTN2:
            if not self.config.is_configured():
                ida_kernwin.warning("Please configure Symbiotic Scanner first!")
                configure_symbiotic(self.config)
            else:
                self.scan_all_functions()

        elif result == ida_kernwin.ASKBTN_BTN3:
            configure_symbiotic(self.config)

    def scan_current_function(self, ea):
        """Scan function at current address (async)"""
        func = ida_funcs.get_func(ea)
        if not func:
            ida_kernwin.warning("No function at current address")
            return

        if self._scanning:
            ida_kernwin.warning("A scan is already in progress")
            return

        func_name = idc.get_func_name(ea)
        print(f"\n[Symbiotic] Starting async scan of: {func_name}")
        
        self._scanning = True
        ida_kernwin.show_wait_box(f"Scanning {func_name}...")

        def on_complete(result):
            self._scanning = False
            ida_kernwin.hide_wait_box()
            
            if "error" in result:
                print(f"[Symbiotic] Scan failed: {result['error']}")
            else:
                print("[Symbiotic] Scan completed!")
            
            viewer = SymbioticResultsViewer(result)
            viewer.Show("Symbiotic Scan Results")

        self.scanner.scan_function_async(func.start_ea, on_complete)

    def scan_all_functions(self):
        """Scan all functions (async)"""
        if self._scanning:
            ida_kernwin.warning("A scan is already in progress")
            return

        print("\n[Symbiotic] Starting async scan of all functions...")
        
        self._scanning = True
        ida_kernwin.show_wait_box("Scanning all functions...")

        def on_complete(result):
            self._scanning = False
            ida_kernwin.hide_wait_box()
            
            if "error" in result:
                print(f"[Symbiotic] Scan failed: {result['error']}")
            else:
                print("[Symbiotic] Scan completed!")
            
            viewer = SymbioticResultsViewer(result)
            viewer.Show("Symbiotic Scan Results")

        self.scanner.scan_all_functions_async(on_complete)

    def ask_ai_about_function(self):
        """Ask AI to analyze the current function"""
        from ai_provider import AIProvider
        from ai_prompts import analyze_function
        
        if not self.config.is_ai_configured():
            ida_kernwin.warning("AI not configured!\n\nAdd AI_MODEL and AI_API_KEY to .env file")
            return
        
        ea = ida_kernwin.get_screen_ea()
        func = ida_funcs.get_func(ea)
        if not func:
            ida_kernwin.warning("No function at current address")
            return
        
        func_name = idc.get_func_name(ea)
        print(f"[Symbiotic] Asking AI to analyze: {func_name}")
        
        # Get pseudocode
        try:
            cfunc = ida_hexrays.decompile(func.start_ea)
            if not cfunc:
                ida_kernwin.warning("Failed to decompile function")
                return
            pseudocode = str(cfunc)
        except Exception as e:
            ida_kernwin.warning(f"Decompilation failed: {e}")
            return
        
        ida_kernwin.show_wait_box(f"Analyzing {func_name} with AI...")
        
        try:
            provider = AIProvider(
                model=self.config.ai_model, 
                api_key=self.config.ai_api_key,
                api_base=self.config.ai_api_base
            )
            analysis = analyze_function(provider, pseudocode, func_name)
            ida_kernwin.hide_wait_box()
            
            # Show result
            msg = f"AI Analysis of {func_name}\n{'='*50}\n\n{analysis}"
            if len(msg) > 2000:
                print(f"\n[Symbiotic AI] Analysis:\n{analysis}\n")
                ida_kernwin.info(msg[:2000] + "\n\n... (see Output window for full)")
            else:
                print(f"\n[Symbiotic AI] Analysis:\n{analysis}\n")
                ida_kernwin.info(msg)
                
        except Exception as e:
            ida_kernwin.hide_wait_box()
            ida_kernwin.warning(f"AI Error: {e}")


    def term(self):
        """Terminate the plugin"""
        ida_kernwin.unregister_action("symbiotic:scan_current")
        ida_kernwin.unregister_action("symbiotic:scan_all")
        ida_kernwin.unregister_action("symbiotic:configure")
        ida_kernwin.unregister_action("symbiotic:ask_ai")

        print("[Symbiotic] Plugin unloaded")


def PLUGIN_ENTRY():
    return SymbioticPlugin()

```

`viewer.py`:

```py
"""
Results Viewer Module
HTML-based viewer with navigation, export, filtering for IDA
"""

import json
import os
import datetime
import idaapi
import idc
import ida_kernwin

try:
    from PySide6.QtWidgets import (QVBoxLayout, QHBoxLayout, QTextBrowser, 
                                    QPushButton, QComboBox, QLabel, QFileDialog, QWidget)
    from PySide6.QtCore import Qt, QUrl
except ImportError:
    try:
        from PyQt6.QtWidgets import (QVBoxLayout, QHBoxLayout, QTextBrowser,
                                      QPushButton, QComboBox, QLabel, QFileDialog, QWidget)
        from PyQt6.QtCore import Qt, QUrl
    except ImportError:
        try:
            from PyQt5.QtWidgets import (QVBoxLayout, QHBoxLayout, QTextBrowser,
                                          QPushButton, QComboBox, QLabel, QFileDialog, QWidget)
            from PyQt5.QtCore import Qt, QUrl
        except ImportError:
            from PySide2.QtWidgets import (QVBoxLayout, QHBoxLayout, QTextBrowser,
                                            QPushButton, QComboBox, QLabel, QFileDialog, QWidget)
            from PySide2.QtCore import Qt, QUrl


# Global scan history
_scan_history = []


class SymbioticResultsViewer(idaapi.PluginForm):
    """HTML-based viewer for displaying scan results with advanced features"""

    def __init__(self, results, func_line_map=None):
        super().__init__()
        self.results = results
        self.func_line_map = func_line_map or results.get("func_line_map", {})
        self.current_filter = "ALL"
        self.current_func_filter = "ALL"
        self.current_tag_filter = "ALL"
        self.vulns = []
        self.ai_results = {}
        self.vuln_tags = {}

        self._load_tags()
        self._load_ai_cache()

        _scan_history.append({
            "timestamp": datetime.datetime.now().isoformat(),
            "results": results,
            "vuln_count": len(self._parse_vulnerabilities())
        })

    def OnCreate(self, form):
        """Called when the form is created"""
        self.parent = self.FormToPyQtWidget(form)

        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Toolbar
        toolbar = QHBoxLayout()
        toolbar.setContentsMargins(8, 8, 8, 8)
        
        # Filter dropdown
        filter_label = QLabel("Severity:")
        filter_label.setStyleSheet("color: #cccccc; padding-right: 5px;")
        toolbar.addWidget(filter_label)
        
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(["ALL", "CRITICAL", "HIGH", "MEDIUM", "LOW"])
        self.filter_combo.setStyleSheet("""
            QComboBox {
                background-color: #3c3c3c;
                color: #cccccc;
                border: 1px solid #555555;
                padding: 4px 8px;
                min-width: 80px;
            }
        """)
        self.filter_combo.currentTextChanged.connect(self._on_filter_changed)
        toolbar.addWidget(self.filter_combo)
        
        # Function filter
        func_label = QLabel("Function:")
        func_label.setStyleSheet("color: #cccccc; padding-left: 10px; padding-right: 5px;")
        toolbar.addWidget(func_label)
        
        self.func_filter_combo = QComboBox()
        self.func_filter_combo.setStyleSheet("""
            QComboBox {
                background-color: #3c3c3c;
                color: #cccccc;
                border: 1px solid #555555;
                padding: 4px 8px;
                min-width: 120px;
            }
        """)
        self.func_filter_combo.currentTextChanged.connect(self._on_func_filter_changed)
        toolbar.addWidget(self.func_filter_combo)
        
        # Tag filter
        tag_label = QLabel("Tag:")
        tag_label.setStyleSheet("color: #cccccc; padding-left: 10px; padding-right: 5px;")
        toolbar.addWidget(tag_label)
        
        self.tag_filter_combo = QComboBox()
        self.tag_filter_combo.addItems(["ALL", "Untagged", "Confirmed", "False Positive"])
        self.tag_filter_combo.setStyleSheet("""
            QComboBox {
                background-color: #3c3c3c;
                color: #cccccc;
                border: 1px solid #555555;
                padding: 4px 8px;
                min-width: 100px;
            }
        """)
        self.tag_filter_combo.currentTextChanged.connect(self._on_tag_filter_changed)
        toolbar.addWidget(self.tag_filter_combo)
        
        toolbar.addStretch()
        
        # Export button
        export_btn = QPushButton("Export JSON")
        export_btn.setStyleSheet("""
            QPushButton {
                background-color: #0e639c;
                color: white;
                border: none;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #1177bb;
            }
        """)
        export_btn.clicked.connect(self._export_json)
        toolbar.addWidget(export_btn)
        
        # Export HTML button
        export_html_btn = QPushButton("Export HTML")
        export_html_btn.setStyleSheet("""
            QPushButton {
                background-color: #0e639c;
                color: white;
                border: none;
                padding: 6px 12px;
                margin-left: 5px;
            }
            QPushButton:hover {
                background-color: #1177bb;
            }
        """)
        export_html_btn.clicked.connect(self._export_html)
        toolbar.addWidget(export_html_btn)
        
        # History button
        history_btn = QPushButton(f"History ({len(_scan_history)})")
        history_btn.setStyleSheet("""
            QPushButton {
                background-color: #3c3c3c;
                color: #cccccc;
                border: 1px solid #555555;
                padding: 6px 12px;
                margin-left: 5px;
            }
            QPushButton:hover {
                background-color: #4c4c4c;
            }
        """)
        history_btn.clicked.connect(self._show_history)
        toolbar.addWidget(history_btn)

        toolbar_widget = QWidget()
        toolbar_widget.setLayout(toolbar)
        toolbar_widget.setStyleSheet("background-color: #252526;")
        main_layout.addWidget(toolbar_widget)

        # Browser
        self.browser = QTextBrowser()
        self.browser.setOpenLinks(False)  # Prevent default navigation
        self.browser.setOpenExternalLinks(False)
        self.browser.anchorClicked.connect(self._on_link_clicked)
        self.vulns = self._parse_vulnerabilities()
        self._populate_func_filter()  # Populate function filter dropdown
        self.browser.setHtml(self._generate_html())

        self.browser.setStyleSheet("""
            QTextBrowser {
                background-color: #1e1e1e;
                color: #cccccc;
                border: 0px;
                padding: 0px;
                margin: 0px;
            }
        """)

        main_layout.addWidget(self.browser)
        self.parent.setLayout(main_layout)
        
        self._print_console_summary()

    def _refresh_html(self):
        """Refresh HTML content while preserving scroll position"""
        # Save scroll position
        scrollbar = self.browser.verticalScrollBar()
        scroll_pos = scrollbar.value() if scrollbar else 0
        
        # Update content
        self.browser.setHtml(self._generate_html())
        
        # Restore scroll position after a short delay (Qt needs time to render)
        if scrollbar and scroll_pos > 0:
            try:
                from PySide6.QtCore import QTimer
            except ImportError:
                try:
                    from PyQt6.QtCore import QTimer
                except ImportError:
                    try:
                        from PyQt5.QtCore import QTimer
                    except ImportError:
                        from PySide2.QtCore import QTimer
            
            def restore_scroll():
                scrollbar.setValue(scroll_pos)
            
            QTimer.singleShot(50, restore_scroll)

    def _on_filter_changed(self, severity):
        """Filter vulnerabilities by severity"""
        self.current_filter = severity
        self._refresh_html()

    def _on_func_filter_changed(self, func_name):
        """Filter vulnerabilities by function"""
        self.current_func_filter = func_name
        self._refresh_html()

    def _on_tag_filter_changed(self, tag):
        """Filter vulnerabilities by tag"""
        self.current_tag_filter = tag
        self._refresh_html()

    def _get_tags_file(self):
        """Get path to persistent tags file"""
        idb_path = idc.get_idb_path() if hasattr(idc, 'get_idb_path') else ""
        if idb_path:
            return idb_path + ".symbiotic_tags.json"
        return os.path.expanduser("~/.symbiotic_tags.json")

    def _load_tags(self):
        """Load tags from persistent file"""
        try:
            tags_file = self._get_tags_file()
            if os.path.exists(tags_file):
                with open(tags_file, "r") as f:
                    self.vuln_tags = json.load(f)
        except:
            self.vuln_tags = {}

    def _save_tags(self):
        """Save tags to persistent file"""
        try:
            tags_file = self._get_tags_file()
            with open(tags_file, "w") as f:
                json.dump(self.vuln_tags, f, indent=2)
        except Exception as e:
            print(f"[Symbiotic] Error saving tags: {e}")

    def _get_ai_cache_file(self):
        """Get path to persistent AI cache file"""
        idb_path = idc.get_idb_path() if hasattr(idc, 'get_idb_path') else ""
        if idb_path:
            return idb_path + ".symbiotic_ai_cache.json"
        return os.path.expanduser("~/.symbiotic_ai_cache.json")

    def _load_ai_cache(self):
        """Load AI results from persistent cache"""
        try:
            cache_file = self._get_ai_cache_file()
            if os.path.exists(cache_file):
                with open(cache_file, "r") as f:
                    self.ai_results = json.load(f)
                print(f"[Symbiotic] Loaded {len(self.ai_results)} cached AI results")
        except Exception as e:
            print(f"[Symbiotic] Could not load AI cache: {e}")
            self.ai_results = {}

    def _save_ai_cache(self):
        """Save AI results to persistent cache"""
        try:
            cache_file = self._get_ai_cache_file()
            # Only save completed results (not loading states)
            to_save = {}
            for key, result in self.ai_results.items():
                content = result.get("content", "")
                if not content.startswith("Generating") and not content.startswith("Error"):
                    to_save[key] = result
            
            with open(cache_file, "w") as f:
                json.dump(to_save, f, indent=2)
        except Exception as e:
            print(f"[Symbiotic] Error saving AI cache: {e}")

    def _handle_tag(self, vuln_id, tag_type):
        """Handle tagging a vulnerability"""
        # Don't convert underscores - use ID as-is from URL
        current = self.vuln_tags.get(vuln_id)
        
        # Toggle: if same tag, remove it; otherwise set it
        if current == tag_type:
            del self.vuln_tags[vuln_id]
            print(f"[Symbiotic] Removed tag from {vuln_id}")
        else:
            self.vuln_tags[vuln_id] = tag_type
            print(f"[Symbiotic] Tagged {vuln_id} as {tag_type.upper()}")
        
        self._save_tags()
        self._refresh_html()

    def _populate_func_filter(self):
        """Populate function filter dropdown with unique functions"""
        functions = set(["ALL"])
        for v in self.vulns:
            loc = v.get("location", {})
            line = loc.get("start_line", 0)
            if line:
                _, func_name = self._get_func_info_for_line(line)
                if func_name:
                    functions.add(func_name)
        
        # Update dropdown
        self.func_filter_combo.blockSignals(True)
        self.func_filter_combo.clear()
        self.func_filter_combo.addItems(sorted(functions))
        self.func_filter_combo.blockSignals(False)

    def _on_link_clicked(self, url):
        """Handle internal links - navigate to function or AI actions"""
        url_str = url.toString()
        
        if url_str.startswith("ida://"):
            # Extract address from ida://0x12345
            addr_str = url_str.replace("ida://", "")
            try:
                addr = int(addr_str, 16)
                # Jump to address in IDA
                idc.jumpto(addr)
                print(f"[Symbiotic] Jumped to {hex(addr)}")
            except:
                print(f"[Symbiotic] Invalid address: {addr_str}")
                
        elif url_str.startswith("ai://explain/"):
            # AI Explain vulnerability
            vuln_id = url_str.replace("ai://explain/", "").replace("_", " ")
            self._handle_ai_explain(vuln_id)
            
        elif url_str.startswith("ai://poc/"):
            # AI Generate PoC
            vuln_id = url_str.replace("ai://poc/", "").replace("_", " ")
            self._handle_ai_poc(vuln_id)
            
        elif url_str.startswith("ai://toggle/"):
            # Toggle (hide) AI result
            parts = url_str.replace("ai://toggle/", "").split("/")
            if len(parts) == 2:
                vuln_id = parts[0].replace("_", " ")
                result_type = parts[1]
                self._handle_ai_toggle(vuln_id, result_type)
        
        elif url_str.startswith("tag://confirmed/"):
            vuln_id = url_str.replace("tag://confirmed/", "")
            self._handle_tag(vuln_id, "confirmed")
        
        elif url_str.startswith("tag://false_positive/"):
            vuln_id = url_str.replace("tag://false_positive/", "")
            self._handle_tag(vuln_id, "false_positive")
            
        elif url_str.startswith("http"):
            # Open external link
            import webbrowser
            webbrowser.open(url_str)

    def _handle_ai_explain(self, vuln_id):
        """Call AI to explain a vulnerability (async)"""
        import threading
        from .config import SymbioticConfig
        
        config = SymbioticConfig()
        if not config.is_ai_configured():
            ida_kernwin.warning("Gemini API not configured!\n\nGo to: Edit > Plugins > Symbiotic Configuration > AI")
            return
        
        vuln = self._find_vuln_by_id(vuln_id)
        if not vuln:
            ida_kernwin.warning(f"Vulnerability not found: {vuln_id}")
            return
        
        print(f"[Symbiotic] Calling AI to explain: {vuln.get('title', vuln_id)}")
        
        # Mark as loading - use composite key
        storage_key = f"{vuln_id}_explain"
        self.ai_results[storage_key] = {"type": "explain", "content": "Generating explanation..."}
        self._refresh_html()
        
        def do_ai_call():
            try:
                from .ai_provider import AIProvider
                from .ai_prompts import explain_vulnerability
                provider = AIProvider(model=config.ai_model, api_key=config.ai_api_key, api_base=config.ai_api_base)
                explanation = explain_vulnerability(
                    provider,
                    vuln.get("title", "Vulnerability"),
                    vuln.get("cwe", ""),
                    vuln.get("snippet", "")
                )
                
                # Update on main thread via execute_sync
                def update_ui():
                    self.ai_results[storage_key] = {"type": "explain", "content": explanation}
                    
                    # Check if AI detected this as a false positive
                    if "[LIKELY FALSE POSITIVE]" in explanation.upper() or "LIKELY FALSE POSITIVE" in explanation.upper():
                        # Auto-tag as false positive
                        self.vuln_tags[vuln_id] = "false_positive"
                        self._save_tags()
                        print(f"[Symbiotic AI] Auto-tagged as FALSE POSITIVE: {vuln_id}")
                    elif "[CONFIRMED VULNERABILITY]" in explanation.upper() or "CONFIRMED VULNERABILITY" in explanation.upper():
                        # Auto-tag as confirmed
                        self.vuln_tags[vuln_id] = "confirmed"
                        self._save_tags()
                        print(f"[Symbiotic AI] Auto-tagged as CONFIRMED: {vuln_id}")
                    self._save_ai_cache()  # Persist cache
                    self._refresh_html()
                    print(f"[Symbiotic AI] Explanation generated")
                
                idaapi.execute_sync(update_ui, idaapi.MFF_FAST)
                
            except Exception as e:
                def show_error():
                    self.ai_results[storage_key] = {"type": "explain", "content": f"Error: {e}"}
                    self._refresh_html()
                idaapi.execute_sync(show_error, idaapi.MFF_FAST)
        
        thread = threading.Thread(target=do_ai_call, daemon=True)
        thread.start()

    def _handle_ai_poc(self, vuln_id):
        """Call AI to generate PoC (async)"""
        import threading
        from .config import SymbioticConfig
        
        config = SymbioticConfig()
        if not config.is_ai_configured():
            ida_kernwin.warning("Gemini API not configured!\n\nGo to: Edit > Plugins > Symbiotic Configuration > AI")
            return
        
        vuln = self._find_vuln_by_id(vuln_id)
        if not vuln:
            ida_kernwin.warning(f"Vulnerability not found: {vuln_id}")
            return
        
        print(f"[Symbiotic] Generating PoC for: {vuln.get('title', vuln_id)}")
        
        # Mark as loading - use composite key
        storage_key = f"{vuln_id}_poc"
        self.ai_results[storage_key] = {"type": "poc", "content": "Generating PoC exploit..."}
        self._refresh_html()
        
        def do_ai_call():
            try:
                from .ai_provider import AIProvider
                from .ai_prompts import generate_poc
                provider = AIProvider(model=config.ai_model, api_key=config.ai_api_key, api_base=config.ai_api_base)
                poc = generate_poc(
                    provider,
                    vuln.get("title", "Vulnerability"),
                    vuln.get("cwe", ""),
                    vuln.get("snippet", ""),
                    "target_function"
                )
                
                def update_ui():
                    self.ai_results[storage_key] = {"type": "poc", "content": poc}
                    self._save_ai_cache()  # Persist cache
                    self._refresh_html()
                    print(f"[Symbiotic AI] PoC generated")
                
                idaapi.execute_sync(update_ui, idaapi.MFF_FAST)
                
            except Exception as e:
                def show_error():
                    self.ai_results[storage_key] = {"type": "poc", "content": f"Error: {e}"}
                    self._refresh_html()
                idaapi.execute_sync(show_error, idaapi.MFF_FAST)
        
        thread = threading.Thread(target=do_ai_call, daemon=True)
        thread.start()

    def _handle_ai_toggle(self, vuln_id, result_type):
        """Toggle (collapse/expand) AI result content"""
        # Find the result and toggle its hidden state
        for vid in [vuln_id, vuln_id.replace(" ", "_"), vuln_id.replace("_", " ")]:
            key = f"{vid}_{result_type}"
            if key in self.ai_results:
                result = self.ai_results[key]
                # Toggle hidden state
                result["hidden"] = not result.get("hidden", False)
                print(f"[Symbiotic] Toggled {result_type}: hidden={result['hidden']}")
                break
        
        # Refresh display
        self._refresh_html()

    def _find_vuln_by_id(self, vuln_id):
        """Find vulnerability by rule_id"""
        for v in self.vulns:
            rule_id = v.get("rule_id", "")
            # Match with both spaces and underscores
            if rule_id.replace(" ", "_") == vuln_id.replace(" ", "_"):
                return v
        return None

    def _get_ai_result(self, vuln_id, result_type=None):
        """Get cached AI result for a vulnerability
        
        Args:
            vuln_id: Vulnerability ID (will try with spaces and underscores)
            result_type: 'explain' or 'poc' - required for new composite key lookup
        """
        if not result_type:
            return None
            
        # Normalize vuln_id formats
        vuln_id_spaces = vuln_id.replace("_", " ")
        vuln_id_underscores = vuln_id.replace(" ", "_")
        
        # Try composite keys with both formats
        for vid in [vuln_id, vuln_id_spaces, vuln_id_underscores]:
            key = f"{vid}_{result_type}"
            result = self.ai_results.get(key)
            if result:
                return result
        
        return None
    
    def _render_ai_content(self, result, accent_color):
        """Render AI result content to HTML"""
        content = result.get("content", "")
        
        # Only show loading for actual loading messages (short strings starting with "Generating")
        if content.startswith("Generating") and len(content) < 50:
            return f'<font size="2" color="#a0aec0">{self._escape_html(content)}</font>'
        
        return self._markdown_to_html(content, accent_color)

    def _highlight_code(self, code, lang="c"):
        """Apply syntax highlighting to code with proper formatting"""
        import re
        
        # Colors for syntax highlighting
        colors = {
            "keyword": "#c45d97",    # Pink - keywords
            "type": "#74c1cf",        # Cyan - types
            "string": "#6ad9a9",      # Green - strings
            "comment": "#666666",     # Gray - comments
            "number": "#e5c166",      # Yellow - numbers
            "default": "#e0e0e0",     # White - default
        }
        
        # C/C++ keywords and types
        c_keywords = {'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue',
                      'return', 'goto', 'typedef', 'struct', 'union', 'enum', 'sizeof', 'void',
                      'const', 'static', 'extern', 'volatile', 'register', 'inline', 'auto', 
                      'default', 'include', 'define', 'ifdef', 'ifndef', 'endif', 'elif', 'pragma'}
        c_types = {'int', 'char', 'float', 'double', 'long', 'short', 'unsigned', 'signed',
                   'size_t', 'bool', 'NULL', 'true', 'false', 'uint8_t', 'uint16_t', 'uint32_t',
                   'uint64_t', 'int8_t', 'int16_t', 'int32_t', 'int64_t', 'FILE', 'void'}
        
        # Python keywords
        py_keywords = {'def', 'class', 'if', 'elif', 'else', 'for', 'while', 'try', 'except',
                       'finally', 'with', 'as', 'import', 'from', 'return', 'yield', 'raise',
                       'pass', 'break', 'continue', 'and', 'or', 'not', 'in', 'is', 'None',
                       'True', 'False', 'lambda', 'global', 'nonlocal', 'assert', 'async', 'await'}
        
        keywords = py_keywords if lang in ['python', 'py'] else c_keywords
        types = set() if lang in ['python', 'py'] else c_types
        
        def highlight_line(line):
            """Highlight a single line of code"""
            if not line:
                return ""
            
            # Handle leading whitespace (preserve indentation)
            leading_spaces = len(line) - len(line.lstrip(' '))
            indent = '&nbsp;' * leading_spaces
            line = line[leading_spaces:]
            
            # Check for C-style comments
            if line.strip().startswith('//'):
                return f'{indent}<font color="{colors["comment"]}">{self._escape_html(line)}</font>'
            
            # Check for Python comments
            if lang in ['python', 'py'] and line.strip().startswith('#'):
                return f'{indent}<font color="{colors["comment"]}">{self._escape_html(line)}</font>'
            
            # Tokenize and highlight
            result = [indent]
            
            # Split by word boundaries but keep delimiters
            tokens = re.split(r'(\s+|[^\w]+)', line)
            
            in_string = False
            string_char = None
            
            for token in tokens:
                if not token:
                    continue
                
                # Handle strings
                if not in_string and (token.startswith('"') or token.startswith("'")):
                    in_string = True
                    string_char = token[0]
                    result.append(f'<font color="{colors["string"]}">{self._escape_html(token)}')
                    if len(token) > 1 and token.endswith(string_char):
                        in_string = False
                        result.append('</font>')
                    continue
                
                if in_string:
                    result.append(self._escape_html(token))
                    if token.endswith(string_char) and not token.endswith('\\' + string_char):
                        in_string = False
                        result.append('</font>')
                    continue
                
                escaped = self._escape_html(token)
                
                # Highlight based on token type
                if token in keywords:
                    result.append(f'<font color="{colors["keyword"]}">{escaped}</font>')
                elif token in types:
                    result.append(f'<font color="{colors["type"]}">{escaped}</font>')
                elif re.match(r'^0x[0-9a-fA-F]+$', token) or re.match(r'^\d+$', token):
                    result.append(f'<font color="{colors["number"]}">{escaped}</font>')
                elif token.isspace():
                    result.append(escaped.replace(' ', '&nbsp;'))
                else:
                    result.append(f'<font color="{colors["default"]}">{escaped}</font>')
            
            if in_string:
                result.append('</font>')
            
            return ''.join(result)
        
        # Process line by line
        lines = code.split('\n')
        highlighted_lines = [highlight_line(line) for line in lines]
        
        return '<br>'.join(highlighted_lines)

    def _markdown_to_html(self, text, accent_color="#c45d97"):
        """Convert markdown to styled HTML for IDA viewer"""
        import re
        
        # Use accent_color for headings, bullets, inline code
        colors = {
            "text": "#e0e0e0",
            "heading": accent_color,           # Use accent color
            "code_bg": "#0a0a0f",              # Very dark
            "code_text": "#74c1cf",            # Info cyan
            "inline_code": accent_color,       # Use accent color
            "bold": "#ffffff",
            "bullet": accent_color,            # Use accent color
            "link": "#74c1cf",                 # Info cyan
            "success": "#6ad9a9",
            "warning": "#e5c166",
            "error": "#e57260",
        }
        
        # IMPORTANT: Process code blocks BEFORE HTML escaping
        # to preserve code formatting
        def replace_code_block(match):
            lang = match.group(1) or ""
            code = match.group(2).strip()
            
            # Apply syntax highlighting (code is not yet escaped)
            highlighted = self._highlight_code(code, lang if lang else "c")
            
            return f'<table width="100%" cellpadding="8" cellspacing="0" style="background-color:{colors["code_bg"]}; margin: 0; border-radius: 4px; border: 1px solid #1a1a24;"><tr><td><font face="Consolas, Monaco, monospace" size="2">{highlighted}</font></td></tr></table>'
        
        # Extract code blocks first, before escaping
        text = re.sub(r'```(\w*)\n?(.*?)```', replace_code_block, text, flags=re.DOTALL)
        
        # Now escape the rest of the HTML (code blocks already processed)
        # We need to be careful - code blocks are now HTML, rest is not
        # Split by code blocks and escape only non-code parts
        html = text
        
        # Headers - NO extra line breaks (remove <br>)
        # Process #### first (most specific), then ###, ##, #
        html = re.sub(r'^#### (.+)$', f'<font size="2" color="{colors["heading"]}"><b>\\1</b></font>', html, flags=re.MULTILINE)
        html = re.sub(r'^### (.+)$', f'<font size="2" color="{colors["heading"]}"><b>\\1</b></font>', html, flags=re.MULTILINE)
        html = re.sub(r'^## (.+)$', f'<font size="2" color="{colors["heading"]}"><b>\\1</b></font>', html, flags=re.MULTILINE)
        html = re.sub(r'^# (.+)$', f'<font size="3" color="{colors["heading"]}"><b>\\1</b></font>', html, flags=re.MULTILINE)
        
        # Bold **text**
        html = re.sub(r'\*\*(.+?)\*\*', f'<font color="{colors["bold"]}"><b>\\1</b></font>', html)
        
        # Italic *text*
        html = re.sub(r'\*(.+?)\*', '<i>\\1</i>', html)
        
        # Inline code `code`
        html = re.sub(r'`([^`]+)`', f'<font face="Consolas, monospace" color="{colors["inline_code"]}">\\1</font>', html)
        
        # Bullet points
        html = re.sub(r'^- (.+)$', f'<font color="{colors["bullet"]}">•</font> <font color="{colors["text"]}">\\1</font>', html, flags=re.MULTILINE)
        html = re.sub(r'^\* (.+)$', f'<font color="{colors["bullet"]}">•</font> <font color="{colors["text"]}">\\1</font>', html, flags=re.MULTILINE)
        
        # Numbered lists
        html = re.sub(r'^(\d+)\. (.+)$', f'<font color="{colors["bullet"]}">\\1.</font> <font color="{colors["text"]}">\\2</font>', html, flags=re.MULTILINE)
        
        # Line breaks
        html = html.replace('\n', '<br>')
        
        # Wrap in default text color
        return f'<font size="2" color="{colors["text"]}">{html}</font>'

    def _export_json(self):
        """Export results to JSON file"""
        filename, _ = QFileDialog.getSaveFileName(
            self.parent, "Export Results", 
            os.path.expanduser("~/symbiotic_results.json"),
            "JSON Files (*.json)"
        )
        if filename:
            # Prepare AI results for export
            ai_data = {}
            for key, result in self.ai_results.items():
                if not result.get("hidden", False):
                    content = result.get("content", "")
                    if not content.startswith("Generating"):
                        ai_data[key] = {"type": result.get("type", "unknown"), "content": content}
            
            export_data = {
                "timestamp": datetime.datetime.now().isoformat(),
                "scanner": self.results.get("scanner", "opengrep"),
                "scan_type": self.results.get("scan_type", "unknown"),
                "total_functions": self.results.get("total_functions", 0),
                "vulnerabilities": self.vulns,
                "ai_results": ai_data
            }
            with open(filename, "w") as f:
                json.dump(export_data, f, indent=2)
            print(f"[Symbiotic] Results exported to {filename}")
            ida_kernwin.info(f"Results exported to:\n{filename}")

    def _export_html(self):
        """Export results to HTML file"""
        filename, _ = QFileDialog.getSaveFileName(
            self.parent, "Export Results", 
            os.path.expanduser("~/symbiotic_results.html"),
            "HTML Files (*.html)"
        )
        if filename:
            html_content = self._generate_html(for_export=True)
            with open(filename, "w") as f:
                f.write(html_content)
            print(f"[Symbiotic] HTML exported to {filename}")
            ida_kernwin.info(f"HTML exported to:\n{filename}")

    def _show_history(self):
        """Show scan history with diff comparison"""
        if len(_scan_history) < 1:
            ida_kernwin.info("No scan history available")
            return
        
        msg = "═══ SCAN HISTORY ═══\n\n"
        
        for i, h in enumerate(reversed(_scan_history[-10:])):
            ts = h["timestamp"][:19].replace("T", " ")
            count = h["vuln_count"]
            current = " ← CURRENT" if i == 0 else ""
            msg += f"{i+1}. {ts} - {count} issue(s){current}\n"
        
        # Show diff if we have at least 2 scans
        if len(_scan_history) >= 2:
            current_scan = _scan_history[-1]
            previous_scan = _scan_history[-2]
            
            # Get rule IDs from each scan
            current_rules = set()
            previous_rules = set()
            
            try:
                current_results = current_scan.get("results", {}).get("output", "")
                if current_results:
                    current_data = json.loads(current_results)
                    for v in current_data.get("fail_results", []):
                        current_rules.add(v.get("rule_id", ""))
                
                previous_results = previous_scan.get("results", {}).get("output", "")
                if previous_results:
                    previous_data = json.loads(previous_results)
                    for v in previous_data.get("fail_results", []):
                        previous_rules.add(v.get("rule_id", ""))
                
                new_vulns = current_rules - previous_rules
                fixed_vulns = previous_rules - current_rules
                
                msg += "\n═══ DIFF vs PREVIOUS ═══\n"
                
                if new_vulns:
                    msg += f"\n🔴 NEW ({len(new_vulns)}):\n"
                    for r in list(new_vulns)[:5]:
                        msg += f"  + {r}\n"
                    if len(new_vulns) > 5:
                        msg += f"  ... and {len(new_vulns) - 5} more\n"
                
                if fixed_vulns:
                    msg += f"\n🟢 FIXED ({len(fixed_vulns)}):\n"
                    for r in list(fixed_vulns)[:5]:
                        msg += f"  - {r}\n"
                    if len(fixed_vulns) > 5:
                        msg += f"  ... and {len(fixed_vulns) - 5} more\n"
                
                if not new_vulns and not fixed_vulns:
                    msg += "\nNo changes from previous scan.\n"
                    
            except Exception as e:
                msg += f"\n(Could not compute diff: {e})\n"
        
        ida_kernwin.info(msg)

    def _get_func_info_for_line(self, line_num):
        """Get function address and name for a given line number"""
        for func_ea, info in self.func_line_map.items():
            if info["start_line"] <= line_num <= info["end_line"]:
                return func_ea, info.get("name", "Unknown")
        return None, None

    def _group_vulnerabilities(self, vulns):
        """Group vulnerabilities by rule_id to reduce repetition"""
        from collections import OrderedDict
        
        grouped = OrderedDict()
        for v in vulns:
            rule_id = v.get("rule_id", "UNKNOWN")
            if rule_id not in grouped:
                grouped[rule_id] = {
                    "rule_id": rule_id,
                    "title": v.get("title", "Vulnerability"),
                    "severity": v.get("severity", "MEDIUM"),
                    "description": v.get("description", ""),
                    "cwe": v.get("cwe", ""),
                    "impact": v.get("impact", ""),
                    "references": v.get("references", []),
                    "impact_level": v.get("impact_level", "MEDIUM"),
                    "likelihood_level": v.get("likelihood_level", "LOW"),
                    "confidence_level": v.get("confidence_level", "MEDIUM"),
                    "occurrences": []
                }
            
            # Add this occurrence
            loc = v.get("location", {})
            line = loc.get("start_line", 0)
            func_addr, func_name = self._get_func_info_for_line(line) if line else (None, None)
            
            grouped[rule_id]["occurrences"].append({
                "line": line,
                "snippet": v.get("snippet", ""),
                "func_addr": func_addr,
                "func_name": func_name
            })
        
        return list(grouped.values())

    def _generate_html(self, for_export=False):
        """Generate HTML content"""
        
        # Colors
        bg_main = "#1e1e1e"
        bg_card = "#252526"
        text_white = "#ffffff"
        text_gray = "#858585"
        text_light = "#cccccc"
        brand_pink = "#c45d97"
        color_critical = "#ff4040"
        color_error = "#e57260"
        color_warning = "#e5c166"
        color_success = "#6ad9a9"
        color_info = "#74c1cf"
        color_link = "#3794ff"
        
        html = f'''<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body {{ 
    background-color: {bg_main}; 
    color: {text_light}; 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 13px;
    padding: 16px;
    margin: 0;
}}
a {{ color: {color_link}; text-decoration: none; cursor: pointer; }}
a:hover {{ text-decoration: underline; }}
.jump-btn {{
    background-color: #0e639c;
    color: white;
    padding: 4px 8px;
    border-radius: 3px;
    font-size: 11px;
    margin-left: 30px;
}}
</style>
</head>
<body>
'''
        if "error" in self.results:
            html += f'<font color="{color_error}"><b>Error:</b> {self._escape_html(self.results["error"])}</font>'
            html += '</body></html>'
            return html

        scan_type = self.results.get("scan_type", "single_function")
        scanner = self.results.get("scanner", "opengrep").upper()

        if scan_type == "all_functions":
            total = self.results.get("total_functions", 0)
            scanned = self.results.get("functions_scanned", 0)
            header_info = f"Scanner: {scanner} | Functions: {scanned}/{total}"
        else:
            func = self.results.get("function_name", "Unknown")
            addr = self.results.get("address", "Unknown")
            header_info = f"{self._escape_html(func)} @ {addr} | Scanner: {scanner}"

        # Filter vulnerabilities by severity
        filtered_vulns = self.vulns
        if self.current_filter != "ALL":
            filtered_vulns = [v for v in filtered_vulns if v.get("severity", "").upper() == self.current_filter]
        
        # Filter by function
        if self.current_func_filter != "ALL":
            def match_func(v):
                loc = v.get("location", {})
                line = loc.get("start_line", 0)
                if line:
                    _, func_name = self._get_func_info_for_line(line)
                    return func_name == self.current_func_filter
                return False
            filtered_vulns = [v for v in filtered_vulns if match_func(v)]
        
        # Filter by tag
        if self.current_tag_filter != "ALL":
            def match_tag(v):
                rule_id = v.get("rule_id", "UNKNOWN")
                tag = self.vuln_tags.get(rule_id)
                if self.current_tag_filter == "Untagged":
                    return tag is None
                elif self.current_tag_filter == "Confirmed":
                    return tag == "confirmed"
                elif self.current_tag_filter == "False Positive":
                    return tag == "false_positive"
                return True
            filtered_vulns = [v for v in filtered_vulns if match_tag(v)]

        # Group vulnerabilities by rule_id
        grouped_vulns = self._group_vulnerabilities(filtered_vulns)

        status_html = f'<font color="{color_success}">[OK] Scan completed successfully</font>'
        
        # Build filter info
        filter_info = []
        if self.current_filter != "ALL":
            filter_info.append(self.current_filter)
        if self.current_func_filter != "ALL":
            filter_info.append(f"func:{self.current_func_filter}")
        if self.current_tag_filter != "ALL":
            filter_info.append(f"tag:{self.current_tag_filter}")
        filter_str = f" (filtered: {', '.join(filter_info)})" if filter_info else ""
        
        html += f'''
<font size="2" color="{text_gray}">{header_info}</font><br>
{status_html}<br>
<font size="2" color="{text_gray}">Found {len(self.vulns)} issue(s) in {len(grouped_vulns)} unique rule(s){filter_str}</font>
<br><br>
'''
        
        if grouped_vulns:
            for g in grouped_vulns:
                html += self._render_grouped_vuln(g, bg_card, text_white, text_gray, text_light, 
                                          brand_pink, color_critical, color_error, 
                                          color_warning, color_success, color_info, for_export)
        else:
            html += f'''
<table width="100%" cellpadding="40" cellspacing="0">
<tr><td align="center">
<font size="4" color="{color_success}">[OK]</font><br><br>
<font size="3" color="{color_success}"><b>No Issues Found</b></font><br>
<font size="2" color="{text_gray}">No vulnerabilities match the current filter.</font>
</td></tr>
</table>
'''

        html += '</body></html>'
        return html

    def _render_grouped_vuln(self, g, bg_card, text_white, text_gray, text_light, brand_pink,
                             color_critical, color_error, color_warning, color_success, color_info, for_export=False):
        """Render a grouped vulnerability with multiple occurrences"""
        rule_id = g.get("rule_id", "UNKNOWN")
        title = g.get("title", "Vulnerability")
        severity = g.get("severity", "MEDIUM").upper()
        desc = g.get("description", "")
        cwe = g.get("cwe", "")
        impact_desc = g.get("impact", "")
        refs = g.get("references", [])
        occurrences = g.get("occurrences", [])
        
        impact_level = g.get("impact_level", "HIGH" if severity in ["CRITICAL", "HIGH"] else "MEDIUM")
        likelihood = g.get("likelihood_level", "LOW")
        confidence = g.get("confidence_level", "MEDIUM")
        
        sev_styles = {
            "CRITICAL": (color_critical, "#ffffff"),
            "HIGH": (color_error, "#ffffff"),
            "MEDIUM": (color_warning, "#1e1e1e"),
            "LOW": (color_success, "#1e1e1e"),
        }
        sev_bg, sev_fg = sev_styles.get(severity, ("#666666", "#ffffff"))
        
        occ_count = len(occurrences)
        occ_text = f"{occ_count} occurrence{'s' if occ_count > 1 else ''}"
        
        
        # Tag buttons (only when not exporting)
        vuln_id_safe = rule_id.replace(" ", "_")
        
        # Get current tag for this vuln (use safe ID with underscores)
        current_tag = self.vuln_tags.get(vuln_id_safe)
        tag_badge = ""
        if current_tag == "confirmed":
            tag_badge = f'<font color="{color_success}"> ✓ CONFIRMED</font>'
        elif current_tag == "false_positive":
            tag_badge = f'<font color="{color_error}"> ✗ FALSE POSITIVE</font>'
        
        tag_buttons = ""
        if not for_export:
            confirm_style = f'color:{color_success}; font-weight:bold;' if current_tag == "confirmed" else 'color:#666;'
            fp_style = f'color:{color_error}; font-weight:bold;' if current_tag == "false_positive" else 'color:#666;'
            tag_buttons = f'''<div style="float:right;">
<a href="tag://confirmed/{vuln_id_safe}" style="{confirm_style} text-decoration:none; padding:4px 8px;">[✓ Confirm]</a>
<a href="tag://false_positive/{vuln_id_safe}" style="{fp_style} text-decoration:none; padding:4px 8px;">[✗ False+]</a>
</div>'''
        
        html = f'''
<br>
<table width="100%" border="1" bordercolor="#555555" cellpadding="20" cellspacing="0" bgcolor="{bg_card}">
<tr><td>
{tag_buttons}
<font size="2" color="{text_gray}">{self._escape_html(rule_id)} | <font color="{brand_pink}">{occ_text}</font>{tag_badge}</font><br>
<font size="4" color="{text_white}"><b>{self._escape_html(title)}</b></font><br><br>
<table cellpadding="0" cellspacing="0"><tr>
<td bgcolor="{sev_bg}" style="padding: 3px 6px;"><font size="1" color="{sev_fg}"><b>{severity}</b></font></td>
<td style="padding-left: 12px;"><font size="2" color="{text_gray}">Impact: </font><font size="2" color="{text_white}"><b>{impact_level}</b></font></td>
<td style="padding-left: 12px;"><font size="2" color="{text_gray}">Likelihood: </font><font size="2" color="{text_white}"><b>{likelihood}</b></font></td>
<td style="padding-left: 12px;"><font size="2" color="{text_gray}">Confidence: </font><font size="2" color="{text_white}"><b>{confidence}</b></font></td>
</tr></table>
'''

        if cwe:
            html += f'''<br><br>
<table cellpadding="8" cellspacing="0" style="background-color:#2d2030;">
<tr><td style="border-left: 3px solid {brand_pink};"><font size="2" color="{brand_pink}"><b>{self._escape_html(cwe)}</b></font></td></tr>
</table>
'''

        if desc:
            html += f'''<br><br>
<font size="2" color="{text_gray}">Description</font><br>
<font size="2" color="{text_light}">{self._escape_html(desc[:700])}</font>
'''

        if impact_desc:
            html += f'''<br><br>
<font size="2" color="{text_gray}">Impact</font><br>
<font size="2" color="{text_light}">{self._escape_html(impact_desc[:500])}</font>
'''

        # Occurrences section - show all locations with jump links
        if occurrences:
            html += f'''<br><br>
<font size="2" color="{brand_pink}"><b>Occurrences ({occ_count})</b></font><br>
<table width="100%" cellpadding="8" cellspacing="2" style="margin-top: 8px;">
'''
            for i, occ in enumerate(occurrences):
                line = occ.get("line", 0)
                func_name = occ.get("func_name", "")
                func_addr = occ.get("func_addr")
                snippet = occ.get("snippet", "")
                
                # Jump link
                jump_link = ""
                if func_addr and not for_export:
                    jump_link = f'<a href="ida://{hex(func_addr)}" style="color:#3794ff; font-size:11px;">[Jump]</a>'
                
                func_display = f' in <b>{self._escape_html(func_name)}</b>' if func_name else ""
                
                # Alternating row colors
                row_bg = "#1e1e1e" if i % 2 == 0 else "#252526"
                
                html += f'''<tr style="background-color:{row_bg};">
<td style="padding: 8px; border-left: 2px solid {brand_pink};">
<font size="2" color="{text_white}">Line {line}{func_display} {jump_link}</font><br>
<font face="Consolas, Monaco, monospace" size="2" color="{color_info}">{self._escape_html(snippet[:150])}</font>
</td>
</tr>
'''
            html += '</table>'

        if refs:
            html += f'<br><br><font size="2" color="{text_gray}">Resources</font><br>'
            for r in refs[:3]:
                html += f'<a href="{self._escape_html(r)}"><font size="2">{self._escape_html(r)}</font></a><br>'

        # AI Action buttons
        if not for_export:
            vuln_id = rule_id.replace(" ", "_")
            html += f'''<br><br>
<table cellpadding="0" cellspacing="4"><tr>
<td>
<a href="ai://explain/{vuln_id}" style="
    display: inline-block;
    background: linear-gradient(180deg, #0e639c 0%, #0a4d7a 100%);
    color: #ffffff;
    padding: 8px 16px;
    border-radius: 4px;
    text-decoration: none;
    font-family: 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid #0d5a8f;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
">Explain with AI</a>
</td>
<td style="padding-left: 8px;">
<a href="ai://poc/{vuln_id}" style="
    display: inline-block;
    background: linear-gradient(180deg, #c45d97 0%, #a04b7d 100%);
    color: #ffffff;
    padding: 8px 16px;
    border-radius: 4px;
    text-decoration: none;
    font-family: 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid #b3528a;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
">Generate PoC</a>
</td>
</tr></table>
'''

        # AI Results section (same as before)
        explain_result = self._get_ai_result(rule_id, "explain")
        poc_result = self._get_ai_result(rule_id, "poc")
        has_explain = explain_result is not None
        has_poc = poc_result is not None
        
        if has_explain or has_poc:
            explain_hidden = explain_result.get("hidden", False) if has_explain else True
            poc_hidden = poc_result.get("hidden", False) if has_poc else True
            
            html += '<br><table width="100%" cellpadding="0" cellspacing="4" style="table-layout: fixed;"><tr>'
            
            if has_explain:
                content = explain_result.get("content", "")
                is_loading = content.startswith("Generating") and len(content) < 50
                tab_color = "#e5c166" if is_loading else "#c45d97"
                status = " (loading...)" if is_loading else ""
                toggle_text = "[show]" if explain_hidden else "[hide]"
                toggle_link = f'<a href="ai://toggle/{vuln_id}/explain" style="text-decoration:none; margin-left:8px;"><font color="#666">{toggle_text}</font></a>' if not is_loading else ""
                width = "50%" if has_poc else "100%"
                html += f'''<td width="{width}" style="background-color:#0a0a0f; padding: 8px 16px; border-top: 2px solid {tab_color}; border-radius: 6px 6px 0 0;">
<font size="2" color="{tab_color}"><b>AI Explanation{status}</b></font>{toggle_link}
</td>'''
            
            if has_poc:
                content = poc_result.get("content", "")
                is_loading = content.startswith("Generating") and len(content) < 50
                tab_color = "#e5c166" if is_loading else "#74c1cf"
                status = " (loading...)" if is_loading else ""
                toggle_text = "[show]" if poc_hidden else "[hide]"
                toggle_link = f'<a href="ai://toggle/{vuln_id}/poc" style="text-decoration:none; margin-left:8px;"><font color="#666">{toggle_text}</font></a>' if not is_loading else ""
                width = "50%" if has_explain else "100%"
                html += f'''<td width="{width}" style="background-color:#0a0a0f; padding: 8px 16px; border-top: 2px solid {tab_color}; border-radius: 6px 6px 0 0;">
<font size="2" color="{tab_color}"><b>Generated PoC{status}</b></font>{toggle_link}
</td>'''
            
            html += '</tr></table>'
            
            show_explain = has_explain and not explain_hidden
            show_poc = has_poc and not poc_hidden
            
            if show_explain or show_poc:
                html += '<table width="100%" cellpadding="0" cellspacing="4" style="table-layout: fixed;"><tr valign="top">'
                
                if has_explain and has_poc:
                    if show_explain:
                        explain_html = self._render_ai_content(explain_result, "#c45d97")
                        html += f'<td width="50%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; word-wrap: break-word;">{explain_html}</td>'
                    else:
                        html += '<td width="50%"></td>'
                    
                    if show_poc:
                        poc_html = self._render_ai_content(poc_result, "#74c1cf")
                        html += f'<td width="50%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; word-wrap: break-word;">{poc_html}</td>'
                    else:
                        html += '<td width="50%"></td>'
                else:
                    if show_explain:
                        explain_html = self._render_ai_content(explain_result, "#c45d97")
                        html += f'<td width="100%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; word-wrap: break-word;">{explain_html}</td>'
                    elif show_poc:
                        poc_html = self._render_ai_content(poc_result, "#74c1cf")
                        html += f'<td width="100%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; word-wrap: break-word;">{poc_html}</td>'
                
                html += '</tr></table>'

        html += '</td></tr></table>'
        return html

    def _render_vuln(self, v, bg_card, text_white, text_gray, text_light, brand_pink,
                     color_critical, color_error, color_warning, color_success, color_info, for_export=False):
        """Render a single vulnerability with navigation link"""
        rule_id = v.get("rule_id", "UNKNOWN")
        title = v.get("title", "Vulnerability")
        severity = v.get("severity", "MEDIUM").upper()
        desc = v.get("description", "")
        snippet = v.get("snippet", "")
        cwe = v.get("cwe", "")
        impact_desc = v.get("impact", "")
        refs = v.get("references", [])
        loc = v.get("location", {})
        line = loc.get("start_line", 0)
        
        # Get function address and name for navigation
        func_addr, func_name = self._get_func_info_for_line(line) if line else (None, None)
        
        impact_level = v.get("impact_level", "HIGH" if severity in ["CRITICAL", "HIGH"] else "MEDIUM")
        likelihood = v.get("likelihood_level", "LOW")
        confidence = v.get("confidence_level", "MEDIUM")
        
        sev_styles = {
            "CRITICAL": (color_critical, "#ffffff"),
            "HIGH": (color_error, "#ffffff"),
            "MEDIUM": (color_warning, "#1e1e1e"),
            "LOW": (color_success, "#1e1e1e"),
        }
        sev_bg, sev_fg = sev_styles.get(severity, ("#666666", "#ffffff"))
        
        # Navigation link - put on separate line, right-aligned
        nav_link = ""
        if func_addr and not for_export:
            nav_link = f'<div style="float:right;"><a href="ida://{hex(func_addr)}" class="jump-btn">Jump to Function</a></div>'
        
        # Function name display
        func_display = f" in <b>{self._escape_html(func_name)}</b>" if func_name else ""
        
        html = f'''
<br>
<table width="100%" border="1" bordercolor="#555555" cellpadding="20" cellspacing="0" bgcolor="{bg_card}">
<tr><td>
{nav_link}
<font size="2" color="{text_gray}">{self._escape_html(rule_id)} | Line {line}{func_display}</font><br>
<font size="4" color="{text_white}"><b>{self._escape_html(title)}</b></font><br><br>
<table cellpadding="0" cellspacing="0"><tr>
<td bgcolor="{sev_bg}" style="padding: 3px 6px;"><font size="1" color="{sev_fg}"><b>{severity}</b></font></td>
<td style="padding-left: 12px;"><font size="2" color="{text_gray}">Impact: </font><font size="2" color="{text_white}"><b>{impact_level}</b></font></td>
<td style="padding-left: 12px;"><font size="2" color="{text_gray}">Likelihood: </font><font size="2" color="{text_white}"><b>{likelihood}</b></font></td>
<td style="padding-left: 12px;"><font size="2" color="{text_gray}">Confidence: </font><font size="2" color="{text_white}"><b>{confidence}</b></font></td>
</tr></table>
'''

        if cwe:
            html += f'''<br><br>
<table cellpadding="8" cellspacing="0" style="background-color:#2d2030;">
<tr><td style="border-left: 3px solid {brand_pink};"><font size="2" color="{brand_pink}"><b>{self._escape_html(cwe)}</b></font></td></tr>
</table>
'''

        if desc:
            html += f'''<br><br>
<font size="2" color="{text_gray}">Description</font><br>
<font size="2" color="{text_light}">{self._escape_html(desc[:700])}</font>
'''

        if impact_desc:
            html += f'''<br><br>
<font size="2" color="{text_gray}">Impact</font><br>
<font size="2" color="{text_light}">{self._escape_html(impact_desc[:500])}</font>
'''

        if snippet:
            html += f'''<br><br>
<font size="2" color="{text_gray}">Vulnerable code example</font><br>
<table width="100%" cellpadding="12" cellspacing="0" style="background-color:#1e1e1e; margin-top: 8px;">
<tr><td><font face="Consolas, Monaco, monospace" size="2" color="{color_error}">{self._escape_html(snippet)}</font></td></tr>
</table>
'''

        if refs:
            html += f'<br><br><font size="2" color="{text_gray}">Resources</font><br>'
            for r in refs[:3]:
                html += f'<a href="{self._escape_html(r)}"><font size="2">{self._escape_html(r)}</font></a><br>'

        # AI Action buttons (VSCode-style)
        if not for_export:
            vuln_id = rule_id.replace(" ", "_")
            html += f'''<br><br>
<table cellpadding="0" cellspacing="4"><tr>
<td>
<a href="ai://explain/{vuln_id}" style="
    display: inline-block;
    background: linear-gradient(180deg, #0e639c 0%, #0a4d7a 100%);
    color: #ffffff;
    padding: 8px 16px;
    border-radius: 4px;
    text-decoration: none;
    font-family: 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid #0d5a8f;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
">Explain with AI</a>
</td>
<td style="padding-left: 8px;">
<a href="ai://poc/{vuln_id}" style="
    display: inline-block;
    background: linear-gradient(180deg, #6e40c9 0%, #553299 100%);
    color: #ffffff;
    padding: 8px 16px;
    border-radius: 4px;
    text-decoration: none;
    font-family: 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid #5c35a8;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
">Generate PoC</a>
</td>
</tr></table>
'''

            # Check if there are AI results for this vuln
            explain_result = self._get_ai_result(vuln_id, "explain")
            poc_result = self._get_ai_result(vuln_id, "poc")
            
            has_explain = explain_result is not None
            has_poc = poc_result is not None
            
            if has_explain or has_poc:
                # Use fixed table layout for aligned 50/50 columns
                html += '<br><table width="100%" cellpadding="0" cellspacing="4" style="table-layout: fixed;"><tr>'
                
                # Determine if content is hidden
                explain_hidden = explain_result.get("hidden", False) if has_explain else True
                poc_hidden = poc_result.get("hidden", False) if has_poc else True
                
                # Tab headers - always 50% each when both exist
                if has_explain:
                    content = explain_result.get("content", "")
                    is_loading = content.startswith("Generating") and len(content) < 50
                    tab_color = "#e5c166" if is_loading else "#c45d97"
                    status = " (loading...)" if is_loading else ""
                    toggle_text = "[show]" if explain_hidden else "[hide]"
                    toggle_link = f'<a href="ai://toggle/{vuln_id}/explain" style="text-decoration:none; margin-left:8px;"><font color="#666">{toggle_text}</font></a>' if not is_loading else ""
                    width = "50%" if has_poc else "100%"
                    html += f'''<td width="{width}" style="background-color:#0a0a0f; padding: 8px 16px; border-top: 2px solid {tab_color}; border-radius: 6px 6px 0 0;">
<font size="2" color="{tab_color}"><b>AI Explanation{status}</b></font>{toggle_link}
</td>'''
                
                if has_poc:
                    content = poc_result.get("content", "")
                    is_loading = content.startswith("Generating") and len(content) < 50
                    tab_color = "#e5c166" if is_loading else "#74c1cf"
                    status = " (loading...)" if is_loading else ""
                    toggle_text = "[show]" if poc_hidden else "[hide]"
                    toggle_link = f'<a href="ai://toggle/{vuln_id}/poc" style="text-decoration:none; margin-left:8px;"><font color="#666">{toggle_text}</font></a>' if not is_loading else ""
                    width = "50%" if has_explain else "100%"
                    html += f'''<td width="{width}" style="background-color:#0a0a0f; padding: 8px 16px; border-top: 2px solid {tab_color}; border-radius: 6px 6px 0 0;">
<font size="2" color="{tab_color}"><b>Generated PoC{status}</b></font>{toggle_link}
</td>'''
                
                html += '</tr></table>'
                
                # Content area - only show if not hidden
                show_explain_content = has_explain and not explain_hidden
                show_poc_content = has_poc and not poc_hidden
                
                if show_explain_content or show_poc_content:
                    html += '<table width="100%" cellpadding="0" cellspacing="4" style="table-layout: fixed;"><tr valign="top">'
                    
                    if has_explain and has_poc:
                        # Both exist - show columns based on hidden state
                        if show_explain_content:
                            explain_html = self._render_ai_content(explain_result, "#c45d97")
                            html += f'''<td width="50%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; vertical-align: top; word-wrap: break-word;">
{explain_html}
</td>'''
                        else:
                            html += '<td width="50%"></td>'  # Empty placeholder for alignment
                        
                        if show_poc_content:
                            poc_html = self._render_ai_content(poc_result, "#74c1cf")
                            html += f'''<td width="50%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; vertical-align: top; word-wrap: break-word;">
{poc_html}
</td>'''
                        else:
                            html += '<td width="50%"></td>'  # Empty placeholder for alignment
                    else:
                        # Single result - full width
                        if show_explain_content:
                            explain_html = self._render_ai_content(explain_result, "#c45d97")
                            html += f'''<td width="100%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; vertical-align: top; word-wrap: break-word;">
{explain_html}
</td>'''
                        elif show_poc_content:
                            poc_html = self._render_ai_content(poc_result, "#74c1cf")
                            html += f'''<td width="100%" style="background-color:#0a0a0f; padding: 12px; border-radius: 0 0 6px 6px; vertical-align: top; word-wrap: break-word;">
{poc_html}
</td>'''
                    
                    html += '</tr></table>'

        html += '</td></tr></table>'
        return html

    def _parse_vulnerabilities(self):
        """Parse vulnerabilities from scan output"""
        output = self.results.get("output", "")
        if not output:
            return []
        try:
            data = json.loads(output)
            return data.get("fail_results", [])
        except:
            return []

    def _escape_html(self, text):
        """Escape HTML special characters"""
        if not text:
            return ""
        text = str(text)
        return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;")

    def _print_console_summary(self):
        """Print summary to IDA console"""
        print(f"\n[Symbiotic] Scan Results: {len(self.vulns)} issue(s) found")
        for v in self.vulns[:5]:
            title = v.get("title", "Unknown")
            severity = v.get("severity", "?")
            print(f"  - [{severity}] {title}")
        if len(self.vulns) > 5:
            print(f"  ... and {len(self.vulns) - 5} more")

    def OnClose(self, form):
        pass

    def Show(self, title="Symbiotic Scan Results"):
        return idaapi.PluginForm.Show(self, title, options=idaapi.PluginForm.WOPN_PERSIST)

```