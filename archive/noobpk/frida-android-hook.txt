Project Path: arc_noobpk_frida-android-hook_icniegv5

Source Tree:

```txt
arc_noobpk_frida-android-hook_icniegv5
â”œâ”€â”€ CHANGELOG.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ frida-android-hook
â”‚   â”œâ”€â”€ androidhook
â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ hook.json
â”‚   â”‚   â”œâ”€â”€ hook.py
â”‚   â”‚   â””â”€â”€ utils
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ checkversion.py
â”‚   â”‚       â”œâ”€â”€ cli.py
â”‚   â”‚       â”œâ”€â”€ config.py
â”‚   â”‚       â”œâ”€â”€ dump-memory
â”‚   â”‚       â”‚   â”œâ”€â”€ dumper.py
â”‚   â”‚       â”‚   â”œâ”€â”€ fridump.py
â”‚   â”‚       â”‚   â””â”€â”€ utils.py
â”‚   â”‚       â”œâ”€â”€ listapp.py
â”‚   â”‚       â”œâ”€â”€ log.py
â”‚   â”‚       â””â”€â”€ suggestion.py
â”‚   â”œâ”€â”€ frida-scripts
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ android-crypto-interceptor.js
â”‚   â”‚   â”œâ”€â”€ android-intercepts-crypto.js
â”‚   â”‚   â”œâ”€â”€ android-logcat.js
â”‚   â”‚   â”œâ”€â”€ call-method-of-class.js
â”‚   â”‚   â”œâ”€â”€ dupDex.js
â”‚   â”‚   â”œâ”€â”€ fingerprint-bypass-via-exception-handling.js
â”‚   â”‚   â”œâ”€â”€ fingerprint-bypass.js
â”‚   â”‚   â”œâ”€â”€ frida-traffic-interceptor.js
â”‚   â”‚   â”œâ”€â”€ frinja-crypto.js
â”‚   â”‚   â”œâ”€â”€ hook-method-of-class.js
â”‚   â”‚   â”œâ”€â”€ intercept-android-apk-crypto-operations.js
â”‚   â”‚   â”œâ”€â”€ java-crypto-viewer.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_bypass.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_debug.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_enum.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_findClass1.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_findClass2.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_lowlevel.js
â”‚   â”‚   â”œâ”€â”€ raptor_frida_android_trace.js
â”‚   â”‚   â”œâ”€â”€ show-all-classes-methods.js
â”‚   â”‚   â”œâ”€â”€ show-all-classes.js
â”‚   â”‚   â”œâ”€â”€ show-module-exported-functions.js
â”‚   â”‚   â”œâ”€â”€ show-modules-exports.js
â”‚   â”‚   â””â”€â”€ show-specific-class-methods.js
â”‚   â””â”€â”€ methods
â”‚       â”œâ”€â”€ bypass_root.js
â”‚       â”œâ”€â”€ bypass_ssl.js
â”‚       â”œâ”€â”€ intercept_crypto.js
â”‚       â””â”€â”€ intercept_nw_request.js
â”œâ”€â”€ requirements.txt
â””â”€â”€ setup.py

```

`CHANGELOG.md`:

```md
# Frida Android Hook ChangeLog

## [Release 1.4] - 2024-09-05

### Added
- Add new frida scripts
- Add option --proxy
### Changed
- Update readme, changelog
- Update frida-script
- Update hook.py
### Fixed
- Fix bug

## [Release 1.3] - 2022-06-21

### Added
- Add setup.py for build executable
- Add suggestion script for option -s (--script)
### Changed
- Update readme, changelog
- Update frida-script
- Update hook.py
### Fixed
- Fix syntax in hook.json

## [Unrelease] - 2022-04-18

### Add
- Add setup.py for build executable

### Changed
- Update Readme.md

## [Unrelease] - 2022-03-17

### Added

### Changed
- Update androidhook. Check python3 command exists

## [Unrelease] - 2022-01-24

### Added
- Update frida-scripts
- Update option listscripts

### Changed
- Update README.md
- Update repo structure
- Preparing to release version 1.3

### Fixed
```

`LICENSE`:

```
MIT License

Copyright (c) 2020 lethanhphuc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<img width="544" alt="image" src="https://user-images.githubusercontent.com/31820707/108661418-60d4b500-74fe-11eb-81ed-c164df9ef4a5.png">

# Frida Android hook

[![CodeQL](https://github.com/noobpk/frida-android-hook/actions/workflows/codeql-analysis.yml/badge.svg)](https://github.com/noobpk/frida-android-hook/actions/workflows/codeql-analysis.yml)
![python](https://img.shields.io/badge/python-3.x-blue)
![frida](https://img.shields.io/badge/frida-15.x-orange)

ðŸ“ A tool that helps you can easy using frida. It support script for trace classes, functions, and modify the return values of methods on iOS platform.

ðŸ‘‰ For iOS platform: [frida-ios-hook](https://github.com/noobpk/frida-ios-hook)

## Env OS Support
| OS      | Supported          | Noted   |
| ------- | ------------------ | ------- |
| Darwin  | :white_check_mark: | main	 |
| Linux   | :white_check_mark: | sub  	 |
| Windows | :white_check_mark: | sub	 |

## Compatible with
| Android Api   |  Frida   | Supported         |
| ------------- | ---------| ----------------- |
|  8.0 - Api 26 | 14.2.13  | :white_check_mark:|
|  8.0 - Api 26 | 15.0.18  | :white_check_mark:|
|  13.0 - Api 33 | 16.4.9  | :white_check_mark:|

## Feature

Running with python3.x

Support both spawn & attach script to process.

```
[+] Options:

	-p(--package)		Identifier of application ex: com.android.calendar
	-n(--name) 		Name of application ex: Calendar
	-s(--script) 		Using script format script.js
	-c(--check-version) 	Check for the newest version
	-u(--update) 		Update to the newest version
	
	[*] Dump memory application:
	
    	--dump-memory         Dump memory of application

	[*] Information:

	--fs-install	    Install frida server
	--fs-start          Start frida server
	--fs-stop           Stop frida server
	--list-devices      List All Devices
	--list-apps         List the installed apps
	--list-scripts      List All Scripts
	--logcat            Show system log of device
	--shell             Get the shell of connect device
	--proxy             Config global proxy ::3128 and reverse tcp 3128:8080

	[*] Quick method:

	-m(--method)    Support commonly used methods
				bypass-root(-p)
				bypass-ssl(-p)
				i-nw-req(-p)
				i-crypto(-p)
```

## ChangeLog

Version: 1.4
```
	[+] Add:
	
		[-] Add new frida scrips
				
		[-] Add option `--proxy` for config global proxy on device
		
		
	[+] Change:
		
		[-] Update readme, changelog
		
		[-] Update frida-script
		
		[-] Update hook.py
	
	[+] Fix
		
		[-] Fix bug

```
[See Full ChangeLog](https://github.com/noobpk/frida-android-hook/blob/master/CHANGELOG.md)

## Install

```
	[+] Latest version
	
		https://github.com/noobpk/frida-android-hook/releases
		
	[+] Develop version
	
		git clone -b dev https://github.com/noobpk/frida-android-hook.git
```

## Build

```
2. cd frida-android-hook/
3. pip3 install -r requirements.txt
4. python3 setup.py
4. cd frida-android-hook
```

### Usage For Windows: 

```
5.1 Start Frida-server: `python3 androidhook.py --fs-start`
5.2 python3 androidhook.py --help(-h)
5.3 rebellion :))
```

### Usage For Darwin / Linux

```
6.1 Start Frida-server: `./androidhook --fs-start`
6.2 ./androidhook --help(-h)
6.3 rebellion :))
```
[See Full Usage as Wiki](https://github.com/noobpk/frida-android-hook/wiki)

If you run the script but it doesn't work, you can try the following:
```frida -U -f package -l script.js```

## ðŸ“º Demo Feature

|N|Title|Link|
|:---|:---|:---|
|1||
|2||
|3||

## Frida Scripts

|N|Spawn/Attach|Script Name| Script Description|Script Version|
|:---|:---|:---|:---|:---|
|1|S+A|android-intercepts-crypto.js|Android Intercepts Crypto Operations|1.0|
|2|S+A|android-logcat.js|Android logcat capture|1.0|
|3|S+A|call-method-of-class.js|Call method of class|1.0|
|4|S+A|dupDex.js|dupDex|1.0|
|5|S+A|fingerprint-bypass-via-exception-handling.js|Fingerprint bypass via Exception Handling.|1.0|
|6|S+A|fingerprint-bypass.js|Fingerprint bypass|1.0|
|7|S+A|hook-method-of-class.js|Hook method of class|1.0|
|8|S|raptor_frida_android_bypass.js|Raptor frida android bypass|1.0|
|9|S|raptor_frida_android_debug.js|Raptor frida android debug|1.0|
|10|S|raptor_frida_android_enum.js|Raptor frida android enum|1.0|
|11|S|raptor_frida_android_findClass1.js|Raptor frida android findclass 1|1.0|
|12|S|raptor_frida_android_findClass2.js|Raptor frida android findclass 2|1.0|
|13|S|raptor_frida_android_lowlevel.js|Raptor frida android low level |1.0|
|14|S|raptor_frida_android_trace.js|Raptor frida android trace|1.0|
|15|S+A|show-all-classes-methods.js|Show all class name and method|1.0|
|16|S+A|show-all-classes.js|Show all class name|1.0|
|17|S+A|show-module-exported-functions.js|Show module exported function|1.0|
|18|S+A|show-modules-exports.js|Show modules exports|1.0|
|19|S+A|show-specific-class-methods.js|Show specific class and method|1.0|

## Disclaimer
Because I am not a developer, so my coding skills might not be the best. Therefore, if this tool have any issue or not working for you, create an issue and i will try to fix it.
Any suggestions for new feature and discussions are welcome!



```

`frida-android-hook/androidhook`:

```
#!/usr/bin/python3

import os
import subprocess
import shlex
import sys
from shutil import which

try:
    if(which('python3') is not None):
        command = shlex.split("python3 " + "core/hook.py")
    else:
        command = shlex.split("python " + "core/hook.py")

    command.extend(sys.argv[1:])
    subprocess.call(command, cwd=os.path.dirname(__file__))

except Exception as e:
    raise e

```

`frida-android-hook/core/hook.json`:

```json
{
    "name": "frida-android-hook",
    "version": "1.4",
    "cliVersion": "1.0",
    "author": "noobpk",
    "license": "LICENSE",
    "requirements": "requirements.txt",
    "firstRun": true,
    "packages": {
        "windows": {
            "Android Debug Bridge": "https://dl.google.com/android/repository/platform-tools-latest-windows.zip"
        },
        "linux": {
            "Android Debug Bridge": "android-tools-adb"
        },
        "darwin": {
            "Android Debug Bridge": "android-platform-tools"
        }
    },
    "errorLog": "errors.log",
    "methods": {
        "Bypass Root Detection": "methods/bypass_root.js",
        "Bypass SSL Pinning": "methods/bypass_ssl.js",
        "Intercept Network Request": "methods/intercept_nw_request.js",
        "Intercept Crypto Operations": "methods/intercept_crypto.js"
    },
    "utils": {
        "Dump Memory": "core/utils/dump-memory/fridump.py"
    },
    "platformSupport": {
        "linux": "Linux",
        "linux1": "Linux",
        "linux2": "Linux",
        "darwin": "OS X",
        "win32": "Windows"
    },
    "fridaScripts": "frida-scripts/"
}
```

`frida-android-hook/core/hook.py`:

```py
import frida
import time
import os
import sys
import optparse
import subprocess
import re
import fnmatch
import shlex

from utils.listapp import *
from utils.checkversion import *
from utils.log import *
from utils.config import *
from utils.cli import *
from utils.suggestion import *

GLOBAL_CONFIG = config.loadConfig()

APP_FRIDA_SCRIPTS = GLOBAL_CONFIG['fridaScripts']
APP_METHODS = GLOBAL_CONFIG['methods']
APP_UTILS = GLOBAL_CONFIG['utils']

def start_frida_server(param_1):
    fs = "/data/local/tmp/frida-server*"
    isFs = os.system('adb shell ls ' + fs +' 2> /dev/null')
    if (isFs == 0 | isFs == 256):
        print("\033[1;31m[-] Frida Server Not Found!!\033[1;31m")
    else:
        fsName = os.popen('adb shell ls ' + fs + '|' + param_1).read()
        logger.info('[*] Found Frida Server: '+ fsName)
        isProc = os.popen('adb shell ps |' + param_1).read()
        if (isProc):
            logger.warning("[!] Frida Server Is Running")
        else:
            logger.info("[*] Start Frida Server...")
            os.system('adb shell chmod +x ' + fs)
            os.system('adb shell ' + 'su -c ' + fs + ' &')
            time.sleep(2)
            isProc = os.popen('adb shell ps |' + param_1).read()
            if (isProc):
                logger.info("[*] Frida Server Start Success!!")
            else:
                logger.error("[-] Frida Server Start Failed!! Check & Try Again")

def stop_frida_server(param):
    fs = "/data/local/tmp/frida-server*"
    
    # Check if the Frida server process is running
    isProc = subprocess.getoutput(f'adb shell ps | {param}')
    
    if isProc:
        logger.info("[*] Found Process Frida Server: " + isProc)
        logger.info("[*] Stop Frida Server...")

        # Try to stop the Frida server with su privilege
        result = subprocess.run(f'adb shell su -c "pkill -f {fs}"', shell=True)
        
        # Check if the su command was successful
        if result.returncode != 0:
            logger.error("[!] Failed to stop Frida Server with su -c")
            # Retry without su
            logger.info("[*] Try to stop Frida Server withou su...")
            result = subprocess.run(f'adb shell pkill -f {fs}', shell=True)
            
            if result.returncode != 0:
                logger.error("[!] Failed to stop Frida Server")
                return
        
        time.sleep(2)
        logger.info("[*] Stop Frida Server Success!!")
    else:
        logger.warning("[!] Frida Server Not Started")

def check_frida_server_run(param):
    isProc = os.popen('adb shell ps |' + param).read()
    if (isProc):
        return True
    else:
        logger.warning("[!] Frida Server Not Start")
        sys.exit(0)

def dump_memory(option, process):
    try:
        util = APP_UTILS['Dump Memory']
        if option != "-h":
            cmd = shlex.split("python3 " + util + ' ' + "-u" + ' ' + option + ' ' + '"' + process + '"')
        else:
            cmd = shlex.split("python3 " + util + ' ' + option)
        subprocess.call(cmd)
        sys.exit(0)
    except Exception as e:
        logger.error("[x_x] Something went wrong, please check your error message.\n Message - {0}".format(e))

def main():
    try:

        usage = '''
        [>] ./androidhook %prog [options] arg
        Example for spawn or attach app with -s(--script) options:
        [>] ./androidhook -p com.android.calendar / [-n 'Calendar'] -s trace_class.js
        Example for spawn or attach app with -m(--method) options:
        [>] ./androidhook -p com.android.calendar / [-n 'Calendar'] -m app-static'''

        parser = optparse.OptionParser(usage,add_help_option=False)
        info = optparse.OptionGroup(parser,"Information")
        quick = optparse.OptionGroup(parser,"Quick Method")

        parser.add_option('-h', "--help", action="help", dest="help", help='''Show basic help message and exit''')
        parser.add_option("--cli", action="store_true", dest="cli", help='''AndroidHook command line interface''')
        #Using options -p(--package) for spawn application and load script
        parser.add_option("-p", "--package", dest="package",
                        help='''Identifier of the target app''', metavar="PACKAGE", action="store", type="string")
        #Using options -n(--name) for attach script to application is running
        parser.add_option("-n", "--name", dest="name",
                        help='''Name of the target app''', metavar="NAME", action="store", type="string")

        parser.add_option("-s", "--script", dest="script",
                        help='''Frida Script Hooking''', metavar="SCIPRT.JS")

        parser.add_option("-c", "--check-version", action="store_true", help='''Check AndroidHook for the newest version''', dest="checkversion")
        parser.add_option("-u", "--update", action="store_true", help='''Update AndroidHook to the newest version''', dest="update")

        parser.add_option("--dump-memory", action="store", help='''Dump memory of application''', dest="dumpmemory")
        
        quick.add_option("-m", "--method", dest="method", type="choice", choices=['bypass-root','bypass-ssl','i-nw-req','i-crypto'],
                        help='''bypass-root: Bypass Root Detection(-p)
                        bypass-ssl: Bypass SSL Pinning(-p)
                        i-nw-req: Intercept NetworkRequest in App(-p)
                        i-crypto: Intercept Crypto in App(-p)''', metavar="METHOD")

        info.add_option("--fs-install",
                        action="store", help="Install frida server", dest="installfrida", type="string")
        info.add_option("--fs-start",
                        action="store_true", help="Start frida server", dest="startfs")
        info.add_option("--fs-stop",
                        action="store_true", help="Stop frida server", dest="stopfs")
        info.add_option("--list-devices",
                        action="store_true", help="List All Devices", dest="listdevices")
        info.add_option("--list-apps",
                        action="store_true", help="List the installed apps", dest="listapp") 
        info.add_option("--list-scripts",
                        action="store_true", help="List All Scripts", dest="listscripts")
        info.add_option("--logcat", action="store_true", help="Show system log of device", dest="logcat")
        info.add_option("--shell", action="store_true", help="Get the shell of connect device", dest="shell")
        info.add_option("--proxy", action="store_true", help="Config global proxy ::3128 and reverse tcp 3128:8080", dest="proxy")

        parser.add_option_group(info)
        parser.add_option_group(quick)

        options, args = parser.parse_args()
        
        if options.listdevices:
            logger.info('[*] List All Devices: ')
            os.system('frida-ls-devices')

        elif options.listscripts:
            path = APP_FRIDA_SCRIPTS
            description_pattern = " * Description:"
            mode_pattern = " * Mode:"
            version_pattern = " * Version:"

            if os.path.exists(path):
                logger.info('[*] List All Scripts: ')
                print("# Frida scripts for Android app testing")
                print(" ")
                files = os.listdir(path)
                sorted_files =  sorted(files)
                i = 0
                for file_name in sorted_files:
                    if fnmatch.fnmatch(file_name, '*.js'):
                        i +=1
                        f = open(path+file_name, "r")
                        for line in f:
                            if re.search(description_pattern, line):
                                description = re.sub(r'\n', '', line[16:])
                            if re.search(mode_pattern, line):
                                mode = re.sub(r'\s+', '', line[9:])
                            if re.search(version_pattern, line):
                                version = re.sub(r'\s+', '', line[12:])  
                        print('|%d|%s|%s|%s|%s|' % (i, mode, file_name, description, version))
            else:
                logger.error('[?] Path frida-script not exists!')

        elif options.installfrida:
            logger.info("[+] Installing Frida Server...")
            if os.path.isfile(options.installfrida):
               os.system('adb push ' + options.installfrida +' /data/local/tmp')
               logger.info("[+] Install Frida Server Success!!")
            else:
               logger.error('[?] Frida Server not found!')

        elif options.startfs:
            get_usb_iphone()
            if sys.platform == "win32":
                start_frida_server('FIND /I "frida-server"')
            else:
                start_frida_server('grep frida-server')          

        elif options.stopfs:
            get_usb_iphone()
            if sys.platform == "win32":
                stop_frida_server('FIND /I "frida-server"')
            else:
                stop_frida_server('grep frida-server')

        elif options.listapp:
            if sys.platform == "win32":
                check_frida_server_run('FIND /I "frida-server"')
            else:
                check_frida_server_run('grep frida-server')
            device = get_usb_iphone()
            list_applications(device)

        #Attaching script to application
        elif options.name and options.script:
            if not os.path.isfile(options.script):
                logger.warning('[!] Script '+options.script+' not found. Try suggestion in frida-script!')
                findingScript = suggestion_script(options.script)
                if (findingScript == False):
                    logger.error('[x_x] No matching suggestions!')
                    sys.exit(0)
                logger.info('[*] androidhook suggestion use '+findingScript)
                answer = input('[?] Do you want continue? (y/n): ') or "y"
                if answer == "y": 
                    options.script =  APP_FRIDA_SCRIPTS + findingScript
                elif answer == "n": 
                    sys.exit(0)
                else: 
                    logger.error('[x_x] Nothing done. Please try again!')
                    sys.exit(0)
            if os.path.isfile(options.script):
                logger.info('[*] Attaching: ' + options.name)
                logger.info('[*] Script: ' + options.script)
                time.sleep(2)
                process = frida.get_usb_device().attach(options.name)
                hook = open(options.script, 'r')
                script = process.create_script(hook.read())
                script.load()
                sys.stdin.read()
            else:
                logger.error('[?] Script not found!')

        #Spawning application and load script
        elif options.package and options.script:
            if not os.path.isfile(options.script):
                logger.warning('[!] Script '+options.script+' not found. Try suggestion in frida-script!')
                findingScript = suggestion_script(options.script)
                if (findingScript == False):
                    logger.error('[x_x] No matching suggestions!')
                    sys.exit(0)
                logger.info('[*] androidhook suggestion use '+findingScript)
                answer = input('[?] Do you want continue? (y/n): ') or "y"
                if answer == "y": 
                    options.script =  APP_FRIDA_SCRIPTS + findingScript
                elif answer == "n": 
                    sys.exit(0)
                else: 
                    logger.error('[x_x] Nothing done. Please try again!')
                    sys.exit(0)
            if os.path.isfile(options.script):
                logger.info('[*] Spawning: ' + options.package)
                logger.info('[*] Script: ' + options.script)
                time.sleep(2)
                pid = frida.get_usb_device().spawn(options.package)
                session = frida.get_usb_device().attach(pid)
                hook = open(options.script, 'r')
                script = session.create_script(hook.read())
                script.load()
                frida.get_usb_device().resume(pid)
                sys.stdin.read()
            else:
                logger.error('[?] Script not found!')

        #Bypass jailbreak
        elif options.package and options.method == "bypass-root":
            method = APP_METHODS['Bypass Root Detection']
            if os.path.isfile(method):
                logger.info('[*] Bypass Root: ')
                logger.info('[*] Spawning: ' + options.package)
                logger.info('[*] Script: ' + method)
                time.sleep(2)
                pid = frida.get_usb_device().spawn(options.package)
                session = frida.get_usb_device().attach(pid)
                hook = open(method, 'r')
                script = session.create_script(hook.read())
                script.load()
                frida.get_usb_device().resume(pid)
                sys.stdin.read()
            else:
                logger.error('[x_x] Script for method not found!')

        #Bypass SSL Pinning
        elif options.package and options.method == "bypass-ssl":
            method = APP_METHODS['Bypass SSL Pinning']
            if os.path.isfile(method):
                logger.info('[*] Bypass SSL Pinning: ')
                logger.info('[*] Spawning: ' + options.package)
                logger.info('[*] Script: ' + method)
                time.sleep(2)
                pid = frida.get_usb_device().spawn(options.package)
                session = frida.get_usb_device().attach(pid)
                hook = open(method, 'r')
                script = session.create_script(hook.read())
                script.load()
                frida.get_usb_device().resume(pid)
                sys.stdin.read()
            else:
                logger.error('[x_x] Script for method not found!')

        #Intercept url request in app
        elif options.name and options.method == "i-nw-req":
            method = APP_METHODS['Intercept Network Request']
            if os.path.isfile(method):
                logger.info('[*] Intercept NetWork Request: ')
                logger.info('[*] Attaching: ' + options.name)
                logger.info('[*] Script: ' + method)
                process = frida.get_usb_device().attach(options.name)
                method = open(method, 'r')
                script = process.create_script(method.read())
                script.load()
                sys.stdin.read()
            else:
                logger.error('[x_x] Script for method not found!')

        #Intercept Crypto Operations
        elif options.package and options.method == "i-crypto":
            method = APP_METHODS['Intercept Crypto Operations']
            if os.path.isfile(method):
                logger.info('[*] Intercept Crypto Operations: ')
                logger.info('[*] Spawning: ' + options.package)
                logger.info('[*] Script: ' + method)
                time.sleep(2)
                pid = frida.get_usb_device().spawn(options.package)
                session = frida.get_usb_device().attach(pid)
                hook = open(method, 'r')
                script = session.create_script(hook.read())
                script.load()
                frida.get_usb_device().resume(pid)
                sys.stdin.read()
            else:
                logger.error('[x_x] Script for method not found!')

        #check newversion
        elif options.checkversion:
            logger.info('[*] Checking for updates...')
            is_newest = check_version(speak=True)
            # if not is_newest:
            #     logger.info('[*] There is an update available for androidhook')

        #update newversion
        elif options.update:
            logger.info('[*] Update in progress...')
            cmd = shlex.split("git pull origin master")
            subprocess.call(cmd)
            sys.exit(0)

        #dump decrypt application
        elif options.package and options.dumpmemory:
            dump_memory(options.dumpmemory, options.package)

        #android system log
        elif options.logcat:
            cmd = shlex.split('adb logcat')
            subprocess.call(cmd)
            sys.exit(0)

        #android get the shell
        elif options.shell:
            cmd = shlex.split('adb shell')
            subprocess.call(cmd)
            sys.exit(0)

        #androidhook cli
        elif options.cli:
            logger.info("Welcome to AndroidHook CLI! Type ? to list commands")
            AndroidHook_CLI().cmdloop()

        #androidhook proxy
        elif options.proxy:
            cmd1 = shlex.split('adb shell settings put global http_proxy 127.0.0.1:3128')
            cmd2 = shlex.split('adb reverse tcp:3128 tcp:8080')

            logger.info("[*] Config device global proxy to ::3128")
            subprocess.call(cmd1)

            logger.info("[*] Config reverse tcp from device to machine 3128:8080")
            subprocess.call(cmd2)

            logger.info("[*] Config success - Using proxy 127.0.0.1:8080")
            sys.exit(0)

        else:
            logger.warning("[!] Specify the options. use (-h) for more help!")
            # sys.exit(0)

    #EXCEPTION FOR FRIDA
    except frida.ServerNotRunningError:
        logger.error("[x_x] Frida server is not running.")
    except frida.TimedOutError:
        logger.error("Timed out while waiting for device to appear.")
    except frida.TransportError:
        logger.error("[x_x] The application may crash or lose connection.")
    except (frida.ProcessNotFoundError,
            frida.InvalidOperationError):
        logger.error("[x_x] Unable to find process with name " + options.name + ". You need run app first.!!")
    #EXCEPTION FOR OPTIONPARSING

    #EXCEPTION FOR SYSTEM
    except Exception as e:
        logger.error("[x_x] Something went wrong, please check your error message.\n Message - {0}".format(e))

    except KeyboardInterrupt:
        logger.info("Bye bro!!")
        # sys.exit(0)

def run():
    #check python version
    if sys.version_info < (3, 0):
        logger.error("[x_x] Android hook requires Python 3.x")
        sys.exit(1)
    else:
        deleteLog()
        main()

if __name__ == '__main__':
    run()

    
```

`frida-android-hook/core/utils/checkversion.py`:

```py
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from utils.log import *
from utils.config import *

GLOBAL_CONFIG = config.loadConfig()

def check_version(speak=True):
    """
    check the version number for updates
    """
    version_url = "https://raw.githubusercontent.com/noobpk/frida-android-hook/master/frida-android-hook/core/hook.json"
    try:
        req = requests.get(version_url)
        content = req.text
        version_identification = content.find('"version": ')
        current_version = content[version_identification:version_identification + 16]
        current_version = str(current_version.strip().split('"')[3])
        my_version = GLOBAL_CONFIG['version']
        if not current_version == my_version:
            if speak:
                logger.info('[*] New version: {} is available'.format(current_version))
                return False
            else:
                return False
        else:
            if speak:
                logger.info('[*] AndroidHook already up to date.')
                return True
    except Exception:
        logger.error("[x_x] Error checking version, try again laster.")
        return True

# if __name__ == '__main__':
#     check_version()
```

`frida-android-hook/core/utils/cli.py`:

```py
import fnmatch
from cmd import Cmd

from utils.listapp import *
from utils.checkversion import *
from utils.log import *
from utils.config import *

GLOBAL_CONFIG = config.loadConfig()

APP_VERSION = GLOBAL_CONFIG['version']
APP_CLI_VERSION = GLOBAL_CONFIG['cliVersion']
APP_FRIDA_SCRIPTS = GLOBAL_CONFIG['fridaScripts']
APP_METHODS = GLOBAL_CONFIG['methods']
APP_UTILS = GLOBAL_CONFIG['utils']

class AndroidHook_CLI(Cmd):
    try:
        prompt = 'AndroidHook> '

        #DO COMMAND
        def do_version(self, arg):
            logger.info('[*] AndroidHook version: ' + APP_VERSION)
            logger.info('[*] AndroidHook CLI version: ' + APP_CLI_VERSION)

        def do_listdevices(self, arg):
            logger.info('[*] List All Devices: ')
            print(arg)
            os.system('frida-ls-devices')

        def do_listapps(self, arg):
            logger.info('[*] List All Apps on Devices: ')
            device = get_usb_iphone()
            list_applications(device)

        def do_listscripts(self, arg):
            path = APP_FRIDA_SCRIPTS
            if os.path.exists(path):
                logger.info('[*] List All Scripts: ')
                for file_name in os.listdir(path):
                    if fnmatch.fnmatch(file_name, '*.js'):
                        print('[*] ' + file_name)
            else:
                logger.error('[?] Path frida-script not exists!')

        def do_logcat(self, arg):
            logger.info('[*] Device System Log: ')
            cmd = shlex.split('abd logcat')
            subprocess.call(cmd)

        def do_shell(self, arg):
            logger.info('[*] Get Device Shell: ')
            cmd = shlex.split('abd shell')
            subprocess.call(cmd)

        def do_exit(self, arg):
            logger.info("Bye bro!!")
            return True
        
        #HELP DOCUMENT
        def help_version(self):
            logger.info('Show Version')

        def help_listdevices(self):
            logger.info('List All Devices')

        def help_listapps(self):
            logger.info('List The Installed Apps')

        def help_listscripts(self):
            logger.info('List All Scripts')

        def help_logcat(self):
            logger.info('Show System Log of Device')

        def help_shell(self):
            logger.info('Get The Shell of Connect Device')

        def help_exit(self):
            print('Exit AndroidHook CLI')

        def emptyline(self):
            pass

        do_EOF = do_exit
        help_EOF = help_exit

    #EXCEPTION FOR FRIDA
    except frida.ServerNotRunningError:
        logger.error("Frida server is not running.")
    except frida.TimedOutError:
        logger.error("Timed out while waiting for device to appear.")
    except frida.TransportError:
        logger.error("[x_x] The application may crash or lose connection.")
    except (frida.ProcessNotFoundError,
            frida.InvalidOperationError):
        logger.error("[x_x] Unable to find process with name " + options.name + ". You need run app first.!!")
    #EXCEPTION FOR OPTIONPARSING

    #EXCEPTION FOR SYSTEM
    except Exception as e:
        logger.error("[x_x] Something went wrong, please check your error message.\n Message - {0}".format(e))

    except KeyboardInterrupt:
        logger.info("Bye bro!!")

# if __name__ == '__main__':
#     MyPrompt().cmdloop()
```

`frida-android-hook/core/utils/config.py`:

```py
import os
import sys
import json
from shutil import which
import shlex
import subprocess
from utils.log import *

APP_AUTHOR = ''
APP_VERSION = ''
APP_PLATFORM_SUPPORT = ''
APP_FIRST_RUN = ''
APP_PACKAGES = ''
APP_CONFIG = 'core/hook.json'

class config():

    def loadConfig():

        global APP_VERSION, APP_AUTHOR, APP_PLATFORM_SUPPORT, APP_FIRST_RUN, APP_PACKAGES

        try:
            if os.path.isfile(APP_CONFIG):
                with open(APP_CONFIG, 'r') as f:
                    data = f.read()

                obj = json.loads(data)

                APP_AUTHOR = obj['author']
                APP_VERSION = obj['version']
                APP_CLI_VERSION = obj['cliVersion']
                APP_METHODS = obj['methods']
                APP_UTILS = obj['utils']
                APP_PLATFORM_SUPPORT = obj['platformSupport']
                APP_FIRST_RUN = obj['firstRun']
                APP_PACKAGES = obj['packages']
                APP_FRIDA_SCRIPTS = obj['fridaScripts']
                return {
                    "version" : APP_VERSION,
                    "cliVersion": APP_CLI_VERSION,
                    "author": APP_AUTHOR,
                    "methods": APP_METHODS,
                    "utils": APP_UTILS,
                    "platformSupport": APP_PLATFORM_SUPPORT,
                    "firstRun": APP_FIRST_RUN,
                    "packages": APP_PACKAGES,
                    "fridaScripts": APP_FRIDA_SCRIPTS
                }
            else:
                logger.error('Configuration File Not Found.')
        except Exception as e:
            logger.error("[x_x] Something went wrong, please check your error message.\n Message - {0}".format(e))

    def loadBanner():
        print ('''\033[1;31m \n
                                _           _     _   _    _             _    
                /\             | |         (_)   | | | |  | |           | |   
               /  \   _ __   __| |_ __ ___  _  __| | | |__| | ___   ___ | | __
              / /\ \ | '_ \ / _` | '__/ _ \| |/ _` | |  __  |/ _ \ / _ \| |/ /
             / ____ \| | | | (_| | | | (_) | | (_| | | |  | | (_) | (_) |   < 
            /_/    \_\_| |_|\__,_|_|  \___/|_|\__,_| |_|  |_|\___/ \___/|_|\_\\\t
                        https://noobpk.github.io          #noobboy
                    Trace Class/Func & Modify Return Value
            ''')

        print ("\033[1;34m[*]___author___: @" + APP_AUTHOR + "\033[1;37m")
        print ("\033[1;34m[*]___version___: " + APP_VERSION + "\033[1;37m")
        print ("")

config.loadConfig()
config.loadBanner()

class check():

    def initLoad():
        try:
            if APP_FIRST_RUN == True:
                logger.info("[*] This is the first time you are running AndroidHook. We are need install some package.")
                if sys.platform == 'darwin':
                    for name, cmd in APP_PACKAGES['darwin'].items():
                        logger.info("[*] Install " + name)
                        cmd = shlex.split("brew install " + cmd)
                        subprocess.call(cmd)
                elif sys.platform == 'linux':
                    for name, cmd in APP_PACKAGES['linux'].items():
                        logger.info("[*] Install " + name)
                        cmd = shlex.split("sudo apt-get install " + cmd)
                        subprocess.call(cmd)
                elif sys.platform == 'windows':
                    for name, cmd in APP_PACKAGES['windows'].items():
                        logger.warning("[*] You are running AndroidHook on Windows. Please download " + name + " at " + cmd + " then set system variable.!!")

                with open(APP_CONFIG, "r") as f:
                    data = json.load(f)
                    data['firstRun'] = False

                with open(APP_CONFIG, "w") as f:
                    f.write(json.dumps(data, sort_keys=False, indent=4))

        except Exception as e:
            logger.error("[x_x] Something went wrong, please check your error message.\n Message - {0}".format(e))

    def platform():
        try:
            if sys.platform not in APP_PLATFORM_SUPPORT:
                sys.exit(logger.error("[x_x] Your platform currently does not support."))
        except Exception as e:
            logger.error("[x_x] Something went wrong, please check your error message.\n Message - {0}".format(e))

check.initLoad()
check.platform()
```

`frida-android-hook/core/utils/dump-memory/dumper.py`:

```py
import os
import logging

# Reading bytes from session and saving it to a file

def dump_to_file(agent,base,size,error,directory):
        try:
                filename = str(base)+'_dump.data'
                dump =  agent.read_memory(base, size)
                f = open(os.path.join(directory,filename), 'wb')
                f.write(dump)
                f.close()
                return error
        except Exception as e:
            logging.debug("[!]"+str(e))
            print("Oops, memory access violation!")
            return error

#Read bytes that are bigger than the max_size value, split them into chunks and save them to a file

def splitter(agent,base,size,max_size,error,directory):
        times = size/max_size
        diff = size % max_size
        if diff is 0:
            logging.debug("Number of chunks:"+str(times+1))
        else:
            logging.debug("Number of chunks:"+str(times))
        global cur_base
        cur_base = int(base,0)

        for time in range(int(times)):
                logging.debug("Save bytes: "+str(cur_base)+" till "+str(cur_base+max_size))
                dump_to_file(agent, cur_base, max_size, error, directory)
                cur_base = cur_base + max_size

        if diff is not 0:
            logging.debug("Save bytes: "+str(hex(cur_base))+" till "+str(hex(cur_base+diff)))
            dump_to_file(agent, cur_base, diff, error, directory)


```

`frida-android-hook/core/utils/dump-memory/fridump.py`:

```py
import textwrap
import frida
import os
import sys
import frida.core
import dumper
import utils
import argparse
import logging

logo = """
        ______    _     _
        |  ___|  (_)   | |
        | |_ _ __ _  __| |_   _ _ __ ___  _ __
        |  _| '__| |/ _` | | | | '_ ` _ \| '_ \\
        | | | |  | | (_| | |_| | | | | | | |_) |
        \_| |_|  |_|\__,_|\__,_|_| |_| |_| .__/
                                         | |
                                         |_|
        """


# Main Menu
def MENU():
    parser = argparse.ArgumentParser(
        prog='dump-memory',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(""))

    parser.add_argument('process',
                        help='the process that you will be injecting to')
    parser.add_argument('-o', '--out', type=str, metavar="dir",
                        help='provide full output directory path. (def: \'memory-dump\')')
    parser.add_argument('-U', '--usb', action='store_true',
                        help='device connected over usb')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='verbose')
    parser.add_argument('-r', '--read-only', action='store_true',
                        help="dump read-only parts of memory. More data, more errors")
    parser.add_argument('-s', '--strings', action='store_true',
                        help='run strings on all dump files. Saved in output dir.')
    parser.add_argument('--max-size', type=int, metavar="bytes",
                        help='maximum size of dump file in bytes (def: 20971520)')
    args = parser.parse_args()
    return args


#print(logo)

arguments = MENU()

# Define Configurations
APP_NAME = arguments.process
DIRECTORY = ""
USB = arguments.usb
DEBUG_LEVEL = logging.INFO
STRINGS = arguments.strings
MAX_SIZE = 20971520
PERMS = 'rw-'

if arguments.read_only:
    PERMS = 'r--'

if arguments.verbose:
    DEBUG_LEVEL = logging.DEBUG
logging.basicConfig(format='%(levelname)s:%(message)s', level=DEBUG_LEVEL)


# Start a new Session
session = None
try:
    if USB:
        session = frida.get_usb_device().attach(APP_NAME)
    else:
        session = frida.attach(APP_NAME)
except Exception as e:
    print("Can't connect to App. Have you connected the device?")
    logging.debug(str(e))
    sys.exit()


# Selecting Output directory
if arguments.out is not None:
    DIRECTORY = arguments.out
    if os.path.isdir(DIRECTORY):
        print("Output directory is set to: " + DIRECTORY)
    else:
        print("The selected output directory does not exist!")
        sys.exit(1)

else:
    print("Current Directory: " + str(os.getcwd()))
    DIRECTORY = os.path.join(os.getcwd(), "memory-dump")
    print("Output directory is set to: " + DIRECTORY)
    if not os.path.exists(DIRECTORY):
        print("Creating directory...")
        os.makedirs(DIRECTORY)

mem_access_viol = ""

print("Starting Memory dump...")

script = session.create_script(
    """'use strict';

    rpc.exports = {
      enumerateRanges: function (prot) {
        return Process.enumerateRangesSync(prot);
      },
      readMemory: function (address, size) {
        return Memory.readByteArray(ptr(address), size);
      }
    };

    """)
script.on("message", utils.on_message)
script.load()

agent = script.exports
ranges = agent.enumerate_ranges(PERMS)

if arguments.max_size is not None:
    MAX_SIZE = arguments.max_size

i = 0
l = len(ranges)

# Performing the memory dump
for range in ranges:
    base = range["base"]
    size = range["size"]

    logging.debug("Base Address: " + str(base))
    logging.debug("")
    logging.debug("Size: " + str(size))


    if size > MAX_SIZE:
        logging.debug("Too big, splitting the dump into chunks")
        mem_access_viol = dumper.splitter(
            agent, base, size, MAX_SIZE, mem_access_viol, DIRECTORY)
        continue
    mem_access_viol = dumper.dump_to_file(
        agent, base, size, mem_access_viol, DIRECTORY)
    i += 1
    utils.printProgress(i, l, prefix='Progress:', suffix='Complete', bar=50)
print("")

# Run Strings if selected

if STRINGS:
    files = os.listdir(DIRECTORY)
    i = 0
    l = len(files)
    print("Running strings on all files:")
    for f1 in files:
        utils.strings(f1, DIRECTORY)
        i += 1
        utils.printProgress(i, l, prefix='Progress:', suffix='Complete', bar=50)
print("Finished!")
```

`frida-android-hook/core/utils/dump-memory/utils.py`:

```py
import sys
import string
import logging
import os
import re
from io import open

# Progress bar function
def printProgress (times, total, prefix ='', suffix ='', decimals = 2, bar = 100):
    filled = int(round(bar * times / float(total)))
    percents = round(100.00 * (times / float(total)), decimals)
    bar = '#' * filled + '-' * (bar - filled)
    sys.stdout.write('%s [%s] %s%s %s\r' % (prefix, bar, percents, '%', suffix)),
    sys.stdout.flush()
    if times == total:
        print("\n")


# A very basic implementations of Strings
def strings(filename, directory, min=4):
    strings_file = os.path.join(directory, "strings.txt")
    path = os.path.join(directory, filename)
    with open(path, encoding='Latin-1') as infile:
        str_list = re.findall("[\x20-\x7E]+\x00", infile.read())
        with open(strings_file, "a") as st:
            for string in str_list:
                if len(string) > min:
                    logging.debug(string)
                    st.write(string + "\n")

# Method to receive messages from Javascript API calls
def on_message(message, data):
   print("[on_message] message:", message, "data:", data)

```

`frida-android-hook/core/utils/listapp.py`:

```py
import frida
import threading
import sys

def get_usb_iphone():
    Type = 'usb'
    if int(frida.__version__.split('.')[0]) < 12:
        Type = 'tether'
    device_manager = frida.get_device_manager()
    changed = threading.Event()

    def on_changed():
        changed.set()

    device_manager.on('changed', on_changed)

    device = None
    while device is None:
        devices = [dev for dev in device_manager.enumerate_devices() if dev.type == Type]
        if len(devices) == 0:
            print('Waiting for USB device...')
            changed.wait()
        else:
            device = devices[0]

    device_manager.off('changed', on_changed)

    return device

def compare_applications(a, b):
    a_is_running = a.pid != 0
    b_is_running = b.pid != 0
    if a_is_running == b_is_running:
        if a.name > b.name:
            return 1
        elif a.name < b.name:
            return -1
        else:
            return 0
    elif a_is_running:
        return -1
    else:
        return 1

def cmp_to_key(mycmp):
    """Convert a cmp= function into a key= function"""

    class K:
        def __init__(self, obj):
            self.obj = obj

        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0

        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0

        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0

        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0

        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0

        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0

    return K

def get_applications(device):
    try:
        applications = device.enumerate_applications()
    except Exception as e:
        sys.exit('Failed to enumerate applications: %s' % e)

    return applications

def list_applications(device):
    applications = get_applications(device)

    if len(applications) > 0:
        pid_column_width = max(map(lambda app: len('{}'.format(app.pid)), applications))
        name_column_width = max(map(lambda app: len(app.name), applications))
        identifier_column_width = max(map(lambda app: len(app.identifier), applications))
    else:
        pid_column_width = 0
        name_column_width = 0
        identifier_column_width = 0

    header_format = '%' + str(pid_column_width) + 's  ' + '%-' + str(name_column_width) + 's  ' + '%-' + str(
        identifier_column_width) + 's'
    print(header_format % ('PID', 'Name', 'Identifier'))
    print('%s  %s  %s' % (pid_column_width * '-', name_column_width * '-', identifier_column_width * '-'))
    line_format = '%' + str(pid_column_width) + 's  ' + '%-' + str(name_column_width) + 's  ' + '%-' + str(
        identifier_column_width) + 's'
    for application in sorted(applications, key=cmp_to_key(compare_applications)):
        if application.pid == 0:
            print(line_format % ('-', application.name, application.identifier))
        else:
            print(line_format % (application.pid, application.name, application.identifier))
```

`frida-android-hook/core/utils/log.py`:

```py
import os
import logging
from colorlog import ColoredFormatter


def setup_logging():
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    color_formatter = ColoredFormatter(
            "%(log_color)s[%(asctime)s] [%(levelname)-4s]%(reset)s - %(message)s",
            datefmt='%d-%m-%y %H:%M:%S',
            reset=True,
            log_colors={
                'DEBUG':    'cyan',
                'INFO':     'green',
                'WARNING':  'bold_yellow',
                'ERROR':    'bold_red',
                'CRITICAL': 'bold_red',
            },
            secondary_log_colors={},
            style='%')
    logging_handler = logging.StreamHandler()
    logging_handler.setFormatter(color_formatter)
    logger.addHandler(logging_handler)
    #record logg
    file_handler = logging.FileHandler('errors.log')
    file_handler.setLevel(logging.ERROR)
    file_format = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(file_format)
    logger.addHandler(file_handler)
    
# setup logging for script
setup_logging()
logger = logging.getLogger(__name__)

def deleteLog():
    try:
        pwd = os.getcwd()
        path = pwd + '/errors.log'
        file_stats = os.stat(path)
        if (file_stats.st_size > 1024000000): #delete errors.log if file size > 1024 MB
            os.remove(path)
        else:
            return True
    except Exception as e:
        logger.error("[x_x] Something went wrong when clear error log. Please clear error log manual.\n Message - {0}".format(e))
```

`frida-android-hook/core/utils/suggestion.py`:

```py
import os
from utils.config import *

GLOBAL_CONFIG = config.loadConfig()
APP_FRIDA_SCRIPTS = GLOBAL_CONFIG['fridaScripts']

list_Script = os.listdir(APP_FRIDA_SCRIPTS)

def suggestion_script(word):
    i = 0
    while i < len(list_Script):
        if word[0] == list_Script[i][0] and word[1] == list_Script[i][1]:
            return list_Script[i]
        i += 1
    else:
        return False

# if __name__ == '__main__':
#     suggestion_script()
```

`frida-android-hook/frida-scripts/README.md`:

```md
# Frida scripts for Android app testing

|N|Spawn/Attach|Script Name| Script Description|Script Version|
|:---|:---|:---|:---|:---|
|1|S+A|android-intercepts-crypto.js|Android Intercepts Crypto Operations|1.0|
|2|S+A|android-logcat.js|Android logcat capture|1.0|
|3|S+A|call-method-of-class.js|Call method of class|1.0|
|4|S+A|dupDex.js|dupDex|1.0|
|5|S+A|fingerprint-bypass-via-exception-handling.js|Fingerprint bypass via Exception Handling.|1.0|
|6|S+A|fingerprint-bypass.js|Fingerprint bypass|1.0|
|7|S+A|hook-method-of-class.js|Hook method of class|1.0|
|8|S|raptor_frida_android_bypass.js|Raptor frida android bypass|1.0|
|9|S|raptor_frida_android_debug.js|Raptor frida android debug|1.0|
|10|S|raptor_frida_android_enum.js|Raptor frida android enum|1.0|
|11|S|raptor_frida_android_findClass1.js|Raptor frida android findclass 1|1.0|
|12|S|raptor_frida_android_findClass2.js|Raptor frida android findclass 2|1.0|
|13|S|raptor_frida_android_lowlevel.js|Raptor frida android low level |1.0|
|14|S|raptor_frida_android_trace.js|Raptor frida android trace|1.0|
|15|S+A|show-all-classes-methods.js|Show all class name and method|1.0|
|16|S+A|show-all-classes.js|Show all class name|1.0|
|17|S+A|show-module-exported-functions.js|Show module exported function|1.0|
|18|S+A|show-modules-exports.js|Show modules exports|1.0|
|19|S+A|show-specific-class-methods.js|Show specific class and method|1.0|

## Credit

âž¡ï¸ [interference-security/frida-scripts](https://github.com/interference-security/frida-scripts/tree/master/android)

âž¡ï¸ [0xdea/frida-scripts](https://github.com/0xdea/frida-scripts/tree/master/android-snippets)

âž¡ï¸ [Frida CodeShare](https://codeshare.frida.re/browse)


```

`frida-android-hook/frida-scripts/android-crypto-interceptor.js`:

```js
/**@@@+++@@@@******************************************************************
 **
 ** Android Crypto Interceptor frida script v1.4 hyugogirubato
 **
 ** frida -D "DEVICE" -l "crypto.js" -f "PACKAGE"
 **
 ** Update: Removed detection of UUID form in hex format.
 **
 ***@@@---@@@@******************************************************************
 */


// Custom params
const MODE = {
    KeyGenerator: true,
    KeyPairGenerator: true,
    SecretKeySpec: true,
    MessageDigest: true,
    SecretKeyFactory: true,
    Signature: true,
    Cipher: true,
    Mac: true,
    KeyGenParameterSpec: true,
    IvParameterSpec: true
};


let index = 0; // color index
const STRING = Java.use("java.lang.String");
const BASE64 = Java.use("java.util.Base64");
const COLORS = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    reset: '\x1b[0m'
};

const randomColor = () => {
    const colorKeys = Object.keys(COLORS).filter(key => key !== "reset" && key !== "red");
    index = (index + 1) % colorKeys.length;
    return COLORS[colorKeys[index]];
}

const bytesToString = (bytes) => {
    return bytes === null ? null : STRING.$new(bytes).toString();
}

const bytesToBase64 = (bytes) => {
    if (bytes !== null) {
        try {
            return BASE64.getEncoder().encodeToString(bytes);
        } catch {
            return BASE64.getEncoder().encodeToString([bytes & 0xff]);
        }
    }
    return null;
}

const Base64ToHex = (base64) => {
    const bytes = BASE64.getDecoder().decode(base64);
    let hexData = "";
    for (let i = 0; i < bytes.length; i++) {
        let value = bytes[i].toString(16);
        if (value.length % 2 === 1) {
            value = "0" + value
        }
        hexData += value
    }
    return hexData;
}

const showVariable = (module, items, colorKey, hexValue = false) => {
    console.log(`${colorKey}[+] onEnter: ${module}${COLORS.reset}`);
    for (let i = 0; i < items.length; i++) {
        console.log(`${colorKey}  --> [${i}] ${items[i].key}: ${items[i].value}${COLORS.reset}`);

        // Hex
        if (items[i].key.includes("Base64") && items[i].value !== null) {
            const key = items[i].key.replace("Base64", "HEX");
            const value = Base64ToHex(items[i].value);
            if ((!value.includes("-") && [32, 40, 48, 64].includes(value.length)) || hexValue) {
                console.log(`${colorKey}  --> [${i}] ${key}: ${value}${COLORS.reset}`);
            }
        }
    }
    console.log(`${colorKey}[-] onLeave: ${module}${COLORS.reset}`);
}


setTimeout(function () {
    console.log("---");
    console.log("Capturing Android app...");

    if (Java.available) {
        console.log("[*] Java available");
        Java.perform(function () {

            if (MODE.KeyGenerator) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.KeyGenerator");
                const keyGenerator = Java.use("javax.crypto.KeyGenerator");

                keyGenerator.generateKey.implementation = function () {
                    showVariable("keyGenerator.generateKey", [], colorKey);
                    return this.generateKey();
                };

                keyGenerator.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("keyGenerator.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                keyGenerator.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("keyGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                keyGenerator.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("keyGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

            }

            if (MODE.KeyPairGenerator) {
                const colorKey = randomColor();
                console.log("[*] Module attached: java.security.KeyPairGenerator");
                const keyPairGenerator = Java.use("java.security.KeyPairGenerator");
                keyPairGenerator.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("keyPairGenerator.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                keyPairGenerator.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("keyPairGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                keyPairGenerator.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("keyPairGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.SecretKeySpec) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.spec.SecretKeySpec");
                const secretKeySpec = Java.use("javax.crypto.spec.SecretKeySpec");
                secretKeySpec.$init.overload("[B", "java.lang.String").implementation = function (key, cipher) {
                    const keyBase64 = bytesToBase64(key);
                    const keyString = bytesToString(key);
                    showVariable("secretKeySpec.init", [
                        {key: "Key Base64", value: keyBase64},
                        {key: "Key String", value: keyString},
                        {key: "Algorithm", value: cipher}
                    ], colorKey);
                    return secretKeySpec.$init.overload("[B", "java.lang.String").call(this, key, cipher);
                }
            }

            if (MODE.MessageDigest) {
                const colorKey = randomColor();
                console.log("[*] Module attached: java.security.MessageDigest");
                const messageDigest = Java.use("java.security.MessageDigest");
                messageDigest.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("messageDigest.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                messageDigest.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("messageDigest.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                messageDigest.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("messageDigest.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                messageDigest.update.overload("[B").implementation = function (input) {
                    const inputBase64 = bytesToBase64(input);
                    const inputString = bytesToString(input);
                    showVariable("messageDigest.update", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString}
                    ], colorKey);
                    return this.update.overload("[B").call(this, input);
                };

                messageDigest.digest.overload().implementation = function () {
                    const output = messageDigest.digest.overload().call(this);
                    const outputBase64 = bytesToBase64(output);
                    const outputString = bytesToString(output);
                    showVariable("messageDigest.digest", [
                        {key: "Output Base64", value: outputBase64},
                        {key: "Output String", value: outputString},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    return output;
                };

                /*
                messageDigest.digest.overload("[B").implementation = function (input) {
                    const inputBase64 = bytesToBase64(input);
                    const inputString = bytesToString(input);
                    showVariable("messageDigest.digest", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    return this.digest.overload("[B").call(this, input);
                };

                messageDigest.digest.overload("[B", "int", "int").implementation = function (input, offset, len) {
                    const inputBase64 = bytesToBase64(input);
                    const inputString = bytesToString(input);
                    showVariable("messageDigest.digest", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Algorithm", value: this.getAlgorithm()},
                        {key: "Offset", value: offset},
                        {key: "Length", value: len}
                    ], colorKey);
                    return this.digest.overload("[B", "int", "int").call(this, input, offset, len);
                };
                 */

            }

            if (MODE.SecretKeyFactory) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.SecretKeyFactory");
                const secretKeyFactory = Java.use("javax.crypto.SecretKeyFactory");
                secretKeyFactory.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("secretKeyFactory.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                secretKeyFactory.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("secretKeyFactory.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                secretKeyFactory.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("secretKeyFactory.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.Signature) {
                const colorKey = randomColor();
                console.log("[*] Module attached: java.security.Signature");
                const signature = Java.use("java.security.Signature");
                signature.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("signature.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                signature.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("signature.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                signature.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("signature.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.Cipher) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.Cipher");
                const cipher = Java.use("javax.crypto.Cipher");
                cipher.init.overload("int", "java.security.Key").implementation = function (opmode, key) {
                    showVariable("cipher.init", [
                        {key: "Key", value: bytesToBase64(key.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.Key").call(this, opmode, key);
                }

                cipher.init.overload("int", "java.security.cert.Certificate").implementation = function (opmode, certificate) {
                    showVariable("cipher.init", [
                        {key: "Certificate", value: bytesToBase64(certificate.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.cert.Certificate").call(this, opmode, certificate);
                }

                cipher.init.overload("int", "java.security.Key", "java.security.AlgorithmParameters").implementation = function (opmode, key, algorithmParameter) {
                    showVariable("cipher.init", [
                        {key: "Key", value: bytesToBase64(key.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.Key", "java.security.AlgorithmParameters").call(this, opmode, key, algorithmParameter);
                }

                cipher.init.overload("int", "java.security.Key", "java.security.spec.AlgorithmParameterSpec").implementation = function (opmode, key, algorithmParameter) {
                    showVariable("cipher.init", [
                        {key: "Key", value: bytesToBase64(key.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.Key", "java.security.spec.AlgorithmParameterSpec").call(this, opmode, key, algorithmParameter);
                }

                cipher.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("cipher.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                cipher.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("cipher.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                cipher.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("cipher.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                cipher.doFinal.overload("[B").implementation = function (arg0) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B").call(this, arg0);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                };


                cipher.doFinal.overload("[B", "int").implementation = function (arg0, arg1) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int").call(this, arg0, arg1);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }

                cipher.doFinal.overload("[B", "int", "int").implementation = function (arg0, arg1, arg2) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int", "int").call(this, arg0, arg1, arg2);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }

                cipher.doFinal.overload("[B", "int", "int", "[B").implementation = function (arg0, arg1, arg2, arg3) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int", "int", "[B").call(this, arg0, arg1, arg2, arg3);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }

                cipher.doFinal.overload("[B", "int", "int", "[B", "int").implementation = function (arg0, arg1, arg2, arg3, arg4) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int", "int", "[B", "int").call(this, arg0, arg1, arg2, arg3, arg4);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }
            }

            if (MODE.Mac) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.Mac");
                const mac = Java.use("javax.crypto.Mac");
                mac.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("mac.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                mac.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("mac.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                mac.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("mac.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.KeyGenParameterSpec) {
                const colorKey = randomColor();
                console.log("[*] Module attached: android.security.keystore.KeyGenParameterSpec$Builder");
                const useKeyGen = Java.use("android.security.keystore.KeyGenParameterSpec$Builder");
                useKeyGen.$init.overload("java.lang.String", "int").implementation = function (keyStoreAlias, purpose) {
                    let purposeStr = "";
                    if (purpose === 1) {
                        purposeStr = "encrypt";
                    } else if (purpose === 2) {
                        purposeStr = "decrypt";
                    } else if (purpose === 3) {
                        purposeStr = "decrypt|encrypt";
                    } else if (purpose === 4) {
                        purposeStr = "sign";
                    } else if (purpose === 8) {
                        purposeStr = "verify";
                    } else {
                        purposeStr = purpose;
                    }

                    showVariable("KeyGenParameterSpec.init", [
                        {key: "KeyStoreAlias", value: keyStoreAlias},
                        {key: "Purpose", value: purposeStr}
                    ], colorKey);
                    return useKeyGen.$init.overload("java.lang.String", "int").call(this, keyStoreAlias, purpose);
                }

                useKeyGen.setBlockModes.implementation = function (modes) {
                    showVariable("KeyGenParameterSpec.setBlockModes", [
                        {key: "BlockMode", value: modes.toString()}
                    ], colorKey);
                    return useKeyGen.setBlockModes.call(this, modes);
                }

                useKeyGen.setDigests.implementation = function (digests) {
                    showVariable("KeyGenParameterSpec.setDigests", [
                        {key: "Digests", value: digests.toString()}
                    ], colorKey);
                    return useKeyGen.setDigests.call(this, digests);
                }

                useKeyGen.setKeySize.implementation = function (keySize) {
                    showVariable("KeyGenParameterSpec.setKeySize", [
                        {key: "KeySize", value: keySize}
                    ], colorKey);
                    return useKeyGen.setKeySize.call(this, keySize);
                }

                useKeyGen.setEncryptionPaddings.implementation = function (paddings) {
                    showVariable("KeyGenParameterSpec.setEncryptionPaddings", [
                        {key: "Paddings", value: paddings.toString()}
                    ], colorKey);
                    return useKeyGen.setEncryptionPaddings.call(this, paddings);
                }

                useKeyGen.setSignaturePaddings.implementation = function (paddings) {
                    showVariable("KeyGenParameterSpec.setSignaturePaddings", [
                        {key: "Paddings", value: paddings.toString()}
                    ], colorKey);
                    return useKeyGen.setSignaturePaddings.call(this, paddings);
                }

                useKeyGen.setAlgorithmParameterSpec.implementation = function (spec) {
                    showVariable("KeyGenParameterSpec.setAlgorithmParameterSpec", [
                        {key: "ParameterSpec", value: spec.toString()}
                    ], colorKey);
                    return useKeyGen.setAlgorithmParameterSpec.call(this, spec);
                }

                useKeyGen.build.implementation = function () {
                    showVariable("KeyGenParameterSpec.build", [], colorKey);
                    return useKeyGen.build.call(this);
                }
            }

            if (MODE.IvParameterSpec) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.spec.IvParameterSpec");
                const ivParameter = Java.use("javax.crypto.spec.IvParameterSpec");
                ivParameter.$init.overload("[B").implementation = function (ivKey) {
                    showVariable("IvParameterSpec.init", [
                        {key: "IV Key", value: bytesToBase64(ivKey)}
                    ], colorKey);
                    return this.$init.overload("[B").call(this, ivKey);
                }

                ivParameter.$init.overload("[B", "int", "int").implementation = function (ivKey, offset, len) {
                    showVariable("IvParameterSpec.init", [
                        {key: "IV Key", value: bytesToBase64(ivKey)},
                        {key: "Offset", value: offset},
                        {key: "Length", value: len}
                    ], colorKey);
                    return this.$init.overload("[B", "int", "int").call(this, ivKey, offset, len);
                }
            }

        });
    } else {
        console.log(`${COLORS.red}[!] Java unavailable${COLORS.reset}`);
    }

    console.log("Capturing setup completed");
    console.log("---");
}, 0);
```

`frida-android-hook/frida-scripts/android-intercepts-crypto.js`:

```js
/* Description: Android Intercepts Crypto Operations
 * Mode: S+A
 * Version: 1.0
 * Credit: https://codeshare.frida.re/@fadeevab/intercept-android-apk-crypto-operations/
 * Author: @fadeevab
 */
/*************************************************************************************
 * Name: Intercepts Crypto Operations
 * OS: Android
 * Author: @fadeevab
 * Source: https://codeshare.frida.re/@fadeevab/intercept-android-apk-crypto-operations/
 **************************************************************************************/


function bin2ascii(array) {
    var result = [];

    for (var i = 0; i < array.length; ++i) {
        result.push(String.fromCharCode( // hex2ascii part
            parseInt(
                ('0' + (array[i] & 0xFF).toString(16)).slice(-2), // binary2hex part
                16
            )
        ));
    }
    return result.join('');
}

function bin2hex(array, length) {
    var result = "";

    length = length || array.length;

    for (var i = 0; i < length; ++i) {
        result += ('0' + (array[i] & 0xFF).toString(16)).slice(-2);
    }
    return result;
}

Java.perform(function() {
    Java.use('javax.crypto.spec.SecretKeySpec').$init.overload('[B', 'java.lang.String').implementation = function(key, spec) {
        send("KEY: " + bin2hex(key) + " | " + bin2ascii(key));
        return this.$init(key, spec);
    };

    Java.use('javax.crypto.Cipher')['getInstance'].overload('java.lang.String').implementation = function(spec) {
        send("CIPHER: " + spec);
        return this.getInstance(spec);
    };

    Java.use('javax.crypto.Cipher')['doFinal'].overload('[B').implementation = function(data) {
        send("doFinal!");
        send(bin2ascii(data));
        return this.doFinal(data);
    };
});

```

`frida-android-hook/frida-scripts/android-logcat.js`:

```js
/* Description: Android logcat capture
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
Java.perform(function() {
	var class_name = Java.use("android.util.Log");
	//isLoggable
	class_name.isLoggable.overload("java.lang.String", "int").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " isLoggable was called:")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	//DEBUG
	class_name.d.overload("java.lang.String", "java.lang.String").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " DEBUG (d):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.d.overload("java.lang.String", "java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2, arg3) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " DEBUG (d):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		console.log("\targ3 : " + arg3.toString())
		return true;
	}
	//ERROR
	class_name.e.overload("java.lang.String", "java.lang.String").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " ERROR (e):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.e.overload("java.lang.String", "java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2, arg3) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " ERROR (e):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		console.log("\targ3 : " + arg3.toString())
		return true;
	}
	//INFO
	class_name.i.overload("java.lang.String", "java.lang.String").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " INFO (i):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.i.overload("java.lang.String", "java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2, arg3) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " INFO (i):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		console.log("\targ3 : " + arg3.toString())
		return true;
	}
	//VERBOSE
	class_name.v.overload("java.lang.String", "java.lang.String").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " VERBOSE (v):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.v.overload("java.lang.String", "java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2, arg3) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " VERBOSE (v):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		console.log("\targ3 : " + arg3.toString())
		return true;
	}
	//WARNING
	class_name.w.overload("java.lang.String", "java.lang.String").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " WARNING (w):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.w.overload("java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " WARNING (w):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.w.overload("java.lang.String", "java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2, arg3) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " WARNING (w):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		console.log("\targ3 : " + arg3.toString())
		return true;
	}
	//What a Terrible Failure (WTF)
	class_name.wtf.overload("java.lang.String", "java.lang.String").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " WTF (wtf):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.wtf.overload("java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " WTF (wtf):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		return true;
	}
	class_name.wtf.overload("java.lang.String", "java.lang.String", "java.lang.Throwable").implementation = function (arg1, arg2, arg3) {
		var today = new Date()
		var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
		console.log("[*] " + time + " WTF (wtf):")
		console.log("\targ1 : " + arg1.toString())
		console.log("\targ2 : " + arg2.toString())
		console.log("\targ3 : " + arg3.toString())
		return true;
	}
});

```

`frida-android-hook/frida-scripts/call-method-of-class.js`:

```js
/* Description: Call method of class
 * Mode: S+A
 * Version: 1.0
 * Credit: https://11x256.github.io/Frida-hooking-android-part-2/ & https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */

//Update fully qualified activity class name here
Java.choose("com.example.app.activity_class_name" , {
  onMatch : function(instance){ //This function will be called for every instance found by frida
    console.log("Found instance: "+instance);
    console.log("Result of method call: " + instance.method_name_to_call()); //Update method name here to call
  },
  onComplete:function(){}
});

```

`frida-android-hook/frida-scripts/dupDex.js`:

```js
/* Description: dupDex
 * Mode: S+A
 * Version: 1.0
 * Credit: 
 * Author: 
 */
'use strict';
//Android O: 
//ARM32/64: _ZN3art7DexFile10OpenCommonEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPKNS_10OatDexFileEbbPS9_PNS0_12VerifyResultE
//Android P:
//ARM32/64: _ZN3art13DexFileLoader10OpenCommonEPKhmS2_mRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPKNS_10OatDexFileEbbPS9_NS3_10unique_ptrINS_16DexFileContainerENS3_14default_deleteISH_EEEEPNS0_12VerifyResultE
//if u want to get own func name,u can use this script to get it!
var moduleFuncName;
var m =  Module.enumerateExportsSync('libart.so');
m.forEach(function(m){
	if(m.name.indexOf("OpenCommon") != -1){

		moduleFuncName = m.name;
		console.log("module function name: "+ m.name);
}else if(m.name.indexOf("OpenMemory") != -1){
		moduleFuncName = m.name;
		console.log("module function name: "+ m.name);

};

});

//var moduleO = "_ZN3art7DexFile10OpenCommonEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPKNS_10OatDexFileEbbPS9_PNS0_12VerifyResultE";
//var moduleP = "_ZN3art13DexFileLoader10OpenCommonEPKhmS2_mRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPKNS_10OatDexFileEbbPS9_NS3_10unique_ptrINS_16DexFileContainerENS3_14default_deleteISH_EEEEPNS0_12VerifyResultE";

if(moduleFuncName != null){
	console.log("=========================================");
	console.log("Hook Start");
	var OpenCommon = Module.findExportByName("libart.so",moduleFuncName);
	if(OpenCommon != undefined){
		Interceptor.attach(OpenCommon,{
		onEnter: function(args){
			console.log("base: "+ args[1]);
			console.log("size: "+ args[2].toInt32());
			console.log(hexdump(
				args[1],{
					offset: 0,
					length: 64,
					header: true,
					ansi: true


				}
				));
			var begin = args[1];
			console.log("magic : " + Memory.readUtf8String(begin))
			var address = parseInt(begin,16) + 0x20;
			var dex_size = Memory.readInt(ptr(address));
			console.log("dex_size :" + dex_size);
			var file = new File("/data/data/com.jjwxc.reader/" + dex_size + ".dex", "wb");
			file.write(Memory.readByteArray(begin, dex_size));
			file.flush();
			file.close();


		},
		onLeave: function(retval){
			console.log("Finished!!!");
			console.log("=========================================");
		}
	});

}else{
	console.log("Null Point!!!");
}


}else{
	console.log("Function not exist!\n");
}

```

`frida-android-hook/frida-scripts/fingerprint-bypass-via-exception-handling.js`:

```js
/* Description: Fingerprint bypass via Exception Handling.
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/FSecureLABS/android-keystore-audit & https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
/*
    Fingerprint bypass via Exception Handling.
    We assume that application use CryptoObject to perform some crypto stuff in the onAuthenticationSucceeded only to confirm that fingerprint authentication (e.g. all data is encrypted using key other than this from fingerprint ).

    How to use:
    1. Attach script to application.
    1. Trigger fingerprint screen (frida should log that authenticate() method was called)
    3. run bypass() function.

*/

console.log("Fingerprint hooks loaded!");

Java.perform(function () {

    //Call in try catch as Biometric prompt is supported since api 28 (Android 9)
    try {hookBiometricPrompt_authenticate();} catch (error){console.log("hookBiometricPrompt_authenticate not supported on this android version")}
    try {hookBiometricPrompt_authenticate2();} catch (error){console.log("hookBiometricPrompt_authenticate not supported on this android version")}
    
    //hookFingerprintManagerCompat_authenticate();
    hookFingerprintManager_authenticate();


    hookDoFinal();
    hookDoFinal2();
    hookDoFinal3();
    hookDoFinal4();
    hookDoFinal5();
    hookDoFinal6();
    hookDoFinal7();
    hookUpdate();
    hookUpdate2();
    hookUpdate3();
    hookUpdate4();
    hookUpdate5();
 
});



var cipherList = [];
var callbackG = null;
var authenticationResultInst = null;
var StringCls = null;
Java.perform(function () {
    StringCls = Java.use('java.lang.String');


});


function hookBiometricPrompt_authenticate()
{
    var biometricPrompt = Java.use('android.hardware.biometrics.BiometricPrompt')['authenticate'].overload('android.os.CancellationSignal', 'java.util.concurrent.Executor', 'android.hardware.biometrics.BiometricPrompt$AuthenticationCallback');
    console.log("Hooking BiometricPrompt.authenticate()...");
    biometricPrompt.implementation = function(cancellationSignal,executor,callback) {
        console.log("[BiometricPrompt.BiometricPrompt()]: cancellationSignal: " + cancellationSignal +", executor: "+ ", callback: "+ callback);

        var sweet_cipher=null;
        var cryptoObj = Java.use('android.hardware.biometrics.BiometricPrompt$CryptoObject');
        var cryptoInst = cryptoObj.$new(sweet_cipher);
        
        var authenticationResultObj = Java.use('android.hardware.biometrics.BiometricPrompt$AuthenticationResult');
        authenticationResultInst = authenticationResultObj.$new(cryptoInst,null,0);
        console.log("cryptoInst:, " + cryptoInst + " class: "+ cryptoInst.$className);

        callback.onAuthenticationSucceeded(authenticationResultInst);  
        //return this.authenticate(cancellationSignal,executor,callback);
    }   

}

function hookBiometricPrompt_authenticate2()
{
    var biometricPrompt = Java.use('android.hardware.biometrics.BiometricPrompt')['authenticate'].overload('android.hardware.biometrics.BiometricPrompt$CryptoObject', 'android.os.CancellationSignal', 'java.util.concurrent.Executor', 'android.hardware.biometrics.BiometricPrompt$AuthenticationCallback');
    console.log("Hooking BiometricPrompt.authenticate2()...");
    biometricPrompt.implementation = function(crypto,cancellationSignal,executor,callback) {
       console.log("[BiometricPrompt.BiometricPrompt2()]: crypto:" + crypto+ ", cancellationSignal: " + cancellationSignal +", executor: "+ ", callback: "+ callback);


        
        var authenticationResultObj = Java.use('android.hardware.biometrics.BiometricPrompt$AuthenticationResult');
        authenticationResultInst = authenticationResultObj.$new(crypto,null,0);
        callbackG = callback; 

        //callback.onAuthenticationSucceeded(authenticationResultInst);

        return this.authenticate(crypto,cancellationSignal,executor,callback);
    }   

}

function hookFingerprintManagerCompat_authenticate()
{
    /*
    void authenticate (FingerprintManagerCompat.CryptoObject crypto, 
                    int flags, 
                    CancellationSignal cancel, 
                    FingerprintManagerCompat.AuthenticationCallback callback, 
                    Handler handler)
    */
    var fingerprintManagerCompat=null;
    var cryptoObj=null;
    var authenticationResultObj=null;
    try{
        fingerprintManagerCompat = Java.use('android.support.v4.hardware.fingerprint.FingerprintManagerCompat');
        cryptoObj = Java.use('android.support.v4.hardware.fingerprint.FingerprintManagerCompat$CryptoObject');
        authenticationResultObj = Java.use('android.support.v4.hardware.fingerprint.FingerprintManagerCompat$AuthenticationResult');
    }catch(error){}
    if(fingerprintManagerCompat == null)
    {
        try{
            fingerprintManagerCompat = Java.use('androidx.core.hardware.fingerprint.FingerprintManagerCompat');
            cryptoObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManagerCompat$CryptoObject');
            authenticationResultObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManagerCompat$AuthenticationResult');
        }catch(error){}
    }
    if(fingerprintManagerCompat == null)
    {
        console.log("FingerprintManagerCompat class not found!");
        return;
    }
    console.log("Hooking FingerprintManagerCompat.authenticate()...");
    var fingerprintManagerCompat_authenticate = fingerprintManagerCompat['authenticate'];
    fingerprintManagerCompat_authenticate.implementation = function(crypto,flags, cancel, callback, handler) {
        console.log("[FingerprintManagerCompat.authenticate()]: crypto: " + crypto + ", flags: "+ flags + ", cancel:" + cancel + ", callback: " + callback + ", handler: "+ handler );
        //console.log(enumMethods(callback.$className));
        // Hook onAuthenticationFailed
        callback['onAuthenticationFailed'].implementation = function() {
            console.log("[onAuthenticationFailed()]:" );


           
        }   
        
        authenticationResultInst = authenticationResultObj.$new(crypto,null,0);
        callbackG = callback; 

        return this.authenticate(crypto,flags, cancel, callback, handler);
    }   
}

function hookFingerprintManager_authenticate()
{
    /*
    public void authenticate (FingerprintManager.CryptoObject crypto, 
                    CancellationSignal cancel, 
                    int flags, 
                    FingerprintManager.AuthenticationCallback callback, 
                    Handler handler)
Error: authenticate(): has more than one overload, use .overload(<signature>) to choose from:
    .overload('android.hardware.fingerprint.FingerprintManager$CryptoObject', 'android.os.CancellationSignal', 'int', 'android.hardware.fingerprint.FingerprintManager$AuthenticationCallback', 'android.os.Handler')
    .overload('android.hardware.fingerprint.FingerprintManager$CryptoObject', 'android.os.CancellationSignal', 'int', 'android.hardware.fingerprint.FingerprintManager$AuthenticationCallback', 'android.os.Handler', 'int')


    */
    var fingerprintManager=null;
    var cryptoObj=null;
    var authenticationResultObj=null;
    try{
        fingerprintManager = Java.use('android.hardware.fingerprint.FingerprintManager');
        cryptoObj = Java.use('android.hardware.fingerprint.FingerprintManager$CryptoObject');
        authenticationResultObj = Java.use('android.hardware.fingerprint.FingerprintManager$AuthenticationResult');
    }catch(error){}
    if(fingerprintManager == null)
    {
        try{
            fingerprintManager = Java.use('androidx.core.hardware.fingerprint.FingerprintManager');
            cryptoObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManager$CryptoObject');
            authenticationResultObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManager$AuthenticationResult');
        }catch(error){}
    }
    if(fingerprintManager == null)
    {
        console.log("FingerprintManager class not found!");
        return;
    }
    console.log("Hooking FingerprintManager.authenticate()...");

    var fingerprintManager_authenticate = fingerprintManager['authenticate'].overload('android.hardware.fingerprint.FingerprintManager$CryptoObject', 'android.os.CancellationSignal', 'int', 'android.hardware.fingerprint.FingerprintManager$AuthenticationCallback', 'android.os.Handler');
    fingerprintManager_authenticate.implementation = function(crypto,cancel, flags, callback, handler) {
        console.log("[FingerprintManager.authenticate()]: crypto: " + crypto + ", flags: "+ flags + ", cancel:" + cancel + ", callback: " + callback + ", handler: "+ handler );
        
        authenticationResultInst = authenticationResultObj.$new(crypto,null,0);
        callbackG = callback;

        return this.authenticate(crypto, cancel,flags, callback, handler);
    }   
}


function enumMethods(targetClass)
{
    var hook = Java.use(targetClass);
    var ownMethods = hook.class.getDeclaredMethods();

    return ownMethods;
}



/*

Handler handler = new Handler(Looper.getMainLooper());
handler.post(new Runnable() {
     public void run() {
          // UI code goes here
     }
});
*/

function bypass()
{
    Java.perform(function () {

        try {
            var Runnable = Java.use('java.lang.Runnable');
            var Runner = Java.registerClass({
                name: 'com.MWR.Runner',
                implements: [Runnable],
                methods: {
                    run: function () 
                        {
                            try
                            { 
                                callbackG.onAuthenticationSucceeded(authenticationResultInst); // we just need to call this single line (other code is needed to call this on UI thread)
                            } 
                            catch (error)
                            {
                                console.log("exception catched!" + error  ); 
                            }
                        }
                }
            });

            var Handler = Java.use('android.os.Handler');
            var Looper = Java.use('android.os.Looper'); 
            var loop = Looper.getMainLooper();
            var handler = Handler.$new(loop);
            handler.post(Runner.$new());

        } catch (e) {
            console.log("registerClass error3 >>>>>>>> " + e);
        }

    });
}

function hookDoFinal()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload() ;
    var tmp = null;
    cipherInit.implementation = function() {
        console.log("[Cipher.doFinal()]: "+ "  cipherObj: "+this);
        
        try{  
            tmp = this.doFinal();
        }
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return null;
            }
        }
        return tmp;
    } 
}

function hookDoFinal2()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload('[B') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr) {
        console.log("[Cipher.doFinal2()]: "+ "  cipherObj: "+this);
        try{  
            tmp = this.doFinal(byteArr);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return byteArr;
            }
        }
        return tmp;
    } 
}

function hookDoFinal3()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload('[B', 'int') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1) {
        console.log("[Cipher.doFinal3()]: "+ "  cipherObj: "+this);
        try{ 
            tmp = this.doFinal(byteArr, a1);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }
        }
        return tmp;
    } 
}

function hookDoFinal4()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer') ;
    var tmp = null;
    cipherInit.implementation = function(a1, a2) {
        console.log("[Cipher.doFinal4()]: "+ "  cipherObj: "+this);
        try{          
            tmp = this.doFinal(a1, a2);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }

        }
        return tmp;
    } 
}

function hookDoFinal5()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload('[B', 'int', 'int') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1, a2) {
        console.log("[Cipher.doFinal5()]: "+ "  cipherObj: "+this);
        try{ 
            tmp = this.doFinal(byteArr, a1, a2);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return byteArr;
            }
        }
        return tmp;
    } 
}

function hookDoFinal6()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload('[B', 'int', 'int', '[B') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1, a2, outputArr) {
        console.log("[Cipher.doFinal6()]: "+ "  cipherObj: "+this);
        try{
            tmp = this.doFinal(byteArr, a1, a2, outputArr);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }
        }
        
        return tmp;
    } 
}

function hookDoFinal7()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['doFinal'].overload('[B', 'int', 'int', '[B', 'int') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1, a2, outputArr, a4) {
        console.log("[Cipher.doFinal7()]: "+ "  cipherObj: "+this);
        try{
            tmp = this.doFinal(byteArr, a1, a2, outputArr, a4);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }
        }

        return tmp;
    } 
}

/*
    .overload('[B')
    .overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer')
    .overload('[B', 'int', 'int')
    .overload('[B', 'int', 'int', '[B')
    .overload('[B', 'int', 'int', '[B', 'int')
*/
function hookUpdate()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['update'].overload('[B') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr) {
        console.log("[Cipher.update()]: "+ "  cipherObj: "+this);
        try{        
            tmp = this.update(byteArr);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return byteArr;
            }            
        }
        return tmp;
    } 
}

function hookUpdate2()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['update'].overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, outputArr) {
        console.log("[Cipher.update2()]: "+ "  cipherObj: "+this);
        try{
            tmp = this.update(byteArr, outputArr);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }              
        }
        return tmp;
    } 
}

function hookUpdate3()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['update'].overload('[B', 'int', 'int') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1, a2) {
        console.log("[Cipher.update3()]: "+ "  cipherObj: "+this);
        try{
            tmp = this.update(byteArr, a1, a2);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return byteArr;
            }              
        }
        return tmp;
    } 
}

function hookUpdate4()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['update'].overload('[B', 'int', 'int', '[B') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1, a2, outputArr) {
        console.log("[Cipher.update4()]: "+ "  cipherObj: "+this);
        try{
            tmp = this.update(byteArr, a1, a2, outputArr );
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }  
        }
        return tmp;
    } 
}

function hookUpdate5()
{
    var cipherInit = Java.use('javax.crypto.Cipher')['update'].overload('[B', 'int', 'int', '[B', 'int') ;
    var tmp = null;
    cipherInit.implementation = function(byteArr, a1, a2, outputArr, a4) {
        console.log("[Cipher.update5()]: "+ "  cipherObj: "+this);
        try{
            tmp = this.update(byteArr, a1, a2, outputArr, a4);
        } 
        catch (error)
        {
            console.log("exception catched! " + error  ); 
            if((error+"").indexOf("javax.crypto.IllegalBlockSizeException")==-1) 
                throw error;
            else
            {
                return 1;
            }  
        }    
        return tmp;
    } 
}
```

`frida-android-hook/frida-scripts/fingerprint-bypass.js`:

```js
/* Description: Fingerprint bypass
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/FSecureLABS/android-keystore-audit & https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
/*
    Bypass fingerprint authentication if the app accept NULL cryptoObject in onAuthenticationSucceeded(...).
    This script should automatically bypass fingerprint when authenticate(...) method will be called.
*/

console.log("Fingerprint hooks loaded!");

Java.perform(function () {
    //Call in try catch as Biometric prompt is supported since api 28 (Android 9)
    try { hookBiometricPrompt_authenticate(); }
    catch (error) { console.log("hookBiometricPrompt_authenticate not supported on this android version") }
    try { hookBiometricPrompt_authenticate2(); }
    catch (error) { console.log("hookBiometricPrompt_authenticate not supported on this android version") }
    try { hookFingerprintManagerCompat_authenticate(); }
    catch (error) { console.log("hookFingerprintManagerCompat_authenticate failed"); }
    try { hookFingerprintManager_authenticate(); }
    catch (error) { console.log("hookFingerprintManager_authenticate failed"); }
});



var cipherList = [];
var StringCls = null;
Java.perform(function () {
    StringCls = Java.use('java.lang.String');


});

function getAuthResult(resultObj, cryptoInst) {
    try {
        var authenticationResultInst = resultObj.$new(cryptoInst, null, 0);
    } catch (error) {
        try {
            var authenticationResultInst = resultObj.$new(cryptoInst, null);
        }
        catch (error) {
            var authenticationResultInst = resultObj.$new(cryptoInst);
        }
    }
    console.log("cryptoInst:, " + cryptoInst + " class: " + cryptoInst.$className);
    return authenticationResultInst;
}

function getBiometricPromptAuthResult() {
    var sweet_cipher = null;
    var cryptoObj = Java.use('android.hardware.biometrics.BiometricPrompt$CryptoObject');
    var cryptoInst = cryptoObj.$new(sweet_cipher);
    var authenticationResultObj = Java.use('android.hardware.biometrics.BiometricPrompt$AuthenticationResult');
    var authenticationResultInst = getAuthResult(authenticationResultObj, cryptoInst);
    return authenticationResultInst
}

function hookBiometricPrompt_authenticate() {
    var biometricPrompt = Java.use('android.hardware.biometrics.BiometricPrompt')['authenticate'].overload('android.os.CancellationSignal', 'java.util.concurrent.Executor', 'android.hardware.biometrics.BiometricPrompt$AuthenticationCallback');
    console.log("Hooking BiometricPrompt.authenticate()...");
    biometricPrompt.implementation = function (cancellationSignal, executor, callback) {
        console.log("[BiometricPrompt.BiometricPrompt()]: cancellationSignal: " + cancellationSignal + ", executor: " + ", callback: " + callback);
        var authenticationResultInst = getBiometricPromptAuthResult();
        callback.onAuthenticationSucceeded(authenticationResultInst);
    }
}

function hookBiometricPrompt_authenticate2() {
    var biometricPrompt = Java.use('android.hardware.biometrics.BiometricPrompt')['authenticate'].overload('android.hardware.biometrics.BiometricPrompt$CryptoObject', 'android.os.CancellationSignal', 'java.util.concurrent.Executor', 'android.hardware.biometrics.BiometricPrompt$AuthenticationCallback');
    console.log("Hooking BiometricPrompt.authenticate2()...");
    biometricPrompt.implementation = function (crypto, cancellationSignal, executor, callback) {
        console.log("[BiometricPrompt.BiometricPrompt2()]: crypto:" + crypto + ", cancellationSignal: " + cancellationSignal + ", executor: " + ", callback: " + callback);
        var authenticationResultInst = getBiometricPromptAuthResult();
        callback.onAuthenticationSucceeded(authenticationResultInst);
    }
}

function hookFingerprintManagerCompat_authenticate() {
    /*
    void authenticate (FingerprintManagerCompat.CryptoObject crypto, 
                    int flags, 
                    CancellationSignal cancel, 
                    FingerprintManagerCompat.AuthenticationCallback callback, 
                    Handler handler)
    */
    var fingerprintManagerCompat = null;
    var cryptoObj = null;
    var authenticationResultObj = null;
    try {
        fingerprintManagerCompat = Java.use('android.support.v4.hardware.fingerprint.FingerprintManagerCompat');
        cryptoObj = Java.use('android.support.v4.hardware.fingerprint.FingerprintManagerCompat$CryptoObject');
        authenticationResultObj = Java.use('android.support.v4.hardware.fingerprint.FingerprintManagerCompat$AuthenticationResult');
    } catch (error) {
        try {
            fingerprintManagerCompat = Java.use('androidx.core.hardware.fingerprint.FingerprintManagerCompat');
            cryptoObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManagerCompat$CryptoObject');
            authenticationResultObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManagerCompat$AuthenticationResult');
        }
        catch (error) {
            console.log("FingerprintManagerCompat class not found!");
            return
        }
    }
    console.log("Hooking FingerprintManagerCompat.authenticate()...");
    var fingerprintManagerCompat_authenticate = fingerprintManagerCompat['authenticate'];
    fingerprintManagerCompat_authenticate.implementation = function (crypto, flags, cancel, callback, handler) {
        console.log("[FingerprintManagerCompat.authenticate()]: crypto: " + crypto + ", flags: " + flags + ", cancel:" + cancel + ", callback: " + callback + ", handler: " + handler);
        //console.log(enumMethods(callback.$className));
        callback['onAuthenticationFailed'].implementation = function () {
            console.log("[onAuthenticationFailed()]:");
            var sweet_cipher = null;
            var cryptoInst = cryptoObj.$new(sweet_cipher);
            var authenticationResultInst = getAuthResult(authenticationResultObj, cryptoInst);
            callback.onAuthenticationSucceeded(authenticationResultInst);
        }
        return this.authenticate(crypto, flags, cancel, callback, handler);
    }
}

function hookFingerprintManager_authenticate() {
    /*
    public void authenticate (FingerprintManager.CryptoObject crypto, 
                    CancellationSignal cancel, 
                    int flags, 
                    FingerprintManager.AuthenticationCallback callback, 
                    Handler handler)
Error: authenticate(): has more than one overload, use .overload(<signature>) to choose from:
    .overload('android.hardware.fingerprint.FingerprintManager$CryptoObject', 'android.os.CancellationSignal', 'int', 'android.hardware.fingerprint.FingerprintManager$AuthenticationCallback', 'android.os.Handler')
    .overload('android.hardware.fingerprint.FingerprintManager$CryptoObject', 'android.os.CancellationSignal', 'int', 'android.hardware.fingerprint.FingerprintManager$AuthenticationCallback', 'android.os.Handler', 'int')


    */
    var fingerprintManager = null;
    var cryptoObj = null;
    var authenticationResultObj = null;
    try {
        fingerprintManager = Java.use('android.hardware.fingerprint.FingerprintManager');
        cryptoObj = Java.use('android.hardware.fingerprint.FingerprintManager$CryptoObject');
        authenticationResultObj = Java.use('android.hardware.fingerprint.FingerprintManager$AuthenticationResult');
    } catch (error) {
        try {
            fingerprintManager = Java.use('androidx.core.hardware.fingerprint.FingerprintManager');
            cryptoObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManager$CryptoObject');
            authenticationResultObj = Java.use('androidx.core.hardware.fingerprint.FingerprintManager$AuthenticationResult');
        }
        catch (error) {
            console.log("FingerprintManager class not found!");
            return
        }
    }
    console.log("Hooking FingerprintManager.authenticate()...");

    var fingerprintManager_authenticate = fingerprintManager['authenticate'].overload('android.hardware.fingerprint.FingerprintManager$CryptoObject', 'android.os.CancellationSignal', 'int', 'android.hardware.fingerprint.FingerprintManager$AuthenticationCallback', 'android.os.Handler');
    fingerprintManager_authenticate.implementation = function (crypto, cancel, flags, callback, handler) {
        console.log("[FingerprintManager.authenticate()]: crypto: " + crypto + ", flags: " + flags + ", cancel:" + cancel + ", callback: " + callback + ", handler: " + handler);
        var sweet_cipher = null;
        var cryptoInst = cryptoObj.$new(sweet_cipher);
        var authenticationResultInst = getAuthResult(authenticationResultObj, cryptoInst);
        callback.onAuthenticationSucceeded(authenticationResultInst);
        return this.authenticate(crypto, cancel, flags, callback, handler);
    }
}


function enumMethods(targetClass) {
    var hook = Java.use(targetClass);
    var ownMethods = hook.class.getDeclaredMethods();

    return ownMethods;
}
```

`frida-android-hook/frida-scripts/frida-traffic-interceptor.js`:

```js
/*
 * Android okhttp3 Traffic Interceptor
 * Author: Vinay Kumar Rasala (Linuxinet)
 * Organization: XYSec Labs (Appknox)
 * Description: Intercepts network traffic using Frida for specified target hosts, logging API calls and WebView URL loads.
 * Supported Libraries: okhttp3
 */

setImmediate(function() {
    console.log("[*] Waiting for Traffic");
    console.warn("[*] Please Check Target Hosts section in the code, if u dont see requests");

    Java.perform(function() {
        var okhttp3 = Java.use('okhttp3.OkHttpClient');
        var webViewClient = Java.use('android.webkit.WebViewClient');

        // ANSI escape code for red color
        var redColor = '\u001b[31m';
        // ANSI escape code for green color
        var greenColor = '\u001b[32m';
        // ANSI escape code to reset color
        var resetColor = '\u001b[0m';

        var targetHosts = [];
        // Replace with your target hosts to set your scope 
        // eg: targetHosts = ["google.com", "frida.re", "github.com"]
        // leave empty (eg: []) to print all requests


        // Intercept API calls
        var originalNewCall = okhttp3.newCall.overload('okhttp3.Request');
        originalNewCall.implementation = function(request) {
            // Get the request's URL and extract the host
            var requestUrl = request.url().toString();
            var urlParts = requestUrl.split("/");
            var extractedHost = urlParts[2]; // Assumes the host is at index 2
            // console.log("request url: ", requestUrl)
            // console.log("request parts: ", urlParts)
            // console.log("extractedHost: ", extractedHost)


            if (targetHosts.includes(extractedHost) || targetHosts.length === 0) {

                var requestEndpoint = requestUrl.replace(/^(https?:\/\/[^\/]+)(\/.*)$/, '$2');
                // Construct and print request headers
                var requestHeaders = request.headers();
                console.log(redColor + "[API Call]" + resetColor);
                console.log("             ");
                console.log(greenColor + request.method() + " " + requestEndpoint);
                // Add the Host header with the extracted host
                requestHeaders = requestHeaders.newBuilder()
                    .add("Host", extractedHost)
                    .build();
                // console.log(greenColor + "Request Headers:");
                var requestHeaderNames = requestHeaders.names();
                var requestHeaderNamesArray = requestHeaderNames.toArray();

                for (var i = 0; i < requestHeaderNamesArray.length; i++) {
                    var headerName = requestHeaderNamesArray[i];
                    var headerValue = requestHeaders.get(headerName);
                    headerValue = decodeURIComponent(headerValue); // Decode header value
                    console.log(greenColor + headerName + ": " + headerValue + resetColor);
                }
                console.log("             ");
                console.log("             ");


                console.log(greenColor + requestBodyToString(request.body()) + resetColor);
                console.log(redColor + "============================" + resetColor);

                var newRequest = request.newBuilder().headers(requestHeaders).build();
                var response = this.newCall(newRequest).execute();

                // Construct and print response headers
                console.log(redColor + "[API Response]" + " - [" + requestEndpoint + "]" + resetColor);
                console.log("             ");
                console.log(greenColor + response.code() + " " + response.message() + resetColor);
                var responseHeaders = response.headers();
                var responseHeaderNames = responseHeaders.names();
                var responseHeaderNamesArray = responseHeaderNames.toArray();
                for (var i = 0; i < responseHeaderNamesArray.length; i++) {
                    var responseHeaderName = responseHeaderNamesArray[i];
                    var responseHeaderValue = responseHeaders.get(responseHeaderName);
                    console.log(greenColor + responseHeaderName + ": " + responseHeaderValue + resetColor);
                }
                console.log("             ");

                // console.log(greenColor  + response.message());
                var responseBody = response.body();
                if (responseBody !== null) {
                    if (response.isSuccessful()) {
                        console.log(greenColor + responseBody.string() + resetColor + resetColor);
                    } else {
                        console.log(redColor + "Error: Response not successful" + resetColor);
                    }
                } else {
                    console.log(greenColor + "Error: Empty response body" + resetColor);
                }
                console.log(redColor + "============================" + resetColor);
                return this.newCall(request);

            } else {
                // Return a new Call instance for Frida to continue instrumenting
                return this.newCall(request);
            }
        };

        // Intercept WebView URL loads
        var shouldOverrideUrlLoading = webViewClient.shouldOverrideUrlLoading.overload('android.webkit.WebView', 'java.lang.String');
        shouldOverrideUrlLoading.implementation = function(view, url) {
            console.log(redColor + "[WebView URL]: " + url + resetColor);
            return shouldOverrideUrlLoading.call(this, view, url);
        };
    });
});

function requestBodyToString(requestBody) {
    if (requestBody === null) {
        return '';
    }

    var buffer = Java.use('okio.Buffer').$new();
    requestBody.writeTo(buffer);
    return buffer.readUtf8();
}
```

`frida-android-hook/frida-scripts/frinja-crypto.js`:

```js
/*
	Author: secretdiary.ninja
	License: (CC BY-SA 4.0) 
 * */

    setTimeout(function() {
        Java.perform(function() {
            console.log("started");
            
            Log = Java.use("android.util.Log")
            Exception = Java.use("java.lang.Exception")
            
            // KeyGenerator
            var keyGenerator = Java.use("javax.crypto.KeyGenerator");
            keyGenerator.generateKey.implementation = function () {
                console.log("[*] Generate symmetric key called. ");
                return this.generateKey();
            };
    
            keyGenerator.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] KeyGenerator.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            keyGenerator.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] KeyGenerator.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            keyGenerator.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] KeyGenerator.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            // KeyPairGenerator
            var keyPairGenerator = Java.use("java.security.KeyPairGenerator");
            keyPairGenerator.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] GetPairGenerator.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            keyPairGenerator.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] GetPairGenerator.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
            
            keyPairGenerator.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] GetPairGenerator.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
            
            // secret key spec
            var secretKeySpec = Java.use("javax.crypto.spec.SecretKeySpec");
            secretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(keyb, cipher){
                var buffer = Java.array('byte', keyb);
                var resultStr = "";
                try{
                    for(var i = 0; i < buffer.length; ++i){
                        resultStr+= (String.fromCharCode(buffer[i]));
                    }
                }catch(e){
                    resultStr = "0x";
                    for(var i = 0; i < buffer.length; ++i){
                        var nn = buffer[i];
                        resultStr+= nn.toString(16);
                    }
                }
                console.log("[*] SecretKeySpec.init called with key: " + resultStr + " using algorithm" + cipher + "\n");
                return secretKeySpec.$init.overload('[B', 'java.lang.String').call(this, keyb, cipher);
            }
            
            // MessageDigest
            var messageDigest = Java.use("java.security.MessageDigest");
            messageDigest.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] MessageDigest.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            messageDigest.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] MessageDigest.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
            
            messageDigest.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] MessageDigest.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
            
            messageDigest.digest.overload().implementation = function () {
                ret =  messageDigest.digest.overload().call(this);
                var buffer = Java.array('byte', ret);
                var resultStr = "0x";
                for(var i = 0; i < 16; ++i){
                     var nn = buffer[i];
                     if (nn < 0)
                     {
                         nn = 0xFFFFFFFF + nn + 1;
                     }
                     nn.toString(16).toUpperCase();
                     resultStr+= nn;
                }
                console.log("[*] MessageDigest.digest called with hash: " + resultStr + " using algorithm: " + this.getAlgorithm() + "\n");
                return ret;
            };
            
            /*
            messageDigest.digest.overload("[B").implementation = function (inp) {
                ret =  messageDigest.digest.overload("[B").call(this, inp);
                var buffer = Java.array('byte', ret);
                var resultStr = "0x";
                for(var i = 0; i < buffer.length; ++i){
                    var nn = buffer[i];
                    resultStr+= nn.toString(16);
                }
                console.log("[*] MessageDigest.digest called with hash: " + resultStr + " using algorithm: " + this.getAlgorithm() + "\n");
            };
            
            messageDigest.digest.overload("[B", "int", "int").implementation = function (inp, offset, len) {
                ret =  messageDigest.digest.overload("[B", "int", "int").call(this, inp, offset, len);
                var buffer = Java.array('byte', inp);
                var resultStr = "0x";
                for(var i = offset; i < ret; ++i){
                    var nn = buffer[i];
                    resultStr+= nn.toString(16);
                }
                console.log("[*] MessageDigest.digest called with hash: " + resultStr + " using algorithm: " + this.getAlgorithm() + "\n");
            };*/
    
            // secret key factory
            var secretKeyFactory = Java.use("javax.crypto.SecretKeyFactory");
            secretKeyFactory.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] SecretKeyFactory.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            secretKeyFactory.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] SecretKeyFactory.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            secretKeyFactory.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] SecretKeyFactory.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            // Signature
            var signature = Java.use("java.security.Signature");
            signature.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] Signature.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            signature.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] Signature.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            signature.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] Signature.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
    
            // Cipher
            var cipher = Java.use("javax.crypto.Cipher");
            cipher.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] Cipher.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            cipher.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] Cipher.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            cipher.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] Cipher.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            cipher.doFinal.overload('[B').implementation = function (b) {
                console.log("Cipher.doFinal called by " + Log.getStackTraceString(Exception.$new()));
                return cipher.doFinal.overload("[B").call(this, b);
            };
            
            
            // MAC
            
            var mac = Java.use("javax.crypto.Mac");
            mac.getInstance.overload('java.lang.String').implementation = function (var0) {
                console.log("[*] Mac.getInstance called with algorithm: " + var0 + "\n");
                return this.getInstance(var0);
            };
    
            mac.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (var0, var1) {
                console.log("[*] Mac.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
    
            mac.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (var0, var1) {
                console.log("[*] Mac.getInstance called with algorithm: " + var0 + " and provider: " + var1 + "\n");
                return this.getInstance(var0, var1);
            };
            
            
            
            /** KeyGenParameterSpec **/
            
            //decrypt = 2
            // encrypt = 1
            // decrypt | encrypt = 3
            // sign = 4
            // verify = 8
            var useKeyGen = Java.use("android.security.keystore.KeyGenParameterSpec$Builder");
            useKeyGen.$init.overload("java.lang.String", "int").implementation = function(keyStoreAlias, purpose){
                purposeStr = "Purpose = " + purpose;
                if (purpose == 2)
                    purposeStr = "decrypt";
                else if (purpose == 1)
                    purposeStr = "encrypt";
                else if (purpose == 3)
                    purposeStr = "decrypt|encrypt";
                else if (purpose == 4)
                    purposeStr = "sign";
                else if (purpose == 8)
                    purposeStr = "verify";
                
                console.log("KeyGenParameterSpec.Builder(" + keyStoreAlias + ", " + purposeStr + ")");
                
                return useKeyGen.$init.overload("java.lang.String", "int").call(this, keyStoreAlias, purpose);
            }
            
            useKeyGen.setBlockModes.implementation = function(modes){
                console.log("KeyGenParameterSpec.Builder.setBlockModes('"+ modes.toString() +"')");
                return useKeyGen.setBlockModes.call(this, modes);
            }
            
            useKeyGen.setDigests.implementation = function(digests){
                console.log("KeyGenParameterSpec.Builder.setDigests('"+ digests.toString() +"')");
                return useKeyGen.setDigests.call(this, digests);
            }
            
            useKeyGen.setKeySize.implementation = function(keySize){
                console.log("KeyGenParameterSpec.Builder.setKeySize("+ keySize +")");
                return useKeyGen.setKeySize.call(this, keySize);
            }
            
            useKeyGen.setEncryptionPaddings.implementation = function(paddings){
                console.log("KeyGenParameterSpec.Builder.setEncryptionPaddings('"+ paddings.toString() +"')");
                return useKeyGen.setEncryptionPaddings.call(this, paddings);
            }
            
            useKeyGen.setSignaturePaddings.implementation = function(paddings){
                console.log("KeyGenParameterSpec.Builder.setSignaturePaddings('"+ paddings.toString() +"')");
                return useKeyGen.setSignaturePaddings.call(this, paddings);
            }
            
            useKeyGen.setAlgorithmParameterSpec.implementation = function(spec){
                console.log("KeyGenParameterSpec.Builder.setAlgorithmParameterSpec('"+ spec.toString() +"')");
                return useKeyGen.setAlgorithmParameterSpec.call(this, spec);
            }
             
            useKeyGen.build.implementation = function(){
                console.log("KeyGenParameterSpec.Builder.build()");
                return useKeyGen.build.call(this);
            }
            
            // IvParameterSpec
            ivSpec = Java.use("javax.crypto.spec.IvParameterSpec");
            ivSpec.$init.overload("[B").implementation = function(ivBytes){
                var buffer = Java.array('byte', ivBytes);
                var resultStr = "";
                try{
                    for(var i = 0; i < buffer.length; ++i){
                        resultStr+= (String.fromCharCode(buffer[i]));
                    }
                }catch(e){
                    resultStr = "0x";
                    for(var i = 0; i < buffer.length; ++i){
                        var nn = buffer[i];
                        resultStr+= nn.toString(16);
                    }
                }
                console.log("IvParameterSpec.init(" + resultStr + ")");
                return ivSpec.$init.overload("[B").call(this, ivBytes);
            }
            
            ivSpec.$init.overload("[B", "int", "int").implementation = function(ivBytes, offset, len){
                var buffer = Java.array('byte', ivBytes);
                var resultStr = "";
                try{
                    for(var i = offset; i < len; ++i){
                        resultStr+= (String.fromCharCode(buffer[i]));
                    }
                }catch(e){
                    resultStr = "0x";
                    for(var i = offset; i < len; ++i){
                        var nn = buffer[i];
                        resultStr+= nn.toString(16);
                    }
                }
                console.log("IvParameterSpec.init(" + resultStr + ")");
                return ivSpec.$init.overload("[B", "int", "int").call(this, ivBytes, offset, len);
            }
    
        });
    }, 0);
```

`frida-android-hook/frida-scripts/hook-method-of-class.js`:

```js
/* Description: Hook method of class
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
Java.perform(function() {
  //enter class name here: example android.security.keystore.KeyGenParameterSpec$Builder
	//class inside a class is defined using CLASS_NAME$SUB_CLASS_NAME
	var class_name = Java.use("android.security.keystore.KeyGenParameterSpec$Builder");
  //replace FUNC_NAME_HERE with method name you want to hook and remove arg1 or add more if the function has arguments
	class_name.FUNC_NAME_HERE.implementation = function (arg1) {
		console.log("[*] CLASS_NAME:FUNC_NAME was called");
		return this.FUNC_NAME_HERE(arg1)
	}
});

```

`frida-android-hook/frida-scripts/intercept-android-apk-crypto-operations.js`:

```js
// fadeevab/intercept-android-apk-crypto-operations

function bin2ascii(array) {
    var result = [];

    for (var i = 0; i < array.length; ++i) {
        result.push(String.fromCharCode( // hex2ascii part
            parseInt(
                ('0' + (array[i] & 0xFF).toString(16)).slice(-2), // binary2hex part
                16
            )
        ));
    }
    return result.join('');
}

function bin2hex(array, length) {
    var result = "";

    length = length || array.length;

    for (var i = 0; i < length; ++i) {
        result += ('0' + (array[i] & 0xFF).toString(16)).slice(-2);
    }
    return result;
}

Java.perform(function() {
    Java.use('javax.crypto.spec.SecretKeySpec').$init.overload('[B', 'java.lang.String').implementation = function(key, spec) {
        console.log("KEY: " + bin2hex(key) + " | " + bin2ascii(key));
        return this.$init(key, spec);
    };

    Java.use('javax.crypto.Cipher')['getInstance'].overload('java.lang.String').implementation = function(spec) {
        console.log("CIPHER: " + spec);
        return this.getInstance(spec);
    };

    Java.use('javax.crypto.Cipher')['doFinal'].overload('[B').implementation = function(data) {
        console.log("Gotcha!");
        console.log(bin2ascii(data));
        return this.doFinal(data);
    };
});
```

`frida-android-hook/frida-scripts/java-crypto-viewer.js`:

```js
//Serhatcck/java-crypto-viewer

Java.perform(function(){
    var base64 = Java.use('java.util.Base64');
    
    var cipher = Java.use("javax.crypto.Cipher");
    
    cipher.init.overload('int', 'java.security.Key').implementation = function(opmode,key){
        send_log("Key",base64.getEncoder().encodeToString(key.getEncoded()));
        send_log("Opmode String",this.getOpmodeString(opmode));
        send_log("Algorithm",this.getAlgorithm());

        this.init.overload('int', 'java.security.Key').call(this,opmode,key);
    }
    
    cipher.init.overload('int', 'java.security.cert.Certificate').implementation = function(opmode,certificate){
        send_log("Certificate",base64.getEncoder().encodeToString(certificate.getEncoded()));
        send_log("Opmode String",this.getOpmodeString(opmode));
        send_log("Algorithm",this.getAlgorithm());

        this.init.overload('int', 'java.security.cert.Certificate').call(this,opmode,certificate)
    }
    
    cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters').implementation = function(opmode,key,algorithmParameter){
        send_log("Key",base64.getEncoder().encodeToString(key.getEncoded()));
        send_log("Opmode String",this.getOpmodeString(opmode));
        send_log("Algorithm",this.getAlgorithm());

        this.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters').call(this,opmode,key,algorithmParameter);
    }


    cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').implementation = function(opmode,key,algorithmParameter){
        send_log("Key",base64.getEncoder().encodeToString(key.getEncoded()));
        send_log("Opmode String",this.getOpmodeString(opmode));
        send_log("Algorithm",this.getAlgorithm());
        this.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').call(this,opmode,key,algorithmParameter);
    }


   


    cipher.doFinal.overload('[B').implementation = function(input){
        var input_base64 = base64.getEncoder().encodeToString(input);
        var input_string = byte_to_string(input);
        var output = this.doFinal.overload('[B').call(this,input);
        var output_base64 = base64.getEncoder().encodeToString(output);
        send_log("Input Base64",input_base64);
        send_log("Input String",input_string);
        send_log("Output Base64",output_base64);
        send_log("----------------","----------------");
        return output;
    }

    cipher.doFinal.overload('[B', 'int').implementation = function(input,input2){
        var input_base64 = base64.getEncoder().encodeToString(input);
        var input_string = byte_to_string(input);
        var output = this.doFinal.overload('[B', 'int').call(this,input,input2);
        var output_base64 = base64.getEncoder().encodeToString(output);
        send_log("Input Base64",input_base64);
        send_log("Input String",input_string);
        send_log("Output Base64",output_base64);
        send_log("----------------","----------------");
        return output;
    }

    cipher.doFinal.overload('[B', 'int', 'int').implementation = function(input,input2,input3){
        var input_base64 = base64.getEncoder().encodeToString(input);
        var input_string = byte_to_string(input);
        var output = this.doFinal.overload('[B', 'int', 'int').call(this,input,input2,input3);
        var output_base64 = base64.getEncoder().encodeToString(output);
        send_log("Input Base64",input_base64);
        send_log("Input String",input_string);
        send_log("Output Base64",output_base64);
        send_log("----------------","----------------");
        return output;
    }

    cipher.doFinal.overload('[B', 'int', 'int', '[B').implementation = function(input,input2,input3,input4){
        var input_base64 = base64.getEncoder().encodeToString(input);
        var input_string = byte_to_string(input);
        var output = this.doFinal.overload('[B', 'int', 'int', '[B').call(this,input,input2,input3,input4);
        var output_base64 = base64.getEncoder().encodeToString(output);
        send_log("Input Base64",input_base64);
        send_log("Input String",input_string);
        send_log("Output Base64",output_base64);
        send_log("----------------","----------------");
        return output;
    }

    cipher.doFinal.overload('[B', 'int', 'int', '[B', 'int').implementation = function(input,input2,input3,input4,input5){
        var input_base64 = base64.getEncoder().encodeToString(input);
        var input_string = byte_to_string(input);
        var output = this.doFinal.overload('[B', 'int', 'int', '[B', 'int').call(this,input,input2,input3,input4,input5);
        var output_base64 = base64.getEncoder().encodeToString(output);
        send_log("Input Base64",input_base64);
        send_log("Input String",input_string);
        send_log("Output Base64",output_base64);
        send_log("----------------","----------------");
        return output;
    }


    
    var ivParameter =  Java.use('javax.crypto.spec.IvParameterSpec');
 

    ivParameter.$init.overload('[B').implementation = function(ivKey){
        send_log("Iv Key",base64.getEncoder().encodeToString(ivKey));
        this.$init.overload('[B').call(this,ivKey);
    }

    
    
})

function send_log(string, value){
    console.log("[+] "+string+" : "+value);
}



function byte_to_string(byte_array){
    var StringClass = Java.use('java.lang.String');
    return StringClass.$new(byte_array).toString();
}
```

`frida-android-hook/frida-scripts/raptor_frida_android_bypass.js`:

```js
/* Description: Raptor frida android bypass
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_*.js - Frida snippets for Android
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS script snippets for Android instrumentation.
 * See https://www.frida.re/ and https://codeshare.frida.re/
 * for further information on this powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Many thanks to Maurizio Agazzini <inode@wayreth.eu.org>
 * and Federico Dotta <federico.dotta@mediaservice.net>.
 *
 * Example usage:
 * # frida -U -f com.xxx.yyy -l raptor_frida_android.js --no-pause
 */

setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {

		// Root detection bypass example

		var hook = Java.use("com.target.utils.RootCheck");
		console.log("info: hooking target class");

		hook.isRooted.overload().implementation = function() {
			console.log("info: entered target method");
			
			// obtain old retval
			var retval = this.isRooted.overload().call(this);
			console.log("old ret value: " + retval);

			// set new retval
			var retnew = false;
			console.log("new ret value: " + retnew);
			return retnew;
		}

	});   

}, 0);

```

`frida-android-hook/frida-scripts/raptor_frida_android_debug.js`:

```js
/* Description: Raptor frida android debug
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_*.js - Frida snippets for Android
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS script snippets for Android instrumentation.
 * See https://www.frida.re/ and https://codeshare.frida.re/
 * for further information on this powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Many thanks to Maurizio Agazzini <inode@wayreth.eu.org>
 * and Federico Dotta <federico.dotta@mediaservice.net>.
 *
 * Example usage:
 * # frida -U -f com.xxx.yyy -l raptor_frida_android.js --no-pause
 */

setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {

		// Debug some methods

		var CryptoUtils = Java.use("com.target.app.CryptoUtils");
		console.log("info: hooking class CryptoUtils");
		var PrefUtils = Java.use("com.target.app.PrefUtils");
		console.log("info: hooking class PrefUtils");

		CryptoUtils.decrypt.overload("java.lang.String").implementation = function(arg0) {
			console.warn("\n*** entered CryptoUtils.decrypt(java.lang.String arg0)");
			var retval = this.decrypt.overload("java.lang.String").call(this, arg0);
			console.log("\narg0: " + arg0);
			console.log("\nretval: " + retval);
			console.warn("\n*** exiting CryptoUtils.decrypt(java.lang.String arg0)");
			return retval;
		}

		CryptoUtils.decrypt.overload("java.lang.String", "java.lang.String").implementation = function(arg0, arg1) {
			console.warn("\n*** entered CryptoUtils.decrypt(java.lang.String arg0, java.lang.String arg1)");
			var retval = this.decrypt.overload("java.lang.String", "java.lang.String").call(this, arg0, arg1);
			console.log("\narg0: " + arg0);
			console.log("arg1: " + arg1);
			console.log("\nretval: " + retval);
			console.warn("\n*** exiting CryptoUtils.decrypt(java.lang.String arg0, java.lang.String arg1)");
			return retval;
		}

		// overload not really necessary here
		CryptoUtils.genIv.overload().implementation = function() {
			console.warn("\n*** entered CryptoUtils.genIv()");
			var retval = this.genIv.overload().call(this);
			console.log("\nretval: " + retval);
			console.warn("\n*** exiting CryptoUtils.genIv()");
			// XXX print IvParameterSpec | javax.crypto.spec.IvParameterSpec
			return retval;
		}

		// overload not really necessary here
		PrefUtils.saveUser.overload("java.util.List").implementation = function(arg0) {
			console.warn("\n*** entered PrefUtils.saveUser(java.util.List arg0)");
			var retval = this.saveUser.overload("java.util.List").call(this, arg0);
			console.log("\narg0: " + arg0);
			console.log("\nretval: " + retval);
			console.warn("\n*** exiting PrefUtils.saveUser(java.util.List arg0)");
			return retval;
		}

	});   

}, 0);

```

`frida-android-hook/frida-scripts/raptor_frida_android_enum.js`:

```js
/* Description: Raptor frida android enum
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_enum.js - Java class/method enumerator
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS functions to enumerate Java classes and methods 
 * declared in an iOS app. See https://www.frida.re/ and 
 * https://codeshare.frida.re/ for further information on this 
 * powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Example usage:
 * # frida -U -f com.target.app -l raptor_frida_android_enum.js --no-pause
 *
 * Get the latest version at:
 * https://github.com/0xdea/frida-scripts/
 */

// enumerate all Java classes
function enumAllClasses()
{
	var allClasses = [];
	var classes = Java.enumerateLoadedClassesSync();

	classes.forEach(function(aClass) {
		try {
			var className = aClass.match(/[L](.*);/)[1].replace(/\//g, ".");
		}
		catch(err) {} // avoid TypeError: cannot read property 1 of null
		allClasses.push(className);
	});

	return allClasses;
}

// find all Java classes that match a pattern
function findClasses(pattern)
{
	var allClasses = enumAllClasses();
	var foundClasses = [];

	allClasses.forEach(function(aClass) {
		try {
			if (aClass.match(pattern)) {
				foundClasses.push(aClass);
			}
		}
		catch(err) {} // avoid TypeError: cannot read property 'match' of undefined
	});

	return foundClasses;
}

// enumerate all methods declared in a Java class
function enumMethods(targetClass)
{
	var hook = Java.use(targetClass);
	var ownMethods = hook.class.getDeclaredMethods();
	hook.$dispose;

	return ownMethods;
}

/*
 * The following functions were not implemented because deemed impractical:
 *
 * enumAllMethods() - enumerate all methods declared in all Java classes
 * findMethods(pattern) - find all Java methods that match a pattern
 *
 * See raptor_frida_ios_enum.js for a couple of ObjC implementation examples.
 */

// usage examples
setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {

		// enumerate all classes
		/*
		var a = enumAllClasses();
		a.forEach(function(s) { 
			console.log(s); 
		});
		*/

		// find classes that match a pattern
		/*
		var a = findClasses(/password/i);
		a.forEach(function(s) { 
			console.log(s); 
		});
		*/

		// enumerate all methods in a class
		/*
		var a = enumMethods("com.target.app.PasswordManager")
		a.forEach(function(s) { 
			console.log(s); 
		});
		*/

	});
}, 0);

```

`frida-android-hook/frida-scripts/raptor_frida_android_findClass1.js`:

```js
/* Description: Raptor frida android findclass 1
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_*.js - Frida snippets for Android
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS script snippets for Android instrumentation.
 * See https://www.frida.re/ and https://codeshare.frida.re/
 * for further information on this powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Many thanks to Maurizio Agazzini <inode@wayreth.eu.org>
 * and Federico Dotta <federico.dotta@mediaservice.net>.
 *
 * Example usage:
 * # frida -U -f com.xxx.yyy -l raptor_frida_android.js --no-pause
 */

// find loaded classes that match a pattern (sync)
function findClass(pattern)
{
	console.warn("\n*** finding all classes that match pattern: " + pattern + "\n");

	var allClasses = Java.enumerateLoadedClassesSync();
	allClasses.forEach(function(aClass) {
		if (aClass.match(pattern))
			console.log(aClass);
	});
}

// usage examples
setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {

		//findClass();		// print all loaded classes
		//findClass("Root");	// print all classes that match a string
		//findClass(/root/i);	// print all classes that match a regex (e.g., case insensitive)

	});   

}, 0);

```

`frida-android-hook/frida-scripts/raptor_frida_android_findClass2.js`:

```js
/* Description: Raptor frida android findclass 2
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_*.js - Frida snippets for Android
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS script snippets for Android instrumentation.
 * See https://www.frida.re/ and https://codeshare.frida.re/
 * for further information on this powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Many thanks to Maurizio Agazzini <inode@wayreth.eu.org>
 * and Federico Dotta <federico.dotta@mediaservice.net>.
 *
 * Example usage:
 * # frida -U -f com.xxx.yyy -l raptor_frida_android.js --no-pause
 */

// find loaded classes that match a pattern (async)
function findClass(pattern)
{
	console.warn("\n*** finding all classes that match pattern: " + pattern + "\n");

	Java.enumerateLoadedClasses({
		onMatch: function(aClass) {
			if (aClass.match(pattern))
				console.log(aClass);
		},
		onComplete: function() {}
	});
}

// usage examples
setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {

		//findClass();		// print all loaded classes
		//findClass("Root");	// print all classes that match a string
		//findClass(/root/i);	// print all classes that match a regex (e.g., case insensitive)

	});   

}, 0);

```

`frida-android-hook/frida-scripts/raptor_frida_android_lowlevel.js`:

```js
/* Description: Raptor frida android low level 
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_*.js - Frida snippets for Android
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS script snippets for Android instrumentation.
 * See https://www.frida.re/ and https://codeshare.frida.re/
 * for further information on this powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Many thanks to Maurizio Agazzini <inode@wayreth.eu.org>
 * and Federico Dotta <federico.dotta@mediaservice.net>.
 *
 * Example usage:
 * # frida -U -f com.xxx.yyy -l raptor_frida_android.js --no-pause
 */

setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {
		
		// Low-level intercept and backtrace example

		Interceptor.attach(Module.findExportByName("/system/lib/libc.so", "open"), {

			onEnter: function(args) {

				// debug only the intended calls
				this.flag = false;
				// var filename = Memory.readCString(ptr(args[0]));
				// if (filename.indexOf("XYZ") === -1 && filename.indexOf("ZYX") === -1) // exclusion list
				// if (filename.indexOf("my.interesting.file") !== -1) // inclusion list
					this.flag = true;

				if (this.flag) {
					console.warn("\n*** entered open");

					var filename = Memory.readCString(ptr(args[0]));
					console.log("\nfile name: " + filename);

					// print backtrace
					console.log("\nBacktrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE)
							.map(DebugSymbol.fromAddress).join("\n"));
				}
			},

			onLeave: function(retval) {

				if (this.flag) {
					// print retval
					console.log("\nretval: " + retval);
					console.warn("\n*** exiting open");
				}
			}

		});   

	});   

}, 0);

```

`frida-android-hook/frida-scripts/raptor_frida_android_trace.js`:

```js
/* Description: Raptor frida android trace
 * Mode: S
 * Version: 1.0
 * Credit: https://github.com/0xdea/frida-scripts/tree/master/android-snippets
 * Author: @0xdea
 */
/*
 * raptor_frida_android_trace.js - Code tracer for Android
 * Copyright (c) 2017 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Frida.re JS script to trace arbitrary Java Methods and
 * Module functions for debugging and reverse engineering.
 * See https://www.frida.re/ and https://codeshare.frida.re/
 * for further information on this powerful tool.
 *
 * "We want to help others achieve interop through reverse
 * engineering" -- @oleavr
 *
 * Many thanks to @inode-, @federicodotta, @leonjza, and
 * @dankluev.
 *
 * Example usage:
 * # frida -U -f com.target.app -l raptor_frida_android_trace.js --no-pause
 *
 * Get the latest version at:
 * https://github.com/0xdea/frida-scripts/
 */

// generic trace
function trace(pattern)
{
	var type = (pattern.toString().indexOf("!") === -1) ? "java" : "module";

	if (type === "module") {

		// trace Module
		var res = new ApiResolver("module");
		var matches = res.enumerateMatchesSync(pattern);
		var targets = uniqBy(matches, JSON.stringify);
		targets.forEach(function(target) {
			traceModule(target.address, target.name);
		});

	} else if (type === "java") {

		// trace Java Class
		var found = false;
		Java.enumerateLoadedClasses({
			onMatch: function(aClass) {
				if (aClass.match(pattern)) {
					found = true;
					var className = aClass.match(/[L](.*);/)[1].replace(/\//g, ".");
					traceClass(className);
				}
			},
			onComplete: function() {}
		});

		// trace Java Method
		if (!found) {
			try {
				traceMethod(pattern);
			}
			catch(err) { // catch non existing classes/methods
				console.error(err);
			}
		}
	}
}

// find and trace all methods declared in a Java Class
function traceClass(targetClass)
{
	var hook = Java.use(targetClass);
	var methods = hook.class.getDeclaredMethods();
	hook.$dispose;

	var parsedMethods = [];
	methods.forEach(function(method) {
		parsedMethods.push(method.toString().replace(targetClass + ".", "TOKEN").match(/\sTOKEN(.*)\(/)[1]);
	});

	var targets = uniqBy(parsedMethods, JSON.stringify);
	targets.forEach(function(targetMethod) {
		traceMethod(targetClass + "." + targetMethod);
	});
}

// trace a specific Java Method
function traceMethod(targetClassMethod)
{
	var delim = targetClassMethod.lastIndexOf(".");
	if (delim === -1) return;

	var targetClass = targetClassMethod.slice(0, delim)
	var targetMethod = targetClassMethod.slice(delim + 1, targetClassMethod.length)

	var hook = Java.use(targetClass);
	var overloadCount = hook[targetMethod].overloads.length;

	console.log("Tracing " + targetClassMethod + " [" + overloadCount + " overload(s)]");

	for (var i = 0; i < overloadCount; i++) {

		hook[targetMethod].overloads[i].implementation = function() {
			console.warn("\n*** entered " + targetClassMethod);

			// print backtrace
			// Java.perform(function() {
			//	var bt = Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Exception").$new());
			//	console.log("\nBacktrace:\n" + bt);
			// });   

			// print args
			if (arguments.length) console.log();
			for (var j = 0; j < arguments.length; j++) {
				console.log("arg[" + j + "]: " + arguments[j]);
			}

			// print retval
			var retval = this[targetMethod].apply(this, arguments); // rare crash (Frida bug?)
			console.log("\nretval: " + retval);
			console.warn("\n*** exiting " + targetClassMethod);
			return retval;
		}
	}
}

// trace Module functions
function traceModule(impl, name)
{
	console.log("Tracing " + name);

	Interceptor.attach(impl, {

		onEnter: function(args) {

			// debug only the intended calls
			this.flag = false;
			// var filename = Memory.readCString(ptr(args[0]));
			// if (filename.indexOf("XYZ") === -1 && filename.indexOf("ZYX") === -1) // exclusion list
			// if (filename.indexOf("my.interesting.file") !== -1) // inclusion list
				this.flag = true;

			if (this.flag) {
				console.warn("\n*** entered " + name);

				// print backtrace
				console.log("\nBacktrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE)
						.map(DebugSymbol.fromAddress).join("\n"));
			}
		},

		onLeave: function(retval) {

			if (this.flag) {
				// print retval
				console.log("\nretval: " + retval);
				console.warn("\n*** exiting " + name);
			}
		}

	});
}

// remove duplicates from array
function uniqBy(array, key)
{
        var seen = {};
        return array.filter(function(item) {
                var k = key(item);
                return seen.hasOwnProperty(k) ? false : (seen[k] = true);
        });
}

// usage examples
setTimeout(function() { // avoid java.lang.ClassNotFoundException

	Java.perform(function() {

		// trace("com.target.utils.CryptoUtils.decrypt");
		// trace("com.target.utils.CryptoUtils");
		// trace("CryptoUtils");
		// trace(/crypto/i);
		// trace("exports:*!open*");

	});   
}, 0);

```

`frida-android-hook/frida-scripts/show-all-classes-methods.js`:

```js
/* Description: Show all class name and method
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
Java.perform(function() {
	Java.enumerateLoadedClasses({
		onMatch: function(className) {
			console.log("[*] Class Name: " + className);
			var db1 = Java.use(className);
			var methodArr = db1.class.getMethods();
			for(var m in methodArr)
			{
				console.log("\t" + methodArr[m]);
			}
		},
		onComplete: function() {}
	});
});

```

`frida-android-hook/frida-scripts/show-all-classes.js`:

```js
/* Description: Show all class name
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
Java.perform(function() {
	Java.enumerateLoadedClasses({
		onMatch: function(className) {
			console.log(className);
		},
		onComplete: function() {}
	});
});

```

`frida-android-hook/frida-scripts/show-module-exported-functions.js`:

```js
/* Description: Show module exported function
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
//Twitter: https://twitter.com/xploresec
//GitHub: https://github.com/interference-security
function show_specific_module_exported_functions(modulesName)
{
	//var modulesName = "libsqlite3.dylib";
	var module_export_list = Module.enumerateExports(modulesName)
	for(var j=0 ; j<module_export_list.length ; j++)
	{
		if(module_export_list[j].type == "function")
			console.log(module_export_list[j].name)
	}
}

//Update module name in below line
show_specific_module_exported_functions("MODULE_NAME_HERE")

```

`frida-android-hook/frida-scripts/show-modules-exports.js`:

```js
/* Description: Show modules exports
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
//Script to show modules and its exports. Works on both Android and iOS
function show_modules_exports()
{
	var module_name_list = Process.enumerateModules();
	for(var i=0 ; i<Process.enumerateModules().length ; i++)
	{
		var module_name = module_name_list[i].name;
		var module_export_list = Module.enumerateExports(module_name);
		console.log("[*] " + module_name);
		for(var j=0 ; j<module_export_list.length ; j++)
		{
			var module_export_name = module_export_list[j].name;
			console.log("\t[-] " + module_export_name);
		}
	}
}
setImmediate(show_modules_exports)

```

`frida-android-hook/frida-scripts/show-specific-class-methods.js`:

```js
/* Description: Show specific class and method
 * Mode: S+A
 * Version: 1.0
 * Credit: https://github.com/interference-security/frida-scripts/tree/master/android
 * Author: @interference-security
 */
Java.perform(function() {
	//enter class name here: example android.security.keystore.KeyGenParameterSpec$Builder
	//class inside a class is defined using CLASS_NAME$SUB_CLASS_NAME
	var class_name = "android.security.keystore.KeyGenParameterSpec$Builder";
	var db1 = Java.use(class_name);
	var methodArr = db1.class.getMethods();
	console.log("[*] Class Name: " + class_name)
	console.log("[*] Method Names:")
	for(var m in methodArr)
	{
		console.log(methodArr[m]);
	}
});

```

`frida-android-hook/methods/bypass_root.js`:

```js
// $ frida -l antiroot.js -U -f com.example.app --no-pause
// CHANGELOG by Pichaya Morimoto (p.morimoto@sth.sh): 
//  - I added extra whitelisted items to deal with the latest versions 
// 						of RootBeer/Cordova iRoot as of August 6, 2019
//  - The original one just fucked up (kill itself) if Magisk is installed lol
// Credit & Originally written by: https://codeshare.frida.re/@dzonerzy/fridantiroot/
// If this isn't working in the future, check console logs, rootbeer src, or libtool-checker.so
Java.perform(function() {

    var RootPackages = ["com.noshufou.android.su", "com.noshufou.android.su.elite", "eu.chainfire.supersu",
        "com.koushikdutta.superuser", "com.thirdparty.superuser", "com.yellowes.su", "com.koushikdutta.rommanager",
        "com.koushikdutta.rommanager.license", "com.dimonvideo.luckypatcher", "com.chelpus.lackypatch",
        "com.ramdroid.appquarantine", "com.ramdroid.appquarantinepro", "com.devadvance.rootcloak", "com.devadvance.rootcloakplus",
        "de.robv.android.xposed.installer", "com.saurik.substrate", "com.zachspong.temprootremovejb", "com.amphoras.hidemyroot",
        "com.amphoras.hidemyrootadfree", "com.formyhm.hiderootPremium", "com.formyhm.hideroot", "me.phh.superuser",
        "eu.chainfire.supersu.pro", "com.kingouser.com", "com.android.vending.billing.InAppBillingService.COIN","com.topjohnwu.magisk"
    ];

    var RootBinaries = ["su", "busybox", "supersu", "Superuser.apk", "KingoUser.apk", "SuperSu.apk","magisk"];

    var RootProperties = {
        "ro.build.selinux": "1",
        "ro.debuggable": "0",
        "service.adb.root": "0",
        "ro.secure": "1"
    };

    var RootPropertiesKeys = [];

    for (var k in RootProperties) RootPropertiesKeys.push(k);

    var PackageManager = Java.use("android.app.ApplicationPackageManager");

    var Runtime = Java.use('java.lang.Runtime');

    var NativeFile = Java.use('java.io.File');

    var String = Java.use('java.lang.String');

    var SystemProperties = Java.use('android.os.SystemProperties');

    var BufferedReader = Java.use('java.io.BufferedReader');

    var ProcessBuilder = Java.use('java.lang.ProcessBuilder');

    var StringBuffer = Java.use('java.lang.StringBuffer');

    var loaded_classes = Java.enumerateLoadedClassesSync();

    send("Loaded " + loaded_classes.length + " classes!");

    var useKeyInfo = false;

    var useProcessManager = false;

    send("loaded: " + loaded_classes.indexOf('java.lang.ProcessManager'));

    if (loaded_classes.indexOf('java.lang.ProcessManager') != -1) {
        try {
            //useProcessManager = true;
            //var ProcessManager = Java.use('java.lang.ProcessManager');
        } catch (err) {
            send("ProcessManager Hook failed: " + err);
        }
    } else {
        send("ProcessManager hook not loaded");
    }

    var KeyInfo = null;

    if (loaded_classes.indexOf('android.security.keystore.KeyInfo') != -1) {
        try {
            //useKeyInfo = true;
            //var KeyInfo = Java.use('android.security.keystore.KeyInfo');
        } catch (err) {
            send("KeyInfo Hook failed: " + err);
        }
    } else {
        send("KeyInfo hook not loaded");
    }

    PackageManager.getPackageInfo.overload('java.lang.String', 'int').implementation = function(pname, flags) {
        var shouldFakePackage = (RootPackages.indexOf(pname) > -1);
        if (shouldFakePackage) {
            send("Bypass root check for package: " + pname);
            pname = "set.package.name.to.a.fake.one.so.we.can.bypass.it";
        }
        return this.getPackageInfo.call(this, pname, flags);
    };

    NativeFile.exists.implementation = function() {
        var name = NativeFile.getName.call(this);
        var shouldFakeReturn = (RootBinaries.indexOf(name) > -1);
        if (shouldFakeReturn) {
            send("Bypass return value for binary: " + name);
            return false;
        } else {
            return this.exists.call(this);
        }
    };

    var exec = Runtime.exec.overload('[Ljava.lang.String;');
    var exec1 = Runtime.exec.overload('java.lang.String');
    var exec2 = Runtime.exec.overload('java.lang.String', '[Ljava.lang.String;');
    var exec3 = Runtime.exec.overload('[Ljava.lang.String;', '[Ljava.lang.String;');
    var exec4 = Runtime.exec.overload('[Ljava.lang.String;', '[Ljava.lang.String;', 'java.io.File');
    var exec5 = Runtime.exec.overload('java.lang.String', '[Ljava.lang.String;', 'java.io.File');

    exec5.implementation = function(cmd, env, dir) {
        if (cmd.indexOf("getprop") != -1 || cmd == "mount" || cmd.indexOf("build.prop") != -1 || cmd == "id" || cmd == "sh") {
            var fakeCmd = "grep";
            send("Bypass " + cmd + " command");
            return exec1.call(this, fakeCmd);
        }
        if (cmd == "su") {
            var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
            send("Bypass " + cmd + " command");
            return exec1.call(this, fakeCmd);
        }
        if (cmd == "which") {
            var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
            send("Bypass which command");
            return exec1.call(this, fakeCmd);
        }
        return exec5.call(this, cmd, env, dir);
    };

    exec4.implementation = function(cmdarr, env, file) {
        for (var i = 0; i < cmdarr.length; i = i + 1) {
            var tmp_cmd = cmdarr[i];
            if (tmp_cmd.indexOf("getprop") != -1 || tmp_cmd == "mount" || tmp_cmd.indexOf("build.prop") != -1 || tmp_cmd == "id" || tmp_cmd == "sh") {
                var fakeCmd = "grep";
                send("Bypass " + cmdarr + " command");
                return exec1.call(this, fakeCmd);
            }

            if (tmp_cmd == "su") {
                var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
                send("Bypass " + cmdarr + " command");
                return exec1.call(this, fakeCmd);
            }
        }
        return exec4.call(this, cmdarr, env, file);
    };

    exec3.implementation = function(cmdarr, envp) {
        for (var i = 0; i < cmdarr.length; i = i + 1) {
            var tmp_cmd = cmdarr[i];
            if (tmp_cmd.indexOf("getprop") != -1 || tmp_cmd == "mount" || tmp_cmd.indexOf("build.prop") != -1 || tmp_cmd == "id" || tmp_cmd == "sh") {
                var fakeCmd = "grep";
                send("Bypass " + cmdarr + " command");
                return exec1.call(this, fakeCmd);
            }

            if (tmp_cmd == "su") {
                var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
                send("Bypass " + cmdarr + " command");
                return exec1.call(this, fakeCmd);
            }
        }
        return exec3.call(this, cmdarr, envp);
    };

    exec2.implementation = function(cmd, env) {
        if (cmd.indexOf("getprop") != -1 || cmd == "mount" || cmd.indexOf("build.prop") != -1 || cmd == "id" || cmd == "sh") {
            var fakeCmd = "grep";
            send("Bypass " + cmd + " command");
            return exec1.call(this, fakeCmd);
        }
        if (cmd == "su") {
            var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
            send("Bypass " + cmd + " command");
            return exec1.call(this, fakeCmd);
        }
        return exec2.call(this, cmd, env);
    };

    exec.implementation = function(cmd) {
        for (var i = 0; i < cmd.length; i = i + 1) {
            var tmp_cmd = cmd[i];
            if (tmp_cmd.indexOf("getprop") != -1 || tmp_cmd == "mount" || tmp_cmd.indexOf("build.prop") != -1 || tmp_cmd == "id" || tmp_cmd == "sh") {
                var fakeCmd = "grep";
                send("Bypass " + cmd + " command");
                return exec1.call(this, fakeCmd);
            }

            if (tmp_cmd == "su") {
                var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
                send("Bypass " + cmd + " command");
                return exec1.call(this, fakeCmd);
            }
        }

        return exec.call(this, cmd);
    };

    exec1.implementation = function(cmd) {
        if (cmd.indexOf("getprop") != -1 || cmd == "mount" || cmd.indexOf("build.prop") != -1 || cmd == "id" || cmd == "sh") {
            var fakeCmd = "grep";
            send("Bypass " + cmd + " command");
            return exec1.call(this, fakeCmd);
        }
        if (cmd == "su") {
            var fakeCmd = "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled";
            send("Bypass " + cmd + " command");
            return exec1.call(this, fakeCmd);
        }
        return exec1.call(this, cmd);
    };

    String.contains.implementation = function(name) {
        if (name == "test-keys") {
            send("Bypass test-keys check");
            return false;
        }
        return this.contains.call(this, name);
    };

    var get = SystemProperties.get.overload('java.lang.String');

    get.implementation = function(name) {
        if (RootPropertiesKeys.indexOf(name) != -1) {
            send("Bypass " + name);
            return RootProperties[name];
        }
        return this.get.call(this, name);
    };

    Interceptor.attach(Module.findExportByName("libc.so", "fopen"), {
        onEnter: function(args) {
            var path1 = Memory.readCString(args[0]);
            var path = path1.split("/");
            var executable = path[path.length - 1];
            var shouldFakeReturn = (RootBinaries.indexOf(executable) > -1)
            if (shouldFakeReturn) {
                Memory.writeUtf8String(args[0], "/ggezxxx");
                send("Bypass native fopen >> "+path1);
            }
        },
        onLeave: function(retval) {

        }
    });

    Interceptor.attach(Module.findExportByName("libc.so", "fopen"), {
        onEnter: function(args) {
            var path1 = Memory.readCString(args[0]);
            var path = path1.split("/");
            var executable = path[path.length - 1];
            var shouldFakeReturn = (RootBinaries.indexOf(executable) > -1)
            if (shouldFakeReturn) {
                Memory.writeUtf8String(args[0], "/ggezxxx");
                send("Bypass native fopen >> "+path1);
            }
        },
        onLeave: function(retval) {

        }
    });

    Interceptor.attach(Module.findExportByName("libc.so", "system"), {
        onEnter: function(args) {
            var cmd = Memory.readCString(args[0]);
            send("SYSTEM CMD: " + cmd);
            if (cmd.indexOf("getprop") != -1 || cmd == "mount" || cmd.indexOf("build.prop") != -1 || cmd == "id") {
                send("Bypass native system: " + cmd);
                Memory.writeUtf8String(args[0], "grep");
            }
            if (cmd == "su") {
                send("Bypass native system: " + cmd);
                Memory.writeUtf8String(args[0], "justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled");
            }
        },
        onLeave: function(retval) {

        }
    });

    /*

    TO IMPLEMENT:

    Exec Family

    int execl(const char *path, const char *arg0, ..., const char *argn, (char *)0);
    int execle(const char *path, const char *arg0, ..., const char *argn, (char *)0, char *const envp[]);
    int execlp(const char *file, const char *arg0, ..., const char *argn, (char *)0);
    int execlpe(const char *file, const char *arg0, ..., const char *argn, (char *)0, char *const envp[]);
    int execv(const char *path, char *const argv[]);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execvp(const char *file, char *const argv[]);
    int execvpe(const char *file, char *const argv[], char *const envp[]);

    */


    BufferedReader.readLine.overload().implementation = function() {
        var text = this.readLine.call(this);
        if (text === null) {
            // just pass , i know it's ugly as hell but test != null won't work :(
        } else {
            var shouldFakeRead = (text.indexOf("ro.build.tags=test-keys") > -1);
            if (shouldFakeRead) {
                send("Bypass build.prop file read");
                text = text.replace("ro.build.tags=test-keys", "ro.build.tags=release-keys");
            }
        }
        return text;
    };

    var executeCommand = ProcessBuilder.command.overload('java.util.List');

    ProcessBuilder.start.implementation = function() {
        var cmd = this.command.call(this);
        var shouldModifyCommand = false;
        for (var i = 0; i < cmd.size(); i = i + 1) {
            var tmp_cmd = cmd.get(i).toString();
            if (tmp_cmd.indexOf("getprop") != -1 || tmp_cmd.indexOf("mount") != -1 || tmp_cmd.indexOf("build.prop") != -1 || tmp_cmd.indexOf("id") != -1) {
                shouldModifyCommand = true;
            }
        }
        if (shouldModifyCommand) {
            send("Bypass ProcessBuilder " + cmd);
            this.command.call(this, ["grep"]);
            return this.start.call(this);
        }
        if (cmd.indexOf("su") != -1) {
            send("Bypass ProcessBuilder " + cmd);
            this.command.call(this, ["justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled"]);
            return this.start.call(this);
        }

        return this.start.call(this);
    };

    if (useProcessManager) {
        var ProcManExec = ProcessManager.exec.overload('[Ljava.lang.String;', '[Ljava.lang.String;', 'java.io.File', 'boolean');
        var ProcManExecVariant = ProcessManager.exec.overload('[Ljava.lang.String;', '[Ljava.lang.String;', 'java.lang.String', 'java.io.FileDescriptor', 'java.io.FileDescriptor', 'java.io.FileDescriptor', 'boolean');

        ProcManExec.implementation = function(cmd, env, workdir, redirectstderr) {
            var fake_cmd = cmd;
            for (var i = 0; i < cmd.length; i = i + 1) {
                var tmp_cmd = cmd[i];
                if (tmp_cmd.indexOf("getprop") != -1 || tmp_cmd == "mount" || tmp_cmd.indexOf("build.prop") != -1 || tmp_cmd == "id") {
                    var fake_cmd = ["grep"];
                    send("Bypass " + cmdarr + " command");
                }

                if (tmp_cmd == "su") {
                    var fake_cmd = ["justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled"];
                    send("Bypass " + cmdarr + " command");
                }
            }
            return ProcManExec.call(this, fake_cmd, env, workdir, redirectstderr);
        };

        ProcManExecVariant.implementation = function(cmd, env, directory, stdin, stdout, stderr, redirect) {
            var fake_cmd = cmd;
            for (var i = 0; i < cmd.length; i = i + 1) {
                var tmp_cmd = cmd[i];
                if (tmp_cmd.indexOf("getprop") != -1 || tmp_cmd == "mount" || tmp_cmd.indexOf("build.prop") != -1 || tmp_cmd == "id") {
                    var fake_cmd = ["grep"];
                    send("Bypass " + cmdarr + " command");
                }

                if (tmp_cmd == "su") {
                    var fake_cmd = ["justafakecommandthatcannotexistsusingthisshouldthowanexceptionwheneversuiscalled"];
                    send("Bypass " + cmdarr + " command");
                }
            }
            return ProcManExecVariant.call(this, fake_cmd, env, directory, stdin, stdout, stderr, redirect);
        };
    }

    if (useKeyInfo) {
        KeyInfo.isInsideSecureHardware.implementation = function() {
            send("Bypass isInsideSecureHardware");
            return true;
        }
    }

});
```

`frida-android-hook/methods/bypass_ssl.js`:

```js
/* 
   Android SSL Re-pinning frida script v0.2 030417-pier 

   $ adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt
   $ frida -U -f it.app.mobile -l frida-android-repinning.js --no-pause

   https://techblog.mediaservice.net/2017/07/universal-android-ssl-pinning-bypass-with-frida/
   
   UPDATE 20191605: Fixed undeclared var. Thanks to @oleavr and @ehsanpc9999 !
*/

setTimeout(function(){
    Java.perform(function (){
        try {
            console.log("");
            console.log("[.] Cert Pinning Bypass/Re-Pinning");

            var CertificateFactory = Java.use("java.security.cert.CertificateFactory");
            var FileInputStream = Java.use("java.io.FileInputStream");
            var BufferedInputStream = Java.use("java.io.BufferedInputStream");
            var X509Certificate = Java.use("java.security.cert.X509Certificate");
            var KeyStore = Java.use("java.security.KeyStore");
            var TrustManagerFactory = Java.use("javax.net.ssl.TrustManagerFactory");
            var SSLContext = Java.use("javax.net.ssl.SSLContext");

            // Load CAs from an InputStream
            console.log("[+] Loading our CA...")
            var cf = CertificateFactory.getInstance("X.509");
            
            try {
                var fileInputStream = FileInputStream.$new("/data/local/tmp/cert-der.crt");
            }
            catch(err) {
                console.log("[o] " + err);
            }
            
            var bufferedInputStream = BufferedInputStream.$new(fileInputStream);
            var ca = cf.generateCertificate(bufferedInputStream);
            bufferedInputStream.close();

            var certInfo = Java.cast(ca, X509Certificate);
            console.log("[o] Our CA Info: " + certInfo.getSubjectDN());

            // Create a KeyStore containing our trusted CAs
            console.log("[+] Creating a KeyStore for our CA...");
            var keyStoreType = KeyStore.getDefaultType();
            var keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry("ca", ca);
            
            // Create a TrustManager that trusts the CAs in our KeyStore
            console.log("[+] Creating a TrustManager that trusts the CA in our KeyStore...");
            var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);
            console.log("[+] Our TrustManager is ready...");

            console.log("[+] Hijacking SSLContext methods now...")
            console.log("[-] Waiting for the app to invoke SSLContext.init()...")

            SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").implementation = function(a,b,c) {
                console.log("[o] App invoked javax.net.ssl.SSLContext.init...");
                SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").call(this, a, tmf.getTrustManagers(), c);
                console.log("[+] SSLContext initialized with our custom TrustManager!");
            }
        }
        catch (e) {
            console.log(e);
        }
//Universal Android SSL Pinning Bypass 2
        try {
            var array_list = Java.use("java.util.ArrayList");
            var ApiClient = Java.use('com.android.org.conscrypt.TrustManagerImpl');

            ApiClient.checkTrustedRecursive.implementation = function(a1, a2, a3, a4, a5, a6) {
                console.log('Bypassing SSL Pinning');
                var k = array_list.$new();
                return k;
            }
        }
        catch (e) {
            console.log(e);
        }
// Android Certificate Pinning Bypass
        try {
            // Invalidate the certificate pinner set up
            var OkHttpClient = Java.use("com.squareup.okhttp.OkHttpClient");
            OkHttpClient.setCertificatePinner.implementation = function(certificatePinner){
                // do nothing
                console.log("Called!");
                return this;
            };

            // Invalidate the certificate pinnet checks (if "setCertificatePinner" was called before the previous invalidation)
            var CertificatePinner = Java.use("com.squareup.okhttp.CertificatePinner");
            CertificatePinner.check.overload('java.lang.String', '[Ljava.security.cert.Certificate;').implementation = function(p0, p1){
                // do nothing
                console.log("Called! [Certificate]");
                return;
            };
            CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(p0, p1){
                // do nothing
                console.log("Called! [List]");
                return;
            };
        }
        catch (e) {
            console.log(e);
        }
//okhttp3-certificate-pinner-bypass
        try {
            var TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl');
            var ArrayList = Java.use("java.util.ArrayList");
            TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain,
                host, clientAuth, ocspData, tlsSctData) {
                console.log("[+] Bypassing TrustManagerImpl->verifyChain()");
                return untrustedChain;
            }
            TrustManagerImpl.checkTrustedRecursive.implementation = function(certs, host, clientAuth, untrustedChain,
                trustAnchorChain, used) {
                console.log("[+] Bypassing TrustManagerImpl->checkTrustedRecursive()");
                return ArrayList.$new();
            };
            var CertificatePinner = Java.use('okhttp3.CertificatePinner');
            console.log("[+] Bypassing CertificatePinner->check()");
            CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCertificates) {
                return;
            }
        }
        catch (e) {
            console.log(e);
        }
//okhttp3-pinning-bypass
        try {
            var okhttp3_CertificatePinner_class = null;
            try {
                okhttp3_CertificatePinner_class = Java.use('okhttp3.CertificatePinner');    
            } catch (err) {
                console.log('[-] OkHTTPv3 CertificatePinner class not found. Skipping.');
                okhttp3_CertificatePinner_class = null;
            }

            if(okhttp3_CertificatePinner_class != null) {

                try{
                    okhttp3_CertificatePinner_class.check.overload('java.lang.String', 'java.util.List').implementation = function (str,list) {
                        console.log('[+] Bypassing OkHTTPv3 1: ' + str);
                        return true;
                    };
                    console.log('[+] Loaded OkHTTPv3 hook 1');
                } catch(err) {
                    console.log('[-] Skipping OkHTTPv3 hook 1');
                }

                try{
                    okhttp3_CertificatePinner_class.check.overload('java.lang.String', 'java.security.cert.Certificate').implementation = function (str,cert) {
                        console.log('[+] Bypassing OkHTTPv3 2: ' + str);
                        return true;
                    };
                    console.log('[+] Loaded OkHTTPv3 hook 2');
                } catch(err) {
                    console.log('[-] Skipping OkHTTPv3 hook 2');
                }

                try {
                    okhttp3_CertificatePinner_class.check.overload('java.lang.String', '[Ljava.security.cert.Certificate;').implementation = function (str,cert_array) {
                        console.log('[+] Bypassing OkHTTPv3 3: ' + str);
                        return true;
                    };
                    console.log('[+] Loaded OkHTTPv3 hook 3');
                } catch(err) {
                    console.log('[-] Skipping OkHTTPv3 hook 3');
                }

                try {
                    okhttp3_CertificatePinner_class['check$okhttp'].implementation = function (str,obj) {
                        console.log('[+] Bypassing OkHTTPv3 4 (4.2+): ' + str);
                    };
                    console.log('[+] Loaded OkHTTPv3 hook 4 (4.2+)');
                } catch(err) {
                    console.log('[-] Skipping OkHTTPv3 hook 4 (4.2+)');
                }

            }
        }
        catch (e) {
            console.log(e);
        }

    });
},0);
```

`frida-android-hook/methods/intercept_crypto.js`:

```js
/**@@@+++@@@@******************************************************************
 **
 ** Android Crypto Interceptor frida script v1.4 hyugogirubato
 **
 ** frida -D "DEVICE" -l "crypto.js" -f "PACKAGE"
 **
 ** Update: Removed detection of UUID form in hex format.
 **
 ***@@@---@@@@******************************************************************
 */


// Custom params
const MODE = {
    KeyGenerator: false,
    KeyPairGenerator: false,
    SecretKeySpec: false,
    MessageDigest: false,
    SecretKeyFactory: false,
    Signature: false,
    Cipher: false,
    Mac: false,
    KeyGenParameterSpec: true,
    IvParameterSpec: false
};


let index = 0; // color index
const STRING = Java.use("java.lang.String");
const BASE64 = Java.use("java.util.Base64");
const COLORS = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    reset: '\x1b[0m'
};

const randomColor = () => {
    const colorKeys = Object.keys(COLORS).filter(key => key !== "reset" && key !== "red");
    index = (index + 1) % colorKeys.length;
    return COLORS[colorKeys[index]];
}

const bytesToString = (bytes) => {
    return bytes === null ? null : STRING.$new(bytes).toString();
}

const bytesToBase64 = (bytes) => {
    if (bytes !== null) {
        try {
            return BASE64.getEncoder().encodeToString(bytes);
        } catch {
            return BASE64.getEncoder().encodeToString([bytes & 0xff]);
        }
    }
    return null;
}

const Base64ToHex = (base64) => {
    const bytes = BASE64.getDecoder().decode(base64);
    let hexData = "";
    for (let i = 0; i < bytes.length; i++) {
        let value = bytes[i].toString(16);
        if (value.length % 2 === 1) {
            value = "0" + value
        }
        hexData += value
    }
    return hexData;
}

const showVariable = (module, items, colorKey, hexValue = false) => {
    console.log(`${colorKey}[+] onEnter: ${module}${COLORS.reset}`);
    for (let i = 0; i < items.length; i++) {
        console.log(`${colorKey}  --> [${i}] ${items[i].key}: ${items[i].value}${COLORS.reset}`);

        // Hex
        if (items[i].key.includes("Base64") && items[i].value !== null) {
            const key = items[i].key.replace("Base64", "HEX");
            const value = Base64ToHex(items[i].value);
            if ((!value.includes("-") && [32, 40, 48, 64].includes(value.length)) || hexValue) {
                console.log(`${colorKey}  --> [${i}] ${key}: ${value}${COLORS.reset}`);
            }
        }
    }
    console.log(`${colorKey}[-] onLeave: ${module}${COLORS.reset}`);
}


setTimeout(function () {
    console.log("---");
    console.log("Capturing Android app...");

    if (Java.available) {
        console.log("[*] Java available");
        Java.perform(function () {

            if (MODE.KeyGenerator) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.KeyGenerator");
                const keyGenerator = Java.use("javax.crypto.KeyGenerator");

                keyGenerator.generateKey.implementation = function () {
                    showVariable("keyGenerator.generateKey", [], colorKey);
                    return this.generateKey();
                };

                keyGenerator.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("keyGenerator.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                keyGenerator.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("keyGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                keyGenerator.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("keyGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

            }

            if (MODE.KeyPairGenerator) {
                const colorKey = randomColor();
                console.log("[*] Module attached: java.security.KeyPairGenerator");
                const keyPairGenerator = Java.use("java.security.KeyPairGenerator");
                keyPairGenerator.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("keyPairGenerator.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                keyPairGenerator.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("keyPairGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                keyPairGenerator.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("keyPairGenerator.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.SecretKeySpec) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.spec.SecretKeySpec");
                const secretKeySpec = Java.use("javax.crypto.spec.SecretKeySpec");
                secretKeySpec.$init.overload("[B", "java.lang.String").implementation = function (key, cipher) {
                    const keyBase64 = bytesToBase64(key);
                    const keyString = bytesToString(key);
                    showVariable("secretKeySpec.init", [
                        {key: "Key Base64", value: keyBase64},
                        {key: "Key String", value: keyString},
                        {key: "Algorithm", value: cipher}
                    ], colorKey);
                    return secretKeySpec.$init.overload("[B", "java.lang.String").call(this, key, cipher);
                }
            }

            if (MODE.MessageDigest) {
                const colorKey = randomColor();
                console.log("[*] Module attached: java.security.MessageDigest");
                const messageDigest = Java.use("java.security.MessageDigest");
                messageDigest.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("messageDigest.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                messageDigest.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("messageDigest.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                messageDigest.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("messageDigest.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                messageDigest.update.overload("[B").implementation = function (input) {
                    const inputBase64 = bytesToBase64(input);
                    const inputString = bytesToString(input);
                    showVariable("messageDigest.update", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString}
                    ], colorKey);
                    return this.update.overload("[B").call(this, input);
                };

                messageDigest.digest.overload().implementation = function () {
                    const output = messageDigest.digest.overload().call(this);
                    const outputBase64 = bytesToBase64(output);
                    const outputString = bytesToString(output);
                    showVariable("messageDigest.digest", [
                        {key: "Output Base64", value: outputBase64},
                        {key: "Output String", value: outputString},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    return output;
                };

                /*
                messageDigest.digest.overload("[B").implementation = function (input) {
                    const inputBase64 = bytesToBase64(input);
                    const inputString = bytesToString(input);
                    showVariable("messageDigest.digest", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    return this.digest.overload("[B").call(this, input);
                };

                messageDigest.digest.overload("[B", "int", "int").implementation = function (input, offset, len) {
                    const inputBase64 = bytesToBase64(input);
                    const inputString = bytesToString(input);
                    showVariable("messageDigest.digest", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Algorithm", value: this.getAlgorithm()},
                        {key: "Offset", value: offset},
                        {key: "Length", value: len}
                    ], colorKey);
                    return this.digest.overload("[B", "int", "int").call(this, input, offset, len);
                };
                 */

            }

            if (MODE.SecretKeyFactory) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.SecretKeyFactory");
                const secretKeyFactory = Java.use("javax.crypto.SecretKeyFactory");
                secretKeyFactory.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("secretKeyFactory.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                secretKeyFactory.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("secretKeyFactory.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                secretKeyFactory.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("secretKeyFactory.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.Signature) {
                const colorKey = randomColor();
                console.log("[*] Module attached: java.security.Signature");
                const signature = Java.use("java.security.Signature");
                signature.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("signature.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                signature.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("signature.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                signature.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("signature.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.Cipher) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.Cipher");
                const cipher = Java.use("javax.crypto.Cipher");
                cipher.init.overload("int", "java.security.Key").implementation = function (opmode, key) {
                    showVariable("cipher.init", [
                        {key: "Key", value: bytesToBase64(key.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.Key").call(this, opmode, key);
                }

                cipher.init.overload("int", "java.security.cert.Certificate").implementation = function (opmode, certificate) {
                    showVariable("cipher.init", [
                        {key: "Certificate", value: bytesToBase64(certificate.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.cert.Certificate").call(this, opmode, certificate);
                }

                cipher.init.overload("int", "java.security.Key", "java.security.AlgorithmParameters").implementation = function (opmode, key, algorithmParameter) {
                    showVariable("cipher.init", [
                        {key: "Key", value: bytesToBase64(key.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.Key", "java.security.AlgorithmParameters").call(this, opmode, key, algorithmParameter);
                }

                cipher.init.overload("int", "java.security.Key", "java.security.spec.AlgorithmParameterSpec").implementation = function (opmode, key, algorithmParameter) {
                    showVariable("cipher.init", [
                        {key: "Key", value: bytesToBase64(key.getEncoded())},
                        {key: "Opmode", value: this.getOpmodeString(opmode)},
                        {key: "Algorithm", value: this.getAlgorithm()}
                    ], colorKey);
                    this.init.overload("int", "java.security.Key", "java.security.spec.AlgorithmParameterSpec").call(this, opmode, key, algorithmParameter);
                }

                cipher.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("cipher.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                cipher.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("cipher.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                cipher.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("cipher.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                cipher.doFinal.overload("[B").implementation = function (arg0) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B").call(this, arg0);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                };


                cipher.doFinal.overload("[B", "int").implementation = function (arg0, arg1) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int").call(this, arg0, arg1);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }

                cipher.doFinal.overload("[B", "int", "int").implementation = function (arg0, arg1, arg2) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int", "int").call(this, arg0, arg1, arg2);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }

                cipher.doFinal.overload("[B", "int", "int", "[B").implementation = function (arg0, arg1, arg2, arg3) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int", "int", "[B").call(this, arg0, arg1, arg2, arg3);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }

                cipher.doFinal.overload("[B", "int", "int", "[B", "int").implementation = function (arg0, arg1, arg2, arg3, arg4) {
                    const inputBase64 = bytesToBase64(arg0);
                    const inputString = bytesToString(arg0);
                    const output = this.doFinal.overload("[B", "int", "int", "[B", "int").call(this, arg0, arg1, arg2, arg3, arg4);
                    const outputBase64 = bytesToBase64(output);
                    showVariable("cipher.doFinal", [
                        {key: "Input Base64", value: inputBase64},
                        {key: "Input String", value: inputString},
                        {key: "Output Base64", value: outputBase64}
                    ], colorKey);
                    return output;
                }
            }

            if (MODE.Mac) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.Mac");
                const mac = Java.use("javax.crypto.Mac");
                mac.getInstance.overload("java.lang.String").implementation = function (arg0) {
                    showVariable("mac.getInstance", [
                        {key: "Algorithm", value: arg0}
                    ], colorKey);
                    return this.getInstance(arg0);
                };

                mac.getInstance.overload("java.lang.String", "java.lang.String").implementation = function (arg0, arg1) {
                    showVariable("mac.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };

                mac.getInstance.overload("java.lang.String", "java.security.Provider").implementation = function (arg0, arg1) {
                    showVariable("mac.getInstance", [
                        {key: "Algorithm", value: arg0},
                        {key: "Provider", value: arg1}
                    ], colorKey);
                    return this.getInstance(arg0, arg1);
                };
            }

            if (MODE.KeyGenParameterSpec) {
                const colorKey = randomColor();
                console.log("[*] Module attached: android.security.keystore.KeyGenParameterSpec$Builder");
                const useKeyGen = Java.use("android.security.keystore.KeyGenParameterSpec$Builder");
                useKeyGen.$init.overload("java.lang.String", "int").implementation = function (keyStoreAlias, purpose) {
                    let purposeStr = "";
                    if (purpose === 1) {
                        purposeStr = "encrypt";
                    } else if (purpose === 2) {
                        purposeStr = "decrypt";
                    } else if (purpose === 3) {
                        purposeStr = "decrypt|encrypt";
                    } else if (purpose === 4) {
                        purposeStr = "sign";
                    } else if (purpose === 8) {
                        purposeStr = "verify";
                    } else {
                        purposeStr = purpose;
                    }

                    showVariable("KeyGenParameterSpec.init", [
                        {key: "KeyStoreAlias", value: keyStoreAlias},
                        {key: "Purpose", value: purposeStr}
                    ], colorKey);
                    return useKeyGen.$init.overload("java.lang.String", "int").call(this, keyStoreAlias, purpose);
                }

                useKeyGen.setBlockModes.implementation = function (modes) {
                    showVariable("KeyGenParameterSpec.setBlockModes", [
                        {key: "BlockMode", value: modes.toString()}
                    ], colorKey);
                    return useKeyGen.setBlockModes.call(this, modes);
                }

                useKeyGen.setDigests.implementation = function (digests) {
                    showVariable("KeyGenParameterSpec.setDigests", [
                        {key: "Digests", value: digests.toString()}
                    ], colorKey);
                    return useKeyGen.setDigests.call(this, digests);
                }

                useKeyGen.setKeySize.implementation = function (keySize) {
                    showVariable("KeyGenParameterSpec.setKeySize", [
                        {key: "KeySize", value: keySize}
                    ], colorKey);
                    return useKeyGen.setKeySize.call(this, keySize);
                }

                useKeyGen.setEncryptionPaddings.implementation = function (paddings) {
                    showVariable("KeyGenParameterSpec.setEncryptionPaddings", [
                        {key: "Paddings", value: paddings.toString()}
                    ], colorKey);
                    return useKeyGen.setEncryptionPaddings.call(this, paddings);
                }

                useKeyGen.setSignaturePaddings.implementation = function (paddings) {
                    showVariable("KeyGenParameterSpec.setSignaturePaddings", [
                        {key: "Paddings", value: paddings.toString()}
                    ], colorKey);
                    return useKeyGen.setSignaturePaddings.call(this, paddings);
                }

                useKeyGen.setAlgorithmParameterSpec.implementation = function (spec) {
                    showVariable("KeyGenParameterSpec.setAlgorithmParameterSpec", [
                        {key: "ParameterSpec", value: spec.toString()}
                    ], colorKey);
                    return useKeyGen.setAlgorithmParameterSpec.call(this, spec);
                }

                useKeyGen.build.implementation = function () {
                    showVariable("KeyGenParameterSpec.build", [], colorKey);
                    return useKeyGen.build.call(this);
                }
            }

            if (MODE.IvParameterSpec) {
                const colorKey = randomColor();
                console.log("[*] Module attached: javax.crypto.spec.IvParameterSpec");
                const ivParameter = Java.use("javax.crypto.spec.IvParameterSpec");
                ivParameter.$init.overload("[B").implementation = function (ivKey) {
                    showVariable("IvParameterSpec.init", [
                        {key: "IV Key", value: bytesToBase64(ivKey)}
                    ], colorKey);
                    return this.$init.overload("[B").call(this, ivKey);
                }

                ivParameter.$init.overload("[B", "int", "int").implementation = function (ivKey, offset, len) {
                    showVariable("IvParameterSpec.init", [
                        {key: "IV Key", value: bytesToBase64(ivKey)},
                        {key: "Offset", value: offset},
                        {key: "Length", value: len}
                    ], colorKey);
                    return this.$init.overload("[B", "int", "int").call(this, ivKey, offset, len);
                }
            }

        });
    } else {
        console.log(`${COLORS.red}[!] Java unavailable${COLORS.reset}`);
    }

    console.log("Capturing setup completed");
    console.log("---");
}, 0);
```

`frida-android-hook/methods/intercept_nw_request.js`:

```js
function hook_okhttp3() {
    Java.perform(function() {
        var ByteString = Java.use("com.android.okhttp.okio.ByteString");
        var Buffer = Java.use("com.android.okhttp.okio.Buffer");
        var Interceptor = Java.use("okhttp3.Interceptor");
        var MyInterceptor = Java.registerClass({
            name: "okhttp3.MyInterceptor",
            implements: [Interceptor],
            methods: {
                intercept: function(chain) {
                    var request = chain.request();
                    try {
                        console.log("MyInterceptor.intercept onEnter:", request, "\nrequest headers:\n", request.headers());
                        var requestBody = request.body();
                        var contentLength = requestBody ? requestBody.contentLength() : 0;
                        if (contentLength > 0) {
                            var BufferObj = Buffer.$new();
                            requestBody.writeTo(BufferObj);
                            try {
                                console.log("\nrequest body String:\n", BufferObj.readString(), "\n");
                            } catch (error) {
                                try {
                                    console.log("\nrequest body ByteString:\n", ByteString.of(BufferObj.readByteArray()).hex(), "\n");
                                } catch (error) {
                                    console.log("error 1:", error);
                                }
                            }
                        }
                    } catch (error) {
                        console.log("error 2:", error);
                    }
                    var response = chain.proceed(request);
                    try {
                        console.log("MyInterceptor.intercept onLeave:", response, "\nresponse headers:\n", response.headers());
                        var responseBody = response.body();
                        var contentLength = responseBody ? responseBody.contentLength() : 0;
                        if (contentLength > 0) {
                            console.log("\nresponsecontentLength:", contentLength, "responseBody:", responseBody, "\n");

                            var ContentType = response.headers().get("Content-Type");
                            console.log("ContentType:", ContentType);
                            if (ContentType.indexOf("video") == -1) {
                                if (ContentType.indexOf("application") == 0) {
                                    var source = responseBody.source();
                                    if (ContentType.indexOf("application/zip") != 0) {
                                        try {
                                            console.log("\nresponse.body StringClass\n", source.readUtf8(), "\n");
                                        } catch (error) {
                                            try {
                                                console.log("\nresponse.body ByteString\n", source.readByteString().hex(), "\n");
                                            } catch (error) {
                                                console.log("error 4:", error);
                                            }
                                        }
                                    }
                                }

                            }

                        }

                    } catch (error) {
                        console.log("error 3:", error);
                    }
                    return response;
                }
            }
        });
        var ArrayList = Java.use("java.util.ArrayList");
        var OkHttpClient = Java.use("okhttp3.OkHttpClient");
        console.log(OkHttpClient);
        OkHttpClient.$init.overload('okhttp3.OkHttpClient$Builder').implementation = function(Builder) {
            console.log("OkHttpClient.$init:", this, Java.cast(Builder.interceptors(), ArrayList));
            this.$init(Builder);
        };

        var MyInterceptorObj = MyInterceptor.$new();
        var Builder = Java.use("okhttp3.OkHttpClient$Builder");
        console.log(Builder);
        Builder.build.implementation = function() {
            this.interceptors().clear();
            //var MyInterceptorObj = MyInterceptor.$new();
            this.interceptors().add(MyInterceptorObj);
            var result = this.build();
            return result;
        };

        Builder.addInterceptor.implementation = function(interceptor) {
            this.interceptors().clear();
            //var MyInterceptorObj = MyInterceptor.$new();
            this.interceptors().add(MyInterceptorObj);
            return this;
            //return this.addInterceptor(interceptor);
        };

        console.log("hook_okhttp3...");
    });
}
```

`requirements.txt`:

```txt
requests==2.28.1
frida==16.4.9
colorlog==6.7.0

```

`setup.py`:

```py
#!/usr/bin/python3
import sys
import os
setup = """#!/usr/bin/python3

import os
import subprocess
import shlex
import sys
from shutil import which

try:
    if(which('python3') is not None):
        command = shlex.split("python3 " +"core/hook.py")
    else:
        command = shlex.split("python " +"core/hook.py")

    command.extend(sys.argv[1:])
    subprocess.call(command, cwd=os.path.dirname(__file__))

except Exception as e:
    raise e
"""""
    
def _buildBinary():
    try:
        if sys.platform == 'darwin':
            with open('frida-android-hook/androidhook','w+', encoding="utf-8") as f:
                f.write(setup)
            os.system('chmod +x frida-android-hook/androidhook')
            print("[+] Build executable for Darwin success.")
        elif sys.platform == 'linux':
            with open('frida-android-hook/androidhook','w+', encoding="utf-8") as f:
                f.write(setup)
            os.system('chmod +x frida-android-hook/androidhook')
            print("[+] Build executable for Linux success.")
        elif sys.platform == 'win32':
            with open('frida-android-hook/androidhook.py','w+', encoding="utf-8") as f:
                f.write(setup)
            print("[+] Build executable for Windows success.")
    except Exception as e:
        raise e

if __name__ == '__main__':
    if sys.version_info < (3, 0):
        print("[x_x] Android hook requires Python 3.x")
        sys.exit(0)
    else:
        _buildBinary()
```