Project Path: arc_DosX-dev_obfus.h_4h1fetg7

Source Tree:

```txt
arc_DosX-dev_obfus.h_4h1fetg7
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ experiments
‚îÇ   ‚îî‚îÄ‚îÄ obfus-gcc-by-CyberForgeEx.h
‚îú‚îÄ‚îÄ include
‚îÇ   ‚îî‚îÄ‚îÄ obfus.h
‚îú‚îÄ‚îÄ include-updater
‚îÇ   ‚îî‚îÄ‚îÄ obfh-update.cmd
‚îú‚îÄ‚îÄ pics
‚îÇ   ‚îú‚îÄ‚îÄ before_and_after.png
‚îÇ   ‚îú‚îÄ‚îÄ before_and_after_2.png
‚îÇ   ‚îú‚îÄ‚îÄ how-it-works.png
‚îÇ   ‚îú‚îÄ‚îÄ how-it-works.txt
‚îÇ   ‚îî‚îÄ‚îÄ obfus.h.png
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ build_all.bat
    ‚îú‚îÄ‚îÄ disasm-security-audit
    ‚îÇ   ‚îú‚îÄ‚îÄ TinySnake_after.c
    ‚îÇ   ‚îú‚îÄ‚îÄ TinySnake_before.c
    ‚îÇ   ‚îú‚îÄ‚îÄ example.h
    ‚îÇ   ‚îî‚îÄ‚îÄ legacy_tests
    ‚îÇ       ‚îú‚îÄ‚îÄ ASM
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ after_x64.asm
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ after_x86.asm
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ before_x64.asm
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ before_x86.asm
    ‚îÇ       ‚îú‚îÄ‚îÄ C
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ after_x64.c
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ after_x86.c
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ before_x64.c
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ before_x86.c
    ‚îÇ       ‚îî‚îÄ‚îÄ example.c
    ‚îú‚îÄ‚îÄ dll.c
    ‚îú‚îÄ‚îÄ fib.c
    ‚îú‚îÄ‚îÄ hello_dll.c
    ‚îú‚îÄ‚îÄ hello_win.c
    ‚îú‚îÄ‚îÄ sorter.c
    ‚îú‚îÄ‚îÄ virtualmachine.c
    ‚îî‚îÄ‚îÄ virtualmachine_unit.c

```

`LICENSE`:

```
MIT License

Copyright (c) 2024-2026 DosX

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
![](pics/obfus.h.png)
# obfus.h

**[obfus.h](https://github.com/DosX-dev/obfus.h/blob/main/include/obfus.h)** is a macro-only library for compile-time obfuscating C applications, designed specifically for the **[Tiny C (tcc)](https://bellard.org/tcc/)**. It is tailored for Windows x86 and x64 platforms and supports almost all versions of the compiler. **Very reliable armor for your C programs!**

### What features does it have?...
- üîç **Function Call Obfuscation**: Confuse function calls to make your code less readable to unauthorized eyes.
- üõ°Ô∏è **Anti-Debugging Techniques**: Built-in mechanisms to prevent code analysis during runtime.
- üîÑ **Control Flow Code Mutation**: Turns code into spaghetti, making it difficult to parse conditions and loops.
- üß∂ **Strings Hiding**: Hides specified strings in a file and dynamically collects them when executed.
- üö´ **Anti-Decompilation Techniques**: Makes many popular decompilers useless visually breaking their output.
- üòà **Fake Signatures Adding**: Can add fake signatures of various packers and protectors to confuse reverse engineers.
- üß† **Virtualization**: Makes math operations very difficult to understand using virtual machine commands.

## üëæ Usage

Integrating **[obfus.h](https://github.com/DosX-dev/obfus.h/blob/main/include/obfus.h)** into your project is a simple process. Just include the following line in your code:
```c
#include "obfus.h"
```
This will automatically obfuscate your code during compilation, ensuring protection and confidentiality of your intellectual property.

> Available options for protection configuring:
> ```c
> // Advanced code protection (see the "Virtualization" part of the documentation!)
> #define VIRT           1  // Allows you to use the functions of a math VM
> 
> // Additional options
> #define CFLOW_V2       1  // More powerful Control Flow obfuscation (slowly!)
> #define ANTIDEBUG_V2   1  // Use better dynamic anti-debugging protection
> #define FAKE_SIGNS     1  // Adds fake signatures of various protectors or packers
> 
> // Disabling default features
> #define NO_OBF         1  // Don't obfuscate (for debugging)
> #define NO_CFLOW       1  // Don't use Control-Flow obfuscation
> #define NO_ANTIDEBUG   1  // Don't build in debugging protection
> ```
> or use it with compiler args:
> 
> ```
> tcc "app.c" -w  -D NO_CFLOW  -D ANTIDEBUG_V2  -D FAKE_SIGNS  -D VIRT
> ```

> [!WARNING]
> When compiling an application with obfuscation, use the `-w` argument to suppress warnings. Otherwise, the console will display numerous intimidating logs that have no impact on the final result. There's no need to be alarmed by them.

üîê Debugging protection is triggered by calls to many basic MSVCRT functions.
In critical places in the code you can use the `ANTI_DEBUG;` construct. For example:
```c
ANTI_DEBUG;
if (!licenseExpired()) {
	// ...
}
```

## üß∂ Strings hiding
The `HIDE_STRING(str)` obfuscates and visually hides strings by mutating them, significantly complicating their discovery and patching in the source code. When declared in this manner, the strings are assembled on the stack through `mov` instructions rather than being loaded all at once. This method ensures that the strings are not statically declared and are instead constructed at runtime, making them less susceptible to static analysis. However, it is important to note that this feature cannot be used for hiding static fields during their declaration, as it involves a function call.

> [!IMPORTANT]
> Some decompilers may still reveal them due to static optimizations. In disassembler output, the code will appear complex and cumbersome, which can deter straightforward analysis but may not fully prevent determined reverse engineering efforts.

An example of calling the `printf` function from the standard library with static hiding of the message and its decryption on the stack:
```c
char *hidden_message = HIDE_STRING("Hello, world!");
// ...
printf(hidden_message);
```

## üë∫ Virtualization
This is a protection technique in which certain calculations are performed through an embedded virtual machine upon command. Makes analysis of mathematical operations **very difficult**! It will work with the `VIRT` option enabled (and only!). Otherwise, all virtual machine commands will be replaced by ordinary mathematical operators.

> [!WARNING]
> Virtualization in critical locations can impact optimization. Use with caution only in areas where it is really needed

| Function         | Type           | Op | Description                                                                | Example                              |
|------------------|----------------|----|----------------------------------------------------------------------------|--------------------------------------|
| **`VM_ADD`**     | *long*         |`+` | Adds two numbers                                                           | `VM_ADD(5, 3)` = **`8`**             |
| **`VM_SUB`**     | *long*         |`-` | Subtracts two numbers                                                      | `VM_SUB(5, 3)` = **`2`**             |
| **`VM_MUL`**     | *long*         |`*` | Multiplies two numbers                                                     | `VM_MUL(5, 3)` = **`15`**            |
| **`VM_DIV`**     | *long*         |`/` | Divides two numbers                                                        | `VM_DIV(6, 3)` = **`2`**             |
| **`VM_MOD`**     | *long*         |`%` | Calculates the modulus of two numbers                                      | `VM_MOD(5, 3)` = **`2`**             |
| **`VM_EQU`**     | *BOOL*         |`==`| Checks if two numbers are equal                                            | `VM_EQU(5, 5)` = **`true`**          |
| **`VM_NEQ`**     | *BOOL*         |`!=`| Checks if two numbers are not equal                                        | `VM_NEQ(5, 3)` = **`true`**          |
| **`VM_LSS`**     | *BOOL*         |`<` | Checks if the first number is less than the second number                  | `VM_LSS(3, 5)` = **`true`**          |
| **`VM_GTR`**     | *BOOL*         |`>` | Checks if the first number is greater than the second number               | `VM_GTR(5, 3)` = **`true`**          |
| **`VM_LEQ`**     | *BOOL*         |`<=`| Checks if the first number is less than or equal to the second number      | `VM_LEQ(3, 5)` = **`true`**          |
| **`VM_GEQ`**     | *BOOL*         |`>=`| Checks if the first number is greater than or equal to the second number   | `VM_GEQ(5, 3)` = **`true`**          |
| **`VM_ADD_DBL`** | *long double*  |`+` | Adds two double numbers                                                    | `VM_ADD_DBL(5.5, 3.2)` = **`‚âà8.7`**  |
| **`VM_SUB_DBL`** | *long double*  |`-` | Subtracts two double numbers                                               | `VM_SUB_DBL(5.5, 3.2)` = **`‚âà2.3`**  |
| **`VM_MUL_DBL`** | *long double*  |`*` | Multiplies two double numbers                                              | `VM_MUL_DBL(5.5, 3.2)` = **`‚âà17.6`** |
| **`VM_DIV_DBL`** | *long double*  |`/` | Divides two double numbers                                                 | `VM_DIV_DBL(6.0, 3.0)` = **`‚âà2.0`**  |
| **`VM_LSS_DBL`** | *BOOL*         |`<` | Checks if the first double number is less than the second double number    | `VM_LSS_DBL(3.5, 5.2)` = **`true`**  |
| **`VM_GTR_DBL`** | *BOOL*         |`>` | Checks if the first double number is greater than the second double number | `VM_GTR_DBL(5.5, 3.2)` = **`true`**  |
> The virtual machine does not support some basic `double` comparison operations.

You can use logical operators that use virtual machine calls to further complicate the understanding of your code:
| Operator        | Description               |
|-----------------|---------------------------|
| **`VM_IF`**     | Use instead of `if`       |
| **`VM_ELSE_IF`**| Use instead of `else if`  |
| **`VM_ELSE`**   | Use instead of `else`     |
> This is not a complete replacement for if/else, but is just a complication of standard operators.

A simple example of using virtualization:
```c
// ...
#define VIRT 1
// ...

// if ((2 + 2) == 4) { ... }
VM_IF (VM_EQU(VM_ADD(2, 2), 4)) {
	printf("2 + 2 == 4!");
}

// if (condition1) { ... }
// else if (condition2) { ... }
// else { ... }
VM_IF (condition1) {
	// if
} VM_ELSE_IF (condition2) {
	// else if
} VM_ELSE {
	// else
}
```

You can find examples of using all the functions of a virtual machine in the file [tests/virtualmachine.c](tests/virtualmachine.c)

## ‚ùì Example of using
If you need advanced protection against skilled reversers, use `CFLOW_V2` and `ANTIDEBUG_V2` options.
```c
// Let's obfuscate your code!

#include <stdio.h>

#define VIRT         1 // [+] Use math virtual machine

#define CFLOW_V2     1 // [+] ControlFlow v2
#define FAKE_SIGNS   1 // [+] Fake signatures
#define ANTIDEBUG_V2 1 // [+] AntiDebug v2

#define NO_OBF       0 // [-] Don't obfuscate (disable all)
#define NO_CFLOW     0 // [-] Disable ControlFlow
#define NO_ANTIDEBUG 0 // [-] Disable AntiDebug


#include "obfus.h"

void main() {
	char *out = malloc(256);

	strcpy(out, HIDE_STRING("Hello, world!\n"));

	if (out) {
		printf(out);
	} else {
		printf("Error!\n");
	}

	free(out);

	int result = VM_ADD(5, 7); // 5 + 7

	VM_IF (VM_EQU(result, 12)) { // (5 + 7) == 12
		printf("5 + 7 == 12");
	}
}
```

## ü§ñ How it works?
> ![](pics/how-it-works.png)

## üõ† Compiler (important)
The latest version of **Tiny C** (`0.9.27`) is recommended for use. Unfortunately, some versions of the compiler do not support the functionality needed to completely obfuscation. **Visual C**, **GCC** and **Clang** *is not supported* and is unlikely to be supported.

## üåê obfus.h updater
You can use [special script](include-updater/obfh-update.cmd) for Windows to get the latest versions of `obfus.h` by downloading the package from the official repository. This is useful if you need to automate security updates without using `git`.

> For example, you can use it before building your project:
> ```diff
> + C:\...> call obfh-update
>   C:\...> tcc app.c -w
> ```
> The script will update the contents of the obfus.h file in the current directory (according to the specified configuration)

## üìñ Summarize
The code of a program (and its original original logic) protected using **[obfus.h](https://github.com/DosX-dev/obfus.h/blob/main/include/obfus.h)** is almost **impossible to recover (deobfuscate)**. However, using this obfuscator does not guarantee complete protection against all types of threats. **It's important to develop and maintain internal program security systems.**

> **What the diagrammatic code will look like after obfuscation:**
> ![](pics/before_and_after.png)

> **The reverser will see something like this if he tries to use a decompiler:**
> ![](pics/before_and_after_2.png)

> **This is what all hidden strings via `HIDE_STRING` feature look like in the disassembler (x86-64 arch):**
> ```asm
>   ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
>   ; PROTECTED STRING:                  ; ORIGINAL STRING:         ;
>   mov eax, 48h                         lea rax, aHelloWorld       ;
>   mov [rbp-0Fh], al                    mov r11, rax               ;
>   mov eax, 65h                         ; . . .                    ;
>   mov [rbp-0Eh], al                                               ;
>   mov eax, 6Ch                                                    ;
>   mov [rbp-0Dh], al                                               ;
>   mov eax, 6Ch                                                    ;
>   mov [rbp-0Ch], al                                               ;
>   mov eax, 6Fh                                                    ;
>   mov [rbp-0Bh], al                                               ;
>   mov eax, 2Ch                                                    ;
>   ; etc . . .                                                     ;
>   ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
> ```

<!-- ```c
// BEFORE OBFUSCATION       
__int64 sub_4010B8() {
	printf("Hello, world!");
	return 0i64;
}
```

```c
// AFTER OBFUSCATION
 __int64 sub_401000() {
	 *(_DWORD *)(a2 + v2) += v2;
	 if ( !(_DWORD)a2 )
	   JUMPOUT(0x100C3C9);
	 MEMORY[0x100C3C9] &= a2;
	 return (loc_4017B1)(asc_404159);
 }
``` -->

## üåà Special thanks
Thanks to everyone who helped in the development of this project. I appreciate it! ‚ù§Ô∏è
 * üë®üèº‚Äçüíª **[@horsicq](https://github.com/horsicq)** *(for help with the code and advices)*
 * üê∫ **[@ac3ss0r](https://github.com/ac3ss0r)** *(for cool ideas and their solutions)*

And **thanks to you** ü§ù for paying attention to this project!

```

`experiments/obfus-gcc-by-CyberForgeEx.h`:

```h
/*
[Same operations on obfus.h with gcc compatibility]
~ Compile with: gcc -O2 -masm=intel your_file.c -o output.exe -w
*/

#ifndef OBFH
#define OBFH

#if !__TINYC__ && !__GNUC__ && !__MINGW32__
#define __attribute__(...)
#endif

// if virtualization disabled
#if NO_OBF == 1 || VIRT != 1
#define VM_ADD(num1, num2) ((num1) + (num2))
#define VM_SUB(num1, num2) ((num1) - (num2))
#define VM_MUL(num1, num2) ((num1) * (num2))
#define VM_DIV(num1, num2) ((num1) / (num2))
#define VM_MOD(num1, num2) ((num1) % (num2))
#define VM_EQU(num1, num2) ((num1) == (num2))
#define VM_NEQ(num1, num2) ((num1) != (num2))
#define VM_LSS(num1, num2) ((num1) < (num2))
#define VM_GTR(num1, num2) ((num1) > (num2))
#define VM_LEQ(num1, num2) ((num1) <= (num2))
#define VM_GEQ(num1, num2) ((num1) >= (num2))
#define VM_ADD_DBL(num1, num2) ((num1) + (num2))
#define VM_SUB_DBL(num1, num2) ((num1) - (num2))
#define VM_MUL_DBL(num1, num2) ((num1) * (num2))
#define VM_DIV_DBL(num1, num2) ((num1) / (num2))
#define VM_LSS_DBL(num1, num2) ((num1) < (num2))
#define VM_GTR_DBL(num1, num2) ((num1) > (num2))
#define VM_IF(condition) if (condition)
#define VM_ELSE_IF(condition) else if (condition)
#define VM_ELSE else
#define VM_OBF_INT(num) (num)
#define VM_OBF_DBL(num) (num)
#endif

#if NO_OBF == 1
#define HIDE_STRING(str) str
#define ANTI_DEBUG 0
#endif

#if !NO_OBF

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdarg.h>

#if defined _MSC_VER
#warning obfus.h optimized for GCC/MinGW. MSVC may have issues.
#endif

#if !defined __COUNTER__
#error You are using too old a compiler version!
#endif

#ifndef __asm__
#define __asm__(...)
#endif

#define SECTION_ATTRIBUTE(NAME) __attribute__((section(NAME)))

#define DATA_SECTION_ATTRIBUTE SECTION_ATTRIBUTE(".data")

// Fake signatures
#if FAKE_SIGNS == 1

static const char FAKE_ENIGMAVM_1[] SECTION_ATTRIBUTE(".enigma1") = {0};
static const char FAKE_ENIGMAVM_2[] SECTION_ATTRIBUTE(".enigma2") = {0};
static const char FAKE_VMPROTECT_1[] SECTION_ATTRIBUTE(".vmp0") = {0};
static const char FAKE_VMPROTECT_2[] SECTION_ATTRIBUTE(".vmp1") = {0};
static const char FAKE_VMPROTECT_3[] SECTION_ATTRIBUTE(".vmp2") = {0};

#define OBFH_SECTION_ATTRIBUTE SECTION_ATTRIBUTE("UPX0")
static const char FAKE_UPX[] OBFH_SECTION_ATTRIBUTE = {0};

static const char FAKE_THEMIDA[] SECTION_ATTRIBUTE(".winlice") = {0};
static const char FAKE_PETITE[] SECTION_ATTRIBUTE(".petite") = {0};
static const char FAKE_ENIGMA[] SECTION_ATTRIBUTE(".data") = {0x45, 0x6e, 0x69, 0x67,
                                                              0x6d, 0x61, 0x20, 0x70,
                                                              0x72, 0x6f, 0x74, 0x65,
                                                              0x63, 0x74, 0x6f, 0x72,
                                                              0x20, 0x76, 0x01};

#else

#define OBFH_SECTION_ATTRIBUTE  // Empty for GCC compatibility

#endif

// Compile-time random number generator
#define RND(min, max) \
    (min + (((__COUNTER__ + (__LINE__ * __LINE__)) * 2654435761u) % (max - min + 1)))

#define STACK_STRING(str) ((char[]){str})

// Forward declarations
int obfh_int_proxy(int value);
float obfh_condition_true(void);
long double __s_rdtsc(float junk, ...);
char *obfh_process_hidden_string(char *string, ...);

#define HIDE_STRING(str) \
    (_0 < RND(1, 255) ? obfh_process_hidden_string(STACK_STRING("\0" str "\0"), (float)__s_rdtsc(RND(0, 255)) != 0.1) : (char*)str)

typedef enum {
    SALT_SHIFT = RND(0xBAD, 0xBEEF)
} VAR_ADDR_SHIFT;

#define RET_BY_VAR(value)                                   \
    {                                                       \
        int _obfh_ret_val_shift = SALT_SHIFT,               \
            *_obfh_ret_val_addr = ((int*)&value + SALT_SHIFT);    \
        return *(_obfh_ret_val_addr - _obfh_ret_val_shift); \
    }

// Obfuscation data variables (without section attributes for GCC compatibility)
volatile static char _s_a[] = "a", _s_b[] = "b", _s_c[] = "c", _s_d[] = "d",
                     _s_e[] = "e", _s_f[] = "f", _s_g[] = "g", _s_h[] = "h",
                     _s_i[] = "i", _s_j[] = "j", _s_k[] = "k", _s_l[] = "l",
                     _s_m[] = "m", _s_n[] = "n", _s_o[] = "o", _s_p[] = "p",
                     _s_q[] = "q", _s_r[] = "r", _s_s[] = "s", _s_t[] = "t",
                     _s_u[] = "u", _s_v[] = "v", _s_w[] = "w", _s_x[] = "x",
                     _s_y[] = "y", _s_z[] = "z";

volatile static char _a = 'a', _b = 'b', _c = 'c', _d = 'd',
                     _e = 'e', _f = 'f', _g = 'g', _h = 'h',
                     _i = 'i', _j = 'j', _k = 'k', _l = 'l',
                     _m = 'm', _n = 'n', _o = 'o', _p = 'p',
                     _q = 'q', _r = 'r', _s = 's', _t = 't',
                     _u = 'u', _v = 'v', _w = 'w', _x = 'x',
                     _y = 'y', _z = 'z',
                     _S = 'S', _L = 'L', _A = 'A', _I = 'I',
                     _D = 'D', _P = 'P';

volatile static char _0 = 0, _1 = 1, _2 = 2, _3 = 3, _4 = 4,
                     _5 = 5, _6 = 6, _7 = 7, _8 = 8, _9 = 9;

#define __obfh_asm__(...) __asm__ __volatile__(__VA_ARGS__)

// Stack breaking macros (x86/x64 compatible)
#define BREAK_STACK_1      \
    __obfh_asm__(          \
        "xor eax, eax\n\t" \
        "jz 1f\n\t"           \
        ".byte 0xE8\n\t"      \
        "1:\n\t"               \
        ::: "eax")

#define BREAK_STACK_2 \
    if (_0) __obfh_asm__(".byte 0x00")

#define BREAK_STACK_3                          \
    switch (_0) {                              \
        case RND(1, 1000):                     \
            __obfh_asm__(".byte 0x00, 0x00"); \
    }

#define BREAK_STACK_4      \
    __obfh_asm__(          \
        "xor ebx, ebx\n\t" \
        "xor edx, edx\n\t" \
        "jz 1f\n\t"           \
        ".byte 0x00\n\t"      \
        "1:\n\t"               \
        ::: "ebx", "edx")

#define FAKE_CPUID __obfh_asm__("nop\n\t" ::: )

#if defined(__x86_64__) || defined(_M_X64)
#define BAD_JMP __obfh_asm__(".byte 0xFF, 0x25, 0xF1, 0xF2, 0xF3, 0xF4")
#else
#define BAD_JMP __obfh_asm__(".byte 0xEB, 0xE1")
#endif

#define BAD_CALL __obfh_asm__(".byte 0xB8")

// Function declarations
void obfh_junk_func_args(int z, ...) {
    BREAK_STACK_1;
    __obfh_asm__("nop");
    return;
}

void obfh_junk_func(void) {
    __obfh_asm__("nop");
    return;
}

#define __CRASH       \
    __obfh_asm__(     \
        ".byte 0xED\n\t" \
        "int3");   \
    exit(1)

#define TRUE ((((_9 + _7 + (RND(0, 1000) * _0))) / _8) - _1)
#define FALSE (((_3 + _6 + (RND(0, 1000) * _0)) - _9) * RND(0, 255))

#define NOP_FLOOD                                  \
    (RND(0, 1000)) + obfh_int_proxy(RND(0, 1000)); \
    if (obfh_junk_func_args) {                     \
        __obfh_asm__("nop");                      \
    }                                              \
    do {                                           \
        __obfh_asm__("nop\n\t" "nop");            \
    } while (RND(0, 200) * _0)

static float rndValueToProxy = RND(0, 10);

int obfh_int_proxy(int value) {
    volatile int temp = value;
    return temp;
}

double obfh_double_proxy(double value) {
    volatile double temp = value;
    return temp;
}

float obfh_condition_true(void) {
    BREAK_STACK_1;
    return _1 && TRUE;
}

int obfh_condition_proxy(float junk, float condition, ...) {
    volatile int temp = (int)condition;
    return temp;
}

char *obfh_process_hidden_string(char *string, ...) {
    BREAK_STACK_1;
    
    if (!obfh_condition_true() || _0) {
        BAD_JMP;
    }

    static char string_to_return[4096];
    strcpy(string_to_return, string + 1);
    return string_to_return;
}

long double __s_rdtsc(float junk, ...) {
    unsigned int lo, hi;
    __obfh_asm__(
        "rdtsc\n\t"
        : "=a"(lo), "=d"(hi)
    );
    
    unsigned long long time = ((unsigned long long)hi << 32) | lo;
    return (long double)time;
}

// =============================================================
// Control Flow Obfuscation
#if NO_CFLOW != 1

#define if(cond)                                                                         \
    if ((float)__s_rdtsc(RND(0, 255)) == (float)((RND(1, 255) * -1)) * (float)1.0) {     \
        BAD_CALL;                                                                        \
    } else if (&__s_rdtsc && (cond ? ((float)__s_rdtsc(RND(0, 255), RND(0, 255)) != 0.1) \
                                   : (float)__s_rdtsc(RND(0, 255)) == 0.1))

#define else      \
    else if (0) { \
        BAD_CALL; \
    }             \
    else

#if CFLOW_V2
#define OBFUS_CONDITION_BLOCK(...) \
    (obfh_condition_proxy(RND(0, 255), (__VA_ARGS__) ? !!obfh_int_proxy(!!obfh_condition_true()) : !!!obfh_condition_true(), RND(0, 255)) ? !!obfh_condition_true() : obfh_int_proxy(!obfh_condition_true()))
#else
#define OBFUS_CONDITION_BLOCK(...) \
    (obfh_condition_proxy(RND(0, 255), (__VA_ARGS__), RND(0, 255)) ? !!obfh_condition_true() : !obfh_condition_true())
#endif

#define break                                                  \
    {                                                          \
        if (OBFUS_CONDITION_BLOCK(RND(1, 255))) BREAK_STACK_1; \
        break;                                                 \
    }

#define switch(...)                         \
    if (OBFUS_CONDITION_BLOCK(RND(1, 255))) \
        switch (__VA_ARGS__)

#define while(...) \
    while ((float)__s_rdtsc(RND(0, 255)) != 0.1 && (&__s_rdtsc != (void*)!&__s_rdtsc) && (__VA_ARGS__))

#define for(...)                            \
    if (OBFUS_CONDITION_BLOCK(RND(1, 255))) \
        for (__VA_ARGS__)

#endif
// =============================================================

// =============================================================
// Virtual Machine
#if VIRT == 1

typedef enum {
    OP__ADD = RND(0, 900) * 5,
    OP__SUB = RND(1000, 1900) * 5,
    OP__MUL = RND(2000, 2900) * 5,
    OP__DIV = RND(3000, 3900) * 5,
    OP__MOD = RND(4000, 4900) * 5,
    OP__EQU = RND(5000, 5900) * 5,
    OP__NEQ = RND(6000, 6900) * 5,
    OP__GTR = RND(7000, 7900) * 5,
    OP__LSS = RND(8000, 8900) * 5,
    OP__LEQ = RND(9000, 9900) * 5,
    OP__GEQ = RND(10000, 10900) * 5,
    OP__NOP = RND(11000, 11900) * 5
} CMD;

typedef enum {
    SALT_CMD = RND(100, 900),
    SALT_NUM1 = RND(16, 48),
    SALT_NUM2 = RND(16, 48)
} VM_SALT;

static int _salt = SALT_CMD;

#define _VM_DEMUTATOR_KEY (1)
#define _VM_MUTATOR_KEY (1)

#define _VM_ENCRYPT_INT(value) ((value - _VM_MUTATOR_KEY) * ~SALT_CMD)
#define _ENC_OP__ADD _VM_ENCRYPT_INT(OP__ADD)
#define _ENC_OP__SUB _VM_ENCRYPT_INT(OP__SUB)
#define _ENC_OP__MUL _VM_ENCRYPT_INT(OP__MUL)
#define _ENC_OP__DIV _VM_ENCRYPT_INT(OP__DIV)
#define _ENC_OP__MOD _VM_ENCRYPT_INT(OP__MOD)
#define _ENC_OP__EQU _VM_ENCRYPT_INT(OP__EQU)
#define _ENC_OP__NEQ _VM_ENCRYPT_INT(OP__NEQ)
#define _ENC_OP__GTR _VM_ENCRYPT_INT(OP__GTR)
#define _ENC_OP__LSS _VM_ENCRYPT_INT(OP__LSS)
#define _ENC_OP__LEQ _VM_ENCRYPT_INT(OP__LEQ)
#define _ENC_OP__GEQ _VM_ENCRYPT_INT(OP__GEQ)
#define _ENC_OP__NOP _VM_ENCRYPT_INT(OP__NOP)

long double Obfh_VirtualMachine(long double uni_key, int command, long double num1, long double junk_2, long double num2, long double junk_3);

#define VM_ADD(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__ADD, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_SUB(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__SUB, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_MUL(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__MUL, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_DIV(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__DIV, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_MOD(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__MOD, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_EQU(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__EQU, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_NEQ(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__NEQ, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_LSS(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__LSS, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_GTR(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__GTR, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_LEQ(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__LEQ, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_GEQ(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__GEQ, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_OBF_INT(num1) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__NOP, (num1) * -1 + SALT_NUM1, RND(1, 500), 0, RND(1, 500)))

#define VM_ADD_DBL(num1, num2) (Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__ADD, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_SUB_DBL(num1, num2) (Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__SUB, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_MUL_DBL(num1, num2) (Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__MUL, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_DIV_DBL(num1, num2) (Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__DIV, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_LSS_DBL(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__LSS, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_GTR_DBL(num1, num2) ((long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__GTR, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500)))
#define VM_OBF_DBL(num1) (Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__NOP, (num1) * -1 + SALT_NUM1, RND(1, 500), 0, RND(1, 500)))

#define VM_IF(condition) if (!VM_EQU((int)(condition), VM_MUL(RND(111111, 999999), 0)))
#define VM_ELSE_IF(condition) else if (!VM_EQU((int)(condition), VM_MUL(0, RND(111111, 999999))))
#define VM_ELSE else if (VM_EQU(1, _1))

long double obfhVmResult = 0;

long double Obfh_VirtualMachine(long double uni_key, int command, long double num1, long double junk_2, long double num2, long double junk_3) {
    BREAK_STACK_1;
    
    // Restore values
    command /= ~_salt;
    command += (int)uni_key;
    
    num2 -= SALT_NUM2;
    num2 *= (-1 * _1);
    
    num1 -= SALT_NUM1;
    num1 *= (-1 * _1);

    switch (command) {
        case OP__ADD:
            obfhVmResult = (num1 + num2);
            break;
        case OP__SUB:
            obfhVmResult = (num1 - num2);
            break;
        case OP__MUL:
            if (num1 == _0 || num2 == _0)
                obfhVmResult = _0;
            else
                obfhVmResult = num1 * num2;
            break;
        case OP__DIV:
            if (num2 != _0)
                obfhVmResult = num1 / num2;
            else
                obfhVmResult = _0;
            break;
        case OP__MOD:
            if (num2 != 0)
                obfhVmResult = (int)num1 % (int)num2;
            else
                obfhVmResult = _0;
            break;
        case OP__EQU:
            obfhVmResult = (num1 == num2) ? _1 : _0;
            break;
        case OP__NEQ:
            obfhVmResult = (num1 != num2) ? _1 : _0;
            break;
        case OP__LSS:
            obfhVmResult = (num1 < num2) ? _1 : _0;
            break;
        case OP__GTR:
            obfhVmResult = (num1 > num2) ? _1 : _0;
            break;
        case OP__LEQ:
            obfhVmResult = (num1 <= num2) ? _1 : _0;
            break;
        case OP__GEQ:
            obfhVmResult = (num1 >= num2) ? _1 : _0;
            break;
        case OP__NOP:
            obfhVmResult = num1;
            break;
        default:
            obfhVmResult = _0;
            BAD_JMP;
    }

    return obfhVmResult;
}
#endif
// =============================================================

// Custom standard library wrappers
int strcmp_custom(const char *str1, const char *str2) {
    BREAK_STACK_1;
    while (*str1 != '\0' || *str2 != '\0') {
        if (*str1 < *str2) {
            return -1;
        } else if (*str1 > *str2) {
            return 1;
        }
        str1++;
        str2++;
    }
    FAKE_CPUID;
    return 0;
}
#define strcmp(...) strcmp_custom(__VA_ARGS__)

size_t strlen_custom(const char *str) {
    BREAK_STACK_1;
    size_t length = 0;
    while (*str != '\0') {
        length++;
        str++;
    }
    FAKE_CPUID;
    return length;
}
#define strlen(...) strlen_custom(__VA_ARGS__)

// =============================================================
// Anti-Debug Protection
#if NO_ANTIDEBUG != 1

#if ANTIDEBUG_V2 == 1

void ad_ZeroDRs(PCONTEXT pCtx) {
    BREAK_STACK_1;
    pCtx->Dr0 = 0;
    pCtx->Dr1 = 0;
    pCtx->Dr2 = 0;
    pCtx->Dr3 = 0;
    pCtx->Dr6 = 0;
    pCtx->Dr7 = 0;
}

int ad_CompareDRs(PCONTEXT pCtx) {
    BREAK_STACK_1;
    if (pCtx->Dr7 != 0) {
        ad_ZeroDRs(pCtx);
        return 1;
    } else {
        if (0 == (pCtx->Dr0 | pCtx->Dr1 | pCtx->Dr2 | pCtx->Dr3)) {
            ad_ZeroDRs(pCtx);
        }
        ad_ZeroDRs(pCtx);
    }
    return 0;
}

DWORD WINAPI ThreadCompareDRs(void *p) {
    BREAK_STACK_1;
    DWORD dwRet = 0;
    HANDLE hMainThread = (HANDLE)p;
    if (-1 != SuspendThread(hMainThread)) {
        CONTEXT context;
        context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
        if (GetThreadContext(hMainThread, &context)) {
            if (ad_CompareDRs(&context))
                dwRet = 1;
        }
        ResumeThread(hMainThread);
    }
    CloseHandle(hMainThread);
    return dwRet;
}

int IsDebuggerPresent_proxy(void) {
    BREAK_STACK_1;
    NOP_FLOOD;
    
    // Register validation
    HANDLE hMainThread;
    DWORD dwDummy, exitCode = 0;

    DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(),
                    &hMainThread, 0, FALSE, DUPLICATE_SAME_ACCESS);

    HANDLE hThread = CreateThread(NULL, 0, ThreadCompareDRs, hMainThread, 0, &dwDummy);
    if (hThread) {
        WaitForSingleObject(hThread, INFINITE);
        GetExitCodeThread(hThread, &exitCode);
        CloseHandle(hThread);
    }

    if (exitCode) return exitCode;

    // Dynamic antidebugger
    return IsDebuggerPresent();
}

#else

int IsDebuggerPresent_proxy(void) {
    BREAK_STACK_1;
    NOP_FLOOD;
    return IsDebuggerPresent();
}

#endif

void crash(void) {
    BREAK_STACK_1;
    __obfh_asm__("int3\n\t" ".byte 0xED, 0x00");
}

void loop(void) {
    while (1) {
        Sleep(1000);
    }
}

#define ANTI_DEBUG                                                              \
    if (IsDebuggerPresent() || IsDebuggerPresent_proxy()) {                    \
        loop();                                                                 \
        while (1) {};                                                           \
        __obfh_asm__(".byte 0xED");                                            \
        BREAK_STACK_1;                                                          \
        crash();                                                                \
    } else {                                                                    \
        (void)0;                                                                \
    }

#else
#define ANTI_DEBUG ((void)0)
#endif
// =============================================================

// Custom printf implementation
void printf_custom(const char *format, ...) {
    BREAK_STACK_1;
    char buffer[4096];
    va_list args;
    
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD written;
    WriteConsoleA(hConsole, buffer, (DWORD)strlen(buffer), &written, NULL);
}

#define printf(...) do { \
    BREAK_STACK_1; \
    printf_custom(__VA_ARGS__); \
} while (0)

// Memory management wrappers
void *memset_proxy(void *ptr, int value, size_t num) {
    BREAK_STACK_1;
    return memset(ptr, value, num);
}
#define memset(...) memset_proxy(__VA_ARGS__)

void *calloc_proxy(size_t nmemb, size_t size) {
    BREAK_STACK_1;
    return calloc(nmemb, size);
}
#define calloc(nmemb, size) calloc_proxy(nmemb, size)

void *realloc_proxy(void *ptr, size_t size) {
    BREAK_STACK_1;
    return realloc(ptr, size);
}
#define realloc(ptr, size) realloc_proxy(ptr, size)

// String manipulation wrappers
char *strcpy_proxy(char *dest, const char *src) {
    BREAK_STACK_1;
    return strcpy(dest, src);
}
#define strcpy(dest, src) strcpy_proxy(dest, src)

char *strcat_proxy(char *dest, const char *src) {
    BREAK_STACK_1;
    return strcat(dest, src);
}
#define strcat(dest, src) strcat_proxy(dest, src)

char *strchr_proxy(const char *str, int c) {
    BREAK_STACK_1;
    return strchr(str, c);
}
#define strchr(str, c) strchr_proxy(str, c)

char *strrchr_proxy(const char *str, int c) {
    BREAK_STACK_1;
    return strrchr(str, c);
}
#define strrchr(str, c) strrchr_proxy(str, c)

char *strtok_proxy(char *str, const char *delim) {
    BREAK_STACK_1;
    return strtok(str, delim);
}
#define strtok(str, delim) strtok_proxy(str, delim)

// File operations wrappers
FILE *fopen_proxy(const char *filename, const char *mode) {
    BREAK_STACK_1;
    return fopen(filename, mode);
}
#define fopen(filename, mode) fopen_proxy(filename, mode)

int fclose_proxy(FILE *stream) {
    BREAK_STACK_1;
    return fclose(stream);
}
#define fclose(stream) fclose_proxy(stream)

size_t fread_proxy(void *ptr, size_t size, size_t count, FILE *stream) {
    BREAK_STACK_1;
    return fread(ptr, size, count, stream);
}
#define fread(ptr, size, count, stream) fread_proxy(ptr, size, count, stream)

size_t fwrite_proxy(const void *ptr, size_t size, size_t count, FILE *stream) {
    BREAK_STACK_1;
    return fwrite(ptr, size, count, stream);
}
#define fwrite(ptr, size, count, stream) fwrite_proxy(ptr, size, count, stream)

// System functions wrappers
int system_proxy(const char *command) {
    BREAK_STACK_1;
    return system(command);
}
#define system(command) system_proxy(command)

void exit_proxy(int status) {
    BREAK_STACK_1;
    exit(status);
}
#define exit(status) exit_proxy(status)

void abort_proxy(void) {
    BREAK_STACK_1;
    abort();
}
#define abort() abort_proxy()

int atexit_proxy(void (*func)(void)) {
    BREAK_STACK_1;
    return atexit(func);
}
#define atexit(func) atexit_proxy(func)

char *getenv_proxy(const char *name) {
    BREAK_STACK_1;
    return getenv(name);
}
#define getenv(name) getenv_proxy(name)

// Character classification wrappers
int tolower_proxy(int c) {
    BREAK_STACK_1;
    return tolower(c);
}
#define tolower(c) tolower_proxy(c)

int toupper_proxy(int c) {
    BREAK_STACK_1;
    return toupper(c);
}
#define toupper(c) toupper_proxy(c)

// Math function wrappers
#define _MUTATE_MATH(value) (FALSE + (value) * TRUE)

#define sqrt(x) sqrt(_MUTATE_MATH(x))
#define sin(x) sin(_MUTATE_MATH(x))
#define cos(x) cos(_MUTATE_MATH(x))
#define tan(x) tan(_MUTATE_MATH(x))
#define asin(x) asin(_MUTATE_MATH(x))
#define acos(x) acos(_MUTATE_MATH(x))
#define atan(x) atan(_MUTATE_MATH(x))
#define exp(x) exp(_MUTATE_MATH(x))
#define log(x) log(_MUTATE_MATH(x))
#define log10(x) log10(_MUTATE_MATH(x))
#define pow(x, y) pow(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define ceil(x) ceil(_MUTATE_MATH(x))
#define floor(x) floor(_MUTATE_MATH(x))
#define fabs(x) fabs(_MUTATE_MATH(x))
#define abs(x) ((x) < FALSE ? -(x) : (x))

// Windows API wrappers
#define Sleep(x) Sleep(obfh_int_proxy(x * TRUE))

#define GetStdHandle(nStdHandle) GetStdHandle(obfh_int_proxy(nStdHandle))

#define WriteConsoleA(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved) \
    WriteConsoleA(hConsoleOutput, lpBuffer, obfh_int_proxy(nNumberOfCharsToWrite), lpNumberOfCharsWritten, lpReserved)

#define GetModuleHandleA(lpModuleName) GetModuleHandleA(lpModuleName)

#define GetCurrentProcess() GetCurrentProcess()

#define VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect) \
    VirtualAlloc(lpAddress, obfh_int_proxy(dwSize), obfh_int_proxy(flAllocationType), obfh_int_proxy(flProtect))

#define VirtualFree(lpAddress, dwSize, dwFreeType) \
    VirtualFree(lpAddress, obfh_int_proxy(dwSize), obfh_int_proxy(dwFreeType))

#define CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId) \
    CreateThread(lpThreadAttributes, obfh_int_proxy(dwStackSize), lpStartAddress, lpParameter, obfh_int_proxy(dwCreationFlags), lpThreadId)

#define WaitForSingleObject(hHandle, dwMilliseconds) \
    WaitForSingleObject(hHandle, obfh_int_proxy(dwMilliseconds))

#define CloseHandle(hObject) CloseHandle(hObject)

#define CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) \
    CreateFileA(lpFileName, obfh_int_proxy(dwDesiredAccess), obfh_int_proxy(dwShareMode), lpSecurityAttributes, obfh_int_proxy(dwCreationDisposition), obfh_int_proxy(dwFlagsAndAttributes), hTemplateFile)

#define ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped) \
    ReadFile(hFile, lpBuffer, obfh_int_proxy(nNumberOfBytesToRead), lpNumberOfBytesRead, lpOverlapped)

#define WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped) \
    WriteFile(hFile, lpBuffer, obfh_int_proxy(nNumberOfBytesToWrite), lpNumberOfBytesWritten, lpOverlapped)

#define GetModuleFileNameA(hModule, lpFilename, nSize) \
    GetModuleFileNameA(hModule, lpFilename, obfh_int_proxy(nSize))

#define ExitProcess(uExitCode) ExitProcess(obfh_int_proxy(uExitCode))

// Utility functions
#define memmove(dest, src, n) memmove(dest, src, obfh_int_proxy((n) * TRUE))

#define memcpy(dest, src, n) memcpy(dest, src, obfh_int_proxy((n) * TRUE))

// Export function example
__declspec(dllexport) char *WhatSoundDoesACowMake(void) {
    return HIDE_STRING("Moo");
}

#else
#warning Obfuscation disabled!
#endif

#endif // OBFH

// End of obfus.h

```

`include-updater/obfh-update.cmd`:

```cmd
@echo off
call:print "         _       __                 _     "
call:print "   ___  | |__   / _| _   _  ___    | |__  "
call:print "  / _ \ | '_ \ | |_ | | | |/ __|   | '_ \ "
call:print " | (_) || |_) ||  _|| |_| |\__ \ _ | | | |"
call:print "  \___/ |_.__/ |_|   \__,_||___/(_)|_| |_|"

echo.

:: Host and protocol
set "protocol=https"
set "host=github.com:443"

:: Path to file of obfus.h
set "obfus_h_path=DosX-dev/obfus.h/raw/main/include/obfus.h"

:: Save to directory...
:: "\." - current directory (.\obfus.h)
set "output_dir=.\"

:: If error:
::  0 - stop
::  1 - continue (not recommended)
set "onerror=0"

:: Additional cURL options
set "special=--ssl-no-revoke -s"



call :process
set /a process_el=errorlevel

if "%onerror%" == "0" if "%errorlevel%" == "1" ( timeout 1 /nobreak>nul && call:log "STOPPED!" && pause>nul )

exit /b %process_el%

:process
set "curl_path=%windir%\System32\curl.exe"
call:log "Getting the latest version of obfus.h protection from %host%..."

if not exist "%curl_path%" (
    call:log "Missing cURL executable at %curl_path%!"
    exit /b 1
)

call "%curl_path%" -L %special% "%protocol%://%host%/%obfus_h_path%" -o "%output_dir%\obfus.h"

if "%errorlevel%" == "0" (
    call:log "Latest version of protection has been installed."
    exit /b 0
) else (
    call:log "An error occurred while downloading the component package."
    exit /b 1
)
goto :eof

:log
echo [%time%][pkg:obfus.h] %~1
goto :eof

:print
for /f %%a in ('"prompt $H && for %%b in (1) do rem"') do set "bs=%%a"
<nul set/p=".%bs%%~1"
echo.
goto :eof

```

`include/obfus.h`:

```h
/*
         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó
        ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ñà‚ñà‚ïë
        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
        ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
         ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
                  Very reliable armor for your C programs!
                        Coded by (C) DosX, 2025

 [Additional options]
 ~ CFLOW_V2       = more powerful Control Flow obfuscation (slowly!)
 ~ ANTIDEBUG_V2   = use better dynamic anti-debugging protection
 ~ FAKE_SIGNS     = adds fake signatures of various protectors or packers

 [Advanced code protection]
 ~ VIRT           = allows you to use the functions of a math VM

 [Disabling default features]
 ~ NO_CFLOW       = disable control flow obfuscation
 ~ NO_ANTIDEBUG   = disable antidebug protection

 ~ NO_OBF         = disable obfuscation

 GitHub:
 -> https://github.com/DosX-dev/obfus.h

 (Full documentation and examples are available on the GitHub page)
*/

#ifndef OBFH
#define OBFH

#if !__TINYC__ && !__GNUC__ && !__MINGW32__
#define __attribute__(...)
#endif

// if virtualization disabled
#if NO_OBF == 1 || VIRT != 1
#define VM_ADD(num1, num2) num1 + num2
#define VM_SUB(num1, num2) num1 - num2
#define VM_MUL(num1, num2) num1 *num2
#define VM_DIV(num1, num2) num1 / num2
#define VM_MOD(num1, num2) num1 % num2
#define VM_EQU(num1, num2) num1 == num2
#define VM_NEQ(num1, num2) num1 != num2
#define VM_LSS(num1, num2) num1 < num2
#define VM_GTR(num1, num2) num1 > num2
#define VM_LEQ(num1, num2) num1 <= num2
#define VM_GEQ(num1, num2) num1 >= num2
#define VM_ADD_DBL(num1, num2) num1 + num2
#define VM_SUB_DBL(num1, num2) num1 - num2
#define VM_MUL_DBL(num1, num2) num1 *num2
#define VM_DIV_DBL(num1, num2) num1 / num2
#define VM_LSS_DBL(num1, num2) num1 < num2
#define VM_GTR_DBL(num1, num2) num1 > num2
#define VM_IF(condition) if (condition)
#define VM_ELSE_IF(condition) else if (condition)
#define VM_ELSE else
#define VM_OBF_INT(num) num
#define VM_OBF_DBL(num) num
#endif

#if NO_OBF == 1
#define HIDE_STRING(str) str
#define ANTI_DEBUG 0
#endif

#if !NO_OBF

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#if defined _MSC_VER
#warning obfus.h doesn't support Visual C/C++. You can use [obfusheader.h] by ac3ss0r to obfuscate this app (https://github.com/ac3ss0r/obfusheader.h)
#endif

#if !defined __COUNTER__
#error You are using too old a compiler version!
#endif

#ifndef __asm__
#define __asm__(...)
#endif

#define SECTION_ATTRIBUTE(NAME) __attribute__((section(NAME)))

#define DATA_SECTION_ATTRIBUTE SECTION_ATTRIBUTE(".data")  // Data section

// Fake signatures ;)
#if FAKE_SIGNS == 1

static const char FAKE_ENIGMAVM_1[] SECTION_ATTRIBUTE(".enigma1") = {0};
static const char FAKE_ENIGMAVM_2[] SECTION_ATTRIBUTE(".enigma2") = {0};
static const char FAKE_VMPROTECT_1[] SECTION_ATTRIBUTE(".vmp0") = {0};  // (now is open-source)
static const char FAKE_VMPROTECT_2[] SECTION_ATTRIBUTE(".vmp1") = {0};
static const char FAKE_VMPROTECT_3[] SECTION_ATTRIBUTE(".vmp2") = {0};

#define OBFH_SECTION_ATTRIBUTE SECTION_ATTRIBUTE("UPX0")  // OBFH section
static const char FAKE_UPX[] OBFH_SECTION_ATTRIBUTE = {0};

static const char FAKE_THEMIDA[] SECTION_ATTRIBUTE(".winlice") = {0};
static const char FAKE_PETITE[] SECTION_ATTRIBUTE(".petite") = {0};
static const char FAKE_RLP[] SECTION_ATTRIBUTE(".rlp") = {0};
static const char FAKE_SECUROM[] SECTION_ATTRIBUTE(".dsstext") = {0};
static const char FAKE_SQUISHY[] SECTION_ATTRIBUTE("logicoma") = {0};
static const char FAKE_THEARK_1[] SECTION_ATTRIBUTE("adr") = {0};
static const char FAKE_THEARK_2[] SECTION_ATTRIBUTE("have") = {0};
static const char FAKE_THEARK_3[] SECTION_ATTRIBUTE("30cm") = {0};
static const char FAKE_PETETRIS[] SECTION_ATTRIBUTE("PETETRIS") = {0};

static const char FAKE_ENIGMA[] SECTION_ATTRIBUTE(".data") = {0x45, 0x6e, 0x69, 0x67,
                                                              0x6d, 0x61, 0x20, 0x70,
                                                              0x72, 0x6f, 0x74, 0x65,
                                                              0x63, 0x74, 0x6f, 0x72,
                                                              0x20, 0x76, 0x01};

static const char FAKE_ALINYZE[] SECTION_ATTRIBUTE(".alien") = {0};
static const char FAKE_PWDPROTECT[] SECTION_ATTRIBUTE(".pwdprot") = {0};

static const char FAKE_DENUVO[] SECTION_ATTRIBUTE(".arch") = {0x64, 0x65, 0x6E, 0x75,
                                                              0x76, 0x6F, 0x5F, 0x61,
                                                              0x74, 0x64, 0x00, 0x00,
                                                              0x00, 0x00, 0x00, 0x00};

static const char FAKE_NUITKA[] SECTION_ATTRIBUTE(".rdata") = {0x4e, 0x55, 0x49, 0x54,
                                                               0x4b, 0x41, 0x5f, 0x4f,
                                                               0x4e, 0x45, 0x46, 0x49,
                                                               0x4c, 0x45, 0x5f, 0x50,
                                                               0x41, 0x52, 0x45, 0x4e,
                                                               0x54};

static const char FAKE_THEARK_4[] SECTION_ATTRIBUTE(".tw") = {0};
static const char FAKE_THEARK_5[] SECTION_ATTRIBUTE("logicoma") = {0};
static const char FAKE_OREANSVM[] SECTION_ATTRIBUTE(".vlizer") = {0};

static const char FAKE_SCREEN2EXE[] SECTION_ATTRIBUTE(".text") = {0x56, 0x69, 0x64, 0x65,
                                                                  0x6f, 0x20, 0x63, 0x72,
                                                                  0x65, 0x61, 0x74, 0x65,
                                                                  0x64, 0x20, 0x62, 0x79,
                                                                  0x20, 0x53, 0x43, 0x52,
                                                                  0x45, 0x45, 0x4e, 0x32,
                                                                  0x45, 0x58, 0x45, 0x2f,
                                                                  0x53, 0x43, 0x52, 0x45,
                                                                  0x45, 0x4e, 0x32, 0x53,
                                                                  0x57, 0x46};

static const char FAKE_ASPACK_1[] SECTION_ATTRIBUTE(".aspack") = {0};
static const char FAKE_ASPACK_2[] SECTION_ATTRIBUTE(".adata") = {0};
static const char FAKE_WIBUCODEMETER_1[] SECTION_ATTRIBUTE("__wibu00") = {0};
static const char FAKE_WIBUCODEMETER_2[] SECTION_ATTRIBUTE("__wibu01") = {0};
static const char *FAKE_DONGLE[] = {"skeydrv.dll", "HASPDOSDRV",
                                    "MARXDEV1.SYS", "MxLPT_Sem",
                                    "nethasp.ini", "sense4.dll",
                                    "SNTNLUSB", "RNBOspro",
                                    "SSIVDDP.DLL", "WIBUKEY",
                                    "\\\\.\\WIZZKEYRL",
                                    "\\\\.\\NVKEY"};

#else

#define OBFH_SECTION_ATTRIBUTE SECTION_ATTRIBUTE(".obfh")  // OBFH section

#endif

// Thanks to @horsicq && @ac3ss0r
#define RND(min, max) \
    (min + (((__COUNTER__ + (__LINE__ * __LINE__)) * 2654435761u) % (max - min + 1)))

#define STACK_STRING(str) ((char[]){str})

#define HIDE_STRING(str) \
    _0 < RND(1, 255) ? obfh_process_hidden_string(STACK_STRING("\0" str "\0"), (float)__s_rdtsc(RND(0, 255)) != 0.1) : (float)__s_rdtsc(RND(0, 255)) == RND(0, 255)

typedef enum {
    SALT_SHIFT = RND(0xBAD, 0xBEEF)
} VAR_ADDR_SHIFT;

#define RET_BY_VAR(value)                                   \
    {                                                       \
        int _obfh_ret_val_shift = SALT_SHIFT,               \
            *_obfh_ret_val_addr = (&value + SALT_SHIFT);    \
        return *(_obfh_ret_val_addr - _obfh_ret_val_shift); \
    }

volatile static char _s_a[] OBFH_SECTION_ATTRIBUTE = "a", _s_b[] OBFH_SECTION_ATTRIBUTE = "b", _s_c[] OBFH_SECTION_ATTRIBUTE = "c", _s_d[] OBFH_SECTION_ATTRIBUTE = "d",
                            _s_e[] OBFH_SECTION_ATTRIBUTE = "e", _s_f[] OBFH_SECTION_ATTRIBUTE = "f", _s_g[] OBFH_SECTION_ATTRIBUTE = "g", _s_h[] OBFH_SECTION_ATTRIBUTE = "h",
                            _s_i[] OBFH_SECTION_ATTRIBUTE = "i", _s_j[] OBFH_SECTION_ATTRIBUTE = "j", _s_k[] OBFH_SECTION_ATTRIBUTE = "k", _s_l[] OBFH_SECTION_ATTRIBUTE = "l",
                            _s_m[] OBFH_SECTION_ATTRIBUTE = "m", _s_n[] OBFH_SECTION_ATTRIBUTE = "n", _s_o[] OBFH_SECTION_ATTRIBUTE = "o", _s_p[] OBFH_SECTION_ATTRIBUTE = "p",
                            _s_q[] OBFH_SECTION_ATTRIBUTE = "q", _s_r[] OBFH_SECTION_ATTRIBUTE = "r", _s_s[] OBFH_SECTION_ATTRIBUTE = "s", _s_t[] OBFH_SECTION_ATTRIBUTE = "t",
                            _s_u[] OBFH_SECTION_ATTRIBUTE = "u", _s_v[] OBFH_SECTION_ATTRIBUTE = "v", _s_w[] OBFH_SECTION_ATTRIBUTE = "w", _s_x[] OBFH_SECTION_ATTRIBUTE = "x",
                            _s_y[] OBFH_SECTION_ATTRIBUTE = "y", _s_z[] = "z",
                            _a OBFH_SECTION_ATTRIBUTE = 'a', _b OBFH_SECTION_ATTRIBUTE = 'b', _c OBFH_SECTION_ATTRIBUTE = 'c', _d OBFH_SECTION_ATTRIBUTE = 'd',
                            _e OBFH_SECTION_ATTRIBUTE = 'e', _f OBFH_SECTION_ATTRIBUTE = 'f', _g OBFH_SECTION_ATTRIBUTE = 'g', _h OBFH_SECTION_ATTRIBUTE = 'h',
                            _i OBFH_SECTION_ATTRIBUTE = 'i', _j OBFH_SECTION_ATTRIBUTE = 'j', _k OBFH_SECTION_ATTRIBUTE = 'k', _l OBFH_SECTION_ATTRIBUTE = 'l',
                            _m OBFH_SECTION_ATTRIBUTE = 'm', _n OBFH_SECTION_ATTRIBUTE = 'n', _o OBFH_SECTION_ATTRIBUTE = 'o', _p OBFH_SECTION_ATTRIBUTE = 'p',
                            _q OBFH_SECTION_ATTRIBUTE = 'q', _r OBFH_SECTION_ATTRIBUTE = 'r', _s OBFH_SECTION_ATTRIBUTE = 's', _t OBFH_SECTION_ATTRIBUTE = 't',
                            _u OBFH_SECTION_ATTRIBUTE = 'u', _v OBFH_SECTION_ATTRIBUTE = 'v', _w OBFH_SECTION_ATTRIBUTE = 'w', _x OBFH_SECTION_ATTRIBUTE = 'x',
                            _y OBFH_SECTION_ATTRIBUTE = 'y', _z OBFH_SECTION_ATTRIBUTE = 'z',
                            _S OBFH_SECTION_ATTRIBUTE = 'S', _L OBFH_SECTION_ATTRIBUTE = 'L', _A OBFH_SECTION_ATTRIBUTE = 'A', _I OBFH_SECTION_ATTRIBUTE = 'I',
                            _D OBFH_SECTION_ATTRIBUTE = 'D', _P OBFH_SECTION_ATTRIBUTE = 'P',
                            _0 DATA_SECTION_ATTRIBUTE = 0, _1 DATA_SECTION_ATTRIBUTE = 1, _2 DATA_SECTION_ATTRIBUTE = 2, _3 DATA_SECTION_ATTRIBUTE = 3, _4 DATA_SECTION_ATTRIBUTE = 4,
                            _5 DATA_SECTION_ATTRIBUTE = 5, _6 DATA_SECTION_ATTRIBUTE = 6, _7 DATA_SECTION_ATTRIBUTE = 7, _8 DATA_SECTION_ATTRIBUTE = 8, _9 DATA_SECTION_ATTRIBUTE = 9;

#define __obfh_asm__(...) __asm__ __volatile(__VA_ARGS__)

#define BREAK_STACK_1      \
    __obfh_asm__(          \
        "xorl %eax, %eax;" \
        "jz 1f;"           \
        ".byte 0xE8;"      \
        "1:"               \
        "cpuid;")

#define BREAK_STACK_2 \
    if (_0) __obfh_asm__(".byte 0x00;")

#define BREAK_STACK_3                          \
    switch (_0) {                              \
        case RND(1, 1000):                     \
            __obfh_asm__(".byte 0x00, 0x00;"); \
    }

#define BREAK_STACK_4      \
    __obfh_asm__(          \
        "xorl %ebx, %ebx;" \
        "xorl %edx, %edx;" \
        "xorl %ebx, %edx;" \
        "jz 1f;"           \
        "mov $4, %eax;"    \
        ".byte 0x00;"      \
        "1:"               \
        "cpuid;")

#define BREAK_STACK_5      \
    __obfh_asm__(          \
        "xorl %ebx, %ebx;" \
        "xorl %eax, %eax;" \
        "mov %eax, %ebx;"  \
        "mov %edx, %ebx;"  \
        "xorl %eax, %edx;" \
        "jz 1f;"           \
        ".byte 0x20;"      \
        "1:"               \
        "cpuid;")

#define BREAK_STACK_6      \
    __obfh_asm__(          \
        "xorl %edx, %edx;" \
        "xorl %eax, %eax;" \
        "mov %eax, %edx;"  \
        "jz 1f;"           \
        ".byte 0xE8;"      \
        "1:"               \
        "cpuid;")

#define BREAK_STACK_7      \
    __obfh_asm__(          \
        "xorl %edx, %edx;" \
        "jz 1f;"           \
        ".byte 0xE8;"      \
        "1:"               \
        "cpuid;")

#define BREAK_STACK_8      \
    __obfh_asm__(          \
        "xorl %eax, %eax;" \
        "jz 1f;"           \
        ".byte 0x50;"      \
        "1:"               \
        "cpuid;")

#define BREAK_STACK_9       \
    __obfh_asm__(           \
        "xorl %edx, %edx;"  \
        "jz 1f;"            \
        ".byte 0x00, 0x00;" \
        "1:"                \
        "cpuid;")

#if defined(__x86_64__)
#define BAD_JMP __obfh_asm__("cpuid; mov %eax, %rax; mov %ebx, %edx; .byte 0xFF, 0x25, 0xF1, 0xF2, 0xF3, 0xF4;")
#else
#define BAD_JMP __obfh_asm__(".byte 0xEB, 0xE1;")
#endif

#define BAD_CALL __obfh_asm__(".byte 0xB8;")

void obfh_junk_func_args(int z, ...) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    __obfh_asm__("nop;");
    return;
}

void obfh_junk_func() DATA_SECTION_ATTRIBUTE {
    BREAK_STACK_5;
    __obfh_asm__("nop;");
    return;
}

#define __CRASH       \
    __obfh_asm__(     \
        ".byte 0xED;" \
        "int $3;");   \
    exit(1);

#define TRUE ((((_9 + _7 + (RND(0, 1000) * _0))) / _8) - _1)
#define FALSE (((_3 + _6 + (RND(0, 1000) * _0)) - _9) * RND(0, 255))

#define FAKE_CPUID __obfh_asm__( \
    "nop;"                       \
    "cpuid;"                     \
    "nop;")

#define NOP_FLOOD                                  \
    (RND(0, 1000)) + obfh_int_proxy(RND(0, 1000)); \
    if (obfh_junk_func_args) {                     \
        __obfh_asm__("nop;");                      \
    }                                              \
    do {                                           \
        __obfh_asm__(                              \
            "nop;"                                 \
            "nop;");                               \
    } while (RND(0, 200) * _0)

int malloc_proxy(int *size) {
    BREAK_STACK_1;
    return malloc(size);
}
#define malloc(...) malloc_proxy(__VA_ARGS__)

static float rndValueToProxy = RND(0, 10);

int obfh_int_proxy(int value) OBFH_SECTION_ATTRIBUTE {
    RET_BY_VAR(value);
}

double obfh_double_proxy(double value) OBFH_SECTION_ATTRIBUTE {
    RET_BY_VAR(value);
}

float obfh_condition_true();

// ... only for junk data
char *obfh_process_hidden_string(char *string, ...) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;

    if (!obfh_condition_true() || _0) {
        BAD_JMP;
    }

    // ['\0', 's', 't', 'r', 'i', 'n', 'g'] => "string"
    char string_to_return[4096];
    strcpy(string_to_return, string + 1);
    return string_to_return;
}

float obfh_condition_true() OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return _1 && TRUE;
}

int obfh_condition_proxy(float junk, float condition, ...) OBFH_SECTION_ATTRIBUTE {
    RET_BY_VAR(condition);
}

unsigned long double __s_rdtsc(float junk, ...) OBFH_SECTION_ATTRIBUTE {
    {
        unsigned int lo, hi;
        __obfh_asm__(".byte 0x0f, 0x31;"  // rdtsc
                     : "=a"(lo), "=d"(hi));

        unsigned long long rdtsc_result = ((unsigned long long)hi << 32) | lo;

        if (rdtsc_result == obfh_int_proxy(0)) __obfh_asm__(".byte 0xE8;");
    }

    unsigned long long time;
    unsigned int low, high;
    __obfh_asm__(".byte 0x0f, 0xc7, 0xf8;"  // rdtscp
                 : "=a"(low), "=d"(high));
    time = ((unsigned long long)high << 32) | low;
    return time;
}

// =============================================================
// Control Flow (global)
#if NO_CFLOW != 1

// if
#define if(cond)                                                                         \
    if ((float)__s_rdtsc(RND(0, 255)) == (float)((RND(1, 255) * -1)) * (float)1.0) {     \
        BAD_CALL;                                                                        \
    } else if (&__s_rdtsc && (cond ? ((float)__s_rdtsc(RND(0, 255), RND(0, 255)) != 0.1) \
                                   : (float)__s_rdtsc(RND(0, 255)) == 0.1))

// else
#define else      \
    else if (0) { \
        BAD_CALL; \
    }             \
    else

#if CFLOW_V2
#define OBFUS_CONDITION_BLOCK(...) (obfh_condition_proxy(RND(0, 255), (__VA_ARGS__) ? !!obfh_int_proxy(!!obfh_condition_true()) : !!!obfh_condition_true(), RND(0, 255)) ? !!obfh_condition_true() : obfh_int_proxy(!obfh_condition_true()))
#else
#define OBFUS_CONDITION_BLOCK(...) (obfh_condition_proxy(RND(0, 255), (__VA_ARGS__), RND(0, 255)) ? !!obfh_condition_true() : !obfh_condition_true())
#endif

// break
#define break                                                  \
    {                                                          \
        if (OBFUS_CONDITION_BLOCK(RND(1, 255))) BREAK_STACK_1; \
        break;                                                 \
    }

// switch
#define switch(...)                         \
    if (OBFUS_CONDITION_BLOCK(RND(1, 255))) \
        switch (__VA_ARGS__)

// while
#define while(...) while ((float)__s_rdtsc(RND(0, 255)) != 0.1 && (&__s_rdtsc != !&__s_rdtsc) && (__VA_ARGS__))

// for
#define for(...)                            \
    if (OBFUS_CONDITION_BLOCK(RND(1, 255))) \
        for (__VA_ARGS__)

#endif
// =============================================================

// =============================================================
// Virtualization (global)
#if VIRT == 1
typedef enum {
    OP__ADD = RND(0, 900) * __COUNTER__ * 5,
    OP__SUB = RND(1000, 1900) * __COUNTER__ * 5,
    OP__MUL = RND(2000, 2900) * __COUNTER__ * 5,
    OP__DIV = RND(3000, 3900) * __COUNTER__ * 5,
    OP__MOD = RND(4000, 4900) * __COUNTER__ * 5,
    OP__EQU = RND(5000, 5900) * __COUNTER__ * 5,
    OP__NEQ = RND(6000, 6900) * __COUNTER__ * 5,
    OP__GTR = RND(7000, 7900) * __COUNTER__ * 5,
    OP__LSS = RND(8000, 8900) * __COUNTER__ * 5,
    OP__LEQ = RND(9000, 9900) * __COUNTER__ * 5,
    OP__GEQ = RND(10000, 10900) * __COUNTER__ * 5,
    OP__NOP = RND(11000, 11900) * __COUNTER__ * 5
} CMD;

typedef enum {
    SALT_CMD = RND(100, 900),
    SALT_NUM1 = RND(16, 48),
    SALT_NUM2 = RND(16, 48)
} VM_SALT;

static int _salt = SALT_CMD;

#define _VM_DEMUTATOR_KEY (__COUNTER__) / 5
#define _VM_MUTATOR_KEY (__COUNTER__ - 1) / 5

#define _VM_ENCRYPT_INT(value) ((value - _VM_MUTATOR_KEY) * ~SALT_CMD)
#define _ENC_OP__ADD _VM_ENCRYPT_INT(OP__ADD)
#define _ENC_OP__SUB _VM_ENCRYPT_INT(OP__SUB)
#define _ENC_OP__MUL _VM_ENCRYPT_INT(OP__MUL)
#define _ENC_OP__DIV _VM_ENCRYPT_INT(OP__DIV)
#define _ENC_OP__MOD _VM_ENCRYPT_INT(OP__MOD)
#define _ENC_OP__EQU _VM_ENCRYPT_INT(OP__EQU)
#define _ENC_OP__NEQ _VM_ENCRYPT_INT(OP__NEQ)
#define _ENC_OP__GTR _VM_ENCRYPT_INT(OP__GTR)
#define _ENC_OP__LSS _VM_ENCRYPT_INT(OP__LSS)
#define _ENC_OP__LEQ _VM_ENCRYPT_INT(OP__LEQ)
#define _ENC_OP__GEQ _VM_ENCRYPT_INT(OP__GEQ)
#define _ENC_OP__NOP _VM_ENCRYPT_INT(OP__NOP)

#define VM_ADD(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__ADD, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_SUB(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__SUB, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_MUL(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__MUL, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_DIV(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__DIV, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_MOD(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__MOD, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_EQU(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__EQU, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_NEQ(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__NEQ, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_LSS(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__LSS, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_GTR(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__GTR, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_LEQ(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__LEQ, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_GEQ(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__GEQ, (num1) * -1 + SALT_NUM1, RND(1, 500), (num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_OBF_INT(num1) (VM_MUL(RND(1, 999), 0) ? RND(1, 9999) : (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__NOP, (num1) * -1 + SALT_NUM1, RND(1, 500), RND(1, 99999999) * -1 + SALT_NUM2, RND(1, 500)))

#define VM_ADD_DBL(num1, num2) Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__ADD, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_SUB_DBL(num1, num2) Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__SUB, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_MUL_DBL(num1, num2) Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__MUL, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_DIV_DBL(num1, num2) Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__DIV, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_LSS_DBL(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__LSS, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_GTR_DBL(num1, num2) (long)Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__GTR, (double)(num1) * -1 + SALT_NUM1, RND(1, 500), (double)(num2) * -1 + SALT_NUM2, RND(1, 500))
#define VM_OBF_DBL(num1) (VM_MUL(RND(1, 999), 0) ? RND(1, 9999) : Obfh_VirtualMachine(_VM_DEMUTATOR_KEY, _ENC_OP__NOP, (num1) * -1 + SALT_NUM1, RND(1, 500), RND(1, 99999999) * -1 + SALT_NUM2, RND(1, 500)))

#define VM_IF(condition) if (!VM_EQU((int)(condition), VM_MUL(RND(111111, 999999), 0)))
#define VM_ELSE_IF(condition) else if (!VM_EQU((int)(condition), VM_MUL(0, RND(111111, 999999))))
#define VM_ELSE else if (VM_EQU(1, _1))

long double obfhVmResult = 0;
long double Obfh_VirtualMachine(long double uni_key, int command, long double num1, long double junk_2, long double num2, long double junk_3) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    goto firstFakePoint;

    // Restore values
restoreCommand:
    BREAK_STACK_1;
    command /= ~_salt;
    command += uni_key;
    goto restoreNum2;

restoreNum1:
    BREAK_STACK_1;
    num1 -= SALT_NUM1;
    num1 *= (-1 * _1);
    goto letsExecute;

restoreNum2:
    BREAK_STACK_1;
    num2 -= SALT_NUM2;
    num2 *= (-1 * _1);
    goto restoreNum1;

firstFakePoint:
    BREAK_STACK_2;
    goto secondFakePoint;

letsExecute:

    switch (command) {
        case -1 * __LINE__:
            goto restoreCommand;
        case -2 * __LINE__:
            goto firstFakePoint;
        case -3 * __LINE__:
            return _0 * ~_1 + junk_2;
        case -4 * __LINE__:
            goto restoreNum2;
        case -5 * __LINE__:
            goto restoreNum1;
        case -6 * __LINE__:
            __obfh_asm__(".byte 0xFF, 0x25;");  // fake JMP
        case -7 * __LINE__:

#if defined(__x86_64__) || defined(_M_X64)  // fake code, just for decompiler break
            __obfh_asm__(
                "mov %%rax, %%rbx;"
                "xor %%rcx, %%rax;"
                "shr $8, %%rdx;"
                "shl $4, %%rax;"
                "push %%rbx;"
                "pop %%rbx;"
                "inc %%rax;"
                "dec %%rdx;"
                :
                :
                : "rax",
                  "rbx", "rcx", "rdx");
#elif defined(__i386__) || defined(_M_IX86)
            __obfh_asm__(
                "mov %%ebx, %%eax;"
                "add %%ecx, %%eax;"
                "sub %%edx, %%ebx;"
                "shl %%cl, %%ecx;"
                "push %%ebx;"
                "pop %%ebx;"
                "sar %%cl, %%ecx;"
                "or %%edx, %%eax;"
                "dec %%edx;"
                :
                :
                : "eax",
                  "ebx", "ecx", "edx");
#else
#endif
        case -8 * __LINE__:
            BAD_JMP;

        case OP__ADD:  // plus
            obfhVmResult = (num1 + num2) + VM_MUL(junk_3, _0);
            goto afterCalc;
        case OP__SUB:  // minus
            obfhVmResult = (num1 - num2) + VM_MUL(junk_3, _0);
            goto afterCalc;
        case OP__MUL:  // multiply
            if (num1 == _0 || num2 == _0)
                obfhVmResult = _0;
            else
                return num1 * num2;

            goto afterCalc;
        case OP__DIV:  // divide
            if (num2 != _0)
                obfhVmResult = num1 / num2;
            else
                obfhVmResult = VM_ADD(_0, _0);
            goto afterCalc;
        case OP__MOD:  // modulo
            if (num2 != 0)
                obfhVmResult = (int)num1 % (int)num2;
            else
                obfhVmResult = _0;
            goto afterCalc;
        case OP__EQU:            // equal
            if (num1 == num2) {  // 1 + 0 = 1
                obfhVmResult = VM_ADD(_1, _0);
            } else {
                obfhVmResult = _0;
            }
            goto afterCalc;
        case OP__NEQ:            // not equal
            if (num1 != num2) {  // 1 + 0 = 1
                obfhVmResult = VM_ADD(_0, _1) + VM_MUL(junk_2, _0);
            } else {
                obfhVmResult = VM_MUL(junk_3, _0);
            }
            goto afterCalc;
        case OP__LSS:
            obfhVmResult = num1 != num2 && !(num1 + VM_MUL(junk_2, _0) > num2);
            goto afterCalc;
        case OP__GTR:
            obfhVmResult = num1 != num2 && !(num1 + VM_MUL(junk_2, _0) < num2);
            goto afterCalc;
        case OP__LEQ:
            obfhVmResult = !(num1 + VM_MUL(junk_2, _0) > num2);
            goto afterCalc;
        case OP__GEQ:
            obfhVmResult = (num1 + VM_MUL(junk_2, _0) > num2) || (num1 == num2);
            // result = num1 >= num2;
            goto afterCalc;
        case OP__NOP:
            obfhVmResult = num1;
            goto afterCalc;
        default:
            // printf("ADD: %d, CMD: %d\n", OP__ADD, command);
            obfhVmResult = _0 * (uni_key * _3);
            BAD_JMP;
    }
    BREAK_STACK_8;

    long double result = uni_key;
afterCalc:

    goto saveValueToLocal;
resetResult:
    obfhVmResult = 0;
    goto returnValue;
saveValueToLocal:
    result = obfhVmResult;
    goto resetResult;

returnValue:
    return result;

    __obfh_asm__(".byte 0xFF, 0xE0;");  // fake JMP EAX

secondFakePoint:
    BREAK_STACK_7;
    goto restoreCommand;
}
#endif
// =============================================================

char *getCharMask(int count) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    static char mask[16];
    if (count <= _0 || count >= sizeof(mask)) {
        BAD_JMP;
    }
    int i = (((_1 * _5) - _4) + _1) - _2;
    BREAK_STACK_1;
    char *ptr = mask;
    for (i = _0; i < count; i++) {
        *ptr++ = '%';
        *ptr++ = _c;
    }
    *ptr = '\0';

    BREAK_STACK_8;

    FAKE_CPUID;

    return mask;
}

// WriteConsoleA
BOOL WriteConsoleA_proxy(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    FAKE_CPUID;
    return WriteConsoleA(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
}
#define WriteConsoleA(...) WriteConsoleA_proxy(__VA_ARGS__)

// GetStdHandle
HANDLE GetStdHandle_proxy(DWORD nStdHandle) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    FAKE_CPUID;
    return GetStdHandle(obfh_int_proxy(nStdHandle));
}
#define GetStdHandle(...) GetStdHandle_proxy(__VA_ARGS__)

HMODULE GetModuleHandleA_proxy(LPCSTR lpModuleName) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_9;
    FAKE_CPUID;
    return GetModuleHandleA(lpModuleName);
}
#define GetModuleHandleA(...) GetModuleHandleA_proxy(__VA_ARGS__)

// strcmp
int strcmp_custom(const char *str1, const char *str2) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    while (*str1 != '\0' || *str2 != '\0') {
        NOP_FLOOD;
        if ((obfh_int_proxy(*str1) < obfh_int_proxy(*str2)) && obfh_int_proxy(_1)) {
            return (obfh_int_proxy(_2) / _2) * -1;  // -1
        } else if (obfh_int_proxy(*str1) > obfh_int_proxy(*str2)) {
            return obfh_int_proxy(_0 + _1);  // 1
        }
        str1 += obfh_int_proxy(_1);
        str2 += obfh_int_proxy(_2 - _1);
    }
    FAKE_CPUID;
    return _0;
}
#define strcmp(...) strcmp_custom(__VA_ARGS__)

// strlen
size_t strlen_custom(const char *str) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    size_t length = _0;
    while (*str != '\0') {
        length += obfh_int_proxy(_1);
        str += obfh_int_proxy(_2 - _1);
    }
    FAKE_CPUID;
    return obfh_int_proxy(length + (RND(0, 1000) * _0));
}
#define strlen(...) strlen_custom(__VA_ARGS__)

// GetProcAddress
FARPROC GetProcAddress_custom(HMODULE hModule, LPCSTR lpProcName) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_2;
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;
    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE *)hModule + dosHeader->e_lfanew);
    BREAK_STACK_1;
    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE *)hModule +
                                                                        ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    obfh_junk_func_args(RND(0, 885));
    BREAK_STACK_1;
    DWORD *addressOfFunctions = (DWORD *)((BYTE *)hModule + exportDirectory->AddressOfFunctions);
    WORD *addressOfNameOrdinals = (WORD *)((BYTE *)hModule + exportDirectory->AddressOfNameOrdinals);
    BREAK_STACK_1;
    DWORD *addressOfNames = (DWORD *)((BYTE *)hModule + exportDirectory->AddressOfNames);

    for (DWORD i = 0; i < exportDirectory->NumberOfNames; ++i) {
        if (strcmp(lpProcName, (const char *)hModule + addressOfNames[i]) == 0) {
            BREAK_STACK_2;
            return (FARPROC)((BYTE *)hModule + addressOfFunctions[addressOfNameOrdinals[i]]);
        }
    }
    BREAK_STACK_1;
    return NULL;
}
#define GetProcAddress(...) GetProcAddress_custom(__VA_ARGS__)

static char loadStr[5];
static HMODULE hKernel32 = NULL;

HMODULE LoadLibraryA_0(LPCSTR lpLibFileName) OBFH_SECTION_ATTRIBUTE {
    switch (_0) {
        case 1:
            __obfh_asm__(".byte 0x74;");  // fake JE

            break;
        case 0:
            BREAK_STACK_3;
            // return LoadLibraryA(lpLibFileName);

            typedef HMODULE(WINAPI * LoadLibraryAFunc)(LPCSTR);
            static LoadLibraryAFunc loadLibraryA = NULL;
            if (loadLibraryA == NULL) {
                char libName[32];

                // kernel32
                sprintf(libName, strcat(getCharMask(_6), "%d"), _k, _e, _r, _n, _e, _l, (_4 * _8));

                hKernel32 = GetModuleHandleA(libName);

                if (hKernel32 != NULL) {
                    FAKE_CPUID;
                    char _L_char = _L;
                    obfh_junk_func_args(_0 + RND(1, 5));

                    if (loadStr[_3] != obfh_int_proxy(_d)) {  // restore "Load"
                        loadStr[_4] = obfh_int_proxy(_0);
                        loadStr[_3] = obfh_int_proxy(_d);
                        loadStr[_2] = obfh_int_proxy(_a);
                        BREAK_STACK_2;
                        loadStr[_1] = obfh_int_proxy(_o);
                        loadStr[_0] = obfh_int_proxy(_L);
                    }

                    char *funcName = malloc(32);

                    FAKE_CPUID;

                    sprintf(funcName, strcat("Library", "%c"), _A);  // _A = LoadLibrary{'A'}
                    loadLibraryA = (LoadLibraryAFunc)GetProcAddress(hKernel32, strcat(loadStr, funcName));
                    free(funcName);

#if MEM_CLEANER__JUST_FOR_FUN
                    int *value = _1 * -1;
                    SetProcessWorkingSetSize(GetCurrentProcess(), value, value);
#endif
                }
            }
            if (loadLibraryA != NULL) {
                BREAK_STACK_1;
                return loadLibraryA(lpLibFileName);
            }
            return NULL;
    }
}

char *LoadLibraryA_1(LPCSTR lpLibFileName) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_6;
    return LoadLibraryA_0((LPCSTR)lpLibFileName);
}

char *LoadLibraryA_2(LPCSTR lpLibFileName) {
    BREAK_STACK_5;
    return LoadLibraryA_1((LPCSTR)lpLibFileName);
}

char *LoadLibraryA_3(LPCSTR lpLibFileName) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_4;
    return LoadLibraryA_2((LPCSTR)lpLibFileName);
}

char *LoadLibraryA_4(LPCSTR lpLibFileName) {
    BREAK_STACK_3;
    return LoadLibraryA_3((LPCSTR)lpLibFileName);
}

char *LoadLibraryA_5(LPCSTR lpLibFileName) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_2;
    return LoadLibraryA_4((LPCSTR)lpLibFileName);
}

char *LoadLibraryA_proxy(LPCSTR lpLibFileName) {
    BREAK_STACK_1;
    return LoadLibraryA_5((LPCSTR)lpLibFileName);
}
#define LoadLibraryA(...) LoadLibraryA_proxy(__VA_ARGS__)

// =============================================================
// Anti-Debug (global)
#if NO_ANTIDEBUG != 1

#if ANTIDEBUG_V2 == 1  // for ANTIDEBUG_V2
void ad_ZeroDRs(PCONTEXT pCtx) {
    BREAK_STACK_1;
    pCtx->Dr0 = _0;
    pCtx->Dr1 = _0;
    pCtx->Dr2 = _0;
    pCtx->Dr3 = _0;
    pCtx->Dr6 = _0;
    pCtx->Dr7 = _0;
}

int ad_CompareDRs(PCONTEXT pCtx) {
    BREAK_STACK_1;
    if (pCtx->Dr7 != _0) {
        ad_ZeroDRs(pCtx);
        return _1;
    } else {
        // ensure DR0 - DR3 contain zeros even if they are disabled.
        // Skip DR6.  It seems to change erratically, but it's output-only.
        if (_0 == (pCtx->Dr0 | pCtx->Dr1 | pCtx->Dr2 | pCtx->Dr3)) {
            ad_ZeroDRs(pCtx);
        }
        // zero any active debug registers to erase breakpoints.
        // the caller is responsible for ensuring the DR values set are
        // actually applied.
        ad_ZeroDRs(pCtx);
    }
    return _0;
}

WINAPI ThreadCompareDRs(void *p) {
    BREAK_STACK_1;
    DWORD dwRet = _0;
    HANDLE hMainThread = (HANDLE)p;
    if (-1 != SuspendThread(hMainThread)) {
        BREAK_STACK_2;
        CONTEXT context;
        context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
        if (GetThreadContext(hMainThread, &context)) {
            if (ad_CompareDRs(&context))
                dwRet = _1;
        }
        ResumeThread(hMainThread);
    }
    CloseHandle(hMainThread);
    return dwRet;
}
#endif

int IsDebuggerPresent_proxy() OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    NOP_FLOOD;
    BREAK_STACK_2;
#if ANTIDEBUG_V2 == 1

    // Registers validation
    HANDLE hMainThread;
    DWORD dwDummy, exitCode;

    DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(),
                    &hMainThread, _0, FALSE, DUPLICATE_SAME_ACCESS);

    HANDLE hThread = CreateThread(NULL, _0, ThreadCompareDRs, hMainThread, _0, &dwDummy);
    if (hThread) {
        WaitForSingleObject(hThread, INFINITE);
        GetExitCodeThread(hThread, &exitCode);
        CloseHandle(hThread);
    }

    if (exitCode) return exitCode;

    // Dynamic antidebugger
    char result[32];
    sprintf(result, strcat(getCharMask(_6), "%d"), _k, _e, _r, _n, _e, _l, (_6 * _6 - _4));

    char funcName[18];
    funcName[_9 + _8] = _0;

    funcName[_9 + _7 * _1] = _t;
    funcName[_2 + _5 * _1] = _g;
    funcName[_0 * _8 * _1] = _I;
    funcName[_1 + _0 * _1] = _s;
    funcName[_7 * _2 * _1] = _e;
    funcName[_3 * _3 * _1] = _r;
    funcName[_9 + _4 * _1] = _s;
    funcName[_5 * _3 * _1] = _n;
    BREAK_STACK_3;
    funcName[_1 + _1 * _1] = _D;
    funcName[_1 + _2 * _1] = _e;
    funcName[_5 * _2 * _1] = _P;
    funcName[_2 + _2 * _1] = _b;
    funcName[_3 + _2 * _1] = _u;
    funcName[_4 * _2 * _1] = _e;
    funcName[_2 + _9 * _1] = _r;
    funcName[_3 * _2 * _1] = _g;
    funcName[_6 * _2 * _1] = _e;

    return ((BOOL(*)())GetProcAddress(LoadLibraryA(result), funcName))();
#else

    // Standard antidebugger
    NOP_FLOOD;
    return IsDebuggerPresent();

#endif
}
// =============================================================

/*
void antiDebugMessage() {
typedef int(WINAPI * MessageBoxAType)(HWND, LPCSTR, LPCSTR, UINT);
MessageBoxAType MessageBoxA = (MessageBoxAType)GetProcAddress(LoadLibraryA("user32.dll"), "MessageBoxA");
if (MessageBoxA != NULL) MessageBoxA(NULL, "Debugging prevented.", "", 0x10);
}
*/

void crash() {
    BREAK_STACK_1;
    __obfh_asm__(
        "int $3;"
        ".byte 0xED, 0x00;");
}

void loop() {
    while (1) {
    }
}

#define ANTI_DEBUG                                                                                      \
    if (IsDebuggerPresent() || obfh_int_proxy(_0 / !IsDebuggerPresent_proxy() * (_1 + _0 + _1) / _2)) { \
        obfh_double_proxy(RND(1, 999));                                                                 \
        /* antiDebugMessage(); */                                                                       \
        loop();                                                                                         \
        while (1) {                                                                                     \
        };                                                                                              \
        __obfh_asm__(".byte 0xED;");                                                                    \
        BREAK_STACK_1;                                                                                  \
        __obfh_asm__(".byte 0x66, 0xC1, 0xE8, 0x05;");                                                  \
        __obfh_asm__(".byte 0x00;");                                                                    \
        __obfh_asm__("ret;");                                                                           \
        crash();                                                                                        \
    } else {                                                                                            \
        0.0 / !IsDebuggerPresent();                                                                     \
    };

#else
#define ANTI_DEBUG 0
#endif

char *getStdLibName_proxy() {
    BREAK_STACK_7;
    return HIDE_STRING("msvcrt");
}

// printf
void printf_custom(int junk, const char *format, ...) {
    BREAK_STACK_1;
    char buffer[1024];
    va_list args;
    NOP_FLOOD;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    HANDLE hConsole = obfh_int_proxy(GetStdHandle(obfh_int_proxy(STD_OUTPUT_HANDLE)));
    obfh_junk_func_args(RND(0, 1000) * (int)hConsole + junk);
    WriteConsoleA(hConsole, buffer, strlen(buffer), NULL, NULL);
}

// printf as void
#define printf(...)                                   \
    do {                                              \
        BREAK_STACK_1;                                \
        obfh_junk_func_args((RND(0, 1000) * 3) < _0); \
        printf_custom(RND(0, 1000), __VA_ARGS__);     \
    } while (_0 > (RND(0, 100000000000) * _2) + 82)

// scanf
char *getScanfName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "scanf";
    // return ({ char result[32]; sprintf(result, getCharMask(_5), _s, _c, _a, _n, _f); result; });
}
#define scanf(...) ((void *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getScanfName_proxy()))(__VA_ARGS__)

// sprintf
char *getSprintfName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "sprintf";
    // return ({ char result[32]; sprintf(result, getCharMask(_7), _s, _p, _r, _i, _n, _t, _f); result; });
}
#define sprintf(...) ((void *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getSprintfName_proxy()))(__VA_ARGS__)

// fclose
char *getFcloseName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "fclose";
    // return ({ char result[32]; sprintf(result, getCharMask(_6), _f, _c, _l, _o, _s, _e); result; });
}
#define fclose(...) ((void *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getFcloseName_proxy()))(__VA_ARGS__)

// fopen
char *getFopenName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "fopen";
    // return ({ char result[32]; sprintf(result, getCharMask(_5), _f, _o, _p, _e, _n); result; });
}
#define fopen(...) ((FILE * (*)()) GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getFopenName_proxy()))(__VA_ARGS__)

// fread
char *getFreadName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "fread";
    // return ({ char result[32]; sprintf(result, getCharMask(_5), _f, _r, _e, _a, _d); result; });
}
#define fread(...) ((size_t(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getFreadName_proxy()))(__VA_ARGS__)

// fwrite
char *getFwriteName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "fwrite";
    // return ({ char result[32]; sprintf(result, getCharMask(_6), _f, _w, _r, _i, _t, _e); result; });
}
#define fwrite(...) ((size_t(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getFwriteName_proxy()))(__VA_ARGS__)

// exit
char *getExitName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "exit";
    // return ({ char result[32]; sprintf(result, getCharMask(_4), _e, _x, _i, _t); result; });
}
#define exit(...) ((size_t(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getExitName_proxy()))(__VA_ARGS__)

// strcpy
char *getStrcpyName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "strcpy";
    // return ({ char result[32]; sprintf(result, getCharMask(_6), _s, _t, _r, _c, _p, _y); result; });
}
#define strcpy(...) ((char *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getStrcpyName_proxy()))(__VA_ARGS__)

// strtok
char *getStrtokName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "strtok";
    // return ({ char result[32]; sprintf(result, getCharMask(_6), _s, _t, _r, _t, _o, _k); result; });
}
#define strtok(...) ((char *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getStrtokName_proxy()))(__VA_ARGS__)

// memset
void *memset_proxy(void *ptr, int value, size_t num) {
    BREAK_STACK_1;
    return memset(ptr, value * _1, num);
}
#define memset(...) memset_proxy(__VA_ARGS__)

// memcpy
char *getMemcpyName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "memcpy";
    // return ({ char result[32]; sprintf(result, getCharMask(_6), _m, _e, _m, _c, _p, _y); result; });
}
#define memcpy(...) ((void *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getMemcpyName_proxy()))(__VA_ARGS__)

// strchr
char *getStrchrName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "strchr";
    // return ({ char result[32]; sprintf(result, getCharMask(_6), _s, _t, _r, _c, _h, _r); result; });
}
#define strchr(...) ((char *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getStrchrName_proxy()))(__VA_ARGS__)

// strrchr
char *getStrrchrName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "strrchr";
    // return ({ char result[32]; sprintf(result, getCharMask(_7), _s, _t, _r, _r, _c, _h, _r); result; });
}
#define strrchr(...) ((char *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getStrrchrName_proxy()))(__VA_ARGS__)

// rand
char *getRandName_proxy() {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "rand";
    // return ({ char result[32]; sprintf(result, getCharMask(_4), _r, _a, _n, _d); result; });
}
#define rand(...) ((int (*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getRandName_proxy()))(__VA_ARGS__)

// realloc
char *getReallocName_proxy() OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    FAKE_CPUID;
    return "realloc";
}
#define realloc(...) ((void *(*)())GetProcAddress(LoadLibraryA_proxy(getStdLibName_proxy()), getReallocName_proxy()))(__VA_ARGS__)

void *calloc_proxy(size_t nmemb, size_t size) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return calloc(nmemb, size);
}
#define calloc(nmemb, size) calloc_proxy(nmemb, size)

void *realloc_proxy(void *ptr, size_t size) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return realloc(ptr, size);
}
#define realloc(ptr, size) realloc_proxy(ptr, size)

char *gets_proxy(char *s) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return gets(s);
}
#define gets(s) gets_proxy(s)

int snprintf_proxy(char *str, size_t size, const char *format, ...) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    va_list args;
    va_start(args, format);
    int result = vsnprintf(str, size, format, args);
    va_end(args);
    return result;
}
#define snprintf(str, size, format, ...) snprintf_proxy(str, size, format, __VA_ARGS__)

/*
#define printf(...) (([](...) -> int {                                                                        \
static void (*printf_proxy)(const char *, ...) = NULL;                                                    \
if (printf_proxy == NULL) {                                                                               \
printf_proxy = (void (*)(const char *, ...))GetProcAddress(GetModuleHandleA("msvcrt.dll"), "printf"); \
}                                                                                                         \
return printf_proxy(__VA_ARGS__);                                                                         \
})(__VA_ARGS__))
*/

int vsprintf_proxy(char *str, const char *format, va_list args) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return vsprintf(str, format, args);
}
#define vsprintf(str, format, args) vsprintf_proxy(str, format, args)

int vsnprintf_proxy(char *str, size_t size, const char *format, va_list args) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return vsnprintf(str, size, format, args);
}
#define vsnprintf(str, size, format, args) vsnprintf_proxy(str, size, format, args)

char *getenv_proxy(const char *name) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return getenv(name);
}
#define getenv(name) getenv_proxy(name)

int system_proxy(const char *command) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return system(command);
}
#define system(command) system_proxy(command)

void abort_proxy(void) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    abort();
}
#define abort() abort_proxy()

int atexit_proxy(void (*func)(void)) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return atexit(func);
}
#define atexit(func) atexit_proxy(func)

char *getcwd_proxy(char *buf, size_t size) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return getcwd(buf, size);
}
#define getcwd(buf, size) ((char *)getcwd_proxy(buf, size))

int tolower_proxy(int c) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return tolower(c);
}
#define tolower(c) tolower_proxy(c)

int toupper_proxy(int c) OBFH_SECTION_ATTRIBUTE {
    BREAK_STACK_1;
    return toupper(c);
}
#define toupper(c) toupper_proxy(c)

// getch, _getch
#define _getch() obfh_int_proxy(_getch() * TRUE)
#define getch() obfh_int_proxy(getch() + FALSE)

#define Sleep(x) Sleep(obfh_int_proxy((_8 - (_4 * obfh_int_proxy(_2))) + x * TRUE))

#define GetParent(hWnd) \
    GetParent(obfh_int_proxy(((int)hWnd) + (int)hWnd) / _2)

#define GetWindowRect(hWnd, lpRect) \
    GetWindowRect(obfh_int_proxy((int)hWnd *TRUE), obfh_int_proxy((int)lpRect *TRUE))

#define GetClientRect(hWnd, lpRect) \
    GetClientRect(obfh_int_proxy((int)hWnd *TRUE), obfh_int_proxy((int)lpRect *TRUE))

#define SetWindowPos(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags) \
    SetWindowPos(obfh_int_proxy(hWnd), obfh_int_proxy(hWndInsertAfter), obfh_int_proxy(X), obfh_int_proxy(Y), obfh_int_proxy(cx), obfh_int_proxy(cy), obfh_int_proxy(uFlags))

#define SetConsoleTextAttribute(hConsoleOutput, wAttributes) \
    SetConsoleTextAttribute(obfh_int_proxy(hConsoleOutput), obfh_int_proxy(wAttributes))

#define GetDesktopWindow() \
    obfh_int_proxy((int)GetDesktopWindow() * TRUE)

#define GetStockObject(i) \
    GetStockObject(obfh_int_proxy(i) * TRUE)

#define CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) \
    CreateFileA(obfh_int_proxy(lpFileName), obfh_int_proxy(dwDesiredAccess), obfh_int_proxy(dwShareMode), obfh_int_proxy(lpSecurityAttributes), obfh_int_proxy(dwCreationDisposition), obfh_int_proxy(dwFlagsAndAttributes), obfh_int_proxy(hTemplateFile))

#define ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped) \
    ReadFile(obfh_int_proxy(hFile), obfh_int_proxy(lpBuffer), obfh_int_proxy(nNumberOfBytesToRead), obfh_int_proxy(lpNumberOfBytesRead), obfh_int_proxy(lpOverlapped))

#define WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped) \
    WriteFile(obfh_int_proxy(hFile), obfh_int_proxy(lpBuffer), obfh_int_proxy(nNumberOfBytesToWrite), obfh_int_proxy(lpNumberOfBytesWritten), obfh_int_proxy(lpOverlapped))

#define CloseHandle(hObject) \
    CloseHandle(obfh_int_proxy(hObject))

#define GetModuleHandle(lpModuleName) \
    GetModuleHandleA(obfh_int_proxy(lpModuleName))

#define GetCurrentProcess() \
    obfh_int_proxy(GetCurrentProcess())

#define VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect) \
    VirtualAlloc(obfh_int_proxy(lpAddress), obfh_int_proxy(dwSize), obfh_int_proxy(flAllocationType), obfh_int_proxy(flProtect))

#define VirtualFree(lpAddress, dwSize, dwFreeType) \
    VirtualFree(obfh_int_proxy(lpAddress), obfh_int_proxy(dwSize), obfh_int_proxy(dwFreeType))

#define CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId) CreateThread(obfh_int_proxy(lpThreadAttributes), obfh_int_proxy(dwStackSize), obfh_int_proxy(lpStartAddress), obfh_int_proxy(lpParameter), obfh_int_proxy(dwCreationFlags), obfh_int_proxy(lpThreadId))

#define WaitForSingleObject(hHandle, dwMilliseconds) \
    WaitForSingleObject(obfh_int_proxy(hHandle), obfh_int_proxy(dwMilliseconds))

#define ExitProcess(uExitCode) \
    ExitProcess(obfh_int_proxy(uExitCode))

#define GetStartupInfo(lpStartupInfo) \
    GetStartupInfo(obfh_int_proxy(lpStartupInfo))

#define GetModuleFileName(hModule, lpFilename, nSize) \
    GetModuleFileName(obfh_int_proxy(hModule), obfh_int_proxy(lpFilename), obfh_int_proxy(nSize))

#define HeapCreate(flOptions, dwInitialSize, dwMaximumSize) \
    HeapCreate(obfh_int_proxy(flOptions), obfh_int_proxy(dwInitialSize), obfh_int_proxy(dwMaximumSize))

#define HeapAlloc(hHeap, dwFlags, dwBytes) \
    HeapAlloc(obfh_int_proxy(hHeap), obfh_int_proxy(dwFlags), obfh_int_proxy(dwBytes))

#define HeapFree(hHeap, dwFlags, lpMem) \
    HeapFree(obfh_int_proxy(hHeap), obfh_int_proxy(dwFlags), obfh_int_proxy(lpMem))

#define GlobalAlloc(uFlags, dwBytes) \
    GlobalAlloc(obfh_int_proxy(uFlags), obfh_int_proxy(dwBytes))

#define GlobalFree(hMem) \
    GlobalFree(obfh_int_proxy(hMem))

#define GetTempPath(nBufferLength, lpBuffer) \
    GetTempPath(obfh_int_proxy(nBufferLength), obfh_int_proxy(lpBuffer))

#define GetCurrentThreadId() \
    GetCurrentThreadId()

#define SetEvent(hEvent) \
    SetEvent(obfh_int_proxy(hEvent))

#define ResetEvent(hEvent) \
    ResetEvent(obfh_int_proxy(hEvent))

#define WaitForMultipleObjects(nCount, lpHandles, bWaitAll, dwMilliseconds) WaitForMultipleObjects(obfh_int_proxy(nCount), obfh_int_proxy(lpHandles), obfh_int_proxy(bWaitAll), obfh_int_proxy(dwMilliseconds))

#define memmove(_Dst, _Src, _Size) memmove(_Dst, _Src, obfh_int_proxy(_Size *(TRUE + FALSE)))

#define abs(x) ((x) < FALSE ? -(x) : (x))

#if virt_std == 1
#define _MUTATE_MATH(value) VM_MUL_DBL(VM_ADD_DBL(0, value), 1)
#else
#define _MUTATE_MATH(value) FALSE + value *TRUE
#endif

#define fma(x, y, z) fma(_MUTATE_MATH(x), _MUTATE_MATH(y), _MUTATE_MATH(z))
#define nexttoward(x, y) nexttoward(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define nextafter(x, y) nextafter(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define remainder(x, y) remainder(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define copysign(x, y) copysign(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define scalbln(x, y) scalbln(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define remquo(x, y) remquo(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define scalbn(x, y) scalbn(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define atan2(y, x) atan2(_MUTATE_MATH(y), _MUTATE_MATH(x))
#define ldexp(x, y) ldexp(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define frexp(x, y) frexp(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define hypot(x, y) hypot(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define fmod(x, y) fmod(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define modf(x, y) modf(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define fdim(x, y) fdim(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define fmax(x, y) fmax(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define fmin(x, y) fmin(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define pow(x, y) pow(_MUTATE_MATH(x), _MUTATE_MATH(y))
#define nearbyint(x) nearbyint(_MUTATE_MATH(x))
#define lgamma(x) lgamma(_MUTATE_MATH(x))
#define tgamma(x) tgamma(_MUTATE_MATH(x))
#define log10(x) log10(_MUTATE_MATH(x))
#define floor(x) floor(_MUTATE_MATH(x))
#define expm1(x) expm1(_MUTATE_MATH(x))
#define log1p(x) log1p(_MUTATE_MATH(x))
#define acosh(x) acosh(_MUTATE_MATH(x))
#define asinh(x) asinh(_MUTATE_MATH(x))
#define atanh(x) atanh(_MUTATE_MATH(x))
#define ilogb(x) ilogb(_MUTATE_MATH(x))
#define round(x) round(_MUTATE_MATH(x))
#define trunc(x) trunc(_MUTATE_MATH(x))
#define ceil(x) ceil(_MUTATE_MATH(x))
#define fabs(x) fabs(_MUTATE_MATH(x))
#define sqrt(x) sqrt(_MUTATE_MATH(x))
#define asin(x) asin(_MUTATE_MATH(x))
#define acos(x) acos(_MUTATE_MATH(x))
#define atan(x) atan(_MUTATE_MATH(x))
#define sinh(x) sinh(_MUTATE_MATH(x))
#define cosh(x) cosh(_MUTATE_MATH(x))
#define tanh(x) tanh(_MUTATE_MATH(x))
#define ceil(x) ceil(_MUTATE_MATH(x))
#define fabs(x) fabs(_MUTATE_MATH(x))
#define erfc(x) erfc(_MUTATE_MATH(x))
#define log2(x) log2(_MUTATE_MATH(x))
#define cbrt(x) cbrt(_MUTATE_MATH(x))
#define exp2(x) exp2(_MUTATE_MATH(x))
#define logb(x) logb(_MUTATE_MATH(x))
#define rint(x) rint(_MUTATE_MATH(x))
#define exp(x) exp(_MUTATE_MATH(x))
#define log(x) log(_MUTATE_MATH(x))
#define sin(x) sin(_MUTATE_MATH(x))
#define cos(x) cos(_MUTATE_MATH(x))
#define tan(x) tan(_MUTATE_MATH(x))
#define erf(x) erf(_MUTATE_MATH(x))
#define nan(x) nan(_MUTATE_MATH(x))

__declspec(dllexport) char *WhatSoundDoesACowMake() OBFH_SECTION_ATTRIBUTE {
    return HIDE_STRING("Moo");
}

/*
#if __TINYC__
#define main(...) _start(__VA_ARGS__)
#endif
*/

#else
#warning Obfuscation disabled!
#endif
#endif

// ;)

```

`pics/how-it-works.txt`:

```txt
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ------------- Sources ------------ ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ Your C code ‚îÇ + ‚îÇ ‚ÜØ obfus.h ‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
                   ‚îÇ                        |
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ ---------- PreProcessor ---------- ‚îÇ      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ      ‚îÇ
‚îÇ   ‚îå‚îÄ‚î§   1. Fake signatures   ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ   | ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ   | ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
|   ‚îî‚îÄ‚ñ∫   2. Control Flow      ‚îú‚îÄ‚îê   |
‚îÇ     ‚îÇ      obfuscation       ‚îÇ |   |
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò |   ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê |   ‚îÇ
‚îÇ   ‚îå‚îÄ‚î§   3. Virtualization    ‚óÑ‚îÄ‚îò   |
‚îÇ   | ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ   | ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ   ‚îî‚îÄ‚ñ∫    4. Anti-Debugger    ‚îú‚îÄ‚îê   |
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò |   ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê |   ‚îÇ
‚îÇ     ‚îÇ   5. Various code      ‚óÑ‚îÄ‚îò   |
‚îÇ     |      mutations         |     |
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Compiler ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Linker ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     |
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   |
     ‚îÇ   Your program compiled   ‚óÑ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ      and protected!       ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

`tests/build_all.bat`:

```bat
@echo off
rem Set TCC directory
set "path=%path%;C:\tcc"

set "FLAGS=-w -D NO_CFLOW -D ANTIDEBUG_V2 -D FAKE_SIGNS -D VIRT"

for %%F in (
    dll.c
    fib.c
    hello_dll.c
    hello_win.c
    sorter.c
    virtualmachine.c
    virtualmachine_unit.c
) do (
    tcc "%%F" %FLAGS%
)

```

`tests/disasm-security-audit/TinySnake_after.c`:

```c
/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_DWORD sub_402800(); // weak
_DWORD sub_402FC9(); // weak
void sub_403021();
int sub_403039();
_DWORD sub_4032DB(); // weak
_DWORD sub_4033FF(); // weak
_DWORD sub_403B9D(); // weak
_DWORD sub_403DDE(); // weak
_DWORD sub_404206(); // weak
_DWORD sub_404326(); // weak
_DWORD sub_404446(); // weak
_DWORD sub_404566(); // weak
_DWORD sub_40479F(); // weak
_DWORD sub_405726(); // weak
_DWORD sub_405E13(); // weak
_DWORD sub_405F3E(); // weak
_DWORD sub_40608C(); // weak
_DWORD sub_406360(); // weak
_DWORD sub_40648F(); // weak
_DWORD sub_4065C2(); // weak
_DWORD sub_4066E9(); // weak
_DWORD sub_40682A(); // weak
_DWORD sub_406951(); // weak
_DWORD sub_406A7C(); // weak
_DWORD sub_406BA3(); // weak
int sub_406BFB();
BOOL sub_406CB8();
int __cdecl sub_40D752(char *Buffer, size_t BufferCount, char *Format, va_list ArgList); // idb
// int __usercall sub_40D778@<eax>(int a1@<eax>, int a2@<ecx>, __int32 a3@<ebp>);
// int __usercall sub_40D7A4@<eax>(int a1@<ebp>);
// int __usercall sub_40D7A8@<eax>(int a1@<ebp>);
// __time32_t __cdecl time(__time32_t *const Time);
// void __cdecl srand(unsigned int Seed);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// BOOL __stdcall SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);
// int __cdecl vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
void sub_44F05E();
_DWORD __cdecl sub_44F9BF(_DWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4012A8; // weak
_UNKNOWN loc_402EFA; // weak
_UNKNOWN loc_4046D0; // weak
_UNKNOWN loc_405AFC; // weak
int dword_40E09C = 0; // weak
int dword_40E0A0 = 0; // weak
int dword_40E0A4 = 0; // weak
int dword_40E0A8 = 0; // weak
HANDLE hConsoleOutput = NULL; // idb
int dword_40E50C = 0; // weak
int dword_42E50C; // weak
char byte_44F054 = '\0'; // weak
char byte_44F057 = '\x03'; // weak
char byte_44F059 = '\x05'; // weak
char byte_44F05C = '\b'; // weak
_UNKNOWN loc_44F12E; // weak
_UNKNOWN loc_44F19C; // weak


//----- (00402800) --------------------------------------------------------
#error "40280C: cannot convert to microcode (funcsize=6)"

//----- (00402FC9) --------------------------------------------------------
#error "402FD5: cannot convert to microcode (funcsize=6)"

//----- (00403021) --------------------------------------------------------
void sub_403021()
{
  JUMPOUT(0x403034);
}
// 40302D: control flows out of bounds to 403034

//----- (00403039) --------------------------------------------------------
int sub_403039()
{
  int result; // eax

  do
  {
    result = 697;
    if ( (unsigned int)byte_44F054 >= 0x2B9 )
      break;
    result = byte_44F05C;
    if ( byte_44F05C <= byte_44F057 )
      break;
    result = ((int (*)(void))loc_44F12E)();
    if ( !result )
      break;
    result = ((int (__cdecl *)(int, int))loc_44F19C)(31, 1);
    if ( !result )
      break;
    result = byte_44F059;
  }
  while ( byte_44F059 );
  return result;
}
// 44F054: using guessed type char byte_44F054;
// 44F057: using guessed type char byte_44F057;
// 44F059: using guessed type char byte_44F059;
// 44F05C: using guessed type char byte_44F05C;

//----- (004032DB) --------------------------------------------------------
#error "4032E7: cannot convert to microcode (funcsize=6)"

//----- (004033FF) --------------------------------------------------------
#error "40340B: cannot convert to microcode (funcsize=6)"

//----- (00403B9D) --------------------------------------------------------
#error "403BA9: cannot convert to microcode (funcsize=6)"

//----- (00403DDE) --------------------------------------------------------
#error "403DEA: cannot convert to microcode (funcsize=6)"

//----- (00404206) --------------------------------------------------------
#error "404212: cannot convert to microcode (funcsize=6)"

//----- (00404326) --------------------------------------------------------
#error "404332: cannot convert to microcode (funcsize=6)"

//----- (00404446) --------------------------------------------------------
#error "404452: cannot convert to microcode (funcsize=6)"

//----- (00404566) --------------------------------------------------------
#error "404572: cannot convert to microcode (funcsize=6)"

//----- (0040479F) --------------------------------------------------------
#error "4047AB: cannot convert to microcode (funcsize=6)"

//----- (00405726) --------------------------------------------------------
#error "405732: cannot convert to microcode (funcsize=6)"

//----- (00405E13) --------------------------------------------------------
#error "405E1F: cannot convert to microcode (funcsize=6)"

//----- (00405F3E) --------------------------------------------------------
#error "405F4A: cannot convert to microcode (funcsize=6)"

//----- (0040608C) --------------------------------------------------------
#error "406098: cannot convert to microcode (funcsize=6)"

//----- (00406360) --------------------------------------------------------
#error "40636C: cannot convert to microcode (funcsize=6)"

//----- (0040648F) --------------------------------------------------------
#error "40649B: cannot convert to microcode (funcsize=6)"

//----- (004065C2) --------------------------------------------------------
#error "4065CE: cannot convert to microcode (funcsize=6)"

//----- (004066E9) --------------------------------------------------------
#error "4066F5: cannot convert to microcode (funcsize=6)"

//----- (0040682A) --------------------------------------------------------
#error "406836: cannot convert to microcode (funcsize=6)"

//----- (00406951) --------------------------------------------------------
#error "40695D: cannot convert to microcode (funcsize=6)"

//----- (00406A7C) --------------------------------------------------------
#error "406A88: cannot convert to microcode (funcsize=6)"

//----- (00406BA3) --------------------------------------------------------
#error "406BAF: cannot convert to microcode (funcsize=6)"

//----- (00406BFB) --------------------------------------------------------
int sub_406BFB()
{
  unsigned int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int (__cdecl *v5)(_DWORD); // eax
  int result; // eax
  int v7; // [esp+4h] [ebp-Ch]
  int (*v8)(void); // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  dword_40E50C = 12;
  dword_42E50C = 12;
  v0 = time(0);
  srand(v0);
  v1 = ((int (*)(void))loc_4046D0)();
  v9 = ((int (__cdecl *)(int))loc_402EFA)(v1);
  v2 = ((int (*)(void))loc_405AFC)();
  v8 = (int (*)(void))((int (__stdcall *)(int, int))loc_4012A8)(v9, v2);
  dword_40E09C = v8() % 23 + 1;
  v3 = ((int (*)(void))loc_4046D0)();
  v7 = ((int (__cdecl *)(int))loc_402EFA)(v3);
  v4 = ((int (*)(void))loc_405AFC)();
  v5 = (int (__cdecl *)(_DWORD))((int (__stdcall *)(int, int))loc_4012A8)(v7, v4);
  dword_40E0A0 = v5(v5) % 23 + 1;
  dword_40E0A4 = 0;
  result = 1;
  dword_40E0A8 = 1;
  return result;
}
// 40E09C: using guessed type int dword_40E09C;
// 40E0A0: using guessed type int dword_40E0A0;
// 40E0A4: using guessed type int dword_40E0A4;
// 40E0A8: using guessed type int dword_40E0A8;
// 40E50C: using guessed type int dword_40E50C;
// 42E50C: using guessed type int dword_42E50C;

//----- (00406CB8) --------------------------------------------------------
BOOL sub_406CB8()
{
  COORD v1; // [esp-4h] [ebp-8h] BYREF
  __int16 Src[2]; // [esp+0h] [ebp-4h] BYREF

  Src[0] = 0;
  Src[1] = 2;
  memmove(&v1, Src, 4u);
  return SetConsoleCursorPosition(hConsoleOutput, v1);
}

//----- (0040D752) --------------------------------------------------------
int __cdecl sub_40D752(char *Buffer, size_t BufferCount, char *Format, va_list ArgList)
{
  return vsnprintf(Buffer, BufferCount, Format, ArgList);
}

//----- (0040D778) --------------------------------------------------------
int __usercall sub_40D778@<eax>(int a1@<eax>, int a2@<ecx>, __int32 a3@<ebp>)
{
  void **v3; // ecx
  int (__thiscall *v6)(int); // [esp-4h] [ebp-4h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v6 = (int (__thiscall *)(int))_InterlockedExchange((volatile __int32 *)&retaddr, a3);
  v3 = &retaddr;
  do
  {
    v3 -= 1024;
    a1 -= 4096;
  }
  while ( a1 >= 4096 );
  return v6(a2);
}

//----- (0040D7A4) --------------------------------------------------------
int __usercall sub_40D7A4@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 20);
}

//----- (0040D7A8) --------------------------------------------------------
int __usercall sub_40D7A8@<eax>(int a1@<ebp>)
{
  return **(_DWORD **)sub_40D7A4(a1);
}

//----- (0044F05E) --------------------------------------------------------
void sub_44F05E()
{
  ;
}

//----- (0044F9BF) --------------------------------------------------------
#error "44FC98: cannot convert to microcode (funcsize=70)"

// nfuncs=71 queued=33 decompiled=33 lumina nreq=0 worse=0 better=0
#error "There were 24 decompilation failure(s) on 33 function(s)"

```

`tests/disasm-security-audit/TinySnake_before.c`:

```c
/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_401000();
BOOL sub_401077();
BOOL __cdecl sub_4010BC(char *Format, WORD a2);
int sub_401110();
int sub_40137B();
int sub_401471();
// int __usercall sub_4017E5@<eax>(int a1@<ebp>);
void __noreturn start(); // weak
// int __usercall sub_401AFC@<eax>(int a1@<eax>, int a2@<ecx>, __int32 a3@<ebp>);
// int __usercall sub_401B28@<eax>(int a1@<ebp>);
// int __usercall sub_401B2C@<eax>(int a1@<ebp>);
int __cdecl sub_401B6D(_DWORD *a1, char a2);
// __time32_t __cdecl time(__time32_t *const Time);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// BOOL __stdcall SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);
// BOOL __stdcall GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
// BOOL __stdcall SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);
// int printf(const char *const Format, ...);
// int __cdecl kbhit();
// int __cdecl getch();
// int __cdecl tolower(int C);
// int sprintf(char *const Buffer, const char *const Format, ...);
// BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow);
// BOOL __stdcall SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize);
// void *__cdecl memset(void *, int Val, size_t Size);
// BOOL __stdcall SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);
// void __stdcall Sleep(DWORD dwMilliseconds);
// void __cdecl _set_app_type(_crt_app_type Type);
// unsigned int __cdecl controlfp(unsigned int NewValue, unsigned int Mask);
// int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

int dword_401B5C[3] = { -1, 4201270, 4201291 }; // weak
_UNKNOWN j__except_handler3; // weak
int dword_402000 = 0; // weak
int dword_402004 = 0; // weak
int dword_402008 = 1; // weak
int dword_40200C = 0; // weak
int dword_402010 = 0; // weak
int dword_402014 = 0; // weak
int dword_402018 = 0; // weak
HANDLE hConsoleOutput = NULL; // idb
char asc_402020[3] = "  "; // idb
_UNKNOWN unk_402023; // weak
char aOo[3] = "oO"; // idb
char asc_402029[3] = "  "; // idb
char asc_40202C[3] = "##"; // idb
char aScore[] = "SCORE"; // idb
char asc_402098[] = "==============\n="; // idb
char aGameOver[] = " GAME OVER! "; // idb
char asc_4020B6[] = "=\n=============="; // idb
// extern int _argc;
// extern char **_argv;
// extern char **environ;
int dword_4023C8[32768] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  }; // weak
int dword_4223C8[32768]; // weak
struct _CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo; // idb
int dword_4423E0; // weak


//----- (00401000) --------------------------------------------------------
int sub_401000()
{
  unsigned int v0; // eax
  int result; // eax

  dword_4023C8[0] = 12;
  dword_4223C8[0] = 12;
  v0 = time(0);
  srand(v0);
  dword_40200C = rand() % 23 + 1;
  dword_402010 = rand() % 23 + 1;
  dword_402014 = 0;
  result = 1;
  dword_402018 = 1;
  return result;
}
// 40200C: using guessed type int dword_40200C;
// 402010: using guessed type int dword_402010;
// 402014: using guessed type int dword_402014;
// 402018: using guessed type int dword_402018;
// 4023C8: using guessed type int dword_4023C8[32768];
// 4223C8: using guessed type int dword_4223C8[32768];

//----- (00401077) --------------------------------------------------------
BOOL sub_401077()
{
  COORD v1; // [esp-4h] [ebp-8h] BYREF
  __int16 Src[2]; // [esp+0h] [ebp-4h] BYREF

  Src[0] = 0;
  Src[1] = 2;
  memmove(&v1, Src, 4u);
  return SetConsoleCursorPosition(hConsoleOutput, v1);
}

//----- (004010BC) --------------------------------------------------------
BOOL __cdecl sub_4010BC(char *Format, WORD a2)
{
  GetConsoleScreenBufferInfo(hConsoleOutput, &ConsoleScreenBufferInfo);
  SetConsoleTextAttribute(hConsoleOutput, a2);
  printf(Format);
  return SetConsoleTextAttribute(hConsoleOutput, ConsoleScreenBufferInfo.wAttributes);
}

//----- (00401110) --------------------------------------------------------
int sub_401110()
{
  int v0; // eax
  char *v1; // eax
  int k; // [esp+0h] [ebp-10h]
  int v4; // [esp+4h] [ebp-Ch]
  int j; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  sub_401077();
  for ( i = 0; i < 25; ++i )
  {
    for ( j = 0; j < 25; ++j )
    {
      if ( i && i != 24 && j && j != 24 )
      {
        if ( i == dword_4223C8[0] && j == dword_4023C8[0] )
        {
          if ( dword_402000 )
            v1 = aOo;
          else
            v1 = (char *)&unk_402023;
          sub_4010BC(v1, 112);
        }
        else if ( i == dword_402010 && j == dword_40200C )
        {
          sub_4010BC(asc_402029, 192);
        }
        else
        {
          v4 = 0;
          for ( k = 1; k < dword_402008; ++k )
          {
            if ( dword_4023C8[k] == j && dword_4223C8[k] == i )
            {
              sub_4010BC(asc_40202C, 136);
              v4 = 1;
              break;
            }
          }
          if ( !v4 )
            printf("  ");
        }
      }
      else
      {
        if ( dword_402000 )
          v0 = 64;
        else
          v0 = 48;
        sub_4010BC(asc_402020, v0);
      }
    }
    printf("\n");
  }
  sub_4010BC(aScore, 96);
  return printf(": %d\n", dword_402004);
}
// 401077: using guessed type int sub_401077(void);
// 402000: using guessed type int dword_402000;
// 402004: using guessed type int dword_402004;
// 402008: using guessed type int dword_402008;
// 40200C: using guessed type int dword_40200C;
// 402010: using guessed type int dword_402010;
// 4023C8: using guessed type int dword_4023C8[32768];
// 4223C8: using guessed type int dword_4223C8[32768];

//----- (0040137B) --------------------------------------------------------
int sub_40137B()
{
  int result; // eax
  int v1; // eax

  result = kbhit();
  if ( result )
  {
    v1 = getch();
    result = tolower(v1);
    switch ( result )
    {
      case 'a':
        result = dword_402014;
        if ( dword_402014 != 1 )
        {
          dword_402014 = -1;
          result = 0;
          dword_402018 = 0;
        }
        break;
      case 'd':
        result = dword_402014;
        if ( dword_402014 != -1 )
        {
          dword_402014 = 1;
          result = 0;
          dword_402018 = 0;
        }
        break;
      case 's':
        result = dword_402018;
        if ( dword_402018 != -1 )
        {
          dword_402014 = 0;
          result = 1;
          dword_402018 = 1;
        }
        break;
      case 'w':
        result = dword_402018;
        if ( dword_402018 != 1 )
        {
          dword_402014 = 0;
          result = -1;
          dword_402018 = -1;
        }
        break;
    }
  }
  return result;
}
// 402014: using guessed type int dword_402014;
// 402018: using guessed type int dword_402018;

//----- (00401471) --------------------------------------------------------
int sub_401471()
{
  int result; // eax
  int m; // [esp+0h] [ebp-24h]
  int k; // [esp+4h] [ebp-20h]
  int j; // [esp+8h] [ebp-1Ch]
  int v4; // [esp+Ch] [ebp-18h]
  int i; // [esp+10h] [ebp-14h]
  int v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+18h] [ebp-Ch]
  int v8; // [esp+1Ch] [ebp-8h]
  int v9; // [esp+20h] [ebp-4h]

  v9 = dword_4023C8[0];
  v8 = dword_4223C8[0];
  dword_4023C8[0] += dword_402014;
  dword_4223C8[0] += dword_402018;
  if ( dword_4023C8[0] )
  {
    if ( dword_4023C8[0] == 24 )
      dword_4023C8[0] = 1;
  }
  else
  {
    dword_4023C8[0] = 23;
  }
  if ( dword_4223C8[0] )
  {
    if ( dword_4223C8[0] == 24 )
      dword_4223C8[0] = 1;
  }
  else
  {
    dword_4223C8[0] = 23;
  }
  for ( i = 1; i < dword_402008; ++i )
  {
    v7 = dword_4023C8[i];
    v6 = dword_4223C8[i];
    dword_4023C8[i] = v9;
    dword_4223C8[i] = v8;
    v9 = v7;
    v8 = v6;
  }
  if ( dword_4023C8[0] == dword_40200C && dword_4223C8[0] == dword_402010 )
  {
    do
    {
      dword_40200C = rand() % 23 + 1;
      dword_402010 = rand() % 23 + 1;
    }
    while ( dword_40200C == dword_4023C8[0] && dword_402010 == dword_4223C8[0] );
    v4 = 1;
    for ( j = 1; j < dword_402008; ++j )
    {
      if ( dword_40200C == dword_4023C8[j] && dword_402010 == dword_4223C8[j] )
      {
        v4 = 1;
        break;
      }
    }
LABEL_22:
    while ( v4 )
    {
      dword_40200C = rand() % 23 + 1;
      dword_402010 = rand() % 23 + 1;
      v4 = 0;
      for ( k = 0; k < dword_402008; ++k )
      {
        if ( dword_40200C == dword_4023C8[k] && dword_402010 == dword_4223C8[k] )
        {
          v4 = 1;
          goto LABEL_22;
        }
      }
    }
    dword_402004 += 10;
    ++dword_402008;
  }
  for ( m = 1; ; ++m )
  {
    result = m;
    if ( m >= dword_402008 )
      break;
    if ( dword_4023C8[m] == dword_4023C8[0] && dword_4223C8[m] == dword_4223C8[0] )
    {
      result = 1;
      dword_402000 = 1;
      return result;
    }
  }
  return result;
}
// 402000: using guessed type int dword_402000;
// 402004: using guessed type int dword_402004;
// 402008: using guessed type int dword_402008;
// 40200C: using guessed type int dword_40200C;
// 402010: using guessed type int dword_402010;
// 402014: using guessed type int dword_402014;
// 402018: using guessed type int dword_402018;
// 4023C8: using guessed type int dword_4023C8[32768];
// 4223C8: using guessed type int dword_4223C8[32768];

//----- (004017E5) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_4017E5@<eax>(int a1@<ebp>)
{
  int v1; // eax
  int result; // eax
  COORD v3; // [esp-8h] [ebp-8h] BYREF

  sub_401AFC();
  sprintf((char *const)(a1 - 0x8000), "Tiny Snake (x%d)", 32);
  SetConsoleTitleA((LPCSTR)(a1 - 0x8000));
  *(_DWORD *)(a1 - 32776) = 51;
  *(_DWORD *)(a1 - 32772) = 33;
  hConsoleOutput = GetStdHandle(0xFFFFFFF5);
  *(_WORD *)(a1 - 32784) = 0;
  *(_WORD *)(a1 - 32782) = 0;
  *(_WORD *)(a1 - 32780) = *(_DWORD *)(a1 - 32776) - 1;
  *(_WORD *)(a1 - 32778) = *(_DWORD *)(a1 - 32772) - 1;
  SetConsoleWindowInfo(hConsoleOutput, 1, (const SMALL_RECT *)(a1 - 32784));
  *(_WORD *)(a1 - 32788) = *(_WORD *)(a1 - 32776);
  *(_WORD *)(a1 - 32786) = *(_WORD *)(a1 - 32772);
  memmove(&v3, (const void *)(a1 - 32788), 4u);
  SetConsoleScreenBufferSize(hConsoleOutput, v3);
  *(_DWORD *)(a1 - 32796) = 0;
  memset((void *)(a1 - 32792), 0, 4u);
  *(_DWORD *)(a1 - 32796) = 1;
  *(_DWORD *)(a1 - 32792) = 0;
  SetConsoleCursorInfo(hConsoleOutput, (const CONSOLE_CURSOR_INFO *)(a1 - 32796));
  printf("Coded by DosX-dev (GitHub)\nUSE ONLY ENGLISH KEYBOARD LAYOUT! (WASD)\n");
  sub_401000();
  while ( !dword_402000 )
  {
    sub_401110();
    sub_40137B();
    sub_401471();
    Sleep(0x64u);
  }
  dword_402014 = 0;
  dword_402018 = 0;
  sub_401110();
  printf("\n");
  sub_4010BC(asc_402098, 68);
  sub_4010BC(aGameOver, 116);
  sub_4010BC(asc_4020B6, 68);
  printf("\nPress X to exit");
  do
  {
    v1 = getch();
    result = tolower(v1);
  }
  while ( result != 120 );
  return result;
}
// 4019F4: positive sp value 4 has been found
// 401000: using guessed type _DWORD sub_401000();
// 401110: using guessed type _DWORD sub_401110();
// 40137B: using guessed type _DWORD sub_40137B();
// 401471: using guessed type _DWORD sub_401471();
// 401AFC: using guessed type _DWORD sub_401AFC();
// 402000: using guessed type int dword_402000;
// 402014: using guessed type int dword_402014;
// 402018: using guessed type int dword_402018;

//----- (004019F8) --------------------------------------------------------
void __noreturn start()
{
  int v0; // eax
  int v1; // [esp+8h] [ebp-1Ch] BYREF
  char v2[24]; // [esp+Ch] [ebp-18h] BYREF

  sub_401B6D(v2);
  v1 = 0;
  _set_app_type(_crt_console_app);
  controlfp(0x10000u, 0x30000u);
  _getmainargs(_argc, _argv, environ, dword_4423E0, &v1);
  v0 = sub_4017E5(_argc, _argv, environ);
  exit(v0);
}
// 4017E5: using guessed type int __cdecl sub_4017E5(_DWORD, _DWORD, _DWORD);
// 4019F8: using guessed type void __noreturn start();
// 401C50: using guessed type int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4423E0: using guessed type int dword_4423E0;
// 4019F8: using guessed type char var_18[24];

//----- (00401AFC) --------------------------------------------------------
int __usercall sub_401AFC@<eax>(int a1@<eax>, int a2@<ecx>, __int32 a3@<ebp>)
{
  void **v3; // ecx
  int (__thiscall *v6)(int); // [esp-4h] [ebp-4h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v6 = (int (__thiscall *)(int))_InterlockedExchange((volatile __int32 *)&retaddr, a3);
  v3 = &retaddr;
  do
  {
    v3 -= 1024;
    a1 -= 4096;
  }
  while ( a1 >= 4096 );
  return v6(a2);
}

//----- (00401B28) --------------------------------------------------------
int __usercall sub_401B28@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 20);
}

//----- (00401B2C) --------------------------------------------------------
int __usercall sub_401B2C@<eax>(int a1@<ebp>)
{
  return **(_DWORD **)sub_401B28(a1);
}

//----- (00401B6D) --------------------------------------------------------
int __cdecl sub_401B6D(_DWORD *a1, char a2)
{
  int result; // eax

  *a1 = &a2;
  a1[1] = 0;
  a1[2] = NtCurrentTeb()->NtTib.ExceptionList;
  a1[3] = &sub_401B68;
  a1[4] = dword_401B5C;
  result = 0;
  a1[5] = 0;
  return result;
}
// 401B5C: using guessed type int dword_401B5C[3];

// nfuncs=39 queued=12 decompiled=12 lumina nreq=0 worse=0 better=0
// ALL OK, 12 function(s) have been successfully decompiled

```

`tests/disasm-security-audit/example.h`:

```h
#define teststr "%d) Hello, world!\n"
#define errstr "Error!"
```

`tests/disasm-security-audit/legacy_tests/ASM/after_x64.asm`:

```asm
RUNTIME_FUNCTION struc 

FunctionStart dd ?      
FunctionEnd dd ?        
UnwindInfo dd ?         
RUNTIME_FUNCTION ends

UNWIND_INFO_HDR struc 

Ver3_Flags db ?         
PrologSize db ?         
CntUnwindCodes db ?     
FrReg_FrRegOff db ?     
UNWIND_INFO_HDR ends

UNWIND_CODE struc 

PrologOff db ?          
OpCode_OpInfo db ?      
UNWIND_CODE ends

.686p
.mmx
.model flat

_text segment para public 'CODE' use64
assume cs:_text

assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

sub_401000 proc near

arg_0= qword ptr  10h
arg_8= qword ptr  18h
arg_10= qword ptr  20h
arg_18= qword ptr  28h

push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_40100B:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
mov     [rbp+arg_10], r8
mov     [rbp+arg_18], r9
nop
leave
retn
sub_401000 endp

algn_40101E:
align 20h
stru_401020 UNWIND_INFO_HDR <1, 4, 2, 5>
UNWIND_CODE <4, 3>      
UNWIND_CODE <1, 50h>    

sub_401028 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_401033:
mov     [rbp+arg_0], rcx
movsx   eax, cs:byte_405057
mov     r11, rax
movsx   eax, cs:byte_405054
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401000
nop
cpuid
nop
mov     eax, dword ptr [rbp+arg_0]
movsx   ecx, cs:byte_405055
imul    eax, ecx
movsx   ecx, cs:byte_405058
movsx   edx, cs:byte_405056
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505C
sub     eax, ecx
leave
retn
sub_401028 endp

sub_401085 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_401090:
movq    [rbp+arg_0], xmm0
movsx   eax, cs:byte_40505A
mov     r11, rax
movsx   eax, cs:byte_405056
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401000
nop
cpuid
nop
movsx   eax, cs:byte_405055
cvtsi2sd xmm0, eax
movq    xmm1, [rbp+arg_0]
mulsd   xmm1, xmm0
movsd   xmm0, xmm1
leave
retn
sub_401085 endp

sub_4010D2 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_4010DD:
nop
cpuid
nop
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401124
movsx   eax, cs:byte_40505D
movsx   ecx, cs:byte_40505B
add     eax, ecx
movsx   ecx, cs:byte_40505C
cdq
idiv    ecx
movsx   ecx, cs:byte_405055
sub     eax, ecx
cmp     eax, 0
jz      loc_401124
mov     eax, 1
jmp     short locret_401129

loc_401124:
mov     eax, 0

locret_401129:
leave
retn
sub_4010D2 endp

sub_40112B proc near

var_10= qword ptr -10h
var_4= dword ptr -4
arg_0= qword ptr  10h
arg_8= qword ptr  18h

push    rbp
mov     rbp, rsp
sub     rsp, 30h

loc_401136:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
mov     eax, dword ptr [rbp+arg_8]
movsx   ecx, cs:byte_405055
imul    eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
mov     [rbp+var_4], eax
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 3
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
mov     ecx, dword ptr [rbp+arg_0]
imul    eax, ecx
mov     ecx, [rbp+var_4]
cmp     ecx, eax
jnz     loc_4011E0
movsx   eax, cs:byte_405058
movsx   ecx, cs:byte_405056
imul    eax, ecx
movsx   ecx, cs:byte_40505C
sub     ecx, eax
cmp     ecx, 0
jz      loc_4011D1
call    sub_4010D2
cmp     eax, 0
jz      loc_4011CA
jmp     loc_4011D1

loc_4011CA:
mov     eax, 1
jmp     short loc_4011D6

loc_4011D1:
mov     eax, 0

loc_4011D6:
jmp     locret_401309
jmp     loc_4012F7

loc_4011E0:
movsx   eax, cs:byte_40505D
movsx   ecx, cs:byte_40505B
add     eax, ecx
movsx   ecx, cs:byte_405054
shl     ecx, 2
add     eax, ecx
movsx   ecx, cs:byte_40505C
cdq
idiv    ecx
movsx   ecx, cs:byte_405055
sub     eax, ecx
mov     ecx, [rbp+var_4]
cmp     ecx, eax
jnz     loc_4012F7
call    sub_4010D2
cmp     eax, 0
jnz     loc_401298
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 9
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
cmp     eax, 0
jnz     loc_401298
movsx   eax, cs:byte_40505D
movsx   ecx, cs:byte_40505B
add     eax, ecx
movsx   ecx, cs:byte_405054
shl     ecx, 3
add     eax, ecx
movsx   ecx, cs:byte_40505C
cdq
idiv    ecx
movsx   ecx, cs:byte_405055
sub     eax, ecx
cmp     eax, 0
jnz     loc_401298
jmp     loc_4012ED

loc_401298:
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 0Fh
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
movsx   ecx, cs:byte_405055
mov     r10, rcx
mov     [rbp+var_10], rax
mov     rcx, r10
call    sub_401028
mov     ecx, dword ptr [rbp+var_10]
add     ecx, eax
cmp     ecx, 0
jz      loc_4012ED
mov     eax, 1
jmp     short loc_4012F2

loc_4012ED:
mov     eax, 0

loc_4012F2:
jmp     locret_401309

loc_4012F7:
nop
cpuid
nop
mov     eax, dword ptr [rbp+arg_8]
mov     r10, rax
mov     rcx, r10
call    sub_401028

locret_401309:
leave
retn
sub_40112B endp

sub_40130B proc near

var_20= qword ptr -20h
var_18= qword ptr -18h
var_C= dword ptr -0Ch
var_8= qword ptr -8
arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 40h

loc_401316:
mov     [rbp+arg_0], rcx
mov     eax, 0Eh
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401460
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401460
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401460
mov     eax, dword ptr [rbp+arg_0]
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_40140A
movsx   eax, cs:byte_405055
movsxd  rax, eax
shl     rax, 4
movsx   ecx, cs:byte_405056
movsxd  rcx, ecx
imul    rax, rcx
movsx   ecx, cs:byte_405058
movsxd  rcx, ecx
imul    rax, rcx
movsx   ecx, cs:byte_40505C
movsxd  rcx, ecx
xor     rdx, rdx
div     rcx
movsx   ecx, cs:byte_405056
movsxd  rcx, ecx
shl     rcx, 4
movsx   edx, cs:byte_405058
movsxd  rdx, edx
imul    rcx, rdx
movsx   edx, cs:byte_40505C
movsxd  rdx, edx
mov     [rbp+var_8], rax
mov     rax, rcx
mov     rcx, rdx
xor     rdx, rdx
div     rcx
mov     rcx, [rbp+var_8]
add     rcx, rax
movsx   eax, cs:byte_405054
mov     edx, 54h 
imul    eax, edx
movsxd  rax, eax
add     rcx, rax
shr     rcx, 1
mov     eax, dword ptr [rbp+arg_0]
movsxd  rax, eax
cmp     rax, rcx
jnb     loc_40140A
mov     eax, 0
jmp     short loc_40140F

loc_40140A:
mov     eax, 1

loc_40140F:
mov     r11, rax
mov     eax, 8
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401460
call    sub_4010D2
cmp     eax, 0
jnz     loc_401451
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401451
jmp     loc_401460

loc_401451:
mov     rax, 0
jmp     locret_4015B2

loc_401460:
movsx   eax, cs:byte_405055
movsx   ecx, cs:byte_405059
imul    eax, ecx
movsx   ecx, cs:byte_405058
sub     eax, ecx
movsx   ecx, cs:byte_405055
add     eax, ecx
movsx   ecx, cs:byte_405056
sub     eax, ecx
mov     [rbp+var_C], eax
lea     rax, unk_405490
mov     [rbp+var_18], rax
movsx   eax, cs:byte_405054
mov     [rbp+var_C], eax

loc_4014A4:
mov     eax, [rbp+var_C]
mov     ecx, dword ptr [rbp+arg_0]
cmp     eax, ecx
jge     loc_40159C
jmp     loc_401569

loc_4014B7:
mov     eax, [rbp+var_C]
mov     rcx, rax
add     eax, 1
mov     [rbp+var_C], eax
cmp     ecx, 0
jz      loc_401554
movsx   eax, cs:byte_40505D
movsx   ecx, cs:byte_40505B
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 12h
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505C
cdq
idiv    ecx
movsx   ecx, cs:byte_405055
sub     eax, ecx
mov     ecx, 15h
imul    eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsx   ecx, cs:byte_405057
movsx   edx, cs:byte_40505A
add     ecx, edx
movsx   edx, cs:byte_405054
mov     [rbp+var_20], rax
mov     eax, 21h 
imul    edx, eax
add     ecx, edx
movsx   eax, cs:byte_40505D
sub     ecx, eax
mov     eax, dword ptr [rbp+var_20]
add     eax, ecx
cmp     eax, 0
jz      loc_401554
jmp     loc_401564

loc_401554:
movsx   eax, cs:byte_405055
cmp     eax, 0
jnz     $+6

loc_401564:
jmp     loc_4014A4

loc_401569:
mov     rax, [rbp+var_18]
mov     rcx, rax
add     rax, 1
mov     [rbp+var_18], rax
mov     eax, 25h 
mov     [rcx], al
mov     rax, [rbp+var_18]
mov     rcx, rax
add     rax, 1
mov     [rbp+var_18], rax
movsx   eax, cs:byte_405036
mov     [rcx], al
jmp     loc_4014B7

loc_40159C:
mov     rax, [rbp+var_18]
mov     ecx, 0
mov     [rax], cl
nop
cpuid
nop
lea     rax, unk_405490

locret_4015B2:
leave
retn
sub_40130B endp

sub_4015B4 proc near

lpReserved= qword ptr -10h
hConsoleOutput= qword ptr  10h
lpBuffer= qword ptr  18h
nNumberOfCharsToWrite= dword ptr  20h
lpNumberOfCharsWritten= qword ptr  28h
arg_20= qword ptr  30h

push    rbp
mov     rbp, rsp
sub     rsp, 30h

loc_4015BF:
mov     [rbp+hConsoleOutput], rcx
mov     [rbp+lpBuffer], rdx
mov     qword ptr [rbp+nNumberOfCharsToWrite], r8
mov     [rbp+lpNumberOfCharsWritten], r9
nop
cpuid
nop
mov     rax, [rbp+arg_20]
mov     [rsp+30h+lpReserved], rax 
mov     rax, [rbp+lpNumberOfCharsWritten]
mov     r9, rax         
mov     eax, [rbp+nNumberOfCharsToWrite]
mov     r8, rax         
mov     rax, [rbp+lpBuffer]
mov     r11, rax
mov     rax, [rbp+hConsoleOutput]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    WriteConsoleA
leave
retn
sub_4015B4 endp

sub_401604 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40160F:
mov     [rbp+arg_0], rcx
nop
cpuid
nop
mov     eax, dword ptr [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_401028
mov     r10, rax
mov     rcx, r10        
call    GetStdHandle
leave
retn
sub_401604 endp

sub_401632 proc near

hModule= qword ptr  10h
lpProcName= qword ptr  18h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40163D:
mov     [rbp+hModule], rcx
mov     [rbp+lpProcName], rdx
nop
cpuid
nop
mov     rax, [rbp+lpProcName]
mov     r11, rax
mov     rax, [rbp+hModule]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    GetProcAddress
leave
retn
sub_401632 endp

sub_401664 proc near

lpModuleName= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40166F:
mov     [rbp+lpModuleName], rcx
nop
cpuid
nop
mov     rax, [rbp+lpModuleName]
mov     r10, rax
mov     rcx, r10        
call    GetModuleHandleA
leave
retn
sub_401664 endp

sub_401688 proc near

var_18= qword ptr -18h
var_10= qword ptr -10h
var_8= qword ptr -8
arg_0= qword ptr  10h
arg_8= qword ptr  18h

push    rbp
mov     rbp, rsp
sub     rsp, 40h

loc_401693:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx

loc_40169B:
mov     eax, 28h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401F3A
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_401F3A
call    sub_4010D2
cmp     eax, 0
jz      loc_401F3A
mov     rax, [rbp+arg_0]
movsx   ecx, byte ptr [rax]
cmp     ecx, 0
jnz     loc_4016FA
mov     rax, [rbp+arg_8]
movsx   ecx, byte ptr [rax]
cmp     ecx, 0
jnz     loc_4016FA
mov     eax, 0
jmp     short loc_4016FF

loc_4016FA:
mov     eax, 1

loc_4016FF:
mov     r11, rax
mov     eax, 0Dh
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401F3A
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_401F3A
mov     eax, 0Fh
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 38h 
mov     eax, 20h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4017C3
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4017C3
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4017C3
lea     rax, sub_401000
mov     r11, rax
mov     eax, 11h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4017C3
call    sub_4010D2
cmp     eax, 0
jnz     loc_4017C2
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4017C2
jmp     loc_4017C3

loc_4017C2:
nop

loc_4017C3:
nop
nop
mov     eax, 2Eh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401838
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_401838
call    sub_4010D2
cmp     eax, 0
jz      loc_401838
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 13h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401838
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_401838
jmp     loc_4017C3

loc_401838:
mov     eax, 28h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_40193A
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_40193A
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_40193A
mov     rax, [rbp+arg_0]
movsx   ecx, byte ptr [rax]
mov     r10, rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+arg_8]
movsx   edx, byte ptr [rcx]
mov     r10, rdx
mov     [rbp+var_8], rax
mov     rcx, r10
call    sub_401028
mov     ecx, dword ptr [rbp+var_8]
cmp     ecx, eax
jge     loc_4018C5
movsx   eax, cs:byte_405055
mov     r10, rax
mov     rcx, r10
call    sub_401028
cmp     eax, 0
jz      loc_4018C5
mov     eax, 1
jmp     short loc_4018CA

loc_4018C5:
mov     eax, 0

loc_4018CA:
mov     r11, rax
mov     eax, 15h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_40193A
call    sub_4010D2
cmp     eax, 0
jnz     loc_40190C
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_40190C
jmp     loc_40193A

loc_40190C:
movsx   eax, cs:byte_405056
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsx   ecx, cs:byte_405056
cdq
idiv    ecx
mov     ecx, 0FFFFFFFFh
imul    eax, ecx
jmp     locret_401F45
jmp     loc_401EEC

loc_40193A:
mov     eax, 2Eh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4019DB
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4019DB
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4019DB
movsx   eax, cs:byte_405054
cmp     eax, 16h
mov     eax, 0
setnle  al
mov     r11, rax
mov     eax, 18h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4019DB
call    sub_4010D2
cmp     eax, 0
jnz     loc_4019C6
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4019C6
jmp     loc_4019DB

loc_4019C6:
mov     eax, 0Ch
mov     r10, rax
mov     rcx, r10
call    sub_401000
jmp     loc_401EEC

loc_4019DB:
mov     eax, 38h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401A74
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401A74
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401A74
mov     eax, 0
mov     r11, rax
mov     eax, 1Dh
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401A74
call    sub_4010D2
cmp     eax, 0
jnz     loc_401A5A
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401A5A
jmp     loc_401A74

loc_401A5A:
movsx   eax, cs:byte_405057
sub     eax, 1Eh
mov     r10, rax
mov     rcx, r10
call    sub_401028
jmp     loc_401EEC

loc_401A74:
mov     eax, 40h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401C2A
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401C2A
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401C2A
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 5Dh 
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
mov     r11, rax
mov     eax, 21h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401C2A
call    sub_4010D2
cmp     eax, 0
jnz     loc_401B18
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401B18
jmp     loc_401C2A

loc_401B18:
mov     eax, 23h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 88h
mov     eax, 48h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401BB0
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401BB0
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401BB0
lea     rax, sub_401000
mov     r11, rax
mov     eax, 25h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401BB0
call    sub_4010D2
cmp     eax, 0
jnz     loc_401BAF
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401BAF
jmp     loc_401BB0

loc_401BAF:
nop

loc_401BB0:
nop
nop
mov     eax, 42h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401C25
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_401C25
call    sub_4010D2
cmp     eax, 0
jz      loc_401C25
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 27h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401C25
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_401C25
jmp     loc_401BB0

loc_401C25:
jmp     loc_401EEC

loc_401C2A:
mov     eax, 52h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401E1D
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401E1D
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401E1D
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 78h 
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
movsx   ecx, cs:byte_405057
mov     r10, rcx
mov     [rbp+var_10], rax
mov     rcx, r10
call    sub_401028
cmp     eax, 0
jz      loc_401CB0
jmp     loc_401CBC

loc_401CB0:
movsx   eax, cs:byte_405054
jmp     loc_401CC3

loc_401CBC:
movsx   eax, cs:byte_405056

loc_401CC3:
mov     ecx, dword ptr [rbp+var_10]
imul    ecx, eax
mov     r11, rcx
mov     eax, 2Ah 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401E1D
call    sub_4010D2
cmp     eax, 0
jnz     loc_401D0B
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401D0B
jmp     loc_401E1D

loc_401D0B:
mov     eax, 2Ch 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 0ACh
mov     eax, 5Ah 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401DA3
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401DA3
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401DA3
lea     rax, sub_401000
mov     r11, rax
mov     eax, 2Eh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401DA3
call    sub_4010D2
cmp     eax, 0
jnz     loc_401DA2
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401DA2
jmp     loc_401DA3

loc_401DA2:
nop

loc_401DA3:
nop
nop
mov     eax, 4Bh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401E18
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_401E18
call    sub_4010D2
cmp     eax, 0
jz      loc_401E18
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 30h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401E18
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_401E18
jmp     loc_401DA3

loc_401E18:
jmp     loc_401EEC

loc_401E1D:
mov     eax, 62h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_401EEC
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_401EEC
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_401EEC
mov     rax, [rbp+arg_0]
movsx   ecx, byte ptr [rax]
mov     r10, rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+arg_8]
movsx   edx, byte ptr [rcx]
mov     r10, rdx
mov     [rbp+var_18], rax
mov     rcx, r10
call    sub_401028
mov     ecx, dword ptr [rbp+var_18]
cmp     ecx, eax
mov     eax, 0
setnle  al
mov     r11, rax
mov     eax, 32h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_401EEC
call    sub_4010D2
cmp     eax, 0
jnz     loc_401ECC
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_401ECC
jmp     loc_401EEC

loc_401ECC:
movsx   eax, cs:byte_405054
movsx   ecx, cs:byte_405055
add     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
jmp     locret_401F45

loc_401EEC:
movsx   eax, cs:byte_405055
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
mov     rcx, [rbp+arg_0]
add     rcx, rax
mov     [rbp+arg_0], rcx
movsx   eax, cs:byte_405056
movsx   ecx, cs:byte_405055
sub     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
mov     rcx, [rbp+arg_8]
add     rcx, rax
mov     [rbp+arg_8], rcx
jmp     loc_40169B

loc_401F3A:
nop
cpuid
nop
movsx   eax, cs:byte_405054

locret_401F45:
leave
retn
sub_401688 endp

sub_401F47 proc near

var_8= qword ptr -8
arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 30h

loc_401F52:
mov     [rbp+arg_0], rcx
movsx   eax, cs:byte_405054
movsxd  rax, eax
mov     [rbp+var_8], rax

loc_401F64:
mov     eax, 4Fh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_40202B
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_40202B
call    sub_4010D2
cmp     eax, 0
jz      loc_40202B
mov     rax, [rbp+arg_0]
movsx   ecx, byte ptr [rax]
cmp     ecx, 0
mov     eax, 1
setnz   al
mov     r11, rax
mov     eax, 34h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_40202B
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_40202B
movsx   eax, cs:byte_405055
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
mov     rcx, [rbp+var_8]
add     rcx, rax
mov     [rbp+var_8], rcx
movsx   eax, cs:byte_405056
movsx   ecx, cs:byte_405055
sub     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
mov     rcx, [rbp+arg_0]
add     rcx, rax
mov     [rbp+arg_0], rcx
jmp     loc_401F64

loc_40202B:
nop
cpuid
nop
movsx   eax, cs:byte_405054
movsxd  rax, eax
mov     rcx, [rbp+var_8]
add     rcx, rax
mov     r10, rcx
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
leave
retn
sub_401F47 endp

sub_402050 proc near

var_B0= qword ptr -0B0h
var_A8= qword ptr -0A8h
var_A0= qword ptr -0A0h
var_98= qword ptr -98h
var_90= qword ptr -90h
var_88= qword ptr -88h
Source= byte ptr -78h
var_58= qword ptr -58h
var_50= qword ptr -50h
var_48= qword ptr -48h
var_40= qword ptr -40h
var_38= qword ptr -38h
var_29= byte ptr -29h
var_28= qword ptr -28h
Buffer= byte ptr -20h
arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 0D0h

loc_40205B:
mov     [rbp+arg_0], rcx
mov     eax, 6Ah 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4023AE
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4023AE
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4023AE
mov     rax, cs:qword_405060
cmp     rax, 0
mov     eax, 0
setz    al
mov     r11, rax
mov     eax, 36h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4023AE
call    sub_4010D2
cmp     eax, 0
jnz     loc_4020EC
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4020EC
jmp     loc_4023AE

loc_4020EC:
movsx   eax, cs:byte_40505A
mov     r10, rax
mov     rcx, r10
call    sub_40130B
lea     rcx, Source     
mov     r11, rcx
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    strcat
movsx   ecx, cs:byte_405056
mov     [rsp+0D0h+var_88], rcx
movsx   ecx, cs:byte_405057
mov     [rsp+0D0h+var_90], rcx
movsx   ecx, cs:byte_40503F
mov     [rsp+0D0h+var_98], rcx
movsx   ecx, cs:byte_405038
mov     [rsp+0D0h+var_A0], rcx
movsx   ecx, cs:byte_405041
mov     [rsp+0D0h+var_A8], rcx
movsx   ecx, cs:byte_405045
mov     [rsp+0D0h+var_B0], rcx
movsx   ecx, cs:byte_405038
mov     r9, rcx
movsx   ecx, cs:byte_40503E
mov     r8, rcx
mov     r11, rax
lea     rax, [rbp+Buffer]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    sprintf
lea     rax, [rbp+Buffer]
mov     r10, rax
mov     rcx, r10
call    sub_401664
mov     [rbp+var_28], rax
mov     eax, 6Eh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4023AE
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4023AE
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4023AE
mov     rax, [rbp+var_28]
cmp     rax, 0
mov     eax, 1
setnz   al
mov     r11, rax
mov     eax, 38h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4023AE
call    sub_4010D2
cmp     eax, 0
jnz     loc_402224
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402224
jmp     loc_4023AE

loc_402224:
nop
cpuid
nop
movsx   eax, cs:byte_40504F
mov     [rbp+var_29], al
movsx   eax, cs:byte_405054
mov     r10, rax
mov     rcx, r10
call    sub_401000
movsx   eax, cs:byte_405058
movsxd  rax, eax
lea     rcx, byte_4054A0
add     rcx, rax
movsx   eax, cs:byte_405054
mov     r10, rax
mov     [rbp+var_38], rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+var_38]
mov     [rcx], al
movsx   eax, cs:byte_405057
movsxd  rax, eax
lea     rcx, byte_4054A0
add     rcx, rax
movsx   eax, cs:byte_405037
mov     r10, rax
mov     [rbp+var_40], rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+var_40]
mov     [rcx], al
movsx   eax, cs:byte_405056
movsxd  rax, eax
lea     rcx, byte_4054A0
add     rcx, rax
movsx   eax, cs:byte_405034
mov     r10, rax
mov     [rbp+var_48], rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+var_48]
mov     [rcx], al
movsx   eax, cs:byte_405055
movsxd  rax, eax
lea     rcx, byte_4054A0
add     rcx, rax
movsx   eax, cs:byte_405042
mov     r10, rax
mov     [rbp+var_50], rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+var_50]
mov     [rcx], al
movsx   eax, cs:byte_405054
movsxd  rax, eax
lea     rcx, byte_4054A0
add     rcx, rax
movsx   eax, cs:byte_40504F
mov     r10, rax
mov     [rbp+var_58], rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+var_58]
mov     [rcx], al
nop
cpuid
nop
lea     rax, aC         
mov     r11, rax
lea     rax, Destination 
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    strcat
movsx   ecx, cs:byte_405050
mov     r8, rcx
mov     r11, rax
lea     rax, [rbp+Source]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    sprintf
lea     rax, [rbp+Source]
mov     r11, rax
lea     rax, byte_4054A0
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    strcat
mov     r11, rax
mov     rax, [rbp+var_28]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401632
mov     cs:qword_405060, rax

loc_4023AE:
mov     eax, 72h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402454
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402454
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402454
mov     rax, cs:qword_405060
cmp     rax, 0
mov     eax, 1
setnz   al
mov     r11, rax
mov     eax, 3Ah 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402454
call    sub_4010D2
cmp     eax, 0
jnz     loc_40243B
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_40243B
jmp     loc_402454

loc_40243B:
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
mov     r11, cs:qword_405060
call    r11 
jmp     locret_40245E

loc_402454:
mov     rax, 0

locret_40245E:
leave
retn
sub_402050 endp

sub_402460 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40246B:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_402050
leave
retn
sub_402460 endp

sub_402480 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40248B:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_402460
leave
retn
sub_402480 endp

sub_4024A0 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4024AB:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_402480
leave
retn
sub_4024A0 endp

sub_4024C0 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4024CB:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_4024A0
leave
retn
sub_4024C0 endp

sub_4024E0 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4024EB:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_4024C0
leave
retn
sub_4024E0 endp

sub_402500 proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40250B:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    sub_4024E0
leave
retn
sub_402500 endp

sub_402520 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40252B:
mov     eax, 3Ch 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 0ECh
mov     eax, 7Ah 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4025C3
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4025C3
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4025C3
lea     rax, sub_401000
mov     r11, rax
mov     eax, 3Eh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4025C3
call    sub_4010D2
cmp     eax, 0
jnz     loc_4025C2
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4025C2
jmp     loc_4025C3

loc_4025C2:
nop

loc_4025C3:
nop
nop
mov     eax, 5Bh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402638
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_402638
call    sub_4010D2
cmp     eax, 0
jz      loc_402638
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 40h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402638
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_402638
jmp     loc_4025C3

loc_402638:
mov     eax, 42h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 104h
mov     eax, 86h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4026D0
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4026D0
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4026D0
lea     rax, sub_401000
mov     r11, rax
mov     eax, 44h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4026D0
call    sub_4010D2
cmp     eax, 0
jnz     loc_4026CF
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4026CF
jmp     loc_4026D0

loc_4026CF:
nop

loc_4026D0:
nop
nop
mov     eax, 61h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402745
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_402745
call    sub_4010D2
cmp     eax, 0
jz      loc_402745
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 46h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402745
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_402745
jmp     loc_4026D0

loc_402745:
call    IsDebuggerPresent
leave
retn
sub_402520 endp

sub_40274C proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_402757:             
int     3
leave
retn
sub_40274C endp

sub_40275A proc near

var_20= qword ptr -20h
var_18= qword ptr -18h
var_10= qword ptr -10h
var_8= qword ptr -8

push    rbp
mov     rbp, rsp
sub     rsp, 40h

loc_402765:
mov     eax, 48h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 11Ch
mov     eax, 92h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4027FD
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4027FD
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4027FD
lea     rax, sub_401000
mov     r11, rax
mov     eax, 4Ah 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4027FD
call    sub_4010D2
cmp     eax, 0
jnz     loc_4027FC
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4027FC
jmp     loc_4027FD

loc_4027FC:
nop

loc_4027FD:
nop
nop
mov     eax, 67h 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402872
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_402872
call    sub_4010D2
cmp     eax, 0
jz      loc_402872
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 4Ch 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402872
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_402872
jmp     loc_4027FD

loc_402872:
movsx   eax, cs:byte_405054
movsx   ecx, cs:byte_405057
add     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401000
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_405056
sub     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401000
mov     eax, 9Ah
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402A01
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402A01
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402A01
call    IsDebuggerPresent
cmp     eax, 0
jnz     loc_40295A
call    sub_402520
cmp     eax, 0
jz      loc_402903
mov     eax, 0
jmp     short loc_402908

loc_402903:
mov     eax, 1

loc_402908:
mov     [rbp+var_8], rax
movsx   eax, cs:byte_405054
mov     ecx, dword ptr [rbp+var_8]
cdq
idiv    ecx
movsx   ecx, cs:byte_405055
movsx   edx, cs:byte_405054
add     ecx, edx
movsx   edx, cs:byte_405055
add     ecx, edx
imul    eax, ecx
movsx   ecx, cs:byte_405056
cdq
idiv    ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
cmp     eax, 0
jnz     loc_40295A
mov     eax, 0
jmp     short loc_40295F

loc_40295A:
mov     eax, 1

loc_40295F:
mov     r11, rax
mov     eax, 4Eh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402A01
call    sub_4010D2
cmp     eax, 0
jnz     loc_4029A1
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4029A1
jmp     loc_402A01

loc_4029A1:
call    sub_40274C
int     3               
movsx   eax, cs:byte_405054
movsx   ecx, cs:byte_405054
cdq
idiv    ecx
movsx   eax, cs:byte_405055
movsx   ecx, cs:byte_405054
cdq
idiv    ecx
movsx   eax, cs:byte_405056
movsx   ecx, cs:byte_405054
cdq
idiv    ecx
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_405054
cdq
idiv    ecx
movsx   eax, cs:byte_405058
movsx   ecx, cs:byte_405054
cdq
idiv    ecx
jmp     loc_402EF9

loc_402A01:
mov     eax, 0A0h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402AA2
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402AA2
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402AA2
movsx   eax, cs:byte_405054
cmp     eax, 4Fh 
mov     eax, 0
setnle  al
mov     r11, rax
mov     eax, 51h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402AA2
call    sub_4010D2
cmp     eax, 0
jnz     loc_402A8D
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402A8D
jmp     loc_402AA2

loc_402A8D:
mov     eax, 29h 
mov     r10, rax
mov     rcx, r10
call    sub_401000
jmp     loc_402EF9

loc_402AA2:
mov     eax, 0AAh
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402B3B
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402B3B
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402B3B
mov     eax, 0
mov     r11, rax
mov     eax, 56h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402B3B
call    sub_4010D2
cmp     eax, 0
jnz     loc_402B21
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402B21
jmp     loc_402B3B

loc_402B21:
movsx   eax, cs:byte_405057
sub     eax, 57h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
jmp     loc_402EF9

loc_402B3B:
mov     eax, 0B2h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402CF1
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402CF1
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402CF1
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 108h
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
mov     r11, rax
mov     eax, 5Ah 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402CF1
call    sub_4010D2
cmp     eax, 0
jnz     loc_402BDF
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402BDF
jmp     loc_402CF1

loc_402BDF:
mov     eax, 5Ch 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 16Ch
mov     eax, 0BAh
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402C77
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402C77
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402C77
lea     rax, sub_401000
mov     r11, rax
mov     eax, 5Eh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402C77
call    sub_4010D2
cmp     eax, 0
jnz     loc_402C76
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402C76
jmp     loc_402C77

loc_402C76:
nop

loc_402C77:
nop
nop
mov     eax, 7Bh 
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402CEC
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_402CEC
call    sub_4010D2
cmp     eax, 0
jz      loc_402CEC
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 60h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402CEC
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_402CEC
jmp     loc_402C77

loc_402CEC:
jmp     loc_402EF9

loc_402CF1:
mov     eax, 0C4h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402EE4
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402EE4
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402EE4
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 123h
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
movsx   ecx, cs:byte_405057
mov     r10, rcx
mov     [rbp+var_10], rax
mov     rcx, r10
call    sub_401028
cmp     eax, 0
jz      loc_402D77
jmp     loc_402D83

loc_402D77:
movsx   eax, cs:byte_405054
jmp     loc_402D8A

loc_402D83:
movsx   eax, cs:byte_405056

loc_402D8A:
mov     ecx, dword ptr [rbp+var_10]
imul    ecx, eax
mov     r11, rcx
mov     eax, 63h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402EE4
call    sub_4010D2
cmp     eax, 0
jnz     loc_402DD2
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402DD2
jmp     loc_402EE4

loc_402DD2:
mov     eax, 65h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 190h
mov     eax, 0CCh
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402E6A
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_402E6A
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_402E6A
lea     rax, sub_401000
mov     r11, rax
mov     eax, 67h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402E6A
call    sub_4010D2
cmp     eax, 0
jnz     loc_402E69
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_402E69
jmp     loc_402E6A

loc_402E69:
nop

loc_402E6A:
nop
nop
mov     eax, 84h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_402EDF
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_402EDF
call    sub_4010D2
cmp     eax, 0
jz      loc_402EDF
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 69h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_402EDF
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_402EDF
jmp     loc_402E6A

loc_402EDF:
jmp     loc_402EF9

loc_402EE4:
call    IsDebuggerPresent
cvtsi2sd xmm0, eax
movq    xmm1, cs:qword_405078
divsd   xmm1, xmm0

loc_402EF9:
movsx   eax, cs:byte_40505B
movsxd  rax, eax
mov     r10, rax
mov     rcx, r10        
call    malloc
mov     [rbp+var_18], rax
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_405056
add     eax, ecx
movsx   ecx, cs:byte_405055
add     eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
mov     eax, 0
mov     [rcx], al
movsx   eax, cs:byte_405055
movsx   ecx, cs:byte_405056
add     eax, ecx
movsx   ecx, cs:byte_405056
add     eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
movsx   eax, cs:byte_405047
mov     r10, rax
mov     [rbp+var_20], rcx
mov     rcx, r10
call    sub_401028
mov     rcx, [rbp+var_20]
mov     [rcx], al
movsx   eax, cs:byte_405056
movsx   ecx, cs:byte_405055
imul    eax, ecx
movsx   ecx, cs:byte_405056
add     eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
movsx   eax, cs:byte_405045
mov     [rcx], al
mov     eax, 6Bh 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 1A8h
mov     eax, 0D8h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403040
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_403040
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_403040
lea     rax, sub_401000
mov     r11, rax
mov     eax, 6Dh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403040
call    sub_4010D2
cmp     eax, 0
jnz     loc_40303F
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_40303F
jmp     loc_403040

loc_40303F:
nop

loc_403040:
nop
nop
mov     eax, 8Ah
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4030B5
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_4030B5
call    sub_4010D2
cmp     eax, 0
jz      loc_4030B5
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 6Fh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4030B5
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_4030B5
jmp     loc_403040

loc_4030B5:
movsx   eax, cs:byte_405058
movsx   ecx, cs:byte_405056
imul    eax, ecx
movsx   ecx, cs:byte_405059
sub     eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
movsx   eax, cs:byte_405036
mov     [rcx], al
movsx   eax, cs:byte_405055
movsx   ecx, cs:byte_405056
imul    eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
movsx   eax, cs:byte_405049
mov     [rcx], al
movsx   eax, cs:byte_405054
movsx   ecx, cs:byte_405055
add     eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
movsx   eax, cs:byte_405046
mov     [rcx], al
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
sub     eax, ecx
movsx   ecx, cs:byte_405059
sub     eax, ecx
movsxd  rax, eax
mov     rcx, [rbp+var_18]
add     rcx, rax
movsx   eax, cs:byte_405040
mov     [rcx], al
mov     eax, 71h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 1C0h
mov     eax, 0E4h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4031ED
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4031ED
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4031ED
lea     rax, sub_401000
mov     r11, rax
mov     eax, 73h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4031ED
call    sub_4010D2
cmp     eax, 0
jnz     loc_4031EC
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4031EC
jmp     loc_4031ED

loc_4031EC:
nop

loc_4031ED:
nop
nop
mov     eax, 90h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403262
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_403262
call    sub_4010D2
cmp     eax, 0
jz      loc_403262
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 75h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403262
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_403262
jmp     loc_4031ED

loc_403262:
mov     rax, [rbp+var_18]
leave
retn
sub_40275A endp

sub_403268 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403273:
call    sub_40275A
leave
retn
sub_403268 endp

sub_40327A proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403285:
call    sub_403268
leave
retn
sub_40327A endp

sub_40328C proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403297:
call    sub_40327A
leave
retn
sub_40328C endp

sub_40329E proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4032A9:
call    sub_40328C
leave
retn
sub_40329E endp

sub_4032B0 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4032BB:
call    sub_40329E
leave
retn
sub_4032B0 endp

sub_4032C2 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4032CD:
call    sub_4032B0
leave
retn
sub_4032C2 endp

sub_4032D4 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4032DF:
call    sub_4032C2
leave
retn
sub_4032D4 endp

sub_4032E6 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4032F1:
call    sub_4032D4
leave
retn
sub_4032E6 endp

sub_4032F8 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403303:
call    sub_4032E6
leave
retn
sub_4032F8 endp

sub_40330A proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403315:
call    sub_4032F8
leave
retn
sub_40330A endp

sub_40331C proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403327:
call    sub_40330A
leave
retn
sub_40331C endp

sub_40332E proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403339:
call    sub_40331C
leave
retn
sub_40332E endp

sub_403340 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40334B:
call    sub_40332E
leave
retn
sub_403340 endp

sub_403352 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40335D:
call    sub_403340
leave
retn
sub_403352 endp

sub_403364 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40336F:
call    sub_403352
leave
retn
sub_403364 endp

sub_403376 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403381:
call    sub_403364
leave
retn
sub_403376 endp

sub_403388 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403393:
call    sub_403376
leave
retn
sub_403388 endp

sub_40339A proc near

var_430= qword ptr -430h
var_418= dword ptr -418h
var_410= qword ptr -410h
var_408= qword ptr -408h
var_400= dword ptr -400h
arg_0= qword ptr  10h
arg_8= qword ptr  18h
arg_10= qword ptr  20h
arg_18= qword ptr  28h

push    rbp
mov     rbp, rsp
sub     rsp, 450h

loc_4033A5:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
mov     [rbp+arg_10], r8
mov     [rbp+arg_18], r9
mov     eax, 77h 
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 1D8h
mov     eax, 0F0h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_40344D
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_40344D
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_40344D
lea     rax, sub_401000
mov     r11, rax
mov     eax, 79h 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_40344D
call    sub_4010D2
cmp     eax, 0
jnz     loc_40344C
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_40344C
jmp     loc_40344D

loc_40344C:
nop

loc_40344D:
nop
nop
mov     eax, 96h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4034C2
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_4034C2
call    sub_4010D2
cmp     eax, 0
jz      loc_4034C2
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 7Bh 
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4034C2
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_4034C2
jmp     loc_40344D

loc_4034C2:
lea     rax, [rbp+arg_10]
mov     [rbp+var_408], rax
movsx   eax, cs:byte_405055
movsxd  rax, eax
shl     rax, 0Ah
movsx   ecx, cs:byte_405056
movsxd  rcx, ecx
imul    rax, rcx
movsx   ecx, cs:byte_405058
movsxd  rcx, ecx
imul    rax, rcx
movsx   ecx, cs:byte_40505C
movsxd  rcx, ecx
xor     rdx, rdx
div     rcx
movsx   ecx, cs:byte_405056
movsxd  rcx, ecx
shl     rcx, 0Ah
movsx   edx, cs:byte_405058
movsxd  rdx, edx
imul    rcx, rdx
movsx   edx, cs:byte_40505C
movsxd  rdx, edx
mov     [rbp+var_410], rax
mov     rax, rcx
mov     rcx, rdx
xor     rdx, rdx
div     rcx
mov     rcx, [rbp+var_410]
add     rcx, rax
movsx   eax, cs:byte_405054
mov     edx, 0CAh
imul    eax, edx
movsxd  rax, eax
add     rcx, rax
shr     rcx, 1
mov     rax, [rbp+var_408]
mov     r9, rax
mov     rax, [rbp+arg_8]
mov     r8, rax
mov     r11, rcx
lea     rax, [rbp+var_400]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_404303
mov     eax, 0FFFFFFF5h
mov     r10, rax
mov     rcx, r10
call    sub_401028
mov     r10, rax
mov     rcx, r10
call    sub_401604
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
mov     qword ptr [rbp+var_418], rax
mov     eax, [rbp+var_418]
mov     ecx, 7Dh 
imul    eax, ecx
mov     ecx, dword ptr [rbp+arg_0]
add     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401000
lea     rax, [rbp+var_400]
mov     r10, rax
mov     rcx, r10
call    sub_401F47
mov     rcx, 0
mov     [rsp+450h+var_430], rcx 
mov     rcx, 0
mov     r9, rcx         
mov     r8, rax         
lea     rax, [rbp+var_400]
mov     r11, rax
mov     rax, qword ptr [rbp+var_418]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    sub_4015B4
leave
retn
sub_40339A endp

sub_40362C proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403637:
nop
cpuid
nop
lea     rax, aScanf     
leave
retn
sub_40362C endp

sub_403644 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_40364F:
nop
cpuid
nop
lea     rax, aSprintf   
leave
retn
sub_403644 endp

sub_40365C proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403667:
nop
cpuid
nop
lea     rax, aFclose    
leave
retn
sub_40365C endp

sub_403674 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_40367F:
nop
cpuid
nop
lea     rax, aFopen     
leave
retn
sub_403674 endp

sub_40368C proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403697:
nop
cpuid
nop
lea     rax, aFread     
leave
retn
sub_40368C endp

sub_4036A4 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_4036AF:
nop
cpuid
nop
lea     rax, aFwrite    
leave
retn
sub_4036A4 endp

sub_4036BC proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_4036C7:
nop
cpuid
nop
lea     rax, aExit      
leave
retn
sub_4036BC endp

sub_4036D4 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_4036DF:
nop
cpuid
nop
lea     rax, aStrcpy    
leave
retn
sub_4036D4 endp

sub_4036EC proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_4036F7:
nop
cpuid
nop
lea     rax, aStrtok    
leave
retn
sub_4036EC endp

sub_403704 proc near

arg_0= qword ptr  10h
arg_8= qword ptr  18h
Size= qword ptr  20h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40370F:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
mov     [rbp+Size], r8
mov     eax, dword ptr [rbp+arg_8]
movsx   ecx, cs:byte_405055
imul    eax, ecx
mov     rcx, [rbp+Size]
mov     r8, rcx         
mov     r11, rax
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    memset
leave
retn
sub_403704 endp

sub_403746 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403751:
nop
cpuid
nop
lea     rax, aMemcpy    
leave
retn
sub_403746 endp

sub_40375E proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403769:
nop
cpuid
nop
lea     rax, aStrchr    
leave
retn
sub_40375E endp

sub_403776 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403781:
nop
cpuid
nop
lea     rax, aStrrchr   
leave
retn
sub_403776 endp

sub_40378E proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_403799:
nop
cpuid
nop
lea     rax, aRand      
leave
retn
sub_40378E endp

sub_4037A6 proc near
push    rbp
mov     rbp, rsp
sub     rsp, 0

loc_4037B1:
nop
cpuid
nop
lea     rax, aRealloc   
leave
retn
sub_4037A6 endp

sub_4037BE proc near

Count= qword ptr  10h
Size= qword ptr  18h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4037C9:
mov     [rbp+Count], rcx
mov     [rbp+Size], rdx
mov     rax, [rbp+Size]
mov     r11, rax
mov     rax, [rbp+Count]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    calloc
leave
retn
sub_4037BE endp

sub_4037EC proc near

var_10= qword ptr -10h
var_8= qword ptr -8
arg_0= qword ptr  10h
arg_8= qword ptr  18h

push    rbp
mov     rbp, rsp
sub     rsp, 30h

loc_4037F7:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
call    sub_403388
mov     r10, rax
mov     rcx, r10
call    sub_402500
mov     [rbp+var_8], rax
call    sub_4037A6
mov     r11, rax
mov     rax, [rbp+var_8]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401632
mov     rcx, [rbp+arg_8]
mov     r11, rcx
mov     rcx, [rbp+arg_0]
mov     r10, rcx
mov     [rbp+var_10], rax
mov     rcx, r10
mov     rdx, r11
mov     r11, [rbp+var_10]
call    r11
leave
retn
sub_4037EC endp

sub_40384E proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403859:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
call    gets
leave
retn
sub_40384E endp

sub_40386E proc near

var_C= dword ptr -0Ch
var_8= qword ptr -8
arg_0= qword ptr  10h
arg_8= qword ptr  18h
arg_10= qword ptr  20h
arg_18= qword ptr  28h

push    rbp
mov     rbp, rsp
sub     rsp, 30h

loc_403879:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
mov     [rbp+arg_10], r8
mov     [rbp+arg_18], r9
lea     rax, [rbp+arg_18]
mov     [rbp+var_8], rax
mov     rax, [rbp+var_8]
mov     r9, rax
mov     rax, [rbp+arg_10]
mov     r8, rax
mov     rax, [rbp+arg_8]
mov     r11, rax
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_404303
mov     [rbp+var_C], eax
mov     eax, [rbp+var_C]
leave
retn
sub_40386E endp

sub_4038C0 proc near

Buffer= qword ptr  10h
Format= qword ptr  18h
ArgList= qword ptr  20h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4038CB:
mov     [rbp+Buffer], rcx
mov     [rbp+Format], rdx
mov     [rbp+ArgList], r8
mov     rax, [rbp+ArgList]
mov     r8, rax         
mov     rax, [rbp+Format]
mov     r11, rax
mov     rax, [rbp+Buffer]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    vsprintf
leave
retn
sub_4038C0 endp

sub_4038F9 proc near

arg_0= qword ptr  10h
arg_8= qword ptr  18h
arg_10= qword ptr  20h
arg_18= qword ptr  28h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403904:
mov     [rbp+arg_0], rcx
mov     [rbp+arg_8], rdx
mov     [rbp+arg_10], r8
mov     [rbp+arg_18], r9
mov     rax, [rbp+arg_18]
mov     r9, rax
mov     rax, [rbp+arg_10]
mov     r8, rax
mov     rax, [rbp+arg_8]
mov     r11, rax
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_404303
leave
retn
sub_4038F9 endp

sub_40393D proc near

VarName= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403948:
mov     [rbp+VarName], rcx
mov     rax, [rbp+VarName]
mov     r10, rax
mov     rcx, r10        
call    getenv
leave
retn
sub_40393D endp

sub_40395D proc near

Command= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403968:
mov     [rbp+Command], rcx
mov     rax, [rbp+Command]
mov     r10, rax
mov     rcx, r10        
call    system
leave
retn
sub_40395D endp

sub_40397D proc near
push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403988:
call    abort
sub_40397D endp

leave
retn

sub_40398F proc near

arg_0= qword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40399A:
mov     [rbp+arg_0], rcx
mov     rax, [rbp+arg_0]
mov     r10, rax
mov     rcx, r10        
call    atexit
leave
retn
sub_40398F endp

sub_4039AF proc near

DstBuf= qword ptr  10h
SizeInBytes= dword ptr  18h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4039BA:
mov     [rbp+DstBuf], rcx
mov     qword ptr [rbp+SizeInBytes], rdx
mov     rax, qword ptr [rbp+SizeInBytes]
mov     r11, rax
mov     rax, [rbp+DstBuf]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    _getcwd
movsxd  rax, eax
leave
retn
sub_4039AF endp

sub_4039E0 proc near

C= dword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_4039EB:
mov     qword ptr [rbp+C], rcx
mov     eax, [rbp+C]
mov     r10, rax
mov     rcx, r10        
call    tolower
leave
retn
sub_4039E0 endp

sub_4039FF proc near

C= dword ptr  10h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_403A0A:
mov     qword ptr [rbp+C], rcx
mov     eax, [rbp+C]
mov     r10, rax
mov     rcx, r10        
call    toupper
leave
retn
sub_4039FF endp

sub_403A1E proc near

var_48= qword ptr -48h
var_40= qword ptr -40h
var_38= qword ptr -38h
var_30= qword ptr -30h
var_28= qword ptr -28h
var_20= qword ptr -20h
Block= qword ptr -18h
var_10= qword ptr -10h
var_4= dword ptr -4

push    rbp
mov     rbp, rsp
sub     rsp, 70h

loc_403A29:
mov     eax, 0
mov     [rbp+var_4], eax
mov     eax, 0
mov     [rbp+var_4], eax

loc_403A39:
mov     eax, [rbp+var_4]
cmp     eax, 5
jge     loc_4042BE
jmp     loc_403AFC

loc_403A4A:
mov     eax, [rbp+var_4]
mov     rcx, rax
add     eax, 1
mov     [rbp+var_4], eax
cmp     ecx, 0
jz      loc_403AE7
movsx   eax, cs:byte_40505D
movsx   ecx, cs:byte_40505B
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 0FCh
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505C
cdq
idiv    ecx
movsx   ecx, cs:byte_405055
sub     eax, ecx
mov     ecx, 8Ah
imul    eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsx   ecx, cs:byte_405057
movsx   edx, cs:byte_40505A
add     ecx, edx
movsx   edx, cs:byte_405054
mov     [rbp+var_10], rax
mov     eax, 180h
imul    edx, eax
add     ecx, edx
movsx   eax, cs:byte_40505D
sub     ecx, eax
mov     eax, dword ptr [rbp+var_10]
add     eax, ecx
cmp     eax, 0
jz      loc_403AE7
jmp     loc_403AF7

loc_403AE7:
movsx   eax, cs:byte_405055
cmp     eax, 0
jnz     $+6

loc_403AF7:
jmp     loc_403A39

loc_403AFC:
mov     eax, 100h
mov     r10, rax
mov     rcx, r10
call    sub_401028
movsxd  rax, eax
mov     r10, rax
mov     rcx, r10        
call    malloc
mov     [rbp+Block], rax
call    sub_403388
mov     r10, rax
mov     rcx, r10
call    sub_402500
mov     [rbp+var_20], rax
call    sub_4036D4
mov     r11, rax
mov     rax, [rbp+var_20]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401632
lea     rcx, aDHelloWorld 
mov     r11, rcx
mov     rcx, [rbp+Block]
mov     r10, rcx
mov     [rbp+var_28], rax
mov     rcx, r10
mov     rdx, r11
mov     r11, [rbp+var_28]
call    r11
call    sub_403388
mov     r10, rax
mov     rcx, r10
call    sub_402500
mov     [rbp+var_30], rax
call    sub_403644
mov     r11, rax
mov     rax, [rbp+var_30]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401632
mov     ecx, [rbp+var_4]
add     ecx, 1
mov     r8, rcx
mov     rcx, [rbp+Block]
mov     r11, rcx
mov     rcx, [rbp+Block]
mov     r10, rcx
mov     [rbp+var_38], rax
mov     rcx, r10
mov     rdx, r11
mov     r11, [rbp+var_38]
call    r11
mov     eax, 102h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403D02
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_403D02
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_403D02
mov     eax, dword ptr [rbp+Block]
mov     r11, rax
mov     eax, 82h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403D02
call    sub_4010D2
cmp     eax, 0
jnz     loc_403C41
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_403C41
jmp     loc_403D02

loc_403C41:
mov     eax, 189h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
mov     eax, 0
setl    al
mov     r10, rax
mov     rcx, r10
call    sub_401000
mov     rax, [rbp+Block]
mov     r11, rax
mov     eax, 84h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40339A
mov     eax, 0A2h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403CFD
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_403CFD
call    sub_4010D2
cmp     eax, 0
jz      loc_403CFD
movsx   eax, cs:byte_405054
cmp     eax, 15Ch
mov     eax, 0
setnle  al
mov     r11, rax
mov     eax, 87h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403CFD
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_403CFD
jmp     loc_403C41

loc_403CFD:
jmp     loc_4042AA

loc_403D02:
mov     eax, 112h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403DA6
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_403DA6
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_403DA6
movsx   eax, cs:byte_405054
cmp     eax, 88h
mov     eax, 0
setnle  al
mov     r11, rax
mov     eax, 8Ah
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403DA6
call    sub_4010D2
cmp     eax, 0
jnz     loc_403D91
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_403D91
jmp     loc_403DA6

loc_403D91:
mov     eax, 45h 
mov     r10, rax
mov     rcx, r10
call    sub_401000
jmp     loc_4042AA

loc_403DA6:
mov     eax, 11Ch
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403E42
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_403E42
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_403E42
mov     eax, 0
mov     r11, rax
mov     eax, 8Fh
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403E42
call    sub_4010D2
cmp     eax, 0
jnz     loc_403E25
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_403E25
jmp     loc_403E42

loc_403E25:
movsx   eax, cs:byte_405057
sub     eax, 90h
mov     r10, rax
mov     rcx, r10
call    sub_401028
jmp     loc_4042AA

loc_403E42:
mov     eax, 124h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403FF8
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_403FF8
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_403FF8
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 1B3h
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
mov     r11, rax
mov     eax, 93h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403FF8
call    sub_4010D2
cmp     eax, 0
jnz     loc_403EE6
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_403EE6
jmp     loc_403FF8

loc_403EE6:
mov     eax, 95h
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 250h
mov     eax, 12Ch
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403F7E
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_403F7E
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_403F7E
lea     rax, sub_401000
mov     r11, rax
mov     eax, 97h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403F7E
call    sub_4010D2
cmp     eax, 0
jnz     loc_403F7D
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_403F7D
jmp     loc_403F7E

loc_403F7D:
nop

loc_403F7E:
nop
nop
mov     eax, 0B4h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_403FF3
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_403FF3
call    sub_4010D2
cmp     eax, 0
jz      loc_403FF3
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 99h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_403FF3
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_403FF3
jmp     loc_403F7E

loc_403FF3:
jmp     loc_4042AA

loc_403FF8:
mov     eax, 136h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4041EB
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_4041EB
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_4041EB
movsx   eax, cs:byte_405057
movsx   ecx, cs:byte_40505A
add     eax, ecx
movsx   ecx, cs:byte_405054
mov     edx, 1CEh
imul    ecx, edx
add     eax, ecx
movsx   ecx, cs:byte_40505D
sub     eax, ecx
movsx   ecx, cs:byte_405057
mov     r10, rcx
mov     [rbp+var_40], rax
mov     rcx, r10
call    sub_401028
cmp     eax, 0
jz      loc_40407E
jmp     loc_40408A

loc_40407E:
movsx   eax, cs:byte_405054
jmp     loc_404091

loc_40408A:
movsx   eax, cs:byte_405056

loc_404091:
mov     ecx, dword ptr [rbp+var_40]
imul    ecx, eax
mov     r11, rcx
mov     eax, 9Ch
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4041EB
call    sub_4010D2
cmp     eax, 0
jnz     loc_4040D9
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_4040D9
jmp     loc_4041EB

loc_4040D9:
mov     eax, 9Eh
mov     r10, rax
mov     rcx, r10
call    sub_401028
add     eax, 274h
mov     eax, 13Eh
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_404171
movsx   eax, cs:byte_405055
cmp     eax, 0
jz      loc_404171
call    sub_4010D2
movsx   ecx, cs:byte_405056
cmp     ecx, eax
jle     loc_404171
lea     rax, sub_401000
mov     r11, rax
mov     eax, 0A0h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_404171
call    sub_4010D2
cmp     eax, 0
jnz     loc_404170
movsx   eax, cs:byte_405054
cmp     eax, 0
jnz     loc_404170
jmp     loc_404171

loc_404170:
nop

loc_404171:
nop
nop
mov     eax, 0BDh
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4041E6
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_4041E6
call    sub_4010D2
cmp     eax, 0
jz      loc_4041E6
movsx   eax, cs:byte_405054
mov     r11, rax
mov     eax, 0A2h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4041E6
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_4041E6
jmp     loc_404171

loc_4041E6:
jmp     loc_4042AA

loc_4041EB:
mov     eax, 1E9h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
mov     eax, 0
setl    al
mov     r10, rax
mov     rcx, r10
call    sub_401000
lea     rax, aError     
mov     r11, rax
mov     eax, 0A4h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40339A
mov     eax, 0C2h
movsx   ecx, cs:byte_405054
cmp     eax, ecx
jle     loc_4042AA
movsx   eax, cs:byte_40505C
movsx   ecx, cs:byte_405057
cmp     eax, ecx
jle     loc_4042AA
call    sub_4010D2
cmp     eax, 0
jz      loc_4042AA
movsx   eax, cs:byte_405054
cmp     eax, 19Ch
mov     eax, 0
setnle  al
mov     r11, rax
mov     eax, 0A7h
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_40112B
cmp     eax, 0
jz      loc_4042AA
movsx   eax, cs:byte_405059
cmp     eax, 0
jz      loc_4042AA
jmp     loc_4041EB

loc_4042AA:
mov     rax, [rbp+Block]
mov     r10, rax
mov     rcx, r10        
call    free
jmp     loc_403A4A

loc_4042BE:
call    _getch
movsx   ecx, cs:byte_405057
movsx   edx, cs:byte_40505A
add     ecx, edx
movsx   edx, cs:byte_405054
mov     [rbp+var_48], rax
mov     eax, 1F8h
imul    edx, eax
add     ecx, edx
movsx   eax, cs:byte_40505D
sub     ecx, eax
mov     eax, dword ptr [rbp+var_48]
add     eax, ecx
mov     r10, rax
mov     rcx, r10
call    sub_401028
leave
retn
sub_403A1E endp

sub_404303 proc near

Buffer= qword ptr  10h
BufferCount= qword ptr  18h
Format= qword ptr  20h
ArgList= qword ptr  28h

push    rbp
mov     rbp, rsp
sub     rsp, 20h

loc_40430E:
mov     [rbp+Buffer], rcx
mov     [rbp+BufferCount], rdx
mov     [rbp+Format], r8
mov     [rbp+ArgList], r9
mov     rax, [rbp+ArgList]
mov     r9, rax         
mov     rax, [rbp+Format]
mov     r8, rax         
mov     rax, [rbp+BufferCount]
mov     r11, rax
mov     rax, [rbp+Buffer]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    _vsnprintf
leave
retn
sub_404303 endp

algn_404347:
align 8

public start
start proc near

var_30= qword ptr -30h
var_18= qword ptr -18h
var_10= qword ptr -10h
var_4= dword ptr -4

push    rbp
mov     rbp, rsp
sub     rsp, 50h

loc_404353:
mov     eax, 0
mov     [rbp+var_4], eax
mov     eax, 1
mov     r10, rax
mov     rcx, r10        
call    __set_app_type
mov     eax, 30000h
mov     r11, rax
mov     eax, 10000h
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    _controlfp
mov     rax, cs:__argc
mov     rcx, cs:__argv
mov     rdx, cs:_environ
mov     [rbp+var_10], rax
lea     rax, [rbp+var_4]
mov     [rsp+50h+var_30], rax
mov     eax, cs:dword_4054A8
mov     r9, rax
mov     r8, rdx
mov     r11, rcx
mov     rax, [rbp+var_10]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    __getmainargs
mov     rax, cs:__argc
mov     rcx, cs:__argv
mov     rdx, cs:_environ
mov     [rbp+var_18], rax
mov     rax, [rdx]
mov     r8, rax
mov     rax, [rcx]
mov     r11, rax
mov     rax, [rbp+var_18]
mov     eax, [rax]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_403A1E
mov     r10, rax
mov     rcx, r10        
call    exit
start endp

leave
retn
algn_40440F:
align 10h
stru_404410 UNWIND_INFO_HDR <1, 4, 2, 5>
UNWIND_CODE <4, 3>      
UNWIND_CODE <1, 50h>    
push    rbp
mov     rbp, rsp
sub     rsp, 30h

sub_404423 proc near
mov     [rbp+10h], rcx
mov     [rbp+18h], rdx
mov     rax, cs:__argc
mov     ecx, [rbp+10h]
mov     [rax], ecx
mov     rax, cs:__argv
mov     rcx, [rbp+18h]
mov     [rax], rcx
mov     eax, 30000h
mov     r11, rax
mov     eax, 10000h
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    _controlfp
mov     rax, cs:__argc
mov     rcx, cs:__argv
mov     rdx, cs:_environ
mov     [rbp-8], rax
mov     rax, [rdx]
mov     r8, rax
mov     rax, [rcx]
mov     r11, rax
mov     rax, [rbp-8]
mov     eax, [rax]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_403A1E
leave
retn
sub_404423 endp

algn_40449B:
align 20h

align 8

align 10h

align 8

align 20h

align 8

align 10h

align 8

align 20h

align 8

align 10h

align 8

align 20h

align 8

align 10h

align 8

align 20h

align 8

align 10h

align 8

align 20h

align 8

align 10h

align 8

align 20h

align 8

align 100h
dq 140h dup(?)
_text ends

_data segment para public 'DATA' use64
assume cs:_data

aAbcdefghijklmn:
text "UTF-16LE", 'abcdefghijklmnopqrstu'
text "UTF-16LE", 'vwxyz'
byte_405034 db 61h
db  62h 
byte_405036 db 63h
byte_405037 db 64h
byte_405038 db 65h
db  66h 
db  67h 
db  68h 
db  69h 
db  6Ah 
byte_40503E db 6Bh
byte_40503F db 6Ch
byte_405040 db 6Dh
byte_405041 db 6Eh
byte_405042 db 6Fh
db  70h 
db  71h 
byte_405045 db 72h
byte_405046 db 73h
byte_405047 db 74h
db  75h 
byte_405049 db 76h
db  77h 
db  78h 
db  79h 
db  7Ah 
db  53h 
byte_40504F db 4Ch
byte_405050 db 41h
db  49h 
db  44h 
db  50h 
byte_405054 db 0
byte_405055 db 1
byte_405056 db 2
byte_405057 db 3
byte_405058 db 4
byte_405059 db 5
byte_40505A db 6
byte_40505B db 7
byte_40505C db 8
byte_40505D db 9
align 20h
qword_405060 dq 0

Source db '%d%d',0

Destination db 'Library',0

aC db '%c',0
qword_405078 dq 0
aScanf db 'scanf',0
aSprintf db 'sprintf',0
aFclose db 'fclose',0
aFopen db 'fopen',0
aFread db 'fread',0
aFwrite db 'fwrite',0
aExit db 'exit',0
aStrcpy db 'strcpy',0
aStrtok db 'strtok',0
aMemcpy db 'memcpy',0
aStrchr db 'strchr',0
aStrrchr db 'strrchr',0
aRand db 'rand',0
aRealloc db 'realloc',0
aDHelloWorld db '%d) Hello, world!',0Ah,0
aError db 'Error!',0
align 20h
__IMPORT_DESCRIPTOR_kernel32 dd rva off_405234 
dd 0                    
dd 0                    
dd rva aKernel32Dll     
dd rva __imp_WriteConsoleA 
__IMPORT_DESCRIPTOR_msvcrt dd rva off_405264 
dd 0                    
dd 0                    
dd rva aMsvcrtDll       
dd rva __imp_strcat     
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_data ends

extrn __imp_WriteConsoleA:qword

extrn __imp_GetStdHandle:qword

extrn __imp_GetProcAddress:qword

extrn __imp_GetModuleHandleA:qword

extrn __imp_IsDebuggerPresent:qword

extrn __imp_strcat:qword

extrn __imp_sprintf:qword

extrn __imp_malloc:qword

extrn __imp_memset:qword

extrn __imp_calloc:qword
extrn __imp_gets:qword

extrn __imp_vsprintf:qword

extrn __imp_getenv:qword

extrn __imp_system:qword

extrn __imp_abort:qword

extrn __imp_atexit:qword

extrn __imp__getcwd:qword

extrn __imp_tolower:qword

extrn __imp_toupper:qword

extrn __imp_free:qword

extrn __imp__getch:qword

extrn __imp__vsnprintf:qword

extrn __imp___set_app_type:qword

extrn __imp__controlfp:qword

extrn __argc:qword

extrn __argv:qword

extrn _environ:qword
extrn __imp___getmainargs:qword

extrn __imp_exit:qword

_data segment para public 'DATA' use64
assume cs:_data

off_405234 dq rva word_405339
dq rva word_405349
dq rva word_405358
dq rva word_405369
dq rva word_40537C
dq 0

off_405264 dq rva word_40539B
dq rva word_4053A4
dq rva word_4053AE
dq rva word_4053B7
dq rva word_4053C0
dq rva word_4053C9
dq rva word_4053D0
dq rva word_4053DB
dq rva word_4053E4
dq rva word_4053ED
dq rva word_4053F5
dq rva word_4053FE
dq rva word_405408
dq rva word_405412
dq rva word_40541C
dq rva word_405423
dq rva word_40542C
dq rva word_405439
dq rva word_40544A
dq rva word_405457
dq rva word_405460
dq rva word_405469
dq rva word_405474
dq rva word_405484
dq 0
aKernel32Dll db 'kernel32.dll',0
word_405339 dw 0
db 'WriteConsoleA',0
word_405349 dw 0
db 'GetStdHandle',0
word_405358 dw 0
db 'GetProcAddress',0
word_405369 dw 0
db 'GetModuleHandleA',0
word_40537C dw 0
db 'IsDebuggerPresent',0
aMsvcrtDll db 'msvcrt.dll',0
word_40539B dw 0
db 'strcat',0
word_4053A4 dw 0
db 'sprintf',0
word_4053AE dw 0
db 'malloc',0
word_4053B7 dw 0
db 'memset',0
word_4053C0 dw 0
db 'calloc',0
word_4053C9 dw 0
db 'gets',0
word_4053D0 dw 0
db 'vsprintf',0
word_4053DB dw 0
db 'getenv',0
word_4053E4 dw 0
db 'system',0
word_4053ED dw 0
db 'abort',0
word_4053F5 dw 0
db 'atexit',0
word_4053FE dw 0
db '_getcwd',0
word_405408 dw 0
db 'tolower',0
word_405412 dw 0
db 'toupper',0
word_40541C dw 0
db 'free',0
word_405423 dw 0
db '_getch',0
word_40542C dw 0
db '_vsnprintf',0
word_405439 dw 0
db '__set_app_type',0
word_40544A dw 0
db '_controlfp',0
word_405457 dw 0
db '__argc',0
word_405460 dw 0
db '__argv',0
word_405469 dw 0
db '_environ',0
word_405474 dw 0
db '__getmainargs',0
word_405484 dw 0
db 'exit',0
align 10h
unk_405490 db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0

byte_4054A0 db 8 dup(0)
dword_4054A8 dd 0
align 1000h
_data ends

_pdata segment para public 'DATA' use64
assume cs:_pdata

ExceptionDir RUNTIME_FUNCTION <rva loc_40100B, \
                  rva algn_40101E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_401033, \
                  rva sub_401085, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_401090, \
                  rva sub_4010D2, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4010DD, \
                  rva sub_40112B, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_401136, \
                  rva sub_40130B, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_401316, \
                  rva sub_4015B4, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4015BF, \
                  rva sub_401604, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40160F, \
                  rva sub_401632, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40163D, \
                  rva sub_401664, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40166F, \
                  rva sub_401688, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_401693, \
                  rva sub_401F47, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_401F52, \
                  rva sub_402050, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40205B, \
                  rva sub_402460, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40246B, \
                  rva sub_402480, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40248B, \
                  rva sub_4024A0, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4024AB, \
                  rva sub_4024C0, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4024CB, \
                  rva sub_4024E0, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4024EB, \
                  rva sub_402500, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40250B, \
                  rva sub_402520, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40252B, \
                  rva sub_40274C, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_402757, \
                  rva sub_40275A, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_402765, \
                  rva sub_403268, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403273, \
                  rva sub_40327A, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403285, \
                  rva sub_40328C, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403297, \
                  rva sub_40329E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4032A9, \
                  rva sub_4032B0, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4032BB, \
                  rva sub_4032C2, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4032CD, \
                  rva sub_4032D4, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4032DF, \
                  rva sub_4032E6, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4032F1, \
                  rva sub_4032F8, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403303, \
                  rva sub_40330A, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403315, \
                  rva sub_40331C, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403327, \
                  rva sub_40332E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403339, \
                  rva sub_403340, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40334B, \
                  rva sub_403352, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40335D, \
                  rva sub_403364, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40336F, \
                  rva sub_403376, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403381, \
                  rva sub_403388, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403393, \
                  rva sub_40339A, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4033A5, \
                  rva sub_40362C, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403637, \
                  rva sub_403644, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40364F, \
                  rva sub_40365C, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403667, \
                  rva sub_403674, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40367F, \
                  rva sub_40368C, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403697, \
                  rva sub_4036A4, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4036AF, \
                  rva sub_4036BC, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4036C7, \
                  rva sub_4036D4, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4036DF, \
                  rva sub_4036EC, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4036F7, \
                  rva sub_403704, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40370F, \
                  rva sub_403746, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403751, \
                  rva sub_40375E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403769, \
                  rva sub_403776, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403781, \
                  rva sub_40378E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403799, \
                  rva sub_4037A6, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4037B1, \
                  rva sub_4037BE, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4037C9, \
                  rva sub_4037EC, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4037F7, \
                  rva sub_40384E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403859, \
                  rva sub_40386E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403879, \
                  rva sub_4038C0, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4038CB, \
                  rva sub_4038F9, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403904, \
                  rva sub_40393D, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403948, \
                  rva sub_40395D, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403968, \
                  rva sub_40397D, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403988, \
                  rva sub_40398F, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40399A, \
                  rva sub_4039AF, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4039BA, \
                  rva sub_4039E0, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_4039EB, \
                  rva sub_4039FF, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403A0A, \
                  rva sub_403A1E, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_403A29, \
                  rva sub_404303, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_40430E, \
                  rva algn_404347, \
                  rva stru_401020>
RUNTIME_FUNCTION <rva loc_404353, \
                  rva algn_40440F, \
                  rva stru_404410>
RUNTIME_FUNCTION <rva sub_404423, \
                  rva algn_40449B, \
                  rva stru_404410>
align 1000h
_pdata ends

end start
```

`tests/disasm-security-audit/legacy_tests/ASM/after_x86.asm`:

```asm
_crt_unknown_app  = 0
_crt_console_app  = 1
_crt_gui_app  = 2

.686p
.mmx
.model flat

_text segment para public 'CODE' use32
assume cs:_text

assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

sub_401000 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
leave
retn
sub_401000 endp

sub_40100D proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
movsx   eax, byte_405057
push    eax
movsx   eax, byte_405054
push    eax
call    sub_401000
add     esp, 8
nop
cpuid
nop
mov     eax, [ebp+arg_0]
movsx   ecx, byte_405055
imul    eax, ecx
movsx   ecx, byte_405058
movsx   edx, byte_405056
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505C
sub     eax, ecx
leave
retn
sub_40100D endp

push    ebp
mov     ebp, esp
sub     esp, 0
nop
movsx   eax, byte_40505A
push    eax
movsx   eax, byte_405056
push    eax
call    sub_401000
add     esp, 8
nop
cpuid
nop
movsx   eax, byte_405055
push    eax
fild    dword ptr [esp]
add     esp, 4
fmul    qword ptr [ebp+8]
leave
retn

sub_401097 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4010E8
movsx   eax, byte_40505D
movsx   ecx, byte_40505B
add     eax, ecx
movsx   ecx, byte_40505C
cdq
idiv    ecx
movsx   ecx, byte_405055
sub     eax, ecx
cmp     eax, 0
jz      loc_4010E8
mov     eax, 1
jmp     short locret_4010ED

loc_4010E8:
mov     eax, 0

locret_4010ED:
leave
retn
sub_401097 endp

sub_4010EF proc near

var_8= dword ptr -8
var_4= dword ptr -4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch

push    ebp
mov     ebp, esp
sub     esp, 8
nop
mov     eax, [ebp+arg_4]
movsx   ecx, byte_405055
imul    eax, ecx
push    eax
call    sub_40100D
add     esp, 4
mov     [ebp+var_4], eax
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 3
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
mov     ecx, [ebp+arg_0]
imul    eax, ecx
mov     ecx, [ebp+var_4]
cmp     ecx, eax
jnz     loc_401199
movsx   eax, byte_405058
movsx   ecx, byte_405056
imul    eax, ecx
movsx   ecx, byte_40505C
sub     ecx, eax
cmp     ecx, 0
jz      loc_40118A
call    sub_401097
cmp     eax, 0
jz      loc_401183
jmp     loc_40118A

loc_401183:
mov     eax, 1
jmp     short loc_40118F

loc_40118A:
mov     eax, 0

loc_40118F:
jmp     locret_4012BD
jmp     loc_4012AD

loc_401199:
movsx   eax, byte_40505D
movsx   ecx, byte_40505B
add     eax, ecx
movsx   ecx, byte_405054
shl     ecx, 2
add     eax, ecx
movsx   ecx, byte_40505C
cdq
idiv    ecx
movsx   ecx, byte_405055
sub     eax, ecx
mov     ecx, [ebp+var_4]
cmp     ecx, eax
jnz     loc_4012AD
call    sub_401097
cmp     eax, 0
jnz     loc_401251
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 9
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
cmp     eax, 0
jnz     loc_401251
movsx   eax, byte_40505D
movsx   ecx, byte_40505B
add     eax, ecx
movsx   ecx, byte_405054
shl     ecx, 3
add     eax, ecx
movsx   ecx, byte_40505C
cdq
idiv    ecx
movsx   ecx, byte_405055
sub     eax, ecx
cmp     eax, 0
jnz     loc_401251
jmp     loc_4012A3

loc_401251:
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 0Fh
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
movsx   ecx, byte_405055
push    ecx
mov     [ebp+var_8], eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_8]
add     ecx, eax
cmp     ecx, 0
jz      loc_4012A3
mov     eax, 1
jmp     short loc_4012A8

loc_4012A3:
mov     eax, 0

loc_4012A8:
jmp     locret_4012BD

loc_4012AD:
nop
cpuid
nop
mov     eax, [ebp+arg_4]
push    eax
call    sub_40100D
add     esp, 4

locret_4012BD:
leave
retn
sub_4010EF endp

sub_4012BF proc near

var_10= dword ptr -10h
var_C= dword ptr -0Ch
var_8= dword ptr -8
var_4= dword ptr -4
arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 10h
nop
mov     eax, 0Eh
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4013D5
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4013D5
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4013D5
mov     eax, [ebp+arg_0]
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40138B
movsx   eax, byte_405055
shl     eax, 4
movsx   ecx, byte_405056
imul    eax, ecx
movsx   ecx, byte_405058
imul    eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
movsx   ecx, byte_405056
shl     ecx, 4
movsx   edx, byte_405058
imul    ecx, edx
mov     [ebp+var_4], eax
mov     eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
mov     ecx, [ebp+var_4]
add     ecx, eax
movsx   eax, byte_405054
mov     edx, 54h 
imul    eax, edx
add     ecx, eax
shr     ecx, 1
mov     eax, [ebp+arg_0]
cmp     eax, ecx
jnb     loc_40138B
mov     eax, 0
jmp     short loc_401390

loc_40138B:
mov     eax, 1

loc_401390:
push    eax
mov     eax, 8
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4013D5
call    sub_401097
cmp     eax, 0
jnz     loc_4013CB
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4013CB
jmp     loc_4013D5

loc_4013CB:
mov     eax, 0
jmp     locret_40150F

loc_4013D5:
movsx   eax, byte_405055
movsx   ecx, byte_405059
imul    eax, ecx
movsx   ecx, byte_405058
sub     eax, ecx
movsx   ecx, byte_405055
add     eax, ecx
movsx   ecx, byte_405056
sub     eax, ecx
mov     [ebp+var_8], eax
mov     eax, offset unk_4053D4
mov     [ebp+var_C], eax
movsx   eax, byte_405054
mov     [ebp+var_8], eax

loc_401416:
mov     eax, [ebp+var_8]
mov     ecx, [ebp+arg_0]
cmp     eax, ecx
jge     loc_4014FC
jmp     loc_4014D5

loc_401429:
mov     eax, [ebp+var_8]
mov     ecx, eax
inc     eax
mov     [ebp+var_8], eax
cmp     ecx, 0
jz      loc_4014C0
movsx   eax, byte_40505D
movsx   ecx, byte_40505B
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 12h
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505C
cdq
idiv    ecx
movsx   ecx, byte_405055
sub     eax, ecx
mov     ecx, 15h
imul    eax, ecx
push    eax
call    sub_40100D
add     esp, 4
movsx   ecx, byte_405057
movsx   edx, byte_40505A
add     ecx, edx
movsx   edx, byte_405054
mov     [ebp+var_10], eax
mov     eax, 21h 
imul    edx, eax
add     ecx, edx
movsx   eax, byte_40505D
sub     ecx, eax
mov     eax, [ebp+var_10]
add     eax, ecx
cmp     eax, 0
jz      loc_4014C0
jmp     loc_4014D0

loc_4014C0:
movsx   eax, byte_405055
cmp     eax, 0
jnz     $+6

loc_4014D0:
jmp     loc_401416

loc_4014D5:
mov     eax, [ebp+var_C]
mov     ecx, eax
inc     eax
mov     [ebp+var_C], eax
mov     eax, 25h 
mov     [ecx], al
mov     eax, [ebp+var_C]
mov     ecx, eax
inc     eax
mov     [ebp+var_C], eax
movsx   eax, byte_405036
mov     [ecx], al
jmp     loc_401429

loc_4014FC:
mov     eax, [ebp+var_C]
mov     ecx, 0
mov     [eax], cl
nop
cpuid
nop
mov     eax, offset unk_4053D4

locret_40150F:
leave
retn
sub_4012BF endp

sub_401511 proc near

hConsoleOutput= dword ptr  8
lpBuffer= dword ptr  0Ch
nNumberOfCharsToWrite= dword ptr  10h
lpNumberOfCharsWritten= dword ptr  14h
lpReserved= dword ptr  18h

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, [ebp+lpReserved]
push    eax             
mov     eax, [ebp+lpNumberOfCharsWritten]
push    eax             
mov     eax, [ebp+nNumberOfCharsToWrite]
push    eax             
mov     eax, [ebp+lpBuffer]
push    eax             
mov     eax, [ebp+hConsoleOutput]
push    eax             
call    WriteConsoleA
leave
retn
sub_401511 endp

sub_40153A proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_40100D
add     esp, 4
push    eax             
call    GetStdHandle
leave
retn
sub_40153A endp

sub_40155C proc near

hModule= dword ptr  8
lpProcName= dword ptr  0Ch

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, [ebp+lpProcName]
push    eax             
mov     eax, [ebp+hModule]
push    eax             
call    GetProcAddress
leave
retn    8
sub_40155C endp

sub_40157B proc near

lpModuleName= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, [ebp+lpModuleName]
push    eax             
call    GetModuleHandleA
leave
retn
sub_40157B endp

push    ebp
mov     ebp, esp
sub     esp, 0Ch
nop

loc_40159E:
mov     eax, 28h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401DA9
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_401DA9
call    sub_401097
cmp     eax, 0
jz      loc_401DA9
mov     eax, [ebp+8]
movsx   ecx, byte ptr [eax]
cmp     ecx, 0
jnz     loc_4015FB
mov     eax, [ebp+0Ch]
movsx   ecx, byte ptr [eax]
cmp     ecx, 0
jnz     loc_4015FB
mov     eax, 0
jmp     short loc_401600

loc_4015FB:
mov     eax, 1

loc_401600:
push    eax
mov     eax, 0Dh
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401DA9
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_401DA9
mov     eax, 0Fh
push    eax
call    sub_40100D
add     esp, 4
add     eax, 38h 
mov     eax, 20h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4016B2
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4016B2
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4016B2
mov     eax, offset sub_401000
push    eax
mov     eax, 11h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4016B2
call    sub_401097
cmp     eax, 0
jnz     loc_4016B1
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4016B1
jmp     loc_4016B2

loc_4016B1:
nop

loc_4016B2:
nop
nop
mov     eax, 2Eh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401720
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_401720
call    sub_401097
cmp     eax, 0
jz      loc_401720
movsx   eax, byte_405054
push    eax
mov     eax, 13h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401720
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_401720
jmp     loc_4016B2

loc_401720:
mov     eax, 28h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401810
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401810
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401810
mov     eax, [ebp+8]
movsx   ecx, byte ptr [eax]
push    ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+0Ch]
movsx   edx, byte ptr [ecx]
push    edx
mov     [ebp-4], eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp-4]
cmp     ecx, eax
jge     loc_4017A4
movsx   eax, byte_405055
push    eax
call    sub_40100D
add     esp, 4
cmp     eax, 0
jz      loc_4017A4
mov     eax, 1
jmp     short loc_4017A9

loc_4017A4:
mov     eax, 0

loc_4017A9:
push    eax
mov     eax, 15h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401810
call    sub_401097
cmp     eax, 0
jnz     loc_4017E4
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4017E4
jmp     loc_401810

loc_4017E4:
movsx   eax, byte_405056
push    eax
call    sub_40100D
add     esp, 4
movsx   ecx, byte_405056
cdq
idiv    ecx
mov     ecx, 0FFFFFFFFh
imul    eax, ecx
jmp     locret_401DB4
jmp     loc_401D6B

loc_401810:
mov     eax, 2Eh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4018A8
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4018A8
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4018A8
movsx   eax, byte_405054
cmp     eax, 16h
mov     eax, 0
setnle  al
push    eax
mov     eax, 18h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4018A8
call    sub_401097
cmp     eax, 0
jnz     loc_401895
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401895
jmp     loc_4018A8

loc_401895:
mov     eax, 0Ch
push    eax
call    sub_401000
add     esp, 4
jmp     loc_401D6B

loc_4018A8:
mov     eax, 38h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401938
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401938
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401938
mov     eax, 0
push    eax
mov     eax, 1Dh
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401938
call    sub_401097
cmp     eax, 0
jnz     loc_401920
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401920
jmp     loc_401938

loc_401920:
movsx   eax, byte_405057
sub     eax, 1Eh
push    eax
call    sub_40100D
add     esp, 4
jmp     loc_401D6B

loc_401938:
mov     eax, 40h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401AD5
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401AD5
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401AD5
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 5Dh 
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
push    eax
mov     eax, 21h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401AD5
call    sub_401097
cmp     eax, 0
jnz     loc_4019D5
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4019D5
jmp     loc_401AD5

loc_4019D5:
mov     eax, 23h 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 88h
mov     eax, 48h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401A62
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401A62
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401A62
mov     eax, offset sub_401000
push    eax
mov     eax, 25h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401A62
call    sub_401097
cmp     eax, 0
jnz     loc_401A61
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401A61
jmp     loc_401A62

loc_401A61:
nop

loc_401A62:
nop
nop
mov     eax, 42h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401AD0
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_401AD0
call    sub_401097
cmp     eax, 0
jz      loc_401AD0
movsx   eax, byte_405054
push    eax
mov     eax, 27h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401AD0
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_401AD0
jmp     loc_401A62

loc_401AD0:
jmp     loc_401D6B

loc_401AD5:
mov     eax, 52h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401CAC
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401CAC
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401CAC
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 78h 
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
movsx   ecx, byte_405057
push    ecx
mov     [ebp-8], eax
call    sub_40100D
add     esp, 4
cmp     eax, 0
jz      loc_401B58
jmp     loc_401B64

loc_401B58:
movsx   eax, byte_405054
jmp     loc_401B6B

loc_401B64:
movsx   eax, byte_405056

loc_401B6B:
mov     ecx, [ebp-8]
imul    ecx, eax
push    ecx
mov     eax, 2Ah 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401CAC
call    sub_401097
cmp     eax, 0
jnz     loc_401BAC
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401BAC
jmp     loc_401CAC

loc_401BAC:
mov     eax, 2Ch 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 0ACh
mov     eax, 5Ah 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401C39
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401C39
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401C39
mov     eax, offset sub_401000
push    eax
mov     eax, 2Eh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401C39
call    sub_401097
cmp     eax, 0
jnz     loc_401C38
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401C38
jmp     loc_401C39

loc_401C38:
nop

loc_401C39:
nop
nop
mov     eax, 4Bh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401CA7
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_401CA7
call    sub_401097
cmp     eax, 0
jz      loc_401CA7
movsx   eax, byte_405054
push    eax
mov     eax, 30h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401CA7
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_401CA7
jmp     loc_401C39

loc_401CA7:
jmp     loc_401D6B

loc_401CAC:
mov     eax, 62h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401D6B
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_401D6B
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_401D6B
mov     eax, [ebp+8]
movsx   ecx, byte ptr [eax]
push    ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+0Ch]
movsx   edx, byte ptr [ecx]
push    edx
mov     [ebp-0Ch], eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp-0Ch]
cmp     ecx, eax
mov     eax, 0
setnle  al
push    eax
mov     eax, 32h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401D6B
call    sub_401097
cmp     eax, 0
jnz     loc_401D4D
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401D4D
jmp     loc_401D6B

loc_401D4D:
movsx   eax, byte_405054
movsx   ecx, byte_405055
add     eax, ecx
push    eax
call    sub_40100D
add     esp, 4
jmp     locret_401DB4

loc_401D6B:
movsx   eax, byte_405055
push    eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+8]
add     ecx, eax
mov     [ebp+8], ecx
movsx   eax, byte_405056
movsx   ecx, byte_405055
sub     eax, ecx
push    eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+0Ch]
add     ecx, eax
mov     [ebp+0Ch], ecx
jmp     loc_40159E

loc_401DA9:
nop
cpuid
nop
movsx   eax, byte_405054

locret_401DB4:
leave
retn

sub_401DB6 proc near

var_4= dword ptr -4
arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 4
nop
movsx   eax, byte_405054
mov     [ebp+var_4], eax

loc_401DCA:
mov     eax, 4Fh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_401E79
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_401E79
call    sub_401097
cmp     eax, 0
jz      loc_401E79
mov     eax, [ebp+arg_0]
movsx   ecx, byte ptr [eax]
cmp     ecx, 0
mov     eax, 0
setnz   al
push    eax
mov     eax, 34h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_401E79
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_401E79
movsx   eax, byte_405055
push    eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_4]
add     ecx, eax
mov     [ebp+var_4], ecx
movsx   eax, byte_405056
movsx   ecx, byte_405055
sub     eax, ecx
push    eax
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+arg_0]
add     ecx, eax
mov     [ebp+arg_0], ecx
jmp     loc_401DCA

loc_401E79:
nop
cpuid
nop
mov     eax, [ebp+var_4]
movsx   ecx, byte_405054
add     eax, ecx
push    eax
call    sub_40100D
add     esp, 4
leave
retn
sub_401DB6 endp

sub_401E94 proc near

Source= byte ptr -5Ch
var_3C= dword ptr -3Ch
var_38= dword ptr -38h
var_34= dword ptr -34h
var_30= dword ptr -30h
var_2C= dword ptr -2Ch
var_25= byte ptr -25h
hModule= dword ptr -24h
Buffer= byte ptr -20h
arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 5Ch
nop
mov     eax, 6Ah 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402149
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402149
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402149
mov     eax, dword_405060
cmp     eax, 0
mov     eax, 0
setz    al
push    eax
mov     eax, 36h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402149
call    sub_401097
cmp     eax, 0
jnz     loc_401F22
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_401F22
jmp     loc_402149

loc_401F22:
movsx   eax, byte_40505A
push    eax
call    sub_4012BF
add     esp, 4
mov     ecx, offset Source 
push    ecx             
push    eax             
call    strcat
add     esp, 8
movsx   ecx, byte_405056
push    ecx
movsx   ecx, byte_405057
push    ecx
movsx   ecx, byte_40503F
push    ecx
movsx   ecx, byte_405038
push    ecx
movsx   ecx, byte_405041
push    ecx
movsx   ecx, byte_405045
push    ecx
movsx   ecx, byte_405038
push    ecx
movsx   ecx, byte_40503E
push    ecx
push    eax             
lea     eax, [ebp+Buffer]
push    eax             
call    sprintf
add     esp, 28h
lea     eax, [ebp+Buffer]
push    eax             
call    sub_40157B
add     esp, 4
mov     [ebp+hModule], eax
mov     eax, 6Eh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402149
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402149
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402149
mov     eax, [ebp+hModule]
cmp     eax, 0
mov     eax, 0
setnz   al
push    eax
mov     eax, 38h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402149
call    sub_401097
cmp     eax, 0
jnz     loc_40201E
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_40201E
jmp     loc_402149

loc_40201E:
nop
cpuid
nop
movsx   eax, byte_40504F
mov     [ebp+var_25], al
movsx   eax, byte_405054
push    eax
call    sub_401000
add     esp, 4
movsx   eax, byte_405058
mov     ecx, offset byte_4053E4
add     ecx, eax
movsx   eax, byte_405054
push    eax
mov     [ebp+var_2C], ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_2C]
mov     [ecx], al
movsx   eax, byte_405057
mov     ecx, offset byte_4053E4
add     ecx, eax
movsx   eax, byte_405037
push    eax
mov     [ebp+var_30], ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_30]
mov     [ecx], al
movsx   eax, byte_405056
mov     ecx, offset byte_4053E4
add     ecx, eax
movsx   eax, byte_405034
push    eax
mov     [ebp+var_34], ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_34]
mov     [ecx], al
movsx   eax, byte_405055
mov     ecx, offset byte_4053E4
add     ecx, eax
movsx   eax, byte_405042
push    eax
mov     [ebp+var_38], ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_38]
mov     [ecx], al
movsx   eax, byte_405054
mov     ecx, offset byte_4053E4
add     ecx, eax
movsx   eax, byte_40504F
push    eax
mov     [ebp+var_3C], ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_3C]
mov     [ecx], al
nop
cpuid
nop
mov     eax, offset aC  
push    eax             
mov     eax, offset Destination 
push    eax             
call    strcat
add     esp, 8
movsx   ecx, byte_405050
push    ecx
push    eax             
lea     eax, [ebp+Source]
push    eax             
call    sprintf
add     esp, 0Ch
lea     eax, [ebp+Source]
push    eax             
mov     eax, offset byte_4053E4
push    eax             
call    strcat
add     esp, 8
push    eax             
mov     eax, [ebp+hModule]
push    eax             
call    sub_40155C
mov     dword_405060, eax

loc_402149:
mov     eax, 72h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4021DE
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4021DE
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4021DE
mov     eax, dword_405060
cmp     eax, 0
mov     eax, 0
setnz   al
push    eax
mov     eax, 3Ah 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4021DE
call    sub_401097
cmp     eax, 0
jnz     loc_4021CD
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4021CD
jmp     loc_4021DE

loc_4021CD:
mov     eax, [ebp+arg_0]
push    eax
mov     eax, dword_405060
call    eax 
jmp     locret_4021E3

loc_4021DE:
mov     eax, 0

locret_4021E3:
leave
retn
sub_401E94 endp

sub_4021E5 proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_401E94
add     esp, 4
leave
retn
sub_4021E5 endp

sub_4021FD proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_4021E5
add     esp, 4
leave
retn
sub_4021FD endp

sub_402215 proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_4021FD
add     esp, 4
leave
retn
sub_402215 endp

sub_40222D proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_402215
add     esp, 4
leave
retn
sub_40222D endp

sub_402245 proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_40222D
add     esp, 4
leave
retn
sub_402245 endp

sub_40225D proc near

arg_0= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+arg_0]
push    eax
call    sub_402245
add     esp, 4
leave
retn
sub_40225D endp

sub_402275 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, 3Ch 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 0ECh
mov     eax, 7Ah 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40230C
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_40230C
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_40230C
mov     eax, offset sub_401000
push    eax
mov     eax, 3Eh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40230C
call    sub_401097
cmp     eax, 0
jnz     loc_40230B
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_40230B
jmp     loc_40230C

loc_40230B:
nop

loc_40230C:
nop
nop
mov     eax, 5Bh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40237A
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_40237A
call    sub_401097
cmp     eax, 0
jz      loc_40237A
movsx   eax, byte_405054
push    eax
mov     eax, 40h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40237A
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_40237A
jmp     loc_40230C

loc_40237A:
mov     eax, 42h 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 104h
mov     eax, 86h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402407
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402407
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402407
mov     eax, offset sub_401000
push    eax
mov     eax, 44h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402407
call    sub_401097
cmp     eax, 0
jnz     loc_402406
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402406
jmp     loc_402407

loc_402406:
nop

loc_402407:
nop
nop
mov     eax, 61h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402475
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_402475
call    sub_401097
cmp     eax, 0
jz      loc_402475
movsx   eax, byte_405054
push    eax
mov     eax, 46h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402475
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_402475
jmp     loc_402407

loc_402475:
call    IsDebuggerPresent
leave
retn
sub_402275 endp

sub_40247C proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
int     3               
leave
retn
sub_40247C endp

sub_402489 proc near

var_1C= dword ptr -1Ch
var_18= dword ptr -18h
var_14= dword ptr -14h
var_10= qword ptr -10h
var_8= dword ptr -8
var_4= dword ptr -4

push    ebp
mov     ebp, esp
sub     esp, 18h
nop
mov     eax, 48h 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 11Ch
mov     eax, 92h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402520
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402520
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402520
mov     eax, offset sub_401000
push    eax
mov     eax, 4Ah 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402520
call    sub_401097
cmp     eax, 0
jnz     loc_40251F
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_40251F
jmp     loc_402520

loc_40251F:
nop

loc_402520:
nop
nop
mov     eax, 67h 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40258E
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_40258E
call    sub_401097
cmp     eax, 0
jz      loc_40258E
movsx   eax, byte_405054
push    eax
mov     eax, 4Ch 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40258E
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_40258E
jmp     loc_402520

loc_40258E:
movsx   eax, byte_405054
movsx   ecx, byte_405057
add     eax, ecx
push    eax
call    sub_401000
add     esp, 4
movsx   eax, byte_405057
movsx   ecx, byte_405056
sub     eax, ecx
push    eax
call    sub_401000
add     esp, 4
mov     eax, 9Ah
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40270F
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_40270F
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_40270F
call    IsDebuggerPresent
cmp     eax, 0
jnz     loc_40266F
call    sub_402275
cmp     eax, 0
jz      loc_40261B
mov     eax, 0
jmp     short loc_402620

loc_40261B:
mov     eax, 1

loc_402620:
mov     [ebp+var_4], eax
movsx   eax, byte_405054
mov     ecx, [ebp+var_4]
cdq
idiv    ecx
movsx   ecx, byte_405055
movsx   edx, byte_405054
add     ecx, edx
movsx   edx, byte_405055
add     ecx, edx
imul    eax, ecx
movsx   ecx, byte_405056
cdq
idiv    ecx
push    eax
call    sub_40100D
add     esp, 4
cmp     eax, 0
jnz     loc_40266F
mov     eax, 0
jmp     short loc_402674

loc_40266F:
mov     eax, 1

loc_402674:
push    eax
mov     eax, 4Eh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40270F
call    sub_401097
cmp     eax, 0
jnz     loc_4026AF
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4026AF
jmp     loc_40270F

loc_4026AF:
call    sub_40247C
int     3               
movsx   eax, byte_405054
movsx   ecx, byte_405054
cdq
idiv    ecx
movsx   eax, byte_405055
movsx   ecx, byte_405054
cdq
idiv    ecx
movsx   eax, byte_405056
movsx   ecx, byte_405054
cdq
idiv    ecx
movsx   eax, byte_405057
movsx   ecx, byte_405054
cdq
idiv    ecx
movsx   eax, byte_405058
movsx   ecx, byte_405054
cdq
idiv    ecx
jmp     loc_402BC7

loc_40270F:
mov     eax, 0A0h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4027A7
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4027A7
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4027A7
movsx   eax, byte_405054
cmp     eax, 4Fh 
mov     eax, 0
setnle  al
push    eax
mov     eax, 51h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4027A7
call    sub_401097
cmp     eax, 0
jnz     loc_402794
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402794
jmp     loc_4027A7

loc_402794:
mov     eax, 29h 
push    eax
call    sub_401000
add     esp, 4
jmp     loc_402BC7

loc_4027A7:
mov     eax, 0AAh
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402837
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402837
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402837
mov     eax, 0
push    eax
mov     eax, 56h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402837
call    sub_401097
cmp     eax, 0
jnz     loc_40281F
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_40281F
jmp     loc_402837

loc_40281F:
movsx   eax, byte_405057
sub     eax, 57h 
push    eax
call    sub_40100D
add     esp, 4
jmp     loc_402BC7

loc_402837:
mov     eax, 0B2h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4029D4
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4029D4
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4029D4
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 108h
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
push    eax
mov     eax, 5Ah 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4029D4
call    sub_401097
cmp     eax, 0
jnz     loc_4028D4
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4028D4
jmp     loc_4029D4

loc_4028D4:
mov     eax, 5Ch 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 16Ch
mov     eax, 0BAh
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402961
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402961
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402961
mov     eax, offset sub_401000
push    eax
mov     eax, 5Eh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402961
call    sub_401097
cmp     eax, 0
jnz     loc_402960
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402960
jmp     loc_402961

loc_402960:
nop

loc_402961:
nop
nop
mov     eax, 7Bh 
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4029CF
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_4029CF
call    sub_401097
cmp     eax, 0
jz      loc_4029CF
movsx   eax, byte_405054
push    eax
mov     eax, 60h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4029CF
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_4029CF
jmp     loc_402961

loc_4029CF:
jmp     loc_402BC7

loc_4029D4:
mov     eax, 0C4h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402BAB
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402BAB
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402BAB
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 123h
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
movsx   ecx, byte_405057
push    ecx
mov     [ebp+var_8], eax
call    sub_40100D
add     esp, 4
cmp     eax, 0
jz      loc_402A57
jmp     loc_402A63

loc_402A57:
movsx   eax, byte_405054
jmp     loc_402A6A

loc_402A63:
movsx   eax, byte_405056

loc_402A6A:
mov     ecx, [ebp+var_8]
imul    ecx, eax
push    ecx
mov     eax, 63h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402BAB
call    sub_401097
cmp     eax, 0
jnz     loc_402AAB
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402AAB
jmp     loc_402BAB

loc_402AAB:
mov     eax, 65h 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 190h
mov     eax, 0CCh
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402B38
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402B38
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402B38
mov     eax, offset sub_401000
push    eax
mov     eax, 67h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402B38
call    sub_401097
cmp     eax, 0
jnz     loc_402B37
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402B37
jmp     loc_402B38

loc_402B37:
nop

loc_402B38:
nop
nop
mov     eax, 84h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402BA6
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_402BA6
call    sub_401097
cmp     eax, 0
jz      loc_402BA6
movsx   eax, byte_405054
push    eax
mov     eax, 69h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402BA6
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_402BA6
jmp     loc_402B38

loc_402BA6:
jmp     loc_402BC7

loc_402BAB:
call    IsDebuggerPresent
push    eax
fild    [esp+1Ch+var_1C]
add     esp, 4
fst     [ebp+var_10]
fstp    st
fld     dbl_405078
fdiv    [ebp+var_10]
fstp    st

loc_402BC7:
movsx   eax, byte_40505B
push    eax             
call    malloc
add     esp, 4
mov     [ebp+var_14], eax
movsx   eax, byte_405057
movsx   ecx, byte_405056
add     eax, ecx
movsx   ecx, byte_405055
add     eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
mov     eax, 0
mov     [ecx], al
movsx   eax, byte_405055
movsx   ecx, byte_405056
add     eax, ecx
movsx   ecx, byte_405056
add     eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
movsx   eax, byte_405047
push    eax
mov     [ebp+var_18], ecx
call    sub_40100D
add     esp, 4
mov     ecx, [ebp+var_18]
mov     [ecx], al
movsx   eax, byte_405056
movsx   ecx, byte_405055
imul    eax, ecx
movsx   ecx, byte_405056
add     eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
movsx   eax, byte_405045
mov     [ecx], al
mov     eax, 6Bh 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 1A8h
mov     eax, 0D8h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402CEA
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402CEA
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402CEA
mov     eax, offset sub_401000
push    eax
mov     eax, 6Dh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402CEA
call    sub_401097
cmp     eax, 0
jnz     loc_402CE9
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402CE9
jmp     loc_402CEA

loc_402CE9:
nop

loc_402CEA:
nop
nop
mov     eax, 8Ah
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402D58
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_402D58
call    sub_401097
cmp     eax, 0
jz      loc_402D58
movsx   eax, byte_405054
push    eax
mov     eax, 6Fh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402D58
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_402D58
jmp     loc_402CEA

loc_402D58:
movsx   eax, byte_405058
movsx   ecx, byte_405056
imul    eax, ecx
movsx   ecx, byte_405059
sub     eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
movsx   eax, byte_405036
mov     [ecx], al
movsx   eax, byte_405055
movsx   ecx, byte_405056
imul    eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
movsx   eax, byte_405049
mov     [ecx], al
movsx   eax, byte_405054
movsx   ecx, byte_405055
add     eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
movsx   eax, byte_405046
mov     [ecx], al
movsx   eax, byte_40505C
movsx   ecx, byte_405057
sub     eax, ecx
movsx   ecx, byte_405059
sub     eax, ecx
mov     ecx, [ebp+var_14]
add     ecx, eax
movsx   eax, byte_405040
mov     [ecx], al
mov     eax, 71h 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 1C0h
mov     eax, 0E4h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402E71
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_402E71
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_402E71
mov     eax, offset sub_401000
push    eax
mov     eax, 73h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402E71
call    sub_401097
cmp     eax, 0
jnz     loc_402E70
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_402E70
jmp     loc_402E71

loc_402E70:
nop

loc_402E71:
nop
nop
mov     eax, 90h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_402EDF
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_402EDF
call    sub_401097
cmp     eax, 0
jz      loc_402EDF
movsx   eax, byte_405054
push    eax
mov     eax, 75h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_402EDF
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_402EDF
jmp     loc_402E71

loc_402EDF:
mov     eax, [ebp+var_14]
leave
retn
sub_402489 endp

sub_402EE4 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402489
leave
retn
sub_402EE4 endp

sub_402EF5 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402EE4
leave
retn
sub_402EF5 endp

sub_402F06 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402EF5
leave
retn
sub_402F06 endp

sub_402F17 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F06
leave
retn
sub_402F17 endp

sub_402F28 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F17
leave
retn
sub_402F28 endp

sub_402F39 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F28
leave
retn
sub_402F39 endp

sub_402F4A proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F39
leave
retn
sub_402F4A endp

sub_402F5B proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F4A
leave
retn
sub_402F5B endp

sub_402F6C proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F5B
leave
retn
sub_402F6C endp

sub_402F7D proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F6C
leave
retn
sub_402F7D endp

sub_402F8E proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F7D
leave
retn
sub_402F8E endp

sub_402F9F proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F8E
leave
retn
sub_402F9F endp

sub_402FB0 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402F9F
leave
retn
sub_402FB0 endp

sub_402FC1 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402FB0
leave
retn
sub_402FC1 endp

sub_402FD2 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402FC1
leave
retn
sub_402FD2 endp

sub_402FE3 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402FD2
leave
retn
sub_402FE3 endp

sub_402FF4 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    sub_402FE3
leave
retn
sub_402FF4 endp

sub_403005 proc near

hConsoleOutput= dword ptr -410h
var_40C= dword ptr -40Ch
var_408= dword ptr -408h
ArgList= dword ptr -404h
Buffer= byte ptr -400h
arg_0= dword ptr  8
Format= dword ptr  0Ch

push    ebp
mov     ebp, esp
sub     esp, 410h
nop
mov     eax, 77h 
push    eax
call    sub_40100D
add     esp, 4
add     eax, 1D8h
mov     eax, 0F0h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40309C
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_40309C
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_40309C
mov     eax, offset sub_401000
push    eax
mov     eax, 79h 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40309C
call    sub_401097
cmp     eax, 0
jnz     loc_40309B
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_40309B
jmp     loc_40309C

loc_40309B:
nop

loc_40309C:
nop
nop
mov     eax, 96h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40310A
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_40310A
call    sub_401097
cmp     eax, 0
jz      loc_40310A
movsx   eax, byte_405054
push    eax
mov     eax, 7Bh 
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40310A
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_40310A
jmp     loc_40309C

loc_40310A:
movsx   eax, byte_405055
shl     eax, 2
movsx   ecx, byte_405056
imul    eax, ecx
movsx   ecx, byte_405058
imul    eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
movsx   ecx, byte_405056
shl     ecx, 2
movsx   edx, byte_405058
imul    ecx, edx
mov     [ebp+var_408], eax
mov     eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
mov     ecx, [ebp+var_408]
add     ecx, eax
movsx   eax, byte_405054
mov     edx, 0CAh
imul    eax, edx
add     ecx, eax
shr     ecx, 1
add     ecx, 3
and     ecx, 0FFFFFFFCh
lea     eax, [ebp+Format]
add     eax, ecx
mov     [ebp+ArgList], eax
movsx   eax, byte_405055
shl     eax, 0Ah
movsx   ecx, byte_405056
imul    eax, ecx
movsx   ecx, byte_405058
imul    eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
movsx   ecx, byte_405056
shl     ecx, 0Ah
movsx   edx, byte_405058
imul    ecx, edx
mov     [ebp+var_40C], eax
mov     eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
mov     ecx, [ebp+var_40C]
add     ecx, eax
movsx   eax, byte_405054
mov     edx, 0CBh
imul    eax, edx
add     ecx, eax
shr     ecx, 1
mov     eax, [ebp+ArgList]
push    eax             
mov     eax, [ebp+Format]
push    eax             
push    ecx             
lea     eax, [ebp+Buffer]
push    eax             
call    sub_403DEF
add     esp, 10h
mov     eax, 0FFFFFFF5h
push    eax
call    sub_40100D
add     esp, 4
push    eax
call    sub_40153A
add     esp, 4
push    eax
call    sub_40100D
add     esp, 4
mov     [ebp+hConsoleOutput], eax
mov     eax, [ebp+hConsoleOutput]
mov     ecx, 7Eh 
imul    eax, ecx
mov     ecx, [ebp+arg_0]
add     eax, ecx
push    eax
call    sub_401000
add     esp, 4
lea     eax, [ebp+Buffer]
push    eax
call    sub_401DB6
add     esp, 4
mov     ecx, 0
push    ecx             
mov     ecx, 0
push    ecx             
push    eax             
lea     eax, [ebp+Buffer]
push    eax             
mov     eax, [ebp+hConsoleOutput]
push    eax             
call    sub_401511
add     esp, 14h
leave
retn
sub_403005 endp

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aScanf 
leave
retn

sub_403299 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aSprintf 
leave
retn
sub_403299 endp

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aFclose 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aFopen 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aFread 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aFwrite 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aExit 
leave
retn

sub_403317 proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aStrcpy 
leave
retn
sub_403317 endp

push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aStrtok 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+0Ch]
movsx   ecx, byte_405055
imul    eax, ecx
mov     ecx, [ebp+10h]
push    ecx
push    eax
mov     eax, [ebp+8]
push    eax
call    memset
add     esp, 0Ch
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aMemcpy 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aStrchr 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aStrrchr 
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aRand 
leave
retn

sub_4033BF proc near
push    ebp
mov     ebp, esp
sub     esp, 0
nop
nop
cpuid
nop
mov     eax, offset aRealloc 
leave
retn
sub_4033BF endp

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+0Ch]
push    eax
mov     eax, [ebp+8]
push    eax
call    calloc
add     esp, 8
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 8
nop
call    sub_402FF4
push    eax
call    sub_40225D
add     esp, 4
mov     [ebp-4], eax
call    sub_4033BF
push    eax
mov     eax, [ebp-4]
push    eax
call    sub_40155C
mov     ecx, [ebp+0Ch]
push    ecx
mov     ecx, [ebp+8]
push    ecx
mov     [ebp-8], eax
mov     eax, [ebp-8]
call    eax
add     esp, 8
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+8]
push    eax
call    gets
add     esp, 4
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0Ch
nop
movsx   eax, byte_405055
shl     eax, 2
movsx   ecx, byte_405056
imul    eax, ecx
movsx   ecx, byte_405058
imul    eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
movsx   ecx, byte_405056
shl     ecx, 2
movsx   edx, byte_405058
imul    ecx, edx
mov     [ebp-8], eax
mov     eax, ecx
movsx   ecx, byte_40505C
xor     edx, edx
div     ecx
mov     ecx, [ebp-8]
add     ecx, eax
movsx   eax, byte_405054
mov     edx, 0CDh
imul    eax, edx
add     ecx, eax
shr     ecx, 1
add     ecx, 3
and     ecx, 0FFFFFFFCh
lea     eax, [ebp+10h]
add     eax, ecx
mov     [ebp-4], eax
mov     eax, [ebp-4]
push    eax
mov     eax, [ebp+10h]
push    eax
mov     eax, [ebp+0Ch]
push    eax
mov     eax, [ebp+8]
push    eax
call    sub_403DEF
add     esp, 10h
mov     [ebp-0Ch], eax
mov     eax, [ebp-0Ch]
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+10h]
push    eax
mov     eax, [ebp+0Ch]
push    eax
mov     eax, [ebp+8]
push    eax
call    vsprintf
add     esp, 0Ch
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+14h]
push    eax
mov     eax, [ebp+10h]
push    eax
mov     eax, [ebp+0Ch]
push    eax
mov     eax, [ebp+8]
push    eax
call    sub_403DEF
add     esp, 10h
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+8]
push    eax
call    getenv
add     esp, 4
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+8]
push    eax
call    system
add     esp, 4
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
call    abort
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+8]
push    eax
call    atexit
add     esp, 4
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+0Ch]
push    eax
mov     eax, [ebp+8]
push    eax
call    _getcwd
add     esp, 8
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+8]
push    eax
call    tolower
add     esp, 4
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+8]
push    eax
call    toupper
add     esp, 4
leave
retn

sub_4035CE proc near

var_24= dword ptr -24h
var_20= dword ptr -20h
var_1C= dword ptr -1Ch
var_18= dword ptr -18h
var_14= dword ptr -14h
hModule= dword ptr -10h
Block= dword ptr -0Ch
var_8= dword ptr -8
var_4= dword ptr -4

push    ebp
mov     ebp, esp
sub     esp, 24h
nop
mov     eax, 0
mov     [ebp+var_4], eax
mov     eax, 0
mov     [ebp+var_4], eax

loc_4035E8:
mov     eax, [ebp+var_4]
cmp     eax, 5
jge     loc_403DAD
jmp     loc_4036A0

loc_4035F9:
mov     eax, [ebp+var_4]
mov     ecx, eax
inc     eax
mov     [ebp+var_4], eax
cmp     ecx, 0
jz      loc_40368B
movsx   eax, byte_40505D
movsx   ecx, byte_40505B
add     eax, ecx
movsx   ecx, byte_405054
shl     ecx, 8
add     eax, ecx
movsx   ecx, byte_40505C
cdq
idiv    ecx
movsx   ecx, byte_405055
sub     eax, ecx
mov     ecx, 8Ch
imul    eax, ecx
push    eax
call    sub_40100D
add     esp, 4
movsx   ecx, byte_405057
movsx   edx, byte_40505A
add     ecx, edx
movsx   edx, byte_405054
mov     [ebp+var_8], eax
mov     eax, 186h
imul    edx, eax
add     ecx, edx
movsx   eax, byte_40505D
sub     ecx, eax
mov     eax, [ebp+var_8]
add     eax, ecx
cmp     eax, 0
jz      loc_40368B
jmp     loc_40369B

loc_40368B:
movsx   eax, byte_405055
cmp     eax, 0
jnz     $+6

loc_40369B:
jmp     loc_4035E8

loc_4036A0:
mov     eax, 100h
push    eax
call    sub_40100D
add     esp, 4
push    eax             
call    malloc
add     esp, 4
mov     [ebp+Block], eax
call    sub_402FF4
push    eax
call    sub_40225D
add     esp, 4
mov     [ebp+hModule], eax
call    sub_403317
push    eax             
mov     eax, [ebp+hModule]
push    eax             
call    sub_40155C
mov     ecx, offset aDHelloWorld 
push    ecx
mov     ecx, [ebp+Block]
push    ecx
mov     [ebp+var_14], eax
mov     eax, [ebp+var_14]
call    eax
add     esp, 8
call    sub_402FF4
push    eax
call    sub_40225D
add     esp, 4
mov     [ebp+var_18], eax
call    sub_403299
push    eax             
mov     eax, [ebp+var_18]
push    eax             
call    sub_40155C
mov     ecx, [ebp+var_4]
inc     ecx
push    ecx
mov     ecx, [ebp+Block]
push    ecx
mov     ecx, [ebp+Block]
push    ecx
mov     [ebp+var_1C], eax
mov     eax, [ebp+var_1C]
call    eax
add     esp, 0Ch
mov     eax, 106h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40384D
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_40384D
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_40384D
mov     eax, [ebp+Block]
push    eax
mov     eax, 84h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40384D
call    sub_401097
cmp     eax, 0
jnz     loc_40379D
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_40379D
jmp     loc_40384D

loc_40379D:
mov     eax, 18Fh
movsx   ecx, byte_405054
cmp     eax, ecx
mov     eax, 0
setl    al
push    eax
call    sub_401000
add     esp, 4
mov     eax, [ebp+Block]
push    eax             
mov     eax, 86h
push    eax             
call    sub_403005
add     esp, 8
mov     eax, 0A4h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403848
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_403848
call    sub_401097
cmp     eax, 0
jz      loc_403848
movsx   eax, byte_405054
cmp     eax, 160h
mov     eax, 0
setnle  al
push    eax
mov     eax, 89h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403848
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_403848
jmp     loc_40379D

loc_403848:
jmp     loc_403D9C

loc_40384D:
mov     eax, 116h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_4038E8
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_4038E8
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_4038E8
movsx   eax, byte_405054
cmp     eax, 8Ah
mov     eax, 0
setnle  al
push    eax
mov     eax, 8Ch
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_4038E8
call    sub_401097
cmp     eax, 0
jnz     loc_4038D5
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_4038D5
jmp     loc_4038E8

loc_4038D5:
mov     eax, 46h 
push    eax
call    sub_401000
add     esp, 4
jmp     loc_403D9C

loc_4038E8:
mov     eax, 120h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_40397B
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_40397B
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_40397B
mov     eax, 0
push    eax
mov     eax, 91h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_40397B
call    sub_401097
cmp     eax, 0
jnz     loc_403960
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_403960
jmp     loc_40397B

loc_403960:
movsx   eax, byte_405057
sub     eax, 92h
push    eax
call    sub_40100D
add     esp, 4
jmp     loc_403D9C

loc_40397B:
mov     eax, 128h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403B18
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_403B18
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_403B18
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 1B9h
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
push    eax
mov     eax, 95h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403B18
call    sub_401097
cmp     eax, 0
jnz     loc_403A18
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_403A18
jmp     loc_403B18

loc_403A18:
mov     eax, 97h
push    eax
call    sub_40100D
add     esp, 4
add     eax, 258h
mov     eax, 130h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403AA5
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_403AA5
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_403AA5
mov     eax, offset sub_401000
push    eax
mov     eax, 99h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403AA5
call    sub_401097
cmp     eax, 0
jnz     loc_403AA4
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_403AA4
jmp     loc_403AA5

loc_403AA4:
nop

loc_403AA5:
nop
nop
mov     eax, 0B6h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403B13
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_403B13
call    sub_401097
cmp     eax, 0
jz      loc_403B13
movsx   eax, byte_405054
push    eax
mov     eax, 9Bh
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403B13
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_403B13
jmp     loc_403AA5

loc_403B13:
jmp     loc_403D9C

loc_403B18:
mov     eax, 13Ah
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403CEF
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_403CEF
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_403CEF
movsx   eax, byte_405057
movsx   ecx, byte_40505A
add     eax, ecx
movsx   ecx, byte_405054
mov     edx, 1D4h
imul    ecx, edx
add     eax, ecx
movsx   ecx, byte_40505D
sub     eax, ecx
movsx   ecx, byte_405057
push    ecx
mov     [ebp+var_20], eax
call    sub_40100D
add     esp, 4
cmp     eax, 0
jz      loc_403B9B
jmp     loc_403BA7

loc_403B9B:
movsx   eax, byte_405054
jmp     loc_403BAE

loc_403BA7:
movsx   eax, byte_405056

loc_403BAE:
mov     ecx, [ebp+var_20]
imul    ecx, eax
push    ecx
mov     eax, 9Eh
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403CEF
call    sub_401097
cmp     eax, 0
jnz     loc_403BEF
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_403BEF
jmp     loc_403CEF

loc_403BEF:
mov     eax, 0A0h
push    eax
call    sub_40100D
add     esp, 4
add     eax, 27Ch
mov     eax, 142h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403C7C
movsx   eax, byte_405055
cmp     eax, 0
jz      loc_403C7C
call    sub_401097
movsx   ecx, byte_405056
cmp     ecx, eax
jle     loc_403C7C
mov     eax, offset sub_401000
push    eax
mov     eax, 0A2h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403C7C
call    sub_401097
cmp     eax, 0
jnz     loc_403C7B
movsx   eax, byte_405054
cmp     eax, 0
jnz     loc_403C7B
jmp     loc_403C7C

loc_403C7B:
nop

loc_403C7C:
nop
nop
mov     eax, 0BFh
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403CEA
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_403CEA
call    sub_401097
cmp     eax, 0
jz      loc_403CEA
movsx   eax, byte_405054
push    eax
mov     eax, 0A4h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403CEA
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_403CEA
jmp     loc_403C7C

loc_403CEA:
jmp     loc_403D9C

loc_403CEF:
mov     eax, 1EFh
movsx   ecx, byte_405054
cmp     eax, ecx
mov     eax, 0
setl    al
push    eax
call    sub_401000
add     esp, 4
mov     eax, offset Format 
push    eax             
mov     eax, 0A6h
push    eax             
call    sub_403005
add     esp, 8
mov     eax, 0C4h
movsx   ecx, byte_405054
cmp     eax, ecx
jle     loc_403D9C
movsx   eax, byte_40505C
movsx   ecx, byte_405057
cmp     eax, ecx
jle     loc_403D9C
call    sub_401097
cmp     eax, 0
jz      loc_403D9C
movsx   eax, byte_405054
cmp     eax, 1A0h
mov     eax, 0
setnle  al
push    eax
mov     eax, 0A9h
push    eax
call    sub_4010EF
add     esp, 8
cmp     eax, 0
jz      loc_403D9C
movsx   eax, byte_405059
cmp     eax, 0
jz      loc_403D9C
jmp     loc_403CEF

loc_403D9C:
mov     eax, [ebp+Block]
push    eax             
call    free
add     esp, 4
jmp     loc_4035F9

loc_403DAD:
call    _getch
movsx   ecx, byte_405057
movsx   edx, byte_40505A
add     ecx, edx
movsx   edx, byte_405054
mov     [ebp+var_24], eax
mov     eax, 1FEh
imul    edx, eax
add     ecx, edx
movsx   eax, byte_40505D
sub     ecx, eax
mov     eax, [ebp+var_24]
add     eax, ecx
push    eax
call    sub_40100D
add     esp, 4
leave
retn
sub_4035CE endp

sub_403DEF proc near

Buffer= dword ptr  8
BufferCount= dword ptr  0Ch
Format= dword ptr  10h
ArgList= dword ptr  14h

push    ebp
mov     ebp, esp
sub     esp, 0
nop
mov     eax, [ebp+ArgList]
push    eax             
mov     eax, [ebp+Format]
push    eax             
mov     eax, [ebp+BufferCount]
push    eax             
mov     eax, [ebp+Buffer]
push    eax             
call    _vsnprintf
add     esp, 10h
leave
retn
sub_403DEF endp

align 4

public start
start proc near

var_24= dword ptr -24h
var_20= dword ptr -20h
var_1C= dword ptr -1Ch
var_18= byte ptr -18h

push    ebp
mov     ebp, esp
sub     esp, 24h
nop
lea     eax, [ebp+var_18]
push    eax
call    sub_403F89
add     esp, 4
mov     eax, 0
mov     [ebp+var_1C], eax
mov     eax, 1
push    eax             
call    __set_app_type
add     esp, 4
mov     eax, 30000h
push    eax             
mov     eax, 10000h
push    eax             
call    _controlfp
add     esp, 8
mov     eax, ds:__argc
mov     ecx, ds:__argv
mov     edx, ds:_environ
mov     [ebp+var_20], eax
lea     eax, [ebp+var_1C]
push    eax
mov     eax, dword_4053EC
push    eax
push    edx
push    ecx
mov     eax, [ebp+var_20]
push    eax
call    __getmainargs
add     esp, 14h
mov     eax, ds:__argc
mov     ecx, ds:__argv
mov     edx, ds:_environ
mov     [ebp+var_24], eax
mov     eax, [edx]
push    eax
mov     eax, [ecx]
push    eax
mov     eax, [ebp+var_24]
mov     eax, [eax]
push    eax
call    sub_4035CE
add     esp, 0Ch
push    eax             
call    exit
start endp

add     esp, 4
leave
retn
push    ebp
mov     ebp, esp
sub     esp, 4
nop
mov     eax, ds:__argc
mov     ecx, [ebp+8]
mov     [eax], ecx
mov     eax, ds:__argv
mov     ecx, [ebp+0Ch]
mov     [eax], ecx
mov     eax, 30000h
push    eax
mov     eax, 10000h
push    eax
call    _controlfp
add     esp, 8
mov     eax, ds:__argc
mov     ecx, ds:__argv
mov     edx, ds:_environ
mov     [ebp-4], eax
mov     eax, [edx]
push    eax
mov     eax, [ecx]
push    eax
mov     eax, [ebp-4]
mov     eax, [eax]
push    eax
call    sub_4035CE
add     esp, 0Ch
leave
retn
align 4
xchg    ebp, [esp]
push    ebp
lea     ebp, [esp+4]
push    ecx
mov     ecx, ebp

loc_403F23:
sub     ecx, 1000h
test    [ecx], eax
sub     eax, 1000h
cmp     eax, 1000h
jge     short loc_403F23
sub     ecx, eax
test    [ecx], eax
mov     eax, esp
mov     esp, ecx
mov     ecx, [eax]
jmp     dword ptr [eax+4]

sub_403F44 proc near
mov     eax, [ebp-14h]
retn
sub_403F44 endp

sub_403F48 proc near
call    sub_403F44
mov     eax, [eax]
mov     eax, [eax]
retn
sub_403F48 endp

call    sub_403F44
push    eax
call    sub_403F48
push    eax
call    _XcptFilter
add     esp, 8
retn
db 8Bh
dd 0D9E8E865h, 50FFFFFFh, 12BE8h, 0
dword_403F78 dd 0FFFFFFFFh, 403F52h, 403F67h

loc_403F84:
jmp     loc_4040A8

sub_403F89 proc near

arg_0= dword ptr  4
arg_4= byte ptr  8

push    ebp
mov     ebp, [esp+4+arg_0]
lea     eax, [esp+4+arg_4]
mov     [ebp+0], eax
xor     eax, eax
mov     [ebp+4], eax
mov     eax, large fs:0
mov     [ebp+8], eax
mov     eax, offset loc_403F84
mov     [ebp+0Ch], eax
mov     eax, offset dword_403F78
mov     [ebp+10h], eax
xor     eax, eax
mov     [ebp+14h], eax
lea     eax, [ebp+8]
mov     large fs:0, eax
pop     ebp
retn
sub_403F89 endp

align 8

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

align 10h

align 4

loc_4040A8:
jmp     ds:_except_handler3
align 200h
dd 380h dup(?)
_text ends

_data segment para public 'DATA' use32
assume cs:_data

aAbcdefghijklmn:
text "UTF-16LE", 'abcdefghijklmnopqrstu'
text "UTF-16LE", 'vwxyz'
byte_405034 db 61h
db  62h 
byte_405036 db 63h
byte_405037 db 64h
byte_405038 db 65h
db  66h 
db  67h 
db  68h 
db  69h 
db  6Ah 
byte_40503E db 6Bh
byte_40503F db 6Ch
byte_405040 db 6Dh
byte_405041 db 6Eh
byte_405042 db 6Fh
db  70h 
db  71h 
byte_405045 db 72h
byte_405046 db 73h
byte_405047 db 74h
db  75h 
byte_405049 db 76h
db  77h 
db  78h 
db  79h 
db  7Ah 
db  53h 
byte_40504F db 4Ch
byte_405050 db 41h
db  49h 
db  44h 
db  50h 
byte_405054 db 0
byte_405055 db 1
byte_405056 db 2
byte_405057 db 3
byte_405058 db 4
byte_405059 db 5
byte_40505A db 6
byte_40505B db 7
byte_40505C db 8
byte_40505D db 9
align 10h
dword_405060 dd 0

Source db '%d%d',0

Destination db 'Library',0

aC db '%c',0
align 8
dbl_405078 dq 0.0
aScanf db 'scanf',0
aSprintf db 'sprintf',0
aFclose db 'fclose',0
aFopen db 'fopen',0
aFread db 'fread',0
aFwrite db 'fwrite',0
aExit db 'exit',0
aStrcpy db 'strcpy',0
aStrtok db 'strtok',0
aMemcpy db 'memcpy',0
aStrchr db 'strchr',0
aStrrchr db 'strrchr',0
aRand db 'rand',0
aRealloc db 'realloc',0
aDHelloWorld db '%d) Hello, world!',0Ah,0

Format db 'Error!',0
align 10h
__IMPORT_DESCRIPTOR_kernel32 dd rva off_4051C4 
dd 0                    
dd 0                    
dd rva aKernel32Dll     
dd rva __imp_WriteConsoleA 
__IMPORT_DESCRIPTOR_msvcrt dd rva off_4051DC 
dd 0                    
dd 0                    
dd rva aMsvcrtDll       
dd rva __imp_strcat     
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_data ends

extrn __imp_WriteConsoleA:dword

extrn __imp_GetStdHandle:dword

extrn __imp_GetProcAddress:dword

extrn __imp_GetModuleHandleA:dword

extrn __imp_IsDebuggerPresent:dword

extrn __imp_strcat:dword

extrn __imp_sprintf:dword

extrn __imp_malloc:dword

extrn __imp_memset:dword

extrn __imp_calloc:dword
extrn __imp_gets:dword

extrn __imp_vsprintf:dword

extrn __imp_getenv:dword

extrn __imp_system:dword

extrn __imp_abort:dword

extrn __imp_atexit:dword

extrn __imp__getcwd:dword

extrn __imp_tolower:dword

extrn __imp_toupper:dword

extrn __imp_free:dword

extrn __imp__getch:dword

extrn __imp__vsnprintf:dword

extrn __imp___set_app_type:dword

extrn __imp__controlfp:dword

extrn __argc:dword

extrn __argv:dword

extrn _environ:dword
extrn __imp___getmainargs:dword

extrn __imp_exit:dword
extrn __imp__XcptFilter:dword

extrn __imp__exit:dword
extrn _except_handler3:dword

_data segment para public 'DATA' use32
assume cs:_data

off_4051C4 dd rva word_405259
dd rva word_405269
dd rva word_405278
dd rva word_405289
dd rva word_40529C
dd 0

off_4051DC dd rva word_4052BB
dd rva word_4052C4
dd rva word_4052CE
dd rva word_4052D7
dd rva word_4052E0
dd rva word_4052E9
dd rva word_4052F0
dd rva word_4052FB
dd rva word_405304
dd rva word_40530D
dd rva word_405315
dd rva word_40531E
dd rva word_405328
dd rva word_405332
dd rva word_40533C
dd rva word_405343
dd rva word_40534C
dd rva word_405359
dd rva word_40536A
dd rva word_405377
dd rva word_405380
dd rva word_405389
dd rva word_405394
dd rva word_4053A4
dd rva word_4053AB
dd rva word_4053B9
dd rva word_4053C1
dd 0
aKernel32Dll db 'kernel32.dll',0
word_405259 dw 0
db 'WriteConsoleA',0
word_405269 dw 0
db 'GetStdHandle',0
word_405278 dw 0
db 'GetProcAddress',0
word_405289 dw 0
db 'GetModuleHandleA',0
word_40529C dw 0
db 'IsDebuggerPresent',0
aMsvcrtDll db 'msvcrt.dll',0
word_4052BB dw 0
db 'strcat',0
word_4052C4 dw 0
db 'sprintf',0
word_4052CE dw 0
db 'malloc',0
word_4052D7 dw 0
db 'memset',0
word_4052E0 dw 0
db 'calloc',0
word_4052E9 dw 0
db 'gets',0
word_4052F0 dw 0
db 'vsprintf',0
word_4052FB dw 0
db 'getenv',0
word_405304 dw 0
db 'system',0
word_40530D dw 0
db 'abort',0
word_405315 dw 0
db 'atexit',0
word_40531E dw 0
db '_getcwd',0
word_405328 dw 0
db 'tolower',0
word_405332 dw 0
db 'toupper',0
word_40533C dw 0
db 'free',0
word_405343 dw 0
db '_getch',0
word_40534C dw 0
db '_vsnprintf',0
word_405359 dw 0
db '__set_app_type',0
word_40536A dw 0
db '_controlfp',0
word_405377 dw 0
db '__argc',0
word_405380 dw 0
db '__argv',0
word_405389 dw 0
db '_environ',0
word_405394 dw 0
db '__getmainargs',0
word_4053A4 dw 0
db 'exit',0
word_4053AB dw 0
db '_XcptFilter',0
word_4053B9 dw 0
db '_exit',0
word_4053C1 dw 0
db '_except_handler3',0
unk_4053D4 db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0

byte_4053E4 db 8 dup(0)
dword_4053EC dd 0
align 1000h
_data ends

end start
```

`tests/disasm-security-audit/legacy_tests/ASM/before_x64.asm`:

```asm
RUNTIME_FUNCTION struc 

FunctionStart dd ?      
FunctionEnd dd ?        
UnwindInfo dd ?         
RUNTIME_FUNCTION ends

UNWIND_INFO_HDR struc 

Ver3_Flags db ?         
PrologSize db ?         
CntUnwindCodes db ?     
FrReg_FrRegOff db ?     
UNWIND_INFO_HDR ends

UNWIND_CODE struc 

PrologOff db ?          
OpCode_OpInfo db ?      
UNWIND_CODE ends

.686p
.mmx
.model flat

_text segment para public 'CODE' use64
assume cs:_text

assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

sub_401000 proc near

Destination= qword ptr -10h
var_4= dword ptr -4

push    rbp
mov     rbp, rsp
sub     rsp, 30h

loc_40100B:
mov     eax, 0
mov     [rbp+var_4], eax
mov     eax, 0
mov     [rbp+var_4], eax

loc_40101B:
mov     eax, [rbp+var_4]
cmp     eax, 5
jge     loc_4010D7
jmp     loc_40103A

loc_40102C:
mov     eax, [rbp+var_4]
mov     rcx, rax
add     eax, 1
mov     [rbp+var_4], eax
jmp     short loc_40101B

loc_40103A:
mov     eax, 100h
mov     r10, rax
mov     rcx, r10        
call    malloc
movsxd  rax, eax
mov     [rbp+Destination], rax
lea     rax, Source     
mov     r11, rax
mov     rax, [rbp+Destination]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    strcpy
mov     eax, [rbp+var_4]
add     eax, 1
mov     r8, rax
mov     rax, [rbp+Destination]
mov     r11, rax
mov     rax, [rbp+Destination]
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    sprintf
mov     rax, [rbp+Destination]
cmp     rax, 0
jz      loc_4010B1
mov     rax, [rbp+Destination]
mov     r10, rax
mov     rcx, r10        
call    printf
jmp     loc_4010C3

loc_4010B1:
lea     rax, Format     
mov     r10, rax
mov     rcx, r10        
call    printf

loc_4010C3:
mov     rax, [rbp+Destination]
mov     r10, rax
mov     rcx, r10        
call    free
jmp     loc_40102C

loc_4010D7:
call    _getch
leave
retn
sub_401000 endp

algn_4010DE:
align 20h
stru_4010E0 UNWIND_INFO_HDR <1, 4, 2, 5>
UNWIND_CODE <4, 3>      
UNWIND_CODE <1, 50h>    

public start
start proc near

var_30= qword ptr -30h
var_18= qword ptr -18h
var_10= qword ptr -10h
var_4= dword ptr -4

push    rbp
mov     rbp, rsp
sub     rsp, 50h

loc_4010F3:
mov     eax, 0
mov     [rbp+var_4], eax
mov     eax, 1
mov     r10, rax
mov     rcx, r10        
call    __set_app_type
mov     eax, 30000h
mov     r11, rax
mov     eax, 10000h
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    _controlfp
mov     rax, cs:__argc
mov     rcx, cs:__argv
mov     rdx, cs:_environ
mov     [rbp+var_10], rax
lea     rax, [rbp+var_4]
mov     [rsp+50h+var_30], rax
mov     eax, cs:dword_4021C0
mov     r9, rax
mov     r8, rdx
mov     r11, rcx
mov     rax, [rbp+var_10]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    __getmainargs
mov     rax, cs:__argc
mov     rcx, cs:__argv
mov     rdx, cs:_environ
mov     [rbp+var_18], rax
mov     rax, [rdx]
mov     r8, rax
mov     rax, [rcx]
mov     r11, rax
mov     rax, [rbp+var_18]
mov     eax, [rax]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401000
mov     r10, rax
mov     rcx, r10        
call    exit
start endp

leave
retn
algn_4011AF:
align 10h
stru_4011B0 UNWIND_INFO_HDR <1, 4, 2, 5>
UNWIND_CODE <4, 3>      
UNWIND_CODE <1, 50h>    
push    rbp
mov     rbp, rsp
sub     rsp, 30h

sub_4011C3 proc near
mov     [rbp+10h], rcx
mov     [rbp+18h], rdx
mov     rax, cs:__argc
mov     ecx, [rbp+10h]
mov     [rax], ecx
mov     rax, cs:__argv
mov     rcx, [rbp+18h]
mov     [rax], rcx
mov     eax, 30000h
mov     r11, rax
mov     eax, 10000h
mov     r10, rax
mov     rcx, r10        
mov     rdx, r11        
call    _controlfp
mov     rax, cs:__argc
mov     rcx, cs:__argv
mov     rdx, cs:_environ
mov     [rbp-8], rax
mov     rax, [rdx]
mov     r8, rax
mov     rax, [rcx]
mov     r11, rax
mov     rax, [rbp-8]
mov     eax, [rax]
mov     r10, rax
mov     rcx, r10
mov     rdx, r11
call    sub_401000
leave
retn
sub_4011C3 endp

algn_40123B:
align 20h

align 8

align 10h

align 8

align 20h

align 8

align 10h

align 8

align 20h

align 8

align 200h
dq 180h dup(?)
_text ends

_data segment para public 'DATA' use64
assume cs:_data

Source db '%d) Hello, world!',0Ah,0

Format db 'Error!',0
align 20h
__IMPORT_DESCRIPTOR_msvcrt dd rva off_4020B8 
dd 0                    
dd 0                    
dd rva aMsvcrtDll       
dd rva __imp_malloc     
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_data ends

extrn __imp_malloc:qword

extrn __imp_strcpy:qword

extrn __imp_sprintf:qword

extrn __imp_printf:qword

extrn __imp_free:qword

extrn __imp__getch:qword

extrn __imp___set_app_type:qword

extrn __imp__controlfp:qword

extrn __argc:qword

extrn __argv:qword

extrn _environ:qword
extrn __imp___getmainargs:qword

extrn __imp_exit:qword

_data segment para public 'DATA' use64
assume cs:_data

off_4020B8 dq rva word_402133
dq rva word_40213C
dq rva word_402145
dq rva word_40214F
dq rva word_402158
dq rva word_40215F
dq rva word_402168
dq rva word_402179
dq rva word_402186
dq rva word_40218F
dq rva word_402198
dq rva word_4021A3
dq rva word_4021B3
dq 0
aMsvcrtDll db 'msvcrt.dll',0
word_402133 dw 0
db 'malloc',0
word_40213C dw 0
db 'strcpy',0
word_402145 dw 0
db 'sprintf',0
word_40214F dw 0
db 'printf',0
word_402158 dw 0
db 'free',0
word_40215F dw 0
db '_getch',0
word_402168 dw 0
db '__set_app_type',0
word_402179 dw 0
db '_controlfp',0
word_402186 dw 0
db '__argc',0
word_40218F dw 0
db '__argv',0
word_402198 dw 0
db '_environ',0
word_4021A3 dw 0
db '__getmainargs',0
word_4021B3 dw 0
db 'exit',0
align 20h
dword_4021C0 dd 0
align 1000h
_data ends

_pdata segment para public 'DATA' use64
assume cs:_pdata

ExceptionDir RUNTIME_FUNCTION <rva loc_40100B, \
                  rva algn_4010DE, \
                  rva stru_4010E0>
RUNTIME_FUNCTION <rva loc_4010F3, \
                  rva algn_4011AF, \
                  rva stru_4011B0>
RUNTIME_FUNCTION <rva sub_4011C3, \
                  rva algn_40123B, \
                  rva stru_4011B0>
align 1000h
_pdata ends

end start
```

`tests/disasm-security-audit/legacy_tests/ASM/before_x86.asm`:

```asm
_crt_unknown_app  = 0
_crt_console_app  = 1
_crt_gui_app     = 2

                .686p
                .mmx
                .model flat

_text           segment para public 'CODE' use32
                assume cs:_text

                assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

sub_401000      proc near               

Destination     = dword ptr -8
var_4           = dword ptr -4

                push    ebp
                mov     ebp, esp
                sub     esp, 8
                nop
                mov     eax, 0
                mov     [ebp+var_4], eax
                mov     eax, 0
                mov     [ebp+var_4], eax

loc_40101A:                             
                mov     eax, [ebp+var_4]
                cmp     eax, 5
                jge     loc_4010A7
                jmp     loc_401036

loc_40102B:                             
                mov     eax, [ebp+var_4]
                mov     ecx, eax
                inc     eax
                mov     [ebp+var_4], eax
                jmp     short loc_40101A

loc_401036:                             
                mov     eax, 100h
                push    eax             
                call    malloc
                add     esp, 4
                mov     [ebp+Destination], eax
                mov     eax, offset Source 
                push    eax             
                mov     eax, [ebp+Destination]
                push    eax             
                call    strcpy
                add     esp, 8
                mov     eax, [ebp+var_4]
                inc     eax
                push    eax
                mov     eax, [ebp+Destination]
                push    eax             
                mov     eax, [ebp+Destination]
                push    eax             
                call    sprintf
                add     esp, 0Ch
                mov     eax, [ebp+Destination]
                cmp     eax, 0
                jz      loc_40108B
                mov     eax, [ebp+Destination]
                push    eax             
                call    printf
                add     esp, 4
                jmp     loc_401099

loc_40108B:                             
                mov     eax, offset Format 
                push    eax             
                call    printf
                add     esp, 4

loc_401099:                             
                mov     eax, [ebp+Destination]
                push    eax             
                call    free
                add     esp, 4
                jmp     short loc_40102B

loc_4010A7:                             
                call    _getch
                leave
                retn
sub_401000      endp

                align 10h

                public start
start           proc near

var_24          = dword ptr -24h
var_20          = dword ptr -20h
var_1C          = dword ptr -1Ch
var_18          = byte ptr -18h

                push    ebp
                mov     ebp, esp
                sub     esp, 24h
                nop
                lea     eax, [ebp+var_18]
                push    eax
                call    sub_401225
                add     esp, 4
                mov     eax, 0
                mov     [ebp+var_1C], eax
                mov     eax, 1
                push    eax             
                call    __set_app_type
                add     esp, 4
                mov     eax, 30000h
                push    eax             
                mov     eax, 10000h
                push    eax             
                call    _controlfp
                add     esp, 8
                mov     eax, ds:__argc
                mov     ecx, ds:__argv
                mov     edx, ds:_environ
                mov     [ebp+var_20], eax
                lea     eax, [ebp+var_1C]
                push    eax
                mov     eax, dword_40218C
                push    eax
                push    edx
                push    ecx
                mov     eax, [ebp+var_20]
                push    eax
                call    __getmainargs
                add     esp, 14h
                mov     eax, ds:__argc
                mov     ecx, ds:__argv
                mov     edx, ds:_environ
                mov     [ebp+var_24], eax
                mov     eax, [edx]
                push    eax
                mov     eax, [ecx]
                push    eax
                mov     eax, [ebp+var_24]
                mov     eax, [eax]
                push    eax
                call    sub_401000
                add     esp, 0Ch
                push    eax             
                call    exit
start           endp

                add     esp, 4
                leave
                retn

                push    ebp
                mov     ebp, esp
                sub     esp, 4
                nop
                mov     eax, ds:__argc
                mov     ecx, [ebp+8]
                mov     [eax], ecx
                mov     eax, ds:__argv
                mov     ecx, [ebp+0Ch]
                mov     [eax], ecx
                mov     eax, 30000h
                push    eax
                mov     eax, 10000h
                push    eax
                call    _controlfp
                add     esp, 8
                mov     eax, ds:__argc
                mov     ecx, ds:__argv
                mov     edx, ds:_environ
                mov     [ebp-4], eax
                mov     eax, [edx]
                push    eax
                mov     eax, [ecx]
                push    eax
                mov     eax, [ebp-4]
                mov     eax, [eax]
                push    eax
                call    sub_401000
                add     esp, 0Ch
                leave
                retn

                align 4
                xchg    ebp, [esp]
                push    ebp
                lea     ebp, [esp+4]
                push    ecx
                mov     ecx, ebp

loc_4011BF:                             
                sub     ecx, 1000h
                test    [ecx], eax
                sub     eax, 1000h
                cmp     eax, 1000h
                jge     short loc_4011BF
                sub     ecx, eax
                test    [ecx], eax
                mov     eax, esp
                mov     esp, ecx
                mov     ecx, [eax]
                jmp     dword ptr [eax+4]

sub_4011E0      proc near               

                mov     eax, [ebp-14h]
                retn
sub_4011E0      endp

sub_4011E4      proc near               
                call    sub_4011E0
                mov     eax, [eax]
                mov     eax, [eax]
                retn
sub_4011E4      endp

                call    sub_4011E0
                push    eax
                call    sub_4011E4
                push    eax
                call    _XcptFilter
                add     esp, 8
                retn

                db 8Bh
                dd 0D9E8E865h, 50FFFFFFh, 0A7E8h, 0
dword_401214    dd 0FFFFFFFFh, 4011EEh, 401203h

loc_401220:                             
                jmp     loc_4012C0

sub_401225      proc near               

arg_0           = dword ptr  4
arg_4           = byte ptr  8

                push    ebp
                mov     ebp, [esp+4+arg_0]
                lea     eax, [esp+4+arg_4]
                mov     [ebp+0], eax
                xor     eax, eax
                mov     [ebp+4], eax
                mov     eax, large fs:0
                mov     [ebp+8], eax
                mov     eax, offset loc_401220
                mov     [ebp+0Ch], eax
                mov     eax, offset dword_401214
                mov     [ebp+10h], eax
                xor     eax, eax
                mov     [ebp+14h], eax
                lea     eax, [ebp+8]
                mov     large fs:0, eax
                pop     ebp
                retn
sub_401225      endp

                align 10h

                align 4

                align 10h

                align 4

                align 10h

                align 4

                align 10h

                align 4

                align 10h

                align 4

                align 10h

                align 4

                align 10h

loc_4012C0:                             
                jmp     ds:_except_handler3

                align 200h
                dd 300h dup(?)
_text           ends

_data           segment para public 'DATA' use32
                assume cs:_data

Source          db '%d) Hello, world!',0Ah,0

Format          db 'Error!',0           
                align 10h
__IMPORT_DESCRIPTOR_msvcrt dd rva off_40208C 
                dd 0                    
                dd 0                    
                dd rva aMsvcrtDll       
                dd rva __imp_malloc     
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
                db    0
_data           ends

                extrn __imp_malloc:dword 

                extrn __imp_strcpy:dword 

                extrn __imp_sprintf:dword 

                extrn __imp_printf:dword 

                extrn __imp_free:dword  

                extrn __imp__getch:dword 

                extrn __imp___set_app_type:dword

                extrn __imp__controlfp:dword 

                extrn __argc:dword      

                extrn __argv:dword      

                extrn _environ:dword    

                extrn __imp___getmainargs:dword

                extrn __imp_exit:dword  
                extrn __imp__XcptFilter:dword 

                extrn __imp__exit:dword 
                extrn _except_handler3:dword

_data           segment para public 'DATA' use32
                assume cs:_data

off_40208C      dd rva word_4020DB      
                dd rva word_4020E4
                dd rva word_4020ED
                dd rva word_4020F7
                dd rva word_402100
                dd rva word_402107
                dd rva word_402110
                dd rva word_402121
                dd rva word_40212E
                dd rva word_402137
                dd rva word_402140
                dd rva word_40214B
                dd rva word_40215B
                dd rva word_402162
                dd rva word_402170
                dd rva word_402178
                dd 0
aMsvcrtDll      db 'msvcrt.dll',0       
word_4020DB     dw 0                    
                db 'malloc',0
word_4020E4     dw 0                    
                db 'strcpy',0
word_4020ED     dw 0                    
                db 'sprintf',0
word_4020F7     dw 0                    
                db 'printf',0
word_402100     dw 0                    
                db 'free',0
word_402107     dw 0                    
                db '_getch',0
word_402110     dw 0                    
                db '__set_app_type',0
word_402121     dw 0                    
                db '_controlfp',0
word_40212E     dw 0                    
                db '__argc',0
word_402137     dw 0                    
                db '__argv',0
word_402140     dw 0                    
                db '_environ',0
word_40214B     dw 0                    
                db '__getmainargs',0
word_40215B     dw 0                    
                db 'exit',0
word_402162     dw 0                    
                db '_XcptFilter',0
word_402170     dw 0                    
                db '_exit',0
word_402178     dw 0                    
                db '_except_handler3',0
                align 4
dword_40218C    dd 0                    
                align 1000h
_data           ends

                end start
```

`tests/disasm-security-audit/legacy_tests/C/after_x64.c`:

```c

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_401000();
__int64 __fastcall sub_401028(int a1);
double __fastcall sub_401085(double a1);
_BOOL8 __fastcall sub_4010D2();
__int64 __fastcall sub_40112B(int a1, int a2);
void *__fastcall sub_40130B(int a1);
BOOL __fastcall sub_4015B4(void *a1, const void *a2, DWORD a3, DWORD *a4, LPVOID lpReserved);
HANDLE __fastcall sub_401604(int a1);
FARPROC __fastcall sub_401632(HMODULE a1, const CHAR *a2);
HMODULE __fastcall sub_401664(const CHAR *a1);
__int64 __fastcall sub_401688(_BYTE *a1, _BYTE *a2);
__int64 __fastcall sub_401F47(char *a1);
__int64 __fastcall sub_402050(__int64 a1);
__int64 __fastcall sub_402460(__int64 a1);
__int64 __fastcall sub_402480(__int64 a1);
__int64 __fastcall sub_4024A0(__int64 a1);
__int64 __fastcall sub_4024C0(__int64 a1);
__int64 __fastcall sub_4024E0(__int64 a1);
__int64 __fastcall sub_402500(__int64 a1);
BOOL sub_402520();
void sub_40274C();
_BYTE *sub_40275A();
_BYTE *sub_403268();
_BYTE *sub_40327A();
_BYTE *sub_40328C();
_BYTE *sub_40329E();
_BYTE *sub_4032B0();
_BYTE *sub_4032C2();
_BYTE *sub_4032D4();
_BYTE *sub_4032E6();
_BYTE *sub_4032F8();
_BYTE *sub_40330A();
_BYTE *sub_40331C();
_BYTE *sub_40332E();
_BYTE *sub_403340();
_BYTE *sub_403352();
_BYTE *sub_403364();
_BYTE *sub_403376();
_BYTE *sub_403388();
BOOL sub_40339A(__int64 a1, const char *a2, ...);
char *__fastcall sub_40362C();
char *__fastcall sub_403644();
char *__fastcall sub_40365C();
char *__fastcall sub_403674();
char *__fastcall sub_40368C();
char *__fastcall sub_4036A4();
char *__fastcall sub_4036BC();
char *__fastcall sub_4036D4();
char *__fastcall sub_4036EC();
void *__fastcall sub_403704(void *a1, int a2, size_t a3);
char *__fastcall sub_403746();
char *__fastcall sub_40375E();
char *__fastcall sub_403776();
char *__fastcall sub_40378E();
char *__fastcall sub_4037A6();
void *__fastcall sub_4037BE(size_t a1, size_t a2);
__int64 __fastcall sub_4037EC(__int64 a1, __int64 a2);
__int64 __fastcall sub_40384E(__int64 a1);
__int64 sub_40386E(char *a1, size_t a2, const char *a3, ...);
int __fastcall sub_4038C0(char *a1, const char *a2, va_list a3);
int __fastcall sub_4038F9(char *a1, size_t a2, const char *a3, va_list a4);
char *__fastcall sub_40393D(const char *a1);
int __fastcall sub_40395D(const char *a1);
void __noreturn sub_40397D();
int __fastcall sub_40398F(void (__cdecl *a1)());
__int64 __fastcall sub_4039AF(char *a1, int a2);
int __fastcall sub_4039E0(int a1);
int __fastcall sub_4039FF(int a1);
__int64 sub_403A1E();
int __fastcall sub_404303(char *a1, size_t a2, const char *a3, va_list a4);
void __noreturn start();
__int64 __fastcall sub_404423(__int64 a1, __int64 a2);
// BOOL __stdcall WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// char *__cdecl strcat(char *Destination, const char *Source);
// int sprintf(char *const Buffer, const char *const Format, ...);
// BOOL __stdcall IsDebuggerPresent();
// void *__cdecl malloc(size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl calloc(size_t Count, size_t Size);
// __int64 __fastcall gets(_QWORD); weak
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// char *__cdecl getenv(const char *VarName);
// int __cdecl system(const char *Command);
// void __cdecl __noreturn abort();
// int __cdecl atexit(void (__cdecl *)());
// char *__cdecl getcwd(char *DstBuf, int SizeInBytes);
// int __cdecl tolower(int C);
// int __cdecl toupper(int C);
// void __cdecl free(void *Block);
// int __cdecl getch();
// int __cdecl vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// void __cdecl _set_app_type(_crt_app_type Type);
// unsigned int __cdecl controlfp(unsigned int NewValue, unsigned int Mask);
// __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

char byte_405034 = 'a'; // weak
char byte_405036 = 'c'; // weak
char byte_405037 = 'd'; // weak
char byte_405038 = 'e'; // weak
char byte_40503E = 'k'; // weak
char byte_40503F = 'l'; // weak
char byte_405040 = 'm'; // weak
char byte_405041 = 'n'; // weak
char byte_405042 = 'o'; // weak
char byte_405045 = 'r'; // weak
char byte_405046 = 's'; // weak
char byte_405047 = 't'; // weak
char byte_405049 = 'v'; // weak
char byte_40504F = 'L'; // weak
char byte_405050 = 'A'; // weak
char byte_405054 = '\0'; // weak
char byte_405055 = '\x01'; // weak
char byte_405056 = '\x02'; // weak
char byte_405057 = '\x03'; // weak
char byte_405058 = '\x04'; // weak
char byte_405059 = '\x05'; // weak
char byte_40505A = '\x06'; // weak
char byte_40505B = '\a'; // weak
char byte_40505C = '\b'; // weak
char byte_40505D = '\t'; // weak
__int64 (__fastcall *qword_405060)(_QWORD) = NULL; // weak
char Source[] = "%d%d"; // idb
char Destination[] = "Library"; // idb
char aC[] = "%c"; // idb
char aScanf[6] = "scanf"; // weak
char aSprintf[8] = "sprintf"; // weak
char aFclose[7] = "fclose"; // weak
char aFopen[6] = "fopen"; // weak
char aFread[6] = "fread"; // weak
char aFwrite[7] = "fwrite"; // weak
char aExit[5] = "exit"; // weak
char aStrcpy[7] = "strcpy"; // weak
char aStrtok[7] = "strtok"; // weak
char aMemcpy[7] = "memcpy"; // weak
char aStrchr[7] = "strchr"; // weak
char aStrrchr[8] = "strrchr"; // weak
char aRand[5] = "rand"; // weak
char aRealloc[8] = "realloc"; // weak
char aDHelloWorld[19] = "%d) Hello, world!\n"; // weak
char aError[7] = "Error!"; // weak
// extern int _argc;
// extern char **_argv;
// extern char **environ;
_UNKNOWN unk_405490; // weak
char byte_4054A0[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
int dword_4054A8 = 0; // weak


//----- (0000000000401000) ----------------------------------------------------
void sub_401000()
{
  ;
}

//----- (0000000000401028) ----------------------------------------------------
__int64 __fastcall sub_401028(int a1)
{
  sub_401000();
  __asm { cpuid }
  return (unsigned int)(byte_405056 * byte_405058 + byte_405055 * a1 - byte_40505C);
}
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405058: using guessed type char byte_405058;
// 40505C: using guessed type char byte_40505C;

//----- (0000000000401085) ----------------------------------------------------
double __fastcall sub_401085(double a1)
{
  sub_401000();
  __asm { cpuid }
  return a1 * (double)byte_405055;
}
// 405055: using guessed type char byte_405055;

//----- (00000000004010D2) ----------------------------------------------------
_BOOL8 __fastcall sub_4010D2()
{
  __asm { cpuid }
  return byte_405055 && (byte_40505B + byte_40505D) / byte_40505C != byte_405055;
}
// 405055: using guessed type char byte_405055;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (000000000040112B) ----------------------------------------------------
__int64 __fastcall sub_40112B(int a1, int a2)
{
  int v8; // [rsp+20h] [rbp-10h]
  int v9; // [rsp+2Ch] [rbp-4h]

  v9 = sub_401028(byte_405055 * a2);
  if ( v9 == a1 * (3 * byte_405054 + byte_40505A + byte_405057 - byte_40505D) )
    return byte_40505C != byte_405056 * byte_405058 && !sub_4010D2();
  _RAX = (unsigned int)((4 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C - byte_405055);
  if ( v9 == (_DWORD)_RAX )
    return (sub_4010D2()
         || 9 * byte_405054 + byte_40505A + byte_405057 != byte_40505D
         || (8 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C != byte_405055)
        && (v8 = 15 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, (unsigned int)sub_401028(byte_405055) + v8);
  __asm { cpuid }
  return sub_401028(a2);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (000000000040130B) ----------------------------------------------------
void *__fastcall sub_40130B(int a1)
{
  int v1; // eax
  _BYTE *v3; // rcx
  _BYTE *v9; // [rsp+28h] [rbp-18h]
  int i; // [rsp+34h] [rbp-Ch]

  if ( byte_405054 < 14 && byte_405055 && byte_405056 > (int)sub_4010D2() )
  {
    v1 = a1 <= byte_405054
      || a1 >= (84 * byte_405054
              + byte_405058 * 16i64 * byte_405056 / (unsigned __int64)byte_40505C
              + byte_405058 * byte_405056 * 16i64 * byte_405055 / (unsigned __int64)byte_40505C) >> 1;
    if ( (unsigned int)sub_40112B(8, v1) && (sub_4010D2() || byte_405054) )
      return 0i64;
  }
  v9 = &unk_405490;
  for ( i = byte_405054; i < a1; ++i )
  {
    *v9 = 37;
    v3 = v9 + 1;
    v9 += 2;
    *v3 = byte_405036;
    LODWORD(v3) = i;
    if ( (_DWORD)v3 )
      sub_401028(21 * ((18 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C - byte_405055));
  }
  _RAX = v9;
  *v9 = 0;
  __asm { cpuid }
  return &unk_405490;
}
// 405036: using guessed type char byte_405036;
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 405059: using guessed type char byte_405059;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (00000000004015B4) ----------------------------------------------------
BOOL __fastcall sub_4015B4(void *a1, const void *a2, DWORD a3, DWORD *a4, LPVOID lpReserved)
{
  __asm { cpuid }
  return WriteConsoleA(a1, a2, a3, a4, lpReserved);
}

//----- (0000000000401604) ----------------------------------------------------
HANDLE __fastcall sub_401604(int a1)
{
  DWORD v6; // eax

  __asm { cpuid }
  v6 = sub_401028(a1);
  return GetStdHandle(v6);
}

//----- (0000000000401632) ----------------------------------------------------
FARPROC __fastcall sub_401632(HMODULE a1, const CHAR *a2)
{
  __asm { cpuid }
  return GetProcAddress(a1, a2);
}

//----- (0000000000401664) ----------------------------------------------------
HMODULE __fastcall sub_401664(const CHAR *a1)
{
  __asm { cpuid }
  return GetModuleHandleA(a1);
}

//----- (0000000000401688) ----------------------------------------------------
__int64 __fastcall sub_401688(_BYTE *a1, _BYTE *a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // eax
  int v7; // eax
  int v12; // [rsp+28h] [rbp-18h]
  int v13; // [rsp+30h] [rbp-10h]
  int v14; // [rsp+38h] [rbp-8h]

  while ( 1 )
  {
    _RAX = 40i64;
    if ( byte_405054 >= 40 )
      break;
    _RAX = (unsigned int)byte_40505C;
    if ( (int)_RAX <= byte_405057 )
      break;
    _RAX = sub_4010D2();
    if ( !(_DWORD)_RAX )
      break;
    v3 = *a1 || *a2;
    _RAX = sub_40112B(13, v3);
    if ( !(_DWORD)_RAX )
      break;
    _RAX = (unsigned int)byte_405059;
    if ( !byte_405059 )
      break;
    sub_401028(15);
    if ( byte_405054 < 32
      && byte_405055
      && byte_405056 > (int)sub_4010D2()
      && (unsigned int)sub_40112B(17, (int)sub_401000) )
    {
      sub_4010D2();
    }
    while ( byte_405054 < 46
         && byte_40505C > byte_405057
         && sub_4010D2()
         && (unsigned int)sub_40112B(19, byte_405054)
         && byte_405059 )
      ;
    if ( byte_405054 < 40 && byte_405055 && byte_405056 > (int)sub_4010D2() )
    {
      v14 = sub_401028((char)*a1);
      v4 = v14 < (int)sub_401028((char)*a2) && (unsigned int)sub_401028(byte_405055);
      if ( (unsigned int)sub_40112B(21, v4) && (sub_4010D2() || byte_405054) )
        return (unsigned int)-((int)sub_401028(byte_405056) / byte_405056);
    }
    if ( byte_405054 < 46
      && byte_405055
      && byte_405056 > (int)sub_4010D2()
      && (unsigned int)sub_40112B(24, byte_405054 > 22)
      && (sub_4010D2() || byte_405054) )
    {
      sub_401000();
    }
    else if ( byte_405054 < 56
           && byte_405055
           && byte_405056 > (int)sub_4010D2()
           && (unsigned int)sub_40112B(29, 0)
           && (sub_4010D2() || byte_405054) )
    {
      sub_401028(byte_405057 - 30);
    }
    else if ( byte_405054 < 64
           && byte_405055
           && byte_405056 > (int)sub_4010D2()
           && (unsigned int)sub_40112B(33, 93 * byte_405054 + byte_40505A + byte_405057 - byte_40505D)
           && (sub_4010D2() || byte_405054) )
    {
      sub_401028(35);
      if ( byte_405054 < 72
        && byte_405055
        && byte_405056 > (int)sub_4010D2()
        && (unsigned int)sub_40112B(37, (int)sub_401000) )
      {
        sub_4010D2();
      }
      while ( byte_405054 < 66
           && byte_40505C > byte_405057
           && sub_4010D2()
           && (unsigned int)sub_40112B(39, byte_405054)
           && byte_405059 )
        ;
    }
    else if ( byte_405054 < 82
           && byte_405055
           && byte_405056 > (int)sub_4010D2()
           && ((v13 = 120 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, (unsigned int)sub_401028(byte_405057))
             ? (v6 = byte_405056)
             : (v6 = byte_405054),
               (unsigned int)sub_40112B(42, v6 * v13) && (sub_4010D2() || byte_405054)) )
    {
      sub_401028(44);
      if ( byte_405054 < 90
        && byte_405055
        && byte_405056 > (int)sub_4010D2()
        && (unsigned int)sub_40112B(46, (int)sub_401000) )
      {
        sub_4010D2();
      }
      while ( byte_405054 < 75
           && byte_40505C > byte_405057
           && sub_4010D2()
           && (unsigned int)sub_40112B(48, byte_405054)
           && byte_405059 )
        ;
    }
    else if ( byte_405054 < 98 )
    {
      if ( byte_405055 )
      {
        if ( byte_405056 > (int)sub_4010D2() )
        {
          v12 = sub_401028((char)*a1);
          v7 = sub_401028((char)*a2);
          if ( (unsigned int)sub_40112B(50, v12 > v7) )
          {
            if ( sub_4010D2() || byte_405054 )
              return sub_401028(byte_405055 + byte_405054);
          }
        }
      }
    }
    a1 += (int)sub_401028(byte_405055);
    a2 += (int)sub_401028(byte_405056 - byte_405055);
  }
  __asm { cpuid }
  return (unsigned int)byte_405054;
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505A: using guessed type char byte_40505A;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (0000000000401F47) ----------------------------------------------------
__int64 __fastcall sub_401F47(char *a1)
{
  __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = byte_405054;
  while ( 1 )
  {
    _RAX = 79i64;
    if ( byte_405054 >= 79 )
      break;
    _RAX = (unsigned int)byte_40505C;
    if ( (int)_RAX <= byte_405057 )
      break;
    _RAX = sub_4010D2();
    if ( !(_DWORD)_RAX )
      break;
    _RAX = sub_40112B(52, *a1 != 0);
    if ( !(_DWORD)_RAX )
      break;
    _RAX = (unsigned int)byte_405059;
    if ( !byte_405059 )
      break;
    v7 += (int)sub_401028(byte_405055);
    a1 += (int)sub_401028(byte_405056 - byte_405055);
  }
  __asm { cpuid }
  return (int)sub_401028(byte_405054 + (int)v7);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505C: using guessed type char byte_40505C;

//----- (0000000000402050) ----------------------------------------------------
__int64 __fastcall sub_402050(__int64 a1)
{
  char *v1; // rax
  char *v2; // rax
  char *v13; // rax
  char *v14; // rax
  char Source[32]; // [rsp+58h] [rbp-78h] BYREF
  char *v17; // [rsp+78h] [rbp-58h]
  char *v18; // [rsp+80h] [rbp-50h]
  char *v19; // [rsp+88h] [rbp-48h]
  char *v20; // [rsp+90h] [rbp-40h]
  char *v21; // [rsp+98h] [rbp-38h]
  char v22; // [rsp+A7h] [rbp-29h]
  HMODULE v23; // [rsp+A8h] [rbp-28h]
  char Buffer[32]; // [rsp+B0h] [rbp-20h] BYREF

  if ( byte_405054 < 106
    && byte_405055
    && byte_405056 > (int)sub_4010D2()
    && (unsigned int)sub_40112B(54, qword_405060 == 0i64)
    && (sub_4010D2() || byte_405054) )
  {
    v1 = (char *)sub_40130B(byte_40505A);
    v2 = strcat(v1, ::Source);
    sprintf(
      Buffer,
      v2,
      (unsigned int)byte_40503E,
      (unsigned int)byte_405038,
      (unsigned int)byte_405045,
      (unsigned int)byte_405041,
      (unsigned int)byte_405038,
      (unsigned int)byte_40503F,
      (unsigned int)byte_405057,
      (unsigned int)byte_405056);
    v23 = sub_401664(Buffer);
    if ( byte_405054 < 110 )
    {
      if ( byte_405055 )
      {
        if ( byte_405056 > (int)sub_4010D2() )
        {
          if ( (unsigned int)sub_40112B(56, v23 != 0i64) )
          {
            _RAX = sub_4010D2();
            if ( (_DWORD)_RAX || (_RAX = (unsigned int)byte_405054, byte_405054) )
            {
              __asm { cpuid }
              v22 = byte_40504F;
              sub_401000();
              v21 = &byte_4054A0[byte_405058];
              *v21 = sub_401028(byte_405054);
              v20 = &byte_4054A0[byte_405057];
              *v20 = sub_401028(byte_405037);
              v19 = &byte_4054A0[byte_405056];
              *v19 = sub_401028(byte_405034);
              v18 = &byte_4054A0[byte_405055];
              *v18 = sub_401028(byte_405042);
              v17 = &byte_4054A0[byte_405054];
              _RAX = sub_401028(byte_40504F);
              *v17 = _RAX;
              __asm { cpuid }
              v13 = strcat(Destination, aC);
              sprintf(Source, v13, (unsigned int)byte_405050);
              v14 = strcat(byte_4054A0, Source);
              qword_405060 = (__int64 (__fastcall *)(_QWORD))sub_401632(v23, v14);
            }
          }
        }
      }
    }
  }
  if ( byte_405054 < 114
    && byte_405055
    && byte_405056 > (int)sub_4010D2()
    && (unsigned int)sub_40112B(58, qword_405060 != 0i64)
    && (sub_4010D2() || byte_405054) )
  {
    return qword_405060(a1);
  }
  else
  {
    return 0i64;
  }
}
// 405034: using guessed type char byte_405034;
// 405037: using guessed type char byte_405037;
// 405038: using guessed type char byte_405038;
// 40503E: using guessed type char byte_40503E;
// 40503F: using guessed type char byte_40503F;
// 405041: using guessed type char byte_405041;
// 405042: using guessed type char byte_405042;
// 405045: using guessed type char byte_405045;
// 40504F: using guessed type char byte_40504F;
// 405050: using guessed type char byte_405050;
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 40505A: using guessed type char byte_40505A;
// 405060: using guessed type __int64 (__fastcall *qword_405060)(_QWORD);

//----- (0000000000402460) ----------------------------------------------------
__int64 __fastcall sub_402460(__int64 a1)
{
  return sub_402050(a1);
}

//----- (0000000000402480) ----------------------------------------------------
__int64 __fastcall sub_402480(__int64 a1)
{
  return sub_402460(a1);
}

//----- (00000000004024A0) ----------------------------------------------------
__int64 __fastcall sub_4024A0(__int64 a1)
{
  return sub_402480(a1);
}

//----- (00000000004024C0) ----------------------------------------------------
__int64 __fastcall sub_4024C0(__int64 a1)
{
  return sub_4024A0(a1);
}

//----- (00000000004024E0) ----------------------------------------------------
__int64 __fastcall sub_4024E0(__int64 a1)
{
  return sub_4024C0(a1);
}

//----- (0000000000402500) ----------------------------------------------------
__int64 __fastcall sub_402500(__int64 a1)
{
  return sub_4024E0(a1);
}

//----- (0000000000402520) ----------------------------------------------------
BOOL sub_402520()
{
  sub_401028(60);
  if ( byte_405054 < 122
    && byte_405055
    && byte_405056 > (int)sub_4010D2()
    && (unsigned int)sub_40112B(62, (int)sub_401000) )
  {
    sub_4010D2();
  }
  while ( byte_405054 < 91
       && byte_40505C > byte_405057
       && sub_4010D2()
       && (unsigned int)sub_40112B(64, byte_405054)
       && byte_405059 )
    ;
  sub_401028(66);
  if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(68, (int)sub_401000) )
    sub_4010D2();
  while ( byte_405054 < 97
       && byte_40505C > byte_405057
       && sub_4010D2()
       && (unsigned int)sub_40112B(70, byte_405054)
       && byte_405059 )
    ;
  return IsDebuggerPresent();
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505C: using guessed type char byte_40505C;

//----- (000000000040274C) ----------------------------------------------------
void sub_40274C()
{
  __debugbreak();
}

//----- (000000000040275A) ----------------------------------------------------
_BYTE *sub_40275A()
{
  __int64 v0; // kr00_8
  int v1; // eax
  int v2; // eax
  _BYTE *v4; // [rsp+20h] [rbp-20h]
  _BYTE *v5; // [rsp+28h] [rbp-18h]
  int v6; // [rsp+30h] [rbp-10h]

  sub_401028(72);
  if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(74, (int)sub_401000) )
    sub_4010D2();
  while ( byte_405054 < 103
       && byte_40505C > byte_405057
       && sub_4010D2()
       && (unsigned int)sub_40112B(76, byte_405054)
       && byte_405059 )
    ;
  sub_401000();
  sub_401000();
  if ( byte_405055 && byte_405056 > (int)sub_4010D2() )
  {
    v1 = 1;
    if ( !IsDebuggerPresent() )
    {
      v0 = (byte_405055 + byte_405054 + byte_405055) * (byte_405054 / !sub_402520());
      if ( !(unsigned int)sub_401028(v0 / byte_405056) )
        v1 = 0;
    }
    if ( (unsigned int)sub_40112B(78, v1) && (sub_4010D2() || byte_405054) )
    {
      sub_40274C();
      __debugbreak();
    }
  }
  if ( byte_405055
    && byte_405056 > (int)sub_4010D2()
    && (unsigned int)sub_40112B(81, byte_405054 > 79)
    && (sub_4010D2() || byte_405054) )
  {
    sub_401000();
  }
  else if ( byte_405055
         && byte_405056 > (int)sub_4010D2()
         && (unsigned int)sub_40112B(86, 0)
         && (sub_4010D2() || byte_405054) )
  {
    sub_401028(byte_405057 - 87);
  }
  else if ( byte_405055
         && byte_405056 > (int)sub_4010D2()
         && (unsigned int)sub_40112B(90, 264 * byte_405054 + byte_40505A + byte_405057 - byte_40505D)
         && (sub_4010D2() || byte_405054) )
  {
    sub_401028(92);
    if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(94, (int)sub_401000) )
      sub_4010D2();
    while ( byte_405054 < 123
         && byte_40505C > byte_405057
         && sub_4010D2()
         && (unsigned int)sub_40112B(96, byte_405054)
         && byte_405059 )
      ;
  }
  else if ( byte_405055
         && byte_405056 > (int)sub_4010D2()
         && ((v6 = 291 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, (unsigned int)sub_401028(byte_405057))
           ? (v2 = byte_405056)
           : (v2 = byte_405054),
             (unsigned int)sub_40112B(99, v2 * v6) && (sub_4010D2() || byte_405054)) )
  {
    sub_401028(101);
    if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(103, (int)sub_401000) )
      sub_4010D2();
    while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(105, byte_405054) && byte_405059 )
      ;
  }
  else
  {
    IsDebuggerPresent();
  }
  v5 = malloc(byte_40505B);
  v5[byte_405055 + byte_405056 + byte_405057] = 0;
  v4 = &v5[byte_405056 + byte_405056 + byte_405055];
  *v4 = sub_401028(byte_405047);
  v5[byte_405056 + byte_405055 * byte_405056] = byte_405045;
  sub_401028(107);
  if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(109, (int)sub_401000) )
    sub_4010D2();
  while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(111, byte_405054) && byte_405059 )
    ;
  v5[byte_405056 * byte_405058 - byte_405059] = byte_405036;
  v5[byte_405056 * byte_405055] = byte_405049;
  v5[byte_405055 + byte_405054] = byte_405046;
  v5[byte_40505C - byte_405057 - byte_405059] = byte_405040;
  sub_401028(113);
  if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(115, (int)sub_401000) )
    sub_4010D2();
  while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(117, byte_405054) && byte_405059 )
    ;
  return v5;
}
// 402EE9: ignored the value written to the shadow area of the succeeding call
// 405036: using guessed type char byte_405036;
// 405040: using guessed type char byte_405040;
// 405045: using guessed type char byte_405045;
// 405046: using guessed type char byte_405046;
// 405047: using guessed type char byte_405047;
// 405049: using guessed type char byte_405049;
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 405059: using guessed type char byte_405059;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (0000000000403268) ----------------------------------------------------
_BYTE *sub_403268()
{
  return sub_40275A();
}

//----- (000000000040327A) ----------------------------------------------------
_BYTE *sub_40327A()
{
  return sub_403268();
}

//----- (000000000040328C) ----------------------------------------------------
_BYTE *sub_40328C()
{
  return sub_40327A();
}

//----- (000000000040329E) ----------------------------------------------------
_BYTE *sub_40329E()
{
  return sub_40328C();
}

//----- (00000000004032B0) ----------------------------------------------------
_BYTE *sub_4032B0()
{
  return sub_40329E();
}

//----- (00000000004032C2) ----------------------------------------------------
_BYTE *sub_4032C2()
{
  return sub_4032B0();
}

//----- (00000000004032D4) ----------------------------------------------------
_BYTE *sub_4032D4()
{
  return sub_4032C2();
}

//----- (00000000004032E6) ----------------------------------------------------
_BYTE *sub_4032E6()
{
  return sub_4032D4();
}

//----- (00000000004032F8) ----------------------------------------------------
_BYTE *sub_4032F8()
{
  return sub_4032E6();
}

//----- (000000000040330A) ----------------------------------------------------
_BYTE *sub_40330A()
{
  return sub_4032F8();
}

//----- (000000000040331C) ----------------------------------------------------
_BYTE *sub_40331C()
{
  return sub_40330A();
}

//----- (000000000040332E) ----------------------------------------------------
_BYTE *sub_40332E()
{
  return sub_40331C();
}

//----- (0000000000403340) ----------------------------------------------------
_BYTE *sub_403340()
{
  return sub_40332E();
}

//----- (0000000000403352) ----------------------------------------------------
_BYTE *sub_403352()
{
  return sub_403340();
}

//----- (0000000000403364) ----------------------------------------------------
_BYTE *sub_403364()
{
  return sub_403352();
}

//----- (0000000000403376) ----------------------------------------------------
_BYTE *sub_403376()
{
  return sub_403364();
}

//----- (0000000000403388) ----------------------------------------------------
_BYTE *sub_403388()
{
  return sub_403376();
}

//----- (000000000040339A) ----------------------------------------------------
BOOL sub_40339A(__int64 a1, const char *a2, ...)
{
  int v2; // eax
  int v3; // eax
  DWORD v4; // eax
  void *v6; // [rsp+38h] [rbp-418h]
  char v7[1024]; // [rsp+50h] [rbp-400h] BYREF
  va_list va; // [rsp+470h] [rbp+20h] BYREF

  va_start(va, a2);
  sub_401028(119);
  if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(121, (int)sub_401000) )
    sub_4010D2();
  while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(123, byte_405054) && byte_405059 )
    ;
  sub_404303(
    v7,
    (202 * byte_405054
   + byte_405058 * ((__int64)byte_405056 << 10) / (unsigned __int64)byte_40505C
   + byte_405058 * byte_405056 * ((__int64)byte_405055 << 10) / (unsigned __int64)byte_40505C) >> 1,
    a2,
    va);
  v2 = sub_401028(-11);
  v3 = (unsigned int)sub_401604(v2);
  v6 = (void *)(int)sub_401028(v3);
  sub_401000();
  v4 = sub_401F47(v7);
  return sub_4015B4(v6, v7, v4, 0i64, 0i64);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 405059: using guessed type char byte_405059;
// 40505C: using guessed type char byte_40505C;
// 40339A: using guessed type char var_400[1024];

//----- (000000000040362C) ----------------------------------------------------
char *__fastcall sub_40362C()
{
  __asm { cpuid }
  return aScanf;
}

//----- (0000000000403644) ----------------------------------------------------
char *__fastcall sub_403644()
{
  __asm { cpuid }
  return aSprintf;
}

//----- (000000000040365C) ----------------------------------------------------
char *__fastcall sub_40365C()
{
  __asm { cpuid }
  return aFclose;
}

//----- (0000000000403674) ----------------------------------------------------
char *__fastcall sub_403674()
{
  __asm { cpuid }
  return aFopen;
}

//----- (000000000040368C) ----------------------------------------------------
char *__fastcall sub_40368C()
{
  __asm { cpuid }
  return aFread;
}

//----- (00000000004036A4) ----------------------------------------------------
char *__fastcall sub_4036A4()
{
  __asm { cpuid }
  return aFwrite;
}

//----- (00000000004036BC) ----------------------------------------------------
char *__fastcall sub_4036BC()
{
  __asm { cpuid }
  return aExit;
}

//----- (00000000004036D4) ----------------------------------------------------
char *__fastcall sub_4036D4()
{
  __asm { cpuid }
  return aStrcpy;
}

//----- (00000000004036EC) ----------------------------------------------------
char *__fastcall sub_4036EC()
{
  __asm { cpuid }
  return aStrtok;
}

//----- (0000000000403704) ----------------------------------------------------
void *__fastcall sub_403704(void *a1, int a2, size_t a3)
{
  return memset(a1, byte_405055 * a2, a3);
}
// 405055: using guessed type char byte_405055;

//----- (0000000000403746) ----------------------------------------------------
char *__fastcall sub_403746()
{
  __asm { cpuid }
  return aMemcpy;
}

//----- (000000000040375E) ----------------------------------------------------
char *__fastcall sub_40375E()
{
  __asm { cpuid }
  return aStrchr;
}

//----- (0000000000403776) ----------------------------------------------------
char *__fastcall sub_403776()
{
  __asm { cpuid }
  return aStrrchr;
}

//----- (000000000040378E) ----------------------------------------------------
char *__fastcall sub_40378E()
{
  __asm { cpuid }
  return aRand;
}

//----- (00000000004037A6) ----------------------------------------------------
char *__fastcall sub_4037A6()
{
  __asm { cpuid }
  return aRealloc;
}

//----- (00000000004037BE) ----------------------------------------------------
void *__fastcall sub_4037BE(size_t a1, size_t a2)
{
  return calloc(a1, a2);
}

//----- (00000000004037EC) ----------------------------------------------------
__int64 __fastcall sub_4037EC(__int64 a1, __int64 a2)
{
  _BYTE *v2; // rax
  char *v3; // rax
  FARPROC v5; // [rsp+20h] [rbp-10h]
  HMODULE v6; // [rsp+28h] [rbp-8h]

  v2 = sub_403388();
  v6 = (HMODULE)sub_402500((__int64)v2);
  v3 = sub_4037A6();
  v5 = sub_401632(v6, v3);
  return ((__int64 (__fastcall *)(__int64, __int64))v5)(a1, a2);
}

//----- (000000000040384E) ----------------------------------------------------
__int64 __fastcall sub_40384E(__int64 a1)
{
  return gets(a1);
}
// 4044F0: using guessed type __int64 __fastcall gets(_QWORD);

//----- (000000000040386E) ----------------------------------------------------
__int64 sub_40386E(char *a1, size_t a2, const char *a3, ...)
{
  va_list va; // [rsp+58h] [rbp+28h] BYREF

  va_start(va, a3);
  return (unsigned int)sub_404303(a1, a2, a3, va);
}

//----- (00000000004038C0) ----------------------------------------------------
int __fastcall sub_4038C0(char *a1, const char *a2, va_list a3)
{
  return vsprintf(a1, a2, a3);
}

//----- (00000000004038F9) ----------------------------------------------------
int __fastcall sub_4038F9(char *a1, size_t a2, const char *a3, va_list a4)
{
  return sub_404303(a1, a2, a3, a4);
}

//----- (000000000040393D) ----------------------------------------------------
char *__fastcall sub_40393D(const char *a1)
{
  return getenv(a1);
}

//----- (000000000040395D) ----------------------------------------------------
int __fastcall sub_40395D(const char *a1)
{
  return system(a1);
}

//----- (000000000040397D) ----------------------------------------------------
void __noreturn sub_40397D()
{
  abort();
}

//----- (000000000040398F) ----------------------------------------------------
int __fastcall sub_40398F(void (__cdecl *a1)())
{
  return atexit(a1);
}

//----- (00000000004039AF) ----------------------------------------------------
__int64 __fastcall sub_4039AF(char *a1, int a2)
{
  return (int)getcwd(a1, a2);
}

//----- (00000000004039E0) ----------------------------------------------------
int __fastcall sub_4039E0(int a1)
{
  return tolower(a1);
}

//----- (00000000004039FF) ----------------------------------------------------
int __fastcall sub_4039FF(int a1)
{
  return toupper(a1);
}

//----- (0000000000403A1E) ----------------------------------------------------
__int64 sub_403A1E()
{
  int v1; // eax
  _BYTE *v2; // rax
  char *v3; // rax
  _BYTE *v4; // rax
  char *v5; // rax
  int v6; // eax
  int v7; // eax
  int v9; // [rsp+30h] [rbp-40h]
  FARPROC v10; // [rsp+38h] [rbp-38h]
  HMODULE v11; // [rsp+40h] [rbp-30h]
  FARPROC v12; // [rsp+48h] [rbp-28h]
  HMODULE v13; // [rsp+50h] [rbp-20h]
  char *Block; // [rsp+58h] [rbp-18h]
  int i; // [rsp+6Ch] [rbp-4h]

  for ( i = 0; i < 5; ++i )
  {
    v1 = sub_401028(256);
    Block = (char *)malloc(v1);
    v2 = sub_403388();
    v13 = (HMODULE)sub_402500((__int64)v2);
    v3 = sub_4036D4();
    v12 = sub_401632(v13, v3);
    ((void (*)(char *, const char *, ...))v12)(Block, aDHelloWorld);
    v4 = sub_403388();
    v11 = (HMODULE)sub_402500((__int64)v4);
    v5 = sub_403644();
    v10 = sub_401632(v11, v5);
    ((void (__fastcall *)(char *, char *, _QWORD))v10)(Block, Block, (unsigned int)(i + 1));
    if ( byte_405055
      && byte_405056 > (int)sub_4010D2()
      && (unsigned int)sub_40112B(130, (int)Block)
      && (sub_4010D2() || byte_405054) )
    {
      do
      {
        sub_401000();
        sub_40339A(132i64, Block);
      }
      while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(135, 0) && byte_405059 );
    }
    else if ( byte_405055
           && byte_405056 > (int)sub_4010D2()
           && (unsigned int)sub_40112B(138, 0)
           && (sub_4010D2() || byte_405054) )
    {
      sub_401000();
    }
    else if ( byte_405055
           && byte_405056 > (int)sub_4010D2()
           && (unsigned int)sub_40112B(143, 0)
           && (sub_4010D2() || byte_405054) )
    {
      sub_401028(byte_405057 - 144);
    }
    else if ( byte_405055
           && byte_405056 > (int)sub_4010D2()
           && (unsigned int)sub_40112B(147, 435 * byte_405054 + byte_40505A + byte_405057 - byte_40505D)
           && (sub_4010D2() || byte_405054) )
    {
      sub_401028(149);
      if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(151, (int)sub_401000) )
        sub_4010D2();
      while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(153, byte_405054) && byte_405059 )
        ;
    }
    else if ( byte_405055
           && byte_405056 > (int)sub_4010D2()
           && ((v9 = 462 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, (unsigned int)sub_401028(byte_405057))
             ? (v6 = byte_405056)
             : (v6 = byte_405054),
               (unsigned int)sub_40112B(156, v6 * v9) && (sub_4010D2() || byte_405054)) )
    {
      sub_401028(158);
      if ( byte_405055 && byte_405056 > (int)sub_4010D2() && (unsigned int)sub_40112B(160, (int)sub_401000) )
        sub_4010D2();
      while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(162, byte_405054) && byte_405059 )
        ;
    }
    else
    {
      do
      {
        sub_401000();
        sub_40339A(164i64, aError);
      }
      while ( byte_40505C > byte_405057 && sub_4010D2() && (unsigned int)sub_40112B(167, 0) && byte_405059 );
    }
    free(Block);
    if ( i )
      sub_401028(138 * ((252 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C - byte_405055));
  }
  v7 = getch();
  return sub_401028(504 * byte_405054 + byte_40505A + byte_405057 - byte_40505D + v7);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (0000000000404303) ----------------------------------------------------
int __fastcall sub_404303(char *a1, size_t a2, const char *a3, va_list a4)
{
  return vsnprintf(a1, a2, a3, a4);
}

//----- (0000000000404348) ----------------------------------------------------
void __noreturn start()
{
  int v0; // eax
  int v1; // [rsp+4Ch] [rbp-4h] BYREF

  v1 = 0;
  _set_app_type(_crt_console_app);
  controlfp(0x10000u, 0x30000u);
  _getmainargs(*(_QWORD *)&_argc, _argv, environ, (unsigned int)dword_4054A8, &v1);
  v0 = sub_403A1E();
  exit(v0);
}
// 404560: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4054A8: using guessed type int dword_4054A8;

//----- (0000000000404423) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_404423(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp

  *(_QWORD *)(v2 + 16) = a1;
  *(_QWORD *)(v2 + 24) = a2;
  _argc = *(_DWORD *)(v2 + 16);
  _argv = *(char ***)(v2 + 24);
  controlfp(0x10000u, 0x30000u);
  *(_QWORD *)(v2 - 8) = *(_QWORD *)&_argc;
  return sub_403A1E();
}
// 404435: write access to const memory at 405204 has been detected
// 404442: write access to const memory at 40520C has been detected
// 404423: variable 'v2' is possibly undefined

// nfuncs=98 queued=72 decompiled=72 lumina nreq=0 worse=0 better=0
// ALL OK, 72 function(s) have been successfully decompiled

```

`tests/disasm-security-audit/legacy_tests/C/after_x86.c`:

```c

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_401000();
int __cdecl sub_40100D(int a1);
BOOL sub_401097();
int __cdecl sub_4010EF(int a1, int a2);
void *__cdecl sub_4012BF(signed int a1);
BOOL __cdecl sub_401511(HANDLE hConsoleOutput, void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
HANDLE __cdecl sub_40153A(int a1);
FARPROC __stdcall sub_40155C(HMODULE hModule, LPCSTR lpProcName);
HMODULE __cdecl sub_40157B(LPCSTR lpModuleName);
int __cdecl sub_401DB6(char *a1);
int __cdecl sub_401E94(int a1);
int __cdecl sub_4021E5(int a1);
int __cdecl sub_4021FD(int a1);
int __cdecl sub_402215(int a1);
int __cdecl sub_40222D(int a1);
int __cdecl sub_402245(int a1);
int __cdecl sub_40225D(int a1);
BOOL sub_402275();
void sub_40247C();
_BYTE *sub_402489();
_BYTE *sub_402EE4();
_BYTE *sub_402EF5();
_BYTE *sub_402F06();
_BYTE *sub_402F17();
_BYTE *sub_402F28();
_BYTE *sub_402F39();
_BYTE *sub_402F4A();
_BYTE *sub_402F5B();
_BYTE *sub_402F6C();
_BYTE *sub_402F7D();
_BYTE *sub_402F8E();
_BYTE *sub_402F9F();
_BYTE *sub_402FB0();
_BYTE *sub_402FC1();
_BYTE *sub_402FD2();
_BYTE *sub_402FE3();
_BYTE *sub_402FF4();
BOOL __cdecl sub_403005(int a1, char *Format);
char *sub_403299();
char *sub_403317();
char *sub_4033BF();
int sub_4035CE();
int __cdecl sub_403DEF(char *Buffer, size_t BufferCount, char *Format, va_list ArgList); // idb
void __noreturn start(); // weak
// int __usercall sub_403F44@<eax>(int a1@<ebp>);
// int __usercall sub_403F48@<eax>(int a1@<ebp>);
int __cdecl sub_403F89(_DWORD *a1, char a2);
// BOOL __stdcall WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// char *__cdecl strcat(char *Destination, const char *Source);
// int sprintf(char *const Buffer, const char *const Format, ...);
// BOOL __stdcall IsDebuggerPresent();
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// int __cdecl getch();
// int __cdecl vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// void __cdecl _set_app_type(_crt_app_type Type);
// unsigned int __cdecl controlfp(unsigned int NewValue, unsigned int Mask);
// int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

int dword_403F78[3] = { -1, 4210514, 4210535 }; // weak
_UNKNOWN j__except_handler3; // weak
char byte_405034 = 'a'; // weak
char byte_405036 = 'c'; // weak
char byte_405037 = 'd'; // weak
char byte_405038 = 'e'; // weak
char byte_40503E = 'k'; // weak
char byte_40503F = 'l'; // weak
char byte_405040 = 'm'; // weak
char byte_405041 = 'n'; // weak
char byte_405042 = 'o'; // weak
char byte_405045 = 'r'; // weak
char byte_405046 = 's'; // weak
char byte_405047 = 't'; // weak
char byte_405049 = 'v'; // weak
char byte_40504F = 'L'; // weak
char byte_405050 = 'A'; // weak
char byte_405054 = '\0'; // weak
char byte_405055 = '\x01'; // weak
char byte_405056 = '\x02'; // weak
char byte_405057 = '\x03'; // weak
char byte_405058 = '\x04'; // weak
char byte_405059 = '\x05'; // weak
char byte_40505A = '\x06'; // weak
char byte_40505B = '\a'; // weak
char byte_40505C = '\b'; // weak
char byte_40505D = '\t'; // weak
int (__stdcall *dword_405060)(_DWORD) = NULL; // weak
char Source[] = "%d%d"; // idb
char Destination[] = "Library"; // idb
char aC[] = "%c"; // idb
char aSprintf[8] = "sprintf"; // weak
char aStrcpy[7] = "strcpy"; // weak
char aRealloc[8] = "realloc"; // weak
char aDHelloWorld[19] = "%d) Hello, world!\n"; // weak
char Format[] = "Error!"; // idb
// extern int _argc;
// extern char **_argv;
// extern char **environ;
_UNKNOWN unk_4053D4; // weak
char byte_4053E4[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
int dword_4053EC = 0; // weak


//----- (00401000) --------------------------------------------------------
void sub_401000()
{
  ;
}

//----- (0040100D) --------------------------------------------------------
int __cdecl sub_40100D(int a1)
{
  sub_401000();
  __asm { cpuid }
  return byte_405056 * byte_405058 + byte_405055 * a1 - byte_40505C;
}
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405058: using guessed type char byte_405058;
// 40505C: using guessed type char byte_40505C;

//----- (00401097) --------------------------------------------------------
BOOL sub_401097()
{
  __asm { cpuid }
  return byte_405055 && (byte_40505B + byte_40505D) / byte_40505C != byte_405055;
}
// 405055: using guessed type char byte_405055;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (004010EF) --------------------------------------------------------
int __cdecl sub_4010EF(int a1, int a2)
{
  int v8; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  v9 = sub_40100D(byte_405055 * a2);
  if ( v9 == a1 * (3 * byte_405054 + byte_40505A + byte_405057 - byte_40505D) )
    return byte_40505C != byte_405056 * byte_405058 && !sub_401097();
  _EAX = (4 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C - byte_405055;
  if ( v9 == _EAX )
    return (sub_401097()
         || 9 * byte_405054 + byte_40505A + byte_405057 != byte_40505D
         || (8 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C != byte_405055)
        && (v8 = 15 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, sub_40100D(byte_405055) + v8);
  __asm { cpuid }
  return sub_40100D(a2);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (004012BF) --------------------------------------------------------
void *__cdecl sub_4012BF(signed int a1)
{
  int v1; // eax
  _BYTE *v4; // ecx
  _BYTE *v10; // [esp+4h] [ebp-Ch]
  signed int i; // [esp+8h] [ebp-8h]

  if ( byte_405054 < 14 && byte_405055 && byte_405056 > sub_401097() )
  {
    v1 = a1 <= byte_405054
      || a1 >= (84 * byte_405054
              + byte_405058 * 16 * byte_405056 / (unsigned int)byte_40505C
              + byte_405058 * byte_405056 * 16 * byte_405055 / (unsigned int)byte_40505C) >> 1;
    if ( sub_4010EF(8, v1) && (sub_401097() || byte_405054) )
      return 0;
  }
  v10 = &unk_4053D4;
  for ( i = byte_405054; i < a1; ++i )
  {
    *v10 = 37;
    v4 = v10 + 1;
    v10 += 2;
    *v4 = byte_405036;
    if ( i )
      sub_40100D(21 * ((18 * byte_405054 + byte_40505B + byte_40505D) / byte_40505C - byte_405055));
  }
  _EAX = v10;
  *v10 = 0;
  __asm { cpuid }
  return &unk_4053D4;
}
// 405036: using guessed type char byte_405036;
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (00401511) --------------------------------------------------------
BOOL __cdecl sub_401511(
        HANDLE hConsoleOutput,
        void *lpBuffer,
        DWORD nNumberOfCharsToWrite,
        LPDWORD lpNumberOfCharsWritten,
        LPVOID lpReserved)
{
  __asm { cpuid }
  return WriteConsoleA(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
}

//----- (0040153A) --------------------------------------------------------
HANDLE __cdecl sub_40153A(int a1)
{
  int v6; // eax

  __asm { cpuid }
  v6 = sub_40100D(a1);
  return GetStdHandle(v6);
}

//----- (0040155C) --------------------------------------------------------
FARPROC __stdcall sub_40155C(HMODULE hModule, LPCSTR lpProcName)
{
  __asm { cpuid }
  return GetProcAddress(hModule, lpProcName);
}

//----- (0040157B) --------------------------------------------------------
HMODULE __cdecl sub_40157B(LPCSTR lpModuleName)
{
  __asm { cpuid }
  return GetModuleHandleA(lpModuleName);
}

//----- (00401DB6) --------------------------------------------------------
int __cdecl sub_401DB6(char *a1)
{
  int v7; // [esp+0h] [ebp-4h]

  v7 = byte_405054;
  while ( 1 )
  {
    _EAX = 79;
    if ( byte_405054 >= 79 )
      break;
    _EAX = byte_40505C;
    if ( byte_40505C <= byte_405057 )
      break;
    _EAX = sub_401097();
    if ( !_EAX )
      break;
    _EAX = sub_4010EF(52, *a1 != 0);
    if ( !_EAX )
      break;
    _EAX = byte_405059;
    if ( !byte_405059 )
      break;
    v7 += sub_40100D(byte_405055);
    a1 += sub_40100D(byte_405056 - byte_405055);
  }
  __asm { cpuid }
  return sub_40100D(byte_405054 + v7);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505C: using guessed type char byte_40505C;

//----- (00401E94) --------------------------------------------------------
int __cdecl sub_401E94(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v13; // eax
  char *v14; // eax
  char Source[32]; // [esp+0h] [ebp-5Ch] BYREF
  char *v17; // [esp+20h] [ebp-3Ch]
  char *v18; // [esp+24h] [ebp-38h]
  char *v19; // [esp+28h] [ebp-34h]
  char *v20; // [esp+2Ch] [ebp-30h]
  char *v21; // [esp+30h] [ebp-2Ch]
  char v22; // [esp+37h] [ebp-25h]
  HMODULE hModule; // [esp+38h] [ebp-24h]
  char Buffer[32]; // [esp+3Ch] [ebp-20h] BYREF

  if ( byte_405054 < 106
    && byte_405055
    && byte_405056 > sub_401097()
    && sub_4010EF(54, dword_405060 == 0)
    && (sub_401097() || byte_405054) )
  {
    v1 = (char *)sub_4012BF(byte_40505A);
    v2 = strcat(v1, ::Source);
    sprintf(
      Buffer,
      v2,
      byte_40503E,
      byte_405038,
      byte_405045,
      byte_405041,
      byte_405038,
      byte_40503F,
      byte_405057,
      byte_405056);
    hModule = sub_40157B(Buffer);
    if ( byte_405054 < 110 )
    {
      if ( byte_405055 )
      {
        if ( byte_405056 > sub_401097() )
        {
          if ( sub_4010EF(56, hModule != 0) )
          {
            _EAX = sub_401097();
            if ( _EAX || (_EAX = byte_405054) != 0 )
            {
              __asm { cpuid }
              v22 = byte_40504F;
              sub_401000();
              v21 = &byte_4053E4[byte_405058];
              *v21 = sub_40100D(byte_405054);
              v20 = &byte_4053E4[byte_405057];
              *v20 = sub_40100D(byte_405037);
              v19 = &byte_4053E4[byte_405056];
              *v19 = sub_40100D(byte_405034);
              v18 = &byte_4053E4[byte_405055];
              *v18 = sub_40100D(byte_405042);
              v17 = &byte_4053E4[byte_405054];
              _EAX = sub_40100D(byte_40504F);
              *v17 = _EAX;
              __asm { cpuid }
              v13 = strcat(Destination, aC);
              sprintf(Source, v13, byte_405050);
              v14 = strcat(byte_4053E4, Source);
              dword_405060 = (int (__stdcall *)(_DWORD))sub_40155C(hModule, v14);
            }
          }
        }
      }
    }
  }
  if ( byte_405054 < 114
    && byte_405055
    && byte_405056 > sub_401097()
    && sub_4010EF(58, dword_405060 != 0)
    && (sub_401097() || byte_405054) )
  {
    return dword_405060(a1);
  }
  else
  {
    return 0;
  }
}
// 405034: using guessed type char byte_405034;
// 405037: using guessed type char byte_405037;
// 405038: using guessed type char byte_405038;
// 40503E: using guessed type char byte_40503E;
// 40503F: using guessed type char byte_40503F;
// 405041: using guessed type char byte_405041;
// 405042: using guessed type char byte_405042;
// 405045: using guessed type char byte_405045;
// 40504F: using guessed type char byte_40504F;
// 405050: using guessed type char byte_405050;
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 40505A: using guessed type char byte_40505A;
// 405060: using guessed type int (__stdcall *dword_405060)(_DWORD);

//----- (004021E5) --------------------------------------------------------
int __cdecl sub_4021E5(int a1)
{
  return sub_401E94(a1);
}

//----- (004021FD) --------------------------------------------------------
int __cdecl sub_4021FD(int a1)
{
  return sub_4021E5(a1);
}

//----- (00402215) --------------------------------------------------------
int __cdecl sub_402215(int a1)
{
  return sub_4021FD(a1);
}

//----- (0040222D) --------------------------------------------------------
int __cdecl sub_40222D(int a1)
{
  return sub_402215(a1);
}

//----- (00402245) --------------------------------------------------------
int __cdecl sub_402245(int a1)
{
  return sub_40222D(a1);
}

//----- (0040225D) --------------------------------------------------------
int __cdecl sub_40225D(int a1)
{
  return sub_402245(a1);
}

//----- (00402275) --------------------------------------------------------
BOOL sub_402275()
{
  sub_40100D(60);
  if ( byte_405054 < 122 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(62, (int)sub_401000) )
    sub_401097();
  while ( byte_405054 < 91 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(64, byte_405054) && byte_405059 )
    ;
  sub_40100D(66);
  if ( byte_405054 != 134 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(68, (int)sub_401000) )
    sub_401097();
  while ( byte_405054 < 97 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(70, byte_405054) && byte_405059 )
    ;
  return IsDebuggerPresent();
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505C: using guessed type char byte_40505C;

//----- (0040247C) --------------------------------------------------------
void sub_40247C()
{
  __debugbreak();
}

//----- (00402489) --------------------------------------------------------
_BYTE *sub_402489()
{
  int v0; // eax
  int v1; // eax
  _BYTE *v3; // [esp+4h] [ebp-18h]
  _BYTE *v4; // [esp+8h] [ebp-14h]
  int v5; // [esp+14h] [ebp-8h]
  BOOL v6; // [esp+18h] [ebp-4h]

  sub_40100D(72);
  if ( byte_405054 != 146 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(74, (int)sub_401000) )
    sub_401097();
  while ( byte_405054 < 103 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(76, byte_405054) && byte_405059 )
    ;
  sub_401000();
  sub_401000();
  if ( byte_405054 != 154 && byte_405055 && byte_405056 > sub_401097() )
  {
    v0 = 1;
    if ( !IsDebuggerPresent() )
    {
      v6 = !sub_402275();
      if ( !sub_40100D((byte_405055 + byte_405054 + byte_405055) * (byte_405054 / v6) / byte_405056) )
        v0 = 0;
    }
    if ( sub_4010EF(78, v0) && (sub_401097() || byte_405054) )
    {
      sub_40247C();
      __debugbreak();
    }
  }
  if ( byte_405054 != 160
    && byte_405055
    && byte_405056 > sub_401097()
    && sub_4010EF(81, byte_405054 > 79)
    && (sub_401097() || byte_405054) )
  {
    sub_401000();
  }
  else if ( byte_405054 != 170
         && byte_405055
         && byte_405056 > sub_401097()
         && sub_4010EF(86, 0)
         && (sub_401097() || byte_405054) )
  {
    sub_40100D(byte_405057 - 87);
  }
  else if ( byte_405054 != 178
         && byte_405055
         && byte_405056 > sub_401097()
         && sub_4010EF(90, 264 * byte_405054 + byte_40505A + byte_405057 - byte_40505D)
         && (sub_401097() || byte_405054) )
  {
    sub_40100D(92);
    if ( byte_405054 != 186 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(94, (int)sub_401000) )
      sub_401097();
    while ( byte_405054 < 123 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(96, byte_405054) && byte_405059 )
      ;
  }
  else if ( byte_405054 != 196
         && byte_405055
         && byte_405056 > sub_401097()
         && ((v5 = 291 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, sub_40100D(byte_405057))
           ? (v1 = byte_405056)
           : (v1 = byte_405054),
             sub_4010EF(99, v1 * v5) && (sub_401097() || byte_405054)) )
  {
    sub_40100D(101);
    if ( byte_405054 != 204 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(103, (int)sub_401000) )
      sub_401097();
    while ( byte_405054 != 132
         && byte_40505C > byte_405057
         && sub_401097()
         && sub_4010EF(105, byte_405054)
         && byte_405059 )
      ;
  }
  else
  {
    IsDebuggerPresent();
  }
  v4 = malloc(byte_40505B);
  v4[byte_405055 + byte_405056 + byte_405057] = 0;
  v3 = &v4[byte_405056 + byte_405056 + byte_405055];
  *v3 = sub_40100D(byte_405047);
  v4[byte_405056 + byte_405055 * byte_405056] = byte_405045;
  sub_40100D(107);
  if ( byte_405054 != 216 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(109, (int)sub_401000) )
    sub_401097();
  while ( byte_405054 != 138 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(111, byte_405054) && byte_405059 )
    ;
  v4[byte_405056 * byte_405058 - byte_405059] = byte_405036;
  v4[byte_405056 * byte_405055] = byte_405049;
  v4[byte_405055 + byte_405054] = byte_405046;
  v4[byte_40505C - byte_405057 - byte_405059] = byte_405040;
  sub_40100D(113);
  if ( byte_405054 != 228 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(115, (int)sub_401000) )
    sub_401097();
  while ( byte_405054 != 144 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(117, byte_405054) && byte_405059 )
    ;
  return v4;
}
// 405036: using guessed type char byte_405036;
// 405040: using guessed type char byte_405040;
// 405045: using guessed type char byte_405045;
// 405046: using guessed type char byte_405046;
// 405047: using guessed type char byte_405047;
// 405049: using guessed type char byte_405049;
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 405059: using guessed type char byte_405059;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (00402EE4) --------------------------------------------------------
_BYTE *sub_402EE4()
{
  return sub_402489();
}

//----- (00402EF5) --------------------------------------------------------
_BYTE *sub_402EF5()
{
  return sub_402EE4();
}

//----- (00402F06) --------------------------------------------------------
_BYTE *sub_402F06()
{
  return sub_402EF5();
}

//----- (00402F17) --------------------------------------------------------
_BYTE *sub_402F17()
{
  return sub_402F06();
}

//----- (00402F28) --------------------------------------------------------
_BYTE *sub_402F28()
{
  return sub_402F17();
}

//----- (00402F39) --------------------------------------------------------
_BYTE *sub_402F39()
{
  return sub_402F28();
}

//----- (00402F4A) --------------------------------------------------------
_BYTE *sub_402F4A()
{
  return sub_402F39();
}

//----- (00402F5B) --------------------------------------------------------
_BYTE *sub_402F5B()
{
  return sub_402F4A();
}

//----- (00402F6C) --------------------------------------------------------
_BYTE *sub_402F6C()
{
  return sub_402F5B();
}

//----- (00402F7D) --------------------------------------------------------
_BYTE *sub_402F7D()
{
  return sub_402F6C();
}

//----- (00402F8E) --------------------------------------------------------
_BYTE *sub_402F8E()
{
  return sub_402F7D();
}

//----- (00402F9F) --------------------------------------------------------
_BYTE *sub_402F9F()
{
  return sub_402F8E();
}

//----- (00402FB0) --------------------------------------------------------
_BYTE *sub_402FB0()
{
  return sub_402F9F();
}

//----- (00402FC1) --------------------------------------------------------
_BYTE *sub_402FC1()
{
  return sub_402FB0();
}

//----- (00402FD2) --------------------------------------------------------
_BYTE *sub_402FD2()
{
  return sub_402FC1();
}

//----- (00402FE3) --------------------------------------------------------
_BYTE *sub_402FE3()
{
  return sub_402FD2();
}

//----- (00402FF4) --------------------------------------------------------
_BYTE *sub_402FF4()
{
  return sub_402FE3();
}

//----- (00403005) --------------------------------------------------------
BOOL __cdecl sub_403005(int a1, char *Format)
{
  int v2; // eax
  HANDLE v3; // eax
  int v4; // eax
  HANDLE hConsoleOutput; // [esp+0h] [ebp-410h]
  char Buffer[1024]; // [esp+10h] [ebp-400h] BYREF

  sub_40100D(119);
  if ( byte_405054 != 240 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(121, (int)sub_401000) )
    sub_401097();
  while ( byte_405054 != 150 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(123, byte_405054) && byte_405059 )
    ;
  sub_403DEF(
    Buffer,
    (203 * byte_405054
   + byte_405058 * (byte_405056 << 10) / (unsigned int)byte_40505C
   + byte_405058 * byte_405056 * (byte_405055 << 10) / (unsigned int)byte_40505C) >> 1,
    Format,
    (va_list)&Format
  + ((((202 * byte_405054
      + byte_405058 * 4 * byte_405056 / (unsigned int)byte_40505C
      + byte_405058 * byte_405056 * 4 * byte_405055 / (unsigned int)byte_40505C) >> 1)
    + 3) & 0xFFFFFFFC));
  v2 = sub_40100D(-11);
  v3 = sub_40153A(v2);
  hConsoleOutput = (HANDLE)sub_40100D((int)v3);
  sub_401000();
  v4 = sub_401DB6(Buffer);
  return sub_401511(hConsoleOutput, Buffer, v4, 0, 0);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405058: using guessed type char byte_405058;
// 405059: using guessed type char byte_405059;
// 40505C: using guessed type char byte_40505C;

//----- (00403299) --------------------------------------------------------
char *sub_403299()
{
  __asm { cpuid }
  return aSprintf;
}

//----- (00403317) --------------------------------------------------------
char *sub_403317()
{
  __asm { cpuid }
  return aStrcpy;
}

//----- (004033BF) --------------------------------------------------------
char *sub_4033BF()
{
  __asm { cpuid }
  return aRealloc;
}

//----- (004035CE) --------------------------------------------------------
int sub_4035CE()
{
  int v1; // eax
  _BYTE *v2; // eax
  char *v3; // eax
  _BYTE *v4; // eax
  char *v5; // eax
  int v6; // eax
  int v8; // [esp+0h] [ebp-24h]
  int v9; // [esp+4h] [ebp-20h]
  FARPROC v10; // [esp+8h] [ebp-1Ch]
  HMODULE v11; // [esp+Ch] [ebp-18h]
  FARPROC v12; // [esp+10h] [ebp-14h]
  HMODULE hModule; // [esp+14h] [ebp-10h]
  char *Block; // [esp+18h] [ebp-Ch]
  int i; // [esp+20h] [ebp-4h]

  for ( i = 0; i < 5; ++i )
  {
    v1 = sub_40100D(256);
    Block = (char *)malloc(v1);
    v2 = sub_402FF4();
    hModule = (HMODULE)sub_40225D((int)v2);
    v3 = sub_403317();
    v12 = sub_40155C(hModule, v3);
    ((void (*)(char *, const char *, ...))v12)(Block, aDHelloWorld);
    v4 = sub_402FF4();
    v11 = (HMODULE)sub_40225D((int)v4);
    v5 = sub_403299();
    v10 = sub_40155C(v11, v5);
    ((void (__cdecl *)(char *, char *, int))v10)(Block, Block, i + 1);
    if ( byte_405054 != 262
      && byte_405055
      && byte_405056 > sub_401097()
      && sub_4010EF(132, (int)Block)
      && (sub_401097() || byte_405054) )
    {
      do
      {
        sub_401000();
        sub_403005(134, Block);
      }
      while ( byte_405054 != 164 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(137, 0) && byte_405059 );
    }
    else if ( byte_405054 != 278
           && byte_405055
           && byte_405056 > sub_401097()
           && sub_4010EF(140, 0)
           && (sub_401097() || byte_405054) )
    {
      sub_401000();
    }
    else if ( byte_405054 != 288
           && byte_405055
           && byte_405056 > sub_401097()
           && sub_4010EF(145, 0)
           && (sub_401097() || byte_405054) )
    {
      sub_40100D(byte_405057 - 146);
    }
    else if ( byte_405054 != 296
           && byte_405055
           && byte_405056 > sub_401097()
           && sub_4010EF(149, 441 * byte_405054 + byte_40505A + byte_405057 - byte_40505D)
           && (sub_401097() || byte_405054) )
    {
      sub_40100D(151);
      if ( byte_405054 != 304 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(153, (int)sub_401000) )
        sub_401097();
      while ( byte_405054 != 182
           && byte_40505C > byte_405057
           && sub_401097()
           && sub_4010EF(155, byte_405054)
           && byte_405059 )
        ;
    }
    else if ( byte_405054 != 314
           && byte_405055
           && byte_405056 > sub_401097()
           && ((v9 = 468 * byte_405054 + byte_40505A + byte_405057 - byte_40505D, sub_40100D(byte_405057))
             ? (v6 = byte_405056)
             : (v6 = byte_405054),
               sub_4010EF(158, v6 * v9) && (sub_401097() || byte_405054)) )
    {
      sub_40100D(160);
      if ( byte_405054 != 322 && byte_405055 && byte_405056 > sub_401097() && sub_4010EF(162, (int)sub_401000) )
        sub_401097();
      while ( byte_405054 != 191
           && byte_40505C > byte_405057
           && sub_401097()
           && sub_4010EF(164, byte_405054)
           && byte_405059 )
        ;
    }
    else
    {
      do
      {
        sub_401000();
        sub_403005(166, Format);
      }
      while ( byte_405054 != 196 && byte_40505C > byte_405057 && sub_401097() && sub_4010EF(169, 0) && byte_405059 );
    }
    free(Block);
    if ( i )
      sub_40100D(140 * (((byte_405054 << 8) + byte_40505B + byte_40505D) / byte_40505C - byte_405055));
  }
  v8 = getch();
  return sub_40100D(510 * byte_405054 + byte_40505A + byte_405057 - byte_40505D + v8);
}
// 405054: using guessed type char byte_405054;
// 405055: using guessed type char byte_405055;
// 405056: using guessed type char byte_405056;
// 405057: using guessed type char byte_405057;
// 405059: using guessed type char byte_405059;
// 40505A: using guessed type char byte_40505A;
// 40505B: using guessed type char byte_40505B;
// 40505C: using guessed type char byte_40505C;
// 40505D: using guessed type char byte_40505D;

//----- (00403DEF) --------------------------------------------------------
int __cdecl sub_403DEF(char *Buffer, size_t BufferCount, char *Format, va_list ArgList)
{
  return vsnprintf(Buffer, BufferCount, Format, ArgList);
}

//----- (00403E14) --------------------------------------------------------
void __noreturn start()
{
  int v0; // eax
  char v1; // [esp+0h] [ebp-24h]
  int v2; // [esp+8h] [ebp-1Ch] BYREF
  int v3[6]; // [esp+Ch] [ebp-18h] BYREF

  sub_403F89(v3, v1);
  v2 = 0;
  _set_app_type(_crt_console_app);
  controlfp(0x10000u, 0x30000u);
  _getmainargs(_argc, _argv, environ, dword_4053EC, &v2);
  v0 = sub_4035CE();
  exit(v0);
}
// 403E22: variable 'v1' is possibly undefined
// 403E14: using guessed type void __noreturn start();
// 404088: using guessed type int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4053EC: using guessed type int dword_4053EC;
// 403E14: using guessed type int var_18[6];

//----- (00403F44) --------------------------------------------------------
int __usercall sub_403F44@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 20);
}

//----- (00403F48) --------------------------------------------------------
int __usercall sub_403F48@<eax>(int a1@<ebp>)
{
  return **(_DWORD **)sub_403F44(a1);
}

//----- (00403F89) --------------------------------------------------------
int __cdecl sub_403F89(_DWORD *a1, char a2)
{
  int result; // eax

  *a1 = &a2;
  a1[1] = 0;
  a1[2] = NtCurrentTeb()->NtTib.ExceptionList;
  a1[3] = &sub_403F84;
  a1[4] = dword_403F78;
  result = 0;
  a1[5] = 0;
  return result;
}
// 403F78: using guessed type int dword_403F78[3];

// nfuncs=77 queued=47 decompiled=47 lumina nreq=0 worse=0 better=0
// ALL OK, 47 function(s) have been successfully decompiled

```

`tests/disasm-security-audit/legacy_tests/C/before_x64.c`:

```c

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_401000();
void __noreturn start();
int __fastcall sub_4011C3(__int64 a1, __int64 a2);
// void *__cdecl malloc(size_t Size);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int sprintf(char *const Buffer, const char *const Format, ...);
// int printf(const char *const Format, ...);
// void __cdecl free(void *Block);
// int __cdecl getch();
// void __cdecl _set_app_type(_crt_app_type Type);
// unsigned int __cdecl controlfp(unsigned int NewValue, unsigned int Mask);
// __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

char Source[] = "%d) Hello, world!\n"; // idb
// extern int _argc;
// extern char **_argv;
// extern char **environ;
int dword_4021C0 = 0; // weak


//----- (0000000000401000) ----------------------------------------------------
int sub_401000()
{
  char *Destination; // [rsp+20h] [rbp-10h]
  int i; // [rsp+2Ch] [rbp-4h]

  for ( i = 0; i < 5; ++i )
  {
    Destination = (char *)(int)malloc(0x100ui64);
    strcpy(Destination, Source);
    sprintf(Destination, Destination, (unsigned int)(i + 1));
    if ( Destination )
      printf(Destination);
    else
      printf("Error!");
    free(Destination);
  }
  return getch();
}

//----- (00000000004010E8) ----------------------------------------------------
void __noreturn start()
{
  int v0; // eax
  int v1; // [rsp+4Ch] [rbp-4h] BYREF

  v1 = 0;
  _set_app_type(_crt_console_app);
  controlfp(0x10000u, 0x30000u);
  _getmainargs(*(_QWORD *)&_argc, _argv, environ, (unsigned int)dword_4021C0, &v1);
  v0 = sub_401000();
  exit(v0);
}
// 401280: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4021C0: using guessed type int dword_4021C0;

//----- (00000000004011C3) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __fastcall sub_4011C3(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp

  *(_QWORD *)(v2 + 16) = a1;
  *(_QWORD *)(v2 + 24) = a2;
  _argc = *(_DWORD *)(v2 + 16);
  _argv = *(char ***)(v2 + 24);
  controlfp(0x10000u, 0x30000u);
  *(_QWORD *)(v2 - 8) = *(_QWORD *)&_argc;
  return sub_401000();
}
// 4011D5: write access to const memory at 402088 has been detected
// 4011E2: write access to const memory at 402090 has been detected
// 4011C3: variable 'v2' is possibly undefined

// nfuncs=13 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled

```

`tests/disasm-security-audit/legacy_tests/C/before_x86.c`:

```c

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_401000();
void __noreturn start(); // weak
// int __usercall sub_4011E0@<eax>(int a1@<ebp>);
// int __usercall sub_4011E4@<eax>(int a1@<ebp>);
int __cdecl sub_401225(_DWORD *a1, char a2);
// void *__cdecl malloc(size_t Size);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int sprintf(char *const Buffer, const char *const Format, ...);
// int printf(const char *const Format, ...);
// void __cdecl free(void *Block);
// int __cdecl getch();
// void __cdecl _set_app_type(_crt_app_type Type);
// unsigned int __cdecl controlfp(unsigned int NewValue, unsigned int Mask);
// int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

int dword_401214[3] = { -1, 4198894, 4198915 }; // weak
_UNKNOWN j__except_handler3; // weak
char Source[] = "%d) Hello, world!\n"; // idb
// extern int _argc;
// extern char **_argv;
// extern char **environ;
int dword_40218C = 0; // weak


//----- (00401000) --------------------------------------------------------
int sub_401000()
{
  char *Destination; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 5; ++i )
  {
    Destination = (char *)malloc(0x100u);
    strcpy(Destination, Source);
    sprintf(Destination, Destination, i + 1);
    if ( Destination )
      printf(Destination);
    else
      printf("Error!");
    free(Destination);
  }
  return getch();
}

//----- (004010B0) --------------------------------------------------------
void __noreturn start()
{
  int v0; // eax
  int v1; // [esp+8h] [ebp-1Ch] BYREF
  char v2[24]; // [esp+Ch] [ebp-18h] BYREF

  sub_401225(v2);
  v1 = 0;
  _set_app_type(_crt_console_app);
  controlfp(0x10000u, 0x30000u);
  _getmainargs(_argc, _argv, environ, dword_40218C, &v1);
  v0 = sub_401000(_argc, _argv, environ);
  exit(v0);
}
// 401000: using guessed type int __cdecl sub_401000(_DWORD, _DWORD, _DWORD);
// 4010B0: using guessed type void __noreturn start();
// 4012A0: using guessed type int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40218C: using guessed type int dword_40218C;
// 4010B0: using guessed type char var_18[24];

//----- (004011E0) --------------------------------------------------------
int __usercall sub_4011E0@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 20);
}

//----- (004011E4) --------------------------------------------------------
int __usercall sub_4011E4@<eax>(int a1@<ebp>)
{
  return **(_DWORD **)sub_4011E0(a1);
}

//----- (00401225) --------------------------------------------------------
int __cdecl sub_401225(_DWORD *a1, char a2)
{
  int result; // eax

  *a1 = &a2;
  a1[1] = 0;
  a1[2] = NtCurrentTeb()->NtTib.ExceptionList;
  a1[3] = &sub_401220;
  a1[4] = dword_401214;
  result = 0;
  a1[5] = 0;
  return result;
}
// 401214: using guessed type int dword_401214[3];

// nfuncs=19 queued=5 decompiled=5 lumina nreq=0 worse=0 better=0
// ALL OK, 5 function(s) have been successfully decompiled

```

`tests/disasm-security-audit/legacy_tests/example.c`:

```c

#include <stdio.h>

// #define no_cflow      1
// #define no_antidebug  1
#include "../../include/obfus.h"
#include "example.h"  // test header import

void main() {
    int i = 0;
    for (i = 0; i < 5; i++) {
        char *out = malloc(256);

        strcpy(out, teststr);

        sprintf(out, out, (i + 1));

        if (out) {
            printf(out);
        } else {
            printf(errstr);
        }

        free(out);
    }

    getch();
}
```

`tests/dll.c`:

```c
//+---------------------------------------------------------------------------
//
//  dll.c - Windows DLL example - dynamically linked part
//

#include <windows.h>
#include "../include/obfus.h"

// Exported data
__declspec(dllexport) const char *hello_data = "(not set)";

// Exported function
__declspec(dllexport) void hello_func(void)
{
    MessageBoxA(NULL, hello_data, "From DLL", MB_ICONINFORMATION);
}

```

`tests/fib.c`:

```c
#include <stdio.h>
#include <stdlib.h>  // For atoi()

#include "../include/obfus.h"

/**
 * Computes the nth Fibonacci number recursively.
 * For n <= 2, returns 1.
 * For n > 2, returns fib(n-1) + fib(n-2).
 *
 * @param n The position in the Fibonacci sequence (must be >= 1).
 * @return The nth Fibonacci number.
 */
int fib(int n) {
    if (n <= 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

/**
 * Entry point of the program.
 * Expects a single command-line argument specifying n.
 * Prints the nth Fibonacci number.
 *
 * Usage:
 *   fib n
 *
 * Example:
 *   fib 10
 *   Output: fib(10) = 55
 */
int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: fib n\n");
        printf("Compute the nth Fibonacci number.\n");
        return 1;
    }

    int n = atoi(argv[1]);
    printf("fib(%d) = %d\n", n, fib(n));
    return 0;
}

```

`tests/hello_dll.c`:

```c
//-----------------------------------------------------------------------------
//  HELLO_DLL.C - Windows DLL example - Main Application Entry Point
//-----------------------------------------------------------------------------

#include <windows.h>
#include "../include/obfus.h"

// Function prototype for DLL function
void hello_func(void);

// Import external constant defined in the DLL
__declspec(dllimport) extern const char *hello_data;

// Entry point for the Windows application
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    // Set the shared DLL data to a greeting message
    hello_data = "Hello World!";

    // Call the DLL's function to display or process the message
    hello_func();

    // Exit the application
    return 0;
}

```

`tests/hello_win.c`:

```c
//+---------------------------------------------------------------------------
//
//  HELLO_WIN.C - Windows GUI 'Hello World!' Example
//
//+---------------------------------------------------------------------------

#include <windows.h>
#include "../include/obfus.h"

#define APPNAME "Turn around"

char szAppName[] = APPNAME;      // Application name
char szTitle[] = APPNAME;        // Title bar text
const char *pWindowText;         // Text to display in window

void CenterWindow(HWND hWnd);

//+---------------------------------------------------------------------------
//  WndProc - Handles window messages
//+---------------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_CREATE:
            CenterWindow(hwnd);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_RBUTTONUP:           // Right mouse button releases
        case WM_KEYDOWN:
            if (message == WM_KEYDOWN && wParam != VK_ESCAPE)
                break;
            DestroyWindow(hwnd);
            break;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            RECT rc;
            GetClientRect(hwnd, &rc);
            SetTextColor(hdc, RGB(240, 240, 96));
            SetBkMode(hdc, TRANSPARENT);
            DrawText(hdc, pWindowText, -1, &rc, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
            EndPaint(hwnd, &ps);
            break;
        }

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//  WinMain - Program Entry Point
//+---------------------------------------------------------------------------
int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
) {
    MSG msg;
    WNDCLASS wc = { 0 };
    HWND hwnd;

    // Use command line as window text, or default
    pWindowText = lpCmdLine[0] ? lpCmdLine : "DosX behind you!";

    // Set up window class
    wc.hInstance = hInstance;
    wc.lpszClassName = szAppName;
    wc.lpfnWndProc = WndProc;
    wc.style = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);

    if (!RegisterClass(&wc))
        return 0;

    // Create main window
    hwnd = CreateWindow(
        szAppName, szTitle,
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT, CW_USEDEFAULT,
        360, 240,         // Size: width, height
        NULL, NULL,
        hInstance, NULL
    );

    if (!hwnd)
        return 0;

    // Message loop
    while (GetMessage(&msg, NULL, 0, 0) > 0) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

//+---------------------------------------------------------------------------
//  CenterWindow - Centers window on its parent or desktop
//+---------------------------------------------------------------------------
void CenterWindow(HWND hwnd_self) {
    HWND hwnd_parent = GetParent(hwnd_self);
    if (!hwnd_parent)
        hwnd_parent = GetDesktopWindow();

    RECT rw_self, rc_parent, rw_parent;
    GetWindowRect(hwnd_parent, &rw_parent);
    GetClientRect(hwnd_parent, &rc_parent);
    GetWindowRect(hwnd_self, &rw_self);

    int xpos = rw_parent.left + (rc_parent.right + rw_self.left - rw_self.right) / 2;
    int ypos = rw_parent.top + (rc_parent.bottom + rw_self.top - rw_self.bottom) / 2;

    SetWindowPos(
        hwnd_self, NULL,
        xpos, ypos, 0, 0,
        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE
    );
}

```

`tests/sorter.c`:

```c
#include <stdio.h>

#include "../include/obfus.h"

void main() {
    int arr[] = {
        1524, 5772, 9906, 9432, 5306, 5762, 4371, 9723, 9262, 9163, 548, 3736, 3436, 7444,
        9943, 811, 4215, 4729, 2628, 4105, 4037, 4083, 5397, 8664, 9460, 1784, 3785, 3067,
        9358, 7312, 8307, 1937, 4282, 3470, 5392, 9720, 4800, 4886, 8412, 7641, 9326, 3347,
        2090, 4488, 9799, 7541, 316, 9869, 2501, 4003, 9095, 784, 1351, 1507, 8407, 5526,
        9557, 5974, 9651, 5200, 4325, 2102, 9228, 6673, 4274, 7979, 5030, 2421, 3103, 9062,
        4841, 2096, 3501, 8380, 2422, 6122, 6033, 855, 6767, 4297, 8859, 7955, 176, 8883,
        5556, 4988, 6100, 6091, 9274, 8378, 7696, 8531, 3927, 8836, 6839, 3592, 2739, 3150,
        7955, 2887, 5002, 3536, 5918, 627, 5063, 6466, 7177, 5152, 5581, 4314, 1617, 8122,
        4920, 3178, 7696, 4357, 6206, 2738, 529, 6669, 5035, 7676, 1470, 616, 1784, 2596,
        6340, 1917, 7703, 7437, 9938, 7014, 8238, 5793, 758, 9369, 6611, 8693, 4445, 2894,
        7870, 9801, 2581, 3915, 938, 184, 8947, 329, 9964, 2499, 8741, 3345, 8551, 7111,
        3362, 1029, 3947};

    int n = sizeof(arr) / sizeof(arr[0]);

    int key, j;
    for (int i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }

    for (int f = 0; f < n; f++) printf("%d ", arr[f]);
    printf("\n");
}
```

`tests/virtualmachine.c`:

```c
#include <stdio.h>
#include <string.h>
#include <windows.h>

#define VIRT 1
#include "../include/obfus.h"

void main() {
    //      VM_***(N1, N2) == RESULT == CORRECT
    printf("VM_ADD(15, 15) == %d == 30\n", VM_ADD(15, 15));
    printf("VM_SUB(30, 15) == %d == 15\n", VM_SUB(30, 15));
    printf("VM_MUL(5, 6) == %d == 30\n", VM_MUL(5, 6));
    printf("VM_DIV(20, 4) == %d == 5\n", VM_DIV(20, 4));
    printf("VM_MOD(20, 3) == %d == 2\n", VM_MOD(20, 3));
    printf("VM_EQU(10, 10) == %d == 1\n", VM_EQU(10, 10));
    printf("VM_EQU(10, 20) == %d == 0\n", VM_EQU(10, 20));
    printf("VM_NEQ(10, 20) == %d == 1\n", VM_NEQ(10, 20));
    printf("VM_NEQ(10, 20) == %d == 0\n", VM_NEQ(10, 10));
    printf("VM_LSS(10, 20) == %d == 1\n", VM_LSS(10, 20));
    printf("VM_LSS(20, 10) == %d == 0\n", VM_LSS(20, 10));
    printf("VM_GTR(20, 10) == %d == 1\n", VM_GTR(20, 10));
    printf("VM_GTR(10, 20) == %d == 0\n", VM_GTR(10, 20));
    printf("VM_LEQ(10, 10) == %d == 1\n", VM_LEQ(10, 10));
    printf("VM_LEQ(20, 10) == %d == 0\n", VM_LEQ(20, 10));
    printf("VM_GEQ(20, 10) == %d == 1\n", VM_GEQ(20, 10));
    printf("VM_GEQ(10, 20) == %d == 0\n", VM_GEQ(10, 20));

    printf("VM_ADD_DBL(3.5, 4.5) == %.1f == 8.0\n", VM_ADD_DBL(3.5, 4.5));
    printf("VM_SUB_DBL(10.0, 5.5) == %.1f == 4.5\n", VM_SUB_DBL(10.0, 5.5));
    printf("VM_MUL_DBL(2.5, 4.0) == %.1f == 10.0\n", VM_MUL_DBL(2.5, 4.0));
    printf("VM_DIV_DBL(20.0, 4.0) == %.1f == 5.0\n", VM_DIV_DBL(20.0, 4.0));
    printf("VM_LSS_DBL(3.5, 4.5) == %d == 1\n", VM_LSS_DBL(3.5, 4.5));
    printf("VM_LSS_DBL(4.5, 3.5) == %d == 0\n", VM_LSS_DBL(4.5, 3.5));
    printf("VM_GTR_DBL(4.5, 3.5) == %d == 1\n", VM_GTR_DBL(4.5, 3.5));
    printf("VM_GTR_DBL(3.5, 4.5) == %d == 0\n", VM_GTR_DBL(3.5, 4.5));

    getch();
}
```

`tests/virtualmachine_unit.c`:

```c
// Unit testing is very helpful in fixing virtualization bugs, but fixing them is still always a big headache!

#include <stdio.h>
#include <assert.h>

#define VIRT 1
#include "../include/obfus.h"

void test_int_operations() {
    // Test integer operations
    assert(VM_ADD(15, 15) == 30);
    assert(VM_SUB(30, 15) == 15);
    assert(VM_MUL(5, 6) == 30);
    assert(VM_DIV(20, 4) == 5);
    assert(VM_MOD(20, 3) == 2);
    assert(VM_EQU(10, 10) == 1);
    assert(VM_EQU(10, 20) == 0);
    assert(VM_NEQ(10, 20) == 1);
    assert(VM_NEQ(10, 10) == 0);
    assert(VM_LSS(10, 20) == 1);
    assert(VM_LSS(20, 10) == 0);
    assert(VM_GTR(20, 10) == 1);
    assert(VM_GTR(10, 20) == 0);
    assert(VM_LEQ(10, 10) == 1);
    assert(VM_LEQ(20, 10) == 0);
    assert(VM_GEQ(20, 10) == 1);
    assert(VM_GEQ(10, 20) == 0);

    printf("Integer operations: Passed\n");
}

void test_double_operations() {
    // Test double operations
    assert(VM_ADD_DBL(3.5, 4.5) == 8.0);
    assert(VM_SUB_DBL(10.0, 5.5) == 4.5);
    assert(VM_MUL_DBL(2.5, 4.0) == 10.0);
    assert(VM_DIV_DBL(20.0, 4.0) == 5.0);
    assert(VM_LSS_DBL(3.5, 4.5) == 1);
    assert(VM_LSS_DBL(4.5, 3.5) == 0);
    assert(VM_GTR_DBL(4.5, 3.5) == 1);
    assert(VM_GTR_DBL(3.5, 4.5) == 0);

    printf("Double operations: Passed\n");
}

void main() {
    // Call all the tests
    test_int_operations();
    test_double_operations();
}
```