Project Path: arc_hfiref0x_WinObjEx64_p_qlagzk

Source Tree:

```txt
arc_hfiref0x_WinObjEx64_p_qlagzk
├── Docs
│   ├── Callbacks.pdf
│   ├── Plugins
│   │   ├── Plugins.odt
│   │   └── Plugins.pdf
│   ├── Screenshots
│   │   ├── AlpcPortConnections.png
│   │   ├── ApiSetView.png
│   │   ├── ApiSetView190.png
│   │   ├── CallbackObjectView.png
│   │   ├── CallbacksView.png
│   │   ├── CmControlVector.png
│   │   ├── FindObjectDialog.png
│   │   ├── ImsSection.png
│   │   ├── ImsStrings.png
│   │   ├── MainWindow.png
│   │   ├── NdisProtocols.png
│   │   ├── ObjectTypeView.png
│   │   ├── ProcessList.png
│   │   ├── PropertiesDialog.png
│   │   ├── SecurityDialogPage.png
│   │   ├── TokenProperties.png
│   │   ├── UnloadedDrivers.png
│   │   ├── ViewingObjectDump.png
│   │   ├── ViewingPipes.png
│   │   ├── ViewingPrivateNamespaces.png
│   │   ├── ViewingProcessProperties.png
│   │   ├── ViewingSectionObject.png
│   │   ├── ViewingServiceTable.png
│   │   ├── ViewingThreadProperties.png
│   │   ├── ViewingTokenProperties.png
│   │   ├── ViewingTypeInformation.png
│   │   ├── ViewingUserSharedData.png
│   │   └── W32pServiceTableView.png
│   ├── WHATSNEW_170.md
│   ├── WHATSNEW_173.md
│   ├── WHATSNEW_180.md
│   ├── WHATSNEW_187.md
│   ├── WHATSNEW_190.md
│   ├── WHATSNEW_200.md
│   └── WinObjEx64.chm
├── LICENSE.md
├── README.md
├── Source
│   ├── CHANGELOG.txt
│   ├── FILELIST.txt
│   ├── Plugins
│   │   ├── ApiSetView
│   │   │   ├── ApiSetView.vcxproj
│   │   │   ├── ApiSetView.vcxproj.filters
│   │   │   ├── ApiSetView.vcxproj.user
│   │   │   ├── Resource.rc
│   │   │   ├── export.def
│   │   │   ├── global.h
│   │   │   ├── main.c
│   │   │   ├── query.c
│   │   │   ├── query.h
│   │   │   ├── resource.h
│   │   │   └── ui.h
│   │   ├── ExamplePlugin
│   │   │   ├── ExamplePlugin.vcxproj
│   │   │   ├── ExamplePlugin.vcxproj.filters
│   │   │   ├── ExamplePlugin.vcxproj.user
│   │   │   ├── Resource.rc
│   │   │   ├── export.def
│   │   │   ├── main.c
│   │   │   └── resource.h
│   │   ├── ImageScope
│   │   │   ├── ImageScope.vcxproj
│   │   │   ├── ImageScope.vcxproj.filters
│   │   │   ├── ImageScope.vcxproj.user
│   │   │   ├── Resource.rc
│   │   │   ├── export.def
│   │   │   ├── global.h
│   │   │   ├── main.c
│   │   │   ├── query.c
│   │   │   ├── query.h
│   │   │   ├── resource.h
│   │   │   ├── ui.c
│   │   │   └── ui.h
│   │   ├── Sonar
│   │   │   ├── Resource.rc
│   │   │   ├── Sonar.vcxproj
│   │   │   ├── Sonar.vcxproj.filters
│   │   │   ├── Sonar.vcxproj.user
│   │   │   ├── export.def
│   │   │   ├── global.h
│   │   │   ├── main.c
│   │   │   ├── ndis.h
│   │   │   ├── query.c
│   │   │   ├── query.h
│   │   │   ├── resource.h
│   │   │   └── ui.h
│   │   ├── plugin_def.h
│   │   ├── postbuild.cmd
│   │   ├── utils.c
│   │   └── utils.h
│   ├── Shared
│   │   ├── minirtl
│   │   │   ├── _filename.c
│   │   │   ├── _filename.h
│   │   │   ├── _strcat.c
│   │   │   ├── _strchr.c
│   │   │   ├── _strcmp.c
│   │   │   ├── _strcmpi.c
│   │   │   ├── _strcpy.c
│   │   │   ├── _strcpyn.c
│   │   │   ├── _strend.c
│   │   │   ├── _strlen.c
│   │   │   ├── _strncmp.c
│   │   │   ├── _strncmpi.c
│   │   │   ├── _strncpy.c
│   │   │   ├── _strstr.c
│   │   │   ├── _strstri.c
│   │   │   ├── hextou64.c
│   │   │   ├── hextoul.c
│   │   │   ├── i64tostr.c
│   │   │   ├── itostr.c
│   │   │   ├── minirtl.h
│   │   │   ├── rtltypes.h
│   │   │   ├── strtoi.c
│   │   │   ├── strtoi64.c
│   │   │   ├── strtou64.c
│   │   │   ├── strtoul.c
│   │   │   ├── u64tohex.c
│   │   │   ├── u64tostr.c
│   │   │   ├── ultohex.c
│   │   │   └── ultostr.c
│   │   ├── ntos
│   │   │   ├── apisetx.h
│   │   │   ├── halamd64.h
│   │   │   ├── ntalpc.h
│   │   │   ├── ntbuilds.h
│   │   │   ├── ntldr.c
│   │   │   ├── ntldr.h
│   │   │   ├── ntos.h
│   │   │   ├── ntsup.c
│   │   │   └── ntsup.h
│   │   ├── ntuser
│   │   │   └── ntuser.h
│   │   ├── sdk
│   │   │   └── extdef.h
│   │   ├── tabs
│   │   │   ├── tabsctrl.c
│   │   │   └── tabsctrl.h
│   │   └── treelist
│   │       ├── treelist.c
│   │       └── treelist.h
│   ├── TypesWithNoDesc.txt
│   ├── Utils
│   │   ├── GenAsIo2Unlock
│   │   │   ├── GenAsIo2Unlock.sln
│   │   │   ├── GenAsIo2Unlock.vcxproj
│   │   │   ├── GenAsIo2Unlock.vcxproj.filters
│   │   │   ├── GenAsIo2Unlock.vcxproj.user
│   │   │   └── main.cpp
│   │   ├── SearchPattern
│   │   │   ├── SearchPattern.cpp
│   │   │   ├── SearchPattern.sln
│   │   │   ├── SearchPattern.vcxproj
│   │   │   ├── SearchPattern.vcxproj.filters
│   │   │   ├── SearchPattern.vcxproj.user
│   │   │   └── test.cmd
│   │   └── readme.txt
│   ├── WinObjEx64
│   │   ├── Resource.rc
│   │   ├── WinObjEx64.vcxproj
│   │   ├── WinObjEx64.vcxproj.filters
│   │   ├── WinObjEx64.vcxproj.user
│   │   ├── aboutDlg.c
│   │   ├── driver.rc
│   │   ├── drivers
│   │   │   ├── wdbgdrv.c
│   │   │   ├── wdbgdrv.h
│   │   │   ├── wdrvprv.c
│   │   │   ├── wdrvprv.h
│   │   │   ├── winio.c
│   │   │   └── winio.h
│   │   ├── excepth.c
│   │   ├── excepth.h
│   │   ├── extapi.c
│   │   ├── extapi.h
│   │   ├── extras
│   │   │   ├── extras.c
│   │   │   ├── extras.h
│   │   │   ├── extrasCallbacks.c
│   │   │   ├── extrasCallbacksPatterns.h
│   │   │   ├── extrasCmOpt.c
│   │   │   ├── extrasDrivers.c
│   │   │   ├── extrasIPC.c
│   │   │   ├── extrasPN.c
│   │   │   ├── extrasPSList.c
│   │   │   ├── extrasSL.c
│   │   │   ├── extrasSSDT.c
│   │   │   └── extrasUSD.c
│   │   ├── findDlg.c
│   │   ├── global.h
│   │   ├── hash.c
│   │   ├── hash.h
│   │   ├── hde
│   │   │   ├── hde64.c
│   │   │   ├── hde64.h
│   │   │   ├── pstdint.h
│   │   │   └── table64.h
│   │   ├── kldbg.c
│   │   ├── kldbg.h
│   │   ├── kldbg_patterns.h
│   │   ├── ksymbols.h
│   │   ├── list.c
│   │   ├── list.h
│   │   ├── log
│   │   │   ├── log.c
│   │   │   └── log.h
│   │   ├── main.c
│   │   ├── msvcver.h
│   │   ├── objects.c
│   │   ├── objects.h
│   │   ├── plugmngr.c
│   │   ├── plugmngr.h
│   │   ├── props
│   │   │   ├── propAlpcPort.c
│   │   │   ├── propBasic.c
│   │   │   ├── propBasicConsts.h
│   │   │   ├── propCommon.h
│   │   │   ├── propDesktop.c
│   │   │   ├── propDlg.c
│   │   │   ├── propDlg.h
│   │   │   ├── propDriver.c
│   │   │   ├── propObjectDump.c
│   │   │   ├── propObjectDumpConsts.h
│   │   │   ├── propProcess.c
│   │   │   ├── propSection.c
│   │   │   ├── propSecurity.c
│   │   │   ├── propSecurityConsts.h
│   │   │   ├── propToken.c
│   │   │   ├── propType.c
│   │   │   ├── propTypeConsts.h
│   │   │   └── props.h
│   │   ├── resource.h
│   │   ├── rsrc
│   │   │   ├── 100.ico
│   │   │   ├── 101.ico
│   │   │   ├── 102.ico
│   │   │   ├── 103.ico
│   │   │   ├── 104.ico
│   │   │   ├── 105.ico
│   │   │   ├── 106.ico
│   │   │   ├── 107.ico
│   │   │   ├── 108.ico
│   │   │   ├── 109.ico
│   │   │   ├── 110.ico
│   │   │   ├── 111.ico
│   │   │   ├── 112.ico
│   │   │   ├── 113.ico
│   │   │   ├── 114.ico
│   │   │   ├── 115.ico
│   │   │   ├── 116.ico
│   │   │   ├── 117.ico
│   │   │   ├── 118.ico
│   │   │   ├── 119.ico
│   │   │   ├── 120.ico
│   │   │   ├── 121.ico
│   │   │   ├── 122.ico
│   │   │   ├── 123.ico
│   │   │   ├── 124.ico
│   │   │   ├── 125.ico
│   │   │   ├── 126.ico
│   │   │   ├── 127.ico
│   │   │   ├── 128.ico
│   │   │   ├── 129.ico
│   │   │   ├── 130.ico
│   │   │   ├── 131.ico
│   │   │   ├── 132.ico
│   │   │   ├── 133.ico
│   │   │   ├── 134.ico
│   │   │   ├── 135.ico
│   │   │   ├── 136.ico
│   │   │   ├── 137.ico
│   │   │   ├── 138.ico
│   │   │   ├── 139.ico
│   │   │   ├── 140.ico
│   │   │   ├── 141.ico
│   │   │   ├── 142.ico
│   │   │   ├── 143.ico
│   │   │   ├── 144.ico
│   │   │   ├── 145.ico
│   │   │   ├── 146.ico
│   │   │   ├── 147.ico
│   │   │   ├── 148.ico
│   │   │   ├── 149.ico
│   │   │   ├── 6001.ico
│   │   │   ├── 6002.ico
│   │   │   ├── Bitmap_125.bmp
│   │   │   ├── grid.ico
│   │   │   ├── ico50.ico
│   │   │   ├── mailslot.ico
│   │   │   ├── obex.manifest
│   │   │   ├── pipe.ico
│   │   │   └── security.ico
│   │   ├── sdviewDlg.c
│   │   ├── sup
│   │   │   ├── sup.c
│   │   │   ├── sup.h
│   │   │   ├── sync.c
│   │   │   ├── w32k.c
│   │   │   ├── w32k.h
│   │   │   ├── wine.c
│   │   │   └── wine.h
│   │   ├── symparser.c
│   │   ├── symparser.h
│   │   ├── sysinfoDlg.c
│   │   ├── tests
│   │   │   ├── ntsup_tests.c
│   │   │   ├── ntsup_tests.h
│   │   │   ├── testunit.c
│   │   │   └── testunit.h
│   │   ├── ui.h
│   │   └── utils
│   │       └── GenAsIo2Unlock.exe
│   ├── WinObjEx64.sln
│   ├── WinObjEx64_Plugins.sln
│   └── drvstore
│       └── kldbgdrv.sys
└── appveyor.yml

```

`Docs/WHATSNEW_170.md`:

```md

## What is new in 1.7

 - **W32pServiceTable viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/W32pServiceTableView.png" width="600" />
 
W32pServiceTable is a service table of Win32k - a Windows User and GDI subsystem driver. It is a secondary system service table (where first is a ntoskrnl managed KiServiceTable). This table can be saved to text file from popup menu.

This feature available starting from Windows 10 1607 (RS1 14393) and require running program as administrator. Additionally Windows must be booted in the Debug mode (only for kldbgdrv version).

 - **Process list**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ProcessList.png" width="600" />

Simple process list dialog. Display tree of running processes, their id, address of EPROCESS structure, user and domain name. Additionally this list uses highlighting similar to SysInternals Process Explorer. You can copy EPROCESS address value from popup menu. To view all process information program must run elevated.

 - **Callbacks viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/CallbacksView.png" width="600" />

List of system wide driver callbacks and notify routines registered with the following API:

1. ObRegisterCallbacks
2. CmRegisterCallbacks
3. CmRegisterCallbacksEx
4. PsSetCreateProcessNotifyRoutine
5. PsSetCreateProcessNotifyRoutineEx
6. PsSetCreateProcessNotifyRoutineEx2
7. PsSetCreateThreadNotifyRoutine
8. PsSetCreateThreadNotifyRoutineEx
9. PsSetLoadImageNotifyRoutine
10. PsSetLoadImageNotifyRoutineEx
11. KeRegisterBugCheckCallback
12. KeRegisterBugCheckReasonCallback
13. IoRegisterShutdownNotification
14. IoRegisterLastChanceShutdownNotification
15. SeRegisterLogonSessionTerminatedRoutine
16. SeRegisterLogonSessionTerminatedRoutineEx
17. PoRegisterPowerSettingCallback
18. DbgSetDebugPrintCallback
19. IoRegisterFsRegistrationChange
20. IoRegisterFileSystem



 - **Callback object type viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/CallbackObjectView.png" width="600" />

Viewer of registered callbacks for Callback object type. Drivers can create callbacks with ExCreateCallback API and register them with ExRegisterCallback.


 - **Improved OBJECT_TYPE view**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ObjectTypeView.png" width="600" />

Improved display of structured dump for OBJECT_TYPE and substructure OBJECT_TYPE_INITIALIZER by including newly added Windows 10 fields.


```

`Docs/WHATSNEW_173.md`:

```md

## What is new in 1.7.3

 - **Threads view for Process list dialog**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ProcessList.png" width="600" />
 
List of selected process threads. To view much of information administrative privilege and elevation required. Shows driver file for system threads.

 - **Process properties**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ViewingProcessProperties.png" width="600" />

Show basic information about selected process object, including applied mitigation policies (if present) and security. To view all process information program must run elevated.

 - **Thread properties**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ViewingThreadProperties.png" width="600" />

Show basic information about selected thread object, including object security. To view all thread information program must run elevated.


 - **Token properties**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ViewingTokenProperties.png" width="600" />

Show basic information about access token (for Process or Thread object if it impersonating a client).

 - **Other**
 
 Number of UI changes and improvements, including but not limited to bug fixes, and compatibility improvements for upcoming Windows 10 19H1 release.
 
```

`Docs/WHATSNEW_180.md`:

```md

## What is new in 1.8.0

 - **Plugins subsystem**

Subsystem that allows expand WinObjEx64 functionality without modifying main executable with maximum 20 plugins supported implemented as dlls.

 - **NDIS protocols viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/NdisProtocols.png" width="600" />

Show basic information about registered NDIS protocols. Implemented as Sonar plugin, to use it administrative privilege and Windows Debug mode required.

 - **ApiSet viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ApiSetView.png" width="600" />

ApiSet viewer implemented as plugin. Can view current system apiset or parse and display apiset from apiset dll. Supports V2 (Windows 7), V4 (Windows 8+), V6 (Windows 10) apisets.

 - **Other**
 
  Run as LocalSystem feature improved (issue #14), compatibility improvements for upcoming Windows 10 20H1 release.

```

`Docs/WHATSNEW_187.md`:

```md

## What is new in 1.8.7

 - **Plugins subsystem changes**

It has been upgraded to include context plugins and multi-instance support.

 - **ImageScope section object viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ImsSection.png" width="600" />

New WinObjEx64 context plugin. Display information about section object that is backed by an image file. Show version info fields, printable strings.

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ImsStrings.png" width="600" />


 - **Other**
   + Compatibility improvements for Windows 10 20H1/20H2/21H1 versions.
   + Added recongnizing of shimmed drivers in drivers list, this feature is only supported starting from Windows 10
   + Process trust label (if present) now also displayed for objects of section type
   + Added plugins viewer
   + Multiple other minor changes in program logic and UI
   + Fixed several bugs

```

`Docs/WHATSNEW_190.md`:

```md

## What is new in 1.9.0

 - **Unloaded drivers view**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/UnloadedDrivers.png" width="600" />

View contents of MmUnloadedDrivers ntoskrnl managed array.

 - **ALPC Ports connections**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/AlpcPortConnections.png" width="600" />

Display information about ALPC port connected clients, similar to WinDBG *!alpc /port* command.

 - **Section Object dump view**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ViewingSectionObject.png" width="600" />

View contents of Section object type and it child structures such as CONTROL_AREA, SEGMENT etc. Note that view is not complete and only list important fields, similar to WinDBG *!ca 0xX 4* command.

- **Updated ApiSetSchema plugin**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/ApiSetView190.png" width="600" />

Improved search and fixed some bugs.

 - **Other**
   + Added ExCreateCallback list to the callbacks list
   + Fixed several bugs

```

`Docs/WHATSNEW_200.md`:

```md

## What is new in 2.0.0

 - **CmControlVector viewer**

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/CmControlVector.png" width="600" />

View contents of CmControlVector ntoskrnl parameters array. Can display actual values of variables or dump them when driver support is enabled.

 - **Other**
   + Added entirely new handling of object names to support embedded nulls
   + Added Pico providers, Nmi, SiloMonitor and Errata manager callbacks
   + Added Copy Name/Copy Name (Binary) commands to the main window popup menus
   + Added program statistics (see Help->Statistics)
   + Added legend window description for process list
   + Added ability to fix image sections for dumped drivers
   + Added RegistryTransaction object view and access rights
   + Moved "Globals" from about box to the View->System Information and rearranged it output
   + Drivers dump operation can now be cancelled
   + Fix display of PUNICODE_STRING dump
   + Fix ALPC Port type objects sometimes unable to open while they can be opened
   + Plugin sdk updated to accommodate new named objects handling 
   + Imagescope plugin updated to accomodate plugin sdk changes
   + Elevation required features in "extras" will now request elevation instead of just been disabled
   + Help file updated with drivers and symbols usage
   + Internal rearrange and minor UI changes

```

`LICENSE.md`:

```md
Copyright (c) 2015 - 2025, WinObjEx64 Project, hfiref0x

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# WinObjEx64
[![Build status](https://img.shields.io/appveyor/build/hfiref0x/winobjex64?logo=appveyor)](https://ci.appveyor.com/project/hfiref0x/winobjex64)
![Visitors](https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fgithub.com%2Fhfiref0x%2FWinObjEx64&label=Visitors&countColor=%23263759&style=flat)

## Windows Object Explorer 64-bit

<img src="https://raw.githubusercontent.com/hfiref0x/WinObjEx64/master/Docs/Screenshots/MainWindow.png" width="600" />

WinObjEx64 is an advanced utility that lets you explore the Windows Object Manager namespace. For certain object types, you can double-click on it or use the "Properties..." toolbar button to get more information, such as description, attributes, resource usage etc. WinObjEx64 let you view and edit object-related security information if you have required access rights.

# System Requirements

WinObjEx64 does not require administrative privileges. However, administrative privileges are required to view much of the namespace and to edit object-related security information.

WinObjEx64 works only on the following x64 Windows: Windows 7, Windows 8, Windows 8.1, and Windows 10/11, including Server variants.


# Features

<details>
  <summary>View list</summary>

- **Explore all of Windows Object Manager namespace**  
	- Hierarchical objects tree  
	- Symbolic links resolving  
	- Version information for `Section`-type objects backed by an image file  
	- Additional information for `WindowStation`-type objects  
	- **View objects details**:  
		- Descriptions  
		- Flags  
		- Invalid attributes  
		- Memory pool type  
		- Object type-specific information  
		- Object-related structure memory dumps<sup>1</sup>:  
			- `ALPC_PORT`  
			- `CALLBACK_OBJECT`  
			- `DEVICE_OBJECT`  
			- `DRIVER_OBJECT`  
			- `DIRECTORY_OBJECT`  
			- `FLT_SERVER_PORT_OBJECT`  
			- `KEVENT`  
			- `KMUTANT`  
			- `KSEMAPHORE`  
			- `KTIMER`  
			- `KQUEUE` (IoCompletion)  
			- `OBJECT_SYMBOLIC_LINK`  
			- `OBJECT_TYPE`  
		- Opened handles  
		- Statistics  
		- Supported access rights  
		- Process Trust label  
		- And more...  

	- **Display in dump sub-structures**<sup>1</sup>:  
		- `ALPC_PORT_ATTRIBUTES`  
		- `DEVICE_MAP`  
		- `LDR_DATA_TABLE_ENTRY`  
		- `OBJECT_TYPE_INITIALIZER`  
		- `UNICODE_STRING`  
		- And many others  

	- Edit object-related security information<sup>2</sup>  
	- Detect driver object IRP modifications (via structure dump)<sup>1</sup>  
	- Detect kernel object hooking (via structure dump)<sup>1</sup>  
	- Search for objects by name and/or type  

- **System information viewer**  
	- Boot state and type  
	- Code Integrity options  
	- Mitigation flags  
	- Windows version and build  

- **Loaded drivers list viewer**  
	- Dump selected driver<sup>1</sup>  
	- Export driver list to CSV file  
	- Jump to driver file location  
	- Detect Kernel Shim Engine "shimmed" drivers<sup>1</sup>  
	- View driver file properties  

- **Mailslots/Named pipes viewer**  
	- List all registered mailslots/named pipes  
	- Edit named pipes security information<sup>4</sup>  
	- Object statistics  

- **Hierarchical process tree viewer**<sup>2</sup>  
	- Show process ID, user name, `EPROCESS` addresses  
	- Highlight processes by type (similar to Process Explorer)  
	- Show thread list for selected process  
	- Show `ETHREAD` addresses  
	- **Common properties for Process/Thread objects**:  
		- Basic properties (as other object types)  
		- Start time  
		- Process type  
		- Image file name  
		- Command line  
		- Current directory  
		- Applied mitigations  
		- Protection  
		- "Critical Process" flag state  
		- Security edit  
	- Jump to process file location  
	- **Process/Thread token information**:  
		- User name  
		- User SID  
		- AppContainer SID  
		- Session  
		- UIAccess  
		- Elevation state  
		- Integrity level  
		- Privileges and groups  
	- **Additional token properties**:  
		- Basic properties (as other object types)  
		- Security attributes list  
		- Security edit  

- **Software Licensing Cache viewer**  
	- List registered licenses  
	- Display license data  
	- Dump `SL_DATA_BINARY` license data to file  

- **User Shared Data viewer**  
	- Structured dump of key `KUSER_SHARED_DATA` sections  

- **System callbacks viewer**<sup>1</sup>  
	- Display callback addresses, modules, and details for:  
		- `PsSetCreateProcessNotifyRoutine`  
		- `PsSetCreateProcessNotifyRoutineEx`  
		- `PsSetCreateProcessNotifyRoutineEx2`  
		- `PsSetCreateThreadNotifyRoutine`  
		- `PsSetCreateThreadNotifyRoutineEx`  
		- `PsSetLoadImageNotifyRoutine`  
		- `PsSetLoadImageNotifyRoutineEx`  
		- `KeRegisterBugCheckCallback`  
		- `KeRegisterBugCheckReasonCallback`  
		- `CmRegisterCallback`  
		- `CmRegisterCallbackEx`  
		- `IoRegisterShutdownNotification`  
		- `IoRegisterLastChanceShutdownNotification`  
		- `PoRegisterPowerSettingCallback`  
		- `SeRegisterLogonSessionTerminatedRoutine`  
		- `SeRegisterLogonSessionTerminatedRoutineEx`  
		- `IoRegisterFsRegistrationChange`  
		- `IopFsListsCallbacks`  
		- `IoRegisterPlugPlayNotification`  
		- `ObRegisterCallbacks`  
		- `DbgSetDebugPrintCallback`  
		- `DbgkLkmdRegisterCallback`  
		- `PsRegisterAltSystemCallHandler`  
		- CodeIntegrity `SeCiCallbacks`  
		- `ExRegisterExtension`  
		- `PoRegisterCoalescingCallback`  
		- `PsRegisterPicoProvider`  
		- `KeRegisterNmiCallback`  
		- `PsRegisterSiloMonitor`  
		- `EmProviderRegister`  

- **Windows Object Manager private namespace viewer**<sup>1</sup>  
	- Namespace entry information  
	- Boundary descriptor details  
	- Common object properties  

- **KiServiceTable viewer**<sup>1</sup>  
	- Dump `Ntoskrnl`-managed `KiServiceTable` (SSDT)  
	- Jump to service entry module  
	- Export to CSV file  

- **W32pServiceTable viewer**<sup>1</sup>  
	- Dump `Win32k`-managed `W32pServiceTable` (Shadow SSDT)  
	- Win32k import forwarding support  
	- Win32k ApiSets resolving  
	- Jump to service entry module  
	- Export to CSV file  

- **CmControlVector viewer**  
	- Dump `Ntoskrnl` `CmControlVector` array  
	- Export kernel memory data to file<sup>1</sup>  
	- Export to CSV file  

- **Clipboard integration**: Copy object addresses/names to clipboard  

- **Wine/Wine-Staging support**<sup>3</sup>  

- **Plugins subsystem**  
	- **Included plugins**:  
		- **ApiSetView**: Windows ApiSetSchema viewer (supports loading schema from file)  
		- **Example plugin**: Developer template  
		- **Sonar**: NDIS protocols viewer (dumps protocol details)  
		- **ImageScope**: Enhanced `Section`-type object details (via context menu)  

- **Documentation**  
	- Windows Callbacks  
	- Plugins subsystem  

1. Requires driver support (see "Driver Support" section).  
2. Administrator privileges may be required.  
3. Windows internals features unavailable on Wine/Wine-Staging.  
4. Administrator privileges required for some named pipes.  

### Driver support

WinObjEx64 supports two types of driver helpers:  

1. **Helper for read-only access to kernel memory**:  
   - Default version uses the **Kernel Local Debugging Driver (KLDBGDRV)** from WinDbg.  
   - Requires:  
     - Windows booted in debug mode (`bcdedit -debug on`)  
     - WinObjEx64 running with administrator privileges  
   - **Custom helper driver versions** do **not** require Windows debug mode.  
   - Multiple third-party drivers can be used as helpers, though only the **WinDbg-type** driver is included by default.  

2. **Helper to access object handles**:  
   - WinObjEx64 (any variant) **supports** Process Explorer driver v1.5.2 for opening processes/threads.  
   - Enable by running **both** Process Explorer and WinObjEx64 with administrator privileges.  

**Note**: All driver helpers require WinObjEx64 to run with administrative privileges.  

</details>

# Build 

WinObjEx64 comes with full source code. To build from source, you need Microsoft Visual Studio 2015 or later.

## Instructions

* Select Platform ToolSet first for the project in the solution you want to build (Project->Properties->General): 
  * v140 for Visual Studio 2015; 
  * v141 for Visual Studio 2017;
  * v142 for Visual Studio 2019;
  * v143 for Visual Studio 2022.
* For v140 and above, set Target Platform Version (Project->Properties->General):
  * If v140, select 8.1;
  * If v141 and above, select 10.
* Minimum required Windows SDK version: 8.1
* Recommended Windows SDK version: 10.0.19041 and above
 
 
# What is new

[Whats New in 2.0.0](https://github.com/hfiref0x/WinObjEx64/blob/master/Docs/WHATSNEW_200.md)

[Complete changelog](https://github.com/hfiref0x/WinObjEx64/blob/master/Source/CHANGELOG.txt)


# Support Our Work
If you enjoy using this software and would like to help the authors maintain and improve it, please consider supporting us with a donation. Your contribution fuels development, ensures updates, and keeps the project alive.

### Cryptocurrency Donations:

BTC (Bitcoin): bc1qzkvtpa0053cagf35dqmpvv9k8hyrwl7krwdz84q39mcpy68y6tmqsju0g4

This is purely optional, thank you!~

# Authors


(c) 2015 – 2026 WinObjEx64 Project, hfiref0x

Original WinObjEx (c) 2003 – 2005 Four-F

```

`Source/CHANGELOG.txt`:

```txt
v2.1.0
win11 25H2 compatibility improvements
fixed incorrect object quota information dump
more descriptions for object types
internal rearrangement

v2.0.9
internal rearrangement
updated RTLs (ntos, ntsup, treelist)

v2.0.8
fixed various spelling errors throughout the codebase and documentation
plugins have been upgraded to the new interface version, improving compatibility and extensibility
fixed memory leaks in several plugins and addressed application-wide memory leaks
performed internal refactoring for object management, which should theoretically improve performance
optimized the process tree view, resulting in better performance for the process list dialog, especially with large process sets
improved Authenticode hash calculations, adding better padding logic and enhanced error handling
updated the object search dialog logic for better handling of large/big search queries
updated the MSVC compiler versions database for more accurate build/version reporting
updated RTLs (ntos, ntsup, ntldr, tabctrl, symparser) to their latest versions for improved stability and feature support
support Vista again (limited set of features), as per feature request #44

v2.0.7
win11 24h2 compatibility improvements

v2.0.6
win11 24h2/25h2 compatibility improvements
RTLs updated

v2.0.5
added Pnp manager callbacks
win11 22h2/23h2/24h2 compatibility improvements

v2.0.4
win11 23h2 compatibility
win11+ 24h2 compatibility improvements
fixed tooltip flickering for drivers list
fixed log UI highlight glitch
fixed Authenticode hash missing pad bytes (in some cases)
driver list tooltip now includes information if the given driver is registered as filter (admin priv. required)

v2.0.3
recent win11 compatibility improvements
win11 24h2 preliminary support

v2.0.2
recent win10/win11 compatibility improvements
display more details about shimmed drivers

v2.0.1
recent win10/win11 compatibility improvements
token properties dialog changes
added and updated some object type descriptions (from Windows Internals 7ed book)

v2.0.0
added entirely new handling of object names to support embedded nulls
added Pico providers, Nmi, SiloMonitor and Errata manager callbacks
added CmControlVector viewer
added Copy Name/Copy Name (Binary) commands to the main window popup menus
added program statistics (see Help->Statistics)
added legend window description for process list
added ability to fix image sections for dumped drivers
added RegistryTransaction object view and access rights
moved "Globals" from about box to the View->System Information and rearranged its output
drivers dump operation can now be cancelled
fixed display of PUNICODE_STRING dump
fixed ALPC Port type objects sometimes unable to open while they can be opened
plugin SDK updated to accommodate new named objects handling 
imagescope plugin updated to accommodate plugin SDK changes
elevation required features in "extras" will now request elevation instead of just being disabled
help file updated with drivers and symbols usage
internal rearrangement and minor UI changes

v1.9.3
updated SeCiCallbacks search for newest Windows versions
added Windows Server 2022 support
fixed win32k ApiSet resolving for Win10 21H2
fixed ObCallbacks enumeration issues
support for various kernel driver helpers
ported to msvc 2022 (with backward compatibility to 2019)
bugfixes
RTLs updated

v1.9.2
more Win10/11 21h2 compatibility changes
added FLT_FILTER, FLT_OBJECT structured dump
added Authenticode hash calculation for loaded drivers (extras->Drivers, use popup menu on driver entry)
added coalescing callbacks to callbacks list
various minor UI changes
fixed misbehavior with recent Wine staging 6.x
internal rearrangement
RTLs updated

v1.9.1
21h2 compatibility improvements
RTLs updated

v1.9.0
added Section object structured dump
added ALPC port connections list (similar to !alpc /lpc windbg command)
added MmUnloadedDrivers list
added ExCreateCallback list to the callbacks list (PR #26)
updated ApiSet plugin now supports in-place search filter
internal rearrangement

v1.8.8
internal rearrangement
view security for alpc ports (most of them)
security descriptor view dialog (object sid, dacl & sacl)
fixed SCM services list query
fixed "jump to file may fail under certain conditions" bug
various minor UI changes
21h1 compatibility improvements

v1.8.7
20h1/20h2/21h1 compatibility improvements
added recognizing of shimmed drivers for drivers list (win10+)
show process trust label for sections if it present
plugins system extended and upgraded to support context plugins
added imagescope plugin for section object types backed by imagefile
added plugins viewer
various minor changes
treelist: fixed tooltips flickering on Windows 7
turned off Spectre nonsense
RTLs updated

v1.8.6
reimplemented directory object dump to output more data
added callbacks registered with ExRegisterExtension
fixed for pipes (PR #17)
internal rearrangement
fixed high CPU usage for splitter drag (report/fix by RamMerlabs) 
fixed security dialog regression (reported by RamMerlabs) 

v1.8.5
fixed object cookie
added error log
20h1/20h2 compatibility improvements

v1.8.4
support of additional helper driver
fixed Windows 7 regressions

v1.8.3
internal rearrangement
ported to msvc 2019 (with backward compatibility to 2017)
fixed current directory value for elevated/system re-launch (reported by RamMerlabs)

v1.8.2
added Token object properties
added PsAltSystemCallHandlers to callbacks dialog
fixed High DPI issues
fixed Pipe security dialog not shown where available
fixed multiple Wine/Wine Staging misbehavior
corrected typo in DebugObject description
more 20H1 support changes
various minor changes

v1.8.1
19H2 support
Preliminary 20H1 support

v1.8.0
improved run as localsystem feature
added plugin subsystem
added example plugin
added Sonar plugin - NDIS protocols viewer
added ApiSetView plugin - ApiSetSchema viewer (supported v2, v4, v6)

v1.7.4
added software licensing cache view (extras)
resolve apisets while viewing shadow table in Windows 10 20H1 >= 18890 builds
fixed displaying sid user/domain information for private namespaces
added refresh (f5) for private namespace dialog

v1.7.3
threads list in processes dialog
view file properties for KisServiceTable/W32pServiceTable dialogs
process/thread/token object properties dialogs
bugfixes

v1.7.2
symbolic link object dump
internal fixes after profiling
support for 19H1 SeCiCallbacks scan
added and updated more object type descriptions

v1.7.1
SeCiCallbacks/g_CiCallbacks, DbgkLmdCallbacks added to the callbacks viewer
Session object view and access rights, merged pull request #8 #9
fixed regression added in 1.7.0
treelist updated

v1.7.0
code can now be compiled as C++
added W32pServiceTable view
added process list dialog (extras)
added Callback object type callbacks list (Properties->Object)
added callbacks viewer for certain callback types (registry, ps, ob, kebugcheck, se, dbg, po, io etc)
reimplemented "type" object type view (added missing fields from w10+)
reimplemented service tables extraction code

v1.6.0
ported to msvc 2017 (with backward compatibility to 2015)
reimplemented private namespaces lookup
object directory dump reflects Win10 changes
added alpc port dump and additional dialog
treelist control updated
private namespaces dialog updated
usershareddata dialog updated
internal rearrangement
merged pull request #7, fixed Job object process list display
multiple Wine Staging fixes
RTLs updated 

v1.5.5
tweaked PTL display

v1.5.4
added display of Process Trust Label for Directory object type

v1.5.3
OpenWindowStation fix

v1.5.2
internal rearrangement

v1.5.1
bugfixes

v1.5.0
added Partition, DxgkCurrentDxgProcessObject objects description
added mailslots viewer dialog
added file properties for drivers (menu -> extras -> Drivers)
added FltConnectionPort object dump
switched to hde instead of ldasm
fixed Wine behavior along with some bugs
RTLs updated, switched to VS2015 U3
note: Windows 10 RS2 (15063), RS1 (14393) supported as well as TH1(10240)/TH2(10586), RS3 supported (16288+ build)

v1.4.0
drivers list and dump (menu -> extras)
kiservicetable dump for all supported Windows versions
some code revision and corrections

v1.3.0
official support for Windows 10
private namespaces (menu -> extras)

v1.2.0
added KUSER_SHARED_DATA dump (menu -> extras)
code revision and corrections
ported to msvc 2015

v1.1.0
added popup menu for Process page 
added file properties dialog for Process page 
added descriptions for more object types 
added named pipes dialog (menu -> extras) 
added information for IoCompletion object type, including structured object body dump2 
some code revision and corrections 

v1.0.0 (Feb 23, 2015)
initial release

```

`Source/FILELIST.txt`:

```txt
* Driver providers interface *
winobjex64\drivers\wdrvprv.c
winobjex64\drivers\wdrvprv.h
** WINDBG/WODBG provider **
winobjex64\drivers\wdbgdrv.c
winobjex64\drivers\wdbgdrv.h
** WINIO provider **
winobjex64\drivers\winio.c
winobjex64\drivers\winio.h
** RKHDRV provider **
winobjex64\drivers\rkhdrv.c
winobjex64\drivers\rkhdrv.h
** HE/Alice provider **
winobjex64\drivers\alice.c
winobjex64\drivers\alice.h

* About dialog routines including window dialog procedure *
winobjex64\aboutDlg.c

* System information dialog routines including window dialog procedure *
winobjex64\sysinfoDlg.c

* Custom access violation exception handler including minidump *
winobjex64\excepth.c
winobjex64\excepth.h

* Extras menu handler *
winobjex64\extras\extras.c
winobjex64\extras\extras.h

* Windows 7/8/8.1 missing API support *
winobjex64\extapi.c
winobjex64\extapi.h

* Windows kernel callbacks list *
winobjex64\extas\extrasCallbacks.c
winobjex64\extras\extrasCallbacksPatterns.h

* Drivers list *
winobjex64\extras\extrasDrivers.c

* KiServiceTable/W32pServiceTable list *
winobjex64\extras\extrasSSDT.c

* Pipes and mailslots dialog *
winobjex64\extras\extrasIPC.c

* Windows Private Namespaces dialog *
winobjex64\extras\extrasPN.c

* Process list dialog *
winobjex64\extras\extrasPSList.c

* Software Licensing Cache dialog *
winobjex64\extras\extrasSL.c

* UserSharedData dialog *
winobjex64\extras\extrasUSD.c

* CmControlVector dialog *
winobjex64\extras\extrasCmOpt.c

* Find Object routines including window dialog procedure *
winobjex64\findDlg.c

* Authenticode hash support *
winobjex64\hash.c
winobjex64\hash.h

* Windows Kernel Debugging Driver support routines, object related internal API set *
winobjex64\kldbg.c
winobjex64\kldbg.h

* Signature patterns used to find undocumented stuff *
winobjex64\kldbg_pattern.h

* Header file for kernel symbol names *
winobjex64\ksymbols.h

* Treeview and listview handlers for main window *
winobjex64\list.c
winobjex64\list.h

* WinObjEx64 internal logviewer *
winonjex64\log\log.c
winonjex64\log\log.h

* Program entry point and initialization routines, main window dialog procedure handler *
winobjex64\main.c

* Set of reimplemented rtl routines *
winobjex64\minirtl\minirtl.c
winobjex64\minirtl\minirtl.h

* MS VisualC compiler versions header file *
winobjex64\msvcver.h

* Known objects support functions and global objects table *
winobjex64\objects.c
winobjex64\objects.h

* Plugin manager *
winobjex64\plugmngr.c
winobjex64\plugmngr.h

* Symbols support *
winobjex64\symparser.c
winobjex64\symparser.h

* Property sheet for ALPC Port information *
winobjex64\props\propAlpcPort.c

* Property sheet "Basic" handlers, including window procedures and consts *
winobjex64\props\propBasic.c
winobjex64\props\propBasicConsts.h

* Property sheet "Desktop" handlers *
winobjex64\props\propDesktop.c

* "Properties" property sheet creation and window procedures, all sheets created here *
winobjex64\props\propDlg.c
winobjex64\props\propDlg.h
winobjex64\props\propCommon.h
winobjex64\props\props.h

* Property sheet "Driver" handlers *
winobjex64\props\propDriver.c

* Dumping and decoding kernel objects for "Object" property sheet and constants*
winobjex64\props\propObjectDump.c 
winobjex64\props\propObjectDumpConsts.h

* Property sheet "Process" handler, window procedure *
winobjex64\props\propProcess.c

* Property sheet for Section object dump information *
winobjex64\props\propSection.c

* "Security" property sheet handler and ISecurityInformation implementation and constants *
winobjex64\props\propSecurity.c
winobjex64\props\propSecurityConsts.h

* Property sheet "Token" handler, window procedure *
winobjex64\props\propToken.c

* Property sheet "Type" handlers, including window procedure for "Procedures" sheet and constants*
winobjex64\props\propType.c
winobjex64\props\propTypeConsts.h

* "View Security Descriptor" dialog routines including window procedure *
winobjex64\sdviewDlg.c

* Support api set and consts *
winobjex64\sup\sup.c
winobjex64\sup\sup.h
winobjex64\sup\sync.c

* Win32k service table parsing support *
winobjex64\sup\w32k.c
winobjex64\sup\w32k.h

* Wine support header file *
winobjex64\sup\wine.c
winobjex64\sup\wine.h

* All objects test code here *
winobjex64\tests\testunit.c
winobjex64\tests\testunit.h

* systreeview32 combined with sysheader32 control *
shared\treelist\treelist.c
shared\treelist\treelist.h

* Global include file *
winobjex64\global.h

* NT os internals related definitions and prototypes *
shared\ntos\ntos.h

* MS ALPC port dedicated header file *
shared\ntos\ntalpc.h

* NT PE loader related declarations and routines *
shared\ntos\ntldr.c
shared\ntos\ntldr.h

* Native API shared rtl *
shared\ntos\ntsup.c
shared\ntos\ntsup.h

* MS ApiSetSchema dedicated header file *
shared\ntos\apisetx.h

* Windows SDK 8.1 missing definitions support *
shared\sdk\extdef.h

* Visual Studio generated resource header *
winobjex64\resource.h

* User interface global constant *
winobjex64\ui.h

```

`Source/Plugins/ApiSetView/ApiSetView.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{72BF2A8F-E7AE-467F-B00F-1C51F1C3D2C8}</ProjectGuid>
    <RootNamespace>ApiSetView</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <StringPooling>true</StringPooling>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <EnablePREfast>false</EnablePREfast>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <SetChecksum>true</SetChecksum>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>$(SolutionDir)Plugins\postbuild.cmd $(ProjectName) .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).dll .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).pdb</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\minirtl\hextou64.c" />
    <ClCompile Include="..\..\Shared\minirtl\ultostr.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcpy.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strend.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncmp.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncpy.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strstri.c" />
    <ClCompile Include="..\..\Shared\ntos\ntsup.c" />
    <ClCompile Include="..\..\Shared\treelist\treelist.c" />
    <ClCompile Include="..\utils.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="query.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\..\Shared\minirtl\rtltypes.h" />
    <ClInclude Include="..\..\Shared\ntos\apisetx.h" />
    <ClInclude Include="..\..\Shared\ntos\ntos.h" />
    <ClInclude Include="..\..\Shared\ntos\ntsup.h" />
    <ClInclude Include="..\..\Shared\treelist\treelist.h" />
    <ClInclude Include="..\plugin_def.h" />
    <ClInclude Include="..\utils.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="query.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="ui.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Plugins/ApiSetView/ApiSetView.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{d8ef8d3d-fe7d-4908-93bf-5279accdabfe}</UniqueIdentifier>
    </Filter>
    <Filter Include="treelist">
      <UniqueIdentifier>{83c6e752-f5b5-48a7-8e6f-231cba8a450d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ntos">
      <UniqueIdentifier>{315785cb-45b6-49b7-ad7e-eb6925ca5197}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="query.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\ultostr.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strstri.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\treelist\treelist.c">
      <Filter>treelist</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\ntos\ntsup.c">
      <Filter>ntos</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\hextou64.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\plugin_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="query.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\treelist\treelist.h">
      <Filter>treelist</Filter>
    </ClInclude>
    <ClInclude Include="..\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\apisetx.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntos.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntsup.h">
      <Filter>ntos</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Source/Plugins/ApiSetView/ApiSetView.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/Plugins/ApiSetView/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,2510
 PRODUCTVERSION 1,2,0,2510
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "WinObjEx64 Plugin V1.2"
            VALUE "FileVersion", "1.2.0.2510"
            VALUE "InternalName", "ApiSetView"
            VALUE "LegalCopyright", "Copyright (C) 2019 - 2025"
            VALUE "OriginalFilename", "ApiSetView.dll"
            VALUE "ProductName", "ApiSetView Plugin for WinObjEx64"
            VALUE "ProductVersion", "1.2.0.2510"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ASDIALOG DIALOGEX 0, 0, 495, 353
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "ApiSetSchema Viewer"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Selected Entry",IDC_STATIC,7,304,202,40
    GROUPBOX        "Search By Name (case insensitive)",IDC_STATIC,218,303,270,40
    EDITTEXT        IDC_ENTRY_EDIT,14,319,187,14,ES_AUTOHSCROLL | ES_READONLY
    EDITTEXT        IDC_SEARCH_EDIT,225,319,256,14,ES_AUTOHSCROLL
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ASDIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 488
        TOPMARGIN, 7
        BOTTOMMARGIN, 346
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/Plugins/ApiSetView/export.def`:

```def
EXPORTS
PluginInit

```

`Source/Plugins/ApiSetView/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Common header file for the Windows Object Explorer ApiSetView plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Strict UNICODE
//
#if !defined UNICODE
#error ANSI build is not supported
#endif

#define OEMRESOURCE
#include <Windows.h>
#include <windowsx.h>
#include <strsafe.h>
#include <commctrl.h>
#include <commdlg.h>
#include <Uxtheme.h>

#pragma warning(push)
#pragma warning(disable: 4005)
#include <ntstatus.h>
#pragma warning(pop)

#pragma warning(disable: 6258) // TerminateThread
#pragma warning(disable: 6320) // Exception-filter expression is the constant EXCEPTION_EXECUTE_HANDLER
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'


#include "ntos/ntos.h"
#include "ntos/apisetx.h"
#include "treelist/treelist.h"
#include "minirtl/minirtl.h"
#include "plugin_def.h"
#include "resource.h"
#include "ui.h"
#include "query.h"

//
// Declared in main.c
//
extern GUI_CONTEXT g_ctx;

#include "utils.h"

```

`Source/Plugins/ApiSetView/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 ApiSetView plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define APISETVIEW_PLUGIN_MAJOR_VERSION 1
#define APISETVIEW_PLUGIN_MINOR_VERSION 2

//
// Plugin entry.
//
WINOBJEX_PLUGIN* g_plugin = NULL;

HINSTANCE g_thisDll = NULL;
GUI_CONTEXT g_ctx;

volatile DWORD g_pluginState = PLUGIN_RUNNING;

/*
* ClipboardCopy
*
* Purpose:
*
* Copy text to the clipboard.
*
*/
VOID ClipboardCopy(
    _In_ LPWSTR lpText,
    _In_ SIZE_T cbText
)
{
    LPWSTR  lptstrCopy;
    HGLOBAL hglbCopy = NULL;
    SIZE_T  dwSize;
    BOOL    dataSet = FALSE;

    if (!OpenClipboard(NULL))
        return;

    __try {
        EmptyClipboard();
        dwSize = cbText + sizeof(UNICODE_NULL);
        hglbCopy = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize);
        if (hglbCopy == NULL)
            __leave;

        lptstrCopy = (LPWSTR)GlobalLock(hglbCopy);
        if (lptstrCopy == NULL)
            __leave;

        RtlCopyMemory(lptstrCopy, lpText, cbText);
        GlobalUnlock(hglbCopy);

        dataSet = SetClipboardData(CF_UNICODETEXT, hglbCopy) != NULL;
        if (dataSet) {
            hglbCopy = NULL;
        }
    }
    __finally {
        CloseClipboard();
        if (hglbCopy != NULL) {
            GlobalFree(hglbCopy);
        }
    }
}

/*
* TreeListCopyItemValueToClipboard
*
* Purpose:
*
* Copy selected treelist item text to the clipboard.
*
*/
BOOL TreeListCopyItemValueToClipboard(
    _In_ HWND hwndTreeList,
    _In_ INT tlSubItemHit
)
{
    INT         nIndex;
    LPWSTR      lpCopyData = NULL;
    SIZE_T      cbCopyData = 0;
    TVITEMEX    itemex;
    WCHAR       szText[MAX_PATH + 1];

    TL_SUBITEMS_FIXED* pSubItems = NULL;

    szText[0] = 0;
    RtlSecureZeroMemory(&itemex, sizeof(itemex));
    itemex.mask = TVIF_TEXT;
    itemex.hItem = TreeList_GetSelection(hwndTreeList);
    itemex.pszText = szText;
    itemex.cchTextMax = MAX_PATH;

    if (TreeList_GetTreeItem(hwndTreeList, &itemex, &pSubItems)) {

        if ((tlSubItemHit > 0) && (pSubItems != NULL)) {

            nIndex = (tlSubItemHit - 1);
            if (nIndex < (INT)pSubItems->Count) {
                lpCopyData = pSubItems->Text[nIndex];
                if (lpCopyData) {
                    cbCopyData = (1 + _strlen(lpCopyData)) * sizeof(WCHAR);
                }
            }

        }
        else {
            if (tlSubItemHit == 0) {
                lpCopyData = szText;
                cbCopyData = (1 + _strlen(lpCopyData)) * sizeof(WCHAR);
            }
        }

        if (lpCopyData && cbCopyData) {
            ClipboardCopy(lpCopyData, cbCopyData);
            return TRUE;
        }
        else {
            if (OpenClipboard(NULL)) {
                EmptyClipboard();
                CloseClipboard();
            }
        }
    }

    return FALSE;
}


/*
* TreeListAddCopyValueItem
*
* Purpose:
*
* Add copy to clipboard menu item depending on hit treelist header item.
*
*/
BOOL TreeListAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndTreeList,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ LPARAM lParam,
    _In_ INT* pSubItemHit
)
{
    HDHITTESTINFO hti;
    HD_ITEM hdItem;
    WCHAR szHeaderText[MAX_PATH + 1];
    WCHAR szItem[MAX_PATH * 2];

    *pSubItemHit = -1;

    hti.iItem = -1;
    hti.pt.x = LOWORD(lParam);
    hti.pt.y = HIWORD(lParam);
    ScreenToClient(hwndTreeList, &hti.pt);

    hti.pt.y = 1;
    if (TreeList_HeaderHittest(hwndTreeList, &hti) < 0)
        return FALSE;

    RtlSecureZeroMemory(&hdItem, sizeof(hdItem));

    szHeaderText[0] = 0;
    hdItem.mask = HDI_TEXT;

    hdItem.cchTextMax = RTL_NUMBER_OF(szHeaderText) - 1;

    hdItem.pszText = szHeaderText;
    if (TreeList_GetHeaderItem(hwndTreeList, hti.iItem, &hdItem)) {
        *pSubItemHit = hti.iItem;
        StringCchPrintf(szItem, RTL_NUMBER_OF(szItem), TEXT("Copy \"%ws\""), szHeaderText);
        if (InsertMenu(hMenu, uPos, MF_BYCOMMAND, uId, szItem)) {
            return TRUE;
        }
    }

    return FALSE;
}

/*
* ContextMenuHandler
*
* Purpose:
*
* Main list context menu handler.
*
*/
VOID ContextMenuHandler(
    _In_ HWND hwndDlg,
    _In_ HWND hwndTreeList,
    _In_ LPARAM lParam,
    _Inout_ INT* pSubItemHit
)
{
    POINT pt1;
    HMENU hMenu;
    INT uPos = 0;

    if (GetCursorPos(&pt1) == FALSE)
        return;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (TreeListAddCopyValueItem(hMenu,
            hwndTreeList,
            ID_OBJECT_COPY,
            uPos++,
            lParam,
            pSubItemHit))
        {
            InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }
        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, IDC_BROWSE_BUTTON, TEXT("Select Schema File"));
        InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_USE_SYSTEM_SCHEMA_FILE, TEXT("Use System Schema"));
        TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, pt1.x, pt1.y, 0, hwndDlg, NULL);
        DestroyMenu(hMenu);
    }

}

/*
* OpenDialogExecute
*
* Purpose:
*
* Display OpenDialog
*
*/
BOOL OpenDialogExecute(
    _In_ HWND OwnerWindow,
    _Inout_ LPWSTR OpenFileName,
    _In_ LPWSTR lpDialogFilter
)
{
    OPENFILENAME tag1;

    RtlSecureZeroMemory(&tag1, sizeof(OPENFILENAME));

    tag1.lStructSize = sizeof(OPENFILENAME);
    tag1.hwndOwner = OwnerWindow;
    tag1.lpstrFilter = lpDialogFilter;
    tag1.lpstrFile = OpenFileName;
    tag1.nMaxFile = MAX_PATH;
    tag1.lpstrInitialDir = NULL;
    tag1.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    return GetOpenFileName(&tag1);
}

/*
* PluginHandleWMNotify
*
* Purpose:
*
* Main window WM_NOTIFY handler.
*
*/
VOID PluginHandleWMNotify(
    _In_ HWND   hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    TL_SUBITEMS_FIXED* subitems;
    LPNMHDR hdr = (LPNMHDR)lParam;

    UNREFERENCED_PARAMETER(wParam);

    HWND TreeList = (HWND)TreeList_GetTreeControlWindow(g_ctx.TreeList);

    TVITEMEX tvi;
    WCHAR szBuffer[MAX_PATH + 1];

    if (hdr->hwndFrom == TreeList) {
        switch (hdr->code) {
        case TVN_ITEMEXPANDED:
        case TVN_SELCHANGED:
            RtlSecureZeroMemory(&tvi, sizeof(tvi));
            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

            tvi.mask = TVIF_TEXT;
            tvi.pszText = szBuffer;
            tvi.hItem = TreeList_GetSelection(g_ctx.TreeList);
            tvi.cchTextMax = MAX_PATH;
            if (TreeList_GetTreeItem(g_ctx.TreeList, &tvi, &subitems)) {
                SendDlgItemMessage(
                    hwndDlg,
                    IDC_ENTRY_EDIT,
                    WM_SETTEXT,
                    (WPARAM)0,
                    (LPARAM)&szBuffer);
            }

            break;
        default:
            break;
        }
    }
}

/*
* CenterWindow
*
* Purpose:
*
* Centers given window relative to desktop window.
*
*/
VOID CenterWindow(
    _In_ HWND hwnd
)
{
    RECT rc, rcDlg, rcOwner;
    HWND hwndParent = GetDesktopWindow();

    if (hwndParent) {
        GetWindowRect(hwndParent, &rcOwner);
        GetWindowRect(hwnd, &rcDlg);
        CopyRect(&rc, &rcOwner);
        OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
        OffsetRect(&rc, -rc.left, -rc.top);
        OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

        //
        // Center window
        //
        SetWindowPos(hwnd,
            HWND_TOP,
            rcOwner.left + (rc.right / 2),
            rcOwner.top + (rc.bottom / 2),
            0, 0,
            SWP_NOSIZE);
    }
}

/*
* InitTreeList
*
* Purpose:
*
* Intialize TreeList control.
*
*/
BOOL InitTreeList(
    _In_ HWND hwndParent,
    _Out_ HWND* pTreeListHwnd
)
{
    HWND treeList;
    HDITEM hdrItem;
    RECT rc;

    UINT uDpi;
    INT dpiScaledX, dpiScaledY, scaledWidth, scaledHeight, scaleSubX, scaleSubY;

    if (pTreeListHwnd == NULL) {
        return FALSE;
    }

    uDpi = g_ctx.ParamBlock.CurrentDPI;
    dpiScaledX = MulDiv(10, uDpi, DefaultSystemDpi);
    dpiScaledY = dpiScaledX;

    GetWindowRect(hwndParent, &rc);

    scaleSubX = MulDiv(24, uDpi, DefaultSystemDpi);
    scaleSubY = MulDiv(140, uDpi, DefaultSystemDpi);
    scaledWidth = (rc.right - rc.left) - dpiScaledX - scaleSubX;
    scaledHeight = (rc.bottom - rc.top) - dpiScaledY - scaleSubY;

    treeList = CreateWindowEx(WS_EX_CLIENTEDGE, WC_TREELIST, NULL,
        WS_VISIBLE | WS_CHILD | WS_TABSTOP | TLSTYLE_COLAUTOEXPAND | TLSTYLE_LINKLINES,
        dpiScaledX, dpiScaledY,
        scaledWidth, scaledHeight, hwndParent, NULL, NULL, NULL);

    if (treeList == NULL) {
        *pTreeListHwnd = NULL;
        return FALSE;
    }

    *pTreeListHwnd = treeList;

    RtlSecureZeroMemory(&hdrItem, sizeof(hdrItem));
    hdrItem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
    hdrItem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;

    hdrItem.cxy = 340;
    hdrItem.pszText = TEXT("Namespace");
    TreeList_InsertHeaderItem(treeList, 0, &hdrItem);

    hdrItem.cxy = 130;
    hdrItem.pszText = TEXT("Flags");
    TreeList_InsertHeaderItem(treeList, 1, &hdrItem);

    hdrItem.cxy = 200;
    hdrItem.pszText = TEXT("Alias");
    TreeList_InsertHeaderItem(treeList, 2, &hdrItem);

    return TRUE;
}

/*
* PluginDialogProc
*
* Purpose:
*
* Main plugin window procedure.
*
*/
INT_PTR CALLBACK PluginDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    HANDLE hIcon;
    HTREEITEM hRoot;
    LPWSTR lpFilter = NULL;
    WCHAR szFileName[MAX_PATH + 1];
    WCHAR szFilterOption[MAX_PATH + 1];

    switch (uMsg) {

    case WM_INITDIALOG:

        g_ctx.MainWindow = hwndDlg;
        g_ctx.SearchEdit = GetDlgItem(hwndDlg, IDC_SEARCH_EDIT);
        g_ctx.tlSubItemHit = -1;

        hIcon = LoadImage(
            g_ctx.ParamBlock.Instance,
            MAKEINTRESOURCE(WINOBJEX64_ICON_MAIN),
            IMAGE_ICON,
            32, 32,
            0);

        if (hIcon) {
            SendMessage(hwndDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);
            SendMessage(hwndDlg, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)hIcon);
            g_ctx.WindowIcon = hIcon;

        }

        if (InitTreeList(hwndDlg, &g_ctx.TreeList)) {
            ListApiSetFromFile(NULL, NULL);
        }
        else {
            MessageBox(g_ctx.MainWindow,
                TEXT("ApiSetView: Could not initialize treelist window"),
                NULL,
                MB_ICONERROR);
        }

        break;

    case WM_CLOSE:
        InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);
        PostQuitMessage(0);
        break;

    case WM_SHOWWINDOW:
        if (wParam) {
            CenterWindow(hwndDlg);
            SendDlgItemMessage(hwndDlg, IDC_SEARCH_EDIT, EM_LIMITTEXT, MAX_PATH, 0);
            hRoot = TreeList_GetRoot(g_ctx.TreeList);
            TreeList_EnsureVisible(g_ctx.TreeList, hRoot);
            SetFocus(g_ctx.TreeList);
        }
        break;

    case WM_CONTEXTMENU:

        ContextMenuHandler(hwndDlg,
            g_ctx.TreeList,
            lParam,
            &g_ctx.tlSubItemHit);

        break;

    case WM_NOTIFY:
        PluginHandleWMNotify(
            hwndDlg,
            wParam,
            lParam);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_SEARCH_EDIT:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                RtlSecureZeroMemory(szFilterOption, sizeof(szFilterOption));
                if (GetWindowText(
                    g_ctx.SearchEdit,
                    szFilterOption,
                    MAX_PATH))
                {
                    if (szFilterOption[0] != 0) {
                        lpFilter = szFilterOption;
                    }
                }

                ListApiSetFromFile(g_ctx.SchemaFileName, lpFilter);

            }
            break;

        case ID_USE_SYSTEM_SCHEMA_FILE:
            ListApiSetFromFile(NULL, NULL);
            break;

        case IDC_BROWSE_BUTTON:

            RtlSecureZeroMemory(szFileName, sizeof(szFileName));
            if (OpenDialogExecute(hwndDlg,
                szFileName,
                TEXT("All files\0*.*\0\0")))
            {
                SetWindowText(g_ctx.SearchEdit, TEXT(""));
                _strcpy(g_ctx.SchemaFileName, szFileName);
                ListApiSetFromFile(g_ctx.SchemaFileName, NULL);
            }
            break;

        case IDOK:
        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            return TRUE;

        case ID_OBJECT_COPY:

            TreeListCopyItemValueToClipboard(g_ctx.TreeList,
                g_ctx.tlSubItemHit);

            break;
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* PluginFreeGlobalResources
*
* Purpose:
*
* Plugin resources deallocation routine.
*
*/
VOID PluginFreeGlobalResources()
{
    if (g_ctx.WindowIcon)
        DestroyIcon(g_ctx.WindowIcon);

    if (g_ctx.PluginHeap) {
        HeapDestroy(g_ctx.PluginHeap);
        g_ctx.PluginHeap = NULL;
    }

    if (g_plugin && g_plugin->StateChangeCallback)
        g_plugin->StateChangeCallback(g_plugin, PluginStopped, NULL);
}

/*
* PluginThread
*
* Purpose:
*
* Plugin payload thread.
*
*/
DWORD WINAPI PluginThread(
    _In_ PVOID Parameter
)
{
    UNREFERENCED_PARAMETER(Parameter);

    INITCOMMONCONTROLSEX icex;

    BOOL rv;
    MSG msg1;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES;
    InitCommonControlsEx(&icex);

    CreateDialogParam(g_thisDll,
        MAKEINTRESOURCE(IDD_ASDIALOG),
        NULL,
        PluginDialogProc,
        0);

    do {
        rv = GetMessage(&msg1, NULL, 0, 0);

        if (rv == -1)
            break;

        TranslateMessage(&msg1);
        DispatchMessage(&msg1);

    } while (rv != 0 && InterlockedCompareExchange((PLONG)&g_pluginState, 0, 0) == PLUGIN_RUNNING);

    PluginFreeGlobalResources();

    ExitThread(0);
}

/*
* StartPlugin
*
* Purpose:
*
* Run actual plugin code in dedicated thread.
*
* Parameters:
*   ParamBlock - Plugin parameters passed from WinObjEx64
*
* Return:
*   STATUS_SUCCESS - Plugin started successfully
*   STATUS_UNSUCCESSFUL - Failed to start plugin
*/
NTSTATUS CALLBACK StartPlugin(
    _In_ PWINOBJEX_PARAM_BLOCK ParamBlock
)
{
    DWORD threadId;
    NTSTATUS status;
    WINOBJEX_PLUGIN_STATE state = PluginInitialization;

    InterlockedExchange((PLONG)&g_pluginState, PLUGIN_RUNNING);

    RtlSecureZeroMemory(&g_ctx, sizeof(g_ctx));

    g_ctx.PluginHeap = HeapCreate(0, 0, 0);
    if (g_ctx.PluginHeap) {

        HeapSetInformation(g_ctx.PluginHeap, HeapEnableTerminationOnCorruption, NULL, 0);

        RtlCopyMemory(&g_ctx.ParamBlock, ParamBlock, sizeof(WINOBJEX_PARAM_BLOCK));

        g_ctx.WorkerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PluginThread, (PVOID)NULL, 0, &threadId);
        if (g_ctx.WorkerThread) {
            status = STATUS_SUCCESS;
            state = PluginRunning;
        }
        else {
            status = STATUS_UNSUCCESSFUL;
            state = PluginError;
            HeapDestroy(g_ctx.PluginHeap);
            g_ctx.PluginHeap = NULL;
        }

        if (g_plugin && g_plugin->StateChangeCallback)
            g_plugin->StateChangeCallback(g_plugin, state, NULL);

    }
    else {
        status = STATUS_MEMORY_NOT_ALLOCATED;
    }

    return status;
}

/*
* StopPlugin
*
* Purpose:
*
* Stop plugin execution and cleanup resources.
*
*/
void CALLBACK StopPlugin(
    VOID
)
{
    if (g_ctx.WorkerThread) {
        InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);//force stop
        if (WaitForSingleObject(g_ctx.WorkerThread, 1000) == WAIT_TIMEOUT) {
            TerminateThread(g_ctx.WorkerThread, 0);
        }
        CloseHandle(g_ctx.WorkerThread);
        g_ctx.WorkerThread = NULL;

        if (g_plugin && g_plugin->StateChangeCallback)
            g_plugin->StateChangeCallback(g_plugin, PluginStopped, NULL);
    }
}

/*
* PluginInit
*
* Purpose:
*
* Initialize plugin information for WinObjEx64.
*
*/
BOOLEAN CALLBACK PluginInit(
    _Inout_ PWINOBJEX_PLUGIN PluginData
)
{
    // Don't initialize twice
    if (g_plugin) {
        return FALSE;
    }

    __try {

        if (PluginData == NULL) {
            return FALSE;
        }

        if (PluginData->cbSize < sizeof(WINOBJEX_PLUGIN)) {
            return FALSE;
        }

        if (PluginData->AbiVersion != WINOBJEX_PLUGIN_ABI_VERSION) {
            return FALSE;
        }

        //
        // Set plugin name to be displayed in WinObjEx64 UI.
        //
        StringCbCopy(PluginData->Name, sizeof(PluginData->Name), TEXT("ApiSetSchema Viewer"));

        //
        // Set authors.
        //
        StringCbCopy(PluginData->Authors, sizeof(PluginData->Authors), TEXT("UG North"));

        //
        // Set plugin description.
        //
        StringCbCopy(PluginData->Description, sizeof(PluginData->Description),
            TEXT("A simple viewer for ApiSet schema."));

        //
        // Set required plugin system version.
        //
        PluginData->RequiredPluginSystemVersion = WOBJ_PLUGIN_SYSTEM_VERSION;

        //
        // Setup start/stop plugin callbacks.
        //
        PluginData->StartPlugin = (pfnStartPlugin)&StartPlugin;
        PluginData->StopPlugin = (pfnStopPlugin)&StopPlugin;

        //
        // Setup permissions.
        //
        PluginData->Capabilities.u1.NeedAdmin = FALSE;
        PluginData->Capabilities.u1.SupportWine = FALSE;
        PluginData->Capabilities.u1.NeedDriver = FALSE;

        PluginData->MajorVersion = APISETVIEW_PLUGIN_MAJOR_VERSION;
        PluginData->MinorVersion = APISETVIEW_PLUGIN_MINOR_VERSION;

        //
        // Set plugin type.
        //
        PluginData->Type = DefaultPlugin;

        g_plugin = PluginData;

        return TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint("PluginInit exception thrown %lx\r\n", GetExceptionCode());
        return FALSE;
    }
}

/*
* DllMain
*
* Purpose:
*
* DLL entry point.
*
* Parameters:
*   hinstDLL - DLL instance handle
*   fdwReason - Reason for calling function
*   lpvReserved - Reserved
*
* Return:
*   TRUE - Always
*/
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD     fdwReason,
    _In_ LPVOID    lpvReserved
)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_thisDll = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
    }
    return TRUE;
}

```

`Source/Plugins/ApiSetView/query.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       QUERY.C
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Query and output ApiSet specific data.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

typedef VOID(CALLBACK* pfnApiSetQueryMap)(
    _In_ PVOID ApiSetMap,
    _In_ HTREEITEM RootItem,
    _In_opt_ LPCWSTR FilterByName,
    _In_ SIZE_T ApiSetSize);

#define APISET_QUERY_ROUTINE(n) VOID n(   \
    _In_ PVOID ApiSetMap,                 \
    _In_ HTREEITEM RootItem,              \
    _In_opt_ LPCWSTR FilterByName,        \
    _In_ SIZE_T ApiSetSize)

VALUE_DESC g_apiSetEntryFlags[] = {
    { API_SET_SCHEMA_ENTRY_FLAGS_SEALED, L"Sealed" },
    { API_SET_SCHEMA_ENTRY_FLAGS_EXTENSION, L"Extension" }
};

/*
* DisplayErrorText
*
* Purpose:
*
* In debug build send string to debugger else show message box.
*
*/
VOID DisplayErrorText(
    _In_ LPWSTR ErrorMsg)
{
#ifdef _DEBUG
    OutputDebugString(ErrorMsg);
#else
    MessageBox(g_ctx.MainWindow, ErrorMsg, NULL, MB_ICONERROR);
#endif
}

/*
* IsRangeValid
*
* Purpose:
*
* Validate that Offset..Offset+Length lies within 0..BaseSize.
*
*/
BOOLEAN IsRangeValid(
    _In_ SIZE_T BaseSize,
    _In_ ULONG Offset,
    _In_ ULONG Length
)
{
    SIZE_T start = (SIZE_T)Offset;
    SIZE_T len = (SIZE_T)Length;
    SIZE_T end;

    if (start > BaseSize) return FALSE;
    end = start + len;
    if (end > BaseSize) return FALSE;
    return TRUE;
}

/*
* GetApiSetEntryName
*
* Purpose:
*
* Return apiset entry name, use HeapFree to release allocated memory.
*
*/
LPWSTR GetApiSetEntryName(
    _In_ PBYTE Namespace,
    _In_ SIZE_T NamespaceSize,
    _In_ ULONG NameOffset,
    _In_ ULONG NameLength
)
{
    PWSTR lpEntryName;

    if (NameLength == 0)
        return NULL;

    if ((NameLength % sizeof(WCHAR)) != 0)
        return NULL;

    if (!IsRangeValid(NamespaceSize, NameOffset, NameLength))
        return NULL;

    {
        SIZE_T cch = NameLength / sizeof(WCHAR);
        lpEntryName = HeapAlloc(
            g_ctx.PluginHeap,
            HEAP_ZERO_MEMORY,
            (cch + 1) * sizeof(WCHAR));

        if (lpEntryName) {

            RtlCopyMemory(
                lpEntryName,
                RtlOffsetToPointer(Namespace, NameOffset),
                NameLength);

            lpEntryName[cch] = 0;
        }
    }

    return lpEntryName;
}

/*
* OutNamespaceEntry
*
* Purpose:
*
* Namespace entry formatted output routine.
*
*/
HTREEITEM OutNamespaceEntry(
    _In_ HTREEITEM RootItem,
    _In_ LPWSTR EntryName,
    _In_ ULONG Flags
)
{
    ULONG i, flagsValue;
    LPTSTR lpText = NULL;
    HTREEITEM h_tviRootItem;

    TL_SUBITEMS_FIXED tlSubItems;

    WCHAR szBuffer[20];

    RtlZeroMemory(&tlSubItems, sizeof(tlSubItems));

    flagsValue = Flags;

    //
    // Output first flag from combination.
    //
    if (flagsValue) {
        for (i = 0; i < RTL_NUMBER_OF(g_apiSetEntryFlags); i++) {
            if (flagsValue & g_apiSetEntryFlags[i].Value) {
                lpText = (LPTSTR)g_apiSetEntryFlags[i].Desc;
                flagsValue &= ~g_apiSetEntryFlags[i].Value;
                break;
            }
        }

        //
        // Unrecognized flags combination.
        //
        if (lpText == NULL) {
            szBuffer[0] = 0;
            ultostr(flagsValue, szBuffer);
            lpText = szBuffer;
            flagsValue = 0;
        }

    }

    if (lpText == NULL) lpText = T_EmptyString;

    tlSubItems.Text[0] = lpText;
    tlSubItems.Text[1] = T_EmptyString;
    tlSubItems.Count = 2;

    h_tviRootItem = supTreeListAddItem(
        g_ctx.TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        EntryName,
        &tlSubItems);

    //
    // List rest of the flags.
    //
    if (h_tviRootItem && flagsValue) {
        for (i = 0; i < RTL_NUMBER_OF(g_apiSetEntryFlags); i++) {
            if (flagsValue & g_apiSetEntryFlags[i].Value) {

                flagsValue &= ~g_apiSetEntryFlags[i].Value;
                tlSubItems.Text[0] = (LPTSTR)g_apiSetEntryFlags[i].Desc;
                tlSubItems.Text[1] = T_EmptyString;
                tlSubItems.Count = 2;

                supTreeListAddItem(
                    g_ctx.TreeList,
                    h_tviRootItem,
                    TVIF_TEXT | TVIF_STATE,
                    (UINT)0,
                    (UINT)0,
                    T_EmptyString,
                    &tlSubItems);

            }
        }

        //
        // Unrecognized flags.
        //
        if (flagsValue) {

            szBuffer[0] = 0;
            ultostr(flagsValue, szBuffer);
            tlSubItems.Text[0] = szBuffer;
            tlSubItems.Text[1] = T_EmptyString;
            tlSubItems.Count = 2;
            supTreeListAddItem(
                g_ctx.TreeList,
                h_tviRootItem,
                TVIF_TEXT | TVIF_STATE,
                (UINT)0,
                (UINT)0,
                T_EmptyString,
                &tlSubItems);

        }
    }

    return h_tviRootItem;
}

/*
* OutNamespaceValue
*
* Purpose:
*
* Add entry to treelist with namespace value information.
*
*/
void OutNamespaceValue(
    _In_ HTREEITEM RootItem,
    _In_ PBYTE Namespace,
    _In_ SIZE_T NamespaceSize,
    _In_ ULONG ValueOffset,
    _In_ ULONG ValueLength,
    _In_ ULONG NameOffset,
    _In_ ULONG NameLength,
    _In_ ULONG Flags
)
{
    TL_SUBITEMS_FIXED tlSubItems;
    LPWSTR lpValueName = NULL, lpAliasName = NULL;
    WCHAR szBuffer[20];

    //
    // Get value name.
    //
    lpValueName = GetApiSetEntryName(
        Namespace,
        NamespaceSize,
        ValueOffset,
        ValueLength);

    //
    // Get value alias if present.
    //
    lpAliasName = GetApiSetEntryName(Namespace,
        NamespaceSize,
        NameOffset,
        NameLength);

    RtlSecureZeroMemory(&tlSubItems, sizeof(tlSubItems));

    tlSubItems.Count = 2;

    if (Flags) {
        szBuffer[0] = 0;
        ultostr(Flags, szBuffer);
        tlSubItems.Text[0] = szBuffer;
    }
    else {
        tlSubItems.Text[0] = T_EmptyString;
    }

    if (lpAliasName) {
        TreeList_Expand(g_ctx.TreeList, RootItem, TVE_EXPAND);
        tlSubItems.Text[1] = lpAliasName;
    }
    else {
        tlSubItems.Text[1] = T_EmptyString;
    }

    supTreeListAddItem(
        g_ctx.TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        lpValueName,
        &tlSubItems);

    if (lpValueName) HeapFree(g_ctx.PluginHeap, 0, lpValueName);
    if (lpAliasName) HeapFree(g_ctx.PluginHeap, 0, lpAliasName);
}

/*
* ListApiSetV2
*
* Purpose:
*
* Parse and output ApiSet Version 2 (Windows 7).
*
*/
APISET_QUERY_ROUTINE(ListApiSetV2)
{
    API_SET_NAMESPACE_ARRAY_V2* namespace = (API_SET_NAMESPACE_ARRAY_V2*)ApiSetMap;

    ULONG i, j;

    API_SET_NAMESPACE_ENTRY_V2* nsEntry;
    API_SET_VALUE_ARRAY_V2* valuesArray;
    API_SET_VALUE_ENTRY_V2* valueEntry;

    HTREEITEM hSubItem;

    LPWSTR lpEntryName;

    for (i = 0; i < namespace->Count; i++) {

        nsEntry = &namespace->Array[i];

        lpEntryName = GetApiSetEntryName(
            (PBYTE)namespace,
            ApiSetSize,
            nsEntry->NameOffset,
            nsEntry->NameLength);

        if (lpEntryName) {

            if (FilterByName) {

                if (_strstri(lpEntryName, FilterByName) == NULL) {
                    HeapFree(g_ctx.PluginHeap, 0, lpEntryName);
                    continue;
                }

            }

            hSubItem = OutNamespaceEntry(
                RootItem,
                lpEntryName,
                0);

            //
            // Namespace entry name no longer needed.
            //
            HeapFree(g_ctx.PluginHeap, 0, lpEntryName);

            //
            // List values array.
            //
            if (!IsRangeValid(ApiSetSize, nsEntry->DataOffset, sizeof(API_SET_VALUE_ARRAY_V2)))
                continue;

            valuesArray = (API_SET_VALUE_ARRAY_V2*)RtlOffsetToPointer(
                namespace,
                nsEntry->DataOffset);

            for (j = 0; j < valuesArray->Count; j++) {

                valueEntry = &valuesArray->Array[j];

                if (!API_SET_EMPTY_NAMESPACE_VALUE(valueEntry)) {
                    OutNamespaceValue(
                        hSubItem,
                        (PBYTE)namespace,
                        ApiSetSize,
                        valueEntry->ValueOffset,
                        valueEntry->ValueLength,
                        valueEntry->NameOffset,
                        valueEntry->NameLength,
                        0);
                }
            }

        } //if (lpEntryName)
    }
}

/*
* ListApiSetV4
*
* Purpose:
*
* Parse and output ApiSet Version 4 (Windows 8.x).
*
*/
APISET_QUERY_ROUTINE(ListApiSetV4)
{
    API_SET_NAMESPACE_ARRAY_V4* namespace = (API_SET_NAMESPACE_ARRAY_V4*)ApiSetMap;

    ULONG i, j;

    API_SET_NAMESPACE_ENTRY_V4* nsEntry;
    API_SET_VALUE_ARRAY_V4* valuesArray;
    API_SET_VALUE_ENTRY_V4* valueEntry;

    HTREEITEM hSubItem;

    LPWSTR lpEntryName;

    for (i = 0; i < namespace->Count; i++) {

        nsEntry = &namespace->Array[i];

        lpEntryName = GetApiSetEntryName(
            (PBYTE)namespace,
            ApiSetSize,
            nsEntry->NameOffset,
            nsEntry->NameLength);

        if (lpEntryName) {

            if (FilterByName) {

                if (_strstri(lpEntryName, FilterByName) == NULL) {
                    HeapFree(g_ctx.PluginHeap, 0, lpEntryName);
                    continue;
                }

            }

            hSubItem = OutNamespaceEntry(
                RootItem,
                lpEntryName,
                nsEntry->Flags);

            //
            // Namespace entry name no longer needed.
            //
            HeapFree(g_ctx.PluginHeap, 0, lpEntryName);

            //
            // List values array.
            //
            if (!IsRangeValid(ApiSetSize, nsEntry->DataOffset, sizeof(API_SET_VALUE_ARRAY_V4)))
                continue;

            valuesArray = (API_SET_VALUE_ARRAY_V4*)RtlOffsetToPointer(
                namespace,
                nsEntry->DataOffset);

            for (j = 0; j < valuesArray->Count; j++) {

                valueEntry = &valuesArray->Array[j];

                if (!API_SET_EMPTY_NAMESPACE_VALUE(valueEntry)) {
                    OutNamespaceValue(
                        hSubItem,
                        (PBYTE)namespace,
                        ApiSetSize,
                        valueEntry->ValueOffset,
                        valueEntry->ValueLength,
                        valueEntry->NameOffset,
                        valueEntry->NameLength,
                        valueEntry->Flags);
                }
            }

        } //if (lpEntryName)
    }
}

/*
* ListApiSetV6
*
* Purpose:
*
* Parse and output ApiSet Version 6 (Windows 10).
*
*/
APISET_QUERY_ROUTINE(ListApiSetV6)
{
    API_SET_NAMESPACE_ARRAY_V6* namespace = (API_SET_NAMESPACE_ARRAY_V6*)ApiSetMap;

    ULONG i, j;

    API_SET_NAMESPACE_ENTRY_V6* nsEntry;
    API_SET_VALUE_ENTRY_V6* valueEntry;

    HTREEITEM hSubItem;

    LPWSTR lpEntryName;

    nsEntry = (API_SET_NAMESPACE_ENTRY_V6*)RtlOffsetToPointer(
        namespace,
        namespace->NamespaceEntryOffset);

    for (i = 0; i < namespace->Count; i++) {

        if (!IsRangeValid(ApiSetSize, (ULONG)((PBYTE)nsEntry - (PBYTE)namespace), sizeof(API_SET_NAMESPACE_ENTRY_V6)))
            break;

        lpEntryName = GetApiSetEntryName(
            (PBYTE)namespace,
            ApiSetSize,
            nsEntry->NameOffset,
            nsEntry->NameLength);

        if (lpEntryName) {

            if (FilterByName && _strstri(lpEntryName, FilterByName) == NULL) {
                HeapFree(g_ctx.PluginHeap, 0, lpEntryName);
            }
            else {
                hSubItem = OutNamespaceEntry(
                    RootItem,
                    lpEntryName,
                    nsEntry->Flags);

                //
                // Namespace entry name no longer needed.
                //
                HeapFree(g_ctx.PluginHeap, 0, lpEntryName);

                //
                // List values array.
                //
                valueEntry = (API_SET_VALUE_ENTRY_V6*)RtlOffsetToPointer(
                    namespace,
                    nsEntry->DataOffset);

                for (j = 0; j < nsEntry->Count; j++) {

                    if (!API_SET_EMPTY_NAMESPACE_VALUE(valueEntry)) {
                        OutNamespaceValue(
                            hSubItem,
                            (PBYTE)namespace,
                            ApiSetSize,
                            valueEntry->ValueOffset,
                            valueEntry->ValueLength,
                            valueEntry->NameOffset,
                            valueEntry->NameLength,
                            valueEntry->Flags);
                    }

                    valueEntry = (API_SET_VALUE_ENTRY_V6*)RtlOffsetToPointer(
                        valueEntry,
                        sizeof(API_SET_VALUE_ENTRY_V6));

                }
            }
        } //if (lpEntryName)

        //
        // Go to next entry.
        //
        nsEntry = (API_SET_NAMESPACE_ENTRY_V6*)RtlOffsetToPointer(
            nsEntry,
            sizeof(API_SET_NAMESPACE_ENTRY_V6));
    }
}

/*
* ResolveDllData
*
* Purpose:
*
* Process apiset file, locate apiset section and schema version.
*
*/
BOOL ResolveDllData(
    _In_ HMODULE DllHandle,
    _Inout_ PVOID* ApiSetData,
    _Out_ PULONG SchemaVersion,
    _Out_opt_ PULONG ApiSetSize
)
{
    ULONG dataSize = 0;
    UINT i;
    ULONG currentSchemaVersion = 0;

    PIMAGE_NT_HEADERS ntHeaders;
    IMAGE_SECTION_HEADER* sectionTableEntry;
    PBYTE baseAddress;
    PBYTE dataPtr = NULL;

    *SchemaVersion = 0;
    if (ApiSetSize) *ApiSetSize = 0;

    baseAddress = (PBYTE)(((ULONG_PTR)DllHandle) & ~3);

    ntHeaders = RtlImageNtHeader(baseAddress);
    if (ntHeaders == NULL)
        return FALSE;

    sectionTableEntry = IMAGE_FIRST_SECTION(ntHeaders);

    i = ntHeaders->FileHeader.NumberOfSections;
    while (i > 0) {
        if (_strncmpi_a((CHAR*)&sectionTableEntry->Name,
            API_SET_SECTION_NAME,
            sizeof(API_SET_SECTION_NAME)) == 0)
        {
            dataSize = sectionTableEntry->SizeOfRawData;

            dataPtr = (PBYTE)RtlOffsetToPointer(
                baseAddress,
                sectionTableEntry->PointerToRawData);

            break;
        }
        i -= 1;
        sectionTableEntry += 1;
    }

    if (dataPtr == NULL || dataSize == 0) {
        return FALSE;
    }

    if (dataSize < sizeof(ULONG))
        return FALSE;

    currentSchemaVersion = *(ULONG*)dataPtr;

    *SchemaVersion = currentSchemaVersion;
    *ApiSetData = dataPtr;
    if (ApiSetSize) *ApiSetSize = dataSize;

    return TRUE;
}

/*
* ListApiSetFromFileWorker
*
* Purpose:
*
* Processing apiset file.
*
*/
VOID WINAPI ListApiSetFromFileWorker(
    _In_ LPCWSTR SchemaFileName,
    _In_opt_ LPCWSTR FilterByName,
    _In_ PVOID ApiSetData,
    _In_ ULONG SchemaVersion,
    _In_ SIZE_T ApiSetSize
)
{
    pfnApiSetQueryMap queryMapRoutine = NULL;

    WCHAR szBuffer[MAX_PATH * 2];

    HTREEITEM h_tviRootItem, h_tviSubItem;

    //
    // Disable controls.
    //
    EnableWindow(GetDlgItem(g_ctx.MainWindow, IDC_BROWSE_BUTTON), FALSE);

    //
    // Reset output controls.
    //
    SetDlgItemText(g_ctx.MainWindow, IDC_ENTRY_EDIT, T_EmptyString);
    TreeList_ClearTree(g_ctx.TreeList);
    TreeList_RedrawDisable(g_ctx.TreeList);

    StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer), TEXT("Schema Version %lu"), SchemaVersion);

    //
    // Parse and output apiset.
    //
    h_tviRootItem = supTreeListAddItem(
        g_ctx.TreeList,
        (HTREEITEM)NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        (LPWSTR)SchemaFileName,
        (PVOID)NULL);

    if (h_tviRootItem) {

        h_tviSubItem = supTreeListAddItem(
            g_ctx.TreeList,
            (HTREEITEM)h_tviRootItem,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            (LPWSTR)szBuffer,
            (PVOID)NULL);

        if (h_tviSubItem) {
            switch (SchemaVersion) {
            case API_SET_SCHEMA_VERSION_V2:
                queryMapRoutine = (pfnApiSetQueryMap)ListApiSetV2;
                break;
            case API_SET_SCHEMA_VERSION_V4:
                queryMapRoutine = (pfnApiSetQueryMap)ListApiSetV4;
                break;
            case API_SET_SCHEMA_VERSION_V6:
                queryMapRoutine = (pfnApiSetQueryMap)ListApiSetV6;
                break;
            default:
                queryMapRoutine = NULL;
                break;
            }

            __try {

                if (queryMapRoutine)
                    queryMapRoutine(ApiSetData, h_tviSubItem, FilterByName, ApiSetSize);

            }
            __except (EXCEPTION_EXECUTE_HANDLER) {

                szBuffer[0] = 0;

                StringCchPrintf(
                    szBuffer,
                    RTL_NUMBER_OF(szBuffer),
                    TEXT("ApiSetView: Exception %lu thrown while processing apiset, schema version %lu"),
                    GetExceptionCode(),
                    SchemaVersion);

                DisplayErrorText(szBuffer);

            }
        }
    }

    //
    // Reenable controls.
    //
    EnableWindow(GetDlgItem(g_ctx.MainWindow, IDC_BROWSE_BUTTON), TRUE);
    TreeList_RedrawEnableAndUpdateNow(g_ctx.TreeList);
}

/*
* ListApiSetFromFile
*
* Purpose:
*
* Load file or use default system apiset and output it contents.
*
*/
VOID ListApiSetFromFile(
    _In_opt_ LPCWSTR FileName,
    _In_opt_ LPCWSTR FilterByName
)
{
    ULONG cch;
    ULONG schemaVersion = 0;
    HMODULE hApiSetDll;
    LPWSTR lpFileName = NULL;
    PVOID dataPtr = NULL;
    ULONG dataSize = 0;
    WCHAR szErrorMsg[MAX_PATH + 1];
    WCHAR szSystemDirectory[MAX_PATH + 1];

    //
    // Select apiset dll name.
    //
    if (FileName) {
        lpFileName = (LPWSTR)FileName;
    }
    else {
        RtlSecureZeroMemory(&g_ctx.SchemaFileName, sizeof(g_ctx.SchemaFileName));
        RtlSecureZeroMemory(szSystemDirectory, sizeof(szSystemDirectory));
        cch = GetSystemDirectory(szSystemDirectory, MAX_PATH);
        if (cch && cch < MAX_PATH) {
            StringCchPrintf(g_ctx.SchemaFileName,
                RTL_NUMBER_OF(g_ctx.SchemaFileName) - 1,
                TEXT("%s\\apisetschema.dll"),
                szSystemDirectory);
            lpFileName = g_ctx.SchemaFileName;
        }
    }

    if (lpFileName == NULL) {
        DisplayErrorText(TEXT("ApiSet dll filename not specified"));
        return;
    }

    //
    // Load library and locate apiset section.
    //

    hApiSetDll = LoadLibraryEx(lpFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hApiSetDll) {
        if (ResolveDllData(hApiSetDll, &dataPtr, &schemaVersion, &dataSize)) {
            if (schemaVersion != API_SET_SCHEMA_VERSION_V2 &&
                schemaVersion != API_SET_SCHEMA_VERSION_V4 &&
                schemaVersion != API_SET_SCHEMA_VERSION_V6)
            {
                StringCchPrintf(szErrorMsg,
                    RTL_NUMBER_OF(szErrorMsg),
                    TEXT("ApiSetView: Unknown schema version %lu"), schemaVersion);

                DisplayErrorText(szErrorMsg);
            }
            else {
                ListApiSetFromFileWorker(
                    lpFileName,
                    FilterByName,
                    dataPtr,
                    schemaVersion,
                    dataSize);
            }
        }
        else {
            DisplayErrorText(TEXT("ApiSetView: could not resolve data, probably not apiset file or data corrupted"));
        }

        FreeLibrary(hApiSetDll);
    }
    else {
        DisplayErrorText(TEXT("ApiSetView: could not load apiset library"));
    }
}

```

`Source/Plugins/ApiSetView/query.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2021
*
*  TITLE:       QUERY.H
*
*  VERSION:     1.11
*
*  DATE:        01 June 2021
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

VOID ListApiSetFromFile(
    _In_opt_ LPCWSTR lpFileName,
    _In_opt_ LPCWSTR FilterByName);

```

`Source/Plugins/ApiSetView/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDD_ASDIALOG                    101
#define IDC_ENTRY_EDIT                  1001
#define IDC_SEARCH_EDIT                 1002
#define IDC_SEARCH_BUTTON               1003
#define IDC_BROWSE_BUTTON               1004
#define ID_USE_SYSTEM_SCHEMA_FILE       40001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/Plugins/ApiSetView/ui.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       UI.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 ApiSetView UI constants, definitions and includes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "uxtheme.lib")

#define DefaultSystemDpi            96
#define WINOBJEX64_ICON_MAIN        174
#define ID_OBJECT_COPY              40008

#define T_EmptyString TEXT("")

typedef struct _VALUE_DESC {
    ULONG Value;
    LPCWSTR Desc;
} VALUE_DESC, * PVALUE_DESC;

typedef struct _GUI_CONTEXT {
    HWND MainWindow;
    HWND TreeList;
    HWND SearchEdit;
    HANDLE PluginHeap;
    HANDLE WorkerThread;
    HICON WindowIcon;

    INT tlSubItemHit;

    WCHAR SchemaFileName[MAX_PATH * 2];

    //
    // WinObjEx64 data and pointers.
    //
    WINOBJEX_PARAM_BLOCK ParamBlock;
} GUI_CONTEXT, *PGUI_CONTEXT;

```

`Source/Plugins/ExamplePlugin/ExamplePlugin.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{7C10DDD2-E88A-4133-B140-80679BE8AFDD}</ProjectGuid>
    <RootNamespace>ExamplePlugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ExamplePlugin</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>$(SolutionDir)Plugins\postbuild.cmd $(ProjectName) .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).dll .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).pdb</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\plugin_def.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Plugins/ExamplePlugin/ExamplePlugin.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\plugin_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Source/Plugins/ExamplePlugin/ExamplePlugin.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/Plugins/ExamplePlugin/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,2510
 PRODUCTVERSION 1,2,0,2510
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "WinObjEx64 Plugin V1.2"
            VALUE "FileVersion", "1.2.0.2510"
            VALUE "InternalName", "ExamplePlugin"
            VALUE "LegalCopyright", "Copyright (C) 2019 - 2025"
            VALUE "OriginalFilename", "ExamplePlugin.dll"
            VALUE "ProductName", "Example Plugin for WinObjEx64"
            VALUE "ProductVersion", "1.2.0.2510"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/Plugins/ExamplePlugin/export.def`:

```def
EXPORTS
PluginInit

```

`Source/Plugins/ExamplePlugin/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.03
*
*  DATE:        22 Aug 2025
*
*  WinObjEx64 example and test plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma warning(disable: 6258) //Using TerminateThread does not allow proper thread clean up.
#pragma warning(disable: 6320) //Exception-filter expression is the constant EXCEPTION_EXECUTE_HANDLER. This might mask exceptions that were not intended to be handled.

#define EXAMPLE_PLUGIN_MAJOR_VERSION 1
#define EXAMPLE_PLUGIN_MINOR_VERSION 2

#include <Windows.h>
#include <strsafe.h>

#pragma warning(push)
#pragma warning(disable: 4005)
#include <ntstatus.h>
#pragma warning(pop)
#include "ntos/ntos.h"
#include "plugin_def.h"

volatile DWORD g_pluginState = PLUGIN_RUNNING;
HANDLE g_threadHandle = NULL;
WINOBJEX_PARAM_BLOCK g_paramBlock;
WINOBJEX_PLUGIN* g_plugin = NULL;
HINSTANCE g_thisDll = NULL;

/*
* PluginThread
*
* Purpose:
*
* Plugin payload thread.
*
*/
DWORD WINAPI PluginThread(
    _In_ PVOID Parameter
)
{
    UNREFERENCED_PARAMETER(Parameter);

    MessageBox(GetDesktopWindow(), TEXT("This is message from example plugin, plugin will stop in 5 sec."), TEXT("ExamplePlugin"), MB_ICONINFORMATION);

    Sleep(5000);
    InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);

    if (g_plugin && g_plugin->StateChangeCallback)
        g_plugin->StateChangeCallback(g_plugin, PluginStopped, NULL);

    return 0;
}

/*
* StartPlugin
*
* Purpose:
*
* Run actual plugin code in dedicated thread.
*
* Parameters:
*   ParamBlock - Plugin parameters passed from WinObjEx64
*
* Return:
*   STATUS_SUCCESS - Plugin started successfully
*   STATUS_UNSUCCESSFUL - Failed to start plugin
*/
NTSTATUS CALLBACK StartPlugin(
    _In_ PWINOBJEX_PARAM_BLOCK ParamBlock
)
{
    DWORD threadId;
    NTSTATUS status;
    WINOBJEX_PLUGIN_STATE State = PluginInitialization;

    DbgPrint("StartPlugin called from thread 0x%lx\r\n", GetCurrentThreadId());

    if (ParamBlock == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory(&g_paramBlock, ParamBlock, sizeof(WINOBJEX_PARAM_BLOCK));
    InterlockedExchange((PLONG)&g_pluginState, PLUGIN_RUNNING);
    
    g_threadHandle = CreateThread(
        NULL, 
        0, 
        (LPTHREAD_START_ROUTINE)PluginThread, 
        (PVOID)NULL, 0, 
        &threadId);

    if (g_threadHandle) {
        status = STATUS_SUCCESS;
        State = PluginRunning;
    }
    else {
        status = STATUS_UNSUCCESSFUL;
        State = PluginError;
    }

    if (g_plugin && g_plugin->StateChangeCallback)
        g_plugin->StateChangeCallback(g_plugin, State, NULL);

    return status;
}

/*
* StopPlugin
*
* Purpose:
*
* Stop plugin execution and cleanup resources.
*
*/
void CALLBACK StopPlugin(
    VOID
)
{
    DbgPrint("StopPlugin called from thread 0x%lx\r\n", GetCurrentThreadId());

    if (g_threadHandle) {

        InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);

        if (WaitForSingleObject(g_threadHandle, 1000) == WAIT_TIMEOUT) {
            DbgPrint("Wait timeout, terminating plugin thread, g_threadHandle = %llx\r\n", (ULONG_PTR)g_threadHandle);
            TerminateThread(g_threadHandle, 0);
        }
        else {
            DbgPrint("Wait success, plugin thread stopped, g_threadHandle = %llx\r\n", (ULONG_PTR)g_threadHandle);
        }

        CloseHandle(g_threadHandle);
        g_threadHandle = NULL;

        if (g_plugin && g_plugin->StateChangeCallback)
            g_plugin->StateChangeCallback(g_plugin, PluginStopped, NULL);
    }
}

/*
* PluginInit
*
* Purpose:
*
* Initialize plugin information for WinObjEx64.
*
* Parameters:
*   PluginData - Plugin data structure to be filled
*
* Return:
*   TRUE - Plugin initialized successfully
*   FALSE - Failed to initialize plugin
*/
BOOLEAN CALLBACK PluginInit(
    _Inout_ PWINOBJEX_PLUGIN PluginData
)
{
    // Don't initialize twice
    if (g_plugin) {
        return FALSE;
    }

    __try {
        if (PluginData == NULL) {
            return FALSE;
        }

        if (PluginData->cbSize < sizeof(WINOBJEX_PLUGIN)) {
            return FALSE;
        }

        if (PluginData->AbiVersion != WINOBJEX_PLUGIN_ABI_VERSION) {
            return FALSE;
        }

        //
        // Set plugin name to be displayed in WinObjEx64 UI.
        //
        StringCbCopy(PluginData->Name, sizeof(PluginData->Name), TEXT("Example Plugin"));

        //
        // Set authors.
        //
        StringCbCopy(PluginData->Authors, sizeof(PluginData->Authors), TEXT("UG North"));

        //
        // Set plugin description.
        //
        StringCbCopy(PluginData->Description, sizeof(PluginData->Description), 
            TEXT("WinObjEx64 example plugin."));

        //
        // Set required plugin system version.
        //
        PluginData->RequiredPluginSystemVersion = WOBJ_PLUGIN_SYSTEM_VERSION;

        //
        // Setup start/stop plugin callbacks.
        //
        PluginData->StartPlugin = (pfnStartPlugin)&StartPlugin;
        PluginData->StopPlugin = (pfnStopPlugin)&StopPlugin;

        //
        // Setup permissions.
        //
        PluginData->Capabilities.u1.NeedAdmin = FALSE;
        PluginData->Capabilities.u1.SupportWine = TRUE;
        PluginData->Capabilities.u1.NeedDriver = FALSE;

        PluginData->MajorVersion = EXAMPLE_PLUGIN_MAJOR_VERSION;
        PluginData->MinorVersion = EXAMPLE_PLUGIN_MINOR_VERSION;

        //
        // Set plugin type.
        //
        PluginData->Type = DefaultPlugin;

        g_plugin = PluginData;

        return TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint("PluginInit exception thrown %lx\r\n", GetExceptionCode());
        return FALSE;
    }
}

/*
* DllMain
*
* Purpose:
*
* DLL entry point.
*
* Parameters:
*   hinstDLL - DLL instance handle
*   fdwReason - Reason for calling function
*   lpvReserved - Reserved
*
* Return:
*   TRUE - Always
*/
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD     fdwReason,
    _In_ LPVOID    lpvReserved
)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_thisDll = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
    }
    return TRUE;
}

```

`Source/Plugins/ExamplePlugin/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/Plugins/ImageScope/ImageScope.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{38d717f0-9152-4b74-8d32-5222373eab3e}</ProjectGuid>
    <RootNamespace>ImageScope</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <Optimization>MinSpace</Optimization>
      <StringPooling>true</StringPooling>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>$(SolutionDir)Plugins\postbuild.cmd $(ProjectName) .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).dll .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).pdb</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\minirtl\hextou64.c" />
    <ClCompile Include="..\..\Shared\minirtl\u64tohex.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcmp.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcpy.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncmp.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncpy.c" />
    <ClCompile Include="..\..\Shared\ntos\ntsup.c" />
    <ClCompile Include="..\..\Shared\tabs\tabsctrl.c" />
    <ClCompile Include="..\..\Shared\treelist\treelist.c" />
    <ClCompile Include="..\utils.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="query.c" />
    <ClCompile Include="ui.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\..\Shared\minirtl\rtltypes.h" />
    <ClInclude Include="..\..\Shared\ntos\ntos.h" />
    <ClInclude Include="..\..\Shared\ntos\ntsup.h" />
    <ClInclude Include="..\..\Shared\sdk\extdef.h" />
    <ClInclude Include="..\..\Shared\tabs\tabsctrl.h" />
    <ClInclude Include="..\..\Shared\treelist\treelist.h" />
    <ClInclude Include="..\plugin_def.h" />
    <ClInclude Include="..\utils.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="query.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="ui.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Plugins/ImageScope/ImageScope.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ntos">
      <UniqueIdentifier>{d2825bdd-fe43-4ebf-9d7e-93f70bee0a6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{3fc49280-92ec-4638-ae24-6144bed64c6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="tabs">
      <UniqueIdentifier>{47476539-9197-402f-8e71-0bd5fcb07914}</UniqueIdentifier>
    </Filter>
    <Filter Include="treelist">
      <UniqueIdentifier>{fbb5d080-c089-4398-bc97-6a35b013bcb7}</UniqueIdentifier>
    </Filter>
    <Filter Include="sdk">
      <UniqueIdentifier>{d9dffc49-f34e-4cb2-9938-e1a6bc53a50b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="query.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\tabs\tabsctrl.c">
      <Filter>tabs</Filter>
    </ClCompile>
    <ClCompile Include="ui.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\treelist\treelist.c">
      <Filter>treelist</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\ntos\ntsup.c">
      <Filter>ntos</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\u64tohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\hextou64.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\plugin_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntos.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="query.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\tabs\tabsctrl.h">
      <Filter>tabs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\treelist\treelist.h">
      <Filter>treelist</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\sdk\extdef.h">
      <Filter>sdk</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntsup.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Source/Plugins/ImageScope/ImageScope.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/Plugins/ImageScope/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,2510
 PRODUCTVERSION 1,2,0,2510
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "WinObjEx64 Plugin V1.2"
            VALUE "FileVersion", "1.2.0.2510"
            VALUE "InternalName", "ImageScope"
            VALUE "LegalCopyright", "Copyright (C) 2019 - 2025"
            VALUE "OriginalFilename", "ImageScope.dll"
            VALUE "ProductName", "ImageScope Plugin for WinObjEx64"
            VALUE "ProductVersion", "1.2.0.2510"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_TABDLG_VSINFO DIALOGEX 0, 0, 345, 201
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_VISIBLE | WS_SYSMENU
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,7,331,187
END

IDD_TABDLG_STRINGS DIALOGEX 0, 0, 344, 200
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_VISIBLE | WS_SYSMENU
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,7,330,186
END

IDD_TABDLG_SECTION DIALOGEX 0, 0, 344, 200
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_VISIBLE | WS_SYSMENU
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_TABDLG_VSINFO, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 338
        TOPMARGIN, 7
        BOTTOMMARGIN, 194
    END

    IDD_TABDLG_STRINGS, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 337
        TOPMARGIN, 7
        BOTTOMMARGIN, 193
    END

    IDD_TABDLG_SECTION, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 337
        TOPMARGIN, 7
        BOTTOMMARGIN, 193
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/Plugins/ImageScope/export.def`:

```def
EXPORTS
PluginInit

```

`Source/Plugins/ImageScope/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Common header file for the Windows Object Explorer ImageScope plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Strict UNICODE
//
#if !defined UNICODE
#error ANSI build is not supported
#endif

#define OEMRESOURCE
#include <Windows.h>
#include <windowsx.h>
#include <strsafe.h>
#include <commctrl.h>
#include <Uxtheme.h>

#pragma warning(push)
#pragma warning(disable: 4005)
#include <ntstatus.h>
#pragma warning(pop)

#pragma warning(disable: 6258) // TerminateThread
#pragma warning(disable: 6320) // Exception-filter expression is the constant EXCEPTION_EXECUTE_HANDLER
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'


#include "ntos/ntos.h"
#include "ntos/ntsup.h"
#include "treelist/treelist.h"
#include "minirtl/minirtl.h"
#include "tabs/tabsctrl.h"
#include "plugin_def.h"
#include "sdk/extdef.h"
#include "resource.h"
#include "query.h"
#include "ui.h"

//declared in main.c
extern HINSTANCE g_thisDll;
extern volatile DWORD g_pluginState;
extern WINOBJEX_PLUGIN* g_plugin;

#ifdef _DEBUG
#define kdDebugPrint(f, ...) DbgPrint(f, __VA_ARGS__)
#else
#define kdDebugPrint(f, ...) 
#endif

#include "utils.h"

```

`Source/Plugins/ImageScope/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.22
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 ImageScope plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define IMAGESCOPE_PLUGIN_MAJOR_VERSION 1
#define IMAGESCOPE_PLUGIN_MINOR_VERSION 2

//
// Dll instance.
//
HINSTANCE g_thisDll = NULL;

volatile DWORD g_pluginState = PLUGIN_RUNNING;

//
// Plugin entry.
//
WINOBJEX_PLUGIN* g_plugin = NULL;
volatile LONG g_refCount = 0;

/*
* PmpCopyObjectData
*
* Purpose:
*
* Create copies of object directory and name.
*
*/
BOOL PmpCopyObjectData(
    _In_ WINOBJEX_PARAM_OBJECT* Source,
    _In_ WINOBJEX_PARAM_OBJECT* Dest
)
{
    HANDLE HeapHandle = NtCurrentPeb()->ProcessHeap;

    return supDuplicateUnicodeString(HeapHandle, &Dest->Directory, &Source->Directory) &&
        supDuplicateUnicodeString(HeapHandle, &Dest->Name, &Source->Name);
}

/*
* PluginFreeGlobalResources
*
* Purpose:
*
* Plugin resources deallocation routine.
*
*/
VOID PluginFreeGlobalResources(
    _In_ GUI_CONTEXT* Context
)
{
    if (Context->SectionAddress) {
        NtUnmapViewOfSection(NtCurrentProcess(), Context->SectionAddress);
        Context->SectionAddress = NULL;
    }

    supFreeDuplicatedUnicodeString(NtCurrentPeb()->ProcessHeap,
        &Context->ParamBlock.Object.Directory, TRUE);

    supFreeDuplicatedUnicodeString(NtCurrentPeb()->ProcessHeap,
        &Context->ParamBlock.Object.Name, TRUE);
}

/*
* PluginThread
*
* Purpose:
*
* Plugin payload thread.
*
*/
DWORD WINAPI PluginThread(
    _In_ PVOID Parameter
)
{
    ULONG uResult = 0;
    GUI_CONTEXT* context = (GUI_CONTEXT*)Parameter;

    if (context == NULL)
        return (DWORD)-1;

    InterlockedIncrement(&g_refCount);

    __try {
        if (g_plugin == NULL || g_plugin->GuiInitCallback == NULL) { // this is required callback
            kdDebugPrint("Gui init callback required\r\n");
            __leave;
        }

        if (!g_plugin->GuiInitCallback(g_plugin,
            g_thisDll,
            (WNDPROC)MainWindowProc,
            NULL))
        {
            kdDebugPrint("Gui init callback failure\r\n");
            __leave;
        }

        uResult = (ULONG)RunUI(context);
    }
    __finally {
        InterlockedDecrement(&g_refCount);
        PluginFreeGlobalResources(context);
        supHeapFree(context);
    }

    ExitThread(uResult);
}

/*
* StartPlugin
*
* Purpose:
*
* Run actual plugin code in dedicated thread.
*
*/
NTSTATUS CALLBACK StartPlugin(
    _In_ PWINOBJEX_PARAM_BLOCK ParamBlock
)
{
    BOOL deallocateContext = FALSE;
    DWORD threadId;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    WINOBJEX_PLUGIN_STATE state = PluginInitialization;
    HANDLE workerThread, sectionHandle = NULL;
    GUI_CONTEXT* Context;

    WCHAR szError[100];

    Context = (GUI_CONTEXT*)supHeapAlloc(sizeof(GUI_CONTEXT));
    if (Context == NULL)
        return STATUS_MEMORY_NOT_ALLOCATED;

    __try {
        RtlCopyMemory(
            &Context->ParamBlock,
            ParamBlock,
            sizeof(WINOBJEX_PARAM_BLOCK));

        RtlZeroMemory(
            &Context->ParamBlock.Object,
            sizeof(WINOBJEX_PARAM_OBJECT));

        if (!PmpCopyObjectData(
            &ParamBlock->Object,
            &Context->ParamBlock.Object))
        {
            deallocateContext = TRUE;
            status = STATUS_MEMORY_NOT_ALLOCATED;
            __leave;
        }

        if (Context->ParamBlock.OpenNamedObjectByType == NULL) {
            deallocateContext = TRUE;
            status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        status = Context->ParamBlock.OpenNamedObjectByType(
            &sectionHandle,
            ObjectTypeSection,
            &Context->ParamBlock.Object.Directory,
            &Context->ParamBlock.Object.Name,
            SECTION_QUERY | SECTION_MAP_READ);

        if (!NT_SUCCESS(status)) {
            StringCbPrintf(szError, sizeof(szError), TEXT("Could not open section, 0x%08X"), (ULONG)status);

            MessageBox(
                ParamBlock->ParentWindow,
                szError,
                T_PLUGIN_NAME,
                MB_ICONERROR);

            deallocateContext = TRUE;
            status = STATUS_SUCCESS;
            __leave;
        }

        // Map section
        status = supMapSection(
            sectionHandle,
            &Context->SectionAddress,
            &Context->SectionViewSize);

        NtClose(sectionHandle);
        sectionHandle = NULL;

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NOT_SUPPORTED) {
                MessageBox(ParamBlock->ParentWindow,
                    TEXT("This section does not represent mapped image, unable to continue."),
                    T_PLUGIN_NAME,
                    MB_ICONINFORMATION);
            }
            else {
                StringCbPrintf(szError, sizeof(szError), TEXT("Could not map section, 0x%08X"), (ULONG)status);
                MessageBox(ParamBlock->ParentWindow, szError,
                    T_PLUGIN_NAME,
                    MB_ICONERROR);
            }

            // Stop plugin if we cannot open section, but do not fail with error as we already displayed it.
            state = PluginStopped;
            deallocateContext = TRUE;
            status = STATUS_SUCCESS;
            __leave;
        }

        workerThread = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)PluginThread,
            (PVOID)Context,
            0,
            &threadId);

        if (workerThread) {
            status = STATUS_SUCCESS;
            CloseHandle(workerThread);
            workerThread = NULL;
            state = PluginRunning;
        }
        else {
            status = STATUS_UNSUCCESSFUL;
            state = PluginError;
            deallocateContext = TRUE;
        }
    }
    __finally {
        if (sectionHandle) {
            NtClose(sectionHandle);
        }

        if (deallocateContext && Context) {
            supHeapFree(Context);
        }

        if (g_plugin && g_plugin->StateChangeCallback)
            g_plugin->StateChangeCallback(g_plugin, state, NULL);
    }
    return status;
}

/*
* StopPlugin
*
* Purpose:
*
* Stop plugin execution.
*
*/
void CALLBACK StopPlugin(
    VOID
)
{
    // Signal stop
    InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);

    // Wait for all references to be released
    while (InterlockedCompareExchange(&g_refCount, 0, 0) > 0)
        Sleep(50);

    if (g_plugin && g_plugin->GuiShutdownCallback)
        g_plugin->GuiShutdownCallback(g_plugin, g_thisDll, NULL);

}

/*
* PluginInit
*
* Purpose:
*
* Initialize plugin information for WinObjEx64.
*
*/
BOOLEAN CALLBACK PluginInit(
    _Inout_ PWINOBJEX_PLUGIN PluginData
)
{
    // Don't initialize twice
    if (g_plugin) {
        return FALSE;
    }

    __try {

        if (PluginData == NULL) {
            return FALSE;
        }

        if (PluginData->cbSize < sizeof(WINOBJEX_PLUGIN)) {
            return FALSE;
        }

        if (PluginData->AbiVersion != WINOBJEX_PLUGIN_ABI_VERSION) {
            return FALSE;
        }

        //
        // Set plugin name to be displayed in WinObjEx64 UI.
        //
        StringCbCopy(PluginData->Name, sizeof(PluginData->Name), TEXT("ImageScope"));

        //
        // Set authors.
        //
        StringCbCopy(PluginData->Authors, sizeof(PluginData->Authors), TEXT("UG North"));

        //
        // Set plugin description.
        //
        StringCbCopy(PluginData->Description, sizeof(PluginData->Description),
            TEXT("Display additional information for sections created from PE files."));

        //
        // Set required plugin system version.
        //
        PluginData->RequiredPluginSystemVersion = WOBJ_PLUGIN_SYSTEM_VERSION;

        //
        // Setup start/stop plugin callbacks.
        //
        PluginData->StartPlugin = (pfnStartPlugin)&StartPlugin;
        PluginData->StopPlugin = (pfnStopPlugin)&StopPlugin;

        //
        // Setup capabilities.
        //
        PluginData->Capabilities.u1.NeedAdmin = FALSE;
        PluginData->Capabilities.u1.SupportWine = TRUE;
        PluginData->Capabilities.u1.NeedDriver = FALSE;
        PluginData->Capabilities.u1.SupportMultipleInstances = TRUE;

        PluginData->MajorVersion = IMAGESCOPE_PLUGIN_MAJOR_VERSION;
        PluginData->MinorVersion = IMAGESCOPE_PLUGIN_MINOR_VERSION;

        //
        // Set plugin type.
        //
        PluginData->Type = ContextPlugin;

        //
        // Set supported object type(s).
        //
        RtlFillMemory(
            PluginData->SupportedObjectsIds,
            sizeof(PluginData->SupportedObjectsIds),
            ObjectTypeNone);

        PluginData->SupportedObjectsIds[0] = ObjectTypeSection;

        g_plugin = PluginData;

        return TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint("PluginInit exception thrown %lx\r\n", GetExceptionCode());
        return FALSE;
    }
}

/*
* DllMain
*
* Purpose:
*
* Dll entry point.
*
*/
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD     fdwReason,
    _In_ LPVOID    lpvReserved
)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_thisDll = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
    }
    return TRUE;
}

```

`Source/Plugins/ImageScope/query.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       QUERY.C
*
*  VERSION:     1.22
*
*  DATE:        03 Oct 2025
*
*  ImageScope main logic.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define IMGSCOPE_MAX_EXTRACTED_STR 255

static inline BOOL IsWideStartChar(WCHAR c)
{
    return ((c >= L'A' && c <= L'Z') ||
        (c >= L'a' && c <= L'z') ||
        (c >= L'0' && c <= L'9') ||
        c == L'(' || c == L'<' || c == L'\"' ||
        c == L'.' || c == L'%' || c == L'{' ||
        c == L'\\' || c == L'@');
}

static inline BOOL IsWideContinueChar(WCHAR c)
{
    return (((c >= 0x20) && (c <= 0x7f)) ||
        c == L'\r' || c == L'\n' || c == L'\t');
}

static inline BOOL IsAnsiStartChar(UCHAR c)
{
    return ((c >= 'A' && c <= 'Z') ||
        (c >= 'a' && c <= 'z') ||
        (c >= '0' && c <= '9') ||
        c == '(' || c == '<' || c == '\"' ||
        c == '.' || c == '%' || c == '{' ||
        c == '\\' || c == '@');
}

static inline BOOL IsAnsiContinueChar(UCHAR c)
{
    return (((c >= 0x20) && (c <= 0x7f)) ||
        c == '\r' || c == '\n' || c == '\t');
}

ULONG_PTR FORCEINLINE ALIGN_UP_32(
    _In_ ULONG_PTR p)
{
    return (p + 3) & (~(ULONG_PTR)3);
}

static inline BOOL IsRangeValid(
    _In_ SIZE_T BaseSize,
    _In_ SIZE_T Offset,
    _In_ SIZE_T Length
)
{
    SIZE_T start = Offset;
    SIZE_T len = Length;

    if (start >= BaseSize) return FALSE;
    if (len > BaseSize - start) return FALSE;
    return TRUE;
}

/*
* PEImageEnumVarFileInfo
*
* Purpose:
*
* Enumerate version info variables in the given module.
*
*/
BOOL PEImageEnumVarFileInfo(
    _In_ PIMGVSTRING hdr,
    _In_ PVOID BasePtr,
    _In_ SIZE_T BaseSize,
    _In_ PEnumVarInfoCallback vcallback,
    _In_opt_ PVOID cbparam)
{
    ULONG_PTR   vLimit;
    PDWORD      value;
    DWORD       uZero = 0;
    SIZE_T      hdrOffset;

    if (hdr == NULL || vcallback == NULL || BasePtr == NULL)
        return FALSE;

    hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)BasePtr);
    if (!IsRangeValid(BaseSize, hdrOffset, sizeof(IMGVARINFO)))
        return FALSE;

    if (!IsRangeValid(BaseSize, hdrOffset, hdr->vshdr.wLength))
        return FALSE;

    vLimit = (ULONG_PTR)hdr + hdr->vshdr.wLength;

    for (
        /* first child structure */
        hdr = (PIMGVSTRING)ALIGN_UP_32((ULONG_PTR)hdr + sizeof(IMGVARINFO));
        (ULONG_PTR)hdr < vLimit;
        hdr = (PIMGVSTRING)ALIGN_UP_32((ULONG_PTR)hdr + hdr->vshdr.wLength))
    {
        hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)BasePtr);
        if (!IsRangeValid(BaseSize, hdrOffset, sizeof(IMGVARINFO)))
            return FALSE;

        if (hdr->vshdr.wValueLength == 0) {
            value = &uZero;
        }
        else {
            SIZE_T valueOffset = (SIZE_T)((ULONG_PTR)&hdr->szKey - (ULONG_PTR)BasePtr);
            SIZE_T nameChars = (SIZE_T)(1 + wcslen(hdr->szKey));
            SIZE_T valuePtrOffset = valueOffset + nameChars * sizeof(WCHAR);
            valuePtrOffset = (SIZE_T)ALIGN_UP_32((ULONG_PTR)valuePtrOffset);
            if (!IsRangeValid(BaseSize, valuePtrOffset, sizeof(DWORD)))
                return FALSE;
            value = (PDWORD)RtlOffsetToPointer(BasePtr, (ULONG_PTR)valuePtrOffset);
        }

        if (!vcallback(hdr->szKey, *value, cbparam))
            return FALSE;
    }

    return TRUE;
}

/*
* PEImageEnumStrings
*
* Purpose:
*
* Enumerate strings in the given module.
*
*/
BOOL PEImageEnumStrings(
    _In_ PIMGVSTRING hdr,
    _In_ PVOID BasePtr,
    _In_ SIZE_T BaseSize,
    _In_ PEnumStringInfoCallback callback,
    _In_ PWCHAR langId,
    _In_opt_ PVOID cbparam)
{
    ULONG_PTR   vLimit;
    PWCHAR      value;
    SIZE_T      hdrOffset;
    SIZE_T      keyLenChars;

    if (hdr == NULL || callback == NULL || BasePtr == NULL)
        return FALSE;

    hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)BasePtr);
    if (!IsRangeValid(BaseSize, hdrOffset, sizeof(IMGSTRINGTABLE)))
        return FALSE;

    if (!IsRangeValid(BaseSize, hdrOffset, hdr->vshdr.wLength))
        return FALSE;

    vLimit = (ULONG_PTR)hdr + hdr->vshdr.wLength;

    for (
        /* first child structure */
        hdr = (PIMGVSTRING)ALIGN_UP_32((ULONG_PTR)hdr + sizeof(IMGSTRINGTABLE));
        (ULONG_PTR)hdr < vLimit;
        hdr = (PIMGVSTRING)ALIGN_UP_32((ULONG_PTR)hdr + hdr->vshdr.wLength))
    {
        hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)BasePtr);
        if (!IsRangeValid(BaseSize, hdrOffset, sizeof(IMGVARINFO)))
            return FALSE;

        if (hdr->vshdr.wValueLength == 0) {
            value = L"";
        }
        else {
            keyLenChars = 1 + wcslen(hdr->szKey);
            SIZE_T keyBytes = keyLenChars * sizeof(WCHAR);
            SIZE_T valuePtrOffset = (SIZE_T)((ULONG_PTR)&hdr->szKey - (ULONG_PTR)BasePtr) + keyBytes;
            valuePtrOffset = (SIZE_T)ALIGN_UP_32((ULONG_PTR)valuePtrOffset);
            if (!IsRangeValid(BaseSize, valuePtrOffset, (SIZE_T)hdr->vshdr.wValueLength))
                return FALSE;
            value = (PWCHAR)RtlOffsetToPointer(BasePtr, (ULONG_PTR)valuePtrOffset);
        }

        if (!callback(hdr->szKey, value, langId, cbparam))
            return FALSE;
    }

    return TRUE;
}

/*
* PEImageEnumStringFileInfo
*
* Purpose:
*
* Enumerate strings in version info in the given module.
*
*/
BOOL PEImageEnumStringFileInfo(
    _In_ PIMGSTRINGTABLE hdr,
    _In_ PVOID BasePtr,
    _In_ SIZE_T BaseSize,
    _In_ PEnumStringInfoCallback callback,
    _In_opt_ PVOID cbparam)
{
    ULONG_PTR   vLimit;
    SIZE_T      hdrOffset;

    if (hdr == NULL || callback == NULL || BasePtr == NULL)
        return FALSE;

    hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)BasePtr);
    if (!IsRangeValid(BaseSize, hdrOffset, sizeof(IMGSTRINGINFO)))
        return FALSE;

    if (!IsRangeValid(BaseSize, hdrOffset, hdr->vshdr.wLength))
        return FALSE;

    vLimit = (ULONG_PTR)hdr + hdr->vshdr.wLength;

    for (
        /* first child structure */
        hdr = (PIMGSTRINGTABLE)ALIGN_UP_32((ULONG_PTR)hdr + sizeof(IMGSTRINGINFO));
        (ULONG_PTR)hdr < vLimit;
        hdr = (PIMGSTRINGTABLE)ALIGN_UP_32((ULONG_PTR)hdr + hdr->vshdr.wLength))
    {
        hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)BasePtr);
        if (!IsRangeValid(BaseSize, hdrOffset, hdr->vshdr.wLength))
            return FALSE;

        if (!PEImageEnumStrings((PIMGVSTRING)hdr, BasePtr, BaseSize, callback, hdr->wIdKey, cbparam))
            return FALSE;
    }

    return TRUE;
}

/*
* PEImageEnumVersionFields
*
* Purpose:
*
* Enumerate version info fields in the given module.
*
*/
VS_FIXEDFILEINFO* PEImageEnumVersionFields(
    _In_ HMODULE module,
    _In_ PEnumStringInfoCallback scallback,
    _In_opt_ PEnumVarInfoCallback vcallback,
    _Inout_opt_ PVOID cbparam)
{
    HGLOBAL     rPtr = NULL;
    ULONG_PTR   ids[3];
    VS_FIXEDFILEINFO* vinfo = NULL;
    PIMGVSVERSIONINFO   hdr;
    NTSTATUS status;
    SIZE_T dataSz = 0;
    ULONG_PTR vLimit;
    SIZE_T baseSize = 0;
    PVOID basePtr = NULL;

    if (!scallback)
        return NULL;

    __try {
        ids[0] = (ULONG_PTR)RT_VERSION;                     //type
        ids[1] = 1;                                         //id
        ids[2] = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL); //lang

        status = LdrResSearchResource(
            module,
            (ULONG_PTR*)&ids,
            3,
            0,
            (LPVOID*)&rPtr,
            (ULONG_PTR*)&dataSz,
            NULL,
            NULL);

        if (NT_SUCCESS(status)) {
            hdr = (PIMGVSVERSIONINFO)rPtr;
            basePtr = rPtr;
            baseSize = dataSz;

            if (hdr == NULL || dataSz < sizeof(IMGVSVERSIONINFO)) {
                __leave;
            }

            /* validate root header length */
            if (!IsRangeValid(baseSize, 0, hdr->vshdr.wLength))
                __leave;

            vLimit = (ULONG_PTR)hdr + hdr->vshdr.wLength;

            if (hdr->vshdr.wValueLength)
                vinfo = (VS_FIXEDFILEINFO*)((ULONG_PTR)hdr + sizeof(IMGVSVERSIONINFO));

            for (
                /* first child structure */
                hdr = (PIMGVSVERSIONINFO)ALIGN_UP_32((ULONG_PTR)hdr + hdr->vshdr.wValueLength + sizeof(IMGVSVERSIONINFO));
                (ULONG_PTR)hdr < vLimit;
                hdr = (PIMGVSVERSIONINFO)ALIGN_UP_32((ULONG_PTR)hdr + hdr->vshdr.wLength))
            {
                SIZE_T hdrOffset = (SIZE_T)((ULONG_PTR)hdr - (ULONG_PTR)basePtr);
                if (!IsRangeValid(baseSize, hdrOffset, sizeof(IMGVSVERSIONINFO)))
                    break;

                if (!IsRangeValid(baseSize, hdrOffset, hdr->vshdr.wLength))
                    break;

                if (_strcmp(hdr->wIdString, L"StringFileInfo") == 0) {
                    if (!PEImageEnumStringFileInfo((PIMGSTRINGTABLE)hdr, basePtr, baseSize, scallback, cbparam))
                        break;
                }

                if (vcallback) {
                    if ((_strcmp(hdr->wIdString, L"VarFileInfo") == 0)) {
                        if (!PEImageEnumVarFileInfo((PIMGVSTRING)hdr, basePtr, baseSize, vcallback, cbparam))
                            break;
                    }
                }
            }
        }
        else {
            SetLastError(RtlNtStatusToDosError(status));
        }
    }
    __finally {
        if (AbnormalTermination()) {
            SetLastError((DWORD)STATUS_ACCESS_VIOLATION);
            vinfo = NULL;
        }
    }

    return vinfo;
}

/*
* EnumImageStringsW
*
* Purpose:
*
* Enumerate printable unicode strings in the given buffer.
*
*/
PSTRING_PTR EnumImageStringsW(
    _In_ PVOID heapHandle,
    _In_ PWCHAR buffer,
    _In_ ULONG sizeBytes
)
{
    if (heapHandle == NULL || buffer == NULL || sizeBytes < sizeof(WCHAR))
        return NULL;

    SIZE_T unitCount = sizeBytes / sizeof(WCHAR);
    PWCHAR p = buffer;
    PWCHAR end = buffer + unitCount;

    PSTRING_PTR head = NULL, last = NULL;

    while (p < end) {
        WCHAR c = *p;
        if (!IsWideStartChar(c)) {
            ++p;
            continue;
        }

        PWCHAR startPtr = p;
        SIZE_T len = 1;
        PWCHAR q = p + 1;
        while (q < end && len < IMGSCOPE_MAX_EXTRACTED_STR) {
            WCHAR cc = *q;
            if (!IsWideContinueChar(cc))
                break;
            ++q;
            ++len;
        }

        if (len > 2) {
            PSTRING_PTR node = RtlAllocateHeap(heapHandle, HEAP_ZERO_MEMORY, sizeof(STRING_PTR));
            if (node) {
                node->length = (ULONG)len;
                node->pnext = NULL;
                node->ofpstr = (ULONG)((ULONG_PTR)(startPtr - buffer) * sizeof(WCHAR));
                if (last)
                    last->pnext = node;
                else
                    head = node;
                last = node;
            }
        }

        p = (q > p) ? q : p + 1;
    }

    return head;
}

/*
* EnumImageStringsA
*
* Purpose:
*
* Enumerate printable ansi strings in the given buffer.
*
*/
PSTRING_PTR EnumImageStringsA(
    _In_ PVOID heapHandle,
    _In_ PCHAR buffer,
    _In_ ULONG size
)
{
    if (heapHandle == NULL || buffer == NULL || size == 0)
        return NULL;

    PCHAR p = buffer;
    PCHAR end = buffer + size;

    PSTRING_PTR head = NULL, last = NULL;

    while (p < end) {
        UCHAR c = (UCHAR)*p;
        if (!IsAnsiStartChar(c)) {
            ++p;
            continue;
        }

        PCHAR startPtr = p;
        SIZE_T len = 1;
        PCHAR q = p + 1;
        while (q < end && len < IMGSCOPE_MAX_EXTRACTED_STR) {
            UCHAR cc = (UCHAR)*q;
            if (!IsAnsiContinueChar(cc))
                break;
            ++q;
            ++len;
        }

        if (len > 2) {
            PSTRING_PTR node = RtlAllocateHeap(heapHandle, HEAP_ZERO_MEMORY, sizeof(STRING_PTR));
            if (node) {
                node->length = (ULONG)len;
                node->pnext = NULL;
                node->ofpstr = (ULONG)(startPtr - buffer);
                if (last)
                    last->pnext = node;
                else
                    head = node;
                last = node;
            }
        }

        p = (q > p) ? q : p + 1;
    }

    return head;
}

```

`Source/Plugins/ImageScope/query.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020
*
*  TITLE:       QUERY.H
*
*  VERSION:     1.00
*
*  DATE:        10 July 2020
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

typedef BOOL(CALLBACK* PEnumStringInfoCallback)(
    _In_ PWCHAR key,
    _In_ PWCHAR value,
    _In_ PWCHAR langid,
    _In_opt_ LPVOID cbparam);

typedef BOOL(CALLBACK* PEnumVarInfoCallback)(
    _In_ PWCHAR key,
    _In_ DWORD value,
    _In_opt_ LPVOID cbparam);

typedef struct _IMGVSHDR {
    WORD    wLength;
    WORD    wValueLength;
    WORD    wType;
} IMGVSHDR, * PIMGVSHDR;

typedef struct _IMGVSVERSIONINFO {
    IMGVSHDR    vshdr;
    WCHAR       wIdString[17];
} IMGVSVERSIONINFO, * PIMGVSVERSIONINFO;

typedef struct _IMGSTRINGINFO {
    IMGVSHDR    vshdr;
    WCHAR       wIdKey[15];
} IMGSTRINGINFO, * PIMGSTRINGINFO;

typedef struct _IMGVARINFO {
    IMGVSHDR    vshdr;
    WCHAR       wIdKey[13];
} IMGVARINFO, * PIMGVARINFO;

typedef struct _IMGSTRINGTABLE {
    IMGVSHDR    vshdr;
    WCHAR       wIdKey[9];
} IMGSTRINGTABLE, * PIMGSTRINGTABLE;

typedef struct _IMGVSTRING {
    IMGVSHDR    vshdr;
    WCHAR       szKey[1];
} IMGVSTRING, * PIMGVSTRING;

typedef struct _STRING_PTR {
    ULONG               ofpstr;
    ULONG               length;
    struct _STRING_PTR* pnext;
} STRING_PTR, * PSTRING_PTR;

VS_FIXEDFILEINFO* PEImageEnumVersionFields(
    _In_ HMODULE module,
    _In_ PEnumStringInfoCallback scallback,
    _In_opt_ PEnumVarInfoCallback vcallback,
    _Inout_opt_ PVOID cbparam);

PSTRING_PTR EnumImageStringsW(
    _In_ PVOID HeapHandle,
    _In_ PWCHAR Buffer,
    _In_ ULONG Size);

PSTRING_PTR EnumImageStringsA(
    _In_ PVOID HeapHandle,
    _In_ PCHAR Buffer,
    _In_ ULONG Size);

```

`Source/Plugins/ImageScope/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDD_TABDLG_SECTION              9
#define IDD_TABDLG_VSINFO               103
#define IDD_TABDLG_STRINGS              105
#define IDC_LIST                        1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/Plugins/ImageScope/ui.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       UI.C
*
*  VERSION:     1.22
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 ImageScope UI.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

INT_PTR CALLBACK TabsWndProc(
    _In_ HWND hWnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

static IMS_TAB imsTabs[] = {
    { IDD_TABDLG_SECTION, TabIdSection, TabsWndProc, TEXT("Section") },
    { IDD_TABDLG_VSINFO, TabIdVSInfo, TabsWndProc, TEXT("VersionInfo") },
    { IDD_TABDLG_STRINGS, TabIdStrings, TabsWndProc, TEXT("Strings") }
};

static VALUE_DESC peImageFileChars[] = {
    { TEXT("RelocsStripped"), IMAGE_FILE_RELOCS_STRIPPED },
    { TEXT("Executable"), IMAGE_FILE_EXECUTABLE_IMAGE },
    { TEXT("LineNumsStripped"), IMAGE_FILE_LINE_NUMS_STRIPPED },
    { TEXT("SymsStripped"), IMAGE_FILE_LOCAL_SYMS_STRIPPED },
    { TEXT("AggressiveWsTrim"), IMAGE_FILE_AGGRESIVE_WS_TRIM },
    { TEXT("LargeAddressAware"), IMAGE_FILE_LARGE_ADDRESS_AWARE },
    { TEXT("32bit"), IMAGE_FILE_32BIT_MACHINE },
    { TEXT("DebugStripped"), IMAGE_FILE_DEBUG_STRIPPED },
    { TEXT("RemovableRunFromSwap"), IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP },
    { TEXT("NetRunFromSwap"), IMAGE_FILE_NET_RUN_FROM_SWAP },
    { TEXT("System"), IMAGE_FILE_SYSTEM },
    { TEXT("Dll"), IMAGE_FILE_DLL },
    { TEXT("UpSystemOnly"), IMAGE_FILE_UP_SYSTEM_ONLY }
};

static VALUE_DESC peDllChars[] = {
    { TEXT("HighEntropyVA"), IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA },
    { TEXT("DynamicBase"), IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE },
    { TEXT("ForceIntegrity"), IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY },
    { TEXT("NXCompat"), IMAGE_DLLCHARACTERISTICS_NX_COMPAT },
    { TEXT("NoIsolation"), IMAGE_DLLCHARACTERISTICS_NO_ISOLATION },
    { TEXT("NoSEH"), IMAGE_DLLCHARACTERISTICS_NO_SEH },
    { TEXT("NoBind"), IMAGE_DLLCHARACTERISTICS_NO_BIND },
    { TEXT("AppContainer"), IMAGE_DLLCHARACTERISTICS_APPCONTAINER },
    { TEXT("WDMDriver"), IMAGE_DLLCHARACTERISTICS_WDM_DRIVER },
    { TEXT("GuardCF"), IMAGE_DLLCHARACTERISTICS_GUARD_CF },
    { TEXT("TerminalServerAware"), IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE }
};

typedef enum _ValueDumpType {
    UlongDump = 0,
    UShortDump,
    UCharDump,
    BooleanDump,
    InvalidDumpType
} ValueDumpType;

VOID SectionDumpUlong(
    _In_ HWND treeList,
    _In_ HTREEITEM rootItem,
    _In_ ULONG value,
    _In_ LPWSTR valueName,
    _In_opt_ LPWSTR valueDesc,
    _In_ ValueDumpType dumpType
)
{
    TL_SUBITEMS_FIXED subItems;
    LPWSTR lpFormat;
    WCHAR szText[PRINTF_BUFFER_LENGTH];

    RtlSecureZeroMemory(&subItems, sizeof(subItems));
    szText[0] = 0;
    subItems.Count = 2;
    subItems.Text[0] = szText;

    if (valueDesc)
        subItems.Text[1] = valueDesc;
    else
        subItems.Text[1] = EMPTY_STRING;

    switch (dumpType) {
    case UShortDump:
        lpFormat = TEXT("0x%hX");
        break;
    case UCharDump:
        lpFormat = TEXT("0x%02X");
        break;
    case BooleanDump:
        lpFormat = TEXT("%01u");
        break;
    case UlongDump:
    default:
        lpFormat = TEXT("0x%08lX");
        break;
    }

    StringCchPrintf(
        szText,
        PRINTF_BUFFER_LENGTH,
        lpFormat,
        value);

    supTreeListAddItem(
        treeList,
        rootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        valueName,
        &subItems);
}

VOID SectionDumpFlags(
    _In_ HWND treeList,
    _In_ HTREEITEM rootItem,
    _In_ ULONG flags,
    _In_ PVALUE_DESC flagsDescriptions,
    _In_ ULONG maxDescriptions,
    _In_ LPWSTR valueName,
    _In_ ValueDumpType dumpType
)
{
    UINT i, j;
    LPWSTR lpType;
    ULONG scanFlags = flags;
    TL_SUBITEMS_FIXED subItems;

    WCHAR szValue[PRINTF_BUFFER_LENGTH];

    RtlSecureZeroMemory(&szValue, sizeof(szValue));
    RtlSecureZeroMemory(&subItems, sizeof(subItems));

    j = 0;
    lpType = NULL;
    if (scanFlags) {
        for (i = 0; i < maxDescriptions; i++) {
            if (scanFlags & flagsDescriptions[i].dwValue) {
                lpType = flagsDescriptions[i].lpDescription;
                subItems.Count = 2;

                //add first entry with name
                if (j == 0) {
                    StringCchPrintf(szValue, PRINTF_BUFFER_LENGTH,
                        TEXT("0x%08lX"), scanFlags);

                    subItems.Text[0] = szValue;
                    subItems.Text[1] = lpType;
                }
                else {
                    //add subentry
                    subItems.Text[0] = EMPTY_STRING;
                    subItems.Text[1] = lpType;
                }

                supTreeListAddItem(
                    treeList,
                    rootItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    0,
                    (j == 0) ? valueName : EMPTY_STRING,
                    &subItems);

                scanFlags &= ~flagsDescriptions[i].dwValue;
                j++;
            }
            if (scanFlags == 0) {
                break;
            }
        }
    }
    else {
        SectionDumpUlong(treeList, rootItem, flags, valueName, NULL, dumpType);
    }
}

VOID SectionDumpUnicodeString(
    _In_ HWND treeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR stringName,
    _In_ PUNICODE_STRING pString,
    _In_ DWORD itemState,
    _In_ DWORD stateMask
)
{
    HTREEITEM           hSubItem;
    TL_SUBITEMS_FIXED   subItems;
    WCHAR               szValue[PRINTF_BUFFER_LENGTH];

    RtlSecureZeroMemory(&subItems, sizeof(subItems));
    subItems.Count = 2;

    subItems.Text[0] = EMPTY_STRING;
    subItems.Text[1] = TEXT("UNICODE_STRING");

    hSubItem = supTreeListAddItem(
        treeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        itemState,
        stateMask,
        stringName,
        &subItems);

    //
    // Add UNICODE_STRING.Length
    //
    RtlSecureZeroMemory(&subItems, sizeof(subItems));
    RtlSecureZeroMemory(szValue, sizeof(szValue));

    StringCchPrintf(
        szValue,
        RTL_NUMBER_OF(szValue),
        TEXT("0x%hX"),
        pString->Length);

    subItems.Count = 2;
    subItems.Text[0] = szValue;
    subItems.Text[1] = EMPTY_STRING;

    supTreeListAddItem(
        treeList,
        hSubItem,
        TVIF_TEXT,
        0,
        0,
        TEXT("Length"),
        &subItems);

    //
    // Add UNICODE_STRING.MaximumLength
    //
    RtlSecureZeroMemory(szValue, sizeof(szValue));
    RtlSecureZeroMemory(&subItems, sizeof(subItems));

    StringCchPrintf(
        szValue,
        RTL_NUMBER_OF(szValue),
        TEXT("0x%hX"),
        pString->MaximumLength);

    subItems.Count = 2;
    subItems.Text[0] = szValue;
    subItems.Text[1] = EMPTY_STRING;

    supTreeListAddItem(
        treeList,
        hSubItem,
        TVIF_TEXT,
        0,
        0,
        TEXT("MaximumLength"),
        &subItems);

    //
    // Add UNICODE_STRING.Buffer
    //
    RtlSecureZeroMemory(&subItems, sizeof(subItems));
    subItems.Count = 2;

    if (pString->Buffer == NULL) {
        subItems.Text[0] = TEXT("NULL");
        subItems.Text[1] = EMPTY_STRING;
    }
    else {
        RtlSecureZeroMemory(&szValue, sizeof(szValue));
        szValue[0] = TEXT('0');
        szValue[1] = TEXT('x');
        u64tohex((ULONG_PTR)pString->Buffer, &szValue[2]);
        subItems.Text[0] = szValue;
        subItems.Text[1] = pString->Buffer;
    }

    supTreeListAddItem(
        treeList,
        hSubItem,
        TVIF_TEXT,
        0,
        0,
        TEXT("Buffer"),
        &subItems);
}

VOID SectionDumpImageFileName(
    _In_ GUI_CONTEXT* context
)
{
    OBJECT_NAME_INFORMATION* objectNameInfo = NULL;
    PVOID baseAddress = context->SectionAddress;
    NTSTATUS ntStatus;
    SIZE_T returnedLength = 0;
    HTREEITEM tviRoot;

    do {
        ntStatus = NtQueryVirtualMemory(
            NtCurrentProcess(),
            baseAddress,
            MemoryMappedFilenameInformation,
            NULL,
            0,
            &returnedLength);

        if (ntStatus != STATUS_INFO_LENGTH_MISMATCH)
            break;

        //
        // Allocate required buffer.
        //      
        objectNameInfo = (OBJECT_NAME_INFORMATION*)supHeapAlloc(returnedLength);
        if (objectNameInfo == NULL)
            break;

        //
        // Query information.
        //
        ntStatus = NtQueryVirtualMemory(
            NtCurrentProcess(),
            baseAddress,
            MemoryMappedFilenameInformation,
            objectNameInfo,
            returnedLength,
            &returnedLength);

        if (NT_SUCCESS(ntStatus)) {
            tviRoot = supTreeListAddItem(
                context->TreeList,
                NULL,
                TVIF_TEXT | TVIF_STATE,
                (UINT)TVIS_EXPANDED,
                (UINT)TVIS_EXPANDED,
                TEXT("OBJECT_NAME_INFORMATION"),
                NULL);

            if (tviRoot) {
                SectionDumpUnicodeString(
                    context->TreeList,
                    tviRoot,
                    TEXT("Name"),
                    &objectNameInfo->Name,
                    TVIS_EXPANDED,
                    TVIS_EXPANDED);
            }
        }
    } while (FALSE);

    if (objectNameInfo)
        supHeapFree(objectNameInfo);
}

VOID SectionDumpStructs(
    _In_ GUI_CONTEXT* context
)
{
    BOOL bInternalPresent = FALSE;
    SECTION_IMAGE_INFORMATION sii;
    SECTION_INTERNAL_IMAGE_INFORMATION sii2;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE sectionHandle = NULL;
    SIZE_T returnLength;

    WCHAR szText[PRINTF_BUFFER_LENGTH];

    LPWSTR lpDesc;
    HTREEITEM tviRoot;
    TL_SUBITEMS_FIXED subItems;

    __try {
        ntStatus = context->ParamBlock.OpenNamedObjectByType(
            &sectionHandle,
            ObjectTypeSection,
            &context->ParamBlock.Object.Directory,
            &context->ParamBlock.Object.Name,
            SECTION_QUERY);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        ntStatus = NtQuerySection(
            sectionHandle,
            SectionImageInformation,
            &sii,
            sizeof(SECTION_IMAGE_INFORMATION),
            &returnLength);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        bInternalPresent = NT_SUCCESS(NtQuerySection(
            sectionHandle,
            SectionInternalImageInformation,
            &sii2,
            sizeof(SECTION_INTERNAL_IMAGE_INFORMATION),
            &returnLength));

        NtClose(sectionHandle);
        sectionHandle = NULL;

        tviRoot = supTreeListAddItem(
            context->TreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            (UINT)TVIS_EXPANDED,
            (UINT)TVIS_EXPANDED,
            TEXT("SECTION_IMAGE_INFORMATION"),
            NULL);

        if (tviRoot) {
            RtlSecureZeroMemory(&subItems, sizeof(subItems));
            szText[0] = 0;
            subItems.Count = 2;
            subItems.Text[0] = szText;
            subItems.Text[1] = EMPTY_STRING;

            StringCchPrintf(szText, PRINTF_BUFFER_LENGTH, TEXT("0x%p"), sii.TransferAddress);
            supTreeListAddItem(
                context->TreeList,
                tviRoot,
                TVIF_TEXT | TVIF_STATE,
                (UINT)0,
                (UINT)0,
                TEXT("TransferAddress"),
                &subItems);

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.ZeroBits, TEXT("ZeroBits"), NULL, UlongDump);

            StringCchPrintf(szText, PRINTF_BUFFER_LENGTH, TEXT("0x%I64X"), sii.MaximumStackSize);
            supTreeListAddItem(
                context->TreeList,
                tviRoot,
                TVIF_TEXT | TVIF_STATE,
                (UINT)0,
                (UINT)0,
                TEXT("MaximumStackSize"),
                &subItems);

            StringCchPrintf(szText, PRINTF_BUFFER_LENGTH, TEXT("0x%I64X"), sii.CommittedStackSize);
            supTreeListAddItem(
                context->TreeList,
                tviRoot,
                TVIF_TEXT | TVIF_STATE,
                (UINT)0,
                (UINT)0,
                TEXT("CommittedStackSize"),
                &subItems);

            switch (sii.SubSystemType) {
            case IMAGE_SUBSYSTEM_NATIVE:
                lpDesc = TEXT("Native");
                break;
            case IMAGE_SUBSYSTEM_WINDOWS_GUI:
                lpDesc = TEXT("Windows GUI");
                break;
            case IMAGE_SUBSYSTEM_WINDOWS_CUI:
                lpDesc = TEXT("Windows Console");
                break;
            case IMAGE_SUBSYSTEM_OS2_CUI:
                lpDesc = TEXT("OS/2 Console");
                break;
            case IMAGE_SUBSYSTEM_POSIX_CUI:
                lpDesc = TEXT("Posix Console");
                break;
            case IMAGE_SUBSYSTEM_XBOX:
                lpDesc = TEXT("XBox");
                break;
            case IMAGE_SUBSYSTEM_EFI_APPLICATION:
                lpDesc = TEXT("EFI Application");
                break;
            case IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
                lpDesc = TEXT("EFI Boot Service Driver");
                break;
            case IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
                lpDesc = TEXT("EFI Runtime Driver");
                break;
            case IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION:
                lpDesc = TEXT("Windows Boot Application");
                break;
            case IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG:
                lpDesc = TEXT("XBox Code Catalog");
                break;
            default:
                lpDesc = TEXT("Unknown");
                break;
            }

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.SubSystemType, TEXT("SubSystemType"), lpDesc, UlongDump);

            StringCchPrintf(
                szText,
                PRINTF_BUFFER_LENGTH,
                TEXT("%hu.%hu"),
                sii.SubSystemMajorVersion,
                sii.SubSystemMinorVersion);

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.SubSystemVersion, TEXT("SubSystemVersion"), szText, UlongDump);

            StringCchPrintf(
                szText,
                PRINTF_BUFFER_LENGTH,
                TEXT("%hu.%hu"),
                sii.MajorOperatingSystemVersion,
                sii.MinorOperatingSystemVersion);

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.OperatingSystemVersion, TEXT("OperatingSystemVersion"), szText, UlongDump);

            SectionDumpFlags(context->TreeList, tviRoot,
                sii.ImageCharacteristics,
                peImageFileChars,
                RTL_NUMBER_OF(peImageFileChars),
                TEXT("ImageCharacteristics"),
                UShortDump);

            SectionDumpFlags(context->TreeList, tviRoot,
                sii.DllCharacteristics,
                peDllChars,
                RTL_NUMBER_OF(peDllChars),
                TEXT("DllCharacteristics"),
                UShortDump);

            switch (sii.Machine) {
            case IMAGE_FILE_MACHINE_I386:
                lpDesc = TEXT("Intel386");
                break;
            case IMAGE_FILE_MACHINE_AMD64:
                lpDesc = TEXT("AMD64");
                break;
            default:
                lpDesc = TEXT("Unknown/Unsupported Machine");
                break;
            }

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.Machine, TEXT("Machine"), lpDesc, UShortDump);

            SectionDumpUlong(context->TreeList, tviRoot,
                (ULONG)sii.ImageContainsCode, TEXT("ImageContainsCode"), NULL, BooleanDump);

            SectionDumpUlong(context->TreeList, tviRoot,
                (ULONG)sii.ImageFlags, TEXT("ImageFlags"), NULL, UCharDump);

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.LoaderFlags, TEXT("LoaderFlags"), NULL, UlongDump);

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.ImageFileSize, TEXT("ImageFileSize"), NULL, UlongDump);

            SectionDumpUlong(context->TreeList, tviRoot,
                sii.CheckSum, TEXT("CheckSum"), NULL, UlongDump);
        }

        SectionDumpImageFileName(context);

        if (bInternalPresent == FALSE)
            __leave;

        tviRoot = supTreeListAddItem(
            context->TreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            (UINT)TVIS_EXPANDED,
            (UINT)TVIS_EXPANDED,
            TEXT("SECTION_INTERNAL_IMAGE_INFORMATION"),
            NULL);

        if (tviRoot) {
            SectionDumpUlong(context->TreeList, tviRoot,
                sii2.ExtendedFlags, TEXT("ExtendedFlags"), NULL, UlongDump);
        }
    }
    __finally {
        if (sectionHandle)
            NtClose(sectionHandle);

        if (!NT_SUCCESS(ntStatus)) {
            StringCchPrintf(szText,
                _countof(szText),
                TEXT("Query status 0x%lx"), ntStatus);
        }
        else {
            _strcpy(szText, TEXT("Query - OK"));
        }

        supStatusBarSetText(
            context->StatusBar,
            0,
            szText);
    }
}

/*
* VsInfoStringsEnumCallback
*
* Purpose:
*
* VERSION_INFO enumeration callback.
*
*/
BOOL CALLBACK VsInfoStringsEnumCallback(
    _In_ PWCHAR key,
    _In_ PWCHAR value,
    _In_ PWCHAR langId,
    _In_opt_ LPVOID cbparam
)
{
    LV_ITEM lvItem;
    INT itemIndex;
    HWND hwndList = (HWND)cbparam;
    WCHAR szLangId[128];

    if (hwndList == 0)
        return 0;

    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = key;
    lvItem.iItem = MAXINT;
    itemIndex = ListView_InsertItem(hwndList, &lvItem);

    lvItem.iSubItem = 1;
    lvItem.pszText = value;
    lvItem.iItem = itemIndex;
    ListView_SetItem(hwndList, &lvItem);

    szLangId[0] = 0;
    StringCchPrintf(szLangId, _countof(szLangId), TEXT("0x%ws"), langId);

    lvItem.iSubItem = 2;
    lvItem.pszText = szLangId;
    lvItem.iItem = itemIndex;
    ListView_SetItem(hwndList, &lvItem);

    return TRUE; // continue enum
}

/*
* VsInfoTabOnInit
*
* Purpose:
*
* Initialize VersionInfo tab dialog page.
*
*/
VOID VsInfoTabOnInit(
    _In_ HWND hWndDlg,
    _In_ GUI_CONTEXT* context
)
{
    WCHAR szText[100];
    HWND hwndList = GetDlgItem(hWndDlg, IDC_LIST);

    supAddListViewColumn(hwndList,
        0,
        0,
        0,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("Name"),
        120,
        context->CurrentDPI);

    supAddListViewColumn(hwndList,
        1,
        1,
        1,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("Value"),
        300,
        context->CurrentDPI);

    supAddListViewColumn(hwndList,
        2,
        2,
        2,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("LangId"),
        100,
        context->CurrentDPI);

    ListView_SetExtendedListViewStyle(hwndList,
        LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_DOUBLEBUFFER);

    SetWindowTheme(hwndList, TEXT("Explorer"), NULL);

    SendMessage(hwndList, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);

    if (PEImageEnumVersionFields(
        context->SectionAddress,
        &VsInfoStringsEnumCallback,
        NULL,
        (LPVOID)hwndList))
    {
        StringCchCopy(szText, _countof(szText), TEXT("Query - OK"));
    }
    else {
        StringCchPrintf(
            szText,
            _countof(szText),
            TEXT("Query Error 0x%lx"), GetLastError());
    }

    SendMessage(hwndList, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);

    supStatusBarSetText(
        context->StatusBar,
        0,
        szText);
}

/*
* SectionTabOnInit
*
* Purpose:
*
* Initialize Section tab dialog page.
*
*/
VOID SectionTabOnInit(
    _In_ HWND hWndDlg,
    _In_ GUI_CONTEXT* context
)
{
    RECT rc;
    HWND hwndList;
    HDITEM hdrItem;

    GetClientRect(hWndDlg, &rc);

    TabCtrl_AdjustRect(context->TabHeader->hwndTab, FALSE, &rc);

    hwndList = CreateWindowEx(WS_EX_STATICEDGE, WC_TREELIST, NULL,
        WS_VISIBLE | WS_CHILD | WS_TABSTOP | TLSTYLE_COLAUTOEXPAND | TLSTYLE_LINKLINES,
        rc.left,
        rc.top,
        rc.right,
        rc.bottom,
        hWndDlg, NULL, NULL, NULL);

    if (hwndList) {
        RtlSecureZeroMemory(&hdrItem, sizeof(hdrItem));
        hdrItem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
        hdrItem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;
        hdrItem.cxy = ScaleDPI(220, context->CurrentDPI);
        hdrItem.pszText = TEXT("Field");
        TreeList_InsertHeaderItem(hwndList, 0, &hdrItem);
        hdrItem.cxy = ScaleDPI(130, context->CurrentDPI);
        hdrItem.pszText = TEXT("Value");
        TreeList_InsertHeaderItem(hwndList, 1, &hdrItem);
        hdrItem.cxy = ScaleDPI(210, context->CurrentDPI);
        hdrItem.pszText = TEXT("Additional Information");
        TreeList_InsertHeaderItem(hwndList, 2, &hdrItem);

        context->TreeList = hwndList;
        SectionDumpStructs(context);
    }
}

#pragma warning(push)
#pragma warning(disable: 6262)
UINT AddStringsToList(
    _In_ HWND hWndDlg,
    _In_ PVOID baseAddress,
    _In_ PSTRING_PTR chainHead,
    _In_ BOOLEAN isUnicode
)
{
    INT nLength, iItem;
    UINT stringCount = 0;
    PSTRING_PTR chain = chainHead;
    HWND hwndList = GetDlgItem(hWndDlg, IDC_LIST);
    LV_ITEM lvItem;
    WCHAR szBuffer[UNICODE_STRING_MAX_CHARS];

    RtlZeroMemory(szBuffer, sizeof(szBuffer));

    lvItem.mask = LVIF_TEXT;

    while (chain) {
        if (isUnicode) {
            _strncpy(szBuffer,
                UNICODE_STRING_MAX_CHARS,
                (PWCHAR)RtlOffsetToPointer(baseAddress, chain->ofpstr),
                chain->length);

            nLength = chain->length;
        }
        else {
            nLength = MultiByteToWideChar(CP_ACP, 0,
                (PCHAR)RtlOffsetToPointer(baseAddress, chain->ofpstr),
                chain->length,
                szBuffer,
                UNICODE_STRING_MAX_CHARS);

            if (nLength)
                szBuffer[nLength] = 0;
        }

        if (nLength) {
            lvItem.pszText = szBuffer;
            lvItem.iItem = INT_MAX;
            lvItem.iSubItem = 0;
            iItem = ListView_InsertItem(hwndList, &lvItem);

            lvItem.pszText = (isUnicode) ? TEXT("U") : TEXT("A");
            lvItem.iSubItem = 1;
            lvItem.iItem = iItem;
            ListView_SetItem(hwndList, &lvItem);

            stringCount++;
        }

        chain = chain->pnext;
    }

    return stringCount;
}
#pragma warning(pop)

VOID ScanRegions(
    _In_ HWND hWndDlg,
    _In_ HANDLE scanHeap,
    _In_ GUI_CONTEXT* context
)
{
    ULONG cAnsi = 0;
    ULONG cUnicode = 0;

    NTSTATUS ntStatus;
    SIZE_T totalLength = context->SectionViewSize, curPos = 0, dummy;
    PVOID baseAddress = context->SectionAddress;
    PSTRING_PTR chain = NULL;
    MEMORY_BASIC_INFORMATION mbi;
    WCHAR szBuffer[100];

    RtlZeroMemory(&mbi, sizeof(mbi));

    do {
        ntStatus = NtQueryVirtualMemory(
            NtCurrentProcess(),
            baseAddress,
            MemoryBasicInformation,
            &mbi,
            sizeof(mbi),
            &dummy);

        if (NT_SUCCESS(ntStatus)) {
            curPos += mbi.RegionSize;

            if (mbi.State & MEM_COMMIT) {
                if (!(mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS))) {
                    if (mbi.Protect & (PAGE_READONLY |
                        PAGE_READWRITE |
                        PAGE_EXECUTE |
                        PAGE_EXECUTE_READ |
                        PAGE_EXECUTE_READWRITE))
                    {
                        chain = EnumImageStringsA(
                            scanHeap,
                            baseAddress,
                            (ULONG)mbi.RegionSize);

                        if (chain) {
                            cAnsi += AddStringsToList(
                                hWndDlg,
                                baseAddress,
                                chain,
                                FALSE);
                        }

                        chain = EnumImageStringsW(
                            scanHeap,
                            baseAddress,
                            (ULONG)mbi.RegionSize);

                        if (chain) {
                            cUnicode += AddStringsToList(
                                hWndDlg,
                                baseAddress,
                                chain,
                                TRUE);
                        }
                    }
                }
            }
        }
        else {
            curPos += PAGE_SIZE;
        }

        baseAddress = RtlOffsetToPointer(context->SectionAddress, curPos);

    } while (curPos < totalLength);

    StringCchPrintf(
        szBuffer,
        _countof(szBuffer),
        TEXT("Strings: %lu (A: %lu, U: %lu)"),
        cAnsi + cUnicode,
        cAnsi, cUnicode);

    supStatusBarSetText(
        context->StatusBar,
        0,
        szBuffer);
}

/*
* StringsTabOnShow
*
* Purpose:
*
* Strings page WM_SHOWWINDOW handler.
*
*/
VOID StringsTabOnShow(
    _In_ HWND hWndDlg,
    _In_ GUI_CONTEXT* context
)
{
    PVOID heapHandle = NULL;
    HWND hwndList = GetDlgItem(hWndDlg, IDC_LIST);

    __try {
        SendMessage(hwndList, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);
        supSetWaitCursor(TRUE);

        heapHandle = HeapCreate(0, UNICODE_STRING_MAX_CHARS * sizeof(WCHAR), 0);
        if (heapHandle) {
            ScanRegions(
                hWndDlg,
                heapHandle,
                context);

            HeapDestroy(heapHandle);
            heapHandle = NULL;
        }
    }
    __finally {
        SendMessage(hwndList, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
        supSetWaitCursor(FALSE);
        if (heapHandle)
            HeapDestroy(heapHandle);
    }
}

/*
* StringsTabOnInit
*
* Purpose:
*
* Initialize Strings tab page dialog.
*
*/
VOID StringsTabOnInit(
    _In_ HWND hWndDlg,
    _In_ GUI_CONTEXT* context
)
{
    HWND hwndList = GetDlgItem(hWndDlg, IDC_LIST);

    if (hwndList) {
        supAddListViewColumn(hwndList,
            0,
            0,
            0,
            I_IMAGENONE,
            LVCFMT_LEFT,
            TEXT("String"),
            MAX_PATH,
            context->CurrentDPI);

        supAddListViewColumn(hwndList,
            1,
            1,
            1,
            I_IMAGENONE,
            LVCFMT_CENTER,
            TEXT("Type"),
            80,
            context->CurrentDPI);

        ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER);
        SetWindowTheme(hwndList, TEXT("Explorer"), NULL);
    }
}

/*
* TabOnInit
*
* Purpose:
*
* Tab window WM_INITDIALOG handler.
*
*/
VOID TabOnInit(
    _In_ HWND hWndDlg,
    _In_ GUI_CONTEXT* context
)
{
    INT iSel;

    if (context == NULL)
        return;

    iSel = TabCtrl_GetCurSel(context->TabHeader->hwndTab);

    switch (iSel) {
    case TabIdSection:
        SectionTabOnInit(hWndDlg, context);
        break;
    case TabIdVSInfo:
        VsInfoTabOnInit(hWndDlg, context);
        break;
    case TabIdStrings:
        StringsTabOnInit(hWndDlg, context);
        break;
    default:
        break;
    }
}

/*
* TabOnShow
*
* Purpose:
*
* Tab window WM_SHOWWINDOW handler.
*
*/
INT_PTR TabOnShow(
    _In_ HWND hWndDlg,
    _In_ BOOL fShow
)
{
    INT iSel;
    GUI_CONTEXT* context = GetProp(hWndDlg, T_IMS_PROP);

    if (context == NULL)
        return 0;

    iSel = TabCtrl_GetCurSel(context->TabHeader->hwndTab);

    switch (iSel) {
    case TabIdStrings:
        if (fShow)
            StringsTabOnShow(hWndDlg, context);
        break;
    default:
        break;
    }

    return 1;
}

/*
* TabsOnContextMenu
*
* Purpose:
*
* Tab control WM_CONTEXTMENU handler.
*
*/
VOID TabsOnContextMenu(
    _In_ HWND hWndDlg
)
{
    INT iSel;
    UINT uPos = 0;
    POINT pt1;
    HMENU hMenu;
    GUI_CONTEXT* context = GetProp(hWndDlg, T_IMS_PROP);

    if (context == NULL)
        return;

    iSel = TabCtrl_GetCurSel(context->TabHeader->hwndTab);

    switch (iSel) {
    case TabIdVSInfo:
    case TabIdStrings:
        if (GetCursorPos(&pt1)) {
            hMenu = CreatePopupMenu();
            if (hMenu) {
                //
                // Add "Copy %item%" menu item.
                //
                if (supListViewAddCopyValueItem(hMenu,
                    GetDlgItem(hWndDlg, IDC_LIST),
                    ID_MENU_LIST_COPY,
                    uPos,
                    &pt1,
                    &context->LvItemHit,
                    &context->LvColumnHit))
                {
                    uPos++;
                    InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
                }

                InsertMenu(hMenu, uPos, MF_BYCOMMAND, ID_MENU_LIST_DUMP, T_EXPORTTOFILE);
                TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, pt1.x, pt1.y, 0, hWndDlg, NULL);
                DestroyMenu(hMenu);
            }
        }
        break;
    default:
        break;
    }
}

VOID TabsDumpList(
    _In_ HWND hWndDlg
)
{
    INT iSel;
    LPWSTR lpFileName;
    GUI_CONTEXT* context = GetProp(hWndDlg, T_IMS_PROP);
    HWND hwndList = GetDlgItem(hWndDlg, IDC_LIST);

    if (context == NULL)
        return;

    iSel = TabCtrl_GetCurSel(context->TabHeader->hwndTab);

    switch (iSel) {
    case TabIdVSInfo:
        lpFileName = TEXT("VersionInfo.csv");
        break;
    case TabIdStrings:
        lpFileName = TEXT("Strings.csv");
        break;
    default:
        return;
    }

    supListViewExportToFile(lpFileName, hWndDlg, hwndList, T_CSV_FILE_FILTER);
}

VOID TabsListViewCopyItem(
    _In_ HWND hWndDlg
)
{
    GUI_CONTEXT* context = GetProp(hWndDlg, T_IMS_PROP);

    if (context) {
        supListViewCopyItemValueToClipboard(GetDlgItem(hWndDlg, IDC_LIST),
            context->LvItemHit,
            context->LvColumnHit);
    }
}

/*
* TabsWndProc
*
* Purpose:
*
* Tab control window handler.
*
*/
INT_PTR CALLBACK TabsWndProc(
    _In_ HWND hWnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        SetProp(hWnd, T_IMS_PROP, (HANDLE)lParam);
        TabOnInit(hWnd, (GUI_CONTEXT*)lParam);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case ID_MENU_LIST_DUMP:
            TabsDumpList(hWnd);
            break;

        case ID_MENU_LIST_COPY:
            TabsListViewCopyItem(hWnd);
            break;

        default:
            break;
        }
        break;

    case WM_CONTEXTMENU:
        TabsOnContextMenu(hWnd);
        break;

    case WM_SHOWWINDOW:
        return TabOnShow(hWnd, (wParam != 0));

    case WM_DESTROY:
        RemoveProp(hWnd, T_IMS_PROP);
        break;

    default:
        return 0;
    }

    return 1;
}

/*
* OnTabResize
*
* Purpose:
*
* Tab window WM_RESIZE handler.
*
*/
VOID CALLBACK OnTabResize(
    _In_ TABHDR* tabHeader
)
{
    RECT hwndRect;
    INT iSel;
    HWND hwndList = 0;
    GUI_CONTEXT* context;

    context = (GUI_CONTEXT*)GetProp(tabHeader->hwndDisplay, T_IMS_PROP);
    if (context == NULL)
        return;

    iSel = TabCtrl_GetCurSel(tabHeader->hwndTab);
    GetClientRect(tabHeader->hwndDisplay, &hwndRect);

    switch (iSel) {
    case TabIdSection:
        hwndList = context->TreeList;
        break;

    case TabIdVSInfo:
    case TabIdStrings:
        hwndList = GetDlgItem(tabHeader->hwndDisplay, IDC_LIST);
        break;

    default:
        return;
    }

    if (hwndList == NULL)
        return;

    GetClientRect(tabHeader->hwndDisplay, &hwndRect);

    TabCtrl_AdjustRect(tabHeader->hwndTab, FALSE, &hwndRect);

    SetWindowPos(hwndList,
        HWND_TOP,
        0,
        0,
        hwndRect.right,
        hwndRect.bottom,
        SWP_NOOWNERZORDER);
}

/*
* OnResize
*
* Purpose:
*
* WM_SIZE handler.
*
*/
VOID OnResize(
    _In_ HWND hWnd
)
{
    GUI_CONTEXT* context;
    RECT r, szr;

    context = (GUI_CONTEXT*)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    if (context) {
        SendMessage(context->StatusBar, WM_SIZE, 0, 0);

        GetClientRect(hWnd, &r);
        GetClientRect(context->StatusBar, &szr);

        //resize of the tab control
        if (context->TabHeader != NULL) {
            SetWindowPos(
                context->TabHeader->hwndTab,
                HWND_TOP,
                0,
                0,
                r.right,
                r.bottom - szr.bottom,
                SWP_NOACTIVATE | SWP_NOZORDER);

            TabResizeTabWindow(context->TabHeader);
        }
    }
}

/*
* OnNotify
*
* Purpose:
*
* WM_NOTIFY handler.
*
*/
VOID OnNotify(
    _In_ HWND hWnd,
    _In_ LPNMHDR nmhdr
)
{
    GUI_CONTEXT* context;

    if (InterlockedAdd((PLONG)&g_pluginState, PLUGIN_RUNNING) == PLUGIN_STOP)
        return;

    context = (GUI_CONTEXT*)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    if (context) {
        TabOnChangeTab(context->TabHeader, nmhdr);
    }
}

VOID OnGetMinMax(
    _In_ HWND hWnd,
    _In_ PMINMAXINFO mmInfo
)
{
    GUI_CONTEXT* context;
    context = (GUI_CONTEXT*)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    if (context) {
        mmInfo->ptMinTrackSize.x = ScaleDPI(640, context->CurrentDPI);
        mmInfo->ptMinTrackSize.y = ScaleDPI(480, context->CurrentDPI);
    }
}

/*
* MainWindowProc
*
* Purpose:
*
* Main window procedure.
*
*/
LRESULT CALLBACK MainWindowProc(
    _In_ HWND hWnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    switch (uMsg) {
    case WM_CLOSE:
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        OnResize(hWnd);
        break;

    case WM_NOTIFY:
        OnNotify(hWnd, (LPNMHDR)lParam);
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            OnGetMinMax(hWnd, (PMINMAXINFO)lParam);
        }
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

/*
* RunUI
*
* Purpose:
*
* Create main window, run message loop.
*
*/
BOOL RunUI(
    _In_ GUI_CONTEXT* context
)
{
    INT i;
    INITCOMMONCONTROLSEX icex;

    BOOL rv;
    MSG msg1;
    LPWSTR lpTitle;
    WCHAR szClassName[100];

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_BAR_CLASSES | ICC_TAB_CLASSES;
    InitCommonControlsEx(&icex);

#pragma warning(push)
#pragma warning(disable: 6031)
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
#pragma warning(pop)

    context->CurrentDPI = context->ParamBlock.CurrentDPI;

    context->LvColumnHit = -1;
    context->LvItemHit = -1;

    //
    // Window class once.
    //
    StringCchPrintf(szClassName,
        RTL_NUMBER_OF(szClassName),
        TEXT("%wsWndClass"),
        g_plugin->Name);

    lpTitle = IMAGESCOPE_WNDTITLE;

    //
    // Create main window.
    //
    context->MainWindow = CreateWindowEx(
        0,
        szClassName,
        lpTitle,
        WS_VISIBLE | WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        ScaleDPI(640, context->CurrentDPI),
        ScaleDPI(480, context->CurrentDPI),
        NULL,
        NULL,
        g_thisDll,
        NULL);

    if (context->MainWindow == 0) {
        kdDebugPrint("Could not create main window, err = %lu\r\n", GetLastError());
        return FALSE;
    }

    SetWindowLongPtr(context->MainWindow, GWLP_USERDATA, (LONG_PTR)context);

    //
    // Status Bar window.
    //
    context->StatusBar = CreateWindowEx(
        0,
        STATUSCLASSNAME,
        NULL,
        WS_VISIBLE | WS_CHILD,
        0,
        0,
        0,
        0,
        context->MainWindow,
        NULL,
        g_thisDll,
        NULL);

    if (context->StatusBar == 0) {
        kdDebugPrint("Could not create statusbar window, err = %lu\r\n", GetLastError());
        return FALSE;
    }

    context->TabHeader = TabCreateControl(
        g_thisDll,
        context->MainWindow,
        NULL,
        NULL,
        (TABRESIZECALLBACK)&OnTabResize,
        (TABCALLBACK_ALLOCMEM)&supHeapAlloc,
        (TABCALLBACK_FREEMEM)&supHeapFree);

    if (context->TabHeader == NULL) {
        kdDebugPrint("Could not create tabcontrol window\r\n");
        return FALSE;
    }

    for (i = 0; i < _countof(imsTabs); i++) {
        TabAddPage(context->TabHeader,
            imsTabs[i].ResourceId,
            imsTabs[i].WndProc,
            imsTabs[i].TabCaption,
            I_IMAGENONE,
            (LPARAM)context);
    }

    TabOnSelChanged(context->TabHeader);

    // call resize
    SendMessage(context->MainWindow, WM_SIZE, 0, 0);

    do {
        rv = GetMessage(&msg1, NULL, 0, 0);

        if (rv == -1)
            break;

        TranslateMessage(&msg1);
        DispatchMessage(&msg1);

    } while (rv != 0 && InterlockedCompareExchange((PLONG)&g_pluginState, 0, 0) == PLUGIN_RUNNING);

    TabDestroyControl(context->TabHeader);
    DestroyWindow(context->MainWindow);

    return TRUE;
}

```

`Source/Plugins/ImageScope/ui.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       UI.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 ImageScope UI constants, definitions and includes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "uxtheme.lib")

#define T_PLUGIN_NAME       TEXT("ImageScope")
#define IMAGESCOPE_WNDTITLE T_PLUGIN_NAME
#define T_IMS_PROP          TEXT("ImsProp")

#define EMPTY_STRING        TEXT("")
#define T_EXPORTTOFILE      TEXT("Export List to File")
#define T_CSV_FILE_FILTER   TEXT("CSV Files\0*.csv\0\0")

#define PRINTF_BUFFER_LENGTH 100

#define ID_MENU_LIST_DUMP     49001
#define ID_MENU_LIST_COPY     49002

typedef struct _GUI_CONTEXT {
    UINT CurrentDPI;

    INT LvItemHit;
    INT LvColumnHit;

    HWND MainWindow;
    HWND StatusBar;
    HWND TreeList;
    HANDLE WorkerThread;
    PVOID SectionAddress;
    SIZE_T SectionViewSize;

    TABHDR* TabHeader;

    //
    // WinObjEx64 data and pointers.
    //
    WINOBJEX_PARAM_BLOCK ParamBlock;
} GUI_CONTEXT, * PGUI_CONTEXT;

#define IDC_TAB 8086

typedef enum _IMS_TAB_ID {
    TabIdSection = 0,
    TabIdVSInfo = 1,
    TabIdStrings = 2,
    TabIdMax
} IMS_TAB_ID;

typedef struct _IMS_TAB {
    UINT ResourceId;
    IMS_TAB_ID TabId;
    WNDPROC WndProc;
    LPTSTR TabCaption;
} IMS_TAB;

typedef struct _VALUE_DESC {
    LPWSTR lpDescription;
    DWORD dwValue;
} VALUE_DESC, * PVALUE_DESC;

LRESULT CALLBACK MainWindowProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

BOOL RunUI(_In_ GUI_CONTEXT* Context);

```

`Source/Plugins/Sonar/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,2510
 PRODUCTVERSION 1,2,0,2510
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "WinObjEx64 Plugin V1.2"
            VALUE "FileVersion", "1.2.0.2510"
            VALUE "InternalName", "Sonar.dll"
            VALUE "LegalCopyright", "Copyright (C) 2019 - 2025"
            VALUE "OriginalFilename", "Sonar.dll"
            VALUE "ProductName", "Sonar NDIS plugin for WinObjEx64"
            VALUE "ProductVersion", "1.2.0.2510"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/Plugins/Sonar/Sonar.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{91A5250B-99D2-48F9-B649-82D66C9A6396}</ProjectGuid>
    <RootNamespace>Sonar</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <EnablePREfast>false</EnablePREfast>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>$(SolutionDir)Plugins\postbuild.cmd $(ProjectName) .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).dll .\output\$(Platform)\$(Configuration)\bin\$(ProjectName).pdb</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)\Plugins;$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\minirtl\hextou64.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcpy.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strend.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncmp.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strncpy.c" />
    <ClCompile Include="..\..\Shared\ntos\ntsup.c" />
    <ClCompile Include="..\..\Shared\treelist\treelist.c" />
    <ClCompile Include="..\utils.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="query.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\..\Shared\ntos\ntbuilds.h" />
    <ClInclude Include="..\..\Shared\ntos\ntos.h" />
    <ClInclude Include="..\..\Shared\ntos\ntsup.h" />
    <ClInclude Include="..\..\Shared\treelist\treelist.h" />
    <ClInclude Include="..\plugin_def.h" />
    <ClInclude Include="..\utils.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="ndis.h" />
    <ClInclude Include="query.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="ui.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Plugins/Sonar/Sonar.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="treelist">
      <UniqueIdentifier>{4a1ef988-ec2c-4e01-9f42-58a21d9d7087}</UniqueIdentifier>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{cf71df74-886f-4e59-9549-bb7a5f08bd19}</UniqueIdentifier>
    </Filter>
    <Filter Include="ntos">
      <UniqueIdentifier>{cdc2911e-e806-4308-b367-3e794c15d6a0}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="query.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\treelist\treelist.c">
      <Filter>treelist</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\hextou64.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\ntos\ntsup.c">
      <Filter>ntos</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strncmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ndis.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="query.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\plugin_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\treelist\treelist.h">
      <Filter>treelist</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntos.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntsup.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\ntos\ntbuilds.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Source/Plugins/Sonar/Sonar.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/Plugins/Sonar/export.def`:

```def
EXPORTS
PluginInit

```

`Source/Plugins/Sonar/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Common header file for the Windows Object Explorer Sonar plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Strict UNICODE
//
#if !defined UNICODE
#error ANSI build is not supported
#endif

#define OEMRESOURCE
#include <Windows.h>
#include <windowsx.h>
#include <strsafe.h>
#include <CommCtrl.h>
#include <Uxtheme.h>

#pragma warning(push)
#pragma warning(disable: 4005)
#include <ntstatus.h>
#pragma warning(pop)

#pragma warning(disable: 6320) //Exception-filter expression is the constant EXCEPTION_EXECUTE_HANDLER

#include "ntos/ntos.h"
#include "treelist/treelist.h"
#include "minirtl/minirtl.h"
#include "ntos/ntsup.h"
#include "ntos/ntbuilds.h"
#include "plugin_def.h"
#include "utils.h"
#include "ui.h"
#include "resource.h"
#include "ndis.h"
#include "query.h"

//declared in main.c
extern SONARCONTEXT g_ctx;

#ifdef _DEBUG
#define kdDebugPrint(f, ...) DbgPrint(f, __VA_ARGS__)
#else
#define kdDebugPrint(f, ...) 
#endif

```

`Source/Plugins/Sonar/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 Sonar plugin.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define SONAR_PLUGIN_MAJOR_VERSION 1
#define SONAR_PLUGIN_MINOR_VERSION 2

//
// Maximum tested build Sonar is known to work.
//
#define SONAR_MAX_TESTED_BUILD NT_WIN11_25H2

//
// Safety cap for walking kernel lists to avoid infinite loops.
//
#define MAX_LIST_TRAVERSAL 100000

//
// Dll instance.
//
HINSTANCE g_thisDll = NULL;

//
// Run state.
//
volatile DWORD g_pluginState = PLUGIN_RUNNING;

//
// Number of listview columns.
//
#define PROTOCOLLIST_COLUMN_COUNT 3

//
// GUI context.
//
SONARCONTEXT g_ctx;

//
// Plugin entry.
//
WINOBJEX_PLUGIN* g_plugin = NULL;

VOID ListProtocols(
    _In_ BOOL bRefresh);

/*
* StatusBarSetText
*
* Purpose:
*
* Display status in status bar part.
*
*/
VOID StatusBarSetText(
    _In_ LPWSTR lpText
)
{
    SetWindowText(g_ctx.StatusBar, lpText);
}

/*
* AddListViewColumn
*
* Purpose:
*
* Wrapper for ListView_InsertColumn.
*
*/
INT AddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT ImageIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width
)
{
    LVCOLUMN column;

    column.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH | LVCF_ORDER;

    if (ImageIndex != I_IMAGENONE) column.mask |= LVCF_IMAGE;

    column.fmt = Format;
    column.cx = ScaleDPI(Width, g_ctx.CurrentDPI);
    column.pszText = Text;
    column.iSubItem = SubItemIndex;
    column.iOrder = OrderIndex;
    column.iImage = ImageIndex;

    return ListView_InsertColumn(ListViewHwnd, ColumnIndex, &column);
}

/*
* TreeListAddItem
*
* Purpose:
*
* Insert new treelist item.
*
*/
HTREEITEM TreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems
)
{
    TVINSERTSTRUCT  tvitem;
    PTL_SUBITEMS    si = (PTL_SUBITEMS)subitems;

    RtlSecureZeroMemory(&tvitem, sizeof(tvitem));
    tvitem.hParent = hParent;
    tvitem.item.mask = mask;
    tvitem.item.state = state;
    tvitem.item.stateMask = stateMask;
    tvitem.item.pszText = pszText;
    tvitem.hInsertAfter = TVI_LAST;
    return TreeList_InsertTreeItem(TreeList, &tvitem, si);
}

/*
* ListOpenQueue
*
* Purpose:
*
* Output NDIS_OPEN_BLOCK queue to the treelist.
*
*/
BOOL ListOpenQueue(
    _In_ HTREEITEM hTreeRootItem,
    _In_ ULONG_PTR OpenQueueAddress
)
{
    BOOL bResult = TRUE;
    ULONG iter = 0;
    ULONG_PTR ProtocolNextOpen = OpenQueueAddress;

    NDIS_OPEN_BLOCK_COMPATIBLE OpenBlock;

    WCHAR szBuffer[200];
    TL_SUBITEMS_FIXED subitems;

    do {
        if (++iter > MAX_LIST_TRAVERSAL) {
            StatusBarSetText(TEXT("Traversal aborted (too many iterations)"));
            bResult = FALSE;
            break;
        }

        RtlSecureZeroMemory(&OpenBlock, sizeof(OpenBlock));
        if (!ReadAndConvertOpenBlock(ProtocolNextOpen, &OpenBlock, NULL)) {

            StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
                TEXT("Error, read NDIS_OPEN_BLOCK at 0x%llX failed!"), ProtocolNextOpen);

            StatusBarSetText(szBuffer);

            bResult = FALSE;
            break;
        }

        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        subitems.UserParam = IntToPtr(NdisObjectTypeOpenBlock);
        StringCchPrintf(szBuffer, 32, TEXT("0x%llX"), ProtocolNextOpen);
        subitems.Count = 2;
        subitems.Text[0] = szBuffer;
        subitems.Text[1] = TEXT("");

        TreeListAddItem(
            g_ctx.TreeList,
            hTreeRootItem,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            TEXT("OpenQueue"),
            &subitems);

        ProtocolNextOpen = (ULONG_PTR)OpenBlock.ProtocolNextOpen;

    } while (ProtocolNextOpen != 0);

    return bResult;
}

/*
* AddProtocolToTreeList
*
* Purpose:
*
* Output NDIS_PROTOCOL_BLOCK to the treelist.
*
*/
BOOL AddProtocolToTreeList(
    _In_ NDIS_PROTOCOL_BLOCK_COMPATIBLE* ProtoBlock,
    _In_ ULONG_PTR ProtocolAddress
)
{
    BOOL bResult = TRUE;
    PWCHAR lpProtocolName = NULL, lpImageName = NULL;
    UNICODE_STRING* usTemp;

    TL_SUBITEMS_FIXED subitems;
    HTREEITEM hTreeItem = NULL;

    WCHAR szBuffer[32];

    usTemp = &ProtoBlock->Name;

    lpProtocolName = (PWCHAR)DumpUnicodeString((ULONG_PTR)usTemp->Buffer,
        usTemp->Length,
        usTemp->MaximumLength,
        FALSE);

    if (lpProtocolName) {
        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        subitems.UserParam = IntToPtr(NdisObjectTypeProtocolBlock);
        StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer), TEXT("0x%llX"), ProtocolAddress);
        subitems.Count = 2;
        subitems.Text[0] = szBuffer;

        if (ProtoBlock->ImageName.Length == 0) {
            subitems.Text[1] = TEXT("");
        }
        else {

            usTemp = &ProtoBlock->ImageName;
            lpImageName = (PWCHAR)DumpUnicodeString((ULONG_PTR)usTemp->Buffer,
                usTemp->Length,
                usTemp->MaximumLength,
                FALSE);

            if (lpImageName) {
                subitems.Text[1] = lpImageName;
            }
            else {
                subitems.Text[1] = TEXT("Unknown image");
            }
        }

        hTreeItem = TreeListAddItem(
            g_ctx.TreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            lpProtocolName,
            &subitems);

        if (lpImageName)
            supHeapFree(lpImageName);


        if ((ULONG_PTR)ProtoBlock->OpenQueue > g_ctx.ParamBlock.SystemRangeStart) {
            bResult = ListOpenQueue(hTreeItem, (ULONG_PTR)ProtoBlock->OpenQueue);
        }

        supHeapFree(lpProtocolName);
    }

    return bResult;
}

/*
* ListProtocols
*
* Purpose:
*
* Query ndisProtocolList and output it.
*
*/
VOID ListProtocols(
    _In_ BOOL bRefresh
)
{
    ULONG iter = 0;
    BOOLEAN bAnyErrors = FALSE;
    NDIS_PROTOCOL_BLOCK_COMPATIBLE ProtoBlock;

    ULONG_PTR ProtocolBlockAddress = 0;

    WCHAR szBuffer[200];

    if (bRefresh) {
        ListView_DeleteAllItems(g_ctx.ListView);
        TreeList_ClearTree(g_ctx.TreeList);
    }

    if (g_ctx.ndisProtocolList == 0)
        g_ctx.ndisProtocolList = QueryProtocolList();

    if (g_ctx.ndisProtocolList == 0) {

        StatusBarSetText(TEXT("Error, ndisProtocolList variable query failed!"));
        return;

    }

    //
    // Read head and skip it.
    //
    if (g_ctx.ndisNextProtocolOffset == 0)
        g_ctx.ndisNextProtocolOffset = GetNextProtocolOffset(g_ctx.ParamBlock.Version.dwBuildNumber);

    ProtocolBlockAddress = (ULONG_PTR)g_ctx.ndisProtocolList - g_ctx.ndisNextProtocolOffset;
    RtlSecureZeroMemory(&ProtoBlock, sizeof(ProtoBlock));
    if (!ReadAndConvertProtocolBlock(ProtocolBlockAddress, &ProtoBlock, NULL)) {

        StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
            TEXT("Error, read NDIS_PROTOCOL_BLOCK at 0x%llX failed!"), ProtocolBlockAddress);

        StatusBarSetText(szBuffer);

        return;
    }

    ProtocolBlockAddress = (ULONG_PTR)ProtoBlock.NextProtocol;

    //
    // Walk protocol list.
    //
    do {
        if (++iter > MAX_LIST_TRAVERSAL) {
            StatusBarSetText(TEXT("Traversal aborted (too many iterations)"));
            bAnyErrors = TRUE;
            break;
        }

        RtlSecureZeroMemory(&ProtoBlock, sizeof(ProtoBlock));
        if (!ReadAndConvertProtocolBlock(ProtocolBlockAddress, &ProtoBlock, NULL)) {

            StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
                TEXT("Error, read NDIS_PROTOCOL_BLOCK at 0x%llX failed!"), ProtocolBlockAddress);

            StatusBarSetText(szBuffer);
            bAnyErrors = TRUE;
            break;
        }

        if (!AddProtocolToTreeList(&ProtoBlock, ProtocolBlockAddress)) {
            bAnyErrors = TRUE;
        }

        ProtocolBlockAddress = (ULONG_PTR)ProtoBlock.NextProtocol;

    } while (ProtocolBlockAddress != 0);

    TreeView_SelectItem(g_ctx.TreeList, TreeView_GetRoot(g_ctx.TreeList));
    SetFocus(g_ctx.TreeList);

    if (bAnyErrors == FALSE)
        StatusBarSetText(TEXT("List protocols - OK"));
}

/*
* OnResize
*
* Purpose:
*
* Main window WM_SIZE handler.
*
*/
VOID OnResize(
    _In_ HWND hwndDlg
)
{
    RECT r, szr;
    HDWP hDeferPos;

    RtlZeroMemory(&r, sizeof(RECT));
    RtlZeroMemory(&szr, sizeof(RECT));

    SendMessage(g_ctx.StatusBar, WM_SIZE, 0, 0);

    GetClientRect(hwndDlg, &r);
    GetClientRect(g_ctx.StatusBar, &szr);
    g_ctx.SplitterMaxY = r.bottom - Y_SPLITTER_MIN;

    hDeferPos = BeginDeferWindowPos(7);
    if (!hDeferPos) return;

    hDeferPos = DeferWindowPos(hDeferPos, g_ctx.TreeList, 0,
        0, 0,
        r.right,
        g_ctx.SplitterPosY,
        SWP_NOOWNERZORDER);

    hDeferPos = DeferWindowPos(hDeferPos, g_ctx.ListView, 0,
        0, g_ctx.SplitterPosY + Y_SPLITTER_SIZE,
        r.right,
        r.bottom - g_ctx.SplitterPosY - Y_SPLITTER_SIZE - szr.bottom,
        SWP_NOOWNERZORDER);

    EndDeferWindowPos(hDeferPos);
    InvalidateRect(hwndDlg, NULL, FALSE);
}

/*
* ListViewCompareFunc
*
* Purpose:
*
* ListView comparer function.
*
*/
INT CALLBACK ListViewCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    INT nResult;

    switch (lParamSort) {

    case 0: //text value

        nResult = supGetMaxCompareTwoFixedStrings(
            g_ctx.ListView,
            lParam1,
            lParam2,
            lParamSort,
            g_ctx.bInverseSort);

        break;

    default: // address

        nResult = supGetMaxOfTwoU64FromHex(
            g_ctx.ListView,
            lParam1,
            lParam2,
            lParamSort,
            g_ctx.bInverseSort);

        break;
    }

    return nResult;
}

/*
* GetNdisObjectInformationFromList
*
* Purpose:
*
* Return NDIS object type and address (converted from text) from treelist item.
*
*/
BOOLEAN GetNdisObjectInformationFromList(
    _In_ HTREEITEM hTreeItem,
    _Out_ NDIS_OBJECT_TYPE* NdisObjectType,
    _Out_ PULONG_PTR ObjectAddress
)
{
    TVITEMEX itemex;
    PWCHAR lpAddressField;
    TL_SUBITEMS_FIXED* subitems = NULL;

    *NdisObjectType = NdisObjectTypeInvalid;
    *ObjectAddress = 0ull;

    SIZE_T Length;

    RtlSecureZeroMemory(&itemex, sizeof(itemex));

    itemex.hItem = hTreeItem;
    if (TreeList_GetTreeItem(g_ctx.TreeList, &itemex, &subitems))
        if (subitems) {
            if (subitems->Text[0]) {
                *NdisObjectType = (NDIS_OBJECT_TYPE)(ULONG_PTR)subitems->UserParam;
                Length = _strlen(subitems->Text[0]);
                if (Length > 2) {
                    lpAddressField = subitems->Text[0];
                    *ObjectAddress = hextou64(&lpAddressField[2]);
                }
                return TRUE;
            }
        }

    return FALSE;
}

/*
* xxxDumpProtocolBlock
*
* Purpose:
*
* Add item to list view.
*
*/
VOID xxxDumpProtocolBlock(
    _In_ LPWSTR lpszItem,
    _In_ LPWSTR lpszValue,
    _In_opt_ LPWSTR lpszAdditionalInfo
)
{
    INT lvItemIndex;
    LVITEM lvItem;

    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iItem = MAXINT;
    lvItem.pszText = lpszItem;
    lvItem.iImage = I_IMAGENONE;
    lvItemIndex = ListView_InsertItem(g_ctx.ListView, &lvItem);

    lvItem.pszText = lpszValue;
    lvItem.iSubItem = 1;
    lvItem.iItem = lvItemIndex;
    ListView_SetItem(g_ctx.ListView, &lvItem);

    if (lpszAdditionalInfo) {
        lvItem.pszText = lpszAdditionalInfo;
    }
    else {
        lvItem.pszText = TEXT("");
    }
    lvItem.iSubItem = 2;
    ListView_SetItem(g_ctx.ListView, &lvItem);
}

/*
* DumpHandlers
*
* Purpose:
*
* Output handlers with associated names.
*
*/
VOID DumpHandlers(
    _In_ PVOID* Handlers,
    _In_ UINT Count,
    _In_ LPCWSTR* Names,
    RTL_PROCESS_MODULES* pModulesList
)
{
    BOOL ConvertNeedFree = FALSE;
    ULONG moduleIndex = 0;
    PWSTR pAssociatedModule = NULL;

    WCHAR szBuffer[64];
    UNICODE_STRING usConvert;

    PRTL_PROCESS_MODULE_INFORMATION pModule;

    UINT i;

    for (i = 0; i < Count; i++) {
        if ((ULONG_PTR)Handlers[i] > g_ctx.ParamBlock.SystemRangeStart) {

            StringCchPrintf(szBuffer,
                RTL_NUMBER_OF(szBuffer),
                TEXT("0x%p"),
                Handlers[i]);

            if (ntsupFindModuleEntryByAddress(
                pModulesList,
                Handlers[i],
                &moduleIndex))
            {
                RtlInitEmptyUnicodeString(&usConvert, NULL, 0);
                pModule = &pModulesList->Modules[moduleIndex];
                if (NT_SUCCESS(ntsupConvertToUnicode((LPSTR)&pModule->FullPathName, &usConvert))) {
                    pAssociatedModule = usConvert.Buffer;
                    ConvertNeedFree = TRUE;
                }
                else {
                    pAssociatedModule = TEXT("Unknown Module");
                }
            }
            else {
                pAssociatedModule = TEXT("");//could be any garbage pointer.
            }

            xxxDumpProtocolBlock((LPWSTR)Names[i], szBuffer, pAssociatedModule);

            if (ConvertNeedFree) {
                RtlFreeUnicodeString(&usConvert);
                ConvertNeedFree = FALSE;
            }
        }

    }
}

/*
* DumpProtocolInfo
*
* Purpose:
*
* Read NDIS_PROTOCOL_BLOCK from memory and output it information.
*
*/
VOID DumpProtocolInfo(
    _In_ ULONG_PTR ProtocolAddress
)
{
    PWCHAR DumpedString;
    NDIS_PROTOCOL_BLOCK_COMPATIBLE ProtoBlock;
    WCHAR szBuffer[200];

    RTL_PROCESS_MODULES* pModulesList = NULL;

    PVOID ProtocolHandlers[_countof(g_lpszProtocolBlockHandlers)];

    ListView_DeleteAllItems(g_ctx.ListView);

    pModulesList = ntsupGetLoadedModulesListEx(
        FALSE,
        NULL,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);

    if (pModulesList == NULL) {
        StatusBarSetText(TEXT("Error, cannot query system information!"));
        return;
    }

    //
    // Dump protocol block from kernel.
    //
    RtlSecureZeroMemory(&ProtoBlock, sizeof(ProtoBlock));
    if (!ReadAndConvertProtocolBlock(ProtocolAddress, &ProtoBlock, NULL)) {

        supHeapFree(pModulesList);

        StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
            TEXT("Error, read NDIS_PROTOCOL_BLOCK at 0x%llX failed!"), ProtocolAddress);

        StatusBarSetText(szBuffer);

        return;
    }

    //
    // Output protocol version.
    //
    StringCchPrintf(szBuffer, 64, TEXT("%lu.%lu"), ProtoBlock.MajorNdisVersion, ProtoBlock.MinorNdisVersion);
    xxxDumpProtocolBlock(TEXT("NDIS Version"), szBuffer, NULL);

    //
    // Output driver version if set.
    //
    if (ProtoBlock.MajorDriverVersion) {
        StringCchPrintf(szBuffer, 64, TEXT("%lu.%lu"), ProtoBlock.MajorDriverVersion, ProtoBlock.MinorDriverVersion);
        xxxDumpProtocolBlock(TEXT("Driver Version"), szBuffer, NULL);
    }

    //
    // Read and output BindDeviceName UNICODE_STRING.
    //
    DumpedString = DumpUnicodeString((ULONG_PTR)ProtoBlock.BindDeviceName, 0, 0, TRUE);
    if (DumpedString) {
        StringCchPrintf(szBuffer, 64, TEXT("0x%llX"), (ULONG_PTR)ProtoBlock.BindDeviceName);
        xxxDumpProtocolBlock(TEXT("BindDeviceName"), szBuffer, DumpedString);
        supHeapFree(DumpedString);
    }

    //
    // Read and output RootDeviceName UNICODE_STRING.
    //
    DumpedString = DumpUnicodeString((ULONG_PTR)ProtoBlock.RootDeviceName, 0, 0, TRUE);
    if (DumpedString) {
        StringCchPrintf(szBuffer, 64, TEXT("0x%llX"), (ULONG_PTR)ProtoBlock.RootDeviceName);
        xxxDumpProtocolBlock(TEXT("RootDeviceName"), szBuffer, DumpedString);
        supHeapFree(DumpedString);
    }

    //
    // Output associated mini driver if present.
    //
    if (ProtoBlock.AssociatedMiniDriver) {
        StringCchPrintf(szBuffer, 64, TEXT("0x%llX"), (ULONG_PTR)ProtoBlock.AssociatedMiniDriver);
        xxxDumpProtocolBlock(TEXT("AssociatedMiniDriver"), szBuffer, NULL);
    }

    //
    // List Handlers.
    //
    RtlCopyMemory(ProtocolHandlers, &ProtoBlock.Handlers, sizeof(ProtocolHandlers));

    DumpHandlers(ProtocolHandlers, _countof(ProtocolHandlers), g_lpszProtocolBlockHandlers, pModulesList);

    supHeapFree(pModulesList);

    StatusBarSetText(TEXT("List protocol information - OK"));
}

/*
* DumpProtocolInfo
*
* Purpose:
*
* Read NDIS_OPEN_BLOCK from memory and output it information.
*
*/
VOID DumpOpenBlockInfo(
    _In_ ULONG_PTR OpenBlockAddress
)
{
    PWCHAR DumpedString;
    NDIS_OPEN_BLOCK_COMPATIBLE OpenBlock;
    WCHAR szBuffer[200];

    RTL_PROCESS_MODULES* pModulesList = NULL;

    PVOID OpenBlockHandlers[_countof(g_lpszOpenBlockHandlers)];

    ListView_DeleteAllItems(g_ctx.ListView);

    //
    // Allocate loaded modules list.
    //    
    pModulesList = ntsupGetLoadedModulesListEx(
        FALSE,
        NULL,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);

    if (pModulesList == NULL) {
        StatusBarSetText(TEXT("Error, cannot query system information!"));
        return;
    }

    //
    // Dump open block from kernel.
    //
    RtlSecureZeroMemory(&OpenBlock, sizeof(OpenBlock));
    if (!ReadAndConvertOpenBlock(OpenBlockAddress, &OpenBlock, NULL)) {

        supHeapFree(pModulesList);

        StringCchPrintf(szBuffer, RTL_NUMBER_OF(szBuffer),
            TEXT("Error, read NDIS_OPEN_BLOCK at 0x%llX failed!"), OpenBlockAddress);

        StatusBarSetText(szBuffer);

        return;
    }

    //
    // Read and output BindDeviceName UNICODE_STRING.
    //
    DumpedString = DumpUnicodeString((ULONG_PTR)OpenBlock.BindDeviceName, 0, 0, TRUE);
    if (DumpedString) {
        StringCchPrintf(szBuffer, 64, TEXT("0x%llX"), (ULONG_PTR)OpenBlock.BindDeviceName);
        xxxDumpProtocolBlock(TEXT("BindDeviceName"), szBuffer, DumpedString);
        supHeapFree(DumpedString);
    }

    //
    // Read and output RootDeviceName UNICODE_STRING.
    //
    DumpedString = DumpUnicodeString((ULONG_PTR)OpenBlock.RootDeviceName, 0, 0, TRUE);
    if (DumpedString) {
        StringCchPrintf(szBuffer, 64, TEXT("0x%llX"), (ULONG_PTR)OpenBlock.RootDeviceName);
        xxxDumpProtocolBlock(TEXT("RootDeviceName"), szBuffer, DumpedString);
        supHeapFree(DumpedString);
    }

    //
    // List Handlers.
    //
    RtlCopyMemory(OpenBlockHandlers, &OpenBlock.Handlers, sizeof(OpenBlockHandlers));

    DumpHandlers(OpenBlockHandlers, _countof(OpenBlockHandlers), g_lpszOpenBlockHandlers, pModulesList);
    supHeapFree(pModulesList);

    StatusBarSetText(TEXT("List open block information - OK"));
}

/*
* OnContextMenu
*
* Purpose:
*
* Main window WM_CONTEXTMENU handler.
*
*/
VOID OnContextMenu(
    _In_ HWND hwnd,
    _In_ LPPOINT lpPoint,
    _In_ LPARAM lParam,
    _In_ BOOLEAN fTreeList
)
{
    HMENU hMenu;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        //
        // Add "Copy %item%" menu item.
        //
        if (fTreeList) {

            supTreeListAddCopyValueItem(hMenu,
                g_ctx.TreeList,
                ID_MENU_COPY_VALUE,
                0,
                lParam,
                &g_ctx.tlSubItemHit);

        }
        else {

            supListViewAddCopyValueItem(hMenu,
                g_ctx.ListView,
                ID_MENU_COPY_VALUE,
                0,
                lpPoint,
                &g_ctx.LvItemHit,
                &g_ctx.LvColumnHit);

        }

        TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, lpPoint->x, lpPoint->y, 0, hwnd, NULL);
        DestroyMenu(hMenu);
    }
}

/*
* RefreshViewsHandler
*
* Purpose:
*
* TreeList/ListView refresh (F5 accelerator) handler.
*
*/
VOID RefreshViewsHandler(
    _In_ HWND hwndFocus)
{
    HWND            TreeListControl = TreeList_GetTreeControlWindow(g_ctx.TreeList);
    HTREEITEM       SelectedTreeItem;
    ULONG_PTR       ObjectAddress;

    NDIS_OBJECT_TYPE NdisObjectType;

    if (hwndFocus == TreeListControl) {
        ListProtocols(TRUE);
    }
    else if (hwndFocus == g_ctx.ListView) {

        SelectedTreeItem = TreeList_GetSelection(g_ctx.TreeList);
        if (SelectedTreeItem) {
            ObjectAddress = 0ull;
            if (GetNdisObjectInformationFromList(SelectedTreeItem,
                &NdisObjectType,
                &ObjectAddress))
            {

                switch (NdisObjectType) {
                case NdisObjectTypeProtocolBlock:
                    DumpProtocolInfo(ObjectAddress);
                    break;
                case NdisObjectTypeOpenBlock:
                    DumpOpenBlockInfo(ObjectAddress);
                    break;
                case NdisObjectTypeMDriverBlock:
                default:
                    break;
                }

                ListView_SetItemState(g_ctx.ListView,
                    0,
                    LVIS_FOCUSED | LVIS_SELECTED,
                    0x000F);

            }
        }
    }
}

/*
* ShowProperties
*
* Purpose:
*
* Show file properties Windows dialog.
*
*/
VOID ShowProperties(
    _In_ HWND hwndDlg,
    _In_ LPWSTR lpFileName
)
{
    SHELLEXECUTEINFO shinfo;

    if (lpFileName == NULL) {
        return;
    }

    RtlSecureZeroMemory(&shinfo, sizeof(shinfo));
    shinfo.cbSize = sizeof(shinfo);
    shinfo.fMask = SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_NO_UI;
    shinfo.hwnd = hwndDlg;
    shinfo.lpVerb = TEXT("properties");
    shinfo.lpFile = lpFileName;
    shinfo.nShow = SW_SHOWNORMAL;
    ShellExecuteEx(&shinfo);
}

/*
* ShowPropertiesHandler
*
* Purpose:
*
* Show file properties for listview.
*
* N.B. There is no usable full path in treelist.
*
*/
VOID ShowPropertiesHandler(
    _In_ HWND hwndFocus)
{
    LV_ITEM item;
    WCHAR szBuffer[MAX_PATH + 1];
    WCHAR szConvertedFileName[MAX_PATH + 1];

    if (hwndFocus == g_ctx.ListView) {

        RtlSecureZeroMemory(&item, sizeof(item));
        szBuffer[0] = 0;

        item.iItem = ListView_GetSelectionMark(g_ctx.ListView);
        item.iSubItem = 2;
        item.pszText = szBuffer;
        item.cchTextMax = (SIZE_T)MAX_PATH;
        SendMessage(g_ctx.ListView, LVM_GETITEMTEXT, (WPARAM)item.iItem, (LPARAM)&item);

        szConvertedFileName[0] = 0;
        if (supGetWin32FileName(
            szBuffer,
            szConvertedFileName,
            MAX_PATH))
        {
            ShowProperties(g_ctx.MainWindow, szConvertedFileName);
        }
    }
}

/*
* OnNotify
*
* Purpose:
*
* WM_NOTIFY handler.
*
*/
VOID OnNotify(
    _In_ HWND hwnd,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    INT             i, SortColumn, ImageIndex;
    ULONG_PTR       ObjectAddress;
    HWND            TreeControl;
    LVCOLUMN        col;
    LPNMHDR         hdr = (LPNMHDR)lParam;
    LPNMTREEVIEW    lpnmTreeView;

    NDIS_OBJECT_TYPE NdisObjectType;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(wParam);

    if (InterlockedCompareExchange((PLONG)&g_pluginState, 0, 0) == PLUGIN_STOP)
        return;

    TreeControl = (HWND)TreeList_GetTreeControlWindow(g_ctx.TreeList);

    if (hdr->hwndFrom == TreeControl) {

        switch (hdr->code) {

        case TVN_SELCHANGED:

            lpnmTreeView = (LPNMTREEVIEW)lParam;
            if (lpnmTreeView) {
                ObjectAddress = 0ull;
                if (GetNdisObjectInformationFromList(lpnmTreeView->itemNew.hItem,
                    &NdisObjectType,
                    &ObjectAddress))
                {
                    switch (NdisObjectType) {
                    case NdisObjectTypeProtocolBlock:
                        DumpProtocolInfo(ObjectAddress);
                        break;
                    case NdisObjectTypeOpenBlock:
                        DumpOpenBlockInfo(ObjectAddress);
                        break;
                    default:
                        break;

                    }
                }
            }
            break;

        default:
            break;
        }

    }
    else if (hdr->hwndFrom == g_ctx.ListView) {

        switch (hdr->code) {

        case NM_DBLCLK:
            ShowPropertiesHandler(hdr->hwndFrom);
            break;

        case LVN_COLUMNCLICK:
            g_ctx.bInverseSort = (~g_ctx.bInverseSort) & 1;
            SortColumn = ((NMLISTVIEW*)lParam)->iSubItem;

            ListView_SortItemsEx(g_ctx.ListView, &ListViewCompareFunc, SortColumn);

            ImageIndex = ImageList_GetImageCount(g_ctx.ImageList);
            if (g_ctx.bInverseSort)
                ImageIndex -= 2;
            else
                ImageIndex -= 1;

            RtlSecureZeroMemory(&col, sizeof(col));
            col.mask = LVCF_IMAGE;

            for (i = 0; i < g_ctx.lvColumnCount; i++) {
                if (i == SortColumn) {
                    col.iImage = ImageIndex;
                }
                else {
                    col.iImage = I_IMAGENONE;
                }
                ListView_SetColumn(g_ctx.ListView, i, &col);
            }

            break;

        default:
            break;
        }

    }
}

/*
* MainWindowProc
*
* Purpose:
*
* Main window procedure.
*
*/
LRESULT CALLBACK MainWindowProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    INT dy;
    RECT crc;
    INT mark;
    HWND TreeListControl, FocusWindow;

    switch (uMsg) {

    case WM_CONTEXTMENU:

        RtlSecureZeroMemory(&crc, sizeof(crc));

        TreeListControl = TreeList_GetTreeControlWindow(g_ctx.TreeList);

        if ((HWND)wParam == TreeListControl) {
            GetCursorPos((LPPOINT)&crc);
            OnContextMenu(hwnd, (LPPOINT)&crc, lParam, TRUE);
        }

        if ((HWND)wParam == g_ctx.ListView) {

            mark = ListView_GetSelectionMark(g_ctx.ListView);

            if (lParam == MAKELPARAM(-1, -1)) {
                ListView_GetItemRect(g_ctx.ListView, mark, &crc, TRUE);
                crc.top = crc.bottom;
                ClientToScreen(g_ctx.ListView, (LPPOINT)&crc);
            }
            else
                GetCursorPos((LPPOINT)&crc);

            OnContextMenu(hwnd, (LPPOINT)&crc, 0, FALSE);
        }
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case ID_MENU_COPY_VALUE:

            FocusWindow = GetFocus();
            TreeListControl = TreeList_GetTreeControlWindow(g_ctx.TreeList);

            //
            // Copy text to the clipboard.
            //
            if (FocusWindow == TreeListControl) {

                supTreeListCopyItemValueToClipboard(g_ctx.TreeList,
                    g_ctx.tlSubItemHit);

            }
            else if (FocusWindow == g_ctx.ListView) {

                supListViewCopyItemValueToClipboard(g_ctx.ListView,
                    g_ctx.LvItemHit,
                    g_ctx.LvColumnHit);

            }

            break;

        case WINOBJEX64_ACC_F5:
            RefreshViewsHandler(GetFocus());
            break;

        case WINOBJEX64_OBJECT_PROP:
            ShowPropertiesHandler(GetFocus());
            break;

        default:
            break;
        }

        break;

    case WM_SIZE:
        OnResize(hwnd);
        break;

    case WM_LBUTTONUP:
        ReleaseCapture();
        break;

    case WM_LBUTTONDOWN:
        SetCapture(hwnd);
        g_ctx.CapturePosY = (int)(short)HIWORD(lParam);
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            ((PMINMAXINFO)lParam)->ptMinTrackSize.x = 400;
            ((PMINMAXINFO)lParam)->ptMinTrackSize.y = 256;
        }
        break;


    case WM_MOUSEMOVE:

        if (wParam & MK_LBUTTON) {
            dy = (int)(short)HIWORD(lParam) - g_ctx.CapturePosY;
            if (dy != 0) {
                g_ctx.CapturePosY = (int)(short)HIWORD(lParam);
                g_ctx.SplitterPosY += dy;
                if (g_ctx.SplitterPosY < Y_SPLITTER_MIN)
                {
                    g_ctx.SplitterPosY = Y_SPLITTER_MIN;
                    g_ctx.CapturePosY = Y_SPLITTER_MIN;
                }

                if (g_ctx.SplitterPosY > g_ctx.SplitterMaxY)
                {
                    g_ctx.SplitterPosY = g_ctx.SplitterMaxY;
                    g_ctx.CapturePosY = g_ctx.SplitterMaxY;
                }
                SendMessage(hwnd, WM_SIZE, 0, 0);
            }
        }
        break;

    case WM_CLOSE:
        InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);
        PostQuitMessage(0);
        break;

    case WM_NOTIFY:
        OnNotify(hwnd, wParam, lParam);
        break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*
* PluginFreeGlobalResources
*
* Purpose:
*
* Plugin resources deallocation routine.
*
*/
VOID PluginFreeGlobalResources(
    VOID
)
{
    if (g_ctx.ImageList) {
        ImageList_Destroy(g_ctx.ImageList);
        g_ctx.ImageList = 0;
    }
    if (g_ctx.PluginHeap) {
        HeapDestroy(g_ctx.PluginHeap);
        g_ctx.PluginHeap = NULL;
    }

    if (g_plugin->StateChangeCallback)
        g_plugin->StateChangeCallback(g_plugin, PluginStopped, NULL);

    if (g_plugin->GuiShutdownCallback)
        g_plugin->GuiShutdownCallback(g_plugin, g_thisDll, NULL);

}

/*
* PluginThread
*
* Purpose:
*
* Plugin payload thread.
*
*/
DWORD WINAPI PluginThread(
    _In_ PVOID Parameter
)
{
    BOOL rv;
    HRESULT hr = CO_E_NOTINITIALIZED;
    HICON hIcon;
    LONG_PTR wndStyles;
    HWND MainWindow;
    HDITEM hdritem;
    MSG msg1;
    WCHAR szClassName[100];

    UNREFERENCED_PARAMETER(Parameter);

    do {

        if (g_plugin->GuiInitCallback == NULL) { // this is required callback
            kdDebugPrint("Gui init callback required\r\n");
            break;
        }

        if (!g_plugin->GuiInitCallback(g_plugin,
            g_thisDll,
            (WNDPROC)MainWindowProc,
            NULL))
        {
            kdDebugPrint("Gui init callback failure\r\n");
            break;
        }

        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
        g_ctx.CurrentDPI = g_ctx.ParamBlock.CurrentDPI;

        //
        // Window class once.
        //
        StringCchPrintf(szClassName,
            RTL_NUMBER_OF(szClassName),
            TEXT("%wsWndClass"),
            g_plugin->Name);

        //
        // Create main window.
        //
        MainWindow = CreateWindowEx(
            0,
            szClassName,
            SONAR_WNDTITLE,
            WS_VISIBLE | WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            ScaleDPI(800, g_ctx.CurrentDPI),
            ScaleDPI(600, g_ctx.CurrentDPI),
            NULL,
            NULL,
            g_thisDll,
            NULL);

        if (MainWindow == 0) {
            kdDebugPrint("Could not create main window, err = %lu\r\n", GetLastError());
            break;
        }

        g_ctx.MainWindow = MainWindow;
        g_ctx.SplitterPosY = 300;

        //
        // Status Bar window.
        //
        g_ctx.StatusBar = CreateWindowEx(
            0,
            STATUSCLASSNAME,
            NULL,
            WS_VISIBLE | WS_CHILD,
            0,
            0,
            0,
            0,
            MainWindow,
            NULL,
            g_thisDll,
            NULL);

        if (g_ctx.StatusBar == 0) {
            kdDebugPrint("Could not create statusbar window, err = %lu\r\n", GetLastError());
            break;
        }

        //
        // TreeList window.
        //
        g_ctx.TreeList = CreateWindowEx(WS_EX_CLIENTEDGE, WC_TREELIST, NULL,
            WS_VISIBLE | WS_CHILD | TLSTYLE_LINKLINES | TLSTYLE_COLAUTOEXPAND | WS_TABSTOP,
            0, 0, 768, 256, MainWindow, NULL, NULL, NULL);

        if (g_ctx.TreeList == 0) {
            kdDebugPrint("Could not create treelist window, err = %lu\r\n", GetLastError());
            break;
        }

        //
        // ListView window.
        //
        g_ctx.ListView = CreateWindowEx(WS_EX_CLIENTEDGE, WC_LISTVIEW, NULL,
            WS_VISIBLE | WS_CHILD | WS_TABSTOP |
            LVS_AUTOARRANGE | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_SINGLESEL,
            0, 0, 0, 0, MainWindow, NULL, NULL, NULL);

        if (g_ctx.ListView == 0) {
            kdDebugPrint("Could not create listview window, err = %lu\r\n", GetLastError());
            break;
        }

        ListView_SetExtendedListViewStyle(g_ctx.ListView,
            LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_LABELTIP | LVS_EX_DOUBLEBUFFER);

        //
        // Image list for sorting column images.
        //
        g_ctx.ImageList = ImageList_Create(
            16,
            16,
            ILC_COLOR32 | ILC_MASK,
            2,
            2);

        hIcon = (HICON)LoadImage(g_ctx.ParamBlock.Instance,
            MAKEINTRESOURCE(WINOBJEX64_ICON_SORT_UP), IMAGE_ICON, 0, 0,
            LR_DEFAULTCOLOR);

        if (hIcon) {
            ImageList_ReplaceIcon(g_ctx.ImageList, -1, hIcon);
            DestroyIcon(hIcon);
        }

        hIcon = (HICON)LoadImage(g_ctx.ParamBlock.Instance,
            MAKEINTRESOURCE(WINOBJEX64_ICON_SORT_DOWN), IMAGE_ICON, 0, 0,
            LR_DEFAULTCOLOR);

        if (hIcon) {
            ImageList_ReplaceIcon(g_ctx.ImageList, -1, hIcon);
            DestroyIcon(hIcon);
        }

        ListView_SetImageList(g_ctx.ListView, g_ctx.ImageList, LVSIL_SMALL);

        //
        // Init listview columns.
        //

        AddListViewColumn(g_ctx.ListView, 0, 0, 0,
            I_IMAGENONE,
            LVCFMT_LEFT,
            TEXT("Item"), 300);

        AddListViewColumn(g_ctx.ListView, 1, 1, 1,
            I_IMAGENONE,
            LVCFMT_LEFT,
            TEXT("Value"), 140);

        AddListViewColumn(g_ctx.ListView, 2, 2, 2,
            I_IMAGENONE,
            LVCFMT_LEFT,
            TEXT("Additional Information"), 300);

        //
        // Remember column count.
        //
        g_ctx.lvColumnCount = PROTOCOLLIST_COLUMN_COUNT;

        //
        // Init treelist.
        //
        g_ctx.tlSubItemHit = -1;

        RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
        hdritem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
        hdritem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;
        hdritem.cxy = ScaleDPI(300, g_ctx.CurrentDPI);
        hdritem.pszText = TEXT("Protocol");
        TreeList_InsertHeaderItem(g_ctx.TreeList, 0, &hdritem);

        hdritem.cxy = ScaleDPI(130, g_ctx.CurrentDPI);
        hdritem.pszText = TEXT("Object");
        TreeList_InsertHeaderItem(g_ctx.TreeList, 1, &hdritem);

        hdritem.cxy = ScaleDPI(200, g_ctx.CurrentDPI);
        hdritem.pszText = TEXT("Additional Information");
        TreeList_InsertHeaderItem(g_ctx.TreeList, 2, &hdritem);

        wndStyles = GetWindowLongPtr(g_ctx.TreeList, GWL_STYLE);
        SetWindowLongPtr(g_ctx.TreeList, GWL_STYLE, wndStyles | TLSTYLE_LINKLINES);

        SetWindowTheme(g_ctx.TreeList, TEXT("Explorer"), NULL);
        SetWindowTheme(g_ctx.ListView, TEXT("Explorer"), NULL);

        g_ctx.AccTable = LoadAccelerators(g_ctx.ParamBlock.Instance, MAKEINTRESOURCE(WINOBJEX64_ACC_TABLE));

        OnResize(MainWindow);

        if (g_ctx.ParamBlock.Version.dwBuildNumber > SONAR_MAX_TESTED_BUILD) {

            SetWindowText(MainWindow, TEXT("Sonar: Untested Windows version, plugin may output wrong data"));

        }

        ListProtocols(FALSE);

        do {
            rv = GetMessage(&msg1, NULL, 0, 0);

            if (rv == -1)
                break;

            if (IsDialogMessage(MainWindow, &msg1)) {
                TranslateAccelerator(MainWindow, g_ctx.AccTable, &msg1);
                continue;
            }

            TranslateMessage(&msg1);
            DispatchMessage(&msg1);

        } while (rv != 0 && InterlockedCompareExchange((PLONG)&g_pluginState, 0, 0) == PLUGIN_RUNNING);

    } while (FALSE);

    DestroyWindow(g_ctx.MainWindow);

    if (SUCCEEDED(hr)) { 
        CoUninitialize(); 
    }

    PluginFreeGlobalResources();

    ExitThread(0);
}

/*
* StartPlugin
*
* Purpose:
*
* Run actual plugin code in dedicated thread.
*
*/
NTSTATUS CALLBACK StartPlugin(
    _In_ PWINOBJEX_PARAM_BLOCK ParamBlock
)
{
    DWORD ThreadId;
    NTSTATUS Status;
    WINOBJEX_PLUGIN_STATE State = PluginInitialization;

    InterlockedExchange((PLONG)&g_pluginState, PLUGIN_RUNNING);

    RtlSecureZeroMemory(&g_ctx, sizeof(g_ctx));

    g_ctx.PluginHeap = HeapCreate(0, 0, 0);
    if (g_ctx.PluginHeap == NULL)
        return STATUS_MEMORY_NOT_ALLOCATED;

    HeapSetInformation(g_ctx.PluginHeap, HeapEnableTerminationOnCorruption, NULL, 0);

    RtlCopyMemory(&g_ctx.ParamBlock, ParamBlock, sizeof(WINOBJEX_PARAM_BLOCK));

    g_ctx.WorkerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PluginThread, (PVOID)&g_ctx.ParamBlock, 0, &ThreadId);
    if (g_ctx.WorkerThread) {
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
        HeapDestroy(g_ctx.PluginHeap);
        g_ctx.PluginHeap = NULL;
    }

    if (NT_SUCCESS(Status))
        State = PluginRunning;
    else
        State = PluginError;

    if (g_plugin->StateChangeCallback)
        g_plugin->StateChangeCallback(g_plugin, State, NULL);

    return Status;
}

/*
* StopPlugin
*
* Purpose:
*
* Stop plugin execution.
*
*/
void CALLBACK StopPlugin(
    VOID
)
{
    if (g_ctx.WorkerThread) {
        InterlockedExchange((PLONG)&g_pluginState, PLUGIN_STOP);//force stop
        if (WaitForSingleObject(g_ctx.WorkerThread, 1000) == WAIT_TIMEOUT) {
#pragma warning(push)
#pragma warning(disable: 6258)
            TerminateThread(g_ctx.WorkerThread, 0);
#pragma warning(pop)

        }
        CloseHandle(g_ctx.WorkerThread);
        g_ctx.WorkerThread = NULL;

        //
        // Free global resources and set plugin state.
        //
        PluginFreeGlobalResources();
    }
}

/*
* PluginInit
*
* Purpose:
*
* Initialize plugin information for WinObjEx64.
*
*/
BOOLEAN CALLBACK PluginInit(
    _Inout_ PWINOBJEX_PLUGIN PluginData
)
{
    // Don't initialize twice
    if (g_plugin) {
        return FALSE;
    }

    __try {
        if (PluginData == NULL) {
            return FALSE;
        }

        if (PluginData->cbSize < sizeof(WINOBJEX_PLUGIN)) {
            return FALSE;
        }

        if (PluginData->AbiVersion != WINOBJEX_PLUGIN_ABI_VERSION) {
            return FALSE;
        }

        //
        // Set plugin name to be displayed in WinObjEx64 UI.
        //
        StringCbCopy(PluginData->Name, sizeof(PluginData->Name), TEXT("NDIS Protocol List"));

        //
        // Set authors.
        //
        StringCbCopy(PluginData->Authors, sizeof(PluginData->Authors), TEXT("UG North"));

        //
        // Set plugin description.
        //
        StringCbCopy(PluginData->Description, sizeof(PluginData->Description),
            TEXT("Displays registered NDIS protocols and lists their key functions."));

        //
        // Set required plugin system version.
        //
        PluginData->RequiredPluginSystemVersion = WOBJ_PLUGIN_SYSTEM_VERSION;

        //
        // Setup start/stop plugin callbacks.
        //
        PluginData->StartPlugin = (pfnStartPlugin)&StartPlugin;
        PluginData->StopPlugin = (pfnStopPlugin)&StopPlugin;

        //
        // Setup capabilities.
        //
        PluginData->Capabilities.u1.NeedAdmin = TRUE;
        PluginData->Capabilities.u1.SupportWine = FALSE;
        PluginData->Capabilities.u1.NeedDriver = TRUE;

        PluginData->MajorVersion = SONAR_PLUGIN_MAJOR_VERSION;
        PluginData->MinorVersion = SONAR_PLUGIN_MINOR_VERSION;

        //
        // Set plugin type.
        //
        PluginData->Type = DefaultPlugin;

        g_plugin = PluginData;

        return TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        kdDebugPrint("PluginInit exception thrown %lx", GetExceptionCode());
        return FALSE;
    }
}

/*
* DllMain
*
* Purpose:
*
* Dummy dll entrypoint.
*
*/
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD     fdwReason,
    _In_ LPVOID    lpvReserved
)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    switch (fdwReason) {

    case DLL_PROCESS_ATTACH:
        g_thisDll = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
        break;
    }

    return TRUE;
}

```

`Source/Plugins/Sonar/ndis.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2023
*  Translated from Microsoft sources/symbols with help of pdbex
*
*  TITLE:       NDIS.H
*
*  VERSION:     1.06
*
*  DATE:        14 Jul 2023
*
*  Common header file for the NDIS related definitions/structures.
*
*  Depends on:    ntos.h
*
*  Include:       ntos.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/
#pragma once

#ifndef NDIS_RTL
#define NDIS_RTL


//
// NDIS_RTL HEADER BEGIN
//

#if defined(__cplusplus)
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used: nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

//
// Basic types from MS ndis.h
//

typedef struct _NDIS_OBJECT_HEADER
{
    UCHAR Type;
    UCHAR Revision;
    USHORT Size;
} NDIS_OBJECT_HEADER, *PNDIS_OBJECT_HEADER;

// NdisAllocateSpinLock

typedef struct _NDIS_SPIN_LOCK
{
    KSPIN_LOCK SpinLock;
    KIRQL OldIrql;
} NDIS_SPIN_LOCK, *PNDIS_SPIN_LOCK;

typedef struct _REFERENCE
{
    unsigned __int64 SpinLock;
    USHORT ReferenceCount;
    UCHAR Closing;
    char __PADDING__[5];
} REFERENCE, *PREFERENCE;

typedef struct _REFERENCE_EX
{
    unsigned __int64 SpinLock;
    USHORT ReferenceCount;
    UCHAR Closing;
    UCHAR ZeroBased;
    long Padding_188;
    struct NDIS_REFCOUNT_HANDLE__* RefCountTracker;
} REFERENCE_EX, *PREFERENCE_EX; /* size: 0x0018 */

typedef VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef struct _WORK_QUEUE_ITEM
{
    LIST_ENTRY             List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    __volatile PVOID       Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

struct _NDIS_WORK_ITEM;
typedef
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID NDIS_PROC_CALLBACK(
    _In_ struct _NDIS_WORK_ITEM * WorkItem,
    _In_opt_ PVOID Context);
typedef NDIS_PROC_CALLBACK *NDIS_PROC;

typedef struct _NDIS_WORK_ITEM
{
    PVOID           Context;
    NDIS_PROC       Routine;
    UCHAR           WrapperReserved[8 * sizeof(PVOID)];
} NDIS_WORK_ITEM, *PNDIS_WORK_ITEM;

typedef struct _NDIS_EVENT
{
    KEVENT      Event;
} NDIS_EVENT, *PNDIS_EVENT;

typedef struct _QUEUED_CLOSE {
    int Status;
    long Padding_274;
    WORK_QUEUE_ITEM WorkItem;
} QUEUED_CLOSE, *PQUEUED_CLOSE;

typedef enum _NDIS_PARAMETER_TYPE
{
    NdisParameterInteger,
    NdisParameterHexInteger,
    NdisParameterString,
    NdisParameterMultiString,
    NdisParameterBinary
} NDIS_PARAMETER_TYPE, *PNDIS_PARAMETER_TYPE;

typedef enum _NDIS_PROCESSOR_TYPE
{
    NdisProcessorX86,
    NdisProcessorMips,
    NdisProcessorAlpha,
    NdisProcessorPpc,
    NdisProcessorAmd64,
    NdisProcessorIA64,
    NdisProcessorArm,
    NdisProcessorArm64
} NDIS_PROCESSOR_TYPE, *PNDIS_PROCESSOR_TYPE;

typedef enum _NDIS_NDIS5_DRIVER_STATE
{
    Ndis5StateUnused = 0,
    Ndis5StatePaused = 1,
    Ndis5StateRunning = 2,
} NDIS_NDIS5_DRIVER_STATE, *PNDIS_NDIS5_DRIVER_STATE;

typedef enum _NDIS_OPEN_STATE
{
    NdisOpenStateRunning = 0,
    NdisOpenStatePausing = 1,
    NdisOpenStatePaused = 2,
    NdisOpenStateRestarting = 3,
} NDIS_OPEN_STATE, *PNDIS_OPEN_STATE;

typedef enum _NDIS_OPEN_UNBIND_REASON
{
    UnbindReasonNotUnbinding = 0,
    UnbindReasonCloseMiniportBindings = 1,
    UnbindReasonCloseAllBindingsOnProtocol = 2,
    UnbindReasonCloseMiniportBindingsForPause = 3,
    UnbindReasonHandleProtocolReconfigNotification = 4,
    UnbindReasonHandleProtocolUnbindNotification = 5,
    UnbindReasonPnPNotifyAllTransports = 6,
    UnbindReasonPnPNotifyBinding = 7,
} NDIS_OPEN_UNBIND_REASON, *PNDIS_OPEN_UNBIND_REASON;

typedef enum _NDIS_INTERFACE_TYPE
{
    NdisInterfaceInternal = Internal,
    NdisInterfaceIsa = Isa,
    NdisInterfaceEisa = Eisa,
    NdisInterfaceMca = MicroChannel,
    NdisInterfaceTurboChannel = TurboChannel,
    NdisInterfacePci = PCIBus,
    NdisInterfacePcMcia = PCMCIABus,
    NdisInterfaceCBus = CBus,
    NdisInterfaceMPIBus = MPIBus,
    NdisInterfaceMPSABus = MPSABus,
    NdisInterfaceProcessorInternal = ProcessorInternal,
    NdisInterfaceInternalPowerBus = InternalPowerBus,
    NdisInterfacePNPISABus = PNPISABus,
    NdisInterfacePNPBus = PNPBus,
    NdisInterfaceUSB,
    NdisInterfaceIrda,
    NdisInterface1394,
    NdisMaximumInterfaceType
} NDIS_INTERFACE_TYPE, *PNDIS_INTERFACE_TYPE;

typedef struct _NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS
{
    NDIS_OBJECT_HEADER Header;
    ULONG Reserved;
    PVOID CmCreateVcHandler;
    PVOID CmDeleteVcHandler;
    PVOID CmOpenAfHandler;
    PVOID CmCloseAfHandler;
    PVOID CmRegisterSapHandler;
    PVOID CmDeregisterSapHandler;
    PVOID CmMakeCallHandler;
    PVOID CmCloseCallHandler;
    PVOID CmIncomingCallCompleteHandler;
    PVOID CmAddPartyHandler;
    PVOID CmDropPartyHandler;
    PVOID CmActivateVcCompleteHandler;
    PVOID CmDeactivateVcCompleteHandler;
    PVOID CmModifyCallQoSHandler;
    PVOID CmOidRequestHandler;
    PVOID CmOidRequestCompleteHandler;
    PVOID CmNotifyCloseAfCompleteHandler;
} NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS, *PNDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS;

typedef struct _NDIS_CO_CLIENT_OPTIONAL_HANDLERS {
    NDIS_OBJECT_HEADER Header;
    ULONG Reserved;
    PVOID ClCreateVcHandler;
    PVOID ClDeleteVcHandler;
    PVOID ClOidRequestHandler;
    PVOID ClOidRequestCompleteHandler;
    PVOID ClOpenAfCompleteHandlerEx;
    PVOID ClCloseAfCompleteHandler;
    PVOID ClRegisterSapCompleteHandler;
    PVOID ClDeregisterSapCompleteHandler;
    PVOID ClMakeCallCompleteHandler;
    PVOID ClModifyCallQoSCompleteHandler;
    PVOID ClCloseCallCompleteHandler;
    PVOID ClAddPartyCompleteHandler;
    PVOID ClDropPartyCompleteHandler;
    PVOID ClIncomingCallHandler;
    PVOID ClIncomingCallQoSChangeHandler;
    PVOID ClIncomingCloseCallHandler;
    PVOID ClIncomingDropPartyHandler;
    PVOID ClCallConnectedHandler;
    PVOID ClNotifyCloseAfHandler;
} NDIS_CO_CLIENT_OPTIONAL_HANDLERS, *PNDIS_CO_CLIENT_OPTIONAL_HANDLERS;

typedef struct _NDIS_PM_PARAMETERS
{
    NDIS_OBJECT_HEADER Header;
    ULONG              EnabledWoLPacketPatterns;
    ULONG              EnabledProtocolOffloads;
    ULONG              WakeUpFlags;
    ULONG              MediaSpecificWakeUpEvents;
} NDIS_PM_PARAMETERS, *PNDIS_PM_PARAMETERS;

typedef struct _NDIS_PM_PARAMETERS_7601
{
    /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    /* 0x0004 */ ULONG EnabledWoLPacketPatterns;
    /* 0x0008 */ ULONG EnabledProtocolOffloads;
    /* 0x000c */ ULONG WakeUpFlags;
} NDIS_PM_PARAMETERS_7601, *PNDIS_PM_PARAMETERS_7601; /* size: 0x0010 */

typedef enum _NDIS_OPEN_TRANSLATION_STATE
{
    OpenDontXlate = 0,
    OpenXlateExceptSends = 1,
    OpenXlateAll = 2,
} NDIS_OPEN_TRANSLATION_STATE, *PNDIS_OPEN_TRANSLATION_STATE;

//
// NDIS Win10 RS6+ specific
//

typedef enum _PKTMON_PACKET_TYPE
{
    PktMonPayload_Unknown = 0,
    PktMonPayload_Ethernet = 1,
    PktMonPayload_WiFi = 2,
    PktMonPayload_IP = 3,
    PktMonPayload_HTTP = 4,
    PktMonPayload_TCP = 5,
    PktMonPayload_UDP = 6,
    PktMonPayload_ARP = 7,
    PktMonPayload_ICMP = 8,
    PktMonPayload_ESP = 9,
    PktMonPayload_AH = 10,
    PktMonPayload_L4Payload = 11
} PKTMON_PACKET_TYPE, *PPKTMON_PACKET_TYPE;

typedef enum _PKTMON_COMPONENT_TYPE
{
    PktMonComp_Ndis = 1,
    PktMonComp_Miniport = 2,
    PktMonComp_Filter = 3,
    PktMonComp_Protocol = 4,
    PktMonComp_VmsVmNic = 5,
    PktMonComp_VmsMiniport = 6,
    PktMonComp_VmsExtMiniport = 7,
    PktMonComp_VmsProtocolNic = 8,
    PktMonComp_NetVsc = 9,
    PktMonComp_HTTP = 10,
    PktMonComp_IpInterface = 11,
    PktMonComp_Slbmux = 12,
    PktMonComp_Ipsec = 13,
    PktMonComp_NetCx = 14,
    PktMonComp_HTTPMessage = 15
} PKTMON_COMPONENT_TYPE, * PPKTMON_COMPONENT_TYPE;

typedef struct _PKTMON_COMPONENT_CONTEXT
{
    /* 0x0000 */ PVOID CompHandle;
    /* 0x0008 */ PKTMON_PACKET_TYPE PacketType;
    struct /* bitfield */
    {
        /* 0x000c */ int FlowEnabled : 1; /* bit position: 0 */
        /* 0x000c */ int DropEnabled : 1; /* bit position: 1 */
    }; /* bitfield */
} PKTMON_COMPONENT_CONTEXT, *PPKTMON_COMPONENT_CONTEXT; /* size: 0x0010 */

typedef struct _PKTMON_COMPONENT_CONTEXT_V2
{
    /* 0x0000 */ struct _LIST_ENTRY ListLink;
    /* 0x0010 */ struct _LIST_ENTRY EdgeList;
    /* 0x0020 */ long EdgeCount;
    /* 0x0024 */ long Padding_113;
    /* 0x0028 */ PVOID CompHandle;
    /* 0x0030 */ PKTMON_COMPONENT_TYPE CompType;
    /* 0x0034 */ PKTMON_PACKET_TYPE PacketType;
    struct /* bitfield */
    {
        /* 0x0038 */ int FlowEnabled : 1; /* bit position: 0 */
        /* 0x0038 */ int DropEnabled : 1; /* bit position: 1 */
    }; /* bitfield */
    /* 0x003c */ long __PADDING__[1];
} PKTMON_COMPONENT_CONTEXT_V2, * PPKTMON_COMPONENT_CONTEXT_V2; /* size: 0x0040 */

typedef struct _PKTMON_EDGE_CONTEXT
{
    /* 0x0000 */ PVOID EdgeHandle;
    /* 0x0008 */ PKTMON_COMPONENT_CONTEXT* CompContext;
    /* 0x0010 */ PKTMON_PACKET_TYPE PacketType;
} PKTMON_EDGE_CONTEXT, *PPKTMON_EDGE_CONTEXT; /* size: 0x0018 */

typedef struct _PKTMON_EDGE_CONTEXT_V2
{
    /* 0x0000 */ LIST_ENTRY ListLink;
    /* 0x0010 */ PVOID EdgeHandle;
    /* 0x0018 */ PKTMON_COMPONENT_CONTEXT* CompContext;
    /* 0x0020 */ enum _PKTMON_PACKET_TYPE PacketType;
} PKTMON_EDGE_CONTEXT_V2, * PPKTMON_EDGE_CONTEXT_V2; /* size: 0x0028 */

typedef struct _NDIS_OPEN_BLOCK_7601 {
    union
    {
        /* 0x0000 */ PVOID MacHandle;
        /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    }; /* size: 0x0008 */
    /* 0x0008 */ PVOID BindingHandle;
    /* 0x0010 */ struct _NDIS_MINIPORT_BLOCK* MiniportHandle;
    /* 0x0018 */ struct _NDIS_PROTOCOL_BLOCK* ProtocolHandle;
    /* 0x0020 */ PVOID ProtocolBindingContext;
    /* 0x0028 */ PVOID NextSendHandler;
    /* 0x0030 */ PVOID NextSendContext;
    /* 0x0038 */ PVOID MiniportAdapterContext;
    /* 0x0040 */ UCHAR Reserved1;
    /* 0x0041 */ UCHAR CallingFromNdis6Protocol;
    /* 0x0042 */ UCHAR Reserved3;
    /* 0x0043 */ UCHAR Reserved4;
    /* 0x0044 */ ULONG Padding1;
    /* 0x0048 */ PVOID NextReturnNetBufferListsHandler;
    /* 0x0050 */ unsigned __int64 Reserved5;
    /* 0x0058 */ PVOID NextReturnNetBufferListsContext;
    union
    {
        /* 0x0060 */ PVOID SendHandler;
        /* 0x0060 */ PVOID WanSendHandler;
    }; /* size: 0x0008 */
    /* 0x0068 */ PVOID TransferDataHandler;
    /* 0x0070 */ PVOID SendCompleteHandler;
    /* 0x0078 */ PVOID TransferDataCompleteHandler;
    /* 0x0080 */ PVOID ReceiveHandler;
    /* 0x0088 */ PVOID ReceiveCompleteHandler;
    /* 0x0090 */ PVOID WanReceiveHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    /* 0x00a0 */ PVOID ReceivePacketHandler;
    /* 0x00a8 */ PVOID SendPacketsHandler;
    /* 0x00b0 */ PVOID ResetHandler;
    /* 0x00b8 */ PVOID RequestHandler;
    /* 0x00c0 */ PVOID OidRequestHandler;
    /* 0x00c8 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x00d0 */ PVOID StatusHandler;
        /* 0x00d0 */ PVOID StatusHandlerEx;
    }; /* size: 0x0008 */
    /* 0x00d8 */ PVOID StatusCompleteHandler;
    /* 0x00e0 */ ULONG Flags;
    /* 0x00e4 */ LONG References;
    /* 0x00e8 */ unsigned __int64 SpinLock;
    /* 0x00f0 */ PVOID FilterHandle;
    /* 0x00f8 */ UINT FrameTypeArraySize;
    /* 0x00fc */ USHORT FrameTypeArray[4];
    /* 0x0104 */ ULONG ProtocolOptions;
    /* 0x0108 */ ULONG CurrentLookahead;
    /* 0x010c */ ULONG Padding2;
    /* 0x0110 */ PVOID WSendHandler;
    /* 0x0118 */ PVOID WTransferDataHandler;
    /* 0x0120 */ PVOID WSendPacketsHandler;
    /* 0x0128 */ PVOID CancelSendPacketsHandler;
    /* 0x0130 */ ULONG WakeUpEnable;
    /* 0x0134 */ NDIS_PM_PARAMETERS_7601 PMCurrentParameters;
    /* 0x0144 */ ULONG Padding3;
    /* 0x0148 */ struct _KEVENT* CloseCompleteEvent;
    /* 0x0150 */ struct _QUEUED_CLOSE QC;
    /* 0x0178 */ long AfReferences;
    /* 0x017c */ long Padding_278;
    /* 0x0180 */ struct _NDIS_OPEN_BLOCK* NextGlobalOpen;
    /* 0x0188 */ struct _NDIS_OPEN_BLOCK* MiniportNextOpen;
    /* 0x0190 */ struct _NDIS_OPEN_BLOCK* ProtocolNextOpen;
    /* 0x0198 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01a0 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01a8 */ struct _NDIS_OPEN_BLOCK* FilterNextOpen;
    /* 0x01b0 */ unsigned int PacketFilters;
    /* 0x01b4 */ unsigned int OldPacketFilters;
    union
    {
        struct
        {
            /* 0x01b8 */ unsigned int MaxMulticastAddresses;
            /* 0x01bc */ long Padding_279;
            /* 0x01c0 */ struct _ETH_MULTICAST_WRAPPER* MCastAddressBuf;
            /* 0x01c8 */ unsigned int NumAddresses;
            /* 0x01cc */ long Padding_280;
            /* 0x01d0 */ struct _ETH_MULTICAST_WRAPPER* OldMCastAddressBuf;
            /* 0x01d8 */ unsigned int OldNumAddresses;
        }; /* size: 0x001c */
        struct
        {
            /* 0x01b8 */ unsigned long FunctionalAddress;
            /* 0x01bc */ unsigned long OldFunctionalAddress;
            /* 0x01c0 */ unsigned char UsingGroupAddress;
            /* 0x01c1 */ unsigned char OldUsingGroupAddress;
            /* 0x01c2 */ char Padding_281[2];
            /* 0x01c4 */ unsigned long FARefCount[32];
            /* 0x0244 */ unsigned long OldFARefCount[32];
            /* 0x02c4 */ long Padding_282[3];
            /* 0x02d0 */ unsigned char RSSParametersBuf[656];
            /* 0x0560 */ struct _NDIS_RECEIVE_SCALE_PARAMETERS* NdisRSSParameters;
            /* 0x0568 */ SINGLE_LIST_ENTRY PatternList;
            /* 0x0570 */ SINGLE_LIST_ENTRY WOLPatternList;
            /* 0x0578 */ SINGLE_LIST_ENTRY PMProtocolOffloadList;
            /* 0x0580 */ PVOID ProtSendNetBufferListsComplete;
            /* 0x0588 */ PVOID SendCompleteNdisPacketContext;
            /* 0x0590 */ PVOID SendCompleteNetBufferListsContext;
            /* 0x0598 */ PVOID ReceiveNetBufferLists;
            /* 0x05a0 */ PVOID ReceiveNetBufferListsContext;
            /* 0x05a8 */ PVOID SavedSendNBLHandler;
            /* 0x05b0 */ PVOID SavedSendPacketsHandler;
            /* 0x05b8 */ PVOID SavedCancelSendPacketsHandler;
            union
            {
                /* 0x05c0 */ PVOID SavedSendHandler;
                /* 0x05c0 */ PVOID SavedWanSendHandler;
            }; /* size: 0x0008 */
            /* 0x05c8 */ PVOID InitiateOffloadCompleteHandler;
            /* 0x05d0 */ PVOID TerminateOffloadCompleteHandler;
            /* 0x05d8 */ PVOID UpdateOffloadCompleteHandler;
            /* 0x05e0 */ PVOID InvalidateOffloadCompleteHandler;
            /* 0x05e8 */ PVOID QueryOffloadCompleteHandler;
            /* 0x05f0 */ PVOID IndicateOffloadEventHandler;
            /* 0x05f8 */ PVOID TcpOffloadSendCompleteHandler;
            /* 0x0600 */ PVOID TcpOffloadReceiveCompleteHandler;
            /* 0x0608 */ PVOID TcpOffloadDisconnectCompleteHandler;
            /* 0x0610 */ PVOID TcpOffloadForwardCompleteHandler;
            /* 0x0618 */ PVOID TcpOffloadEventHandler;
            /* 0x0620 */ PVOID TcpOffloadReceiveIndicateHandler;
            /* 0x0628 */ unsigned long ProtocolMajorVersion;
            /* 0x062c */ long Padding_283;
            /* 0x0630 */ PVOID* IfBlock;
            /* 0x0638 */ NDIS_SPIN_LOCK PnPStateLock;
            /* 0x0648 */ NDIS_NDIS5_DRIVER_STATE PnPState;
            /* 0x064c */ NDIS_OPEN_TRANSLATION_STATE TranslationState;
            /* 0x0650 */ int OutstandingSends;
            /* 0x0654 */ long Padding_284;
            /* 0x0658 */ NDIS_EVENT PauseEvent;
            /* 0x0670 */ PVOID Ndis5WanSendHandler;
            /* 0x0678 */ PVOID ProtSendCompleteHandler;
            /* 0x0680 */ PVOID OidRequestCompleteHandler;
            /* 0x0688 */ PVOID OidRequestCompleteContext;
            /* 0x0690 */ long NumOfPauseRestartRequests;
            /* 0x0694 */ NDIS_OPEN_STATE State;
            /* 0x0698 */ struct _NDIS_OPEN_OFFLOAD* Offload;
            /* 0x06a0 */ struct _NDIS_STATUS_UNBIND_WORKITEM* StatusUnbindWorkItem;
            /* 0x06a8 */ unsigned __int64 DpcStartCycle;
            /* 0x06b0 */ unsigned long NumberOfNetBufferLists;
            /* 0x06b4 */ long Padding_285;
            /* 0x06b8 */ unsigned char* ReceivedAPacket;
            /* 0x06c0 */ PVOID DirectOidRequestCompleteHandler;
            /* 0x06c8 */ PVOID DirectOidRequestHandler;
            /* 0x06d0 */ PVOID DirectOidRequestCompleteContext;
            /* 0x06d8 */ LIST_ENTRY ReceiveQueueList;
            /* 0x06e8 */ unsigned long NumReceiveQueues;
            /* 0x06ec */ long Padding_286;
            /* 0x06f0 */ LIST_ENTRY SharedMemoryBlockList;
            /* 0x0700 */ PVOID AllocateSharedMemoryHandler;
            /* 0x0708 */ PVOID FreeSharedMemoryHandler;
            /* 0x0710 */ PVOID AllocateSharedMemoryContext;
            /* 0x0718 */ long Padding_287[2];
            /* 0x0720 */ struct _NDIS_CO_AF_BLOCK* NextAf;
            /* 0x0728 */ PVOID MiniportCoCreateVcHandler;
            /* 0x0730 */ PVOID MiniportCoRequestHandler;
            /* 0x0738 */ PVOID CoCreateVcHandler;
            /* 0x0740 */ PVOID CoDeleteVcHandler;
            /* 0x0748 */ PVOID CmActivateVcCompleteHandler;
            /* 0x0750 */ PVOID CmDeactivateVcCompleteHandler;
            /* 0x0758 */ PVOID CoRequestCompleteHandler;
            /* 0x0760 */ PVOID CoRequestHandler;
            /* 0x0768 */ LIST_ENTRY ActiveVcHead;
            /* 0x0778 */ LIST_ENTRY InactiveVcHead;
            /* 0x0788 */ long PendingAfNotifications;
            /* 0x078c */ long Padding_288;
            /* 0x0790 */ struct _KEVENT* AfNotifyCompleteEvent;
            /* 0x0798 */ PVOID MiniportCoOidRequestHandler;
            /* 0x07a0 */ PVOID CoOidRequestCompleteHandler;
            /* 0x07a8 */ PVOID CoOidRequestHandler;
        }; /* size: 0x05ce */
    }; /* size: 0x05ce */
} NDIS_OPEN_BLOCK_7601, *PNDIS_OPEN_BLOCK_7601; /* size: 0x07b0 */

typedef struct _NDIS_OPEN_BLOCK_9200
{
    union
    {
        /* 0x0000 */ PVOID MacHandle;
        /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    }; /* size: 0x0008 */
    /* 0x0008 */ PVOID BindingHandle;
    /* 0x0010 */ struct _NDIS_MINIPORT_BLOCK* MiniportHandle;
    /* 0x0018 */ struct _NDIS_PROTOCOL_BLOCK* ProtocolHandle;
    /* 0x0020 */ PVOID ProtocolBindingContext;
    /* 0x0028 */ PVOID NextSendHandler;
    /* 0x0030 */ PVOID NextSendContext;
    /* 0x0038 */ PVOID MiniportAdapterContext;
    /* 0x0040 */ UCHAR Reserved1;
    /* 0x0041 */ UCHAR CallingFromNdis6Protocol;
    /* 0x0042 */ UCHAR Reserved3;
    /* 0x0043 */ UCHAR Reserved4;
    /* 0x0044 */ long Padding_47;
    /* 0x0048 */ PVOID NextReturnNetBufferListsHandler;
    /* 0x0050 */ unsigned __int64 Reserved5;
    /* 0x0058 */ PVOID NextReturnNetBufferListsContext;
    union
    {
        /* 0x0060 */ PVOID SendHandler;
        /* 0x0060 */ PVOID WanSendHandler;
    }; /* size: 0x0008 */
    /* 0x0068 */ PVOID TransferDataHandler;
    /* 0x0070 */ PVOID SendCompleteHandler;
    /* 0x0078 */ PVOID TransferDataCompleteHandler;
    /* 0x0080 */ PVOID ReceiveHandler;
    /* 0x0088 */ PVOID ReceiveCompleteHandler;
    /* 0x0090 */ PVOID WanReceiveHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    /* 0x00a0 */ PVOID ReceivePacketHandler;
    /* 0x00a8 */ PVOID SendPacketsHandler;
    /* 0x00b0 */ PVOID ResetHandler;
    /* 0x00b8 */ PVOID RequestHandler;
    /* 0x00c0 */ PVOID OidRequestHandler;
    /* 0x00c8 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x00d0 */ PVOID StatusHandler;
        /* 0x00d0 */ PVOID StatusHandlerEx;
    }; /* size: 0x0008 */
    /* 0x00d8 */ PVOID StatusCompleteHandler;
    /* 0x00e0 */ volatile ULONG OpenFlags;
    /* 0x00e4 */ long References;
    /* 0x00e8 */ unsigned __int64 SpinLock;
    /* 0x00f0 */ PVOID FilterHandle;
    /* 0x00f8 */ unsigned int FrameTypeArraySize;
    /* 0x00fc */ unsigned short FrameTypeArray[4];
    /* 0x0104 */ ULONG ProtocolOptions;
    /* 0x0108 */ ULONG CurrentLookahead;
    /* 0x010c */ long Padding_48;
    /* 0x0110 */ PVOID WSendHandler;
    /* 0x0118 */ PVOID WTransferDataHandler;
    /* 0x0120 */ PVOID WSendPacketsHandler;
    /* 0x0128 */ PVOID CancelSendPacketsHandler;
    /* 0x0130 */ ULONG WakeUpEnable;
    /* 0x0134 */ NDIS_PM_PARAMETERS PMCurrentParameters;
    /* 0x0148 */ KEVENT* CloseCompleteEvent;
    /* 0x0150 */ QUEUED_CLOSE QC;
    /* 0x0178 */ long AfReferences;
    /* 0x017c */ long Padding_49;
    /* 0x0180 */ struct _NDIS_OPEN_BLOCK* NextGlobalOpen;
    /* 0x0188 */ struct _NDIS_OPEN_BLOCK* MiniportNextOpen;
    /* 0x0190 */ struct _NDIS_OPEN_BLOCK* ProtocolNextOpen;
    /* 0x0198 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01a0 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01a8 */ struct _NDIS_OPEN_BLOCK* FilterNextOpen;
    /* 0x01b0 */ unsigned int PacketFilters;
    /* 0x01b4 */ unsigned int OldPacketFilters;
    /* 0x01b8 */ unsigned int MaxMulticastAddresses;
    /* 0x01bc */ long Padding_50;
    /* 0x01c0 */ struct _ETH_MULTICAST_WRAPPER* MCastAddressBuf;
    /* 0x01c8 */ unsigned int NumAddresses;
    /* 0x01cc */ long Padding_51;
    /* 0x01d0 */ struct _ETH_MULTICAST_WRAPPER* OldMCastAddressBuf;
    /* 0x01d8 */ unsigned int OldNumAddresses;
    /* 0x01dc */ long Padding_52;
    /* 0x01e0 */ UCHAR* RssParametersBuffer;
    /* 0x01e8 */ struct _NDIS_RECEIVE_SCALE_PARAMETERS* NdisRSSParameters;
    /* 0x01f0 */ SINGLE_LIST_ENTRY PatternList;
    /* 0x01f8 */ SINGLE_LIST_ENTRY WOLPatternList;
    /* 0x0200 */ SINGLE_LIST_ENTRY PMProtocolOffloadList;
    /* 0x0208 */ PVOID ProtSendNetBufferListsComplete;
    /* 0x0210 */ PVOID SendCompleteNdisPacketContext;
    /* 0x0218 */ PVOID SendCompleteNetBufferListsContext;
    /* 0x0220 */ PVOID ReceiveNetBufferLists;
    /* 0x0228 */ PVOID ReceiveNetBufferListsContext;
    /* 0x0230 */ PVOID SavedSendPacketsHandler;
    /* 0x0238 */ PVOID SavedCancelSendPacketsHandler;
    /* 0x0240 */ PVOID SavedSendHandler;
    /* 0x0248 */ PVOID InitiateOffloadCompleteHandler;
    /* 0x0250 */ PVOID TerminateOffloadCompleteHandler;
    /* 0x0258 */ PVOID UpdateOffloadCompleteHandler;
    /* 0x0260 */ PVOID InvalidateOffloadCompleteHandler;
    /* 0x0268 */ PVOID QueryOffloadCompleteHandler;
    /* 0x0270 */ PVOID IndicateOffloadEventHandler;
    /* 0x0278 */ PVOID TcpOffloadSendCompleteHandler;
    /* 0x0280 */ PVOID TcpOffloadReceiveCompleteHandler;
    /* 0x0288 */ PVOID TcpOffloadDisconnectCompleteHandler;
    /* 0x0290 */ PVOID TcpOffloadForwardCompleteHandler;
    /* 0x0298 */ PVOID TcpOffloadEventHandler;
    /* 0x02a0 */ PVOID TcpOffloadReceiveIndicateHandler;
    /* 0x02a8 */ struct NDIS_NBL_TRACKER_HANDLE__* NblTracker;
    /* 0x02b0 */ struct NDIS_REFCOUNT_HANDLE__* RefCountTracker;
    /* 0x02b8 */ unsigned __int64 RefCountLock;
    /* 0x02c0 */ ULONG ProtocolMajorVersion;
    /* 0x02c4 */ long Padding_53;
    /* 0x02c8 */ PVOID *IfBlock;
    /* 0x02d0 */ NDIS_SPIN_LOCK PnPStateLock;
    /* 0x02e0 */ NDIS_NDIS5_DRIVER_STATE PnPState;
    /* 0x02e4 */ int OutstandingSends;
    /* 0x02e8 */ NDIS_EVENT PauseEvent;
    /* 0x0300 */ PVOID Ndis5WanSendHandler;
    /* 0x0308 */ PVOID ProtSendCompleteHandler;
    /* 0x0310 */ PVOID OidRequestCompleteHandler;
    /* 0x0318 */ long NumOfPauseRestartRequests;
    /* 0x031c */ NDIS_OPEN_STATE State;
    /* 0x0320 */ struct _NDIS_OPEN_OFFLOAD* Offload;
    /* 0x0328 */ struct _NDIS_STATUS_UNBIND_WORKITEM* StatusUnbindWorkItem;
    /* 0x0330 */ unsigned __int64 DpcStartCycle;
    /* 0x0338 */ struct PNDIS_PER_PROCESSOR_SLOT__* ReceivedAPacketSlot;
    /* 0x0340 */ PVOID DirectOidRequestHandler;
    /* 0x0348 */ LIST_ENTRY ReceiveQueueList;
    /* 0x0358 */ ULONG NumReceiveQueues;
    /* 0x035c */ long Padding_54;
    /* 0x0360 */ LIST_ENTRY SharedMemoryBlockList;
    /* 0x0370 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0378 */ PVOID FreeSharedMemoryHandler;
    /* 0x0380 */ PVOID AllocateSharedMemoryContext;
    /* 0x0388 */ struct _NDIS_COMPOSITE_BUS_INFORMATION* CompositeBus;
    /* 0x0390 */ ULONG NumAllocatedVFs;
    /* 0x0394 */ long Padding_55;
    /* 0x0398 */ LIST_ENTRY VFList;
    /* 0x03a8 */ ULONG NumActiveVPorts;
    /* 0x03ac */ long Padding_56;
    /* 0x03b0 */ LIST_ENTRY VPortList;
    /* 0x03c0 */ NDIS_OPEN_UNBIND_REASON UnbindReason;
    /* 0x03c4 */ ULONG AoAcReferences;
    /* 0x03c8 */ struct _NDIS_CO_AF_BLOCK* NextAf;
    /* 0x03d0 */ PVOID MiniportCoCreateVcHandler;
    /* 0x03d8 */ PVOID MiniportCoRequestHandler;
    /* 0x03e0 */ PVOID CoCreateVcHandler;
    /* 0x03e8 */ PVOID CoDeleteVcHandler;
    /* 0x03f0 */ PVOID CmActivateVcCompleteHandler;
    /* 0x03f8 */ PVOID CmDeactivateVcCompleteHandler;
    /* 0x0400 */ PVOID CoRequestCompleteHandler;
    /* 0x0408 */ PVOID CoRequestHandler;
    /* 0x0410 */ LIST_ENTRY ActiveVcHead;
    /* 0x0420 */ LIST_ENTRY InactiveVcHead;
    /* 0x0430 */ long PendingAfNotifications;
    /* 0x0434 */ long Padding_57;
    /* 0x0438 */ KEVENT* AfNotifyCompleteEvent;
    /* 0x0440 */ PVOID MiniportCoOidRequestHandler;
    /* 0x0448 */ PVOID CoOidRequestCompleteHandler;
    /* 0x0450 */ PVOID CoOidRequestHandler;
} NDIS_OPEN_BLOCK_9200, *PNDIS_OPEN_BLOCK_9200; /* size: 0x0458 */

typedef struct _NDIS_OPEN_BLOCK_9600_10586
{
    /* 0x0000 */ long Padding_302[252]; //NDIS_COMMON_OPEN_BLOCK
    /* 0x03f0 */ struct _NDIS_CO_AF_BLOCK* NextAf;
    /* 0x03f8 */ PVOID MiniportCoCreateVcHandler;
    /* 0x0400 */ PVOID MiniportCoRequestHandler;
    /* 0x0408 */ PVOID CoCreateVcHandler;
    /* 0x0410 */ PVOID CoDeleteVcHandler;
    /* 0x0418 */ PVOID CmActivateVcCompleteHandler;
    /* 0x0420 */ PVOID CmDeactivateVcCompleteHandler;
    /* 0x0428 */ PVOID CoRequestCompleteHandler;
    /* 0x0430 */ PVOID CoRequestHandler;
    /* 0x0438 */ LIST_ENTRY ActiveVcHead;
    /* 0x0448 */ LIST_ENTRY InactiveVcHead;
    /* 0x0458 */ long PendingAfNotifications;
    /* 0x045c */ long Padding_303;
    /* 0x0460 */ KEVENT* AfNotifyCompleteEvent;
    /* 0x0468 */ PVOID MiniportCoOidRequestHandler;
    /* 0x0470 */ PVOID CoOidRequestCompleteHandler;
    /* 0x0478 */ PVOID CoOidRequestHandler;
} NDIS_OPEN_BLOCK_9600_10586, *PNDIS_OPEN_BLOCK_9600_10586; /* size: 0x0480 */

typedef struct _NDIS_OPEN_BLOCK_14393_17134
{
    /* 0x0000 */ long Padding_7[254]; //NDIS_COMMON_OPEN_BLOCK
    /* 0x03f8 */ struct _NDIS_CO_AF_BLOCK* NextAf;
    /* 0x0400 */ PVOID MiniportCoCreateVcHandler;
    /* 0x0408 */ PVOID MiniportCoRequestHandler;
    /* 0x0410 */ PVOID CoCreateVcHandler;
    /* 0x0418 */ PVOID CoDeleteVcHandler;
    /* 0x0420 */ PVOID CmActivateVcCompleteHandler;
    /* 0x0428 */ PVOID CmDeactivateVcCompleteHandler;
    /* 0x0430 */ PVOID CoRequestCompleteHandler;
    /* 0x0438 */ PVOID CoRequestHandler;
    /* 0x0440 */ LIST_ENTRY ActiveVcHead;
    /* 0x0450 */ LIST_ENTRY InactiveVcHead;
    /* 0x0460 */ long PendingAfNotifications;
    /* 0x0464 */ long Padding_8;
    /* 0x0468 */ KEVENT* AfNotifyCompleteEvent;
    /* 0x0470 */ PVOID MiniportCoOidRequestHandler;
    /* 0x0478 */ PVOID CoOidRequestCompleteHandler;
    /* 0x0480 */ PVOID CoOidRequestHandler;
} NDIS_OPEN_BLOCK_14393_17134, *PNDIS_OPEN_BLOCK_14393_17134; /* size: 0x0488 */

typedef struct _NDIS_OPEN_BLOCK_17763_22000
{
    /* 0x0000 */ long Padding_297[240]; //NDIS_COMMON_OPEN_BLOCK
    /* 0x03c0 */ struct _NDIS_CO_AF_BLOCK* NextAf;
    /* 0x03c8 */ PVOID MiniportCoCreateVcHandler;
    /* 0x03d0 */ PVOID MiniportCoRequestHandler;
    /* 0x03d8 */ PVOID CoCreateVcHandler;
    /* 0x03e0 */ PVOID CoDeleteVcHandler;
    /* 0x03e8 */ PVOID CmActivateVcCompleteHandler;
    /* 0x03f0 */ PVOID CmDeactivateVcCompleteHandler;
    /* 0x03f8 */ PVOID CoRequestCompleteHandler;
    /* 0x0400 */ PVOID CoRequestHandler;
    /* 0x0408 */ LIST_ENTRY ActiveVcHead;
    /* 0x0418 */ LIST_ENTRY InactiveVcHead;
    /* 0x0428 */ long PendingAfNotifications;
    /* 0x042c */ long Padding_298;
    /* 0x0430 */ struct _KEVENT* AfNotifyCompleteEvent;
    /* 0x0438 */ PVOID MiniportCoOidRequestHandler;
    /* 0x0440 */ PVOID CoOidRequestCompleteHandler;
    /* 0x0448 */ PVOID CoOidRequestHandler;
} NDIS_OPEN_BLOCK_17763_22000, *PNDIS_OPEN_BLOCK_17763_22000; /* size: 0x0450 */

typedef struct _NDIS_OPEN_BLOCK_22621_25905
{
    /* 0x0000 */ long Padding_293[256]; //NDIS_COMMON_OPEN_BLOCK
    /* 0x0400 */ struct _NDIS_CO_AF_BLOCK* NextAf;
    /* 0x0408 */ void* MiniportCoCreateVcHandler /* function */;
    /* 0x0410 */ void* MiniportCoRequestHandler /* function */;
    /* 0x0418 */ void* CoCreateVcHandler /* function */;
    /* 0x0420 */ void* CoDeleteVcHandler /* function */;
    /* 0x0428 */ void* CmActivateVcCompleteHandler /* function */;
    /* 0x0430 */ void* CmDeactivateVcCompleteHandler /* function */;
    /* 0x0438 */ void* CoRequestCompleteHandler /* function */;
    /* 0x0440 */ void* CoRequestHandler /* function */;
    /* 0x0448 */ struct _LIST_ENTRY ActiveVcHead;
    /* 0x0458 */ struct _LIST_ENTRY InactiveVcHead;
    /* 0x0468 */ long PendingAfNotifications;
    /* 0x046c */ long Padding_294;
    /* 0x0470 */ struct _KEVENT* AfNotifyCompleteEvent;
    /* 0x0478 */ void* MiniportCoOidRequestHandler /* function */;
    /* 0x0480 */ void* CoOidRequestCompleteHandler /* function */;
    /* 0x0488 */ void* CoOidRequestHandler /* function */;
} NDIS_OPEN_BLOCK_22621_25905, * PNDIS_OPEN_BLOCK_22621_25905; /* size: 0x0490 */

typedef struct _NDIS_COMMON_OPEN_BLOCK_9600_10586
{
    union
    {
        /* 0x0000 */ PVOID MacHandle;
        /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    }; /* size: 0x0008 */
    /* 0x0008 */ PVOID BindingHandle;
    /* 0x0010 */ struct _NDIS_MINIPORT_BLOCK* MiniportHandle;
    /* 0x0018 */ struct _NDIS_PROTOCOL_BLOCK* ProtocolHandle;
    /* 0x0020 */ PVOID ProtocolBindingContext;
    /* 0x0028 */ PVOID NextSendHandler;
    /* 0x0030 */ PVOID NextSendContext;
    /* 0x0038 */ PVOID MiniportAdapterContext;
    /* 0x0040 */ UCHAR Reserved1;
    /* 0x0041 */ UCHAR CallingFromNdis6Protocol;
    /* 0x0042 */ UCHAR Reserved3;
    /* 0x0043 */ UCHAR Reserved4;
    /* 0x0044 */ long Padding_439;
    /* 0x0048 */ PVOID NextReturnNetBufferListsHandler;
    /* 0x0050 */ unsigned __int64 Reserved5;
    /* 0x0058 */ PVOID NextReturnNetBufferListsContext;
    union
    {
        /* 0x0060 */ PVOID SendHandler;
        /* 0x0060 */ PVOID WanSendHandler;
    }; /* size: 0x0008 */
    /* 0x0068 */ PVOID TransferDataHandler;
    /* 0x0070 */ PVOID SendCompleteHandler;
    /* 0x0078 */ PVOID TransferDataCompleteHandler;
    /* 0x0080 */ PVOID ReceiveHandler;
    /* 0x0088 */ PVOID ReceiveCompleteHandler;
    /* 0x0090 */ PVOID WanReceiveHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    /* 0x00a0 */ PVOID ReceivePacketHandler;
    /* 0x00a8 */ PVOID SendPacketsHandler;
    /* 0x00b0 */ PVOID ResetHandler;
    /* 0x00b8 */ PVOID RequestHandler;
    /* 0x00c0 */ PVOID OidRequestHandler;
    /* 0x00c8 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x00d0 */ PVOID StatusHandler;
        /* 0x00d0 */ PVOID StatusHandlerEx;
    }; /* size: 0x0008 */
    /* 0x00d8 */ PVOID StatusCompleteHandler;
    /* 0x00e0 */ volatile ULONG OpenFlags;
    /* 0x00e4 */ long References;
    /* 0x00e8 */ unsigned __int64 SpinLock;
    /* 0x00f0 */ PVOID FilterHandle;
    /* 0x00f8 */ unsigned int FrameTypeArraySize;
    /* 0x00fc */ unsigned short FrameTypeArray[4];
    /* 0x0104 */ ULONG ProtocolOptions;
    /* 0x0108 */ ULONG CurrentLookahead;
    /* 0x010c */ long Padding_440;
    /* 0x0110 */ PVOID WSendHandler;
    /* 0x0118 */ PVOID WTransferDataHandler;
    /* 0x0120 */ PVOID WSendPacketsHandler;
    /* 0x0128 */ PVOID CancelSendPacketsHandler;
    /* 0x0130 */ ULONG WakeUpEnable;
    /* 0x0134 */ NDIS_PM_PARAMETERS PMCurrentParameters;
    /* 0x0148 */ struct _KEVENT* CloseCompleteEvent;
    /* 0x0150 */ QUEUED_CLOSE QC;
    /* 0x0178 */ long AfReferences;
    /* 0x017c */ long Padding_441;
    /* 0x0180 */ struct _NDIS_OPEN_BLOCK* NextGlobalOpen;
    /* 0x0188 */ struct _NDIS_OPEN_BLOCK* MiniportNextOpen;
    /* 0x0190 */ struct _NDIS_OPEN_BLOCK* ProtocolNextOpen;
    /* 0x0198 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01a0 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01a8 */ struct _NDIS_OPEN_BLOCK* FilterNextOpen;
    /* 0x01b0 */ unsigned int PacketFilters;
    /* 0x01b4 */ unsigned int OldPacketFilters;
    /* 0x01b8 */ unsigned int MaxMulticastAddresses;
    /* 0x01bc */ long Padding_442;
    /* 0x01c0 */ struct _ETH_MULTICAST_WRAPPER* MCastAddressBuf;
    /* 0x01c8 */ unsigned int NumAddresses;
    /* 0x01cc */ long Padding_443;
    /* 0x01d0 */ struct _ETH_MULTICAST_WRAPPER* OldMCastAddressBuf;
    /* 0x01d8 */ unsigned int OldNumAddresses;
    /* 0x01dc */ long Padding_444;
    /* 0x01e0 */ UCHAR* RssParametersBuffer;
    /* 0x01e8 */ struct _NDIS_RECEIVE_SCALE_PARAMETERS* NdisRSSParameters;
    /* 0x01f0 */ SINGLE_LIST_ENTRY PatternList;
    /* 0x01f8 */ SINGLE_LIST_ENTRY WOLPatternList;
    /* 0x0200 */ SINGLE_LIST_ENTRY PMProtocolOffloadList;
    /* 0x0208 */ PVOID ProtSendNetBufferListsComplete;
    /* 0x0210 */ PVOID SendCompleteNdisPacketContext;
    /* 0x0218 */ PVOID SendCompleteNetBufferListsContext;
    /* 0x0220 */ PVOID ReceiveNetBufferLists;
    /* 0x0228 */ PVOID ReceiveNetBufferListsContext;
    /* 0x0230 */ PVOID SavedSendPacketsHandler;
    /* 0x0238 */ PVOID SavedCancelSendPacketsHandler;
    /* 0x0240 */ PVOID SavedSendHandler;
    /* 0x0248 */ PVOID InitiateOffloadCompleteHandler;
    /* 0x0250 */ PVOID TerminateOffloadCompleteHandler;
    /* 0x0258 */ PVOID UpdateOffloadCompleteHandler;
    /* 0x0260 */ PVOID InvalidateOffloadCompleteHandler;
    /* 0x0268 */ PVOID QueryOffloadCompleteHandler;
    /* 0x0270 */ PVOID IndicateOffloadEventHandler;
    /* 0x0278 */ PVOID TcpOffloadSendCompleteHandler;
    /* 0x0280 */ PVOID TcpOffloadReceiveCompleteHandler;
    /* 0x0288 */ PVOID TcpOffloadDisconnectCompleteHandler;
    /* 0x0290 */ PVOID TcpOffloadForwardCompleteHandler;
    /* 0x0298 */ PVOID TcpOffloadEventHandler;
    /* 0x02a0 */ PVOID TcpOffloadReceiveIndicateHandler;
    /* 0x02a8 */ struct NDIS_NBL_TRACKER_HANDLE__* NblTracker;
    /* 0x02b0 */ struct NDIS_REFCOUNT_HANDLE__* RefCountTracker;
    /* 0x02b8 */ unsigned __int64 RefCountLock;
    /* 0x02c0 */ ULONG ProtocolMajorVersion;
    /* 0x02c4 */ long Padding_445;
    /* 0x02c8 */ PVOID *IfBlock;
    /* 0x02d0 */ NDIS_SPIN_LOCK PnPStateLock;
    /* 0x02e0 */ NDIS_NDIS5_DRIVER_STATE PnPState;
    /* 0x02e4 */ int OutstandingSends;
    /* 0x02e8 */ NDIS_EVENT PauseEvent;
    /* 0x0300 */ PVOID Ndis5WanSendHandler;
    /* 0x0308 */ PVOID ProtSendCompleteHandler;
    /* 0x0310 */ PVOID OidRequestCompleteHandler;
    /* 0x0318 */ struct _NDIS_OPEN_OFFLOAD* Offload;
    /* 0x0320 */ struct _NDIS_STATUS_UNBIND_WORKITEM* StatusUnbindWorkItem;
    /* 0x0328 */ unsigned __int64 DpcStartCycle;
    /* 0x0330 */ struct PNDIS_PER_PROCESSOR_SLOT__* ReceivedAPacketSlot;
    /* 0x0338 */ PVOID DirectOidRequestHandler;
    /* 0x0340 */ LIST_ENTRY ReceiveQueueList;
    /* 0x0350 */ ULONG NumReceiveQueues;
    /* 0x0354 */ long Padding_446;
    /* 0x0358 */ LIST_ENTRY SharedMemoryBlockList;
    /* 0x0368 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0370 */ PVOID FreeSharedMemoryHandler;
    /* 0x0378 */ PVOID AllocateSharedMemoryContext;
    /* 0x0380 */ ULONG NumAllocatedVFs;
    /* 0x0384 */ long Padding_447;
    /* 0x0388 */ LIST_ENTRY VFList;
    /* 0x0398 */ ULONG NumActiveVPorts;
    /* 0x039c */ long Padding_448;
    /* 0x03a0 */ LIST_ENTRY VPortList;
    /* 0x03b0 */ ULONG AoAcReferences;
    /* 0x03b4 */ long Padding_449;
    /* 0x03b8 */ struct NDIS_BIND_PROTOCOL_LINK* Bind;
    /* 0x03c0 */ WORK_QUEUE_ITEM UnsolicitedUnbindComplete;
    /* 0x03e0 */ KEVENT* UnsolicitedUnbindEvent;
    /* 0x03e8 */ char PendingLegacyUnbind;
    /* 0x03e9 */ char __PADDING__[7];
} NDIS_COMMON_OPEN_BLOCK_9600_10586, *PNDIS_COMMON_OPEN_BLOCK_9600_10586; /* size: 0x03f0 */

typedef struct _NDIS_COMMON_OPEN_BLOCK_14393_17134
{
    union
    {
        /* 0x0000 */ PVOID MacHandle;
        /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    }; /* size: 0x0008 */
    /* 0x0008 */ PVOID BindingHandle;
    /* 0x0010 */ struct _NDIS_MINIPORT_BLOCK* MiniportHandle;
    /* 0x0018 */ struct _NDIS_PROTOCOL_BLOCK* ProtocolHandle;
    /* 0x0020 */ PVOID ProtocolBindingContext;
    /* 0x0028 */ PVOID NextSendHandler;
    /* 0x0030 */ PVOID NextSendContext;
    /* 0x0038 */ PVOID MiniportAdapterContext;
    /* 0x0040 */ UCHAR Reserved1;
    /* 0x0041 */ UCHAR CallingFromNdis6Protocol;
    /* 0x0042 */ UCHAR Reserved3;
    /* 0x0043 */ UCHAR Reserved4;
    /* 0x0044 */ long Padding_374;
    /* 0x0048 */ PVOID NextReturnNetBufferListsHandler;
    /* 0x0050 */ unsigned __int64 Reserved5;
    /* 0x0058 */ PVOID NextReturnNetBufferListsContext;
    union
    {
        /* 0x0060 */ PVOID SendHandler;
        /* 0x0060 */ PVOID WanSendHandler;
    }; /* size: 0x0008 */
    /* 0x0068 */ PVOID TransferDataHandler;
    /* 0x0070 */ PVOID SendCompleteHandler;
    /* 0x0078 */ PVOID TransferDataCompleteHandler;
    /* 0x0080 */ PVOID ReceiveHandler;
    /* 0x0088 */ PVOID ReceiveCompleteHandler;
    /* 0x0090 */ PVOID WanReceiveHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    /* 0x00a0 */ PVOID ReceivePacketHandler;
    /* 0x00a8 */ PVOID SendPacketsHandler;
    /* 0x00b0 */ PVOID ResetHandler;
    /* 0x00b8 */ PVOID RequestHandler;
    /* 0x00c0 */ PVOID OidRequestHandler;
    /* 0x00c8 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x00d0 */ PVOID StatusHandler;
        /* 0x00d0 */ PVOID StatusHandlerEx;
    }; /* size: 0x0008 */
    /* 0x00d8 */ PVOID StatusCompleteHandler;
    /* 0x00e0 */ volatile ULONG OpenFlags;
    /* 0x00e4 */ long References;
    /* 0x00e8 */ unsigned __int64 SpinLock;
    /* 0x00f0 */ PVOID FilterHandle;
    /* 0x00f8 */ unsigned int FrameTypeArraySize;
    /* 0x00fc */ unsigned short FrameTypeArray[4];
    /* 0x0104 */ ULONG ProtocolOptions;
    /* 0x0108 */ ULONG CurrentLookahead;
    /* 0x010c */ long Padding_375;
    /* 0x0110 */ PVOID WSendHandler;
    /* 0x0118 */ PVOID WTransferDataHandler;
    /* 0x0120 */ PVOID WSendPacketsHandler;
    /* 0x0128 */ PVOID CancelSendPacketsHandler;
    /* 0x0130 */ ULONG WakeUpEnable;
    /* 0x0134 */ NDIS_PM_PARAMETERS PMCurrentParameters;
    /* 0x0148 */ KEVENT* CloseCompleteEvent;
    /* 0x0150 */ QUEUED_CLOSE QC;
    /* 0x0178 */ long AfReferences;
    /* 0x017c */ long Padding_376;
    /* 0x0180 */ struct _NDIS_OPEN_BLOCK* NextGlobalOpen;
    /* 0x0188 */ struct _NDIS_OPEN_BLOCK* MiniportNextOpen;
    /* 0x0190 */ struct _NDIS_OPEN_BLOCK* ProtocolNextOpen;
    /* 0x0198 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01a0 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01a8 */ struct _NDIS_OPEN_BLOCK* FilterNextOpen;
    /* 0x01b0 */ unsigned int PacketFilters;
    /* 0x01b4 */ unsigned int OldPacketFilters;
    /* 0x01b8 */ unsigned int MaxMulticastAddresses;
    /* 0x01bc */ long Padding_377;
    /* 0x01c0 */ struct _ETH_MULTICAST_WRAPPER* MCastAddressBuf;
    /* 0x01c8 */ unsigned int NumAddresses;
    /* 0x01cc */ long Padding_378;
    /* 0x01d0 */ struct _ETH_MULTICAST_WRAPPER* OldMCastAddressBuf;
    /* 0x01d8 */ unsigned int OldNumAddresses;
    /* 0x01dc */ long Padding_379;
    /* 0x01e0 */ UCHAR* RssParametersBuffer;
    /* 0x01e8 */ struct _NDIS_RECEIVE_SCALE_PARAMETERS* NdisRSSParameters;
    /* 0x01f0 */ SINGLE_LIST_ENTRY PatternList;
    /* 0x01f8 */ SINGLE_LIST_ENTRY WOLPatternList;
    /* 0x0200 */ SINGLE_LIST_ENTRY PMProtocolOffloadList;
    /* 0x0208 */ PVOID ProtSendNetBufferListsComplete;
    /* 0x0210 */ PVOID SendCompleteNdisPacketContext;
    /* 0x0218 */ PVOID SendCompleteNetBufferListsContext;
    /* 0x0220 */ PVOID ReceiveNetBufferLists;
    /* 0x0228 */ PVOID ReceiveNetBufferListsContext;
    /* 0x0230 */ PVOID SavedSendPacketsHandler;
    /* 0x0238 */ PVOID SavedCancelSendPacketsHandler;
    /* 0x0240 */ PVOID SavedSendHandler;
    /* 0x0248 */ PVOID InitiateOffloadCompleteHandler;
    /* 0x0250 */ PVOID TerminateOffloadCompleteHandler;
    /* 0x0258 */ PVOID UpdateOffloadCompleteHandler;
    /* 0x0260 */ PVOID InvalidateOffloadCompleteHandler;
    /* 0x0268 */ PVOID QueryOffloadCompleteHandler;
    /* 0x0270 */ PVOID IndicateOffloadEventHandler;
    /* 0x0278 */ PVOID TcpOffloadSendCompleteHandler;
    /* 0x0280 */ PVOID TcpOffloadReceiveCompleteHandler;
    /* 0x0288 */ PVOID TcpOffloadDisconnectCompleteHandler;
    /* 0x0290 */ PVOID TcpOffloadForwardCompleteHandler;
    /* 0x0298 */ PVOID TcpOffloadEventHandler;
    /* 0x02a0 */ PVOID TcpOffloadReceiveIndicateHandler;
    /* 0x02a8 */ struct NDIS_NBL_TRACKER_HANDLE__* NblTracker;
    /* 0x02b0 */ struct NDIS_REFCOUNT_HANDLE__* RefCountTracker;
    /* 0x02b8 */ unsigned __int64 RefCountLock;
    /* 0x02c0 */ ULONG ProtocolMajorVersion;
    /* 0x02c4 */ long Padding_380;
    /* 0x02c8 */ PVOID * IfBlock;
    /* 0x02d0 */ NDIS_SPIN_LOCK PnPStateLock;
    /* 0x02e0 */ NDIS_NDIS5_DRIVER_STATE PnPState;
    /* 0x02e4 */ int OutstandingSends;
    /* 0x02e8 */ NDIS_EVENT PauseEvent;
    /* 0x0300 */ PVOID Ndis5WanSendHandler;
    /* 0x0308 */ PVOID ProtSendCompleteHandler;
    /* 0x0310 */ PVOID OidRequestCompleteHandler;
    /* 0x0318 */ struct _NDIS_OPEN_OFFLOAD* Offload;
    /* 0x0320 */ struct _NDIS_STATUS_UNBIND_WORKITEM* StatusUnbindWorkItem;
    /* 0x0328 */ unsigned __int64 DpcStartCycle;
    /* 0x0330 */ struct PNDIS_PER_PROCESSOR_SLOT__* ReceivedAPacketSlot;
    /* 0x0338 */ PVOID DirectOidRequestHandler;
    /* 0x0340 */ LIST_ENTRY ReceiveQueueList;
    /* 0x0350 */ ULONG NumReceiveQueues;
    /* 0x0354 */ long Padding_381;
    /* 0x0358 */ LIST_ENTRY SharedMemoryBlockList;
    /* 0x0368 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0370 */ PVOID FreeSharedMemoryHandler;
    /* 0x0378 */ PVOID AllocateSharedMemoryContext;
    /* 0x0380 */ ULONG NumAllocatedVFs;
    /* 0x0384 */ long Padding_382;
    /* 0x0388 */ LIST_ENTRY VFList;
    /* 0x0398 */ ULONG NumActiveVPorts;
    /* 0x039c */ long Padding_383;
    /* 0x03a0 */ LIST_ENTRY VPortList;
    /* 0x03b0 */ ULONG AoAcReferences;
    /* 0x03b4 */ long Padding_384;
    /* 0x03b8 */ struct NDIS_BIND_PROTOCOL_LINK* Bind;
    /* 0x03c0 */ WORK_QUEUE_ITEM UnsolicitedUnbindComplete;
    /* 0x03e0 */ KEVENT* UnsolicitedUnbindEvent;
    /* 0x03e8 */ char PendingLegacyUnbind;
    /* 0x03e9 */ char Padding_385[7];
    /* 0x03f0 */ KEVENT* WaitNetPnpEvent;
} NDIS_COMMON_OPEN_BLOCK_14393_17134, *PNDIS_COMMON_OPEN_BLOCK_14393_17134; /* size: 0x03f8 */

typedef struct _NDIS_COMMON_OPEN_BLOCK_17763_22000
{
    union
    {
        /* 0x0000 */ PVOID MacHandle;
        /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    }; /* size: 0x0008 */
    /* 0x0008 */ PVOID BindingHandle;
    /* 0x0010 */ struct _NDIS_MINIPORT_BLOCK* MiniportHandle;
    /* 0x0018 */ struct _NDIS_PROTOCOL_BLOCK* ProtocolHandle;
    /* 0x0020 */ PVOID ProtocolBindingContext;
    /* 0x0028 */ PVOID NextSendHandler;
    /* 0x0030 */ PVOID NextSendContext;
    /* 0x0038 */ PVOID MiniportAdapterContext;
    /* 0x0040 */ UCHAR Reserved1;
    /* 0x0041 */ UCHAR CallingFromNdis6Protocol;
    /* 0x0042 */ UCHAR Reserved3;
    /* 0x0043 */ UCHAR Reserved4;
    /* 0x0044 */ long Padding_367;
    /* 0x0048 */ PVOID NextReturnNetBufferListsHandler;
    /* 0x0050 */ unsigned __int64 Reserved5;
    /* 0x0058 */ PVOID NextReturnNetBufferListsContext;
    union
    {
        /* 0x0060 */ PVOID SendHandler;
        /* 0x0060 */ PVOID WanSendHandler;
    }; /* size: 0x0008 */
    /* 0x0068 */ PVOID TransferDataHandler;
    /* 0x0070 */ PVOID SendCompleteHandler;
    /* 0x0078 */ PVOID TransferDataCompleteHandler;
    /* 0x0080 */ PVOID ReceiveHandler;
    /* 0x0088 */ PVOID ReceiveCompleteHandler;
    /* 0x0090 */ PVOID WanReceiveHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    /* 0x00a0 */ PVOID ReceivePacketHandler;
    /* 0x00a8 */ PVOID SendPacketsHandler;
    /* 0x00b0 */ PVOID ResetHandler;
    /* 0x00b8 */ PVOID RequestHandler;
    /* 0x00c0 */ PVOID OidRequestHandler;
    /* 0x00c8 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x00d0 */ PVOID StatusHandler;
        /* 0x00d0 */ PVOID StatusHandlerEx;
    }; /* size: 0x0008 */
    /* 0x00d8 */ PVOID StatusCompleteHandler;
    /* 0x00e0 */ volatile ULONG OpenFlags;
    /* 0x00e4 */ long References;
    /* 0x00e8 */ unsigned __int64 SpinLock;
    /* 0x00f0 */ PVOID FilterHandle;
    /* 0x00f8 */ unsigned int FrameTypeArraySize;
    /* 0x00fc */ unsigned short FrameTypeArray[4];
    /* 0x0104 */ ULONG ProtocolOptions;
    /* 0x0108 */ ULONG CurrentLookahead;
    /* 0x010c */ long Padding_368;
    /* 0x0110 */ PVOID WSendHandler;
    /* 0x0118 */ PVOID WTransferDataHandler;
    /* 0x0120 */ PVOID WSendPacketsHandler;
    /* 0x0128 */ PVOID CancelSendPacketsHandler;
    /* 0x0130 */ ULONG WakeUpEnable;
    /* 0x0134 */ NDIS_PM_PARAMETERS PMCurrentParameters;
    /* 0x0148 */ KEVENT* CloseCompleteEvent;
    /* 0x0150 */ QUEUED_CLOSE QC;
    /* 0x0178 */ long AfReferences;
    /* 0x017c */ long Padding_369;
    /* 0x0180 */ struct _NDIS_OPEN_BLOCK* NextGlobalOpen;
    /* 0x0188 */ struct _NDIS_OPEN_BLOCK* MiniportNextOpen;
    /* 0x0190 */ struct _NDIS_OPEN_BLOCK* ProtocolNextOpen;
    /* 0x0198 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01a0 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01a8 */ struct _NDIS_OPEN_BLOCK* FilterNextOpen;
    /* 0x01b0 */ unsigned int PacketFilters;
    /* 0x01b4 */ unsigned int OldPacketFilters;
    /* 0x01b8 */ unsigned int MaxMulticastAddresses;
    /* 0x01bc */ long Padding_370;
    /* 0x01c0 */ struct _ETH_MULTICAST_WRAPPER* MCastAddressBuf;
    /* 0x01c8 */ unsigned int NumAddresses;
    /* 0x01cc */ long Padding_371;
    /* 0x01d0 */ struct _ETH_MULTICAST_WRAPPER* OldMCastAddressBuf;
    /* 0x01d8 */ unsigned int OldNumAddresses;
    /* 0x01dc */ long Padding_372;
    /* 0x01e0 */ UCHAR* RssParametersBuffer;
    /* 0x01e8 */ struct _NDIS_RECEIVE_SCALE_PARAMETERS* NdisRSSParameters;
    /* 0x01f0 */ SINGLE_LIST_ENTRY PatternList;
    /* 0x01f8 */ SINGLE_LIST_ENTRY WOLPatternList;
    /* 0x0200 */ SINGLE_LIST_ENTRY PMProtocolOffloadList;
    /* 0x0208 */ PVOID ProtSendNetBufferListsComplete;
    /* 0x0210 */ PVOID SendCompleteNdisPacketContext;
    /* 0x0218 */ PVOID SendCompleteNetBufferListsContext;
    /* 0x0220 */ PVOID ReceiveNetBufferLists;
    /* 0x0228 */ PVOID ReceiveNetBufferListsContext;
    /* 0x0230 */ PVOID SavedSendPacketsHandler;
    /* 0x0238 */ PVOID SavedCancelSendPacketsHandler;
    /* 0x0240 */ PVOID SavedSendHandler;
    /* 0x0248 */ struct NDIS_NBL_TRACKER_HANDLE__* NblTracker;
    /* 0x0250 */ struct NDIS_REFCOUNT_HANDLE__* RefCountTracker;
    /* 0x0258 */ unsigned __int64 RefCountLock;
    /* 0x0260 */ ULONG ProtocolMajorVersion;
    /* 0x0264 */ long Padding_373;
    /* 0x0268 */ PVOID* IfBlock;
    /* 0x0270 */ NDIS_SPIN_LOCK PnPStateLock;
    /* 0x0280 */ NDIS_NDIS5_DRIVER_STATE PnPState;
    /* 0x0284 */ int OutstandingSends;
    /* 0x0288 */ NDIS_EVENT PauseEvent;
    /* 0x02a0 */ PVOID Ndis5WanSendHandler;
    /* 0x02a8 */ PVOID ProtSendCompleteHandler;
    /* 0x02b0 */ PVOID OidRequestCompleteHandler;
    /* 0x02b8 */ struct _NDIS_OPEN_OFFLOAD* Offload;
    /* 0x02c0 */ struct _NDIS_STATUS_UNBIND_WORKITEM* StatusUnbindWorkItem;
    /* 0x02c8 */ unsigned __int64 DpcStartCycle;
    /* 0x02d0 */ struct PNDIS_PER_PROCESSOR_SLOT__* ReceivedAPacketSlot;
    /* 0x02d8 */ PVOID DirectOidRequestHandler;
    /* 0x02e0 */ LIST_ENTRY ReceiveQueueList;
    /* 0x02f0 */ ULONG NumReceiveQueues;
    /* 0x02f4 */ long Padding_374;
    /* 0x02f8 */ LIST_ENTRY SharedMemoryBlockList;
    /* 0x0308 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0310 */ PVOID FreeSharedMemoryHandler;
    /* 0x0318 */ PVOID AllocateSharedMemoryContext;
    /* 0x0320 */ ULONG NumAllocatedVFs;
    /* 0x0324 */ long Padding_375;
    /* 0x0328 */ struct _LIST_ENTRY VFList;
    /* 0x0338 */ ULONG NumActiveVPorts;
    /* 0x033c */ long Padding_376;
    /* 0x0340 */ struct _LIST_ENTRY VPortList;
    /* 0x0350 */ ULONG AoAcReferences;
    /* 0x0354 */ long Padding_377;
    /* 0x0358 */ struct NDIS_BIND_PROTOCOL_LINK* Bind;
    /* 0x0360 */ WORK_QUEUE_ITEM UnsolicitedUnbindComplete;
    /* 0x0380 */ KEVENT* UnsolicitedUnbindEvent;
    /* 0x0388 */ char PendingLegacyUnbind;
    /* 0x0389 */ char Padding_378[7];
    /* 0x0390 */ KEVENT* WaitNetPnpEvent;
    /* 0x0398 */ PKTMON_COMPONENT_CONTEXT PktMonComp;
    /* 0x03a8 */ PKTMON_EDGE_CONTEXT PktMonEdge;
} NDIS_COMMON_OPEN_BLOCK_17763_22000, *PNDIS_COMMON_OPEN_BLOCK_17763_22000; /* size: 0x03c0 */

typedef struct _NDIS_COMMON_OPEN_BLOCK_22621_25905
{
    union
    {
        /* 0x0000 */ PVOID MacHandle;
        /* 0x0000 */ struct _NDIS_OBJECT_HEADER Header;
    }; /* size: 0x0008 */
    /* 0x0008 */ PVOID BindingHandle;
    /* 0x0010 */ struct _NDIS_MINIPORT_BLOCK* MiniportHandle;
    /* 0x0018 */ struct _NDIS_PROTOCOL_BLOCK* ProtocolHandle;
    /* 0x0020 */ PVOID ProtocolBindingContext;
    /* 0x0028 */ PVOID NextSendHandler /* function */;
    /* 0x0030 */ PVOID NextSendContext;
    /* 0x0038 */ PVOID MiniportAdapterContext;
    /* 0x0040 */ unsigned char Reserved1;
    /* 0x0041 */ unsigned char CallingFromNdis6Protocol;
    /* 0x0042 */ unsigned char Reserved3;
    /* 0x0043 */ unsigned char Reserved4;
    /* 0x0044 */ long Padding_328;
    /* 0x0048 */ PVOID NextReturnNetBufferListsHandler /* function */;
    /* 0x0050 */ unsigned __int64 Reserved5;
    /* 0x0058 */ PVOID NextReturnNetBufferListsContext;
    union
    {
        /* 0x0060 */ PVOID SendHandler /* function */;
        /* 0x0060 */ PVOID WanSendHandler /* function */;
    }; /* size: 0x0008 */
    /* 0x0068 */ PVOID TransferDataHandler /* function */;
    /* 0x0070 */ PVOID SendCompleteHandler /* function */;
    /* 0x0078 */ PVOID TransferDataCompleteHandler /* function */;
    /* 0x0080 */ PVOID ReceiveHandler /* function */;
    /* 0x0088 */ PVOID ReceiveCompleteHandler /* function */;
    /* 0x0090 */ PVOID WanReceiveHandler /* function */;
    /* 0x0098 */ PVOID RequestCompleteHandler /* function */;
    /* 0x00a0 */ PVOID ReceivePacketHandler /* function */;
    /* 0x00a8 */ PVOID SendPacketsHandler /* function */;
    /* 0x00b0 */ PVOID ResetHandler /* function */;
    /* 0x00b8 */ PVOID RequestHandler /* function */;
    /* 0x00c0 */ PVOID OidRequestHandler /* function */;
    /* 0x00c8 */ PVOID ResetCompleteHandler /* function */;
    union
    {
        /* 0x00d0 */ PVOID StatusHandler /* function */;
        /* 0x00d0 */ PVOID StatusHandlerEx /* function */;
    }; /* size: 0x0008 */
    /* 0x00d8 */ PVOID StatusCompleteHandler /* function */;
    /* 0x00e0 */ volatile unsigned long OpenFlags;
    /* 0x00e4 */ long References;
    /* 0x00e8 */ unsigned __int64 SpinLock;
    /* 0x00f0 */ PVOID FilterHandle;
    /* 0x00f8 */ unsigned int FrameTypeArraySize;
    /* 0x00fc */ unsigned short FrameTypeArray[4];
    /* 0x0104 */ unsigned long ProtocolOptions;
    /* 0x0108 */ unsigned long CurrentLookahead;
    /* 0x010c */ long Padding_329;
    /* 0x0110 */ PVOID WSendHandler /* function */;
    /* 0x0118 */ PVOID WTransferDataHandler /* function */;
    /* 0x0120 */ PVOID WSendPacketsHandler /* function */;
    /* 0x0128 */ PVOID CancelSendPacketsHandler /* function */;
    /* 0x0130 */ unsigned long WakeUpEnable;
    /* 0x0134 */ struct _NDIS_PM_PARAMETERS PMCurrentParameters;
    /* 0x0148 */ struct _KEVENT* CloseCompleteEvent;
    /* 0x0150 */ QUEUED_CLOSE QC;
    /* 0x0178 */ long AfReferences;
    /* 0x017c */ long Padding_330;
    /* 0x0180 */ struct _NDIS_OPEN_BLOCK* NextGlobalOpen;
    /* 0x0188 */ struct _NDIS_OPEN_BLOCK* MiniportNextOpen;
    /* 0x0190 */ struct _NDIS_OPEN_BLOCK* ProtocolNextOpen;
    /* 0x0198 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01a0 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01a8 */ struct _NDIS_OPEN_BLOCK* FilterNextOpen;
    /* 0x01b0 */ unsigned int PacketFilters;
    /* 0x01b4 */ unsigned int OldPacketFilters;
    /* 0x01b8 */ unsigned int MaxMulticastAddresses;
    /* 0x01bc */ long Padding_331;
    /* 0x01c0 */ struct _ETH_MULTICAST_WRAPPER* MCastAddressBuf;
    /* 0x01c8 */ unsigned int NumAddresses;
    /* 0x01cc */ long Padding_332;
    /* 0x01d0 */ struct _ETH_MULTICAST_WRAPPER* OldMCastAddressBuf;
    /* 0x01d8 */ unsigned int OldNumAddresses;
    /* 0x01dc */ long Padding_333;
    /* 0x01e0 */ unsigned char* RssParametersBuffer;
    /* 0x01e8 */ struct _NDIS_RECEIVE_SCALE_PARAMETERS* NdisRSSParameters;
    /* 0x01f0 */ struct _SINGLE_LIST_ENTRY PatternList;
    /* 0x01f8 */ struct _SINGLE_LIST_ENTRY WOLPatternList;
    /* 0x0200 */ struct _SINGLE_LIST_ENTRY PMProtocolOffloadList;
    /* 0x0208 */ PVOID ProtSendNetBufferListsComplete /* function */;
    /* 0x0210 */ PVOID SendCompleteNdisPacketContext;
    /* 0x0218 */ PVOID SendCompleteNetBufferListsContext;
    /* 0x0220 */ PVOID ReceiveNetBufferLists /* function */;
    /* 0x0228 */ PVOID ReceiveNetBufferListsContext;
    /* 0x0230 */ PVOID SavedSendPacketsHandler /* function */;
    /* 0x0238 */ PVOID SavedCancelSendPacketsHandler /* function */;
    /* 0x0240 */ PVOID SavedSendHandler /* function */;
    /* 0x0248 */ struct NDIS_NBL_TRACKER_HANDLE__* NblTracker;
    /* 0x0250 */ struct NDIS_REFCOUNT_HANDLE__* RefCountTracker;
    /* 0x0258 */ unsigned __int64 RefCountLock;
    /* 0x0260 */ unsigned long ProtocolMajorVersion;
    /* 0x0264 */ long Padding_334;
    /* 0x0268 */ PVOID* IfBlock;
    /* 0x0270 */ struct _NDIS_SPIN_LOCK PnPStateLock;
    /* 0x0280 */ enum NDIS_NDIS5_DRIVER_STATE PnPState;
    /* 0x0284 */ int OutstandingSends;
    /* 0x0288 */ struct _NDIS_EVENT PauseEvent;
    /* 0x02a0 */ PVOID Ndis5WanSendHandler /* function */;
    /* 0x02a8 */ PVOID ProtSendCompleteHandler /* function */;
    /* 0x02b0 */ PVOID OidRequestCompleteHandler /* function */;
    /* 0x02b8 */ struct _NDIS_OPEN_OFFLOAD* Offload;
    /* 0x02c0 */ struct _NDIS_STATUS_UNBIND_WORKITEM* StatusUnbindWorkItem;
    /* 0x02c8 */ unsigned __int64 DpcStartCycle;
    /* 0x02d0 */ struct PNDIS_PER_PROCESSOR_SLOT__* ReceivedAPacketSlot;
    /* 0x02d8 */ PVOID DirectOidRequestHandler /* function */;
    /* 0x02e0 */ struct _LIST_ENTRY ReceiveQueueList;
    /* 0x02f0 */ unsigned long NumReceiveQueues;
    /* 0x02f4 */ long Padding_335;
    /* 0x02f8 */ struct _LIST_ENTRY SharedMemoryBlockList;
    /* 0x0308 */ PVOID AllocateSharedMemoryHandler /* function */;
    /* 0x0310 */ PVOID FreeSharedMemoryHandler /* function */;
    /* 0x0318 */ PVOID AllocateSharedMemoryContext;
    /* 0x0320 */ unsigned long NumAllocatedVFs;
    /* 0x0324 */ long Padding_336;
    /* 0x0328 */ struct _LIST_ENTRY VFList;
    /* 0x0338 */ unsigned long NumActiveVPorts;
    /* 0x033c */ long Padding_337;
    /* 0x0340 */ struct _LIST_ENTRY VPortList;
    /* 0x0350 */ unsigned long AoAcReferences;
    /* 0x0354 */ long Padding_338;
    /* 0x0358 */ struct NDIS_BIND_PROTOCOL_LINK* Bind;
    /* 0x0360 */ struct _WORK_QUEUE_ITEM UnsolicitedUnbindComplete;
    /* 0x0380 */ struct _KEVENT* UnsolicitedUnbindEvent;
    /* 0x0388 */ char PendingLegacyUnbind;
    /* 0x0389 */ char Padding_339[7];
    /* 0x0390 */ struct _KEVENT* WaitNetPnpEvent;
    /* 0x0398 */ PKTMON_COMPONENT_CONTEXT_V2 PktMonComp;
    /* 0x03d8 */ PKTMON_EDGE_CONTEXT_V2 PktMonEdge;
} NDIS_COMMON_OPEN_BLOCK_22621_25905, * PNDIS_COMMON_OPEN_BLOCK_22621_25905; /* size: 0x0400 */

typedef struct _NDIS_PROTOCOL_BLOCK_7601 {
    NDIS_OBJECT_HEADER Header;
    LONG Padding_289;
    PVOID ProtocolDriverContext;
    struct _NDIS_PROTOCOL_BLOCK_7601* NextProtocol;
    NDIS_OPEN_BLOCK_7601* OpenQueue;
    REFERENCE Ref;
    UCHAR MajorNdisVersion;
    UCHAR MinorNdisVersion;
    UCHAR MajorDriverVersion;
    UCHAR MinorDriverVersion;
    UINT Reserved;
    UINT Flags;
    LONG Padding_290;
    UNICODE_STRING Name;
    UCHAR IsIPv4;
    UCHAR IsIPv6;
    UCHAR IsNdisTest6;
    CHAR Padding_291[5];
    PVOID BindAdapterHandlerEx;
    PVOID UnbindAdapterHandlerEx;
    PVOID OpenAdapterCompleteHandlerEx;
    PVOID CloseAdapterCompleteHandlerEx;
    union
    {
        PVOID PnPEventHandler;
        PVOID NetPnPEventHandler;
    } u1;
    PVOID UnloadHandler;
    PVOID UninstallHandler;
    PVOID RequestCompleteHandler;
    union
    {
        PVOID StatusHandlerEx;
        PVOID StatusHandler;
    } u2;
    PVOID StatusCompleteHandler;
    PVOID ReceiveNetBufferListsHandler;
    PVOID SendNetBufferListsCompleteHandler;
    union
    {
        PVOID CoStatusHandlerEx;
        PVOID CoStatusHandler;
    } u3;
    PVOID CoAfRegisterNotifyHandler;
    PVOID CoReceiveNetBufferListsHandler;
    PVOID CoSendNetBufferListsCompleteHandler;
    PVOID OpenAdapterCompleteHandler;
    PVOID CloseAdapterCompleteHandler;
    union
    {
        PVOID SendCompleteHandler;
        PVOID WanSendCompleteHandler;
    } u4;
    union
    {
        PVOID TransferDataCompleteHandler;
        PVOID WanTransferDataCompleteHandler;
    } u5;
    PVOID ResetCompleteHandler;
    union
    {
        PVOID ReceiveHandler;
        PVOID WanReceiveHandler;
    } u6;
    PVOID ReceiveCompleteHandler;
    PVOID ReceivePacketHandler;
    PVOID BindAdapterHandler;
    PVOID UnbindAdapterHandler;
    PVOID CoSendCompleteHandler;
    PVOID CoReceivePacketHandler;
    PVOID OidRequestCompleteHandler;
    WORK_QUEUE_ITEM WorkItem;
    KMUTANT Mutex;
    PVOID MutexOwnerThread;
    ULONG MutexOwnerCount;
    ULONG MutexOwner;
    UNICODE_STRING* BindDeviceName;
    UNICODE_STRING* RootDeviceName;
    struct _NDIS_M_DRIVER_BLOCK* AssociatedMiniDriver;
    struct _NDIS_MINIPORT_BLOCK* BindingAdapter;
    KEVENT* DeregEvent;
    union
    {
        NDIS_CO_CLIENT_OPTIONAL_HANDLERS ClientChars;
        NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS CallMgrChars;
    } u7;
    PVOID InitiateOffloadCompleteHandler;
    PVOID TerminateOffloadCompleteHandler;
    PVOID UpdateOffloadCompleteHandler;
    PVOID InvalidateOffloadCompleteHandler;
    PVOID QueryOffloadCompleteHandler;
    PVOID IndicateOffloadEventHandler;
    PVOID TcpOffloadSendCompleteHandler;
    PVOID TcpOffloadReceiveCompleteHandler;
    PVOID TcpOffloadDisconnectCompleteHandler;
    PVOID TcpOffloadForwardCompleteHandler;
    PVOID TcpOffloadEventHandler;
    PVOID TcpOffloadReceiveIndicateHandler;
    PVOID DirectOidRequestCompleteHandler;
    PVOID AllocateSharedMemoryHandler;
    PVOID FreeSharedMemoryHandler;
    PVOID AllocateSharedMemoryContext;
    UNICODE_STRING ImageName;
} NDIS_PROTOCOL_BLOCK_7601, *PNDIS_PROTOCOL_BLOCK_7601;  /* size: 0x0300 */

typedef struct _NDIS_PROTOCOL_BLOCK_9200
{
    /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    /* 0x0004 */ long Padding_81;
    /* 0x0008 */ PVOID ProtocolDriverContext;
    /* 0x0010 */ struct _NDIS_PROTOCOL_BLOCK* NextProtocol;
    /* 0x0018 */ struct _NDIS_OPEN_BLOCK* OpenQueue;
    /* 0x0020 */ REFERENCE_EX Ref;
    /* 0x0038 */ UCHAR MajorNdisVersion;
    /* 0x0039 */ UCHAR MinorNdisVersion;
    /* 0x003a */ UCHAR MajorDriverVersion;
    /* 0x003b */ UCHAR MinorDriverVersion;
    /* 0x003c */ unsigned int Reserved;
    /* 0x0040 */ unsigned int Flags;
    /* 0x0044 */ long Padding_82;
    /* 0x0048 */ UNICODE_STRING Name;
    /* 0x0058 */ UCHAR IsIPv4;
    /* 0x0059 */ UCHAR IsIPv6;
    /* 0x005a */ UCHAR IsNdisTest6;
    /* 0x005b */ char Padding_83[5];
    /* 0x0060 */ PVOID BindAdapterHandlerEx;
    /* 0x0068 */ PVOID UnbindAdapterHandlerEx;
    /* 0x0070 */ PVOID OpenAdapterCompleteHandlerEx;
    /* 0x0078 */ PVOID CloseAdapterCompleteHandlerEx;
    union
    {
        /* 0x0080 */ PVOID PnPEventHandler;
        /* 0x0080 */ PVOID NetPnPEventHandler;
    } u1; /* size: 0x0008 */
    /* 0x0088 */ PVOID UnloadHandler;
    /* 0x0090 */ PVOID UninstallHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    union
    {
        /* 0x00a0 */ PVOID StatusHandlerEx;
        /* 0x00a0 */ PVOID StatusHandler;
    } u2; /* size: 0x0008 */
    /* 0x00a8 */ PVOID StatusCompleteHandler;
    /* 0x00b0 */ PVOID ReceiveNetBufferListsHandler;
    /* 0x00b8 */ PVOID SendNetBufferListsCompleteHandler;
    union
    {
        /* 0x00c0 */ PVOID CoStatusHandlerEx;
        /* 0x00c0 */ PVOID CoStatusHandler;
    } u3; /* size: 0x0008 */
    /* 0x00c8 */ PVOID CoAfRegisterNotifyHandler;
    /* 0x00d0 */ PVOID CoReceiveNetBufferListsHandler;
    /* 0x00d8 */ PVOID CoSendNetBufferListsCompleteHandler;
    /* 0x00e0 */ PVOID OpenAdapterCompleteHandler;
    /* 0x00e8 */ PVOID CloseAdapterCompleteHandler;
    union
    {
        /* 0x00f0 */ PVOID SendCompleteHandler;
        /* 0x00f0 */ PVOID WanSendCompleteHandler;
    } u4; /* size: 0x0008 */
    union
    {
        /* 0x00f8 */ PVOID TransferDataCompleteHandler;
        /* 0x00f8 */ PVOID WanTransferDataCompleteHandler;
    } u5; /* size: 0x0008 */
    /* 0x0100 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x0108 */ PVOID ReceiveHandler;
        /* 0x0108 */ PVOID WanReceiveHandler;
    } u6; /* size: 0x0008 */
    /* 0x0110 */ PVOID ReceiveCompleteHandler;
    /* 0x0118 */ PVOID ReceivePacketHandler;
    /* 0x0120 */ PVOID BindAdapterHandler;
    /* 0x0128 */ PVOID UnbindAdapterHandler;
    /* 0x0130 */ PVOID CoSendCompleteHandler;
    /* 0x0138 */ PVOID CoReceivePacketHandler;
    /* 0x0140 */ PVOID OidRequestCompleteHandler;
    /* 0x0148 */ WORK_QUEUE_ITEM WorkItem;
    /* 0x0168 */ KMUTANT Mutex;
    /* 0x01a0 */ PVOID MutexOwnerThread;
    /* 0x01a8 */ ULONG MutexOwnerCount;
    /* 0x01ac */ ULONG MutexOwner;
    /* 0x01b0 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01b8 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01c0 */ struct _NDIS_M_DRIVER_BLOCK* AssociatedMiniDriver;
    /* 0x01c8 */ struct _NDIS_MINIPORT_BLOCK* BindingAdapter;
    /* 0x01d0 */ KEVENT* DeregEvent;
    /* 0x01d8 */ NDIS_CO_CLIENT_OPTIONAL_HANDLERS ClientChars;
    /* 0x0278 */ NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS CallMgrChars;
    /* 0x0308 */ PVOID InitiateOffloadCompleteHandler;
    /* 0x0310 */ PVOID TerminateOffloadCompleteHandler;
    /* 0x0318 */ PVOID UpdateOffloadCompleteHandler;
    /* 0x0320 */ PVOID InvalidateOffloadCompleteHandler;
    /* 0x0328 */ PVOID QueryOffloadCompleteHandler;
    /* 0x0330 */ PVOID IndicateOffloadEventHandler;
    /* 0x0338 */ PVOID TcpOffloadSendCompleteHandler;
    /* 0x0340 */ PVOID TcpOffloadReceiveCompleteHandler;
    /* 0x0348 */ PVOID TcpOffloadDisconnectCompleteHandler;
    /* 0x0350 */ PVOID TcpOffloadForwardCompleteHandler;
    /* 0x0358 */ PVOID TcpOffloadEventHandler;
    /* 0x0360 */ PVOID TcpOffloadReceiveIndicateHandler;
    /* 0x0368 */ PVOID DirectOidRequestCompleteHandler;
    /* 0x0370 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0378 */ PVOID FreeSharedMemoryHandler;
    /* 0x0380 */ PVOID AllocateSharedMemoryContext;
    /* 0x0388 */ UNICODE_STRING ImageName;
} NDIS_PROTOCOL_BLOCK_9200, *PNDIS_PROTOCOL_BLOCK_9200; /* size: 0x0398 */

typedef struct _NDIS_PROTOCOL_BLOCK_9600_17134
{
    /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    /* 0x0004 */ long Padding_265;
    /* 0x0008 */ PVOID ProtocolDriverContext;
    /* 0x0010 */ struct _NDIS_PROTOCOL_BLOCK* NextProtocol;
    /* 0x0018 */ struct _NDIS_OPEN_BLOCK* OpenQueue;
    /* 0x0020 */ REFERENCE_EX Ref;
    /* 0x0038 */ UCHAR MajorNdisVersion;
    /* 0x0039 */ UCHAR MinorNdisVersion;
    /* 0x003a */ UCHAR MajorDriverVersion;
    /* 0x003b */ UCHAR MinorDriverVersion;
    /* 0x003c */ unsigned int Reserved;
    /* 0x0040 */ unsigned int Flags;
    /* 0x0044 */ long Padding_266;
    /* 0x0048 */ UNICODE_STRING Name;
    /* 0x0058 */ UCHAR IsIPv4;
    /* 0x0059 */ UCHAR IsIPv6;
    /* 0x005a */ UCHAR IsNdisTest6;
    /* 0x005b */ char Padding_267[5];
    /* 0x0060 */ PVOID BindAdapterHandlerEx;
    /* 0x0068 */ PVOID UnbindAdapterHandlerEx;
    /* 0x0070 */ PVOID OpenAdapterCompleteHandlerEx;
    /* 0x0078 */ PVOID CloseAdapterCompleteHandlerEx;
    union
    {
        /* 0x0080 */ PVOID PnPEventHandler;
        /* 0x0080 */ PVOID NetPnPEventHandler;
    } u1; /* size: 0x0008 */
    /* 0x0088 */ PVOID UnloadHandler;
    /* 0x0090 */ PVOID UninstallHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    union
    {
        /* 0x00a0 */ PVOID StatusHandlerEx;
        /* 0x00a0 */ PVOID StatusHandler;
    } u2; /* size: 0x0008 */
    /* 0x00a8 */ PVOID StatusCompleteHandler;
    /* 0x00b0 */ PVOID ReceiveNetBufferListsHandler;
    /* 0x00b8 */ PVOID SendNetBufferListsCompleteHandler;
    union
    {
        /* 0x00c0 */ PVOID CoStatusHandlerEx;
        /* 0x00c0 */ PVOID CoStatusHandler;
    } u3; /* size: 0x0008 */
    /* 0x00c8 */ PVOID CoAfRegisterNotifyHandler;
    /* 0x00d0 */ PVOID CoReceiveNetBufferListsHandler;
    /* 0x00d8 */ PVOID CoSendNetBufferListsCompleteHandler;
    /* 0x00e0 */ PVOID OpenAdapterCompleteHandler;
    /* 0x00e8 */ PVOID CloseAdapterCompleteHandler;
    union
    {
        /* 0x00f0 */ PVOID SendCompleteHandler;
        /* 0x00f0 */ PVOID WanSendCompleteHandler;
    } u4; /* size: 0x0008 */
    union
    {
        /* 0x00f8 */ PVOID TransferDataCompleteHandler;
        /* 0x00f8 */ PVOID WanTransferDataCompleteHandler;
    } u5; /* size: 0x0008 */
    /* 0x0100 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x0108 */ PVOID ReceiveHandler;
        /* 0x0108 */ PVOID WanReceiveHandler;
    } u6; /* size: 0x0008 */
    /* 0x0110 */ PVOID ReceiveCompleteHandler;
    /* 0x0118 */ PVOID ReceivePacketHandler;
    /* 0x0120 */ PVOID BindAdapterHandler;
    /* 0x0128 */ PVOID UnbindAdapterHandler;
    /* 0x0130 */ PVOID CoSendCompleteHandler;
    /* 0x0138 */ PVOID CoReceivePacketHandler;
    /* 0x0140 */ PVOID OidRequestCompleteHandler;
    /* 0x0148 */ WORK_QUEUE_ITEM WorkItem;
    /* 0x0168 */ KMUTANT Mutex;
    /* 0x01a0 */ PVOID MutexOwnerThread;
    /* 0x01a8 */ ULONG MutexOwnerCount;
    /* 0x01ac */ ULONG MutexOwner;
    /* 0x01b0 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01b8 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01c0 */ struct _NDIS_M_DRIVER_BLOCK* AssociatedMiniDriver;
    /* 0x01c8 */ struct _NDIS_MINIPORT_BLOCK* BindingAdapter;
    /* 0x01d0 */ KEVENT* DeregEvent;
    /* 0x01d8 */ NDIS_CO_CLIENT_OPTIONAL_HANDLERS ClientChars;
    /* 0x0278 */ NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS CallMgrChars;
    /* 0x0308 */ PVOID InitiateOffloadCompleteHandler;
    /* 0x0310 */ PVOID TerminateOffloadCompleteHandler;
    /* 0x0318 */ PVOID UpdateOffloadCompleteHandler;
    /* 0x0320 */ PVOID InvalidateOffloadCompleteHandler;
    /* 0x0328 */ PVOID QueryOffloadCompleteHandler;
    /* 0x0330 */ PVOID IndicateOffloadEventHandler;
    /* 0x0338 */ PVOID TcpOffloadSendCompleteHandler;
    /* 0x0340 */ PVOID TcpOffloadReceiveCompleteHandler;
    /* 0x0348 */ PVOID TcpOffloadDisconnectCompleteHandler;
    /* 0x0350 */ PVOID TcpOffloadForwardCompleteHandler;
    /* 0x0358 */ PVOID TcpOffloadEventHandler;
    /* 0x0360 */ PVOID TcpOffloadReceiveIndicateHandler;
    /* 0x0368 */ PVOID DirectOidRequestCompleteHandler;
    /* 0x0370 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0378 */ PVOID FreeSharedMemoryHandler;
    /* 0x0380 */ PVOID AllocateSharedMemoryContext;
    /* 0x0388 */ UNICODE_STRING ImageName;
    /* 0x0398 */ PVOID Bind; //class pointer
    /* 0x03a0 */ PVOID NotifyBindCompleteWorkItem; //class pointer
} NDIS_PROTOCOL_BLOCK_9600_17134, *PNDIS_PROTOCOL_BLOCK_9600_17134; /* size: 0x03d8 */

typedef struct _NDIS_PROTOCOL_BLOCK_17763
{
    /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    /* 0x0004 */ long Padding_126;
    /* 0x0008 */ PVOID ProtocolDriverContext;
    /* 0x0010 */ struct _NDIS_PROTOCOL_BLOCK* NextProtocol;
    /* 0x0018 */ struct _NDIS_OPEN_BLOCK* OpenQueue;
    /* 0x0020 */ REFERENCE_EX Ref;
    /* 0x0038 */ UCHAR MajorNdisVersion;
    /* 0x0039 */ UCHAR MinorNdisVersion;
    /* 0x003a */ UCHAR MajorDriverVersion;
    /* 0x003b */ UCHAR MinorDriverVersion;
    /* 0x003c */ unsigned int Reserved;
    /* 0x0040 */ unsigned int Flags;
    /* 0x0044 */ long Padding_127;
    /* 0x0048 */ UNICODE_STRING Name;
    /* 0x0058 */ UCHAR IsIPv4;
    /* 0x0059 */ UCHAR IsIPv6;
    /* 0x005a */ UCHAR IsNdisTest6;
    /* 0x005b */ char Padding_128[5];
    /* 0x0060 */ PVOID BindAdapterHandlerEx;
    /* 0x0068 */ PVOID UnbindAdapterHandlerEx;
    /* 0x0070 */ PVOID OpenAdapterCompleteHandlerEx;
    /* 0x0078 */ PVOID CloseAdapterCompleteHandlerEx;
    union
    {
        /* 0x0080 */ PVOID PnPEventHandler;
        /* 0x0080 */ PVOID NetPnPEventHandler;
    } u1; /* size: 0x0008 */
    /* 0x0088 */ PVOID UnloadHandler;
    /* 0x0090 */ PVOID UninstallHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    union
    {
        /* 0x00a0 */ PVOID StatusHandlerEx;
        /* 0x00a0 */ PVOID StatusHandler;
    } u2; /* size: 0x0008 */
    /* 0x00a8 */ PVOID StatusCompleteHandler;
    /* 0x00b0 */ PVOID ReceiveNetBufferListsHandler;
    /* 0x00b8 */ PVOID SendNetBufferListsCompleteHandler;
    union
    {
        /* 0x00c0 */ PVOID CoStatusHandlerEx;
        /* 0x00c0 */ PVOID CoStatusHandler;
    } u3; /* size: 0x0008 */
    /* 0x00c8 */ PVOID CoAfRegisterNotifyHandler;
    /* 0x00d0 */ PVOID CoReceiveNetBufferListsHandler;
    /* 0x00d8 */ PVOID CoSendNetBufferListsCompleteHandler;
    /* 0x00e0 */ PVOID OpenAdapterCompleteHandler;
    /* 0x00e8 */ PVOID CloseAdapterCompleteHandler;
    union
    {
        /* 0x00f0 */ PVOID SendCompleteHandler;
        /* 0x00f0 */ PVOID WanSendCompleteHandler;
    } u4; /* size: 0x0008 */
    union
    {
        /* 0x00f8 */ PVOID TransferDataCompleteHandler;
        /* 0x00f8 */ PVOID WanTransferDataCompleteHandler;
    } u5; /* size: 0x0008 */
    /* 0x0100 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x0108 */ PVOID ReceiveHandler;
        /* 0x0108 */ PVOID WanReceiveHandler;
    } u6; /* size: 0x0008 */
    /* 0x0110 */ PVOID ReceiveCompleteHandler;
    /* 0x0118 */ PVOID ReceivePacketHandler;
    /* 0x0120 */ PVOID BindAdapterHandler;
    /* 0x0128 */ PVOID UnbindAdapterHandler;
    /* 0x0130 */ PVOID CoSendCompleteHandler;
    /* 0x0138 */ PVOID CoReceivePacketHandler;
    /* 0x0140 */ PVOID OidRequestCompleteHandler;
    /* 0x0148 */ WORK_QUEUE_ITEM WorkItem;
    /* 0x0168 */ KMUTANT Mutex;
    /* 0x01a0 */ PVOID MutexOwnerThread;
    /* 0x01a8 */ ULONG MutexOwnerCount;
    /* 0x01ac */ ULONG MutexOwner;
    /* 0x01b0 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01b8 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01c0 */ struct _NDIS_M_DRIVER_BLOCK* AssociatedMiniDriver;
    /* 0x01c8 */ struct _NDIS_MINIPORT_BLOCK* BindingAdapter;
    /* 0x01d0 */ KEVENT* DeregEvent;
    /* 0x01d8 */ NDIS_CO_CLIENT_OPTIONAL_HANDLERS ClientChars;
    /* 0x0278 */ NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS CallMgrChars;
    /* 0x0308 */ PVOID DirectOidRequestCompleteHandler;
    /* 0x0310 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0318 */ PVOID FreeSharedMemoryHandler;
    /* 0x0320 */ PVOID AllocateSharedMemoryContext;
    /* 0x0328 */ UNICODE_STRING ImageName;
    /* 0x0338 */ PVOID Bind; //class pointer
    /* 0x0340 */ PVOID NotifyBindCompleteWorkItem; //class pointer
} NDIS_PROTOCOL_BLOCK_17763, *PNDIS_PROTOCOL_BLOCK_17763; /* size: 0x0378 */

typedef struct _NDIS_PROTOCOL_BLOCK_18362_25905
{
    /* 0x0000 */ NDIS_OBJECT_HEADER Header;
    /* 0x0004 */ long Padding_126;
    /* 0x0008 */ PVOID ProtocolDriverContext;
    /* 0x0010 */ struct _NDIS_PROTOCOL_BLOCK* NextProtocol;
    /* 0x0018 */ struct _NDIS_OPEN_BLOCK* OpenQueue;
    /* 0x0020 */ REFERENCE_EX Ref;
    /* 0x0038 */ UCHAR MajorNdisVersion;
    /* 0x0039 */ UCHAR MinorNdisVersion;
    /* 0x003a */ UCHAR MajorDriverVersion;
    /* 0x003b */ UCHAR MinorDriverVersion;
    /* 0x003c */ unsigned int Reserved;
    /* 0x0040 */ unsigned int Flags;
    /* 0x0044 */ long Padding_127;
    /* 0x0048 */ UNICODE_STRING Name;
    /* 0x0058 */ UCHAR IsIPv4;
    /* 0x0059 */ UCHAR IsIPv6;
    /* 0x005a */ UCHAR IsNdisTest6;
    /* 0x005b */ char Padding_128[5];
    /* 0x0060 */ PVOID BindAdapterHandlerEx;
    /* 0x0068 */ PVOID UnbindAdapterHandlerEx;
    /* 0x0070 */ PVOID OpenAdapterCompleteHandlerEx;
    /* 0x0078 */ PVOID CloseAdapterCompleteHandlerEx;
    union
    {
        /* 0x0080 */ PVOID PnPEventHandler;
        /* 0x0080 */ PVOID NetPnPEventHandler;
    } u1; /* size: 0x0008 */
    /* 0x0088 */ PVOID UnloadHandler;
    /* 0x0090 */ PVOID UninstallHandler;
    /* 0x0098 */ PVOID RequestCompleteHandler;
    union
    {
        /* 0x00a0 */ PVOID StatusHandlerEx;
        /* 0x00a0 */ PVOID StatusHandler;
    } u2; /* size: 0x0008 */
    /* 0x00a8 */ PVOID StatusCompleteHandler;
    /* 0x00b0 */ PVOID ReceiveNetBufferListsHandler;
    /* 0x00b8 */ PVOID SendNetBufferListsCompleteHandler;
    union
    {
        /* 0x00c0 */ PVOID CoStatusHandlerEx;
        /* 0x00c0 */ PVOID CoStatusHandler;
    } u3; /* size: 0x0008 */
    /* 0x00c8 */ PVOID CoAfRegisterNotifyHandler;
    /* 0x00d0 */ PVOID CoReceiveNetBufferListsHandler;
    /* 0x00d8 */ PVOID CoSendNetBufferListsCompleteHandler;
    /* 0x00e0 */ PVOID OpenAdapterCompleteHandler;
    /* 0x00e8 */ PVOID CloseAdapterCompleteHandler;
    union
    {
        /* 0x00f0 */ PVOID SendCompleteHandler;
        /* 0x00f0 */ PVOID WanSendCompleteHandler;
    } u4; /* size: 0x0008 */
    union
    {
        /* 0x00f8 */ PVOID TransferDataCompleteHandler;
        /* 0x00f8 */ PVOID WanTransferDataCompleteHandler;
    } u5; /* size: 0x0008 */
    /* 0x0100 */ PVOID ResetCompleteHandler;
    union
    {
        /* 0x0108 */ PVOID ReceiveHandler;
        /* 0x0108 */ PVOID WanReceiveHandler;
    } u6; /* size: 0x0008 */
    /* 0x0110 */ PVOID ReceiveCompleteHandler;
    /* 0x0118 */ PVOID ReceivePacketHandler;
    /* 0x0120 */ PVOID BindAdapterHandler;
    /* 0x0128 */ PVOID UnbindAdapterHandler;
    /* 0x0130 */ PVOID CoSendCompleteHandler;
    /* 0x0138 */ PVOID CoReceivePacketHandler;
    /* 0x0140 */ PVOID OidRequestCompleteHandler;
    /* 0x0148 */ WORK_QUEUE_ITEM WorkItem;
    /* 0x0168 */ KMUTANT Mutex;
    /* 0x01a0 */ PVOID MutexOwnerThread;
    /* 0x01a8 */ ULONG MutexOwnerCount;
    /* 0x01ac */ ULONG Padding_220;
    /* 0x01b0 */ struct _UNICODE_STRING* BindDeviceName;
    /* 0x01b8 */ struct _UNICODE_STRING* RootDeviceName;
    /* 0x01c0 */ struct _NDIS_M_DRIVER_BLOCK* AssociatedMiniDriver;
    /* 0x01c8 */ struct _NDIS_MINIPORT_BLOCK* BindingAdapter;
    /* 0x01d0 */ KEVENT* DeregEvent;
    /* 0x01d8 */ NDIS_CO_CLIENT_OPTIONAL_HANDLERS ClientChars;
    /* 0x0278 */ NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS CallMgrChars;
    /* 0x0308 */ PVOID DirectOidRequestCompleteHandler;
    /* 0x0310 */ PVOID AllocateSharedMemoryHandler;
    /* 0x0318 */ PVOID FreeSharedMemoryHandler;
    /* 0x0320 */ PVOID AllocateSharedMemoryContext;
    /* 0x0328 */ UNICODE_STRING ImageName;
    /* 0x0338 */ PVOID Bind; //class pointer
    /* 0x0340 */ PVOID NotifyBindCompleteWorkItem; //class pointer
} NDIS_PROTOCOL_BLOCK_18362_25905, *PNDIS_PROTOCOL_BLOCK_18362_25905; /* size: 0x0378 */


//
// NDIS_RTL HEADER END
//

#pragma warning(pop)


#ifdef __cplusplus
}
#endif

#endif NDIS_RTL

```

`Source/Plugins/Sonar/query.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       QUERY.C
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Query NDIS specific data.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

/*

Generic search pattern

NdisDeregisterProtocol

7601
48 8B 3D 46 B9 FA FF                                            mov     rdi, cs:ndisProtocolList
9200
48 8B 3D 9A 1F FB FF                                            mov     rdi, cs:ndisProtocolList
9600
48 8B 3D 7A EF F9 FF                                            mov     rdi, cs:ndisProtocolList
10240
48 8B 3D FA 1D F9 FF                                            mov     rdi, cs:ndisProtocolList
10586
48 8B 3D 1A 62 F9 FF                                            mov     rdi, cs:ndisProtocolList
14393
48 8B 3D 4A 44 F9 FF                                            mov     rdi, cs:ndisProtocolList
15063
48 8B 3D 32 F4 F8 FF                                            mov     rdi, cs:ndisProtocolList
16299
48 8B 3D 6A BC F8 FF                                            mov     rdi, cs:ndisProtocolList
17134
48 8B 3D 9A AF F8 FF                                            mov     rdi, cs:ndisProtocolList
17763
48 8B 3D C4 7F F8 FF                                            mov     rdi, cs:ndisProtocolList
18362/18363
48 8B 3D A2 CE FA FF                                            mov     rdi, cs:ndisProtocolList
19041/19042
48 8B 3D BA 92 FA FF                                            mov     rdi, cs:ndisProtocolList
21376
48 8B 3D XX XX XX XX                                            mov     rdi, cs:ndisProtocolList
25905
48 8B 3D 7C FB F9 FF                                            mov     rdi, cs:ndisProtocolList
27842
48 8B 3D 44 A6 FA FF                                            mov     rdi, cs:ndisProtocolList
*/

#define HDE_F_ERROR 0x00001000


/*
* AddressInImage
*
* Purpose:
*
* Test if given address in range of image.
*
*/
BOOL AddressInImage(
    _In_ PVOID Address,
    _In_ PVOID ImageBase,
    _In_ ULONG ImageSize
)
{
    return IN_REGION(Address,
        ImageBase,
        ImageSize);
}

/*
* QueryProtocolList
*
* Purpose:
*
* Return kernel address of ndis!ndisProtocolList global variable.
*
*/
ULONG_PTR QueryProtocolList(
    VOID
)
{
    UCHAR       Length;
    LONG        Rel = 0;
    ULONG       Index, DisasmFlags;
    ULONG_PTR   Address = 0, Result = 0;
    HMODULE     hModule = NULL;
    PBYTE       ptrCode;

    PRTL_PROCESS_MODULES            miSpace = NULL;
    PRTL_PROCESS_MODULE_INFORMATION NdisModule;
    WCHAR                           szBuffer[MAX_PATH * 2];

    do {
        if (g_ctx.ParamBlock.GetInstructionLength == NULL)
            break;

        //
        // Query NDIS.sys base
        //
        miSpace = ntsupGetSystemInfoEx(
            SystemModuleInformation,
            NULL,
            (PNTSUPMEMALLOC)supHeapAlloc,
            (PNTSUPMEMFREE)supHeapFree);

        if (miSpace == NULL)
            break;

        if (miSpace->NumberOfModules == 0)
            break;

        NdisModule = ntsupFindModuleEntryByName((PVOID)miSpace, "ndis.sys");
        if (NdisModule == NULL)
            break;

        //
        // Preload NDIS.sys
        //
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

        StringCchPrintf(
            szBuffer,
            _countof(szBuffer),
            TEXT("%s\\system32\\drivers\\ndis.sys"),
            USER_SHARED_DATA->NtSystemRoot);

        hModule = LoadLibraryEx(szBuffer, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL)
            break;

        //
        // Match pattern scan from NdisDeregisterProtocol.
        //
        ptrCode = (PBYTE)GetProcAddress(hModule, "NdisDeregisterProtocol");
        if (ptrCode == NULL)
            break;

        Index = 0;
        do {
            DisasmFlags = 0;
            Length = g_ctx.ParamBlock.GetInstructionLength((void*)(ptrCode + Index), &DisasmFlags);
            if (DisasmFlags & HDE_F_ERROR)
                break;

            if (Length == 7) {

                if ((ptrCode[Index] == 0x48) &&
                    (ptrCode[Index + 1] == 0x8B) &&
                    (ptrCode[Index + 2] == 0x3D))
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }
            }
            Index += Length;

        } while (Index < 256);

        if (Rel == 0)
            break;

        Address = (ULONG_PTR)ptrCode + Index + Length + Rel;
        Address = (ULONG_PTR)NdisModule->ImageBase + Address - (ULONG_PTR)hModule;

        if (!AddressInImage((PVOID)Address, NdisModule->ImageBase, NdisModule->ImageSize))
            break;

        Result = Address;

    } while (FALSE);

    if (hModule) FreeLibrary(hModule);
    if (miSpace) supHeapFree(miSpace);

    return Result;
}

/*
* DumpObjectWithSpecifiedSize
*
* Purpose:
*
* Return dumped object version aware.
*
* Use supHeapFree to free returned buffer.
*
*/
PVOID DumpObjectWithSpecifiedSize(
    _In_ ULONG_PTR ObjectAddress,
    _In_ ULONG ObjectSize,
    _In_ ULONG ObjectVersion,
    _Out_ PULONG ReadSize,
    _Out_ PULONG ReadVersion
)
{
    PVOID ObjectBuffer = NULL;
    ULONG BufferSize = ALIGN_UP_BY(ObjectSize, PAGE_SIZE);

    if (ReadSize) *ReadSize = 0;
    if (ReadVersion) *ReadVersion = 0;

    ObjectBuffer = supHeapAlloc(BufferSize);
    if (ObjectBuffer == NULL) {
        return NULL;
    }

    if (!g_ctx.ParamBlock.ReadSystemMemoryEx(
        ObjectAddress,
        ObjectBuffer,
        (ULONG)ObjectSize,
        NULL))
    {
        supHeapFree(ObjectBuffer);
        return NULL;
    }

    if (ReadSize)
        *ReadSize = ObjectSize;
    if (ReadVersion)
        *ReadVersion = ObjectVersion;

    return ObjectBuffer;
}

/*
* DumpProtocolBlockVersionAware
*
* Purpose:
*
* Return dumped NDIS_PROTOCOL_BLOCK version aware.
*
* Use supHeapFree to free returned buffer.
*
*/
PVOID DumpProtocolBlockVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version)
{
    ULONG ObjectSize = 0;
    ULONG ObjectVersion = 0;

    //assume failure
    if (Size) *Size = 0;
    if (Version) *Version = 0;

    switch (g_ctx.ParamBlock.Version.dwBuildNumber) {
    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
        ObjectSize = sizeof(NDIS_PROTOCOL_BLOCK_7601);
        ObjectVersion = 1;
        break;

    case NT_WIN8_RTM:
        ObjectSize = sizeof(NDIS_PROTOCOL_BLOCK_9200);
        ObjectVersion = 2;
        break;

    case NT_WIN8_BLUE:
    case NT_WIN10_THRESHOLD1:
    case NT_WIN10_THRESHOLD2:
    case NT_WIN10_REDSTONE1:
    case NT_WIN10_REDSTONE2:
    case NT_WIN10_REDSTONE3:
    case NT_WIN10_REDSTONE4:
        ObjectSize = sizeof(NDIS_PROTOCOL_BLOCK_9600_17134);
        ObjectVersion = 3;
        break;
    case NT_WIN10_REDSTONE5:
        ObjectSize = sizeof(NDIS_PROTOCOL_BLOCK_17763);
        ObjectVersion = 4;
        break;
    case NT_WIN10_19H1:
    case NT_WIN10_19H2:
    case NT_WIN10_20H1:
    case NT_WIN10_20H2:
    case NT_WIN10_21H1:
    case NT_WIN10_21H2:
    case NT_WIN11_21H2:
    case NT_WIN11_22H2:
    case NT_WIN11_23H2:
    case NT_WIN11_24H2:
    case NT_WIN11_25H2:
    default:
        ObjectSize = sizeof(NDIS_PROTOCOL_BLOCK_18362_25905);
        ObjectVersion = 5;
        break;

    }

    return DumpObjectWithSpecifiedSize(ObjectAddress,
        ObjectSize,
        ObjectVersion,
        Size,
        Version);
}

/*
* DumpOpenBlockVersionAware
*
* Purpose:
*
* Return dumped NDIS_OPEN_BLOCK version aware.
*
* Use supHeapFree to free returned buffer.
*
*/
PVOID DumpOpenBlockVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version)
{
    ULONG ObjectSize = 0;
    ULONG ObjectVersion = 0;

    //assume failure
    if (Size) *Size = 0;
    if (Version) *Version = 0;

    switch (g_ctx.ParamBlock.Version.dwBuildNumber) {
    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
        ObjectSize = sizeof(NDIS_OPEN_BLOCK_7601);
        ObjectVersion = NDIS_OPEN_BLOCK_VERSION_WIN7;
        break;
    case NT_WIN8_RTM:
        ObjectSize = sizeof(NDIS_OPEN_BLOCK_9200);
        ObjectVersion = NDIS_OPEN_BLOCK_VERSION_WIN8;
        break;
    case NT_WIN8_BLUE:
    case NT_WIN10_THRESHOLD1:
    case NT_WIN10_THRESHOLD2:
        ObjectSize = sizeof(NDIS_OPEN_BLOCK_9600_10586);
        ObjectVersion = NDIS_OPEN_BLOCK_VERSION_WIN81_WIN10TH1;
        break;
    case NT_WIN10_REDSTONE1:
    case NT_WIN10_REDSTONE2:
    case NT_WIN10_REDSTONE3:
    case NT_WIN10_REDSTONE4:
        ObjectSize = sizeof(NDIS_OPEN_BLOCK_14393_17134);
        ObjectVersion = NDIS_OPEN_BLOCK_VERSION_WIN10_RS1_4;
        break;
    case NT_WIN10_REDSTONE5:
    case NT_WIN10_19H1:
    case NT_WIN10_19H2:
    case NT_WIN10_20H1:
    case NT_WIN10_20H2:
    case NT_WIN10_21H1:
    case NT_WIN10_21H2:
    case NT_WIN11_21H2:
        ObjectSize = sizeof(NDIS_OPEN_BLOCK_17763_22000);
        ObjectVersion = NDIS_OPEN_BLOCK_VERSION_WIN10_RS5_WIN11;
        break;
    case NT_WIN11_22H2:
    case NT_WIN11_23H2:
    case NT_WIN11_24H2:
    case NT_WIN11_25H2:
    default:
        ObjectSize = sizeof(NDIS_OPEN_BLOCK_22621_25905);
        ObjectVersion = NDIS_OPEN_BLOCK_VERSION_WIN11_22_25H2;
        break;
    }

    return DumpObjectWithSpecifiedSize(ObjectAddress,
        ObjectSize,
        ObjectVersion,
        Size,
        Version);
}

/*
* DumpUnicodeString
*
* Purpose:
*
* Read UNICODE_STRING buffer from kernel.
*
* Use supHeapFree to free returned buffer.
*
*/
PVOID DumpUnicodeString(
    _In_ ULONG_PTR Address,
    _In_ WORD Length,
    _In_ WORD MaximumLength,
    _In_ BOOLEAN IsPtr)
{
    ULONG readBytes;
    PVOID DumpedString = NULL;
    SIZE_T Size;
    UNICODE_STRING tempString;

    if (Address <= g_ctx.ParamBlock.SystemRangeStart)
        return NULL;

    RtlSecureZeroMemory(&tempString, sizeof(tempString));

    if (IsPtr) { //given address is pointer to the string

        if (g_ctx.ParamBlock.ReadSystemMemoryEx(Address,
            &tempString,
            sizeof(UNICODE_STRING),
            &readBytes))
        {
            if (readBytes != sizeof(UNICODE_STRING)) {
                return NULL;
            }
        }

    }
    else {
        tempString.Buffer = (PWCHAR)Address;
        tempString.Length = Length;
        tempString.MaximumLength = MaximumLength;
    }

    if (tempString.Length == 0 && tempString.MaximumLength == 0)
        return NULL;

    Size = (SIZE_T)tempString.Length + MAX_PATH;
    DumpedString = (PVOID)supHeapAlloc(Size);
    if (DumpedString) {
        if (!g_ctx.ParamBlock.ReadSystemMemoryEx((ULONG_PTR)tempString.Buffer,
            DumpedString,
            tempString.Length,
            &readBytes))
        {
            supHeapFree(DumpedString);
            return NULL;
        }

        if (readBytes != tempString.Length) {
            supHeapFree(DumpedString);
            return NULL;
        }
    }

    return DumpedString;
}

/*
* GetNextProtocolOffset
*
* Purpose:
*
* Return offset of NextProtocol structure field (structure version specific).
*
*/
ULONG GetNextProtocolOffset(
    _In_ ULONG WindowsVersion
)
{
    ULONG Offset = 0;

    switch (WindowsVersion) {

    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
        Offset = FIELD_OFFSET(NDIS_PROTOCOL_BLOCK_7601, NextProtocol);
        break;
    case NT_WIN8_RTM:
        Offset = FIELD_OFFSET(NDIS_PROTOCOL_BLOCK_9200, NextProtocol);
        break;
    case NT_WIN8_BLUE:
    case NT_WIN10_THRESHOLD1:
    case NT_WIN10_THRESHOLD2:
    case NT_WIN10_REDSTONE1:
    case NT_WIN10_REDSTONE2:
    case NT_WIN10_REDSTONE3:
    case NT_WIN10_REDSTONE4:
        Offset = FIELD_OFFSET(NDIS_PROTOCOL_BLOCK_9600_17134, NextProtocol);
        break;
    case NT_WIN10_REDSTONE5:
        Offset = FIELD_OFFSET(NDIS_PROTOCOL_BLOCK_17763, NextProtocol);
        break;
    case NT_WIN10_19H1:
    case NT_WIN10_19H2:
    case NT_WIN10_20H1:
    case NT_WIN10_20H2:
    case NT_WIN10_21H1:
    case NT_WIN10_21H2:
    case NT_WIN11_21H2:
    case NT_WIN11_22H2:
    case NT_WIN11_23H2:
    case NT_WIN11_24H2:
    case NT_WIN11_25H2:
    default:
        Offset = FIELD_OFFSET(NDIS_PROTOCOL_BLOCK_18362_25905, NextProtocol);
        break;

    }

    return Offset;
}

/*
* CreateCompatibleProtocolBlock
*
* Purpose:
*
* Build compatible protocol block for easy work with it.
*
*/
_Success_(return == TRUE)
BOOL CreateCompatibleProtocolBlock(
    _In_ ULONG ObjectVersion,
    _In_ PROTOCOL_BLOCK_VERSIONS * ProtocolRef,
    _Out_ NDIS_PROTOCOL_BLOCK_COMPATIBLE * ProtoBlock)
{
    switch (ObjectVersion) {

    case 1:
        RtlCopyMemory(&ProtoBlock->Name, &ProtocolRef->u1.Versions.v1->Name, sizeof(UNICODE_STRING));
        RtlCopyMemory(&ProtoBlock->ImageName, &ProtocolRef->u1.Versions.v1->ImageName, sizeof(UNICODE_STRING));
        ProtoBlock->OpenQueue = ProtocolRef->u1.Versions.v1->OpenQueue;
        ProtoBlock->NextProtocol = ProtocolRef->u1.Versions.v1->NextProtocol;
        ProtoBlock->AssociatedMiniDriver = ProtocolRef->u1.Versions.v1->AssociatedMiniDriver;

        ProtoBlock->MajorDriverVersion = ProtocolRef->u1.Versions.v1->MajorDriverVersion;
        ProtoBlock->MajorNdisVersion = ProtocolRef->u1.Versions.v1->MajorNdisVersion;
        ProtoBlock->MinorDriverVersion = ProtocolRef->u1.Versions.v1->MinorDriverVersion;
        ProtoBlock->MinorNdisVersion = ProtocolRef->u1.Versions.v1->MinorNdisVersion;

        ProtoBlock->Handlers.AllocateSharedMemoryHandler = ProtocolRef->u1.Versions.v1->AllocateSharedMemoryHandler;
        ProtoBlock->Handlers.BindAdapterHandler = ProtocolRef->u1.Versions.v1->BindAdapterHandler;
        ProtoBlock->Handlers.BindAdapterHandlerEx = ProtocolRef->u1.Versions.v1->BindAdapterHandlerEx;
        ProtoBlock->BindDeviceName = ProtocolRef->u1.Versions.v1->BindDeviceName;
        ProtoBlock->Handlers.CloseAdapterCompleteHandler = ProtocolRef->u1.Versions.v1->CloseAdapterCompleteHandler;
        ProtoBlock->Handlers.CloseAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v1->CloseAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.CoAfRegisterNotifyHandler = ProtocolRef->u1.Versions.v1->CoAfRegisterNotifyHandler;
        ProtoBlock->Handlers.CoReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v1->CoReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.CoReceivePacketHandler = ProtocolRef->u1.Versions.v1->CoReceivePacketHandler;
        ProtoBlock->Handlers.CoSendCompleteHandler = ProtocolRef->u1.Versions.v1->CoSendCompleteHandler;
        ProtoBlock->Handlers.CoSendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v1->CoSendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.CoStatusHandler = ProtocolRef->u1.Versions.v1->u3.CoStatusHandler;
        ProtoBlock->Handlers.DirectOidRequestCompleteHandler = ProtocolRef->u1.Versions.v1->DirectOidRequestCompleteHandler;
        ProtoBlock->Handlers.FreeSharedMemoryHandler = ProtocolRef->u1.Versions.v1->FreeSharedMemoryHandler;
        ProtoBlock->Handlers.IndicateOffloadEventHandler = ProtocolRef->u1.Versions.v1->IndicateOffloadEventHandler;
        ProtoBlock->Handlers.InitiateOffloadCompleteHandler = ProtocolRef->u1.Versions.v1->InitiateOffloadCompleteHandler;
        ProtoBlock->Handlers.InvalidateOffloadCompleteHandler = ProtocolRef->u1.Versions.v1->InvalidateOffloadCompleteHandler;
        ProtoBlock->Handlers.OidRequestCompleteHandler = ProtocolRef->u1.Versions.v1->OidRequestCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandler = ProtocolRef->u1.Versions.v1->OpenAdapterCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v1->OpenAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.PnPEventHandler = ProtocolRef->u1.Versions.v1->u1.PnPEventHandler;
        ProtoBlock->Handlers.QueryOffloadCompleteHandler = ProtocolRef->u1.Versions.v1->QueryOffloadCompleteHandler;
        ProtoBlock->Handlers.ReceiveCompleteHandler = ProtocolRef->u1.Versions.v1->ReceiveCompleteHandler;
        ProtoBlock->Handlers.ReceiveHandler = ProtocolRef->u1.Versions.v1->u6.ReceiveHandler;
        ProtoBlock->Handlers.ReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v1->ReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.ReceivePacketHandler = ProtocolRef->u1.Versions.v1->ReceivePacketHandler;
        ProtoBlock->Handlers.RequestCompleteHandler = ProtocolRef->u1.Versions.v1->RequestCompleteHandler;
        ProtoBlock->Handlers.ResetCompleteHandler = ProtocolRef->u1.Versions.v1->ResetCompleteHandler;
        ProtoBlock->RootDeviceName = ProtocolRef->u1.Versions.v1->RootDeviceName;
        ProtoBlock->Handlers.SendCompleteHandler = ProtocolRef->u1.Versions.v1->u4.SendCompleteHandler;
        ProtoBlock->Handlers.SendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v1->SendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.StatusCompleteHandler = ProtocolRef->u1.Versions.v1->StatusCompleteHandler;
        ProtoBlock->Handlers.StatusHandler = ProtocolRef->u1.Versions.v1->u2.StatusHandler;
        ProtoBlock->Handlers.TcpOffloadDisconnectCompleteHandler = ProtocolRef->u1.Versions.v1->TcpOffloadDisconnectCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadEventHandler = ProtocolRef->u1.Versions.v1->TcpOffloadEventHandler;
        ProtoBlock->Handlers.TcpOffloadForwardCompleteHandler = ProtocolRef->u1.Versions.v1->TcpOffloadForwardCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadReceiveCompleteHandler = ProtocolRef->u1.Versions.v1->TcpOffloadReceiveCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadReceiveIndicateHandler = ProtocolRef->u1.Versions.v1->TcpOffloadReceiveIndicateHandler;
        ProtoBlock->Handlers.TcpOffloadSendCompleteHandler = ProtocolRef->u1.Versions.v1->TcpOffloadSendCompleteHandler;
        ProtoBlock->Handlers.TerminateOffloadCompleteHandler = ProtocolRef->u1.Versions.v1->TerminateOffloadCompleteHandler;
        ProtoBlock->Handlers.TransferDataCompleteHandler = ProtocolRef->u1.Versions.v1->u5.TransferDataCompleteHandler;
        ProtoBlock->Handlers.UnbindAdapterHandler = ProtocolRef->u1.Versions.v1->UnbindAdapterHandler;
        ProtoBlock->Handlers.UnbindAdapterHandlerEx = ProtocolRef->u1.Versions.v1->UnbindAdapterHandlerEx;
        ProtoBlock->Handlers.UninstallHandler = ProtocolRef->u1.Versions.v1->UninstallHandler;
        ProtoBlock->Handlers.UnloadHandler = ProtocolRef->u1.Versions.v1->UnloadHandler;
        ProtoBlock->Handlers.UpdateOffloadCompleteHandler = ProtocolRef->u1.Versions.v1->UpdateOffloadCompleteHandler;
        break;

    case 2:
        RtlCopyMemory(&ProtoBlock->Name, &ProtocolRef->u1.Versions.v2->Name, sizeof(UNICODE_STRING));
        RtlCopyMemory(&ProtoBlock->ImageName, &ProtocolRef->u1.Versions.v2->ImageName, sizeof(UNICODE_STRING));
        ProtoBlock->OpenQueue = ProtocolRef->u1.Versions.v2->OpenQueue;
        ProtoBlock->NextProtocol = ProtocolRef->u1.Versions.v2->NextProtocol;
        ProtoBlock->AssociatedMiniDriver = ProtocolRef->u1.Versions.v2->AssociatedMiniDriver;

        ProtoBlock->MajorDriverVersion = ProtocolRef->u1.Versions.v2->MajorDriverVersion;
        ProtoBlock->MajorNdisVersion = ProtocolRef->u1.Versions.v2->MajorNdisVersion;
        ProtoBlock->MinorDriverVersion = ProtocolRef->u1.Versions.v2->MinorDriverVersion;
        ProtoBlock->MinorNdisVersion = ProtocolRef->u1.Versions.v2->MinorNdisVersion;

        ProtoBlock->Handlers.AllocateSharedMemoryHandler = ProtocolRef->u1.Versions.v2->AllocateSharedMemoryHandler;
        ProtoBlock->Handlers.BindAdapterHandler = ProtocolRef->u1.Versions.v2->BindAdapterHandler;
        ProtoBlock->Handlers.BindAdapterHandlerEx = ProtocolRef->u1.Versions.v2->BindAdapterHandlerEx;
        ProtoBlock->BindDeviceName = ProtocolRef->u1.Versions.v2->BindDeviceName;
        ProtoBlock->Handlers.CloseAdapterCompleteHandler = ProtocolRef->u1.Versions.v2->CloseAdapterCompleteHandler;
        ProtoBlock->Handlers.CloseAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v2->CloseAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.CoAfRegisterNotifyHandler = ProtocolRef->u1.Versions.v2->CoAfRegisterNotifyHandler;
        ProtoBlock->Handlers.CoReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v2->CoReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.CoReceivePacketHandler = ProtocolRef->u1.Versions.v2->CoReceivePacketHandler;
        ProtoBlock->Handlers.CoSendCompleteHandler = ProtocolRef->u1.Versions.v2->CoSendCompleteHandler;
        ProtoBlock->Handlers.CoSendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v2->CoSendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.CoStatusHandler = ProtocolRef->u1.Versions.v2->u3.CoStatusHandler;
        ProtoBlock->Handlers.DirectOidRequestCompleteHandler = ProtocolRef->u1.Versions.v2->DirectOidRequestCompleteHandler;
        ProtoBlock->Handlers.FreeSharedMemoryHandler = ProtocolRef->u1.Versions.v2->FreeSharedMemoryHandler;
        ProtoBlock->Handlers.IndicateOffloadEventHandler = ProtocolRef->u1.Versions.v2->IndicateOffloadEventHandler;
        ProtoBlock->Handlers.InitiateOffloadCompleteHandler = ProtocolRef->u1.Versions.v2->InitiateOffloadCompleteHandler;
        ProtoBlock->Handlers.InvalidateOffloadCompleteHandler = ProtocolRef->u1.Versions.v2->InvalidateOffloadCompleteHandler;
        ProtoBlock->Handlers.OidRequestCompleteHandler = ProtocolRef->u1.Versions.v2->OidRequestCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandler = ProtocolRef->u1.Versions.v2->OpenAdapterCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v2->OpenAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.PnPEventHandler = ProtocolRef->u1.Versions.v2->u1.PnPEventHandler;
        ProtoBlock->Handlers.QueryOffloadCompleteHandler = ProtocolRef->u1.Versions.v2->QueryOffloadCompleteHandler;
        ProtoBlock->Handlers.ReceiveCompleteHandler = ProtocolRef->u1.Versions.v2->ReceiveCompleteHandler;
        ProtoBlock->Handlers.ReceiveHandler = ProtocolRef->u1.Versions.v2->u6.ReceiveHandler;
        ProtoBlock->Handlers.ReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v2->ReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.ReceivePacketHandler = ProtocolRef->u1.Versions.v2->ReceivePacketHandler;
        ProtoBlock->Handlers.RequestCompleteHandler = ProtocolRef->u1.Versions.v2->RequestCompleteHandler;
        ProtoBlock->Handlers.ResetCompleteHandler = ProtocolRef->u1.Versions.v2->ResetCompleteHandler;
        ProtoBlock->RootDeviceName = ProtocolRef->u1.Versions.v2->RootDeviceName;
        ProtoBlock->Handlers.SendCompleteHandler = ProtocolRef->u1.Versions.v2->u4.SendCompleteHandler;
        ProtoBlock->Handlers.SendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v2->SendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.StatusCompleteHandler = ProtocolRef->u1.Versions.v2->StatusCompleteHandler;
        ProtoBlock->Handlers.StatusHandler = ProtocolRef->u1.Versions.v2->u2.StatusHandler;
        ProtoBlock->Handlers.TcpOffloadDisconnectCompleteHandler = ProtocolRef->u1.Versions.v2->TcpOffloadDisconnectCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadEventHandler = ProtocolRef->u1.Versions.v2->TcpOffloadEventHandler;
        ProtoBlock->Handlers.TcpOffloadForwardCompleteHandler = ProtocolRef->u1.Versions.v2->TcpOffloadForwardCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadReceiveCompleteHandler = ProtocolRef->u1.Versions.v2->TcpOffloadReceiveCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadReceiveIndicateHandler = ProtocolRef->u1.Versions.v2->TcpOffloadReceiveIndicateHandler;
        ProtoBlock->Handlers.TcpOffloadSendCompleteHandler = ProtocolRef->u1.Versions.v2->TcpOffloadSendCompleteHandler;
        ProtoBlock->Handlers.TerminateOffloadCompleteHandler = ProtocolRef->u1.Versions.v2->TerminateOffloadCompleteHandler;
        ProtoBlock->Handlers.TransferDataCompleteHandler = ProtocolRef->u1.Versions.v2->u5.TransferDataCompleteHandler;
        ProtoBlock->Handlers.UnbindAdapterHandler = ProtocolRef->u1.Versions.v2->UnbindAdapterHandler;
        ProtoBlock->Handlers.UnbindAdapterHandlerEx = ProtocolRef->u1.Versions.v2->UnbindAdapterHandlerEx;
        ProtoBlock->Handlers.UninstallHandler = ProtocolRef->u1.Versions.v2->UninstallHandler;
        ProtoBlock->Handlers.UnloadHandler = ProtocolRef->u1.Versions.v2->UnloadHandler;
        ProtoBlock->Handlers.UpdateOffloadCompleteHandler = ProtocolRef->u1.Versions.v2->UpdateOffloadCompleteHandler;
        break;

    case 3:
        RtlCopyMemory(&ProtoBlock->Name, &ProtocolRef->u1.Versions.v3->Name, sizeof(UNICODE_STRING));
        RtlCopyMemory(&ProtoBlock->ImageName, &ProtocolRef->u1.Versions.v3->ImageName, sizeof(UNICODE_STRING));
        ProtoBlock->OpenQueue = ProtocolRef->u1.Versions.v3->OpenQueue;
        ProtoBlock->NextProtocol = ProtocolRef->u1.Versions.v3->NextProtocol;
        ProtoBlock->AssociatedMiniDriver = ProtocolRef->u1.Versions.v3->AssociatedMiniDriver;

        ProtoBlock->MajorDriverVersion = ProtocolRef->u1.Versions.v3->MajorDriverVersion;
        ProtoBlock->MajorNdisVersion = ProtocolRef->u1.Versions.v3->MajorNdisVersion;
        ProtoBlock->MinorDriverVersion = ProtocolRef->u1.Versions.v3->MinorDriverVersion;
        ProtoBlock->MinorNdisVersion = ProtocolRef->u1.Versions.v3->MinorNdisVersion;

        ProtoBlock->Handlers.AllocateSharedMemoryHandler = ProtocolRef->u1.Versions.v3->AllocateSharedMemoryHandler;
        ProtoBlock->Handlers.BindAdapterHandler = ProtocolRef->u1.Versions.v3->BindAdapterHandler;
        ProtoBlock->Handlers.BindAdapterHandlerEx = ProtocolRef->u1.Versions.v3->BindAdapterHandlerEx;
        ProtoBlock->BindDeviceName = ProtocolRef->u1.Versions.v3->BindDeviceName;
        ProtoBlock->Handlers.CloseAdapterCompleteHandler = ProtocolRef->u1.Versions.v3->CloseAdapterCompleteHandler;
        ProtoBlock->Handlers.CloseAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v3->CloseAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.CoAfRegisterNotifyHandler = ProtocolRef->u1.Versions.v3->CoAfRegisterNotifyHandler;
        ProtoBlock->Handlers.CoReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v3->CoReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.CoReceivePacketHandler = ProtocolRef->u1.Versions.v3->CoReceivePacketHandler;
        ProtoBlock->Handlers.CoSendCompleteHandler = ProtocolRef->u1.Versions.v3->CoSendCompleteHandler;
        ProtoBlock->Handlers.CoSendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v3->CoSendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.CoStatusHandler = ProtocolRef->u1.Versions.v3->u3.CoStatusHandler;
        ProtoBlock->Handlers.DirectOidRequestCompleteHandler = ProtocolRef->u1.Versions.v3->DirectOidRequestCompleteHandler;
        ProtoBlock->Handlers.FreeSharedMemoryHandler = ProtocolRef->u1.Versions.v3->FreeSharedMemoryHandler;
        ProtoBlock->Handlers.IndicateOffloadEventHandler = ProtocolRef->u1.Versions.v3->IndicateOffloadEventHandler;
        ProtoBlock->Handlers.InitiateOffloadCompleteHandler = ProtocolRef->u1.Versions.v3->InitiateOffloadCompleteHandler;
        ProtoBlock->Handlers.InvalidateOffloadCompleteHandler = ProtocolRef->u1.Versions.v3->InvalidateOffloadCompleteHandler;
        ProtoBlock->Handlers.OidRequestCompleteHandler = ProtocolRef->u1.Versions.v3->OidRequestCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandler = ProtocolRef->u1.Versions.v3->OpenAdapterCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v3->OpenAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.PnPEventHandler = ProtocolRef->u1.Versions.v3->u1.PnPEventHandler;
        ProtoBlock->Handlers.QueryOffloadCompleteHandler = ProtocolRef->u1.Versions.v3->QueryOffloadCompleteHandler;
        ProtoBlock->Handlers.ReceiveCompleteHandler = ProtocolRef->u1.Versions.v3->ReceiveCompleteHandler;
        ProtoBlock->Handlers.ReceiveHandler = ProtocolRef->u1.Versions.v3->u6.ReceiveHandler;
        ProtoBlock->Handlers.ReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v3->ReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.ReceivePacketHandler = ProtocolRef->u1.Versions.v3->ReceivePacketHandler;
        ProtoBlock->Handlers.RequestCompleteHandler = ProtocolRef->u1.Versions.v3->RequestCompleteHandler;
        ProtoBlock->Handlers.ResetCompleteHandler = ProtocolRef->u1.Versions.v3->ResetCompleteHandler;
        ProtoBlock->RootDeviceName = ProtocolRef->u1.Versions.v3->RootDeviceName;
        ProtoBlock->Handlers.SendCompleteHandler = ProtocolRef->u1.Versions.v3->u4.SendCompleteHandler;
        ProtoBlock->Handlers.SendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v3->SendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.StatusCompleteHandler = ProtocolRef->u1.Versions.v3->StatusCompleteHandler;
        ProtoBlock->Handlers.StatusHandler = ProtocolRef->u1.Versions.v3->u2.StatusHandler;
        ProtoBlock->Handlers.TcpOffloadDisconnectCompleteHandler = ProtocolRef->u1.Versions.v3->TcpOffloadDisconnectCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadEventHandler = ProtocolRef->u1.Versions.v3->TcpOffloadEventHandler;
        ProtoBlock->Handlers.TcpOffloadForwardCompleteHandler = ProtocolRef->u1.Versions.v3->TcpOffloadForwardCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadReceiveCompleteHandler = ProtocolRef->u1.Versions.v3->TcpOffloadReceiveCompleteHandler;
        ProtoBlock->Handlers.TcpOffloadReceiveIndicateHandler = ProtocolRef->u1.Versions.v3->TcpOffloadReceiveIndicateHandler;
        ProtoBlock->Handlers.TcpOffloadSendCompleteHandler = ProtocolRef->u1.Versions.v3->TcpOffloadSendCompleteHandler;
        ProtoBlock->Handlers.TerminateOffloadCompleteHandler = ProtocolRef->u1.Versions.v3->TerminateOffloadCompleteHandler;
        ProtoBlock->Handlers.TransferDataCompleteHandler = ProtocolRef->u1.Versions.v3->u5.TransferDataCompleteHandler;
        ProtoBlock->Handlers.UnbindAdapterHandler = ProtocolRef->u1.Versions.v3->UnbindAdapterHandler;
        ProtoBlock->Handlers.UnbindAdapterHandlerEx = ProtocolRef->u1.Versions.v3->UnbindAdapterHandlerEx;
        ProtoBlock->Handlers.UninstallHandler = ProtocolRef->u1.Versions.v3->UninstallHandler;
        ProtoBlock->Handlers.UnloadHandler = ProtocolRef->u1.Versions.v3->UnloadHandler;
        ProtoBlock->Handlers.UpdateOffloadCompleteHandler = ProtocolRef->u1.Versions.v3->UpdateOffloadCompleteHandler;
        break;

    case 4:
        RtlCopyMemory(&ProtoBlock->Name, &ProtocolRef->u1.Versions.v4->Name, sizeof(UNICODE_STRING));
        RtlCopyMemory(&ProtoBlock->ImageName, &ProtocolRef->u1.Versions.v4->ImageName, sizeof(UNICODE_STRING));
        ProtoBlock->OpenQueue = ProtocolRef->u1.Versions.v4->OpenQueue;
        ProtoBlock->NextProtocol = ProtocolRef->u1.Versions.v4->NextProtocol;
        ProtoBlock->AssociatedMiniDriver = ProtocolRef->u1.Versions.v4->AssociatedMiniDriver;

        ProtoBlock->MajorDriverVersion = ProtocolRef->u1.Versions.v4->MajorDriverVersion;
        ProtoBlock->MajorNdisVersion = ProtocolRef->u1.Versions.v4->MajorNdisVersion;
        ProtoBlock->MinorDriverVersion = ProtocolRef->u1.Versions.v4->MinorDriverVersion;
        ProtoBlock->MinorNdisVersion = ProtocolRef->u1.Versions.v4->MinorNdisVersion;

        ProtoBlock->Handlers.AllocateSharedMemoryHandler = ProtocolRef->u1.Versions.v4->AllocateSharedMemoryHandler;
        ProtoBlock->Handlers.BindAdapterHandler = ProtocolRef->u1.Versions.v4->BindAdapterHandler;
        ProtoBlock->Handlers.BindAdapterHandlerEx = ProtocolRef->u1.Versions.v4->BindAdapterHandlerEx;
        ProtoBlock->BindDeviceName = ProtocolRef->u1.Versions.v4->BindDeviceName;
        ProtoBlock->Handlers.CloseAdapterCompleteHandler = ProtocolRef->u1.Versions.v4->CloseAdapterCompleteHandler;
        ProtoBlock->Handlers.CloseAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v4->CloseAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.CoAfRegisterNotifyHandler = ProtocolRef->u1.Versions.v4->CoAfRegisterNotifyHandler;
        ProtoBlock->Handlers.CoReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v4->CoReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.CoReceivePacketHandler = ProtocolRef->u1.Versions.v4->CoReceivePacketHandler;
        ProtoBlock->Handlers.CoSendCompleteHandler = ProtocolRef->u1.Versions.v4->CoSendCompleteHandler;
        ProtoBlock->Handlers.CoSendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v4->CoSendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.CoStatusHandler = ProtocolRef->u1.Versions.v4->u3.CoStatusHandler;
        ProtoBlock->Handlers.DirectOidRequestCompleteHandler = ProtocolRef->u1.Versions.v4->DirectOidRequestCompleteHandler;
        ProtoBlock->Handlers.FreeSharedMemoryHandler = ProtocolRef->u1.Versions.v4->FreeSharedMemoryHandler;
        ProtoBlock->Handlers.OidRequestCompleteHandler = ProtocolRef->u1.Versions.v4->OidRequestCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandler = ProtocolRef->u1.Versions.v4->OpenAdapterCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v4->OpenAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.PnPEventHandler = ProtocolRef->u1.Versions.v4->u1.PnPEventHandler;
        ProtoBlock->Handlers.ReceiveCompleteHandler = ProtocolRef->u1.Versions.v4->ReceiveCompleteHandler;
        ProtoBlock->Handlers.ReceiveHandler = ProtocolRef->u1.Versions.v4->u6.ReceiveHandler;
        ProtoBlock->Handlers.ReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v4->ReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.ReceivePacketHandler = ProtocolRef->u1.Versions.v4->ReceivePacketHandler;
        ProtoBlock->Handlers.RequestCompleteHandler = ProtocolRef->u1.Versions.v4->RequestCompleteHandler;
        ProtoBlock->Handlers.ResetCompleteHandler = ProtocolRef->u1.Versions.v4->ResetCompleteHandler;
        ProtoBlock->RootDeviceName = ProtocolRef->u1.Versions.v4->RootDeviceName;
        ProtoBlock->Handlers.SendCompleteHandler = ProtocolRef->u1.Versions.v4->u4.SendCompleteHandler;
        ProtoBlock->Handlers.SendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v4->SendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.StatusCompleteHandler = ProtocolRef->u1.Versions.v4->StatusCompleteHandler;
        ProtoBlock->Handlers.StatusHandler = ProtocolRef->u1.Versions.v4->u2.StatusHandler;
        ProtoBlock->Handlers.TransferDataCompleteHandler = ProtocolRef->u1.Versions.v4->u5.TransferDataCompleteHandler;
        ProtoBlock->Handlers.UnbindAdapterHandler = ProtocolRef->u1.Versions.v4->UnbindAdapterHandler;
        ProtoBlock->Handlers.UnbindAdapterHandlerEx = ProtocolRef->u1.Versions.v4->UnbindAdapterHandlerEx;
        ProtoBlock->Handlers.UninstallHandler = ProtocolRef->u1.Versions.v4->UninstallHandler;
        ProtoBlock->Handlers.UnloadHandler = ProtocolRef->u1.Versions.v4->UnloadHandler;
        break;

    case 5:
        RtlCopyMemory(&ProtoBlock->Name, &ProtocolRef->u1.Versions.v5->Name, sizeof(UNICODE_STRING));
        RtlCopyMemory(&ProtoBlock->ImageName, &ProtocolRef->u1.Versions.v5->ImageName, sizeof(UNICODE_STRING));
        ProtoBlock->OpenQueue = ProtocolRef->u1.Versions.v5->OpenQueue;
        ProtoBlock->NextProtocol = ProtocolRef->u1.Versions.v5->NextProtocol;
        ProtoBlock->AssociatedMiniDriver = ProtocolRef->u1.Versions.v5->AssociatedMiniDriver;

        ProtoBlock->MajorDriverVersion = ProtocolRef->u1.Versions.v5->MajorDriverVersion;
        ProtoBlock->MajorNdisVersion = ProtocolRef->u1.Versions.v5->MajorNdisVersion;
        ProtoBlock->MinorDriverVersion = ProtocolRef->u1.Versions.v5->MinorDriverVersion;
        ProtoBlock->MinorNdisVersion = ProtocolRef->u1.Versions.v5->MinorNdisVersion;

        ProtoBlock->Handlers.AllocateSharedMemoryHandler = ProtocolRef->u1.Versions.v5->AllocateSharedMemoryHandler;
        ProtoBlock->Handlers.BindAdapterHandler = ProtocolRef->u1.Versions.v5->BindAdapterHandler;
        ProtoBlock->Handlers.BindAdapterHandlerEx = ProtocolRef->u1.Versions.v5->BindAdapterHandlerEx;
        ProtoBlock->BindDeviceName = ProtocolRef->u1.Versions.v5->BindDeviceName;
        ProtoBlock->Handlers.CloseAdapterCompleteHandler = ProtocolRef->u1.Versions.v5->CloseAdapterCompleteHandler;
        ProtoBlock->Handlers.CloseAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v5->CloseAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.CoAfRegisterNotifyHandler = ProtocolRef->u1.Versions.v5->CoAfRegisterNotifyHandler;
        ProtoBlock->Handlers.CoReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v5->CoReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.CoReceivePacketHandler = ProtocolRef->u1.Versions.v5->CoReceivePacketHandler;
        ProtoBlock->Handlers.CoSendCompleteHandler = ProtocolRef->u1.Versions.v5->CoSendCompleteHandler;
        ProtoBlock->Handlers.CoSendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v5->CoSendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.CoStatusHandler = ProtocolRef->u1.Versions.v5->u3.CoStatusHandler;
        ProtoBlock->Handlers.DirectOidRequestCompleteHandler = ProtocolRef->u1.Versions.v5->DirectOidRequestCompleteHandler;
        ProtoBlock->Handlers.FreeSharedMemoryHandler = ProtocolRef->u1.Versions.v5->FreeSharedMemoryHandler;
        ProtoBlock->Handlers.OidRequestCompleteHandler = ProtocolRef->u1.Versions.v5->OidRequestCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandler = ProtocolRef->u1.Versions.v5->OpenAdapterCompleteHandler;
        ProtoBlock->Handlers.OpenAdapterCompleteHandlerEx = ProtocolRef->u1.Versions.v5->OpenAdapterCompleteHandlerEx;
        ProtoBlock->Handlers.PnPEventHandler = ProtocolRef->u1.Versions.v5->u1.PnPEventHandler;
        ProtoBlock->Handlers.ReceiveCompleteHandler = ProtocolRef->u1.Versions.v5->ReceiveCompleteHandler;
        ProtoBlock->Handlers.ReceiveHandler = ProtocolRef->u1.Versions.v5->u6.ReceiveHandler;
        ProtoBlock->Handlers.ReceiveNetBufferListsHandler = ProtocolRef->u1.Versions.v5->ReceiveNetBufferListsHandler;
        ProtoBlock->Handlers.ReceivePacketHandler = ProtocolRef->u1.Versions.v5->ReceivePacketHandler;
        ProtoBlock->Handlers.RequestCompleteHandler = ProtocolRef->u1.Versions.v5->RequestCompleteHandler;
        ProtoBlock->Handlers.ResetCompleteHandler = ProtocolRef->u1.Versions.v5->ResetCompleteHandler;
        ProtoBlock->RootDeviceName = ProtocolRef->u1.Versions.v5->RootDeviceName;
        ProtoBlock->Handlers.SendCompleteHandler = ProtocolRef->u1.Versions.v5->u4.SendCompleteHandler;
        ProtoBlock->Handlers.SendNetBufferListsCompleteHandler = ProtocolRef->u1.Versions.v5->SendNetBufferListsCompleteHandler;
        ProtoBlock->Handlers.StatusCompleteHandler = ProtocolRef->u1.Versions.v5->StatusCompleteHandler;
        ProtoBlock->Handlers.StatusHandler = ProtocolRef->u1.Versions.v5->u2.StatusHandler;
        ProtoBlock->Handlers.TransferDataCompleteHandler = ProtocolRef->u1.Versions.v5->u5.TransferDataCompleteHandler;
        ProtoBlock->Handlers.UnbindAdapterHandler = ProtocolRef->u1.Versions.v5->UnbindAdapterHandler;
        ProtoBlock->Handlers.UnbindAdapterHandlerEx = ProtocolRef->u1.Versions.v5->UnbindAdapterHandlerEx;
        ProtoBlock->Handlers.UninstallHandler = ProtocolRef->u1.Versions.v5->UninstallHandler;
        ProtoBlock->Handlers.UnloadHandler = ProtocolRef->u1.Versions.v5->UnloadHandler;
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

/*
* CreateCompatibleOpenBlock
*
* Purpose:
*
* Build compatible open block for easy work with it.
*
*/
_Success_(return == TRUE)
BOOL CreateCompatibleOpenBlock(
    _In_ ULONG ObjectVersion,
    _In_ OPEN_BLOCK_VERSIONS * BlockRef,
    _Out_ NDIS_OPEN_BLOCK_COMPATIBLE * OpenBlock)
{
    switch (ObjectVersion) {

    case NDIS_OPEN_BLOCK_VERSION_WIN7: //7600..7601
        OpenBlock->ProtocolNextOpen = BlockRef->u1.Versions.v1->ProtocolNextOpen;
        OpenBlock->BindDeviceName = BlockRef->u1.Versions.v1->BindDeviceName;
        OpenBlock->RootDeviceName = BlockRef->u1.Versions.v1->RootDeviceName;

        OpenBlock->Handlers.AllocateSharedMemoryHandler = BlockRef->u1.Versions.v1->AllocateSharedMemoryHandler;
        OpenBlock->Handlers.CancelSendPacketsHandler = BlockRef->u1.Versions.v1->CancelSendPacketsHandler;
        OpenBlock->Handlers.CmActivateVcCompleteHandler = BlockRef->u1.Versions.v1->CmActivateVcCompleteHandler;
        OpenBlock->Handlers.CmDeactivateVcCompleteHandler = BlockRef->u1.Versions.v1->CmDeactivateVcCompleteHandler;
        OpenBlock->Handlers.CoCreateVcHandler = BlockRef->u1.Versions.v1->CoCreateVcHandler;
        OpenBlock->Handlers.CoDeleteVcHandler = BlockRef->u1.Versions.v1->CoDeleteVcHandler;
        OpenBlock->Handlers.CoOidRequestCompleteHandler = BlockRef->u1.Versions.v1->CoOidRequestCompleteHandler;
        OpenBlock->Handlers.CoOidRequestHandler = BlockRef->u1.Versions.v1->CoOidRequestHandler;
        OpenBlock->Handlers.CoRequestCompleteHandler = BlockRef->u1.Versions.v1->CoRequestCompleteHandler;
        OpenBlock->Handlers.CoRequestHandler = BlockRef->u1.Versions.v1->CoRequestHandler;
        OpenBlock->Handlers.DirectOidRequestCompleteHandler = BlockRef->u1.Versions.v1->DirectOidRequestCompleteHandler;
        OpenBlock->Handlers.DirectOidRequestHandler = BlockRef->u1.Versions.v1->DirectOidRequestHandler;
        OpenBlock->Handlers.FreeSharedMemoryHandler = BlockRef->u1.Versions.v1->FreeSharedMemoryHandler;
        OpenBlock->Handlers.IndicateOffloadEventHandler = BlockRef->u1.Versions.v1->IndicateOffloadEventHandler;
        OpenBlock->Handlers.InitiateOffloadCompleteHandler = BlockRef->u1.Versions.v1->InitiateOffloadCompleteHandler;
        OpenBlock->Handlers.InvalidateOffloadCompleteHandler = BlockRef->u1.Versions.v1->InvalidateOffloadCompleteHandler;
        OpenBlock->Handlers.MiniportCoCreateVcHandler = BlockRef->u1.Versions.v1->MiniportCoCreateVcHandler;
        OpenBlock->Handlers.MiniportCoOidRequestHandler = BlockRef->u1.Versions.v1->MiniportCoOidRequestHandler;
        OpenBlock->Handlers.MiniportCoRequestHandler = BlockRef->u1.Versions.v1->MiniportCoRequestHandler;
        OpenBlock->Handlers.Ndis5WanSendHandler = BlockRef->u1.Versions.v1->Ndis5WanSendHandler;
        OpenBlock->Handlers.NextReturnNetBufferListsHandler = BlockRef->u1.Versions.v1->NextReturnNetBufferListsHandler;
        OpenBlock->Handlers.NextSendHandler = BlockRef->u1.Versions.v1->NextSendHandler;
        OpenBlock->Handlers.OidRequestCompleteHandler = BlockRef->u1.Versions.v1->OidRequestCompleteHandler;
        OpenBlock->Handlers.OidRequestHandler = BlockRef->u1.Versions.v1->OidRequestHandler;
        OpenBlock->Handlers.ProtSendCompleteHandler = BlockRef->u1.Versions.v1->ProtSendCompleteHandler;
        OpenBlock->Handlers.ProtSendNetBufferListsComplete = BlockRef->u1.Versions.v1->ProtSendNetBufferListsComplete;
        OpenBlock->Handlers.QueryOffloadCompleteHandler = BlockRef->u1.Versions.v1->QueryOffloadCompleteHandler;
        OpenBlock->Handlers.ReceiveCompleteHandler = BlockRef->u1.Versions.v1->ReceiveCompleteHandler;
        OpenBlock->Handlers.ReceiveHandler = BlockRef->u1.Versions.v1->ReceiveHandler;
        OpenBlock->Handlers.ReceiveNetBufferLists = BlockRef->u1.Versions.v1->ReceiveNetBufferLists;
        OpenBlock->Handlers.ReceivePacketHandler = BlockRef->u1.Versions.v1->ReceivePacketHandler;
        OpenBlock->Handlers.RequestCompleteHandler = BlockRef->u1.Versions.v1->RequestCompleteHandler;
        OpenBlock->Handlers.RequestHandler = BlockRef->u1.Versions.v1->RequestHandler;
        OpenBlock->Handlers.ResetCompleteHandler = BlockRef->u1.Versions.v1->ResetCompleteHandler;
        OpenBlock->Handlers.ResetHandler = BlockRef->u1.Versions.v1->ResetHandler;
        OpenBlock->Handlers.SavedCancelSendPacketsHandler = BlockRef->u1.Versions.v1->SavedCancelSendPacketsHandler;
        OpenBlock->Handlers.SavedSendHandler = BlockRef->u1.Versions.v1->SavedSendHandler;
        OpenBlock->Handlers.SavedSendNBLHandler = BlockRef->u1.Versions.v1->SavedSendNBLHandler;
        OpenBlock->Handlers.SavedSendPacketsHandler = BlockRef->u1.Versions.v1->SavedSendPacketsHandler;
        OpenBlock->Handlers.SendCompleteHandler = BlockRef->u1.Versions.v1->SendCompleteHandler;
        OpenBlock->Handlers.SendHandler = BlockRef->u1.Versions.v1->SendHandler;
        OpenBlock->Handlers.SendPacketsHandler = BlockRef->u1.Versions.v1->SendPacketsHandler;
        OpenBlock->Handlers.StatusCompleteHandler = BlockRef->u1.Versions.v1->StatusCompleteHandler;
        OpenBlock->Handlers.StatusHandler = BlockRef->u1.Versions.v1->StatusHandler;
        OpenBlock->Handlers.TcpOffloadDisconnectCompleteHandler = BlockRef->u1.Versions.v1->TcpOffloadDisconnectCompleteHandler;
        OpenBlock->Handlers.TcpOffloadEventHandler = BlockRef->u1.Versions.v1->TcpOffloadEventHandler;
        OpenBlock->Handlers.TcpOffloadForwardCompleteHandler = BlockRef->u1.Versions.v1->TcpOffloadForwardCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveCompleteHandler = BlockRef->u1.Versions.v1->TcpOffloadReceiveCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveIndicateHandler = BlockRef->u1.Versions.v1->TcpOffloadReceiveIndicateHandler;
        OpenBlock->Handlers.TcpOffloadSendCompleteHandler = BlockRef->u1.Versions.v1->TcpOffloadSendCompleteHandler;
        OpenBlock->Handlers.TerminateOffloadCompleteHandler = BlockRef->u1.Versions.v1->TerminateOffloadCompleteHandler;
        OpenBlock->Handlers.TransferDataCompleteHandler = BlockRef->u1.Versions.v1->TransferDataCompleteHandler;
        OpenBlock->Handlers.TransferDataHandler = BlockRef->u1.Versions.v1->TransferDataHandler;
        OpenBlock->Handlers.UpdateOffloadCompleteHandler = BlockRef->u1.Versions.v1->UpdateOffloadCompleteHandler;
        OpenBlock->Handlers.WanReceiveHandler = BlockRef->u1.Versions.v1->WanReceiveHandler;
        OpenBlock->Handlers.WSendHandler = BlockRef->u1.Versions.v1->WSendHandler;
        OpenBlock->Handlers.WSendPacketsHandler = BlockRef->u1.Versions.v1->WSendPacketsHandler;
        OpenBlock->Handlers.WTransferDataHandler = BlockRef->u1.Versions.v1->WTransferDataHandler;
        break;

    case NDIS_OPEN_BLOCK_VERSION_WIN8: //9200
        OpenBlock->ProtocolNextOpen = BlockRef->u1.Versions.v2->ProtocolNextOpen;
        OpenBlock->BindDeviceName = BlockRef->u1.Versions.v2->BindDeviceName;
        OpenBlock->RootDeviceName = BlockRef->u1.Versions.v2->RootDeviceName;

        OpenBlock->Handlers.AllocateSharedMemoryHandler = BlockRef->u1.Versions.v2->AllocateSharedMemoryHandler;
        OpenBlock->Handlers.CancelSendPacketsHandler = BlockRef->u1.Versions.v2->CancelSendPacketsHandler;
        OpenBlock->Handlers.CmActivateVcCompleteHandler = BlockRef->u1.Versions.v2->CmActivateVcCompleteHandler;
        OpenBlock->Handlers.CmDeactivateVcCompleteHandler = BlockRef->u1.Versions.v2->CmDeactivateVcCompleteHandler;
        OpenBlock->Handlers.CoCreateVcHandler = BlockRef->u1.Versions.v2->CoCreateVcHandler;
        OpenBlock->Handlers.CoDeleteVcHandler = BlockRef->u1.Versions.v2->CoDeleteVcHandler;
        OpenBlock->Handlers.CoOidRequestCompleteHandler = BlockRef->u1.Versions.v2->CoOidRequestCompleteHandler;
        OpenBlock->Handlers.CoOidRequestHandler = BlockRef->u1.Versions.v2->CoOidRequestHandler;
        OpenBlock->Handlers.CoRequestCompleteHandler = BlockRef->u1.Versions.v2->CoRequestCompleteHandler;
        OpenBlock->Handlers.CoRequestHandler = BlockRef->u1.Versions.v2->CoRequestHandler;
        OpenBlock->Handlers.DirectOidRequestHandler = BlockRef->u1.Versions.v2->DirectOidRequestHandler;
        OpenBlock->Handlers.FreeSharedMemoryHandler = BlockRef->u1.Versions.v2->FreeSharedMemoryHandler;
        OpenBlock->Handlers.IndicateOffloadEventHandler = BlockRef->u1.Versions.v2->IndicateOffloadEventHandler;
        OpenBlock->Handlers.InitiateOffloadCompleteHandler = BlockRef->u1.Versions.v2->InitiateOffloadCompleteHandler;
        OpenBlock->Handlers.InvalidateOffloadCompleteHandler = BlockRef->u1.Versions.v2->InvalidateOffloadCompleteHandler;
        OpenBlock->Handlers.MiniportCoCreateVcHandler = BlockRef->u1.Versions.v2->MiniportCoCreateVcHandler;
        OpenBlock->Handlers.MiniportCoOidRequestHandler = BlockRef->u1.Versions.v2->MiniportCoOidRequestHandler;
        OpenBlock->Handlers.MiniportCoRequestHandler = BlockRef->u1.Versions.v2->MiniportCoRequestHandler;
        OpenBlock->Handlers.Ndis5WanSendHandler = BlockRef->u1.Versions.v2->Ndis5WanSendHandler;
        OpenBlock->Handlers.NextReturnNetBufferListsHandler = BlockRef->u1.Versions.v2->NextReturnNetBufferListsHandler;
        OpenBlock->Handlers.NextSendHandler = BlockRef->u1.Versions.v2->NextSendHandler;
        OpenBlock->Handlers.OidRequestCompleteHandler = BlockRef->u1.Versions.v2->OidRequestCompleteHandler;
        OpenBlock->Handlers.OidRequestHandler = BlockRef->u1.Versions.v2->OidRequestHandler;
        OpenBlock->Handlers.ProtSendCompleteHandler = BlockRef->u1.Versions.v2->ProtSendCompleteHandler;
        OpenBlock->Handlers.ProtSendNetBufferListsComplete = BlockRef->u1.Versions.v2->ProtSendNetBufferListsComplete;
        OpenBlock->Handlers.QueryOffloadCompleteHandler = BlockRef->u1.Versions.v2->QueryOffloadCompleteHandler;
        OpenBlock->Handlers.ReceiveCompleteHandler = BlockRef->u1.Versions.v2->ReceiveCompleteHandler;
        OpenBlock->Handlers.ReceiveHandler = BlockRef->u1.Versions.v2->ReceiveHandler;
        OpenBlock->Handlers.ReceiveNetBufferLists = BlockRef->u1.Versions.v2->ReceiveNetBufferLists;
        OpenBlock->Handlers.ReceivePacketHandler = BlockRef->u1.Versions.v2->ReceivePacketHandler;
        OpenBlock->Handlers.RequestCompleteHandler = BlockRef->u1.Versions.v2->RequestCompleteHandler;
        OpenBlock->Handlers.RequestHandler = BlockRef->u1.Versions.v2->RequestHandler;
        OpenBlock->Handlers.ResetCompleteHandler = BlockRef->u1.Versions.v2->ResetCompleteHandler;
        OpenBlock->Handlers.ResetHandler = BlockRef->u1.Versions.v2->ResetHandler;
        OpenBlock->Handlers.SavedCancelSendPacketsHandler = BlockRef->u1.Versions.v2->SavedCancelSendPacketsHandler;
        OpenBlock->Handlers.SavedSendHandler = BlockRef->u1.Versions.v2->SavedSendHandler;
        OpenBlock->Handlers.SavedSendPacketsHandler = BlockRef->u1.Versions.v2->SavedSendPacketsHandler;
        OpenBlock->Handlers.SendCompleteHandler = BlockRef->u1.Versions.v2->SendCompleteHandler;
        OpenBlock->Handlers.SendHandler = BlockRef->u1.Versions.v2->SendHandler;
        OpenBlock->Handlers.SendPacketsHandler = BlockRef->u1.Versions.v2->SendPacketsHandler;
        OpenBlock->Handlers.StatusCompleteHandler = BlockRef->u1.Versions.v2->StatusCompleteHandler;
        OpenBlock->Handlers.StatusHandler = BlockRef->u1.Versions.v2->StatusHandler;
        OpenBlock->Handlers.TcpOffloadDisconnectCompleteHandler = BlockRef->u1.Versions.v2->TcpOffloadDisconnectCompleteHandler;
        OpenBlock->Handlers.TcpOffloadEventHandler = BlockRef->u1.Versions.v2->TcpOffloadEventHandler;
        OpenBlock->Handlers.TcpOffloadForwardCompleteHandler = BlockRef->u1.Versions.v2->TcpOffloadForwardCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveCompleteHandler = BlockRef->u1.Versions.v2->TcpOffloadReceiveCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveIndicateHandler = BlockRef->u1.Versions.v2->TcpOffloadReceiveIndicateHandler;
        OpenBlock->Handlers.TcpOffloadSendCompleteHandler = BlockRef->u1.Versions.v2->TcpOffloadSendCompleteHandler;
        OpenBlock->Handlers.TerminateOffloadCompleteHandler = BlockRef->u1.Versions.v2->TerminateOffloadCompleteHandler;
        OpenBlock->Handlers.TransferDataCompleteHandler = BlockRef->u1.Versions.v2->TransferDataCompleteHandler;
        OpenBlock->Handlers.TransferDataHandler = BlockRef->u1.Versions.v2->TransferDataHandler;
        OpenBlock->Handlers.UpdateOffloadCompleteHandler = BlockRef->u1.Versions.v2->UpdateOffloadCompleteHandler;
        OpenBlock->Handlers.WanReceiveHandler = BlockRef->u1.Versions.v2->WanReceiveHandler;
        OpenBlock->Handlers.WSendHandler = BlockRef->u1.Versions.v2->WSendHandler;
        OpenBlock->Handlers.WSendPacketsHandler = BlockRef->u1.Versions.v2->WSendPacketsHandler;
        OpenBlock->Handlers.WTransferDataHandler = BlockRef->u1.Versions.v2->WTransferDataHandler;
        break;

    case NDIS_OPEN_BLOCK_VERSION_WIN81_WIN10TH1: //9600..10586      
        OpenBlock->ProtocolNextOpen = BlockRef->u1.Versions.u_v3.v3c->ProtocolNextOpen;
        OpenBlock->BindDeviceName = BlockRef->u1.Versions.u_v3.v3c->BindDeviceName;
        OpenBlock->RootDeviceName = BlockRef->u1.Versions.u_v3.v3c->RootDeviceName;

        OpenBlock->Handlers.AllocateSharedMemoryHandler = BlockRef->u1.Versions.u_v3.v3c->AllocateSharedMemoryHandler;
        OpenBlock->Handlers.CancelSendPacketsHandler = BlockRef->u1.Versions.u_v3.v3c->CancelSendPacketsHandler;
        OpenBlock->Handlers.CmActivateVcCompleteHandler = BlockRef->u1.Versions.u_v3.v3->CmActivateVcCompleteHandler;
        OpenBlock->Handlers.CmDeactivateVcCompleteHandler = BlockRef->u1.Versions.u_v3.v3->CmDeactivateVcCompleteHandler;
        OpenBlock->Handlers.CoCreateVcHandler = BlockRef->u1.Versions.u_v3.v3->CoCreateVcHandler;
        OpenBlock->Handlers.CoDeleteVcHandler = BlockRef->u1.Versions.u_v3.v3->CoDeleteVcHandler;
        OpenBlock->Handlers.CoOidRequestCompleteHandler = BlockRef->u1.Versions.u_v3.v3->CoOidRequestCompleteHandler;
        OpenBlock->Handlers.CoOidRequestHandler = BlockRef->u1.Versions.u_v3.v3->CoOidRequestHandler;
        OpenBlock->Handlers.CoRequestCompleteHandler = BlockRef->u1.Versions.u_v3.v3->CoRequestCompleteHandler;
        OpenBlock->Handlers.CoRequestHandler = BlockRef->u1.Versions.u_v3.v3->CoRequestHandler;
        OpenBlock->Handlers.DirectOidRequestHandler = BlockRef->u1.Versions.u_v3.v3c->DirectOidRequestHandler;
        OpenBlock->Handlers.FreeSharedMemoryHandler = BlockRef->u1.Versions.u_v3.v3c->FreeSharedMemoryHandler;
        OpenBlock->Handlers.IndicateOffloadEventHandler = BlockRef->u1.Versions.u_v3.v3c->IndicateOffloadEventHandler;
        OpenBlock->Handlers.InitiateOffloadCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->InitiateOffloadCompleteHandler;
        OpenBlock->Handlers.InvalidateOffloadCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->InvalidateOffloadCompleteHandler;
        OpenBlock->Handlers.MiniportCoCreateVcHandler = BlockRef->u1.Versions.u_v3.v3->MiniportCoCreateVcHandler;
        OpenBlock->Handlers.MiniportCoOidRequestHandler = BlockRef->u1.Versions.u_v3.v3->MiniportCoOidRequestHandler;
        OpenBlock->Handlers.MiniportCoRequestHandler = BlockRef->u1.Versions.u_v3.v3->MiniportCoRequestHandler;
        OpenBlock->Handlers.Ndis5WanSendHandler = BlockRef->u1.Versions.u_v3.v3c->Ndis5WanSendHandler;
        OpenBlock->Handlers.NextReturnNetBufferListsHandler = BlockRef->u1.Versions.u_v3.v3c->NextReturnNetBufferListsHandler;
        OpenBlock->Handlers.NextSendHandler = BlockRef->u1.Versions.u_v3.v3c->NextSendHandler;
        OpenBlock->Handlers.OidRequestCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->OidRequestCompleteHandler;
        OpenBlock->Handlers.OidRequestHandler = BlockRef->u1.Versions.u_v3.v3c->OidRequestHandler;
        OpenBlock->Handlers.ProtSendCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->ProtSendCompleteHandler;
        OpenBlock->Handlers.ProtSendNetBufferListsComplete = BlockRef->u1.Versions.u_v3.v3c->ProtSendNetBufferListsComplete;
        OpenBlock->Handlers.QueryOffloadCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->QueryOffloadCompleteHandler;
        OpenBlock->Handlers.ReceiveCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->ReceiveCompleteHandler;
        OpenBlock->Handlers.ReceiveHandler = BlockRef->u1.Versions.u_v3.v3c->ReceiveHandler;
        OpenBlock->Handlers.ReceiveNetBufferLists = BlockRef->u1.Versions.u_v3.v3c->ReceiveNetBufferLists;
        OpenBlock->Handlers.ReceivePacketHandler = BlockRef->u1.Versions.u_v3.v3c->ReceivePacketHandler;
        OpenBlock->Handlers.RequestCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->RequestCompleteHandler;
        OpenBlock->Handlers.RequestHandler = BlockRef->u1.Versions.u_v3.v3c->RequestHandler;
        OpenBlock->Handlers.ResetCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->ResetCompleteHandler;
        OpenBlock->Handlers.ResetHandler = BlockRef->u1.Versions.u_v3.v3c->ResetHandler;
        OpenBlock->Handlers.SavedCancelSendPacketsHandler = BlockRef->u1.Versions.u_v3.v3c->SavedCancelSendPacketsHandler;
        OpenBlock->Handlers.SavedSendHandler = BlockRef->u1.Versions.u_v3.v3c->SavedSendHandler;
        OpenBlock->Handlers.SavedSendPacketsHandler = BlockRef->u1.Versions.u_v3.v3c->SavedSendPacketsHandler;
        OpenBlock->Handlers.SendCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->SendCompleteHandler;
        OpenBlock->Handlers.SendHandler = BlockRef->u1.Versions.u_v3.v3c->SendHandler;
        OpenBlock->Handlers.SendPacketsHandler = BlockRef->u1.Versions.u_v3.v3c->SendPacketsHandler;
        OpenBlock->Handlers.StatusCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->StatusCompleteHandler;
        OpenBlock->Handlers.StatusHandler = BlockRef->u1.Versions.u_v3.v3c->StatusHandler;
        OpenBlock->Handlers.TcpOffloadDisconnectCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->TcpOffloadDisconnectCompleteHandler;
        OpenBlock->Handlers.TcpOffloadEventHandler = BlockRef->u1.Versions.u_v3.v3c->TcpOffloadEventHandler;
        OpenBlock->Handlers.TcpOffloadForwardCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->TcpOffloadForwardCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->TcpOffloadReceiveCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveIndicateHandler = BlockRef->u1.Versions.u_v3.v3c->TcpOffloadReceiveIndicateHandler;
        OpenBlock->Handlers.TcpOffloadSendCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->TcpOffloadSendCompleteHandler;
        OpenBlock->Handlers.TerminateOffloadCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->TerminateOffloadCompleteHandler;
        OpenBlock->Handlers.TransferDataCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->TransferDataCompleteHandler;
        OpenBlock->Handlers.TransferDataHandler = BlockRef->u1.Versions.u_v3.v3c->TransferDataHandler;
        OpenBlock->Handlers.UpdateOffloadCompleteHandler = BlockRef->u1.Versions.u_v3.v3c->UpdateOffloadCompleteHandler;
        OpenBlock->Handlers.WanReceiveHandler = BlockRef->u1.Versions.u_v3.v3c->WanReceiveHandler;
        OpenBlock->Handlers.WSendHandler = BlockRef->u1.Versions.u_v3.v3c->WSendHandler;
        OpenBlock->Handlers.WSendPacketsHandler = BlockRef->u1.Versions.u_v3.v3c->WSendPacketsHandler;
        OpenBlock->Handlers.WTransferDataHandler = BlockRef->u1.Versions.u_v3.v3c->WTransferDataHandler;
        break;

    case NDIS_OPEN_BLOCK_VERSION_WIN10_RS1_4: //14393..17134
        OpenBlock->ProtocolNextOpen = BlockRef->u1.Versions.u_v4.v4c->ProtocolNextOpen;
        OpenBlock->BindDeviceName = BlockRef->u1.Versions.u_v4.v4c->BindDeviceName;
        OpenBlock->RootDeviceName = BlockRef->u1.Versions.u_v4.v4c->RootDeviceName;

        OpenBlock->Handlers.AllocateSharedMemoryHandler = BlockRef->u1.Versions.u_v4.v4c->AllocateSharedMemoryHandler;
        OpenBlock->Handlers.CancelSendPacketsHandler = BlockRef->u1.Versions.u_v4.v4c->CancelSendPacketsHandler;
        OpenBlock->Handlers.CmActivateVcCompleteHandler = BlockRef->u1.Versions.u_v4.v4->CmActivateVcCompleteHandler;
        OpenBlock->Handlers.CmDeactivateVcCompleteHandler = BlockRef->u1.Versions.u_v4.v4->CmDeactivateVcCompleteHandler;
        OpenBlock->Handlers.CoCreateVcHandler = BlockRef->u1.Versions.u_v4.v4->CoCreateVcHandler;
        OpenBlock->Handlers.CoDeleteVcHandler = BlockRef->u1.Versions.u_v4.v4->CoDeleteVcHandler;
        OpenBlock->Handlers.CoOidRequestCompleteHandler = BlockRef->u1.Versions.u_v4.v4->CoOidRequestCompleteHandler;
        OpenBlock->Handlers.CoOidRequestHandler = BlockRef->u1.Versions.u_v4.v4->CoOidRequestHandler;
        OpenBlock->Handlers.CoRequestCompleteHandler = BlockRef->u1.Versions.u_v4.v4->CoRequestCompleteHandler;
        OpenBlock->Handlers.CoRequestHandler = BlockRef->u1.Versions.u_v4.v4->CoRequestHandler;
        OpenBlock->Handlers.DirectOidRequestHandler = BlockRef->u1.Versions.u_v4.v4c->DirectOidRequestHandler;
        OpenBlock->Handlers.FreeSharedMemoryHandler = BlockRef->u1.Versions.u_v4.v4c->FreeSharedMemoryHandler;
        OpenBlock->Handlers.IndicateOffloadEventHandler = BlockRef->u1.Versions.u_v4.v4c->IndicateOffloadEventHandler;
        OpenBlock->Handlers.InitiateOffloadCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->InitiateOffloadCompleteHandler;
        OpenBlock->Handlers.InvalidateOffloadCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->InvalidateOffloadCompleteHandler;
        OpenBlock->Handlers.MiniportCoCreateVcHandler = BlockRef->u1.Versions.u_v4.v4->MiniportCoCreateVcHandler;
        OpenBlock->Handlers.MiniportCoOidRequestHandler = BlockRef->u1.Versions.u_v4.v4->MiniportCoOidRequestHandler;
        OpenBlock->Handlers.MiniportCoRequestHandler = BlockRef->u1.Versions.u_v4.v4->MiniportCoRequestHandler;
        OpenBlock->Handlers.Ndis5WanSendHandler = BlockRef->u1.Versions.u_v4.v4c->Ndis5WanSendHandler;
        OpenBlock->Handlers.NextReturnNetBufferListsHandler = BlockRef->u1.Versions.u_v4.v4c->NextReturnNetBufferListsHandler;
        OpenBlock->Handlers.NextSendHandler = BlockRef->u1.Versions.u_v4.v4c->NextSendHandler;
        OpenBlock->Handlers.OidRequestCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->OidRequestCompleteHandler;
        OpenBlock->Handlers.OidRequestHandler = BlockRef->u1.Versions.u_v4.v4c->OidRequestHandler;
        OpenBlock->Handlers.ProtSendCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->ProtSendCompleteHandler;
        OpenBlock->Handlers.ProtSendNetBufferListsComplete = BlockRef->u1.Versions.u_v4.v4c->ProtSendNetBufferListsComplete;
        OpenBlock->Handlers.QueryOffloadCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->QueryOffloadCompleteHandler;
        OpenBlock->Handlers.ReceiveCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->ReceiveCompleteHandler;
        OpenBlock->Handlers.ReceiveHandler = BlockRef->u1.Versions.u_v4.v4c->ReceiveHandler;
        OpenBlock->Handlers.ReceiveNetBufferLists = BlockRef->u1.Versions.u_v4.v4c->ReceiveNetBufferLists;
        OpenBlock->Handlers.ReceivePacketHandler = BlockRef->u1.Versions.u_v4.v4c->ReceivePacketHandler;
        OpenBlock->Handlers.RequestCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->RequestCompleteHandler;
        OpenBlock->Handlers.RequestHandler = BlockRef->u1.Versions.u_v4.v4c->RequestHandler;
        OpenBlock->Handlers.ResetCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->ResetCompleteHandler;
        OpenBlock->Handlers.ResetHandler = BlockRef->u1.Versions.u_v4.v4c->ResetHandler;
        OpenBlock->Handlers.SavedCancelSendPacketsHandler = BlockRef->u1.Versions.u_v4.v4c->SavedCancelSendPacketsHandler;
        OpenBlock->Handlers.SavedSendHandler = BlockRef->u1.Versions.u_v4.v4c->SavedSendHandler;
        OpenBlock->Handlers.SavedSendPacketsHandler = BlockRef->u1.Versions.u_v4.v4c->SavedSendPacketsHandler;
        OpenBlock->Handlers.SendCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->SendCompleteHandler;
        OpenBlock->Handlers.SendHandler = BlockRef->u1.Versions.u_v4.v4c->SendHandler;
        OpenBlock->Handlers.SendPacketsHandler = BlockRef->u1.Versions.u_v4.v4c->SendPacketsHandler;
        OpenBlock->Handlers.StatusCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->StatusCompleteHandler;
        OpenBlock->Handlers.StatusHandler = BlockRef->u1.Versions.u_v4.v4c->StatusHandler;
        OpenBlock->Handlers.TcpOffloadDisconnectCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->TcpOffloadDisconnectCompleteHandler;
        OpenBlock->Handlers.TcpOffloadEventHandler = BlockRef->u1.Versions.u_v4.v4c->TcpOffloadEventHandler;
        OpenBlock->Handlers.TcpOffloadForwardCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->TcpOffloadForwardCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->TcpOffloadReceiveCompleteHandler;
        OpenBlock->Handlers.TcpOffloadReceiveIndicateHandler = BlockRef->u1.Versions.u_v4.v4c->TcpOffloadReceiveIndicateHandler;
        OpenBlock->Handlers.TcpOffloadSendCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->TcpOffloadSendCompleteHandler;
        OpenBlock->Handlers.TerminateOffloadCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->TerminateOffloadCompleteHandler;
        OpenBlock->Handlers.TransferDataCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->TransferDataCompleteHandler;
        OpenBlock->Handlers.TransferDataHandler = BlockRef->u1.Versions.u_v4.v4c->TransferDataHandler;
        OpenBlock->Handlers.UpdateOffloadCompleteHandler = BlockRef->u1.Versions.u_v4.v4c->UpdateOffloadCompleteHandler;
        OpenBlock->Handlers.WanReceiveHandler = BlockRef->u1.Versions.u_v4.v4c->WanReceiveHandler;
        OpenBlock->Handlers.WSendHandler = BlockRef->u1.Versions.u_v4.v4c->WSendHandler;
        OpenBlock->Handlers.WSendPacketsHandler = BlockRef->u1.Versions.u_v4.v4c->WSendPacketsHandler;
        OpenBlock->Handlers.WTransferDataHandler = BlockRef->u1.Versions.u_v4.v4c->WTransferDataHandler;
        break;

    case NDIS_OPEN_BLOCK_VERSION_WIN10_RS5_WIN11: //17763..22000
        OpenBlock->ProtocolNextOpen = BlockRef->u1.Versions.u_v5.v5c->ProtocolNextOpen;
        OpenBlock->BindDeviceName = BlockRef->u1.Versions.u_v5.v5c->BindDeviceName;
        OpenBlock->RootDeviceName = BlockRef->u1.Versions.u_v5.v5c->RootDeviceName;

        OpenBlock->Handlers.AllocateSharedMemoryHandler = BlockRef->u1.Versions.u_v5.v5c->AllocateSharedMemoryHandler;
        OpenBlock->Handlers.CancelSendPacketsHandler = BlockRef->u1.Versions.u_v5.v5c->CancelSendPacketsHandler;
        OpenBlock->Handlers.CmActivateVcCompleteHandler = BlockRef->u1.Versions.u_v5.v5->CmActivateVcCompleteHandler;
        OpenBlock->Handlers.CmDeactivateVcCompleteHandler = BlockRef->u1.Versions.u_v5.v5->CmDeactivateVcCompleteHandler;
        OpenBlock->Handlers.CoCreateVcHandler = BlockRef->u1.Versions.u_v5.v5->CoCreateVcHandler;
        OpenBlock->Handlers.CoDeleteVcHandler = BlockRef->u1.Versions.u_v5.v5->CoDeleteVcHandler;
        OpenBlock->Handlers.CoOidRequestCompleteHandler = BlockRef->u1.Versions.u_v5.v5->CoOidRequestCompleteHandler;
        OpenBlock->Handlers.CoOidRequestHandler = BlockRef->u1.Versions.u_v5.v5->CoOidRequestHandler;
        OpenBlock->Handlers.CoRequestCompleteHandler = BlockRef->u1.Versions.u_v5.v5->CoRequestCompleteHandler;
        OpenBlock->Handlers.CoRequestHandler = BlockRef->u1.Versions.u_v5.v5->CoRequestHandler;
        OpenBlock->Handlers.DirectOidRequestHandler = BlockRef->u1.Versions.u_v5.v5c->DirectOidRequestHandler;
        OpenBlock->Handlers.FreeSharedMemoryHandler = BlockRef->u1.Versions.u_v5.v5c->FreeSharedMemoryHandler;
        OpenBlock->Handlers.MiniportCoCreateVcHandler = BlockRef->u1.Versions.u_v5.v5->MiniportCoCreateVcHandler;
        OpenBlock->Handlers.MiniportCoOidRequestHandler = BlockRef->u1.Versions.u_v5.v5->MiniportCoOidRequestHandler;
        OpenBlock->Handlers.MiniportCoRequestHandler = BlockRef->u1.Versions.u_v5.v5->MiniportCoRequestHandler;
        OpenBlock->Handlers.Ndis5WanSendHandler = BlockRef->u1.Versions.u_v5.v5c->Ndis5WanSendHandler;
        OpenBlock->Handlers.NextReturnNetBufferListsHandler = BlockRef->u1.Versions.u_v5.v5c->NextReturnNetBufferListsHandler;
        OpenBlock->Handlers.NextSendHandler = BlockRef->u1.Versions.u_v5.v5c->NextSendHandler;
        OpenBlock->Handlers.OidRequestCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->OidRequestCompleteHandler;
        OpenBlock->Handlers.OidRequestHandler = BlockRef->u1.Versions.u_v5.v5c->OidRequestHandler;
        OpenBlock->Handlers.ProtSendCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->ProtSendCompleteHandler;
        OpenBlock->Handlers.ProtSendNetBufferListsComplete = BlockRef->u1.Versions.u_v5.v5c->ProtSendNetBufferListsComplete;
        OpenBlock->Handlers.ReceiveCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->ReceiveCompleteHandler;
        OpenBlock->Handlers.ReceiveHandler = BlockRef->u1.Versions.u_v5.v5c->ReceiveHandler;
        OpenBlock->Handlers.ReceiveNetBufferLists = BlockRef->u1.Versions.u_v5.v5c->ReceiveNetBufferLists;
        OpenBlock->Handlers.ReceivePacketHandler = BlockRef->u1.Versions.u_v5.v5c->ReceivePacketHandler;
        OpenBlock->Handlers.RequestCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->RequestCompleteHandler;
        OpenBlock->Handlers.RequestHandler = BlockRef->u1.Versions.u_v5.v5c->RequestHandler;
        OpenBlock->Handlers.ResetCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->ResetCompleteHandler;
        OpenBlock->Handlers.ResetHandler = BlockRef->u1.Versions.u_v5.v5c->ResetHandler;
        OpenBlock->Handlers.SavedCancelSendPacketsHandler = BlockRef->u1.Versions.u_v5.v5c->SavedCancelSendPacketsHandler;
        OpenBlock->Handlers.SavedSendHandler = BlockRef->u1.Versions.u_v5.v5c->SavedSendHandler;
        OpenBlock->Handlers.SavedSendPacketsHandler = BlockRef->u1.Versions.u_v5.v5c->SavedSendPacketsHandler;
        OpenBlock->Handlers.SendCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->SendCompleteHandler;
        OpenBlock->Handlers.SendHandler = BlockRef->u1.Versions.u_v5.v5c->SendHandler;
        OpenBlock->Handlers.SendPacketsHandler = BlockRef->u1.Versions.u_v5.v5c->SendPacketsHandler;
        OpenBlock->Handlers.StatusCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->StatusCompleteHandler;
        OpenBlock->Handlers.StatusHandler = BlockRef->u1.Versions.u_v5.v5c->StatusHandler;
        OpenBlock->Handlers.TransferDataCompleteHandler = BlockRef->u1.Versions.u_v5.v5c->TransferDataCompleteHandler;
        OpenBlock->Handlers.TransferDataHandler = BlockRef->u1.Versions.u_v5.v5c->TransferDataHandler;
        OpenBlock->Handlers.WanReceiveHandler = BlockRef->u1.Versions.u_v5.v5c->WanReceiveHandler;
        OpenBlock->Handlers.WSendHandler = BlockRef->u1.Versions.u_v5.v5c->WSendHandler;
        OpenBlock->Handlers.WSendPacketsHandler = BlockRef->u1.Versions.u_v5.v5c->WSendPacketsHandler;
        OpenBlock->Handlers.WTransferDataHandler = BlockRef->u1.Versions.u_v5.v5c->WTransferDataHandler;
        break;

    case NDIS_OPEN_BLOCK_VERSION_WIN11_22_25H2: //22621..25905
        OpenBlock->ProtocolNextOpen = BlockRef->u1.Versions.u_v6.v6c->ProtocolNextOpen;
        OpenBlock->BindDeviceName = BlockRef->u1.Versions.u_v6.v6c->BindDeviceName;
        OpenBlock->RootDeviceName = BlockRef->u1.Versions.u_v6.v6c->RootDeviceName;

        OpenBlock->Handlers.AllocateSharedMemoryHandler = BlockRef->u1.Versions.u_v6.v6c->AllocateSharedMemoryHandler;
        OpenBlock->Handlers.CancelSendPacketsHandler = BlockRef->u1.Versions.u_v6.v6c->CancelSendPacketsHandler;
        OpenBlock->Handlers.CmActivateVcCompleteHandler = BlockRef->u1.Versions.u_v6.v6->CmActivateVcCompleteHandler;
        OpenBlock->Handlers.CmDeactivateVcCompleteHandler = BlockRef->u1.Versions.u_v6.v6->CmDeactivateVcCompleteHandler;
        OpenBlock->Handlers.CoCreateVcHandler = BlockRef->u1.Versions.u_v6.v6->CoCreateVcHandler;
        OpenBlock->Handlers.CoDeleteVcHandler = BlockRef->u1.Versions.u_v6.v6->CoDeleteVcHandler;
        OpenBlock->Handlers.CoOidRequestCompleteHandler = BlockRef->u1.Versions.u_v6.v6->CoOidRequestCompleteHandler;
        OpenBlock->Handlers.CoOidRequestHandler = BlockRef->u1.Versions.u_v6.v6->CoOidRequestHandler;
        OpenBlock->Handlers.CoRequestCompleteHandler = BlockRef->u1.Versions.u_v6.v6->CoRequestCompleteHandler;
        OpenBlock->Handlers.CoRequestHandler = BlockRef->u1.Versions.u_v6.v6->CoRequestHandler;
        OpenBlock->Handlers.DirectOidRequestHandler = BlockRef->u1.Versions.u_v6.v6c->DirectOidRequestHandler;
        OpenBlock->Handlers.FreeSharedMemoryHandler = BlockRef->u1.Versions.u_v6.v6c->FreeSharedMemoryHandler;
        OpenBlock->Handlers.MiniportCoCreateVcHandler = BlockRef->u1.Versions.u_v6.v6->MiniportCoCreateVcHandler;
        OpenBlock->Handlers.MiniportCoOidRequestHandler = BlockRef->u1.Versions.u_v6.v6->MiniportCoOidRequestHandler;
        OpenBlock->Handlers.MiniportCoRequestHandler = BlockRef->u1.Versions.u_v6.v6->MiniportCoRequestHandler;
        OpenBlock->Handlers.Ndis5WanSendHandler = BlockRef->u1.Versions.u_v6.v6c->Ndis5WanSendHandler;
        OpenBlock->Handlers.NextReturnNetBufferListsHandler = BlockRef->u1.Versions.u_v6.v6c->NextReturnNetBufferListsHandler;
        OpenBlock->Handlers.NextSendHandler = BlockRef->u1.Versions.u_v6.v6c->NextSendHandler;
        OpenBlock->Handlers.OidRequestCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->OidRequestCompleteHandler;
        OpenBlock->Handlers.OidRequestHandler = BlockRef->u1.Versions.u_v6.v6c->OidRequestHandler;
        OpenBlock->Handlers.ProtSendCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->ProtSendCompleteHandler;
        OpenBlock->Handlers.ProtSendNetBufferListsComplete = BlockRef->u1.Versions.u_v6.v6c->ProtSendNetBufferListsComplete;
        OpenBlock->Handlers.ReceiveCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->ReceiveCompleteHandler;
        OpenBlock->Handlers.ReceiveHandler = BlockRef->u1.Versions.u_v6.v6c->ReceiveHandler;
        OpenBlock->Handlers.ReceiveNetBufferLists = BlockRef->u1.Versions.u_v6.v6c->ReceiveNetBufferLists;
        OpenBlock->Handlers.ReceivePacketHandler = BlockRef->u1.Versions.u_v6.v6c->ReceivePacketHandler;
        OpenBlock->Handlers.RequestCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->RequestCompleteHandler;
        OpenBlock->Handlers.RequestHandler = BlockRef->u1.Versions.u_v6.v6c->RequestHandler;
        OpenBlock->Handlers.ResetCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->ResetCompleteHandler;
        OpenBlock->Handlers.ResetHandler = BlockRef->u1.Versions.u_v6.v6c->ResetHandler;
        OpenBlock->Handlers.SavedCancelSendPacketsHandler = BlockRef->u1.Versions.u_v6.v6c->SavedCancelSendPacketsHandler;
        OpenBlock->Handlers.SavedSendHandler = BlockRef->u1.Versions.u_v6.v6c->SavedSendHandler;
        OpenBlock->Handlers.SavedSendPacketsHandler = BlockRef->u1.Versions.u_v6.v6c->SavedSendPacketsHandler;
        OpenBlock->Handlers.SendCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->SendCompleteHandler;
        OpenBlock->Handlers.SendHandler = BlockRef->u1.Versions.u_v6.v6c->SendHandler;
        OpenBlock->Handlers.SendPacketsHandler = BlockRef->u1.Versions.u_v6.v6c->SendPacketsHandler;
        OpenBlock->Handlers.StatusCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->StatusCompleteHandler;
        OpenBlock->Handlers.StatusHandler = BlockRef->u1.Versions.u_v6.v6c->StatusHandler;
        OpenBlock->Handlers.TransferDataCompleteHandler = BlockRef->u1.Versions.u_v6.v6c->TransferDataCompleteHandler;
        OpenBlock->Handlers.TransferDataHandler = BlockRef->u1.Versions.u_v6.v6c->TransferDataHandler;
        OpenBlock->Handlers.WanReceiveHandler = BlockRef->u1.Versions.u_v6.v6c->WanReceiveHandler;
        OpenBlock->Handlers.WSendHandler = BlockRef->u1.Versions.u_v6.v6c->WSendHandler;
        OpenBlock->Handlers.WSendPacketsHandler = BlockRef->u1.Versions.u_v6.v6c->WSendPacketsHandler;
        OpenBlock->Handlers.WTransferDataHandler = BlockRef->u1.Versions.u_v6.v6c->WTransferDataHandler;
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

/*
* ReadAndConvertProtocolBlock
*
* Purpose:
*
* Read protocol block from kernel and convert it to the compatible form.
*
*/
_Success_(return == TRUE)
BOOL ReadAndConvertProtocolBlock(
    _In_ ULONG_PTR ObjectAddress,
    _Inout_ NDIS_PROTOCOL_BLOCK_COMPATIBLE * ProtoBlock,
    _Out_opt_ PULONG ObjectVersion
)
{
    BOOL Result = FALSE;
    ULONG objectVersion;
    ULONG objectSize;
    PVOID objectPtr;

    PROTOCOL_BLOCK_VERSIONS ProtocolRef;

    objectPtr = DumpProtocolBlockVersionAware(ObjectAddress, &objectSize, &objectVersion);
    if (objectPtr == NULL)
        return FALSE;

    ProtocolRef.u1.Ref = objectPtr;
    Result = CreateCompatibleProtocolBlock(objectVersion, &ProtocolRef, ProtoBlock);

    if (ObjectVersion) {
        *ObjectVersion = objectVersion;
    }

    supHeapFree(objectPtr);

    return Result;
}

/*
* ReadAndConvertOpenBlock
*
* Purpose:
*
* Read open block from kernel and convert it to compatible form.
*
*/
_Success_(return == TRUE)
BOOL ReadAndConvertOpenBlock(
    _In_ ULONG_PTR ObjectAddress,
    _Inout_ NDIS_OPEN_BLOCK_COMPATIBLE * OpenBlock,
    _Out_opt_ PULONG ObjectVersion)
{
    BOOL Result = FALSE;
    ULONG objectVersion;
    ULONG objectSize;
    PVOID objectPtr;

    OPEN_BLOCK_VERSIONS BlockRef;

    objectPtr = DumpOpenBlockVersionAware(ObjectAddress, &objectSize, &objectVersion);
    if (objectPtr == NULL) {
        return FALSE;
    }
    BlockRef.u1.Ref = objectPtr;

    Result = CreateCompatibleOpenBlock(objectVersion, &BlockRef, OpenBlock);

    if (ObjectVersion) {
        *ObjectVersion = objectVersion;
    }

    supHeapFree(objectPtr);

    return Result;
}

```

`Source/Plugins/Sonar/query.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       QUERY.H
*
*  VERSION:     1.05
*
*  DATE:        14 May 2025
*
*  Sonar plugin query information definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define NDIS_OPEN_BLOCK_VERSION_WIN7            1
#define NDIS_OPEN_BLOCK_VERSION_WIN8            2
#define NDIS_OPEN_BLOCK_VERSION_WIN81_WIN10TH1  3
#define NDIS_OPEN_BLOCK_VERSION_WIN10_RS1_4     4
#define NDIS_OPEN_BLOCK_VERSION_WIN10_RS5_WIN11 5
#define NDIS_OPEN_BLOCK_VERSION_WIN11_22_25H2   6

typedef struct _PROTOCOL_BLOCK_VERSIONS {
    union {
        union {
            NDIS_PROTOCOL_BLOCK_7601* v1;
            NDIS_PROTOCOL_BLOCK_9200* v2;
            NDIS_PROTOCOL_BLOCK_9600_17134* v3;
            NDIS_PROTOCOL_BLOCK_17763* v4;
            NDIS_PROTOCOL_BLOCK_18362_25905* v5;
        } Versions;
        PVOID Ref;
    } u1;
} PROTOCOL_BLOCK_VERSIONS, * PPROTOCOL_BLOCK_VERSIONS;

typedef struct _OPEN_BLOCK_VERSIONS {
    union {
        union {
            NDIS_OPEN_BLOCK_7601* v1;
            NDIS_OPEN_BLOCK_9200* v2;
            union {
                NDIS_COMMON_OPEN_BLOCK_9600_10586* v3c;
                NDIS_OPEN_BLOCK_9600_10586* v3;
            } u_v3;
            union {
                NDIS_COMMON_OPEN_BLOCK_14393_17134* v4c;
                NDIS_OPEN_BLOCK_14393_17134* v4;
            } u_v4;
            union {
                NDIS_COMMON_OPEN_BLOCK_17763_22000* v5c;
                NDIS_OPEN_BLOCK_17763_22000* v5;
            } u_v5;
            union {
                NDIS_COMMON_OPEN_BLOCK_22621_25905* v6c;
                NDIS_OPEN_BLOCK_22621_25905* v6;
            } u_v6;
        } Versions;
        PVOID Ref;
    } u1;
} OPEN_BLOCK_VERSIONS, * POPEN_BLOCK_VERSIONS;

typedef enum _NDIS_OBJECT_TYPE {
    NdisObjectTypeProtocolBlock = 1,
    NdisObjectTypeOpenBlock,
    NdisObjectTypeMDriverBlock,
    NdisObjectTypeMiniportBlock,
    NdisObjectTypeInvalid
} NDIS_OBJECT_TYPE;

//
// Structure for dump convertion, only handlers, flags, unicode strings.
//
typedef struct _NDIS_OPEN_BLOCK_HANDLERS {
    PVOID NextSendHandler;
    PVOID NextReturnNetBufferListsHandler;
    PVOID SendHandler;
    PVOID TransferDataHandler;
    PVOID SendCompleteHandler;
    PVOID TransferDataCompleteHandler;
    PVOID ReceiveHandler;
    PVOID ReceiveCompleteHandler;
    PVOID WanReceiveHandler;
    PVOID RequestCompleteHandler;
    PVOID ReceivePacketHandler;
    PVOID SendPacketsHandler;
    PVOID ResetHandler;
    PVOID RequestHandler;
    PVOID OidRequestHandler;
    PVOID ResetCompleteHandler;

    PVOID StatusHandler;
    PVOID StatusCompleteHandler;

    PVOID WSendHandler;
    PVOID WTransferDataHandler;
    PVOID WSendPacketsHandler;
    PVOID CancelSendPacketsHandler;

    PVOID ProtSendNetBufferListsComplete;
    PVOID ReceiveNetBufferLists;
    PVOID SavedSendNBLHandler;
    PVOID SavedSendPacketsHandler;
    PVOID SavedCancelSendPacketsHandler;

    PVOID SavedSendHandler;

    PVOID InitiateOffloadCompleteHandler;
    PVOID TerminateOffloadCompleteHandler;
    PVOID UpdateOffloadCompleteHandler;
    PVOID InvalidateOffloadCompleteHandler;
    PVOID QueryOffloadCompleteHandler;
    PVOID IndicateOffloadEventHandler;
    PVOID TcpOffloadSendCompleteHandler;
    PVOID TcpOffloadReceiveCompleteHandler;
    PVOID TcpOffloadDisconnectCompleteHandler;
    PVOID TcpOffloadForwardCompleteHandler;
    PVOID TcpOffloadEventHandler;
    PVOID TcpOffloadReceiveIndicateHandler;

    PVOID Ndis5WanSendHandler;
    PVOID ProtSendCompleteHandler;
    PVOID OidRequestCompleteHandler;

    PVOID DirectOidRequestCompleteHandler;
    PVOID DirectOidRequestHandler;

    PVOID AllocateSharedMemoryHandler;
    PVOID FreeSharedMemoryHandler;

    PVOID MiniportCoCreateVcHandler;
    PVOID MiniportCoRequestHandler;
    PVOID CoCreateVcHandler;
    PVOID CoDeleteVcHandler;
    PVOID CmActivateVcCompleteHandler;
    PVOID CmDeactivateVcCompleteHandler;
    PVOID CoRequestCompleteHandler;
    PVOID CoRequestHandler;

    PVOID MiniportCoOidRequestHandler;
    PVOID CoOidRequestCompleteHandler;
    PVOID CoOidRequestHandler;
} NDIS_OPEN_BLOCK_HANDLERS, * PNDIS_OPEN_BLOCK_HANDLERS;

typedef struct _NDIS_OPEN_BLOCK_COMPATIBLE {
    PVOID ProtocolNextOpen;

    UNICODE_STRING* BindDeviceName;
    UNICODE_STRING* RootDeviceName;

    NDIS_OPEN_BLOCK_HANDLERS Handlers;

} NDIS_OPEN_BLOCK_COMPATIBLE, * PNDIS_OPEN_BLOCK_COMPATIBLE;

typedef struct _NDIS_PROTOCOL_BLOCK_HANDLERS {
    PVOID BindAdapterHandlerEx;
    PVOID UnbindAdapterHandlerEx;
    PVOID OpenAdapterCompleteHandlerEx;
    PVOID CloseAdapterCompleteHandlerEx;
    PVOID PnPEventHandler;

    PVOID UnloadHandler;
    PVOID UninstallHandler;
    PVOID RequestCompleteHandler;

    PVOID StatusHandler;

    PVOID StatusCompleteHandler;
    PVOID ReceiveNetBufferListsHandler;
    PVOID SendNetBufferListsCompleteHandler;

    PVOID CoStatusHandler;

    PVOID CoAfRegisterNotifyHandler;
    PVOID CoReceiveNetBufferListsHandler;
    PVOID CoSendNetBufferListsCompleteHandler;
    PVOID OpenAdapterCompleteHandler;
    PVOID CloseAdapterCompleteHandler;

    PVOID SendCompleteHandler;

    PVOID TransferDataCompleteHandler;

    PVOID ResetCompleteHandler;

    PVOID ReceiveHandler;

    PVOID ReceiveCompleteHandler;
    PVOID ReceivePacketHandler;
    PVOID BindAdapterHandler;
    PVOID UnbindAdapterHandler;
    PVOID CoSendCompleteHandler;
    PVOID CoReceivePacketHandler;
    PVOID OidRequestCompleteHandler;

    PVOID InitiateOffloadCompleteHandler;
    PVOID TerminateOffloadCompleteHandler;
    PVOID UpdateOffloadCompleteHandler;
    PVOID InvalidateOffloadCompleteHandler;
    PVOID QueryOffloadCompleteHandler;
    PVOID IndicateOffloadEventHandler;
    PVOID TcpOffloadSendCompleteHandler;
    PVOID TcpOffloadReceiveCompleteHandler;
    PVOID TcpOffloadDisconnectCompleteHandler;
    PVOID TcpOffloadForwardCompleteHandler;
    PVOID TcpOffloadEventHandler;
    PVOID TcpOffloadReceiveIndicateHandler;
    PVOID DirectOidRequestCompleteHandler;
    PVOID AllocateSharedMemoryHandler;
    PVOID FreeSharedMemoryHandler;
} NDIS_PROTOCOL_BLOCK_HANDLERS, * PNDIS_PROTOCOL_BLOCK_HANDLERS;

typedef struct _NDIS_PROTOCOL_BLOCK_COMPATIBLE {
    UNICODE_STRING Name;
    UNICODE_STRING ImageName;
    UNICODE_STRING* BindDeviceName;
    UNICODE_STRING* RootDeviceName;

    PVOID NextProtocol;
    PVOID OpenQueue;
    PVOID AssociatedMiniDriver;

    UCHAR MajorNdisVersion;
    UCHAR MinorNdisVersion;
    UCHAR MajorDriverVersion;
    UCHAR MinorDriverVersion;

    NDIS_PROTOCOL_BLOCK_HANDLERS Handlers;

} NDIS_PROTOCOL_BLOCK_COMPATIBLE, * PNDIS_PROTOCOL_BLOCK_COMPATIBLE;

static LPCWSTR g_lpszOpenBlockHandlers[] = {
    TEXT("NextSendHandler"),
    TEXT("NextReturnNetBufferListsHandler"),
    TEXT("SendHandler"),
    TEXT("TransferDataHandler"),
    TEXT("SendCompleteHandler"),
    TEXT("TransferDataCompleteHandler"),
    TEXT("ReceiveHandler"),
    TEXT("ReceiveCompleteHandler"),
    TEXT("WanReceiveHandler"),
    TEXT("RequestCompleteHandler"),
    TEXT("ReceivePacketHandler"),
    TEXT("SendPacketsHandler"),
    TEXT("ResetHandler"),
    TEXT("RequestHandler"),
    TEXT("OidRequestHandler"),
    TEXT("ResetCompleteHandler"),

    TEXT("StatusHandler"),
    TEXT("StatusCompleteHandler"),

    TEXT("WSendHandler"),
    TEXT("WTransferDataHandler"),
    TEXT("WSendPacketsHandler"),
    TEXT("CancelSendPacketsHandler"),

    TEXT("ProtSendNetBufferListsComplete"),
    TEXT("ReceiveNetBufferLists"),
    TEXT("SavedSendNBLHandler"),
    TEXT("SavedSendPacketsHandler"),
    TEXT("SavedCancelSendPacketsHandler"),

    TEXT("SavedSendHandler"),

    TEXT("InitiateOffloadCompleteHandler"),
    TEXT("TerminateOffloadCompleteHandler"),
    TEXT("UpdateOffloadCompleteHandler"),
    TEXT("InvalidateOffloadCompleteHandler"),
    TEXT("QueryOffloadCompleteHandler"),
    TEXT("IndicateOffloadEventHandler"),
    TEXT("TcpOffloadSendCompleteHandler"),
    TEXT("TcpOffloadReceiveCompleteHandler"),
    TEXT("TcpOffloadDisconnectCompleteHandler"),
    TEXT("TcpOffloadForwardCompleteHandler"),
    TEXT("TcpOffloadEventHandler"),
    TEXT("TcpOffloadReceiveIndicateHandler"),

    TEXT("Ndis5WanSendHandler"),
    TEXT("ProtSendCompleteHandler"),
    TEXT("OidRequestCompleteHandler"),

    TEXT("DirectOidRequestCompleteHandler"),
    TEXT("DirectOidRequestHandler"),

    TEXT("AllocateSharedMemoryHandler"),
    TEXT("FreeSharedMemoryHandler"),

    TEXT("MiniportCoCreateVcHandler"),
    TEXT("MiniportCoRequestHandler"),
    TEXT("CoCreateVcHandler"),
    TEXT("CoDeleteVcHandler"),
    TEXT("CmActivateVcCompleteHandler"),
    TEXT("CmDeactivateVcCompleteHandler"),
    TEXT("CoRequestCompleteHandler"),
    TEXT("CoRequestHandler"),

    TEXT("MiniportCoOidRequestHandler"),
    TEXT("CoOidRequestCompleteHandler"),
    TEXT("CoOidRequestHandler")
};

static LPCWSTR g_lpszProtocolBlockHandlers[] = {
    TEXT("BindAdapterHandlerEx"),
    TEXT("UnbindAdapterHandlerEx"),
    TEXT("OpenAdapterCompleteHandlerEx"),
    TEXT("CloseAdapterCompleteHandlerEx"),
    TEXT("PnPEventHandler"),
    TEXT("UnloadHandler"),
    TEXT("UninstallHandler"),
    TEXT("RequestCompleteHandler"),
    TEXT("StatusHandler"),
    TEXT("StatusCompleteHandler"),
    TEXT("ReceiveNetBufferListsHandler"),
    TEXT("SendNetBufferListsCompleteHandler"),
    TEXT("CoStatusHandler"),
    TEXT("CoAfRegisterNotifyHandler"),
    TEXT("CoReceiveNetBufferListsHandler"),
    TEXT("CoSendNetBufferListsCompleteHandler"),
    TEXT("OpenAdapterCompleteHandler"),
    TEXT("CloseAdapterCompleteHandler"),
    TEXT("SendCompleteHandler"),
    TEXT("TransferDataCompleteHandler"),
    TEXT("ResetCompleteHandler"),
    TEXT("ReceiveHandler"),
    TEXT("ReceiveCompleteHandler"),
    TEXT("ReceivePacketHandler"),
    TEXT("BindAdapterHandler"),
    TEXT("UnbindAdapterHandler"),
    TEXT("CoSendCompleteHandler"),
    TEXT("CoReceivePacketHandler"),
    TEXT("OidRequestCompleteHandler"),
    TEXT("InitiateOffloadCompleteHandler"),
    TEXT("TerminateOffloadCompleteHandler"),
    TEXT("UpdateOffloadCompleteHandler"),
    TEXT("InvalidateOffloadCompleteHandler"),
    TEXT("QueryOffloadCompleteHandler"),
    TEXT("IndicateOffloadEventHandler"),
    TEXT("TcpOffloadSendCompleteHandler"),
    TEXT("TcpOffloadReceiveCompleteHandler"),
    TEXT("TcpOffloadDisconnectCompleteHandler"),
    TEXT("TcpOffloadForwardCompleteHandler"),
    TEXT("TcpOffloadEventHandler"),
    TEXT("TcpOffloadReceiveIndicateHandler"),
    TEXT("DirectOidRequestCompleteHandler"),
    TEXT("AllocateSharedMemoryHandler"),
    TEXT("FreeSharedMemoryHandler")
};

ULONG_PTR QueryProtocolList(VOID);

PVOID DumpUnicodeString(
    _In_ ULONG_PTR Address,
    _In_ WORD Length,
    _In_ WORD MaximumLength,
    _In_ BOOLEAN IsPtr);

ULONG GetNextProtocolOffset(
    _In_ ULONG WindowsVersion);

_Success_(return == TRUE)
BOOL ReadAndConvertProtocolBlock(
    _In_ ULONG_PTR ObjectAddress,
    _Inout_ NDIS_PROTOCOL_BLOCK_COMPATIBLE * ProtoBlock,
    _Out_opt_ PULONG ObjectVersion);

_Success_(return == TRUE)
BOOL ReadAndConvertOpenBlock(
    _In_ ULONG_PTR ObjectAddress,
    _Inout_ NDIS_OPEN_BLOCK_COMPATIBLE * OpenBlock,
    _Out_opt_ PULONG ObjectVersion);


```

`Source/Plugins/Sonar/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDI_ICON2                       104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/Plugins/Sonar/ui.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       UI.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  WinObjEx64 Sonar UI constants, definitions and includes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "uxtheme.lib")

#define SONAR_WNDTITLE TEXT("Sonar")

#define WINOBJEX64_ACC_TABLE        166
#define WINOBJEX64_ICON_MAIN        174
#define WINOBJEX64_ICON_SORT_UP     6001
#define WINOBJEX64_ICON_SORT_DOWN   6002
#define WINOBJEX64_ACC_F5           40003
#define WINOBJEX64_OBJECT_PROP      40004

#define ID_MENU_COPY_VALUE 41008

#define Y_SPLITTER_SIZE 4
#define Y_SPLITTER_MIN  100

typedef struct _SONARCONTEXT {
    //
    // GUI context variables.
    //
    HWND MainWindow;
    HWND ListView;
    HWND TreeList;
    HWND StatusBar;
    HACCEL AccTable;
    HIMAGELIST ImageList;
    LONG lvColumnToSort;
    LONG lvColumnCount;
    BOOL bInverseSort;

    HANDLE PluginHeap;
    HANDLE WorkerThread;

    INT SplitterPosY;
    INT CapturePosY;
    INT SplitterMaxY;

    INT LvItemHit;
    INT LvColumnHit;

    INT tlSubItemHit;

    UINT CurrentDPI;

    //
    // NDIS related.
    //
    ULONG_PTR ndisProtocolList;
    ULONG ndisNextProtocolOffset;
    
    //
    // WinObjEx64 data and pointers.
    //
    WINOBJEX_PARAM_BLOCK ParamBlock;
} SONARCONTEXT, *PSONARCONTEXT;

```

`Source/Plugins/plugin_def.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       PLUGIN_DEF.H
*
*  VERSION:     1.12
*
*  DATE:        14 Jun 2025
*
*  Common header file for the plugin subsystem definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define WOBJ_PLUGIN_SYSTEM_VERSION 25006

//
// Plugin ABI/capabilities version
//
#define WINOBJEX_PLUGIN_ABI_VERSION 0x0100

//
// Plugin text consts, must include terminating 0.
//
#define MAX_PLUGIN_NAME 32
#define MAX_AUTHORS_NAME 32
#define MAX_PLUGIN_DESCRIPTION 128

// Plugin run state

// Indicates that plugin is running or about to run
#define PLUGIN_RUNNING  0

// Indicates that plugin need to be stopped
#define PLUGIN_STOP     1

typedef BOOL(CALLBACK* pfnReadSystemMemoryEx)(
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

typedef UCHAR(CALLBACK* pfnGetInstructionLength)(
    _In_ PVOID ptrCode,
    _Out_ PULONG ptrFlags);

typedef NTSTATUS(*pfnOpenNamedObjectByType)(
    _Out_ HANDLE* ObjectHandle,
    _In_ ULONG TypeIndex,
    _In_ PUNICODE_STRING ObjectDirectory,
    _In_ PUNICODE_STRING ObjectName,
    _In_ ACCESS_MASK DesiredAccess);

typedef struct _WINOBJEX_PARAM_OBJECT {
    UNICODE_STRING Name;
    UNICODE_STRING Directory;
} WINOBJEX_PARAM_OBJECT, * PWINOBJEX_PARAM_OBJECT;

typedef struct _WINOBJEX_PARAM_BLOCK {
    ULONG cbSize; 
    HWND ParentWindow;
    HINSTANCE Instance;
    ULONG_PTR SystemRangeStart;
    UINT CurrentDPI;
    RTL_OSVERSIONINFOW Version;
    WINOBJEX_PARAM_OBJECT Object; // used only by Context plugins during StartPlugin callback

    //sys
    pfnReadSystemMemoryEx ReadSystemMemoryEx;
    pfnGetInstructionLength GetInstructionLength;
    pfnOpenNamedObjectByType OpenNamedObjectByType;

    ULONG Reserved[8];
} WINOBJEX_PARAM_BLOCK, * PWINOBJEX_PARAM_BLOCK;

typedef NTSTATUS(CALLBACK* pfnStartPlugin)(
    _In_ PWINOBJEX_PARAM_BLOCK ParamBlock);

typedef void(CALLBACK* pfnStopPlugin)(
    VOID);

typedef struct _WINOBJEX_PLUGIN WINOBJEX_PLUGIN;

typedef enum _WINOBJEX_PLUGIN_STATE {
    PluginInitialization = 0,
    PluginStopped = 1,
    PluginRunning = 2,
    PluginError = 3,
    MaxPluginState
} WINOBJEX_PLUGIN_STATE;

typedef enum _WINOBJEX_PLUGIN_TYPE {
    DefaultPlugin = 0, // General purpose plugin (shown in main menu under "Plugins")
    ContextPlugin = 1, // Object type specific plugin (shown in popup menu for specified object types)
    InvalidPluginType
} WINOBJEX_PLUGIN_TYPE;

typedef void(CALLBACK* pfnStateChangeCallback)(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ WINOBJEX_PLUGIN_STATE NewState,
    _Reserved_ PVOID Reserved);

typedef BOOL(CALLBACK* pfnGuiInitCallback)(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ HINSTANCE PluginInstance,
    _In_ WNDPROC WndProc,
    _Reserved_ PVOID Reserved
    );

typedef VOID(CALLBACK* pfnGuiShutdownCallback)(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ HINSTANCE PluginInstance,
    _Reserved_ PVOID Reserved
    );

//
// Object type indexes for known types, must be in compliance with WOBJ_OBJECT_TYPE values.
//

#define ObjectTypeDevice                        0
#define ObjectTypeDriver                        1
#define ObjectTypeSection                       2
#define ObjectTypePort                          3
#define ObjectTypeSymbolicLink                  4
#define ObjectTypeKey                           5
#define ObjectTypeEvent                         6
#define ObjectTypeJob                           7
#define ObjectTypeMutant                        8
#define ObjectTypeKeyedEvent                    9
#define ObjectTypeType                          10
#define ObjectTypeDirectory                     11
#define ObjectTypeWinstation                    12
#define ObjectTypeCallback                      13
#define ObjectTypeSemaphore                     14
#define ObjectTypeWaitablePort                  15
#define ObjectTypeTimer                         16
#define ObjectTypeSession                       17
#define ObjectTypeController                    18
#define ObjectTypeProfile                       19
#define ObjectTypeEventPair                     20
#define ObjectTypeDesktop                       21
#define ObjectTypeFile                          22
#define ObjectTypeWMIGuid                       23
#define ObjectTypeDebugObject                   24
#define ObjectTypeIoCompletion                  25
#define ObjectTypeProcess                       26
#define ObjectTypeAdapter                       27
#define ObjectTypeToken                         28
#define ObjectTypeETWRegistration               29
#define ObjectTypeThread                        30
#define ObjectTypeTmTx                          31
#define ObjectTypeTmTm                          32
#define ObjectTypeTmRm                          33
#define ObjectTypeTmEn                          34
#define ObjectTypePcwObject                     35
#define ObjectTypeFltConnPort                   36
#define ObjectTypeFltComnPort                   37
#define ObjectTypePowerRequest                  38
#define ObjectTypeETWConsumer                   39
#define ObjectTypeTpWorkerFactory               40
#define ObjectTypeComposition                   41
#define ObjectTypeIRTimer                       42
#define ObjectTypeDxgkSharedResource            43
#define ObjectTypeDxgkSharedSwapChain           44
#define ObjectTypeDxgkSharedSyncObject          45
#define ObjectTypeDxgkCurrentDxgProcessObject   46
#define ObjectTypeDxgkCurrentDxgThreadObject    47
#define ObjectTypeDxgkDisplayManager            48
#define ObjectTypeDxgkDisplayMuxSwitch          49
#define ObjectTypeDxgkSharedBundle              50
#define ObjectTypeDxgkSharedProtectedSession    51
#define ObjectTypeDxgkComposition               52
#define ObjectTypeDxgkSharedKeyedMutex          53
#define ObjectTypeMemoryPartition               54
#define ObjectTypeRegistryTransaction           55
#define ObjectTypeDmaAdapter                    56
#define ObjectTypeDmaDomain                     57
#define ObjectTypeCoverageSampler               58
#define ObjectTypeActivationObject              59
#define ObjectTypeActivityReference             60
#define ObjectTypeCoreMessaging                 61
#define ObjectTypeRawInputManager               62
#define ObjectTypeWaitCompletionPacket          63
#define ObjectTypeIoCompletionReserve           64
#define ObjectTypeUserApcReserve                65
#define ObjectTypeIoRing                        66
#define ObjectTypeTerminal                      67
#define ObjectTypeTerminalEventQueue            68
#define ObjectTypeEnergyTracker                 69
#define ObjectTypeUnknown                       70
#define ObjectTypeAnyType                       0xfe
#define ObjectTypeNone                          0xff

#define PLUGIN_MAX_SUPPORTED_OBJECT_ID 0xff

typedef struct _WINOBJEX_PLUGIN {
    ULONG cbSize;
    ULONG AbiVersion;
    union {
        ULONG Flags;
        struct {
            ULONG NeedAdmin : 1;
            ULONG NeedDriver : 1;
            ULONG SupportWine : 1;
            ULONG SupportMultipleInstances : 1;
            ULONG Reserved : 28;
        } u1;
    } Capabilities;
    WINOBJEX_PLUGIN_TYPE Type;
    WINOBJEX_PLUGIN_STATE State;
    WORD MajorVersion;
    WORD MinorVersion;
    ULONG RequiredPluginSystemVersion;
    UCHAR SupportedObjectsIds[PLUGIN_MAX_SUPPORTED_OBJECT_ID]; // Ignored if plugin Type is DefaultPlugin
    WCHAR Name[MAX_PLUGIN_NAME];
    WCHAR Authors[MAX_AUTHORS_NAME];
    WCHAR Description[MAX_PLUGIN_DESCRIPTION];
    pfnStartPlugin StartPlugin;
    pfnStopPlugin StopPlugin;
    pfnStateChangeCallback StateChangeCallback;
    pfnGuiInitCallback GuiInitCallback;
    pfnGuiShutdownCallback GuiShutdownCallback;

    ULONG Reserved[8];
} WINOBJEX_PLUGIN, * PWINOBJEX_PLUGIN;

```

`Source/Plugins/postbuild.cmd`:

```cmd
echo ----------------------------------------------
echo %1 post-build script
echo ----------------------------------------------

echo Copy %2 to Bin\Plugins
copy %2 ..\..\Bin\plugins /y

echo Copy %2 to WinObjEx64\Plugins [DEBUG]
copy %2 ..\..\WinObjEx64\plugins /y

IF EXIST %3 (
    Echo Copy %3 to WinObjEx64\Plugins [DEBUG]
    copy %3 ..\..\WinObjEx64\plugins /y 
 ) ELSE ( 
    echo %3 pdb file was not found, skipping
 )

```

`Source/Plugins/utils.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       UTILS.C
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Shared plugins runtime support functions and prototypes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "utils.h"

/*
* supSetWaitCursor
*
* Purpose:
*
* Sets cursor state.
*
*/
VOID supSetWaitCursor(
    _In_ BOOL fSet
)
{
    HCURSOR h = LoadCursor(NULL, fSet ? IDC_WAIT : IDC_ARROW);
    if (h) {
        SetCursor(h);
    }
}

/*
* supMapSection
*
* Purpose:
*
* Return pointer to section mapped view.
*
*/
NTSTATUS supMapSection(
    _In_ HANDLE SectionHandle,
    _Out_ PVOID* BaseAddress,
    _Out_ SIZE_T* ViewSize
)
{
    NTSTATUS ntStatus;
    SECTION_BASIC_INFORMATION sbi;
    SIZE_T bytesReturned;

    *BaseAddress = NULL;
    *ViewSize = 0;

    __try {

        //
        // Check if this is image mapped file.
        //
        ntStatus = NtQuerySection(SectionHandle,
            SectionBasicInformation,
            (PVOID)&sbi,
            sizeof(SECTION_BASIC_INFORMATION),
            &bytesReturned);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        if (!((sbi.AllocationAttributes & SEC_IMAGE) &&
            (sbi.AllocationAttributes & SEC_FILE)))
        {
            ntStatus = STATUS_NOT_SUPPORTED;
            __leave;
        }

        ntStatus = NtMapViewOfSection(SectionHandle,
            NtCurrentProcess(),
            BaseAddress,
            0,
            0,
            NULL,
            ViewSize,
            ViewUnmap,
            0,
            PAGE_READONLY);

    }
    __finally {
        if (AbnormalTermination())
            ntStatus = STATUS_ACCESS_VIOLATION;
    }

    return ntStatus;
}

/*
* supSaveDialogExecute
*
* Purpose:
*
* Display SaveDialog.
*
*/
BOOL supSaveDialogExecute(
    _In_ HWND OwnerWindow,
    _Inout_ LPWSTR SaveFileName,
    _In_ LPWSTR lpDialogFilter
)
{
    OPENFILENAME tag1;

    RtlSecureZeroMemory(&tag1, sizeof(OPENFILENAME));

    tag1.lStructSize = sizeof(OPENFILENAME);
    tag1.hwndOwner = OwnerWindow;
    tag1.lpstrFilter = lpDialogFilter;
    tag1.lpstrFile = SaveFileName;
    tag1.nMaxFile = MAX_PATH;
    tag1.lpstrInitialDir = NULL;
    tag1.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    return GetSaveFileName(&tag1);
}

size_t supxEscStrlen(wchar_t* s)
{
    size_t result, quoteCount;
    wchar_t* s0;

    if (s == NULL)
        return 0;

    s0 = s;
    result = 2;
    quoteCount = 0;

    while (*s) {
        if (*s == L'"')
            ++quoteCount;
        ++s;
    }

    return result + (s - s0) + quoteCount;
}

wchar_t* supxEscStrcpy(wchar_t* dst, wchar_t* src)
{
    if (dst == NULL || src == NULL)
        return dst;

    *(dst++) = L'"';

    while (*src != L'\0') {
        if (*src == L'"') {
            *(dst++) = L'"';
            *(dst++) = L'"';
            ++src;
        }
        else {
            *(dst++) = *src;
            ++src;
        }
    }

    *(dst++) = L'"';
    *dst = L'\0';

    return dst;
}

/*
* supxListViewExportCSV
*
* Purpose:
*
* Export listview entries into file in csv format.
*
*/
BOOL supxListViewExportCSV(
    _In_ HWND List,
    _In_ PWCHAR FileName)
{
    HWND hdr;
    int pass, i, c, col_count, icount;
    HDITEM ih;
    LVITEM lvi;
    PWCHAR text, buffer0, buffer;
    BOOL result;
    SIZE_T total_length, field_length;
    DWORD iobytes;
    HANDLE f;
    WORD bom;

    if (!List || !FileName)
        return FALSE;

    hdr = ListView_GetHeader(List);
    if (!hdr)
        return FALSE;

    col_count = Header_GetItemCount(hdr);
    if (col_count <= 0)
        return FALSE;

    icount = 1 + ListView_GetItemCount(List);

    text = (PWCHAR)ntsupVirtualAlloc(32768 * sizeof(WCHAR));
    if (!text)
        return FALSE;

    buffer0 = NULL;
    buffer = NULL;
    result = FALSE;

    RtlZeroMemory(&ih, sizeof(HDITEM));
    RtlZeroMemory(&lvi, sizeof(LVITEM));

    ih.pszText = lvi.pszText = text;
    ih.cchTextMax = lvi.cchTextMax = 32767;

    for (pass = 0; pass < 2; ++pass) {
        total_length = 0;

        for (i = 0; i < icount; ++i) {
            for (c = 0; c < col_count; ++c) {
                text[0] = L'\0';

                if (i == 0) {
                    ih.mask = HDI_TEXT | HDI_ORDER;
                    ih.iOrder = c;
                    Header_GetItem(hdr, c, &ih);
                }
                else {
                    lvi.mask = LVIF_TEXT;
                    lvi.iItem = i - 1;
                    lvi.iSubItem = c;
                    ListView_GetItem(List, &lvi);
                }

                field_length = supxEscStrlen(text);
                total_length += field_length;

                if (buffer) {
                    buffer = supxEscStrcpy(buffer, text);
                }

                if (c != col_count - 1) {
                    total_length += 1;
                    if (buffer) {
                        *(buffer++) = L',';
                    }
                }
                else {
                    total_length += 2;
                    if (buffer) {
                        *(buffer++) = L'\r';
                        *(buffer++) = L'\n';
                    }
                }
            }
        }

        if (buffer0 == NULL) {
            buffer0 = (PWCHAR)ntsupVirtualAlloc((1 + total_length) * sizeof(WCHAR));
            if (!buffer0)
                break;
            buffer = buffer0;
        }
        else {
            f = CreateFile(FileName,
                GENERIC_WRITE | SYNCHRONIZE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

            if (f != INVALID_HANDLE_VALUE) {
                bom = 0xFEFF;
                WriteFile(f, &bom, sizeof(WORD), &iobytes, NULL);
                WriteFile(f, buffer0, (DWORD)(total_length * sizeof(WCHAR)), &iobytes, NULL);
                CloseHandle(f);
                result = TRUE;
            }
            ntsupVirtualFree(buffer0);
            buffer0 = NULL;
        }
    }

    if (buffer0)
        ntsupVirtualFree(buffer0);

    ntsupVirtualFree(text);
    return result;
}

/*
* supListViewExportToFile
*
* Purpose:
*
* Export listview contents to the specified file.
*
*/
BOOL supListViewExportToFile(
    _In_ LPWSTR FileName,
    _In_ HWND WindowHandle,
    _In_ HWND ListView,
    _In_ LPWSTR FileFilter
)
{
    BOOL bResult = FALSE;
    WCHAR szExportFileName[MAX_PATH + 1];

    RtlSecureZeroMemory(&szExportFileName, sizeof(szExportFileName));

    _strcpy(szExportFileName, FileName);
    if (supSaveDialogExecute(WindowHandle,
        (LPWSTR)&szExportFileName,
        FileFilter))
    {
        SetCapture(WindowHandle);
        supSetWaitCursor(TRUE);

        bResult = supxListViewExportCSV(ListView, szExportFileName);

        supSetWaitCursor(FALSE);
        ReleaseCapture();
    }

    return bResult;
}

/*
* supStatusBarSetText
*
* Purpose:
*
* Display status in status bar part.
*
*/
VOID supStatusBarSetText(
    _In_ HWND hwndStatusBar,
    _In_ WPARAM partIndex,
    _In_ LPWSTR lpText
)
{
    SendMessage(hwndStatusBar, SB_SETTEXT, partIndex, (LPARAM)lpText);
}

/*
* supTreeListAddItem
*
* Purpose:
*
* Insert new treelist item.
*
*/
HTREEITEM supTreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems
)
{
    TVINSERTSTRUCT  tvitem;
    PTL_SUBITEMS    si = (PTL_SUBITEMS)subitems;

    RtlSecureZeroMemory(&tvitem, sizeof(tvitem));
    tvitem.hParent = hParent;
    tvitem.item.mask = mask;
    tvitem.item.state = state;
    tvitem.item.stateMask = stateMask;
    tvitem.item.pszText = pszText;
    tvitem.hInsertAfter = TVI_LAST;
    return TreeList_InsertTreeItem(TreeList, &tvitem, si);
}

/*
* supAddListViewColumn
*
* Purpose:
*
* Insert list view column.
*
*/
INT supAddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT ImageIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width,
    _In_ INT DpiValue
)
{
    LVCOLUMN column;

    column.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH | LVCF_ORDER | LVCF_IMAGE;
    column.fmt = Format;
    column.cx = ScaleDPI(Width, DpiValue);
    column.pszText = Text;
    column.iSubItem = SubItemIndex;
    column.iOrder = OrderIndex;
    column.iImage = ImageIndex;

    return ListView_InsertColumn(ListViewHwnd, ColumnIndex, &column);
}

/*
* supTreeListAddCopyValueItem
*
* Purpose:
*
* Add copy to clipboard menu item depending on hit treelist header item.
*
*/
BOOL supTreeListAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndTreeList,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ LPARAM lParam,
    _In_ INT* pSubItemHit
)
{
    HDHITTESTINFO hti;
    HD_ITEM hdItem;
    WCHAR szHeaderText[MAX_PATH + 1];
    WCHAR szItem[MAX_PATH * 2];

    *pSubItemHit = -1;

    hti.iItem = -1;
    hti.pt.x = LOWORD(lParam);
    hti.pt.y = HIWORD(lParam);
    ScreenToClient(hwndTreeList, &hti.pt);

    hti.pt.y = 1;
    if (TreeList_HeaderHittest(hwndTreeList, &hti) < 0)
        return FALSE;

    RtlSecureZeroMemory(&hdItem, sizeof(hdItem));

    szHeaderText[0] = 0;
    hdItem.mask = HDI_TEXT;

    hdItem.cchTextMax = RTL_NUMBER_OF(szHeaderText);

    hdItem.pszText = szHeaderText;
    if (TreeList_GetHeaderItem(hwndTreeList, hti.iItem, &hdItem)) {
        *pSubItemHit = hti.iItem;
        StringCchPrintf(szItem, RTL_NUMBER_OF(szItem), TEXT("Copy \"%ws\""), szHeaderText);
        if (InsertMenu(hMenu, uPos, MF_BYCOMMAND, uId, szItem)) {
            return TRUE;
        }
    }

    return FALSE;
}

/*
* supGetItemText
*
* Purpose:
*
* Returns buffer with text from the given listview item.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
LPWSTR supGetItemText(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _Out_opt_ PSIZE_T lpSize
)
{
    INT len;
    LPARAM sz = 0;
    LV_ITEM item;

    RtlSecureZeroMemory(&item, sizeof(item));

    item.iItem = nItem;
    item.iSubItem = nSubItem;
    len = 128;

    do {
        len *= 2;
        item.cchTextMax = len;
        if (item.pszText) {
            supHeapFree(item.pszText);
            item.pszText = NULL;
        }
        item.pszText = (LPWSTR)supHeapAlloc(len * sizeof(WCHAR));
        if (item.pszText == NULL)
            break;

        sz = SendMessage(ListView, LVM_GETITEMTEXT, (WPARAM)item.iItem, (LPARAM)&item);
    } while (sz == (LPARAM)len - 1);

    if (sz == 0) {
        if (item.pszText) {
            supHeapFree(item.pszText);
            item.pszText = NULL;
        }
    }

    if (lpSize) {
        *lpSize = sz * sizeof(WCHAR);
    }

    return item.pszText;
}

/*
* supGetItemText2
*
* Purpose:
*
* Returns text from the given listview item.
*
*/
LPWSTR supGetItemText2(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _In_ WCHAR* pszText,
    _In_ UINT cchText
)
{
    LV_ITEM item;

    RtlSecureZeroMemory(&item, sizeof(item));

    item.iItem = nItem;
    item.iSubItem = nSubItem;
    item.pszText = pszText;
    item.cchTextMax = (SIZE_T)cchText;
    SendMessage(ListView, LVM_GETITEMTEXT, (WPARAM)item.iItem, (LPARAM)&item);

    return item.pszText;
}

/*
* supClipboardCopy
*
* Purpose:
*
* Copy text to the clipboard.
*
*/
VOID supClipboardCopy(
    _In_ LPWSTR lpText,
    _In_ SIZE_T cbText
)
{
    LPWSTR  lptstrCopy;
    HGLOBAL hglbCopy = NULL;
    SIZE_T  dwSize;
    BOOL    dataSet = FALSE;

    if (!OpenClipboard(NULL))
        return;

    __try {
        EmptyClipboard();
        dwSize = cbText + sizeof(UNICODE_NULL);
        hglbCopy = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize);
        if (hglbCopy == NULL)
            __leave;

        lptstrCopy = (LPWSTR)GlobalLock(hglbCopy);
        if (lptstrCopy == NULL)
            __leave;

        RtlCopyMemory(lptstrCopy, lpText, cbText);
        GlobalUnlock(hglbCopy);

        dataSet = SetClipboardData(CF_UNICODETEXT, hglbCopy) != NULL;
        if (dataSet) {
            hglbCopy = NULL;
        }
    }
    __finally {
        CloseClipboard();
        if (hglbCopy != NULL) {
            GlobalFree(hglbCopy);
        }
    }
}

/*
* supListViewCopyItemValueToClipboard
*
* Purpose:
*
* Copy selected item text to the clipboard.
*
*/
BOOL supListViewCopyItemValueToClipboard(
    _In_ HWND hwndListView,
    _In_ INT iItem,
    _In_ INT iSubItem
)
{
    SIZE_T cbText;
    LPWSTR lpText;

    if ((iSubItem < 0) || (iItem < 0))
        return FALSE;

    lpText = supGetItemText(hwndListView,
        iItem,
        iSubItem,
        NULL);

    if (lpText) {
        cbText = _strlen(lpText) * sizeof(WCHAR);
        supClipboardCopy(lpText, cbText);
        supHeapFree(lpText);
        return TRUE;
    }
    else {
        if (OpenClipboard(NULL)) {
            EmptyClipboard();
            CloseClipboard();
        }
    }

    return FALSE;
}

/*
* supFreeDuplicatedUnicodeString
*
* Purpose:
*
* Release memory allocated for duplicated string.
*
*/
_Success_(return)
BOOL supFreeDuplicatedUnicodeString(
    _In_ HANDLE HeapHandle,
    _Inout_ PUNICODE_STRING DuplicatedString,
    _In_ BOOL DoZeroMemory
)
{
    BOOL bResult = FALSE;
    if (DuplicatedString->Buffer) {
        bResult = RtlFreeHeap(HeapHandle, 0, DuplicatedString->Buffer);
        if (DoZeroMemory) {
            DuplicatedString->Buffer = NULL;
            DuplicatedString->Length = DuplicatedString->MaximumLength = 0;
        }
    }
    return bResult;
}

/*
* supDuplicateUnicodeString
*
* Purpose:
*
* Duplicate existing UNICODE_STRING to another without RtlDuplicateUnicodeString.
*
* Note: Use supFreeDuplicatedUnicodeString to release allocated memory.
*
*/
_Success_(return)
BOOL supDuplicateUnicodeString(
    _In_ HANDLE HeapHandle,
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString
)
{
    USHORT maxLength = SourceString->MaximumLength;
    PWCHAR strBuffer;

    if (maxLength == 0 || maxLength < SourceString->Length)
        return FALSE;

    strBuffer = (PWCHAR)RtlAllocateHeap(HeapHandle, HEAP_ZERO_MEMORY, (SIZE_T)maxLength);
    if (strBuffer) {
        DestinationString->Buffer = strBuffer;
        DestinationString->MaximumLength = maxLength;
        RtlCopyUnicodeString(DestinationString, SourceString);
        return TRUE;
    }

    return FALSE;
}

//
// Conversion buffer size
//
#define CONVERT_NTNAME_BUFFER_SIZE 512

/*
* supConvertFileName
*
* Purpose:
*
* Translate Nt path name to Dos path name.
*
*/
BOOL supConvertFileName(
    _In_ LPWSTR NtFileName,
    _Inout_ LPWSTR DosFileName,
    _In_ SIZE_T ccDosFileName
)
{
    BOOL bFound = FALSE;

    SIZE_T nLen;

    WCHAR szDrive[3];
    WCHAR szName[MAX_PATH];
    WCHAR szTemp[CONVERT_NTNAME_BUFFER_SIZE];
    WCHAR* pszTemp;

    //
    // All input parameters are validated by caller before.
    //

    //
    // Drive template.
    //
    szDrive[0] = L'X';
    szDrive[1] = L':';
    szDrive[2] = 0;

    //
    // Query array of logical disk drive strings.
    //
    szTemp[0] = 0;
    if (GetLogicalDriveStrings(RTL_NUMBER_OF(szTemp), szTemp) == 0)
        return FALSE;

    pszTemp = szTemp;

    do {

        //
        // Copy the drive letter to the template string.
        //
        *szDrive = *pszTemp;
        szName[0] = 0;

        //
        // Lookup each device name.
        //
        if (QueryDosDevice(szDrive, szName, MAX_PATH)) {

            nLen = _strlen(szName);

            if (nLen < MAX_PATH) {

                //
                // Match device name.
                //
                bFound = ((_strncmpi(NtFileName, szName, nLen) == 0)
                    && *(NtFileName + nLen) == L'\\');

                if (bFound) {

                    //
                    // Build output name.
                    //
                    StringCchPrintf(
                        DosFileName,
                        ccDosFileName,
                        TEXT("%ws%ws"),
                        szDrive,
                        NtFileName + nLen);

                }

            }

        }

        //
        // Go to the next NULL character, i.e. the next drive name.
        //
        while (*pszTemp++);

    } while (!bFound && *pszTemp);

    return bFound;
}

/*
* supGetWin32FileName
*
* Purpose:
*
* Query filename by handle.
*
* Input buffer must be at least MAX_PATH length.
*
*/
BOOL supGetWin32FileName(
    _In_ LPWSTR FileName,
    _Inout_ LPWSTR Win32FileName,
    _In_ SIZE_T ccWin32FileName
)
{
    BOOL                bResult = FALSE;
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    HANDLE              hFile = NULL;
    UNICODE_STRING      NtFileName;
    OBJECT_ATTRIBUTES   obja;
    IO_STATUS_BLOCK     iost;
    ULONG               memIO;
    BYTE* Buffer = NULL;

    if ((Win32FileName == NULL) || (ccWin32FileName < MAX_PATH)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    do {

        RtlInitUnicodeString(&NtFileName, FileName);
        InitializeObjectAttributes(&obja, &NtFileName, OBJ_CASE_INSENSITIVE, 0, NULL);

        status = NtCreateFile(&hFile, SYNCHRONIZE, &obja, &iost, NULL, 0,
            FILE_SHARE_VALID_FLAGS, FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);

        if (!NT_SUCCESS(status))
            break;

        memIO = 0;
        status = NtQueryObject(hFile, ObjectNameInformation, NULL, 0, &memIO);
        if (status != STATUS_INFO_LENGTH_MISMATCH)
            break;

        Buffer = (BYTE*)supHeapAlloc(memIO);
        if (Buffer == NULL)
            break;

        status = NtQueryObject(hFile, ObjectNameInformation, Buffer, memIO, NULL);
        if (!NT_SUCCESS(status))
            break;

        if (!supConvertFileName(((PUNICODE_STRING)Buffer)->Buffer, Win32FileName, ccWin32FileName))
            break;

        bResult = TRUE;

    } while (FALSE);

    if (hFile)
        NtClose(hFile);

    if (Buffer != NULL)
        supHeapFree(Buffer);

    return bResult;
}

/*
* supGetMaxCompareTwoFixedStrings
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxCompareTwoFixedStrings(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL, FirstToCompare, SecondToCompare;
    WCHAR     szString1[MAX_PATH + 1], szString2[MAX_PATH + 1];

    szString1[0] = 0;

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szString1,
        MAX_PATH);

    szString2[0] = 0;

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szString2,
        MAX_PATH);

    if (Inverse) {
        FirstToCompare = lpItem2;
        SecondToCompare = lpItem1;
    }
    else {
        FirstToCompare = lpItem1;
        SecondToCompare = lpItem2;
    }

    nResult = _strcmpi(FirstToCompare, SecondToCompare);

    return nResult;
}

/*
* supGetMaxOfTwoU64FromHex
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxOfTwoU64FromHex(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL;
    ULONG_PTR ad1, ad2;
    WCHAR     szText[32];

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szText,
        RTL_NUMBER_OF(szText));

    ad1 = hextou64(&lpItem1[2]);

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szText,
        RTL_NUMBER_OF(szText));

    ad2 = hextou64(&lpItem2[2]);

    if (Inverse)
        nResult = ad1 < ad2;
    else
        nResult = ad1 > ad2;

    return nResult;
}

/*
* supTreeListCopyItemValueToClipboard
*
* Purpose:
*
* Copy selected treelist item text to the clipboard.
*
*/
BOOL supTreeListCopyItemValueToClipboard(
    _In_ HWND hwndTreeList,
    _In_ INT tlSubItemHit
)
{
    INT         nIndex;
    LPWSTR      lpCopyData = NULL;
    SIZE_T      cbCopyData = 0;
    TVITEMEX    itemex;
    WCHAR       szText[MAX_PATH + 1];

    TL_SUBITEMS_FIXED* pSubItems = NULL;

    szText[0] = 0;
    RtlSecureZeroMemory(&itemex, sizeof(itemex));
    itemex.mask = TVIF_TEXT;
    itemex.hItem = TreeList_GetSelection(hwndTreeList);
    itemex.pszText = szText;
    itemex.cchTextMax = MAX_PATH;

    if (TreeList_GetTreeItem(hwndTreeList, &itemex, &pSubItems)) {

        if ((tlSubItemHit > 0) && (pSubItems != NULL)) {

            nIndex = (tlSubItemHit - 1);
            if (nIndex < (INT)pSubItems->Count) {

                lpCopyData = pSubItems->Text[nIndex];
                cbCopyData = _strlen(lpCopyData) * sizeof(WCHAR);

            }

        }
        else {
            if (tlSubItemHit == 0) {
                lpCopyData = szText;
                cbCopyData = sizeof(szText); // copy everything
            }
        }

        if (lpCopyData && cbCopyData) {
            supClipboardCopy(lpCopyData, cbCopyData);
            return TRUE;
        }
        else {
            if (OpenClipboard(NULL)) {
                EmptyClipboard();
                CloseClipboard();
            }
        }
    }

    return FALSE;
}

/*
* supListViewAddCopyValueItem
*
* Purpose:
*
* Add copy to clipboard menu item depending on hit column.
*
*/
BOOL supListViewAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndLv,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ POINT * lpPoint,
    _Out_ INT * pItemHit,
    _Out_ INT * pColumnHit
)
{
    LVHITTESTINFO lvht;
    LVCOLUMN lvc;
    WCHAR szItem[MAX_PATH * 2];
    WCHAR szColumn[MAX_PATH + 1];

    *pColumnHit = -1;
    *pItemHit = -1;

    RtlSecureZeroMemory(&lvht, sizeof(lvht));
    lvht.pt.x = lpPoint->x;
    lvht.pt.y = lpPoint->y;
    ScreenToClient(hwndLv, &lvht.pt);
    if (ListView_SubItemHitTest(hwndLv, &lvht) == -1)
        return FALSE;

    RtlSecureZeroMemory(&lvc, sizeof(lvc));
    RtlSecureZeroMemory(&szColumn, sizeof(szColumn));

    lvc.mask = LVCF_TEXT;
    lvc.pszText = szColumn;
    lvc.cchTextMax = MAX_PATH;
    if (ListView_GetColumn(hwndLv, lvht.iSubItem, &lvc)) {
        _strcpy(szItem, TEXT("Copy \""));
        _strcat(szItem, szColumn);
        _strcat(szItem, TEXT("\""));
        if (InsertMenu(hMenu, uPos, MF_BYCOMMAND, uId, szItem)) {
            *pColumnHit = lvht.iSubItem;
            *pItemHit = lvht.iItem;
            return TRUE;
        }
    }

    return FALSE;
}

```

`Source/Plugins/utils.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       UTILS.H
*
*  VERSION:     1.20
*
*  DATE:        03 Oct 2025
*
*  Common header file for the plugin support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef PLUGIN_UTILS_H
#define PLUGIN_UTILS_H

#ifndef _WINDOWS_
#include <Windows.h>
#endif

#pragma warning(push)
#pragma warning(disable: 4005) //macro redefinition
#include <ntstatus.h>
#pragma warning(pop)

#include "ntos/ntos.h"
#include "ntos/ntsup.h"
#include <strsafe.h>

#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_

#include "minirtl/minirtl.h"
#include "tabs/tabsctrl.h"
#include "treelist/treelist.h"

#define supHeapAlloc ntsupHeapAlloc
#define supHeapFree ntsupHeapFree

#define DefaultSystemDpi            96
#define ScaleDPI(Value, CurrentDPI) MulDiv(Value, CurrentDPI, DefaultSystemDpi)

typedef struct _TL_SUBITEMS_FIXED {
    ULONG       Count;
    ULONG       ColorFlags;
    COLORREF    BgColor;
    COLORREF    FontColor;
    PVOID       UserParam;
    LPTSTR      CustomTooltip;
    LPTSTR      Text[2];
} TL_SUBITEMS_FIXED, * PTL_SUBITEMS_FIXED;

VOID supSetWaitCursor(
    _In_ BOOL fSet);

NTSTATUS supMapSection(
    _In_ HANDLE SectionHandle,
    _Out_ PVOID* BaseAddress,
    _Out_ SIZE_T* ViewSize);

BOOL supSaveDialogExecute(
    _In_ HWND OwnerWindow,
    _Inout_ LPWSTR SaveFileName,
    _In_ LPWSTR lpDialogFilter);

BOOL supListViewExportToFile(
    _In_ LPWSTR FileName,
    _In_ HWND WindowHandle,
    _In_ HWND ListView,
    _In_ LPWSTR FileFilter);

VOID supStatusBarSetText(
    _In_ HWND hwndStatusBar,
    _In_ WPARAM partIndex,
    _In_ LPWSTR lpText);

HTREEITEM supTreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems);

INT supAddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT ImageIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width,
    _In_ INT DpiValue);

BOOL supListViewAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndLv,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ POINT* lpPoint,
    _Out_ INT* pItemHit,
    _Out_ INT* pColumnHit);

LPWSTR supGetItemText(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _Out_opt_ PSIZE_T lpSize);

VOID supClipboardCopy(
    _In_ LPWSTR lpText,
    _In_ SIZE_T cbText);

BOOL supListViewCopyItemValueToClipboard(
    _In_ HWND hwndListView,
    _In_ INT iItem,
    _In_ INT iSubItem);

_Success_(return)
BOOL supFreeDuplicatedUnicodeString(
    _In_ HANDLE HeapHandle,
    _Inout_ PUNICODE_STRING DuplicatedString,
    _In_ BOOL DoZeroMemory);

_Success_(return)
BOOL supDuplicateUnicodeString(
    _In_ HANDLE HeapHandle,
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

BOOL supTreeListAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndTreeList,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ LPARAM lParam,
    _In_ INT * pSubItemHit);

BOOL supGetWin32FileName(
    _In_ LPWSTR FileName,
    _Inout_ LPWSTR Win32FileName,
    _In_ SIZE_T ccWin32FileName);

INT supGetMaxCompareTwoFixedStrings(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

INT supGetMaxOfTwoU64FromHex(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

BOOL supTreeListCopyItemValueToClipboard(
    _In_ HWND hwndTreeList,
    _In_ INT tlSubItemHit);

#endif /* PLUGIN_UTILS_H */

```

`Source/Shared/minirtl/_filename.c`:

```c
#include <Windows.h>
#include "minirtl.h"

char *_filename_a(const char *f)
{
	char *p = (char *)f;

	if (f == 0)
		return 0;

	while (*f != (char)0) {
		if (*f == '\\')
			p = (char *)f + 1;
		f++;
	}
	return p;
}

wchar_t *_filename_w(const wchar_t *f)
{
	wchar_t *p = (wchar_t *)f;

	if (f == 0)
		return 0;

	while (*f != (wchar_t)0) {
		if (*f == (wchar_t)'\\')
			p = (wchar_t *)f + 1;
		f++;
	}
	return p;
}

char *_fileext_a(const char *f)
{
	char *p = 0;

	if (f == 0)
		return 0;

	while (*f != (char)0) {
		if (*f == '.')
			p = (char *)f;
		f++;
	}

	if (p == 0)
		p = (char *)f;

	return p;
}

wchar_t *_fileext_w(const wchar_t *f)
{
	wchar_t *p = 0;

	if (f == 0)
		return 0;

	while (*f != (wchar_t)0) {
		if (*f == (wchar_t)'.')
			p = (wchar_t *)f;
		f++;
	}

	if (p == 0)
		p = (wchar_t *)f;

	return p;
}

char *_filename_noext_a(char *dest, const char *f)
{
    char *p, *l, *dot;

    if ((f == 0) || (dest == 0))
        return 0;

    p = _filename_a(f);
    if (p == 0)
        return 0;

    dot = _strend_a(p);
    if (dot == 0)
        return 0;

    l = p;

    while (*l != (char)0)
    {
        if (*l == '.')
            dot = l;
        l++;
    }

    while (p<dot)
    {
        *dest = *p;
        p++;
        dest++;
    }

    *dest = 0;
    return dest;
}

wchar_t *_filename_noext_w(wchar_t *dest, const wchar_t *f)
{
    wchar_t *p, *l, *dot;

    if ((f == 0) || (dest == 0))
        return 0;

    p = _filename_w(f);
    if (p == 0)
        return 0;

    dot = _strend_w(p);
    if (dot == 0)
        return 0;

    l = p;

    while (*l != (wchar_t)0)
    {
        if (*l == (wchar_t)'.')
            dot = l;
        l++;
    }

    while (p<dot)
    {
        *dest = *p;
        p++;
        dest++;
    }

    *dest = 0;
    return dest;
}

char *_filepath_a(const char *fname, char *fpath)
{
    char *p = (char *)fname, *p0 = (char*)fname, *p1 = (char*)fpath;

	if ((fname == 0) || (fpath == NULL)) 
		return 0;

	while (*fname != (char)0) {
		if (*fname == '\\')
			p = (char *)fname + 1;
		fname++;
	}

    while (p0 < p) {
        *p1 = *p0;
        p1++;
        p0++;
    }
    *p1 = 0;

	return fpath;
}

wchar_t *_filepath_w(const wchar_t *fname, wchar_t *fpath)
{
    wchar_t *p = (wchar_t *)fname, *p0 = (wchar_t*)fname, *p1 = (wchar_t*)fpath;

    if ((fname == 0) || (fpath == NULL))
        return 0;

    while (*fname != (wchar_t)0) {
        if (*fname == '\\')
            p = (wchar_t *)fname + 1;
        fname++;
    }

    while (p0 < p) {
        *p1 = *p0;
        p1++;
        p0++;
    }
    *p1 = 0;

    return fpath;
}

```

`Source/Shared/minirtl/_filename.h`:

```h
#pragma once

#ifndef _FILENAMEH_
#define _FILENAMEH_

char *_filename_a(const char *f);
wchar_t *_filename_w(const wchar_t *f);
char *_fileext_a(const char *f);
wchar_t *_fileext_w(const wchar_t *f);
char *_filename_noext_a(char *dest, const char *f);
wchar_t *_filename_noext_w(wchar_t *dest, const wchar_t *f);
char *_filepath_a(const char *fname, char *fpath);
wchar_t *_filepath_w(const wchar_t *fname, wchar_t *fpath);

#ifdef UNICODE
#define _filename  _filename_w
#define _fileext   _fileext_w
#define _filepath  _filepath_w
#define _filename_noext  _filename_noext_w
#else // ANSI
#define _filename  _filename_a
#define _fileext   _fileext_a
#define _filepath  _filepath_a
#define _filename_noext  _filename_noext_a
#endif

#endif /* _FILENAMEH_ */
```

`Source/Shared/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`Source/Shared/minirtl/_strchr.c`:

```c
#include "rtltypes.h"

char *_strchr_a(const char *s, const char ch)
{
    char *p = (char *)s;

    if (s == 0)
        return 0;

    while (*p != 0) {
        if (*p == ch)
            return p;
        p++;
    }

    return 0;
}

wchar_t *_strchr_w(const wchar_t *s, const wchar_t ch)
{
    wchar_t *p = (wchar_t *)s;

    if (s == 0)
        return 0;

    while (*p != 0) {
        if (*p == ch)
            return p;
        p++;
    }

    return 0;

}

```

`Source/Shared/minirtl/_strcmp.c`:

```c
#include "rtltypes.h"

int _strcmp_a(const char *s1, const char *s2)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmp_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t	c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strcmpi.c`:

```c
#include "rtltypes.h"

int _strcmpi_a(const char *s1, const char *s2)
{
	char c1, c2;
	
	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmpi_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`Source/Shared/minirtl/_strcpyn.c`:

```c
#include "rtltypes.h"

char *_strcpyn_a(char* dest, const char* src, size_t n)
{
    size_t i = 0;
    char *p;

    if ((dest == 0) || (src == 0))
        return dest;

    p = dest;

    while (i++ != n && (*p++ = *src++));

    *p = 0;

    return dest;
}

wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n)
{
    size_t i = 0;
    wchar_t *p;

    if ((dest == 0) || (src == 0))
        return dest;

    p = dest;

    while (i++ != n && (*p++ = *src++));

    *p = 0;

    return dest;
}

```

`Source/Shared/minirtl/_strend.c`:

```c
#include "rtltypes.h"

char *_strend_a(const char *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (char *)s;
}

wchar_t *_strend_w(const wchar_t *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (wchar_t *)s;
}

```

`Source/Shared/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`Source/Shared/minirtl/_strncmp.c`:

```c
#include "rtltypes.h"

int _strncmp_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strncmpi.c`:

```c
#include "rtltypes.h"

int _strncmpi_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strncpy.c`:

```c
#include "rtltypes.h"

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc)
{
	char *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc)
{
	wchar_t *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

```

`Source/Shared/minirtl/_strstr.c`:

```c
#include "rtltypes.h"

char *_strstr_a(const char *s, const char *sub_s)
{
	char c0, c1, c2, *tmps, *tmpsub;

	if (s == sub_s)
		return (char *)s;

	if (s == 0)
		return 0;

	if (sub_s == 0)
		return 0;

	c0 = *sub_s;
	while (c0 != 0) {

		while (*s != 0) {
			c2 = *s;
			if (c2 == c0)
				break;
			s++;
		}

		if (*s == 0)
			return 0;

		tmps = (char *)s;
		tmpsub = (char *)sub_s;
		do {
			c1 = *tmps;
			c2 = *tmpsub;
			tmps++;
			tmpsub++;
		} while ((c1 == c2) && (c2 != 0));

		if (c2 == 0)
			return (char *)s;

		s++;
	}
	return 0;
}

wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s)
{
	wchar_t c0, c1, c2, *tmps, *tmpsub;

	if (s == sub_s)
		return (wchar_t *)s;

	if (s == 0)
		return 0;

	if (sub_s == 0)
		return 0;

	c0 = *sub_s;
	while (c0 != 0) {

		while (*s != 0) {
			c2 = *s;
			if (c2 == c0)
				break;
			s++;
		}

		if (*s == 0)
			return 0;

		tmps = (wchar_t *)s;
		tmpsub = (wchar_t *)sub_s;
		do {
			c1 = *tmps;
			c2 = *tmpsub;
			tmps++;
			tmpsub++;
		} while ((c1 == c2) && (c2 != 0));

		if (c2 == 0)
			return (wchar_t *)s;

		s++;
	}
	return 0;
}

```

`Source/Shared/minirtl/_strstri.c`:

```c
#include "rtltypes.h"

char *_strstri_a(const char *s, const char *sub_s)
{
	char c0, c1, c2, *tmps, *tmpsub;

	if (s == sub_s)
		return (char *)s;

	if (s == 0)
		return 0;

	if (sub_s == 0)
		return 0;

	c0 = locase_a(*sub_s);
	while (c0 != 0) {

		while (*s != 0) {
			c2 = locase_a(*s);
			if (c2 == c0)
				break;
			s++;
		}

		if (*s == 0)
			return 0;

		tmps = (char *)s;
		tmpsub = (char *)sub_s;
		do {
			c1 = locase_a(*tmps);
			c2 = locase_a(*tmpsub);
			tmps++;
			tmpsub++;
		} while ((c1 == c2) && (c2 != 0));

		if (c2 == 0)
			return (char *)s;

		s++;
	}
	return 0;
}

wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s)
{
	wchar_t c0, c1, c2, *tmps, *tmpsub;

	if (s == sub_s)
		return (wchar_t *)s;

	if (s == 0)
		return 0;

	if (sub_s == 0)
		return 0;

	c0 = locase_w(*sub_s);
	while (c0 != 0) {

		while (*s != 0) {
			c2 = locase_w(*s);
			if (c2 == c0)
				break;
			s++;
		}

		if (*s == 0)
			return 0;

		tmps = (wchar_t *)s;
		tmpsub = (wchar_t *)sub_s;
		do {
			c1 = locase_w(*tmps);
			c2 = locase_w(*tmpsub);
			tmps++;
			tmpsub++;
		} while ((c1 == c2) && (c2 != 0));

		if (c2 == 0)
			return (wchar_t *)s;

		s++;
	}
	return 0;
}

```

`Source/Shared/minirtl/hextou64.c`:

```c
#include "rtltypes.h"

unsigned long long hextou64_a(char* s)
{
	unsigned long long	r = 0;
	char			c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = locase_a(*s);
		s++;
		if (_isdigit_a(c))
			r = 16 * r + (unsigned long int)c - (unsigned long int)'0';
		else
			if ((c >= 'a') && (c <= 'f'))
				r = 16 * r + (unsigned long int)c - (unsigned long int)'a' + 10;
			else
				break;
	}
	return r;
}

unsigned long long hextou64_w(wchar_t *s)
{
	unsigned long long	r = 0;
	wchar_t			c;

	if ( s==0 )
		return 0;

	while ( *s!=0 ) {
		c = locase_w(*s);
		s++;
		if (_isdigit_w(c))
			r = 16 * r + (unsigned long int)c - (unsigned long int)L'0';
		else
			if ((c >= L'a') && (c <= L'f'))
				r = 16 * r + (unsigned long int)c - (unsigned long int)L'a' + 10;
			else
				break;
	}
	return r;
}

```

`Source/Shared/minirtl/hextoul.c`:

```c
#include "rtltypes.h"

unsigned long hextoul_a(char *s)
{
	unsigned long	r = 0;
	char			c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = locase_a(*s);
		s++;
		if (_isdigit_a(c))
			r = 16 * r + (c - '0');
		else
			if ((c >= 'a') && (c <= 'f'))
				r = 16 * r + (c - 'a' + 10);
			else
				break;
	}
	return r;
}

unsigned long hextoul_w(wchar_t *s)
{
	unsigned long	r = 0;
	wchar_t			c;

	if ( s==0 )
		return 0;

	while ( *s!=0 ) {
		c = locase_w(*s);
		s++;
		if (_isdigit_w(c))
			r = 16*r + (c-L'0');
		else
			if ((c >= L'a') && (c <= L'f'))
				r = 16*r + (c-L'a'+10);
			else
				break;
	}
	return r;
}

```

`Source/Shared/minirtl/i64tostr.c`:

```c
#include "rtltypes.h"

size_t i64tostr_a(signed long long x, char *s)
{
	signed long long	t=x;
	size_t		i, r=1, sign;

	if (x < 0) {
		sign = 1;
		while (t <= -10) {
			t /= 10;
			r++;
		}
	}
	else {
		sign = 0;
		while (t >= 10) {
			t /= 10;
			r++;
		}
	}

	if (s == 0)
		return r + sign;

	if (sign) {
		*s = '-';
		s++;
	}

	for (i = r; i != 0; i--) {
		s[i - 1] = (char)byteabs(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r + sign;
}

size_t i64tostr_w(signed long long x, wchar_t *s)
{
	signed long long	t=x;
	size_t		i, r=1, sign;

	if (x < 0) {
		sign = 1;
		while (t <= -10) {
			t /= 10;
			r++;
		}
	} else {
		sign = 0;
		while (t >= 10) {
			t /= 10;
			r++;
		}
	}

	if (s == 0)
		return r+sign;
	
	if (sign) {
		*s = '-';
		s++;
	}

	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)byteabs(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r+sign;
}

```

`Source/Shared/minirtl/itostr.c`:

```c
#include "rtltypes.h"

size_t itostr_a(int x, char *s)
{
	int		t;
	size_t	i, r = 1, sign;

	t = x;

	if (x < 0) {
		sign = 1;
		while (t <= -10) {
			t /= 10;
			r++;
		}
	}
	else {
		sign = 0;
		while (t >= 10) {
			t /= 10;
			r++;
		}
	}

	if (s == 0)
		return r + sign;

	if (sign) {
		*s = '-';
		s++;
	}

	for (i = r; i != 0; i--) {
		s[i - 1] = (char)byteabs(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r + sign;
}


size_t itostr_w(int x, wchar_t *s)
{
	int		t;
	size_t	i, r = 1, sign;

	t = x;

	if (x < 0) {
		sign = 1;
		while (t <= -10) {
			t /= 10;
			r++;
		}
	}
	else {
		sign = 0;
		while (t >= 10) {
			t /= 10;
			r++;
		}
	}

	if (s == 0)
		return r + sign;

	if (sign) {
		*s = '-';
		s++;
	}

	for (i = r; i != 0; i--) {
		s[i - 1] = (wchar_t)byteabs(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r + sign;
}

```

`Source/Shared/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	4 Oct 2020
*/

#pragma once

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

char *_strcpyn_a(char* dest, const char* src, size_t n);
wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

char *_strchr_a(const char *s, const char ch);
wchar_t *_strchr_w(const wchar_t *s, const wchar_t ch);


// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w
#define _strcpyn _strcpyn_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w
#define _strchr _strchr_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define _strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcpyn _strcpyn_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a
#define _strchr _strchr_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define _strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`Source/Shared/minirtl/rtltypes.h`:

```h
#pragma once

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`Source/Shared/minirtl/strtoi.c`:

```c
#include "rtltypes.h"

int strtoi_a(char *s)
{
	int		a = 0, sign;
	char	c;

	if (s == 0)
		return 0;

	switch (*s) {
	case '-':
		s++;
		sign = -1;
		break;

	case '+':
		s++;
		sign = 1;
		break;

	default:
		sign = 1;
	}

	while (*s != 0) {
		c = *s;
		if (_isdigit_a(c))
			a = (a*10) + (c-'0');
		else
			break;
		s++;
	}
	return a*sign;
}

int strtoi_w(wchar_t *s)
{
	int			a = 0, sign;
	wchar_t		c;

	if (s == 0)
		return 0;

	switch (*s) {
	case L'-':
		s++;
		sign = -1;
		break;

	case L'+':
		s++;
		sign = 1;
		break;

	default:
		sign = 1;
	}

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+(c-L'0');
		else
			break;
		s++;
	}
	return a*sign;
}

```

`Source/Shared/minirtl/strtoi64.c`:

```c
#include "rtltypes.h"

signed long long strtoi64_a(char *s)
{
	signed long long	a = 0, sign;
	char	c;

	if (s == 0)
		return 0;

	switch (*s) {
	case '-':
		s++;
		sign = -1;
		break;

	case '+':
		s++;
		sign = 1;
		break;

	default:
		sign = 1;
	}

	while (*s != 0) {
		c = *s;
		if (_isdigit_a(c))
			a = (a*10) + ((signed long long)c-'0');
		else
			break;
		s++;
	}
	return a*sign;
}

signed long long strtoi64_w(wchar_t *s)
{
	signed long long	a = 0, sign;
	wchar_t		c;

	if (s == 0)
		return 0;

	switch (*s) {
	case L'-':
		s++;
		sign = -1;
		break;

	case L'+':
		s++;
		sign = 1;
		break;

	default:
		sign = 1;
	}

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+((signed long long)c-L'0');
		else
			break;
		s++;
	}
	return a*sign;
}

```

`Source/Shared/minirtl/strtou64.c`:

```c
#include "rtltypes.h"

unsigned long long strtou64_a(char *s)
{
	unsigned long long 	a = 0;
	char				c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_a(c))
			a = (a*10)+((unsigned long long)c-'0');
		else
			break;
		s++;
	}
	return a;
}

unsigned long long strtou64_w(wchar_t *s)
{
	unsigned long long 	a = 0;
	wchar_t				c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+((unsigned long long)c-L'0');
		else
			break;
		s++;
	}
	return a;
}

```

`Source/Shared/minirtl/strtoul.c`:

```c
#include "rtltypes.h"

unsigned long strtoul_a(char *s)
{
	unsigned long	a = 0;
	char			c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_a(c))
			a = (a*10)+(c-'0');
		else
			break;
		s++;
	}
	return a;
}

unsigned long strtoul_w(wchar_t *s)
{
	unsigned long	a = 0;
	wchar_t			c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+(c-L'0');
		else
			break;
		s++;
	}
	return a;
}

```

`Source/Shared/minirtl/u64tohex.c`:

```c
#include "rtltypes.h"

size_t u64tohex_a(unsigned long long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c=0; c<16; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

size_t u64tohex_w(unsigned long long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c = 0; c<16; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

```

`Source/Shared/minirtl/u64tostr.c`:

```c
#include "rtltypes.h"

size_t u64tostr_a(unsigned long long x, char *s)
{
	unsigned long long	t = x;
	size_t	i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (char)(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r;
}

size_t u64tostr_w(unsigned long long x, wchar_t *s)
{
	unsigned long long	t = x;
	size_t	i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r;
}

```

`Source/Shared/minirtl/ultohex.c`:

```c
#include "rtltypes.h"

size_t ultohex_a(unsigned long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

size_t ultohex_w(unsigned long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

```

`Source/Shared/minirtl/ultostr.c`:

```c
#include "rtltypes.h"

size_t ultostr_a(unsigned long x, char *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (char)(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r;
}

size_t ultostr_w(unsigned long x, wchar_t *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r;
}

```

`Source/Shared/ntos/apisetx.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2024, translated from Microsoft sources/debugger
*
*  TITLE:       APISETX.H
*
*  VERSION:     1.08
*
*  DATE:        16 Sep 2024
*
*  Common header file for the ApiSetSchema definitions.
*
*  Depends on:    ntos.h
*
*  Include:       ntos.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#pragma once

#ifndef APISETX
#define APISETX

//
// Copy-pasted from MS headers from the pre nerfed state.
//

#ifndef API_SET_SECTION_NAME
#define API_SET_SECTION_NAME            ".apiset"
#endif

#ifndef API_SET_SCHEMA_SUFFIX
#define API_SET_SCHEMA_SUFFIX           L".sys"
#endif

#define API_SET_PREFIX_API 0x2d004900500041 
#define API_SET_PREFIX_EXT 0x2d005400580045

#define API_SET_PREFIX_NAME_A           "API-"
#define API_SET_PREFIX_NAME_A_SIZE      (sizeof(API_SET_PREFIX_NAME_A) - sizeof(CHAR))
#define API_SET_PREFIX_NAME_U           TEXT(API_SET_PREFIX_NAME_A)
#define API_SET_PREFIX_NAME_U_SIZE      (sizeof(API_SET_PREFIX_NAME_U) - sizeof(WCHAR))
#define API_SET_PREFIX_NAME_LENGTH      (RTL_NUMBER_OF(API_SET_PREFIX_NAME_U) - 1)

#define API_SET_EXTENSION_NAME_A        "EXT-"
#define API_SET_EXTENSION_NAME_A_SIZE   (sizeof(API_SET_EXTENSION_NAME_A) - sizeof(CHAR))
#define API_SET_EXTENSION_NAME_U        TEXT(API_SET_EXTENSION_NAME_A)
#define API_SET_EXTENSION_NAME_U_SIZE   (sizeof(API_SET_EXTENSION_NAME_U) - sizeof(WCHAR))
#define API_SET_EXTENSION_NAME_LENGTH   (RTL_NUMBER_OF(API_SET_EXTENSION_NAME_U) - 1)

#define API_SET_SCHEMA_FLAGS_SEALED              0x00000001UL
#define API_SET_SCHEMA_FLAGS_HOST_EXTENSION      0x00000002UL

#define API_SET_SCHEMA_ENTRY_FLAGS_SEALED        0x00000001UL
#define API_SET_SCHEMA_ENTRY_FLAGS_EXTENSION     0x00000002UL

#ifndef API_SET_SCHEMA_VERSION_V2
#define API_SET_SCHEMA_VERSION_V2    2
#endif

#ifndef API_SET_SCHEMA_VERSION_V3
#define API_SET_SCHEMA_VERSION_V3    3  //private
#endif

#ifndef API_SET_SCHEMA_VERSION_V4
#define API_SET_SCHEMA_VERSION_V4    4
#endif

#ifndef API_SET_SCHEMA_VERSION_V6
#define API_SET_SCHEMA_VERSION_V6    6
#endif

#define API_SET_EMPTY_NAMESPACE_VALUE(ValueEntry) \
    ((ValueEntry->ValueOffset == 0) && (ValueEntry->ValueLength == 0) && \
    (ValueEntry->NameOffset == 0) && (ValueEntry->NameLength == 0))

#define API_SET_TO_UPPER_PREFIX(x) ((x) & 0xFFFFFFDFFFDFFFDFULL)

//
// Macro for APISET structures.
//
#define API_SET_TO_VALUE_ENTRY(Namespace, Entry, Index) \
    ((API_SET_VALUE_ENTRY_V6 *)RtlOffsetToPointer(Namespace, (Index) * sizeof(API_SET_VALUE_ENTRY_V6) + Entry->DataOffset))

#define API_SET_TO_VALUE_NAME(Namespace, Entry) \
    ((PWCHAR)RtlOffsetToPointer(Namespace, Entry->NameOffset))

#define API_SET_TO_HASH_ENTRY(Namespace, HashIndex) \
   ((API_SET_HASH_ENTRY_V6*)RtlOffsetToPointer(Namespace, Namespace->NamespaceHashesOffset + sizeof(ULONG64) * (HashIndex)))

#define API_SET_TO_NAMESPACE_ENTRY(Namespace, LookupHashEntry) \
   ((PAPI_SET_NAMESPACE_ENTRY_V6)RtlOffsetToPointer(Namespace, LookupHashEntry->NamespaceIndex * sizeof(API_SET_NAMESPACE_ENTRY_V6) + Namespace->NamespaceEntryOffset))

#define API_SET_TO_NAMESPACE_ENTRY_NAME(Namespace, NamespaceEntry) \
   ((PWCHAR)RtlOffsetToPointer(Namespace, NamespaceEntry->NameOffset))

// V2

typedef struct _API_SET_VALUE_ENTRY_V2 {
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY_V2, *PAPI_SET_VALUE_ENTRY_V2;

typedef struct _API_SET_VALUE_ARRAY_V2 {
    ULONG Count;
    API_SET_VALUE_ENTRY_V2 Array[ANYSIZE_ARRAY];
} API_SET_VALUE_ARRAY_V2, *PAPI_SET_VALUE_ARRAY_V2;

typedef struct _API_SET_NAMESPACE_ENTRY_V2 {
    ULONG NameOffset;
    ULONG NameLength;
    ULONG DataOffset;   // API_SET_VALUE_ARRAY
} API_SET_NAMESPACE_ENTRY_V2, *PAPI_SET_NAMESPACE_ENTRY_V2;

typedef struct _API_SET_NAMESPACE_ARRAY_V2 {
    ULONG Version;
    ULONG Count;
    _Field_size_full_(Count) API_SET_NAMESPACE_ENTRY_V2 Array[ANYSIZE_ARRAY];
} API_SET_NAMESPACE_ARRAY_V2, *PAPI_SET_NAMESPACE_ARRAY_V2;

// V4

typedef struct _API_SET_VALUE_ENTRY_V4 {
    ULONG Flags;
    ULONG NameOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG NameLength;
    ULONG ValueOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG ValueLength;
} API_SET_VALUE_ENTRY_V4, *PAPI_SET_VALUE_ENTRY_V4;

_Struct_size_bytes_(FIELD_OFFSET(API_SET_VALUE_ARRAY_V4, Array) + (sizeof(API_SET_VALUE_ENTRY_V4) * Count))
typedef struct _API_SET_VALUE_ARRAY_V4 {
    ULONG Flags;
    ULONG Count;
    _Field_size_full_(Count) API_SET_VALUE_ENTRY_V4 Array[ANYSIZE_ARRAY];
} API_SET_VALUE_ARRAY_V4, *PAPI_SET_VALUE_ARRAY_V4;

typedef struct _API_SET_NAMESPACE_ENTRY_V4 {
    ULONG Flags;
    ULONG NameOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG NameLength;
    ULONG AliasOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG AliasLength;
    ULONG DataOffset;   // API_SET_VALUE_ARRAY_V4
} API_SET_NAMESPACE_ENTRY_V4, *PAPI_SET_NAMESPACE_ENTRY_V4;

_Struct_size_bytes_(Size)
typedef struct _API_SET_NAMESPACE_ARRAY_V4 {
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    _Field_size_full_(Count) API_SET_NAMESPACE_ENTRY_V4 Array[ANYSIZE_ARRAY];
} API_SET_NAMESPACE_ARRAY_V4, *PAPI_SET_NAMESPACE_ARRAY_V4;

// V6

typedef struct _API_SET_HASH_ENTRY_V6 {
    ULONG Hash;
    ULONG NamespaceIndex;
} API_SET_HASH_ENTRY_V6, *PAPI_SET_HASH_ENTRY_V6;

typedef struct _API_SET_NAMESPACE_ENTRY_V6 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG HashNameLength; //size of name up to the last hyphen
    ULONG DataOffset;     //API_SET_VALUE_ENTRY_V6
    ULONG Count;          //number of API_SET_VALUE_ENTRY_V6 at DataOffset
} API_SET_NAMESPACE_ENTRY_V6, *PAPI_SET_NAMESPACE_ENTRY_V6;

typedef struct _API_SET_VALUE_ENTRY_V6 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY_V6, *PAPI_SET_VALUE_ENTRY_V6;

_Struct_size_bytes_(Size)
typedef struct _API_SET_NAMESPACE_ARRAY_V6 {
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    ULONG NamespaceEntryOffset;  //API_SET_NAMESPACE_ENTRY_V6
    ULONG NamespaceHashesOffset; //_API_SET_HASH_ENTRY_V6
    ULONG HashMultiplier;
} API_SET_NAMESPACE_ARRAY_V6, *PAPI_SET_NAMESPACE_ARRAY_V6;

typedef struct _API_SET_NAMESPACE {
    union {
        API_SET_NAMESPACE_ARRAY_V2 *v2;
        API_SET_NAMESPACE_ARRAY_V4 *v4;
        API_SET_NAMESPACE_ARRAY_V6 *v6;
    } Namespace;
} API_SET_NAMESPACE, *PAPI_SET_NAMESPACE;

#endif /* APISETX */

```

`Source/Shared/ntos/halamd64.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2020
*  Taken from publicly available Microsoft sources or mentioned elsewhere.
*
*  TITLE:       HALAMD64.H
*
*  VERSION:     1.11
*
*  DATE:        12 Feb 2020
*
*  Common header file for the ntos HAL AMD64 definitions.
*
*  Depends on:    Windows.h
*
*  Include:       Windows.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef HALAMD64_RTL
#define HALAMD64_RTL

#pragma warning(push)
#pragma warning(disable: 4214)

//
// HALAMD64_RTL HEADER BEGIN
//

#pragma pack(push,2)

typedef struct _FAR_JMP_16 {
    UCHAR  OpCode;  // = 0xe9
    USHORT Offset;
} FAR_JMP_16;

typedef struct _FAR_TARGET_32 {
    ULONG Offset;
    USHORT Selector;
} FAR_TARGET_32;

typedef struct _PSEUDO_DESCRIPTOR_32 {
    USHORT Limit;
    ULONG Base;
} PSEUDO_DESCRIPTOR_32;

#pragma pack(pop)

typedef union _KGDTENTRY64 {
    struct {
        USHORT  LimitLow;
        USHORT  BaseLow;
        union {
            struct {
                UCHAR   BaseMiddle;
                UCHAR   Flags1;
                UCHAR   Flags2;
                UCHAR   BaseHigh;
            } Bytes;

            struct {
                ULONG   BaseMiddle : 8;
                ULONG   Type : 5;
                ULONG   Dpl : 2;
                ULONG   Present : 1;
                ULONG   LimitHigh : 4;
                ULONG   System : 1;
                ULONG   LongMode : 1;
                ULONG   DefaultBig : 1;
                ULONG   Granularity : 1;
                ULONG   BaseHigh : 8;
            } Bits;
        };

        ULONG BaseUpper;
        ULONG MustBeZero;
    };

    ULONG64 Alignment;
} KGDTENTRY64, * PKGDTENTRY64;

typedef union _KIDTENTRY64 {
    struct {
        USHORT OffsetLow;
        USHORT Selector;
        USHORT IstIndex : 3;
        USHORT Reserved0 : 5;
        USHORT Type : 5;
        USHORT Dpl : 2;
        USHORT Present : 1;
        USHORT OffsetMiddle;
        ULONG OffsetHigh;
        ULONG Reserved1;
    };

    ULONG64 Alignment;
} KIDTENTRY64, * PKIDTENTRY64;

typedef union _KGDT_BASE {
    struct {
        USHORT BaseLow;
        UCHAR BaseMiddle;
        UCHAR BaseHigh;
        ULONG BaseUpper;
    };

    ULONG64 Base;
} KGDT_BASE, * PKGDT_BASE;

typedef union _KGDT_LIMIT {
    struct {
        USHORT LimitLow;
        USHORT LimitHigh : 4;
        USHORT MustBeZero : 12;
    };

    ULONG Limit;
} KGDT_LIMIT, * PKGDT_LIMIT;

#define PSB_GDT32_MAX       3

typedef struct _KDESCRIPTOR {
    USHORT Pad[3];
    USHORT Limit;
    PVOID Base;
} KDESCRIPTOR, * PKDESCRIPTOR;

typedef struct _KDESCRIPTOR32 {
    USHORT Pad[3];
    USHORT Limit;
    ULONG Base;
} KDESCRIPTOR32, * PKDESCRIPTOR32;

typedef struct _KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
    ULONG64 Cr8;
    ULONG64 MsrGsBase;
    ULONG64 MsrGsSwap;
    ULONG64 MsrStar;
    ULONG64 MsrLStar;
    ULONG64 MsrCStar;
    ULONG64 MsrSyscallMask;
} KSPECIAL_REGISTERS, * PKSPECIAL_REGISTERS;

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, * PKPROCESSOR_STATE;

typedef struct _PROCESSOR_START_BLOCK* PPROCESSOR_START_BLOCK;

typedef struct _PROCESSOR_START_BLOCK {

    //
    // The block starts with a jmp instruction to the end of the block
    //

    FAR_JMP_16 Jmp;

    //
    // Completion flag is set to non-zero when the target processor has
    // started
    //

    ULONG CompletionFlag;

    //
    // Pseudo descriptors for GDT and IDT.
    //

    PSEUDO_DESCRIPTOR_32 Gdt32;
    PSEUDO_DESCRIPTOR_32 Idt32;

    //
    // The temporary 32-bit GDT itself resides here.
    //

    KGDTENTRY64 Gdt[PSB_GDT32_MAX + 1];

    //
    // Physical address of the 64-bit top-level identity-mapped page table.
    //

    ULONG64 TiledCr3;

    //
    // Far jump target from Rm to Pm code
    //

    FAR_TARGET_32 PmTarget;

    //
    // Far jump target from Pm to Lm code
    //

    FAR_TARGET_32 LmIdentityTarget;

    //
    // Address of LmTarget
    //

    PVOID LmTarget;

    //
    // Linear address of this structure
    //

    PPROCESSOR_START_BLOCK SelfMap;

    //
    // Contents of the PAT msr
    //

    ULONG64 MsrPat;

    //
    // Contents of the EFER msr
    //

    ULONG64 MsrEFER;

    //
    // Initial processor state for the processor to be started
    //

    KPROCESSOR_STATE ProcessorState;

} PROCESSOR_START_BLOCK;

#pragma warning(pop)

//
// HALAMD64_RTL HEADER END
//

#endif HALAMD64_RTL

```

`Source/Shared/ntos/ntalpc.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2022, translated from Microsoft sources/debugger
*
*  TITLE:       NTALPC.H
*
*  VERSION:     1.95
*
*  DATE:        02 Feb 2022
*
*  Common header file for the ntos ALPC/CSR related functions and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef NTALPC_RTL
#define NTALPC_RTL

//
// NTALPC_RTL HEADER BEGIN
//

#if defined(__cplusplus)
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#define CSR_API_PORT_NAME               L"ApiPort"

#define WINSS_OBJECT_DIRECTORY_NAME     L"\\Windows"

#define CSRSRV_SERVERDLL_INDEX          0
#define CSRSRV_FIRST_API_NUMBER         0

#define BASESRV_SERVERDLL_INDEX         1
#define BASESRV_FIRST_API_NUMBER        0

#define CONSRV_SERVERDLL_INDEX          2
#define CONSRV_FIRST_API_NUMBER         512

#define USERSRV_SERVERDLL_INDEX         3
#define USERSRV_FIRST_API_NUMBER        1024

#define CSR_CSRSS_SECTION_SIZE          65536

#define ALPC_MSGFLG_REPLY_MESSAGE 0x1
#define ALPC_MSGFLG_LPC_MODE 0x2
#define ALPC_MSGFLG_RELEASE_MESSAGE 0x10000
#define ALPC_MSGFLG_SYNC_REQUEST 0x20000
#define ALPC_MSGFLG_WAIT_USER_MODE 0x100000
#define ALPC_MSGFLG_WAIT_ALERTABLE 0x200000
#define ALPC_MSGFLG_WOW64_CALL 0x80000000

typedef enum _ALPC_PORT_INFORMATION_CLASS {
    AlpcBasicInformation,
    AlpcPortInformation,
    AlpcAssociateCompletionPortInformation,
    AlpcConnectedSIDInformation,
    AlpcServerInformation,
    AlpcMessageZoneInformation,
    AlpcRegisterCompletionListInformation,
    AlpcUnregisterCompletionListInformation,
    AlpcAdjustCompletionListConcurrencyCountInformation,
    AlpcRegisterCallbackInformation,
    AlpcCompletionListRundownInformation,
    AlpcWaitForPortReferences,
    MaxAlpcInformation
} ALPC_PORT_INFORMATION_CLASS;

typedef struct _ALPC_SERVER_INFORMATION {
    union
    {
        struct
        {
            HANDLE ThreadHandle;
        } In;
        struct
        {
            BOOLEAN ThreadBlocked;
            HANDLE ConnectedProcessId;
            UNICODE_STRING ConnectionPortName;
        } Out;
    };
} ALPC_SERVER_INFORMATION, *PALPC_SERVER_INFORMATION;

typedef struct _ALPC_PORT_ATTRIBUTES {
    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SIZE_T MaxMessageLength;
    SIZE_T MemoryBandwidth;
    SIZE_T MaxPoolUsage;
    SIZE_T MaxSectionSize;
    SIZE_T MaxViewSize;
    SIZE_T MaxTotalSectionSize;
    ULONG DupObjectTypes;
#ifdef _WIN64
    ULONG Reserved;
#endif
} ALPC_PORT_ATTRIBUTES, *PALPC_PORT_ATTRIBUTES;

typedef struct _ALPC_MESSAGE_ATTRIBUTES {
    ULONG AllocatedAttributes;
    ULONG ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES, * PALPC_MESSAGE_ATTRIBUTES;

typedef struct _ALPC_BASIC_INFORMATION {
    ULONG Flags;
    ULONG SequenceNo;
    PVOID PortContext;
} ALPC_BASIC_INFORMATION, *PALPC_BASIC_INFORMATION;

typedef struct _ALPC_HANDLE_TABLE {
    struct _ALPC_HANDLE_ENTRY *Handles;
    ULONG TotalHandles;
    ULONG Flags;
    struct _EX_PUSH_LOCK Lock;
} ALPC_HADNLE_TABLE, *PALPC_HANDLE_TABLE;

// Windows 7 - Windows 8
typedef struct _ALPC_COMMUNICATION_INFO_V1 {
    struct _ALPC_PORT *ConnectionPort;
    struct _ALPC_PORT *ServerCommunicationPort;
    struct _ALPC_PORT *ClientCommunicationPort;
    struct _LIST_ENTRY CommunicationList;
    struct _ALPC_HANDLE_TABLE HandleTable;
} ALPC_COMMUNICATION_INFO_V1, *PALPC_COMMUNICATION_INFO_V1;

// Windows 8.1+
typedef struct _ALPC_COMMUNICATION_INFO_V2 {
    struct _ALPC_PORT *ConnectionPort;
    struct _ALPC_PORT *ServerCommunicationPort;
    struct _ALPC_PORT *ClientCommunicationPort;
    struct _LIST_ENTRY CommunicationList;
    struct _ALPC_HANDLE_TABLE HandleTable;
    struct _KALPC_MESSAGE *CloseMessage;
} ALPC_COMMUNICATION_INFO_V2, *PALPC_COMMUNICATION_INFO_V2;

//
// Compatible fields only structure.
//
typedef struct _ALPC_COMMUNICATION_INFO_COMPAT {
    struct _ALPC_PORT* ConnectionPort;
    struct _ALPC_PORT* ServerCommunicationPort;
    struct _ALPC_PORT* ClientCommunicationPort;
    struct _LIST_ENTRY CommunicationList;
    struct _ALPC_HANDLE_TABLE HandleTable;
} ALPC_COMMUNICATION_INFO_COMPAT, * PALPC_COMMUNICATION_INFO_COMPAT;

typedef union _ALPC_PORT_STATE {
    struct
    {
        unsigned long Initialized : 1;
        unsigned long Type : 2;
        unsigned long ConnectionPending : 1;
        unsigned long ConnectionRefused : 1;
        unsigned long Disconnected : 1;
        unsigned long Closed : 1;
        unsigned long NoFlushOnClose : 1;
        unsigned long ReturnExtendedInfo : 1;
        unsigned long Waitable : 1;
        unsigned long DynamicSecurity : 1;
        unsigned long Wow64CompletionList : 1;
        unsigned long Lpc : 1;
        unsigned long LpcToLpc : 1;
        unsigned long HasCompletionList : 1;
        unsigned long HadCompletionList : 1;
        unsigned long EnableCompletionList : 1;
    } s1;
    unsigned long State;
} ALPC_PORT_STATE, *PALPC_PORT_STATE;

//
// ALPC port object collection.
//
// Windows 7 ALPC port object.
//
typedef struct _ALPC_PORT_7600 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V1* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _LIST_ENTRY MainQueue;
    /* 0x0098 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00a8 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b8 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00c8 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00c8 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x00d0 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0118 */ struct _EX_PUSH_LOCK Lock;
    /* 0x0120 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0128 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0138 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0140 */ struct _ALPC_MESSAGE_ZONE* MessageZone;
    /* 0x0148 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0150 */ void* CallbackContext;
    /* 0x0158 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0168 */ volatile long SequenceNo;
    union
    {
        struct
        {
            unsigned long Initialized : 1; /* bit position: 0 */
            unsigned long Type : 2; /* bit position: 1 */
            unsigned long ConnectionPending : 1; /* bit position: 3 */
            unsigned long ConnectionRefused : 1; /* bit position: 4 */
            unsigned long Disconnected : 1; /* bit position: 5 */
            unsigned long Closed : 1; /* bit position: 6 */
            unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            unsigned long Waitable : 1; /* bit position: 9 */
            unsigned long DynamicSecurity : 1; /* bit position: 10 */
            unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            unsigned long Lpc : 1; /* bit position: 12 */
            unsigned long LpcToLpc : 1; /* bit position: 13 */
            unsigned long HasCompletionList : 1; /* bit position: 14 */
            unsigned long HadCompletionList : 1; /* bit position: 15 */
            unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x016c */ unsigned long State;
    } u1;
    /* 0x0170 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x0178 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x0180 */ struct _KALPC_MESSAGE* volatile CachedMessage;
    /* 0x0188 */ unsigned long MainQueueLength;
    /* 0x018c */ unsigned long PendingQueueLength;
    /* 0x0190 */ unsigned long LargeMessageQueueLength;
    /* 0x0194 */ unsigned long CanceledQueueLength;
    /* 0x0198 */ unsigned long WaitQueueLength;
    /* 0x019c */ long __PADDING__[1];
} ALPC_PORT_7600, *PALPC_PORT_7600; /* size: 0x01a0 */

//
// Windows 8 ALPC port object.
//
typedef struct _ALPC_PORT_9200 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V1* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _EX_PUSH_LOCK IncomingQueueLock;
    /* 0x0090 */ struct _LIST_ENTRY MainQueue;
    /* 0x00a0 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b0 */ struct _EX_PUSH_LOCK PendingQueueLock;
    /* 0x00b8 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00c8 */ struct _EX_PUSH_LOCK WaitQueueLock;
    /* 0x00d0 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00e0 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00e0 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x00e8 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0130 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0138 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0148 */ struct _EX_PUSH_LOCK PortObjectLock;
    /* 0x0150 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0158 */ struct _ALPC_MESSAGE_ZONE* MessageZone;
    /* 0x0160 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0168 */ void* CallbackContext;
    /* 0x0170 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0180 */ long SequenceNo;
    union
    {
        struct
        {
            unsigned long Initialized : 1; /* bit position: 0 */
            unsigned long Type : 2; /* bit position: 1 */
            unsigned long ConnectionPending : 1; /* bit position: 3 */
            unsigned long ConnectionRefused : 1; /* bit position: 4 */
            unsigned long Disconnected : 1; /* bit position: 5 */
            unsigned long Closed : 1; /* bit position: 6 */
            unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            unsigned long Waitable : 1; /* bit position: 9 */
            unsigned long DynamicSecurity : 1; /* bit position: 10 */
            unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            unsigned long Lpc : 1; /* bit position: 12 */
            unsigned long LpcToLpc : 1; /* bit position: 13 */
            unsigned long HasCompletionList : 1; /* bit position: 14 */
            unsigned long HadCompletionList : 1; /* bit position: 15 */
            unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x0184 */ unsigned long State;
    } u1;
    /* 0x0188 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x0190 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x0198 */ struct _KALPC_MESSAGE* CachedMessage;
    /* 0x01a0 */ unsigned long MainQueueLength;
    /* 0x01a4 */ unsigned long LargeMessageQueueLength;
    /* 0x01a8 */ unsigned long PendingQueueLength;
    /* 0x01ac */ unsigned long CanceledQueueLength;
    /* 0x01b0 */ unsigned long WaitQueueLength;
    /* 0x01b4 */ long __PADDING__[1];
} ALPC_PORT_9200, *PALPC_PORT_9200; /* size: 0x01b8 */

//
// Windows 8.1 ALPC port object.
//
typedef struct _ALPC_PORT_9600 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V2* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _EX_PUSH_LOCK IncomingQueueLock;
    /* 0x0090 */ struct _LIST_ENTRY MainQueue;
    /* 0x00a0 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b0 */ struct _EX_PUSH_LOCK PendingQueueLock;
    /* 0x00b8 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00c8 */ struct _EX_PUSH_LOCK WaitQueueLock;
    /* 0x00d0 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00e0 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00e0 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x00e8 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0130 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0138 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0148 */ struct _EX_PUSH_LOCK PortObjectLock;
    /* 0x0150 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0158 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0160 */ void* CallbackContext;
    /* 0x0168 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0178 */ long SequenceNo;
    /* 0x017c */ long ReferenceNo;
    /* 0x0180 */ struct _PALPC_PORT_REFERENCE_WAIT_BLOCK* ReferenceNoWait;
    union
    {
        struct
        {
            unsigned long Initialized : 1; /* bit position: 0 */
            unsigned long Type : 2; /* bit position: 1 */
            unsigned long ConnectionPending : 1; /* bit position: 3 */
            unsigned long ConnectionRefused : 1; /* bit position: 4 */
            unsigned long Disconnected : 1; /* bit position: 5 */
            unsigned long Closed : 1; /* bit position: 6 */
            unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            unsigned long Waitable : 1; /* bit position: 9 */
            unsigned long DynamicSecurity : 1; /* bit position: 10 */
            unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            unsigned long Lpc : 1; /* bit position: 12 */
            unsigned long LpcToLpc : 1; /* bit position: 13 */
            unsigned long HasCompletionList : 1; /* bit position: 14 */
            unsigned long HadCompletionList : 1; /* bit position: 15 */
            unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x0188 */ unsigned long State;
    } u1;
    /* 0x0190 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x0198 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x01a0 */ struct _KALPC_MESSAGE* CachedMessage;
    /* 0x01a8 */ unsigned long MainQueueLength;
    /* 0x01ac */ unsigned long LargeMessageQueueLength;
    /* 0x01b0 */ unsigned long PendingQueueLength;
    /* 0x01b4 */ unsigned long CanceledQueueLength;
    /* 0x01b8 */ unsigned long WaitQueueLength;
    /* 0x01bc */ long __PADDING__[1];
} ALPC_PORT_9600, *PALPC_PORT_9600; /* size: 0x01c0 */

//
// Windows 10 (10240 - 18290) ALPC port object.
//
typedef struct _ALPC_PORT_10240 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V2* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _EX_PUSH_LOCK IncomingQueueLock;
    /* 0x0090 */ struct _LIST_ENTRY MainQueue;
    /* 0x00a0 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b0 */ struct _EX_PUSH_LOCK PendingQueueLock;
    /* 0x00b8 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00c8 */ struct _EX_PUSH_LOCK DirectQueueLock;
    /* 0x00d0 */ struct _LIST_ENTRY DirectQueue;
    /* 0x00e0 */ struct _EX_PUSH_LOCK WaitQueueLock;
    /* 0x00e8 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00f8 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00f8 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x0100 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0148 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0150 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0160 */ struct _EX_PUSH_LOCK PortObjectLock;
    /* 0x0168 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0170 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0178 */ void* CallbackContext;
    /* 0x0180 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0190 */ long SequenceNo;
    /* 0x0194 */ long ReferenceNo;
    /* 0x0198 */ struct _PALPC_PORT_REFERENCE_WAIT_BLOCK* ReferenceNoWait;
    union
    {
        struct /* bitfield */
        {
            /* 0x01a0 */ unsigned long Initialized : 1; /* bit position: 0 */
            /* 0x01a0 */ unsigned long Type : 2; /* bit position: 1 */
            /* 0x01a0 */ unsigned long ConnectionPending : 1; /* bit position: 3 */
            /* 0x01a0 */ unsigned long ConnectionRefused : 1; /* bit position: 4 */
            /* 0x01a0 */ unsigned long Disconnected : 1; /* bit position: 5 */
            /* 0x01a0 */ unsigned long Closed : 1; /* bit position: 6 */
            /* 0x01a0 */ unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            /* 0x01a0 */ unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            /* 0x01a0 */ unsigned long Waitable : 1; /* bit position: 9 */
            /* 0x01a0 */ unsigned long DynamicSecurity : 1; /* bit position: 10 */
            /* 0x01a0 */ unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            /* 0x01a0 */ unsigned long Lpc : 1; /* bit position: 12 */
            /* 0x01a0 */ unsigned long LpcToLpc : 1; /* bit position: 13 */
            /* 0x01a0 */ unsigned long HasCompletionList : 1; /* bit position: 14 */
            /* 0x01a0 */ unsigned long HadCompletionList : 1; /* bit position: 15 */
            /* 0x01a0 */ unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x01a0 */ unsigned long State;
    } u1;
    /* 0x01a8 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x01b0 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x01b8 */ struct _KALPC_MESSAGE* CachedMessage;
    /* 0x01c0 */ unsigned long MainQueueLength;
    /* 0x01c4 */ unsigned long LargeMessageQueueLength;
    /* 0x01c8 */ unsigned long PendingQueueLength;
    /* 0x01cc */ unsigned long DirectQueueLength;
    /* 0x01d0 */ unsigned long CanceledQueueLength;
    /* 0x01d4 */ unsigned long WaitQueueLength;
} ALPC_PORT_10240, *PALPC_PORT_10240; /* size: 0x01d8 */

NTSYSAPI
NTSTATUS 
NTAPI 
NtAlpcCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes);

NTSYSAPI
NTSTATUS 
NTAPI 
NtAlpcDisconnectPort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS 
NTAPI 
NtAlpcQueryInformation(
    _In_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _Inout_updates_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAlpcAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ HANDLE ConnectionPortHandle,
    _In_ ULONG Flags,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_opt_ PVOID PortContext,
    _In_opt_ PPORT_MESSAGE ConnectionRequest,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes,
    _In_ BOOLEAN AcceptConnection);

NTSYSAPI
NTSTATUS
NTAPI
NtAlpcSendWaitReceivePort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_opt_ PPORT_MESSAGE pSendMessage,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,
    _Out_opt_ PPORT_MESSAGE pReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout);

//
// NTALPC_RTL HEADER END
//

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTALPC_RTL

```

`Source/Shared/ntos/ntbuilds.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2025
*
*  TITLE:       NTBUILDS.H
*
*  VERSION:     1.28
*
*  DATE:        18 Sep 2025
*
*  Windows NT builds definition file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Defines for Major Windows NT release builds
//

// Windows 7 RTM
#define NT_WIN7_RTM             7600

// Windows 7 SP1
#define NT_WIN7_SP1             7601

// Windows 8 RTM
#define NT_WIN8_RTM             9200

// Windows 8.1
#define NT_WIN8_BLUE            9600

// Windows 10 TH1
#define NT_WIN10_THRESHOLD1     10240

// Windows 10 TH2
#define NT_WIN10_THRESHOLD2     10586

// Windows 10 RS1
#define NT_WIN10_REDSTONE1      14393

// Windows 10 RS2
#define NT_WIN10_REDSTONE2      15063

// Windows 10 RS3
#define NT_WIN10_REDSTONE3      16299

// Windows 10 RS4
#define NT_WIN10_REDSTONE4      17134

// Windows 10 RS5
#define NT_WIN10_REDSTONE5      17763

// Windows 10 19H1
#define NT_WIN10_19H1           18362

// Windows 10 19H2
#define NT_WIN10_19H2           18363

// Windows 10 20H1
#define NT_WIN10_20H1           19041

// Windows 10 20H2
#define NT_WIN10_20H2           19042

// Windows 10 21H1
#define NT_WIN10_21H1           19043

// Windows 10 21H2
#define NT_WIN10_21H2           19044

// Windows 10 22H2
#define NT_WIN10_22H2           19045

// Windows Server 2022
#define NT_WINSRV_21H1          20348

// Windows 11 21H2
#define NT_WIN11_21H2           22000

// Windows 11 22H2
#define NT_WIN11_22H2           22621

// Windows 11 23H2
#define NT_WIN11_23H2           22631

// Windows 11 24H2
#define NT_WIN11_24H2           26100

// Windows 11 25H2
#define NT_WIN11_25H2           26200

// Windows 11 Active Development Branch
#define NT_WIN11_ADB            27943

```

`Source/Shared/ntos/ntldr.c`:

```c
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2025
*
*  TITLE:       NTLDR.C
*
*  VERSION:     1.24
*
*  DATE:        11 Jun 2025
*
*  NT loader raw parsing related code.
*
*  Depends on:    ntos.h
*                 apisetx.h
*                 minirtl
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#include "ntldr.h"

PFNNTLDR_EXCEPT_FILTER NtpLdrExceptionFilter = NULL;

INT NtLdrExceptionFilter(
    _In_ UINT ExceptionCode,
    _In_ EXCEPTION_POINTERS* ExceptionPointers);

#define NTLDR_EXCEPTION_FILTER NtLdrExceptionFilter(GetExceptionCode(), GetExceptionInformation())
#define SYSCALL_SIGNATURE 0xb8d18b4c // mov r10, rcx; mov eax


/*
* NtLdrExceptionFilter
*
* Purpose:
*
* Default exception filter with optional custom callback.
*
*/
INT NtLdrExceptionFilter(
    _In_ UINT ExceptionCode,
    _In_ EXCEPTION_POINTERS* ExceptionPointers
)
{
    if (NtpLdrExceptionFilter)
        return NtpLdrExceptionFilter(ExceptionCode, ExceptionPointers);

    return EXCEPTION_EXECUTE_HANDLER;
}

/*
* NtRawGetProcAddress
*
* Purpose:
*
* Custom GPA.
*
*/
NTSTATUS NtRawGetProcAddress(
    _In_ LPVOID Module,
    _In_ LPCSTR ProcName,
    _In_ PRESOLVE_INFO Pointer
)
{
    PIMAGE_NT_HEADERS ntHeaders;
    PIMAGE_EXPORT_DIRECTORY exp;
    PDWORD fntable, nametable;
    PWORD ordtable;
    ULONG mid, high, low, ordinal;
    ULONG_PTR fnptr, exprva, expsize;
    int r;

    if (Module == NULL)
        return STATUS_INVALID_PARAMETER_1;

    if (ProcName == NULL)
        return STATUS_INVALID_PARAMETER_2;

    if (Pointer == NULL)
        return STATUS_INVALID_PARAMETER_3;

    ntHeaders = RtlImageNtHeader(Module);
    if (ntHeaders == NULL)
        return STATUS_INVALID_IMAGE_FORMAT;

    if (ntHeaders->OptionalHeader.NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_EXPORT)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    exprva = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    if (exprva == 0)
        return STATUS_INVALID_IMAGE_FORMAT;

    expsize = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    exp = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)Module + exprva);
    fntable = (PDWORD)((ULONG_PTR)Module + exp->AddressOfFunctions);

    if ((ULONG_PTR)ProcName < 0x10000) {
        // ProcName is ordinal
        if (
            ((ULONG_PTR)ProcName < (ULONG_PTR)exp->Base) ||
            ((ULONG_PTR)ProcName >= (ULONG_PTR)exp->Base + exp->NumberOfFunctions))
            return STATUS_OBJECT_NAME_NOT_FOUND;

        ordinal = (ULONG)((ULONG_PTR)ProcName - exp->Base);
        if (ordinal >= exp->NumberOfFunctions)
            return STATUS_OBJECT_NAME_NOT_FOUND;

        fnptr = fntable[ordinal];

    }
    else {
        // ProcName is ANSI string
        nametable = (PDWORD)((ULONG_PTR)Module + exp->AddressOfNames);
        ordtable = (PWORD)((ULONG_PTR)Module + exp->AddressOfNameOrdinals);

        if (exp->NumberOfNames == 0)
            return STATUS_OBJECT_NAME_NOT_FOUND;

        low = 0;
        high = exp->NumberOfNames;

        do {
            mid = low + (high - low) / 2;
            r = _strcmp_a(ProcName, (LPCSTR)((ULONG_PTR)Module + nametable[mid]));

            if (r > 0)
            {
                low = mid + 1;
            }
            else
            {
                if (r < 0)
                    high = mid;
                else
                    break;
            }
        } while (low < high);

        if (r == 0) {
            if (ordtable[mid] >= exp->NumberOfFunctions)
                return STATUS_INVALID_IMAGE_FORMAT;

            fnptr = fntable[ordtable[mid]];
        }
        else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if ((fnptr >= exprva) && (fnptr < exprva + expsize))
        Pointer->ResultType = ForwarderString;
    else
        Pointer->ResultType = FunctionCode;

    Pointer->Function = (LPVOID)((ULONG_PTR)Module + fnptr);
    return STATUS_SUCCESS;
}

/*
* NtRawEnumSyscallExports
*
* Purpose:
*
* Enumerate syscall module exports to the table.
*
*/
_Success_(return != 0)
ULONG NtRawEnumSyscallExports(
    _In_ HANDLE HeapHandle,
    _In_ LPVOID Module,
    _Out_ PRAW_SYSCALL_ENTRY * SyscallTable
)
{
    PIMAGE_EXPORT_DIRECTORY pExportDirectory;
    PDWORD FnPtrTable, NameTable;
    PWORD NameOrdTable;
    ULONG_PTR fnptr;
    ULONG i, j, result, exportSize;
    PRAW_SYSCALL_ENTRY newEntry;

    pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
        Module,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &exportSize);

    if (pExportDirectory == NULL)
        return 0;

    FnPtrTable = (PDWORD)((ULONG_PTR)Module + pExportDirectory->AddressOfFunctions);
    NameTable = (PDWORD)((ULONG_PTR)Module + pExportDirectory->AddressOfNames);
    NameOrdTable = (PWORD)((ULONG_PTR)Module + pExportDirectory->AddressOfNameOrdinals);

    result = 0;

    for (i = 0; i < pExportDirectory->NumberOfFunctions; ++i) {

        if (FnPtrTable[i] == 0)
            continue;

        fnptr = (ULONG_PTR)Module + FnPtrTable[i];
        if (*(PDWORD)fnptr != SYSCALL_SIGNATURE)
            continue;

        newEntry = (PRAW_SYSCALL_ENTRY)RtlAllocateHeap(HeapHandle,
            HEAP_ZERO_MEMORY, sizeof(RAW_SYSCALL_ENTRY));

        if (newEntry == NULL)
            break;

        newEntry->Index = *(PDWORD)(fnptr + 4);

        for (j = 0; j < pExportDirectory->NumberOfNames; ++j)
        {
            if (NameOrdTable[j] >= pExportDirectory->NumberOfFunctions)
                continue;

            if (NameOrdTable[j] == i)
            {
                _strncpy_a(&newEntry->Name[0],
                    sizeof(newEntry->Name),
                    (LPCSTR)((ULONG_PTR)Module + NameTable[j]),
                    sizeof(newEntry->Name));

                break;
            }
        }

        ++result;

        *SyscallTable = newEntry;
        SyscallTable = &newEntry->NextEntry;
    }

    return result;
}

/*
* NtRawIATEntryToImport
*
* Purpose:
*
* Resolve function name.
*
*/
_Success_(return != NULL)
LPCSTR NtRawIATEntryToImport(
    _In_ LPVOID Module,
    _In_ LPVOID IATEntry,
    _Out_opt_ LPCSTR * ImportModuleName
)
{
    PIMAGE_IMPORT_DESCRIPTOR pImageImportDescriptor;
    ULONG_PTR* rname;
    ULONG size;
    LPVOID* raddr;
    PIMAGE_IMPORT_BY_NAME importByName;

    if (ImportModuleName)
        *ImportModuleName = NULL;

    pImageImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
        Module,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &size);

    if (pImageImportDescriptor == NULL)
        return 0;

    while (pImageImportDescriptor->Name != 0) {
        raddr = (LPVOID*)((ULONG_PTR)Module + pImageImportDescriptor->FirstThunk);
        if (pImageImportDescriptor->OriginalFirstThunk == 0)
            rname = (ULONG_PTR*)raddr;
        else
            rname = (ULONG_PTR*)((ULONG_PTR)Module + pImageImportDescriptor->OriginalFirstThunk);

        while (*rname != 0) {
            if (IATEntry == raddr)
            {
                if (((*rname) & IMAGE_ORDINAL_FLAG) == 0)
                {
                    importByName = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)Module + *rname);

                    if (ImportModuleName) {
                        *ImportModuleName = (LPCSTR)((ULONG_PTR)Module + pImageImportDescriptor->Name);
                    }
                    return (LPCSTR)&importByName->Name[0];
                }
            }

            ++rname;
            ++raddr;
        }
        ++pImageImportDescriptor;
    }

    return NULL;
}

/*
* ApiSetpSearchForApiSetHost
*
* Purpose:
*
* Resolve alias name if present.
* Directly ripped from ntdll!ApiSetpSearchForApiSetHost.
*
*/
PAPI_SET_VALUE_ENTRY_V6 ApiSetpSearchForApiSetHost(
    _In_ PAPI_SET_NAMESPACE_ENTRY_V6 Entry,
    _In_ PWCHAR ApiSetToResolve,
    _In_ USHORT ApiSetToResolveLength,
    _In_ PVOID Namespace)
{
    API_SET_VALUE_ENTRY_V6* ValueEntry;
    API_SET_VALUE_ENTRY_V6* AliasValueEntry, * Result = NULL;
    ULONG AliasCount, i, AliasIndex;
    PWCHAR AliasName;
    LONG CompareResult;

    ValueEntry = API_SET_TO_VALUE_ENTRY(Namespace, Entry, 0);
    AliasCount = Entry->Count;

    if (AliasCount >= 1) {

        i = 1;

        do {
            AliasIndex = (AliasCount + i) >> 1;
            AliasValueEntry = API_SET_TO_VALUE_ENTRY(Namespace, Entry, AliasIndex);
            AliasName = API_SET_TO_VALUE_NAME(Namespace, AliasValueEntry);

            CompareResult = RtlCompareUnicodeStrings(
                ApiSetToResolve,
                ApiSetToResolveLength,
                AliasName,
                AliasValueEntry->NameLength >> 1,
                TRUE);

            if (CompareResult < 0) {
                AliasCount = AliasIndex - 1;
            }
            else {
                if (CompareResult == 0) {

                    Result = API_SET_TO_VALUE_ENTRY(Namespace,
                        Entry,
                        ((AliasCount + i) >> 1));

                    break;
                }
                i = (AliasCount + 1);
            }

        } while (i <= AliasCount);

    }
    else {
        Result = ValueEntry;
    }

    return Result;
}

/*
* ApiSetpSearchForApiSet
*
* Purpose:
*
* Find apiset entry by hash from it name.
*
*/
PAPI_SET_NAMESPACE_ENTRY_V6 ApiSetpSearchForApiSet(
    _In_ PVOID Namespace,
    _In_ PWCHAR ResolveName,
    _In_ USHORT ResolveNameEffectiveLength)
{
    ULONG LookupHash = 0, i, c, HashIndex, EntryCount, EntryHash;
    WCHAR ch;

    PWCHAR NamespaceEntryName;
    API_SET_HASH_ENTRY_V6* LookupHashEntry;
    PAPI_SET_NAMESPACE_ENTRY_V6 NamespaceEntry = NULL;
    PAPI_SET_NAMESPACE_ARRAY_V6 ApiSetNamespace = (PAPI_SET_NAMESPACE_ARRAY_V6)Namespace;

    if ((ApiSetNamespace->Count == 0) || (ResolveNameEffectiveLength == 0))
        return NULL;

    //
    // Calculate lookup hash.
    //
    for (i = 0; i < ResolveNameEffectiveLength; i++) {
        ch = locase_w(ResolveName[i]);
        LookupHash = LookupHash * ApiSetNamespace->HashMultiplier + ch;
    }

    //
    // Search for hash.
    //
    c = 0;
    EntryCount = ApiSetNamespace->Count - 1;

    do {
        HashIndex = (EntryCount + c) >> 1;
        LookupHashEntry = API_SET_TO_HASH_ENTRY(ApiSetNamespace, HashIndex);
        EntryHash = LookupHashEntry->Hash;

        if (LookupHash < EntryHash) {
            EntryCount = HashIndex - 1;
            if (c > EntryCount)
                return NULL;
            continue;
        }

        if (EntryHash == LookupHash) {
            // Hash found, query namespace entry and break.
            NamespaceEntry = API_SET_TO_NAMESPACE_ENTRY(ApiSetNamespace, LookupHashEntry);
            break;
        }

        c = HashIndex + 1;

        if (c > EntryCount)
            return NULL;

    } while (1);

    if (NamespaceEntry == NULL)
        return NULL;

    //
    // Verify entry name.
    //
    NamespaceEntryName = API_SET_TO_NAMESPACE_ENTRY_NAME(ApiSetNamespace, NamespaceEntry);

    if (0 == RtlCompareUnicodeStrings(
        ResolveName,
        ResolveNameEffectiveLength,
        NamespaceEntryName,
        (NamespaceEntry->HashNameLength >> 1),
        TRUE))
    {
        return NamespaceEntry;
    }

    return NULL;
}

/*
* NtRawApiSetResolveLibrary
*
* Purpose:
*
* Resolve apiset library name.
*
*/
NTSTATUS NtRawApiSetResolveLibrary(
    _In_ PVOID Namespace,
    _In_ PCUNICODE_STRING ApiSetToResolve,
    _In_opt_ PCUNICODE_STRING ApiSetParentName,
    _Inout_ PUNICODE_STRING ResolvedHostLibraryName
)
{
    NTSTATUS Status = STATUS_APISET_NOT_PRESENT;
    PWCHAR BufferPtr;
    USHORT Length;
    ULONG64 SchemaPrefix;
    API_SET_NAMESPACE_ENTRY_V6* ResolvedEntry;
    API_SET_VALUE_ENTRY_V6* HostLibraryEntry = NULL;
    PAPI_SET_NAMESPACE_ARRAY_V6 ApiSetNamespace = (PAPI_SET_NAMESPACE_ARRAY_V6)Namespace;

    __try {

        //
        // Only Win10+ version supported.
        //
        if (ApiSetNamespace->Version != API_SET_SCHEMA_VERSION_V6)
            return STATUS_UNKNOWN_REVISION;

        //
        // Must include something except prefix.
        //
        if (ApiSetToResolve->Length <= API_SET_PREFIX_NAME_U_SIZE)
            return STATUS_INVALID_PARAMETER_2;

        //
        // Check prefix.
        //
        SchemaPrefix = API_SET_TO_UPPER_PREFIX(((ULONG64*)ApiSetToResolve->Buffer)[0]);
        if ((SchemaPrefix != API_SET_PREFIX_API) && (SchemaPrefix != API_SET_PREFIX_EXT)) //API- or EXT- only
            return STATUS_INVALID_PARAMETER;

        //
        // Calculate length without everything after last hyphen including dll suffix.
        //
        BufferPtr = (PWCHAR)RtlOffsetToPointer(ApiSetToResolve->Buffer, ApiSetToResolve->Length);
        Length = ApiSetToResolve->Length;

        do {
            if (Length <= 1)
                break;

            Length -= sizeof(WCHAR);
            --BufferPtr;

        } while (*BufferPtr != L'-');

        Length = (USHORT)Length >> 1;

        //
        // Resolve apiset entry.
        //
        ResolvedEntry = ApiSetpSearchForApiSet(
            Namespace,
            ApiSetToResolve->Buffer,
            Length);

        if (ResolvedEntry == NULL)
            return STATUS_INVALID_PARAMETER;

        //
        // If parent name specified and resolved entry has more than 1 value entry check it out.
        //
        if (ApiSetParentName && ResolvedEntry->Count > 1) {

            HostLibraryEntry = ApiSetpSearchForApiSetHost(ResolvedEntry,
                ApiSetParentName->Buffer,
                ApiSetParentName->Length >> 1,
                Namespace);

        }
        else {

            //
            // If resolved apiset entry has value check it out.
            //
            if (ResolvedEntry->Count > 0) {
                HostLibraryEntry = API_SET_TO_VALUE_ENTRY(Namespace, ResolvedEntry, 0);
            }
        }

        //
        // Set output parameter if host library resolved.
        //
        if (HostLibraryEntry) {
            if (!API_SET_EMPTY_NAMESPACE_VALUE(HostLibraryEntry)) {

                //
                // Host library name is not null terminated, handle that.
                //
                BufferPtr = (PWSTR)RtlAllocateHeap(
                    NtCurrentPeb()->ProcessHeap,
                    HEAP_ZERO_MEMORY,
                    HostLibraryEntry->ValueLength + sizeof(UNICODE_NULL));

                if (BufferPtr) {

                    RtlCopyMemory(BufferPtr,
                        (PWSTR)RtlOffsetToPointer(Namespace, HostLibraryEntry->ValueOffset),
                        (SIZE_T)HostLibraryEntry->ValueLength);

                    ResolvedHostLibraryName->Length = (USHORT)HostLibraryEntry->ValueLength;
                    ResolvedHostLibraryName->MaximumLength = (USHORT)HostLibraryEntry->ValueLength;
                    ResolvedHostLibraryName->Buffer = BufferPtr;
                    Status = STATUS_SUCCESS;
                }
                else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }
    }
    __except (NTLDR_EXCEPTION_FILTER)
    {
        return GetExceptionCode();
    }

    return Status;
}

```

`Source/Shared/ntos/ntldr.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2023
*
*  TITLE:       NTLDR.H
*
*  VERSION:     1.22
*
*  DATE:        25 Jul 2023
*
*  Common header file for the NTLDR definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef NTLDR_RTL
#define NTLDR_RTL

#pragma warning(push)
#pragma warning(disable: 4201) // nameless struct/union

#include <Windows.h>

#pragma warning(push)
#pragma warning(disable: 4005) //macro redefinition
#include <ntstatus.h>
#pragma warning(pop)

#include "ntos.h"
#include "apisetx.h"
#include "minirtl/minirtl.h"
#include "minirtl/rtltypes.h"

typedef INT(*PFNNTLDR_EXCEPT_FILTER)(
    _In_ UINT ExceptionCode,
    _In_ EXCEPTION_POINTERS* ExceptionPointers);

extern PFNNTLDR_EXCEPT_FILTER NtpLdrExceptionFilter;

//
// 
//  W32pServiceTable query related structures and definitions.
//
//

typedef enum _RESOLVE_POINTER_TYPE {
    ForwarderString = 0,
    FunctionCode = 1
} RESOLVE_POINTER_TYPE;

typedef struct _RESOLVE_INFO {
    RESOLVE_POINTER_TYPE ResultType;
    union {
        LPCSTR ForwarderName;
        LPVOID Function;
    };
} RESOLVE_INFO, *PRESOLVE_INFO;

typedef struct _RAW_SYSCALL_ENTRY {
    ULONG Index;
    CHAR Name[256];
    ULONG_PTR KernelStubAddress;
    ULONG_PTR KernelStubTargetAddress;
    struct _RAW_SYSCALL_ENTRY* NextEntry;
} RAW_SYSCALL_ENTRY, *PRAW_SYSCALL_ENTRY;

_Success_(return != NULL)
LPCSTR NtRawIATEntryToImport(
    _In_ LPVOID Module,
    _In_ LPVOID IATEntry,
    _Out_opt_ LPCSTR *ImportModuleName);

_Success_(return != 0)
ULONG NtRawEnumSyscallExports(
    _In_ HANDLE HeapHandle,
    _In_ LPVOID Module,
    _Out_ PRAW_SYSCALL_ENTRY* SyscallTable);

NTSTATUS NtRawGetProcAddress(
    _In_ LPVOID Module,
    _In_ LPCSTR ProcName,
    _In_ PRESOLVE_INFO Pointer);

NTSTATUS NtRawApiSetResolveLibrary(
    _In_ PVOID Namespace,
    _In_ PCUNICODE_STRING ApiSetToResolve,
    _In_opt_ PCUNICODE_STRING ApiSetParentName,
    _Inout_ PUNICODE_STRING ResolvedHostLibraryName);


#pragma warning(pop)

#endif NTLDR_RTL

```

`Source/Shared/ntos/ntos.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*  Translated from Microsoft sources/debugger or mentioned elsewhere.
*
*  TITLE:       NTOS.H
*
*  VERSION:     1.237
*
*  DATE:        22 Aug 2025
*
*  Common header file for the ntos API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*
*  Include:       Windows.h
*                 NtStatus.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef NTOS_RTL
#define NTOS_RTL

//
// NTOS_RTL HEADER BEGIN
//

//
// Enable LIST_ENTRY macroses.
//
#define NTOS_ENABLE_LIST_ENTRY_MACRO

#if defined(__cplusplus)

#ifndef MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
#endif

extern "C" {
#endif

#pragma comment(lib, "ntdll.lib")

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif

#ifndef ABSOLUTE_TIME
#define ABSOLUTE_TIME(wait) (wait)
#endif

#ifndef RELATIVE_TIME
#define RELATIVE_TIME(wait) (-(wait))
#endif

#ifndef NANOSECONDS
#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#endif

#ifndef MICROSECONDS
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#endif

#ifndef MILLISECONDS
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#endif

#ifndef SECONDS
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#endif

#ifndef POI //poi-poi
#define POI(addr) *(ULONG *)(addr)
#endif

typedef char CCHAR;
typedef unsigned char UCHAR;
typedef CCHAR KPROCESSOR_MODE;
typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;
typedef ULONG CLONG;
typedef LONG KPRIORITY;
typedef short CSHORT;
typedef ULONGLONG REGHANDLE, *PREGHANDLE;
typedef PVOID *PDEVICE_MAP;
typedef PVOID PHEAD;
typedef PVOID PEJOB;
typedef PVOID PKTHREAD;
typedef struct _IO_TIMER* PIO_TIMER;
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
typedef struct _EJOB* PESILO;

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
typedef PVOID PMEM_EXTENDED_PARAMETER;
#endif

#ifndef IN_REGION
#define IN_REGION(x, Base, Size) ( \
    (((ULONG_PTR)(Base) + (ULONG_PTR)(Size)) > (ULONG_PTR)(Base)) && \
    /* x within [Base, Base+Size) */ \
    (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && ((ULONG_PTR)(x) < ((ULONG_PTR)(Base) + (ULONG_PTR)(Size)))))
#endif

#define PE_SIGNATURE_SIZE           4
#ifndef RTL_MEG
#define RTL_MEG                     (1024UL * 1024UL)
#endif
#ifndef RTLP_IMAGE_MAX_DOS_HEADER
#define RTLP_IMAGE_MAX_DOS_HEADER   (256UL * RTL_MEG)
#endif
#ifndef MM_SIZE_OF_LARGEST_IMAGE
#define MM_SIZE_OF_LARGEST_IMAGE    ((ULONG)0x77000000)
#endif
#ifndef MM_MAXIMUM_IMAGE_HEADER
#define MM_MAXIMUM_IMAGE_HEADER     (2 * PAGE_SIZE)
#endif
#ifndef MM_MAXIMUM_IMAGE_SECTIONS
#define MM_MAXIMUM_IMAGE_SECTIONS                       \
     ((MM_MAXIMUM_IMAGE_HEADER - (PAGE_SIZE + sizeof(IMAGE_NT_HEADERS))) /  \
            sizeof(IMAGE_SECTION_HEADER))
#endif

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

//Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) 
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentThreadEffectiveToken() ((HANDLE)(LONG_PTR)-6) //GetCurrentThreadEffectiveToken

enum _KPROCESSOR_MODE {
    KernelMode = 0,
    UserMode,
    MaximumMode
};

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
#endif

#ifndef RTL_CONSTANT_OBJECT_ATTRIBUTES
#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }
#endif

// This synonym is more appropriate for initializing what isn't actually const.
#ifndef RTL_INIT_OBJECT_ATTRIBUTES
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)
#endif

//
// ntdef.h end
//
#ifndef RtlOffsetToPointer
#define RtlOffsetToPointer(Base, Offset)  ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset))  ))
#endif

#ifndef RtlPointerToOffset
#define RtlPointerToOffset(Base, Pointer)  ((ULONG)( ((PCHAR)(Pointer)) - ((PCHAR)(Base))  ))
#endif

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT                         0x00000002L
#define OBJ_PERMANENT                       0x00000010L
#define OBJ_EXCLUSIVE                       0x00000020L
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define OBJ_OPENIF                          0x00000080L
#define OBJ_OPENLINK                        0x00000100L
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_FORCE_ACCESS_CHECK              0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x00000800L
#define OBJ_DONT_REPARSE                    0x00001000L
#define OBJ_VALID_ATTRIBUTES                0x00001FF2L

#define OBJ_PROTECT_CLOSE                   0x00000001L
#define OBJ_AUDIT_OBJECT_CLOSE              0x00000004L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE    0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|CALLBACK_MODIFY_STATE )

//
// CompositionSurface Access Rights
//
#ifndef COMPOSITIONSURFACE_READ
#define COMPOSITIONSURFACE_READ         0x0001L
#endif

#ifndef COMPOSITIONSURFACE_WRITE
#define COMPOSITIONSURFACE_WRITE        0x0002L
#endif

#ifndef COMPOSITIONSURFACE_ALL_ACCESS
#define COMPOSITIONSURFACE_ALL_ACCESS   (COMPOSITIONSURFACE_READ | COMPOSITIONSURFACE_WRITE)
#endif

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#ifndef EVENT_QUERY_STATE
#define EVENT_QUERY_STATE       0x0001
#endif

#ifndef EVENT_MODIFY_STATE      //SDK compatibility
#define EVENT_MODIFY_STATE      0x0002  
#endif

#ifndef EVENT_ALL_ACCESS        //SDK compatibility
#define EVENT_ALL_ACCESS(EVENT_QUERY_STATE | EVENT_MODIFY_STATE | STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE)
#endif

//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#ifndef MUTANT_QUERY_STATE      //SDK compatibility
#define MUTANT_QUERY_STATE      0x0001
#endif

#ifndef MUTANT_ALL_ACCESS //SDK compatibility
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)
#endif

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | PORT_CONNECT)

//
// Filter Port Access Rights
//
#define FLT_PORT_CONNECT 0x0001
#define FLT_PORT_ALL_ACCESS (FLT_PORT_CONNECT|STANDARD_RIGHTS_ALL)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#ifndef SEMAPHORE_QUERY_STATE       //SDK compatibility
#define SEMAPHORE_QUERY_STATE       0x0001
#endif

#ifndef SEMAPHORE_MODIFY_STATE      //SDK compatibility
#define SEMAPHORE_MODIFY_STATE      0x0002 
#endif

#ifndef SEMAPHORE_ALL_ACCESS //SDK compatibility
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|SEMAPHORE_QUERY_STATE|SEMAPHORE_MODIFY_STATE)
#endif

//
// Time Object Access rights
//
#ifndef TIMER_QUERY_STATE
#define TIMER_QUERY_STATE 0x0001
#endif

#ifndef TIMER_MODIFY_STATE
#define TIMER_MODIFY_STATE 0x0002
#endif

#ifndef TIMER_ALL_ACCESS
#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|TIMER_QUERY_STATE|TIMER_MODIFY_STATE)
#endif

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY 0x0001
#define SYMBOLIC_LINK_SET   0x0002
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYMBOLIC_LINK_QUERY)
#define SYMBOLIC_LINK_ALL_ACCESS_EX (STANDARD_RIGHTS_REQUIRED | 0xFFFF)

//
// Thread Object Access Rights
//
#define THREAD_ALERT   (0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002 
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET  0x00000020
#define THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE   0x00000040
#define THREAD_CREATE_FLAGS_INITIAL_THREAD          0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER       0x0001
#define WORKER_FACTORY_WAIT                 0x0002
#define WORKER_FACTORY_SET_INFORMATION      0x0004
#define WORKER_FACTORY_QUERY_INFORMATION    0x0008
#define WORKER_FACTORY_READY_WORKER         0x0010
#define WORKER_FACTORY_SHUTDOWN             0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | OBJECT_TYPE_CREATE)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_LOG_EVENT            0x0200 // used on Vista and greater
#define TRACELOG_CREATE_INPROC        0x0200 // used pre-Vista
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800
#define TRACELOG_JOIN_GROUP           0x1000

//
// Memory Partition Object Access Rights
//
#ifndef MEMORY_PARTITION_QUERY_ACCESS
#define MEMORY_PARTITION_QUERY_ACCESS  0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |         \
                                     SYNCHRONIZE |                      \
                                     MEMORY_PARTITION_QUERY_ACCESS |    \
                                     MEMORY_PARTITION_MODIFY_ACCESS)
#endif

//
// Define special ByteOffset parameters for read and write operations
//
#ifndef FILE_WRITE_TO_END_OF_FILE
#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#endif
#ifndef FILE_USE_FILE_POINTER_POSITION
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe
#endif

#ifndef FILE_SHARE_VALID_FLAGS
#define FILE_SHARE_VALID_FLAGS FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE
#endif

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#ifndef MAXUSHORT
#define MAXUSHORT   0xffff     
#endif
#ifndef MAX_USTRING
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )
#endif

typedef struct _EX_RUNDOWN_REF {
    union
    {
        ULONG Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

#ifdef _WIN64
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

typedef struct _EX_FAST_REF {
    union {
        PVOID Object;
#if defined (_WIN64)
        ULONG_PTR RefCnt : 4;
#else
        ULONG_PTR RefCnt : 3;
#endif
        ULONG_PTR Value;
    };
} EX_FAST_REF, *PEX_FAST_REF;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value) \
  static UNICODE_STRING string = { sizeof(value) - sizeof(WCHAR), sizeof(value), value };
#endif

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;
typedef CONST char *PCSZ;

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#ifndef INTERFACE_TYPE
typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    ACPIBus,
    MaximumInterfaceType
} INTERFACE_TYPE, * PINTERFACE_TYPE;
#endif

/*
** FileCache and MemoryList START
*/

typedef enum _SYSTEM_MEMORY_LIST_COMMAND {
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

typedef struct _SYSTEM_FILECACHE_INFORMATION {
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

/*
** FileCache and MemoryList END
*/

/*
** Processes START
*/

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef enum _THREAD_STATE {
    StateInitialized,
    StateReady,
    StateRunning,
    StateStandby,
    StateTerminated,
    StateWait,
    StateTransition,
    StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
    Executive = 0,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair, //has no effect after 7
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    WrPhysicalFault,
    WrIoRing,
    WrMdlCache,
    WrRcu,
    MaximumWaitReason
} KWAIT_REASON;

typedef VOID KSTART_ROUTINE(
    _In_ PVOID StartContext
);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID64 {
    ULONG64 UniqueProcess;
    ULONG64 UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

typedef struct _CLIENT_ID32 {
    ULONG32 UniqueProcess;
    ULONG32 UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} VM_COUNTERS;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitchCount;
    THREAD_STATE State;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PVOID TebBase;
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryDelta;
    ULONG ThreadCount;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    VM_COUNTERS VmCounters;
    IO_COUNTERS IoCounters;
    SYSTEM_THREAD_INFORMATION Threads[1]; //not a part of this structure
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry,
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

typedef struct _PROCESS_DISK_COUNTERS {
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

typedef union _ENERGY_STATE_DURATION {
    union
    {
        ULONGLONG Value;
        ULONG LastChangeTime;
    };

    ULONG Duration : 31;
    ULONG IsInState : 1;
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES {
    ULONGLONG Cycles[2][4];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset;
    PROCESS_ENERGY_VALUES EnergyValues;
    ULONG AppIdOffset;
    SIZE_T SharedCommitCharge;
    ULONG JobObjectId;
    ULONG SpareUlong;
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

typedef struct _SYSTEM_PROCESS_FULL_INFORMATION {
    SYSTEM_PROCESS_INFORMATION ProcessAndThreads;
    SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
} SYSTEM_PROCESS_FULL_INFORMATION, *PSYSTEM_PROCESS_FULL_INFORMATION;

typedef struct _SYSTEM_PROCESS_ID_INFORMATION {
    HANDLE ProcessId;
    UNICODE_STRING ImageName;
} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_INFORMATION {
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN EncryptionKeyAvailable : 1;
    BOOLEAN SpareFlags : 2;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN HvciDisableAllowed : 1;
    BOOLEAN HardwareEnforcedVbs : 1;
    BOOLEAN NoSecrets : 1;
    BOOLEAN EncryptionKeyPersistent : 1;
    BOOLEAN HardwareEnforcedHvpt : 1;
    BOOLEAN HardwareHvptAvailable : 1;
    BOOLEAN SpareFlags2 : 1;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION { //chappell
    ULONGLONG ProcessorFeatureBits;
    ULONGLONG Reserved[3];
} SYSTEM_PROCESSOR_FEATURES_INFORMATION, * PSYSTEM_PROCESSOR_FEATURES_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY {
    BOOLEAN Allocated;
    BOOLEAN Spare0;
    USHORT AllocatorBackTraceIndex;
    ULONG Size;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
        PVOID ProcessChargedQuota;
    };
} SYSTEM_POOL_ENTRY, * PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION {
    SIZE_T TotalSize;
    PVOID FirstEntry;
    USHORT EntryOverhead;
    BOOLEAN PoolTagPresent;
    BOOLEAN Spare0;
    ULONG NumberOfEntries;
    SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, * PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_POOLTAG {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedUsed;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, * PSYSTEM_POOLTAG;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    SIZE_T SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_POOLTAG_INFORMATION {
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_POOLTAG_INFORMATION, * PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_SESSION_POOLTAG_INFORMATION, * PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
    UNICODE_STRING FirmwarePartition; // \Device\HarddiskX
} SYSTEM_FIRMWARE_PARTITION_INFORMATION, * PSYSTEM_FIRMWARE_PARTITION_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION {
    PCHAR SymbolicBackTrace;
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[32];
} RTL_PROCESS_BACKTRACE_INFORMATION, * PRTL_PROCESS_BACKTRACE_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACES {
    ULONG CommittedMemory;
    ULONG ReservedMemory;
    ULONG NumberOfBackTraceLookups;
    ULONG NumberOfBackTraces;
    RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[1];
} RTL_PROCESS_BACKTRACES, * PRTL_PROCESS_BACKTRACES;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessConsoleHostProcess = 49, //ProcessOwnerInformation
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessActivityThrottleState = 77,
    ProcessActivityThrottlePolicy = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 94,
    ProcessCombineSecurityDomainsInformation = 95,
    ProcessEnableLogging = 96,
    ProcessLeapSecondInformation = 97,
    ProcessFiberShadowStackAllocation = 98,
    ProcessFreeFiberShadowStackAllocation = 99,
    ProcessAltSystemCallInformation = 100,
    ProcessDynamicEHContinuationTargets = 101,
    ProcessDynamicEnforcedCetCompatibleRanges = 102,
    ProcessCreateStateChange = 103,
    ProcessApplyStateChange = 104,
    ProcessEnableOptionalXStateFeatures = 105,
    ProcessAltPrefetchParam = 106,
    ProcessAssignCpuPartitions = 107,
    ProcessPriorityClassEx = 108,
    ProcessMembershipInformation = 109,
    ProcessEffectiveIoPriority = 110,
    ProcessEffectivePagePriority = 111,
    ProcessSchedulerSharedData = 112,
    ProcessSlistRollbackInformation = 113,
    ProcessNetworkIoCounters = 114,
    ProcessFindFirstThreadByTebValue = 115,
    ProcessEnclaveAddressSpaceRestriction = 116,
    ProcessAvailableCpus = 117,
    MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    ThreadSwitchLegacyState,
    ThreadIsTerminated,
    ThreadLastSystemCall,
    ThreadIoPriority,
    ThreadCycleTime,
    ThreadPagePriority,
    ThreadActualBasePriority,
    ThreadTebInformation,
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context,
    ThreadGroupInformation,
    ThreadUmsInformation,
    ThreadCounterProfiling,
    ThreadIdealProcessorEx,
    ThreadCpuAccountingInformation,
    ThreadSuspendCount,
    ThreadHeterogeneousCpuPolicy,
    ThreadContainerId,
    ThreadNameInformation,
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation,
    ThreadActualGroupAffinity,
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation,
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    ThreadManageWritesToExecutableMemory,
    ThreadPowerThrottlingState,
    ThreadWorkloadClass,
    ThreadCreateStateChange,
    ThreadApplyStateChange,
    ThreadStrongerBadHandleChecks,
    ThreadEffectiveIoPriority,
    ThreadEffectivePagePriority,
    ThreadUpdateLockOwnership,
    ThreadSchedulerSharedDataSlot,
    ThreadTebInformationAtomic,
    ThreadIndexInformation,
    MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// taken from ph2(whatever)
typedef struct _THREAD_LAST_SYSCALL_INFORMATION {
    PVOID FirstArgument;
    USHORT SystemCallNumber;
#ifdef WIN64
    USHORT Pad[0x3]; // since REDSTONE2
#else
    USHORT Pad[0x1]; // since REDSTONE2
#endif
    ULONG64 WaitTime;
} THREAD_LAST_SYSCALL_INFORMATION, * PTHREAD_LAST_SYSCALL_INFORMATION;

typedef struct _THREAD_NAME_INFORMATION {
    UNICODE_STRING ThreadName;
} THREAD_NAME_INFORMATION, * PTHREAD_NAME_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    SIZE_T Size;
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _PROCESS_ACCESS_TOKEN {
    HANDLE Token;
    HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

typedef enum _PROCESS_STATE_CHANGE_TYPE {
    ProcessStateChangeSuspend,
    ProcessStateChangeResume,
    ProcessStateChangeMax,
} PROCESS_STATE_CHANGE_TYPE, *PPROCESS_STATE_CHANGE_TYPE;

typedef enum _THREAD_STATE_CHANGE_TYPE {
    ThreadStateChangeSuspend,
    ThreadStateChangeResume,
    ThreadStateChangeMax,
} THREAD_STATE_CHANGE_TYPE, *PTHREAD_STATE_CHANGE_TYPE;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//
typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef enum _PS_MITIGATION_OPTION {
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT,
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS,
    PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION,
    PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES,
    PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY,
    PS_MITIGATION_OPTION_REDIRECTION_TRUST,
    PS_MITIGATION_OPTION_RESTRICT_CORE_SHARING,
    PS_MITIGATION_OPTION_FSCTL_SYSTEM_CALL_DISABLE
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE {
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName,
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO {
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        struct
        {
            HANDLE FileHandle;
        } FailSection;

        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1;
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

typedef struct _PS_ATTRIBUTE {
    ULONG Attribute;
    SIZE_T Size;
    union
    {
        ULONG Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST {
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef enum _PS_PROTECTED_TYPE {
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

#define PS_PROTECTED_SIGNER_MASK 0xFF
#define PS_PROTECTED_AUDIT_MASK 0x08
#define PS_PROTECTED_TYPE_MASK 0x07

// from ph2
#define PsProtectedValue(aSigner, aAudit, aType) ( \
    (((aSigner) & PS_PROTECTED_SIGNER_MASK) << 4) | \
    (((aAudit) & PS_PROTECTED_AUDIT_MASK) << 3) | \
    ((aType) & PS_PROTECTED_TYPE_MASK)\
    )

#define InitializePsProtection(aProtectionLevelPtr, aSigner, aAudit, aType) { \
    (aProtectionLevelPtr)->Signer = aSigner; \
    (aProtectionLevelPtr)->Audit = aAudit; \
    (aProtectionLevelPtr)->Type = aType; \
    }

typedef struct _PS_PROTECTION {
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

// begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 
#define PS_ATTRIBUTE_INPUT 0x00020000 
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 
// end_rev

typedef enum _PS_ATTRIBUTE_NUM {
    PsAttributeParentProcess,
    PsAttributeDebugPort,
    PsAttributeToken,
    PsAttributeClientId,
    PsAttributeTebAddress,
    PsAttributeImageName,
    PsAttributeImageInfo,
    PsAttributeMemoryReserve,
    PsAttributePriorityClass,
    PsAttributeErrorMode,
    PsAttributeStdHandleInfo,
    PsAttributeHandleList,
    PsAttributeGroupAffinity,
    PsAttributePreferredNode,
    PsAttributeIdealProcessor,
    PsAttributeUmsThread,
    PsAttributeMitigationOptions,
    PsAttributeProtectionLevel,
    PsAttributeSecureProcess,
    PsAttributeJobList,
    PsAttributeChildProcessPolicy,
    PsAttributeAllApplicationPackagesPolicy,
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation,
    PsAttributeDesktopAppPolicy,
    PsAttributeChpe,
    PsAttributeMitigationAuditOptions,
    PsAttributeMachineType,
    PsAttributeComponentFilter,
    PsAttributeEnableOptionalXStateFeatures,
    PsAttributeSupportedMachines,
    PsAttributeSveVectorLength,
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_OBJECT \
    PsAttributeValue(PsAttributeDebugObject, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHPE \
    PsAttributeValue(PsAttributeChpe, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_MITIGATION_AUDIT_OPTIONS \
    PsAttributeValue(PsAttributeMitigationAuditOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_MACHINE_TYPE \
    PsAttributeValue(PsAttributeMachineType, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_COMPONENT_FILTER \
    PsAttributeValue(PsAttributeComponentFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ENABLE_OPTIONAL_XSTATE_FEATURES \
    PsAttributeValue(PsAttributeEnableOptionalXStateFeatures, TRUE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED                 0x00000001
#define RTL_USER_PROC_PROFILE_USER                      0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL                    0x00000004
#define RTL_USER_PROC_PROFILE_SERVER                    0x00000008
#define RTL_USER_PROC_RESERVE_1MB                       0x00000020
#define RTL_USER_PROC_RESERVE_16MB                      0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE                    0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT             0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL             0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT              0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING                 0x00004000
#define RTL_USER_PROC_DEV_OVERRIDE_ENABLED              0x00008000
#define RTL_USER_PROC_OPTIN_PROCESS                     0x00020000
#define RTL_USER_PROC_SESSION_OWNER                     0x00040000
#define RTL_USER_PROC_HANDLE_USER_CALLBACK_EXCEPTIONS   0x00080000
#define RTL_USER_PROC_PROTECTED_PROCESS                 0x00400000
#define RTL_USER_PROC_SECURE_PROCESS                    0x80000000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE {
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, * PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, * PPROCESS_HANDLE_TRACING_ENABLE_EX;

#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

#define PROCESS_HANDLE_TRACE_TYPE_OPEN      1
#define PROCESS_HANDLE_TRACE_TYPE_CLOSE     2
#define PROCESS_HANDLE_TRACE_TYPE_BADREF    3

typedef struct _PROCESS_HANDLE_TRACING_ENTRY {
    HANDLE Handle;
    CLIENT_ID ClientId;
    ULONG Type;
    PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, * PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY {
    HANDLE Handle;
    ULONG TotalTraces;
    PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, * PPROCESS_HANDLE_TRACING_QUERY;

typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, * PPROCESS_WS_WATCH_INFORMATION;

typedef struct _PROCESS_WS_WATCH_INFORMATION_EX {
    PROCESS_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;
} PROCESS_WS_WATCH_INFORMATION_EX, * PPROCESS_WS_WATCH_INFORMATION_EX;

typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
    ULONG Version;
    ULONG Reserved;
    PVOID Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, * PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

/*
** Processes END
*/

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemSpare0 = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemVsmProtectionInformation = 169, //ex SystemDmaProtectionInformation
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    SystemSecurityModelInformation = 208,
    SystemCodeIntegritySyntheticCacheInformation = 209,
    SystemFeatureConfigurationInformation = 210,
    SystemFeatureConfigurationSectionInformation = 211,
    SystemFeatureUsageSubscriptionInformation = 212,
    SystemSecureSpeculationControlInformation = 213,
    SystemSpacesBootInformation = 214,
    SystemFwRamdiskInformation = 215,
    SystemWheaIpmiHardwareInformation = 216,
    SystemDifSetRuleClassInformation = 217,
    SystemDifClearRuleClassInformation = 218,
    SystemDifApplyPluginVerificationOnDriver = 219,
    SystemDifRemovePluginVerificationOnDriver = 220,
    SystemShadowStackInformation = 221,
    SystemBuildVersionInformation = 222,
    SystemPoolLimitInformation = 223,
    SystemCodeIntegrityAddDynamicStore = 224,
    SystemCodeIntegrityClearDynamicStores = 225,
    SystemDifPoolTrackingInformation = 226,
    SystemPoolZeroingInformation = 227,
    SystemDpcWatchdogInformation = 228,
    SystemDpcWatchdogInformation2 = 229,
    SystemSupportedProcessorArchitectures2 = 230,
    SystemSingleProcessorRelationshipInformation = 231,
    SystemXfgCheckFailureInformation = 232,
    SystemIommuStateInformation = 233,
    SystemHypervisorMinrootInformation = 234,
    SystemHypervisorBootPagesInformation = 235,
    SystemPointerAuthInformation = 236,
    SystemSecureKernelDebuggerInformation = 237,
    SystemOriginalImageFeatureInformation = 238,
    SystemMemoryNumaInformation = 239,
    SystemMemoryNumaPerformanceInformation = 240,
    SystemCodeIntegritySignedPoliciesFullInformation = 241,
    SystemSecureSecretsInformation = 242,
    SystemTrustedAppsRuntimeInformation = 243,
    SystemBadPageInformationEx = 244,
    SystemResourceDeadlockTimeout = 245,
    SystemBreakOnContextUnwindFailureInformation = 246,
    SystemOslRamdiskInformation = 247,
    SystemCodeIntegrityPolicyManagementInformation = 248,
    SystemMemoryNumaCacheInformation = 249,
    SystemProcessorFeaturesBitMapInformation = 250,
    SystemRefTraceInformationEx = 251,
    SystemBasicProcessInformation = 252,
    SystemHandleCountInformation = 253,
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_VSM_PROTECTION_INFORMATION {
    CHAR DmaProtectionsAvailable;
    CHAR DmaProtectionsInUse;
    CHAR HardwareMbecAvailable;
    CHAR ApicVirtualizationAvailable;
} SYSTEM_VSM_PROTECTION_INFORMATION, * PSYSTEM_VSM_PROTECTION_INFORMATION;

//msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
    union {
        ULONG Flags;
        struct {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1;
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1;
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1;
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG TsxCtrlStatus : 2;
            ULONG TsxCtrlReported : 1;
            ULONG TaaHardwareImmune : 1;
            ULONG Reserved : 1;
        } SpeculationControlFlags;
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION_V2 {
    union {
        ULONG Flags;
        struct {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1;
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1;
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1;
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG TsxCtrlStatus : 2;
            ULONG TsxCtrlReported : 1;
            ULONG TaaHardwareImmune : 1;
            ULONG Reserved : 1;
        } SpeculationControlFlags;
    };
    union {
        ULONG Flags2;
        struct {
            ULONG SbdrSsdpHardwareProtected : 1;
            ULONG FbsdpHardwareProtected : 1;
            ULONG PsdpHardwareProtected : 1;
            ULONG FbClearEnabled : 1;
            ULONG FbClearReported : 1;
            ULONG BhbEnabled : 1;
            ULONG BhbDisabledSystemPolicy : 1;
            ULONG BhbDisabledNoHardwareSupport : 1;
            ULONG BranchConfusionStatus : 2;
            ULONG BranchConfusionReported : 1;
            ULONG RdclHardwareProtectedReported : 1;
            ULONG RdclHardwareProtected : 1;
            ULONG Reserved3 : 4;
            ULONG Reserved4 : 3;
            ULONG DivideByZeroReported : 1;
            ULONG DivideByZeroStatus : 1;
            ULONG Reserved5 : 3;
            ULONG Reserved : 7;
        } SpeculationControlFlags2;
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION_V2, * PSYSTEM_SPECULATION_CONTROL_INFORMATION_V2;

typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    union {
        ULONG Flags;
        struct {
            ULONG KvaShadowEnabled : 1;
            ULONG KvaShadowUserGlobal : 1;
            ULONG KvaShadowPcid : 1;
            ULONG KvaShadowInvpcid : 1;
            ULONG KvaShadowRequired : 1;
            ULONG KvaShadowRequiredAvailable : 1;
            ULONG InvalidPteBit : 6;
            ULONG L1DataCacheFlushSupported : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved : 18;
        } KvaShadowFlags;
    };
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG  Length;
    ULONG  CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED                      0x01
#define CODEINTEGRITY_OPTION_TESTSIGN                     0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED                 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED       0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED  0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD                   0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD          0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED            0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD                 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED            0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED            0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED  0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED             0x2000
#define CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED     0x4000
#define CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED       0x8000

typedef struct _HV_DETAILS {
    ULONG Data[4];
} HV_DETAILS, * PHV_DETAILS;

typedef struct _HV_VENDOR_AND_MAX_FUNCTION {
    ULONG MaxFunction;
    CHAR VendorName[12];
} HV_VENDOR_AND_MAX_FUNCTION, * PHV_VENDOR_AND_MAX_FUNCTION;

typedef struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
    HV_DETAILS HvVendorAndMaxFunction;
    HV_DETAILS HypervisorInterface;
    HV_DETAILS HypervisorVersion;
    HV_DETAILS HvFeatures;
    HV_DETAILS HwFeatures;
    HV_DETAILS EnlightenmentInfo;
    HV_DETAILS ImplementationLimits;
} SYSTEM_HYPERVISOR_DETAIL_INFORMATION, * PSYSTEM_HYPERVISOR_DETAIL_INFORMATION;

typedef struct _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
    BOOLEAN HypervisorConnected;
    BOOLEAN HypervisorDebuggingEnabled;
    BOOLEAN HypervisorPresent;
    BOOLEAN Spare0[5];
    ULONGLONG EnabledEnlightenments;
} SYSTEM_HYPERVISOR_QUERY_INFORMATION, * PSYSTEM_HYPERVISOR_QUERY_INFORMATION;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _SYSTEM_VHD_BOOT_INFORMATION {
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

/*
** Boot Entry START
*/

typedef struct _FILE_PATH {
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

typedef struct _BOOT_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[ANYSIZE_ARRAY];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST {
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

/*
** Boot Entry END
*/

/*
** File start
*/

#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileObjectIdInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileQuotaInformation,
    FileReparsePointInformation,
    FileNetworkOpenInformation,
    FileAttributeTagInformation,
    FileTrackingInformation,
    FileIdBothDirectoryInformation,
    FileIdFullDirectoryInformation,
    FileValidDataLengthInformation,
    FileShortNameInformation,
    FileIoCompletionNotificationInformation,
    FileIoStatusBlockRangeInformation,
    FileIoPriorityHintInformation,
    FileSfioReserveInformation,
    FileSfioVolumeInformation,
    FileHardLinkInformation,
    FileProcessIdsUsingFileInformation,
    FileNormalizedNameInformation,
    FileNetworkPhysicalNameInformation,
    FileIdGlobalTxDirectoryInformation,
    FileIsRemoteDeviceInformation,
    FileUnusedInformation,
    FileNumaNodeInformation,
    FileStandardLinkInformation,
    FileRemoteProtocolInformation,
    FileRenameInformationBypassAccessCheck,
    FileLinkInformationBypassAccessCheck,
    FileVolumeNameInformation,
    FileIdInformation,
    FileIdExtdDirectoryInformation,
    FileReplaceCompletionInformation,
    FileHardLinkFullIdInformation,
    FileIdExtdBothDirectoryInformation,
    FileDispositionInformationEx,
    FileRenameInformationEx,
    FileRenameInformationExBypassAccessCheck,
    FileDesiredStorageClassInformation,
    FileStatInformation,
    FileMemoryPartitionInformation,
    FileStatLxInformation,
    FileCaseSensitiveInformation,
    FileLinkInformationEx,
    FileLinkInformationExBypassAccessCheck,
    FileStorageReserveIdInformation,
    FileCaseSensitiveInformationForceAccessCheck,
    FileKnownFolderInformation,
    FileStatBasicInformation,
    FileId64ExtdDirectoryInformation,
    FileId64ExtdBothDirectoryInformation,
    FileIdAllExtdDirectoryInformation,
    FileIdAllExtdBothDirectoryInformation,
    FileStreamReservationInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsControlInformation,
    FileFsFullSizeInformation,
    FileFsObjectIdInformation,
    FileFsDriverPathInformation,
    FileFsVolumeFlagsInformation,
    FileFsSectorSizeInformation,
    FileFsDataCopyInformation,
    FileFsMetadataSizeInformation,
    FileFsFullSizeInformationEx,
    FileFsGuidInformation,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    UCHAR DeletePending;
    UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

//
// Define the NamedPipeType flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_TYPE      0x00000000
#define FILE_PIPE_MESSAGE_TYPE          0x00000001

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


typedef struct _FILE_PIPE_INFORMATION {
    ULONG ReadMode;
    ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
    ULONG NamedPipeType;
    ULONG NamedPipeConfiguration;
    ULONG MaximumInstances;
    ULONG CurrentInstances;
    ULONG InboundQuota;
    ULONG ReadDataAvailable;
    ULONG OutboundQuota;
    ULONG WriteQuotaAvailable;
    ULONG NamedPipeState;
    ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
    LARGE_INTEGER CollectDataTime;
    ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION {
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

//
// Define the flags for NtSet(Query)EaFile service structure entries
//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG         VolumeSerialNumber;
    ULONG         VolumeLabelLength;
    BOOLEAN       SupportsObjects;
    WCHAR         VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

/*
** File END
*/

/*
** Section START
*/

typedef enum _SECTION_INFORMATION_CLASS {
    SectionBasicInformation,
    SectionImageInformation,
    SectionRelocationInformation,
    SectionOriginalBaseInformation,
    SectionInternalImageInformation,
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFO {
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION {
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _MI_EXTRA_IMAGE_INFORMATION {
    ULONG SizeOfHeaders;
    ULONG SizeOfImage;
} MI_EXTRA_IMAGE_INFORMATION, *PMI_EXTRA_IMAGE_INFORMATION;

typedef struct _MI_SECTION_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION ExportedImageInformation;
    MI_EXTRA_IMAGE_INFORMATION InternalImageInformation;
} MI_SECTION_IMAGE_INFORMATION, *PMI_SECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
    ULONGLONG TransferAddress;
    ULONG ZeroBits;
    ULONGLONG MaximumStackSize;
    ULONGLONG CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG ImageCetShadowStacksReady : 1; // 20H1
            ULONG ImageXfgEnabled : 1; // 20H2
            ULONG ImageCetShadowStacksStrictMode : 1;
            ULONG ImageCetSetContextIpValidationRelaxedMode : 1;
            ULONG ImageCetDynamicApisAllowInProc : 1;
            ULONG ImageCetDowngradeReserved1 : 1;
            ULONG ImageCetDowngradeReserved2 : 1;
            ULONG Reserved : 24;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, * PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

#ifndef SEC_BASED
#define SEC_BASED          0x200000
#endif

#ifndef SEC_NO_IMAGE
#define SEC_NO_CHANGE      0x400000
#endif

#ifndef SEC_FILE
#define SEC_FILE           0x800000     
#endif

#ifndef SEC_IMAGE
#define SEC_IMAGE         0x1000000     
#endif

#ifndef SEC_RESERVE
#define SEC_RESERVE       0x4000000     
#endif

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000     
#endif

#ifndef SEC_NOCACHE
#define SEC_NOCACHE      0x10000000     
#endif

#ifndef SEC_GLOBAL
#define SEC_GLOBAL       0x20000000
#endif

#ifndef SEC_LARGE_PAGES
#define SEC_LARGE_PAGES  0x80000000    
#endif

/*
** Section END
*/

/*
** System Table START
*/
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX   0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

typedef struct _KSERVICE_TABLE_DESCRIPTOR {
    ULONG_PTR Base; //e.g. KiServiceTable
    PULONG Count;
    ULONG Limit;//e.g. KiServiceLimit
    PUCHAR Number; //e.g. KiArgumentTable
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
/*
** System Table END
*/

/*
** System Boot Environment START
*/

// Size=20
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

// Size=32
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
    union
    {
        ULONGLONG BootFlags;
        struct
        {
            ULONGLONG DbgMenuOsSelection : 1; // RS4
            ULONGLONG DbgHiberBoot : 1;
            ULONGLONG DbgSoftBoot : 1;
            ULONGLONG DbgMeasuredLaunch : 1;
            ULONGLONG DbgMeasuredLaunchCapable : 1; // 19H1
            ULONGLONG DbgSystemHiveReplace : 1;
            ULONGLONG DbgMeasuredLaunchSmmProtections : 1;
            ULONGLONG DbgMeasuredLaunchSmmLevel : 7; // 20H1
        };
    };
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

/*
** System Boot Environment END
*/

/*
** Key START
*/

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    KeyHandleTagsInformation,
    KeyTrustInformation,
    KeyLayerInformation,
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation,
    KeyWow64FlagsInformation,
    KeyControlFlagsInformation,
    KeySetVirtualizationInformation,
    KeySetDebugInformation,
    KeySetHandleTagsInformation,
    KeySetLayerInformation,
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    KeyValueLayerInformation,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
    //          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

/*
** Key END
*/


/*
** TIME_FIELDS START
*/

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

/*
** TIME_FIELDS END
*/

/*
** HANDLE START
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

/*
** HANDLE END
*/

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


/*
** OBJECT MANAGER START
*/

//
// Header flags
//

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

//
// InfoMask values
//

#define OB_INFOMASK_PROCESS_INFO    0x10
#define OB_INFOMASK_QUOTA           0x08
#define OB_INFOMASK_HANDLE          0x04
#define OB_INFOMASK_NAME            0x02
#define OB_INFOMASK_CREATOR_INFO    0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

typedef struct _OBJECT_DIRECTORY_ENTRY {
    PVOID ChainLink;
    PVOID Object;
    ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _EX_PUSH_LOCK {
    union {
        struct {
            ULONG_PTR Locked : 1;
            ULONG_PTR Waiting : 1;
            ULONG_PTR Waking : 1;
            ULONG_PTR MultipleShared : 1;
            ULONG_PTR Shared : sizeof(ULONG_PTR) * 8 - 4;
        };
        ULONG_PTR Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
    union {
        struct {
            ULONG Expanded : 1;
            ULONG Transitioning : 1;
            ULONG Pageable : 1;
        };
        ULONG Value;
    };
} EX_PUSH_LOCK_AUTO_EXPAND_STATE, *PEX_PUSH_LOCK_AUTO_EXPAND_STATE; /* size: 0x0004 */

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND {
    EX_PUSH_LOCK LocalLock;
    EX_PUSH_LOCK_AUTO_EXPAND_STATE State;
    ULONG Stats;
} EX_PUSH_LOCK_AUTO_EXPAND, *PEX_PUSH_LOCK_AUTO_EXPAND; /* size: 0x0010 */

typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
    LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    ULONG NumberOfPrivateSpaces;
} OBJECT_NAMESPACE_LOOKUPTABLE, *POBJECT_NAMESPACE_LOOKUPTABLE;

typedef struct _OBJECT_NAMESPACE_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID NamespaceRootDirectory;
    ULONG SizeOfBoundaryInformation;
    ULONG Reserved;
    UCHAR HashValue;
    ULONG_PTR Alignment;
} OBJECT_NAMESPACE_ENTRY, *POBJECT_NAMESPACE_ENTRY;

typedef enum _BOUNDARY_ENTRY_TYPE {
    OBNS_Invalid = 0,
    OBNS_Name = 1,
    OBNS_SID = 2,
    OBNS_IntegrityLabel = 3
} BOUNDARY_ENTRY_TYPE;

typedef struct _OBJECT_BOUNDARY_ENTRY {
    BOUNDARY_ENTRY_TYPE EntryType;
    ULONG EntrySize;
} OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

typedef struct _OBJECT_BOUNDARY_DESCRIPTOR {
    ULONG Version;
    ULONG Items;
    ULONG TotalSize;
    ULONG Reserved;
} OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

typedef struct _OBJECT_DIRECTORY {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_DIRECTORY_V2 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
    LONG Padding[1];
} OBJECT_DIRECTORY_V2, *POBJECT_DIRECTORY_V2;

typedef struct _OBJECT_DIRECTORY_V3 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    PVOID NamespaceEntry;
    PVOID SessionObject;
    ULONG Flags;
    ULONG SessionId;
} OBJECT_DIRECTORY_V3, *POBJECT_DIRECTORY_V3;

typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

typedef struct _OBJECT_HEADER_CREATOR_INFO {// Size=32
    LIST_ENTRY TypeList; // Size=16 Offset=0
    PVOID CreatorUniqueProcess; // Size=8 Offset=16
    USHORT CreatorBackTraceIndex; // Size=2 Offset=24
    USHORT Reserved; // Size=2 Offset=26
} OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

typedef struct _OBJECT_HANDLE_COUNT_ENTRY {// Size=16
    PVOID Process; // Size=8 Offset=0
    struct
    {
        unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
        unsigned long LockCount : 8; // Size=4 Offset=8 BitOffset=24 BitCount=8
    };
} OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

typedef struct _OBJECT_HEADER_HANDLE_INFO { // Size=16
    union {
        PVOID HandleCountDataBase; // Size=8 Offset=0
        struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
    };
} OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

typedef struct _OBJECT_HEADER_PROCESS_INFO { // Size=16
    PVOID ExclusiveProcess; // Size=8 Offset=0
    PVOID Reserved; // Size=8 Offset=8
} OBJECT_HEADER_PROCESS_INFO, *POBJECT_HEADER_PROCESS_INFO;

typedef struct _OBJECT_HEADER_QUOTA_INFO {
    ULONG PagedPoolCharge; //4
    ULONG NonPagedPoolCharge; //4 
    ULONG SecurityDescriptorCharge; //4
    PVOID SecurityDescriptorQuotaBlock; //sizeof(pointer)
    unsigned __int64 Reserved; //sizeof(uint64)
} OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

typedef struct _OBJECT_HEADER_PADDING_INFO {
    ULONG PaddingAmount;
} OBJECT_HEADER_PADDING_INFO, *POBJECT_HEADER_PADDING_INFO;

typedef struct _OBJECT_HEADER_AUDIT_INFO {
    PVOID SecurityDescriptor;
    PVOID Reserved;
} OBJECT_HEADER_AUDIT_INFO, *POBJECT_HEADER_AUDIT_INFO;

typedef struct _OBJECT_HEADER_EXTENDED_INFO {
    struct _OBJECT_FOOTER *Footer;
    PVOID Reserved;
} OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

typedef struct _OB_HANDLE_REVOCATION_BLOCK
{
    LIST_ENTRY RevocationInfos;
    struct _EX_PUSH_LOCK Lock;
    struct _EX_RUNDOWN_REF Rundown;
} OB_HANDLE_REVOCATION_BLOCK, *POB_HANDLE_REVOCATION_BLOCK;

typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO {
    LIST_ENTRY ListEntry;
    OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
    unsigned char Padding1[4];
    unsigned char Padding2[4];
} OBJECT_HEADER_HANDLE_REVOCATION_INFO, *POBJECT_HEADER_HANDLE_REVOCATION_INFO;

typedef struct _QUAD {
    union {
        INT64 UseThisFieldToCopy;
        float DoNotUseThisField;
    };
} QUAD, *PQUAD;

typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG Attributes;
    PVOID RootDirectory;
    CHAR ProbeMode;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PVOID SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

typedef struct _SECURITY_CLIENT_CONTEXT {
    struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
    void* ClientToken;
    UCHAR DirectlyAccessClientToken;
    UCHAR DirectAccessEffectiveOnly;
    UCHAR ServerIsRemote;
    struct _TOKEN_CONTROL ClientTokenControl;
    LONG __PADDING__[1];
} SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32
} POOL_TYPE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_INITIALIZER_COMPATIBLE {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
} OBJECT_TYPE_INITIALIZER_COMPATIBLE, *POBJECT_TYPE_INITIALIZER_COMPATIBLE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_COMPATIBLE {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_COMPATIBLE TypeInfo;
} OBJECT_TYPE_COMPATIBLE, *POBJECT_TYPE_COMPATIBLE;
typedef POBJECT_TYPE_COMPATIBLE POBJECT_TYPE;

//
// Complete definitions of OBJECT_TYPE + OBJECT_TYPE_INITIALIZER per Windows version.
//

typedef struct _OBJECT_TYPE_INITIALIZER_7 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER_7, *POBJECT_TYPE_INITIALIZER_7;

//
// Windows 8, new object type flag, WaitObject* members added
//
typedef struct _OBJECT_TYPE_INITIALIZER_8 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_8, *POBJECT_TYPE_INITIALIZER_8;

//
// Windows 10 RS1, new ObjectTypeFlags2 flag added, 
// ParseProcedure now has two variants with different parameters.
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS1 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    union
    {
        UCHAR ObjectTypeFlags2; //for ParseProcedureEx
        struct
        {
            UCHAR UseExtendedParameters : 1;
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS1, *POBJECT_TYPE_INITIALIZER_RS1;

//
// ObjectTypeFlags2 moved to extended to USHORT ObjectTypeFlags field.
// It was that hard to do this since beginning?
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS2 {
    USHORT Length;
    union
    {
        USHORT ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
        struct
        {
            UCHAR UseExtendedParameters : 1;//for ParseProcedureEx
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS2, *POBJECT_TYPE_INITIALIZER_RS2;

//
// OBJECT_TYPE definition vary only because of OBJECT_TYPE_INITIALIZER changes.
//
typedef struct _OBJECT_TYPE_7 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_7 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_7, POBJECT_TYPE_7;

typedef struct _OBJECT_TYPE_8 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_8 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_8, POBJECT_TYPE_8;

typedef struct _OBJECT_TYPE_RS1 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS1 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS1, POBJECT_TYPE_RS1;

typedef struct _OBJECT_TYPE_RS2 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS2 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS2, POBJECT_TYPE_RS2;

/*
** brand new header starting from 6.1
*/

typedef struct _OBJECT_HEADER {
    LONG_PTR PointerCount;
    union
    {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };
    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;
    UCHAR TraceFlags;
    UCHAR InfoMask;
    UCHAR Flags;
    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };
    PVOID SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

//
// Actual object header from windows 10-11.
//
typedef struct _OBJECT_HEADER_X {
    LONG_PTR PointerCount;
    union
    {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };

    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;

    union
    {
        UCHAR TraceFlags;
        struct
        {
            UCHAR DbgRefTrace : 1;
            UCHAR DbgTracePermanent : 1;
        };
    };

    UCHAR InfoMask;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR NewObject : 1;
            UCHAR KernelObject : 1;
            UCHAR KernelOnlyAccess : 1;
            UCHAR ExclusiveObject : 1;
            UCHAR PermanentObject : 1;
            UCHAR DefaultSecurityQuota : 1;
            UCHAR SingleHandleEntry : 1;
            UCHAR DeletedInline : 1;
        };
    };

    ULONG Reserved;

    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PVOID SecurityDescriptor;
    QUAD Body;

} OBJECT_HEADER_X, * POBJECT_HEADER_X;

#define OBJECT_TO_OBJECT_HEADER(obj) \
    CONTAINING_RECORD( (obj), OBJECT_HEADER, Body )

#define DOSDEVICE_DRIVE_UNKNOWN     0
#define DOSDEVICE_DRIVE_CALCULATE   1 //e.g. symlink
#define DOSDEVICE_DRIVE_REMOVABLE   2
#define DOSDEVICE_DRIVE_FIXED       3
#define DOSDEVICE_DRIVE_REMOTE      4
#define DOSDEVICE_DRIVE_CDROM       5
#define DOSDEVICE_DRIVE_RAMDISK     6

typedef struct _DEVICE_MAP_V1 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PVOID DosDevicesDirectoryHandle;
    ULONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[32];
} DEVICE_MAP_V1, * PDEVICE_MAP_V1;

typedef struct _DEVICE_MAP_V1 DEVICE_MAP_COMPATIBLE;
typedef struct _DEVICE_MAP_V1* PDEVICE_MAP_COMPATIBLE;

//Since REDSTONE1 (14393)
typedef struct _DEVICE_MAP_V2 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PVOID DosDevicesDirectoryHandle;
    volatile LONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[32];
    PEJOB ServerSilo;
} DEVICE_MAP_V2, * PDEVICE_MAP_V2;

//Since W11 (22000)
typedef struct _DEVICE_MAP_V3 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PEJOB ServerSilo;
    struct _DEVICE_MAP* GlobalDeviceMap;
    EX_FAST_REF DriveObject[26];
    LONGLONG ReferenceCount;
    PVOID DosDevicesDirectoryHandle;
    ULONG DriveMap;
    UCHAR DriveType[32];
} DEVICE_MAP_V3, PDEVICE_MAP_V3;

/*
** OBJECT MANAGER END
*/

/*
* WDM START
*/
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
    union {
        union {
            volatile LONG Lock;
            LONG LockNV;
        } DUMMYUNIONNAME;

        struct {                            // Events, Semaphores, Gates, etc.
            UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        } DUMMYSTRUCTNAME;

        struct {                            // Timer
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                } DUMMYSTRUCTNAME;
            };

            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

                    UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;
        } DUMMYSTRUCTNAME2;

        struct {                            // Timer2
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR Timer2Reserved1;
            UCHAR Timer2Reserved2;
        } DUMMYSTRUCTNAME3;

        struct {                            // Queue
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR QueueSize;
            UCHAR QueueReserved;
        } DUMMYSTRUCTNAME4;

        struct {                            // Thread
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR ThreadReservedControlFlags : 4;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            union {
                UCHAR DebugActive;

#if !defined(_X86_)

                struct {
                    BOOLEAN ActiveDR7 : 1;
                    BOOLEAN Instrumented : 1;
                    BOOLEAN Minimal : 1;
                    BOOLEAN Reserved4 : 3;
                    BOOLEAN UmsScheduled : 1;
                    BOOLEAN UmsPrimary : 1;
                } DUMMYSTRUCTNAME;

#endif

            } DUMMYUNIONNAME2;
        } DUMMYSTRUCTNAME5;

        struct {                         // Mutant
            UCHAR MutantType;
            UCHAR MutantSize;
            BOOLEAN DpcActive;
            UCHAR MutantReserved;
        } DUMMYSTRUCTNAME6;
    } DUMMYUNIONNAME;

    LONG SignalState;                   // Object lock
    LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _FAST_MUTEX {
    LONG_PTR Count;
    void *Owner;
    ULONG Contention;
    struct _KEVENT Event;
    ULONG OldIrql;
    LONG __PADDING__[1];
} FAST_MUTEX, *PFAST_MUTEX;

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    ULONG Processor;
    LONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

typedef struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    SINGLE_LIST_ENTRY DpcListEntry;
    KAFFINITY ProcessorHistory;
    PVOID DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _WAIT_CONTEXT_BLOCK {
    union {
        KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG Reserved : 30;
        };
    };
    PVOID DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE;

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

enum _KOBJECTS {
    EventNotificationObject = 0x0,
    EventSynchronizationObject = 0x1,
    MutantObject = 0x2,
    ProcessObject = 0x3,
    QueueObject = 0x4,
    SemaphoreObject = 0x5,
    ThreadObject = 0x6,
    GateObject = 0x7,
    TimerNotificationObject = 0x8,
    TimerSynchronizationObject = 0x9,
    Spare2Object = 0xa,
    Spare3Object = 0xb,
    Spare4Object = 0xc,
    Spare5Object = 0xd,
    Spare6Object = 0xe,
    Spare7Object = 0xf,
    Spare8Object = 0x10,
    Spare9Object = 0x11,
    ApcObject = 0x12,
    DpcObject = 0x13,
    DeviceQueueObject = 0x14,
    EventPairObject = 0x15,
    InterruptObject = 0x16,
    ProfileObject = 0x17,
    ThreadedDpcObject = 0x18,
    MaximumKernelObject = 0x19,
};

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000
#define DO_DEVICE_TO_BE_RESET           0x04000000      
#define DO_DAX_VOLUME                   0x10000000    

#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041
#define FILE_DEVICE_MT_COMPOSITE        0x00000042
#define FILE_DEVICE_MT_TRANSPORT        0x00000043
#define FILE_DEVICE_BIOMETRIC           0x00000044
#define FILE_DEVICE_PMI                 0x00000045
#define FILE_DEVICE_EHSTOR              0x00000046
#define FILE_DEVICE_DEVAPI              0x00000047
#define FILE_DEVICE_GPIO                0x00000048
#define FILE_DEVICE_USBEX               0x00000049
#define FILE_DEVICE_CONSOLE             0x00000050
#define FILE_DEVICE_NFP                 0x00000051
#define FILE_DEVICE_SYSENV              0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK       0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE    0x00000054
#define FILE_DEVICE_STORAGE_REPLICATION 0x00000055
#define FILE_DEVICE_TRUST_ENV           0x00000056
#define FILE_DEVICE_UCM                 0x00000057
#define FILE_DEVICE_UCMTCPCI            0x00000058
#define FILE_DEVICE_PERSISTENT_MEMORY   0x00000059
#define FILE_DEVICE_NVDIMM              0x0000005a
#define FILE_DEVICE_HOLOGRAPHIC         0x0000005b
#define FILE_DEVICE_SDFXHCI             0x0000005c
#define FILE_DEVICE_UCMUCSI             0x0000005d

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
    struct _IRP* CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    __volatile PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
    PVOID  Reserved;

} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT* PDEVICE_OBJECT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    // end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
    // WARNING: Access via PO macros
    // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
    // Set in the filesystem's volume device object.
    // This is a reverse VPB pointer.

    // begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PVOID FastIoCheckIfPossible;
    PVOID FastIoRead;
    PVOID FastIoWrite;
    PVOID FastIoQueryBasicInfo;
    PVOID FastIoQueryStandardInfo;
    PVOID FastIoLock;
    PVOID FastIoUnlockSingle;
    PVOID FastIoUnlockAll;
    PVOID FastIoUnlockAllByKey;
    PVOID FastIoDeviceControl;
    PVOID AcquireFileForNtCreateSection;
    PVOID ReleaseFileForNtCreateSection;
    PVOID FastIoDetachDevice;
    PVOID FastIoQueryNetworkOpenInfo;
    PVOID AcquireForModWrite;
    PVOID MdlRead;
    PVOID MdlReadComplete;
    PVOID PrepareMdlWrite;
    PVOID MdlWriteComplete;
    PVOID FastIoReadCompressed;
    PVOID FastIoWriteCompressed;
    PVOID MdlReadCompleteCompressed;
    PVOID MdlWriteCompleteCompressed;
    PVOID FastIoQueryOpen;
    PVOID ReleaseForModWrite;
    PVOID AcquireForCcFlush;
    PVOID ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

// Public structure
typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PVOID AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

// Private, since 7.1
typedef struct _DRIVER_EXTENSION_V2 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
} DRIVER_EXTENSION_V2, * PDRIVER_EXTENSION_V2;

// Private, since 8.0
typedef struct _DRIVER_EXTENSION_V3 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
} DRIVER_EXTENSION_V3, * PDRIVER_EXTENSION_V3;

// Private, since 8.1
typedef struct _DRIVER_EXTENSION_V4 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
    PVOID VerifierContext;
} DRIVER_EXTENSION_V4, * PDRIVER_EXTENSION_V4;

// Private, since 11 25XXX
typedef struct _DRIVER_EXTENSION_V5 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
    PVOID VerifierContext;
    struct _DRIVER_PROXY_EXTENSION* DriverProxyExtension;
} DRIVER_EXTENSION_V5, * PDRIVER_EXTENSION_V5; /* size: 0x0058 */

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection; //PLDR_DATA_TABLE_ENTRY
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PVOID DriverInit;
    PVOID DriverStartIo;
    PVOID DriverUnload;
    PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;

//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS* PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, * PIO_COMPLETION_CONTEXT;

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT* RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    __volatile ULONG Waiters;
    __volatile ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    __volatile PIO_COMPLETION_CONTEXT CompletionContext;
    KSPIN_LOCK IrpListLock;
    LIST_ENTRY IrpList;
    __volatile PVOID FileObjectExtension;
} FILE_OBJECT;
typedef struct _FILE_OBJECT* PFILE_OBJECT;

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD* PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

/*
* WDM END
*/

/*
* MM START
*/
typedef ULONG MMSECTION_FLAGS2;

typedef struct _MMEXTEND_INFO {
    ULONG_PTR CommittedSize;
    ULONG ReferenceCount;
} MMEXTEND_INFO, * PMMEXTEND_INFO; /* size: 0x0010 */

//
// Flags definitions valid only for Windows 10.
//
typedef struct _MMSECTION_FLAGS {
    struct {
        UINT BeingDeleted : 1; /* bit position: 0 */
        UINT BeingCreated : 1; /* bit position: 1 */
        UINT BeingPurged : 1; /* bit position: 2 */
        UINT NoModifiedWriting : 1; /* bit position: 3 */
        UINT FailAllIo : 1; /* bit position: 4 */
        UINT Image : 1; /* bit position: 5 */
        UINT Based : 1; /* bit position: 6 */
        UINT File : 1; /* bit position: 7 */
        UINT AttemptingDelete : 1; /* bit position: 8 */
        UINT PrefetchCreated : 1; /* bit position: 9 */
        UINT PhysicalMemory : 1; /* bit position: 10 */
        UINT ImageControlAreaOnRemovableMedia : 1; /* bit position: 11 */  //CopyOnWrite
        UINT Reserve : 1; /* bit position: 12 */
        UINT Commit : 1; /* bit position: 13 */
        UINT NoChange : 1; /* bit position: 14 */
        UINT WasPurged : 1; /* bit position: 15 */
        UINT UserReference : 1; /* bit position: 16 */
        UINT GlobalMemory : 1; /* bit position: 17 */
        UINT DeleteOnClose : 1; /* bit position: 18 */
        UINT FilePointerNull : 1; /* bit position: 19 */
        UINT PreferredNode : 6; /* bit position: 20 */
        UINT GlobalOnlyPerSession : 1; /* bit position: 26 */
        UINT UserWritable : 1; /* bit position: 27 */
        UINT SystemVaAllocated : 1; /* bit position: 28 */
        UINT PreferredFsCompressionBoundary : 1; /* bit position: 29 */
        UINT UsingFileExtents : 1; /* bit position: 30 */
        UINT PageSize64K : 1; /* bit position: 31 */
    };
} MMSECTION_FLAGS, * PMMSECTION_FLAGS; /* size: 0x0004 */

//
// Flags definitions valid only for Windows 10.
//
typedef struct _SEGMENT_FLAGS {
    union {
        struct {
            USHORT TotalNumberOfPtes4132 : 10; /* bit position: 0 */
            USHORT Spare0 : 2; /* bit position: 10 */
            USHORT LargePages : 1; /* bit position: 12 */
            USHORT DebugSymbolsLoaded : 1; /* bit position: 13 */
            USHORT WriteCombined : 1; /* bit position: 14 */
            USHORT NoCache : 1; /* bit position: 15 */
        }; 
        USHORT Short0;
    }; /* size: 0x0002 */
    union {
        struct {
            UCHAR FloppyMedia : 1; /* bit position: 0 */
            UCHAR DefaultProtectionMask : 5; /* bit position: 1 */
            UCHAR Binary32 : 1; /* bit position: 6 */
            UCHAR ContainsDebug : 1; /* bit position: 7 */
        };
        UCHAR UChar1;
    }; /* size: 0x0001 */
    union {
        struct {
            UCHAR ForceCollision : 1; /* bit position: 0 */
            UCHAR ImageSigningType : 3; /* bit position: 1 */
            UCHAR ImageSigningLevel : 4; /* bit position: 4 */
        };
        UCHAR UChar2;
    };
} SEGMENT_FLAGS, * PSEGMENT_FLAGS; /* size: 0x0004 */

typedef struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
    union {
        ULONGLONG NumberOfPtes : 6;
        ULONGLONG PartitionId : 10;
        ULONGLONG Spare : 2;
        ULONGLONG SectionOffset : 48;
    } u1;
} MI_SYSTEM_CACHE_VIEW_ATTRIBUTES, * PMI_SYSTEM_CACHE_VIEW_ATTRIBUTES;

#define VIEW_MAP_TYPE_PROCESS         1
#define VIEW_MAP_TYPE_SESSION         2
#define VIEW_MAP_TYPE_SYSTEM_CACHE    3

typedef struct _MI_REVERSE_VIEW_MAP {
    struct _LIST_ENTRY ViewLinks;
    union {
        VOID* SystemCacheVa;
        VOID* SessionViewVa;
        struct _EPROCESS* VadsProcess;
        ULONG Type : 2;
    } u1;
    union {
        struct _SUBSECTION* Subsection;
        ULONG SubsectionType : 1;
    } u2;
    union {
        struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES SystemCacheAttributes;
        ULONGLONG AllAttributes; //Since W11
        ULONGLONG SectionOffset;
    } u3;
} MI_REVERSE_VIEW_MAP, * PMI_REVERSE_VIEW_MAP; /* size: 0x0028 */

typedef struct _RTL_BALANCED_NODE {
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE* Left;
            struct _RTL_BALANCED_NODE* Right;
        };
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    };
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _SEGMENT {

    struct _CONTROL_AREA* ControlArea;
    unsigned long TotalNumberOfPtes;
    SEGMENT_FLAGS SegmentFlags;
    ULONG_PTR NumberOfCommittedPages;
    ULONG_PTR SizeOfSegment;

    union {
        struct _MMEXTEND_INFO* ExtendInfo;
        void* BasedAddress;
    } u1;

    EX_PUSH_LOCK SegmentLock;

    union {
        union {
            ULONG_PTR ImageCommitment;
            ULONG CreatingProcessId;
        };
    } u2;

    union {
        union {
            struct _MI_SECTION_IMAGE_INFORMATION* ImageInformation;
            void* FirstMappedVa;
        };
    } u3;

    struct _MMPTE* PrototypePte;

} SEGMENT, * PSEGMENT;  /* size: 0x0048 */

typedef struct _CONTROL_AREA_COMPAT {

    SEGMENT* Segment;
    LIST_ENTRY ListHead;
    ULONG_PTR NumberOfSectionReferences;
    ULONG_PTR NumberOfPfnReferences;
    ULONG_PTR NumberOfMappedViews;
    ULONG_PTR NumberOfUserReferences;

    union {
        union {
            ULONG LongFlags;
            MMSECTION_FLAGS Flags;
        };
    } u;

    union {
        union {
            ULONG LongFlags;
            MMSECTION_FLAGS2 Flags;
        };
    } u1;

    EX_FAST_REF FilePointer;
    volatile LONG ControlAreaLock;
    ULONG ModifiedWriteCount;
    struct _MI_CONTROL_AREA_WAIT_BLOCK* WaitList;

    union
    {
        struct
        {
            union
            {
                ULONG NumberOfSystemCacheViews;
                ULONG ImageRelocationStartBit;
            };
            union
            {
                volatile LONG WritableUserReferences;
                struct // version dependent, this bitset is not valid for w11
                {
                    unsigned long ImageRelocationSizeIn64k : 16; /* bit position: 0 */
                    unsigned long LargePage : 1; /* bit position: 16 */
                    unsigned long SystemImage : 1; /* bit position: 17 */
                    unsigned long StrongCode : 2; /* bit position: 18 */
                    unsigned long CantMove : 1; /* bit position: 20 */
                    unsigned long BitMap : 2; /* bit position: 21 */
                    unsigned long ImageActive : 1; /* bit position: 23 */
                };
            };
            union
            {
                ULONG FlushInProgressCount;
                ULONG NumberOfSubsections;
                struct _MI_IMAGE_SECURITY_REFERENCE* SeImageStub;
            };
        } e2;
    } u2;

    //
    // Incomplete definition, tail is version dependent.
    //

} CONTROL_AREA_COMPAT, * PCONTROL_AREA_COMPAT;

//
// N.B. 
// Only valid for Win10.
// Change between Win10 versions.
//
typedef struct _MMVAD_SHORT {
    union
    {
        struct
        {
            struct _MMVAD_SHORT* NextVad;
            void* ExtraCreateInfo;
        };
        struct _RTL_BALANCED_NODE VadNode;
    };

    ULONG StartingVpn;
    ULONG EndingVpn;
    UCHAR StartingVpnHigh;
    UCHAR EndingVpnHigh;
    UCHAR CommitChargeHigh;
    UCHAR SpareNT64VadUChar;
    LONG ReferenceCount;
    EX_PUSH_LOCK PushLock;

    ULONG LongFlags;
    ULONG LongFlags1;

    struct _MI_VAD_EVENT_BLOCK* EventList;

} MMVAD_SHORT, * PMMVAD_SHORT;  /* size: 0x0040 */

typedef struct _MI_VAD_SEQUENTIAL_INFO {

    struct {
#if defined(_AMD64_)
        ULONG_PTR Length : 12; /* bit position: 0 */
        ULONG_PTR Vpn : 52; /* bit position: 12 */
#else
        ULONG Length : 11; /* bit position: 0 */
        ULONG Vpn : 21; /* bit position: 11 */
#endif
    };

} MI_VAD_SEQUENTIAL_INFO, * PMI_VAD_SEQUENTIAL_INFO;

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS {
    struct
    {
        ULONG VadType : 3; /* bit position: 0 */
        ULONG Protection : 5; /* bit position: 3 */
        ULONG PreferredNode : 6; /* bit position: 8 */
        ULONG PrivateMemory : 1; /* bit position: 14 */
        ULONG PrivateFixup : 1; /* bit position: 15 */
        ULONG Enclave : 1; /* bit position: 16 */
        ULONG PageSize64K : 1; /* bit position: 17 */
        ULONG RfgControlStack : 1; /* bit position: 18 */
        ULONG Spare : 8; /* bit position: 19 */
        ULONG NoChange : 1; /* bit position: 27 */
        ULONG ManySubsections : 1; /* bit position: 28 */
        ULONG DeleteInProgress : 1; /* bit position: 29 */
        ULONG LockContended : 1; /* bit position: 30 */
        ULONG Lock : 1; /* bit position: 31 */
    };
} MMVAD_FLAGS, * PMMVAD_FLAGS; /* size: 0x0004 */

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS1 {
    struct
    {
        ULONG CommitCharge : 31; /* bit position: 0 */
        ULONG MemCommit : 1; /* bit position: 31 */
    };
} MMVAD_FLAGS1, * PMMVAD_FLAGS1; /* size: 0x0004 */

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS2 {
    struct
    {
        ULONG FileOffset : 24; /* bit position: 0 */
        ULONG Large : 1; /* bit position: 24 */
        ULONG TrimBehind : 1; /* bit position: 25 */
        ULONG Inherit : 1; /* bit position: 26 */
        ULONG NoValidationNeeded : 1; /* bit position: 27 */
        ULONG PrivateDemandZero : 1; /* bit position: 28 */
        ULONG Spare : 3; /* bit position: 29 */
    };
} MMVAD_FLAGS2, * PMMVAD_FLAGS2; /* size: 0x0004 */

typedef struct _MMVAD {

    struct _MMVAD_SHORT Core;

    union
    {
        union
        {
            ULONG LongFlags2;
            volatile struct _MMVAD_FLAGS2 VadFlags2;
        };
    } u2;

    struct _SUBSECTION* Subsection;
    struct _MMPTE* FirstPrototypePte;
    struct _MMPTE* LastContiguousPte;
    LIST_ENTRY ViewLinks;
    struct _EPROCESS* VadsProcess;

    union
    {
        union
        {
            struct _MI_VAD_SEQUENTIAL_INFO SequentialVa;
            struct _MMEXTEND_INFO* ExtendedInfo;
        };
    } u4;

    FILE_OBJECT* FileObject;

} MMVAD, * PMMVAD; /* size: 0x0088 */

typedef struct _MMVIEW {
    ULONGLONG Entry;
    union {
        ULONGLONG Writable : 1;
        struct _CONTROL_AREA* ControlArea; 
    };
    LIST_ENTRY ViewLinks; 
    PVOID SessionViewVa;
    ULONG SessionId;
} MMVIEW, *PMMVIEW;

typedef struct _MI_IMAGE_ENTRY_IN_SESSION {
    LIST_ENTRY Link;
    PVOID Address;

    //
    // Incomplete and incorrect.
    //

} MI_IMAGE_ENTRY_IN_SESSION, * PMI_IMAGE_ENTRY_IN_SESSION;

typedef struct _SUBSECTION_COMPAT {

    struct _CONTROL_AREA* ControlArea;
    struct _MMPTE* SubsectionBase;
    struct _SUBSECTION* NextSubsection;

    //
    // Incomplete definition.
    //

} SUBSECTION_COMPAT, * PSUBSECTION_COMPAT;

//
// This is Windows 10 only Section Object definition.
// 
// N.B. It completely differs from anything else.
//
typedef struct _SECTION_COMPAT {

    RTL_BALANCED_NODE SectionNode;
    ULONG_PTR StartingVpn;
    ULONG_PTR EndingVpn;

    union {
        union {
            struct _CONTROL_AREA* ControlArea;
            struct _FILE_OBJECT* FileObject;
            struct {
                ULONG_PTR RemoteImageFileObject : 1; /* bit position: 0 */
                ULONG_PTR RemoteDataFileObject : 1; /* bit position: 1 */
            };
        };
    } u1;

    ULONG_PTR SizeOfSection;

    union {
        ULONG LongFlags;
        MMSECTION_FLAGS Flags;
    } u;

    struct {
        ULONG InitialPageProtection : 12; /* bit position: 0 */
        ULONG SessionId : 19; /* bit position: 12 */
        ULONG NoValidationNeeded : 1; /* bit position: 31 */
    };

} SECTION_COMPAT, * PSECTION_COMPAT;  /* size: 0x0040 */

/*
* MM END
*/

/*
*  Configuration Manager control vector
*/
typedef struct _CM_SYSTEM_CONTROL_VECTOR_V1 {
    PWSTR  KeyPath;
    PWSTR  ValueName;
    PVOID  Buffer;
    PULONG BufferLength;
    PULONG Type;
} CM_SYSTEM_CONTROL_VECTOR_V1, * PCM_SYSTEM_CONTROL_VECTOR_V1;

//
// Since Windows 10 RS4
//
typedef struct _CM_SYSTEM_CONTROL_VECTOR_V2 {
    PWSTR  KeyPath;
    PWSTR  ValueName;
    PVOID  Buffer;
    PULONG BufferLength;
    PULONG Type;
    ULONG Flags; //0 or 1 depends on flag from LOADER_PARAMETER_BLOCK attached hives
    ULONG Spare0;
} CM_SYSTEM_CONTROL_VECTOR_V2, * PCM_SYSTEM_CONTROL_VECTOR_V2;

/*
** Callbacks START
*/

typedef NTSTATUS(*PEX_CALLBACK_FUNCTION) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

typedef VOID(NTAPI* PEX_HOST_NOTIFICATION) (
    _In_ ULONG NotificationType,
    _In_opt_ PVOID Context);

typedef struct _EX_EXTENSION_INFORMATION_V1 {
    USHORT Id;
    USHORT Version;
    USHORT FunctionCount;
} EX_EXTENSION_INFORMATION_V1, * PEX_EXTENSION_INFORMATION_V1;

typedef struct _EX_EXTENSION_VERSION {
    USHORT MajorVersion;
    USHORT MinorVersion;
} EX_EXTENSION_VERSION, * PEX_EXTENSION_VERSION;

typedef struct _EX_EXTENSION_INFORMATION_V2 {
    USHORT Id;
    EX_EXTENSION_VERSION Version;
    USHORT FunctionCount;
} EX_EXTENSION_INFORMATION_V2, * PEX_EXTENSION_INFORMATION_V2;

typedef struct _EX_HOST_TABLE {
    EX_EXTENSION_INFORMATION_V2 HostInformation;
    PVOID FunctionTable; //calbacks
} EX_HOST_TABLE, * PEX_HOST_TABLE;

typedef struct _EX_HOST_PARAMS {
    EX_EXTENSION_INFORMATION_V1 HostInformation;
    POOL_TYPE PoolType;
    PVOID HostTable;
    PVOID NotificationRoutine;
    PVOID NotificationContext;
} EX_HOST_PARAMS, * PEX_HOST_PARAMS;

typedef struct _EX_HOST_ENTRY_V1 {
    LIST_ENTRY ListEntry;
    LONG RefCounter;
    EX_HOST_PARAMS HostParameters;
    EX_RUNDOWN_REF RundownProtection;
    EX_PUSH_LOCK PushLock;
    PVOID FunctionTable; //callbacks
    ULONG Flags;
} EX_HOST_ENTRY_V1, * PEX_HOST_ENTRY_V1;

typedef struct _EX_HOST_ENTRY_V2 {
    LIST_ENTRY ListEntry;
    EX_EXTENSION_INFORMATION_V2 HostInformation;
    ULONG64 RefCounter;
    EX_PUSH_LOCK PushLock;
    PEX_HOST_TABLE HostTablesPtr;
    USHORT HostTablesCount;
    PEX_HOST_TABLE CurrentHostTableEntry; //only set when an extension registers
    PVOID NotificationRoutine;
    PVOID NotificationContext;
    EX_EXTENSION_VERSION ExtensionVersion;
    EX_RUNDOWN_REF RundownProtection;
    PVOID FunctionTable;
    USHORT ExtensionTableFunctionCount;
    ULONG Pad;
    ULONG Flags;
    EX_HOST_TABLE HostTables[1];
} EX_HOST_ENTRY_V2, * PEX_HOST_ENTRY_V2;

typedef struct _EX_EXTENSION_REGISTRATION {
    EX_EXTENSION_INFORMATION_V1 Information;
    PVOID FunctionTable;
    PVOID* HostTable;
    PDRIVER_OBJECT DriverObject;
} EX_EXTENSION_REGISTRATION, * PEX_EXTENSION_REGISTRATION;

typedef struct _EX_CALLBACK {
    EX_FAST_REF RoutineBlock;
} EX_CALLBACK, *PEX_CALLBACK;

typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF RundownProtect;
    PVOID Function; //PEX_CALLBACK_FUNCTION
    PVOID Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
    KbCallbackAddPages,
    KbCallbackSecondaryMultiPartDumpData,
    KbCallbackRemovePages,
    KbCallbackTriageDumpData
} KBUGCHECK_CALLBACK_REASON;

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    LONG PreCallListHead;
    LARGE_INTEGER Cookie;
    PVOID CallerContext; 
    PEX_CALLBACK_FUNCTION Function;
    UNICODE_STRING Altitude;
    LIST_ENTRY ObjectContextListHead;
} CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;

typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION {
    struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION *Next;
    PVOID CallbackRoutine; //PSE_LOGON_SESSION_TERMINATED_ROUTINE
} SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, *PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

typedef struct _NOTIFICATION_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DriverObject; //PDRIVER_OBJECT
    PVOID NotificationRoutine; //PDRIVER_FS_NOTIFICATION
} NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DeviceObject; //PDEVICE_OBJECT
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

#define EX_CALLBACK_SIGNATURE 'llaC'

typedef struct _CALLBACK_OBJECT {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    UCHAR reserved[3];
} CALLBACK_OBJECT, *PCALLBACK_OBJECT;

// Since 8.1
typedef struct _CALLBACK_OBJECT_V2 {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    LIST_ENTRY ExpCallbackList;
} CALLBACK_OBJECT_V2, * PCALLBACK_OBJECT_V2;

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY Link;
    PCALLBACK_OBJECT CallbackObject;
    PVOID CallbackFunction; //PCALLBACK_FUNCTION
    PVOID CallbackContext;
    ULONG Busy;
    BOOLEAN UnregisterWaiting;
} CALLBACK_REGISTRATION, *PCALLBACK_REGISTRATION;

typedef ULONG OB_OPERATION;

#define OB_OPERATION_HANDLE_CREATE              0x00000001
#define OB_OPERATION_HANDLE_DUPLICATE           0x00000002

typedef struct _OB_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    OB_OPERATION Operations;
    ULONG Flags;
    struct _OB_REGISTRATION* Registration;
    POBJECT_TYPE ObjectType;
    PVOID PreCallback;
    PVOID PostCallback;
    EX_RUNDOWN_REF RundownReference;
} OB_CALLBACK_CONTEXT_BLOCK, *POB_CALLBACK_CONTEXT_BLOCK;

typedef struct _OB_REGISTRATION {
    USHORT Version;
    USHORT RegistrationCount;
    PVOID  RegistrationContext;
    UNICODE_STRING Altitude;
    OB_CALLBACK_CONTEXT_BLOCK* CallbackContext;
} OB_REGISTRATION, * POB_REGISTRATION;

#define PO_POWER_SETTINGS_REGISTRATION_TAG 'teSP'

typedef struct _POP_POWER_SETTING_REGISTRATION_V1 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V1, *PPOP_POWER_SETTING_REGISTRATION_V1;

//
// WARNING: this structure definition is incomplete. 
// Tail is incorrect/incomplete for newest Win10 versions.
//
typedef struct _POP_POWER_SETTING_REGISTRATION_V2 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD   
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    GUID Guid2;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V2, *PPOP_POWER_SETTING_REGISTRATION_V2;

typedef struct _RTL_CALLBACK_REGISTER {
    ULONG Flags;
    EX_RUNDOWN_REF RundownReference;
    PVOID DebugPrintCallback;
    LIST_ENTRY ListEntry;
} RTL_CALLBACK_REGISTER, *PRTL_CALLBACK_REGISTER;

typedef
VOID
(*PPO_COALESCING_CALLBACK) (
    _In_ ULONG Reason,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID Context);

typedef struct _PO_COALESCING_CALLBACK_V1 {
    EX_PUSH_LOCK PushLock;
    PVOID CoalescingCallback;
    PVOID SelfPtr;
    PPO_COALESCING_CALLBACK Callback;
    BOOLEAN ClientOrServer;
    PVOID Context;
} PO_COALESCING_CALLBACK_V1, * PPO_COALESCING_CALLBACK_V1;

typedef struct _PO_COALESCING_CALLBACK_V2 {
    EX_PUSH_LOCK PushLock;
    PVOID CoalescingCallback;
    PVOID SelfPtr;
    PPO_COALESCING_CALLBACK Callback;
    BOOLEAN ClientOrServer;
    PVOID Context;
    LIST_ENTRY Link;
    EX_CALLBACK ExCallback;
} PO_COALESCING_CALLBACK_V2, * PPO_COALESCING_CALLBACK_V2;

typedef
BOOLEAN
(*PNMI_CALLBACK)(
    __in_opt PVOID Context,
    __in BOOLEAN Handled
    );

typedef struct _KNMI_HANDLER_CALLBACK {
    struct _KNMI_HANDLER_CALLBACK* Next;
    PNMI_CALLBACK Callback;
    PVOID Context;
    PVOID Handle;
} KNMI_HANDLER_CALLBACK, * PKNMI_HANDLER_CALLBACK;

typedef
NTSTATUS
(NTAPI* SILO_MONITOR_CREATE_CALLBACK)(
    _In_ PESILO Silo
    );

typedef
VOID
(NTAPI* SILO_MONITOR_TERMINATE_CALLBACK)(
    _In_ PESILO Silo
    );

#define SILO_MONITOR_REGISTRATION_VERSION (1)

typedef struct _SERVER_SILO_MONITOR {
    LIST_ENTRY ListEntry;
    UCHAR Version;
    BOOLEAN MonitorHost;
    BOOLEAN MonitorExistingSilos;
    UCHAR Reserved[5];
    SILO_MONITOR_CREATE_CALLBACK CreateCallback;
    SILO_MONITOR_TERMINATE_CALLBACK TerminateCallback;
    union {
        PUNICODE_STRING DriverObjectName;
        PUNICODE_STRING ComponentName;
    };
} SERVER_SILO_MONITOR, * PSERVER_SILO_MONITOR;

//
// Errata Manager
//
typedef struct _EMP_CALLBACK_DB_RECORD {
    GUID CallbackId;
    PVOID CallbackFunc;
    LONG_PTR CallbackFuncReference;
    PVOID Context;
    SINGLE_LIST_ENTRY List;
    SINGLE_LIST_ENTRY CallbackDependencyListHead;
    ULONG NumberOfStrings;
    ULONG NumberOfNumerics;
    ULONG NumberOfEntries;
    struct _EMP_ENTRY_DB_RECORD* EntryList[1];
} EMP_CALLBACK_DB_RECORD, * PEMP_CALLBACK_DB_RECORD;

typedef struct _EMP_CALLBACK_LIST_ENTRY {
    EMP_CALLBACK_DB_RECORD* CallbackRecord;
    SINGLE_LIST_ENTRY CallbackListEntry;
} EMP_CALLBACK_LIST_ENTRY, * PEMP_CALLBACK_LIST_ENTRY;

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

typedef
NTSTATUS
(*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
    IN PVOID NotificationStructure,
    IN PVOID Context
    );

typedef struct _KGUARDED_MUTEX {
    LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Event;
    union {
        struct {
            SHORT KernelApcDisable;
            SHORT SpecialApcDisable;
        };

        ULONG CombinedApcDisable;
    };

} KGUARDED_MUTEX, * PKGUARDED_MUTEX;

typedef struct _DEVICE_CLASS_NOTIFY_ENTRY {

    // 
    // Header entries 
    // 

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    HANDLE SessionHandle;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PKGUARDED_MUTEX Lock;
    PERESOURCE EntryLock;
    // 
    // ClassGuid - the guid of the device class we are interested in 
    // 

    GUID ClassGuid;

} DEVICE_CLASS_NOTIFY_ENTRY, * PDEVICE_CLASS_NOTIFY_ENTRY;

/*
** Callbacks END
*/

/*
*  NTQSI Modules START
*/

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

/*
*	NTQSI Modules END
*/

/*
** Virtual Memory START
*/

typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation = 0,
    MemoryWorkingSetInformation,
    MemoryMappedFilenameInformation,
    MemoryRegionInformation,
    MemoryWorkingSetExInformation,
    MemorySharedCommitInformation,
    MemoryImageInformation,
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation,
    MemoryBasicInformationCapped,
    MemoryPhysicalContiguityInformation,
    MemoryBadInformation,
    MemoryBadInformationAllProcesses,
    MaxMemoryInfoClass
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
    VmPrefetchInformation,
    VmPagePriorityInformation,
    VmCfgCallTargetInformation,
    VmPageDirtyStateInformation
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1;
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_REGION_INFORMATION_V2 {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // RS3
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
} MEMORY_REGION_INFORMATION_V2, * PMEMORY_REGION_INFORMATION_V2;

typedef struct _MEMORY_REGION_INFORMATION_V3 {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // RS3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // RS4
            ULONG MappedAwe : 1; // 21H1
            ULONG MappedWriteWatch : 1;
            ULONG PageSizeLarge : 1;
            ULONG PageSizeHuge : 1;
            ULONG Reserved : 19;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
    ULONG_PTR NodePreference; // 20H1
} MEMORY_REGION_INFORMATION_V3, * PMEMORY_REGION_INFORMATION_V3;

typedef struct _MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

typedef struct _MEMORY_IMAGE_INFORMATION {
    PVOID ImageBase;
    SIZE_T SizeOfImage;
    union
    {
        ULONG ImageFlags;
        struct
        {
            ULONG ImagePartialMap : 1;
            ULONG ImageNotExecutable : 1;
            ULONG ImageSigningLevel : 4; // RS3
            ULONG ImageExtensionPresent : 1; // 24H2
            ULONG Reserved : 25;
        };
    };
} MEMORY_IMAGE_INFORMATION, * PMEMORY_IMAGE_INFORMATION;

typedef struct _MEMORY_ENCLAVE_IMAGE_INFORMATION {
    MEMORY_IMAGE_INFORMATION ImageInfo;
    UCHAR UniqueID[32];
    UCHAR AuthorID[32];
} MEMORY_ENCLAVE_IMAGE_INFORMATION, * PMEMORY_ENCLAVE_IMAGE_INFORMATION;

typedef struct _MEMORY_WORKING_SET_BLOCK {
    ULONG_PTR Protection : 5;
    ULONG_PTR ShareCount : 3;
    ULONG_PTR Shared : 1;
    ULONG_PTR Node : 3;
#ifdef _WIN64
    ULONG_PTR VirtualPage : 52;
#else
    ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, * PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION {
    ULONG_PTR NumberOfEntries;
    _Field_size_(NumberOfEntries) MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, * PMEMORY_WORKING_SET_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_BLOCK {
    union {
        struct {
            ULONG_PTR Valid : 1;
            ULONG_PTR ShareCount : 3;
            ULONG_PTR Win32Protection : 11;
            ULONG_PTR Shared : 1;
            ULONG_PTR Node : 6;
            ULONG_PTR Locked : 1;
            ULONG_PTR LargePage : 1;
            ULONG_PTR Priority : 3;
            ULONG_PTR Reserved : 3;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
            ULONG_PTR Win32GraphicsProtection : 4;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 28;
#endif
        };
        struct {
            ULONG_PTR Valid : 1;
            ULONG_PTR Reserved0 : 14;
            ULONG_PTR Shared : 1;
            ULONG_PTR Reserved1 : 5;
            ULONG_PTR PageTable : 1;
            ULONG_PTR Location : 2;
            ULONG_PTR Priority : 3;
            ULONG_PTR ModifiedList : 1;
            ULONG_PTR Reserved2 : 2;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 32;
#endif
        } Invalid;
    };
} MEMORY_WORKING_SET_EX_BLOCK, * PMEMORY_WORKING_SET_EX_BLOCK;

typedef struct _MEMORY_WORKING_SET_EX_INFORMATION {
    PVOID VirtualAddress;
    union {
        MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
        ULONG_PTR Long;
    } u1;
} MEMORY_WORKING_SET_EX_INFORMATION, * PMEMORY_WORKING_SET_EX_INFORMATION;

#define MM_ZERO_ACCESS         0  // this value is not used.
#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define MM_NOCACHE            0x8
#define MM_GUARD_PAGE         0x10
#define MM_DECOMMIT           0x10   // NO_ACCESS, Guard page
#define MM_NOACCESS           0x18   // NO_ACCESS, Guard_page, nocache.
#define MM_UNKNOWN_PROTECTION 0x100  // bigger than 5 bits!

#define MM_INVALID_PROTECTION ((ULONG)-1)  // bigger than 5 bits!

#define MM_PROTECTION_WRITE_MASK     4
#define MM_PROTECTION_COPY_MASK      1
#define MM_PROTECTION_OPERATION_MASK 7 // mask off guard page and nocache.
#define MM_PROTECTION_EXECUTE_MASK   2

#define MM_SECURE_DELETE_CHECK 0x55

/*
** Virtual Memory END
*/

/*
** System Firmware START
*/

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

/*
** System Firmware END
*/

//
//  PEB/TEB
//
#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

// 32-bit definitions
typedef struct _STRING32 {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY32 HashLinks;
        struct
        {
            WOW64_POINTER(PVOID) SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        WOW64_POINTER(PVOID) LoadedImports;
    };
    WOW64_POINTER(PVOID) EntryPointActivationContext;
    WOW64_POINTER(PVOID) PatchInformation;
    LIST_ENTRY32 ForwarderLinks;
    LIST_ENTRY32 ServiceTagLinks;
    LIST_ENTRY32 StaticLinks;
    WOW64_POINTER(PVOID) ContextInformation;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32 {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PPVOID) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    // Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32 {
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32 {
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) SystemReserved1[54];
    NTSTATUS ExceptionCode;
    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    BYTE SpareBytes[36];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

#ifndef FLS_MAXIMUM_AVAILABLE
#define FLS_MAXIMUM_AVAILABLE 128
#endif

#ifndef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 64
#endif

#ifndef TLS_EXPANSION_SLOTS
#define TLS_EXPANSION_SLOTS 1024
#endif

#ifndef DOS_MAX_COMPONENT_LENGTH
#define DOS_MAX_COMPONENT_LENGTH 255
#endif

#ifndef DOS_MAX_PATH_LENGTH
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)
#endif

typedef struct _ACTIVATION_CONTEXT_DATA * PACTIVATION_CONTEXT_DATA;
typedef struct _ASSEMBLY_STORAGE_MAP * PASSEMBLY_STORAGE_MAP;

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;

    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING RedirectionDllName; // RS4
    UNICODE_STRING HeapPartitionName; // 19H1
    ULONG_PTR DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
    ULONG DefaultThreadpoolThreadMaximum;
    ULONG HeapMemoryTypeMask; // WIN11
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

#define FLG_STOP_ON_EXCEPTION 0x00000001
#define FLG_SHOW_LDR_SNAPS 0x00000002 
#define FLG_DEBUG_INITIAL_COMMAND 0x00000004 
#define FLG_STOP_ON_HUNG_GUI 0x00000008 
#define FLG_HEAP_ENABLE_TAIL_CHECK 0x00000010
#define FLG_HEAP_ENABLE_FREE_CHECK 0x00000020
#define FLG_HEAP_VALIDATE_PARAMETERS 0x00000040
#define FLG_HEAP_VALIDATE_ALL 0x00000080
#define FLG_APPLICATION_VERIFIER 0x00000100
#define FLG_MONITOR_SILENT_PROCESS_EXIT 0x00000200
#define FLG_POOL_ENABLE_TAGGING 0x00000400
#define FLG_HEAP_ENABLE_TAGGING 0x00000800
#define FLG_USER_STACK_TRACE_DB 0x00001000 
#define FLG_KERNEL_STACK_TRACE_DB 0x00002000
#define FLG_MAINTAIN_OBJECT_TYPELIST 0x00004000
#define FLG_HEAP_ENABLE_TAG_BY_DLL 0x00008000
#define FLG_DISABLE_STACK_EXTENSION 0x00010000 
#define FLG_ENABLE_CSRDEBUG 0x00020000
#define FLG_ENABLE_KDEBUG_SYMBOL_LOAD 0x00040000 
#define FLG_DISABLE_PAGE_KERNEL_STACKS 0x00080000
#define FLG_ENABLE_SYSTEM_CRIT_BREAKS 0x00100000
#define FLG_HEAP_DISABLE_COALESCING 0x00200000 
#define FLG_ENABLE_CLOSE_EXCEPTIONS 0x00400000 
#define FLG_ENABLE_EXCEPTION_LOGGING 0x00800000
#define FLG_ENABLE_HANDLE_TYPE_TAGGING 0x01000000 
#define FLG_HEAP_PAGE_ALLOCS 0x02000000
#define FLG_DEBUG_INITIAL_COMMAND_EX 0x04000000 
#define FLG_DISABLE_DBGPRINT 0x08000000
#define FLG_CRITSEC_EVENT_CREATION 0x10000000 
#define FLG_LDR_TOP_DOWN 0x20000000 
#define FLG_ENABLE_HANDLE_EXCEPTIONS 0x40000000
#define FLG_DISABLE_PROTDLLS 0x80000000

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PSLIST_HEADER AtlThunkSListPtr;
    PVOID IFEOKey;

    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1; // RS5
            ULONG ReservedBits0 : 24;
        };
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];

    PVOID ReadOnlySharedMemoryBase;
    struct _SILO_USER_SHARED_DATA* SharedData;
    PVOID* ReadOnlyStaticServerData;

    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    union
    {
        ULONG NtGlobalFlag;
        struct
        {
            ULONG StopOnException : 1;          // FLG_STOP_ON_EXCEPTION
            ULONG ShowLoaderSnaps : 1;          // FLG_SHOW_LDR_SNAPS
            ULONG DebugInitialCommand : 1;      // FLG_DEBUG_INITIAL_COMMAND
            ULONG StopOnHungGUI : 1;            // FLG_STOP_ON_HUNG_GUI
            ULONG HeapEnableTailCheck : 1;      // FLG_HEAP_ENABLE_TAIL_CHECK
            ULONG HeapEnableFreeCheck : 1;      // FLG_HEAP_ENABLE_FREE_CHECK
            ULONG HeapValidateParameters : 1;   // FLG_HEAP_VALIDATE_PARAMETERS
            ULONG HeapValidateAll : 1;          // FLG_HEAP_VALIDATE_ALL
            ULONG ApplicationVerifier : 1;      // FLG_APPLICATION_VERIFIER
            ULONG MonitorSilentProcessExit : 1; // FLG_MONITOR_SILENT_PROCESS_EXIT
            ULONG PoolEnableTagging : 1;        // FLG_POOL_ENABLE_TAGGING
            ULONG HeapEnableTagging : 1;        // FLG_HEAP_ENABLE_TAGGING
            ULONG UserStackTraceDb : 1;         // FLG_USER_STACK_TRACE_DB
            ULONG KernelStackTraceDb : 1;       // FLG_KERNEL_STACK_TRACE_DB
            ULONG MaintainObjectTypeList : 1;   // FLG_MAINTAIN_OBJECT_TYPELIST
            ULONG HeapEnableTagByDll : 1;       // FLG_HEAP_ENABLE_TAG_BY_DLL
            ULONG DisableStackExtension : 1;    // FLG_DISABLE_STACK_EXTENSION
            ULONG EnableCsrDebug : 1;           // FLG_ENABLE_CSRDEBUG
            ULONG EnableKDebugSymbolLoad : 1;   // FLG_ENABLE_KDEBUG_SYMBOL_LOAD
            ULONG DisablePageKernelStacks : 1;  // FLG_DISABLE_PAGE_KERNEL_STACKS
            ULONG EnableSystemCritBreaks : 1;   // FLG_ENABLE_SYSTEM_CRIT_BREAKS
            ULONG HeapDisableCoalescing : 1;    // FLG_HEAP_DISABLE_COALESCING
            ULONG EnableCloseExceptions : 1;    // FLG_ENABLE_CLOSE_EXCEPTIONS
            ULONG EnableExceptionLogging : 1;   // FLG_ENABLE_EXCEPTION_LOGGING
            ULONG EnableHandleTypeTagging : 1;  // FLG_ENABLE_HANDLE_TYPE_TAGGING
            ULONG HeapPageAllocs : 1;           // FLG_HEAP_PAGE_ALLOCS
            ULONG DebugInitialCommandEx : 1;    // FLG_DEBUG_INITIAL_COMMAND_EX
            ULONG DisableDbgPrint : 1;          // FLG_DISABLE_DBGPRINT
            ULONG CritSecEventCreation : 1;     // FLG_CRITSEC_EVENT_CREATION
            ULONG LdrTopDown : 1;               // FLG_LDR_TOP_DOWN
            ULONG EnableHandleExceptions : 1;   // FLG_ENABLE_HANDLE_EXCEPTIONS
            ULONG DisableProtDlls : 1;          // FLG_DISABLE_PROTDLLS
        } NtGlobalFlags;
    };

    ULARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID* ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    KAFFINITY ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PACTIVATION_CONTEXT_DATA ActivationContextData;
    PASSEMBLY_STORAGE_MAP ProcessAssemblyStorageMap;
    PACTIVATION_CONTEXT_DATA SystemDefaultActivationContextData;
    PASSEMBLY_STORAGE_MAP SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PVOID SparePointers[2];
    PVOID PatchLoaderData;
    PVOID ChpeV2ProcessInfo; 

    ULONG AppModelFeatureState;
    ULONG SpareUlongs[2];

    USHORT ActiveCodePage;
    USHORT OemCodePage;
    USHORT UseCaseMapping;
    USHORT UnusedNlsField;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;

    union
    {
        PVOID pContextData;
        PVOID pUnused;
        PVOID EcCodeBitMap;
    };

    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PRTL_CRITICAL_SECTION TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // RS3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // RS4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA* LeapSecondData; // RS5
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
    ULONGLONG ExtendedFeatureDisableMask; // since WIN11
} PEB, * PPEB;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
    ULONG Flags;
    PCSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME {
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG	Offset;
    UCHAR	Alignment[4];
    ULONG_PTR HDC;
    ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _ACTIVATION_CONTEXT_DATA {
    ULONG Magic; //'xtcA'
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG TotalSize;
    ULONG DefaultTocOffset;
    ULONG ExtendedTocOffset;
    ULONG AssemblyRosterOffset; 
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA, * PACTIVATION_CONTEXT_DATA;

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {
    ULONG Flags;
    UNICODE_STRING DosPath;
    HANDLE Handle;
} ASSEMBLY_STORAGE_MAP_ENTRY, * PASSEMBLY_STORAGE_MAP_ENTRY;

typedef struct _ASSEMBLY_STORAGE_MAP {
    ULONG Flags;
    ULONG AssemblyCount;
    PASSEMBLY_STORAGE_MAP_ENTRY* AssemblyArray;
} ASSEMBLY_STORAGE_MAP, * PASSEMBLY_STORAGE_MAP;

typedef VOID(NTAPI* PACTIVATION_CONTEXT_NOTIFY_ROUTINE)(
    _In_ ULONG NotificationType,
    _In_ struct _ACTIVATION_CONTEXT* ActivationContext,
    _In_ PACTIVATION_CONTEXT_DATA ActivationContextData,
    _In_opt_ PVOID NotificationContext,
    _In_opt_ PVOID NotificationData,
    _Inout_ PBOOLEAN DisableThisNotification
    );

typedef struct _ACTIVATION_CONTEXT {
    ULONG RefCount;
    ULONG Flags;
    LIST_ENTRY Links;
    ACTIVATION_CONTEXT_DATA* ActivationContextData;
    PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine;
    PVOID NotificationContext;
    ULONG SendNotifications[4];
    ULONG DisabledNotifications[4];
    ASSEMBLY_STORAGE_MAP StorageMap;
    ASSEMBLY_STORAGE_MAP_ENTRY* InlineStorageMapEntries;
    ULONG StackTraceIndex;
    PVOID StackTraces[4][4];
} ACTIVATION_CONTEXT, * PACTIVATION_CONTEXT;

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
    PACTIVATION_CONTEXT ActivationContext;
    ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, * PRTL_ACTIVATION_CONTEXT_STACK_FRAME;

typedef struct _ACTIVATION_CONTEXT_STACK {
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, * PACTIVATION_CONTEXT_STACK;

typedef struct _TEB {
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif

    CHAR PlaceholderCompatibilityMode;
    BOOLEAN PlaceholderHydrationAlwaysExplicit;
    CHAR PlaceholderReserved[10];

    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif

    BOOLEAN InstrumentationCallbackDisabled;
#ifdef _WIN64
    BOOLEAN UnalignedLoadStoreExceptions;
#endif
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle; // tagSOleTlsData
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID* TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapData;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SkipFileAPIBrokering : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
    ULONGLONG LastSleepCounter;
    ULONG SpinCallCount;
    ULONGLONG ExtendedFeatureDisableMask;
} TEB, * PTEB;

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }

/*
** PEB/TEB END
*/

/*
**  MITIGATION POLICY START
*/

//redefine enum

#define ProcessDEPPolicy                    0
#define ProcessASLRPolicy                   1
#define ProcessDynamicCodePolicy            2
#define ProcessStrictHandleCheckPolicy      3
#define ProcessSystemCallDisablePolicy      4
#define ProcessMitigationOptionsMask        5
#define ProcessExtensionPointDisablePolicy  6
#define ProcessControlFlowGuardPolicy       7
#define ProcessSignaturePolicy              8
#define ProcessFontDisablePolicy            9
#define ProcessImageLoadPolicy              10
#define ProcessSystemCallFilterPolicy       11
#define ProcessPayloadRestrictionPolicy     12
#define ProcessChildProcessPolicy           13
#define ProcessSideChannelIsolationPolicy   14
#define ProcessUserShadowStackPolicy        15
#define ProcessRedirectionTrustPolicy       16
#define ProcessUserPointerAuthPolicy        17
#define ProcessSEHOPPolicy                  18

typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD EnableXfg : 1;
            DWORD EnableXfgAuditMode : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG FilterId : 4;
            ULONG ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableExportAddressFilter : 1;
            ULONG AuditExportAddressFilter : 1;
            ULONG EnableExportAddressFilterPlus : 1;
            ULONG AuditExportAddressFilterPlus : 1;
            ULONG EnableImportAddressFilter : 1;
            ULONG AuditImportAddressFilter : 1;
            ULONG EnableRopStackPivot : 1;
            ULONG AuditRopStackPivot : 1;
            ULONG EnableRopCallerCheck : 1;
            ULONG AuditRopCallerCheck : 1;
            ULONG EnableRopSimExec : 1;
            ULONG AuditRopSimExec : 1;
            ULONG ReservedFlags : 20;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG NoChildProcessCreation : 1;
            ULONG AuditNoChildProcessCreation : 1;
            ULONG AllowSecureProcessCreation : 1;
            ULONG ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD SmtBranchTargetIsolation : 1;
            DWORD IsolateSecurityDomain : 1;
            DWORD DisablePageCombine : 1;
            DWORD SpeculativeStoreBypassDisable : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD DisallowFsctlSystemCalls : 1;
            DWORD AuditDisallowFsctlSystemCalls : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableUserShadowStack : 1;
            DWORD AuditUserShadowStack : 1;
            DWORD SetContextIpValidation : 1;
            DWORD AuditSetContextIpValidation : 1;
            DWORD EnableUserShadowStackStrictMode : 1;
            DWORD BlockNonCetBinaries : 1;
            DWORD BlockNonCetBinariesNonEhcont : 1;
            DWORD AuditBlockNonCetBinaries : 1;
            DWORD CetDynamicApisOutOfProcOnly : 1;
            DWORD ReservedFlags : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10, * PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnforceRedirectionTrust : 1;
            DWORD AuditRedirectionTrust : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10, * PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10;

typedef struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 {
    union {
        ULONG Flags;
        struct {
            ULONG EnablePointerAuthUserIp : 1;
            ULONG ReservedFlags : 31;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11, * PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11;

typedef struct _PROCESS_MITIGATION_SEHOP_POLICY_W11 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableSehop : 1;
            ULONG ReservedFlags : 31;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SEHOP_POLICY_W11, * PPROCESS_MITIGATION_SEHOP_POLICY_W11;

typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION {
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
        PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 SideChannelIsolationPolicy;
        PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 UserShadowStackPolicy;
        PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 RedirectionTrustPolicy;
        PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 UserPointerAuthPolicy;
        PROCESS_MITIGATION_SEHOP_POLICY_W11 SEHOPPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

/*
**  MITIGATION POLICY END
*/

/*
** KUSER_SHARED_DATA START
*/
#define NX_SUPPORT_POLICY_ALWAYSOFF     0
#define NX_SUPPORT_POLICY_ALWAYSON      1
#define NX_SUPPORT_POLICY_OPTIN         2
#define NX_SUPPORT_POLICY_OPTOUT        3

#define SEH_VALIDATION_POLICY_ON        0
#define SEH_VALIDATION_POLICY_OFF       1
#define SEH_VALIDATION_POLICY_TELEMETRY 2
#define SEH_VALIDATION_POLICY_DEFER     3

#include <pshpack4.h>
typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;
#include <poppack.h>

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

//
// Define Address of User Shared Data
//
#define MM_SHARED_USER_DATA_VA      0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA {

    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;
    ULONG CryptoExponent;
    ULONG TimeZoneId;
    ULONG LargePageMinimum;

    union {
        ULONG Reserved2[7];
        struct {
            ULONG AitSamplingValue;
            ULONG AppCompatFlag;
            struct {
                ULONG LowPart;
                ULONG HighPart;
            } RNGSeedVersion;
            ULONG GlobalValidationRunlevel;
            LONG TimeZoneBiasStamp;
            ULONG NtBuildNumber;
        };
    };

    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
    ULONG Reserved1;
    ULONG Reserved3;
    volatile ULONG TimeSlip;
    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG BootId; //previously AltArchitecturePad
    LARGE_INTEGER SystemExpirationDate;
    ULONG SuiteMask;
    BOOLEAN KdDebuggerEnabled;

    union {
        UCHAR MitigationPolicies;
        struct {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    UCHAR Reserved6[2];

    volatile ULONG ActiveConsoleId;
    volatile ULONG DismountCount;
    ULONG ComPlusPackage;
    ULONG LastSystemRITEventTickCount;
    ULONG NumberOfPhysicalPages;
    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union {
        ULONG SharedDataFlags;
        struct {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG DbgSplitTokenEnabled : 1;
            ULONG DbgShadowAdminEnabled : 1;
            ULONG SpareBits : 19;
        };
    };
    ULONG DataFlagsPad[1];
    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;

    ULONG SystemCall;
    ULONG SystemCallPad0;

    ULONGLONG SystemCallPad[2];

    union {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        struct {
            ULONG ReservedTickCountOverlay[3];
            ULONG TickCountPad[1];
        };
    };

    ULONG Cookie;
    ULONG CookiedPad[1];

    LONGLONG ConsoleSessionForegroundProcessId;

    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;
    USHORT UnparkedProcessorCount;

    ULONG EnclaveFeatureMask[4];
    union {
        ULONG Reserved8;
        ULONG TelemetryCoverageRound;
    };

    USHORT UserModeGlobalLogger[16];

    ULONG ImageFileExecutionOptions;
    ULONG LangGenerationCount;
    ULONGLONG Reserved4;

    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;

    union {
        USHORT QpcData;
        struct {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    XSTATE_CONFIGURATION XState;

    KSYSTEM_TIME FeatureConfigurationChangeStamp;
    ULONG Spare;

    ULONG64 UserPointerAuthMask;

    ULONG InternsReserved[210];

} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

#if !defined(__midl) && !defined(MIDL_PASS)

//
// The overall size can change, but it must be the same for all architectures.
//

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountLowDeprecated) == 0x0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(__alignof(KSYSTEM_TIME) == 4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x08);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x014);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x020);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x02c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x02e);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x030);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AitSamplingValue) == 0x248);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AppCompatFlag) == 0x24c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, RNGSeedVersion) == 0x250);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, GlobalValidationRunlevel) == 0x258);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasStamp) == 0x25c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtBuildNumber) == 0x260);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NativeProcessorArchitecture) == 0x26a);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MitigationPolicies) == 0x2d5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, VirtualizationFlags) == 0x2ed);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved12) == 0x2ee);

#if defined(_MSC_EXTENSIONS)

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SharedDataFlags) == 0x2f0);

#endif

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcFrequency) == 0x300);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCall) == 0x308);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad0) == 0x30c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x310);

#if defined(_MSC_EXTENSIONS)

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);

#endif

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Cookie) == 0x330);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ConsoleSessionForegroundProcessId) == 0x338);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeUpdateLock) == 0x340);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, BaselineSystemTimeQpc) == 0x348);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, BaselineInterruptTimeQpc) == 0x350);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcSystemTimeIncrement) == 0x358);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcInterruptTimeIncrement) == 0x360);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcSystemTimeIncrementShift) == 0x368);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcInterruptTimeIncrementShift) == 0x369);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UnparkedProcessorCount) == 0x36a);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, EnclaveFeatureMask) == 0x36c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved8) == 0x37c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved4) == 0x3a8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcBias) == 0x3b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorCount) == 0x3c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveGroupCount) == 0x3c4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved9) == 0x3c5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcData) == 0x3c6);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasEffectiveStart) == 0x3c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasEffectiveEnd) == 0x3d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8);

#endif /* __midl | MIDL_PASS */

/*
** KUSER_SHARED_DATA END
*/

/*
** MM UNLOADED DRIVERS START
*/

typedef struct _UNLOADED_DRIVERS {
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS, *PUNLOADED_DRIVERS;

#define MI_UNLOADED_DRIVERS 50

/*
** MM UNLOADED DRIVERS END
*/


/*
** FLT MANAGER START
*/
typedef enum _FLT_FILTER_FLAGS {
    FLTFL_MANDATORY_UNLOAD_IN_PROGRESS = 1,
    FLTFL_FILTERING_INITIATED = 2,
    FLTFL_NAME_PROVIDER = 4,
    FLTFL_SUPPORTS_PIPES_MAILSLOTS = 8,
    FLTFL_BACKED_BY_PAGEFILE = 16,
    FLTFL_SUPPORTS_DAX_VOLUME = 32,
    FLTFL_SUPPORTS_WCOS = 64,
    FLTFL_FILTERS_READ_WRITE = 128,
} FLT_FILTER_FLAGS, *PFLT_FILTER_FLAGS;

typedef enum _FLT_OBJECT_FLAGS {
    FLT_OBFL_DRAINING = 1,
    FLT_OBFL_ZOMBIED = 2,
    FLT_OBFL_TYPE_INSTANCE = 0x1000000,
    FLT_OBFL_TYPE_FILTER = 0x2000000,
    FLT_OBFL_TYPE_VOLUME = 0x4000000,
} FLT_OBJECT_FLAGS, *PFLT_OBJECT_FLAGS;

typedef struct _FLT_OBJECT {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
} FLT_OBJECT, *PFLT_OBJECT;

// Since w10 th1
typedef struct _FLT_OBJECT_V2 {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
    GUID UniqueIdentifier;
} FLT_OBJECT_V2, *PFLT_OBJECT_V2; /* size: 0x0030 */

// Since w11 25h2
typedef struct _FLT_OBJECT_V3 {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
    PVOID RundownLog;
    GUID UniqueIdentifier;
} FLT_OBJECT_V3, * PFLT_OBJECT_V3; /* size: 0x0038 */

typedef struct _FLT_OBJECT_LOG_ENTRY {
    ULONG Action;
    LONG Padding_25;
    EX_RUNDOWN_REF RundownRef;
    PVOID Stack[14];
} FLT_OBJECT_LOG_ENTRY, * PFLT_OBJECT_LOG_ENTRY; /* size: 0x0080 */

typedef struct _FLT_OBJECT_LOG {
    LONG Index;
    ULONG Reserved;
    FLT_OBJECT_LOG_ENTRY Log[1024];
} FLT_OBJECT_LOG, * PFLT_OBJECT_LOG; /* size: 0x20008 */

typedef struct _FLT_SERVER_PORT_OBJECT {
    LIST_ENTRY FilterLink;
    PVOID ConnectNotify;
    PVOID DisconnectNotify;
    PVOID MessageNotify;
    PVOID Filter;
    PVOID Cookie;
    ULONG Flags;
    LONG NumberOfConnections;
    LONG MaxConnections;
    LONG __PADDING__[1];
} FLT_SERVER_PORT_OBJECT, *PFLT_SERVER_PORT_OBJECT; /* size: 0x0048 */

typedef struct _FLT_RESOURCE_LIST_HEAD {
    ERESOURCE rLock;
    LIST_ENTRY rList;
    ULONG rCount;
    LONG __PADDING__[1];
} FLT_RESOURCE_LIST_HEAD, *PFLT_RESOURCE_LIST_HEAD; /* size: 0x0080 */

typedef struct _FLT_MUTEX_LIST_HEAD {
    FAST_MUTEX mLock;
    LIST_ENTRY mList;
    union {
        ULONG mCount;
        struct {
            UCHAR mInvalid : 1;
            CHAR __PADDING__[7];
        };
    }; 
} FLT_MUTEX_LIST_HEAD, *PFLT_MUTEX_LIST_HEAD; /* size: 0x0050 */

// Windows 7 version
typedef struct _FLT_FILTER_V1 {
    /* 0x0000 */ FLT_OBJECT Base;
    /* 0x0020 */ struct _FLTP_FRAME* Frame;
    /* 0x0028 */ UNICODE_STRING Name;
    /* 0x0038 */ UNICODE_STRING DefaultAltitude;
    /* 0x0048 */ FLT_FILTER_FLAGS Flags;
    /* 0x004c */ LONG Padding;
    /* 0x0050 */ DRIVER_OBJECT* DriverObject;
    /* 0x0058 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00d8 */ struct FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00e0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x00f0 */ PVOID FilterUnload /* function */;
    /* 0x00f8 */ PVOID InstanceSetup /* function */;
    /* 0x0100 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0108 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0110 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0118 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0120 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[6];
    /* 0x0150 */ PVOID PreVolumeMount /* function */;
    /* 0x0158 */ PVOID PostVolumeMount /* function */;
    /* 0x0160 */ PVOID GenerateFileName /* function */;
    /* 0x0168 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0170 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0178 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0180 */ PVOID KtmNotification /* function */;
    /* 0x0188 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x0190 */ PVOID OldDriverUnload /* function */;
    /* 0x0198 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x01e8 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0238 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x0288 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V1, * PFLT_FILTER_V1; /* size: 0x0290 */

// Windows 8/8.1 version
typedef struct _FLT_FILTER_V2 {
    /* 0x0000 */ FLT_OBJECT Base;
    /* 0x0020 */ struct _FLTP_FRAME* Frame;
    /* 0x0028 */ UNICODE_STRING Name;
    /* 0x0038 */ UNICODE_STRING DefaultAltitude;
    /* 0x0048 */ FLT_FILTER_FLAGS Flags;
    /* 0x004c */ LONG Padding;
    /* 0x0050 */ DRIVER_OBJECT* DriverObject;
    /* 0x0058 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00d8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00e0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x00f0 */ PVOID FilterUnload /* function */;
    /* 0x00f8 */ PVOID InstanceSetup /* function */;
    /* 0x0100 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0108 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0110 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0118 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0120 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0158 */ PVOID PreVolumeMount /* function */;
    /* 0x0160 */ PVOID PostVolumeMount /* function */;
    /* 0x0168 */ PVOID GenerateFileName /* function */;
    /* 0x0170 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0178 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0180 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0188 */ PVOID KtmNotification /* function */;
    /* 0x0190 */ PVOID SectionNotification /* function */; //SINCE 8.1
    /* 0x0198 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01a0 */ PVOID OldDriverUnload /* function */;
    /* 0x01a8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x01f8 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0248 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x0298 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V2, * PFLT_FILTER_V2; /* size: 0x02a0 */

// Windows 10 version
typedef struct _FLT_FILTER_V3 {
    /* 0x0000 */ FLT_OBJECT_V2 Base;
    /* 0x0030 */ struct _FLTP_FRAME* Frame;
    /* 0x0038 */ UNICODE_STRING Name;
    /* 0x0048 */ UNICODE_STRING DefaultAltitude;
    /* 0x0058 */ FLT_FILTER_FLAGS Flags;
    /* 0x005c */ LONG Padding;
    /* 0x0060 */ DRIVER_OBJECT* DriverObject;
    /* 0x0068 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00e8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0100 */ PVOID FilterUnload /* function */;
    /* 0x0108 */ PVOID InstanceSetup /* function */;
    /* 0x0110 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0118 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0120 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0128 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0168 */ PVOID PreVolumeMount /* function */;
    /* 0x0170 */ PVOID PostVolumeMount /* function */;
    /* 0x0178 */ PVOID GenerateFileName /* function */;
    /* 0x0180 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0190 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0198 */ PVOID KtmNotification /* function */;
    /* 0x01a0 */ PVOID SectionNotification /* function */;
    /* 0x01a8 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b0 */ PVOID OldDriverUnload /* function */;
    /* 0x01b8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0208 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0258 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02a8 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V3, *PFLT_FILTER_V3; /* size: 0x02b0 */

// Windows 10/11+ (22000)
typedef struct _FLT_FILTER_V4 {
    /* 0x0000 */ FLT_OBJECT_V2 Base;
    /* 0x0030 */ struct _FLTP_FRAME* Frame;
    /* 0x0038 */ UNICODE_STRING Name;
    /* 0x0048 */ UNICODE_STRING DefaultAltitude;
    /* 0x0058 */ FLT_FILTER_FLAGS Flags;
    /* 0x005c */ LONG Padding;
    /* 0x0060 */ DRIVER_OBJECT* DriverObject;
    /* 0x0068 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00e8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0100 */ PVOID FilterUnload /* function */;
    /* 0x0108 */ PVOID InstanceSetup /* function */;
    /* 0x0110 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0118 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0120 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0128 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0168 */ PVOID PreVolumeMount /* function */;
    /* 0x0170 */ PVOID PostVolumeMount /* function */;
    /* 0x0178 */ PVOID GenerateFileName /* function */;
    /* 0x0180 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0190 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0198 */ PVOID KtmNotification /* function */;
    /* 0x01a0 */ PVOID SectionNotification /* function */;
    /* 0x01a8 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b0 */ PVOID OldDriverUnload /* function */;
    /* 0x01b8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0208 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0258 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02a8 */ EX_PUSH_LOCK_AUTO_EXPAND PortLock;
} FLT_FILTER_V4, * PFLT_FILTER_V4; /* size: 0x02b8 */

// Windows 11+ (27XXX)
typedef struct _FLT_FILTER_V5 {
    /* 0x0000 */ FLT_OBJECT_V3 Base;
    /* 0x0038 */ struct _FLTP_FRAME* Frame;
    /* 0x0040 */ UNICODE_STRING Name;
    /* 0x0050 */ UNICODE_STRING DefaultAltitude;
    /* 0x0060 */ FLT_FILTER_FLAGS Flags;
    /* 0x0064 */ LONG Padding;
    /* 0x0068 */ DRIVER_OBJECT* DriverObject;
    /* 0x0070 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00f0 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f8 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0108 */ PVOID FilterUnload /* function */;
    /* 0x0110 */ PVOID InstanceSetup /* function */;
    /* 0x0118 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0120 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0128 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0138 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0170 */ PVOID PreVolumeMount /* function */;
    /* 0x0178 */ PVOID PostVolumeMount /* function */;
    /* 0x0180 */ PVOID GenerateFileName /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0190 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0198 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x01a0 */ PVOID KtmNotification /* function */;
    /* 0x01a8 */ PVOID SectionNotification /* function */;
    /* 0x01b0 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b8 */ PVOID OldDriverUnload /* function */;
    /* 0x01c0 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0210 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0260 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02b0 */ EX_PUSH_LOCK_AUTO_EXPAND PortLock;
} FLT_FILTER_V5, * PFLT_FILTER_V5; /* size: 0x02c0 */

typedef FLT_FILTER_V5 FLT_FILTER_COMPATIBLE;
typedef PFLT_FILTER_V5 PFLT_FILTER_COMPATIBLE;

/*
** FLT MANAGER END
*/

/*
** SILO START
*/

typedef struct _SYSTEM_ROOT_SILO_INFORMATION {
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

typedef struct _SILO_USER_SHARED_DATA {
    ULONG ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId; // since RS2
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
    ULONG TimeZoneId; // since 21H2
    LONG TimeZoneBiasStamp;
    KSYSTEM_TIME TimeZoneBias;
    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
    ULONG GlobalDeviceMap;
    ULONG LocalDeviceCount[26];
} OBP_SYSTEM_DOS_DEVICE_STATE, *POBP_SYSTEM_DOS_DEVICE_STATE;

typedef struct _OBP_SILODRIVERSTATE {
    PDEVICE_MAP SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE, *POBP_SILODRIVERSTATE;

typedef struct _OBP_SILODRIVERSTATE_V2 {
    EX_FAST_REF SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE_V2, * POBP_SILODRIVERSTATE_V2; /* size: 0x02e0 */

//incomplete, values not important, change between versions.
typedef struct _ESERVERSILO_GLOBALS {
    OBP_SILODRIVERSTATE ObSiloState;
    //incomplete
} ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

/*
** SILO END
*/

/*
** KSE START
*/

typedef enum _KSE_DISABLE_FLAGS {
    DisableNone = 0,
    DisableDriverShims = 1,
    DisableDeviceShims = 2,
    MaxDisableFlags
} KSE_DISABLE_FLAGS;

typedef enum _KSE_STATE {
    KseNotReady = 0,
    KseInProgress = 1,
    KseReady = 2
} KSE_STATE;

#define KseFlagsNone                0x0000
#define KseFlagsGroupPolicyOk       0x0002
#define KseFlagsVerifierEnabled     0x0040
#define KseFlagsNoDb                0x0080   
#define KseFlagsInitSafeMode        0x0100
#define KseFlagsDrvShimActive       0x0800
#define KseFlagsDevShimsActive      0x1000

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT)_KSE_ENGINE {
    KSE_DISABLE_FLAGS DisableFlags;
    KSE_STATE State;
    ULONG Flags; //KseFlags*
    LIST_ENTRY ProvidersListHead;
    LIST_ENTRY ShimmedDriversListHead;
    PVOID KseGetIoCallbacksRoutine;
    PVOID KseSetCompletionHookRoutine;
    PVOID DeviceInfoCache;
    PVOID HardwareIdCache;
    PVOID ShimmedDriverHint;
} KSE_ENGINE, * PKSE_ENGINE;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _KSE_SHIM {
    ULONG Size;
    GUID* Guid;
    PWCHAR Name;
    PVOID KseCallbackRoutines;
    PVOID RemoveNotificationRoutine;
    PVOID ApplyNotificationRoutine;
    PVOID HookCollectionsArray;
} KSE_SHIM, * PKSE_SHIM;

typedef enum _KSE_HOOK_COLLECTION_TYPE {
    HookNtOsImport = 0,
    HookHalImport = 1,
    HookNamedModuleImports = 2,
    HookCallbacks = 3,
    HookLastCollection = 4
} KSE_HOOK_COLLECTION_TYPE;

typedef struct _KSE_HOOK_COLLECTION {
    KSE_HOOK_COLLECTION_TYPE Type;
    PWCHAR TargetDriverName;
    PVOID HookArray;
} KSE_HOOK_COLLECTION, * PKSE_HOOK_COLLECTION;

typedef enum _KSE_HOOK_TYPE {
    HookFunction = 0,
    HookIrpCallback = 1,
    HookLast = 2
} KSE_HOOK_TYPE, * PKSE_HOOK_TYPE;

typedef struct _KSE_HOOK {
    KSE_HOOK_TYPE Type;
    union {
        PCHAR FunctionName;
        ULONG CallbackId;
    } DUMMYUNION;
    PVOID HookFunction;
    PVOID OriginalFunction;
} KSE_HOOK, * PKSE_HOOK;

typedef struct _KSE_PROVIDER {
    LIST_ENTRY ProviderList;
    PKSE_SHIM Shim;
} KSE_PROVIDER, * PKSE_PROVIDER;

typedef struct _KSE_SHIMMED_DRIVER {
    LIST_ENTRY ListEntry;
    PVOID DriverBaseAddress;
    ULONG RefCount;
    GUID* ShimGuid;
    //incomplete
} KSE_SHIMMED_DRIVER, * PKSE_SHIMMED_DRIVER;

/*
** KSE END
*/

/*
** SOFTWARE LICENSING START
*/
#pragma pack(push, 1)
typedef struct _SL_CACHE_VALUE_DESCRIPTOR {
    USHORT Size;
    USHORT NameLength;
    USHORT Type;
    USHORT DataLength;
    ULONG Attributes;
    ULONG Reserved;
    WCHAR Name[ANYSIZE_ARRAY];
} SL_CACHE_VALUE_DESCRIPTOR, *PSL_CACHE_VALUE_DESCRIPTOR;
typedef SL_CACHE_VALUE_DESCRIPTOR SL_KMEM_CACHE_VALUE_DESCRIPTOR;
#pragma pack(pop)

typedef struct _SL_CACHE {
    ULONG TotalSize;
    ULONG SizeOfData;
    ULONG SignatureSize;
    ULONG Flags;
    ULONG Version;
    SL_KMEM_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} SL_CACHE, *PSL_CACHE;
typedef SL_CACHE SL_KMEM_CACHE;

typedef struct _SL_APPX_CACHE_VALUE_DESCRIPTOR {
    UCHAR HashedName[32];
    ULONGLONG Expiration;
    ULONG DataSize;
    WCHAR Name[ANYSIZE_ARRAY];
} SL_APPX_CACHE_VALUE_DESCRIPTOR, *PSL_APPX_CACHE_VALUE_DESCRIPTOR;

typedef struct _SL_APPX_CACHE {
    ULONG Version;
    ULONG Flags;
    ULONG DataSize;
    ULONGLONG DataCheckSum;
    SL_APPX_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} SL_APPX_CACHE, *PSL_APPX_CACHE;


/*
** SOFTWARE LICENSING END
*/

/*
** List Entry macro START (wdm.h)
*/

#if defined (NTOS_ENABLE_LIST_ENTRY_MACRO)

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

FORCEINLINE
VOID
InitializeListHead(
    _Out_ PLIST_ENTRY ListHead
)
{
    ListHead->Flink = ListHead->Blink = ListHead;
    return;
}

_Must_inspect_result_
BOOLEAN
CFORCEINLINE
IsListEmpty(
    _In_ const LIST_ENTRY* ListHead
)
{
    return (BOOLEAN)(ListHead->Flink == ListHead);
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
    _In_ PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}

FORCEINLINE
PLIST_ENTRY
RemoveTailList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}

FORCEINLINE
VOID
InsertTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
    return;
}

FORCEINLINE
VOID
InsertHeadList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
    return;
}

FORCEINLINE
VOID
AppendTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY ListToAppend
)
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
    return;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead
)
{
    PSINGLE_LIST_ENTRY FirstEntry;

    FirstEntry = ListHead->Next;
    if (FirstEntry != NULL) {
        ListHead->Next = FirstEntry->Next;
    }

    return FirstEntry;
}

FORCEINLINE
VOID
PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PSINGLE_LIST_ENTRY Entry
)
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
    return;
}

#define ASSERT_LIST_ENTRY_VALID(ListEntry) {                    \
    if (ListEntry == NULL)                                      \
        return;                                                 \
    if (ListEntry->Flink == NULL || ListEntry->Blink == NULL)   \
        return;                                                 \
}

#define ASSERT_LIST_ENTRY_VALID_ERROR_X(ListEntry, X) {         \
    if (ListEntry == NULL)                                      \
        return X;                                               \
    if (ListEntry->Flink == NULL || ListEntry->Blink == NULL)   \
        return X;                                               \
}

#define ASSERT_LIST_ENTRY_VALID_BOOLEAN(ListEntry) ASSERT_LIST_ENTRY_VALID_ERROR_X(ListEntry, FALSE)

#endif /* NTOS_ENABLE_LIST_ENTRY_MACRO */

/*
** List Entry macro END
*/

/*
**  LDR START
*/

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef enum _LDR_DLL_LOAD_REASON {
    LoadReasonStaticDependency = 0,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary,
    LoadReasonEnclaveDependency,
    LoadReasonPatchImage,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

//
// Dll Characteristics for LdrLoadDll
//
#define LDR_IGNORE_CODE_AUTHZ_LEVEL                 0x00001000

//
// LdrAddRef Flags
//
#define LDR_ADDREF_DLL_PIN                          0x00000001

//
// LdrLockLoaderLock Flags
//
#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS   0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY          0x00000002

//
// LdrUnlockLoaderLock Flags
//
#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

//
// LdrGetDllHandleEx Flags
//
#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT    0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN                   0x00000002

//
// LdrGetProcedureAddressEx Flags
//
#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#define RESOURCE_TYPE_LEVEL     0
#define RESOURCE_NAME_LEVEL     1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL     3

typedef struct _LDR_RESOURCE_INFO {
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG Lang;
} LDR_RESOURCE_INFO, * PLDR_RESOURCE_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    } DUMMYUNION0;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
            ULONG MarkedForRemoval : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
            ULONG ImageDll : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
            ULONG LoadNotificationsSent : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
            ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
            ULONG ProcessStaticImport : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
            ULONG InLegacyLists : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
            ULONG InIndexes : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
            ULONG ShimDll : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
            ULONG InExceptionTable : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
            ULONG ReservedFlags1 : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
            ULONG LoadInProgress : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
            ULONG LoadConfigProcessed : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
            ULONG EntryProcessed : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
            ULONG ProtectDelayLoad : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
            ULONG ReservedFlags3 : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
            ULONG DontCallForThreads : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
            ULONG ProcessAttachCalled : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
            ULONG ProcessAttachFailed : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
            ULONG CorDeferredValidate : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
            ULONG CorImage : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
            ULONG DontRelocate : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
            ULONG CorILOnly : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
            ULONG ChpeImage : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
            ULONG ReservedFlags5 : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
            ULONG Redirected : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
            ULONG ReservedFlags6 : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
            ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
        };
    } ENTRYFLAGSUNION;
    WORD ObsoleteLoadCount;
    WORD TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    } DUMMYUNION1;
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    } DUMMYUNION2;
    //fields below removed for compatibility, if you need them use LDR_DATA_TABLE_ENTRY_FULL
} LDR_DATA_TABLE_ENTRY_COMPATIBLE, * PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE* PLDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY* PCLDR_DATA_TABLE_ENTRY;

typedef BOOLEAN(NTAPI* PLDR_INIT_ROUTINE)(
    _In_ PVOID DllHandle,
    _In_ ULONG Reason,
    _In_opt_ PVOID Context
    );

typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD* Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef enum _LDR_HOT_PATCH_STATE
{
    LdrHotPatchBaseImage = 0,
    LdrHotPatchNotApplied = 1,
    LdrHotPatchAppliedReverse = 2,
    LdrHotPatchAppliedForward = 3,
    LdrHotPatchFailedToPatch = 4,
    LdrHotPatchStateMax = 5,
} LDR_HOT_PATCH_STATE, * PLDR_HOT_PATCH_STATE;

//
// Full declaration of LDR_DATA_TABLE_ENTRY
//
typedef struct _LDR_DATA_TABLE_ENTRY_FULL
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PLDR_INIT_ROUTINE EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ChpeEmulatorImage : 1;
            ULONG ReservedFlags5 : 1;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID Lock;
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    PVOID LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel;
    ULONG CheckSum; 
    PVOID ActivePatchImageBase;
    LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_FULL, * PLDR_DATA_TABLE_ENTRY_FULL;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, * PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, * PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, * PLDR_DLL_NOTIFICATION_DATA;
typedef const LDR_DLL_NOTIFICATION_DATA* PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID(NTAPI *PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
    _In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,
    _In_    PVOID Context,
    _Inout_ BOOLEAN *StopEnumeration
    );

typedef VOID(CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context);

#ifndef LDR_IS_DATAFILE
#define LDR_IS_DATAFILE(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)1)
#endif

#ifndef LDR_IS_IMAGEMAPPING
#define LDR_IS_IMAGEMAPPING(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)2)
#endif

#ifndef LDR_IS_RESOURCE
#define LDR_IS_RESOURCE(DllHandle) (LDR_IS_IMAGEMAPPING(DllHandle) || LDR_IS_DATAFILE(DllHandle))
#endif

#ifndef IMAGE_FILE_MACHINE_CHPE_X86
#define IMAGE_FILE_MACHINE_CHPE_X86 0x3A64
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64EC
#define IMAGE_FILE_MACHINE_ARM64EC           0xA641
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64X
#define IMAGE_FILE_MACHINE_ARM64X            0xA64E
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    _Out_opt_ PVOID *Address,
    _Out_opt_ PULONG Size);

NTSYSAPI
NTSTATUS
NTAPI
LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    _In_ ULONG Flags,
    _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID Context);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ CONST ULONG_PTR* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceEx_U(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
    _In_ PVOID Address,
    _Out_ PLDR_DATA_TABLE_ENTRY *TableEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ CONST ANSI_STRING* ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID* ProcedureAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section);

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_  PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
    _Out_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_ ULONG ModuleInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID Context,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    _In_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrResSearchResource(
    _In_ PVOID File,
    _In_ CONST ULONG_PTR* ResIds,
    _In_ ULONG ResIdCount,
    _In_ ULONG Flags,
    _Out_ LPVOID *Resource,
    _Out_ ULONG_PTR *Size,
    _In_opt_ USHORT *FoundLanguage,
    _In_opt_ ULONG *FoundLanguageLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ BOOLEAN Wow64Path,
    _Out_ PHANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptions(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
BOOLEAN
NTAPI
LdrIsModuleSxsRedirected( //LdrEntry->Flags->Redirected
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptionsEx(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize,
    _In_ BOOLEAN Wow64Path);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_opt_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid);

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff);

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownProcess(
    VOID);

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownThread(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
LdrControlFlowGuardEnforced(
    VOID);

/*
**  LDR END
*/

/*
** Runtime Library API START
*/

/************************************************************************************
*
* CSR API.
*
************************************************************************************/

NTSYSAPI
ULONG
NTAPI
CsrGetProcessId(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
CsrClientConnectToServer(
    _In_ PWSTR ObjectDirectory,
    _In_ ULONG ServerDllIndex,
    _Inout_ PVOID ConnectionInformation,
    _Inout_ ULONG *ConnectionInformationLength,
    _Out_ PBOOLEAN CalledFromServer);

/************************************************************************************
*
* RTL Strings API.
*
************************************************************************************/

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

FORCEINLINE
VOID
NTAPI
RtlInitEmptyAnsiString(
    _Out_ PANSI_STRING AnsiString,
    _Pre_maybenull_ _Pre_readable_size_(MaximumLength) PCHAR Buffer,
    _In_ USHORT MaximumLength
)
{
    memset(AnsiString, 0, sizeof(ANSI_STRING));
    AnsiString->MaximumLength = MaximumLength;
    AnsiString->Buffer = Buffer;
}

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PSTR SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSZ SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringIn,
    _Out_ PUNICODE_STRING StringOut);

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable);

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ GUID *Guid,
    _Out_ PUNICODE_STRING GuidString);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ GUID *Guid);

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath);

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    _In_ PUNICODE_STRING UnicodeString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _In_ PANSI_STRING AnsiString);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString);

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Reserved_ PVOID Reserved);

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PWCHAR String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PWCHAR String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    _In_ PSTRING DestinationString,
    _In_opt_ PSTRING SourceString);

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
    _In_ CHAR Character);

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    _In_ PSTRING DestinationString,
    _In_ PSTRING SourceString);

NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
    _In_ PCUNICODE_STRING Altitude1,
    _In_ PCUNICODE_STRING Altitude2);

//
// preallocated heap-growable buffers
//
typedef struct _RTL_BUFFER {
    PUCHAR    Buffer;
    PUCHAR    StaticBuffer;
    SIZE_T    Size;
    SIZE_T    StaticSize;
    SIZE_T    ReservedForAllocatedSize; // for future doubling
    PVOID     ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {
    UNICODE_STRING String;
    RTL_BUFFER     ByteBuffer;
    UCHAR          MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

//
// These are OUT Disposition values.
//
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS   (0x00000001)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC         (0x00000002)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE       (0x00000003)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS (0x00000004)

NTSYSAPI
NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    _In_ ULONG Flags,
    _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
    _Out_opt_ PULONG Disposition,
    _Inout_opt_ PWSTR* FilePart);

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName);

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PCWSTR lpFileName,
    _In_ ULONG nBufferLength,
    _Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
    _Out_opt_ PWSTR *lpFilePart);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSearchPath(
    _Out_ PWSTR *SearchPath);

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ const UNICODE_STRING *String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PWSTR Source);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

#define RTL_ENSURE_BUFFER_SIZE_NO_COPY (0x00000001)

NTSYSAPI
NTSTATUS
NTAPI
RtlpEnsureBufferSize(
    _In_ ULONG Flags,
    _Inout_ PRTL_BUFFER Buffer,
    _In_ SIZE_T NewSizeBytes);

#define RtlInitBuffer(Buff, StatBuff, StatSize) \
    do {                                        \
        (Buff)->Buffer       = (StatBuff);      \
        (Buff)->Size         = (StatSize);      \
        (Buff)->StaticBuffer = (StatBuff);      \
        (Buff)->StaticSize   = (StatSize);      \
    } while (0)

#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : RtlpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define RtlFreeBuffer(Buff)                              \
    do {                                                 \
        if ((Buff) != NULL && (Buff)->Buffer != NULL) {  \
            if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buff)) {   \
                UNICODE_STRING UnicodeString;            \
                UnicodeString.Buffer = (PWSTR)(PVOID)(Buff)->Buffer; \
                RtlFreeUnicodeString(&UnicodeString);    \
            }                                            \
            (Buff)->Buffer = (Buff)->StaticBuffer;       \
            (Buff)->Size = (Buff)->StaticSize;           \
        }                                                \
    } while (0)


NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    _Inout_ PUCHAR Seed,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    _In_ UCHAR Seed,
    _Inout_ PUNICODE_STRING String);

/************************************************************************************
*
* RTL Integer conversion API.
*
************************************************************************************/

struct in6_addr;

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Addr,
    _Out_ PWSTR S);

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ LPCWSTR *Terminator,
    _Out_ struct in_addr *Address);

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW(
    _In_ struct in6_addr*Address,
    _Out_writes_(46) PWSTR AddressString);

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW(
    _In_ PCWSTR AddressString,
    _Out_ PCWSTR * Terminator,
    _Out_ struct in6_addr*Address);

//taken from ph2

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToChar(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String);

NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger(
    _In_ PSTR String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToChar(
    _In_ PLARGE_INTEGER Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String);

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString(
    _In_ ULONGLONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
    _In_ PUNICODE_STRING String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value);

/************************************************************************************
*
* RTL Process/Thread API.
*
************************************************************************************/

typedef NTSTATUS(*PUSER_PROCESS_START_ROUTINE)(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS(*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );

typedef struct _RTL_USER_PROCESS_INFORMATION {
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

//
// This structure is used only by Wow64 processes. The offsets
// of structure elements should the same as viewed by a native Win64 application.
//
typedef struct _RTL_USER_PROCESS_INFORMATION64 {
    ULONG Length;
    LONGLONG Process;
    LONGLONG Thread;
    CLIENT_ID64 ClientId;
    SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID *Environment,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_opt_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PCUNICODE_STRING Source,
    _Out_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID *PreviousEnvironment);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Out_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    _Inout_opt_ PVOID* Environment,
    _In_ PUNICODE_STRING Name,
    _In_opt_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG Attributes,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_ ULONG StackZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T InitialStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId);

NTSYSAPI
VOID
NTAPI
RtlExitUserThread(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlExitUserProcess(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlFreeUserThreadStack(
    _In_ HANDLE hProcess,
    _In_ HANDLE hThread);

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID);

NTSYSAPI
PVOID
NTAPI
RtlEncodePointer(
    _In_ PVOID Ptr);

NTSYSAPI
PVOID
NTAPI
RtlDecodePointer(
    _In_ PVOID Ptr);

/************************************************************************************
*
* RTL Memory Buffer API.
*
************************************************************************************/

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
    _In_ PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONGLONG Pattern);

/************************************************************************************
*
* RTL PEB API.
*
************************************************************************************/

NTSYSAPI
PPEB
NTAPI
RtlGetCurrentPeb(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID);

/************************************************************************************
*
* RTL Exception Handling API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle);

NTSYSAPI
BOOLEAN
NTAPI
RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord);

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle);

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord);

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status);

NTSYSAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert);

NTSYSAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance);

__analysis_noreturn
NTSYSAPI
VOID
NTAPI
RtlAssert(
    _In_ PVOID VoidFailedAssertion,
    _In_ PVOID VoidFileName,
    _In_ ULONG LineNumber,
    _In_opt_ PSTR MutableMessage);

#define RTL_ASSERT(exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, NULL), FALSE) : TRUE)
#define RTL_ASSERTMSG(msg, exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, msg), FALSE) : TRUE)
#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp), FALSE) : TRUE)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)), FALSE) : TRUE)

typedef ULONG(NTAPI* PRTLP_UNHANDLED_EXCEPTION_FILTER)(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
    );

NTSYSAPI
VOID
NTAPI
RtlSetUnhandledExceptionFilter(
    _In_ PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter);

NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers);

/************************************************************************************
*
* RTL Security API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR* OutputSecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlMakeSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    _In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Inout_ PULONG AbsoluteSecurityDescriptorSize,
    _Out_writes_bytes_to_opt_(*DaclSize, *DaclSize) PACL Dacl,
    _Inout_ PULONG DaclSize,
    _Out_writes_bytes_to_opt_(*SaclSize, *SaclSize) PACL Sacl,
    _Inout_ PULONG SaclSize,
    _Out_writes_bytes_to_opt_(*OwnerSize, *OwnerSize) PSID Owner,
    _Inout_ PULONG OwnerSize,
    _Out_writes_bytes_to_opt_(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    _Inout_ PULONG PrimaryGroupSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN DaclPresent,
    _In_opt_ PACL Dacl,
    _In_ BOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Out_ PACL* Dacl,
    _Out_ PBOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN SaclPresent,
    _In_opt_ PACL Sacl,
    _In_ BOOLEAN SaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL* Sacl,
    _Out_ PBOOLEAN SaclDefaulted);

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    _In_reads_bytes_(SecurityDescriptorLength) PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    _In_ ULONG SecurityDescriptorLength,
    _In_ SECURITY_INFORMATION RequiredInformation);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl(
    _In_ PACL Acl);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace);

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSYSAPI
PVOID
NTAPI
RtlFindAceByType(
    _In_ PACL pAcl,
    _In_ UCHAR AceType,
    _Out_opt_ PULONG pIndex);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL* Acl);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddProcessTrustLabelAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID ProcessTrustLabelSid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount);

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Out_ PSID *Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount);

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
    _In_ PSID Sid);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _In_ PSID DestinationSid,
    _In_ PSID SourceSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray(
    _In_ ULONG ArrayLength,
    _In_ PSID_AND_ATTRIBUTES Source,
    _In_ ULONG TargetSidBufferSize,
    _Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
    _Out_ PSID TargetSid,
    _Out_ PSID *NextTargetSid,
    _Out_ PULONG RemainingTargetSidBufferSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _In_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    _In_ PUNICODE_STRING ServiceName,
    _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
    _Inout_ PULONG ServiceSidLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSidEqualLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN EqualLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlSidIsHigherLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN HigherLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlReplaceSidInSd(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID OldSid,
    _In_ PSID NewSid,
    _Out_ ULONG* NumChanges);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsElevatedRid(
    _In_ PSID_AND_ATTRIBUTES SidAttr);

FORCEINLINE 
LUID 
NTAPI 
RtlConvertLongToLuid(
    _In_ LONG Long
)
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

FORCEINLINE 
LUID 
RtlConvertUlongToLuid(
    _In_ ULONG Ulong
)
{
    LUID tempLuid;

    tempLuid.LowPart = Ulong;
    tempLuid.HighPart = 0;

    return tempLuid;
}

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled);

#define RTL_ACQUIRE_PRIVILEGE_REVERT 0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
    _In_ PULONG Privilege,
    _In_ ULONG NumPriv,
    _In_ ULONG Flags,
    _Out_ PVOID* ReturnedState);

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
    _In_ PVOID StatePointer);

NTSYSAPI
NTSTATUS
NTAPI
RtlRemovePrivileges(
    _In_ HANDLE TokenHandle,
    _In_ PULONG PrivilegesToKeep,
    _In_ ULONG PrivilegeCount);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    _In_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping);

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelfEx(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    _In_opt_ ACCESS_MASK AdditionalAccess,
    _Out_opt_ PHANDLE ThreadToken);

/************************************************************************************
*
* RTL Version API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Inout_	PRTL_OSVERSIONINFOW lpVersionInformation);

NTSYSAPI
VOID
NTAPI
RtlGetNtVersionNumbers(
    _Out_opt_ PULONG MajorVersion,
    _Out_opt_ PULONG MinorVersion,
    _Out_opt_ PULONG BuildNumber);

/************************************************************************************
*
* RTL Error Status API.
*
************************************************************************************/

_When_(Status < 0, _Out_range_(> , 0))
_When_(Status >= 0, _Out_range_(== , 0))
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID);

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID);

_When_(Status < 0, _Out_range_(> , 0))
_When_(Status >= 0, _Out_range_(== , 0))
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status);

/************************************************************************************
*
* RTL WOW64 Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirectionEx(
    _In_ PVOID DisableFsRedirection,
    _Out_ PVOID *OldFsRedirectionLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetThreadContext(
    _In_ HANDLE ThreadHandle,
    _Inout_ PWOW64_CONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64SetThreadContext(
    _In_ HANDLE ThreadHandle,
    _In_ PWOW64_CONTEXT ThreadContext);

/************************************************************************************
*
* RTL Heap Management API.
*
************************************************************************************/

typedef NTSTATUS(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    _In_  PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_ SIZE_T ReserveSize,
    _In_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _In_ PVOID HeapHandle);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_opt_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_ SIZE_T HeapInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ _Post_invalid_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags);

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly);

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size);

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps);

typedef NTSTATUS(NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter);

/************************************************************************************
*
* RTL Compression API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace);

/************************************************************************************
*
* RTL Image API.
*
************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID Base);

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS * OutHeaders);

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva);

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection);

NTSYSAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
    _In_ PVOID BaseOfImage,
    _In_ PSTR RoutineName);

NTSYSAPI
NTSTATUS
NTAPI
RtlGuardCheckLongJumpTarget(
    _In_ PVOID PcValue,
    _In_ BOOL IsFastFail,
    _Out_ PBOOL IsLongJumpTarget);

/************************************************************************************
*
* RTL Time API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);


NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
NTSTATUS
NTAPI
RtlSystemTimeToLocalTime(
    _In_ PLARGE_INTEGER SystemTime,
    _Out_ PLARGE_INTEGER LocalTime);

NTSYSAPI
NTSTATUS
NTAPI
RtlLocalTimeToSystemTime(
    _In_ PLARGE_INTEGER LocalTime,
    _Out_ PLARGE_INTEGER SystemTime);

NTSYSAPI
ULONGLONG
NTAPI
RtlGetSystemTimePrecise(
    VOID);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlGetInterruptTimePrecise(
    _Out_ PLARGE_INTEGER PerformanceCounter);

NTSYSAPI
BOOLEAN
NTAPI
RtlQueryUnbiasedInterruptTime(
    _Out_ PLARGE_INTEGER InterruptTime);

NTSYSAPI
KSYSTEM_TIME
NTAPI
RtlGetSystemTimeAndBias(
    _Out_ KSYSTEM_TIME TimeZoneBias,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveStart,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveEnd);

/************************************************************************************
*
* RTL Debug Support API.
*
************************************************************************************/

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrint(
    _In_z_ _Printf_format_string_ PCCH Format,
    ...);

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ _Printf_format_string_ PCCH Format,
    ...);

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);

NTSYSAPI
VOID
NTAPI
DbgUserBreakPoint(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process);

NTSYSAPI
_Success_(return != 0)
USHORT
NTAPI
RtlCaptureStackBackTrace(
    _In_ ULONG FramesToSkip,
    _In_ ULONG FramesToCapture,
    _Out_writes_to_(FramesToCapture, return) PVOID* BackTrace,
    _Out_opt_ PULONG BackTraceHash);

/************************************************************************************
*
* RTL AVL Tree API.
*
************************************************************************************/

typedef enum _TABLE_SEARCH_RESULT {
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

#if defined (__cplusplus)
struct _RTL_AVL_TABLE;
#else
typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
typedef struct PRTL_AVL_TABLE *_RTL_AVL_TABLE;
#endif

typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ ULONG ByteSize
    );

typedef VOID(NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS(NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult);

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I);

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table);

/************************************************************************************
*
* RTL Critical Section Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

/************************************************************************************
*
* RTL SRW Lock Support API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared);

/************************************************************************************
*
* RTL UAC Support API.
*
************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED        1
#define DBG_FLAG_VIRTUALIZATION_ENABLED   2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags(
    _Inout_ ULONG *ElevationFlags);

/************************************************************************************
*
* RTL Misc Support API.
*
************************************************************************************/

NTSYSAPI
BOOLEAN
NTAPI
RtlDoesFileExists_U(
    _In_ PCWSTR FileName);

NTSYSAPI
ULONG
NTAPI
RtlGetLongestNtPathLength(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreLongPathsEnabled(
    VOID);

/************************************************************************************
*
* RTL Boundary Descriptor API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags);

NTSYSAPI
VOID
NTAPI
RtlDeleteBoundaryDescriptor(
    _In_ _Post_invalid_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddSIDToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID RequiredSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID IntegrityLabel);

/************************************************************************************
*
* RTL work item/async IO.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueWorkItem(
    _In_ WORKERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    _In_ HANDLE FileHandle,
    _In_ APC_CALLBACK_FUNCTION CompletionProc,
    _In_ ULONG Flags);

/************************************************************************************
*
* RTL data exports.
*
************************************************************************************/

#ifndef _M_X64
#define RtlNtdllName L"ntdll.dll"
#define RtlDosPathSeperatorsString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\/"))
#define RtlAlternateDosPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"/"))
#define RtlNtPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\"))
#else
NTSYSAPI PWSTR RtlNtdllName;
NTSYSAPI UNICODE_STRING RtlDosPathSeperatorsString;
NTSYSAPI UNICODE_STRING RtlAlternateDosPathSeperatorString;
NTSYSAPI UNICODE_STRING RtlNtPathSeperatorString;
#endif

/************************************************************************************
*
* ETW API.
*
************************************************************************************/

typedef VOID(NTAPI *PETWENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ /*EVENT_FILTER_DESCRIPTOR*/ PVOID FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

NTSYSAPI
NTSTATUS
NTAPI
EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PETWENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle);

NTSYSAPI
ULONG
NTAPI
EtwEventWriteNoRegistration(
    _In_ LPCGUID ProviderId,
    _In_ /*PCEVENT_DESCRIPTOR*/ PVOID EventDescriptor,
    _In_ ULONG UserDataCount,
    _In_reads_opt_(UserDataCount) /*PEVENT_DATA_DESCRIPTOR*/PVOID UserData);


/*
** Runtime Library API END
*/

/*
** Native API START
*/

/************************************************************************************
*
* System Information API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
WINAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength);

/************************************************************************************
*
* Event (EventPair) API.
*
************************************************************************************/

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEventEx(
    _In_ HANDLE ThreadId,
    _In_opt_ PRTL_SRWLOCK Lock);

NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

/************************************************************************************
*
* Mutant API.
*
************************************************************************************/

typedef enum _MUTANT_INFORMATION_CLASS {
    MutantBasicInformation,
    MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION {
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Timer API.
*
************************************************************************************/

typedef VOID(*PTIMER_APC_ROUTINE) (
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _TIMER_INFORMATION_CLASS {
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN WakeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PVOID Parameters);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PVOID Parameters);

//ref from ph2

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime);


/************************************************************************************
*
* Semaphore API.
*
************************************************************************************/

typedef enum _SEMAPHORE_INFORMATION_CLASS {
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Object and Handle API.
*
************************************************************************************/
typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectTypesInformation,
    ObjectHandleFlagInformation,
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    ObjectSetRefTraceInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION_V2 {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION_V2, *POBJECT_TYPE_INFORMATION_V2;

typedef struct _OBJECT_TYPES_INFORMATION {
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectType, sizeof(OBJECT_TYPE_INFORMATION) + \
    ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    _In_ _Post_ptr_invalid_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options);

NTSYSAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength);

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Time.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime);

/************************************************************************************
*
* Directory Object API.
*
************************************************************************************/

#define OBJDIR_FLAG_SHADOW_PRESENT 0x4
#define OBJDIR_FLAG_SANDBOX 0x10

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Private Namespace API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle);

/************************************************************************************
*
* Symbolic Link API.
*
************************************************************************************/

typedef enum _SYMBOLIC_LINK_INFO_CLASS {
    SymbolicLinkGlobalInformation = 1,
    SymbolicLinkAccessMask,
    MaxnSymbolicLinkInfoClass
} SYMBOLIC_LINK_INFO_CLASS;

typedef struct _OBJECT_SYMBOLIC_LINK_V1 { //pre Win10 TH1
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
} OBJECT_SYMBOLIC_LINK_V1, *POBJECT_SYMBOLIC_LINK_V1;

typedef struct _OBJECT_SYMBOLIC_LINK_V2 { //Win10 TH1/TH2
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
} OBJECT_SYMBOLIC_LINK_V2, *POBJECT_SYMBOLIC_LINK_V2;

typedef struct _OBJECT_SYMBOLIC_LINK_V3 { //Win10 RS1
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
} OBJECT_SYMBOLIC_LINK_V3, *POBJECT_SYMBOLIC_LINK_V3;

typedef struct _OBJECT_SYMBOLIC_LINK_V4 { //Win10 RS2+
    LARGE_INTEGER CreationTime;
    union {
        UNICODE_STRING LinkTarget;
        struct {
            PVOID Callback;
            PVOID CallbackContext;
        };
    } u1;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
    //long __PADDING__[1];
} OBJECT_SYMBOLIC_LINK_V4, *POBJECT_SYMBOLIC_LINK_V4; /* size: 0x0028 */

typedef struct _OBJECT_SYMBOLIC_LINK_V5 { //Win10 21H1+
    LARGE_INTEGER CreationTime;
    union {
        UNICODE_STRING LinkTarget;
        struct {
            PVOID Callback;
            PVOID CallbackContext;
        };
    } u1;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
    ULONG IntegrityLevel;
} OBJECT_SYMBOLIC_LINK_V5, * POBJECT_SYMBOLIC_LINK_V5; /* size: 0x0028 */

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget);

NTSYSAPI
NTSTATUS
WINAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG  ReturnedLength);

NTSTATUS
NTAPI
NtSetInformationSymbolicLink(
    _In_ HANDLE LinkHandle,
    _In_ SYMBOLIC_LINK_INFO_CLASS SymbolicLinkInformationClass,
    _In_reads_bytes_(SymbolicLinkInformationLength) PVOID SymbolicLinkInformation,
    _In_ ULONG SymbolicLinkInformationLength);

/************************************************************************************
*
* File API (+Driver&HotPatch).
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG QueryFlags,
    _In_opt_ PUNICODE_STRING FileName);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_bytecount_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree);

NTSYSAPI
NTSTATUS
NTAPI
NtCopyFileChunk(
    _In_ HANDLE SourceHandle,
    _In_ HANDLE DestinationHandle,
    _In_opt_ HANDLE EventHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Length,
    _In_ PLARGE_INTEGER SourceOffset,
    _In_ PLARGE_INTEGER DestOffset,
    _In_opt_ PULONG SourceKey,
    _In_opt_ PULONG DestKey,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadHotPatch(
    _In_ PUNICODE_STRING HotPatchName,
    _Reserved_ ULONG LoadFlag);

NTSYSAPI
NTSTATUS
NTAPI
NtManageHotPatch(
    _In_ ULONG HotPatchInformationClass,
    _Out_writes_bytes_opt_(HotPatchInformationLength) PVOID HotPatchInformation,
    _In_ ULONG HotPatchInformationLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Section API (+MemoryPartitions).
*
************************************************************************************/

#define MEM_EXECUTE_OPTION_ENABLE 0x1
#define MEM_EXECUTE_OPTION_DISABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

typedef enum _MEMORY_PARTITION_INFORMATION_CLASS {
    SystemMemoryPartitionInformation,
    SystemMemoryPartitionMoveMemory,
    SystemMemoryPartitionAddPagefile,
    SystemMemoryPartitionCombineMemory,
    SystemMemoryPartitionInitialAddMemory,
    SystemMemoryPartitionGetMemoryEvents,
    SystemMemoryPartitionSetAttributes,
    SystemMemoryPartitionNodeInformation,
    SystemMemoryPartitionCreateLargePages,
    SystemMemoryPartitionDedicatedMemoryInformation,
    SystemMemoryPartitionOpenDedicatedMemory,
    SystemMemoryPartitionMemoryChargeAttributes,
    SystemMemoryPartitionClearAttributes,
    SystemMemoryPartitionSetMemoryThresholds,
    SystemMemoryPartitionMemoryListCommand,
    SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS;

typedef struct _MEMORY_PARTITION_PAGE_RANGE {
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
    PVOID StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;

    // Fields added RS1+
    ULONG_PTR StandbyPageCountByPriority[8];
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR MaximumCommitLimit;
    ULONG_PTR DonatedPagesToPartitions;
    ULONG PartitionId;
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, * PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle);

//taken from ph2
NTSYSAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

//taken from ph2
NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSectionEx(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID* BaseAddress,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect,
    _Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile);

//
// NtCreatePartition
//

//
// 10248
//
typedef NTSTATUS(NTAPI* pfnNtCreatePartitionV1)(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode);

//
// 10586
//
typedef NTSTATUS(NTAPI* pfnNtCreatePartitionV2)(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ HANDLE* PartitionHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Node);

//
// Actual NtCreatePartition definition since Win10 10586
//
NTSYSAPI
NTSTATUS
NTAPI
NtCreatePartition(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ HANDLE* PartitionHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Node);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _Inout_updates_bytes_(PartitionInformationLength) PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength);

/************************************************************************************
*
* Token API.
*
************************************************************************************/
//
// This part is taken from PH ntseapi.h.
//

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

//
// endof ntseapi.h
//

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle);

#ifndef DISABLE_MAX_PRIVILEGE
#define DISABLE_MAX_PRIVILEGE   0x1 // winnt
#endif

#ifndef SANDBOX_INERT
#define SANDBOX_INERT           0x2 // winnt
#endif

#ifndef LUA_TOKEN
#define LUA_TOKEN               0x4 // winnt
#endif

#ifndef WRITE_RESTRICTED
#define WRITE_RESTRICTED        0x8 // winnt
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal);

NTSYSAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PVOID UserAttributes, // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles);

/************************************************************************************
*
* Registry API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName);

NTSYSAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags);

//https://gist.github.com/tyranid/1db47869da253a912242c694e921009d#file-ntloadkeyex3-h

typedef enum _KEY_LOAD_HANDLE_TYPE {
    KeyLoadTrustKey = 1,
    KeyLoadEvent,
    KeyLoadToken
} KEY_LOAD_HANDLE_TYPE;

typedef struct _KEY_LOAD_HANDLE {
    KEY_LOAD_HANDLE_TYPE Type;
    HANDLE Handle;
} KEY_LOAD_HANDLE, *PKEY_LOAD_HANDLE;

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey3(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_ PKEY_LOAD_HANDLE LoadEntries,
    _In_ ULONG LoadEntryCount,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _In_ PVOID Unused);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous);

NTSYSAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI 
NtCreateRegistryTransaction(
    _Out_ PHANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess, //generic + TRANSACTION_*
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ DWORD Flags);

NTSYSAPI
NTSTATUS
NTAPI 
NtCommitRegistryTransaction(
    _In_ HANDLE RegistryHandle,
    _In_ BOOL Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenRegistryTransaction(
    _Out_ PHANDLE RegistryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI 
NtRollbackRegistryTransaction(
    _In_ HANDLE RegistryHandle,
    _In_ BOOL Wait);


/************************************************************************************
*
* Job API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus);

/************************************************************************************
*
* Session API.
*
************************************************************************************/

typedef struct _SESSION_OBJECT {
    KEVENT Event;
    PVOID SessionGlobal; //MM_SESSION_SPACE ptr
} SESSION_OBJECT, * PSESSION_OBJECT;

//taken from ph2

typedef enum _IO_SESSION_EVENT {
    IoSessionEventIgnore,
    IoSessionEventCreated,
    IoSessionEventTerminated,
    IoSessionEventConnected,
    IoSessionEventDisconnected,
    IoSessionEventLogon,
    IoSessionEventLogoff,
    IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE {
    IoSessionStateCreated = 1,
    IoSessionStateInitialized,
    IoSessionStateConnected,
    IoSessionStateDisconnected,
    IoSessionStateDisconnectedLoggedOn,
    IoSessionStateLoggedOn,
    IoSessionStateLoggedOff,
    IoSessionStateTerminated,
    IoSessionStateMax
} IO_SESSION_STATE;

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize);

/************************************************************************************
*
* IO Completion API.
*
************************************************************************************/

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION {
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Count);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Transactions API.
*
************************************************************************************/

//TmTx
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_ ULONG CreateOptions,
    _In_ ULONG IsolationLevel,
    _In_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtThawTransactions(
    VOID);

//TmRm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmEn
NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmTm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_ ULONG CreateOptions,
    _In_ ULONG CommitStrength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_ ULONG OpenOptions);

/************************************************************************************
*
* Performance Counter.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency);

NTSYSAPI
NTSTATUS
NTAPI
NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(
    _In_ BOOLEAN ConvertAuxiliaryToPerformanceCounter,
    _In_ PLARGE_INTEGER PerformanceOrAuxiliaryCounterValue,
    _Out_ PLARGE_INTEGER ConvertedValue,
    _Out_opt_ PLARGE_INTEGER ConversionError);

/************************************************************************************
*
* Process and Thread API.
*
************************************************************************************/

typedef struct _INITIAL_TEB
{
    struct
    {
        PVOID OldStackBase;
        PVOID OldStackLimit;
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackAllocationBase;
} INITIAL_TEB, * PINITIAL_TEB;

#define PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS 0x00000001

#define QUEUE_USER_APC_FLAGS_NONE               0
#define QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC   1

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY        1
#define PS_NO_DEBUG_INHERIT         2
#define PS_INHERIT_HANDLES          4
#define PS_LARGE_PAGES              8
#define PS_ALL_FLAGS                (PS_REQUEST_BREAKAWAY | \
                                     PS_NO_DEBUG_INHERIT  | \
                                     PS_INHERIT_HANDLES   | \
                                     PS_LARGE_PAGES)

NTSYSAPI
NTSTATUS
NTAPI
NtGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ BOOLEAN InJob);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags,
    _In_ ULONG ThreadFlags,
    _In_opt_ PVOID ProcessParameters,
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, //THREAD_CREATE_FLAGS_*
    _In_opt_ ULONG_PTR ZeroBits,
    _In_opt_ SIZE_T StackSize,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessStateChange(
    _Out_ PHANDLE ProcessStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtChangeProcessState(
    _In_ HANDLE ProcessStateChangeHandle,
    _In_ HANDLE ProcessHandle,
    _In_ PROCESS_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadStateChange(
    _Out_ PHANDLE ThreadStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ThreadHandle,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtChangeThreadState(
    _In_ HANDLE ThreadStateChangeHandle,
    _In_ HANDLE ThreadHandle,
    _In_ THREAD_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

NTSYSAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength);

typedef VOID(*PPS_APC_ROUTINE) (
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx2(
    _In_ HANDLE ThreadHandle,
    _In_ HANDLE UserApcReserveHandle,
    _In_ ULONG QueueUserApcFlags, /*QUEUE_USER_APC_FLAGS*/
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2,
    _In_opt_ PVOID SystemArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtYieldExecution(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtTestAlert(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertThread(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertThreadByThreadId(
    _In_ HANDLE ThreadId);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval);

NTSYSAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
    VOID);

/************************************************************************************
*
* License API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize);

/************************************************************************************
*
* Virtual Memory API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG PageProtection,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_(VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect);

#define MAP_PROCESS 1L
#define MAP_SYSTEM  2L

NTSYSAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSTATUS
NTAPI
NtFlushVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _Out_ struct _IO_STATUS_BLOCK* IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length);

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority);

/************************************************************************************
*
* Port API.
*
************************************************************************************/

typedef struct _PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    HANDLE SectionHandle;               // Handle to section object with
                                        // SECTION_MAP_WRITE and SECTION_MAP_READ
    ULONG  SectionOffset;               // The offset in the section to map a view for
                                        // the port data area. The offset must be aligned 
                                        // with the allocation granularity of the system.
    SIZE_T ViewSize;                    // The size of the view (in bytes)
    PVOID  ViewBase;                    // The base address of the view in the creator
                                        // 
    PVOID  ViewRemoteBase;              // The base address of the view in the process
                                        // connected to the port.
} PORT_VIEW, * PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    SIZE_T ViewSize;                    // The size of the view (bytes)
    PVOID  ViewBase;                    // Base address of the view

} REMOTE_PORT_VIEW, * PREMOTE_PORT_VIEW;

typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        SIZE_T ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_MESSAGE32 {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID32 ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
} PORT_MESSAGE32, * PPORT_MESSAGE32;

typedef struct _PORT_MESSAGE64
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID64 ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        ULONGLONG ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE64, * PPORT_MESSAGE64;

typedef struct _PORT_DATA_ENTRY {
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#ifndef InitializeMessageHeader
#define InitializeMessageHeader(ph, l, t)                              \
{                                                                      \
    (ph)->u1.s1.TotalLength      = (USHORT)(l);                        \
    (ph)->u1.s1.DataLength       = (USHORT)(l - sizeof(PORT_MESSAGE)); \
    (ph)->u2.s2.Type             = (USHORT)(t);                        \
    (ph)->u2.s2.DataInfoOffset   = 0;                                  \
    (ph)->ClientId.UniqueProcess = NULL;                               \
    (ph)->ClientId.UniqueThread  = NULL;                               \
    (ph)->MessageId              = 0;                                  \
    (ph)->ClientViewSize         = 0;                                  \
}
#endif

#define LPC_REQUEST                 1
#define LPC_REPLY                   2
#define LPC_DATAGRAM                3
#define LPC_LOST_REPLY              4
#define LPC_PORT_CLOSED             5
#define LPC_CLIENT_DIED             6
#define LPC_EXCEPTION               7
#define LPC_DEBUG_EVENT             8
#define LPC_ERROR_EVENT             9
#define LPC_CONNECTION_REQUEST      10
#define LPC_CONTINUATION_REQUIRED   0x2000


#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

typedef struct _LPC_CLIENT_DIED_MSG {
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_ ULONG MaxPoolUsage);

NTSYSAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtClosePort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_opt_ PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Out_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_	PVOID ConnectionInformation,
    _Inout_opt_	PULONG ConnectionInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView);

NTSYSAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_ PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength);

/************************************************************************************
*
* Boot Management API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength);

/************************************************************************************
*
* Reserve Objects API.
*
************************************************************************************/

typedef enum _MEMORY_RESERVE_TYPE {
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type);

/************************************************************************************
*
* Debug API.
*
************************************************************************************/

//
// Define the debug object thats used to attatch to processes that are being debugged.
//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

typedef struct _DEBUG_OBJECT {
    //
    // Event thats set when the EventList is populated.
    //
    KEVENT EventsPresent;
    //
    // Mutex to protect the structure
    //
    FAST_MUTEX Mutex;
    //
    // Queue of events waiting for debugger intervention
    //
    LIST_ENTRY EventList;
    //
    // Flags for the object
    //
    ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

typedef enum _DEBUGOBJECTINFOCLASS {
    DebugObjectUnusedInformation,
    DebugObjectKillProcessOnExitInformation,
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, * PDEBUGOBJECTINFOCLASS;

typedef struct _DBGKM_EXCEPTION {
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, * PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD {
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, * PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS {
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, * PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, * PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, * PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL {
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    PVOID NamePointer;
} DBGKM_LOAD_DLL, * PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL {
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, * PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE {
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, * PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD {
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, * PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS {
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, * PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE {
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union
    {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, * PDBGUI_WAIT_STATE_CHANGE;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_reads_bytes_(DebugInformationLength) PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);


/************************************************************************************
*
* Profile API.
*
************************************************************************************/

typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity);

NTSYSAPI
NTSTATUS
NTAPI
NtStartProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtStopProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source);

/************************************************************************************
*
* Signing Levels API.
*
************************************************************************************/
typedef UCHAR SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;

typedef struct _SE_FILE_CACHE_CLAIM_INFORMATION {
    ULONG Size;
    PVOID Claim;
} SE_FILE_CACHE_CLAIM_INFORMATION, *PSE_FILE_CACHE_CLAIM_INFORMATION;

typedef struct _SE_SET_FILE_CACHE_INFORMATION {
    ULONG Size;
    UNICODE_STRING CatalogDirectoryPath;
    SE_FILE_CACHE_CLAIM_INFORMATION OriginClaimInfo;
} SE_SET_FILE_CACHE_INFORMATION, *PSE_SET_FILE_CACHE_INFORMATION;

#ifndef SE_SIGNING_LEVEL_UNCHECKED
#define SE_SIGNING_LEVEL_UNCHECKED         0x00000000
#endif

#ifndef SE_SIGNING_LEVEL_UNSIGNED
#define SE_SIGNING_LEVEL_UNSIGNED          0x00000001
#endif

#ifndef SE_SIGNING_LEVEL_ENTERPRISE
#define SE_SIGNING_LEVEL_ENTERPRISE        0x00000002
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_1
#define SE_SIGNING_LEVEL_CUSTOM_1          0x00000003
#endif

#ifndef SE_SIGNING_LEVEL_DEVELOPER
#define SE_SIGNING_LEVEL_DEVELOPER         SE_SIGNING_LEVEL_CUSTOM_1
#endif

#ifndef SE_SIGNING_LEVEL_AUTHENTICODE
#define SE_SIGNING_LEVEL_AUTHENTICODE      0x00000004
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_2
#define SE_SIGNING_LEVEL_CUSTOM_2          0x00000005
#endif

#ifndef SE_SIGNING_LEVEL_STORE
#define SE_SIGNING_LEVEL_STORE             0x00000006
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_3
#define SE_SIGNING_LEVEL_CUSTOM_3          0x00000007
#endif

#ifndef SE_SIGNING_LEVEL_ANTIMALWARE
#define SE_SIGNING_LEVEL_ANTIMALWARE       SE_SIGNING_LEVEL_CUSTOM_3
#endif

#ifndef SE_SIGNING_LEVEL_MICROSOFT
#define SE_SIGNING_LEVEL_MICROSOFT         0x00000008
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_4
#define SE_SIGNING_LEVEL_CUSTOM_4          0x00000009
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_5
#define SE_SIGNING_LEVEL_CUSTOM_5          0x0000000A
#endif

#ifndef SE_SIGNING_LEVEL_DYNAMIC_CODEGEN
#define SE_SIGNING_LEVEL_DYNAMIC_CODEGEN   0x0000000B
#endif

#ifndef SE_SIGNING_LEVEL_WINDOWS
#define SE_SIGNING_LEVEL_WINDOWS           0x0000000C
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_7
#define SE_SIGNING_LEVEL_CUSTOM_7          0x0000000D
#endif

#ifndef SE_SIGNING_LEVEL_WINDOWS_TCB
#define SE_SIGNING_LEVEL_WINDOWS_TCB       0x0000000E
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_6
#define SE_SIGNING_LEVEL_CUSTOM_6          0x0000000F
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile);

NTSYSAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel2(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile,
    _In_opt_ SE_SET_FILE_CACHE_INFORMATION* CacheInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm);

//REDSTONE 2 and above
NTSYSAPI
NTSTATUS
NTAPI
NtCompareSigningLevels(
    _In_ SE_SIGNING_LEVEL FirstSigningLevel,
    _In_ SE_SIGNING_LEVEL SecondSigningLevel);

/************************************************************************************
*
* Worker Factory API.
*
************************************************************************************/

typedef enum _WORKERFACTORYINFOCLASS {
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters,
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle);

/************************************************************************************
*
* Event Tracing API.
*
************************************************************************************/

typedef enum _TRACE_CONTROL_INFORMATION_CLASS {
    TraceControlStartLogger = 1,
    TraceControlStopLogger = 2,
    TraceControlQueryLogger = 3,
    TraceControlUpdateLogger = 4,
    TraceControlFlushLogger = 5,
    TraceControlIncrementLoggerFile = 6,
    TraceControlInvalidClass1 = 7,
    TraceControlInvalidCalss2 = 8,
    TraceControlInvalidClass3 = 9,
    TraceControlInvalidClass4 = 10,
    TraceControlRealtimeConnect = 11,
    TraceControlWdiDispatchControl = 13,
    TraceControlRealtimeDisconnectConsumerByHandle = 14,
    TraceControlReceiveNotification = 16,
    TraceControlEnableGuid = 17,
    TraceControlSendReplyDataBlock = 18,
    TraceControlReceiveReplyDataBlock = 19,
    TraceControlWdiUpdateSem = 20,
    TraceControlGetTraceGuidList = 21,
    TraceControlGetTraceGuidInfo = 22,
    TraceControlEnumerateTraceGuids = 23,
    TraceControlInvalidClass5 = 24,
    TraceControlQueryReferenceTime = 25,
    TraceControlTrackProviderBinary = 26,
    TraceControlAddNotificationEvent = 27,
    TraceControlUpdateDisallowList = 28,
    TraceControlInvalidClass6 = 29,
    TraceControlInvalidClass7 = 30,
    TraceControlUseDescriptorTypeUm = 31,
    TraceControlGetTraceGroupList = 32,
    TraceControlGetTraceGroupInfo = 33,
    TraceControlTraceSetDisallowList = 34,
    TraceControlSetCompressionSettings = 35,
    TraceControlGetCompressionSettings = 36,
    TraceControlUpdatePeriodicCaptureState = 37,
    TraceControlGetPrivateSessionTraceHandle = 38,
    TraceControlRegisterPrivateSession = 39,
    TraceControlQuerySessionDemuxObject = 40,
    TraceControlSetProviderBinaryTracking = 41,
    TraceControlMaxLoggers = 42,
    TraceControlMaxPmcCounter = 43
} TRACE_CONTROL_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields);

NTSYSAPI
NTSTATUS
NTAPI
NtTraceControl(
    _In_ TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_ PULONG ReturnLength);

/************************************************************************************
*
* Enclave API.
*
************************************************************************************/

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
typedef LPVOID(WINAPI* PENCLAVE_ROUTINE) (LPVOID lpThreadParameter);
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnclave(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T Size,
    _In_ SIZE_T InitialCommitment,
    _In_ ULONG EnclaveType,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadEnclaveData(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _In_ ULONG Protect,
    _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
    _In_ ULONG PageInformationLength,
    _Out_opt_ PSIZE_T NumberOfBytesWritten,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtInitializeEnclave(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateEnclave(
    _In_ PVOID BaseAddress,
    _In_ BOOLEAN WaitForThread);

NTSYSAPI
NTSTATUS
NTAPI
NtCallEnclave(
    _In_ PENCLAVE_ROUTINE Routine,
    _In_ PVOID Parameter,
    _In_ BOOLEAN WaitForThread,
    _Out_opt_ PVOID* ReturnValue);


/************************************************************************************
*
* LUID/UUID API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
    _In_ PCHAR Seed);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
    _Out_ PLUID Luid);


/************************************************************************************
*
* Kernel Debugger API.
*
************************************************************************************/

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef enum _SYSDBG_COMMAND {
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump,
    SysDbgKdPullRemoteFile,
    SysDbgMaxInfoClass
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL {
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

NTSYSAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* HardError API.
*
************************************************************************************/

#ifndef HARDERROR_OVERRIDE_ERRORMODE
#define HARDERROR_OVERRIDE_ERRORMODE 0x10000000
#endif

typedef enum _HARDERROR_RESPONSE_OPTION {
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE {
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
} HARDERROR_RESPONSE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response);

/************************************************************************************
*
* IoRing API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIoRing(
    _Out_ PHANDLE IoRingHandle,
    _In_ ULONG CreateParametersLength,
    _In_ PVOID CreateParameters,
    _In_ ULONG OutputParametersLength,
    _Out_ PVOID OutputParameters);

/************************************************************************************
*
* Thread Pooling API and definitions.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
    _Out_ PTP_POOL* PoolReturn,
    _Reserved_ PVOID Reserved);

NTSYSAPI
VOID
NTAPI
TpReleasePool(
    _Inout_ PTP_POOL Pool);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
    _Out_ PTP_WORK* WorkReturn,
    _In_ PTP_WORK_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron);

NTSYSAPI
VOID
NTAPI
TpReleaseWork(
    _Inout_ PTP_WORK Work);

NTSYSAPI
VOID
NTAPI
TpPostWork(
    _Inout_ PTP_WORK Work);

NTSYSAPI
VOID
NTAPI
TpWaitForWork(
    _Inout_ PTP_WORK Work,
    _In_ LOGICAL CancelPendingCallbacks);

/************************************************************************************
*
* ApiSet definitions.
*
************************************************************************************/

NTSYSAPI
BOOL
NTAPI
ApiSetQueryApiSetPresence(
    _In_ PCUNICODE_STRING Namespace,
    _Out_ PBOOLEAN Present);

NTSYSAPI
BOOL
NTAPI
ApiSetQueryApiSetPresenceEx(
    _In_ PCUNICODE_STRING Namespace,
    _Out_ PBOOLEAN IsInSchema,
    _Out_ PBOOLEAN Present);

/************************************************************************************
*
* Application Verifier API and definitions.
*
************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

typedef VOID(NTAPI *RTL_VERIFIER_DLL_LOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(
    PVOID AllocationBase,
    SIZE_T AllocationSize);

typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
    PCHAR ThunkName;
    PVOID ThunkOldAddress;
    PVOID ThunkNewAddress;
} RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {
    PWCHAR DllName;
    DWORD DllFlags;
    PVOID DllAddress;
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
} RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
    DWORD Length;
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
    PWSTR VerifierImage;
    DWORD VerifierFlags;
    DWORD VerifierDebug;
    PVOID RtlpGetStackTraceAddress;
    PVOID RtlpDebugPageHeapCreate;
    PVOID RtlpDebugPageHeapDestroy;
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
} RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

//
// Application verifier standard flags.
//
#define RTL_VRF_FLG_FULL_PAGE_HEAP                   0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE                0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS                    0x00000004
#define RTL_VRF_FLG_STACK_CHECKS                     0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS                 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS                       0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS                     0x00000040
#define RTL_VRF_FLG_RPC_CHECKS                       0x00000080
#define RTL_VRF_FLG_COM_CHECKS                       0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS                   0x00000200
#define RTL_VRF_FLG_RACE_CHECKS                      0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS                  0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS    0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS               0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING                   0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP                   0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING           0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE              0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS             0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS                      0x00040000

NTSYSAPI
VOID
NTAPI
RtlApplicationVerifierStop(
    _In_ ULONG_PTR Code,
    _In_ PSTR Message,
    _In_ ULONG_PTR Param1,
    _In_ PSTR Description1,
    _In_ ULONG_PTR Param2,
    _In_ PSTR Description2,
    _In_ ULONG_PTR Param3,
    _In_ PSTR Description3,
    _In_ ULONG_PTR Param4,
    _In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        RtlApplicationVerifierStop ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
#endif

/************************************************************************************
*
* CPU partition API & definitions.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtOpenCpuPartition(
    _Out_ PHANDLE CpuPartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateCpuPartition(
    _Out_ PHANDLE CpuPartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationCpuPartition(
    _In_ HANDLE CpuPartitionHandle,
    _In_ ULONG CpuPartitionInformationClass,
    _In_reads_bytes_(CpuPartitionInformationLength) PVOID CpuPartitionInformation,
    _In_ ULONG CpuPartitionInformationLength,
    _Reserved_ PVOID Reserved0,
    _Reserved_ ULONG Reserved1,
    _Reserved_ ULONG Reserved2);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationCpuPartition(
    _In_ HANDLE CpuPartitionHandle,
    _In_ ULONG CpuPartitionInformationClass,
    _Out_writes_bytes_opt_(CpuPartitionInformationLength) PVOID CpuPartitionInformation,
    _In_ ULONG CpuPartitionInformationLength,
    _Out_opt_ PULONG ReturnLength);

//
// NTOS_RTL HEADER END
//

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTOS_RTL

```

`Source/Shared/ntos/ntsup.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2011 - 2025 UGN/HE
*
*  TITLE:       NTSUP.C
*
*  VERSION:     2.25
*
*  DATE:        18 Aug 2025
*
*  Native API support functions.
*
*  Only ntdll-bound import.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "ntsup.h"

#pragma warning(push)
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'
#pragma warning(disable: 6320) // exception may mask

/*
* 
* SHA256 algo (used by Ronova so keep it here).
* 
*/

typedef struct _NTSUP_SHA256_CTX {
    ULONG State[8];
    ULONG64 BitCount;
    UCHAR Buffer[64];
} NTSUP_SHA256_CTX, * PNTSUP_SHA256_CTX;

#define NTSUP_ROTR32(v,b) _rotr(v,b)
#define NTSUP_CH(x,y,z)   (((x) & (y)) ^ ((~x) & (z)))
#define NTSUP_MAJ(x,y,z)  (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define NTSUP_BSIG0(x)    (NTSUP_ROTR32(x,2) ^ NTSUP_ROTR32(x,13) ^ NTSUP_ROTR32(x,22))
#define NTSUP_BSIG1(x)    (NTSUP_ROTR32(x,6) ^ NTSUP_ROTR32(x,11) ^ NTSUP_ROTR32(x,25))
#define NTSUP_SSIG0(x)    (NTSUP_ROTR32(x,7) ^ NTSUP_ROTR32(x,18) ^ ((x) >> 3))
#define NTSUP_SSIG1(x)    (NTSUP_ROTR32(x,17) ^ NTSUP_ROTR32(x,19) ^ ((x) >> 10))

static const ULONG ntsupSha256K[64] = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
    0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
    0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
    0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
    0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
    0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
    0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
    0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
    0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

VOID ntsupSha256Transform(
    _Inout_ PNTSUP_SHA256_CTX Ctx,
    _In_reads_bytes_(64) const UCHAR Block[64]
)
{
    ULONG W[64];
    ULONG a, b, c, d, e, f, g, h, t1, t2;
    ULONG i;
    for (i = 0; i < 16; i++) {
        W[i] = (Block[i * 4] << 24) |
            (Block[i * 4 + 1] << 16) |
            (Block[i * 4 + 2] << 8) |
            (Block[i * 4 + 3]);
    }
    for (i = 16; i < 64; i++) {
        W[i] = NTSUP_SSIG1(W[i - 2]) + W[i - 7] + NTSUP_SSIG0(W[i - 15]) + W[i - 16];
    }

    a = Ctx->State[0];
    b = Ctx->State[1];
    c = Ctx->State[2];
    d = Ctx->State[3];
    e = Ctx->State[4];
    f = Ctx->State[5];
    g = Ctx->State[6];
    h = Ctx->State[7];

    for (i = 0; i < 64; i++) {
        t1 = h + NTSUP_BSIG1(e) + NTSUP_CH(e, f, g) + ntsupSha256K[i] + W[i];
        t2 = NTSUP_BSIG0(a) + NTSUP_MAJ(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    Ctx->State[0] += a;
    Ctx->State[1] += b;
    Ctx->State[2] += c;
    Ctx->State[3] += d;
    Ctx->State[4] += e;
    Ctx->State[5] += f;
    Ctx->State[6] += g;
    Ctx->State[7] += h;

    RtlSecureZeroMemory(W, sizeof(W));
}

VOID ntsupSha256Init(
    _Out_ PNTSUP_SHA256_CTX Ctx
)
{
    RtlSecureZeroMemory(Ctx, sizeof(NTSUP_SHA256_CTX));
    Ctx->State[0] = 0x6A09E667;
    Ctx->State[1] = 0xBB67AE85;
    Ctx->State[2] = 0x3C6EF372;
    Ctx->State[3] = 0xA54FF53A;
    Ctx->State[4] = 0x510E527F;
    Ctx->State[5] = 0x9B05688C;
    Ctx->State[6] = 0x1F83D9AB;
    Ctx->State[7] = 0x5BE0CD19;
}

VOID ntsupSha256Update(
    _Inout_ PNTSUP_SHA256_CTX Ctx,
    _In_reads_bytes_(Length) const UCHAR* Data,
    _In_ SIZE_T Length
)
{
    SIZE_T have, need;
    SIZE_T off;
    const UCHAR* p;

    if (Length == 0) return;

    have = (SIZE_T)((Ctx->BitCount >> 3) & 0x3F);
    need = 64 - have;
    Ctx->BitCount += (ULONG64)Length * 8;
    p = Data;
    off = 0;

    if (have && Length >= need) {
        RtlCopyMemory(Ctx->Buffer + have, p, need);
        ntsupSha256Transform(Ctx, Ctx->Buffer);
        off += need;
        have = 0;
    }

    while (off + 64 <= Length) {
#pragma warning(push)
#pragma warning(disable: 6385)
        ntsupSha256Transform(Ctx, p + off);
#pragma warning(pop)
        off += 64;
    }

    if (off < Length) {
        RtlCopyMemory(Ctx->Buffer + have, p + off, Length - off);
    }
}

VOID ntsupSha256Final(
    _Inout_ PNTSUP_SHA256_CTX Ctx,
    _Out_writes_bytes_all_(32) UCHAR Digest[32]
)
{
    UCHAR pad[64];
    UCHAR len[8];
    SIZE_T padLen;
    SIZE_T i;
    ULONG64 bitCount;

    bitCount = Ctx->BitCount;

    for (i = 0; i < 8; i++) {
        len[7 - i] = (UCHAR)(bitCount >> (i * 8));
    }

    pad[0] = 0x80;
    RtlSecureZeroMemory(pad + 1, 63);

    padLen = 64 - ((bitCount >> 3) & 0x3f);
    if (padLen < 9) padLen += 64;

    ntsupSha256Update(Ctx, pad, padLen - 8);
    ntsupSha256Update(Ctx, len, 8);

    for (i = 0; i < 8; i++) {
        Digest[i * 4 + 0] = (UCHAR)(Ctx->State[i] >> 24);
        Digest[i * 4 + 1] = (UCHAR)(Ctx->State[i] >> 16);
        Digest[i * 4 + 2] = (UCHAR)(Ctx->State[i] >> 8);
        Digest[i * 4 + 3] = (UCHAR)(Ctx->State[i]);
    }

    RtlSecureZeroMemory(Ctx, sizeof(NTSUP_SHA256_CTX));
    RtlSecureZeroMemory(pad, sizeof(pad));
    RtlSecureZeroMemory(len, sizeof(len));
}

/*
* ntsupHeapAlloc
*
* Purpose:
*
* Wrapper for RtlAllocateHeap with process heap.
*
*/
PVOID ntsupHeapAlloc(
    _In_ SIZE_T Size
)
{
    return RtlAllocateHeap(ntsupProcessHeap(), HEAP_ZERO_MEMORY, Size);
}

/*
* ntsupHeapFree
*
* Purpose:
*
* Wrapper for RtlFreeHeap with process heap.
*
*/
VOID ntsupHeapFree(
    _In_ PVOID BaseAddress
)
{
    RtlFreeHeap(ntsupProcessHeap(), 0, BaseAddress);
}

/*
* ntsupVirtualAllocEx
*
* Purpose:
*
* Wrapper for ntsupVirtualAllocEx with standard parameters.
*
*/
PVOID ntsupVirtualAllocEx(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect)
{
    NTSTATUS ntStatus;
    PVOID bufferPtr = NULL;
    SIZE_T bufferSize;

    bufferSize = Size;
    ntStatus = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &bufferPtr,
        0,
        &bufferSize,
        AllocationType,
        Protect);

    if (NT_SUCCESS(ntStatus)) {
        return bufferPtr;
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NULL;
}

/*
* ntsupVirtualAlloc
*
* Purpose:
*
* Wrapper for supVirtualAllocEx.
*
*/
PVOID ntsupVirtualAlloc(
    _In_ SIZE_T Size)
{
    return ntsupVirtualAllocEx(Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

/*
* ntsupVirtualLock
*
* Purpose:
*
* Wrapper for NtLockVirtualMemory.
*
*/
BOOL ntsupVirtualLock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize
)
{
    return (NT_SUCCESS(NtLockVirtualMemory(NtCurrentProcess(),
        &lpAddress,
        &dwSize,
        MAP_PROCESS)));
}

/*
* ntsupVirtualUnlock
*
* Purpose:
*
* Wrapper for NtUnlockVirtualMemory.
*
*/
BOOL ntsupVirtualUnlock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize
)
{
    return (NT_SUCCESS(NtUnlockVirtualMemory(NtCurrentProcess(),
        &lpAddress,
        &dwSize,
        MAP_PROCESS)));
}

/*
* ntsupVirtualFree
*
* Purpose:
*
* Wrapper for NtFreeVirtualMemory.
*
*/
BOOL ntsupVirtualFree(
    _In_ PVOID Memory)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    SIZE_T sizeDummy = 0;

    if (Memory) {
        ntStatus = NtFreeVirtualMemory(
            NtCurrentProcess(),
            &Memory,
            &sizeDummy,
            MEM_RELEASE);
    }
    else {
        RtlSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NT_SUCCESS(ntStatus);
}

/*
* ntsupWriteBufferToFile
*
* Purpose:
*
* Create new file (or open existing) and write buffer to it.
*
*/
SIZE_T ntsupWriteBufferToFile(
    _In_ PCWSTR FileName,
    _In_ PVOID Buffer,
    _In_ SIZE_T Size,
    _In_ BOOL Flush,
    _In_ BOOL Append,
    _Out_opt_ NTSTATUS* Result
)
{
    NTSTATUS           ntStatus = STATUS_UNSUCCESSFUL;
    ACCESS_MASK        desiredAccess = FILE_WRITE_DATA | SYNCHRONIZE;
    DWORD              dwFlag = FILE_OVERWRITE_IF;
    ULONG              blockSize, remainingSize;
    HANDLE             hFile = NULL;
    ULONG_PTR          nBlocks, blockIndex;
    SIZE_T             bytesWritten = 0;
    PBYTE              ptr = (PBYTE)Buffer;
    LARGE_INTEGER      filePosition;
    PLARGE_INTEGER     pPosition = NULL;
    OBJECT_ATTRIBUTES  attr;
    UNICODE_STRING     ntFileName;
    IO_STATUS_BLOCK    ioStatus;

    if (Result)
        *Result = STATUS_UNSUCCESSFUL;

    if (RtlDosPathNameToNtPathName_U(FileName, &ntFileName, NULL, NULL) == FALSE) {
        if (Result)
            *Result = STATUS_INVALID_PARAMETER_1;
        return 0;
    }

    if (Append) {
        desiredAccess |= FILE_READ_DATA | FILE_APPEND_DATA;
        dwFlag = FILE_OPEN_IF;
    }

    InitializeObjectAttributes(&attr, &ntFileName, OBJ_CASE_INSENSITIVE, 0, NULL);

    __try {
        ntStatus = NtCreateFile(&hFile, desiredAccess, &attr,
            &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, dwFlag,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        if (Append) {
            filePosition.LowPart = FILE_WRITE_TO_END_OF_FILE;
            filePosition.HighPart = -1;
            pPosition = &filePosition;
        }

        if (Size < 0x80000000) {
            blockSize = (ULONG)Size;
            ntStatus = NtWriteFile(hFile, 0, NULL, NULL, &ioStatus, ptr, blockSize, pPosition, NULL);
            if (!NT_SUCCESS(ntStatus))
                __leave;

            bytesWritten += ioStatus.Information;
            if (Append)
                pPosition = NULL;
        }
        else {
            blockSize = MAX_NTSUP_WRITE_CHUNK;
            nBlocks = (Size / blockSize);
            for (blockIndex = 0; blockIndex < nBlocks; blockIndex++) {

                ntStatus = NtWriteFile(hFile, 0, NULL, NULL, &ioStatus, ptr, blockSize, pPosition, NULL);
                if (!NT_SUCCESS(ntStatus))
                    __leave;

                ptr += blockSize;
                bytesWritten += ioStatus.Information;
                if (Append && blockIndex == 0)
                    pPosition = NULL;
            }
            remainingSize = (ULONG)(Size % blockSize);
            if (remainingSize) {
                ntStatus = NtWriteFile(hFile, 0, NULL, NULL, &ioStatus, ptr, remainingSize, pPosition, NULL);
                if (!NT_SUCCESS(ntStatus))
                    __leave;
                bytesWritten += ioStatus.Information;
            }
        }
    }
    __finally {
        if (hFile) {

            if (Flush)
                NtFlushBuffersFile(hFile, &ioStatus);

            NtClose(hFile);
        }
        RtlFreeUnicodeString(&ntFileName);
        if (Result) *Result = ntStatus;
    }
    return bytesWritten;
}

/*
* ntsupFindModuleEntryByName
*
* Purpose:
*
* Find Module entry for given name.
*
*/
PVOID ntsupFindModuleEntryByName(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCSTR ModuleName
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules, fnameOffset;
    LPSTR entryName;
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry;

    for (i = 0; i < modulesCount; i++) {

        moduleEntry = &ModulesList->Modules[i];
        fnameOffset = moduleEntry->OffsetToFileName;
        entryName = (LPSTR)&moduleEntry->FullPathName[fnameOffset];
        if (_strcmpi_a(entryName, ModuleName) == 0)
            return moduleEntry;
    }

    return NULL;
}

/*
* ntsupFindModuleEntryByName_U
*
* Purpose:
*
* Find Module entry for given name.
*
*/
PVOID ntsupFindModuleEntryByName_U(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCWSTR ModuleName
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules, fnameOffset;
    LPSTR entryName;
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry, result = NULL;

    UNICODE_STRING usString;
    ANSI_STRING moduleName;

    if (NT_SUCCESS(RtlInitUnicodeStringEx(&usString, ModuleName))) {
        moduleName.Buffer = NULL;
        moduleName.Length = moduleName.MaximumLength = 0;
        if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&moduleName, &usString, TRUE))) {

            for (i = 0; i < modulesCount; i++) {

                moduleEntry = &ModulesList->Modules[i];
                fnameOffset = moduleEntry->OffsetToFileName;
                entryName = (LPSTR)&moduleEntry->FullPathName[fnameOffset];
                if (_strcmpi_a(entryName, moduleName.Buffer) == 0) {
                    result = moduleEntry;
                    break;
                }
            }

            RtlFreeAnsiString(&moduleName);
        }
    }
    return result;
}

/*
* ntsupFindModuleEntryByAddress
*
* Purpose:
*
* Find Module Name for given Address and copy it to the supplied buffer.
*
* Returns module entry if found, NULL otherwise.
*
*/
BOOL ntsupFindModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Out_ PULONG ModuleIndex
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules;

    *ModuleIndex = 0;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            ModulesList->Modules[i].ImageBase,
            ModulesList->Modules[i].ImageSize))
        {
            *ModuleIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

/*
* ntsupGetModuleEntryByAddress
*
* Purpose:
*
* Get Module Entry for given Address.
*
*/
PVOID ntsupGetModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            ModulesList->Modules[i].ImageBase,
            ModulesList->Modules[i].ImageSize))
        {           
            return &ModulesList->Modules[i];
        }
    }
    return NULL;
}

/*
* ntsupFindModuleNameByAddress
*
* Purpose:
*
* Find Module Name for given Address.
*
*/
PVOID ntsupFindModuleNameByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD ccBuffer //size of buffer in chars
)
{
    ULONG i, modulesCount;
    NTSTATUS ntStatus;
    SIZE_T copyLength;
    UNICODE_STRING usConvertedName;
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry;

    if ((Buffer == NULL) || (ccBuffer == 0)) {
        return NULL;
    }

    modulesCount = ModulesList->NumberOfModules;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            ModulesList->Modules[i].ImageBase,
            ModulesList->Modules[i].ImageSize))
        {
            moduleEntry = &ModulesList->Modules[i];

            RtlInitEmptyUnicodeString(&usConvertedName, NULL, 0);
            ntStatus = ntsupConvertToUnicode(
                (LPSTR)&moduleEntry->FullPathName[moduleEntry->OffsetToFileName],
                &usConvertedName);

            if (NT_SUCCESS(ntStatus)) {

                copyLength = usConvertedName.Length / sizeof(WCHAR);
                if (copyLength > (SIZE_T)(ccBuffer - 1))
                    copyLength = ccBuffer - 1;

                _strncpy(
                    Buffer,
                    ccBuffer,
                    usConvertedName.Buffer,
                    copyLength);

                RtlFreeUnicodeString(&usConvertedName);

                return &ModulesList->Modules[i];
            }
            else {
                return NULL;
            }
        }
    }
    return NULL;
}

/*
* ntsupConvertToUnicode
*
* Purpose:
*
* Convert ANSI string to UNICODE string.
*
* N.B.
* If function succeeded - use RtlFreeUnicodeString to release allocated string.
*
*/
NTSTATUS ntsupConvertToUnicode(
    _In_ LPCSTR AnsiString,
    _Inout_ PUNICODE_STRING UnicodeString)
{
    ANSI_STRING ansiString;

    RtlInitString(&ansiString, AnsiString);
    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiString, TRUE);
}

/*
* ntsupConvertToAnsi
*
* Purpose:
*
* Convert UNICODE string to ANSI string.
*
* N.B.
* If function succeeded - use RtlFreeAnsiString to release allocated string.
*
*/
NTSTATUS ntsupConvertToAnsi(
    _In_ LPCWSTR UnicodeString,
    _Inout_ PANSI_STRING AnsiString)
{
    UNICODE_STRING unicodeString;

    RtlInitUnicodeString(&unicodeString, UnicodeString);
    return RtlUnicodeStringToAnsiString(AnsiString, &unicodeString, TRUE);
}

/*
* ntsupEnablePrivilege
*
* Purpose:
*
* Enable/Disable given privilege.
*
* Return FALSE on any error.
*
*/
BOOLEAN ntsupEnablePrivilege(
    _In_ DWORD Privilege,
    _In_ BOOLEAN Enable
)
{
    ULONG returnLength;
    NTSTATUS ntStatus;
    HANDLE tokenHandle;

    PTOKEN_PRIVILEGES newState;
    UCHAR rawBuffer[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];

    ntStatus = NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &tokenHandle);

    if (NT_SUCCESS(ntStatus)) {

        newState = (PTOKEN_PRIVILEGES)rawBuffer;

        newState->PrivilegeCount = 1;
        newState->Privileges[0].Luid = RtlConvertUlongToLuid(Privilege);
        newState->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

        ntStatus = NtAdjustPrivilegesToken(
            tokenHandle,
            FALSE,
            newState,
            sizeof(rawBuffer),
            NULL,
            &returnLength);

        if (ntStatus == STATUS_NOT_ALL_ASSIGNED) {
            ntStatus = STATUS_PRIVILEGE_NOT_HELD;
        }

        NtClose(tokenHandle);

    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NT_SUCCESS(ntStatus);
}

/*
* ntsupGetCurrentProcessToken
*
* Purpose:
*
* Return current process token value with TOKEN_QUERY access right.
*
*/
HANDLE ntsupGetCurrentProcessToken(
    VOID)
{
    HANDLE tokenHandle = NULL;

    if (NT_SUCCESS(NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle)))
    {
        return tokenHandle;
    }
    return NULL;
}

/*
* ntsupQuerySystemRangeStart
*
* Purpose:
*
* Return MmSystemRangeStart value.
*
*/
ULONG_PTR ntsupQuerySystemRangeStart(
    VOID
)
{
    NTSTATUS  ntStatus;
    ULONG_PTR systemRangeStart = 0;
    ULONG     memIO = 0;

    ntStatus = NtQuerySystemInformation(
        SystemRangeStartInformation,
        (PVOID)&systemRangeStart,
        sizeof(ULONG_PTR),
        &memIO);

    if (!NT_SUCCESS(ntStatus)) {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }
    return systemRangeStart;
}

/*
* ntsupQueryUserModeAccessibleRange
*
* Purpose:
*
* Return user mode applications accessible address range.
*
*/
BOOLEAN ntsupQueryUserModeAccessibleRange(
    _Out_ PULONG_PTR MinimumUserModeAddress,
    _Out_ PULONG_PTR MaximumUserModeAddress
)
{
    NTSTATUS  ntStatus;
    ULONG     memIO = 0;
    SYSTEM_BASIC_INFORMATION sysBasicInfo;

    RtlSecureZeroMemory(&sysBasicInfo, sizeof(sysBasicInfo));

    ntStatus = NtQuerySystemInformation(
        SystemBasicInformation,
        (PVOID)&sysBasicInfo,
        sizeof(sysBasicInfo),
        &memIO);

    if (NT_SUCCESS(ntStatus)) {

        *MinimumUserModeAddress = sysBasicInfo.MinimumUserModeAddress;
        *MaximumUserModeAddress = sysBasicInfo.MaximumUserModeAddress;

        return TRUE;
    }
    else {

        *MinimumUserModeAddress = 0;
        *MaximumUserModeAddress = 0;

    }

    return FALSE;
}

/*
* ntsupIsKdEnabled
*
* Purpose:
*
* Perform check if the kernel debugger active.
*
*/
BOOLEAN ntsupIsKdEnabled(
    _Out_opt_ PBOOLEAN DebuggerAllowed,
    _Out_opt_ PBOOLEAN DebuggerNotPresent
)
{
    BOOLEAN bResult = FALSE;
    NTSTATUS ntStatus;
    ULONG returnLength = 0;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION kdInfo;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX kdInfoEx;

    if (DebuggerAllowed)
        *DebuggerAllowed = FALSE;
    if (DebuggerNotPresent)
        *DebuggerNotPresent = FALSE;

    RtlSecureZeroMemory(&kdInfo, sizeof(kdInfo));

    ntStatus = NtQuerySystemInformation(
        SystemKernelDebuggerInformation,
        &kdInfo,
        sizeof(kdInfo),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {

        if (DebuggerNotPresent)
            *DebuggerNotPresent = kdInfo.KernelDebuggerNotPresent;

        bResult = kdInfo.KernelDebuggerEnabled;
    }
    else {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
        return FALSE;
    }

    if (DebuggerAllowed) {

        RtlSecureZeroMemory(&kdInfoEx, sizeof(kdInfoEx));

        ntStatus = NtQuerySystemInformation(
            SystemKernelDebuggerInformationEx,
            &kdInfoEx,
            sizeof(kdInfoEx),
            &returnLength);

        if (NT_SUCCESS(ntStatus)) {
            *DebuggerAllowed = kdInfoEx.DebuggerAllowed;
        }
        else {
            *DebuggerAllowed = FALSE;
            RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
        }

    }

    return bResult;
}

/*
* ntsupIsProcess32bit
*
* Purpose:
*
* Return TRUE if process is wow64.
*
*/
BOOL ntsupIsProcess32bit(
    _In_ HANDLE hProcess
)
{
    ULONG                              returnLength;
    PROCESS_EXTENDED_BASIC_INFORMATION pebi;

    RtlSecureZeroMemory(&pebi, sizeof(pebi));
    pebi.Size = sizeof(PROCESS_EXTENDED_BASIC_INFORMATION);

    if (NT_SUCCESS(NtQueryInformationProcess(
        hProcess,
        ProcessBasicInformation,
        &pebi,
        sizeof(pebi),
        &returnLength)))
    {
        return (pebi.IsWow64Process == 1);
    }

    return FALSE;
}

/*
* ntsupGetLoadedModulesListEx
*
* Purpose:
*
* Read list of loaded kernel modules.
*
*/
PVOID ntsupGetLoadedModulesListEx(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    NTSTATUS    ntStatus;
    PVOID       buffer;
    ULONG       bufferSize = PAGE_SIZE;

    PRTL_PROCESS_MODULES pvModules;
    SYSTEM_INFORMATION_CLASS infoClass;

    if (ReturnLength)
        *ReturnLength = 0;

    infoClass = ExtendedOutput ? SystemModuleInformationEx : SystemModuleInformation;

    buffer = AllocMem((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    ntStatus = NtQuerySystemInformation(
        infoClass,
        buffer,
        bufferSize,
        &bufferSize);

    if (ntStatus == STATUS_INFO_LENGTH_MISMATCH) {

        FreeMem(buffer);
        if (bufferSize == 0 || bufferSize > MAX_NTSUP_BUFFER_SIZE)
            return NULL;

        buffer = AllocMem((SIZE_T)bufferSize);
        if (buffer == NULL)
            return NULL;

        ntStatus = NtQuerySystemInformation(
            infoClass,
            buffer,
            bufferSize,
            &bufferSize);
    }

    if (ReturnLength)
        *ReturnLength = bufferSize;

    //
    // Handle special case:
    // If driver image path exceeds structure field size, 
    // RtlUnicodeStringToAnsiString will throw STATUS_BUFFER_OVERFLOW.
    // If this is the last driver in enumeration, service will return 
    // valid data but with STATUS_BUFFER_OVERFLOW result.
    //
    if (ntStatus == STATUS_BUFFER_OVERFLOW) {

        //
        // Force ignore this status if list is not empty.
        //
        pvModules = (PRTL_PROCESS_MODULES)buffer;
        if (pvModules->NumberOfModules != 0)
            return buffer;
    }

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    FreeMem(buffer);
    return NULL;
}

/*
* ntsupGetLoadedModulesList
*
* Purpose:
*
* Read list of loaded kernel modules.
*
* Returned buffer must be freed with ntsupHeapFree after usage.
*
*/
PVOID ntsupGetLoadedModulesList(
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(
        FALSE,
        ReturnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);
}

/*
* ntsupGetLoadedModulesList2
*
* Purpose:
*
* Read list of loaded kernel modules.
*
* Returned buffer must be freed with ntsupHeapFree after usage.
*
*/
PVOID ntsupGetLoadedModulesList2(
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(
        TRUE,
        ReturnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);
}

/*
* ntsupGetSystemInfoEx
*
* Purpose:
*
* Returns buffer with system information by given SystemInformationClass.
*
* Returned buffer must be freed with FreeMem function after usage.
*
*/
PVOID ntsupGetSystemInfoEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    PVOID       buffer = NULL;
    ULONG       bufferSize = PAGE_SIZE;
    NTSTATUS    ntStatus;
    ULONG       returnedLength = 0;

    if (ReturnLength)
        *ReturnLength = 0;

    buffer = AllocMem((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    while ((ntStatus = NtQuerySystemInformation(
        SystemInformationClass,
        buffer,
        bufferSize,
        &returnedLength)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        FreeMem(buffer);
        bufferSize <<= 1;

        if (bufferSize > MAX_NTSUP_BUFFER_SIZE)
            return NULL;

        buffer = AllocMem((SIZE_T)bufferSize);
        if (buffer == NULL)
            return NULL;
    }

    if (ReturnLength)
        *ReturnLength = returnedLength;

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    FreeMem(buffer);
    return NULL;
}

/*
* ntsupGetSystemInfo
*
* Purpose:
*
* Returns buffer with system information by given SystemInformationClass.
*
* Returned buffer must be freed with ntsupHeapFree after usage.
*
*/
PVOID ntsupGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetSystemInfoEx(
        SystemInformationClass,
        ReturnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);
}

/*
* ntsupResolveSymbolicLink
*
* Purpose:
*
* Resolve symbolic link target and copy it to the supplied buffer.
*
* Return FALSE on any error.
*
*/
BOOL ntsupResolveSymbolicLink(
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cbBuffer //size of buffer in bytes
)
{
    BOOL                bResult = FALSE;
    HANDLE              linkHandle = NULL;
    DWORD               cLength = 0;
    NTSTATUS            ntStatus;
    UNICODE_STRING      infoUString;
    OBJECT_ATTRIBUTES   objectAttr;

    if ((cbBuffer == 0) || (Buffer == NULL)) {
        RtlSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return bResult;
    }

    InitializeObjectAttributes(&objectAttr,
        LinkName, OBJ_CASE_INSENSITIVE, RootDirectoryHandle, NULL);

    ntStatus = NtOpenSymbolicLinkObject(&linkHandle,
        SYMBOLIC_LINK_QUERY,
        &objectAttr);

    if (!NT_SUCCESS(ntStatus) || (linkHandle == NULL)) {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
        return bResult;
    }

    cLength = (DWORD)(cbBuffer - sizeof(UNICODE_NULL));
    if (cLength >= MAX_USTRING) {
        cLength = MAX_USTRING - sizeof(UNICODE_NULL);
    }

    infoUString.Buffer = Buffer;
    infoUString.Length = (USHORT)cLength;
    infoUString.MaximumLength = (USHORT)(cLength + sizeof(UNICODE_NULL));

    ntStatus = NtQuerySymbolicLinkObject(linkHandle,
        &infoUString,
        NULL);

    bResult = (NT_SUCCESS(ntStatus));
    NtClose(linkHandle);
    return bResult;
}

/*
* ntsupQueryThreadWin32StartAddress
*
* Purpose:
*
* Lookups thread win32 start address.
*
*/
BOOL ntsupQueryThreadWin32StartAddress(
    _In_ HANDLE ThreadHandle,
    _Out_ PULONG_PTR Win32StartAddress
)
{
    ULONG returnLength;
    NTSTATUS ntStatus;
    ULONG_PTR win32StartAddress = 0;

    ntStatus = NtQueryInformationThread(
        ThreadHandle,
        ThreadQuerySetWin32StartAddress,
        &win32StartAddress,
        sizeof(ULONG_PTR),
        &returnLength);

    if (Win32StartAddress)
        *Win32StartAddress = win32StartAddress;

    return NT_SUCCESS(ntStatus);
}

/*
* ntsupOpenDirectoryEx
*
* Purpose:
*
* Open directory handle with DIRECTORY_QUERY access, with root directory support.
*
*/
_Success_(return)
NTSTATUS ntsupOpenDirectoryEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING DirectoryName,
    _In_ ACCESS_MASK DesiredAccess
)
{
    NTSTATUS          ntStatus;
    HANDLE            directoryHandle = NULL;
    OBJECT_ATTRIBUTES objectAttrbutes;

    InitializeObjectAttributes(&objectAttrbutes,
        DirectoryName, OBJ_CASE_INSENSITIVE, RootDirectoryHandle, NULL);

    ntStatus = NtOpenDirectoryObject(&directoryHandle,
        DesiredAccess,
        &objectAttrbutes);

    *DirectoryHandle = directoryHandle;

    return ntStatus;
}

/*
* ntsupOpenDirectory
*
* Purpose:
*
* Open directory handle with DIRECTORY_QUERY access, with root directory support.
*
*/
NTSTATUS ntsupOpenDirectory(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ LPCWSTR DirectoryName,
    _In_ ACCESS_MASK DesiredAccess
)
{
    UNICODE_STRING usName;

    RtlInitUnicodeString(&usName, DirectoryName);
    return ntsupOpenDirectoryEx(DirectoryHandle, RootDirectoryHandle, &usName, DesiredAccess);
}

/*
* ntsupQueryProcessName
*
* Purpose:
*
* Lookups process name by given process ID.
*
* If nothing found return FALSE.
*
*/
BOOL ntsupQueryProcessName(
    _In_ ULONG_PTR dwProcessId,
    _In_ PVOID ProcessList,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD ccBuffer //size of buffer in chars
)
{
    ULONG NextEntryDelta = 0, iteration = 0;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } List;

    List.ListRef = (PBYTE)ProcessList;

    do {

        List.ListRef += NextEntryDelta;

        if ((ULONG_PTR)List.Process->UniqueProcessId == dwProcessId) {

            _strncpy(
                Buffer,
                ccBuffer,
                List.Process->ImageName.Buffer,
                List.Process->ImageName.Length / sizeof(WCHAR));

            return TRUE;
        }

        NextEntryDelta = List.Process->NextEntryDelta;
        if (++iteration > MAX_NTSUP_PROCESS_ENUM_ITER)
            break;

    } while (NextEntryDelta);

    return FALSE;
}

/*
* ntsupQueryProcessEntryById
*
* Purpose:
*
* Lookups process entry by given process id.
*
* If nothing found return FALSE.
*
*/
BOOL ntsupQueryProcessEntryById(
    _In_ HANDLE UniqueProcessId,
    _In_ PVOID ProcessList,
    _Out_ PSYSTEM_PROCESS_INFORMATION* Entry
)
{
    ULONG NextEntryDelta = 0, iteration = 0;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } List;

    List.ListRef = (PBYTE)ProcessList;

    *Entry = NULL;

    do {

        List.ListRef += NextEntryDelta;

        if (List.Process->UniqueProcessId == UniqueProcessId) {
            *Entry = List.Process;
            return TRUE;
        }

        NextEntryDelta = List.Process->NextEntryDelta;
        if (++iteration > MAX_NTSUP_PROCESS_ENUM_ITER)
            break;

    } while (NextEntryDelta);

    return FALSE;
}

/*
* ntsupQueryProcessImageFileNameByProcessId
*
* Purpose:
*
* Query image path for given process id in NT format.
*
* Use FreeMem to release allocated buffer.
*
*/
NTSTATUS ntsupQueryProcessImageFileNameByProcessId(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING ProcessImageFileName,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    NTSTATUS ntStatus;
    SYSTEM_PROCESS_ID_INFORMATION processData;

    processData.ProcessId = UniqueProcessId;
    processData.ImageName.Length = 0;
    processData.ImageName.MaximumLength = 256;

    do {

        processData.ImageName.Buffer = (PWSTR)AllocMem(processData.ImageName.MaximumLength);
        if (processData.ImageName.Buffer == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;

        ntStatus = NtQuerySystemInformation(SystemProcessIdInformation,
            (PVOID)&processData,
            sizeof(SYSTEM_PROCESS_ID_INFORMATION),
            NULL);

        if (!NT_SUCCESS(ntStatus))
            FreeMem(processData.ImageName.Buffer);

    } while (ntStatus == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    *ProcessImageFileName = processData.ImageName;

    return ntStatus;
}

/*
* ntsupQuerySystemObjectInformationVariableSize
*
* Purpose:
*
* Generic object information query routine.
*
* Use FreeMem to release allocated buffer.
*
*/
NTSTATUS ntsupQuerySystemObjectInformationVariableSize(
    _In_ PFN_NTQUERYROUTINE QueryRoutine,
    _In_opt_ HANDLE ObjectHandle,
    _In_ DWORD InformationClass,
    _Out_ PVOID* Buffer,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    NTSTATUS ntStatus;
    PVOID queryBuffer;
    ULONG returnLengthLocal = 0;

    *Buffer = NULL;
    if (ReturnLength) *ReturnLength = 0;

    ntStatus = QueryRoutine(ObjectHandle,
        InformationClass,
        NULL,
        0,
        &returnLengthLocal);

    //
    // Test all possible acceptable failures.
    //
    if (ntStatus != STATUS_BUFFER_OVERFLOW &&
        ntStatus != STATUS_BUFFER_TOO_SMALL &&
        ntStatus != STATUS_INFO_LENGTH_MISMATCH)
    {
        return ntStatus;
    }

    if (returnLengthLocal == 0 || returnLengthLocal > MAX_NTSUP_BUFFER_SIZE)
        return STATUS_INVALID_BUFFER_SIZE;

    queryBuffer = AllocMem(returnLengthLocal);
    if (queryBuffer == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    ntStatus = QueryRoutine(ObjectHandle,
        InformationClass,
        queryBuffer,
        returnLengthLocal,
        &returnLengthLocal);

    if (NT_SUCCESS(ntStatus)) {
        *Buffer = queryBuffer;
        if (ReturnLength) *ReturnLength = returnLengthLocal;
    }
    else {
        FreeMem(queryBuffer);
    }

    return ntStatus;
}

/*
* ntsupQueryVsmProtectionInformation
*
* Purpose:
*
* Query VSM protection information.
*
*/
BOOLEAN ntsupQueryVsmProtectionInformation(
    _Out_ PBOOLEAN pbDmaProtectionsAvailable,
    _Out_ PBOOLEAN pbDmaProtectionsInUse,
    _Out_ PBOOLEAN pbHardwareMbecAvailable,
    _Out_ PBOOLEAN pbApicVirtualizationAvailable
)
{
    NTSTATUS ntStatus;
    ULONG returnLength;
    SYSTEM_VSM_PROTECTION_INFORMATION svpi;

    if (pbDmaProtectionsAvailable) *pbDmaProtectionsAvailable = FALSE;
    if (pbDmaProtectionsInUse) *pbDmaProtectionsInUse = FALSE;
    if (pbHardwareMbecAvailable) *pbHardwareMbecAvailable = FALSE;
    if (pbApicVirtualizationAvailable) *pbApicVirtualizationAvailable = FALSE;

    RtlSecureZeroMemory(&svpi, sizeof(SYSTEM_VSM_PROTECTION_INFORMATION));

    ntStatus = NtQuerySystemInformation(
        SystemVsmProtectionInformation,
        &svpi,
        sizeof(SYSTEM_VSM_PROTECTION_INFORMATION),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        if (pbDmaProtectionsAvailable) *pbDmaProtectionsAvailable = svpi.DmaProtectionsAvailable;
        if (pbDmaProtectionsInUse) *pbDmaProtectionsInUse = svpi.DmaProtectionsInUse;
        if (pbHardwareMbecAvailable) *pbHardwareMbecAvailable = svpi.HardwareMbecAvailable;
        if (pbApicVirtualizationAvailable) *pbApicVirtualizationAvailable = svpi.ApicVirtualizationAvailable;
        return TRUE;
    }
    else {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }

    return FALSE;
}

/*
* ntsupQueryHVCIState
*
* Purpose:
*
* Query HVCI/IUM state.
*
*/
BOOLEAN ntsupQueryHVCIState(
    _Out_ PBOOLEAN pbHVCIEnabled,
    _Out_ PBOOLEAN pbHVCIStrictMode,
    _Out_ PBOOLEAN pbHVCIIUMEnabled
)
{
    BOOLEAN hvciEnabled;
    ULONG returnLength;
    NTSTATUS ntStatus;
    SYSTEM_CODEINTEGRITY_INFORMATION ci;

    if (pbHVCIEnabled) *pbHVCIEnabled = FALSE;
    if (pbHVCIStrictMode) *pbHVCIStrictMode = FALSE;
    if (pbHVCIIUMEnabled) *pbHVCIIUMEnabled = FALSE;

    ci.Length = sizeof(ci);

    ntStatus = NtQuerySystemInformation(
        SystemCodeIntegrityInformation,
        &ci,
        sizeof(ci),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {

        hvciEnabled = ((ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED) &&
            (ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED));

        if (pbHVCIEnabled)
            *pbHVCIEnabled = hvciEnabled;

        if (pbHVCIStrictMode)
            *pbHVCIStrictMode = (hvciEnabled == TRUE) &&
            (ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED);

        if (pbHVCIIUMEnabled)
            *pbHVCIIUMEnabled = (ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED) > 0;

        return TRUE;
    }
    else {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }

    return FALSE;
}

/*
* ntsupLookupImageSectionByName
*
* Purpose:
*
* Lookup section pointer and size for section name.
*
*/
PVOID ntsupLookupImageSectionByName(
    _In_ CHAR* SectionName,
    _In_ ULONG SectionNameLength,
    _In_ PVOID DllBase,
    _Out_ PULONG SectionSize
)
{
    BOOLEAN bFound = FALSE;
    ULONG i;
    PVOID Section;
    IMAGE_NT_HEADERS* NtHeaders = RtlImageNtHeader(DllBase);
    IMAGE_SECTION_HEADER* SectionTableEntry;

    //
    // Assume failure.
    //
    if (SectionSize)
        *SectionSize = 0;

    if (NtHeaders == NULL)
        return NULL;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeaders +
        sizeof(ULONG) +
        sizeof(IMAGE_FILE_HEADER) +
        NtHeaders->FileHeader.SizeOfOptionalHeader);

    //
    // Locate section.
    //
    i = NtHeaders->FileHeader.NumberOfSections;
    while (i > 0) {

        if (_strncmp_a(
            (CHAR*)SectionTableEntry->Name,
            SectionName,
            SectionNameLength) == 0)
        {
            bFound = TRUE;
            break;
        }

        i -= 1;
        SectionTableEntry += 1;
    }

    //
    // Section not found, abort scan.
    //
    if (!bFound)
        return NULL;

    Section = (PVOID)((ULONG_PTR)DllBase + SectionTableEntry->VirtualAddress);
    if (SectionSize)
        *SectionSize = SectionTableEntry->Misc.VirtualSize;

    return Section;
}

/*
* ntsupFindPattern
*
* Purpose:
*
* Lookup pattern in buffer.
*
*/
PVOID ntsupFindPattern(
    _In_ CONST PBYTE Buffer,
    _In_ SIZE_T BufferSize,
    _In_ CONST PBYTE Pattern,
    _In_ SIZE_T PatternSize
)
{
    PBYTE p0 = Buffer, pnext;

    if (PatternSize == 0)
        return NULL;

    if (BufferSize < PatternSize)
        return NULL;

    do {
        pnext = (PBYTE)memchr(p0, Pattern[0], BufferSize);
        if (pnext == NULL)
            break;

        BufferSize -= (ULONG_PTR)(pnext - p0);

        if (BufferSize < PatternSize)
            return NULL;

        if (memcmp(pnext, Pattern, PatternSize) == 0)
            return pnext;

        p0 = pnext + 1;
        --BufferSize;
    } while (BufferSize > 0);

    return NULL;
}

/*
* ntsupFindPatternEx
*
* Purpose:
*
* Lookup pattern in buffer with specified mask.
*
*/
DWORD ntsupFindPatternEx(
    _In_ PATTERN_SEARCH_PARAMS* SearchParams
)
{
    PBYTE   p;
    DWORD   c, i, n;
    BOOLEAN found;
    BYTE    low, high;

    DWORD   bufferSize;

    if (SearchParams == NULL)
        return 0;

    if ((SearchParams->PatternSize == 0) || (SearchParams->PatternSize > SearchParams->BufferSize))
        return 0;

    bufferSize = SearchParams->BufferSize - SearchParams->PatternSize;

    for (n = 0, p = SearchParams->Buffer, c = 0; c <= bufferSize; ++p, ++c)
    {
        found = 1;
        for (i = 0; i < SearchParams->PatternSize; ++i)
        {
            low = p[i] & 0x0f;
            high = p[i] & 0xf0;

            if (SearchParams->Mask[i] & 0xf0)
            {
                if (high != (SearchParams->Pattern[i] & 0xf0))
                {
                    found = 0;
                    break;
                }
            }

            if (SearchParams->Mask[i] & 0x0f)
            {
                if (low != (SearchParams->Pattern[i] & 0x0f))
                {
                    found = 0;
                    break;
                }
            }

        }

        if (found) {

            if (SearchParams->Callback(p,
                SearchParams->PatternSize,
                SearchParams->CallbackContext))
            {
                return n + 1;
            }

            n++;
        }
    }

    return n;
}

/*
* ntsupOpenProcess
*
* Purpose:
*
* NtOpenProcess wrapper.
*
*/
NTSTATUS ntsupOpenProcess(
    _In_ HANDLE UniqueProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    NTSTATUS ntStatus;
    HANDLE processHandle = NULL;
    OBJECT_ATTRIBUTES objectAttributes = RTL_INIT_OBJECT_ATTRIBUTES((PUNICODE_STRING)NULL, 0);
    CLIENT_ID ClientId;

    ClientId.UniqueProcess = UniqueProcessId;
    ClientId.UniqueThread = NULL;

    ntStatus = NtOpenProcess(
        &processHandle,
        DesiredAccess,
        &objectAttributes,
        &ClientId);

    if (NT_SUCCESS(ntStatus)) {
        *ProcessHandle = processHandle;
    }

    return ntStatus;
}

/*
* ntsupOpenThread
*
* Purpose:
*
* NtOpenThread wrapper.
*
*/
NTSTATUS ntsupOpenThread(
    _In_ PCLIENT_ID ClientId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ThreadHandle
)
{
    NTSTATUS ntStatus;
    HANDLE threadHandle = NULL;
    OBJECT_ATTRIBUTES objectAttributes = RTL_INIT_OBJECT_ATTRIBUTES((PUNICODE_STRING)NULL, 0);

    ntStatus = NtOpenThread(
        &threadHandle,
        DesiredAccess,
        &objectAttributes,
        ClientId);

    if (NT_SUCCESS(ntStatus)) {
        *ThreadHandle = threadHandle;
    }

    return ntStatus;
}

/*
* ntsupCICustomKernelSignersAllowed
*
* Purpose:
*
* Return license state if present (EnterpriseG).
*
*/
NTSTATUS ntsupCICustomKernelSignersAllowed(
    _Out_ PBOOLEAN bAllowed)
{
    NTSTATUS ntStatus;
    ULONG uLicense = 0, dataSize;
    UNICODE_STRING usLicenseValue = RTL_CONSTANT_STRING(L"CodeIntegrity-AllowConfigurablePolicy-CustomKernelSigners");

    *bAllowed = FALSE;

    ntStatus = NtQueryLicenseValue(
        &usLicenseValue,
        NULL,
        (PVOID)&uLicense,
        sizeof(DWORD),
        &dataSize);

    if (NT_SUCCESS(ntStatus)) {
        *bAllowed = (uLicense != 0);
    }
    return ntStatus;
}

/*
* ntsupPrivilegeEnabled
*
* Purpose:
*
* Tests if the given token has the given privilege enabled/enabled by default.
*
*/
NTSTATUS ntsupPrivilegeEnabled(
    _In_ HANDLE ClientToken,
    _In_ ULONG Privilege,
    _Out_ LPBOOL pfResult
)
{
    NTSTATUS status;
    PRIVILEGE_SET Privs;
    BOOLEAN bResult = FALSE;

    Privs.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privs.PrivilegeCount = 1;
    Privs.Privilege[0].Luid.LowPart = Privilege;
    Privs.Privilege[0].Luid.HighPart = 0;
    Privs.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED;

    status = NtPrivilegeCheck(ClientToken, &Privs, &bResult);

    *pfResult = bResult;

    return status;
}

/*
* ntsupQueryEnvironmentVariableOffset
*
* Purpose:
*
* Return offset to the given environment variable.
*
*/
LPWSTR ntsupQueryEnvironmentVariableOffset(
    _In_ PUNICODE_STRING Value
)
{
    UNICODE_STRING   str1;
    PWCHAR           ptrEnvironment;
    ULONG            scanCount = 0;

    ptrEnvironment = (PWCHAR)RtlGetCurrentPeb()->ProcessParameters->Environment;

    do {
        if (*ptrEnvironment == 0 || scanCount++ > MAX_NTSUP_ENV_SCAN)
            return 0;

        RtlInitUnicodeString(&str1, ptrEnvironment);
        if (RtlPrefixUnicodeString(Value, &str1, TRUE))
            break;

        ptrEnvironment += _strlen(ptrEnvironment) + 1;

    } while (1);

    return (ptrEnvironment + Value->Length / sizeof(WCHAR));
}

/*
* ntsupExpandEnvironmentStrings
*
* Purpose:
*
* Reimplemented ExpandEnvironmentStrings.
*
*/
DWORD ntsupExpandEnvironmentStrings(
    _In_ LPCWSTR lpSrc,
    _Out_writes_to_opt_(nSize, return) LPWSTR lpDst,
    _In_ DWORD nSize
)
{
    NTSTATUS ntStatus;
    SIZE_T srcLength = 0, returnLength = 0, dstLength = (SIZE_T)nSize;

    if (lpSrc) {
        srcLength = _strlen(lpSrc);
    }

    ntStatus = RtlExpandEnvironmentStrings(
        NULL,
        (PWSTR)lpSrc,
        srcLength,
        (PWSTR)lpDst,
        dstLength,
        &returnLength);

    if ((NT_SUCCESS(ntStatus)) || (ntStatus == STATUS_BUFFER_TOO_SMALL)) {

        if (returnLength <= MAXDWORD32)
            return (DWORD)returnLength;

        ntStatus = STATUS_UNSUCCESSFUL;
    }
    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return 0;
}

/*
* ntsupIsUserHasInteractiveSid
*
* Purpose:
*
* pbInteractiveSid will be set to TRUE if current user has interactive sid, FALSE otherwise.
*
* Function return operation status code.
*
*/
NTSTATUS ntsupIsUserHasInteractiveSid(
    _In_ HANDLE hToken,
    _Out_ PBOOL pbInteractiveSid)
{
    BOOL isInteractiveSid = FALSE;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE heapHandle = NtCurrentPeb()->ProcessHeap;
    ULONG neededLength = 0;

    DWORD i;

    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    PSID pInteractiveSid = NULL;
    PTOKEN_GROUPS groupInfo = NULL;

    do {

        ntStatus = NtQueryInformationToken(
            hToken,
            TokenGroups,
            NULL,
            0,
            &neededLength);

        if (ntStatus != STATUS_BUFFER_TOO_SMALL)
            break;

        groupInfo = (PTOKEN_GROUPS)RtlAllocateHeap(
            heapHandle,
            HEAP_ZERO_MEMORY,
            neededLength);

        if (groupInfo == NULL)
            break;

        ntStatus = NtQueryInformationToken(
            hToken,
            TokenGroups,
            groupInfo,
            neededLength,
            &neededLength);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlAllocateAndInitializeSid(
            &SidAuth,
            1,
            SECURITY_INTERACTIVE_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pInteractiveSid);

        if (!NT_SUCCESS(ntStatus))
            break;

        for (i = 0; i < groupInfo->GroupCount; i++) {

            if (RtlEqualSid(
                pInteractiveSid,
                groupInfo->Groups[i].Sid))
            {
                isInteractiveSid = TRUE;
                break;
            }
        }

    } while (FALSE);

    if (groupInfo != NULL)
        RtlFreeHeap(heapHandle, 0, groupInfo);

    if (pbInteractiveSid)
        *pbInteractiveSid = isInteractiveSid;

    if (pInteractiveSid)
        RtlFreeSid(pInteractiveSid);

    return ntStatus;
}

/*
* ntsupIsLocalSystem
*
* Purpose:
*
* pbResult will be set to TRUE if current account is run by system user, FALSE otherwise.
*
* Function return operation status code.
*
*/
NTSTATUS ntsupIsLocalSystem(
    _Out_ PBOOL pbResult)
{
    BOOL                            bResult = FALSE;

    NTSTATUS                        ntStatus;
    HANDLE                          tokenHandle = NULL;
    HANDLE                          heapHandle = NtCurrentPeb()->ProcessHeap;

    ULONG                           neededLength = 0;

    PSID                            systemSid = NULL;
    PTOKEN_USER                     ptu = NULL;
    SID_IDENTIFIER_AUTHORITY        ntAuthority = SECURITY_NT_AUTHORITY;

    ntStatus = NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtQueryInformationToken(
            tokenHandle,
            TokenUser,
            NULL,
            0,
            &neededLength);

        if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

            ptu = (PTOKEN_USER)RtlAllocateHeap(
                heapHandle,
                HEAP_ZERO_MEMORY,
                neededLength);

            if (ptu) {

                ntStatus = NtQueryInformationToken(
                    tokenHandle,
                    TokenUser,
                    ptu,
                    neededLength,
                    &neededLength);

                if (NT_SUCCESS(ntStatus)) {

                    ntStatus = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &systemSid);

                    if (NT_SUCCESS(ntStatus)) {

                        bResult = RtlEqualSid(
                            ptu->User.Sid,
                            systemSid);

                        RtlFreeSid(systemSid);
                    }

                }
                RtlFreeHeap(heapHandle, 0, ptu);
            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } //STATUS_BUFFER_TOO_SMALL
        NtClose(tokenHandle);
    }

    if (pbResult)
        *pbResult = bResult;

    return ntStatus;
}

/*
* ntsupGetProcessElevationType
*
* Purpose:
*
* Returns process elevation type.
*
*/
BOOL ntsupGetProcessElevationType(
    _In_opt_ HANDLE ProcessHandle,
    _Out_ TOKEN_ELEVATION_TYPE * lpType
)
{
    HANDLE tokenHandle = NULL, processHandle = ProcessHandle;
    NTSTATUS ntStatus;
    ULONG returnedLength = 0;
    TOKEN_ELEVATION_TYPE tokenType = TokenElevationTypeDefault;

    if (ProcessHandle == NULL) {
        processHandle = GetCurrentProcess();
    }

    ntStatus = NtOpenProcessToken(processHandle, TOKEN_QUERY, &tokenHandle);
    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtQueryInformationToken(
            tokenHandle,
            TokenElevationType,
            &tokenType,
            sizeof(TOKEN_ELEVATION_TYPE),
            &returnedLength);

        NtClose(tokenHandle);
    }

    if (lpType)
        *lpType = tokenType;

    return (NT_SUCCESS(ntStatus));
}

/*
* ntsupIsProcessElevated
*
* Purpose:
*
* Returns process elevation state.
*
*/
NTSTATUS ntsupIsProcessElevated(
    _In_ ULONG ProcessId,
    _Out_ PBOOL Elevated)
{
    NTSTATUS ntStatus;
    ULONG returnedLength;
    HANDLE processHandle = NULL, tokenHandle = NULL;
    TOKEN_ELEVATION tokenInfo;

    if (Elevated) *Elevated = FALSE;

    ntStatus = ntsupOpenProcess(
        UlongToHandle(ProcessId),
        MAXIMUM_ALLOWED,
        &processHandle);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtOpenProcessToken(processHandle, TOKEN_QUERY, &tokenHandle);
        if (NT_SUCCESS(ntStatus)) {

            tokenInfo.TokenIsElevated = 0;
            ntStatus = NtQueryInformationToken(
                tokenHandle,
                TokenElevation,
                &tokenInfo,
                sizeof(TOKEN_ELEVATION),
                &returnedLength);

            if (NT_SUCCESS(ntStatus)) {

                if (Elevated)
                    *Elevated = (tokenInfo.TokenIsElevated > 0);

            }

            NtClose(tokenHandle);
        }
        NtClose(processHandle);
    }

    return ntStatus;
}

/*
* ntsupPurgeSystemCache
*
* Purpose:
*
* Flush file cache and memory standby list.
*
*/
VOID ntsupPurgeSystemCache(
    VOID
)
{
    SYSTEM_FILECACHE_INFORMATION sfc;
    SYSTEM_MEMORY_LIST_COMMAND smlc;

    //flush file system cache
    if (ntsupEnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE)) {
        RtlSecureZeroMemory(&sfc, sizeof(SYSTEM_FILECACHE_INFORMATION));
        sfc.MaximumWorkingSet = (SIZE_T)-1;
        sfc.MinimumWorkingSet = (SIZE_T)-1;
        NtSetSystemInformation(SystemFileCacheInformation, (PVOID)&sfc, sizeof(sfc));
    }

    //flush standby list
    if (ntsupEnablePrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE)) {
        smlc = MemoryPurgeStandbyList;
        NtSetSystemInformation(SystemMemoryListInformation, (PVOID)&smlc, sizeof(smlc));
    }
}

/*
* ntsupGetSystemRoot
*
* Purpose:
*
* Return system root directory silo session aware.
*
*/
PWSTR ntsupGetSystemRoot(
    VOID
)
{
    PEB* peb = NtCurrentPeb();

    if (peb->SharedData && peb->SharedData->ServiceSessionId)
        return peb->SharedData->NtSystemRoot;
    else
        return USER_SHARED_DATA->NtSystemRoot;
}

/*
* ntsupGetProcessDebugObject
*
* Purpose:
*
* Reference process debug object.
*
*/
NTSTATUS ntsupGetProcessDebugObject(
    _In_ HANDLE ProcessHandle,
    _Out_ PHANDLE DebugObjectHandle
)
{
    return NtQueryInformationProcess(
        ProcessHandle,
        ProcessDebugObjectHandle,
        DebugObjectHandle,
        sizeof(HANDLE),
        NULL);
}

/*
* ntsupQueryResourceData
*
* Purpose:
*
* Load resource by given id (win32 FindResource, SizeofResource, LockResource).
*
*/
PBYTE ntsupQueryResourceData(
    _In_ ULONG_PTR ResourceId,
    _In_ PVOID DllHandle,
    _In_ PULONG DataSize
)
{
    NTSTATUS                   ntStatus;
    ULONG_PTR                  idPath[3];
    IMAGE_RESOURCE_DATA_ENTRY* dataEntry;
    PBYTE                      dataPtr = NULL;
    ULONG                      dataSize = 0;

    if (DataSize) {
        *DataSize = 0;
    }

    if (DllHandle != NULL) {

        idPath[0] = (ULONG_PTR)RT_RCDATA; //type
        idPath[1] = ResourceId;           //id
        idPath[2] = 0;                    //lang

        ntStatus = LdrFindResource_U(DllHandle, (ULONG_PTR*)&idPath, 3, &dataEntry);
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = LdrAccessResource(DllHandle, dataEntry, (PVOID*)&dataPtr, &dataSize);
            if (NT_SUCCESS(ntStatus)) {
                if (DataSize) {
                    *DataSize = dataSize;
                }
            }
        }
    }
    return dataPtr;
}

/*
* ntsupEnableWow64Redirection
*
* Purpose:
*
* Enable/Disable Wow64 redirection.
*
*/
NTSTATUS ntsupEnableWow64Redirection(
    _In_ BOOLEAN bEnable
)
{
    PVOID OldValue = NULL, Value;

    Value = IntToPtr(bEnable);
    return RtlWow64EnableFsRedirectionEx(Value, &OldValue);
}

/*
* ntsupDetectObjectCallback
*
* Purpose:
*
* Comparer callback routine used in objects enumeration.
*
*/
NTSTATUS NTAPI ntsupDetectObjectCallback(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_ PVOID CallbackParam
)
{
    POBJSCANPARAM Param = (POBJSCANPARAM)CallbackParam;

    if (Entry == NULL) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (CallbackParam == NULL) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (Param->Buffer == NULL || Param->BufferSize == 0) {
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    if (Entry->Name.Buffer) {
        if (_strcmpi_w(Entry->Name.Buffer, Param->Buffer) == 0) {
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}

/*
* ntsupEnumSystemObjects
*
* Purpose:
*
* Lookup object by name in given directory.
*
*/
NTSTATUS NTAPI ntsupEnumSystemObjects(
    _In_opt_ LPCWSTR pwszRootDirectory,
    _In_opt_ HANDLE hRootDirectory,
    _In_ PENUMOBJECTSCALLBACK CallbackProc,
    _In_opt_ PVOID CallbackParam
)
{
    ULONG               ctx, rlen;
    HANDLE              hDirectory = NULL;
    NTSTATUS            status;
    NTSTATUS            CallbackStatus;
    OBJECT_ATTRIBUTES   attr;
    UNICODE_STRING      sname;

    POBJECT_DIRECTORY_INFORMATION    objinf;

    if (CallbackProc == NULL) {
        return STATUS_INVALID_PARAMETER_4;
    }

    status = STATUS_UNSUCCESSFUL;

    // We can use root directory.
    if (pwszRootDirectory != NULL) {
        RtlSecureZeroMemory(&sname, sizeof(sname));
        RtlInitUnicodeString(&sname, pwszRootDirectory);
        InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);
        status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
    else {
        if (hRootDirectory == NULL) {
            return STATUS_INVALID_PARAMETER_2;
        }
        hDirectory = hRootDirectory;
    }

    // Enumerate objects in directory.
    ctx = 0;
    do {

        rlen = 0;
        status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);
        if (status != STATUS_BUFFER_TOO_SMALL)
            break;

        objinf = (POBJECT_DIRECTORY_INFORMATION)ntsupHeapAlloc(rlen);
        if (objinf == NULL)
            break;

        status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);
        if (!NT_SUCCESS(status)) {
            ntsupHeapFree(objinf);
            break;
        }

        CallbackStatus = CallbackProc(objinf, CallbackParam);

        ntsupHeapFree(objinf);

        if (NT_SUCCESS(CallbackStatus)) {
            status = STATUS_SUCCESS;
            break;
        }

    } while (TRUE);

    if (hDirectory != NULL) {
        NtClose(hDirectory);
    }

    return status;
}

/*
* ntsupIsObjectExists
*
* Purpose:
*
* Return TRUE if the given object exists, FALSE otherwise.
*
*/
BOOLEAN ntsupIsObjectExists(
    _In_ LPCWSTR RootDirectory,
    _In_ LPCWSTR ObjectName
)
{
    OBJSCANPARAM Param;

    Param.Buffer = ObjectName;
    Param.BufferSize = (ULONG)_strlen(ObjectName);

    return NT_SUCCESS(ntsupEnumSystemObjects(RootDirectory, NULL, ntsupDetectObjectCallback, &Param));
}

/*
* ntsupUserIsFullAdmin
*
* Purpose:
*
* Tests if the current user is admin with full access token.
*
*/
BOOLEAN ntsupUserIsFullAdmin(
    VOID
)
{
    BOOLEAN  bResult = FALSE;
    HANDLE   hToken = NULL;
    NTSTATUS status;
    DWORD    i, Attributes;
    ULONG    ReturnLength = 0;

    PTOKEN_GROUPS pTkGroups;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup = NULL;

    hToken = ntsupGetCurrentProcessToken();
    if (hToken) {
        if (NT_SUCCESS(RtlAllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &AdministratorsGroup)))
        {
            status = ntsupQueryTokenInformation(hToken,
                TokenGroups,
                &pTkGroups,
                &ReturnLength,
                (PNTSUPMEMALLOC)ntsupHeapAlloc,
                (PNTSUPMEMFREE)ntsupHeapFree);

            if (NT_SUCCESS(status)) {

                for (i = 0; i < pTkGroups->GroupCount; i++) {

                    Attributes = pTkGroups->Groups[i].Attributes;

                    if (RtlEqualSid(AdministratorsGroup, pTkGroups->Groups[i].Sid))
                        if (
                            (Attributes & SE_GROUP_ENABLED) &&
                            (!(Attributes & SE_GROUP_USE_FOR_DENY_ONLY))
                            )
                        {
                            bResult = TRUE;
                            break;
                        }

                }

                ntsupHeapFree(pTkGroups);
            }
            RtlFreeSid(AdministratorsGroup);
        }

        NtClose(hToken);
    }
    return bResult;
}

/*
* ntsupHashImageSections
*
* Purpose:
*
* Produce a SHA-256 hash for a PE image mapping in memory (either a raw
* file mapping or a loaded module) by hashing the PE headers plus every
* executable section.
*
*/
NTSTATUS ntsupHashImageSections(
    _In_ PVOID ImageBase,
    _In_ SIZE_T ImageSize,          // Size of image mapping
    _Out_writes_bytes_(HashBufferSize) PBYTE HashBuffer,
    _In_ SIZE_T HashBufferSize,
    _In_ NTSUP_IMAGE_TYPE ImageType
)
{
    BOOL anySectionHashed;
    PIMAGE_NT_HEADERS ntHeaders;
    PIMAGE_SECTION_HEADER sectionHeader;
    ULONG numberOfSections, i;
    ULONG_PTR baseAddress = (ULONG_PTR)ImageBase;
    NTSUP_SHA256_CTX ctx;
    ULONG_PTR sectionStart, headersEnd;
    SIZE_T toHash, sizeOfHeaders, maxVirtualSize, maxRawSize, maxSafeSize;

    //
    // Validate parameters.
    //
    if (ImageBase == NULL || HashBuffer == NULL)
        return STATUS_INVALID_PARAMETER;

    if (HashBufferSize < NTSUPHASH_SHA256_SIZE)
        return STATUS_BUFFER_TOO_SMALL;

    if (ImageSize == 0)
        return STATUS_INVALID_PARAMETER;

    //
    // Get NT headers with boundary check.
    //
    if (!NT_SUCCESS(RtlImageNtHeaderEx(0,
        ImageBase,
        ImageSize,
        (PIMAGE_NT_HEADERS*)&ntHeaders)) || ntHeaders == NULL) 
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (ntHeaders->OptionalHeader.SizeOfImage == 0)
        return STATUS_INVALID_IMAGE_FORMAT;

    //
    // Validate image size matches reported size.
    //
    if (ntHeaders->OptionalHeader.SizeOfImage > ImageSize &&
        ImageType == ImageTypeLoaded) 
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    numberOfSections = ntHeaders->FileHeader.NumberOfSections;

    //
    // Validate section headers are within image bounds.
    //
    if (numberOfSections == 0 ||
        numberOfSections > (MAXULONG_PTR / sizeof(IMAGE_SECTION_HEADER)))
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
    headersEnd = (ULONG_PTR)sectionHeader +
        (numberOfSections * sizeof(IMAGE_SECTION_HEADER));

    if (headersEnd < (ULONG_PTR)sectionHeader ||
        headersEnd > baseAddress + ImageSize)
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    ntsupSha256Init(&ctx);

    //
    // Hash PE headers first.
    //
    sizeOfHeaders = min(ntHeaders->OptionalHeader.SizeOfHeaders, ImageSize);
    if (sizeOfHeaders) {
        ntsupSha256Update(&ctx, (PUCHAR)ImageBase, sizeOfHeaders);
    }

    anySectionHashed = FALSE;

    //
    // Process each section.
    //
    for (i = 0; i < numberOfSections; i++, sectionHeader++) {
        // Only hash executable sections
        if ((sectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) == 0)
            continue;

        //
        // Determine section location based on image type.
        //
        if (ImageType == ImageTypeLoaded) {
            //
            // For loaded modules: use virtual addresses.
            //
            if (sectionHeader->VirtualAddress == 0 ||
                sectionHeader->Misc.VirtualSize == 0) {
                continue;
            }

            //
            // Skip sections outside loaded image.
            //
            if (sectionHeader->VirtualAddress >= ntHeaders->OptionalHeader.SizeOfImage) {
                continue;
            }

            maxVirtualSize = ntHeaders->OptionalHeader.SizeOfImage - sectionHeader->VirtualAddress;
            toHash = min(sectionHeader->Misc.VirtualSize, maxVirtualSize);
            sectionStart = baseAddress + sectionHeader->VirtualAddress;
        }
        else {
            //
            // For raw files: use file offsets.
            //
            if (sectionHeader->PointerToRawData == 0 ||
                sectionHeader->SizeOfRawData == 0) {
                continue;
            }

            //
            // Skip sections outside file.
            //
            if (sectionHeader->PointerToRawData >= ImageSize) {
                continue;
            }

            maxRawSize = ImageSize - sectionHeader->PointerToRawData;
            toHash = min(sectionHeader->SizeOfRawData, maxRawSize);
            sectionStart = baseAddress + sectionHeader->PointerToRawData;
        }

        if (sectionStart < baseAddress ||
            sectionStart >= baseAddress + ImageSize) 
        {
            continue;
        }

        maxSafeSize = (baseAddress + ImageSize) - sectionStart;
        if (toHash > maxSafeSize) {
            toHash = maxSafeSize;
        }

        ntsupSha256Update(&ctx, (PUCHAR)sectionStart, toHash);
        anySectionHashed = TRUE;
    }

    //
    // Return header-only hash if no executable sections found.
    //
    ntsupSha256Final(&ctx, HashBuffer);
    if (!anySectionHashed)
        return STATUS_NOT_FOUND;

    return STATUS_SUCCESS;
}

#pragma warning(pop)

```

`Source/Shared/ntos/ntsup.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2011 - 2025 UGN/HE
*
*  TITLE:       NTSUP.H
*
*  VERSION:     2.25
*
*  DATE:        18 Aug 2025
*
*  Common header file for the NT API support functions and definitions.
*
*  Depends on:    ntos.h
*                 minirtl
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#define ENABLE_C_EXTERN

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef NTSUP_RTL
#define NTSUP_RTL

#pragma warning(push)
#pragma warning(disable: 4201) // nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int
#pragma warning(disable: 26812) // enum type % is unscoped

#ifndef _WINDOWS_
#include <Windows.h>
#endif

#pragma warning(push)
#pragma warning(disable: 4005) //macro redefinition
#include <ntstatus.h>
#pragma warning(pop)

#include "ntos.h"

#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_

#include "minirtl/minirtl.h"

#ifdef ENABLE_C_EXTERN
#if defined(__cplusplus)
extern "C" {
#endif
#endif

typedef NTSTATUS(NTAPI* PFN_NTQUERYROUTINE)(
   _In_opt_ HANDLE ObjectHandle,
   _In_ DWORD InformationClass,
   _Out_writes_bytes_(ObjectInformationLength) PVOID ObjectInformation,
   _In_ ULONG ObjectInformationLength,
   _Out_opt_ PULONG ReturnLength);

typedef PVOID(CALLBACK* PNTSUPMEMALLOC)(
    _In_ SIZE_T NumberOfBytes);

typedef BOOL(CALLBACK* PNTSUPMEMFREE)(
    _In_ PVOID Memory);

#define ntsupProcessHeap() NtCurrentPeb()->ProcessHeap

#define NTSUPHASH_SHA256_SIZE 32

#define MAX_NTSUP_BUFFER_SIZE (512 * 1024 * 1024) //512MB
#define MAX_NTSUP_ENV_SCAN 4096
#define MAX_NTSUP_PROCESS_ENUM_ITER (1024 * 1024)
#define MAX_NTSUP_WRITE_CHUNK 0x7FFFFFFF

typedef struct _OBJSCANPARAM {
    PCWSTR Buffer;
    ULONG BufferSize;
} OBJSCANPARAM, * POBJSCANPARAM;

typedef NTSTATUS(NTAPI* PENUMOBJECTSCALLBACK)(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry, 
    _In_opt_ PVOID CallbackParam);

typedef BOOL(CALLBACK* pfnPatternSearchCallback)(
    _In_ PBYTE Buffer,
    _In_ ULONG PatternSize,
    _In_opt_ PVOID CallbackContext
    );

typedef struct _PATTERN_SEARCH_PARAMS {
    PBYTE Buffer;
    DWORD BufferSize;
    PBYTE Pattern;
    DWORD PatternSize;
    PBYTE Mask;
    pfnPatternSearchCallback Callback;
    PVOID CallbackContext;
} PATTERN_SEARCH_PARAMS, * PPATTERN_SEARCH_PARAMS;

typedef enum _NTSUP_IMAGE_TYPE {
    ImageTypeRaw,       // Raw file mapping (CreateFileMapping)
    ImageTypeLoaded     // Loaded module (PEB/LdrEntry)
} NTSUP_IMAGE_TYPE;

PVOID ntsupHeapAlloc(
    _In_ SIZE_T Size);

VOID ntsupHeapFree(
    _In_ PVOID BaseAddress);

PVOID ntsupVirtualAllocEx(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

PVOID ntsupVirtualAlloc(
    _In_ SIZE_T Size);

BOOL ntsupVirtualFree(
    _In_ PVOID Memory);

BOOL ntsupVirtualLock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize);

BOOL ntsupVirtualUnlock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize);

SIZE_T ntsupWriteBufferToFile(
    _In_ PCWSTR FileName,
    _In_ PVOID Buffer,
    _In_ SIZE_T Size,
    _In_ BOOL Flush,
    _In_ BOOL Append,
    _Out_opt_ NTSTATUS* Result);

PVOID ntsupGetModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address);

PVOID ntsupFindModuleEntryByName(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCSTR ModuleName);

PVOID ntsupFindModuleEntryByName_U(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCWSTR ModuleName);

BOOL ntsupFindModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Out_ PULONG ModuleIndex);

PVOID ntsupFindModuleNameByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD ccBuffer);

NTSTATUS ntsupConvertToUnicode(
    _In_ LPCSTR AnsiString,
    _Inout_ PUNICODE_STRING UnicodeString);

NTSTATUS ntsupConvertToAnsi(
    _In_ LPCWSTR UnicodeString,
    _Inout_ PANSI_STRING AnsiString);

BOOLEAN ntsupEnablePrivilege(
    _In_ DWORD Privilege,
    _In_ BOOLEAN Enable);

HANDLE ntsupGetCurrentProcessToken(
    VOID);

ULONG_PTR ntsupQuerySystemRangeStart(
    VOID);

BOOLEAN ntsupQueryUserModeAccessibleRange(
    _Out_ PULONG_PTR MinimumUserModeAddress,
    _Out_ PULONG_PTR MaximumUserModeAddress);

BOOL ntsupIsProcess32bit(
    _In_ HANDLE hProcess);

PVOID ntsupGetLoadedModulesListEx(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

PVOID ntsupGetLoadedModulesList(
    _Out_opt_ PULONG ReturnLength);

PVOID ntsupGetLoadedModulesList2(
    _Out_opt_ PULONG ReturnLength);

PVOID ntsupGetSystemInfoEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

PVOID ntsupGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI ntsupEnumSystemObjects(
    _In_opt_ LPCWSTR pwszRootDirectory,
    _In_opt_ HANDLE hRootDirectory,
    _In_ PENUMOBJECTSCALLBACK CallbackProc,
    _In_opt_ PVOID CallbackParam);

BOOL ntsupResolveSymbolicLink(
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cbBuffer);

BOOL ntsupQueryThreadWin32StartAddress(
    _In_ HANDLE ThreadHandle,
    _Out_ PULONG_PTR Win32StartAddress);

_Success_(return)
NTSTATUS ntsupOpenDirectoryEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING DirectoryName,
    _In_ ACCESS_MASK DesiredAccess);

NTSTATUS ntsupOpenDirectory(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ LPCWSTR DirectoryName,
    _In_ ACCESS_MASK DesiredAccess);

BOOL ntsupQueryProcessName(
    _In_ ULONG_PTR dwProcessId,
    _In_ PVOID ProcessList,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD ccBuffer);

BOOL ntsupQueryProcessEntryById(
    _In_ HANDLE UniqueProcessId,
    _In_ PVOID ProcessList,
    _Out_ PSYSTEM_PROCESS_INFORMATION* Entry);

NTSTATUS ntsupQueryProcessImageFileNameByProcessId(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING ProcessImageFileName,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

NTSTATUS ntsupQuerySystemObjectInformationVariableSize(
    _In_ PFN_NTQUERYROUTINE QueryRoutine,
    _In_opt_ HANDLE ObjectHandle,
    _In_ DWORD InformationClass,
    _Out_ PVOID* Buffer,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

BOOLEAN ntsupQueryVsmProtectionInformation(
    _Out_ PBOOLEAN pbDmaProtectionsAvailable,
    _Out_ PBOOLEAN pbDmaProtectionsInUse,
    _Out_ PBOOLEAN pbHardwareMbecAvailable,
    _Out_ PBOOLEAN pbApicVirtualizationAvailable);

BOOLEAN ntsupQueryHVCIState(
    _Out_ PBOOLEAN pbHVCIEnabled,
    _Out_ PBOOLEAN pbHVCIStrictMode,
    _Out_ PBOOLEAN pbHVCIIUMEnabled);

PVOID ntsupLookupImageSectionByName(
    _In_ CHAR* SectionName,
    _In_ ULONG SectionNameLength,
    _In_ PVOID DllBase,
    _Out_ PULONG SectionSize);

PVOID ntsupFindPattern(
    _In_ CONST PBYTE Buffer,
    _In_ SIZE_T BufferSize,
    _In_ CONST PBYTE Pattern,
    _In_ SIZE_T PatternSize);

DWORD ntsupFindPatternEx(
    _In_ PATTERN_SEARCH_PARAMS * SearchParams);

NTSTATUS ntsupOpenProcess(
    _In_ HANDLE UniqueProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

NTSTATUS ntsupOpenThread(
    _In_ PCLIENT_ID ClientId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ThreadHandle);

NTSTATUS ntsupCICustomKernelSignersAllowed(
    _Out_ PBOOLEAN bAllowed);

NTSTATUS ntsupPrivilegeEnabled(
    _In_ HANDLE ClientToken,
    _In_ ULONG Privilege,
    _Out_ LPBOOL pfResult);

LPWSTR ntsupQueryEnvironmentVariableOffset(
    _In_ PUNICODE_STRING Value);

DWORD ntsupExpandEnvironmentStrings(
    _In_ LPCWSTR lpSrc,
    _Out_writes_to_opt_(nSize, return) LPWSTR lpDst,
    _In_ DWORD nSize);

NTSTATUS ntsupIsLocalSystem(
    _Out_ PBOOL pbResult);

NTSTATUS ntsupIsUserHasInteractiveSid(
    _In_ HANDLE hToken,
    _Out_ PBOOL pbInteractiveSid);

BOOL ntsupGetProcessElevationType(
    _In_opt_ HANDLE ProcessHandle,
    _Out_ TOKEN_ELEVATION_TYPE * lpType);

NTSTATUS ntsupIsProcessElevated(
    _In_ ULONG ProcessId,
    _Out_ PBOOL Elevated);

VOID ntsupPurgeSystemCache(
    VOID);

PWSTR ntsupGetSystemRoot(
    VOID);

NTSTATUS ntsupGetProcessDebugObject(
    _In_ HANDLE ProcessHandle,
    _Out_ PHANDLE DebugObjectHandle);

PBYTE ntsupQueryResourceData(
    _In_ ULONG_PTR ResourceId,
    _In_ PVOID DllHandle,
    _In_ PULONG DataSize);

NTSTATUS ntsupEnableWow64Redirection(
    _In_ BOOLEAN bEnable);

BOOLEAN ntsupIsKdEnabled(
    _Out_opt_ PBOOLEAN DebuggerAllowed,
    _Out_opt_ PBOOLEAN DebuggerNotPresent);

BOOLEAN ntsupIsObjectExists(
    _In_ LPCWSTR RootDirectory,
    _In_ LPCWSTR ObjectName);

BOOLEAN ntsupUserIsFullAdmin(
    VOID);

NTSTATUS ntsupHashImageSections(
    _In_ PVOID ImageBase,
    _In_ SIZE_T ImageSize,
    _Out_writes_bytes_(HashBufferSize) PBYTE HashBuffer,
    _In_ SIZE_T HashBufferSize,
    _In_ NTSUP_IMAGE_TYPE ImageType);

#define ntsupQuerySecurityInformation(\
     ObjectHandle, SecurityInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQuerySecurityObject, \
     ObjectHandle, SecurityInformationClass, (PVOID*)Buffer, ReturnLength,\
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryTokenInformation(\
     TokenHandle, TokenInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryInformationToken, \
     TokenHandle, TokenInformationClass, (PVOID*)Buffer, ReturnLength,\
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryObjectInformation(\
     ObjectHandle, ObjectInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryObject, \
    ObjectHandle, ObjectInformationClass, (PVOID*)Buffer, ReturnLength, \
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryThreadInformation(\
    ThreadHandle, ThreadInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryInformationThread, \
    ThreadHandle, ThreadInformationClass, (PVOID*)Buffer, ReturnLength, \
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryProcessInformation(\
    ProcessHandle, ProcessInformationClass, Buffer, ReturnLength, AllocMem, FreeMem)\
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryInformationProcess, \
    ProcessHandle, ProcessInformationClass, (PVOID*)Buffer, ReturnLength, \
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)


#ifdef ENABLE_C_EXTERN
#ifdef __cplusplus
}
#endif
#endif

#pragma warning(pop)

#endif NTSUP_RTL

```

`Source/Shared/ntuser/ntuser.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2023
*  Translated from Microsoft sources/debugger or mentioned elsewhere.
*
*  TITLE:       NTUSER.H
*
*  VERSION:     1.19
*
*  DATE:        21 Jun 2023
*
*  Common header file for the NtUser API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*                 NtOs.h
*
*  Include:       Windows.h
*                 NtStatus.h
*                 NtOs.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef NTUSER_RTL
#define NTUSER_RTL

//
// NtUser definitions are incomplete and only valid for Windows 10 RS4+
//
enum HANDLE_TYPE {
    TYPE_FREE = 0,
    TYPE_WINDOW = 1,
    TYPE_MENU = 2,
    TYPE_CURSOR = 3,
    TYPE_SETWINDOWPOS = 4,
    TYPE_HOOK = 5,
    TYPE_CLIPDATA = 6,
    TYPE_CALLPROC = 7,
    TYPE_ACCELTABLE = 8,
    TYPE_DDEACCESS = 9,
    TYPE_DDECONV = 10,
    TYPE_DDEXACT = 11,
    TYPE_MONITOR = 12,
    TYPE_KBDLAYOUT = 13,
    TYPE_KBDFILE = 14,
    TYPE_WINEVENTHOOK = 15,
    TYPE_TIMER = 16,
    TYPE_INPUTCONTEXT = 17,
    TYPE_HIDDATA = 18,
    TYPE_DEVICEINFO = 19,
    TYPE_TOUCHINPUT = 20,
    TYPE_GESTUREINFO = 21,
    TYPE_CTYPES = 22,
    TYPE_GENERIC = 255
};

#define TIF_INCLEANUP               0x00000001
#define TIF_16BIT                   0x00000002
#define TIF_SYSTEMTHREAD            0x00000004
#define TIF_CSRSSTHREAD             0x00000008
#define TIF_TRACKRECTVISIBLE        0x00000010
#define TIF_ALLOWFOREGROUNDACTIVATE 0x00000020
#define TIF_DONTATTACHQUEUE         0x00000040
#define TIF_DONTJOURNALATTACH       0x00000080
#define TIF_WOW64                   0x00000100
#define TIF_INACTIVATEAPPMSG        0x00000200
#define TIF_SPINNING                0x00000400
#define TIF_PALETTEAWARE            0x00000800
#define TIF_SHAREDWOW               0x00001000
#define TIF_FIRSTIDLE               0x00002000
#define TIF_WAITFORINPUTIDLE        0x00004000
#define TIF_MOVESIZETRACKING        0x00008000
#define TIF_VDMAPP                  0x00010000
#define TIF_DOSEMULATOR             0x00020000
#define TIF_GLOBALHOOKER            0x00040000
#define TIF_DELAYEDEVENT            0x00080000
#define TIF_MSGPOSCHANGED           0x00100000
#define TIF_SHUTDOWNCOMPLETE        0x00200000
#define TIF_IGNOREPLAYBACKDELAY     0x00400000
#define TIF_ALLOWOTHERACCOUNTHOOK   0x00800000
#define TIF_GUITHREADINITIALIZED    0x02000000
#define TIF_DISABLEIME              0x04000000
#define TIF_INGETTEXTLENGTH         0x08000000
#define TIF_ANSILENGTH              0x10000000
#define TIF_DISABLEHOOKS            0x20000000

#define HANDLEF_DESTROY        0x01
#define HANDLEF_INDESTROY      0x02
#define HANDLEF_MARKED_OK      0x10
#define HANDLEF_GRANTED        0x20
#define HANDLEF_POOL           0x40
#define HANDLEF_VALID          0x7F

#if defined(__cplusplus)
extern "C" {
#endif

#ifdef _WIN32ULIB_PRESENT
#pragma comment(lib, "win32u.lib")
#endif

typedef struct _SERVERINFO {
    WORD wRIPFlags;
    WORD wSRVIFlags;
    WORD wRIPPID;
    WORD wRIPError;
    ULONG cHandleEntries; //+8 
    ULONG_PTR pDispInfo;
    // incomplete
} SERVERINFO, * PSERVERINFO;

typedef struct _HANDLEENTRY {
    HANDLE hWnd;
    HANDLE pti;
    PVOID rpdesk;
    BYTE bType;
    BYTE bFlags;
    USHORT wUniq;
} HANDLEENTRY, * PHANDLEENTRY;

typedef struct _tagWND {
    HANDLE hWnd;
    ULONG_PTR DesktopHeapOffset;
    ULONG_PTR UnknownFlags;
    DWORD dwExStyle;
    DWORD dwStyle;
    BYTE Spare[0x130];
} tagWND, * PWND; //sizeof 0x150

//win 11  v33 = HMAllocObject(v208, v255, v31, 328); 0x148

typedef struct _DESKINFO {
    PVOID rpdesk;
} DESKINFO, * PDESKINFO;

typedef struct _CLIENTINFO {
    ULONG_PTR CI_Flags;
    ULONG_PTR cSpins;
    DWORD dwExpWinVer;
    DWORD dwCompatFlags;
    DWORD dwCompatFlags2;
    DWORD dwTIFlags;
    PDESKINFO pDeskInfo;
    PVOID DesktopHeap;
    //incomplete
} CLIENTINFO, * PCLIENTINFO;

typedef struct _SHAREDINFO {
    PSERVERINFO	psi;
    PHANDLEENTRY aheList;
    ULONG HeEntrySize;
    // incomplete
} SHAREDINFO, * PSHAREDINFO;

#define HMINDEXBITS             0x0000FFFF      // bits where index is stored
#define HMUNIQSHIFT             16              // bits to shift uniqueness
#define HMUNIQBITS              0xFFFF          // valid uniqueness bits
#define HMUniqFromHandle(h)     ((WORD)((((ULONG_PTR)h) >> HMUNIQSHIFT) & HMUNIQBITS))
#define HMIndexFromHandle(h)    ((ULONG)(((ULONG_PTR)(h)) & HMINDEXBITS))
#define PtiFromHe(p)            (((PHANDLEENTRY)p)->pti)

typedef enum tagPROCESS_UICONTEXT {
    PROCESS_UICONTEXT_DESKTOP = 0,
    PROCESS_UICONTEXT_IMMERSIVE = 1,
    PROCESS_UICONTEXT_IMMERSIVE_BROKER = 2,
    PROCESS_UICONTEXT_IMMERSIVE_BROWSER = 3
} PROCESS_UICONTEXT;

typedef enum tagPROCESS_UI_FLAGS {
    PROCESS_UIF_NONE = 0,
    PROCESS_UIF_AUTHORING_MODE = 1,
    PROCESS_UIF_RESTRICTIONS_DISABLED = 2
} PROCESS_UI_FLAGS;

typedef struct tagPROCESS_UICONTEXT_INFORMATION {
    DWORD processUIContext; //PROCESS_UICONTEXT
    DWORD dwFlags; //PROCESS_UI_FLAGS
} PROCESS_UICONTEXT_INFORMATION, * PPROCESS_UICONTEXT_INFORMATION;


typedef HWINSTA(NTAPI* pfnNtUserOpenWindowStation)(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ACCESS_MASK DesiredAccess);


#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTUSER_RTL

```

`Source/Shared/sdk/extdef.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       EXTAPI.H
*
*  VERSION:     2.07
*
*  DATE:        04 Feb 2025
*
*  Windows SDK compatibility header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#ifndef PRODUCT_ENTERPRISE_S
#define PRODUCT_ENTERPRISE_S 0x0000007D
#endif

#ifndef PRODUCT_ENTERPRISE_S_N
#define PRODUCT_ENTERPRISE_S_N 0x0000007E
#endif

#ifndef PRODUCT_ENTERPRISE_S_EVALUATION
#define PRODUCT_ENTERPRISE_S_EVALUATION 0x00000081
#endif

#ifndef PRODUCT_ENTERPRISE_S_N_EVALUATION
#define PRODUCT_ENTERPRISE_S_N_EVALUATION 0x00000082
#endif

#ifndef PRODUCT_IOTENTERPRISES
#define PRODUCT_IOTENTERPRISES 0x000000BF
#endif

#define sidTypeUser 1
#define sidTypeGroup 2
#define sidTypeDomain 3
#define sidTypeAlias 4
#define sidTypeWellKnownGroup 5 
#define sidTypeDeletedAccount 6
#define sidTypeInvalid 7
#define sidTypeUnknown 8
#define sidTypeComputer 9
#define sidTypeLabel 10
#define sidTypeLogonSession 11

#ifndef UFIELD_OFFSET
#define UFIELD_OFFSET(type, field)    ((DWORD)(LONG_PTR)&(((type *)0)->field))
#endif

//
// These constants are missing in Windows SDK 8.1
//
#ifndef SYSTEM_ACCESS_FILTER_ACE_TYPE
#define SYSTEM_ACCESS_FILTER_ACE_TYPE           (0x15)
#endif

#ifndef IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG
#define IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG 17
#endif

#ifndef SERVICE_USER_SERVICE
#define SERVICE_USER_SERVICE                        0x00000040
#endif

#ifndef SERVICE_USERSERVICE_INSTANCE
#define SERVICE_USERSERVICE_INSTANCE                0x00000080
#endif

#ifndef SERVICE_PKG_SERVICE
#define SERVICE_PKG_SERVICE                         0x00000200
#endif

#ifndef PF_RDTSCP_INSTRUCTION_AVAILABLE
#define PF_RDTSCP_INSTRUCTION_AVAILABLE             32
#endif

#ifndef PF_RDPID_INSTRUCTION_AVAILABLE
#define PF_RDPID_INSTRUCTION_AVAILABLE              33
#endif

#ifndef PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE
#define PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE    34
#endif

#ifndef PF_MONITORX_INSTRUCTION_AVAILABLE
#define PF_MONITORX_INSTRUCTION_AVAILABLE           35   
#endif

#ifndef PF_SSSE3_INSTRUCTIONS_AVAILABLE
#define PF_SSSE3_INSTRUCTIONS_AVAILABLE             36
#endif

#ifndef PF_SSE4_1_INSTRUCTIONS_AVAILABLE
#define PF_SSE4_1_INSTRUCTIONS_AVAILABLE            37
#endif

#ifndef PF_SSE4_2_INSTRUCTIONS_AVAILABLE
#define PF_SSE4_2_INSTRUCTIONS_AVAILABLE            38
#endif

#ifndef PF_AVX_INSTRUCTIONS_AVAILABLE
#define PF_AVX_INSTRUCTIONS_AVAILABLE               39
#endif

#ifndef PF_AVX2_INSTRUCTIONS_AVAILABLE
#define PF_AVX2_INSTRUCTIONS_AVAILABLE              40
#endif

#ifndef PF_AVX512F_INSTRUCTIONS_AVAILABLE
#define PF_AVX512F_INSTRUCTIONS_AVAILABLE           41
#endif

#ifndef PF_ERMS_AVAILABLE
#define PF_ERMS_AVAILABLE                           42
#endif

#ifndef PF_BMI2_INSTRUCTIONS_AVAILABLE
#define PF_BMI2_INSTRUCTIONS_AVAILABLE              60
#endif

#ifndef VER_SUITE_MULTIUSERTS
#define VER_SUITE_MULTIUSERTS 0x00020000
#endif

#ifndef FILE_SUPPORTS_BLOCK_REFCOUNTING     
#define FILE_SUPPORTS_BLOCK_REFCOUNTING             0
#endif

#ifndef _WIN32_WINNT_WIN10

DECLARE_HANDLE(DPI_AWARENESS_CONTEXT);

typedef enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
} DPI_AWARENESS;

#define DPI_AWARENESS_CONTEXT_UNAWARE               ((DPI_AWARENESS_CONTEXT)-1)
#define DPI_AWARENESS_CONTEXT_SYSTEM_AWARE          ((DPI_AWARENESS_CONTEXT)-2)
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE     ((DPI_AWARENESS_CONTEXT)-3)
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2  ((DPI_AWARENESS_CONTEXT)-4)
#define DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED     ((DPI_AWARENESS_CONTEXT)-5)

#endif //_WIN32_WINNT_WIN10

#ifndef NTDDI_WINTHRESHOLD
#define NTDDI_WINTHRESHOLD 0x0A000000   /* ABRACADABRA_THRESHOLD */
#endif

#ifndef NTDDI_WIN10
#define NTDDI_WIN10 0x0A000000          /* ABRACADABRA_THRESHOLD */
#endif 

#ifndef NTDDI_WIN10_TH2
#define NTDDI_WIN10_TH2 0x0A000001      /* ABRACADABRA_WIN10_TH2 */
#endif

#ifndef NTDDI_WIN10_RS1
#define NTDDI_WIN10_RS1 0x0A000002      /* ABRACADABRA_WIN10_RS1 */
#endif

#ifndef NTDDI_WIN10_RS2
#define NTDDI_WIN10_RS2 0x0A000003      /* ABRACADABRA_WIN10_RS2 */
#endif

#ifndef NTDDI_WIN10_RS3
#define NTDDI_WIN10_RS3 0x0A000004      /* ABRACADABRA_WIN10_RS3 */
#endif

#ifndef NTDDI_WIN10_RS4
#define NTDDI_WIN10_RS4 0x0A000005      /* ABRACADABRA_WIN10_RS4 */
#endif

#ifndef NTDDI_WIN10_RS5
#define NTDDI_WIN10_RS5 0x0A000006      /* ABRACADABRA_WIN10_RS5 */
#endif

#ifndef NTDDI_WIN10_19H1
#define NTDDI_WIN10_19H1 0x0A000007     /* ABRACADABRA_WIN10_19H1 */
#endif

#ifndef NTDDI_WIN10_VB
#define NTDDI_WIN10_VB 0x0A000008       /* ABRACADABRA_WIN10_VB */
#endif

#ifndef NTDDI_WIN10_MN
#define NTDDI_WIN10_MN 0x0A000009       /* ABRACADABRA_WIN10_MN */
#endif

#ifndef NTDDI_WIN10_FE
#define NTDDI_WIN10_FE 0x0A00000A       /* ABRACADABRA_WIN10_FE */
#endif

#ifndef NTDDI_WIN10_CO
#define NTDDI_WIN10_CO 0x0A00000B       /* ABRACADABRA_WIN10_C0 */
#endif

#ifndef NTDDI_WIN10_NI
#define NTDDI_WIN10_NI 0x0A00000C       /* ABRACADABRA_WIN10_NI */
#endif

#ifndef NTDDI_WIN10_CU
#define NTDDI_WIN10_CU 0x0A00000D       /* ABRACADABRA_WIN10_CU */
#endif

#ifndef NTDDI_WIN11_ZN
#define NTDDI_WIN11_ZN 0x0A00000E       /* ABRACADABRA_WIN11_ZN */
#endif

#ifndef NTDDI_WIN11_GA
#define NTDDI_WIN11_GA 0x0A00000F       /* ABRACADABRA_WIN11_GA */
#endif

#ifndef NTDDI_WIN11_GE
#define NTDDI_WIN11_GE 0x0A000010       /* ABRACADABRA_WIN11_GE */
#endif

#ifndef NTDDI_WIN11_SE
#define NTDDI_WIN11_SE 0x0A000011       /* ABRACADABRA_WIN11_SE */
#endif

FORCEINLINE LONG_PTR _InterlockedExchangeAddPointer(
    _Inout_ _Interlocked_operand_ LONG_PTR volatile* Addend,
    _In_ LONG_PTR Value
)
{
#ifdef _WIN64
    return (LONG_PTR)_InterlockedExchangeAdd64((PLONG64)Addend, (LONG64)Value);
#else
    return (LONG_PTR)_InterlockedExchangeAdd((PLONG)Addend, (LONG)Value);
#endif
}

FORCEINLINE LONG_PTR _InterlockedIncrementPointer(
    _Inout_ _Interlocked_operand_ LONG_PTR volatile* Addend
)
{
#ifdef _WIN64
    return (LONG_PTR)_InterlockedIncrement64((PLONG64)Addend);
#else
    return (LONG_PTR)_InterlockedIncrement((PLONG)Addend);
#endif
}

FORCEINLINE LONG_PTR _InterlockedDecrementPointer(
    _Inout_ _Interlocked_operand_ LONG_PTR volatile* Addend
)
{
#ifdef _WIN64
    return (LONG_PTR)_InterlockedDecrement64((PLONG64)Addend);
#else
    return (LONG_PTR)_InterlockedDecrement((PLONG)Addend);
#endif
}

FORCEINLINE BOOLEAN _InterlockedBitTestAndResetPointer(
    _Inout_ _Interlocked_operand_ LONG_PTR volatile* Base,
    _In_ LONG_PTR Bit
)
{
#ifdef _WIN64
    return _interlockedbittestandreset64((PLONG64)Base, (LONG64)Bit);
#else
    return _interlockedbittestandreset((PLONG)Base, (LONG)Bit);
#endif
}

FORCEINLINE BOOLEAN _InterlockedBitTestAndSetPointer(
    _Inout_ _Interlocked_operand_ LONG_PTR volatile* Base,
    _In_ LONG_PTR Bit
)
{
#ifdef _WIN64
    return _interlockedbittestandset64((PLONG64)Base, (LONG64)Bit);
#else
    return _interlockedbittestandset((PLONG)Base, (LONG)Bit);
#endif
}

```

`Source/Shared/tabs/tabsctrl.c`:

```c
/*++

Copyright (c) 2015-2025 (see AUTHORS.txt).

Module Name:

    tabctrl.cpp

Abstract:

    Set of functions used with tab component.

    VERSION 2.1 (08.06.2025)

    WinObjEx64 version.

--*/

#define OEMRESOURCE
#include "tabsctrl.h"

/*
* TabDefaultWndProc
*
* Purpose:
*
* Default empty window procedure for tab pages.
*
*/
INT_PTR CALLBACK TabDefaultWndProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    return 0;
}

/*
* TabResizeTabWindow
*
* Purpose:
*
* Resize the tab control and its content window.
*
*/
VOID TabResizeTabWindow(
    _In_ PTABHDR hdr
)
{
    HWND hParentWnd;
    RECT tr, dr;

    hParentWnd = GetParent(hdr->hwndTab);

    RtlZeroMemory(&tr, sizeof(RECT));
    RtlZeroMemory(&dr, sizeof(RECT));

    TabCtrl_AdjustRect(hdr->hwndTab, FALSE, &tr);
    if (GetClientRect(hdr->hwndTab, &dr)) {

        SetWindowPos(hdr->hwndDisplay,
            HWND_TOP,
            dr.left + tr.left,
            dr.top + tr.top,
            dr.right - dr.left + tr.right - tr.left,
            dr.bottom - dr.top + tr.bottom - tr.top,
            SWP_SHOWWINDOW);

    }

    if (hdr->OnResize != NULL)
        hdr->OnResize(hdr);
}

/*
* TabGetItem
*
* Purpose:
*
* Find tab entry by index.
*
* Returns NULL if not found.
*
*/
PTABENTRY TabGetItem(
    _In_ PTABHDR hdr,
    _In_ INT nIndex
)
{
    PTABENTRY tabEntry;
    PLIST_ENTRY Entry;

    Entry = hdr->tabsHead.Flink;
    while ((Entry != NULL) && (Entry != &hdr->tabsHead)) {

        tabEntry = CONTAINING_RECORD(Entry, TABENTRY, ListEntry);
        if (nIndex == tabEntry->TabIndex)
            return tabEntry;

        Entry = Entry->Flink;
    }
    return NULL;
}

/*
* TabOnSelChanged
*
* Purpose:
*
* Handle tab selection change event.
*
*/
VOID TabOnSelChanged(
    _In_ PTABHDR hdr
)
{
    INT nCurrentTab;
    PTABENTRY tabEntry;

    //get currently selected page
    nCurrentTab = TabCtrl_GetCurSel(hdr->hwndTab);
    if (nCurrentTab < 0)
        return;

    //destroy previous window
    if (hdr->hwndDisplay != NULL) {
        DestroyWindow(hdr->hwndDisplay);
        hdr->hwndDisplay = 0;
    }

    if (hdr->OnSelChange != NULL)
        hdr->OnSelChange(hdr, nCurrentTab);

    tabEntry = TabGetItem(hdr, nCurrentTab);
    if (tabEntry == NULL)
        return;

    hdr->hwndDisplay = CreateDialogParam(hdr->hInstance,
        MAKEINTRESOURCE(tabEntry->ResId),
        GetParent(hdr->hwndTab),
        tabEntry->DlgProc,
        (LPARAM)tabEntry->UserParam);

    if (hdr->hwndDisplay) {
        TabResizeTabWindow(hdr);
    }

}

/*
* TabDestroyControl
*
* Purpose:
*
* Destroy tab control and free all resources.
*
*/
VOID TabDestroyControl(
    _In_ PTABHDR hdr
)
{
    PTABENTRY tabEntry;
    PLIST_ENTRY entry;
    TABCALLBACK_FREEMEM pFree;

    if (hdr) {
        pFree = hdr->FreeMem;
        entry = hdr->tabsHead.Flink;

        while ((entry != NULL) && (entry != &hdr->tabsHead)) {
            tabEntry = CONTAINING_RECORD(entry, TABENTRY, ListEntry);
            entry = entry->Flink;
            pFree(tabEntry);
        }
        pFree(hdr);
    }
}

/*
* TabAddPage
*
* Purpose:
*
* Add a new page to the tab control.
*
* Returns TRUE on success, FALSE otherwise.
*
*/
BOOL TabAddPage(
    _In_ PTABHDR hdr,
    _In_ INT ResId,
    _In_opt_ DLGPROC DlgProc,
    _In_ LPTSTR szCaption,
    _In_ INT iImage,
    _In_ LPARAM lParam
)
{
    PTABENTRY tabEntry;
    TC_ITEM tie;
    INT tabIndex;

    tabEntry = (PTABENTRY)hdr->MemAlloc(sizeof(TABENTRY));
    if (tabEntry == NULL)
        return FALSE;

    RtlSecureZeroMemory(&tie, sizeof(TC_ITEM));
    tie.mask = TCIF_TEXT;
    tie.pszText = szCaption;

    if (hdr->hImageList != NULL) {
        tie.mask |= TCIF_IMAGE;
        tie.iImage = iImage;
    }

    if (lParam) {
        tie.mask |= TCIF_PARAM;
        tie.lParam = lParam;
    }

    tabIndex = TabCtrl_InsertItem(hdr->hwndTab, hdr->tabsCount, &tie);
    if (tabIndex < 0) {
        hdr->FreeMem(tabEntry);
        return FALSE;
    }

    tabEntry->TabIndex = tabIndex;
    hdr->tabsCount++;

    tabEntry->DlgProc = (DlgProc == NULL) ? (DLGPROC)&TabDefaultWndProc : DlgProc;
    tabEntry->ResId = ResId;
    tabEntry->UserParam = (PVOID)lParam;

    InsertHeadList(&hdr->tabsHead, &tabEntry->ListEntry);
    return TRUE;
}

/*
* TabDeletePage
*
* Purpose:
*
* Delete a page from the tab control.
*
* Returns TRUE on success, FALSE otherwise.
*
*/
BOOL TabDeletePage(
    _In_ PTABHDR hdr,
    _In_ INT TabIndex
)
{
    BOOL bResult;
    PTABENTRY tabEntry;

    bResult = TabCtrl_DeleteItem(hdr->hwndTab, TabIndex);
    if (bResult) {
        hdr->tabsCount--;

        tabEntry = TabGetItem(hdr, TabIndex);
        if (tabEntry) {
            RemoveEntryList(&tabEntry->ListEntry);
            hdr->FreeMem(tabEntry);
        }

        if (TabCtrl_GetCurSel(hdr->hwndTab) < 0) {
            TabCtrl_SetCurSel(hdr->hwndTab, 0);
        }
        TabOnSelChanged(hdr);
    }
    return bResult;
}

/*
* TabCreateControl
*
* Purpose:
*
* Create and initialize a new tab control.
*
* Returns pointer to TABHDR structure on success, NULL otherwise.
*
*/
PTABHDR TabCreateControl(
    _In_ HINSTANCE hInstance,
    _In_ HWND hParentWnd,
    _In_opt_ HIMAGELIST hImageList,
    _In_opt_ TABSELCHANGECALLBACK OnSelChangeTab,
    _In_opt_ TABRESIZECALLBACK OnResizeTab,
    _In_ TABCALLBACK_ALLOCMEM MemAlloc,
    _In_ TABCALLBACK_FREEMEM MemFree
)
{
    RECT rcTab;
    HWND hwndTab;
    PTABHDR result;
    LONG dwDlgBase;

    RECT rc;

    GetClientRect(hParentWnd, &rc);

    hwndTab = CreateWindowEx(0, WC_TABCONTROL, 0,
        TCS_FIXEDWIDTH | WS_CHILD | WS_VISIBLE,
        rc.left + 2, rc.top + 2, rc.right, rc.bottom,
        hParentWnd, 0, hInstance, 0);

    if (hwndTab == NULL)
        return NULL;

    // Set the font of the tabs to a more typical system GUI font.
    SendMessage(hwndTab, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), 0);

    result = (PTABHDR)MemAlloc(sizeof(TABHDR));
    if (result == NULL) {
        DestroyWindow(hwndTab);
        return NULL;
    }

    dwDlgBase = GetDialogBaseUnits();
    result->cxMargin = LOWORD(dwDlgBase) / 4;
    result->cyMargin = HIWORD(dwDlgBase) / 8;

    result->hwndTab = hwndTab;
    result->hInstance = hInstance;
    result->tabsCount = 0;
    result->OnResize = OnResizeTab;
    result->OnSelChange = OnSelChangeTab;
    result->MemAlloc = MemAlloc;
    result->FreeMem = MemFree;

    InitializeListHead(&result->tabsHead);

    if (hImageList != NULL) {
        TabCtrl_SetImageList(result->hwndTab, hImageList);
        result->hImageList = hImageList;
    }

    SetRectEmpty(&rcTab);
    GetWindowRect(result->hwndTab, &rcTab);

    TabCtrl_AdjustRect(result->hwndTab, TRUE, &rcTab);

    OffsetRect(&rcTab, result->cxMargin - rcTab.left, result->cyMargin - rcTab.top);
    CopyRect(&result->rcDisplay, &rcTab);

    TabCtrl_AdjustRect(result->hwndTab, FALSE, &result->rcDisplay);

    SetWindowPos(result->hwndTab, 0,
        rcTab.left, rcTab.top,
        rcTab.right - rcTab.left,
        rcTab.bottom - rcTab.top,
        SWP_NOZORDER);

    return result;
}

/*
* TabOnChangeTab
*
* Purpose:
*
* Handle tab control notification events.
*
*/
VOID TabOnChangeTab(
    _In_ PTABHDR hdr,
    _In_ LPNMHDR pnmhdr
)
{
    UINT TAB_SELECTION_CHANGE_NOTIFICATION = TCN_SELCHANGE;
    if ((pnmhdr == NULL) || (hdr == NULL))
        return;

    if (pnmhdr->hwndFrom != hdr->hwndTab)
        return;

    if (pnmhdr->code == TAB_SELECTION_CHANGE_NOTIFICATION) {
        EnableWindow(hdr->hwndTab, FALSE);//lock change
        TabOnSelChanged(hdr); //call actual handler
        EnableWindow(hdr->hwndTab, TRUE); //unlock
    }
}

```

`Source/Shared/tabs/tabsctrl.h`:

```h
/*++

Copyright (c) 2015 (see AUTHORS.txt).

Module Name:

    tabctrl.h

Abstract:

    This file contains function prototypes/variables used by GUI tabs component.

    VERSION 2.0 (01.02.2015)

    WinObjEx64 version.

--*/

#pragma once

#ifndef _GUITABSUNIT_
#define _GUITABSUNIT_

#include <Windows.h>
#include <Windowsx.h>
#include <CommCtrl.h>
#include "ntos/ntos.h"

typedef struct _tagTABHDR* PTABHDR;

typedef VOID(CALLBACK* TABRESIZECALLBACK)(
    _In_ PTABHDR hdr);

typedef VOID(CALLBACK* TABSELCHANGECALLBACK)(
    _In_ PTABHDR hdr,
    _In_ INT SelectedPage);

typedef PVOID(CALLBACK* TABCALLBACK_ALLOCMEM)(
    _In_ SIZE_T size);

typedef BOOL(CALLBACK* TABCALLBACK_FREEMEM)(
    _In_ PVOID ptr);

typedef struct _TABENTRY {
    LIST_ENTRY ListEntry;
    INT TabIndex;
    INT ResId;
    DLGPROC DlgProc;
    PVOID UserParam; // sent as lParam to newly created page dialog
} TABENTRY, * PTABENTRY;

typedef struct _tagTABHDR {

    HWND hwndTab; //tab control window handle
    HWND hwndDisplay; //current page window handle
    RECT rcDisplay;

    HINSTANCE hInstance;
    INT tabsCount;

    HIMAGELIST hImageList;

    TABSELCHANGECALLBACK OnSelChange;
    TABRESIZECALLBACK OnResize;

    TABCALLBACK_ALLOCMEM MemAlloc;
    TABCALLBACK_FREEMEM FreeMem;

    LIST_ENTRY tabsHead;

    INT cxMargin;
    INT cyMargin;

} TABHDR, * PTABHDR;

PTABHDR TabCreateControl(
    _In_ HINSTANCE hInstance,
    _In_ HWND hParentWnd,
    _In_opt_ HIMAGELIST hImageList,
    _In_opt_ TABSELCHANGECALLBACK OnSelChangeTab,
    _In_opt_ TABRESIZECALLBACK OnResizeTab,
    _In_ TABCALLBACK_ALLOCMEM MemAlloc,
    _In_ TABCALLBACK_FREEMEM MemFree);

BOOL TabAddPage(
    _In_ PTABHDR hdr,
    _In_ INT ResId,
    _In_opt_ DLGPROC DlgProc,
    _In_ LPTSTR szCaption,
    _In_ INT iImage,
    _In_ LPARAM lParam);

BOOL TabDeletePage(
    _In_ PTABHDR hdr,
    _In_ INT TabIndex);

VOID TabDestroyControl(
    _In_ PTABHDR hdr);

VOID TabOnChangeTab(
    _In_ PTABHDR hdr,
    _In_ LPNMHDR pnmhdr);

VOID TabOnSelChanged(
    _In_ PTABHDR hdr);

VOID TabResizeTabWindow(
    _In_ PTABHDR hdr);

#endif /* _GUITABSUNIT_ */

```

`Source/Shared/treelist/treelist.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       TREELIST.C
*
*  VERSION:     1.36
*
*  DATE:        20 Sep 2022
*
*  TreeList control.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#define OEMRESOURCE
#include <Windows.h>
#include <Windowsx.h>
#include <CommCtrl.h>
#include <Uxtheme.h>
#include <vsstyle.h>
#include <vssym32.h>
#include "treelist.h"
#include "minirtl\minirtl.h"
#pragma comment(lib, "Uxtheme.lib")

HTHEME  tl_theme = NULL;

VOID AddTooltipItemSub(
    HWND TreeControl,
    HWND ToolTips,
    UINT_PTR itemid,
    UINT_PTR lParam,
    LPRECT rect
)
{
    TOOLINFO tool;
    RtlSecureZeroMemory(&tool, sizeof(tool));

#ifdef UNICODE
    tool.cbSize = TTTOOLINFOW_V2_SIZE;
#else
    tool.cbSize = TTTOOLINFOA_V2_SIZE;
#endif // UNICODE

    tool.uFlags = TTF_SUBCLASS | TTF_TRANSPARENT;
    tool.uId = itemid;
    tool.hwnd = TreeControl;
    tool.lParam = lParam;
    tool.rect = *rect;
    tool.lpszText = LPSTR_TEXTCALLBACK;
    SendMessage(ToolTips, TTM_ADDTOOL, 0, (LPARAM)&tool);
}

VOID TreeListUpdateTooltips(
    HWND hwndTreeList
)
{
    PTL_SUBITEMS    subitems;
    RECT            rc, subrc, treerc;
    TOOLINFO        tool;
    ULONG           ToolCount, newToolId;
    SIZE_T          i;
    LONG            cx;
    TVITEMEX        itemex;
    HWND            TreeControl = (HWND)GetWindowLongPtr(hwndTreeList, TL_TREECONTROL_SLOT),
        ToolTips = (HWND)GetWindowLongPtr(hwndTreeList, TL_TOOLTIPS_SLOT),
        Header = (HWND)GetWindowLongPtr(hwndTreeList, TL_HEADERCONTROL_SLOT);
    HTREEITEM       item = TreeView_GetRoot(TreeControl);

    ToolCount = (ULONG)SendMessage(ToolTips, TTM_GETTOOLCOUNT, 0, 0);
    RtlSecureZeroMemory(&tool, sizeof(tool));
    tool.cbSize = sizeof(tool);

    for (i = 0; i < ToolCount; i++)
    {
        if (SendMessage(ToolTips, TTM_ENUMTOOLS, 0, (LPARAM)&tool))
            SendMessage(ToolTips, TTM_DELTOOL, 0, (LPARAM)&tool);
    }

    GetClientRect(TreeControl, &treerc);
    Header_GetItemRect(Header, 0, &rc);
    cx = rc.right;
    ToolCount = 0;

    while (item) {
        while (TreeView_GetItemRect(TreeControl, item, &rc, TRUE))
        {
            RtlSecureZeroMemory(&itemex, sizeof(itemex));
            itemex.hItem = item;
            itemex.mask = TVIF_HANDLE | TVIF_PARAM;
            TreeView_GetItem(TreeControl, &itemex);

            if (rc.right > cx)
                rc.right = cx;

            if ((rc.bottom < 0) || (rc.top >= treerc.bottom))
                break;

            newToolId = ToolCount++;
            AddTooltipItemSub(TreeControl, ToolTips, newToolId, (UINT_PTR)item, &rc);

            if (!itemex.lParam)
                break;

            subitems = (PTL_SUBITEMS)itemex.lParam;
            for (i = 0; i < subitems->Count; i++) {

                if (!Header_GetItemRect(Header, i + 1, &subrc))
                    break;

                subrc.top = rc.top;
                subrc.bottom = rc.bottom;
                AddTooltipItemSub(TreeControl, ToolTips, (0x1000 * (i + 1)) + newToolId, (UINT_PTR)item, &subrc);
            }

            break; //-V612
        }
        item = TreeView_GetNextVisible(TreeControl, item);
    }
}

LRESULT TreeListCustomDraw(
    HWND hwndHeader,
    LPNMTVCUSTOMDRAW pdraw
)
{
    TCHAR           textbuf[MAX_PATH];
    TVITEMEX        item;
    HDITEM          hdritem;
    HBRUSH          brush;
    HPEN            pen;
    RECT            hr, ir, subr;
    LONG            i, ColumnCount, cx;
    PTL_SUBITEMS    subitem;
    HGDIOBJ         prev;
    BOOL            ItemSelected, first_iter = TRUE;
    HIMAGELIST      ImgList;
    HTREEITEM       iparent;

    if ((pdraw->nmcd.dwDrawStage & CDDS_ITEM) == 0)
        return CDRF_NOTIFYITEMDRAW;

    ItemSelected = pdraw->nmcd.uItemState & CDIS_FOCUS;

    RtlSecureZeroMemory(&item, sizeof(item));
    RtlSecureZeroMemory(&textbuf, sizeof(textbuf));
    item.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM | TVIF_CHILDREN | TVIF_STATE | TVIF_IMAGE;
    item.hItem = (HTREEITEM)pdraw->nmcd.dwItemSpec;
    item.cchTextMax = (sizeof(textbuf) / sizeof(TCHAR)) - 1;
    item.pszText = textbuf;
    TreeView_GetItem(pdraw->nmcd.hdr.hwndFrom, &item);
    subitem = (PTL_SUBITEMS)item.lParam;

    TreeView_GetItemRect(pdraw->nmcd.hdr.hwndFrom, (HTREEITEM)pdraw->nmcd.dwItemSpec, &ir, TRUE);
    ImgList = TreeView_GetImageList(pdraw->nmcd.hdr.hwndFrom, TVSIL_NORMAL);

    if ((GetWindowLongPtr(GetParent(hwndHeader), GWL_STYLE) & TLSTYLE_LINKLINES))
    {
        iparent = (HTREEITEM)pdraw->nmcd.dwItemSpec;
        cx = ir.left - 11;

        while (iparent != NULL) {

            if (TreeView_GetNextSibling(pdraw->nmcd.hdr.hwndFrom, iparent) == NULL)
            {
                if (first_iter)
                {
                    for (i = 0; i < (ir.bottom - ir.top) / 2; i += 2)
                        SetPixel(pdraw->nmcd.hdc, cx, ir.top + i, 0xe0b0b0);
                }
            }
            else
            {
                for (i = ir.top; i < ir.bottom; i += 2)
                    SetPixel(pdraw->nmcd.hdc, cx, i, 0xe0b0b0);
            }

            first_iter = FALSE;
            cx -= 19;
            iparent = TreeView_GetParent(pdraw->nmcd.hdr.hwndFrom, iparent);
        }

        if (textbuf[0] != 0)
        {
            cx = 1 + ir.top + (ir.bottom - ir.top) / 2;
            for (i = ir.left - 11; i < ir.left; i += 2)
                SetPixel(pdraw->nmcd.hdc, i, cx, 0xe0b0b0);
        }
    }

    if (ImgList != NULL)
        ImageList_Draw(ImgList, item.iImage, pdraw->nmcd.hdc, ir.left - 18, ir.top, ILD_NORMAL);

    if (item.cChildren == 1) // msdn: The item has one or more child items.
    {
        subr.top = ir.top;
        subr.bottom = subr.top + ir.bottom - ir.top;
        subr.left = ir.left - (ir.bottom - ir.top);

        if (ImgList != NULL)
            subr.left -= 38;

        subr.right = ir.left;

        FillRect(pdraw->nmcd.hdc, &subr, (HBRUSH)WHITE_BRUSH);
        if (S_OK != DrawThemeBackground(tl_theme, pdraw->nmcd.hdc, TVP_GLYPH, item.state & TVIS_EXPANDED ? GLPS_OPENED : GLPS_CLOSED, &subr, NULL))
        {
            if ((item.state & TVIS_EXPANDED) == 0)
            {
                MoveToEx(pdraw->nmcd.hdc, subr.left + 4, subr.top + 4, NULL);
                LineTo(pdraw->nmcd.hdc, subr.left + 9, subr.top + 9);
                LineTo(pdraw->nmcd.hdc, subr.left + 4, subr.top + 14);
                LineTo(pdraw->nmcd.hdc, subr.left + 4, subr.top + 4);
            }
            else
            {
                MoveToEx(pdraw->nmcd.hdc, subr.left + 2, subr.top + 6, NULL);
                LineTo(pdraw->nmcd.hdc, subr.left + 7, subr.top + 11);
                LineTo(pdraw->nmcd.hdc, subr.left + 12, subr.top + 6);
                LineTo(pdraw->nmcd.hdc, subr.left + 2, subr.top + 6);
            }
        }
    }

    cx = 0;
    ColumnCount = Header_GetItemCount(hwndHeader);
    for (i = 0; i < ColumnCount; i++) {
        RtlSecureZeroMemory(&hr, sizeof(hr));
        Header_GetItemRect(hwndHeader, i, &hr);
        if (hr.right > cx)
            cx = hr.right;
    }

    if (subitem && ItemSelected == 0) {
        if (subitem->ColorFlags & TLF_BGCOLOR_SET) {
            pdraw->clrTextBk = subitem->BgColor;
            SetBkColor(pdraw->nmcd.hdc, subitem->BgColor);
        }

        if (subitem->ColorFlags & TLF_FONTCOLOR_SET) {
            pdraw->clrText = subitem->FontColor;
            SetTextColor(pdraw->nmcd.hdc, subitem->FontColor);
        }
    }

    brush = CreateSolidBrush(pdraw->clrTextBk);
    subr.top = ir.top;
    subr.bottom = ir.bottom - 1;
    subr.left = ir.left;
    subr.right = cx;
    FillRect(pdraw->nmcd.hdc, &subr, brush);
    DeleteObject(brush);

    if (!ItemSelected) {
        for (i = 1; i < ColumnCount; i++) {
            RtlSecureZeroMemory(&hr, sizeof(hr));
            Header_GetItemRect(hwndHeader, i, &hr);

            RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
            hdritem.mask = HDI_LPARAM;
            Header_GetItem(hwndHeader, i, &hdritem);

            if (hdritem.lParam != 0)
            {
                brush = CreateSolidBrush((COLORREF)hdritem.lParam);
                subr.top = ir.top;
                subr.bottom = ir.bottom - 1;
                subr.left = hr.left;
                subr.right = hr.right;
                FillRect(pdraw->nmcd.hdc, &subr, brush);
                DeleteObject(brush);
            }
        }
    }

    Header_GetItemRect(hwndHeader, 0, &hr);
    subr.right = hr.right - 3;
    subr.left = ir.left + 3;
    DrawText(pdraw->nmcd.hdc, textbuf, -1, &subr, DT_END_ELLIPSIS | DT_VCENTER | DT_SINGLELINE);

    ir.right = cx;

    pen = CreatePen(PS_SOLID, 1, 0xfbf3e5);// GetSysColor(COLOR_MENUBAR));
    prev = SelectObject(pdraw->nmcd.hdc, pen);

    for (i = 0; i < ColumnCount; i++) {
        RtlSecureZeroMemory(&hr, sizeof(hr));
        Header_GetItemRect(hwndHeader, i, &hr);

        RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
        hdritem.mask = HDI_LPARAM;
        Header_GetItem(hwndHeader, i, &hdritem);

        if ((i > 0) && subitem)
            if (i <= (LONG)subitem->Count)
                if (subitem->Text[i - 1]) {
                    subr.top = ir.top;
                    subr.bottom = ir.bottom;
                    subr.left = hr.left + 3;
                    subr.right = hr.right - 3;

                    if (!ItemSelected)
                    {
                        if (subitem->ColorFlags & TLF_BGCOLOR_SET) {
                            pdraw->clrTextBk = subitem->BgColor;
                            SetBkColor(pdraw->nmcd.hdc, subitem->BgColor);
                        }

                        if (hdritem.lParam != 0)
                            SetBkColor(pdraw->nmcd.hdc, (COLORREF)hdritem.lParam);
                    }

                    DrawText(pdraw->nmcd.hdc, subitem->Text[i - 1], -1, &subr, DT_END_ELLIPSIS | DT_VCENTER | DT_SINGLELINE);
                }

        MoveToEx(pdraw->nmcd.hdc, hr.left, ir.bottom - 1, NULL);
        LineTo(pdraw->nmcd.hdc, hr.right - 1, ir.bottom - 1);
        LineTo(pdraw->nmcd.hdc, hr.right - 1, ir.top - 1);
    }

    SelectObject(pdraw->nmcd.hdc, prev);
    DeleteObject(pen);

    if ((pdraw->nmcd.uItemState & CDIS_FOCUS) != 0)
        DrawFocusRect(pdraw->nmcd.hdc, &ir);

    return CDRF_SKIPDEFAULT;
}

VOID TreeListHandleHeaderNotify(
    HWND hwndBox,
    HWND hwndTree,
    HWND hwndHeader
)
{
    SCROLLINFO  scroll;
    LONG        cx, i, c, headerheight;
    RECT        hr, ir;

    RtlSecureZeroMemory(&hr, sizeof(hr));
    GetWindowRect(hwndHeader, &hr);
    headerheight = hr.bottom - hr.top;

    cx = 0;
    c = Header_GetItemCount(hwndHeader);
    for (i = 0; i < c; i++) {
        Header_GetItemRect(hwndHeader, i, &hr);
        if (hr.right > cx)
            cx = hr.right;
    }

    GetClientRect(hwndBox, &hr);
    if (cx > hr.right) {
        RtlSecureZeroMemory(&scroll, sizeof(scroll));
        scroll.cbSize = sizeof(scroll);
        scroll.fMask = SIF_ALL;
        GetScrollInfo(hwndBox, SB_HORZ, &scroll);

        GetClientRect(hwndHeader, &ir);
        if ((ir.right > cx) && (scroll.nPos + (int)scroll.nPage == scroll.nMax)) {
            SetWindowPos(hwndHeader, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
            SetWindowPos(hwndTree, 0, 0, headerheight, hr.right, hr.bottom - headerheight, SWP_NOZORDER);
            scroll.nPos = 0;
        }

        scroll.nMax = cx;
        scroll.nPage = hr.right;
        SetScrollInfo(hwndBox, SB_HORZ, &scroll, TRUE);
        GetClientRect(hwndBox, &hr);
        GetWindowRect(hwndTree, &ir);
        ir.right -= ir.left;
        SetWindowPos(hwndTree, 0, 0, 0, ir.right, hr.bottom - headerheight, SWP_NOMOVE | SWP_NOZORDER);
        SetWindowPos(hwndHeader, 0, 0, 0, cx, headerheight, SWP_NOMOVE | SWP_NOZORDER);
    }
    else {
        ShowScrollBar(hwndBox, SB_HORZ, FALSE);
        GetClientRect(hwndBox, &hr);
        SetWindowPos(hwndHeader, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(hwndTree, 0, 0, headerheight, hr.right, hr.bottom - headerheight, SWP_NOZORDER);
    }
    RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_NOERASE);
}

VOID TreeListAutoExpand(
    HWND hwndHeader,
    LPNMTREEVIEW nhdr
)
{
    RECT        irc;
    LONG        cx = 0, xleft = 0;
    HDITEM      hdi;
    HTREEITEM   citem = TreeView_GetChild(nhdr->hdr.hwndFrom, nhdr->itemNew.hItem);

    RtlSecureZeroMemory(&irc, sizeof(irc));
    TreeView_GetItemRect(nhdr->hdr.hwndFrom, citem, &irc, TRUE);
    xleft = irc.left;

    while (citem) {
        RtlSecureZeroMemory(&irc, sizeof(irc));
        TreeView_GetItemRect(nhdr->hdr.hwndFrom, citem, &irc, TRUE);

        if (irc.left < xleft)
            break;

        if (irc.right > cx)
            cx = irc.right;

        citem = TreeView_GetNextVisible(nhdr->hdr.hwndFrom, citem);
    }

    RtlSecureZeroMemory(&hdi, sizeof(hdi));
    hdi.mask = HDI_WIDTH;
    Header_GetItem(hwndHeader, 0, &hdi);

    if (hdi.cxy < cx + 8)
        hdi.cxy = cx + 8;

    Header_SetItem(hwndHeader, 0, &hdi);
}

LRESULT CALLBACK HeaderHookProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND        BaseWindow = GetParent(hwnd);
    WNDPROC     OriginalTreeProc = (WNDPROC)GetWindowLongPtr(BaseWindow, TL_HEADERWNDPROC_SLOT);
    HDC         dc;
    LRESULT     retv;
    RECT        rc;
    HPEN        pen, prev;

    retv = OriginalTreeProc(hwnd, uMsg, wParam, lParam);
    if (uMsg != WM_PAINT)
        return retv;

    GetClientRect(hwnd, &rc);
    --rc.bottom;

    dc = GetDC(hwnd);
    pen = CreatePen(PS_SOLID, 1, 0xfbf3e5);
    prev = (HPEN)SelectObject(dc, (HGDIOBJ)pen);

    MoveToEx(dc, 0, rc.bottom, NULL);
    LineTo(dc, rc.right, rc.bottom);

    SelectObject(dc, prev);
    ReleaseDC(hwnd, dc);
    DeleteObject(pen);

    return retv;
}

LRESULT CALLBACK TreeListHookProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND            BaseWindow = GetParent(hwnd);
    WNDPROC         OriginalTreeProc = (WNDPROC)GetWindowLongPtr(BaseWindow, TL_TREEWNDPROC_SLOT);
    LPNMTTDISPINFO  hdr;
    LPTSTR          privateBuffer;
    TVITEMEX        itemex;
    RECT            rc, hr;
    PTL_SUBITEMS    subitems;
    TOOLINFO        tool;
    HDC             dc;
    HGDIOBJ         prevFont;
    ULONG_PTR       subid;

    switch (uMsg) {
    case WM_NOTIFY:
        hdr = (LPNMTTDISPINFO)lParam;
        if (hdr->hdr.hwndFrom == (HWND)GetWindowLongPtr(BaseWindow, TL_TOOLTIPS_SLOT)) {
            switch (hdr->hdr.code) {
            case TTN_SHOW:

                RtlSecureZeroMemory(&tool, sizeof(tool));
                tool.cbSize = sizeof(tool);
                tool.uId = hdr->hdr.idFrom;
                tool.hwnd = hwnd;
                SendMessage(hdr->hdr.hwndFrom, TTM_GETTOOLINFO, 0, (LPARAM)&tool);

                if (TreeView_GetItemRect(hwnd, (HTREEITEM)tool.lParam, &rc, TRUE)) {

                    subid = (tool.uId & ((ULONG_PTR)~0xfff)) >> 12;
                    if (subid > 0) {
                        Header_GetItemRect((HWND)GetWindowLongPtr(BaseWindow, TL_HEADERCONTROL_SLOT), subid, &hr);
                        rc.left = hr.left;
                        rc.right = hr.right;
                    }

                    rc.left += 3;
                    rc.top += 1;

                    ClientToScreen(hwnd, (LPPOINT)&rc);
                    SendMessage(hdr->hdr.hwndFrom, TTM_ADJUSTRECT, TRUE, (LPARAM)&rc);
                    SetWindowPos(hdr->hdr.hwndFrom, 0, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW);
                    return TRUE;
                }
                break;

            case TTN_GETDISPINFO:

                subid = (hdr->hdr.idFrom & ((ULONG_PTR)~0xfff)) >> 12;
                if (!Header_GetItemRect((HWND)GetWindowLongPtr(BaseWindow, TL_HEADERCONTROL_SLOT), subid, &hr))
                    break;

                if (!TreeView_GetItemRect(hwnd, (HTREEITEM)hdr->lParam, &rc, TRUE))
                    break;

                privateBuffer = (LPTSTR)GetWindowLongPtr(BaseWindow, TL_TOOLTIPSBUFFER_SLOT);
                privateBuffer[0] = 0;

                RtlSecureZeroMemory(&itemex, sizeof(itemex));
                itemex.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM;
                itemex.cchTextMax = MAX_PATH;
                itemex.pszText = privateBuffer;
                itemex.hItem = (HTREEITEM)hdr->lParam;
                TreeView_GetItem(hwnd, &itemex);

                subitems = (PTL_SUBITEMS)itemex.lParam;

                if (subid == 0) // is tooltip from the first column?
                {
                    if (subitems)
                        if (subitems->CustomTooltip)
                        {
                            SendMessage(hdr->hdr.hwndFrom, TTM_SETMAXTIPWIDTH, 0, 1024);
                            _strncpy(privateBuffer, MAX_PATH, subitems->CustomTooltip, MAX_PATH);
                            hdr->lpszText = privateBuffer;
                            break;
                        }

                    if (rc.right < hr.right - 1) // no overflow
                        break;
                }

                if ((subid > 0) && (subitems != 0)) {   
                    rc.left = hr.left + 3;
                    rc.right = hr.right - 3;

                    /*fake DrawText for calculating bounding rectangle*/
                    dc = GetDC(hwnd);
                    prevFont = SelectObject(dc, (HGDIOBJ)SendMessage(hwnd, WM_GETFONT, 0, 0));
                    DrawText(dc, subitems->Text[subid - 1], -1, &rc, DT_VCENTER | DT_SINGLELINE | DT_CALCRECT);
                    SelectObject(dc, prevFont);
                    ReleaseDC(hwnd, dc);

                    if (rc.right < hr.right - 2) // no overflow
                        break;

                    _strncpy(privateBuffer, MAX_PATH, subitems->Text[subid - 1], MAX_PATH);
                }

                hdr->lpszText = privateBuffer;

                break;
            }
        }
        break;

    case WM_PAINT:
        if (!IsWindowVisible((HWND)GetWindowLongPtr(BaseWindow, TL_TOOLTIPS_SLOT)))
            TreeListUpdateTooltips(BaseWindow);
        break;
    }

    return OriginalTreeProc(hwnd, uMsg, wParam, lParam);
}

PTL_SUBITEMS PackSubitems(HANDLE hHeap, IN PTL_SUBITEMS Subitems)
{
    PTL_SUBITEMS    newsubitems;
    size_t          strings_size, header_size;
    ULONG           i;
    LPTSTR          strings;

    if (Subitems == NULL)
        return NULL;

    /*
    size of header + variable length array .Text[1] part
    */
    header_size = sizeof(TL_SUBITEMS);
    if (Subitems->Count > 1) {
        header_size += (Subitems->Count - 1) * sizeof(LPTSTR);
    }

    /*
    total size of all strings including terminating zeros
    */

    strings_size = 0;
    for (i = 0; i < Subitems->Count; i++) {
        if (Subitems->Text[i])
            strings_size += (_strlen(Subitems->Text[i]) + 1) * sizeof(TCHAR);
    }
    
    if (Subitems->CustomTooltip != NULL) {
        strings_size += (_strlen(Subitems->CustomTooltip) + 1) * sizeof(TCHAR);
    }

    newsubitems = (PTL_SUBITEMS)HeapAlloc(hHeap, 0, header_size + strings_size);
    if (!newsubitems)
        return NULL;

    strings = (LPTSTR)((PBYTE)newsubitems + header_size);
    *newsubitems = *Subitems;

    for (i = 0; i < Subitems->Count; i++) {
        if (Subitems->Text[i]) {
            newsubitems->Text[i] = strings;
            _strcpy(strings, Subitems->Text[i]);
            strings += _strlen(Subitems->Text[i]) + 1;
        }
    }

    if (Subitems->CustomTooltip != NULL)
    {
        newsubitems->CustomTooltip = strings;
        _strcpy(strings, Subitems->CustomTooltip);
    }
    else {
        newsubitems->CustomTooltip = NULL;
    }

    return newsubitems;
}

LRESULT CALLBACK TreeListWindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND            TreeControl, HeaderControl, ToolTip;
    PTL_SUBITEMS    subitems, *ppsubitems;
    TVHITTESTINFO   lhti;
    LONG            cx, headerheight;
    HANDLE          hheap;
    RECT            hr;
    HFONT           font;
    LPNMHEADER      hdr;
    SCROLLINFO      scroll;
    TVITEMEX        item;
    LRESULT         result;

    NONCLIENTMETRICS    ncm;
    TV_INSERTSTRUCT     ins;

    switch (uMsg) {

    case TVM_ENSUREVISIBLE:

        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);
        SendMessage(TreeControl, TVM_ENSUREVISIBLE, 0, lParam);
        return SendMessage(TreeControl, TVM_SELECTITEM, TVGN_CARET, lParam);

        break;

    case TVM_GETITEM:

        if (wParam == 0)
            return 0;

        item = *((LPTVITEMEX)wParam);
        ppsubitems = (PTL_SUBITEMS *)lParam;

        if (ppsubitems)
            item.mask |= TVIF_PARAM;

        result = SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_GETITEM, 0, (LPARAM)&item);

        if (ppsubitems) {
            *ppsubitems = (PTL_SUBITEMS)item.lParam;
            item.lParam = 0;
            item.mask &= ~TVIF_PARAM;
        }

        *((LPTVITEMEX)wParam) = item;

        return result;

    case TVM_SETITEM:

        item = *((LPTVITEMEX)wParam);
        ppsubitems = (PTL_SUBITEMS *)lParam;

        hheap = (HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT);
        if (!hheap)
            return 0;

        subitems = NULL;
        if (ppsubitems)
        {
            item.mask |= TVIF_PARAM;
            result = SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_GETITEM, 0, (LPARAM)&item);
            if (!result)
                return FALSE;

            item.mask |= TVIF_PARAM;
            subitems = (PTL_SUBITEMS)item.lParam;
            item.lParam = (LPARAM)PackSubitems(hheap, (PTL_SUBITEMS)lParam);
        }

        result = SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_SETITEM, 0, (LPARAM)&item);
        if (subitems) HeapFree(hheap, 0, subitems);
        return result;

    case TVM_INSERTITEM:

        if (wParam == 0)
            return 0;

        hheap = (HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT);
        if (!hheap)
            return 0;

        ins = *((LPTV_INSERTSTRUCT)wParam);

        if (lParam) {
            ins.item.mask |= TVIF_PARAM;
            ins.item.lParam = (LPARAM)PackSubitems(hheap, (PTL_SUBITEMS)lParam);
        }
        else
            ins.item.lParam = 0;

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_INSERTITEM, 0, (LPARAM)&ins);

    case HDM_INSERTITEM:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT), HDM_INSERTITEM, wParam, lParam);

    case HDM_GETITEM:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT), HDM_GETITEM, wParam, lParam);

    case HDM_SETITEM:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT), HDM_SETITEM, wParam, lParam);

    case HDM_HITTEST:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT), HDM_HITTEST, 0, lParam);
    
    case TVM_GETNEXTITEM:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_GETNEXTITEM, wParam, lParam);

    case TVM_EXPAND:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_EXPAND, wParam, lParam);

    case TVM_SETIMAGELIST:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_SETIMAGELIST, wParam, lParam);

    case TVM_DELETEITEM:

        if (lParam == (LPARAM)TVI_ROOT) {
            SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);

            hheap = (HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT);
            SetWindowLongPtr(hwnd, TL_HEAP_SLOT, 0);
            HeapDestroy(hheap);

            hheap = HeapCreate(0, 0, 0);
            if (hheap == NULL)
                return FALSE;

            SetWindowLongPtr(hwnd, TL_HEAP_SLOT, (LONG_PTR)hheap);
            SetWindowLongPtr(hwnd, TL_TOOLTIPSBUFFER_SLOT, (LONG_PTR)HeapAlloc(hheap, 0, TL_SIZEOF_PRIVATEBUFFER));

            return TRUE;
        }
        break;

    case WM_CONTEXTMENU:

        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);
        lhti.flags = 0;
        lhti.hItem = NULL;
        lhti.pt.x = GET_X_LPARAM(lParam);
        lhti.pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(TreeControl, &lhti.pt);
        TreeView_HitTest(TreeControl, &lhti);
        if (lhti.hItem)
            TreeView_SelectItem(TreeControl, lhti.hItem);

        return SendMessage(GetParent(hwnd), WM_CONTEXTMENU, wParam, lParam);

    case WM_NOTIFY:

        hdr = (LPNMHEADER)lParam;
        HeaderControl = (HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT);
        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);

        if (hdr->hdr.hwndFrom == TreeControl) {
            switch (hdr->hdr.code) {
            case NM_CUSTOMDRAW:
                return TreeListCustomDraw(HeaderControl, (LPNMTVCUSTOMDRAW)lParam);

            case TVN_ITEMEXPANDED:
                if ((((LPNMTREEVIEW)lParam)->action == TVE_EXPAND) && (GetWindowLongPtr(hwnd, GWL_STYLE) & TLSTYLE_COLAUTOEXPAND))
                    TreeListAutoExpand(HeaderControl, (LPNMTREEVIEW)lParam);
                TreeListUpdateTooltips(hwnd);
                break;

            default:
                return SendMessage(GetParent(hwnd), uMsg, wParam, lParam);
            }
            /* break to DefWindowProc */
            break;
        }

        if (hdr->hdr.hwndFrom == HeaderControl) {
            switch (hdr->hdr.code) {
            case HDN_ITEMCHANGED:
                TreeListHandleHeaderNotify(hwnd, TreeControl, HeaderControl);
                break;
            case HDN_ITEMCHANGING:
                if (((hdr->pitem->mask & HDI_WIDTH) != 0) && (hdr->iItem == 0) && (hdr->pitem->cxy < 120))
                    return TRUE;
                break;
            }
        }
        break;

    case WM_HSCROLL:

        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);
        HeaderControl = (HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT);

        GetWindowRect(HeaderControl, &hr);
        headerheight = hr.bottom - hr.top;

        RtlSecureZeroMemory(&scroll, sizeof(scroll));
        scroll.cbSize = sizeof(scroll);
        scroll.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &scroll);

        scroll.fMask = SIF_ALL;
        cx = scroll.nMax - scroll.nPage;

        switch (LOWORD(wParam)) {
        case SB_LINELEFT:
            scroll.nPos -= 16;
            break;
        case SB_LINERIGHT:
            scroll.nPos += 16;
            break;
        case SB_THUMBTRACK:
            scroll.nPos = scroll.nTrackPos;
            break;
        case SB_PAGELEFT:
            scroll.nPos -= cx;
            break;
        case SB_PAGERIGHT:
            scroll.nPos += cx;
            break;
        }

        if (scroll.nPos < 0)
            scroll.nPos = 0;
        if (scroll.nPos > cx)
            scroll.nPos = cx;

        SetScrollInfo(hwnd, SB_HORZ, &scroll, TRUE);
        SetWindowPos(HeaderControl, 0, -scroll.nPos, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        GetClientRect(hwnd, &hr);
        MoveWindow(TreeControl, -scroll.nPos, headerheight, hr.right + scroll.nPos, hr.bottom - headerheight, TRUE);
        break;

    case WM_SETFOCUS:
        SetFocus((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT));
        break;

    case WM_SIZE:
        HeaderControl = (HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT);
        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);

        GetWindowRect(HeaderControl, &hr);
        headerheight = hr.bottom - hr.top;

        RtlSecureZeroMemory(&scroll, sizeof(scroll));
        scroll.cbSize = sizeof(scroll);
        scroll.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &scroll);

        GetClientRect(hwnd, &hr);
        MoveWindow(HeaderControl, -scroll.nPos, 0, hr.right + scroll.nPos, headerheight, TRUE);
        MoveWindow(TreeControl, -scroll.nPos, headerheight, hr.right + scroll.nPos, hr.bottom - headerheight, TRUE);
        return 0;

    case WM_CREATE:
        hheap = HeapCreate(0, 0, 0);
        if (hheap == NULL)
            return -1;

        RtlSecureZeroMemory(&hr, sizeof(hr));
        GetClientRect(hwnd, &hr);

        RtlSecureZeroMemory(&ncm, sizeof(ncm));
        ncm.cbSize = sizeof(ncm) - sizeof(int);
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm) - sizeof(int), &ncm, 0)) {
            font = CreateFontIndirect(&ncm.lfMenuFont);
            cx = ncm.iCaptionHeight;
        }
        else {
            font = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            cx = 20;
        }

        HeaderControl = CreateWindowEx(0, WC_HEADER, NULL,
            WS_VISIBLE | WS_CHILD | HDS_FULLDRAG, 0, 0, hr.right, cx, hwnd, NULL, NULL, NULL);
        TreeControl = CreateWindowEx(0, WC_TREEVIEW, NULL,
            WS_VISIBLE | WS_CHILD | TVS_NOHSCROLL | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_FULLROWSELECT | TVS_NOTOOLTIPS | TVS_SHOWSELALWAYS,
            0, cx, hr.right, hr.bottom - cx, hwnd, NULL, NULL, NULL);

        ToolTip = CreateWindowEx(WS_EX_TRANSPARENT | WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, TTS_NOPREFIX, 0, 0, 0, 0, hwnd, NULL, NULL, NULL);
        SendMessage(ToolTip, TTM_SETDELAYTIME, TTDT_INITIAL, 0);
        SendMessage(ToolTip, TTM_SETDELAYTIME, TTDT_RESHOW, 0);

        /*hooks*/
        SetWindowLongPtr(hwnd, TL_TREEWNDPROC_SLOT,
            /*old wndproc here*/
            SetWindowLongPtr(TreeControl, GWLP_WNDPROC, (LONG_PTR)&TreeListHookProc));

        SetWindowLongPtr(hwnd, TL_HEADERWNDPROC_SLOT,
            /*old wndproc here*/
            SetWindowLongPtr(HeaderControl, GWLP_WNDPROC, (LONG_PTR)&HeaderHookProc));

        SendMessage(TreeControl, TVM_SETEXTENDEDSTYLE, TVS_EX_DOUBLEBUFFER, TVS_EX_DOUBLEBUFFER);
        SendMessage(HeaderControl, WM_SETFONT, (WPARAM)font, TRUE);
        SetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT, (LONG_PTR)TreeControl);
        SetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT, (LONG_PTR)HeaderControl);
        SetWindowLongPtr(hwnd, TL_HEAP_SLOT, (LONG_PTR)hheap);
        SetWindowLongPtr(hwnd, TL_TOOLTIPS_SLOT, (LONG_PTR)ToolTip);
        SetWindowLongPtr(hwnd, TL_TOOLTIPSBUFFER_SLOT, (LONG_PTR)HeapAlloc(hheap, 0, TL_SIZEOF_PRIVATEBUFFER));

        SetWindowTheme(TreeControl, TEXT("Explorer"), NULL);
        SetWindowTheme(HeaderControl, TEXT("Explorer"), NULL);

        if (tl_theme == NULL)
            tl_theme = OpenThemeData(TreeControl, VSCLASS_TREEVIEW);

        break;

    case WM_DESTROY:
        if (tl_theme) {
            CloseThemeData(tl_theme);
            tl_theme = NULL;
        }
        DestroyWindow((HWND)GetWindowLongPtr(hwnd, TL_TOOLTIPS_SLOT));
        HeapDestroy((HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT));
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

ATOM InitializeTreeListControl()
{
    WNDCLASSEX  wincls;
    HINSTANCE   hinst = GetModuleHandle(NULL);

    wincls.cbSize = sizeof(WNDCLASSEX);
    wincls.style = 0;
    wincls.lpfnWndProc = &TreeListWindowProc;
    wincls.cbClsExtra = 0;
    wincls.cbWndExtra = sizeof(HANDLE) * 16;
    wincls.hInstance = hinst;
    wincls.hIcon = NULL;
    wincls.hCursor = (HCURSOR)LoadImage(NULL, MAKEINTRESOURCE(OCR_NORMAL), IMAGE_CURSOR, 0, 0, LR_SHARED);
    wincls.hbrBackground = NULL;
    wincls.lpszMenuName = NULL;
    wincls.lpszClassName = WC_TREELIST;
    wincls.hIconSm = 0;

    return RegisterClassEx(&wincls);
}

```

`Source/Shared/treelist/treelist.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       TREELIST.H
*
*  VERSION:     1.35
*
*  DATE:        10 Jun 2022
*
*  Tree-List custom control header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#define WC_TREELISTA            "CustomTreeList"
#define WC_TREELISTW            L"CustomTreeList"

#ifdef UNICODE
#define WC_TREELIST             WC_TREELISTW
#else
#define WC_TREELIST             WC_TREELISTA
#endif

#define TL_TREECONTROL_SLOT     0
#define TL_HEADERCONTROL_SLOT   sizeof(HANDLE)
#define TL_TREEWNDPROC_SLOT     sizeof(HANDLE)*2
#define TL_HEAP_SLOT            sizeof(HANDLE)*3
#define TL_TOOLTIPS_SLOT        sizeof(HANDLE)*4
#define TL_TOOLTIPSBUFFER_SLOT  sizeof(HANDLE)*5
#define TL_HEADERWNDPROC_SLOT   sizeof(HANDLE)*6

#define TL_SIZEOF_PRIVATEBUFFER (sizeof(TCHAR) * (MAX_PATH + 1))

#define TLF_BGCOLOR_SET         0x01
#define TLF_FONTCOLOR_SET       0x02

#define TLSTYLE_COLAUTOEXPAND   0x01
#define TLSTYLE_LINKLINES       0x02

typedef struct _TL_SUBITEMS {
    ULONG       Count;
    ULONG       ColorFlags;
    COLORREF    BgColor;
    COLORREF    FontColor;
    PVOID       UserParam;
    LPTSTR      CustomTooltip;
    LPTSTR      Text[1];
} TL_SUBITEMS, *PTL_SUBITEMS;

ATOM InitializeTreeListControl();

#define TreeList_GetTreeControlWindow(hwnd) \
    (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT)

#define TreeList_GetTreeItem(hwnd, lpitem, subitems) \
    (BOOL)SNDMSG((hwnd), TVM_GETITEM, (WPARAM)(LPTVITEMEX)(lpitem), (LPARAM)(PTL_SUBITEMS *)(subitems))

#define TreeList_SetTreeItem(hwnd, lpitem, subitems) \
    (BOOL)SNDMSG((hwnd), TVM_SETITEM, (WPARAM)(LPTVITEMEX)(lpitem), (LPARAM)(PTL_SUBITEMS *)(subitems))

#define TreeList_InsertTreeItem(hwnd, lpis, subitems) \
    (HTREEITEM)SNDMSG((hwnd), TVM_INSERTITEM, (WPARAM)(LPTV_INSERTSTRUCT)(lpis), (LPARAM)(PTL_SUBITEMS)(subitems))

#define TreeList_InsertHeaderItem(hwndHD, i, phdi) \
    (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))

#define TreeList_ClearTree(hwnd) \
    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)

#define TreeList_Expand(hwnd, hitem, code) \
    (BOOL)SNDMSG((hwnd), TVM_EXPAND, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))

#define TreeList_GetSelection(hwnd) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, TVGN_CARET, 0)

#define TreeList_EnsureVisible(hwnd, hitem) \
    (BOOL)SNDMSG((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))

#define TreeList_GetRoot(hwnd) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, TVGN_ROOT, 0)

#define TreeList_GetNextItem(hwnd, hitem, code) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))

#define TreeList_SetImageList(hwnd, himl, iImage) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(HIMAGELIST)(himl))

#define TreeList_RedrawDisable(hwnd) \
    SNDMSG(hwnd, WM_SETREDRAW, FALSE, 0)

#define TreeList_RedrawEnableAndUpdateNow(hwnd) { SNDMSG(hwnd, WM_SETREDRAW, TRUE, 0); \
    RedrawWindow(hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE); }

#define TreeList_GetChild(hwnd, hitem)          TreeList_GetNextItem(hwnd, hitem, TVGN_CHILD)
#define TreeList_GetNextSibling(hwnd, hitem)    TreeList_GetNextItem(hwnd, hitem, TVGN_NEXT)

#define TreeList_GetHeaderItem(hwndHD, i, phdi) \
    (int)SNDMSG((hwndHD), HDM_GETITEM, (WPARAM)(int)(i), (LPARAM)(HD_ITEM *)(phdi))

#define TreeList_SetHeaderItem(hwndHD, i, phdi) \
    (int)SNDMSG((hwndHD), HDM_SETITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))

#define TreeList_HeaderHittest(hwndHD, phti) \
    (int)SNDMSG((hwndHD), HDM_HITTEST, (WPARAM)0, (LPARAM)(LPHDHITTESTINFO)(phti))

```

`Source/TypesWithNoDesc.txt`:

```txt
Silo (r3 interface removed in 10240 release, object removed in TH2 builds)

```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31025.218
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GenAsIo2Unlock", "GenAsIo2Unlock.vcxproj", "{19A7EF82-4431-4167-AAC9-57FA29B1AE21}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Debug|x64.ActiveCfg = Debug|x64
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Debug|x64.Build.0 = Debug|x64
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Release|x64.ActiveCfg = Release|x64
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {61964766-0C22-42CC-8170-469C28F6C2D8}
	EndGlobalSection
EndGlobal

```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{19a7ef82-4431-4167-aac9-57fa29b1ae21}</ProjectGuid>
    <RootNamespace>GenAsusUnlock</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>GenAsIo2Unlock</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StringPooling>true</StringPooling>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\minirtl\cmdline.c" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\cmdline.h" />
    <ClInclude Include="..\..\Shared\ntos\ntos.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{df6b50ba-6a92-4149-873b-67cf23736ddf}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\cmdline.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\ntos\ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\cmdline.h">
      <Filter>minirtl</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>c:\makeexe\kdu\kdu.exe</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Source/Utils/GenAsIo2Unlock/main.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.00
*
*  DATE:        18 Apr 2021
*
*  AsIo2 "unlock" resource generator and binder.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include <Windows.h>
#include <strsafe.h>

#ifdef __cplusplus
extern "C" {
#include "../../Shared/ntos/ntos.h"
#include "../../Shared/minirtl/cmdline.h"
}
#endif

/*
* supChkSum
*
* Purpose:
*
* Calculate partial checksum for given buffer.
*
*/
USHORT supChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
)
{
    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }
    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}

/*
* supCalculateCheckSumForMappedFile
*
* Purpose:
*
* Calculate PE file checksum.
*
*/
DWORD supCalculateCheckSumForMappedFile(
    _In_ PVOID BaseAddress,
    _In_ ULONG FileLength
)
{
    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    ULONG CheckSum;

    PartialSum = supChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    NtHeaders = RtlImageNtHeader(BaseAddress);
    if (NtHeaders != NULL) {
        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    }
    else
    {
        PartialSum = 0;
    }
    CheckSum = (ULONG)PartialSum + FileLength;
    return CheckSum;
}

BOOL UpdateChecksum(
    _In_ LPCSTR lpFileName
)
{
    BOOL    bResult = FALSE;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hFileMap = NULL;
    DWORD   FileSize;
    LPVOID  ImageBase = NULL;

    PIMAGE_OPTIONAL_HEADER32    oh32 = NULL;
    PIMAGE_OPTIONAL_HEADER64    oh64 = NULL;

    ULONG NewCheckSum;

    IMAGE_NT_HEADERS* NtHeaders = NULL;

    __try {

        hFile = CreateFileA(lpFileName, GENERIC_READ | GENERIC_WRITE,
            0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            printf_s("[G] Cannot open input file\n");
            __leave;
        }

        FileSize = GetFileSize(hFile, NULL);
        if (FileSize == 0) {
            printf_s("[G] Input file is empty\n");
            __leave;
        }

        hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
        if (hFileMap == NULL) {
            printf_s("[G] CreateFileMapping failed for input file\n");
            __leave;
        }

        ImageBase = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0);
        if (ImageBase == NULL) {
            printf_s("[G] MapViewOfFile failed for input file\n");
            __leave;
        }

        NtHeaders = RtlImageNtHeader(ImageBase);
        if (NtHeaders == NULL) {
            printf_s("[G] RtlImageNtHeader failed for input file\n");
            __leave;
        }

        oh32 = (PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader;
        oh64 = (PIMAGE_OPTIONAL_HEADER64)oh32;

        if ((NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) && (NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)) {
            printf_s("[G] Unsuported FileHeader.Machine value\n");
            __leave;
        }

        NewCheckSum = supCalculateCheckSumForMappedFile(ImageBase, FileSize);
        if (NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
            oh64->CheckSum = NewCheckSum;
        }
        else {
            oh32->CheckSum = NewCheckSum;
        }

        bResult = TRUE;

    }
    __finally {
        if (ImageBase) {
            FlushViewOfFile(ImageBase, 0);
            UnmapViewOfFile(ImageBase);
        }

        if (hFileMap)
            CloseHandle(hFileMap);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }

    return bResult;
}


VOID ProcessFile(
    _In_ LPCSTR lpFileName)
{
    BOOL bUpdated = FALSE, bInit;
    ULONG seconds = 0, dwError;
    LARGE_INTEGER fileTime;

    BYTE Buffer[16];
    DWORD aKey[4] = { 0x16157EAA, 0xA6D2AE28, 0x8815F7AB, 0x3C4FCF09 };

    HCRYPTPROV hProv;
    HCRYPTKEY hKey = NULL;
    DWORD bytesIO = 0;
    DWORD dwMode;

    struct {
        BLOBHEADER hdr;
        DWORD len;
        BYTE key[16];
    } KeyBlob;

    GetSystemTimeAsFileTime((PFILETIME)&fileTime);
    RtlTimeToSecondsSince1970(&fileTime, &seconds);

    RtlSecureZeroMemory(Buffer, sizeof(Buffer));

    RtlCopyMemory(Buffer, &seconds, sizeof(DWORD));

    do {

        bInit = CryptAcquireContext(&hProv,
            NULL,
            MS_ENH_RSA_AES_PROV,
            PROV_RSA_AES,
            CRYPT_SILENT);

        if (!bInit)
        {
            if (GetLastError() == NTE_BAD_KEYSET) {

                bInit = CryptAcquireContext(&hProv,
                    NULL,
                    MS_ENH_RSA_AES_PROV,
                    PROV_RSA_AES,
                    CRYPT_NEWKEYSET);
            }

        }

        if (bInit == FALSE) {
            printf_s("[G] Failed to acquire context for Crypto API, error %lX\n", GetLastError());
            break;
        }

        printf_s("[G] CryptoAPI context acquired\n");

        KeyBlob.hdr.bType = PLAINTEXTKEYBLOB;
        KeyBlob.hdr.bVersion = CUR_BLOB_VERSION;
        KeyBlob.hdr.reserved = 0;
        KeyBlob.hdr.aiKeyAlg = CALG_AES_128;
        KeyBlob.len = sizeof(aKey);
        RtlCopyMemory(KeyBlob.key, aKey, sizeof(aKey));

        if (!CryptImportKey(hProv, (BYTE*)&KeyBlob, sizeof(KeyBlob), NULL, 0, &hKey)) {
            printf_s("[G] Failed to import key, error %lX\n", GetLastError());
            break;
        }
        else {
            printf_s("[G] AES key imported successfully\n");
        }

        dwMode = CRYPT_MODE_ECB;

        if (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&dwMode, 0)) {
            printf_s("[G] Failed to set key param, error %lX\n", GetLastError());
            break;
        }
        else {
            printf_s("[G] AES ECB mode set\n");
        }

        bytesIO = sizeof(Buffer);

        if (!CryptEncrypt(hKey, NULL, FALSE, 0, (BYTE*)Buffer, &bytesIO, bytesIO)) {
            printf_s("[G] Failed to encrypt data, error %lX\n", GetLastError());
            break;
        }
        else {
            printf_s("[G] Data for driver unlocking encrypted successfully\n");
        }

    } while (FALSE);

    if (hKey) CryptDestroyKey(hKey);
    CryptReleaseContext(hProv, 0);

    printf_s("[G] Generating AsIo2 unlock resource\n");

    HANDLE hRes = BeginUpdateResourceA(lpFileName, FALSE);
    if (hRes) {

        if (!UpdateResourceA(hRes,
            (LPCSTR)RT_RCDATA,
            "ASUSCERT",
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            Buffer,
            sizeof(Buffer)))
        {
            dwError = GetLastError();
            printf_s("[G] Could not update resources, GetLastError %lu\n", dwError);
        }
        else {
            printf_s("[G] File resources updated\n");
        }

        bUpdated = EndUpdateResource(hRes, FALSE);

    }
    else {
        dwError = GetLastError();
        printf_s("[G] Could not open %s, GetLastError %lu\n", lpFileName, dwError);
    }

    if (bUpdated) {

        printf_s("[G] Updating file checksum\n");

        if (UpdateChecksum(lpFileName)) {
            printf_s("[G] Checksum updated\n");
        }
        else {
            printf_s("[G] Could not update checksum!\n");
        }
    }
}

int main()
{
    ULONG l;
    CHAR szFileName[MAX_PATH + 1];

    l = 0;
    RtlSecureZeroMemory(szFileName, sizeof(szFileName));
    GetCommandLineParamA(GetCommandLineA(), 1, szFileName, MAX_PATH, &l);
    if (l > 0) {
        printf_s("GenAsIo2Unlock v1.0 built at %s\n[G] Processing input file %s\n", __TIMESTAMP__, szFileName);
        ProcessFile(szFileName);
    }
    else {
        printf_s("[G] Input file not specified\n");
    }
    return 0;
}

```

`Source/Utils/SearchPattern/SearchPattern.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// Search callback, return TRUE to stop search.
//
typedef BOOL(CALLBACK* pfnSearchCallback)(
    _In_ PBYTE Buffer,
    _In_ ULONG PatternSize,
    _In_opt_ PVOID CallbackContext
    );

typedef struct _SEARCH_PARAMS {
    PBYTE Buffer;
    DWORD BufferSize;
    PBYTE Pattern;
    DWORD PatternSize;
    PBYTE Mask;
    pfnSearchCallback Callback;
    PVOID CallbackContext;
} SEARCH_PARAMS, * PSEARCH_PARAMS;

DWORD SearchPattern(
    _In_ PSEARCH_PARAMS SearchParams
)
{
    PBYTE   p;
    DWORD   c, i, n;
    BOOLEAN found;
    BYTE    low, high;

    DWORD   bufferSize;

    if (SearchParams == NULL)
        return 0;

    if ((SearchParams->PatternSize == 0) || (SearchParams->PatternSize > SearchParams->BufferSize))
        return 0;

    bufferSize = SearchParams->BufferSize - SearchParams->PatternSize;

    for (n = 0, p = SearchParams->Buffer, c = 0; c <= bufferSize; ++p, ++c)
    {
        found = 1;
        for (i = 0; i < SearchParams->PatternSize; ++i)
        {
            low = p[i] & 0x0f;
            high = p[i] & 0xf0;

            if (SearchParams->Mask[i] & 0xf0)
            {
                if (high != (SearchParams->Pattern[i] & 0xf0))
                {
                    found = 0;
                    break;
                }
            }

            if (SearchParams->Mask[i] & 0x0f)
            {
                if (low != (SearchParams->Pattern[i] & 0x0f))
                {
                    found = 0;
                    break;
                }
            }

        }

        if (found) {

            if (SearchParams->Callback(p,
                SearchParams->PatternSize,
                SearchParams->CallbackContext))
            {
                return n + 1;
            }

            n++;
        }
    }

    return n;
}

#define MAX_DOS_HEADER (256 * (1024 * 1024))

PIMAGE_NT_HEADERS GetImageNtHeader(
    _In_ PVOID Base)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    if (Base != NULL && Base != (PVOID)-1) {
        __try {
            if ((((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) &&
                (((ULONG)((PIMAGE_DOS_HEADER)Base)->e_lfanew) < MAX_DOS_HEADER)) {
                NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
                if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                    NtHeaders = NULL;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            NtHeaders = NULL;
        }
    }
    return NtHeaders;
}

PVOID LookupImageSectionByName(
    _In_ CHAR* SectionName,
    _In_ ULONG SectionNameLength,
    _In_ PVOID DllBase,
    _Out_ PULONG SectionSize
)
{
    BOOLEAN bFound = FALSE;
    ULONG i;
    PVOID Section;
    IMAGE_NT_HEADERS* NtHeaders = GetImageNtHeader(DllBase);
    IMAGE_SECTION_HEADER* SectionTableEntry;

    if (SectionSize)
        *SectionSize = 0;

    if (NtHeaders == NULL)
        return NULL;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeaders +
        sizeof(ULONG) +
        sizeof(IMAGE_FILE_HEADER) +
        NtHeaders->FileHeader.SizeOfOptionalHeader);

    i = NtHeaders->FileHeader.NumberOfSections;
    while (i > 0) {

        if (memcmp(
            (CHAR*)SectionTableEntry->Name,
            SectionName,
            SectionNameLength) == 0)
        {
            bFound = TRUE;
            break;
        }

        i -= 1;
        SectionTableEntry += 1;
    }

    if (!bFound)
        return NULL;

    Section = (PVOID)((ULONG_PTR)DllBase + SectionTableEntry->VirtualAddress);
    if (SectionSize)
        *SectionSize = SectionTableEntry->Misc.VirtualSize;

    return Section;
}

VOID UnmapInputFile(
    _In_ PVOID FileMapping
)
{
    if (FileMapping) UnmapViewOfFile(FileMapping);
}

PVOID MapInputFile(
    _In_ LPCTSTR lpFileName,
    _Out_ LARGE_INTEGER* liFileSize
)
{
    DWORD lastError = 0;
    HANDLE fileHandle, sectionHandle = NULL;
    PVOID pvImageBase = NULL;

    do {

        liFileSize->QuadPart = 0;

        fileHandle = CreateFile(lpFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_SUPPORTS_BLOCK_REFCOUNTING | FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (fileHandle == INVALID_HANDLE_VALUE)
            break;

        if (!GetFileSizeEx(fileHandle, liFileSize))
            break;

        sectionHandle = CreateFileMapping(fileHandle, NULL,
            PAGE_READONLY | SEC_IMAGE,
            0,
            0,
            NULL);

        if (sectionHandle == NULL)
            break;

        pvImageBase = MapViewOfFile(
            sectionHandle,
            FILE_MAP_READ,
            0, 0, 0);

        if (pvImageBase == NULL)
            break;

    } while (FALSE);

    lastError = GetLastError();
    if (fileHandle != INVALID_HANDLE_VALUE) CloseHandle(fileHandle);
    if (sectionHandle) CloseHandle(sectionHandle);
    SetLastError(lastError);
    return pvImageBase;
}

int _isspace(int c)
{
    return (c == '\t' || c == '\n' ||
        c == '\v' || c == '\f' || c == '\r' || c == ' ' ? 1 : 0);
}

char* trimstring(
    _In_ const char* src,
    _In_ char* dst
)
{
    while (*src) {
        if (!_isspace(*src)) {
            *dst++ = *src;
        }
        src++;
    }
    *dst = 0;
    return dst;
}

size_t hex2bin(
    _In_ const char* src,
    _In_ unsigned char* dst)
{
    unsigned char value = 0;
    unsigned char c;
    size_t i = 0;

    while (*src) {

        c = *src;
        if (c >= '0' && c <= '9')
            value = (c - '0');
        else if (c >= 'A' && c <= 'F')
            value = (10 + (c - 'A'));
        else if (c >= 'a' && c <= 'f')
            value = (10 + (c - 'a'));
        else {
            if (_isspace(c)) {
                src++;
                continue;
            }
        }

        dst[i / 2] += value << (((i + 1) % 2) * 4);
        i++;
        src++;
    }

    return i / 2;
}

__inline TCHAR nibbletoh(BYTE c, BOOLEAN upcase)
{
    if (c < 10)
        return TEXT('0') + c;

    c -= 10;

    if (upcase)
        return TEXT('A') + c;

    return TEXT('a') + c;
}

LPTSTR PrintHex(
    _In_reads_bytes_(Length) LPBYTE Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN UpcaseHex
)
{
    ULONG   c;
    PTCHAR  lpText;
    BYTE    x;

    lpText = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) + ((SIZE_T)Length * 2 * sizeof(TCHAR)));
    if (lpText) {

        for (c = 0; c < Length; ++c) {
            x = Buffer[c];

            lpText[c * 2] = nibbletoh(x >> 4, UpcaseHex);
            lpText[c * 2 + 1] = nibbletoh(x & 15, UpcaseHex);
        }

        lpText[Length * 2] = 0;
    }

    return lpText;
}

BOOL CALLBACK SearchPatternCallback(
    _In_ PBYTE Buffer,
    _In_ ULONG PatternSize,
    _In_opt_ PVOID CallbackContext
)
{
    LPCSTR pszSection = (LPCSTR)CallbackContext;
    LPCSTR pszFound;
    pszFound = PrintHex(Buffer, PatternSize, TRUE);
    if (pszFound) {
        printf_s("%s: %p\t%s\r\n", pszSection, Buffer, pszFound);
        LocalFree((HLOCAL)pszFound);
    }
    return FALSE;
}

void ProcessFile(
    _In_ LPCSTR pszFileName,
    _In_ LPCSTR pszSection,
    _In_ LPCSTR pszPattern,
    _In_ LPCSTR pszMask)
{
    PVOID pvImageBase = NULL, pvSection;
    LARGE_INTEGER fileSize;
    SIZE_T nLen, patternLen, maskLen;
    ULONG sectionSize = 0;

    BYTE* pbPattern = NULL;
    BYTE* pbMask = NULL;

    DWORD patternSize, maskSize;

    SEARCH_PARAMS sparams;

    do {

        nLen = strlen(pszSection);
        if (nLen < 2) {
            printf_s("Section name %s is too short\r\n", pszSection);
            return;
        }

        patternLen = strlen(pszPattern);
        maskLen = strlen(pszMask);

        pbPattern = (BYTE*)LocalAlloc(LPTR, patternLen);
        pbMask = (BYTE*)LocalAlloc(LPTR, maskLen);
        if (pbPattern == NULL || pbMask == NULL) {
            printf_s("Could not allocate temporary buffer\r\n");
            break;
        }

        patternSize = (ULONG)hex2bin(pszPattern, pbPattern);
        maskSize = (ULONG)hex2bin(pszMask, pbMask);
        if (patternSize != maskSize) {
            printf_s("Pattern and mask must be the same size\r\n");
            break;
        }

        pvImageBase = MapInputFile(pszFileName, &fileSize);

        if (pvImageBase == NULL) {
            printf_s("Cannot map input file %s, GetLastError(%lx)", pszFileName, GetLastError());
            break;
        }

        pvSection = LookupImageSectionByName((CHAR*)pszSection, (ULONG)nLen, pvImageBase, &sectionSize);

        if (pvSection == NULL || sectionSize == 0) {
            printf_s("Section %s not found or has invalid size %lx", pszSection, sectionSize);
            break;
        }

        sparams.Buffer = (PBYTE)pvSection;
        sparams.BufferSize = sectionSize;
        sparams.Callback = SearchPatternCallback;
        sparams.CallbackContext = (PVOID)pszSection;
        sparams.Pattern = pbPattern;
        sparams.PatternSize = patternSize;
        sparams.Mask = pbMask;

        if (0 == SearchPattern(&sparams))
            printf_s("Nothing found, check input parameters!\r\n");

    } while (FALSE);

    if (pvImageBase) UnmapInputFile(pvImageBase);
    if (pbPattern) LocalFree(pbPattern);
    if (pbMask) LocalFree(pbMask);
}

int main(int argc, char* argv[])
{
    if (argc > 4) {
        printf_s("File %s, looking for:\r\n\tPattern:\t%s\r\n\tMask:\t\t%s\r\n\tSection:\t%s\r\n",
            argv[1],
            argv[3],
            argv[4],
            argv[2]);

        ProcessFile(argv[1], argv[2], argv[3], argv[4]);
    }
    else {
        printf_s("sp [File] [Section] [Pattern] [Mask]\r\n");
    }
    ExitProcess(0);
}

```

`Source/Utils/SearchPattern/SearchPattern.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32516.85
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SearchPattern", "SearchPattern.vcxproj", "{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Debug|x64.ActiveCfg = Debug|x64
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Debug|x64.Build.0 = Debug|x64
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Debug|x86.ActiveCfg = Debug|Win32
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Debug|x86.Build.0 = Debug|Win32
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Release|x64.ActiveCfg = Release|x64
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Release|x64.Build.0 = Release|x64
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Release|x86.ActiveCfg = Release|Win32
		{B7A2C94C-D4CA-43D5-BD32-FF70E0AA1443}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C910A337-D65F-41AB-9EB6-5303B9099E4E}
	EndGlobalSection
EndGlobal

```

`Source/Utils/SearchPattern/SearchPattern.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b7a2c94c-d4ca-43d5-bd32-ff70e0aa1443}</ProjectGuid>
    <RootNamespace>SearchPattern</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>sp</TargetName>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>sp</TargetName>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="SearchPattern.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Utils/SearchPattern/SearchPattern.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="SearchPattern.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Source/Utils/SearchPattern/SearchPattern.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>C:\Dumps\ntoskrnl.exe "PAGE" "41B8C4000000BF06000000" "1111001111111111111110"</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>C:\Dumps\ntoskrnl.exe "PAGE" "41B8C4000000BF06000000" "1111001111111111111110"</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Source/Utils/SearchPattern/test.cmd`:

```cmd
@echo off
echo Looking for pattern 1
sp.exe C:\Dumps\ntoskrnl.exe "PAGE" "41 B8 FF 00 00 00 BF 06 00 00 00" "11 11 00 11 11 11 11 11 11 11 11"
pause
echo Looking for pattern 2
sp.exe C:\Dumps\ntoskrnl.exe "PAGE" "BA D0 07 00 00 B9 40 00 00 00" "11 11 11 11 11 11 11 11 11 11"
pause
```

`Source/Utils/readme.txt`:

```txt
Support and test utilities.

GenAsIo2Unlock - generate unlocking data for *locked* Asus drivers from EneTech.
SearchPattern - test tool for pattern lookups.

```

`Source/WinObjEx64.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29613.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WinObjEx64", "WinObjEx64\WinObjEx64.vcxproj", "{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		DebugWithDriver|x64 = DebugWithDriver|x64
		Release|x64 = Release|x64
		ReleasePrivateDriver|x64 = ReleasePrivateDriver|x64
		ReleaseWinIoDriver|x64 = ReleaseWinIoDriver|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.Debug|x64.ActiveCfg = Debug|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.Debug|x64.Build.0 = Debug|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.DebugWithDriver|x64.ActiveCfg = DebugWithDriver|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.DebugWithDriver|x64.Build.0 = DebugWithDriver|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.Release|x64.ActiveCfg = Release|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.Release|x64.Build.0 = Release|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.ReleasePrivateDriver|x64.ActiveCfg = ReleasePrivateDriver|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.ReleasePrivateDriver|x64.Build.0 = ReleasePrivateDriver|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.ReleaseWinIoDriver|x64.ActiveCfg = ReleaseWinIoDriver|x64
		{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}.ReleaseWinIoDriver|x64.Build.0 = ReleaseWinIoDriver|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4FAAD6B8-C83A-4862-BD27-9C4030CBA89C}
	EndGlobalSection
EndGlobal

```

`Source/WinObjEx64/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#define WINVER 0x0600
#define _WIN32_WINNT 0x0600
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUD)
LANGUAGE LANG_NEUTRAL, SUBLANG_DEFAULT

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON_MAIN           ICON                    "rsrc\\100.ico"

IDI_ICON_VIEW_DEFAULT   ICON                    "rsrc\\101.ico"

IDI_ICON_VIEW_SELECTED  ICON                    "rsrc\\102.ico"

IDI_ICON_DEVICE         ICON                    "rsrc\\103.ico"

IDI_ICON_DRIVER         ICON                    "rsrc\\104.ico"

IDI_ICON_SECTION        ICON                    "rsrc\\105.ico"

IDI_ICON_PORT           ICON                    "rsrc\\106.ico"

IDI_ICON_SYMLINK        ICON                    "rsrc\\107.ico"

IDI_ICON_KEY            ICON                    "rsrc\\108.ico"

IDI_ICON_EVENT          ICON                    "rsrc\\109.ico"

IDI_ICON_JOB            ICON                    "rsrc\\110.ico"

IDI_ICON_MUTANT         ICON                    "rsrc\\111.ico"

IDI_ICON_KEYEDEVENT     ICON                    "rsrc\\112.ico"

IDI_ICON_TYPE           ICON                    "rsrc\\113.ico"

IDI_ICON_DIRECTORY      ICON                    "rsrc\\114.ico"

IDI_ICON_WINSTATION     ICON                    "rsrc\\115.ico"

IDI_ICON_CALLBACK       ICON                    "rsrc\\116.ico"

IDI_ICON_SEMAPHORE      ICON                    "rsrc\\117.ico"

IDI_ICON_WAITABLEPORT   ICON                    "rsrc\\118.ico"

IDI_ICON_TIMER          ICON                    "rsrc\\119.ico"

IDI_ICON_UNKNOWN        ICON                    "rsrc\\120.ico"

IDI_ICON_SESSION        ICON                    "rsrc\\121.ico"

IDI_ICON_CONTROLLER     ICON                    "rsrc\\122.ico"

IDI_ICON_PROFILE        ICON                    "rsrc\\123.ico"

IDI_ICON_EVENTPAIR      ICON                    "rsrc\\124.ico"

IDI_ICON_DESKTOP        ICON                    "rsrc\\125.ico"

IDI_ICON_FILE           ICON                    "rsrc\\126.ico"

IDI_ICON_WMIGUID        ICON                    "rsrc\\127.ico"

IDI_ICON_DEBUGOBJECT    ICON                    "rsrc\\128.ico"

IDI_ICON_IOCOMPLETION   ICON                    "rsrc\\129.ico"

IDI_ICON_PROCESS        ICON                    "rsrc\\130.ico"

IDI_ICON_ADAPTER        ICON                    "rsrc\\131.ico"

IDI_ICON_TOKEN          ICON                    "rsrc\\132.ico"

IDI_ICON_ETWREGISTRATION ICON                    "rsrc\\133.ico"

IDI_ICON_THREAD         ICON                    "rsrc\\134.ico"

IDI_ICON_SORTUP         ICON                    "rsrc\\6001.ico"

IDI_ICON_SORTDOWN       ICON                    "rsrc\\6002.ico"

IDI_ICON_TMTX           ICON                    "rsrc\\135.ico"

IDI_ICON_TMTM           ICON                    "rsrc\\136.ico"

IDI_ICON_TMRM           ICON                    "rsrc\\137.ico"

IDI_ICON_TMEN           ICON                    "rsrc\\138.ico"

IDI_ICON_PCWOBJECT      ICON                    "rsrc\\139.ico"

IDI_ICON_PIPE           ICON                    "rsrc\\pipe.ico"

IDI_ICON_MAILSLOT       ICON                    "rsrc\\mailslot.ico"

IDI_ICON_FLTCONNPORT    ICON                    "rsrc\\140.ico"

IDI_ICON_FLTCOMMPORT    ICON                    "rsrc\\141.ico"

IDI_ICON_POWERREQUEST   ICON                    "rsrc\\142.ico"

IDI_ICON_ETWCONSUMER    ICON                    "rsrc\\143.ico"

IDI_ICON_TPWORKERFACTORY ICON                    "rsrc\\144.ico"

IDI_ICON_IRTIMER        ICON                    "rsrc\\146.ico"

IDI_ICON_DXOBJECT       ICON                    "rsrc\\147.ico"

IDI_ICON_MEMORYPARTITION ICON                    "rsrc\\148.ico"

IDI_ICON_HALDMA         ICON                    "rsrc\\149.ico"

IDI_ICON_SECURITY       ICON                    "rsrc\\security.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDB_BITMAP1             BITMAP                  "rsrc\\Bitmap_125.bmp"

#endif    // Neutral (Default) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#define WINVER 0x0600\r\n"
    "#define _WIN32_WINNT 0x0600\r\n"
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#include ""driver.rc""\r\n"
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MAINMENU MENU
BEGIN
    POPUP "Fi&le"
    BEGIN
        MENUITEM "E&xit\tEsc",                  ID_FILE_EXIT
    END
    POPUP "&View"
    BEGIN
        MENUITEM "&Refresh\tF5",                ID_VIEW_REFRESH
        MENUITEM "&Display Grid\tCtrl+D",       ID_VIEW_DISPLAYGRID
        MENUITEM SEPARATOR
        MENUITEM "&System Information...\tCtrl+I", ID_VIEW_SYSINFO
    END
    POPUP "&Object"
    BEGIN
        MENUITEM "&Properties...\tEnter",       ID_OBJECT_PROPERTIES
        MENUITEM "&Go To Link Target\tCtrl+->", ID_OBJECT_GOTOLINKTARGET, GRAYED
    END
    POPUP "&Find"
    BEGIN
        MENUITEM "&Find Object...\tCtrl+F",     ID_FIND_FINDOBJECT
    END
    POPUP "&Extras"
    BEGIN
        MENUITEM "CmControl&Vector",            ID_EXTRAS_CMCONTROLVECTOR
        MENUITEM "&Drivers",                    ID_EXTRAS_DRIVERS
        MENUITEM "&Mailslots\tCtrl+M",          ID_EXTRAS_MAILSLOTS
        MENUITEM "&Pipes\tCtrl+P",              ID_EXTRAS_PIPES
        MENUITEM "P&rocesses...",               ID_EXTRAS_PROCESSLIST
        MENUITEM "Software &Licensing Cache",   ID_EXTRAS_SOFTWARELICENSECACHE
        MENUITEM "Unloaded Drivers",            ID_EXTRAS_UNLOADEDDRIVERS
        MENUITEM "&UserSharedData",             ID_EXTRAS_USERSHAREDDATA
        MENUITEM SEPARATOR
        MENUITEM "System &Callbacks",           ID_EXTRAS_CALLBACKS
        MENUITEM "&KiServiceTable",             ID_EXTRAS_SSDT
        MENUITEM "Private &Namespaces...     \tCtrl+N", ID_EXTRAS_PRIVATENAMESPACES
        MENUITEM "&W32pServiceTable",           ID_EXTRAS_W32PSERVICETABLE
    END
    POPUP "&Help"
    BEGIN
        MENUITEM "&Help\tF1",                   ID_HELP_HELP
        MENUITEM "Show Log...",                 ID_HELP_SHOWLOG
        MENUITEM SEPARATOR
        MENUITEM "Statistics",                  ID_HELP_STATISTICS
        MENUITEM "&About...",                   ID_HELP_ABOUT
    END
END

IDR_PSLISTMENU MENU
BEGIN
    POPUP "View"
    BEGIN
        MENUITEM "Legend",                      ID_VIEW_LEGEND
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 2,1,0,2511
 PRODUCTVERSION 2,1,0,2511
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40000L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "WinObjEx64 Project"
            VALUE "FileDescription", "Windows Object Explorer"
            VALUE "FileVersion", "2.1.0.2511"
            VALUE "InternalName", "WinObjEx64.exe"
            VALUE "LegalCopyright", "Copyright © 2015 - 2025 WinObjEx64 Project Authors"
            VALUE "OriginalFilename", "WinObjEx64.exe"
            VALUE "ProductName", "Windows Object Explorer 64-bit"
            VALUE "ProductVersion", "2.1.0.2511"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG_ABOUT DIALOGEX 0, 0, 253, 180
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "<a href=""https://github.com/hfiref0x/winobjex64"">WinObjEx64 on GitHub.com</a>",IDC_ABOUT_SYSLINK,
                    "SysLink",WS_TABSTOP,53,46,184,14
    DEFPUSHBUTTON   "OK",1,198,158,50,14,WS_GROUP
    ICON            "",ID_ABOUT_ICON,14,10,20,20
    LTEXT           "",ID_ABOUT_PROGRAM,54,8,171,8
    GROUPBOX        "Build information",-1,7,60,240,52
    LTEXT           "Version:",-1,13,72,54,8
    LTEXT           "",ID_ABOUT_BUILDINFO,88,72,156,8
    LTEXT           "Compiler:",-1,13,84,54,8
    LTEXT           "",ID_ABOUT_COMPILERINFO,88,84,156,8
    LTEXT           "Build date:",-1,13,96,54,8
    LTEXT           "",ID_ABOUT_BUILDDATE,88,96,156,8
    GROUPBOX        "Operating system",-1,7,116,240,38
    LTEXT           "Name:",-1,13,128,54,8
    LTEXT           "Boot Options:",-1,13,140,54,8
    LTEXT           "This program is free software. You use it at your own risk.",-1,53,34,194,11
    LTEXT           "© 2015 - 2025 WinObjEx64 Project Authors",-1,53,21,194,12
    EDITTEXT        ID_ABOUT_OSNAME,84,128,156,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP
    EDITTEXT        ID_ABOUT_ADVINFO,84,140,156,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP
END

IDD_DIALOG_SEARCH DIALOGEX 0, 0, 391, 266
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
CAPTION "Find Object"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "",ID_SEARCH_GROUPBOXOPTIONS,2,0,386,43
    LTEXT           "( Leave it blank to find all )",-1,6,8,208,8
    EDITTEXT        ID_SEARCH_NAME,6,20,209,12,ES_AUTOHSCROLL
    LTEXT           "Type:",ID_SEARCH_TYPELABEL,219,8,19,8
    COMBOBOX        ID_SEARCH_TYPE,219,20,105,200,CBS_DROPDOWN | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON   "&Find",ID_SEARCH_FIND,328,20,54,12
    GROUPBOX        "Found Objects",ID_SEARCH_GROUPBOX,2,44,386,203
    CONTROL         "",ID_SEARCH_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,5,54,380,189
    CONTROL         "",ID_SEARCH_STATUSBAR,"msctls_statusbar32",WS_CLIPSIBLINGS | 0x10,0,250,389,15
END

IDD_PROP_BASIC DIALOGEX 0, 0, 406, 120
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    LTEXT           "",ID_OBJECT_TRUSTLABEL,323,89,71,8
    LTEXT           "Process Trust Label:",ID_PTL_CAPTION,222,89,74,8,NOT WS_VISIBLE
END

IDD_PROP_PROCESSLIST DIALOGEX 0, 0, 406, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Handle of this object is opened in the following processes",-1,5,3,394,244
    CONTROL         "",ID_PROCESSLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,9,14,386,228
    LTEXT           "NOTE: Probably not all Processes listed!",ID_PROCESSLISTNOALL,10,252,272,9,NOT WS_GROUP
END

IDD_PROP_SERVICE DIALOGEX 0, 0, 406, 250
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    EDITTEXT        IDC_SERVICE_KEYNAME,62,16,89,13,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    PUSHBUTTON      "&Jump To Key",ID_SERVICE_JUMPTOKEY,315,17,73,28
    LTEXT           "",ID_SERVICE_TYPE,64,30,89,8
    LTEXT           "",ID_SERVICE_START,64,44,70,8
    EDITTEXT        IDC_SERVICE_IMAGEPATH,62,58,216,14,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    EDITTEXT        IDC_SERVICE_DISPLAYNAME,62,72,325,20,ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY | NOT WS_BORDER
    EDITTEXT        IDC_SERVICE_LOADORDERGROUP,87,110,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    COMBOBOX        IDC_SERVICE_DEPENDSONGROUP,88,123,306,30,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    COMBOBOX        IDC_SERVICE_DEPENDSONSERVICE,88,140,306,30,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    COMBOBOX        IDC_SERVICE_DEPENDENTSERVICES,88,156,306,30,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        IDC_SERVICE_DESCRIPTION,10,187,383,27,ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY | NOT WS_BORDER
    GROUPBOX        "Registry Information",ID_REGISTRYINFO,5,3,394,171
    LTEXT           "Type:",-1,12,30,19,8
    LTEXT           "Start Type:",-1,12,44,45,8
    LTEXT           "Error Control:",-1,162,30,46,8
    LTEXT           "",ID_SERVICE_ERROR,216,30,70,8
    LTEXT           "Key Name:",-1,12,16,36,8
    LTEXT           "Current State:",-1,162,16,49,8
    LTEXT           "",ID_SERVICE_CURRENT,216,16,70,8
    LTEXT           "Display Name:",-1,12,72,46,8
    LTEXT           "Image Path:",-1,12,58,39,8
    LTEXT           "Depend On Group:",-1,12,126,61,8
    LTEXT           "Load Order Group:",-1,12,110,60,8
    LTEXT           "Depend On Service:",-1,12,142,66,8
    LTEXT           "Dependent Services:",-1,12,158,68,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,99,383,1
    LTEXT           "Tag:",-1,232,110,16,8
    LTEXT           "N/A",ID_SERVICE_TAG,252,110,13,8
    GROUPBOX        "Description",ID_REGISTRYDESC,5,178,394,42
    CTEXT           "Couldn't query registry information",IDC_QUERYFAIL,8,102,389,8
END

IDD_PROP_SYMLINK DIALOGEX 0, 0, 406, 162
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Symbolic Link Information",ID_OBJECT_SYMLINKINFO,5,119,394,38
    LTEXT           "Creation Time:",-1,12,130,46,8
    LTEXT           "",ID_OBJECT_SYMLINK_CREATION,72,130,216,8
    LTEXT           "Link Target:",-1,12,142,39,8
    LTEXT           "",ID_OBJECT_SYMLINK_TARGET,72,142,216,8
    GROUPBOX        "Basic Information",-1,5,3,394,113
END

IDD_PROP_SECTION DIALOGEX 0, 0, 406, 228
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Section Information",ID_SECTIONINFO,5,118,394,38
    LTEXT           "Attributes:",-1,12,130,45,8
    LTEXT           "",ID_SECTION_ATTR,72,130,321,8
    LTEXT           "Size:",-1,12,142,16,8
    LTEXT           "",ID_SECTIONSIZE,72,142,130,8
    GROUPBOX        "Image Information",ID_IMAGEINFO,5,159,394,62,NOT WS_VISIBLE
    LTEXT           "Executable:",ID_IMAGE_EXECUTABLELABEL,12,208,38,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_EXECUTABLE,72,208,48,8,NOT WS_VISIBLE
    LTEXT           "Entry Point:",ID_IMAGE_ENTRYLABEL,12,172,37,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_ENTRY,72,172,76,8,NOT WS_VISIBLE
    LTEXT           "Subsystem:",ID_IMAGE_SUBSYSLABEL,190,172,37,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_SUBSYSTEM,242,172,151,8,NOT WS_VISIBLE
    LTEXT           "Stack Reserve:",ID_IMAGE_STACKRESERVELABEL,12,184,50,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_STACKRESERVE,72,184,80,8,NOT WS_VISIBLE
    LTEXT           "Stack Commit:",ID_IMAGE_STACKCOMMITLABEL,12,196,46,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_STACKCOMMIT,72,196,82,8,NOT WS_VISIBLE
    LTEXT           "Major Version:",ID_IMAGE_MJVLABEL,190,184,47,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_MJV,242,184,38,8,NOT WS_VISIBLE
    LTEXT           "Minor Version:",ID_IMAGE_MNVLABEL,190,196,46,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_MNV,242,196,38,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_OBJECT_TRUSTLABEL,323,89,71,8
    LTEXT           "Process Trust Label:",ID_PTL_CAPTION,222,89,74,8,NOT WS_VISIBLE
    LTEXT           "Flags:",-1,190,208,20,8,NOT WS_VISIBLE
    LTEXT           "N/A",ID_IMAGE_FLAGS,242,208,38,8,NOT WS_VISIBLE
END

IDD_PROP_SEMAPHORE DIALOGEX 0, 0, 406, 160
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Semaphore Information",ID_SEMAPHOREINFO,5,118,394,38
    LTEXT           "Current Count:",-1,12,130,46,8
    LTEXT           "",ID_SEMAPHORECURRENT,65,130,225,8
    LTEXT           "Max Count:",-1,12,142,37,8
    LTEXT           "",ID_SEMAPHOREMAXCOUNT,65,142,225,8
END

IDD_PROP_EVENT DIALOGEX 0, 0, 406, 160
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Event Information",-1,5,118,394,38
    LTEXT           "Type:",-1,12,130,19,8
    LTEXT           "",ID_EVENTTYPE,72,130,103,8
    LTEXT           "State:",-1,12,142,20,8
    LTEXT           "",ID_EVENTSTATE,72,142,103,8
END

IDD_PROP_MUTANT DIALOGEX 0, 0, 406, 159
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Mutant Information",-1,5,118,394,38
    LTEXT           "State:",-1,12,130,20,8
    LTEXT           "",ID_MUTANTSTATE,72,130,114,8
    LTEXT           "Abandoned:",-1,12,142,40,8
    LTEXT           "",ID_MUTANTABANDONED,73,142,103,8
END

IDD_PROP_TIMER DIALOGEX 0, 0, 406, 159
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Timer Information",-1,5,118,394,38
    LTEXT           "State:",-1,12,130,20,8
    LTEXT           "",ID_TIMERSTATE,72,130,103,8
    LTEXT           "Time Remaining:",-1,12,142,54,8
    LTEXT           "",ID_TIMERREMAINING,73,142,103,8
END

IDD_PROP_KEY DIALOGEX 0, 0, 406, 159
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Key Information",-1,5,118,394,38
    LTEXT           "Last Write:",-1,150,130,35,8
    LTEXT           "",ID_KEYLASTWRITE,194,130,91,8
    LTEXT           "Values:",-1,12,142,24,8
    LTEXT           "",ID_KEYVALUES,72,142,48,8
    LTEXT           "SubKeys:",-1,12,130,31,8
    LTEXT           "",ID_KEYSUBKEYS,72,130,48,8
END

IDD_PROP_JOB DIALOGEX 0, 0, 407, 195
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_JOB_PLIST,149,127,244,30,CBS_DROPDOWNLIST | CBS_SORT | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Job Information",-1,5,119,394,72
    LTEXT           "Total Processes:",-1,12,142,54,8
    LTEXT           "",ID_JOBTOTALPROCS,92,142,40,8
    LTEXT           "Active Processes:",-1,12,154,58,8
    LTEXT           "",ID_JOBACTIVEPROCS,92,154,40,8
    LTEXT           "Terminated Processes:",-1,12,166,73,8
    LTEXT           "",ID_JOBTERMINATEDPROCS,92,166,40,8
    LTEXT           "Processes:",-1,12,130,36,8
    LTEXT           "Total User Time:",-1,160,142,53,8
    LTEXT           "",ID_JOBTOTALUMTIME,262,142,66,8
    LTEXT           "Total Kernel Time:",-1,160,154,58,8
    LTEXT           "",ID_JOBTOTALKMTIME,262,154,66,8
    LTEXT           "Total Page Faults:",-1,12,178,58,8
    LTEXT           "",ID_JOBTOTALPF,92,178,59,8
    LTEXT           "This Period Total Kernel Time:",-1,160,178,95,8
    LTEXT           "",ID_JOBTPTOTALKMTIME,262,178,66,8
    LTEXT           "This Period Total User Time:",-1,160,166,90,8
    LTEXT           "",ID_JOBTPTOTALUMTIME,262,166,66,8
END

IDD_PROP_WINSTATION DIALOGEX 0, 0, 406, 153
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Window Station Information",ID_WINSTATIONINFO,5,118,394,28
    LTEXT           "Visible:",-1,12,130,50,8
    LTEXT           "",ID_WINSTATIONVISIBLE,72,130,61,8
END

IDD_PROP_DRIVER DIALOGEX 0, 0, 406, 165
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Display Name",ID_DRIVERINFO,5,118,394,42,NOT WS_VISIBLE
    LTEXT           "",ID_DRIVERDISPLAYNAME,12,129,382,25,NOT WS_VISIBLE
END

IDD_PROP_DEVICE DIALOGEX 0, 0, 406, 165
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Description",ID_DEVICEINFO,5,118,394,42,NOT WS_VISIBLE
    LTEXT           "",ID_DEVICEDESCRIPTION,12,129,381,25,NOT WS_VISIBLE
END

IDD_PROP_OBJECTDUMP DIALOGEX 0, 0, 406, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Object Information",ID_OBJECTDUMPGROUPBOX,5,3,394,260
    CTEXT           "Couldn't query information or it is in inconsistent state.",ID_OBJECTDUMPERROR,2,123,401,8,NOT WS_VISIBLE | NOT WS_GROUP
END

IDD_PROP_TYPE DIALOGEX 0, 0, 406, 249
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    COMBOBOX        IDC_TYPE_FLAGS,300,50,93,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    LISTBOX         ID_TYPE_ATTRLIST,10,122,119,119,LBS_NOINTEGRALHEIGHT | LBS_DISABLENOSCROLL | WS_TABSTOP
    CONTROL         "",ID_TYPE_ACL_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | LVS_NOSORTHEADER | WS_BORDER | WS_TABSTOP,132,122,262,119
    GROUPBOX        "Common Information",-1,5,3,394,104
    LTEXT           "Object Count:",-1,12,53,48,8
    LTEXT           "N/A",ID_TYPE_COUNT,80,53,35,8
    LTEXT           "Handle Count:",-1,12,78,46,8
    LTEXT           "N/A",ID_TYPE_HANDLECOUNT,80,79,35,8
    LTEXT           "Peak Object Count:",-1,12,65,63,8
    LTEXT           "N/A",ID_TYPE_PEAKCOUNT,80,65,35,8
    LTEXT           "Peak Handle Count:",-1,12,91,65,8
    LTEXT           "N/A",ID_TYPE_PEAKHANDLECOUNT,80,91,35,8
    LTEXT           "Memory Pool Type For Objects:",-1,129,79,101,8
    LTEXT           "N/A",ID_TYPE_POOLTYPE,233,79,125,11
    LTEXT           "Default Paged Pool Charge:",-1,129,53,89,8
    LTEXT           "N/A",ID_TYPE_PPCHARGE,233,53,44,8
    LTEXT           "Default Nonpaged Pool Charge:",-1,129,66,102,8
    LTEXT           "N/A",ID_TYPE_NPCHARGE,233,65,44,8
    GROUPBOX        "Invalid Attributes and Access Rights",-1,5,110,394,136
    LTEXT           "",ID_TYPE_DESCRIPTION,39,14,353,25
    CONTROL         "",1091,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Flags:",-1,280,52,20,8
END

IDD_PROP_DESKTOPS DIALOGEX 0, 0, 406, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "List of desktops",-1,5,3,394,244
    CONTROL         "",ID_DESKTOPSLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,10,14,384,228
    LTEXT           "NOTE: Unable to open WindowStation!",ID_DESKTOPSNOTALL,10,252,272,9,NOT WS_GROUP
END

IDD_PROP_IOCOMPLETION DIALOGEX 0, 0, 406, 148
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "IoCompletion Information",-1,5,118,394,26
    LTEXT           "State:",-1,12,130,25,8
    LTEXT           "",ID_IOCOMPLETIONSTATE,72,130,103,8
END

IDD_PROP_PIPE DIALOGEX 0, 0, 406, 242
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_PIPE_FULLPATH,69,52,323,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Pipe Information",-1,5,3,394,126
    LTEXT           "Full Path:",-1,12,53,30,8
    LTEXT           "Type Mode:",-1,12,74,39,8
    LTEXT           "?",ID_PIPE_TYPEMODE,78,74,59,8
    LTEXT           "Access Mode:",-1,12,86,48,8
    LTEXT           "?",ID_PIPE_ACCESSMODE,78,86,59,8
    LTEXT           "Inbound Quota Size:",-1,164,74,71,8
    LTEXT           "?",ID_PIPE_INBUFFER,242,74,88,8
    LTEXT           "Outbound Quota Size:",-1,164,86,73,8
    LTEXT           "?",ID_PIPE_OUTBUFFER,242,86,88,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,45,383,1
    LTEXT           "A pipe is a communication conduit with two ends; a process with a handle to one end can communicate with a process having a handle to the other end.",-1,38,14,333,25
    LTEXT           "Current Instances:",-1,12,98,63,8
    LTEXT           "?",ID_PIPE_CURINSTANCES,78,98,59,8
    LTEXT           "Max Instances:",-1,12,110,49,8
    LTEXT           "?",ID_PIPE_MAXINSTANCES,78,110,59,8
    LTEXT           "",ID_PIPE_QUERYFAIL,10,134,386,25,NOT WS_VISIBLE
    LTEXT           "Write Quota Available:",-1,164,98,74,8
    LTEXT           "?",ID_PIPE_WRITEQUOTAAVAIL,242,98,88,8
END

IDD_DIALOG_USD DIALOGEX 0, 0, 399, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "UserSharedData"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Structure Dump",ID_OBJECTDUMPGROUPBOX,3,3,393,259
END

IDD_DIALOG_PNAMESPACE DIALOGEX 0, 0, 406, 326
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Private Namespaces"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Objects",IDC_STATIC,5,3,394,194
    CONTROL         "",ID_NAMESPACELIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,10,14,385,176
    EDITTEXT        ID_NAMESPACE_ROOT,73,214,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_NAMESPACE_ADDR,73,230,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_BDESCRIPTOR_ADDRESS,73,268,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_BDESCRIPTOR_NAME,73,284,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        ID_BDESCRIPTOR_SID,73,300,102,30,CBS_DROPDOWNLIST | CBS_SORT | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "Copy",ID_BDESCRIPTOR_SID_COPY,177,300,33,13,WS_DISABLED
    EDITTEXT        ID_BDESCRIPTOR_SID_ACCOUNT,226,300,162,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",IDC_STATIC,5,200,394,51
    CTEXT           "",ID_PNAMESPACESINFO,11,156,388,24,NOT WS_VISIBLE | NOT WS_GROUP
    LTEXT           "Lookup Entry:",IDC_STATIC,20,232,50,8
    LTEXT           "Root:",IDC_STATIC,20,216,49,8
    LTEXT           "Address:",IDC_STATIC,20,270,36,8
    LTEXT           "Name:",IDC_STATIC,20,286,36,8
    GROUPBOX        "Boundary Descriptor",IDC_STATIC,6,254,393,67
    LTEXT           "Size of Boundary Information:",IDC_STATIC,225,216,97,8
    LTEXT           "",ID_SIZEOFBOUNDARYINFO,327,216,67,8
    LTEXT           "Integrity Label:",IDC_STATIC,226,270,53,8
    LTEXT           "-",ID_INTEGRITYLABEL,287,270,106,8
    LTEXT           "Entiries Count:",IDC_STATIC,226,286,53,8
    LTEXT           "0",ID_BDESCRIPTOR_ENTRIES,287,286,105,8
    LTEXT           "SID:",IDC_STATIC,20,302,36,8
END

IDD_DIALOG_EXTRASLIST DIALOGEX 0, 0, 513, 291
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",ID_EXTRASLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,0,0,512,271
    CONTROL         "",ID_EXTRASLIST_STATUSBAR,"msctls_statusbar32",0x0,0,275,512,15
END

IDD_DIALOG_IPCOBJECTS DIALOGEX 0, 0, 406, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Relative Path",ID_IPCROOT,5,3,394,259
    CONTROL         "",ID_IPCOBJECTSLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,10,14,384,242
END

IDD_PROP_MAILSLOT DIALOGEX 0, 0, 406, 242
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_MAILSLOT_FULLPATH,69,52,323,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    LTEXT           "",ID_PIPE_QUERYFAIL,10,134,386,25,NOT WS_VISIBLE
    GROUPBOX        "Mailslot Information",-1,5,3,394,126
    LTEXT           "Full Path:",-1,12,53,30,8
    LTEXT           "Mailslot Quota:",-1,12,74,65,8
    LTEXT           "?",ID_MAILSLOT_QUOTA,90,74,59,8
    LTEXT           "Messages Available:",-1,12,86,74,8
    LTEXT           "?",ID_MAILSLOT_MSGAVAILABLE,90,86,59,8
    LTEXT           "Maximum Message Size:",-1,164,74,82,8
    LTEXT           "?",ID_MAILSLOT_MAXMESSAGESZ,250,74,88,8
    LTEXT           "Next Message Size:",-1,164,86,73,8
    LTEXT           "?",ID_MAILSLOT_NEXTMSGSZ,250,86,88,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,45,383,1
    LTEXT           "A mailslot is a mechanism for one-way interprocess communications (IPC). Applications can store messages in a mailslot. The owner of the mailslot can retrieve messages that are stored there.",-1,38,14,333,25
    LTEXT           "Read Timeout:",-1,164,98,48,8
    LTEXT           "?",ID_MAILSLOT_READTIMEOUT,250,98,88,8
END

IDD_PROP_ALPCPORT DIALOGEX 0, 0, 406, 149
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "ALPC Port Information",-1,5,118,394,26
    LTEXT           "OwnerProcess:",-1,12,130,54,8
    LTEXT           "(Cannot query without administrator privileges and helper driver active)",ID_ALPC_OWNERPROCESS,78,130,317,8
END

IDD_DIALOG_CALLBACKS DIALOGEX 0, 0, 467, 320
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",ID_EXTRASLIST_STATUSBAR,"msctls_statusbar32",0x0,0,305,460,15
END

IDD_DIALOG_PSLIST DIALOGEX 0, 0, 551, 340
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
CAPTION "Processes"
CLASS "WinObjEx64PsListClass"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_PSLIST_TREELIST,"CustomTreeList",WS_TABSTOP | 0x1,7,7,537,138,WS_EX_CLIENTEDGE
    CONTROL         "",IDC_PSLIST_LISTVIEW,"SysListView32",LVS_REPORT | LVS_SHAREIMAGELISTS | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,150,537,170,WS_EX_CLIENTEDGE
    CONTROL         "",IDC_PSLIST_STATUSBAR,"msctls_statusbar32",0x0,7,325,537,15
END

IDD_PROP_PROCESS DIALOGEX 0, 0, 406, 242
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_PROCESS_TYPE_FLAGS,278,127,111,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        IDC_PROCESS_FILENAME,80,146,256,14,ES_AUTOHSCROLL | ES_READONLY
    PUSHBUTTON      "Browse",IDC_PROCESS_BROWSE,340,146,50,14,WS_DISABLED
    EDITTEXT        IDC_PROCESS_CMDLINE,80,164,310,14,ES_AUTOHSCROLL | ES_READONLY
    EDITTEXT        IDC_PROCESS_CURDIR,80,182,310,14,ES_AUTOHSCROLL | ES_READONLY
    COMBOBOX        IDC_PROCESS_MITIGATIONS,80,200,310,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Basic Information",IDC_STATIC,5,3,394,113
    LTEXT           "Name:",IDC_STATIC,38,16,22,8
    LTEXT           "Type:",IDC_STATIC,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",IDC_STATIC,12,51,32,8
    LTEXT           "References:",IDC_STATIC,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",IDC_STATIC,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",IDC_STATIC,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",IDC_STATIC,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",IDC_STATIC,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",IDC_STATIC,12,89,26,8
    LTEXT           "Object:",IDC_STATIC,12,101,24,8
    GROUPBOX        "Process Information",ID_PROCESSINFO,5,118,394,118
    LTEXT           "Start Time:",IDC_STATIC,12,130,36,8
    LTEXT           "N/A",IDC_PROCESS_STARTED,80,130,98,8
    LTEXT           "Command Line:",IDC_STATIC,12,166,50,8
    LTEXT           "Current Directory:",IDC_STATIC,12,184,60,8
    LTEXT           "Image File Name:",IDC_STATIC,12,148,56,8
    RTEXT           "Process Type:",IDC_STATIC,200,130,68,8
    LTEXT           "Mitigations:",IDC_STATIC,12,202,38,8
    LTEXT           "Protection:",IDC_STATIC,12,220,36,8
    LTEXT           "N/A",IDC_PROCESS_PROTECTION,80,220,121,8
    RTEXT           "Critical Process:",IDC_STATIC,282,220,64,8
    LTEXT           "N/A",IDC_PROCESS_CRITICAL,355,220,33,8
END

IDD_PROP_THREAD DIALOGEX 0, 0, 406, 211
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        IDC_THREAD_NAME,290,154,106,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    GROUPBOX        "Basic Information",IDC_STATIC,5,3,394,113
    LTEXT           "Name:",IDC_STATIC,38,16,22,8
    LTEXT           "Type:",IDC_STATIC,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",IDC_STATIC,12,51,32,8
    LTEXT           "References:",IDC_STATIC,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",IDC_STATIC,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",IDC_STATIC,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",IDC_STATIC,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",IDC_STATIC,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",IDC_STATIC,12,89,26,8
    LTEXT           "Object:",IDC_STATIC,12,101,24,8
    GROUPBOX        "Thread Information",ID_THREADINFO,5,118,394,86
    LTEXT           "Start Time:",IDC_STATIC,12,130,36,8
    LTEXT           "N/A",IDC_THREAD_STARTED,80,130,98,8
    LTEXT           "Kernel Time:",IDC_STATIC,12,142,40,8
    LTEXT           "N/A",IDC_THREAD_KERNELTIME,80,142,98,8
    LTEXT           "User Time:",IDC_STATIC,12,154,35,8
    LTEXT           "N/A",IDC_THREAD_USERTIME,80,154,98,8
    LTEXT           "Context Switches:",IDC_STATIC,12,166,60,8
    LTEXT           "N/A",IDC_THREAD_CONTEXTSWITCHES,80,166,98,8
    LTEXT           "Base Priority:",IDC_STATIC,222,130,44,8
    LTEXT           "N/A",IDC_THREAD_BASEPRIORITY,290,130,98,8
    LTEXT           "Dynamic Priority:",IDC_STATIC,222,142,55,8
    LTEXT           "N/A",IDC_THREAD_DYNPRIORITY,290,142,98,8
    LTEXT           "Ideal Processor:",IDC_STATIC,12,178,53,8
    LTEXT           "N/A",IDC_THREAD_IDEALPROCESSOR,80,178,98,8
    LTEXT           "Critical Thread:",IDC_STATIC,12,190,50,8
    LTEXT           "N/A",IDC_THREAD_CRITICAL,80,190,98,8
    LTEXT           "Thread Name:",IDC_STATIC,222,154,51,8
END

IDD_DIALOG_TOKEN DIALOGEX 0, 0, 406, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_TOKEN_PRIVLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,9,101,386,151
    CTEXT           "Couldn't query information or it is in inconsistent state.",IDC_TOKEN_ERROR,2,123,401,24,NOT WS_VISIBLE | NOT WS_GROUP
    LTEXT           "User:",IDC_STATIC,12,14,18,8
    LTEXT           "User SID:",IDC_STATIC,12,32,32,8
    GROUPBOX        "",IDC_STATIC,5,3,394,255
    LTEXT           "Session:",IDC_STATIC,12,68,28,8
    LTEXT           "N/A",IDC_TOKEN_SESSION,48,68,24,8
    LTEXT           "Elevated:",IDC_STATIC,80,84,32,8
    LTEXT           "N/A",IDC_TOKEN_ELEVATED,134,84,70,8
    LTEXT           "Virtualized:",IDC_STATIC,222,83,36,8
    LTEXT           "N/A",IDC_TOKEN_VIRTUALIZED,282,83,24,8
    LTEXT           "Integrity Level:",IDC_STATIC,80,68,50,8
    LTEXT           "N/A",IDC_TOKEN_INTEGRITYLEVEL,134,68,70,8
    LTEXT           "UIAccess:",IDC_STATIC,12,84,33,8
    LTEXT           "N/A",IDC_TOKEN_UIACCESS,48,84,24,8
    EDITTEXT        IDC_TOKEN_USER,78,14,234,14,ES_AUTOHSCROLL | ES_READONLY
    EDITTEXT        IDC_TOKEN_SID,78,30,234,14,ES_AUTOHSCROLL | ES_READONLY
    LTEXT           "AppContainer SID:",IDC_STATIC,12,50,61,8
    EDITTEXT        IDC_TOKEN_APPCONTAINER,78,48,233,14,ES_AUTOHSCROLL | ES_READONLY
    PUSHBUTTON      "Advanced",IDC_TOKEN_ADVANCED,319,14,72,14
    LTEXT           "AuthenticationId:",IDC_STATIC,222,68,57,8
    EDITTEXT        IDC_TOKEN_AUTHID,282,66,112,14,ES_AUTOHSCROLL | ES_READONLY
    PUSHBUTTON      "Linked Token",IDC_TOKEN_LINKED,319,31,72,14,WS_DISABLED
END

IDD_DIALOG_SLCACHE DIALOGEX 0, 0, 439, 376
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Software Licensing Cache"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Descriptors",IDC_STATIC,5,3,424,234
    CONTROL         "",ID_SLCACHELIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,10,14,416,215
    GROUPBOX        "Cache Descriptor",IDC_STATIC,5,238,424,91
    CTEXT           "",ID_SLCACHEINFO,11,156,420,24,NOT WS_VISIBLE | NOT WS_GROUP
    EDITTEXT        IDC_SLVALUE,81,304,286,14,ES_AUTOHSCROLL | ES_READONLY
    DEFPUSHBUTTON   "View",IDC_SLVALUE_VIEWWITH,371,304,51,14,WS_DISABLED
    LTEXT           "Size:",IDC_STATIC,20,256,53,8
    LTEXT           "0",ID_SLDESCRIPTOR_SIZE,81,256,106,8
    LTEXT           "Data Length:",IDC_STATIC,20,272,53,8
    LTEXT           "0",ID_SLDESCRIPTOR_DATALENGTH,81,272,105,8
    LTEXT           "Attributes:",IDC_STATIC,226,256,53,8
    LTEXT           "0",ID_SLDESCRIPTOR_ATTRIBUTES,287,256,105,8
    LTEXT           "Data:",IDC_STATIC,20,304,36,8
    LTEXT           "Type:",IDC_STATIC,226,272,53,8
    LTEXT           "N/A",ID_SLDESCRIPTOR_TYPE,288,272,105,8
    EDITTEXT        IDC_SLVALUE_NAME,82,287,340,14,ES_AUTOHSCROLL | ES_READONLY
    LTEXT           "Name:",IDC_STATIC,20,288,36,8
    GROUPBOX        "Search By Name (case insensitive)",IDC_STATIC,5,335,424,36
    EDITTEXT        IDC_SLSEARCH,13,348,408,14,ES_AUTOHSCROLL
END

IDD_DIALOG_GLOBALS DIALOGEX 0, 0, 477, 260
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "System Information & WinObjEx64 Globals"
FONT 8, "Tahoma", 400, 0, 0x0
BEGIN
    CONTROL         "",IDC_GLOBALS,"RichEdit20W",WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP | 0x884,7,7,402,245
    PUSHBUTTON      "Copy",IDC_GLOBALS_COPY,414,25,50,14
    DEFPUSHBUTTON   "Close",2,414,7,50,14
END

IDD_PROP_TOKEN DIALOGEX 0, 0, 406, 250
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    ICON            "",ID_OBJECT_ICON,12,14,20,20,SS_CENTERIMAGE | WS_TABSTOP
    EDITTEXT        ID_OBJECT_NAME,65,15,328,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    COMBOBOX        IDC_OBJECT_FLAGS,65,49,136,30,CBS_DROPDOWNLIST | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        ID_OBJECT_HEADER,65,88,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    EDITTEXT        ID_OBJECT_ADDR,65,100,136,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER,WS_EX_STATICEDGE
    CONTROL         "",IDC_TOKEN_ATTRLIST,"SysTreeView32",TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | WS_BORDER | WS_HSCROLL | WS_TABSTOP,12,131,380,107
    GROUPBOX        "Basic Information",-1,5,3,394,113
    LTEXT           "Name:",-1,38,16,22,8
    LTEXT           "Type:",-1,38,30,19,8
    LTEXT           "",ID_OBJECT_TYPE,65,30,197,8
    LTEXT           "Attributes:",-1,12,51,32,8
    LTEXT           "References:",-1,12,64,48,8
    LTEXT           "N/A",ID_OBJECT_REFC,65,64,48,8
    LTEXT           "Handles:",-1,12,76,29,8
    LTEXT           "N/A",ID_OBJECT_HANDLES,65,76,48,8
    LTEXT           "Paged Pool Charge:",-1,222,51,78,8
    LTEXT           "N/A",ID_OBJECT_PP_CHARGE,323,51,48,8
    LTEXT           "Nonpaged Pool Charge:",-1,222,64,77,8
    LTEXT           "N/A",ID_OBJECT_NP_CHARGE,323,64,48,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ,11,44,383,1
    LTEXT           "Header:",-1,12,89,26,8
    LTEXT           "Object:",-1,12,101,24,8
    GROUPBOX        "Security Attributes",-1,5,118,394,128
END

IDD_DIALOG_LOGVIEWER DIALOGEX 0, 0, 577, 244
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Log Viewer"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    PUSHBUTTON      "Copy",ID_OBJECT_COPY,520,25,50,14
    DEFPUSHBUTTON   "Close",IDCANCEL,520,7,50,14
    CONTROL         "",IDC_LOGLIST,"RichEdit20W",WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP | 0x884,4,4,510,237
END

IDD_DIALOG_VIEWPLUGINS DIALOGEX 0, 0, 329, 315
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "View Plugins"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_PLUGINLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | LVS_NOSORTHEADER | WS_BORDER | WS_TABSTOP,7,7,315,163
    EDITTEXT        IDC_PLUGIN_FILENAME,102,216,214,14,ES_AUTOHSCROLL | ES_READONLY
    COMBOBOX        IDC_PLUGIN_OBJECTTYPE,102,234,214,30,CBS_DROPDOWNLIST | CBS_SORT | WS_DISABLED | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        IDC_PLUGIN_DESC,16,264,299,16,ES_AUTOHSCROLL | ES_READONLY
    PUSHBUTTON      "Close",IDCANCEL,272,294,50,14
    GROUPBOX        "Plugin",IDC_STATIC,7,174,315,114
    LTEXT           "Description:",IDC_STATIC,16,250,82,8
    LTEXT           "Need Admin:",IDC_STATIC,16,186,82,8
    LTEXT           "Filename:",IDC_STATIC,16,218,82,8
    LTEXT           "N/A",IDC_PLUGIN_ADMIN,102,186,32,8
    LTEXT           "Support ObjectType(s):",IDC_STATIC,16,234,82,8
    LTEXT           "Need Helper Driver:",IDC_STATIC,16,202,82,8
    LTEXT           "N/A",IDC_PLUGIN_DRIVER,102,202,32,8
    LTEXT           "Supports Wine:",IDC_STATIC,189,186,82,8
    LTEXT           "N/A",IDC_PLUGIN_WINE,278,186,32,8
    LTEXT           "Multi-Instance:",IDC_STATIC,189,202,82,8
    LTEXT           "N/A",IDC_PLUGIN_MINSTANCES,278,202,32,8
END

IDD_DIALOG_SDVIEW DIALOGEX 0, 0, 515, 310
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
CAPTION "Security Descriptor"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    EDITTEXT        IDC_SDVIEW_OWNER,50,10,338,14,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
    CONTROL         "",IDC_SDVIEW_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,31,501,253
    LTEXT           "Owner:",IDC_STATIC,8,10,36,8
    CTEXT           "Couldn't query information or it is in inconsistent state.",ID_OBJECTDUMPERROR,7,135,501,23,NOT WS_VISIBLE | NOT WS_GROUP
    CONTROL         "",IDC_SDVIEW_STATUSBAR,"msctls_statusbar32",0x0,1,289,508,15
END

IDD_PROP_ALPCPORTLIST DIALOGEX 0, 0, 406, 266
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "List of port connections",-1,5,3,394,244
    CONTROL         "",ID_ALPCLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHAREIMAGELISTS | WS_BORDER | WS_TABSTOP,9,14,386,228
    LTEXT           "Error: Cannot list connections!",ID_ALPCLISTMSG,10,252,272,9,NOT WS_GROUP
END

IDD_DIALOG_LOADLIST DIALOGEX 0, 0, 317, 156
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "Cancel",IDCANCEL,260,135,50,14
    EDITTEXT        IDC_LOADING_MSG,7,7,303,108,ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY | WS_VSCROLL
    LTEXT           "Time elapsed: 00:00",IDC_TIME_ELAPSED,7,135,71,8
    LTEXT           "Loading...",IDC_STATUS_TEXT,7,121,303,8
END

IDD_DIALOG_STATS DIALOGEX 0, 0, 173, 119
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Statistics"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,117,99,50,14
    LTEXT           "TotalHeapAlloc:",IDC_STATIC,7,8,51,8
    LTEXT           "0",IDC_STATS_TOTALHEAPALLOC,108,8,59,8
    LTEXT           "TotalHeapFree:",IDC_STATIC,7,20,51,8
    LTEXT           "0",IDC_STATS_TOTALHEAPFREE,108,20,58,8
    LTEXT           "TotalHeapsCreated:",IDC_STATIC,7,32,66,8
    LTEXT           "0",IDC_STATS_TOTALHEAPSCREATED,108,32,59,8
    LTEXT           "TotalHeapsDestroyed:",IDC_STATIC,8,44,73,8
    LTEXT           "0",IDC_STATS_TOTALHEAPSDESTROYED,108,44,59,8
    LTEXT           "TotalThreadsCreated:",IDC_STATIC,8,56,72,8
    LTEXT           "0",IDC_STATS_TOTALTHREADSCREATED,108,56,59,8
    LTEXT           "TotalHeapMemoryAllocated:",IDC_STATIC,8,68,91,8
    LTEXT           "0",IDC_STATS_TOTALTHEAPMEMORYALLOCATED,108,68,59,8
    LTEXT           "MaxHeapAllocatedBlockSize:",IDC_STATS_MAXHEAPALLOCATEDSIZE_STATIC,8,80,92,8,NOT WS_VISIBLE
    LTEXT           "0",IDC_STATS_MAXHEAPALLOCATEDSIZE,108,80,59,8,NOT WS_VISIBLE
END

IDD_DIALOG_PROGRESS DIALOGEX 0, 0, 193, 89
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_TOPMOST
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "Cancel",IDCANCEL,72,57,50,14
    CTEXT           "",IDC_PROGRESS,7,34,179,8
    CTEXT           "Performing operation, please wait...",IDC_STATIC,7,22,179,8
END

IDD_DIALOG_PSLISTLEGEND DIALOGEX 0, 0, 143, 102
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_TOOLWINDOW
CAPTION "Process List Legend"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,49,81,50,14
    LTEXT           "Services",-1,64,25,70,8
    LTEXT           "Protected Process",-1,64,59,72,8
    LTEXT           "User Own Processes",-1,64,8,72,8
    LTEXT           "Immersive Process",-1,64,42,72,8
    CONTROL         "",IDC_PCTL_SERVICE_PROCES,"Static",SS_ETCHEDFRAME,7,24,50,11
    CONTROL         "",IDC_PCTL_PROTECTED_PROCESS,"Static",SS_ETCHEDFRAME,7,58,50,11
    CONTROL         "",IDC_PCTL_USERPROCESS,"Static",SS_ETCHEDFRAME,7,7,50,11
    CONTROL         "",IDC_PCTL_IMMERSIVE_PROCESS,"Static",SS_ETCHEDFRAME,7,41,50,11
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_ACCELERATOR1 ACCELERATORS
BEGIN
    "M",            ID_EXTRAS_MAILSLOTS,    VIRTKEY, CONTROL, NOINVERT
    "P",            ID_EXTRAS_PIPES,        VIRTKEY, CONTROL, NOINVERT
    "N",            ID_EXTRAS_PRIVATENAMESPACES, VIRTKEY, CONTROL, NOINVERT
    VK_ESCAPE,      ID_FILE_EXIT,           VIRTKEY, NOINVERT
    "F",            ID_FIND_FINDOBJECT,     VIRTKEY, CONTROL, NOINVERT
    VK_F1,          ID_HELP_HELP,           VIRTKEY, NOINVERT
    VK_RIGHT,       ID_OBJECT_GOTOLINKTARGET, VIRTKEY, CONTROL, NOINVERT
    VK_RETURN,      ID_OBJECT_PROPERTIES,   VIRTKEY, NOINVERT
    "D",            ID_VIEW_DISPLAYGRID,    VIRTKEY, CONTROL, NOINVERT
    VK_F5,          ID_VIEW_REFRESH,        VIRTKEY, NOINVERT
    "I",            ID_VIEW_SYSINFO,        VIRTKEY, CONTROL, NOINVERT
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_DIALOG_ABOUT, DIALOG
    BEGIN
    END

    IDD_DIALOG_GLOBALS, DIALOG
    BEGIN
    END

    IDD_DIALOG_LOGVIEWER, DIALOG
    BEGIN
    END

    IDD_DIALOG_LOADLIST, DIALOG
    BEGIN
    END

    IDD_DIALOG_STATS, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG_ABOUT AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_DIALOG_LOADLIST AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_DESC_DEVICE         "A Device is an object that represents a physical, logical, or virtual device."
    IDS_DESC_DRIVER         "A Driver is an object that represents the image of a loaded kernel-mode driver and is used by the I/O Manager to locate certain entry points in the driver."
    IDS_DESC_SECTION        "A Section is an object that provides the mechanism by which a process can map a file into its memory address space."
    IDS_DESC_PORT           "A Port is a conduit for messages between local (server/client) processes. It is used in the ALPC (Advanced Local Procedure Call) model as an object accessible to user-mode processes through system services."
    IDS_DESC_SYMLINK        "A SymbolicLink is an object that is used to translate a reference to one named object into a different name."
    IDS_DESC_KEY            "A Key is an object defined by the Configuration Manager that represents an entry in the registry database."
    IDS_DESC_EVENT          "An Event is an interprocess synchronization object whose state can be explicitly set to signaled or nonsignaled."
    IDS_DESC_JOB            "A Job is an object that allows groups of processes to be managed as a unit."
    IDS_DESC_MUTANT         "A Mutant (Win32 mutex) is an interprocess synchronization object whose state is set to signaled when it is not owned by any thread, and nonsignaled when it is owned."
    IDS_DESC_KEYEDEVENT     "A KeyedEvent is a special executive synchronization object. This object used to build reader - writer locks and condition variables."
    IDS_DESC_TYPE           "A Type is an object that contains information common to each instance of the particular object type."
    IDS_DESC_DIRECTORY      "A Directory is an object that is used to implement hierarchical object names."
END

STRINGTABLE
BEGIN
    IDS_DESC_WINSTATION     "A WindowStation is an object that is associated with a process, and contains a clipboard, an atom table, and a set of desktop objects."
    IDS_DESC_CALLBACK       "A Callback is an object that provides a general way for drivers to request and provide notification when certain conditions are satisfied."
    IDS_DESC_SEMAPHORE      "A Semaphore is an interprocess synchronization object that maintains a count value. The semaphore's state is set to signaled when its count is greater than zero, and nonsignaled when its count is zero."
    IDS_DESC_WAITABLEPORT   "A WaitablePort is an object that is used to implement the LPC mechanism.The only difference from Port object is the Event object that can be used to wait for LPC messages to arrive asynchronously."
    IDS_DESC_TIMER          "A Timer is an interprocess synchronization object whose state is set to signaled when the specified due time arrives."
    IDS_DESC_SESSION        "A Session consists of all of the processes and other system objects that represent a single user’s logon session. These objects include all windows, desktops and windows stations.  "
    IDS_DESC_CONTROLLER     "A Controller object usually represents a physical device controller with attached devices on which a single driver carries out I/O requests. "
    IDS_DESC_PROFILE        "A Profile is an object that is used to collect and gather execution profiling information."
    IDS_DESC_EVENTPAIR      "An EventPair is an object constructed from two event objects and is used for fast client server interactions."
    IDS_DESC_DESKTOP        "A Desktop is an object which has a logical display surface and contains windows, menus, and hooks."
    IDS_DESC_FILE           "A File is an object that represents an open instance of a file, device, directory, or volume."
    IDS_DESC_WMIGUID        "A WmiGuid is an object that represents data block that can be retrieved via Windows Management Instrumentation."
    IDS_DESC_DEBUGOBJECT    "A DebugObject is an object that maintains the context for a single debug session."
    IDS_DESC_IOCOMPLETION   "An IoCompletion is an object that efficiently manages threads used for asynchronous I/O."
    IDS_DESC_PROCESS        "A Process is an object which provides the resources needed to execute a program. It has a virtual address space, executable code, data, object handles, a base priority, etc."
    IDS_DESC_ADAPTER        "An Adapter is an object that is used by the I/O system and its components."
END

STRINGTABLE
BEGIN
    IDS_DESC_TOKEN          "A Token is a security object type, representing an authenticated user process. A token can be assigned to an individual thread also."
    IDS_DESC_ETWREGISTRATION 
                            "An EtwRegistration is an Event Tracing for Windows (ETW) framework object, it is associated with ETW-provider registered with the EventRegister API call."
    IDS_DESC_THREAD         "A Thread is a basic entity that executes the application's code and to which the operating system allocates CPU time."
    IDS_DESC_TMTX           "A TmTx object represent transaction. A transactional client creates a transaction, performs some work, and the either commits or rolls back the transaction."
    IDS_DESC_TMTM           "A Transaction Manager object, provides the infrastructure that enables transactional clients and resource managers to communicate with each other. It also tracks the state of each transaction."
    IDS_DESC_TMRM           "A Transaction Resource Manager object is a component that manages data resources that can be updated by transacted operations."
    IDS_DESC_TMEN           "A Transaction Enlistment object is an association between a transaction resource manager and a transaction."
    IDS_DESC_PCWOBJECT      "An object for Performance Counter for Windows provider registration and management."
    IDS_DESC_FLT_CONN_PORT  "A FilterConnectionPort is an object created by Filter Manager. This object used in minifilter asymmetric communication port model. The kernel-mode end creates the communication port. The user-mode end connects to it."
    IDS_DESC_FLT_COMM_PORT  "A FilterCommunicationPort is an object created by Filter Manager and used for communication between user-mode applications and filesystem minifilters."
    IDS_DESC_POWERREQUEST   "A PowerRequest is an object created by user-mode application with PowerCreateRequest API call. This type of objects used for power management and was introduced in Windows 7."
    IDS_DESC_ETWCONSUMER    "An EtwConsumer is an Event Tracing for Windows (ETW) framework object. It receives events from various ETW event sources, such as ETW Sessions."
    IDS_DESC_TPWORKERFACTORY 
                            "A TpWorkerFactory is an object that responsible for allocating worker threads, maintaining a minimum and maximum thread count, and other accounting information."
    IDS_DESC_COMPOSITION    "A Composition is a Win32k managed object that enables high-performance bitmap composition with transforms, effects, and animations. Used by DX12 APIs."
    IDS_DESC_IRTIMER        "An IRTimer stands for Idle Resilient Timer, is used by UWP applications and certain services to create timers that are not affected by Connected Standby."
    IDS_DESC_DXGK_SHARED_RESOURCE 
                            "An object representing DirectX Graphics Kernel shared resource for cross-process GPU resource sharing."
END

STRINGTABLE
BEGIN
    IDS_DESC_DXGK_SHARED_SWAPCHAIN 
                            "An object representing DirectX Graphics Kernel shared swap chain for cross-process display buffer management."
    IDS_DESC_DXGK_SHARED_SYNC 
                            "An object representing DirectX Graphics Kernel shared synchronization primitive for GPU operation coordination."
    IDS_DESC_DXGK_CURRENT_DXG_PROCESS_OBJECT 
                            "An object representing DirectX Graphics Kernel process context for graphics operations."
    IDS_DESC_DXGK_DISPLAY_MANAGER_OBJECT 
                            "An object for DirectX Graphics Kernel display management and configuration."
    IDS_DESC_DXGK_SHARED_BUNDLE_OBJECT 
                            "An object representing DirectX Graphics Kernel shared bundle for grouped resource management."
    IDS_DESC_DXGK_SHARED_PROTECTED_SESSION_OBJECT 
                            "An object representing DirectX Graphics Kernel protected session for secure content playback."
    IDS_DESC_DXGK_COMPOSITION_OBJECT 
                            "An object for DirectX Graphics Kernel composition management and rendering operations."
    IDS_DESC_DXGK_SHARED_KEYED_MUTEX_OBJECT 
                            "An object representing DirectX Graphics Kernel shared keyed mutex for synchronized cross-process GPU resource access."
    IDS_DESC_MEMORY_PARTITION 
                            "An object for memory resource partitioning used in memory isolation and quota management."
    IDS_DESC_REGISTRY_TRANSACTION 
                            "A RegistryTransaction is an object to provide transaction support for Registry."
    IDS_DESC_DMAADAPTER     "A DmaAdapter is a HAL (Hardware Abstraction Layer) object. It is invisible to user-mode applications."
    IDS_DESC_DMADOMAIN      "A DmaDomain is a HAL (Hardware Abstraction Layer) object. It is invisible to user-mode applications."
    IDS_DESC_DXGK_CURRENT_DXG_THREAD_OBJECT 
                            "An object representing DirectX Graphics Kernel thread context for graphics operations."
    IDS_DESC_COVERAGESAMPLER 
                            "An object that provides code coverage tracing on a given ETW session."
    IDS_DESC_ACTIVATIONOBJECT 
                            "An ActivationObject tracks foreground state for window handles that are managed by the RawInputManager in Win32k.sys."
    IDS_DESC_ACTIVITYREFERENCE 
                            "An ActivityReference object tracks processes managed by the Process Lifetime Manager (PLM) and that should be kept awake during Connected Standby scenarios."
END

STRINGTABLE
BEGIN
    IDS_DESC_COREMESSAGING  "An IPC object that wraps an ALPC port with its own customized namespace and capabilities."
    IDS_DESC_RAWINPUTMANAGER 
                            "Represents the object that is bound to an HID device such as a mouse, keyboard, or tablet and allows reading and managing the window manager input that is being received by it."
    IDS_DESC_WAITCOMPLETIONPACKET 
                            "Used by the new asynchronous wait capabilities that were introduced in the user mode Thread Pool API, this object wraps the completion of a dispatcher wait as an I/O packet that can be delivered to an I/O completion port."
    IDS_DESC_IOCOMPLETIONRESERVE 
                            "Same as IoCompletion except allows preallocation of the port to combat low-memory situations."
    IDS_DESC_USERAPCRESERVE "Similar to IoCompletionReserve in that it allows precreating a data structure to be reused during low-memory conditions, this object encapsulates an APC Kernel Object (KAPC) as an executive object."
    IDS_DESC_IORING         "An object for I/O ring buffer management used in high-performance asynchronous I/O operations."
    IDS_DESC_TERMINAL       "Only enabled if the terminal thermal manager (TTM) is enabled, this represents a user terminal on a device, which is managed by the user mode power manager."
    IDS_DESC_TERMINALEVENTQUEUE 
                            "Only enabled on TTM systems, like the preceding object type, this represents events being delivered to a terminal on a device, which UMPO communicates with the kernel's power manager about."
    IDS_DESC_ENERGYTRACKER  "Exposed to the User Mode Power (UMPO) service to allow tracking and aggregation of energy usage across a variety of hardware and associating it on a per application basis."
    IDS_DESC_DXGK_DISPLAYMUXSWITCH 
                            "An object for DirectX Graphics Kernel display multiplexing and switching functionality."
    IDS_DESC_VREGCFGCTX     "An object representing Virtual Registry configuration context for registry namespace isolation in Server Silos."
    IDS_DESC_PSSILOCONTEXTNP 
                            "An object for Server Silo support containing non-pageable silo context used by container infrastructure."
    IDS_DESC_PSSILOCONTEXT  "An object for Server Silo support containing pageable silo context used by container infrastructure."
    IDS_DESC_ETWSESSIONDEMUXENTRY 
                            "An object for Event Tracing for Windows session demultiplexing and event routing."
    IDS_DESC_NDISCMSTATE    "An object for NDIS connection management state used in network isolation and namespace management."
    IDS_DESC_PROCESSSTATECHANGE 
                            "An object for process state change notification and monitoring."
END

STRINGTABLE
BEGIN
    IDS_DESC_UNKNOWN        "Unknown to Death, Nor known to Life."
END

STRINGTABLE
BEGIN
    IDS_DESC_THREADSTATECHANGE 
                            "An object for thread state change notification and monitoring."
    IDS_DESC_CROSSVMEVENT   "An object for cross-VM event synchronization used in virtual machine communication."
    IDS_DESC_CROSSVMMUTANT  "An object for cross-VM mutual exclusion used in virtual machine resource coordination."
    IDS_DESC_SCHEDULERSHAREDDATA 
                            "An object for thread scheduler shared memory regions used in scheduler optimizations."
    IDS_DESC_CPUPARTITION   "An object for CPU resource partitioning and isolation management."
    IDS_DESC_VIRTUALKEY     "An object for virtual key management used in virtualization security."
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "driver.rc"


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/WinObjEx64/WinObjEx64.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="DebugWithDriver|x64">
      <Configuration>DebugWithDriver</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleasePrivateDriver|x64">
      <Configuration>ReleasePrivateDriver</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseWinIoDriver|x64">
      <Configuration>ReleaseWinIoDriver</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A68B0947-9415-4ACA-BC0A-8558A4F4FBE3}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WinObjEx64</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugWithDriver|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleasePrivateDriver|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWinIoDriver|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugWithDriver|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleasePrivateDriver|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWinIoDriver|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugWithDriver|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleasePrivateDriver|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <PostBuildEventUseInBuild>
    </PostBuildEventUseInBuild>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <TargetName>$(ProjectName)_private</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWinIoDriver|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <PostBuildEventUseInBuild />
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <TargetName>$(ProjectName)_winio</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <AssemblerOutput>All</AssemblerOutput>
      <CompileAs>CompileAsC</CompileAs>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>$(SolutionDir)\Shared;$(ProjectDir);$(ProjectDir)\props;$(ProjectDir)\extras</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <Version>6.0</Version>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <EntryPointSymbol>
      </EntryPointSymbol>
    </Link>
    <Manifest>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <AdditionalManifestFiles>rsrc\obex.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugWithDriver|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>$(SolutionDir)\Shared;$(ProjectDir);$(ProjectDir)\props;$(ProjectDir)\extras</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USE_OWN_DRIVER;_USE_WINIO;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CompileAs>CompileAsCpp</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <Version>6.0</Version>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <EntryPointSymbol>
      </EntryPointSymbol>
    </Link>
    <Manifest>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <AdditionalManifestFiles>rsrc\obex.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </Bscmake>
    <ResourceCompile />
    <ResourceCompile>
      <PreprocessorDefinitions>_UseOwnDriver;_UseWinIo;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <PostBuildEvent>
      <Command>$(ProjectDir)Utils\GenAsIo2Unlock .\output\$(Platform)\$(Configuration)\$(TargetName)$(TargetExt)</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)\Shared;$(ProjectDir);$(ProjectDir)\props;$(ProjectDir)\extras</AdditionalIncludeDirectories>
      <CompileAs>CompileAsC</CompileAs>
      <EnablePREfast>true</EnablePREfast>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <Version>6.0</Version>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
    <Manifest>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <AdditionalManifestFiles>rsrc\obex.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </Bscmake>
    <CustomBuildStep>
      <Command>
      </Command>
    </CustomBuildStep>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleasePrivateDriver|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USE_OWN_DRIVER;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)\Shared;$(ProjectDir);$(ProjectDir)\props;$(ProjectDir)\extras</AdditionalIncludeDirectories>
      <EnablePREfast>true</EnablePREfast>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <Version>6.0</Version>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
    </Link>
    <Manifest>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <AdditionalManifestFiles>rsrc\obex.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </Bscmake>
    <CustomBuildStep>
      <Command>
      </Command>
    </CustomBuildStep>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <ResourceCompile>
      <PreprocessorDefinitions>_UseOwnDriver;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWinIoDriver|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USE_OWN_DRIVER;_USE_WINIO;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>$(SolutionDir)\Shared;$(ProjectDir);$(ProjectDir)\props;$(ProjectDir)\extras</AdditionalIncludeDirectories>
      <EnablePREfast>true</EnablePREfast>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <Version>6.0</Version>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
    <Manifest>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <AdditionalManifestFiles>rsrc\obex.manifest</AdditionalManifestFiles>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
    <Bscmake>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </Bscmake>
    <CustomBuildStep>
      <Command>
      </Command>
    </CustomBuildStep>
    <PostBuildEvent>
      <Command>$(ProjectDir)Utils\GenAsIo2Unlock .\output\$(Platform)\$(Configuration)\bin\$(TargetName)$(TargetExt)</Command>
    </PostBuildEvent>
    <ResourceCompile>
      <PreprocessorDefinitions>_UseOwnDriver;_UseWinIo;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\minirtl\hextou64.c" />
    <ClCompile Include="..\Shared\minirtl\hextoul.c" />
    <ClCompile Include="..\Shared\minirtl\i64tostr.c" />
    <ClCompile Include="..\Shared\minirtl\itostr.c" />
    <ClCompile Include="..\Shared\minirtl\strtoi.c" />
    <ClCompile Include="..\Shared\minirtl\strtoi64.c" />
    <ClCompile Include="..\Shared\minirtl\strtou64.c" />
    <ClCompile Include="..\Shared\minirtl\strtoul.c" />
    <ClCompile Include="..\Shared\minirtl\u64tohex.c" />
    <ClCompile Include="..\Shared\minirtl\u64tostr.c" />
    <ClCompile Include="..\Shared\minirtl\ultohex.c" />
    <ClCompile Include="..\Shared\minirtl\ultostr.c" />
    <ClCompile Include="..\Shared\minirtl\_filename.c" />
    <ClCompile Include="..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\Shared\minirtl\_strchr.c" />
    <ClCompile Include="..\Shared\minirtl\_strcmp.c" />
    <ClCompile Include="..\Shared\minirtl\_strcmpi.c" />
    <ClCompile Include="..\Shared\minirtl\_strcpy.c" />
    <ClCompile Include="..\Shared\minirtl\_strend.c" />
    <ClCompile Include="..\Shared\minirtl\_strlen.c" />
    <ClCompile Include="..\Shared\minirtl\_strncmp.c" />
    <ClCompile Include="..\Shared\minirtl\_strncmpi.c" />
    <ClCompile Include="..\Shared\minirtl\_strncpy.c" />
    <ClCompile Include="..\Shared\minirtl\_strstr.c" />
    <ClCompile Include="..\Shared\minirtl\_strstri.c" />
    <ClCompile Include="..\Shared\ntos\ntldr.c" />
    <ClCompile Include="..\Shared\ntos\ntsup.c" />
    <ClCompile Include="..\Shared\treelist\treelist.c" />
    <ClCompile Include="aboutDlg.c" />
    <ClCompile Include="drivers\wdbgdrv.c" />
    <ClCompile Include="drivers\wdrvprv.c" />
    <ClCompile Include="drivers\winio.c" />
    <ClCompile Include="excepth.c" />
    <ClCompile Include="extapi.c" />
    <ClCompile Include="extras\extras.c" />
    <ClCompile Include="extras\extrasCallbacks.c" />
    <ClCompile Include="extras\extrasCmOpt.c" />
    <ClCompile Include="extras\extrasDrivers.c" />
    <ClCompile Include="extras\extrasIPC.c" />
    <ClCompile Include="extras\extrasPN.c" />
    <ClCompile Include="extras\extrasPSList.c" />
    <ClCompile Include="extras\extrasSL.c" />
    <ClCompile Include="extras\extrasSSDT.c" />
    <ClCompile Include="extras\extrasUSD.c" />
    <ClCompile Include="findDlg.c" />
    <ClCompile Include="hash.c" />
    <ClCompile Include="hde\hde64.c" />
    <ClCompile Include="kldbg.c" />
    <ClCompile Include="sup\sup.c" />
    <ClCompile Include="sup\sync.c" />
    <ClCompile Include="sup\w32k.c" />
    <ClCompile Include="sup\wine.c" />
    <ClCompile Include="symparser.c" />
    <ClCompile Include="list.c" />
    <ClCompile Include="log\log.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="objects.c" />
    <ClCompile Include="plugmngr.c" />
    <ClCompile Include="props\propAlpcPort.c" />
    <ClCompile Include="props\propBasic.c" />
    <ClCompile Include="props\propDesktop.c" />
    <ClCompile Include="props\propDlg.c" />
    <ClCompile Include="props\propDriver.c" />
    <ClCompile Include="props\propObjectDump.c" />
    <ClCompile Include="props\propProcess.c" />
    <ClCompile Include="props\propSection.c" />
    <ClCompile Include="props\propSecurity.c" />
    <ClCompile Include="props\propToken.c" />
    <ClCompile Include="props\propType.c" />
    <ClCompile Include="sdviewDlg.c" />
    <ClCompile Include="sysinfoDlg.c" />
    <ClCompile Include="tests\ntsup_tests.c" />
    <ClCompile Include="tests\testunit.c" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='DebugWithDriver|x64'">_UseOwnDriver;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\Shared\minirtl\rtltypes.h" />
    <ClInclude Include="..\Shared\minirtl\_filename.h" />
    <ClInclude Include="..\Shared\ntos\apisetx.h" />
    <ClInclude Include="..\Shared\ntos\halamd64.h" />
    <ClInclude Include="..\Shared\ntos\ntalpc.h" />
    <ClInclude Include="..\Shared\ntos\ntbuilds.h" />
    <ClInclude Include="..\Shared\ntos\ntldr.h" />
    <ClInclude Include="..\Shared\ntos\ntos.h" />
    <ClInclude Include="..\Shared\ntos\ntsup.h" />
    <ClInclude Include="..\Shared\ntuser\ntuser.h" />
    <ClInclude Include="..\Shared\sdk\extdef.h" />
    <ClInclude Include="..\Shared\treelist\treelist.h" />
    <ClInclude Include="drivers\wdbgdrv.h" />
    <ClInclude Include="drivers\wdrvprv.h" />
    <ClInclude Include="drivers\winio.h" />
    <ClInclude Include="excepth.h" />
    <ClInclude Include="extapi.h" />
    <ClInclude Include="extras\extras.h" />
    <ClInclude Include="extras\extrasCallbacksPatterns.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="hash.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\pstdint.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="kldbg.h" />
    <ClInclude Include="ksymbols.h" />
    <ClInclude Include="props\propCommon.h" />
    <ClInclude Include="props\props.h" />
    <ClInclude Include="sup\sup.h" />
    <ClInclude Include="sup\w32k.h" />
    <ClInclude Include="sup\wine.h" />
    <ClInclude Include="symparser.h" />
    <ClInclude Include="list.h" />
    <ClInclude Include="log\log.h" />
    <ClInclude Include="msvcver.h" />
    <ClInclude Include="objects.h" />
    <ClInclude Include="kldbg_patterns.h" />
    <ClInclude Include="plugmngr.h" />
    <ClInclude Include="props\propBasicConsts.h" />
    <ClInclude Include="props\propDlg.h" />
    <ClInclude Include="props\propObjectDumpConsts.h" />
    <ClInclude Include="props\propSecurityConsts.h" />
    <ClInclude Include="props\propTypeConsts.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="tests\ntsup_tests.h" />
    <ClInclude Include="tests\testunit.h" />
    <ClInclude Include="ui.h" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="rsrc\100.ico" />
    <Image Include="rsrc\101.ico" />
    <Image Include="rsrc\102.ico" />
    <Image Include="rsrc\103.ico" />
    <Image Include="rsrc\104.ico" />
    <Image Include="rsrc\105.ico" />
    <Image Include="rsrc\106.ico" />
    <Image Include="rsrc\107.ico" />
    <Image Include="rsrc\108.ico" />
    <Image Include="rsrc\109.ico" />
    <Image Include="rsrc\110.ico" />
    <Image Include="rsrc\111.ico" />
    <Image Include="rsrc\112.ico" />
    <Image Include="rsrc\113.ico" />
    <Image Include="rsrc\114.ico" />
    <Image Include="rsrc\115.ico" />
    <Image Include="rsrc\116.ico" />
    <Image Include="rsrc\117.ico" />
    <Image Include="rsrc\118.ico" />
    <Image Include="rsrc\119.ico" />
    <Image Include="rsrc\120.ico" />
    <Image Include="rsrc\121.ico" />
    <Image Include="rsrc\122.ico" />
    <Image Include="rsrc\123.ico" />
    <Image Include="rsrc\124.ico" />
    <Image Include="rsrc\125.ico" />
    <Image Include="rsrc\126.ico" />
    <Image Include="rsrc\127.ico" />
    <Image Include="rsrc\128.ico" />
    <Image Include="rsrc\129.ico" />
    <Image Include="rsrc\130.ico" />
    <Image Include="rsrc\131.ico" />
    <Image Include="rsrc\132.ico" />
    <Image Include="rsrc\133.ico" />
    <Image Include="rsrc\134.ico" />
    <Image Include="rsrc\135.ico" />
    <Image Include="rsrc\136.ico" />
    <Image Include="rsrc\137.ico" />
    <Image Include="rsrc\138.ico" />
    <Image Include="rsrc\139.ico" />
    <Image Include="rsrc\140.ico" />
    <Image Include="rsrc\141.ico" />
    <Image Include="rsrc\142.ico" />
    <Image Include="rsrc\143.ico" />
    <Image Include="rsrc\144.ico" />
    <Image Include="rsrc\145.ico" />
    <Image Include="rsrc\146.ico" />
    <Image Include="rsrc\147.ico" />
    <Image Include="rsrc\148.ico" />
    <Image Include="rsrc\149.ico" />
    <Image Include="rsrc\6001.ico" />
    <Image Include="rsrc\6002.ico" />
    <Image Include="rsrc\Bitmap_125.bmp" />
    <Image Include="rsrc\icon1.ico" />
    <Image Include="rsrc\mailslot.ico" />
    <Image Include="rsrc\pipe.ico" />
    <Image Include="rsrc\security.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Source/WinObjEx64/WinObjEx64.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\extras">
      <UniqueIdentifier>{3dd02ac9-71cb-4104-baba-dee9bd04a2cc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\props">
      <UniqueIdentifier>{cb4d8330-830a-457c-9f73-0d59de70caa2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files\graphics">
      <UniqueIdentifier>{87a2b20f-17e9-4ce8-abbd-11f4b06fde61}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\log">
      <UniqueIdentifier>{9201749a-5b24-4976-a330-f03440b3e27d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\tests">
      <UniqueIdentifier>{495dbe60-1cd4-44e0-a57a-5820605391e9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\drivers">
      <UniqueIdentifier>{da588ca3-321f-4491-adcb-55b1d888e133}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\treelist">
      <UniqueIdentifier>{34095c79-e50f-47a4-9daa-c1f74616bcfe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Ntos">
      <UniqueIdentifier>{621f3500-b7f1-418f-8901-7eff2d8c3a2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Minirtl">
      <UniqueIdentifier>{1f87af63-dc0b-4a32-88ee-e9e15a1041c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Hde">
      <UniqueIdentifier>{b8b6096c-f90d-41f3-a643-a53ee0fae82b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\sup">
      <UniqueIdentifier>{ef3c4ca0-1364-4947-a6d6-091b33037c05}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="aboutDlg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="excepth.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="findDlg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="kldbg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="list.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hde\hde64.c">
      <Filter>Hde</Filter>
    </ClCompile>
    <ClCompile Include="objects.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="extapi.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="tests\testunit.c">
      <Filter>Source Files\tests</Filter>
    </ClCompile>
    <ClCompile Include="extras\extras.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasDrivers.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasPN.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasSSDT.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasUSD.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="props\propBasic.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propDesktop.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propDlg.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propDriver.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propObjectDump.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propProcess.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propSecurity.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propType.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasIPC.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasPSList.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasCallbacks.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="props\propToken.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasSL.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="plugmngr.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcat.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strchr.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcmp.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcmpi.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcpy.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strend.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strlen.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strncmp.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strncmpi.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strncpy.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strstr.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strstri.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\hextou64.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\hextoul.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\i64tostr.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\itostr.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtoi.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtoi64.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtou64.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtoul.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\u64tohex.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\u64tostr.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\ultohex.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\ultostr.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ntos\ntldr.c">
      <Filter>Ntos</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\treelist\treelist.c">
      <Filter>Source Files\treelist</Filter>
    </ClCompile>
    <ClCompile Include="log\log.c">
      <Filter>Source Files\log</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ntos\ntsup.c">
      <Filter>Ntos</Filter>
    </ClCompile>
    <ClCompile Include="sdviewDlg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="props\propAlpcPort.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="props\propSection.c">
      <Filter>Source Files\props</Filter>
    </ClCompile>
    <ClCompile Include="symparser.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hash.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="drivers\wdrvprv.c">
      <Filter>Source Files\drivers</Filter>
    </ClCompile>
    <ClCompile Include="drivers\winio.c">
      <Filter>Source Files\drivers</Filter>
    </ClCompile>
    <ClCompile Include="drivers\wdbgdrv.c">
      <Filter>Source Files\drivers</Filter>
    </ClCompile>
    <ClCompile Include="extras\extrasCmOpt.c">
      <Filter>Source Files\extras</Filter>
    </ClCompile>
    <ClCompile Include="sysinfoDlg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="sup\sup.c">
      <Filter>Source Files\sup</Filter>
    </ClCompile>
    <ClCompile Include="sup\sync.c">
      <Filter>Source Files\sup</Filter>
    </ClCompile>
    <ClCompile Include="sup\wine.c">
      <Filter>Source Files\sup</Filter>
    </ClCompile>
    <ClCompile Include="sup\w32k.c">
      <Filter>Source Files\sup</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_filename.c">
      <Filter>Minirtl</Filter>
    </ClCompile>
    <ClCompile Include="tests\ntsup_tests.c">
      <Filter>Source Files\tests</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="excepth.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kldbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="list.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hde\hde64.h">
      <Filter>Hde</Filter>
    </ClInclude>
    <ClInclude Include="hde\table64.h">
      <Filter>Hde</Filter>
    </ClInclude>
    <ClInclude Include="hde\pstdint.h">
      <Filter>Hde</Filter>
    </ClInclude>
    <ClInclude Include="objects.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="extapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tests\testunit.h">
      <Filter>Source Files\tests</Filter>
    </ClInclude>
    <ClInclude Include="msvcver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="extras\extras.h">
      <Filter>Source Files\extras</Filter>
    </ClInclude>
    <ClInclude Include="props\propBasicConsts.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="props\propDlg.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="props\propObjectDumpConsts.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="props\propSecurityConsts.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="props\propTypeConsts.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="kldbg_patterns.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugmngr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\rtltypes.h">
      <Filter>Minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\apisetx.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntalpc.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntldr.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntos.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\treelist\treelist.h">
      <Filter>Source Files\treelist</Filter>
    </ClInclude>
    <ClInclude Include="extras\extrasCallbacksPatterns.h">
      <Filter>Source Files\extras</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\halamd64.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="symparser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="log\log.h">
      <Filter>Source Files\log</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntsup.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="ksymbols.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntbuilds.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="hash.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\minirtl.h">
      <Filter>Minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntuser\ntuser.h">
      <Filter>Ntos</Filter>
    </ClInclude>
    <ClInclude Include="drivers\wdrvprv.h">
      <Filter>Source Files\drivers</Filter>
    </ClInclude>
    <ClInclude Include="drivers\winio.h">
      <Filter>Source Files\drivers</Filter>
    </ClInclude>
    <ClInclude Include="drivers\wdbgdrv.h">
      <Filter>Source Files\drivers</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\sdk\extdef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="props\propCommon.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="sup\sup.h">
      <Filter>Source Files\sup</Filter>
    </ClInclude>
    <ClInclude Include="sup\wine.h">
      <Filter>Source Files\sup</Filter>
    </ClInclude>
    <ClInclude Include="props\props.h">
      <Filter>Source Files\props</Filter>
    </ClInclude>
    <ClInclude Include="sup\w32k.h">
      <Filter>Source Files\sup</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\_filename.h">
      <Filter>Minirtl</Filter>
    </ClInclude>
    <ClInclude Include="tests\ntsup_tests.h">
      <Filter>Source Files\tests</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Image Include="rsrc\pipe.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\100.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\101.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\102.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\103.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\104.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\105.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\106.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\107.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\108.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\109.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\110.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\111.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\112.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\113.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\114.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\115.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\116.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\117.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\118.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\119.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\120.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\121.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\122.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\123.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\124.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\125.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\126.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\127.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\128.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\129.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\130.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\131.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\132.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\133.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\134.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\135.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\136.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\137.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\138.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\139.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\140.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\141.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\142.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\143.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\144.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\145.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\146.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\147.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\148.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\6001.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\6002.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\Bitmap_125.bmp">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\icon1.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\mailslot.ico">
      <Filter>Resource Files\graphics</Filter>
    </Image>
    <Image Include="rsrc\149.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="rsrc\security.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Source/WinObjEx64/WinObjEx64.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugWithDriver|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments />
  </PropertyGroup>
</Project>
```

`Source/WinObjEx64/aboutDlg.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       ABOUTDLG.C
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "msvcver.h"

#define T_ABOUTDLG_ICON_PROP TEXT("aboutDlgIcon")

/*
* AboutDialogInit
*
* Purpose:
*
* Displays program version and system information
*
*/
VOID AboutDialogInit(
    HWND hwndDlg
)
{
    BOOLEAN bSecureBoot = FALSE;
    BOOLEAN bHVCIEnabled = FALSE, bHVCIStrict = FALSE, bHVCIIUMEnabled = FALSE;
    PCHAR wine_ver;
    SIZE_T verLen, totalLen, i;
    HANDLE hImage;
    WCHAR szBuffer[MAX_PATH];
    PWCHAR wbuf;

    FIRMWARE_TYPE firmwareType;

    SetDlgItemText(hwndDlg, ID_ABOUT_PROGRAM, PROGRAM_NAME_AND_TITLE);

    RtlStringCchPrintfSecure(szBuffer,
        MAX_PATH,
        TEXT("%lu.%lu.%lu"),
        PROGRAM_MAJOR_VERSION,
        PROGRAM_MINOR_VERSION,
        PROGRAM_REVISION_NUMBER);

    SetDlgItemText(hwndDlg, ID_ABOUT_BUILDINFO, szBuffer);

    //
    // Set dialog icon.
    //
    hImage = LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_MAIN),
        IMAGE_ICON,
        48, 48,
        0);

    if (hImage) {

        SendDlgItemMessage(hwndDlg, ID_ABOUT_ICON,
            STM_SETIMAGE, IMAGE_ICON, (LPARAM)hImage);

        SetProp(hwndDlg, T_ABOUTDLG_ICON_PROP, hImage);
    }

    //
    // Set compiler version and name.
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    _strcpy(szBuffer, VC_VER);
    if (szBuffer[0] == 0) {
        _strcpy(szBuffer, TEXT("MSVC ("));
        ultostr(_MSC_FULL_VER, _strend(szBuffer));
        _strcat(szBuffer, TEXT(")"));
    }
#if defined(__cplusplus)
    _strcat(szBuffer, TEXT(" compiled as C++"));
#else
    _strcat(szBuffer, TEXT(" compiled as C"));
#endif

    SetDlgItemText(hwndDlg, ID_ABOUT_COMPILERINFO, szBuffer);

    //
    // Set build date and time.
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    RtlStringCchPrintfSecure(szBuffer,
        ARRAYSIZE(szBuffer),
        TEXT("%ws %ws"),
        TEXT(__DATE__),
        TEXT(__TIME__));

    SetDlgItemText(hwndDlg, ID_ABOUT_BUILDDATE, szBuffer);

    //
    // Fill OS name.
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    if (g_WinObj.IsWine) {
        _strcpy(szBuffer, TEXT("Reported as "));
    }

    RtlStringCchPrintfSecure(_strend(szBuffer),
        100,
        TEXT("Windows NT %1u.%1u (build %u"),
        g_WinObj.osver.dwMajorVersion,
        g_WinObj.osver.dwMinorVersion,
        g_WinObj.osver.dwBuildNumber);

    if (g_WinObj.osver.szCSDVersion[0]) {
        _strcat(szBuffer, TEXT(", "));
        _strcat(szBuffer, g_WinObj.osver.szCSDVersion);
    }
    _strcat(szBuffer, TEXT(")"));

    //
    // Fill boot options.
    //   
    if (g_WinObj.IsWine) {
        wine_ver = GetWineVersion();
        if (wine_ver == NULL)
            wine_ver = "Unknown";
        verLen = _strlen_a(wine_ver);
        totalLen = verLen + 5 + 1; // "Wine " + 0
        wbuf = (PWCHAR)supHeapAlloc(totalLen * sizeof(WCHAR));
        if (wbuf) {
            _strcpy(wbuf, L"Wine ");
            for (i = 0; i < verLen; i++)
                wbuf[5 + i] = (WCHAR)(UCHAR)wine_ver[i];
            wbuf[5 + verLen] = 0;
            SetDlgItemText(hwndDlg, ID_ABOUT_OSNAME, wbuf);
            supHeapFree(wbuf);
        }
    }
    else {
        SetDlgItemText(hwndDlg, ID_ABOUT_OSNAME, szBuffer);

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));

        //
        // Query KD debugger enabled.
        //
        if (supIsKdEnabled(NULL, NULL)) {
            _strcpy(szBuffer, TEXT("Debug, "));
        }

        //
        // Query VHD boot state if possible.
        //
        if (g_kdctx.IsOsDiskVhd) {
            _strcat(szBuffer, TEXT("VHD, "));
        }

        //
        // Query firmware mode and SecureBoot state for UEFI.
        //
        firmwareType = g_kdctx.Data->FirmwareType;

        if (firmwareType == FirmwareTypeUnknown) {

            _strcpy(szBuffer, T_Unknown);

        }
        else {

            if (firmwareType == FirmwareTypeUefi) {
                _strcat(szBuffer, TEXT("UEFI"));
            }
            else {
                if (firmwareType == FirmwareTypeBios) {
                    _strcat(szBuffer, TEXT("BIOS"));
                }
                else {
                    _strcat(szBuffer, TEXT("Unknown"));
                }
            }

            if (firmwareType == FirmwareTypeUefi) {
                bSecureBoot = FALSE;
                if (supQuerySecureBootState(&bSecureBoot)) {
                    _strcat(szBuffer, TEXT(" with"));
                    if (bSecureBoot == FALSE) {
                        _strcat(szBuffer, TEXT("out"));
                    }
                    _strcat(szBuffer, TEXT(" SecureBoot"));
                }
                g_kdctx.IsSecureBoot = bSecureBoot;

                if (supQueryHVCIState(&bHVCIEnabled, &bHVCIStrict, &bHVCIIUMEnabled)) {
                    if (bHVCIEnabled) {
                        _strcat(szBuffer, TEXT(", HVCI"));
                        if (bHVCIStrict)
                            _strcat(szBuffer, TEXT(" (strict)"));
                        if (bHVCIIUMEnabled)
                            _strcat(szBuffer, TEXT(", IUM"));
                    }
                }
            }
        }

        SetDlgItemText(hwndDlg, ID_ABOUT_ADVINFO, szBuffer);
    }

    SetFocus(GetDlgItem(hwndDlg, IDOK));
}

/*
* AboutDialogOnNotify
*
* Purpose:
*
* WM_NOTIFY handler.
*
*/
VOID AboutDialogOnNotify(
    _In_ HWND   hwndDlg,
    _In_ LPARAM lParam
)
{
    PNMLINK pNMLink;
    LITEM item;

    switch (((LPNMHDR)lParam)->code) {
    case NM_CLICK:
    case NM_RETURN:

        pNMLink = (PNMLINK)lParam;
        item = pNMLink->item;
        if ((((LPNMHDR)lParam)->hwndFrom == GetDlgItem(hwndDlg, IDC_ABOUT_SYSLINK))
            && (item.iLink == 0))
        {
            supShellExecInExplorerProcess(item.szUrl, NULL);
        }

        break;
    }
}

/*
* AboutDialogProc
*
* Purpose:
*
* About Dialog Window Procedure
*
* During WM_INITDIALOG centers window and initializes system info
*
*/
INT_PTR CALLBACK AboutDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    HANDLE hIcon;

    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        supCenterWindow(hwndDlg);
        AboutDialogInit(hwndDlg);
        return TRUE;

    case WM_NOTIFY:
        AboutDialogOnNotify(hwndDlg, lParam);
        break;

    case WM_COMMAND:

        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {

            hIcon = RemoveProp(hwndDlg, T_ABOUTDLG_ICON_PROP);
            if (hIcon) {
                DestroyIcon((HICON)hIcon);
            }
            return EndDialog(hwndDlg, TRUE);

        }

    }
    return 0;
}

static HANDLE StatsDialogThreadHandle = NULL;
static FAST_EVENT StatsDialogInitializedEvent = FAST_EVENT_INIT;
#define UPDATE_TIMER_ID 1

/*
* StatsTimerProc
*
* Purpose:
*
* Statistics timer callback.
*
*/
VOID StatsTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT_PTR idEvent,
    DWORD dwTime)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(idEvent);
    UNREFERENCED_PARAMETER(dwTime);

    WCHAR szBuffer[64];

    SetDlgItemInt(hwnd, IDC_STATS_TOTALHEAPALLOC, g_WinObjStats.TotalHeapAlloc, FALSE);
    SetDlgItemInt(hwnd, IDC_STATS_TOTALHEAPFREE, g_WinObjStats.TotalHeapFree, FALSE);
    SetDlgItemInt(hwnd, IDC_STATS_TOTALHEAPSCREATED, g_WinObjStats.TotalHeapsCreated, FALSE);
    SetDlgItemInt(hwnd, IDC_STATS_TOTALHEAPSDESTROYED, g_WinObjStats.TotalHeapsDestroyed, FALSE);
    SetDlgItemInt(hwnd, IDC_STATS_TOTALTHREADSCREATED, g_WinObjStats.TotalThreadsCreated, FALSE);

    szBuffer[0] = 0;
    u64tostr(g_WinObjStats.TotalHeapMemoryAllocated, &szBuffer[0]);
    SetDlgItemText(hwnd, IDC_STATS_TOTALTHEAPMEMORYALLOCATED, szBuffer);

#ifdef _DEBUG
    ShowWindow(GetDlgItem(hwnd, IDC_STATS_MAXHEAPALLOCATEDSIZE_STATIC), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, IDC_STATS_MAXHEAPALLOCATEDSIZE), SW_SHOW);
    szBuffer[0] = 0;
    u64tostr(g_WinObjStats.MaxHeapAllocatedBlockSize, &szBuffer[0]);
    SetDlgItemText(hwnd, IDC_STATS_MAXHEAPALLOCATEDSIZE, szBuffer);
#endif
}

/*
* StatsDialogProc
*
* Purpose:
*
* Statistics Dialog Window Procedure
*
* During WM_INITDIALOG centers window and sets timer callback.
*
*/
INT_PTR CALLBACK StatsDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
        SetTimer(hwndDlg, UPDATE_TIMER_ID, 1000, (TIMERPROC)StatsTimerProc);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        KillTimer(hwndDlg, UPDATE_TIMER_ID);
        return DestroyWindow(hwndDlg);

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
        case IDOK:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;
        }
        break;
    }
    return 0;
}

/*
* StatsDialogWorkerThread
*
* Purpose:
*
* Worker thread that creates dialog window and processes messages queue.
*
*/
DWORD StatsDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;

    UNREFERENCED_PARAMETER(Parameter);

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_STATS),
        0,
        (DLGPROC)&StatsDialogProc,
        0);

    supSetFastEvent(&StatsDialogInitializedEvent);

    do {

        bResult = GetMessage(&message, NULL, 0, 0);
        if (bResult == -1)
            break;

        if (!IsDialogMessage(hwndDlg, &message)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }

    } while (bResult != 0);

    supResetFastEvent(&StatsDialogInitializedEvent);

    if (StatsDialogThreadHandle) {
        NtClose(StatsDialogThreadHandle);
        StatsDialogThreadHandle = NULL;
    }
    return 0;
}

/*
* ShowStatsDialog
*
* Purpose:
*
* Create statistics dialog if none present.
*
*/
VOID ShowStatsDialog(
    VOID
)
{
    if (!StatsDialogThreadHandle) {

        StatsDialogThreadHandle = supCreateThread(StatsDialogWorkerThread, NULL, 0);
        supWaitForFastEvent(&StatsDialogInitializedEvent, NULL);

    }
}

```

`Source/WinObjEx64/driver.rc`:

```rc
#include "resource.h"
#include "winres.h"
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#ifndef _UseOwnDriver
IDR_KDBGDRV SYS "..\\drvstore\\kldbgdrv.sys"
#else
#ifdef _UseWinIo
IDR_KDBGDRV SYS "..\\drvstore\\winio.sys"
#else
IDR_KDBGDRV SYS "..\\drvstore\\wodbgdrv.sys"
#endif
#endif

```

`Source/WinObjEx64/drivers/wdbgdrv.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       WDBGDRV.C
*
*  VERSION:     1.93
*
*  DATE:        22 Apr 2022
* 
*  MS WinDbg kldbgdrv based reader.
* 
*  Note:
* 
*    Windows Debug mode is required for using this driver.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "wdbgdrv.h"

/*
* WDbgpDrvReadSystemMemoryWithStatus
*
* Purpose:
*
* Wrapper around SysDbgReadVirtual request to the KLDBGDRV/WODBGDRV
*
*/
BOOL WDbgpDrvReadSystemMemoryWithStatus(
    _In_ WDRV_CONTEXT* Context,
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead,
    _Out_ NTSTATUS* Status,
    _Out_ PIO_STATUS_BLOCK IoStatus
)
{
    BOOL            bResult;
    NTSTATUS        ntStatus;
    KLDBG           kldbg;
    IO_STATUS_BLOCK iost;
    SYSDBG_VIRTUAL  dbgRequest;

    if (NumberOfBytesRead)
        *NumberOfBytesRead = 0;

    *Status = STATUS_UNSUCCESSFUL;
    IoStatus->Information = 0;
    IoStatus->Status = STATUS_UNSUCCESSFUL;

    //
    // Fill parameters for KdSystemDebugControl.
    //
    dbgRequest.Address = (PVOID)Address;
    dbgRequest.Buffer = Buffer;
    dbgRequest.Request = BufferSize;

    //
    // Fill parameters for kldbgdrv ioctl.
    //
    kldbg.SysDbgRequest = SysDbgReadVirtual;
    kldbg.Buffer = &dbgRequest;
    kldbg.BufferSize = sizeof(SYSDBG_VIRTUAL);

    iost.Information = 0;
    iost.Status = 0;

    ntStatus = NtDeviceIoControlFile(Context->DeviceHandle,
        NULL,
        NULL,
        NULL,
        &iost,
        IOCTL_KD_PASS_THROUGH,
        &kldbg,
        sizeof(kldbg),
        &dbgRequest,
        sizeof(dbgRequest));

    if (ntStatus == STATUS_PENDING) {

        ntStatus = NtWaitForSingleObject(Context->DeviceHandle,
            FALSE,
            NULL);

    }

    *Status = ntStatus;

    if (NT_SUCCESS(ntStatus))
        ntStatus = iost.Status;

    IoStatus->Information = iost.Information;
    IoStatus->Status = iost.Status;

    bResult = NT_SUCCESS(ntStatus);

    if (bResult) {

        if (NumberOfBytesRead)
            *NumberOfBytesRead = (ULONG)iost.Information;

    }
    else {
        //
        // We don't need this information in case of error.
        //
        if (!NT_ERROR(ntStatus)) {
            if (NumberOfBytesRead)
                *NumberOfBytesRead = (ULONG)iost.Information;
        }

    }

    return bResult;
}

/*
* WDbgDrvReadSystemMemory
*
* Purpose:
*
* Call internal WDbgpDrvReadSystemMemoryWithStatus.
*
*/
BOOL WDbgDrvReadSystemMemory(
    _In_ WDRV_CONTEXT* Context,
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead
)
{
    ULONG numberOfBytesRead = 0;

    if (NumberOfBytesRead)
        *NumberOfBytesRead = 0;

    if ((Buffer == NULL) ||
        (BufferSize == 0) ||
        (Address < g_kdctx.SystemRangeStart))
    {
        return FALSE;
    }

    BOOL bResult = WDbgpDrvReadSystemMemoryWithStatus(Context,
        Address,
        Buffer,
        BufferSize,
        &numberOfBytesRead,
        &Context->LastNtStatus,
        &Context->IoStatusBlock);

    if (NumberOfBytesRead)
        *NumberOfBytesRead = numberOfBytesRead;

    return bResult;
}

```

`Source/WinObjEx64/drivers/wdbgdrv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       WDBGDRV.H
*
*  VERSION:     1.93
*
*  DATE:        22 Apr 2022
*
*  Common header file for the WINDBG Driver Helper support.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

BOOL WDbgDrvReadSystemMemory(
    _In_ WDRV_CONTEXT* Context,
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

```

`Source/WinObjEx64/drivers/wdrvprv.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       WDRVPRV.C
*
*  VERSION:     2.09
*
*  DATE:        20 Aug 2025
*
*  Driver providers abstraction layer.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "drivers/wdbgdrv.h"
#include "drivers/winio.h"

#ifdef _USE_OWN_DRIVER

#ifdef _USE_WINIO

#define WDRV_PROVIDER_TYPE wdrvWinIo
static WDRV_PROVIDER g_wdpEntry = {
    WINIO_DRV_NAME,
    WINIO_DEV_NAME,
    WDRVPROV_FLAGS_UEFI_REQUIRED | WDRVPROV_FLAGS_FORCE_SD,
    WDrvStartDriver,
    WDrvStopDriver,
    WDrvOpenDriver,
    NULL, //register
    NULL, //unregister
    NULL, //preopen
    WDrvProvPostOpen,
    WinIoReadSystemMemory
};

#elif defined(_USE_RONOVA)

#define WDRV_PROVIDER_TYPE wdrvRonova
static WDRV_PROVIDER g_wdpEntry = {
    L"rnv64hkt",
    L"ronova",
    WDRVPROV_FLAGS_UEFI_REQUIRED,
    WDrvStartDriver,
    WDrvStopDriver,
    WDrvOpenDriver,
    NULL, //register
    NULL, //unregister
    NULL, //preopen
    NULL, //postopen
    WDbgDrvReadSystemMemory
};

#else

#define WDRV_PROVIDER_TYPE wdrvWinObjEx64
static WDRV_PROVIDER g_wdpEntry = {
    L"wodbgdrv",
    L"wodbgdrv",
    WDRVPROV_FLAGS_NONE,
    WDrvStartDriver,
    WDrvStopDriver,
    WDrvOpenDriver,
    NULL, //register
    NULL, //unregister
    NULL, //preopen
    NULL, //postopen
    WDbgDrvReadSystemMemory
};

#endif

#else

#define WDRV_PROVIDER_TYPE wdrvMicrosoft
static WDRV_PROVIDER g_wdpEntry = {
    L"kldbgdrv",
    L"kldbgdrv",
    WDRVPROV_FLAGS_NONE,
    WDrvStartDriver,
    WDrvStopDriver,
    WDrvOpenDriver,
    NULL, //register
    NULL, //unregister
    NULL, //preopen
    NULL, //postopen
    WDbgDrvReadSystemMemory
};

#endif /* _USE_OWN_DRIVER */

#define PHY_ADDRESS_MASK                0x000ffffffffff000ull
#define PHY_ADDRESS_MASK_1GB_PAGES      0x000fffffc0000000ull
#define PHY_ADDRESS_MASK_2MB_PAGES      0x000fffffffe00000ull
#define VADDR_ADDRESS_MASK_1GB_PAGES    0x000000003fffffffull
#define VADDR_ADDRESS_MASK_2MB_PAGES    0x00000000001fffffull
#define VADDR_ADDRESS_MASK_4KB_PAGES    0x0000000000000fffull
#define ENTRY_PRESENT_BIT               1
#define ENTRY_PAGE_SIZE_BIT             0x0000000000000080ull


static inline BOOLEAN PwEntryToPhyAddr(
    _In_ ULONG_PTR entry,
    _Out_ ULONG_PTR* phyaddr)
{
    if ((entry & ENTRY_PRESENT_BIT) == 0) {
        *phyaddr = 0;
        return FALSE;
    }

    *phyaddr = entry & PHY_ADDRESS_MASK;
    return TRUE;
}

NTSTATUS PwVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ provQueryPML4 QueryPML4Routine,
    _In_ provReadPhysicalMemory ReadPhysicalMemoryRoutine,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    NTSTATUS    ntStatus;
    ULONG_PTR   pml4_cr3, selector, table, entry = 0;
    INT         r, shift;
    
    if (PhysicalAddress == NULL)
        return STATUS_INVALID_PARAMETER;

    ntStatus = QueryPML4Routine(DeviceHandle, &pml4_cr3);
    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    table = pml4_cr3 & PHY_ADDRESS_MASK;

    for (r = 0; r < 4; r++) {

        shift = 39 - (r * 9);
        selector = (VirtualAddress >> shift) & 0x1ff;

        ntStatus = ReadPhysicalMemoryRoutine(DeviceHandle,
            table + selector * 8,
            &entry,
            sizeof(ULONG_PTR));

        if (!NT_SUCCESS(ntStatus))
            return ntStatus;

        if (!PwEntryToPhyAddr(entry, &table))
            return STATUS_INTERNAL_ERROR;

        if (entry & ENTRY_PAGE_SIZE_BIT)
        {
            if (r == 1) {
                table &= PHY_ADDRESS_MASK_1GB_PAGES;
                table += VirtualAddress & VADDR_ADDRESS_MASK_1GB_PAGES;
                *PhysicalAddress = table;
                return STATUS_SUCCESS;
            }

            if (r == 2) {
                table &= PHY_ADDRESS_MASK_2MB_PAGES;
                table += VirtualAddress & VADDR_ADDRESS_MASK_2MB_PAGES;
                *PhysicalAddress = table;
                return STATUS_SUCCESS;
            }
        }
    }

    table += VirtualAddress & VADDR_ADDRESS_MASK_4KB_PAGES;
    *PhysicalAddress = table;

    return STATUS_SUCCESS;
}

WDRVPRVTYPE WDrvGetActiveProviderType(
    VOID)
{
    return (WDRVPRVTYPE)WDRV_PROVIDER_TYPE;
}

/*
* WDrvProvPostOpen
*
* Purpose:
*
* Provider post-open driver generic callback.
*
*/
BOOL WINAPI WDrvProvPostOpen(
    _In_ PVOID Param
)
{
    WDRV_CONTEXT* Context = (WDRV_CONTEXT*)Param;
    PSECURITY_DESCRIPTOR driverSD = NULL;

    PACL defaultAcl = NULL;
    HANDLE deviceHandle;
    HANDLE strHandle = NULL;
    NTSTATUS ntStatus;

    deviceHandle = Context->DeviceHandle;

    //
    // Check if we need to forcebly set SD.
    //
    if (Context->Provider->ForceSD) {
        ntStatus = supCreateSystemAdminAccessSD(&driverSD, &defaultAcl);
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = NtSetSecurityObject(deviceHandle,
                DACL_SECURITY_INFORMATION,
                driverSD);

            if (defaultAcl) supHeapFree(defaultAcl);
            supHeapFree(driverSD);

            if (NT_SUCCESS(ntStatus)) {

                //
                // Remove WRITE_DAC from resulting handle by duplicating with reduced rights.
                //
                if (NT_SUCCESS(NtDuplicateObject(NtCurrentProcess(),
                    deviceHandle,
                    NtCurrentProcess(),
                    &strHandle,
                    GENERIC_WRITE | GENERIC_READ,
                    0,
                    0)))
                {
                    NtClose(deviceHandle);
                    deviceHandle = strHandle;
                }
            }
            Context->DeviceHandle = deviceHandle;
        }
    }

    return (deviceHandle != NULL);
}

/*
* WDrvExtractDriverResource
*
* Purpose:
*
* Extract driver from application resource
*
*/
BOOL WDrvExtractDriverResource(
    _In_ LPCWSTR lpExtractTo,
    _In_ LPCWSTR lpName,
    _In_ LPCWSTR lpType
)
{
    HRSRC   hResInfo = NULL;
    HGLOBAL hResData = NULL;
    PVOID   pData;
    BOOL    bResult = FALSE;
    DWORD   dwSize = 0, dwLastError = ERROR_SUCCESS;
    HANDLE  hFile;

    hResInfo = FindResource(g_WinObj.hInstance, lpName, lpType);
    if (hResInfo == NULL) {
        SetLastError(ERROR_RESOURCE_NAME_NOT_FOUND);
        return bResult;
    }

    dwSize = SizeofResource(g_WinObj.hInstance, hResInfo);
    if (dwSize == 0) {
        return bResult;
    }

    hResData = LoadResource(g_WinObj.hInstance, hResInfo);
    if (hResData == NULL) {
        return bResult;
    }

    pData = LockResource(hResData);
    if (pData == NULL) {
        return bResult;
    }

    hFile = CreateFile(lpExtractTo,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return bResult;
    }
    else {
        bResult = WriteFile(hFile, pData, dwSize, &dwSize, NULL);
        if (!bResult) dwLastError = GetLastError();
        CloseHandle(hFile);
    }

    SetLastError(dwLastError);
    return bResult;
}

/*
* WDrvExtractDriver
*
* Purpose:
*
* Save driver to system32\drivers from application resource.
*
* N.B. If driver already exist on disk function return TRUE.
* This is required for WinDBG compatibility.
*
*/
BOOL WDrvExtractDriver(
    _In_ WCHAR* szDriverPath
)
{
    BOOL bResult = FALSE;

    //
    // If no file exists, extract it to the drivers directory.
    //
    bResult = PathFileExists(szDriverPath);

    if (!bResult) {
        bResult = WDrvExtractDriverResource(szDriverPath, MAKEINTRESOURCE(IDR_KDBGDRV), L"SYS");
    }

    return bResult;
}

/*
* WDrvLoadDriver
*
* Purpose:
*
* Load helper driver.
*
*/
NTSTATUS WDrvLoadDriver(
    _In_ PWDRV_CONTEXT Context
)
{
    NTSTATUS ntStatus;

    //
    // Build file path and write file to disk.
    //
    RtlStringCchPrintfSecure(Context->DriverFileName,
        ARRAYSIZE(Context->DriverFileName),
        L"%ws\\drivers\\%ws.sys",
        g_WinObj.szSystemDirectory,
        Context->Provider->DriverName);

    if (!WDrvExtractDriver(Context->DriverFileName)) {
        return STATUS_FILE_NOT_AVAILABLE;
    }

    ntStatus = supLoadDriverEx(Context->Provider->DriverName,
        Context->DriverFileName,
        TRUE,
        NULL,
        NULL);

    if (!NT_SUCCESS(ntStatus)) {
        DeleteFile(Context->DriverFileName);
    }

    return ntStatus;
}

/*
* WDrvOpenDriver
*
* Purpose:
*
* Open handle to driver device, run optional callbacks.
*
*/
NTSTATUS WDrvOpenDriver(
    _In_ PWDRV_CONTEXT Context
)
{
    NTSTATUS ntStatus;
    HANDLE deviceHandle = NULL;

    ULONG openFlags = GENERIC_WRITE | GENERIC_READ;

    if (Context->Provider->Callbacks.PreOpenDriver) {
        Context->Provider->Callbacks.PreOpenDriver((PVOID)Context);
    }

    if (Context->Provider->ForceSD)
        openFlags |= WRITE_DAC;

    ntStatus = supOpenDriver(Context->Provider->DeviceName,
        openFlags,
        &deviceHandle);

    if (NT_SUCCESS(ntStatus)) {
        Context->DeviceHandle = deviceHandle;

        if (Context->Provider->Callbacks.PostOpenDriver) {
            Context->Provider->Callbacks.PostOpenDriver((PVOID)Context);
        }
    }

    return ntStatus;
}

/*
* WDrvStartDriver
*
* Purpose:
*
* Load driver and open handle to it, run optional callbacks.
*
*/
NTSTATUS WDrvStartDriver(
    _In_ PWDRV_CONTEXT Context
)
{
    BOOL bLoaded = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Check if driver already loaded.
    //
    if (supIsObjectExists((LPWSTR)L"\\Device", Context->Provider->DeviceName)) {
        Context->IsOurLoad = FALSE;
        bLoaded = TRUE;
    }
    else {
        ntStatus = WDrvLoadDriver(Context);
        bLoaded = NT_SUCCESS(ntStatus);
        Context->IsOurLoad = bLoaded;
    }

    if (bLoaded) {
        Context->LoadStatus = ntStatus;
        ntStatus = Context->Provider->Callbacks.OpenDriver(Context);
        Context->OpenStatus = ntStatus;
    }

    return ntStatus;
}

/*
* WDrvStopDriver
*
* Purpose:
*
* Stop driver, delete registry entry and remove driver file from disk.
*
*/
VOID WDrvStopDriver(
    _In_ PWDRV_CONTEXT Context
)
{
    NTSTATUS ntStatus;
    LPWSTR lpDriverName = Context->Provider->DriverName;
    LPWSTR lpFullFileName = Context->DriverFileName;

    ntStatus = supUnloadDriver(lpDriverName, TRUE);
    if (NT_SUCCESS(ntStatus)) {
        supDeleteFileWithWait(1000, 5, lpFullFileName);
    }
}

/*
* WDrvProvCreate
*
* Purpose:
*
* Create driver provider instance.
*
* Note:
* SE_DEBUG_PRIVILEGE must be assigned.
*
*/
NTSTATUS WDrvProvCreate(
    _In_ FIRMWARE_TYPE FirmwareType,
    _Out_ PWDRV_CONTEXT Context
)
{
    NTSTATUS ntStatus;
    PWDRV_PROVIDER provider = NULL;

    //
    // Enable debug privilege.
    //
    if (!supEnablePrivilege(SE_DEBUG_PRIVILEGE, TRUE))
        return STATUS_PRIVILEGE_NOT_HELD;

    provider = &g_wdpEntry;

    //
    // UEFI compat check.
    //
    if (provider->UefiRequired && (FirmwareType != FirmwareTypeUefi))
        return STATUS_NOT_SUPPORTED;

    Context->Provider = provider;

    //
    // Load and open driver.
    //
    ntStatus = Context->Provider->Callbacks.StartDriver(Context);
    if (NT_SUCCESS(ntStatus)) {
        if (Context->Provider->Callbacks.RegisterDriver) // optional routine
            if (!Context->Provider->Callbacks.RegisterDriver(Context->DeviceHandle,
                (PVOID)Context))
            {
                ntStatus = STATUS_INTERNAL_ERROR;
            }
    }

    return ntStatus;
}

/*
* WDrvProvRelease
*
* Purpose:
*
* Release driver provider instance.
*
*/
VOID WDrvProvRelease(
    _In_ PWDRV_CONTEXT Context
)
{
    PWDRV_PROVIDER provider;
    HANDLE deviceHandle;

    if (Context) {
        provider = Context->Provider;
        if (provider) {
            deviceHandle = Context->DeviceHandle;
            if (deviceHandle) {
                if (provider->Callbacks.UnregisterDriver)
                    provider->Callbacks.UnregisterDriver(deviceHandle,
                        (PVOID)Context);

                NtClose(deviceHandle);
            }

            if (provider->NoUnloadSupported == 0 && provider->Callbacks.StopDriver != NULL) {
                provider->Callbacks.StopDriver(Context);
            }
        }
        RtlSecureZeroMemory(Context, sizeof(WDRV_CONTEXT));
    }
}

```

`Source/WinObjEx64/drivers/wdrvprv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       WDRVPRV.H
*
*  VERSION:     2.09
*
*  DATE:        20 Aug 2025
*
*  Common header file for WinObjEx64 driver providers.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef enum _WDRVPRVTYPE {
    // Microsoft WinDbg driver
    wdrvMicrosoft = 0,
    // WinObjEx64 driver
    wdrvWinObjEx64 = 1,
    // WinIO based driver
    wdrvWinIo = 2,
    // Rkhdrv series driver deprecated
    // Alice driver
    wdrvAlice = 4,
    // Ronova kernel driver
    wdrvRonova = 5,
    wdrvMax
} WDRVPRVTYPE;

//
// Providers abstraction interface.
//

typedef struct _WDRV_CONTEXT* PWDRV_CONTEXT;

//
// Prototype for read physical memory function.
//
typedef NTSTATUS(WINAPI* provReadPhysicalMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

//
// Prototype for query PML4 value function.
//
typedef NTSTATUS(WINAPI* provQueryPML4)(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

//
// Prototype for read kernel virtual memory function.
//
typedef BOOL(WINAPI* provReadSystemMemory)(
    _In_ struct _WDRV_CONTEXT* Context,
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

//
// Prototype for driver registering/unlocking function.
//
typedef BOOL(WINAPI* provRegisterDriver)(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

//
// Prototype for driver unregistering function.
//
typedef BOOL(WINAPI* provUnregisterDriver)(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

//
// Prototype for driver specific pre-open actions.
//
typedef BOOL(WINAPI* provPreOpenDriver)(
    _In_opt_ PVOID Param
    );

//
// Prototype for driver specific post-open actions.
//
typedef BOOL(WINAPI* provPostOpenDriver)(
    _In_opt_ PVOID Param
    );

//
// Start/Stop/Open prototypes.
//
typedef NTSTATUS(WINAPI* provStartDriver)(
    _In_ struct _WDRV_CONTEXT* Context
    );
typedef void(WINAPI* provStopDriver)(
    _In_ struct _WDRV_CONTEXT* Context
    );
typedef NTSTATUS(WINAPI* provOpenDriver)(
    _In_ struct _WDRV_CONTEXT* Context
    );

//
// No optional provider flags specified, this is default value.
//
#define WDRVPROV_FLAGS_NONE                   0x00000000

//
// Provider requires UEFI firmware type.
//
#define WDRVPROV_FLAGS_UEFI_REQUIRED          0x00000001

//
// Set System/Admin-only security descriptor to the provider driver device.
//
#define WDRVPROV_FLAGS_FORCE_SD               0x00000002

//
// Do not unload, driver does not support this.
//
#define WDRVPROV_FLAGS_NO_UNLOAD_SUP          0x00000004


typedef struct _WDRV_PROVIDER {
    LPWSTR DriverName; // file name only
    LPWSTR DeviceName; // device name only

    union {
        ULONG Flags;
        struct {
            ULONG UefiRequired : 1;
            ULONG ForceSD : 1;
            ULONG NoUnloadSupported : 1;
            ULONG Reserved : 29;
        };
    };

    struct {
        provStartDriver StartDriver;
        provStopDriver StopDriver;
        provOpenDriver OpenDriver;

        provRegisterDriver RegisterDriver; //optional
        provUnregisterDriver UnregisterDriver; //optional

        provPreOpenDriver PreOpenDriver; //optional;
        provPostOpenDriver PostOpenDriver; //optional;

        provReadSystemMemory ReadSystemMemory;
    } Callbacks;

} WDRV_PROVIDER, * PWDRV_PROVIDER;

typedef struct _WDRV_CONTEXT {

    BOOL IsOurLoad;

    NTSTATUS LoadStatus;
    NTSTATUS OpenStatus;

    HANDLE DeviceHandle;
    PWDRV_PROVIDER Provider;

    //full file name to the driver
    WCHAR DriverFileName[MAX_PATH * 2];

    NTSTATUS LastNtStatus;
    IO_STATUS_BLOCK IoStatusBlock;

} WDRV_CONTEXT, * PWDRV_CONTEXT;

WDRVPRVTYPE WDrvGetActiveProviderType(
    VOID);

BOOL WINAPI WDrvProvPostOpen(
    _In_ PVOID Param);

NTSTATUS WDrvStartDriver(
    _In_ PWDRV_CONTEXT Context);

VOID WDrvStopDriver(
    _In_ PWDRV_CONTEXT Context);

NTSTATUS WDrvOpenDriver(
    _In_ PWDRV_CONTEXT Context);

NTSTATUS WDrvProvCreate(
    _In_ FIRMWARE_TYPE FirmwareType,
    _Out_ PWDRV_CONTEXT Context);

VOID WDrvProvRelease(
    _In_ PWDRV_CONTEXT Context);

NTSTATUS PwVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ provQueryPML4 QueryPML4Routine,
    _In_ provReadPhysicalMemory ReadPhysicalMemoryRoutine,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

```

`Source/WinObjEx64/drivers/winio.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       WINIO.C
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
* 
*  WinIo based reader.
*
*  Note:
*
*    WinObjEx64 apply multiple security mitigations when uses this driver.
*    WinIo is known to be vulnerable by design.
*
*  MINIMUM SUPPORTED OS WINDOWS 7
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "ntos/halamd64.h"
#include "winio.h"

typedef NTSTATUS(WINAPI* pfnMapMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject,
    _Out_ PVOID* MappedMemory);

typedef NTSTATUS(WINAPI* pfnUnmapMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject);

NTSTATUS WinIoUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject);

NTSTATUS WinIoMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject,
    _Out_ PVOID* MappedMemory);

#define MapMemoryRoutine WinIoMapMemory
#define UnmapMemoryRoutine WinIoUnmapMemory

/*
* WinIoMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
NTSTATUS WinIoMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject,
    _Out_ PVOID* MappedMemory)
{
    NTSTATUS ntStatus;
    WINIO_PHYSICAL_MEMORY_INFO request;

    *SectionHandle = NULL;
    *ReferencedObject = NULL;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.ViewSize = NumberOfBytes;
    request.BusAddress = PhysicalAddress;

    ntStatus = supCallDriver(DeviceHandle,
        WINIO_IOCTL_MAP,
        &request,
        sizeof(request),
        &request,
        sizeof(request));

    if (NT_SUCCESS(ntStatus)) {
        *SectionHandle = request.SectionHandle;
        *ReferencedObject = request.ReferencedObject;
        *MappedMemory = request.BaseAddress;
    }

    return ntStatus;
}

/*
* WinIoUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
NTSTATUS WinIoUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject
)
{
    WINIO_PHYSICAL_MEMORY_INFO request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.ReferencedObject = ReferencedObject;
    request.SectionHandle = SectionHandle;

    return supCallDriver(DeviceHandle,
        WINIO_IOCTL_UNMAP,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* WinIoGetPML4FromLowStub1M
*
* Purpose:
*
* Search for PML4 (CR3) entry in low stub.
*
*/
ULONG_PTR WinIoGetPML4FromLowStub1M(
    _In_ ULONG_PTR pbLowStub1M)
{
    ULONG offset = 0;
    ULONG_PTR PML4 = 0;
    ULONG cr3_offset = FIELD_OFFSET(PROCESSOR_START_BLOCK, ProcessorState) +
        FIELD_OFFSET(KSPECIAL_REGISTERS, Cr3);

    SetLastError(ERROR_EXCEPTION_IN_SERVICE);

    __try {

        while (offset < 0x100000) {

            offset += 0x1000;

            if (0x00000001000600E9 != (0xffffffffffff00ff & *(UINT64*)(pbLowStub1M + offset))) //PROCESSOR_START_BLOCK->Jmp
                continue;

            if (0xfffff80000000000 != (0xfffff80000000003 & *(UINT64*)(pbLowStub1M + offset + FIELD_OFFSET(PROCESSOR_START_BLOCK, LmTarget))))
                continue;

            if (0xffffff0000000fff & *(UINT64*)(pbLowStub1M + offset + cr3_offset))
                continue;

            PML4 = *(UINT64*)(pbLowStub1M + offset + cr3_offset);
            break;
        }

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return 0;
    }

    SetLastError(ERROR_SUCCESS);

    return PML4;
}

/*
* WinIoQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
NTSTATUS WINAPI WinIoQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    ULONG_PTR PML4 = 0;

    PVOID pbLowStub1M = NULL;
    PVOID refObject = NULL;
    HANDLE sectionHandle = NULL;

    *Value = 0;

    do {

        ntStatus = MapMemoryRoutine(DeviceHandle,
            0ULL,
            0x100000,
            &sectionHandle,
            &refObject,
            &pbLowStub1M);

        if (!NT_SUCCESS(ntStatus))
            break;

        if (pbLowStub1M == NULL) {
            ntStatus = STATUS_INTERNAL_ERROR;
            break;
        }

        PML4 = WinIoGetPML4FromLowStub1M((ULONG_PTR)pbLowStub1M);
        if (PML4)
            *Value = PML4;

        UnmapMemoryRoutine(DeviceHandle,
            (PVOID)pbLowStub1M,
            sectionHandle,
            refObject);

        ntStatus = (PML4 != 0) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    } while (FALSE);

    return ntStatus;
}

/*
* WinIoReadPhysicalMemory
*
* Purpose:
*
* Read physical memory through mapping.
*
*/
NTSTATUS WINAPI WinIoReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    NTSTATUS ntStatus;
    PVOID mappedSection = NULL;

    PVOID refObject = NULL;
    HANDLE sectionHandle = NULL;

    //
    // Map physical memory section.
    //
    ntStatus = MapMemoryRoutine(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes,
        &sectionHandle,
        &refObject,
        &mappedSection);

    if (NT_SUCCESS(ntStatus)) {

        __try {

            RtlCopyMemory(Buffer, mappedSection, NumberOfBytes);

        }
        __except (WOBJ_EXCEPTION_FILTER_LOG)
        {
            ntStatus = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        UnmapMemoryRoutine(DeviceHandle,
            mappedSection,
            sectionHandle,
            refObject);

    }

    return ntStatus;
}

/*
* WinIoVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
NTSTATUS WINAPI WinIoVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    if (PhysicalAddress)
        *PhysicalAddress = 0;
    else {
        return STATUS_INVALID_PARAMETER_3;
    }

    return PwVirtualToPhysical(DeviceHandle,
        WinIoQueryPML4Value,
        WinIoReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* WinIoReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
NTSTATUS WINAPI WinIoReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    NTSTATUS ntStatus;
    ULONG_PTR physicalAddress = 0;

    ntStatus = WinIoVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = WinIoReadPhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes);

    }

    return ntStatus;
}

/*
* WinIoReadSystemMemory
*
* Purpose:
*
* Read kernel virtual memory.
*
*/
BOOL WinIoReadSystemMemory(
    _In_ WDRV_CONTEXT* Context,
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead
)
{
    BOOL bResult = FALSE;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PVOID lockedBuffer = NULL;

    if (NumberOfBytesRead)
        *NumberOfBytesRead = 0;

    if (Address >= g_kdctx.SystemRangeStart) {

        lockedBuffer = supVirtualAlloc(BufferSize);
        if (lockedBuffer) {

            if (VirtualLock(lockedBuffer, BufferSize)) {

                ntStatus = WinIoReadKernelVirtualMemory(Context->DeviceHandle,
                    Address,
                    lockedBuffer,
                    BufferSize);

                if (NT_SUCCESS(ntStatus)) {

                    if (NumberOfBytesRead)
                        *NumberOfBytesRead = BufferSize;

                    RtlCopyMemory(Buffer, lockedBuffer, BufferSize);

                    bResult = TRUE;
                }

                VirtualUnlock(lockedBuffer, BufferSize);
            }
            else {
                ntStatus = STATUS_NOT_LOCKED;
            }

            supVirtualFree(lockedBuffer);
        }
        else {
            ntStatus = STATUS_MEMORY_NOT_ALLOCATED;
        }
    }
    else {
        ntStatus = STATUS_INVALID_PARAMETER_2;
    }

    Context->LastNtStatus = ntStatus;
    Context->IoStatusBlock.Information = 0;
    Context->IoStatusBlock.Status = ntStatus;

    return bResult;
}

```

`Source/WinObjEx64/drivers/winio.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       WINIO.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Common header file for the WINIO Driver Helper support.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define FILE_DEVICE_ASUSIO      (DWORD)0x0000A040

#define ASUSIO_MAP_FUNCID      (DWORD)0x920
#define ASUSIO_UNMAP_FUNCID    (DWORD)0x914

#define IOCTL_ASUSIO_MAP_USER_PHYSICAL_MEMORY    \
    CTL_CODE(FILE_DEVICE_ASUSIO, ASUSIO_MAP_FUNCID, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_ASUSIO_UNMAP_USER_PHYSICAL_MEMORY  \
    CTL_CODE(FILE_DEVICE_ASUSIO, ASUSIO_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define WINIO_IOCTL_MAP   IOCTL_ASUSIO_MAP_USER_PHYSICAL_MEMORY
#define WINIO_IOCTL_UNMAP IOCTL_ASUSIO_UNMAP_USER_PHYSICAL_MEMORY
#define WINIO_DRV_NAME L"Asusgio2"
#define WINIO_DEV_NAME L"Asusgio2"


typedef struct _WINIO_PHYSICAL_MEMORY_INFO {
    ULONG_PTR ViewSize;
    ULONG_PTR BusAddress; //physical address
    HANDLE SectionHandle;
    PVOID BaseAddress;
    PVOID ReferencedObject;
} WINIO_PHYSICAL_MEMORY_INFO, * PWINIO_PHYSICAL_MEMORYINFO;

typedef struct _WINIO_PHYSICAL_MEMORY_INFO_EX {
    ULONG_PTR CommitSize;
    ULONG_PTR BusAddress;
    HANDLE SectionHandle;
    PVOID BaseAddress;
    PVOID ReferencedObject;
    UCHAR EncryptedKey[16];
} WINIO_PHYSICAL_MEMORY_INFO_EX, * PWINIO_PHYSICAL_MEMORY_INFO_EX;

BOOL WinIoReadSystemMemory(
    _In_ WDRV_CONTEXT* Context,
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

```

`Source/WinObjEx64/excepth.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       EXCEPTH.C
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
*  Exception handler routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include <DbgHelp.h>

typedef BOOL(WINAPI* pfnMiniDumpWriteDump)(
    _In_ HANDLE hProcess,
    _In_ DWORD ProcessId,
    _In_ HANDLE hFile,
    _In_ MINIDUMP_TYPE DumpType,
    _In_opt_ PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    _In_opt_ PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    _In_opt_ PMINIDUMP_CALLBACK_INFORMATION CallbackParam);

pfnMiniDumpWriteDump pMiniDumpWriteDump;

/*
* exceptWriteDump
*
* Purpose:
*
* Writes minidump information to the file.
*
*/
BOOL exceptWriteDump(
    _In_ EXCEPTION_POINTERS* ExceptionPointers,
    _In_ LPCWSTR lpFileName
)
{
    BOOL bResult;
    HMODULE hDbgHelp;
    HANDLE hFile;
    WCHAR szFileName[MAX_PATH * 2];
    UINT cch;

    MINIDUMP_EXCEPTION_INFORMATION mdei;

    bResult = FALSE;
    hDbgHelp = GetModuleHandle(TEXT("dbghelp.dll"));
    if (hDbgHelp == NULL) {

        RtlSecureZeroMemory(szFileName, sizeof(szFileName));
        cch = GetSystemDirectory(szFileName, MAX_PATH);
        if (cch == 0 || cch > MAX_PATH)
            return FALSE;

        _strcat(szFileName, TEXT("\\dbghelp.dll"));

        hDbgHelp = LoadLibraryEx(szFileName, 0, 0);
        if (hDbgHelp == NULL)
            return FALSE;
    }

    pMiniDumpWriteDump = (pfnMiniDumpWriteDump)GetProcAddress(hDbgHelp, "MiniDumpWriteDump");
    if (pMiniDumpWriteDump == NULL)
        return FALSE;

    hFile = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        mdei.ThreadId = GetCurrentThreadId();
        mdei.ExceptionPointers = ExceptionPointers;
        mdei.ClientPointers = FALSE;
        bResult = pMiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &mdei, NULL, NULL);
        CloseHandle(hFile);
    }
    return bResult;
}

/*
* exceptShowException
*
* Purpose:
*
* Output exception information to the user.
*
*/
VOID exceptShowException(
    _In_ EXCEPTION_POINTERS* ExceptionPointers,
    _In_ BOOL LastChance
)
{
    WCHAR szFileName[MAX_PATH * 2];
    WCHAR szMessage[2048];
    LPWSTR lpDescription;

    RtlSecureZeroMemory(&szMessage, sizeof(szMessage));
    RtlSecureZeroMemory(&szFileName, sizeof(szFileName));

    RtlStringCchPrintfSecure(szMessage,
        RTL_NUMBER_OF(szMessage),
        TEXT("Sorry, exception occured at address: \r\n0x%llX"),
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress);

    if (ExceptionPointers->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
        switch (ExceptionPointers->ExceptionRecord->ExceptionInformation[0]) {
        case 0:
            lpDescription = TEXT("read");
            break;
        case 1:
            lpDescription = TEXT("write");
            break;
        case 8:
            lpDescription = TEXT("execute");
            break;
        default:
            lpDescription = TEXT("access");
            break;
        }

        RtlStringCchPrintfSecure(_strend(szMessage),
            RTL_NUMBER_OF(szMessage) - _strlen(szMessage),
            TEXT("\r\n\nAttempt to %ws at address: \r\n0x%llX"),
            lpDescription,
            ExceptionPointers->ExceptionRecord->ExceptionInformation[1]);
    }

    GetCurrentDirectory(MAX_PATH, szFileName);
    _strcat(szFileName, TEXT("\\WinObjEx64."));
    ultostr(GetCurrentProcessId(), _strend(szFileName));
    _strcat(szFileName, TEXT("."));
    ultostr(GetCurrentThreadId(), _strend(szFileName));
    _strcat(szFileName, TEXT(".dmp"));

    if (exceptWriteDump(ExceptionPointers, szFileName)) {

        RtlStringCchPrintfSecure(_strend(szMessage),
            RTL_NUMBER_OF(szMessage) - _strlen(szMessage),
            TEXT("\r\n\nMinidump saved to %ws"),
            szFileName);
    }
    else {
        _strcat(szMessage, TEXT("\r\nAnd there is an error while saving minidump :("));
    }
    if (LastChance)
        _strcat(szMessage, TEXT("\r\n\nThe program will be terminated."));

    MessageBox(0, szMessage, NULL, MB_ICONERROR);
}

/*
* exceptFilterUnhandled
*
* Purpose:
*
* Default exception filter, processing AV with minidump if available.
*
*/
INT exceptFilterUnhandled(
    _In_ struct _EXCEPTION_POINTERS* ExceptionInfo
)
{
    WDrvProvRelease(&g_kdctx.DriverContext);
    exceptShowException(ExceptionInfo, TRUE);
    RtlExitUserProcess(ExceptionInfo->ExceptionRecord->ExceptionCode);
    return EXCEPTION_EXECUTE_HANDLER;
}

/*
* exceptFilter
*
* Purpose:
*
* Default exception filter, processing AV with minidump if available.
*
*/
INT exceptFilter(
    _In_ UINT ExceptionCode,
    _In_ EXCEPTION_POINTERS* ExceptionPointers
)
{
    if (ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
        exceptShowException(ExceptionPointers, FALSE);
        return EXCEPTION_EXECUTE_HANDLER;
    }
    else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

/*
* exceptFilterWithLog
*
* Purpose:
*
* Exception filter with log.
*
*/
INT exceptFilterWithLog(
    _In_ UINT ExceptionCode,
    _In_opt_ EXCEPTION_POINTERS* ExceptionPointers
)
{
    supReportException(ExceptionCode, ExceptionPointers);
    return EXCEPTION_EXECUTE_HANDLER;
}

```

`Source/WinObjEx64/excepth.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       EXCEPTH.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Common header file for the exception handling routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

INT exceptFilter(
    _In_ UINT ExceptionCode,
    _In_ EXCEPTION_POINTERS *ExceptionPointers);

INT exceptFilterWithLog(
    _In_ UINT ExceptionCode,
    _In_opt_ EXCEPTION_POINTERS* ExceptionPointers);

INT exceptFilterUnhandled(
    _In_ struct _EXCEPTION_POINTERS* ExceptionInfo);

#define WOBJ_EXCEPTION_FILTER exceptFilter(GetExceptionCode(), GetExceptionInformation())
#define WOBJ_EXCEPTION_FILTER_LOG exceptFilterWithLog(GetExceptionCode(), GetExceptionInformation())

```

`Source/WinObjEx64/extapi.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2025
*
*  TITLE:       EXTAPI.C
*
*  VERSION:     2.09
*
*  DATE:        19 Aug 2025
*
*  Support unit for pre Windows 10 missing APIs.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

EXTENDED_API_SET g_ExtApiSet;

#define RESOLVE_API(set, mod, field, type, name) \
    set->field = (type)GetProcAddress(mod, name); \
    if (set->field) set->NumberOfAPI += 1;

/*
* ExApiSetInit
*
* Purpose:
*
* Initializes newest Windows version specific function pointers.
*
* Called once during supInit
*
*/
NTSTATUS ExApiSetInit(
    VOID
)
{
    NTSTATUS Status;
    HMODULE hNtdll, hUser32;
    PEXTENDED_API_SET set = &g_ExtApiSet;

    RtlSecureZeroMemory(&g_ExtApiSet, sizeof(g_ExtApiSet));

    hNtdll = GetModuleHandle(TEXT("ntdll.dll"));
    if (hNtdll) {
        // Available since Windows 10 TH1.
        RESOLVE_API(set, hNtdll, NtOpenPartition, pfnNtOpenPartition, "NtOpenPartition");
        // Available since Windows 10 REDSTONE 1.
        RESOLVE_API(set, hNtdll, NtOpenRegistryTransaction, pfnNtOpenRegistryTransaction, "NtOpenRegistryTransaction");
    }

    //
    // User32 API introduced with Windows 8.
    //
    hUser32 = GetModuleHandle(TEXT("user32.dll"));
    if (hUser32) {
        RESOLVE_API(set, hUser32, IsImmersiveProcess, pfnIsImmersiveProcess, "IsImmersiveProcess");
        RESOLVE_API(set, hUser32, GetAwarenessFromDpiAwarenessContext, pfnGetAwarenessFromDpiAwarenessContext, "GetAwarenessFromDpiAwarenessContext");
        RESOLVE_API(set, hUser32, GetDpiForSystem, pfnGetDpiForSystem, "GetDpiForSystem");
        RESOLVE_API(set, hUser32, GetDpiForWindow, pfnGetDpiForWindow, "GetDpiForWindow");
        RESOLVE_API(set, hUser32, GetThreadDpiAwarenessContext, pfnGetThreadDpiAwarenessContext, "GetThreadDpiAwarenessContext");
    }

    Status = (g_ExtApiSet.NumberOfAPI == EXTAPI_ALL_MAPPED) ?
        STATUS_SUCCESS : STATUS_NOT_ALL_ASSIGNED;

    return Status;
}

```

`Source/WinObjEx64/extapi.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       EXTAPI.H
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
*  Header for pre Windows 10+ missing API.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef NTSTATUS (NTAPI *pfnNtOpenPartition)(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

typedef NTSTATUS (NTAPI *pfnNtManagePartition)(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _In_ PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength
    );

typedef NTSTATUS (NTAPI *pfnNtOpenRegistryTransaction)(
    _Out_ PHANDLE RegistryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

typedef BOOL (WINAPI *pfnIsImmersiveProcess)(
    HANDLE hProcess
    );

typedef DPI_AWARENESS_CONTEXT (WINAPI *pfnGetThreadDpiAwarenessContext)(
    VOID);

typedef DPI_AWARENESS (WINAPI *pfnGetAwarenessFromDpiAwarenessContext)(
    _In_ DPI_AWARENESS_CONTEXT value);

typedef UINT (WINAPI *pfnGetDpiForWindow)(
    _In_ HWND hwnd);

typedef UINT (WINAPI *pfnGetDpiForSystem)(
    VOID);

//
// Only actual number of functions included in the EXTENDED_API_SET structure.
//
#define EXTAPI_ALL_MAPPED 7

typedef struct _EXTENDED_API_SET {
    ULONG NumberOfAPI;
    pfnNtOpenPartition NtOpenPartition;
    pfnNtOpenRegistryTransaction NtOpenRegistryTransaction;
    pfnIsImmersiveProcess IsImmersiveProcess;
    pfnGetThreadDpiAwarenessContext GetThreadDpiAwarenessContext;
    pfnGetAwarenessFromDpiAwarenessContext GetAwarenessFromDpiAwarenessContext;
    pfnGetDpiForWindow GetDpiForWindow;
    pfnGetDpiForSystem GetDpiForSystem;
} EXTENDED_API_SET, *PEXTENDED_API_SET;

NTSTATUS ExApiSetInit(
    VOID
    );

extern EXTENDED_API_SET g_ExtApiSet;


```

`Source/WinObjEx64/extras/extras.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       EXTRAS.C
*
*  VERSION:     2.10
*
*  DATE:        10 Sep 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"

/*
* extrasHandleSettingsChange
*
* Purpose:
*
* Handle global settings change.
*
*/
VOID extrasHandleSettingsChange(
    EXTRASCONTEXT* Context
)
{
    DWORD lvExStyle;

    lvExStyle = ListView_GetExtendedListViewStyle(Context->ListView);
    if (g_WinObj.ListViewDisplayGrid)
        lvExStyle |= LVS_EX_GRIDLINES;
    else
        lvExStyle &= ~LVS_EX_GRIDLINES;

    ListView_SetExtendedListViewStyle(Context->ListView, lvExStyle);
}

/*
* extrasSimpleListResize
*
* Purpose:
*
* Common resize handler for list only dialogs.
*
*/
VOID extrasSimpleListResize(
    _In_ HWND hwndDlg
)
{
    RECT r, szr;
    HWND hwnd, hwndStatusBar;

    hwnd = GetDlgItem(hwndDlg, ID_EXTRASLIST);
    hwndStatusBar = GetDlgItem(hwndDlg, ID_EXTRASLIST_STATUSBAR);

    if (hwnd == NULL || hwndStatusBar == NULL)
        return;

    GetClientRect(hwndDlg, &r);
    GetClientRect(hwndStatusBar, &szr);

    SendMessage(hwndStatusBar, WM_SIZE, 0, 0);

    SetWindowPos(hwnd, 0, 0, 0,
        r.right,
        r.bottom - szr.bottom,
        SWP_NOZORDER);
}

/*
* extrasSetDlgIcon
*
* Purpose:
*
* Set dialog icon.
*
*/
VOID extrasSetDlgIcon(
    _In_ EXTRASCONTEXT* Context
)
{
    HANDLE hIcon;

    hIcon = LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_MAIN), IMAGE_ICON, 
        32, 32, 
        0);

    if (hIcon) {
        SendMessage(Context->hwndDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);
        SendMessage(Context->hwndDlg, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)hIcon);
        Context->DialogIcon = (HICON)hIcon;
    }
}

/*
* extrasRemoveDlgIcon
*
* Purpose:
*
* Remove dialog icon.
*
*/
VOID extrasRemoveDlgIcon(
    _In_ EXTRASCONTEXT* Context
)
{
    if (Context->DialogIcon) {
        DestroyIcon(Context->DialogIcon);
        Context->DialogIcon = NULL;
    }
}

/*
* extrasProcessElevationRequiredDialogs
*
* Purpose:
*
* Run elevation required dialog.
* If client is not elevated - request elevation.
*
*/
VOID extrasProcessElevationRequiredDialogs(
    _In_ WORD DialogId
)
{
    WCHAR szText[200];

    if (g_WinObj.IsWine)
        return;

    if (g_kdctx.IsFullAdmin == FALSE) {
        supRunAsAdmin();
        return;
    }

    if (!kdConnectDriver()) {      

        RtlStringCchPrintfSecure(szText,
            RTL_NUMBER_OF(szText),
            TEXT("Could not connect to driver, feature is unavailable.\nDriver load status: 0x%lX\nDriver open status: 0x%lX"),
            g_kdctx.DriverContext.LoadStatus,
            g_kdctx.DriverContext.OpenStatus);

        MessageBox(g_hwndMain,
            szText, 
            PROGRAM_NAME, 
            MB_ICONINFORMATION);

        return;
    }

    switch (DialogId) {
    case ID_EXTRAS_DRIVERS:
        //
        // Since 24H2 as it restricts NTQSI output.
        //
        extrasCreateDriversDialog(DrvModeNormal);
        break;
    case ID_EXTRAS_W32PSERVICETABLE:
        //
        // Since 24H2 as it requires driver usage to access kmod apiset table.
        //
        extrasCreateSSDTDialog(SST_Win32k);
        break;
    case ID_EXTRAS_PRIVATENAMESPACES:
        extrasCreatePNDialog();
        break;
    case ID_EXTRAS_CALLBACKS:
        extrasCreateCallbacksDialog();
        break;
    case ID_EXTRAS_UNLOADEDDRIVERS:
        extrasCreateDriversDialog(DrvModeUnloaded);
        break;
    case ID_EXTRAS_SSDT:
        extrasCreateSSDTDialog(SST_Ntos);
        break;
    }
}

/*
* extrasShowDialogById
*
* Purpose:
*
* Display dialog by it identifier.
*
*/
VOID extrasShowDialogById(
    _In_ WORD DialogId
)
{
    BOOL fullAdminAccessRequired = ((g_NtBuildNumber > NT_WIN11_22H2) &&
        (g_kdctx.IsFullAdmin == FALSE) &&
        (g_WinObj.IsWine == FALSE));

    switch (DialogId) {

    case ID_EXTRAS_PIPES:
    case ID_EXTRAS_MAILSLOTS:
        if (DialogId == ID_EXTRAS_MAILSLOTS)
            extrasCreateIpcDialog(IpcModeMailSlots);
        else
            extrasCreateIpcDialog(IpcModeNamedPipes);
        break;

    case ID_EXTRAS_USERSHAREDDATA:
        extrasCreateUsdDialog();
        break;

    case ID_EXTRAS_SSDT:
    case ID_EXTRAS_UNLOADEDDRIVERS:
    case ID_EXTRAS_PRIVATENAMESPACES:
    case ID_EXTRAS_CALLBACKS:
        extrasProcessElevationRequiredDialogs(DialogId);
        break;

    case ID_EXTRAS_W32PSERVICETABLE:
        if (fullAdminAccessRequired) {
            extrasProcessElevationRequiredDialogs(DialogId);
        }
        else {
            extrasCreateSSDTDialog(SST_Win32k);
        }
        break;

    case ID_EXTRAS_DRIVERS:    
        if (fullAdminAccessRequired) {
            extrasProcessElevationRequiredDialogs(DialogId);
        }
        else {
            extrasCreateDriversDialog(DrvModeNormal);
        }
        break;

    case ID_EXTRAS_PROCESSLIST:
        extrasCreatePsListDialog();
        break;

    case ID_EXTRAS_SOFTWARELICENSECACHE:
        extrasCreateSLCacheDialog();
        break;

    case ID_EXTRAS_CMCONTROLVECTOR:
        extrasCreateCmOptDialog();
        break;

    }
}

```

`Source/WinObjEx64/extras/extras.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       EXTRAS.H
*
*  VERSION:     2.10
*
*  DATE:        12 Jan 2026
*
*  Common header file for Extras dialogs.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef struct _EXTRASCONTEXT {
    HWND hwndDlg;
    HWND ListView;
    HWND TreeList;
    HWND StatusBar;
    PVOID TooltipInfo;
    WCHAR* TooltipBuffer;
    HIMAGELIST ImageList;
    INT lvColumnToSort;
    INT lvColumnCount;
    INT lvColumnHit;
    INT lvItemHit;
    INT tlSubItemHit;
    BOOL bInverseSort;
    union {
        ULONG_PTR Reserved;
        ULONG_PTR DialogMode;
    };
    HICON ObjectIcon;
    HICON DialogIcon;
} EXTRASCONTEXT, *PEXTRASCONTEXT;

typedef struct _EXTRASCALLBACK {
    ULONG_PTR lParam;
    ULONG_PTR Value;
} EXTRASCALLBACK, *PEXTRASCALLBACK;

typedef enum _IPC_DLG_MODE {
    IpcModeNamedPipes = 0,
    IpcModeMailSlots = 1,
    IpcMaxMode = 2
} IPC_DLG_MODE;

typedef enum _DRIVERS_DLG_MODE {
    DrvModeNormal = 0,
    DrvModeUnloaded = 1,
    DrvModeMax = 2
} DRIVERS_DLG_MODE;

typedef enum _SSDT_DLG_MODE {
    SST_Ntos = 0,
    SST_Win32k = 1,
    SST_Max = 2
} SSDT_DLG_MODE;

typedef INT(CALLBACK *DlgCompareFunction)(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
    );

typedef BOOL(CALLBACK *CustomNotifyFunction)(
    _In_ LPNMLISTVIEW nhdr,
    _In_ EXTRASCONTEXT *Context,
    _In_opt_ PVOID Parameter
    );

VOID extrasSimpleListResize(
    _In_ HWND hwndDlg);

VOID extrasSetDlgIcon(
    _In_ EXTRASCONTEXT* Context);

VOID extrasRemoveDlgIcon(
    _In_ EXTRASCONTEXT* Context);

VOID extrasShowDialogById(
    _In_ WORD DialogId);

VOID extrasHandleSettingsChange(
    EXTRASCONTEXT* Context);

//
// Dialog handlers.
//

VOID extrasCreateCallbacksDialog(
    VOID);

VOID extrasCreateCmOptDialog(
    VOID);

VOID extrasCreateDriversDialog(
    _In_ DRIVERS_DLG_MODE Mode);

VOID extrasCreateIpcDialog(
    _In_ IPC_DLG_MODE Mode);

VOID extrasCreatePNDialog(
    VOID);

VOID extrasCreatePsListDialog(
    VOID);

VOID extrasCreateSLCacheDialog(
    VOID);

VOID extrasCreateSSDTDialog(
    _In_ SSDT_DLG_MODE Mode);

VOID extrasCreateUsdDialog(
    VOID);

```

`Source/WinObjEx64/extras/extrasCallbacks.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2025
*
*  TITLE:       EXTRASCALLBACKS.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"
#include "extras/extrasCallbacksPatterns.h"
#include "treelist/treelist.h"
#include "hde/hde64.h"
#include "ksymbols.h"

static HANDLE SysCbThreadHandle = NULL;
static FAST_EVENT SysCbInitializedEvent = FAST_EVENT_INIT;

//
// Scan limit constants.
//
#define SCAN_LIMIT_NEAR    64
#define SCAN_LIMIT_SMALL   128
#define SCAN_LIMIT_MEDIUM  256
#define SCAN_LIMIT_LARGE   512
#define SCAN_LIMIT_XLARGE  640
#define SCAN_LIMIT_XXLARGE 1024

#define CBDLG_TRACKSIZE_MIN_X 640
#define CBDLG_TRACKSIZE_MIN_Y 480

//
// Known CiCallbacks structure sizes (including marker tag), update this from time to time.
//
#define CBT_SIZE_REDSTONE5    0xD0
#define CBT_SIZE_19HX         0xD0
#define CBT_SIZE_VB_V1        0xD0
#define CBT_SIZE_VB_V2        0xE8
#define CBT_SIZE_FE_V1        0xF8
#define CBT_SIZE_CO_V1        0x100
#define CBT_SIZE_NI_V1        0xF8
#define CBT_SIZE_GE_V1        0x100 //same as CU/GA

typedef struct _CBT_MAPPING {
    ULONG Build;
    ULONG Tag;
    ULONG Size;
} CBT_MAPPING, * PCBT_MAPPING;

CBT_MAPPING g_CbtMapping[] = {
    { NT_WIN10_REDSTONE5, NTDDI_WIN10_RS5, CBT_SIZE_REDSTONE5 },
    { NT_WIN10_19H1, NTDDI_WIN10_19H1, CBT_SIZE_19HX },
    { NT_WIN10_19H2, NTDDI_WIN10_19H1, CBT_SIZE_19HX },

    { NT_WIN10_20H1, NTDDI_WIN10_VB, CBT_SIZE_VB_V1 },
    { NT_WIN10_20H1, NTDDI_WIN10_VB, CBT_SIZE_VB_V2 },

    { NT_WIN10_20H2, NTDDI_WIN10_VB, CBT_SIZE_VB_V1 },
    { NT_WIN10_20H2, NTDDI_WIN10_VB, CBT_SIZE_VB_V2 },

    { NT_WIN10_21H1, NTDDI_WIN10_VB, CBT_SIZE_VB_V1 },
    { NT_WIN10_21H1, NTDDI_WIN10_VB, CBT_SIZE_VB_V2 },

    { NT_WIN10_21H2, NTDDI_WIN10_VB, CBT_SIZE_VB_V1 },
    { NT_WIN10_21H2, NTDDI_WIN10_VB, CBT_SIZE_VB_V2 },
    { NT_WIN10_22H2, NTDDI_WIN10_VB, CBT_SIZE_VB_V2 },

    { NT_WINSRV_21H1, NTDDI_WIN10_FE, CBT_SIZE_FE_V1 },

    { NT_WIN11_21H2, NTDDI_WIN10_CO, CBT_SIZE_CO_V1 },
    { NT_WIN11_22H2, NTDDI_WIN10_NI, CBT_SIZE_NI_V1 },
    { NT_WIN11_23H2, NTDDI_WIN10_NI, CBT_SIZE_NI_V1 },
    { NT_WIN11_24H2, NTDDI_WIN11_GE, CBT_SIZE_GE_V1 },
    { NT_WIN11_25H2, NTDDI_WIN11_SE, CBT_SIZE_GE_V1 } //update on release
};

//
// CiCompareSigningLevels offset
//
#define CiCompareSigningLevels_Offset 0x40

ULONG g_CallbacksCount;

typedef struct _OBEX_CALLBACK_DISPATCH_ENTRY OBEX_CALLBACK_DISPATCH_ENTRY;

typedef ULONG_PTR(CALLBACK* POBEX_FINDCALLBACK_ROUTINE)(
    _In_ ULONG_PTR QueryFlags);

typedef VOID(CALLBACK* POBEX_DISPLAYCALLBACK_ROUTINE)(
    _In_ HWND TreeList,
    _In_ LPWSTR CallbackType,
    _In_ ULONG_PTR KernelVariableAddress,
    _In_ PRTL_PROCESS_MODULES Modules);

typedef NTSTATUS(CALLBACK* POBEX_QUERYCALLBACK_ROUTINE)(
    _In_ ULONG_PTR QueryFlags,
    _In_ POBEX_DISPLAYCALLBACK_ROUTINE DisplayRoutine,
    _In_opt_ POBEX_FINDCALLBACK_ROUTINE FindRoutine,
    _In_opt_ LPWSTR CallbackType,
    _In_ HWND TreeList,
    _In_ PRTL_PROCESS_MODULES Modules,
    _Inout_opt_ PULONG_PTR SystemCallbacksRef);

#define OBEX_FINDCALLBACK_ROUTINE(n) ULONG_PTR CALLBACK n(    \
    _In_ ULONG_PTR QueryFlags)

#define OBEX_QUERYCALLBACK_ROUTINE(n) NTSTATUS CALLBACK n(    \
    _In_ ULONG_PTR QueryFlags,                                \
    _In_ POBEX_DISPLAYCALLBACK_ROUTINE DisplayRoutine,        \
    _In_opt_ POBEX_FINDCALLBACK_ROUTINE FindRoutine,          \
    _In_opt_ LPWSTR CallbackType,                             \
    _In_ HWND TreeList,                                       \
    _In_ PRTL_PROCESS_MODULES Modules,                        \
    _Inout_opt_ PULONG_PTR SystemCallbacksRef)

#define OBEX_DISPLAYCALLBACK_ROUTINE(n) VOID CALLBACK n(     \
    _In_ HWND TreeList,                               \
    _In_ LPWSTR CallbackType,                         \
    _In_ ULONG_PTR KernelVariableAddress,             \
    _In_ PRTL_PROCESS_MODULES Modules)

//
// Generic upper bound to protect against corrupted kernel lists/arrays causing infinite loops.
//
#define MAX_LIST_ITERATIONS 0x10000

#define LIST_ITERATION_GUARD(it) \
    if ((it)++ >= MAX_LIST_ITERATIONS) { \
        logAdd(EntryTypeWarning, TEXT("List traversal limit reached")); \
        break; \
    }

//
// Returns TRUE if next Flink assigned, FALSE if not in kernel mode address range.
// Valid kernel pointers must be >= g_kdctx.SystemRangeStart.
//
#define SET_NEXT_FLINK_CHECK(ListEntryVar, NextFlinkExpr, MsgLiteral) \
    (((ULONG_PTR)(NextFlinkExpr) < g_kdctx.SystemRangeStart) ? \
        (logAdd(EntryTypeWarning, TEXT(MsgLiteral)), FALSE) : \
        ((ListEntryVar).Flink = (NextFlinkExpr), TRUE))

typedef struct _OBEX_CALLBACK_DISPATCH_ENTRY {
    ULONG_PTR QueryFlags;
    LPWSTR CallbackType;
    POBEX_QUERYCALLBACK_ROUTINE QueryRoutine;
    POBEX_DISPLAYCALLBACK_ROUTINE DisplayRoutine;
    POBEX_FINDCALLBACK_ROUTINE FindRoutine;
    PULONG_PTR SystemCallbacksRef;
} OBEX_CALLBACK_DISPATCH_ENTRY, * POBEX_CALLBACK_DISPATCH_ENTRY;

OBEX_QUERYCALLBACK_ROUTINE(QueryIopFsListsCallbacks);
OBEX_QUERYCALLBACK_ROUTINE(QueryCallbackGeneric);

OBEX_DISPLAYCALLBACK_ROUTINE(DumpPsCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpKeBugCheckCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpKeBugCheckReasonCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpCmCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpIoCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpObCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpSeFileSystemCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPoCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpDbgPrintCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpIoFsRegistrationCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpIoFileSystemCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpDbgkLCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPsAltSystemCallHandlers);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpCiCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpExHostCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpExpCallbackListCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPoCoalescingCallbacks);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPspPicoProviderRoutines);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpKiNmiCallbackListHead);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPspSiloMonitorList);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpEmpCallbackListHead);
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPnpDeviceClassNotifyList);

OBEX_FINDCALLBACK_ROUTINE(FindPspCreateProcessNotifyRoutine);
OBEX_FINDCALLBACK_ROUTINE(FindPspCreateThreadNotifyRoutine);
OBEX_FINDCALLBACK_ROUTINE(FindPspLoadImageNotifyRoutine);
OBEX_FINDCALLBACK_ROUTINE(FindKeBugCheckCallbackHead);
OBEX_FINDCALLBACK_ROUTINE(FindKeBugCheckReasonCallbackHead);
OBEX_FINDCALLBACK_ROUTINE(FindCmCallbackHead);
OBEX_FINDCALLBACK_ROUTINE(FindIopNotifyShutdownQueueHeadHead);
OBEX_FINDCALLBACK_ROUTINE(FindPopRegisteredPowerSettingCallbacks);
OBEX_FINDCALLBACK_ROUTINE(FindSeFileSystemNotifyRoutinesHead);
OBEX_FINDCALLBACK_ROUTINE(FindIopFsNotifyChangeQueueHead);
OBEX_FINDCALLBACK_ROUTINE(FindObjectTypeCallbackListHeadByType);
OBEX_FINDCALLBACK_ROUTINE(FindRtlpDebugPrintCallbackList);
OBEX_FINDCALLBACK_ROUTINE(FindDbgkLmdCallbacks);
OBEX_FINDCALLBACK_ROUTINE(FindPsAltSystemCallHandlers);
OBEX_FINDCALLBACK_ROUTINE(FindCiCallbacksEx);
OBEX_FINDCALLBACK_ROUTINE(FindCiCallbacks);
OBEX_FINDCALLBACK_ROUTINE(FindExHostCallbacks);
OBEX_FINDCALLBACK_ROUTINE(FindExpCallbackListHead);
OBEX_FINDCALLBACK_ROUTINE(FindPoCoalescingCallbacks);
OBEX_FINDCALLBACK_ROUTINE(FindPspPicoProviderRoutines);
OBEX_FINDCALLBACK_ROUTINE(FindKiNmiCallbackListHead);
OBEX_FINDCALLBACK_ROUTINE(FindPspSiloMonitorList);
OBEX_FINDCALLBACK_ROUTINE(FindEmpCallbackListHead);
OBEX_FINDCALLBACK_ROUTINE(FindPnpDeviceClassNotifyList);

OBEX_CALLBACK_DISPATCH_ENTRY g_CallbacksDispatchTable[] = {
    {
        0, L"CreateProcess",
        QueryCallbackGeneric, DumpPsCallbacks, FindPspCreateProcessNotifyRoutine,
        &g_SystemCallbacks.PspCreateProcessNotifyRoutine
    },
    {
        0, L"CreateThread",
        QueryCallbackGeneric, DumpPsCallbacks, FindPspCreateThreadNotifyRoutine,
        &g_SystemCallbacks.PspCreateThreadNotifyRoutine
    },
    {
        0, L"LoadImage",
        QueryCallbackGeneric, DumpPsCallbacks, FindPspLoadImageNotifyRoutine,
        &g_SystemCallbacks.PspLoadImageNotifyRoutine
    },
    {
        0, L"KeBugCheck",
        QueryCallbackGeneric, DumpKeBugCheckCallbacks, FindKeBugCheckCallbackHead,
        &g_SystemCallbacks.KeBugCheckCallbackHead
    },
    {
        0, L"KeBugCheckReason",
        QueryCallbackGeneric, DumpKeBugCheckReasonCallbacks, FindKeBugCheckReasonCallbackHead,
        &g_SystemCallbacks.KeBugCheckReasonCallbackHead
    },
    {
        0, L"CmRegistry",
        QueryCallbackGeneric, DumpCmCallbacks, FindCmCallbackHead,
        &g_SystemCallbacks.CmCallbackListHead
    },
    {
        0, L"Shutdown",
        QueryCallbackGeneric, DumpIoCallbacks, FindIopNotifyShutdownQueueHeadHead,
        &g_SystemCallbacks.IopNotifyShutdownQueueHead
    },
    {
        1, L"LastChanceShutdown",
        QueryCallbackGeneric, DumpIoCallbacks, FindIopNotifyShutdownQueueHeadHead,
        &g_SystemCallbacks.IopNotifyLastChanceShutdownQueueHead
    },
    {
        ObjectTypeProcess, L"ObProcess",
        QueryCallbackGeneric, DumpObCallbacks, FindObjectTypeCallbackListHeadByType,
        &g_SystemCallbacks.ObProcessCallbackHead },
    {
        ObjectTypeThread, L"ObThread",
        QueryCallbackGeneric, DumpObCallbacks, FindObjectTypeCallbackListHeadByType,
        &g_SystemCallbacks.ObThreadCallbackHead
    },
    {
        ObjectTypeDesktop, L"ObDesktop",
        QueryCallbackGeneric, DumpObCallbacks, FindObjectTypeCallbackListHeadByType,
        &g_SystemCallbacks.ObDesktopCallbackHead
    },
    {
        0, L"SeFileSystem",
        QueryCallbackGeneric, DumpSeFileSystemCallbacks, FindSeFileSystemNotifyRoutinesHead,
        &g_SystemCallbacks.SeFileSystemNotifyRoutinesHead
    },
    {
        1, L"SeFileSystemEx",
        QueryCallbackGeneric, DumpSeFileSystemCallbacks, FindSeFileSystemNotifyRoutinesHead,
        &g_SystemCallbacks.SeFileSystemNotifyRoutinesExHead
    },
    {
        0, L"PowerSettings",
        QueryCallbackGeneric, DumpPoCallbacks, FindPopRegisteredPowerSettingCallbacks,
        &g_SystemCallbacks.PopRegisteredPowerSettingCallbacks
    },
    {
        0, L"DebugPrint",
        QueryCallbackGeneric, DumpDbgPrintCallbacks, FindRtlpDebugPrintCallbackList,
        &g_SystemCallbacks.RtlpDebugPrintCallbackList
    },
    {
        0, L"IoFsRegistration",
        QueryCallbackGeneric, DumpIoFsRegistrationCallbacks, FindIopFsNotifyChangeQueueHead,
        &g_SystemCallbacks.IopFsNotifyChangeQueueHead
    },
    {
        0, L"IoFileSystemType",
        QueryIopFsListsCallbacks, DumpIoFileSystemCallbacks, NULL,
        NULL
    },
    {
        0, L"DbgkLmd",
        QueryCallbackGeneric, DumpDbgkLCallbacks, FindDbgkLmdCallbacks,
        &g_SystemCallbacks.DbgkLmdCallbacks
    },
    {
        0, L"AltSystemCall",
        QueryCallbackGeneric, DumpPsAltSystemCallHandlers, FindPsAltSystemCallHandlers,
        &g_SystemCallbacks.PsAltSystemCallHandlers
    },
    {
        0, L"CiCallbacks",
        QueryCallbackGeneric, DumpCiCallbacks, FindCiCallbacks,
        &g_SystemCallbacks.CiCallbacks
    },
    {
        0, L"ExHostCallbacks",
        QueryCallbackGeneric, DumpExHostCallbacks, FindExHostCallbacks,
        &g_SystemCallbacks.ExpHostListHead
    },
    {
        0, L"ExpCallbackList",
        QueryCallbackGeneric, DumpExpCallbackListCallbacks, FindExpCallbackListHead,
        &g_SystemCallbacks.ExpCallbackListHead
    },
    {
        0, L"PowerCoalescing",
        QueryCallbackGeneric, DumpPoCoalescingCallbacks, FindPoCoalescingCallbacks,
        &g_SystemCallbacks.PoCoalescingCallbacks
    },
    {
        0, L"PicoProviderRoutines",
        QueryCallbackGeneric, DumpPspPicoProviderRoutines, FindPspPicoProviderRoutines,
        &g_SystemCallbacks.PspPicoProviderRoutines
    },
    {
        0, L"NmiCallbacks",
        QueryCallbackGeneric, DumpKiNmiCallbackListHead, FindKiNmiCallbackListHead,
        &g_SystemCallbacks.KiNmiCallbackListHead
    },
    {
        0, L"SiloMonitor",
        QueryCallbackGeneric, DumpPspSiloMonitorList, FindPspSiloMonitorList,
        &g_SystemCallbacks.PspSiloMonitorList
    },
    {
        0, L"EmpCallbacks",
        QueryCallbackGeneric, DumpEmpCallbackListHead, FindEmpCallbackListHead,
        &g_SystemCallbacks.EmpCallbackListHead
    },
    {
        0, L"PnpCallbacks",
        QueryCallbackGeneric, DumpPnpDeviceClassNotifyList, FindPnpDeviceClassNotifyList,
        &g_SystemCallbacks.PnpDeviceClassNotifyList
    }
};

//
// All available names for CiCallbacks. Unknown is expected to be XBOX callback.
//
static const WCHAR* CiCallbackNames[] = {
    L"CiSetFileCache", //0
    L"CiGetFileCache", //1
    L"CiQueryInformation", //2
    L"CiValidateImageHeader", //3
    L"CiValidateImageData", //4
    L"CiHashMemory", //5
    L"KappxIsPackageFile", //6
    L"CiCompareSigningLevels", //7
    L"CiValidateFileAsImageType", //8
    L"CiRegisterSigningInformation", //9
    L"CiUnregisterSigningInformation",//10
    L"CiInitializePolicy",//11
    L"CiReleaseContext",//12
    L"XciUnknownCallback",//13 XBOX
    L"CiGetStrongImageReference", //14
    L"CiHvciSetImageBaseAddress", //15
    L"CipQueryPolicyInformation", //16
    L"CiValidateDynamicCodePages", //17
    L"CiQuerySecurityPolicy", //18
    L"CiRevalidateImage", //19
    L"CiSetInformation",//20
    L"CiSetInformationProcess", //21
    L"CiGetBuildExpiryTime", //22
    L"CiCheckProcessDebugAccessPolicy", //23
    L"SIPolicyQueryPolicyInformation",//24
    L"SIPolicyQuerySecurityPolicy",//25
    L"CiSetUnlockInformation",//26
    L"CiGetCodeIntegrityOriginClaimForFileObject",//27
    L"CiDeleteCodeIntegrityOriginClaimMembers", //28
    L"CiDeleteCodeIntegrityOriginClaimForFileObject",//29
    L"CiHvciReportMmIncompatibility",//30
    L"CiCompareExistingSePool",//31
    L"CiSetCachedOriginClaim",//32,
    L"CipIsDeveloperModeEnabled"//33
};

typedef enum _CiNameIds {
    Id_CiSetFileCache = 0,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiSetInformationProcess,
    Id_CiGetBuildExpiryTime,
    Id_CiCheckProcessDebugAccessPolicy,
    Id_SIPolicyQueryPolicyInformation,
    Id_SIPolicyQuerySecurityPolicy,
    Id_CiSetUnlockInformation,
    Id_CiGetCodeIntegrityOriginClaimForFileObject,
    Id_CiDeleteCodeIntegrityOriginClaimMembers,
    Id_CiDeleteCodeIntegrityOriginClaimForFileObject,
    Id_CiHvciReportMmIncompatibility,
    Id_CiCompareExistingSePool,
    Id_CiSetCachedOriginClaim,
    Id_CipIsDeveloperModeEnabled
} CiNameIds;

//
// Callback name index arrays
//

//
// Windows 7
//
static const BYTE CiCallbackIndexes_Win7[] = {
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiQueryInformation
};

//
// Windows 8
//
static const BYTE CiCallbackIndexes_Win8[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile
};

//
// Windows 8.1
//
static const BYTE CiCallbackIndexes_Win81[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy
};

//
// Windows 10 TH1/TH2
//
static const BYTE CiCallbackIndexes_Win10Threshold[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_SIPolicyQueryPolicyInformation,
    Id_CiValidateDynamicCodePages
};

//
// Windows 10 RS1
//
static const BYTE CiCallbackIndexes_Win10RS1[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_SIPolicyQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_SIPolicyQuerySecurityPolicy,
    Id_CiRevalidateImage
};

//
// Windows 10 RS2
//
static const BYTE CiCallbackIndexes_Win10RS2[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_SIPolicyQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetUnlockInformation,
    Id_CiGetBuildExpiryTime
};

//
// Windows 10 RS3
//
static const BYTE CiCallbackIndexes_Win10RS3[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiGetBuildExpiryTime
};

//
// Windows 10 RS4-21H2
//
static const BYTE CiCallbackIndexes_Win10RS4_21H2[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiSetInformationProcess,
    Id_CiGetBuildExpiryTime,
    Id_CiCheckProcessDebugAccessPolicy
};

//
// Windows 10 21H2 updated / 22H2
//
static const BYTE CiCallbackIndexes_Win1021H2_V2[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiSetInformationProcess,
    Id_CiGetBuildExpiryTime,
    Id_CiCheckProcessDebugAccessPolicy,
    Id_CiGetCodeIntegrityOriginClaimForFileObject,
    Id_CiDeleteCodeIntegrityOriginClaimMembers,
    Id_CiDeleteCodeIntegrityOriginClaimForFileObject
};

//
// Windows Server 2022
//
static const BYTE CiCallbacksIndexes_WinSrv21H2[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiSetInformationProcess,
    Id_CiGetBuildExpiryTime,
    Id_CiCheckProcessDebugAccessPolicy,
    Id_CiGetCodeIntegrityOriginClaimForFileObject,
    Id_CiDeleteCodeIntegrityOriginClaimMembers,
    Id_CiDeleteCodeIntegrityOriginClaimForFileObject,
    Id_CiHvciReportMmIncompatibility,
    Id_CiCompareExistingSePool
};

//
// Windows 11 21H2
//
static const BYTE CiCallbackIndexes_Win11_21H1[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiValidateDynamicCodePages,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiSetInformationProcess,
    Id_CiGetBuildExpiryTime,
    Id_CiCheckProcessDebugAccessPolicy,
    Id_CiGetCodeIntegrityOriginClaimForFileObject,
    Id_CiDeleteCodeIntegrityOriginClaimMembers,
    Id_CiDeleteCodeIntegrityOriginClaimForFileObject,
    Id_CiHvciReportMmIncompatibility,
    Id_CiCompareExistingSePool,
    Id_CiSetCachedOriginClaim
};

//
// Windows 11 22H2 - 25H2
//
static const BYTE CiCallbackIndexes_Win11_22H2_25H2[] = {
    Id_CiSetFileCache,
    Id_CiGetFileCache,
    Id_CiQueryInformation,
    Id_CiValidateImageHeader,
    Id_CiValidateImageData,
    Id_CiHashMemory,
    Id_KappxIsPackageFile,
    Id_CiCompareSigningLevels,
    Id_CiValidateFileAsImageType,
    Id_CiRegisterSigningInformation,
    Id_CiUnregisterSigningInformation,
    Id_CiInitializePolicy,
    Id_CiReleaseContext,
    Id_XciUnknownCallback,
    Id_CiGetStrongImageReference,
    Id_CiHvciSetImageBaseAddress,
    Id_CipQueryPolicyInformation,
    Id_CiQuerySecurityPolicy,
    Id_CiRevalidateImage,
    Id_CiSetInformation,
    Id_CiSetInformationProcess,
    Id_CiGetBuildExpiryTime,
    Id_CiCheckProcessDebugAccessPolicy,
    Id_CiGetCodeIntegrityOriginClaimForFileObject,
    Id_CiDeleteCodeIntegrityOriginClaimMembers,
    Id_CiDeleteCodeIntegrityOriginClaimForFileObject,
    Id_CiHvciReportMmIncompatibility,
    Id_CiCompareExistingSePool,
    Id_CiSetCachedOriginClaim,
    Id_CipIsDeveloperModeEnabled
};

typedef struct _CI_INDEX_MAP {
    ULONG MinBuild;
    ULONG MaxBuild;
    ULONG RequiredSize; // 0 = any size
    const BYTE* Table;
    ULONG Count;
} CI_INDEX_MAP, * PCI_INDEX_MAP;

static CI_INDEX_MAP g_CiIndexMap[] = {
    // Windows 7 (RTM..SP1)
    { NT_WIN7_RTM, NT_WIN7_SP1, 0, CiCallbackIndexes_Win7, RTL_NUMBER_OF(CiCallbackIndexes_Win7) },

    // Windows 8 / 8.1
    { NT_WIN8_RTM, NT_WIN8_RTM, 0, CiCallbackIndexes_Win8,  RTL_NUMBER_OF(CiCallbackIndexes_Win8)  },
    { NT_WIN8_BLUE, NT_WIN8_BLUE, 0, CiCallbackIndexes_Win81, RTL_NUMBER_OF(CiCallbackIndexes_Win81) },

    // TH1 / TH2
    { NT_WIN10_THRESHOLD1, NT_WIN10_THRESHOLD2, 0, CiCallbackIndexes_Win10Threshold, RTL_NUMBER_OF(CiCallbackIndexes_Win10Threshold) },

    // RS1
    { NT_WIN10_REDSTONE1, NT_WIN10_REDSTONE1, 0, CiCallbackIndexes_Win10RS1, RTL_NUMBER_OF(CiCallbackIndexes_Win10RS1) },

    // RS2
    { NT_WIN10_REDSTONE2, NT_WIN10_REDSTONE2, 0, CiCallbackIndexes_Win10RS2, RTL_NUMBER_OF(CiCallbackIndexes_Win10RS2) },

    // RS3
    { NT_WIN10_REDSTONE3, NT_WIN10_REDSTONE3, 0, CiCallbackIndexes_Win10RS3, RTL_NUMBER_OF(CiCallbackIndexes_Win10RS3) },

    // RS4 .. 19H2 (original table)
    { NT_WIN10_REDSTONE4, NT_WIN10_19H2, 0, CiCallbackIndexes_Win10RS4_21H2, RTL_NUMBER_OF(CiCallbackIndexes_Win10RS4_21H2) },

    // 20H1 .. 22H2 size-dependent (put size-specific first)
    { NT_WIN10_20H1, NT_WIN10_22H2, CBT_SIZE_VB_V2, CiCallbackIndexes_Win1021H2_V2, RTL_NUMBER_OF(CiCallbackIndexes_Win1021H2_V2) },
    { NT_WIN10_20H1, NT_WIN10_22H2, 0,             CiCallbackIndexes_Win10RS4_21H2, RTL_NUMBER_OF(CiCallbackIndexes_Win10RS4_21H2) },

    // Windows Server 2022 (same build band as 21H2 server)
    { NT_WINSRV_21H1, NT_WINSRV_21H1, 0, CiCallbacksIndexes_WinSrv21H2, RTL_NUMBER_OF(CiCallbacksIndexes_WinSrv21H2) },

    // Windows 11 21H2
    { NT_WIN11_21H2, NT_WIN11_21H2, 0, CiCallbackIndexes_Win11_21H1, RTL_NUMBER_OF(CiCallbackIndexes_Win11_21H1) },

    // Windows 11 22H2 .. 25H2
    { NT_WIN11_22H2, NT_WIN11_25H2, 0, CiCallbackIndexes_Win11_22H2_25H2, RTL_NUMBER_OF(CiCallbackIndexes_Win11_22H2_25H2) }
};

/*
* GetCiRoutineNameFromIndex
*
* Purpose:
*
* Return CiCallback name by index
*
*/
LPWSTR GetCiRoutineNameFromIndex(
    _In_ ULONG Index,
    _In_ ULONG_PTR CiCallbacksSize
)
{
    ULONG i, nameIndex;
    CI_INDEX_MAP* map = NULL;
    const BYTE* indexes;

    for (i = 0; i < RTL_NUMBER_OF(g_CiIndexMap); i++) {

        if ((g_NtBuildNumber >= g_CiIndexMap[i].MinBuild) &&
            (g_NtBuildNumber <= g_CiIndexMap[i].MaxBuild))
        {
            if (g_CiIndexMap[i].RequiredSize == 0 ||
                g_CiIndexMap[i].RequiredSize == CiCallbacksSize)
            {
                map = &g_CiIndexMap[i];
                break;
            }
        }
    }

    if (map == NULL)
        return T_CannotQuery;

    if (Index >= map->Count)
        return T_CannotQuery;

    indexes = map->Table;
    nameIndex = indexes[Index];

    if (nameIndex >= RTL_NUMBER_OF(CiCallbackNames))
        return T_CannotQuery;

    return (LPWSTR)CiCallbackNames[nameIndex];
}

/*
* ComputeAddressInsideNtOs
*
* Purpose:
*
* Returns kernel variable computed address within ntoskrnl image or zero in case of error.
*
*/
ULONG_PTR ComputeAddressInsideNtOs(
    _In_ ULONG_PTR CodeBase,
    _In_ ULONG_PTR Offset,
    _In_ ULONG InstructionLength,
    _In_ LONG Relative
)
{
    ULONG_PTR address;

    if (Relative == 0)
        return 0;

    address = kdAdjustAddressToNtOsBase(CodeBase, Offset, InstructionLength, Relative);

    if (!IN_REGION(address,
        g_kdctx.NtOsBase,
        g_kdctx.NtOsSize))
    {
        return 0;
    }

    return address;
}

/*
* FindCiCallbacksEx
*
* Purpose:
*
* Locate address of ntoskrnl SeCiCallbacks structure for Redstone5+.
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindCiCallbacksEx)
{
    BOOL bFound = FALSE;
    PBYTE ptrCode;
    ULONG_PTR cbSize = 0, ulTag = 0, Index = 0, kvarAddress = 0;
    LONG Rel = 0;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    //
    // NtCompareSigningLevels added in REDSTONE2 (15063)
    // It is a call to SeCiCallbacks[CiCompareSigningLevelsId]
    // Before REDSTONE5 it is called via wrapper SeCompareSigningLevels
    // From REDSTONE6 and above it is sometimes inlined.
    //

    ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap,
        "SeCompareSigningLevels");

    if (ptrCode == NULL) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap,
            "NtCompareSigningLevels");
    }

    if (ptrCode == NULL) {
        logAdd(EntryTypeWarning, TEXT("CompareSigningLevels ptr is not found"));
        return 0;
    }

    do {
        hde64_disasm((void*)(ptrCode + Index), &hs);
        if (hs.flags & F_ERROR)
            break;

        if (hs.len == 7) { //mov     r8, cs:CiCompareSigningLevels
            if ((ptrCode[Index] == 0x4C) &&
                (ptrCode[Index + 1] == 0x8B) &&
                (ptrCode[Index + 2] == 0x05))
            {
                Rel = *(PLONG)(ptrCode + Index + 3);
                break;
            }
        }

        Index += hs.len;

    } while (Index < SCAN_LIMIT_NEAR);

    if (Rel == 0) {
        logAdd(EntryTypeWarning, TEXT("CiCallbacks relative offset is not found"));
        return 0;
    }

    kvarAddress = kdAdjustAddressToNtOsBase((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    kvarAddress -= CiCompareSigningLevels_Offset;

    //
    // Read head - structure size.
    //
    if (!kdReadSystemMemory(kvarAddress, &cbSize, sizeof(cbSize))) {
        logAdd(EntryTypeWarning, TEXT("Failed to read CiCallbacks head"));
        return 0;
    }

    if (cbSize == 0 || cbSize > 0x1000) {
        logAdd(EntryTypeWarning, TEXT("CiCallbacks size is ambiguous"));
        return 0;
    }

    //
    // Read tail - marker tag.
    //
    if (!kdReadSystemMemory(kvarAddress + (cbSize - sizeof(ULONG_PTR)), &ulTag, sizeof(ulTag))) {
        logAdd(EntryTypeWarning, TEXT("Failed to read CiCallbacks tail"));
        return 0;
    }

    for (Index = 0; Index < RTL_NUMBER_OF(g_CbtMapping); Index++) {
        if (g_CbtMapping[Index].Build == g_NtBuildNumber) {
            bFound = TRUE;
            //
            // Validate for known table values.
            //
            if (cbSize == g_CbtMapping[Index].Size &&
                ulTag == g_CbtMapping[Index].Tag)
            {
                return kvarAddress;
            }
        }
    }

    if (bFound == FALSE)
        logAdd(EntryTypeWarning, TEXT("NtBuildNumber is not recognized"));

    return 0;
}

/*
* FindCiCallbacks
*
* Purpose:
*
* Locate address of ntoskrnl g_CiCallbacks/SeCiCallbacks structure.
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindCiCallbacks)
{
    ULONG_PTR kvarAddress = 0;

    PBYTE Signature = NULL, ptrCode = NULL, InstructionMatchPattern = NULL;
    ULONG SignatureSize = 0, InstructionMatchLength;
    ULONG InstructionExactMatchLength;
    PVOID SectionBase;
    ULONG SectionSize = 0, Index;
    LPCWSTR KVARName;
    LONG Rel = 0;
    hde64s hs;

    do {

        //
        // Symbols query.
        //
        if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
            KVARName = (g_NtBuildNumber < NT_WIN8_RTM) ? (LPCWSTR)KVAR_g_CiCallbacks : (LPCWSTR)KVAR_SeCiCallbacks;
            kdGetAddressFromSymbol(&g_kdctx,
                KVARName,
                &kvarAddress);
        }

        //
        // Pattern searching.
        //
        if (kvarAddress == 0) {
            if (g_NtBuildNumber >= NT_WIN10_REDSTONE5) {
                kvarAddress = FindCiCallbacksEx(QueryFlags);
            }
            else {

                //
                // Locate PAGE image section as required variable is always in PAGE.
                //
                SectionBase = supLookupImageSectionByName(
                    PAGE_SECTION,
                    PAGE_SECTION_LENGTH,
                    g_kdctx.NtOsImageMap,
                    &SectionSize);

                if ((SectionBase == 0) || (SectionSize == 0))
                    break;

                InstructionMatchPattern = SeCiCallbacksMatchingPattern; //default matching pattern
                InstructionMatchLength = LEA_INSTRUCTION_LENGTH_7B;
                InstructionExactMatchLength = CI_CALLBACKS_3BYTE_INSTRUCTION_SIZE;

                switch (g_NtBuildNumber) {

                case NT_WIN7_SP1:
                    Signature = g_CiCallbacksPattern_7601;
                    SignatureSize = sizeof(g_CiCallbacksPattern_7601);
                    InstructionMatchPattern = g_CiCallbacksMatchingPattern;
                    break;

                case NT_WIN8_RTM:
                case NT_WIN8_BLUE:
                    Signature = SeCiCallbacksPattern_9200_9600;
                    SignatureSize = sizeof(SeCiCallbacksPattern_9200_9600);
                    break;

                case NT_WIN10_THRESHOLD1:
                case NT_WIN10_THRESHOLD2:
                    Signature = SeCiCallbacksPattern_10240_10586;
                    SignatureSize = sizeof(SeCiCallbacksPattern_10240_10586);
                    break;

                case NT_WIN10_REDSTONE1:
                    Signature = SeCiCallbacksPattern_14393;
                    SignatureSize = sizeof(SeCiCallbacksPattern_14393);
                    break;

                case NT_WIN10_REDSTONE2:
                case NT_WIN10_REDSTONE3:
                    Signature = SeCiCallbacksPattern_15063_16299;
                    SignatureSize = sizeof(SeCiCallbacksPattern_15063_16299);
                    break;

                case NT_WIN10_REDSTONE4:
                default:
                    Signature = SeCiCallbacksPattern_17134_17763;
                    SignatureSize = sizeof(SeCiCallbacksPattern_17134_17763);
                    break;
                }

                ptrCode = (PBYTE)supFindPattern(
                    (PBYTE)SectionBase,
                    SectionSize,
                    Signature,
                    SignatureSize);

                if (ptrCode == NULL)
                    break;

                if (g_NtBuildNumber <= NT_WIN7_SP1) {

                    //
                    // Find reference to g_CiCallbacks in code.
                    //

                    Index = 0; //pattern search include target instruction, do not skip

                }
                else {

                    //
                    // Find reference to SeCiCallbacks/g_CiCallbacks in code.
                    //

                    Index = SignatureSize; //skip signature instructions

                }

                do {
                    hde64_disasm((void*)(ptrCode + Index), &hs);
                    if (hs.flags & F_ERROR)
                        break;
                    //
                    // mov cs:g_CiCallbacks, rax (for Windows 7)
                    // lea rcx, SeCiCallbacks (for 8/10 TH/RS)
                    // mov cs:SeCiCallbacks (19H1-21H1)
                    //
                    if (hs.len == InstructionMatchLength) {

                        //
                        // Match block found.
                        //
                        if (RtlCompareMemory((VOID*)&ptrCode[Index], (VOID*)InstructionMatchPattern,
                            InstructionExactMatchLength) == InstructionExactMatchLength)
                        {
                            Rel = *(PLONG)(ptrCode + Index + InstructionExactMatchLength);
                            break;
                        }
                    }
                    Index += hs.len;

                } while (Index < SCAN_LIMIT_NEAR);

                kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);

            }
        }

    } while (FALSE);

    if (kvarAddress == 0)
        logAdd(EntryTypeWarning, TEXT("Could not locate CiCallbacks"));

    return kvarAddress;
}

/*
* IopFileSystemIsKnownPattern
*
* Purpose:
*
* Tests IoRegisterFileSystem function pattern to be known.
*
*/
BOOL IopFileSystemIsKnownPattern(
    _In_ PBYTE Buffer,
    _In_ ULONG Offset,
    _In_ ULONG InstructionSize
)
{
    BOOL bResult = FALSE;
    BYTE inst3byte;
    BYTE nextInstructionByte1, nextInstructionByte2;

    if (g_NtBuildNumber <= NT_WIN11_21H2) {
        inst3byte = 0x0D;
        nextInstructionByte1 = 0x48;
        nextInstructionByte2 = 0xE9;
    }
    else { //win11 22h1+

        switch (g_NtBuildNumber)
        {
        case NT_WIN11_22H2:
        case NT_WIN11_23H2:
            inst3byte = 0x15;
            nextInstructionByte1 = 0x0F;
            nextInstructionByte2 = 0xE9;
            break;

        case NT_WIN11_24H2:
        default:
            inst3byte = 0x15;
            nextInstructionByte1 = 0x0F;
            nextInstructionByte2 = 0xEB;
            break;
        }
    }

    if ((Buffer[Offset] == 0x48) &&
        (Buffer[Offset + 1] == 0x8D) &&
        (Buffer[Offset + 2] == inst3byte) &&
        ((Buffer[Offset + InstructionSize] == nextInstructionByte1) || (Buffer[Offset + InstructionSize] == nextInstructionByte2)))
    {
        bResult = TRUE;
    }

    return bResult;
}

/*
* LookupIopFileSystemQueueHeads_w7
*
* Purpose:
*
* Windows 7 version of IoRegisterFileSystem listheads lookup.
*
*/
ULONG LookupIopFileSystemQueueHeads_w7(
    _In_ PBYTE Buffer,
    _Inout_ ULONG_PTR* IopCdRomFileSystemQueueHead,
    _Inout_ ULONG_PTR* IopDiskFileSystemQueueHead,
    _Inout_ ULONG_PTR* IopTapeFileSystemQueueHead,
    _Inout_ ULONG_PTR* IopNetworkFileSystemQueueHead
)
{
    ULONG Index = 0, Count = 0;
    LONG Rel = 0;
    ULONG_PTR kvarAddress;
    hde64s hs;
    PBYTE ptrCode = Buffer;

    do {
        hde64_disasm(ptrCode + Index, &hs);
        if (hs.flags & F_ERROR)
            break;

        if (hs.len == LEA_INSTRUCTION_LENGTH_7B) {
            //
            // lea  rdx, xxx                
            //
            if ((ptrCode[Index] == 0x48) &&
                (ptrCode[Index + 1] == 0x8D) &&
                (ptrCode[Index + 2] == 0x15))
            {
                Rel = *(PLONG)(ptrCode + Index + 3);
                if (Rel) {

                    kvarAddress = kdAdjustAddressToNtOsBase((ULONG_PTR)ptrCode, Index, hs.len, Rel);

                    if (kdAddressInNtOsImage((PVOID)kvarAddress)) {

                        switch (Count) {
                        case 0:
                            *IopNetworkFileSystemQueueHead = kvarAddress;
                            break;

                        case 1:
                            *IopCdRomFileSystemQueueHead = kvarAddress;
                            break;

                        case 2:
                            *IopDiskFileSystemQueueHead = kvarAddress;
                            break;

                        case 3:
                            *IopTapeFileSystemQueueHead = kvarAddress;
                            break;
                        }
                        Count += 1;
                        if (Count == 4)
                            break;
                    }
                }
            }

        }

        Index += hs.len;

    } while (Index < SCAN_LIMIT_LARGE);

    return Count;
}

/*
* LookupIopFileSystemQueueHeads_w8_11
*
* Purpose:
*
* Windows 8-11 version of IoRegisterFileSystem listheads lookup.
*
*/
ULONG LookupIopFileSystemQueueHeads_w8_11(
    _In_ PBYTE Buffer,
    _In_ BOOL Reorder,
    _Inout_ ULONG_PTR* IopCdRomFileSystemQueueHead,
    _Inout_ ULONG_PTR* IopDiskFileSystemQueueHead,
    _Inout_ ULONG_PTR* IopTapeFileSystemQueueHead,
    _Inout_ ULONG_PTR* IopNetworkFileSystemQueueHead
)
{
    ULONG Index = 0, Count = 0;
    LONG Rel = 0;
    ULONG_PTR kvarAddress;
    hde64s hs;
    PBYTE ptrCode = Buffer;

    do {
        hde64_disasm(ptrCode + Index, &hs);
        if (hs.flags & F_ERROR)
            break;

        if (hs.len == 7) {

            if (IopFileSystemIsKnownPattern(ptrCode, Index, hs.len)) {
                Rel = *(PLONG)(ptrCode + Index + 3);
                if (Rel) {

                    kvarAddress = kdAdjustAddressToNtOsBase((ULONG_PTR)ptrCode, Index, hs.len, Rel);

                    if (kdAddressInNtOsImage((PVOID)kvarAddress)) {

                        if (Reorder)
                        {
                            switch (Count) {

                            case 0:
                                *IopNetworkFileSystemQueueHead = kvarAddress;
                                break;

                            case 1:
                                *IopCdRomFileSystemQueueHead = kvarAddress;
                                break;

                            case 2:
                                *IopDiskFileSystemQueueHead = kvarAddress;
                                break;

                            case 3:
                                *IopTapeFileSystemQueueHead = kvarAddress;
                                break;
                            }
                        }
                        else {

                            switch (Count) {
                            case 0:
                                *IopDiskFileSystemQueueHead = kvarAddress;
                                break;

                            case 1:
                                *IopCdRomFileSystemQueueHead = kvarAddress;
                                break;

                            case 2:
                                *IopNetworkFileSystemQueueHead = kvarAddress;
                                break;

                            case 3:
                                *IopTapeFileSystemQueueHead = kvarAddress;
                                break;
                            }
                        }
                        Count += 1;
                        if (Count == 4)
                            break;
                    }
                }
            }

        }

        Index += hs.len;

    } while (Index < SCAN_LIMIT_LARGE);

    return Count;
}

/*
* FindIopFileSystemQueueHeads
*
* Purpose:
*
* Return addresses of list heads for callbacks registered with:
*
*   IoRegisterFileSystem
*
*/
BOOL FindIopFileSystemQueueHeads(
    _Out_ ULONG_PTR* IopCdRomFileSystemQueueHead,
    _Out_ ULONG_PTR* IopDiskFileSystemQueueHead,
    _Out_ ULONG_PTR* IopTapeFileSystemQueueHead,
    _Out_ ULONG_PTR* IopNetworkFileSystemQueueHead
)
{
    BOOL bSymQuerySuccess = FALSE;
    ULONG Count = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;

    //
    // Assume failure.
    //
    *IopCdRomFileSystemQueueHead = 0;
    *IopDiskFileSystemQueueHead = 0;
    *IopTapeFileSystemQueueHead = 0;
    *IopNetworkFileSystemQueueHead = 0;

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {

        do {

            if (!kdGetAddressFromSymbol(&g_kdctx,
                KVAR_IopCdRomFileSystemQueueHead,
                &kvarAddress))
            {
                break;
            }

            *IopCdRomFileSystemQueueHead = kvarAddress;

            if (!kdGetAddressFromSymbol(&g_kdctx,
                KVAR_IopDiskFileSystemQueueHead,
                &kvarAddress))
            {
                break;
            }

            *IopDiskFileSystemQueueHead = kvarAddress;

            if (!kdGetAddressFromSymbol(&g_kdctx,
                KVAR_IopTapeFileSystemQueueHead,
                &kvarAddress))
            {
                break;
            }

            *IopTapeFileSystemQueueHead = kvarAddress;

            if (!kdGetAddressFromSymbol(&g_kdctx,
                KVAR_IopNetworkFileSystemQueueHead,
                &kvarAddress))
            {
                break;
            }

            *IopNetworkFileSystemQueueHead = kvarAddress;

            bSymQuerySuccess = TRUE;

        } while (FALSE);

    }

    if (bSymQuerySuccess)
        return TRUE;

    ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap,
        "IoRegisterFileSystem");

    if (ptrCode == NULL)
        return 0;

    if (g_NtBuildNumber < NT_WIN8_RTM) {

        Count = LookupIopFileSystemQueueHeads_w7(ptrCode,
            IopCdRomFileSystemQueueHead,
            IopDiskFileSystemQueueHead,
            IopTapeFileSystemQueueHead,
            IopNetworkFileSystemQueueHead);
    }
    else {
        Count = LookupIopFileSystemQueueHeads_w8_11(ptrCode,
            (g_NtBuildNumber >= NT_WIN11_24H2),  // Since WIN11 24H2 pointer usage in this function is reordered.
            IopCdRomFileSystemQueueHead,
            IopDiskFileSystemQueueHead,
            IopTapeFileSystemQueueHead,
            IopNetworkFileSystemQueueHead);

    }

    return (Count == 4);
}

/*
* IopFsNotifyChangeIsKnownPattern
*
* Purpose:
*
* Tests IoUnregisterFsRegistrationChange function pattern to be known.
*
*/
BOOL IopFsNotifyChangeIsKnownPattern(
    _In_ PBYTE Buffer,
    _In_ ULONG Offset,
    _In_ ULONG InstructionSize
)
{
    BOOL bResult = FALSE;
    BYTE nextInstructionByte1;

    switch (g_NtBuildNumber) {
    case NT_WIN11_24H2:
    case NT_WIN11_25H2:
        nextInstructionByte1 = 0x48;
        break;
    default:
        nextInstructionByte1 = 0xEB;
        break;
    }

    //
    // lea  rax, IopFsNotifyChangeQueueHead
    // jmp  short / cmp rcx, rax
    //
    if ((Buffer[Offset] == 0x48) &&
        (Buffer[Offset + 1] == 0x8D) &&
        (Buffer[Offset + 2] == 0x05) &&
        (Buffer[Offset + InstructionSize] == nextInstructionByte1))
    {
        bResult = TRUE;
    }

    return bResult;
}

/*
* FindIopFsNotifyChangeQueueHead
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   IoRegisterFsRegistrationChange
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindIopFsNotifyChangeQueueHead)
{
    ULONG Index = 0;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_IopFsNotifyChangeQueueHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {

        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap,
            "IoUnregisterFsRegistrationChange");

        if (ptrCode == NULL)
            return 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 7) {

                if (IopFsNotifyChangeIsKnownPattern(
                    ptrCode,
                    Index,
                    hs.len))
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_MEDIUM);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindRtlpDebugPrintCallbackList
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   DbgSetDebugPrintCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindRtlpDebugPrintCallbackList)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_RtlpDebugPrintCallbackList,
            &kvarAddress);
    }

    if (kvarAddress == 0) {

        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "DbgSetDebugPrintCallback");
        if (ptrCode == NULL)
            return 0;

        //
        // Find DbgpInsertDebugPrintCallback pointer.
        //
        Index = 0;
        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            //jmp/call DbgpInsertDebugPrintCallback
            if (hs.len == 5) {
                if (hs.opcode == 0xE8 || hs.opcode == 0xE9)
                {
                    Rel = (LONG)hs.imm.imm32;
                    break;
                }
            }
            //jz
            if (hs.len == 6) {
                if (hs.opcode == 0x0F) {
                    Rel = (LONG)hs.imm.imm32;
                    break;
                }
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_NEAR);

        if (Rel == 0) {
            logAdd(EntryTypeWarning, TEXT("DbgpInsertDebugPrintCallback relative offset is not found"));
            return 0;
        }

        ptrCode = ptrCode + Index + (hs.len) + Rel;
        Index = 0;
        Rel = 0;

        //
        // Complicated search. Not unique search patterns.
        //

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            //
            // lea  reg, RtlpDebugPrintCallbackList
            //
            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) {
                if ((ptrCode[Index] == 0x48) &&
                    (ptrCode[Index + 1] == 0x8D) &&
                    ((ptrCode[Index + 2] == 0x15) || (ptrCode[Index + 2] == 0x0D)) &&
                    (ptrCode[Index + hs.len] == 0x48))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_LARGE);

        if (Rel == 0) {
            logAdd(EntryTypeWarning, TEXT("RtlpDebugPrintCallbackList relative offset is not found"));
            return 0;
        }

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);

    }

    return kvarAddress;
}

/*
* FindPopRegisteredPowerSettingCallbacks
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   PoRegisterPowerSettingCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPopRegisteredPowerSettingCallbacks)
{
    ULONG Index, ScanBytes;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PopRegisteredPowerSettingCallbacks,
            &kvarAddress);
    }

    if (kvarAddress == 0) {

        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap,
            "PoRegisterPowerSettingCallback");

        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        ScanBytes = (g_NtBuildNumber < NT_WIN11_25H2) ? SCAN_LIMIT_LARGE : SCAN_LIMIT_XLARGE;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 7) {
                //
                // lea      rcx, PopRegisteredPowerSettingCallbacks
                // mov      [rbx + 8], rax |
                // cmp      [rax], rcx
                //
                if ((ptrCode[Index] == 0x48) &&
                    (ptrCode[Index + 1] == 0x8D) &&
                    (ptrCode[Index + 2] == 0x0D) &&
                    (ptrCode[Index + 7] == 0x48))
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }

            }

            Index += hs.len;

        } while (Index < ScanBytes);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);

    }

    return kvarAddress;
}

/*
* FindSeFileSystemNotifyRoutinesHead
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   SeRegisterLogonSessionTerminatedRoutine
*   SeRegisterLogonSessionTerminatedRoutineEx
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindSeFileSystemNotifyRoutinesHead)
{
    BOOL Extended = (BOOL)(ULONG)QueryFlags;
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    LPSTR lpCallbackName;
    PBYTE ptrCode;
    hde64s hs;

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            (Extended) ? KVAR_SeFileSystemNotifyRoutinesExHead : KVAR_SeFileSystemNotifyRoutinesHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        //
        // Routines have similar design.
        //
        lpCallbackName = Extended ? "SeRegisterLogonSessionTerminatedRoutineEx" : "SeRegisterLogonSessionTerminatedRoutine";

        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, lpCallbackName);
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 7) {

                //
                // mov     rax, cs:SeFileSystemNotifyRoutines(Ex)Head
                //

                if ((ptrCode[Index] == 0x48) &&
                    (ptrCode[Index + 1] == 0x8B) &&
                    (ptrCode[Index + 2] == 0x05))
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_SMALL);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);

    }

    return kvarAddress;
}

/*
* FindObjectTypeCallbackListHeadByType
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   ObRegisterCallbacks
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindObjectTypeCallbackListHeadByType)
{
    ULONG_PTR ListHead = 0;
    ULONG ObjectSize, ObjectVersion = 0, CallbackListOffset = 0;
    LPWSTR TypeName = NULL;
    POBEX_OBJECT_INFORMATION CurrentObject = NULL;
    PVOID ObjectTypeInformation = NULL;
    UNICODE_STRING usName;

    union {
        union {
            OBJECT_TYPE_7* ObjectType_7;
            OBJECT_TYPE_8* ObjectType_8;
            OBJECT_TYPE_RS1* ObjectType_RS1;
            OBJECT_TYPE_RS2* ObjectType_RS2;
        } Versions;
        PVOID Ref;
    } ObjectType;

    switch ((WOBJ_OBJECT_TYPE)(ULONG)QueryFlags) {
    case ObjectTypeProcess: //PsProcessType
        TypeName = TEXT("Process");
        break;
    case ObjectTypeThread: //PsThreadType
        TypeName = TEXT("Thread");
        break;
    case ObjectTypeDesktop: //ExDesktopObjectType
        TypeName = TEXT("Desktop");
        break;
    default:
        //
        // We cannot process this object type.
        //
        return 0;
    }

    //
    // Get the reference to the object.
    //
    RtlInitUnicodeString(&usName, TypeName);
    CurrentObject = ObQueryObjectInDirectory(&usName,
        ObGetPredefinedUnicodeString(OBP_OBTYPES));

    if (CurrentObject == NULL)
        return 0;

    //
    // Dump object information version aware.
    //
    ObjectTypeInformation = ObDumpObjectTypeVersionAware(
        CurrentObject->ObjectAddress,
        &ObjectSize,
        &ObjectVersion);

    if (ObjectTypeInformation == NULL) {
        supHeapFree(CurrentObject);
        return 0;
    }

    ObjectType.Ref = ObjectTypeInformation;

    //
    // Flags in structure offset compatible fields.
    //
    if (ObjectType.Versions.ObjectType_7->TypeInfo.SupportsObjectCallbacks) {

        //
        // Calculate offset to structure field.
        //
        switch (ObjectVersion) {
        case OBVERSION_OBJECT_TYPE_V1:
            CallbackListOffset = FIELD_OFFSET(OBJECT_TYPE_7, CallbackList);
            break;

        case OBVERSION_OBJECT_TYPE_V2:
            CallbackListOffset = FIELD_OFFSET(OBJECT_TYPE_8, CallbackList);
            break;

        case OBVERSION_OBJECT_TYPE_V3:
            CallbackListOffset = FIELD_OFFSET(OBJECT_TYPE_RS1, CallbackList);
            break;

        default:
            CallbackListOffset = FIELD_OFFSET(OBJECT_TYPE_RS2, CallbackList);
            break;
        }

        ListHead = CurrentObject->ObjectAddress + CallbackListOffset;
    }

    supHeapFree(CurrentObject);
    supVirtualFree(ObjectTypeInformation);
    return ListHead;
}

/*
* FindIopNotifyShutdownQueueHeadHead
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   IoRegisterShutdownNotification
*   IoRegisterLastChanceShutdownNotification
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindIopNotifyShutdownQueueHeadHead)
{
    BOOL bLastChance = (BOOL)(ULONG)QueryFlags;
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    LPSTR lpCallbackName;
    PBYTE ptrCode;
    hde64s hs;

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            (bLastChance) ? KVAR_IopNotifyLastChanceShutdownQueueHead : KVAR_IopNotifyShutdownQueueHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        //
        // Routines have similar design.
        //
        lpCallbackName = (bLastChance) ? "IoRegisterLastChanceShutdownNotification" : "IoRegisterShutdownNotification";
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, lpCallbackName);
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                if (((ptrCode[Index] == 0x48) || (ptrCode[Index] == 0x4C)) &&
                    (ptrCode[Index + 1] == 0x8D))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_SMALL);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);

    }

    return kvarAddress;
}

/*
* FindCmCallbackHead
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   CmRegisterCallback
*   CmRegisterCallbackEx
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindCmCallbackHead)
{
    BOOL bFound = FALSE;
    ULONG Index, resultOffset = 0;
    LONG Rel = 0, FirstInstructionLength;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs, hs_next;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_CallbackListHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "CmUnRegisterCallback");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (g_NtBuildNumber < NT_WIN11_25H2)
            {
                if (hs.len == 5) {
                    /*
                    ** lea     rdx, [rsp+20h] <-
                    ** lea     rcx, CallbackListHead
                    */
                    if ((ptrCode[Index] == 0x48) &&
                        (ptrCode[Index + 1] == 0x8D) &&
                        (ptrCode[Index + 2] == 0x54))
                    {
                        bFound = TRUE;
                    }
                }
            }
            else {
                if (hs.len == 8 &&
                    (hs.flags & F_PREFIX_REX) &&
                    (hs.flags & F_DISP32) &&
                    (hs.flags & F_MODRM))
                {
                    /*
                    ** lea     rdx, [rsp+0B8h+arg_8] <-
                    ** lea     rcx, CallbackListHead
                    */
                    if ((ptrCode[Index] == 0x48) &&
                        (ptrCode[Index + 1] == 0x8D) &&
                        (ptrCode[Index + 2] == 0x94))
                    {
                        bFound = TRUE;
                    }
                }

            }

            if (bFound)
            {
                hde64_disasm(ptrCode + Index + hs.len, &hs_next);
                if (hs_next.flags & F_ERROR)
                    break;
                if (hs_next.len == LEA_INSTRUCTION_LENGTH_7B) {

                    /*
                    ** lea     rdx, [rsp+20h]
                    ** lea     rcx, CallbackListHead <-
                    */
                    FirstInstructionLength = hs.len;

                    if ((ptrCode[Index + FirstInstructionLength] == 0x48) &&
                        (ptrCode[Index + FirstInstructionLength + 1] == 0x8D) &&
                        (ptrCode[Index + FirstInstructionLength + 2] == 0x0D))
                    {
                        resultOffset = Index + FirstInstructionLength + hs_next.len;
                        Rel = *(PLONG)(ptrCode + Index + FirstInstructionLength + 3);
                        break;
                    }
                }
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_MEDIUM);

        if (resultOffset == 0) {
            logAdd(EntryTypeWarning, TEXT("CmCallbackHead offset is not found"));
            return 0;
        }

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, resultOffset, 0, Rel);
    }

    return kvarAddress;
}

/*
* FindKeBugCheckReasonCallbackHead
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   KeRegisterBugCheckReasonCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindKeBugCheckReasonCallbackHead)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_KeBugCheckReasonCallbackListHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "KeRegisterBugCheckReasonCallback");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                if (((ptrCode[Index] == 0x48) || (ptrCode[Index] == 0x4C)) &&
                    (ptrCode[Index + 1] == 0x8D) &&
                    ((ptrCode[Index + hs.len] == 0x48) || (ptrCode[Index + hs.len] == 0x83)))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_LARGE);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindKeBugCheckCallbackHead
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   KeRegisterBugCheckCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindKeBugCheckCallbackHead)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_KeBugCheckCallbackListHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "KeRegisterBugCheckCallback");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea + mov

                if (((ptrCode[Index] == 0x48) || (ptrCode[Index] == 0x4C)) &&
                    (ptrCode[Index + 1] == 0x8D) &&
                    (ptrCode[Index + hs.len] == 0x48))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_LARGE);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPspLoadImageNotifyRoutine
*
* Purpose:
*
* Return array address of callbacks registered with:
*
*   PsSetLoadImageNotifyRoutine
*   PsSetLoadImageNotifyRoutineEx
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPspLoadImageNotifyRoutine)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PspLoadImageNotifyRoutine,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PsRemoveLoadImageNotifyRoutine");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                if (((ptrCode[Index] == 0x48) || (ptrCode[Index] == 0x4C)) &&
                    (ptrCode[Index + 1] == 0x8D))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_SMALL);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPspCreateThreadNotifyRoutine
*
* Purpose:
*
* Return array address of callbacks registered with:
*
*   PsSetCreateThreadNotifyRoutine
*   PsSetCreateThreadNotifyRoutineEx
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPspCreateThreadNotifyRoutine)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PspCreateThreadNotifyRoutine,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PsRemoveCreateThreadNotifyRoutine");

        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                if (((ptrCode[Index] == 0x48) || (ptrCode[Index] == 0x4C)) &&
                    (ptrCode[Index + 1] == 0x8D))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_SMALL);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindDbgkLmdCallbacks
*
* Purpose:
*
* Return array address of callbacks registered with:
*
*   DbgkLkmdRegisterCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindDbgkLmdCallbacks)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_DbgkLmdCallbacks,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "DbgkLkmdUnregisterCallback");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        //
        // Find DbgkLmdCallbacks pointer
        //
        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                //
                // lea     rcx, DbgkLmdCallbacks
                //
                if (((ptrCode[Index] == 0x4C) || (ptrCode[Index] == 0x48)) &&
                    (ptrCode[Index + 1] == 0x8D))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_NEAR);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPspCreateProcessNotifyRoutine
*
* Purpose:
*
* Return array address of callbacks registered with:
*
*   PsSetCreateProcessNotifyRoutine
*   PsSetCreateProcessNotifyRoutineEx
*   PsSetCreateProcessNotifyRoutineEx2
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPspCreateProcessNotifyRoutine)
{
    ULONG Index;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PspCreateProcessNotifyRoutine,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PsSetCreateProcessNotifyRoutine");
        if (ptrCode == NULL)
            return 0;

        //
        // Find PspSetCreateProcessNotifyRoutine pointer.
        //
        Index = 0;
        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            // Handle JMP/CALL rel32
            if ((hs.opcode == 0xE8 || hs.opcode == 0xE9) &&
                hs.len == 5)
            {
                Rel = (LONG)hs.imm.imm32;
                break;
            }
            // Handle JMP rel8 (Windows 8 RTM)
            else if (hs.opcode == 0xEB &&
                hs.len == 2)
            {
                Rel = (LONG)(INT8)hs.imm.imm8;
                break;
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_NEAR);

        if (Rel == 0) {
            logAdd(EntryTypeWarning, TEXT("PspSetCreateProcessNotifyRoutine relative offset is not found"));
            return 0;
        }

        ptrCode = ptrCode + Index + (hs.len) + Rel;
        Index = 0;
        Rel = 0;

        do {
            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                if ((ptrCode[Index] == 0x4C) &&
                    (ptrCode[Index + 1] == 0x8D))
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }

            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_SMALL);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPsAltSystemCallHandlers
*
* Purpose:
*
* Return array address of callbacks registered with:
*
*   PsRegisterAltSystemCallHandler
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPsAltSystemCallHandlers)
{
    ULONG Index, InstructionExactMatchLength;
    LONG Rel = 0;
    ULONG_PTR kvarAddress = 0;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PsAltSystemCallHandlers,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PsRegisterAltSystemCallHandler");
        if (ptrCode == NULL)
            return 0;

        InstructionExactMatchLength = sizeof(PsAltSystemCallHandlersPattern);

        Index = 0;

        do {
            hde64_disasm((void*)(ptrCode + Index), &hs);
            if (hs.flags & F_ERROR)
                break;
            //
            // lea reg, PsAltSystemCallHandlers
            //
            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) {

                //
                // Match block found.
                //
                if (RtlCompareMemory((VOID*)&ptrCode[Index],
                    (VOID*)PsAltSystemCallHandlersPattern,
                    InstructionExactMatchLength) == InstructionExactMatchLength)
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }
            }
            Index += hs.len;

        } while (Index < SCAN_LIMIT_SMALL);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindExHostListCallbacks
*
* Purpose:
*
* Return address of list head for callbacks registered with:
*
*   ExRegisterExtension
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindExHostCallbacks)
{
    ULONG_PTR kvarAddress = 0;
    PBYTE   ptrCode;
    LONG    Rel = 0;
    ULONG   Index, c;
    hde64s  hs;

    ULONG SignatureSize = 0;
    PBYTE Signature = NULL;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_ExpHostList,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "ExRegisterExtension");
        if (ptrCode == NULL)
            return 0;

        c = 0;
        Index = 0;

        //
        // Find ExpFindHost / ExpFindCompatibleHost
        //
        if (g_NtBuildNumber >= NT_WIN11_21H2) {

            //
            // For Windows 11 and above lookup for ExpFindHost parameters 
            // as the call of ExpFindHost maybe deep inside the ExRegisterExtension with
            // multiple other calls before.
            //
            switch (g_NtBuildNumber)
            {
            case NT_WIN11_21H2:
            case NT_WIN11_22H2:
                Signature = g_ExpFindHost22000_22621;
                SignatureSize = sizeof(g_ExpFindHost22000_22621);
                break;
            case NT_WIN11_23H2:
            case NT_WIN11_24H2:
            case NT_WIN11_25H2:
            default:
                Signature = g_ExpFindHost22631_27842;
                SignatureSize = sizeof(g_ExpFindHost22631_27842);
                break;

            }

            ptrCode = (PBYTE)supFindPattern(
                (PBYTE)ptrCode,
                SCAN_LIMIT_XXLARGE,
                Signature,
                SignatureSize);

            if (ptrCode == NULL)
                return 0;

            Index = SignatureSize;
            Rel = 0;

            do {
                hde64_disasm(ptrCode + Index, &hs);
                if (hs.flags & F_ERROR)
                    break;

                //
               // Find call instruction.
               //
                if (hs.len == 5 && hs.opcode == 0xE8) {
                    Rel = (LONG)hs.imm.imm32;
                    break;
                }

                Index += hs.len;

            } while (Index < SCAN_LIMIT_NEAR);

        }
        else {

            do {

                hde64_disasm(ptrCode + Index, &hs);
                if (hs.flags & F_ERROR)
                    break;

                //
                // Find second call instruction.
                //
                if (hs.len == 5 && hs.opcode == 0xE8)
                    c++;

                if (c > 1) {
                    Rel = (LONG)hs.imm.imm32;
                    break;
                }

                Index += hs.len;

            } while (Index < SCAN_LIMIT_LARGE);
        }

        if (Rel == 0) {
            logAdd(EntryTypeWarning, TEXT("ExpFindHost relative offset is not found"));
            return 0;
        }

        //
        // Examine ExpFindHost
        //
        ptrCode = ptrCode + Index + 5 + Rel;

        hde64_disasm(ptrCode, &hs);
        if (hs.flags & F_ERROR)
            return 0;

        if (hs.len == 7) {
            //
            // mov     rax, cs:ExpHostList
            //
            if (ptrCode[1] == 0x8B) {
                Rel = *(PLONG)(ptrCode + 3);
                kvarAddress = kdAdjustAddressToNtOsBase((ULONG_PTR)ptrCode,
                    0,
                    hs.len,
                    Rel);
            }
        }
    }

    return kvarAddress;
}

/*
* FindExpCallbackListHead
*
* Purpose:
*
* Returns the address of ExpCallbackListHead for callbacks registered with:
*
*   ExCreateCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindExpCallbackListHead)
{
    ULONG Index;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (g_NtBuildNumber < NT_WIN8_BLUE)
        return 0;

    ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "ExCreateCallback");
    if (ptrCode == NULL)
        return 0;

    Index = 0;
    Rel = 0;

    do {
        hde64_disasm(ptrCode + Index, &hs);
        if (hs.flags & F_ERROR)
            break;

        if (hs.len == LEA_INSTRUCTION_LENGTH_7B
            && (hs.flags & (F_PREFIX_REX | F_DISP32 | F_MODRM)) == (F_PREFIX_REX | F_DISP32 | F_MODRM))
        {
            if (((ptrCode[Index] == 0x48) || (ptrCode[Index] == 0x4C)) &&
                (ptrCode[Index + 1] == 0x8D) &&
                ((ptrCode[Index + 2] == 0x15) || (ptrCode[Index + hs.len + 3] == 0x28))) // add/lea with +0x28 = offset of object's ExpCallbackList
            {
                Rel = (LONG)hs.disp.disp32;
                break;
            }
        }

        Index += hs.len;

    } while (Index < SCAN_LIMIT_LARGE);

    return ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
}

/*
* FindPoCoalescingCallbacks
*
* Purpose:
*
* Returns the address of PopCoalescingCallbackRoutine array or
* PopCoalRegistrationList list head for callbacks registered with:
*
*   PoRegisterCoalescingCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPoCoalescingCallbacks)
{
    ULONG Index;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;
    LPCWSTR lpSymbolName;
    BYTE checkByte;
    ULONG_PTR kvarAddress = 0;

    UNREFERENCED_PARAMETER(QueryFlags);

    //
    // Not available before Windows 8.
    //
    if (g_NtBuildNumber < NT_WIN8_BLUE)
        return 0;

    if (g_NtBuildNumber < NT_WIN10_REDSTONE4) {
        lpSymbolName = KVAR_PopCoalescingCallbackRoutine;
        checkByte = 0x0D;
    }
    else {
        lpSymbolName = KVAR_PopCoalRegistrationList;
        checkByte = 0x15;
    }

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            lpSymbolName,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PoRegisterCoalescingCallback");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == LEA_INSTRUCTION_LENGTH_7B) { //check if lea

                if ((ptrCode[Index] == 0x48) &&
                    (ptrCode[Index + 1] == 0x8D) &&
                    (ptrCode[Index + 2] == checkByte)) //universal for both types of implementation
                {
                    Rel = (LONG)hs.disp.disp32;
                    break;
                }
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_MEDIUM);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPspPicoProviderRoutines
*
* Purpose:
*
* Returns the address of PspPicoProviderRoutines array of callbacks registered with:
*
*   PsRegisterPicoProvider
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPspPicoProviderRoutines)
{
    ULONG Index;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;
    ULONG_PTR kvarAddress = 0;

    UNREFERENCED_PARAMETER(QueryFlags);

    //
    // Not available prior Win 10 and in Win10 TH2.
    //
    if (g_NtBuildNumber < NT_WIN10_THRESHOLD1 ||
        g_NtBuildNumber == NT_WIN10_THRESHOLD2)
    {
        return 0;
    }

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PspPicoProviderRoutines,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PsRegisterPicoProvider");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 7) { //check if movups

                if ((ptrCode[Index] == 0x0F) &&
                    (ptrCode[Index + 1] == 0x11) &&
                    (ptrCode[Index + 2] == 0x05))
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_MEDIUM);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindKiNmiCallbackListHead
*
* Purpose:
*
* Returns the address of KiNmiCallbackListHead for callbacks registered with:
*
*   KeRegisterNmiCallback
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindKiNmiCallbackListHead)
{
    ULONG Index, c;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;
    ULONG_PTR kvarAddress = 0;

    UNREFERENCED_PARAMETER(QueryFlags);

    //
    // Don't want to bother with support of such legacy code 
    // as we need support for only LTSB/C legacy stuff.
    //
    if (g_NtBuildNumber < NT_WIN10_THRESHOLD1)
        return 0;

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_KiNmiCallbackListHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "KeDeregisterNmiCallback");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        if (g_NtBuildNumber < NT_WIN10_REDSTONE3) {

            c = 0;

            do {

                hde64_disasm(&ptrCode[Index], &hs);
                if (hs.flags & F_ERROR)
                    break;

                if (hs.len == 7) {

                    if (ptrCode[Index] == 0x48 &&
                        ptrCode[Index + 1] == 0x8D &&
                        ptrCode[Index + 2] == 0x0D)
                    {
                        c += 1;
                    }
                }

                if (c > 2) {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }

                Index += hs.len;

            } while (Index < SCAN_LIMIT_MEDIUM);
        }
        else {

            do {
                hde64_disasm(ptrCode + Index, &hs);
                if (hs.flags & F_ERROR)
                    break;

                //
                // Find KiDeregisterNmiSxCallback.
                //
                if (hs.len == 5 && hs.opcode == 0xE8) {
                    Rel = (LONG)hs.imm.imm32;
                    break;
                }

                Index += hs.len;

            } while (Index < SCAN_LIMIT_NEAR);

            if (Rel != 0) {

                ptrCode = ptrCode + Index + hs.len + Rel;
                Index = 0;
                Rel = 0;
                c = 0;

                //
                // Scan KiDeregisterNmiSxCallback.
                //
                do {

                    hde64_disasm(&ptrCode[Index], &hs);
                    if (hs.flags & F_ERROR)
                        break;

                    if (hs.len == 7) {

                        if (ptrCode[Index] == 0x48 &&
                            ptrCode[Index + 1] == 0x8D &&
                            ptrCode[Index + 2] == 0x0D)
                        {
                            c += 1;
                        }
                    }

                    //
                    // Second lea is ours.
                    //
                    if (c > 1) {
                        Rel = *(PLONG)(ptrCode + Index + 3);
                        break;
                    }

                    Index += hs.len;
                } while (Index < SCAN_LIMIT_SMALL);
            }
        }
        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPspSiloMonitorList
*
* Purpose:
*
* Returns the address of PspSiloMonitorList for callbacks registered with:
*
*   PsRegisterSiloMonitor
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPspSiloMonitorList)
{
    ULONG Index;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;
    ULONG_PTR kvarAddress = 0;

    UNREFERENCED_PARAMETER(QueryFlags);

    //
    // Not available prior Windows 10 RS3.
    //
    if (g_NtBuildNumber < NT_WIN10_REDSTONE3)
        return 0;

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PspSiloMonitorList,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "PsStartSiloMonitor");
        if (ptrCode == NULL)
            return 0;

        Index = 0;
        Rel = 0;

        //
        // Search for PspSiloMonitorList.
        //

        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 7) {

                if (ptrCode[Index] == 0x48 &&
                    ptrCode[Index + 1] == 0x8D &&
                    ptrCode[Index + 2] == 0x0D &&
                    ptrCode[Index + hs.len] == 0x48)
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_LARGE);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindEmpCallbackListHead
*
* Purpose:
*
* Returns the address of EmpCallbackListHead for callbacks registered with:
*
*   EmProviderRegister
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindEmpCallbackListHead)
{
    ULONG Index;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;
    ULONG_PTR kvarAddress = 0;

    PVOID SectionBase;
    ULONG SectionSize = 0, SignatureSize = 0;
    PBYTE Signature = NULL;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_EmpCallbackListHead,
            &kvarAddress);
    }

    if (kvarAddress == 0) {

        //
        // Locate PAGE image section as required variable is always in PAGE.
        //
        SectionBase = supLookupImageSectionByName(
            PAGE_SECTION,
            PAGE_SECTION_LENGTH,
            g_kdctx.NtOsImageMap,
            &SectionSize);

        if ((SectionBase == 0) || (SectionSize == 0))
            return 0;

        if (g_NtBuildNumber < NT_WIN8_BLUE) {
            Signature = g_EmpSearchCallbackDatabase;
            SignatureSize = sizeof(g_EmpSearchCallbackDatabase);
        }
        else {
            if (g_NtBuildNumber <= NT_WIN11_23H2) {
                Signature = g_EmpSearchCallbackDatabase2;
                SignatureSize = sizeof(g_EmpSearchCallbackDatabase2);
            }
            else if (g_NtBuildNumber >= NT_WIN11_24H2) {
                Signature = g_EmpSearchCallbackDatabase3;
                SignatureSize = sizeof(g_EmpSearchCallbackDatabase3);
            }
            else {
                return 0; // this is general fuckup.
            }
        }

        ptrCode = (PBYTE)supFindPattern(
            (PBYTE)SectionBase,
            SectionSize,
            Signature,
            SignatureSize);

        if (ptrCode == NULL)
            return 0;

        Index = SignatureSize;
        Rel = 0;

        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            //
            // Find EmpSearchCallbackDatabase.
            //
            if (hs.len == 5 && hs.opcode == 0xE8) {
                Rel = (LONG)hs.imm.imm32;
                break;
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_NEAR);

        if (Rel != 0) {

            ptrCode = ptrCode + Index + hs.len + Rel;
            Index = 0;
            Rel = 0;

            do {

                hde64_disasm(ptrCode + Index, &hs);
                if (hs.flags & F_ERROR)
                    break;

                if (hs.len == 7) {

                    if (ptrCode[Index] == 0x48) {
                        Rel = *(PLONG)(ptrCode + Index + 3);
                        break;
                    }
                }

                Index += hs.len;

            } while (Index < 32);

        }

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* FindPnpDeviceClassNotifyList
*
* Purpose:
*
* Returns the address of PnpDeviceClassNotifyList  for callbacks registered with:
*
*   IoRegisterPlugPlayNotification
*
*/
OBEX_FINDCALLBACK_ROUTINE(FindPnpDeviceClassNotifyList)
{
    ULONG Index;
    LONG Rel;
    PBYTE ptrCode;
    hde64s hs;
    ULONG_PTR kvarAddress = 0;

    ULONG SignatureSize = 0;
    PBYTE Signature = NULL;

    UNREFERENCED_PARAMETER(QueryFlags);

    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {
        kdGetAddressFromSymbol(&g_kdctx,
            KVAR_PnpDeviceClassNotifyList,
            &kvarAddress);
    }

    if (kvarAddress == 0) {
        ptrCode = (PBYTE)GetProcAddress((HMODULE)g_kdctx.NtOsImageMap, "IoRegisterPlugPlayNotification");
        if (ptrCode == NULL)
            return 0;

        //
        // Find subpattern first.
        //

        switch (g_NtBuildNumber) {

        case NT_WIN7_RTM:
        case NT_WIN7_SP1:

            Signature = g_PnpDeviceClassNotifyList_SubPattern_7601;
            SignatureSize = sizeof(g_PnpDeviceClassNotifyList_SubPattern_7601);
            break;

        case NT_WIN8_RTM:
            Signature = g_PnpDeviceClassNotifyList_SubPattern_9200;
            SignatureSize = sizeof(g_PnpDeviceClassNotifyList_SubPattern_9200);
            break;

        default:
            Signature = g_PnpDeviceClassNofityList_SubPattern_9600_26080;
            SignatureSize = sizeof(g_PnpDeviceClassNofityList_SubPattern_9600_26080);
            break;
        }

        ptrCode = (PBYTE)supFindPattern(
            ptrCode,
            SCAN_LIMIT_XXLARGE,
            Signature,
            SignatureSize);

        if (ptrCode == NULL)
            return 0;

        Index = SignatureSize;
        Rel = 0;

        //
        // Find lea rcx, PnpDeviceClassNotifyList
        //

        do {

            hde64_disasm(ptrCode + Index, &hs);
            if (hs.flags & F_ERROR)
                break;

            if ((hs.len == LEA_INSTRUCTION_LENGTH_7B) &&
                (hs.flags & F_PREFIX_REX) &&
                (hs.flags & F_DISP32) &&
                (hs.flags & F_MODRM) &&
                (hs.opcode == 0x8D))
            {
                Rel = (LONG)hs.disp.disp32;
                break;
            }

            Index += hs.len;

        } while (Index < SCAN_LIMIT_NEAR);

        kvarAddress = ComputeAddressInsideNtOs((ULONG_PTR)ptrCode, Index, hs.len, Rel);
    }

    return kvarAddress;
}

/*
* AddRootEntryToList
*
* Purpose:
*
* Adds callback root entry to the treelist.
*
*/
HTREEITEM AddRootEntryToList(
    _In_ HWND TreeList,
    _In_ LPWSTR lpCallbackType
)
{
    return supTreeListAddItem(
        TreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        lpCallbackType,
        NULL);
}

/*
* AddParentEntryToList
*
* Purpose:
*
* Adds a parent entry for callbacks to the treelist.
*
*/
HTREEITEM AddParentEntryToList(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR CallbackObjectAddress,
    _In_ LPWSTR lpCallbackObjectType
)
{
    TL_SUBITEMS_FIXED TreeListSubItems;
    WCHAR szAddress[32];

    RtlSecureZeroMemory(&TreeListSubItems, sizeof(TreeListSubItems));
    TreeListSubItems.Count = 2;

    szAddress[0] = L'0';
    szAddress[1] = L'x';
    szAddress[2] = 0;
    u64tohex(CallbackObjectAddress, &szAddress[2]);
    TreeListSubItems.Text[0] = T_EmptyString;
    TreeListSubItems.Text[1] = lpCallbackObjectType;

    return supTreeListAddItem(
        TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        szAddress,
        &TreeListSubItems);
}

/*
* AddEntryToList
*
* Purpose:
*
* Adds callback entry to the treelist.
*
*/
VOID AddEntryToList(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Function,
    _In_opt_ LPWSTR lpAdditionalInfo,
    _In_ PRTL_PROCESS_MODULES Modules
)
{
    ULONG moduleIndex = 0;
    TL_SUBITEMS_FIXED TreeListSubItems;
    WCHAR szAddress[32];
    WCHAR szBuffer[MAX_PATH + 1];

    RtlSecureZeroMemory(&TreeListSubItems, sizeof(TreeListSubItems));
    TreeListSubItems.Count = 2;

    szAddress[0] = L'0';
    szAddress[1] = L'x';
    szAddress[2] = 0;
    u64tohex(Function, &szAddress[2]);

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

    if (ntsupFindModuleEntryByAddress(
        Modules,
        (PVOID)Function,
        &moduleIndex))
    {
        if (MultiByteToWideChar(
            CP_ACP,
            0,
            (LPCSTR)&Modules->Modules[moduleIndex].FullPathName,
            -1,
            szBuffer,
            MAX_PATH) == 0)
        {
            _strcpy(szBuffer, TEXT("Unknown Module"));
        }
    }
    else {
        _strcpy(szBuffer, TEXT("Unknown Module"));
    }

    TreeListSubItems.Text[0] = szBuffer;
    if (lpAdditionalInfo) {
        TreeListSubItems.Text[1] = lpAdditionalInfo;
    }
    else {
        TreeListSubItems.Text[1] = T_EmptyString;
    }

    supTreeListAddItem(
        TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        szAddress,
        &TreeListSubItems);

    g_CallbacksCount += 1;
}

/*
* AddEmptyEntryToList
*
* Purpose:
*
* Adds empty callback entry to the treelist.
*
*/
VOID AddEmptyEntryToList(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_opt_ LPWSTR lpAdditionalInfo
)
{
    TL_SUBITEMS_FIXED TreeListSubItems;
    WCHAR szAddress[32];

    RtlSecureZeroMemory(&TreeListSubItems, sizeof(TreeListSubItems));
    TreeListSubItems.Count = 2;

    szAddress[0] = L'0';
    szAddress[1] = L'x';
    u64tohex(0, &szAddress[2]);

    TreeListSubItems.Text[0] = T_EmptyString;
    if (lpAdditionalInfo) {
        TreeListSubItems.Text[1] = lpAdditionalInfo;
    }
    else {
        TreeListSubItems.Text[1] = T_EmptyString;
    }

    supTreeListAddItem(
        TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        szAddress,
        &TreeListSubItems);
}

/*
* DumpPsCallbacks
*
* Purpose:
*
* Read Psp* callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPsCallbacks)
{
    ULONG c;
    ULONG_PTR Address, Function;
    EX_FAST_REF Callbacks[PspNotifyRoutinesLimit];
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    RtlSecureZeroMemory(Callbacks, sizeof(Callbacks));
    if (kdReadSystemMemory(KernelVariableAddress,
        &Callbacks, sizeof(Callbacks)))
    {
        for (c = 0; c < PspNotifyRoutinesLimit; c++) {

            if (Callbacks[c].Value) {

                Address = (ULONG_PTR)ObGetObjectFastReference(Callbacks[c]);
                Function = (ULONG_PTR)ObGetCallbackBlockRoutine((PVOID)Address);
                if (Function < g_kdctx.SystemRangeStart)
                    continue;

                AddEntryToList(TreeList,
                    RootItem,
                    Function,
                    NULL,
                    Modules);
            }
        }
    }
}

/*
* DumpDbgkLCallbacks
*
* Purpose:
*
* Read DbgkL* callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpDbgkLCallbacks)
{
    ULONG c;
    ULONG_PTR Address, Function;
    EX_FAST_REF Callbacks[DbgkLmdCount];
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    RtlSecureZeroMemory(Callbacks, sizeof(Callbacks));
    if (kdReadSystemMemory(KernelVariableAddress,
        &Callbacks, sizeof(Callbacks)))
    {
        for (c = 0; c < DbgkLmdCount; c++) {
            if (Callbacks[c].Value > g_kdctx.SystemRangeStart) {
                Address = (ULONG_PTR)ObGetObjectFastReference(Callbacks[c]);
                Function = (ULONG_PTR)ObGetCallbackBlockRoutine((PVOID)Address);
                if (Function < g_kdctx.SystemRangeStart)
                    continue;

                AddEntryToList(TreeList,
                    RootItem,
                    Function,
                    NULL,
                    Modules);
            }
        }
    }
}

/*
* DumpPsAltSystemCallHandlers
*
* Purpose:
*
* Read PsAltSystemCallHandlers data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPsAltSystemCallHandlers)
{
    ULONG i;
    ULONG_PTR AltSystemCallHandlers[MAX_ALT_SYSTEM_CALL_HANDLERS];
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    RtlSecureZeroMemory(AltSystemCallHandlers, sizeof(AltSystemCallHandlers));
    if (kdReadSystemMemory(KernelVariableAddress,
        &AltSystemCallHandlers, sizeof(AltSystemCallHandlers)))
    {
        for (i = 0; i < MAX_ALT_SYSTEM_CALL_HANDLERS; i++) {
            if (AltSystemCallHandlers[i] > g_kdctx.SystemRangeStart) {

                AddEntryToList(TreeList,
                    RootItem,
                    AltSystemCallHandlers[i],
                    NULL,
                    Modules);
            }
        }
    }
}

/*
* DumpKeBugCheckCallbacks
*
* Purpose:
*
* Read KeBugCheck callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpKeBugCheckCallbacks)
{
    ULONG_PTR ListHead = KernelVariableAddress;
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry;
    KBUGCHECK_CALLBACK_RECORD CallbackRecord;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&CallbackRecord, sizeof(CallbackRecord));

        if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
            &CallbackRecord,
            sizeof(CallbackRecord)))
        {
            break;
        }

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)CallbackRecord.CallbackRoutine,
            NULL,
            Modules);

        if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackRecord.Entry.Flink, "KeBugCheckCallbacks NULL Flink"))
            break;
    }
}

/*
* KeBugCheckReasonToString
*
* Purpose:
*
* Return Reason as text constant.
*
*/
LPWSTR KeBugCheckReasonToString(
    _In_ KBUGCHECK_CALLBACK_REASON Reason)
{
    switch (Reason) {
    case KbCallbackInvalid:
        return TEXT("KbCallbackInvalid");

    case KbCallbackReserved1:
        return TEXT("KbCallbackReserved1");

    case KbCallbackSecondaryDumpData:
        return TEXT("KbCallbackSecondaryDumpData");

    case KbCallbackDumpIo:
        return TEXT("KbCallbackDumpIo");

    case KbCallbackAddPages:
        return TEXT("KbCallbackAddPages");

    case KbCallbackSecondaryMultiPartDumpData:
        return TEXT("KbCallbackSecondaryMultiPartDumpData");

    case KbCallbackRemovePages:
        return TEXT("KbCallbackRemovePages");
    case KbCallbackTriageDumpData:
        return TEXT("KbCallbackTriageDumpData");

    }
    return NULL;
}

/*
* DumpKeBugCheckReasonCallbacks
*
* Purpose:
*
* Read KeBugCheckReason callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpKeBugCheckReasonCallbacks)
{
    ULONG_PTR ListHead = KernelVariableAddress;
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry;
    KBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&CallbackRecord, sizeof(CallbackRecord));

        if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
            &CallbackRecord,
            sizeof(CallbackRecord)))
        {
            break;
        }

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)CallbackRecord.CallbackRoutine,
            KeBugCheckReasonToString(CallbackRecord.Reason),
            Modules);

        if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackRecord.Entry.Flink, "KeBugCheckReasonCallbacks NULL Flink"))
            break;
    }
}

/*
* DumpCmCallbacks
*
* Purpose:
*
* Read Cm Registry callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpCmCallbacks)
{
    ULONG_PTR ListHead = KernelVariableAddress;
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry;
    CM_CALLBACK_CONTEXT_BLOCK CallbackRecord;
    HTREEITEM RootItem;
    WCHAR szCookie[100];

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    RtlSecureZeroMemory(&szCookie, sizeof(szCookie));

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&CallbackRecord, sizeof(CallbackRecord));

        if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
            &CallbackRecord,
            sizeof(CallbackRecord)))
        {
            break;
        }

        RtlStringCchPrintfSecure(szCookie,
            RTL_NUMBER_OF(szCookie),
            TEXT("Cookie: 0x%llX"),
            CallbackRecord.Cookie);

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)CallbackRecord.Function,
            szCookie,
            Modules);

        if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackRecord.CallbackListEntry.Flink, "CmCallbacks NULL Flink"))
            break;
    }
}

/*
* DumpIoCallbacks
*
* Purpose:
*
* Read Io related callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpIoCallbacks)
{
    ULONG_PTR ListHead = KernelVariableAddress;
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry;
    SHUTDOWN_PACKET EntryPacket;
    DEVICE_OBJECT DeviceObject;
    DRIVER_OBJECT DriverObject;
    PVOID Routine;
    LPWSTR lpDescription;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&EntryPacket, sizeof(EntryPacket));

        if (!kdReadSystemMemory(
            (ULONG_PTR)ListEntry.Flink,
            &EntryPacket,
            sizeof(EntryPacket)))
        {
            break;
        }

        Routine = EntryPacket.DeviceObject;
        lpDescription = TEXT("PDEVICE_OBJECT");

        //
        // Attempt to query owner of the device object.
        //
        if ((ULONG_PTR)EntryPacket.DeviceObject > g_kdctx.SystemRangeStart) {

            //
            // Read DEVICE_OBJECT.
            //
            RtlSecureZeroMemory(&DeviceObject, sizeof(DeviceObject));

            if (kdReadSystemMemory((ULONG_PTR)EntryPacket.DeviceObject,
                (PVOID)&DeviceObject,
                sizeof(DeviceObject)))
            {
                //
                // Read DRIVER_OBJECT.
                //
                RtlSecureZeroMemory(&DriverObject, sizeof(DriverObject));
                if (kdReadSystemMemory((ULONG_PTR)DeviceObject.DriverObject,
                    (PVOID)&DriverObject,
                    sizeof(DriverObject)))
                {
                    Routine = DriverObject.MajorFunction[IRP_MJ_SHUTDOWN];
                    lpDescription = TEXT("IRP_MJ_SHUTDOWN");
                }
            }
        }

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)Routine,
            lpDescription,
            Modules);

        if (!SET_NEXT_FLINK_CHECK(ListEntry, EntryPacket.ListEntry.Flink, "IoShutdownCallbacks NULL Flink")) 
            break;
    }
}

VOID AddObCallbackEntry(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ LPWSTR CallbackType,
    _In_ PVOID Callback,
    _In_ OB_OPERATION CallbackOperation,
    _In_opt_ LPWSTR Altitude,
    _In_ SIZE_T AltitudeSize,
    _In_ PRTL_PROCESS_MODULES Modules
)
{
    LPWSTR lpText;
    SIZE_T Size;
    BOOL bAltitudePresent = (Altitude && AltitudeSize);

    Size = MAX_PATH * sizeof(WCHAR);
    if (bAltitudePresent)
        Size += AltitudeSize;

    lpText = (LPWSTR)supHeapAlloc(Size);
    if (lpText) {
        _strcpy(lpText, CallbackType);

        if (bAltitudePresent) {
            _strcat(lpText, TEXT(", Altitude: "));
            _strcat(lpText, Altitude);
        }

        if (CallbackOperation & OB_OPERATION_HANDLE_CREATE) _strcat(lpText, TEXT(", CreateHandle"));
        if (CallbackOperation & OB_OPERATION_HANDLE_DUPLICATE) _strcat(lpText, TEXT(", DuplicateHandle"));

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)Callback,
            lpText,
            Modules);

        supHeapFree(lpText);
    }
}

/*
* DumpObCallbacks
*
* Purpose:
*
* Read Ob callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpObCallbacks)
{
    ULONG_PTR ListHead = KernelVariableAddress;
    SIZE_T GuardIter = 0;
    LPWSTR lpAltitudeBuffer;
    SIZE_T AltitudeSize = 0;
    LIST_ENTRY ListEntry;
    OB_CALLBACK_CONTEXT_BLOCK CallbackEntry;
    OB_REGISTRATION RegEntry;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);

        lpAltitudeBuffer = NULL;
        RtlSecureZeroMemory(&CallbackEntry, sizeof(CallbackEntry));

        if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
            &CallbackEntry,
            sizeof(OB_CALLBACK_CONTEXT_BLOCK)))
        {
            break;
        }

        //
        // Read Altitude.
        //
        RtlSecureZeroMemory(&RegEntry, sizeof(RegEntry));
        if (kdReadSystemMemory((ULONG_PTR)CallbackEntry.Registration,
            (PVOID)&RegEntry,
            sizeof(OB_REGISTRATION)))
        {
            AltitudeSize = 100 + (SIZE_T)RegEntry.Altitude.Length;
            lpAltitudeBuffer = (LPWSTR)supHeapAlloc(AltitudeSize);
            if (lpAltitudeBuffer) {
                if (!kdReadSystemMemory((ULONG_PTR)RegEntry.Altitude.Buffer,
                    (PVOID)lpAltitudeBuffer,
                    RegEntry.Altitude.Length))
                {
                    _strcpy(lpAltitudeBuffer, TEXT("Cannot read altitude"));
                }
            }
        }

        //
        // Output PreCallback.
        //
        if ((ULONG_PTR)CallbackEntry.PreCallback > g_kdctx.SystemRangeStart) {
            AddObCallbackEntry(TreeList,
                RootItem,
                TEXT("PreCallback"),
                CallbackEntry.PreCallback,
                CallbackEntry.Operations,
                lpAltitudeBuffer,
                AltitudeSize,
                Modules);
        }

        //
        // Output PostCallback.
        //
        if ((ULONG_PTR)CallbackEntry.PostCallback > g_kdctx.SystemRangeStart) {
            AddObCallbackEntry(TreeList,
                RootItem,
                TEXT("PostCallback"),
                CallbackEntry.PostCallback,
                CallbackEntry.Operations,
                lpAltitudeBuffer,
                AltitudeSize,
                Modules);
        }

        if (lpAltitudeBuffer) supHeapFree(lpAltitudeBuffer);
        if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackEntry.CallbackListEntry.Flink, "ObCallbacks NULL Flink"))
            break;
    }
}

/*
* DumpSeFileSystemCallbacks
*
* Purpose:
*
* Read Se related callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpSeFileSystemCallbacks)
{
    ULONG_PTR Next;

    SEP_LOGON_SESSION_TERMINATED_NOTIFICATION SeEntry; // This structure is different for Ex variant but 
    // key callback function field is on the same offset.

    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    //
    // Read head.
    //
    RtlSecureZeroMemory(&SeEntry, sizeof(SeEntry));

    if (!kdReadSystemMemory(KernelVariableAddress,
        (PVOID)&SeEntry,
        sizeof(SeEntry)))
    {
        return;
    }

    //
    // Walk each entry in single linked list.
    //
    Next = (ULONG_PTR)SeEntry.Next;
    while (Next) {
        RtlSecureZeroMemory(&SeEntry, sizeof(SeEntry));
        if (!kdReadSystemMemory(Next,
            (PVOID)&SeEntry,
            sizeof(SeEntry)))
        {
            break;
        }

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)SeEntry.CallbackRoutine,
            NULL,
            Modules);

        Next = (ULONG_PTR)SeEntry.Next;
    }
}

/*
* DumpPoCallbacks
*
* Purpose:
*
* Read Po callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPoCallbacks)
{
    LIST_ENTRY ListEntry;

    union {
        union {
            POP_POWER_SETTING_REGISTRATION_V1* v1;
            POP_POWER_SETTING_REGISTRATION_V2* v2;
        } Versions;
        PBYTE Ref;
    } CallbackData;

    ULONG ReadSize;
    ULONG_PTR ListHead = KernelVariableAddress;
    SIZE_T BufferSize, GuardIter = 0;
    LPWSTR GuidString;
    PVOID Buffer = NULL;
    PVOID CallbackRoutine = NULL;

    GUID EntryGuid;
    UNICODE_STRING ConvertedGuid;

    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Determinate size of structure to read.
    //
    ReadSize = (g_NtBuildNumber >= NT_WIN10_REDSTONE1) ? sizeof(POP_POWER_SETTING_REGISTRATION_V2) : sizeof(POP_POWER_SETTING_REGISTRATION_V1);

    do {
        //
        // Allocate read buffer with enough size.
        // 
        BufferSize = sizeof(POP_POWER_SETTING_REGISTRATION_V1) + sizeof(POP_POWER_SETTING_REGISTRATION_V2);
        Buffer = supHeapAlloc(BufferSize);
        if (Buffer == NULL)
            break;

        CallbackData.Ref = (PBYTE)Buffer;

        //
        // Read head.
        //
        if (!kdReadSystemMemory(
            ListHead,
            &ListEntry,
            sizeof(LIST_ENTRY)))
        {
            break;
        }

        //
        // Walk list entries.
        //
        while ((ULONG_PTR)ListEntry.Flink != ListHead) {
            LIST_ITERATION_GUARD(GuardIter);
            RtlSecureZeroMemory(Buffer, BufferSize);

            if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
                Buffer,
                ReadSize))
            {
                break;
            }

            //
            // Is valid registration entry?
            //
            if (CallbackData.Versions.v1->Tag != PO_POWER_SETTINGS_REGISTRATION_TAG)
                break;

            if (ReadSize == sizeof(POP_POWER_SETTING_REGISTRATION_V2)) {
                CallbackRoutine = CallbackData.Versions.v2->Callback;
                EntryGuid = CallbackData.Versions.v2->Guid;
            }
            else {
                CallbackRoutine = CallbackData.Versions.v1->Callback;
                EntryGuid = CallbackData.Versions.v1->Guid;
            }

            if (CallbackRoutine) {

                if (NT_SUCCESS(RtlStringFromGUID(&EntryGuid, &ConvertedGuid)))
                    GuidString = ConvertedGuid.Buffer;
                else
                    GuidString = NULL;

                AddEntryToList(TreeList,
                    RootItem,
                    (ULONG_PTR)CallbackRoutine,
                    GuidString,
                    Modules);

                if (GuidString)
                    RtlFreeUnicodeString(&ConvertedGuid);

            }

            //
            // Next item address, ListEntry offset version independent.
            //
            if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackData.Versions.v1->Link.Flink, "PoCallbacks NULL Flink"))
                break;
        }

    } while (FALSE);

    if (Buffer) supHeapFree(Buffer);
}

/*
* DumpDbgPrintCallbacks
*
* Purpose:
*
* Read Dbg callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpDbgPrintCallbacks)
{
    ULONG_PTR ListHead = KernelVariableAddress;
    ULONG_PTR RecordAddress;
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry;
    RTL_CALLBACK_REGISTER CallbackRecord;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(ListEntry)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);

        RtlSecureZeroMemory(&CallbackRecord, sizeof(CallbackRecord));
        RecordAddress = (ULONG_PTR)ListEntry.Flink - FIELD_OFFSET(RTL_CALLBACK_REGISTER, ListEntry);
        if (!kdReadSystemMemory((ULONG_PTR)RecordAddress,
            &CallbackRecord,
            sizeof(CallbackRecord)))
        {
            break;
        }

        if (CallbackRecord.DebugPrintCallback) {
            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)CallbackRecord.DebugPrintCallback,
                NULL,
                Modules);
        }

        if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackRecord.ListEntry.Flink, "DbgPrintCallbacks NULL Flink"))
            break;
    }
}

/*
* DumpIoFsRegistrationCallbacks
*
* Purpose:
*
* Read Io File System registration related callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpIoFsRegistrationCallbacks)
{
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry;
    NOTIFICATION_PACKET CallbackRecord;
    ULONG_PTR ListHead = KernelVariableAddress;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&CallbackRecord, sizeof(CallbackRecord));

        if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
            &CallbackRecord,
            sizeof(CallbackRecord)))
        {
            break;
        }

        if (CallbackRecord.NotificationRoutine) {
            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)CallbackRecord.NotificationRoutine,
                NULL,
                Modules);
        }

        if (!SET_NEXT_FLINK_CHECK(ListEntry, CallbackRecord.ListEntry.Flink, "IoFsRegistrationCallbacks NULL Flink"))
            break;
    }
}

/*
* DumpIoFileSystemCallbacks
*
* Purpose:
*
* Read Io File System related callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpIoFileSystemCallbacks)
{
    BOOL bNeedFree;
    SIZE_T GuardIter = 0;
    LIST_ENTRY ListEntry, NextEntry;
    ULONG_PTR ListHead = KernelVariableAddress;
    ULONG_PTR DeviceObjectAddress = 0, BaseAddress = 0;
    DEVICE_OBJECT DeviceObject;
    DRIVER_OBJECT DriverObject;
    LPWSTR lpType;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&DeviceObject, sizeof(DeviceObject));

        DeviceObjectAddress = (ULONG_PTR)ListEntry.Flink - FIELD_OFFSET(DEVICE_OBJECT, Queue);

        //
        // Read DEVICE_OBJECT.
        //
        if (!kdReadSystemMemory(DeviceObjectAddress,
            &DeviceObject,
            sizeof(DeviceObject)))
        {
            break;
        }

        //
        // Additional info column default text.
        //
        lpType = TEXT("PDEVICE_OBJECT");
        BaseAddress = DeviceObjectAddress;
        bNeedFree = FALSE;

        //
        // Read DRIVER_OBJECT.
        //
        RtlSecureZeroMemory(&DriverObject, sizeof(DriverObject));
        if (kdReadSystemMemory((ULONG_PTR)DeviceObject.DriverObject,
            &DriverObject,
            sizeof(DriverObject)))
        {
            //
            // Determinate address to display.
            //
            BaseAddress = (ULONG_PTR)DriverObject.DriverInit;
            if (BaseAddress == 0) {
                BaseAddress = (ULONG_PTR)DriverObject.DriverStart;
            }

            lpType = NULL;

            //
            // Read DRIVER_OBJECT name.
            //
            if (DriverObject.DriverName.Length &&
                DriverObject.DriverName.MaximumLength &&
                DriverObject.DriverName.Buffer)
            {
                lpType = (LPWSTR)supHeapAlloc((SIZE_T)DriverObject.DriverName.Length + sizeof(UNICODE_NULL));
                if (lpType) {
                    bNeedFree = TRUE;
                    if (!kdReadSystemMemory((ULONG_PTR)DriverObject.DriverName.Buffer,
                        lpType,
                        (ULONG)DriverObject.DriverName.Length))
                    {
                        supHeapFree(lpType);
                        lpType = NULL;
                        bNeedFree = FALSE;
                    }
                }
            }
        }

        AddEntryToList(TreeList,
            RootItem,
            BaseAddress,
            lpType, //PDEVICE_OBJECT or DRIVER_OBJECT.DriverName
            Modules);

        if (bNeedFree)
            supHeapFree(lpType);

        //
        // Next ListEntry.
        //
        NextEntry.Blink = NextEntry.Flink = NULL;

        if (!kdReadSystemMemory(
            (ULONG_PTR)ListEntry.Flink,
            &NextEntry,
            sizeof(LIST_ENTRY)))
        {
            break;
        }

        if (!SET_NEXT_FLINK_CHECK(ListEntry, NextEntry.Flink, "IoFileSystemCallbacks NULL Flink"))
            break;
    }
}

/*
* DumpCiCallbacks
*
* Purpose:
*
* Read SeCiCallbacks/g_CiCallbacks related callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpCiCallbacks)
{
    HTREEITEM RootItem;
    PULONG_PTR CallbacksData, DataPtr;
    LPWSTR CallbackName;
    ULONG_PTR CallbacksSize = 0, EffectiveSize;
    ULONG i, c;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    if (g_NtBuildNumber <= NT_WIN7_SP1) {
        CallbacksSize = 3 * sizeof(ULONG_PTR);

        CallbacksData = (PULONG_PTR)supVirtualAlloc((SIZE_T)CallbacksSize);
        if (CallbacksData) {

            if (kdReadSystemMemory(KernelVariableAddress,
                CallbacksData,
                (ULONG)CallbacksSize))
            {
                c = (ULONG)(CallbacksSize / sizeof(ULONG_PTR));
                for (i = 0; i < c; i++) {

                    CallbackName = GetCiRoutineNameFromIndex(i, 0);
                    if (CallbacksData[i]) {
                        AddEntryToList(TreeList,
                            RootItem,
                            CallbacksData[i],
                            CallbackName,
                            Modules);
                    }
                }
            }
            supVirtualFree(CallbacksData);
        }
    }
    else {
        //
        // Probe size element.
        //
        if (!kdReadSystemMemory(KernelVariableAddress,
            &CallbacksSize,
            sizeof(ULONG_PTR)))
        {
            return;
        }

        //
        // Check size.
        //
        if ((CallbacksSize == 0) || (CallbacksSize > PAGE_SIZE))
            return;

        CallbacksData = (PULONG_PTR)supVirtualAlloc((SIZE_T)CallbacksSize);
        if (CallbacksData) {

            if (kdReadSystemMemory(KernelVariableAddress,
                CallbacksData,
                (ULONG)CallbacksSize))
            {
                /*
                * Windows 10/11 x64 structure layout
                *
                * CI_CALLBACKS
                *
                * +0   ULONG_PTR StructureSize (in bytes)
                * +8   PTR Callback1
                * ...
                * +N   PTR CallbackN
                * +N+8 ULONG_PTR Marker
                *
                */
                EffectiveSize = CallbacksSize;
                DataPtr = CallbacksData;

                // skip sizeof element
                DataPtr++;
                EffectiveSize -= sizeof(ULONG_PTR);

                if (g_NtBuildNumber >= NT_WIN10_REDSTONE1)
                    EffectiveSize -= sizeof(ULONG_PTR); //exclude final marker

                c = (ULONG)(EffectiveSize / sizeof(ULONG_PTR));

                for (i = 0; i < c; i++) {
                    CallbackName = GetCiRoutineNameFromIndex(i, CallbacksSize);
                    if (*DataPtr) {
                        AddEntryToList(TreeList,
                            RootItem,
                            *DataPtr,
                            CallbackName,
                            Modules);
                    }
                    DataPtr++;
                }
            }

            supVirtualFree(CallbacksData);
        }
    }
}

/*
* DumpExHostCallbacks
*
* Purpose:
*
* Read ExHostList related callback data from kernel and send it to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpExHostCallbacks)
{
    ULONG HostEntrySize;
    SIZE_T GuardIter = 0;
    ULONG_PTR ListHead = KernelVariableAddress;
    ULONG_PTR* HostTableDump;
    ULONG NumberOfCallbacks, i;
    PVOID NotificationRoutine;
    PVOID FunctionTable, HostEntryBuffer = NULL;
    LIST_ENTRY ListEntry;
    HTREEITEM RootItem;

    union {
        union {
            EX_HOST_ENTRY_V1* v1;
            EX_HOST_ENTRY_V2* v2;
        } Versions;
        PBYTE Ref;
    } hostEntry;

    do {
        // Starting build 26080 (25H2) the structures were updated
        HostEntrySize = (g_NtBuildNumber < NT_WIN11_25H2) ? sizeof(EX_HOST_ENTRY_V1) : sizeof(EX_HOST_ENTRY_V2);
        HostEntryBuffer = supHeapAlloc(HostEntrySize);
        if (HostEntryBuffer == NULL)
            break;

        hostEntry.Ref = (PBYTE)HostEntryBuffer;

        //
        // Add callback root entry to the treelist.
        //
        RootItem = AddRootEntryToList(TreeList, CallbackType);
        if (RootItem == 0)
            break;

        ListEntry.Flink = ListEntry.Blink = NULL;

        //
        // Read head.
        //
        if (!kdReadSystemMemory(
            ListHead,
            &ListEntry,
            sizeof(LIST_ENTRY)))
        {
            break;
        }

        //
        // Walk list entries.
        //
        while ((ULONG_PTR)ListEntry.Flink != ListHead) {
            LIST_ITERATION_GUARD(GuardIter);
            //
            // Since this buffer now allocated, on a first call it will be empty. Zero it when iteration is over.
            //
            if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
                HostEntryBuffer,
                HostEntrySize))
            {
                break;
            }

            // read extension function table
            if (g_NtBuildNumber < NT_WIN11_25H2) {
                NumberOfCallbacks = hostEntry.Versions.v1->HostParameters.HostInformation.FunctionCount;
                NotificationRoutine = hostEntry.Versions.v1->HostParameters.NotificationRoutine;
                FunctionTable = hostEntry.Versions.v1->FunctionTable;
            }
            else
            {
                NumberOfCallbacks = hostEntry.Versions.v2->ExtensionTableFunctionCount;
                NotificationRoutine = hostEntry.Versions.v2->NotificationRoutine;
                FunctionTable = hostEntry.Versions.v2->FunctionTable;
            }

            //
            // Find not an empty host table.
            //
            if (NumberOfCallbacks) {

                if (NotificationRoutine) {
                    AddEntryToList(TreeList,
                        RootItem,
                        (ULONG_PTR)NotificationRoutine,
                        L"NotificationRoutine",
                        Modules);

                }

                //
                // Read function table.
                //
                if (FunctionTable) {
                    HostTableDump = (ULONG_PTR*)supHeapAlloc(NumberOfCallbacks * sizeof(PVOID));
                    if (HostTableDump) {
                        if (kdReadSystemMemory(
                            (ULONG_PTR)FunctionTable,
                            HostTableDump,
                            NumberOfCallbacks * sizeof(PVOID)))
                        {

                            for (i = 0; i < NumberOfCallbacks; i++) {
                                if (HostTableDump[i]) {
                                    AddEntryToList(TreeList,
                                        RootItem,
                                        (ULONG_PTR)HostTableDump[i],
                                        L"Callback",
                                        Modules);
                                }
                            }

                        }
                        supHeapFree(HostTableDump);
                    }
                }
            }

            //
            // ListEntry is on the same offset.
            //
            if (!SET_NEXT_FLINK_CHECK(ListEntry, hostEntry.Versions.v1->ListEntry.Flink, "ExHostCallbacks NULL Flink"))
                break;

            RtlSecureZeroMemory(HostEntryBuffer, HostEntrySize);
        }

    } while (FALSE);

    if (HostEntryBuffer)
        supHeapFree(HostEntryBuffer);
}

/*
* DumpExpCallbackListCallbacks
*
* Purpose:
*
* Read ExCreateCallback created objects from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpExpCallbackListCallbacks)
{
    LIST_ENTRY ListEntry, NextEntry, RegistrationsListEntry;
    CALLBACK_OBJECT_V2 CallbackObject;
    CALLBACK_REGISTRATION CallbackRegistration;
    SIZE_T GuardIter = 0, GuardSubIter;
    ULONG_PTR ListHead = KernelVariableAddress, RegistrationsListHead;
    ULONG_PTR CallbackObjectAddress;
    HTREEITEM RootItem, SubItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&CallbackObject, sizeof(CallbackObject));

        CallbackObjectAddress = (ULONG_PTR)ListEntry.Flink - FIELD_OFFSET(CALLBACK_OBJECT_V2, ExpCallbackList);

        if (!kdReadSystemMemory(CallbackObjectAddress,
            &CallbackObject,
            sizeof(CallbackObject))
            ||
            CallbackObject.Signature != EX_CALLBACK_SIGNATURE)
        {
            break;
        }

        SubItem = AddParentEntryToList(
            TreeList,
            RootItem,
            CallbackObjectAddress,
            TEXT("Callback object"));
        if (SubItem == 0)
            break;

        //
        // Walk RegisteredCallbacks list entry.
        //
        GuardSubIter = 0;
        RegistrationsListHead = CallbackObjectAddress + FIELD_OFFSET(CALLBACK_OBJECT_V2, RegisteredCallbacks);
        RegistrationsListEntry.Flink = CallbackObject.RegisteredCallbacks.Flink;
        while ((ULONG_PTR)RegistrationsListEntry.Flink != RegistrationsListHead) {
            LIST_ITERATION_GUARD(GuardSubIter);
            //
            // Read callback registration data.
            //
            RtlSecureZeroMemory(&CallbackRegistration, sizeof(CallbackRegistration));
            if (!kdReadSystemMemory((ULONG_PTR)RegistrationsListEntry.Flink,
                (PVOID)&CallbackRegistration,
                sizeof(CallbackRegistration)))
            {
                break;
            }

            AddEntryToList(TreeList,
                SubItem,
                (ULONG_PTR)CallbackRegistration.CallbackFunction,
                TEXT("Callback registration"),
                Modules);

            if (!SET_NEXT_FLINK_CHECK(RegistrationsListEntry, CallbackRegistration.Link.Flink, "ExpCallbackRegistrationsList(1) NULL Flink"))
                break;
        }

        //
        // Next ListEntry.
        //
        NextEntry.Blink = NextEntry.Flink = NULL;

        if (!kdReadSystemMemory(
            (ULONG_PTR)ListEntry.Flink,
            &NextEntry,
            sizeof(LIST_ENTRY)))
        {
            break;
        }

        if (!SET_NEXT_FLINK_CHECK(ListEntry, NextEntry.Flink, "ExpCallbackRegistrationsList(2) NULL Flink"))
            break;
    }
}

/*
* DumpPoCoalescingCallbacks
*
* Purpose:
*
* Read PoRegisterCoalescingCallback created objects from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPoCoalescingCallbacks)
{
    ULONG CallbacksCount, i;
    SIZE_T GuardIter = 0;
    ULONG_PTR ListHead = KernelVariableAddress;
    ULONG_PTR objectFastRef, callbackAddress;
    LIST_ENTRY ListEntry;

    union {
        PO_COALESCING_CALLBACK_V1 v1;
        PO_COALESCING_CALLBACK_V2 v2;
    } callbackObject;

    EX_FAST_REF Callbacks[PopCoalescingCallbackRoutineCount_V2];
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    //
    // Before Win10 RS4 this list implemented as the array of the fixed size.
    //
    if (g_NtBuildNumber < NT_WIN10_REDSTONE4) {
        RtlSecureZeroMemory(Callbacks, sizeof(Callbacks));

        //
        // Before Win10 RS3 this list is limited to 8 callbacks.
        // In Win10 RS3 this list increased up to 32 callbacks.
        //
        CallbacksCount = (g_NtBuildNumber < NT_WIN10_REDSTONE3) ? PopCoalescingCallbackRoutineCount_V1 : PopCoalescingCallbackRoutineCount_V2;
        if (kdReadSystemMemory(KernelVariableAddress,
            &Callbacks,
            CallbacksCount * sizeof(EX_FAST_REF)))
        {
            for (i = 0; i < CallbacksCount; i++) {
                if (Callbacks[i].Value) {
                    objectFastRef = (ULONG_PTR)ObGetObjectFastReference(Callbacks[i]);
                    RtlSecureZeroMemory(&callbackObject, sizeof(callbackObject));

                    if (kdReadSystemMemory(objectFastRef,
                        &callbackObject.v1,
                        sizeof(callbackObject.v1)))
                    {
                        AddEntryToList(TreeList,
                            RootItem,
                            (ULONG_PTR)callbackObject.v1.Callback,
                            L"CoalescingCallback",
                            Modules);
                    }
                }
            }
        }
    }
    else
    {
        ListEntry.Flink = ListEntry.Blink = NULL;

        //
        // Read head.
        //
        if (!kdReadSystemMemory(
            ListHead,
            &ListEntry,
            sizeof(LIST_ENTRY)))
        {
            return;
        }

        //
        // Walk list entries.
        //
        while ((ULONG_PTR)ListEntry.Flink != ListHead) {
            LIST_ITERATION_GUARD(GuardIter);
            RtlSecureZeroMemory(&callbackObject, sizeof(callbackObject));

            callbackAddress = (ULONG_PTR)ListEntry.Flink - FIELD_OFFSET(PO_COALESCING_CALLBACK_V2, Link);
            if (!kdReadSystemMemory(callbackAddress,
                &callbackObject.v2,
                sizeof(callbackObject.v2)))
            {
                break;
            }

            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)callbackObject.v2.Callback,
                L"CoalescingCallback",
                Modules);

            if (!SET_NEXT_FLINK_CHECK(ListEntry, callbackObject.v2.Link.Flink, "CoalescingCallback NULL Flink"))
                break;
        }
    }
}

LPWSTR PspPicoProviderNameFromIndex(
    _In_ SIZE_T Index
)
{
    LPWSTR LxpNames[] = {
        L"PicoSystemCallDispatch",
        L"PicoThreadExit",
        L"PicoProcessExit",
        L"PicoDispatchException",
        L"PicoProcessTerminate",
        L"PicoWalkUserStack",
        L"LxpProtectedRanges",
        L"PicoGetAllocatedProcessImageName"
    };

    if (Index >= RTL_NUMBER_OF(LxpNames))
        return T_Unknown;

    return LxpNames[Index];
}

/*
* DumpPspPicoProviderRoutines
*
* Purpose:
*
* Read PspPicoProviderRoutines data from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPspPicoProviderRoutines)
{
    SIZE_T i, c;
    PULONG_PTR picoRoutines;
    SIZE_T dataSize;
    HTREEITEM RootItem;

    if (!supIsLxssAvailable())
        return;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    dataSize = 0;
    if (kdReadSystemMemory(KernelVariableAddress,
        &dataSize,
        sizeof(dataSize)))
    {
        if (dataSize < 2 * sizeof(SIZE_T) ||
            dataSize > PAGE_SIZE)
        {
            return;
        }

        dataSize -= sizeof(SIZE_T); //exclude size element

        picoRoutines = (PULONG_PTR)supHeapAlloc(ALIGN_UP(dataSize, PULONG_PTR));
        if (picoRoutines) {
            if (kdReadSystemMemory(KernelVariableAddress + sizeof(SIZE_T),
                picoRoutines,
                (ULONG)dataSize))
            {
                c = dataSize / sizeof(ULONG_PTR);
                for (i = 0; i < c; i++) {
                    if (picoRoutines[i] > g_kdctx.SystemRangeStart) {
                        AddEntryToList(TreeList,
                            RootItem,
                            (ULONG_PTR)picoRoutines[i],
                            PspPicoProviderNameFromIndex(i),
                            Modules);
                    }
                }
            }
            supHeapFree(picoRoutines);
        }
    }
}

/*
* DumpKiNmiCallbackListHead
*
* Purpose:
*
* Read NMI callback list from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpKiNmiCallbackListHead)
{
    SIZE_T GuardIter = 0;
    ULONG_PTR Next;
    KNMI_HANDLER_CALLBACK NmiEntry;
    HTREEITEM RootItem;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    //
    // Read head.
    //
    RtlSecureZeroMemory(&NmiEntry, sizeof(NmiEntry));

    if (!kdReadSystemMemory(KernelVariableAddress,
        (PVOID)&NmiEntry,
        sizeof(NmiEntry)))
    {
        return;
    }

    //
    // Walk each entry in single linked list.
    //
    Next = (ULONG_PTR)NmiEntry.Next;
    while (Next) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&NmiEntry, sizeof(NmiEntry));

        if (!kdReadSystemMemory(Next,
            (PVOID)&NmiEntry,
            sizeof(NmiEntry)))
        {
            break;
        }

        AddEntryToList(TreeList,
            RootItem,
            (ULONG_PTR)NmiEntry.Callback,
            NULL,
            Modules);

        Next = (ULONG_PTR)NmiEntry.Next;
    }
}

/*
* DumpPspSiloMonitorList
*
* Purpose:
*
* Read Silo monitor callbacks from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPspSiloMonitorList)
{
    SIZE_T GuardIter = 0;
    ULONG_PTR ListHead = KernelVariableAddress;
    LIST_ENTRY ListEntry;
    HTREEITEM RootItem;
    SERVER_SILO_MONITOR SiloMonitor;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&SiloMonitor, sizeof(SiloMonitor));

        if (!kdReadSystemMemory(
            (ULONG_PTR)ListEntry.Flink,
            &SiloMonitor,
            sizeof(SiloMonitor)))
        {
            break;
        }

        if (SiloMonitor.CreateCallback != NULL) {
            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)SiloMonitor.CreateCallback,
                L"CreateCallback",
                Modules);
        }

        if (SiloMonitor.TerminateCallback != NULL) {
            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)SiloMonitor.TerminateCallback,
                L"TerminateCallback",
                Modules);
        }

        if (!SET_NEXT_FLINK_CHECK(ListEntry, SiloMonitor.ListEntry.Flink, "SiloMonitor NULL Flink"))
            break;
    }
}

/*
* DumpEmpCallbackListHead
*
* Purpose:
*
* Read Errata Manager callbacks from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpEmpCallbackListHead)
{
    SIZE_T GuardIter = 0;
    LPWSTR GuidString;
    ULONG_PTR ListHead = KernelVariableAddress, Next, RecordAddress;
    SINGLE_LIST_ENTRY Head;
    HTREEITEM RootItem;
    EMP_CALLBACK_DB_RECORD CallbackRecord;
    UNICODE_STRING ConvertedGuid;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    //
    // Read head.
    //
    Head.Next = NULL;
    if (!kdReadSystemMemory(
        ListHead,
        &Head,
        sizeof(SINGLE_LIST_ENTRY)))
    {
        return;
    }

    Next = (ULONG_PTR)Head.Next;
    while (Next) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&CallbackRecord, sizeof(CallbackRecord));
        RecordAddress = (ULONG_PTR)Next - FIELD_OFFSET(EMP_CALLBACK_DB_RECORD, List);

        if (!kdReadSystemMemory(RecordAddress, &CallbackRecord, sizeof(CallbackRecord)))
            break;

        if (NT_SUCCESS(RtlStringFromGUID(&CallbackRecord.CallbackId, &ConvertedGuid)))
            GuidString = ConvertedGuid.Buffer;
        else
            GuidString = NULL;

        if (CallbackRecord.CallbackFunc) {
            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)CallbackRecord.CallbackFunc,
                GuidString,
                Modules);
        }
        else {
            AddEmptyEntryToList(TreeList,
                RootItem,
                GuidString);
        }

        if (GuidString)
            RtlFreeUnicodeString(&ConvertedGuid);

        Next = (ULONG_PTR)CallbackRecord.List.Next;
    }
}

/*
* DumpPnpDeviceClassNotifyList
*
* Purpose:
*
* Dump Pnp manager notify list from kernel and send them to output window.
*
*/
OBEX_DISPLAYCALLBACK_ROUTINE(DumpPnpDeviceClassNotifyList)
{
    SIZE_T GuardIter = 0;
    ULONG_PTR ListHead = KernelVariableAddress;
    LPWSTR GuidString;
    LIST_ENTRY ListEntry;
    HTREEITEM RootItem;
    DEVICE_CLASS_NOTIFY_ENTRY NotifyEntry;
    UNICODE_STRING ConvertedGuid;

    //
    // Add callback root entry to the treelist.
    //
    RootItem = AddRootEntryToList(TreeList, CallbackType);
    if (RootItem == 0)
        return;

    ListEntry.Flink = ListEntry.Blink = NULL;

    //
    // Read head.
    //
    if (!kdReadSystemMemory(
        ListHead,
        &ListEntry,
        sizeof(LIST_ENTRY)))
    {
        return;
    }

    //
    // Walk list entries.
    //
    while ((ULONG_PTR)ListEntry.Flink != ListHead) {
        LIST_ITERATION_GUARD(GuardIter);
        RtlSecureZeroMemory(&NotifyEntry, sizeof(NotifyEntry));

        if (!kdReadSystemMemory(
            (ULONG_PTR)ListEntry.Flink,
            &NotifyEntry,
            sizeof(NotifyEntry)))
        {
            break;
        }

        if (NotifyEntry.CallbackRoutine != NULL) {
            if (NT_SUCCESS(RtlStringFromGUID(&NotifyEntry.ClassGuid, &ConvertedGuid)))
                GuidString = ConvertedGuid.Buffer;
            else
                GuidString = NULL;

            AddEntryToList(TreeList,
                RootItem,
                (ULONG_PTR)NotifyEntry.CallbackRoutine,
                GuidString,
                Modules);

            if (GuidString)
                RtlFreeUnicodeString(&ConvertedGuid);
        }

        if (!SET_NEXT_FLINK_CHECK(ListEntry, NotifyEntry.ListEntry.Flink, "PnpDeviceClassNotifyList NULL Flink"))
            break;
    }
}

/*
* QueryIopFsListsCallbacks
*
* Purpose:
*
* Query and list Io Fs lists callbacks.
*
*/
OBEX_QUERYCALLBACK_ROUTINE(QueryIopFsListsCallbacks)
{
    UNREFERENCED_PARAMETER(QueryFlags);
    UNREFERENCED_PARAMETER(CallbackType);
    UNREFERENCED_PARAMETER(FindRoutine);
    UNREFERENCED_PARAMETER(SystemCallbacksRef);

    if ((g_SystemCallbacks.IopCdRomFileSystemQueueHead == 0) ||
        (g_SystemCallbacks.IopDiskFileSystemQueueHead == 0) ||
        (g_SystemCallbacks.IopTapeFileSystemQueueHead == 0) ||
        (g_SystemCallbacks.IopNetworkFileSystemQueueHead == 0))
    {
        if (!FindIopFileSystemQueueHeads(&g_SystemCallbacks.IopCdRomFileSystemQueueHead,
            &g_SystemCallbacks.IopDiskFileSystemQueueHead,
            &g_SystemCallbacks.IopTapeFileSystemQueueHead,
            &g_SystemCallbacks.IopNetworkFileSystemQueueHead))
        {
            kdReportErrorByFunction(__FUNCTIONW__, TEXT("Could not locate all Iop ListHeads"));
            return STATUS_NOT_FOUND;
        }
    }

    if (g_SystemCallbacks.IopDiskFileSystemQueueHead) {
        DisplayRoutine(TreeList,
            TEXT("IoDiskFs"),
            g_SystemCallbacks.IopDiskFileSystemQueueHead,
            Modules);
    }
    if (g_SystemCallbacks.IopCdRomFileSystemQueueHead) {
        DisplayRoutine(TreeList,
            TEXT("IoCdRomFs"),
            g_SystemCallbacks.IopCdRomFileSystemQueueHead,
            Modules);
    }
    if (g_SystemCallbacks.IopNetworkFileSystemQueueHead) {
        DisplayRoutine(TreeList,
            TEXT("IoNetworkFs"),
            g_SystemCallbacks.IopNetworkFileSystemQueueHead,
            Modules);
    }
    if (g_SystemCallbacks.IopTapeFileSystemQueueHead) {
        DisplayRoutine(TreeList,
            TEXT("IoTapeFs"),
            g_SystemCallbacks.IopTapeFileSystemQueueHead,
            Modules);
    }
    return STATUS_SUCCESS;
}

/*
* QueryCallbackGeneric
*
* Purpose:
*
* Query and list kernel mode data for most types of callbacks/notifies.
*
*/
OBEX_QUERYCALLBACK_ROUTINE(QueryCallbackGeneric)
{
    ULONG_PTR QueryAddress = 0;

    //
    // All parameters must be valid for this variant of Query callback.
    //
    if ((DisplayRoutine == NULL) ||
        (FindRoutine == NULL) ||
        (SystemCallbacksRef == NULL) ||
        (CallbackType == NULL))
    {
        return STATUS_INVALID_PARAMETER;
    }

    __try {

        QueryAddress = *SystemCallbacksRef;

        if (QueryAddress == 0)
            QueryAddress = FindRoutine(QueryFlags);

        *SystemCallbacksRef = QueryAddress;

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }

    __try {
        if (QueryAddress) {
            DisplayRoutine(
                TreeList,
                CallbackType,
                QueryAddress,
                Modules);
        }
        else
            return STATUS_NOT_FOUND;
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }

    return STATUS_SUCCESS;
}

/*
* DisplayCallbacksList
*
* Purpose:
*
* Find callbacks pointers and list them to output window.
*
*/
VOID DisplayCallbacksList(
    _In_ HWND TreeList,
    _In_ HWND StatusBar)
{
    ULONG i;
    NTSTATUS QueryStatus;
    PRTL_PROCESS_MODULES Modules = NULL;
    PWSTR lpStatusMsg;
    WCHAR szText[200];

    do {
        if (g_kdctx.NtOsImageMap == NULL) {
            lpStatusMsg = TEXT("Error, ntoskrnl image is not mapped!");
            supStatusBarSetText(StatusBar, 1, lpStatusMsg);
            break;
        }

        Modules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
        if (Modules == NULL) {
            lpStatusMsg = TEXT("Could not allocate memory for modules list!");
            supStatusBarSetText(StatusBar, 1, lpStatusMsg);
            break;
        }

        //
        // List callbacks.
        //
        for (i = 0; i < RTL_NUMBER_OF(g_CallbacksDispatchTable); i++) {
            QueryStatus = g_CallbacksDispatchTable[i].QueryRoutine(
                g_CallbacksDispatchTable[i].QueryFlags,
                g_CallbacksDispatchTable[i].DisplayRoutine,
                g_CallbacksDispatchTable[i].FindRoutine,
                g_CallbacksDispatchTable[i].CallbackType,
                TreeList,
                Modules,
                g_CallbacksDispatchTable[i].SystemCallbacksRef);

            if (!NT_SUCCESS(QueryStatus)) {

                if (QueryStatus == STATUS_NOT_FOUND) {
#ifdef _DEBUG
                    RtlStringCchPrintfSecure(szText,
                        RTL_NUMBER_OF(szText),
                        TEXT("Callback type %ws was not found"),
                        g_CallbacksDispatchTable[i].CallbackType);

                    logAdd(EntryTypeWarning, szText);
#endif
                }
                else {
                    RtlStringCchPrintfSecure(szText,
                        RTL_NUMBER_OF(szText),
                        TEXT("Callback type %ws, error 0x%lX"),
                        g_CallbacksDispatchTable[i].CallbackType,
                        QueryStatus);

                    logAdd(EntryTypeError, szText);
                    supStatusBarSetText(StatusBar, 1, (LPWSTR)&szText);
                }
            }
        }

        //
        // Show total number of callbacks.
        //
        _strcpy(szText, TEXT("Total listed callbacks: "));
        ultostr(g_CallbacksCount, _strend(szText));
        supStatusBarSetText(StatusBar, 0, (LPWSTR)&szText);

    } while (FALSE);

    if (Modules) supHeapFree(Modules);
    SetFocus(TreeList);
}

/*
* SysCbDialogHandlePopupMenu
*
* Purpose:
*
* Treelist popup construction
*
*/
VOID SysCbDialogHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ EXTRASCONTEXT* pDlgContext,
    _In_ LPARAM lParam
)
{
    UINT uPos = 0;
    HMENU hMenu;
    POINT pt1;

    if (GetCursorPos(&pt1) == FALSE)
        return;

    hMenu = CreatePopupMenu();
    if (hMenu) {
        if (supTreeListAddCopyValueItem(hMenu,
            pDlgContext->TreeList,
            ID_OBJECT_COPY,
            uPos++,
            lParam,
            &pDlgContext->tlSubItemHit))
        {
            InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }
        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_VIEW_REFRESH, T_VIEW_REFRESH);
        TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, pt1.x, pt1.y, 0, hwndDlg, NULL);
        DestroyMenu(hMenu);
    }
}

/*
* SysCbDialogResize
*
* Purpose:
*
* WM_SIZE handler.
*
*/
INT_PTR SysCbDialogResize(
    _In_ HWND hwndDlg,
    _In_ HWND hwndStatusBar,
    _In_ HWND hwndTreeList
)
{
    RECT r, szr;

    RtlSecureZeroMemory(&r, sizeof(RECT));
    RtlSecureZeroMemory(&szr, sizeof(RECT));

    GetClientRect(hwndDlg, &r);
    GetClientRect(hwndStatusBar, &szr);

    SendMessage(hwndStatusBar, WM_SIZE, 0, 0);

    SetWindowPos(hwndTreeList, 0, 0, 0,
        r.right,
        r.bottom - szr.bottom,
        SWP_NOZORDER);

    return 1;
}

/*
* SysCbDialogContentRefresh
*
* Purpose:
*
* Refresh callback list handler.
*
*/
VOID SysCbDialogContentRefresh(
    _In_ HWND hwndDlg,
    _In_ EXTRASCONTEXT* pDlgContext,
    _In_ BOOL fResetContent
)
{
    UNREFERENCED_PARAMETER(hwndDlg);
    if (fResetContent)
        TreeList_ClearTree(pDlgContext->TreeList);
    g_CallbacksCount = 0;
    supTreeListEnableRedraw(pDlgContext->TreeList, FALSE);
    DisplayCallbacksList(pDlgContext->TreeList, pDlgContext->StatusBar);
    supTreeListEnableRedraw(pDlgContext->TreeList, TRUE);
}

/*
* SysCbDialogOnInit
*
* Purpose:
*
* WM_INITDIALOG handler.
*
*/
VOID SysCbDialogOnInit(
    _In_ HWND hwndDlg,
    _In_  LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParam;
    RECT rc;
    HDITEM hdritem;
    INT SbParts[] = { 200, -1 };

    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)lParam);

    pDlgContext->hwndDlg = hwndDlg;
    pDlgContext->StatusBar = GetDlgItem(hwndDlg, ID_EXTRASLIST_STATUSBAR);
    SendMessage(pDlgContext->StatusBar, SB_SETPARTS, 2, (LPARAM)&SbParts);

    extrasSetDlgIcon(pDlgContext);
    SetWindowText(hwndDlg, TEXT("System Callbacks"));

    GetClientRect(g_hwndMain, &rc);
    pDlgContext->TreeList = CreateWindowEx(WS_EX_STATICEDGE, WC_TREELIST, NULL,
        WS_VISIBLE | WS_CHILD | WS_TABSTOP | TLSTYLE_COLAUTOEXPAND | TLSTYLE_LINKLINES, 12, 14,
        rc.right - 24, rc.bottom - 24, hwndDlg, NULL, NULL, NULL);

    if (pDlgContext->TreeList) {
        RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
        hdritem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
        hdritem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;
        hdritem.cxy = 160;
        hdritem.pszText = TEXT("Routine Address");
        TreeList_InsertHeaderItem(pDlgContext->TreeList, 0, &hdritem);

        hdritem.cxy = 300;
        hdritem.pszText = TEXT("Module");
        TreeList_InsertHeaderItem(pDlgContext->TreeList, 1, &hdritem);

        hdritem.cxy = 200;
        hdritem.pszText = TEXT("Additional Information");
        TreeList_InsertHeaderItem(pDlgContext->TreeList, 2, &hdritem);

        SysCbDialogContentRefresh(hwndDlg, pDlgContext, FALSE);
    }

    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
    SendMessage(hwndDlg, WM_SIZE, 0, 0);
}

/*
* SysCbDialogProc
*
* Purpose:
*
* Callbacks Dialog window procedure.
*
*/
INT_PTR CALLBACK SysCbDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext;

    switch (uMsg) {

    case WM_INITDIALOG:
        SysCbDialogOnInit(hwndDlg, lParam);
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                CBDLG_TRACKSIZE_MIN_X,
                CBDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_SIZE:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            SysCbDialogResize(hwndDlg, pDlgContext->StatusBar, pDlgContext->TreeList);
        }
        break;

    case WM_CLOSE:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasRemoveDlgIcon(pDlgContext);
            supHeapFree(pDlgContext);
        }
        DestroyWindow(hwndDlg);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_OBJECT_COPY:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {

                supTreeListCopyItemValueToClipboard(pDlgContext->TreeList,
                    pDlgContext->tlSubItemHit);

            }
            break;

        case ID_VIEW_REFRESH:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {
                SysCbDialogContentRefresh(hwndDlg, pDlgContext, TRUE);
            }
            break;

        }
        break;

    case WM_CONTEXTMENU:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            SysCbDialogHandlePopupMenu(hwndDlg, pDlgContext, lParam);
        }
        break;

    }

    return FALSE;
}

/*
* extrasSysCbDialogWorkerThread
*
* Purpose:
*
* Callbacks Dialog worker thread.
*
*/
DWORD extrasSysCbDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    HWND hwndDlg;
    BOOL bResult;
    MSG message;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)Parameter;
    HACCEL acceleratorTable;

    hwndDlg = CreateDialogParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_CALLBACKS),
        0,
        &SysCbDialogProc,
        (LPARAM)pDlgContext);

    acceleratorTable = LoadAccelerators(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

    supSetFastEvent(&SysCbInitializedEvent);

    do {

        bResult = GetMessage(&message, NULL, 0, 0);
        if (bResult == -1)
            break;

        if (IsDialogMessage(hwndDlg, &message)) {
            TranslateAccelerator(hwndDlg, acceleratorTable, &message);
        }
        else {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }

    } while (bResult != 0);

    supResetFastEvent(&SysCbInitializedEvent);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    if (SysCbThreadHandle) {
        NtClose(SysCbThreadHandle);
        SysCbThreadHandle = NULL;
    }

    return 0;
}

/*
* extrasCreateCallbacksDialog
*
* Purpose:
*
* Create and initialize Callbacks Dialog.
*
*/
VOID extrasCreateCallbacksDialog(
    VOID
)
{
    EXTRASCONTEXT* pDlgContext;

    if (!SysCbThreadHandle) {
        pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
        if (pDlgContext) {
            pDlgContext->tlSubItemHit = -1;
            SysCbThreadHandle = supCreateDialogWorkerThread(extrasSysCbDialogWorkerThread, pDlgContext, 0);
            if (SysCbThreadHandle == NULL) {
                supHeapFree(pDlgContext);
                return;
            }
            supWaitForFastEvent(&SysCbInitializedEvent, NULL);
        }
    }
}

```

`Source/WinObjEx64/extras/extrasCallbacksPatterns.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       EXTRASCALLBACKSPATTERNS.H
*
*  VERSION:     2.07
*
*  DATE:        14 May 2025
*
*  Header with search patterns used by Callbacks dialog routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// PsAltSystemCallHandlers
//
#define MAX_ALT_SYSTEM_CALL_HANDLERS 2

BYTE PsAltSystemCallHandlersPattern[] = {
    0x4C, 0x8D, 0x35
};


/*+++

 SeCiCallbacks search patterns

+++*/

//Windows 8/8.1
BYTE SeCiCallbacksPattern_9200_9600[] = {
    0x48, 0x83, 0xEC, 0x20, 0xBF, 0x06, 0x00, 0x00, 0x00
};

//Windows 10 TH1/TH2
BYTE SeCiCallbacksPattern_10240_10586[] = {
    0x48, 0x83, 0xEC, 0x20, 0xBB, 0x98, 0x00, 0x00, 0x00
};

//Windows 10 RS1
BYTE SeCiCallbacksPattern_14393[] = {
    0x48, 0x83, 0xEC, 0x20, 0xBB, 0xB0, 0x00, 0x00, 0x00
};

//Windows 10 RS2/RS3
BYTE SeCiCallbacksPattern_15063_16299[] = {
    0x48, 0x83, 0xEC, 0x20, 0xBB, 0xC0, 0x00, 0x00, 0x00
};

//Windows 10 RS4/RS5
BYTE SeCiCallbacksPattern_17134_17763[] = {
    0x48, 0x83, 0xEC, 0x20, 0xBB, 0xD0, 0x00, 0x00, 0x00
};

// Instruction match pattern
BYTE SeCiCallbacksMatchingPattern[] = {
    0x48, 0x8D, 0x0D
};

//Windows 7
BYTE g_CiCallbacksPattern_7601[] = {
    0x8D, 0x7B, 0x06, 0x48, 0x89, 0x05
};

BYTE g_CiCallbacksMatchingPattern[] = {
    0x48, 0x89, 0x05
};

#define LEA_INSTRUCTION_LENGTH_7B 7
#define CI_CALLBACKS_3BYTE_INSTRUCTION_SIZE 3

/*+++

 EmpSearchCallbackDatabase search pattern

+++*/
BYTE g_EmpSearchCallbackDatabase[] = { 0x48, 0x8B, 0x4E, 0xF8, 0x48, 0x85, 0xC9 };
BYTE g_EmpSearchCallbackDatabase2[] = { 0x49, 0x8B, 0x4A, 0xF8, 0x48, 0x85, 0xC9 };
BYTE g_EmpSearchCallbackDatabase3[] = { 0x4B, 0x8B, 0x0C, 0xDC, 0x48, 0x85, 0xC9, 0x74, 0x48 };

/*+++

 ExpFindHost search pattern

+++*/

BYTE g_ExpFindHost22000_22621[] = { 0x41, 0x0F, 0xB7, 0x0E };
BYTE g_ExpFindHost22631_27842[] = { 0x44, 0x89, 0x44, 0x24, 0x78 };

/*+++

 PnpDeviceClassNotifyList search pattern

+++*/

//
// mul ecx
//
BYTE g_PnpDeviceClassNotifyList_SubPattern_7601[] = { 0xF7, 0xE1 };

BYTE g_PnpDeviceClassNotifyList_SubPattern_9200[] = { 0xC1, 0xEA, 0x02, 0x6B, 0xD2, 0x0D };

//
//  shr edx, 2
//  imul eax, edx, 0Dh
//
BYTE g_PnpDeviceClassNofityList_SubPattern_9600_26080[] = { 0xC1, 0xEA, 0x02, 0x6B, 0xC2, 0x0D };

```

`Source/WinObjEx64/extras/extrasCmOpt.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       EXTRASCMOPT.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"

#define T_DUMP_VALUE TEXT("Dump Value to File")

#define ID_CMOPTLIST_SAVE 40060
#define ID_CMOPTLIST_DUMP 40061

#define CMOPTDLG_TRACKSIZE_MIN_X 640
#define CMOPTDLG_TRACKSIZE_MIN_Y 480

#define COLUMN_CMOPTLIST_KEY_NAME               0
#define COLUMN_CMOPTLIST_VALUE_NAME             1
#define COLUMN_CMOPTLIST_BUFFER                 2
#define COLUMN_CMOPTLIST_BUFFER_LENGTH          3
#define COLUM_CMOPTLIST_VALUE_MEMORY            5

static HANDLE CmOptThreadHandle = NULL;
static FAST_EVENT CmOptInitializedEvent = FAST_EVENT_INIT;

/*
* CmOptDlgDumpValueToFile
*
* Purpose:
*
* Dump selected value from kernel memory to the file.
*
*/
VOID CmOptDlgDumpValueToFile(
    _In_ EXTRASCONTEXT* Context,
    _In_ INT iItem
)
{
    BOOL bSuccess = FALSE;
    WCHAR szBuffer[MAX_PATH + 1];
    ULONG_PTR variableAddress;
    ULONG variableSize, bytesRead = 0;
    PBYTE tempBuffer = NULL;

    do {

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));

        supGetItemText2(
            Context->ListView,
            iItem,
            COLUMN_CMOPTLIST_BUFFER,
            szBuffer,
            MAX_TEXT_CONVERSION_ULONG64);

        variableAddress = hextou64(&szBuffer[2]);
        if (variableAddress < g_kdctx.SystemRangeStart)
            break;

        szBuffer[0] = 0;
        supGetItemText2(
            Context->ListView,
            iItem,
            COLUMN_CMOPTLIST_BUFFER_LENGTH,
            szBuffer,
            MAX_TEXT_CONVERSION_ULONG64);

        variableSize = hextoul(&szBuffer[2]);
        if (variableSize >= 128 * 1024)
            break;

        if (variableSize == 0)
            variableSize = sizeof(ULONG);

        tempBuffer = (PBYTE)supHeapAlloc(ALIGN_UP_BY(variableSize, PAGE_SIZE));
        if (tempBuffer == NULL)
            break;

        //
        // Run Save As Dialog.
        //
        _strcpy(szBuffer, TEXT("dump.bin"));
        if (!supSaveDialogExecute(Context->hwndDlg, szBuffer, TEXT("All files\0*.*\0\0"))) {
            bSuccess = TRUE; //user cancelled
            break;
        }

        if (kdReadSystemMemoryEx(variableAddress,
            tempBuffer,
            variableSize,
            &bytesRead))
        {
            if (bytesRead == variableSize) {

                bSuccess = (bytesRead == supWriteBufferToFile(szBuffer,
                    tempBuffer,
                    bytesRead,
                    FALSE,
                    FALSE, 
                    NULL));

            }
        }

    } while (FALSE);

    if (bSuccess == FALSE) {
        MessageBox(
            Context->hwndDlg,
            TEXT("Error dumping value"),
            PROGRAM_NAME,
            MB_ICONERROR);
    }

    if (tempBuffer) supHeapFree(tempBuffer);
}

/*
* CmOptDlgHandlePopupMenu
*
* Purpose:
*
* Table list popup construction.
*
*/
VOID CmOptDlgHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    BOOLEAN bIoDriverLoaded;
    HMENU hMenu;
    UINT uPos = 0;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            uPos,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }

        bIoDriverLoaded = (Context->Reserved != 0);
        if (bIoDriverLoaded) {
            InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_CMOPTLIST_DUMP, T_DUMP_VALUE);
        }
        InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_CMOPTLIST_SAVE, T_EXPORTTOFILE);

        //
        // Track.
        //
        TrackPopupMenu(hMenu,
            TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            lpPoint->x,
            lpPoint->y,
            0,
            hwndDlg,
            NULL);

        DestroyMenu(hMenu);
    }
}


/*
* CmOptDlgCompareFunc
*
* Purpose:
*
* CmControlVector listview comparer function.
*
*/
INT CALLBACK CmOptDlgCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParamSort;

    if (pDlgContext == NULL)
        return 0;

    switch (pDlgContext->lvColumnToSort) {

    case COLUMN_CMOPTLIST_KEY_NAME:
    case COLUMN_CMOPTLIST_VALUE_NAME:
        return supGetMaxCompareTwoFixedStrings(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);

    case COLUMN_CMOPTLIST_BUFFER:
        return supGetMaxOfTwoU64FromHex(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);

    default:
        return supGetMaxOfTwoUlongFromHex(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);
    }

}

/*
* CmOptDlgHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for CmControlVector list dialog.
*
*/
BOOL CALLBACK CmOptDlgHandleNotify(
    _In_ LPNMLISTVIEW NMListView,
    _In_ EXTRASCONTEXT* Context
)
{
    INT nImageIndex;

    if (NMListView->hdr.idFrom != ID_EXTRASLIST)
        return FALSE;

    switch (NMListView->hdr.code) {

    case LVN_COLUMNCLICK:

        Context->bInverseSort = (~Context->bInverseSort) & 1;
        Context->lvColumnToSort = NMListView->iSubItem;

        ListView_SortItemsEx(Context->ListView,
            CmOptDlgCompareFunc,
            Context);

        nImageIndex = ImageList_GetImageCount(g_ListViewImages);
        if (Context->bInverseSort)
            nImageIndex -= 2; //sort down/up images are always at the end of main imagelist
        else
            nImageIndex -= 1;

        supUpdateLvColumnHeaderImage(
            Context->ListView,
            Context->lvColumnCount,
            Context->lvColumnToSort,
            nImageIndex);

        return TRUE;
    }

    return FALSE;
}

/*
* CmOptDlgHandleWMCommand
*
* Purpose:
*
* WM_COMMAND handler.
*
*/
VOID CmOptDlgHandleWMCommand(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER(lParam);
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {

    case ID_OBJECT_COPY:

        if (pDlgContext) {

            supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                pDlgContext->lvItemHit,
                pDlgContext->lvColumnHit);

        }

        break;

    case ID_CMOPTLIST_SAVE:

        if (pDlgContext) {

            supListViewExportToFile(
                TEXT("CmControlVector.csv"),
                hwndDlg,
                pDlgContext->ListView);
        }
        break;

    case ID_CMOPTLIST_DUMP:

        if (pDlgContext) {

            CmOptDlgDumpValueToFile(pDlgContext,
                pDlgContext->lvItemHit);

        }
        break;

    case IDCANCEL:
        SendMessage(hwndDlg, WM_CLOSE, 0, 0);
        break;

    }
}

/*
* CmpOptDlgAddEntry
*
* Purpose:
*
* Adds CmControlVector entry to the listview.
*
*/
VOID CmpOptDlgAddEntry(
    _In_ HWND hwndList,
    _In_ PVOID pvEntry,
    _In_ ULONG ulEntrySize,
    _In_ BOOLEAN bIoDriverLoaded
)
{
    PBYTE  address;
    ULONG  value;
    INT    lvItemIndex;
    LVITEM lvitem;
    WCHAR  szBuffer[MAX_PATH + 1];

    union {
        union {
            CM_SYSTEM_CONTROL_VECTOR_V1* v1;
            CM_SYSTEM_CONTROL_VECTOR_V2* v2;
        } Version;
        PBYTE Ref;
    } CmControlVector;

    CmControlVector.Ref = (PBYTE)pvEntry;

    __try { //rely on undocumented structures

        RtlSecureZeroMemory(&lvitem, sizeof(lvitem));

        //
        // KeyName
        //
        lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = MAXINT;
        lvitem.pszText = CmControlVector.Version.v1->KeyPath;
        lvitem.iImage = g_TypeKey.ImageIndex;
        lvItemIndex = ListView_InsertItem(hwndList, &lvitem);
        if (lvItemIndex == -1)
            return;

        //
        // ValueName
        //
        lvitem.mask = LVIF_TEXT;
        lvitem.iSubItem++;
        lvitem.pszText = CmControlVector.Version.v1->ValueName;
        lvitem.iItem = lvItemIndex;
        ListView_SetItem(hwndList, &lvitem);

        //
        // Buffer
        //
        address = (PBYTE)CmControlVector.Version.v1->Buffer;
        if (address) {
            address = (ULONG_PTR)g_kdctx.NtOsBase + address - (ULONG_PTR)g_kdctx.NtOsImageMap;
        }
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        szBuffer[2] = 0;
        u64tohex((ULONG_PTR)address, &szBuffer[2]);
        lvitem.iSubItem++;
        lvitem.pszText = szBuffer;
        lvitem.iItem = lvItemIndex;
        ListView_SetItem(hwndList, &lvitem);

        //
        // BufferLength
        //
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        szBuffer[2] = 0;
        value = 0;
        if (CmControlVector.Version.v1->BufferLength) {
            value = *CmControlVector.Version.v1->BufferLength;
        }

        ultohex(value, &szBuffer[2]);
        lvitem.iSubItem++;
        lvitem.pszText = szBuffer;
        lvitem.iItem = lvItemIndex;
        ListView_SetItem(hwndList, &lvitem);

        //
        // Type
        //
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        szBuffer[2] = 0;
        value = 0;
        if (CmControlVector.Version.v1->Type) {
            value = *CmControlVector.Version.v1->Type;
        }
        ultohex(value, &szBuffer[2]);

        lvitem.iSubItem++;
        lvitem.pszText = szBuffer;
        lvitem.iItem = lvItemIndex;
        ListView_SetItem(hwndList, &lvitem);

        //
        // Value
        //
        if (bIoDriverLoaded) {
            szBuffer[0] = 0;
            if (address) {

                value = 0;
                if (kdReadSystemMemory((ULONG_PTR)address, &value, sizeof(ULONG))) {
                    szBuffer[0] = L'0';
                    szBuffer[1] = L'x';
                    szBuffer[2] = 0;
                    ultohex(value, &szBuffer[2]);
                }

            }
            lvitem.iSubItem++;
            lvitem.pszText = szBuffer;
            lvitem.iItem = lvItemIndex;
            ListView_SetItem(hwndList, &lvitem);
        }

        //
        // Flags
        //
        if (ulEntrySize > sizeof(CM_SYSTEM_CONTROL_VECTOR_V1)) {

            szBuffer[0] = L'0';
            szBuffer[1] = L'x';
            szBuffer[2] = 0;
            ultohex(CmControlVector.Version.v2->Flags, &szBuffer[2]);

            lvitem.iSubItem++;
            lvitem.pszText = szBuffer;
            lvitem.iItem = lvItemIndex;
            ListView_SetItem(hwndList, &lvitem);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }
}

/*
* CmOptDlgListOptions
*
* Purpose:
*
* Output CmControlVector data.
*
*/
VOID CmOptDlgListOptions(
    _In_ EXTRASCONTEXT* Context
)
{
    HWND   hwndList = Context->ListView;

    ULONG size;
    WCHAR  szBuffer[MAX_PATH + 1];

    union {
        union {
            CM_SYSTEM_CONTROL_VECTOR_V1* v1;
            CM_SYSTEM_CONTROL_VECTOR_V2* v2;
        } Version;
        PBYTE Ref;
    } CmControlVector;

    if (g_kdctx.Data->CmControlVector == NULL)
        g_kdctx.Data->CmControlVector = kdQueryCmControlVector(&g_kdctx);

    if (g_kdctx.Data->CmControlVector == NULL) {
        supStatusBarSetText(Context->StatusBar, 1, TEXT("Failed to query CmControlVector"));
        return;
    }

    CmControlVector.Ref = (PBYTE)g_kdctx.Data->CmControlVector;

    if (g_NtBuildNumber >= NT_WIN10_REDSTONE4)
        size = sizeof(CM_SYSTEM_CONTROL_VECTOR_V2);
    else
        size = sizeof(CM_SYSTEM_CONTROL_VECTOR_V1);

    supDisableRedraw(hwndList);

    while (CmControlVector.Version.v1->KeyPath != NULL) {
        CmpOptDlgAddEntry(hwndList, CmControlVector.Ref, size, (Context->Reserved != 0));
        CmControlVector.Ref += size;
    }

    ListView_SortItemsEx(hwndList,
        &CmOptDlgCompareFunc,
        (LPARAM)Context);

    supEnableRedraw(hwndList);

    _strcpy(szBuffer, TEXT("Total: "));
    ultostr(ListView_GetItemCount(Context->ListView), _strend(szBuffer));
    supStatusBarSetText(Context->StatusBar, 0, szBuffer);
}

/*
* CmOptDlgOnInit
*
* Purpose:
*
* WM_INITDIALOG handler.
*
*/
VOID CmOptDlgOnInit(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParam;
    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1, iColumn;
    BOOLEAN bIoDriverLoaded;
    LVCOLUMNS_DATA columnDataList[] =
    {
        { L"KeyPath", 200, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, iImage },
        { L"ValueName", 160, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Buffer", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Length", 80, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Type", 80, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE }
    };

    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pDlgContext);

    pDlgContext->hwndDlg = hwndDlg;
    pDlgContext->lvItemHit = -1;
    pDlgContext->lvColumnHit = -1;

    extrasSetDlgIcon(pDlgContext);

    pDlgContext->StatusBar = GetDlgItem(hwndDlg, ID_EXTRASLIST_STATUSBAR);
    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_EXTRASLIST);
    pDlgContext->lvColumnHit = -1;
    pDlgContext->lvItemHit = -1;

    //
    // Set listview imagelist, style flags and theme.
    //
    supSetListViewSettings(pDlgContext->ListView,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        g_ListViewImages,
        LVSIL_SMALL);

    //
    // And columns and remember their count.
    //
    iColumn = supAddLVColumnsFromArray(
        pDlgContext->ListView,
        columnDataList,
        RTL_NUMBER_OF(columnDataList));

    pDlgContext->lvColumnCount = iColumn;

    bIoDriverLoaded = kdIoDriverLoaded();
    pDlgContext->Reserved = bIoDriverLoaded;

    if (bIoDriverLoaded) {
        supAddListViewColumn(pDlgContext->ListView,
            iColumn,
            iColumn,
            iColumn,
            I_IMAGENONE,
            LVCFMT_CENTER | LVCFMT_BITMAP_ON_RIGHT,
            TEXT("Value (Memory)"), 80);

        pDlgContext->lvColumnCount += 1;
        iColumn += 1;
    }

    if (g_NtBuildNumber >= NT_WIN10_REDSTONE4) {
        supAddListViewColumn(pDlgContext->ListView,
            iColumn,
            iColumn,
            iColumn,
            I_IMAGENONE,
            LVCFMT_CENTER | LVCFMT_BITMAP_ON_RIGHT,
            TEXT("Flags"), 80);

        pDlgContext->lvColumnCount += 1;
    }

    SetWindowText(hwndDlg, TEXT("CmControlVector (Relative to: \\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control)"));

    CmOptDlgListOptions(pDlgContext);

    SendMessage(hwndDlg, WM_SIZE, 0, 0);
    SetFocus(pDlgContext->ListView);

    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
}

/*
* CmOptDlgDialogProc
*
* Purpose:
*
* CmControlVector Dialog window procedure.
*
*/
INT_PTR CALLBACK CmOptDlgDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext;

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasHandleSettingsChange(pDlgContext);
        }
        return TRUE;
    }

    switch (uMsg) {

    case WM_SIZE:
        extrasSimpleListResize(hwndDlg);
        break;

    case WM_INITDIALOG:
        CmOptDlgOnInit(hwndDlg, lParam);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasRemoveDlgIcon(pDlgContext);
            supHeapFree(pDlgContext);
        }
        return DestroyWindow(hwndDlg);

    case WM_COMMAND:

        CmOptDlgHandleWMCommand(hwndDlg, wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                CMOPTDLG_TRACKSIZE_MIN_X,
                CMOPTDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_NOTIFY:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            return (INT_PTR)CmOptDlgHandleNotify(
                (LPNMLISTVIEW)lParam,
                pDlgContext);
        }
        break;

    case WM_CONTEXTMENU:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)CmOptDlgHandlePopupMenu,
                pDlgContext);
        }
        break;
    }

    return FALSE;
}

/*
* extrasCmOptDialogWorkerThread
*
* Purpose:
*
* CmControlVector Dialog thread.
*
*/
DWORD extrasCmOptDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)Parameter;

    hwndDlg = CreateDialogParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_EXTRASLIST),
        0,
        &CmOptDlgDialogProc,
        (LPARAM)pDlgContext);

    supSetFastEvent(&CmOptInitializedEvent);

    if (hwndDlg) {
        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (!IsDialogMessage(hwndDlg, &message)) {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    supResetFastEvent(&CmOptInitializedEvent);

    if (CmOptThreadHandle) {
        NtClose(CmOptThreadHandle);
        CmOptThreadHandle = NULL;
    }

    return 0;
}

/*
* extrasCreateCmOptDialog
*
* Purpose:
*
* Create and initialize CmControlVector Dialog.
*
*/
VOID extrasCreateCmOptDialog(
    VOID
)
{
    EXTRASCONTEXT* pDlgContext;

    if (!CmOptThreadHandle) {
        pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
        if (pDlgContext) {
            pDlgContext->tlSubItemHit = -1;
            CmOptThreadHandle = supCreateDialogWorkerThread(extrasCmOptDialogWorkerThread, pDlgContext , 0);
            if (CmOptThreadHandle == NULL) {
                supHeapFree(pDlgContext);
                return;
            }
            supWaitForFastEvent(&CmOptInitializedEvent, NULL);
        }
    }
}

```

`Source/WinObjEx64/extras/extrasDrivers.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2026
*
*  TITLE:       EXTRASDRIVERS.C
*
*  VERSION:     2.10
*
*  DATE:        12 Jan 2026
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"

#define DUMP_PROP L"dumpProp"

BOOLEAN DrvDlgShimsEnabled = FALSE;

#define ID_DRVLIST_REFRESH   ID_VIEW_REFRESH
#define ID_DRVLIST_PROP      ID_OBJECT_PROPERTIES
#define ID_DRVLIST_DUMP      40005
#define ID_DRVLIST_DUMPFIXED 40006
#define ID_DRVLIST_SAVE      40007


#define ID_CALC_HASH_MD5            6000
#define ID_CALC_HASH_SHA1           6001
#define ID_CALC_HASH_SHA256         6002
#define ID_CALC_HASH_SHA384         6003
#define ID_CALC_HASH_SHA512         6004
#define ID_CALC_HASH_PAGE_SHA1      6005
#define ID_CALC_HASH_PAGE_SHA256    6006

#define COLUMN_DRVLIST_LOAD_ORDER               0
#define COLUMN_DRVLIST_DRIVER_NAME              1
#define COLUMN_DRVLIST_DRIVER_ADDRESS           2
#define COLUMN_DRVLIST_SIZE                     3
#define COLUMN_DRVLIST_MODULE_NAME              4
#define COLUMN_DRVLIST_SHIMMED                  5

#define COLUMN_DRVLIST_UNLOADED_DRIVER_NAME     0
#define COLUMN_DRVLIST_UNLOADED_START_ADDRESS   1
#define COLUMN_DRVLIST_UNLOADED_END_ADDRESS     2
#define COLUMN_DRVLIST_UNLOADED_CURRENT_TIME    3

#define T_DUMPDRIVER       L"Dump Driver (Raw)"
#define T_DUMPDRIVER_FIXED L"Dump Driver (Fix Sections)"

#define DRVLISTDLG_TRACKSIZE_MIN_X 640
#define DRVLISTDLG_TRACKSIZE_MIN_Y 480

static EXTRASCONTEXT DrvDlgContext[DrvModeMax];
static HANDLE DrvDlgThreadHandles[DrvModeMax] = { NULL, NULL };
static FAST_EVENT DrvDlgInitializedEvents[DrvModeMax] = { FAST_EVENT_INIT, FAST_EVENT_INIT };
static LIST_ENTRY g_DrvFilterListHead;
static ULONG g_cDrvShimmed = 0;
static ULONG g_cDrvFilters = 0;

WNDPROC g_OriginalListViewProc = NULL;

LPCWSTR CryptAlgoIdRef[] = {
    BCRYPT_MD5_ALGORITHM,
    BCRYPT_SHA1_ALGORITHM,
    BCRYPT_SHA256_ALGORITHM,
    BCRYPT_SHA384_ALGORITHM,
    BCRYPT_SHA512_ALGORITHM
};

VOID DrvTooltipFreeBuffer(
    _In_ EXTRASCONTEXT* Context
)
{
    if (Context == NULL)
        return;

    if (Context->TooltipBuffer) {
        supHeapFree(Context->TooltipBuffer);
        Context->TooltipBuffer = NULL;
    }
}

/*
* DrvListCopyHash
*
* Purpose:
*
* Copy hash menu handler.
*
*/
VOID DrvListCopyHash(
    _In_ EXTRASCONTEXT* Context,
    _In_ UINT MenuId
)
{
    INT         mark;
    NTSTATUS    ntStatus;
    LPWSTR      lpItem, lpszHash = NULL, lpWin32Name;

    FILE_VIEW_INFO fvi;

    if (ListView_GetSelectedCount(Context->ListView) == 0)
        return;

    mark = ListView_GetSelectionMark(Context->ListView);
    if (mark < 0)
        return;

    lpItem = supGetItemText(Context->ListView, mark,
        COLUMN_DRVLIST_MODULE_NAME, NULL);

    if (lpItem == NULL)
        return;

    lpWin32Name = supGetWin32FileName(lpItem);

    if (lpWin32Name) {

        RtlSecureZeroMemory(&fvi, sizeof(fvi));

        fvi.FileName = lpWin32Name;

        ntStatus = HashLoadFile(&fvi, FALSE);
        if (NT_SUCCESS(ntStatus)) {

            if (MenuId >= ID_CALC_HASH_PAGE_SHA1 && MenuId <= ID_CALC_HASH_PAGE_SHA256) {

                lpszHash = ComputeHashForFile(&fvi,
                    (MenuId == ID_CALC_HASH_PAGE_SHA1) ? BCRYPT_SHA1_ALGORITHM : BCRYPT_SHA256_ALGORITHM,
                    PAGE_SIZE,
                    g_obexHeap,
                    TRUE);

            }
            else if (MenuId >= ID_CALC_HASH_MD5 && MenuId <= ID_CALC_HASH_SHA512) {

                lpszHash = ComputeHashForFile(&fvi,
                    CryptAlgoIdRef[MenuId - ID_CALC_HASH_MD5],
                    PAGE_SIZE,
                    g_obexHeap,
                    FALSE);
            }

            HashUnloadFile(&fvi);
        }
        else {
            supShowNtStatus(Context->hwndDlg, TEXT("Error loading file, NTSTATUS: "), ntStatus);
        }

        supHeapFree(lpWin32Name);
    }

    supHeapFree(lpItem);

    if (lpszHash) {
        supClipboardCopy(lpszHash, _strlen(lpszHash) * sizeof(WCHAR));
        supHeapFree(lpszHash);
    }

}

/*
* DrvUpdateStatusBar
*
* Purpose:
*
* Update status bar information.
*
*/
VOID DrvUpdateStatusBar(
    _In_ EXTRASCONTEXT* Context,
    _In_ INT iItem)
{
    INT iSubItem;
    INT sbParts[] = { 100, -1 };
    WCHAR szBuffer[MAX_PATH];

    _strcpy(szBuffer, TEXT("Total: "));
    ultostr(ListView_GetItemCount(Context->ListView), _strend(szBuffer));

    //
    // Add "shimmed" drivers count for normal dialog mode.
    //
    if (Context->DialogMode == DrvModeNormal) {
        if (g_cDrvShimmed) {
            _strcat(szBuffer, TEXT(", Shimmed: "));
            ultostr(g_cDrvShimmed, _strend(szBuffer));
            sbParts[0] = 240;
        }
    }

    SendMessage(Context->StatusBar, SB_SETPARTS, 2, (LPARAM)&sbParts);
    supStatusBarSetText(Context->StatusBar, 0, (LPWSTR)&szBuffer);

    if (iItem >= 0) {

        if (Context->DialogMode == DrvModeNormal)
            iSubItem = COLUMN_DRVLIST_DRIVER_NAME;
        else
            iSubItem = COLUMN_DRVLIST_UNLOADED_DRIVER_NAME;

        supGetItemText2(
            Context->ListView,
            iItem,
            iSubItem,
            szBuffer,
            MAX_PATH);

        supStatusBarSetText(Context->StatusBar, 1, (LPWSTR)&szBuffer);
    }
    else {
        supStatusBarSetText(Context->StatusBar, 1, (LPWSTR)T_EmptyString);
    }
}

/*
* DrvHandlePopupMenu
*
* Purpose:
*
* Table list popup construction.
*
*/
VOID DrvHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    UINT uPos = 0, i;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;
    WCHAR szMenuText[MAX_PATH + 1];

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            uPos,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }

        if (Context->DialogMode == DrvModeNormal) {

            InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_DRVLIST_PROP, T_PROPERTIES);
            InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            if (kdConnectDriver()) {
                InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_DRVLIST_DUMP, T_DUMPDRIVER);
                InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_DRVLIST_DUMPFIXED, T_DUMPDRIVER_FIXED);
            }
            InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_JUMPTOFILE, T_JUMPTOFILE);

        }

        InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_DRVLIST_SAVE, T_EXPORTTOFILE);
        InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_DRVLIST_REFRESH, T_VIEW_REFRESH);

        if (Context->DialogMode == DrvModeNormal) {
            //
            // Hashes.
            //
            InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            for (i = ID_CALC_HASH_MD5; i < ID_CALC_HASH_PAGE_SHA1; i++) {
                RtlStringCchPrintfSecure(szMenuText,
                    MAX_PATH,
                    TEXT("Copy Authenticode %ws hash"),
                    CryptAlgoIdRef[i - ID_CALC_HASH_MD5]);
                InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, i, szMenuText);
            }

            InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

            RtlStringCchPrintfSecure(szMenuText,
                MAX_PATH,
                TEXT("Copy %ws page hash"),
                BCRYPT_SHA1_ALGORITHM);

            InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_CALC_HASH_PAGE_SHA1, szMenuText);

            RtlStringCchPrintfSecure(szMenuText,
                MAX_PATH,
                TEXT("Copy %ws page hash"),
                BCRYPT_SHA256_ALGORITHM);

            InsertMenu(hMenu, ++uPos, MF_BYCOMMAND, ID_CALC_HASH_PAGE_SHA256, szMenuText);

        }

        //
        // Track.
        //
        TrackPopupMenu(hMenu,
            TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            lpPoint->x,
            lpPoint->y,
            0,
            hwndDlg,
            NULL);

        DestroyMenu(hMenu);
    }
}

/*
* DrvListViewProperties
*
* Purpose:
*
* View selected driver file properties.
*
*/
VOID DrvListViewProperties(
    _In_ EXTRASCONTEXT* Context
)
{
    LPWSTR  lpItem, lpWin32Name;
    INT     mark;

    if (ListView_GetSelectedCount(Context->ListView)) {
        mark = ListView_GetSelectionMark(Context->ListView);
        if (mark >= 0) {
            lpItem = supGetItemText(Context->ListView, mark,
                COLUMN_DRVLIST_MODULE_NAME, NULL);

            if (lpItem) {
                lpWin32Name = supGetWin32FileName(lpItem);
                if (lpWin32Name) {
                    supShowProperties(Context->hwndDlg, lpWin32Name);
                    supHeapFree(lpWin32Name);
                }
                supHeapFree(lpItem);
            }
        }
    }
}

static HANDLE DumpDialogThreadHandle = NULL;
static FAST_EVENT DumpDialogInitializedEvent = FAST_EVENT_INIT;
HWND DumpWorkerWindow = NULL;

typedef struct _OBEX_DRVDUMP {
    _In_ BOOL FixSections;
    _In_ ULONG DumpSize;
    _In_ ULONG_PTR DumpAddress;
    _In_ PBYTE Buffer;
    _In_ HWND ParentWindow;
    _Out_ volatile LONGLONG ReadSize;
    _Out_ NTSTATUS DumpStatus;
    _In_ HANDLE hCancelEvent;
    _In_ HANDLE hWorkerThread;
    _In_ WCHAR FileName[MAX_PATH * 2];
} OBEX_DRVDUMP, * POBEX_DRVDUMP;

/*
* DrvDumpThread
*
* Purpose:
*
* Dumper thread worker.
*
*/
DWORD DrvDumpThread(
    _In_ PVOID Parameter
)
{
    OBEX_DRVDUMP* dumpInfo = (POBEX_DRVDUMP)Parameter;

    PBYTE buffer;
    ULONG_PTR dumpAddress;
    ULONG totalSize;
    unsigned long long readBytes = 0;
    ULONG i;
    ULONG remainingBytes;
    ULONG memIO = 0;
    LONGLONG prev;

    if (dumpInfo == NULL)
        return ERROR_INVALID_PARAMETER;

    totalSize = dumpInfo->DumpSize;

    for (i = 0,
        buffer = dumpInfo->Buffer,
        dumpAddress = dumpInfo->DumpAddress;
        (i < (totalSize / PAGE_SIZE));
        i++,
        dumpAddress += PAGE_SIZE,
        buffer = (PBYTE)RtlOffsetToPointer(buffer, PAGE_SIZE))
    {
        if (dumpInfo->hCancelEvent && WaitForSingleObject(dumpInfo->hCancelEvent, 0) == WAIT_OBJECT_0) {
            dumpInfo->DumpStatus = STATUS_CANCELLED;
            PostMessage(dumpInfo->ParentWindow, WM_CLOSE, (WPARAM)0, (LPARAM)0);
            return ERROR_CANCELLED;
        }

        kdReadSystemMemoryEx(dumpAddress, buffer, PAGE_SIZE, &memIO); // ignore read errors
        prev = InterlockedExchangeAdd64(&dumpInfo->ReadSize, (LONGLONG)memIO);
        readBytes = (unsigned long long)(prev + (LONGLONG)memIO);
    }

    remainingBytes = totalSize % PAGE_SIZE;
    if (remainingBytes) {
        if (dumpInfo->hCancelEvent && WaitForSingleObject(dumpInfo->hCancelEvent, 0) == WAIT_OBJECT_0) {
            dumpInfo->DumpStatus = STATUS_CANCELLED;
            PostMessage(dumpInfo->ParentWindow, WM_CLOSE, (WPARAM)0, (LPARAM)0);
            return ERROR_CANCELLED;
        }
        kdReadSystemMemoryEx(dumpAddress, buffer, remainingBytes, &memIO);
        prev = InterlockedExchangeAdd64(&dumpInfo->ReadSize, (LONGLONG)memIO);
        readBytes = (unsigned long long)(prev + (LONGLONG)memIO);
    }

    if (readBytes == 0) {
        dumpInfo->DumpStatus = STATUS_UNSUCCESSFUL;
    }
    else if (readBytes != totalSize) {
        dumpInfo->DumpStatus = STATUS_PARTIAL_COPY;
    }
    else {
        dumpInfo->DumpStatus = STATUS_SUCCESS;
    }

    //
    // Signal dialog to close and let dialog-thread perform cleanup.
    //
    PostMessage(dumpInfo->ParentWindow, WM_CLOSE, (WPARAM)0, (LPARAM)0);
    return ERROR_SUCCESS;
}

/*
* DumpTerminateWorker
*
* Purpose:
*
* Request worker cancellation and wait for worker thread to exit.
*
*/
VOID DumpTerminateWorker(
    _In_ HWND hwndDlg
)
{
    OBEX_DRVDUMP* dumpInfo;

    if (hwndDlg == NULL)
        return;

    dumpInfo = (OBEX_DRVDUMP*)GetProp(hwndDlg, DUMP_PROP);
    if (dumpInfo == NULL)
        return;

    if (dumpInfo->hWorkerThread) {
        //
        // Request cancellation.
        //
        if (dumpInfo->hCancelEvent)
            SetEvent(dumpInfo->hCancelEvent);

        WaitForSingleObject(dumpInfo->hWorkerThread, 20 * 1000);

        CloseHandle(dumpInfo->hWorkerThread);
        dumpInfo->hWorkerThread = NULL;
    }
}

/*
* DumpUpdateTimerProc
*
* Purpose:
*
* Timer proc handler displaying dump progress.
*
*/
VOID DumpUpdateTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT_PTR idEvent,
    DWORD dwTime)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(idEvent);
    UNREFERENCED_PARAMETER(dwTime);

    OBEX_DRVDUMP* dumpInfo;
    HWND hwndProgress = GetDlgItem(hwnd, IDC_PROGRESS);
    WCHAR szBuffer[100];

    dumpInfo = (OBEX_DRVDUMP*)GetProp(hwnd, DUMP_PROP);
    if (dumpInfo) {
        szBuffer[0] = 0;
        RtlStringCchPrintfSecure(szBuffer,
            RTL_NUMBER_OF(szBuffer),
            TEXT("Reading %llu (%llu Kb) of %lu (%lu Kb)"),
            (ULONGLONG)dumpInfo->ReadSize,
            (ULONGLONG)(dumpInfo->ReadSize / 1024),
            dumpInfo->DumpSize,
            dumpInfo->DumpSize / 1024);

        SetWindowText(hwndProgress, szBuffer);
    }
}

/*
* DrvDumpProgressDialogProc
*
* Purpose:
*
* Driver dumping progress dialog proc.
*
*/
INT_PTR CALLBACK DrvDumpProgressDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    OBEX_DRVDUMP* dumpInfo;

    switch (uMsg) {

    case WM_INITDIALOG:
        dumpInfo = (POBEX_DRVDUMP)lParam;
        if (dumpInfo) {
            SetProp(hwndDlg, DUMP_PROP, (HANDLE)dumpInfo);
            supCenterWindowSpecifyParent(hwndDlg, dumpInfo->ParentWindow);
            dumpInfo->ParentWindow = hwndDlg;
            _InterlockedExchange64(&dumpInfo->ReadSize, 0);
            dumpInfo->hCancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            dumpInfo->hWorkerThread = supCreateThread(DrvDumpThread, (PVOID)dumpInfo, 0);
            SetTimer(hwndDlg, 1, 300, DumpUpdateTimerProc);
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            DumpTerminateWorker(hwndDlg);
            RemoveProp(hwndDlg, DUMP_PROP);
            KillTimer(hwndDlg, 1);
            return DestroyWindow(hwndDlg);
        }
    }
    return 0;
}

/*
* DumpDialogWorkerThread
*
* Purpose:
*
* Driver dumping dialog proc.
*
*/
DWORD DumpDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    OBEX_DRVDUMP* dumpInfo = (POBEX_DRVDUMP)Parameter;
    HWND hwndDlg, hwndParent = dumpInfo->ParentWindow;
    HANDLE prev;

    SIZE_T bytesIO;
    WCHAR szBuffer[100];

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_PROGRESS),
        0,
        (DLGPROC)&DrvDumpProgressDialogProc,
        (LPARAM)dumpInfo);

    DumpWorkerWindow = hwndDlg;

    SetWindowText(hwndDlg, TEXT("Driver dump"));

    supSetFastEvent(&DumpDialogInitializedEvent);

    if (hwndDlg) {
        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (!IsDialogMessage(hwndDlg, &message)) {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    if (dumpInfo->hWorkerThread) {
        WaitForSingleObject(dumpInfo->hWorkerThread, INFINITE);
        CloseHandle(dumpInfo->hWorkerThread);
        dumpInfo->hWorkerThread = NULL;
    }

    if ((NT_SUCCESS(dumpInfo->DumpStatus)
        || dumpInfo->DumpStatus == STATUS_PARTIAL_COPY)
        && (dumpInfo->Buffer != NULL))
    {
        if (dumpInfo->FixSections)
            supImageFixSections(dumpInfo->Buffer);

        bytesIO = supWriteBufferToFile(dumpInfo->FileName, dumpInfo->Buffer,
            (SIZE_T)dumpInfo->DumpSize, FALSE, FALSE, NULL);

        RtlStringCchPrintfSecure(szBuffer, RTL_NUMBER_OF(szBuffer),
            TEXT("Read %llu (%llu Kb), Write %llu (%llu Kb), Requested %lu (%lu Kb)"),
            (ULONGLONG)dumpInfo->ReadSize,
            (ULONGLONG)(dumpInfo->ReadSize / 1024),
            (ULONGLONG)bytesIO,
            (ULONGLONG)(bytesIO / 1024),
            dumpInfo->DumpSize,
            dumpInfo->DumpSize / 1024);

    }
    else if (dumpInfo->DumpStatus == STATUS_CANCELLED) {
        _strcpy(szBuffer, TEXT("Operation cancelled by user"));
    }
    else {
        _strcpy(szBuffer, TEXT("Error while dumping memory"));
    }

    supStatusBarSetText(
        GetDlgItem(hwndParent, ID_EXTRASLIST_STATUSBAR),
        1,
        szBuffer);

    if (dumpInfo->hCancelEvent) {
        CloseHandle(dumpInfo->hCancelEvent);
        dumpInfo->hCancelEvent = NULL;
    }

    if (dumpInfo->Buffer) {
        supHeapFree(dumpInfo->Buffer);
        supHeapFree(dumpInfo);
    }

    supResetFastEvent(&DumpDialogInitializedEvent);

    prev = InterlockedExchangePointer((PVOID*)&DumpDialogThreadHandle, NULL);
    if (prev) CloseHandle(prev);
    return 0;
}

/*
* DrvDumpDriver
*
* Purpose:
*
* Read driver from memory and write to disk, ignore read errors
*
*/
VOID DrvDumpDriver(
    _In_ EXTRASCONTEXT* Context,
    _In_ BOOL FixSections
)
{
    INT nSelected;
    SIZE_T sz;
    LPWSTR lpDriverName = NULL;
    WCHAR szBuffer[MAX_PATH * 2], szDriverDumpInfo[MAX_TEXT_CONVERSION_ULONG64];
    OBEX_DRVDUMP* DumpInfo;
    ULONG_PTR dumpAddress;
    ULONG dumpSize;

    if (DumpDialogThreadHandle) {
        return;
    }

    do {

        //
        // Remember selected index.
        //
        nSelected = ListView_GetNextItem(Context->ListView, -1, LVNI_SELECTED);
        if (nSelected < 0)
            break;

        //
        // Query selected driver name.
        //
        sz = 0;
        lpDriverName = supGetItemText(Context->ListView, nSelected, 1, &sz);
        if (lpDriverName == NULL)
            break;

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        _strncpy(szBuffer, MAX_PATH, lpDriverName, sz / sizeof(WCHAR));

        //
        // Run Save As Dialog.
        //
        if (!supSaveDialogExecute(Context->hwndDlg, szBuffer, TEXT("All files\0*.*\0\0")))
            break;

        //
        // Query driver address from listview.
        //
        RtlSecureZeroMemory(szDriverDumpInfo, sizeof(szDriverDumpInfo));
        supGetItemText2(
            Context->ListView,
            nSelected,
            COLUMN_DRVLIST_DRIVER_ADDRESS,
            szDriverDumpInfo,
            MAX_TEXT_CONVERSION_ULONG64);

        if (!(szDriverDumpInfo[0] == L'0' && (szDriverDumpInfo[1] == L'x')))
            break;

        dumpAddress = hextou64(&szDriverDumpInfo[2]);
        if (dumpAddress < g_kdctx.SystemRangeStart)
            break;

        //
        // Query driver size from listview.
        //
        RtlSecureZeroMemory(szDriverDumpInfo, sizeof(szDriverDumpInfo));
        supGetItemText2(
            Context->ListView,
            nSelected,
            COLUMN_DRVLIST_SIZE,
            szDriverDumpInfo,
            MAX_TEXT_CONVERSION_ULONG64);

        dumpSize = _strtoul(szDriverDumpInfo);
        if (dumpSize == 0)
            break;

        // 1 GB cap.
        if (dumpSize > 0x40000000) {
            supStatusBarSetText(Context->StatusBar, 1, TEXT("Dump size too large"));
            break;
        }

        DumpInfo = (OBEX_DRVDUMP*)supHeapAlloc(sizeof(OBEX_DRVDUMP));
        if (DumpInfo == NULL)
            break;

        DumpInfo->Buffer = (PBYTE)supHeapAlloc(dumpSize);
        if (DumpInfo->Buffer == NULL) {
            supHeapFree(DumpInfo);
            break;
        }
        DumpInfo->FixSections = FixSections;
        _strcpy(DumpInfo->FileName, szBuffer);
        DumpInfo->DumpAddress = dumpAddress;
        DumpInfo->DumpSize = dumpSize;
        DumpInfo->ParentWindow = Context->hwndDlg;
        DumpInfo->ReadSize = 0;
        DumpInfo->DumpStatus = STATUS_UNSUCCESSFUL;
        DumpInfo->hCancelEvent = NULL;
        DumpInfo->hWorkerThread = NULL;

        DumpDialogThreadHandle = supCreateThread(DumpDialogWorkerThread, (PVOID)DumpInfo, 0);
        if (DumpDialogThreadHandle == NULL) {
            if (DumpInfo->Buffer) supHeapFree(DumpInfo->Buffer);
            supHeapFree(DumpInfo);
            break;
        }
        supWaitForFastEvent(&DumpDialogInitializedEvent, NULL);

    } while (FALSE);

    if (lpDriverName) supHeapFree(lpDriverName);
}

/*
* DrvDlgCompareFunc
*
* Purpose:
*
* Drivers Dialog listview comparer function.
*
*/
INT CALLBACK DrvDlgCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParamSort;

    if (pDlgContext == NULL)
        return 0;

    if (pDlgContext->DialogMode == DrvModeNormal) {

        switch (pDlgContext->lvColumnToSort) {
        case COLUMN_DRVLIST_LOAD_ORDER: //Load Order
        case COLUMN_DRVLIST_SIZE: //Size
            return supGetMaxOfTwoULongFromString(
                pDlgContext->ListView,
                lParam1,
                lParam2,
                pDlgContext->lvColumnToSort,
                pDlgContext->bInverseSort);

        case COLUMN_DRVLIST_DRIVER_ADDRESS: //Address
            return supGetMaxOfTwoU64FromHex(
                pDlgContext->ListView,
                lParam1,
                lParam2,
                pDlgContext->lvColumnToSort,
                pDlgContext->bInverseSort);

        case COLUMN_DRVLIST_DRIVER_NAME: //Name
        case COLUMN_DRVLIST_MODULE_NAME: //Module
        case COLUMN_DRVLIST_SHIMMED: //Shimmed
            return supGetMaxCompareTwoFixedStrings(
                pDlgContext->ListView,
                lParam1,
                lParam2,
                pDlgContext->lvColumnToSort,
                pDlgContext->bInverseSort);
        }

    }
    else {

        switch (pDlgContext->lvColumnToSort) {
        case COLUMN_DRVLIST_UNLOADED_DRIVER_NAME: //Name
        case COLUMN_DRVLIST_UNLOADED_CURRENT_TIME: //CurrentTime
            return supGetMaxCompareTwoFixedStrings(
                pDlgContext->ListView,
                lParam1,
                lParam2,
                pDlgContext->lvColumnToSort,
                pDlgContext->bInverseSort);

        case COLUMN_DRVLIST_UNLOADED_START_ADDRESS: //StartAddress
        case COLUMN_DRVLIST_UNLOADED_END_ADDRESS: //EndAddress
            return supGetMaxOfTwoU64FromHex(
                pDlgContext->ListView,
                lParam1,
                lParam2,
                pDlgContext->lvColumnToSort,
                pDlgContext->bInverseSort);

        }
    }

    return 0;
}

/*
* DrvListCbEnumerateUnloadedDrivers
*
* Purpose:
*
* Unloaded drivers enumeration callback.
*
*/
BOOL DrvListCbEnumerateUnloadedDrivers(
    _In_ PUNLOADED_DRIVERS Entry,
    _In_ EXTRASCONTEXT* Context
)
{
    INT     lvItemIndex;
    LPWSTR  lpName;
    HWND    hwndList;
    LVITEM  lvitem;
    WCHAR   szBuffer[100];

    hwndList = Context->ListView;

    if (Entry->StartAddress && Entry->EndAddress) {

        if (!NT_SUCCESS(ObIsValidUnicodeString(&Entry->Name)))
            lpName = T_Unknown;
        else
            lpName = Entry->Name.Buffer;

        RtlSecureZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = MAXINT;
        lvitem.iImage = g_TypeDriver.ImageIndex;
        lvitem.pszText = lpName;

        lvItemIndex = ListView_InsertItem(hwndList, &lvitem);
        if (lvItemIndex >= 0) {
            lvitem.pszText = szBuffer;

            //StartAddress
            szBuffer[0] = L'0';
            szBuffer[1] = L'x';
            szBuffer[2] = 0;
            u64tohex((ULONG_PTR)Entry->StartAddress, &szBuffer[2]);
            lvitem.iSubItem = 1;
            lvitem.iItem = lvItemIndex;
            ListView_SetItem(hwndList, &lvitem);

            //EndAddress
            szBuffer[0] = L'0';
            szBuffer[1] = L'x';
            szBuffer[2] = 0;
            u64tohex((ULONG_PTR)Entry->EndAddress, &szBuffer[2]);
            lvitem.iSubItem = 2;
            ListView_SetItem(hwndList, &lvitem);

            //CurrentTime
            szBuffer[0] = 0;
            supPrintTimeConverted(&Entry->CurrentTime, szBuffer, RTL_NUMBER_OF(szBuffer));
            lvitem.iSubItem = 3;
            ListView_SetItem(hwndList, &lvitem);
        }
    }

    return FALSE;
}

/*
* DrvListUnloadedDrivers
*
* Purpose:
*
* Unloaded drivers query and list routine.
*
*/
VOID DrvListUnloadedDrivers(
    _In_ EXTRASCONTEXT* Context,
    _In_ BOOLEAN bRefresh
)
{
    HWND hwndList = Context->ListView;
    WCHAR szBuffer[100];

    if (bRefresh) {
        ListView_DeleteAllItems(hwndList);
    }

    supDisableRedraw(hwndList);

    if (!kdEnumerateMmUnloadedDrivers(
        (PENUMERATE_UNLOADED_DRIVERS_CALLBACK)DrvListCbEnumerateUnloadedDrivers,
        (PVOID)Context))
    {
        _strcpy(szBuffer, TEXT("Could not resolve MmUnloadedDrivers"));
        supStatusBarSetText(Context->StatusBar, 0, (LPWSTR)&szBuffer);
        return;
    }

    DrvUpdateStatusBar(Context, -1);

    ListView_SortItemsEx(hwndList,
        &DrvDlgCompareFunc,
        (LPARAM)Context);

    supEnableRedraw(hwndList);
}

/*
* DrvListDrivers
*
* Purpose:
*
* Drivers query and list routine.
*
*/
VOID DrvListDrivers(
    _In_ EXTRASCONTEXT* Context,
    _In_ BOOLEAN bRefresh
)
{
    INT lvItemIndex;
    ULONG i;

    PCHAR lpDriverName;
    HWND hwndList = Context->ListView;

    LVITEM lvitem;
    WCHAR szBuffer[MAX_PATH * 2];

    GUID shimGUID;
    SUP_SHIM_INFO* shimInfo;

    RTL_PROCESS_MODULES* pModulesList = NULL;
    PRTL_PROCESS_MODULE_INFORMATION pModule;

    g_cDrvShimmed = 0;

    if (bRefresh) {
        ListView_DeleteAllItems(hwndList);
        kdQueryKernelShims(&g_kdctx, TRUE);
    }

    pModulesList = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
    if (pModulesList == NULL)
        return;

    if (g_cDrvFilters) {
        supFilterDestroyList(&g_DrvFilterListHead);
    }
    else {
        InitializeListHead(&g_DrvFilterListHead);
    }
    g_cDrvFilters = supFilterCreateList(&g_DrvFilterListHead);

    supDisableRedraw(hwndList);

    for (i = 0; i < pModulesList->NumberOfModules; i++) {

        pModule = &pModulesList->Modules[i];

        if ((ULONG_PTR)pModule->ImageBase < g_kdctx.SystemRangeStart)
            continue;

        RtlSecureZeroMemory(&lvitem, sizeof(lvitem));

        //LoadOrder
        szBuffer[0] = 0;
        ultostr(pModule->LoadOrderIndex, szBuffer);

        lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = MAXINT;
        lvitem.iImage = g_TypeDriver.ImageIndex;
        lvitem.pszText = szBuffer;
        lvItemIndex = ListView_InsertItem(hwndList, &lvitem);
        if (lvItemIndex == -1)
            continue;

        //Name
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

        //
        // Handle malformed result.
        //
        if (pModule->OffsetToFileName > RTL_NUMBER_OF(pModule->FullPathName)) {
            _strcpy(szBuffer, T_Unknown);
        }
        else {
            lpDriverName = (PCHAR)&pModule->FullPathName[pModule->OffsetToFileName];
            if (*lpDriverName == 0)
            {
                _strcpy(szBuffer, T_Unknown);
            }
            else {
                MultiByteToWideChar(
                    CP_ACP, 0,
                    (LPCSTR)lpDriverName,
                    -1,
                    szBuffer,
                    MAX_PATH);

            }
        }

        lvitem.mask = LVIF_TEXT;
        lvitem.iSubItem = 1;
        lvitem.pszText = szBuffer;
        lvitem.iItem = lvItemIndex;
        ListView_SetItem(hwndList, &lvitem);

        //Address
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        szBuffer[2] = 0;
        u64tohex((ULONG_PTR)pModule->ImageBase, &szBuffer[2]);
        lvitem.iSubItem = 2;
        ListView_SetItem(hwndList, &lvitem);

        //Size
        szBuffer[0] = 0;
        ultostr(pModule->ImageSize, szBuffer);
        lvitem.iSubItem = 3;
        ListView_SetItem(hwndList, &lvitem);

        //FullName
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

        MultiByteToWideChar(
            CP_ACP,
            0,
            (LPCSTR)&pModule->FullPathName,
            -1,
            szBuffer,
            MAX_PATH);

        lvitem.iSubItem = 4;
        ListView_SetItem(hwndList, &lvitem);

        //Shimmed
        if (DrvDlgShimsEnabled) {

            szBuffer[0] = 0;

            if (supIsDriverShimmed(
                &g_kdctx.Data->KseEngineDump,
                pModule->ImageBase,
                &shimGUID))
            {
                g_cDrvShimmed += 1;

                shimInfo = supGetDriverShimInformation(shimGUID);
                if (shimInfo) {

                    RtlStringCchPrintfSecure(szBuffer,
                        RTL_NUMBER_OF(szBuffer),
                        L"%ws: %ws",
                        shimInfo->KseShimName,
                        shimInfo->OwnerModule);

                }
                else {
                    _strcpy(szBuffer, TEXT("Yes"));
                }
            }

            lvitem.iSubItem = 5;
            ListView_SetItem(hwndList, &lvitem);

        }
    }

    supHeapFree(pModulesList);
    DrvUpdateStatusBar(Context, -1);

    ListView_SortItemsEx(hwndList,
        &DrvDlgCompareFunc,
        (LPARAM)Context);

    supEnableRedraw(hwndList);
}

/*
* DrvDlgHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for Driver list dialogs.
*
*/
BOOL CALLBACK DrvDlgHandleNotify(
    _In_ EXTRASCONTEXT* Context,
    _In_ LPARAM lParam
)
{
    INT nImageIndex;
    LPNMLISTVIEW NMListView = (LPNMLISTVIEW)lParam;

    if (NMListView->hdr.idFrom != ID_EXTRASLIST)
        return FALSE;

    switch (NMListView->hdr.code) {

    case LVN_COLUMNCLICK:

        Context->bInverseSort = (~Context->bInverseSort) & 1;
        Context->lvColumnToSort = NMListView->iSubItem;

        ListView_SortItemsEx(Context->ListView,
            DrvDlgCompareFunc,
            Context);

        nImageIndex = ImageList_GetImageCount(g_ListViewImages);
        if (Context->bInverseSort)
            nImageIndex -= 2; //sort down/up images are always at the end of g_ListViewImages
        else
            nImageIndex -= 1;

        supUpdateLvColumnHeaderImage(
            Context->ListView,
            Context->lvColumnCount,
            Context->lvColumnToSort,
            nImageIndex);

        break;

    case NM_DBLCLK:
        DrvListViewProperties(Context);
        break;

    case NM_CLICK:
        DrvUpdateStatusBar(Context, NMListView->iItem);
        break;

    case LVN_ITEMCHANGED:

        if ((NMListView->uNewState & LVIS_SELECTED) &&
            !(NMListView->uOldState & LVIS_SELECTED))
        {
            DrvUpdateStatusBar(Context, NMListView->iItem);
        }

        break;
    default:
        return FALSE;
    }

    return TRUE;
}

/*
* DrvDlgHandleWMCommand
*
* Purpose:
*
* WM_COMMAND handler.
*
*/
VOID DrvDlgHandleWMCommand(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
    LPWSTR lpFileName;

    UNREFERENCED_PARAMETER(lParam);

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case ID_OBJECT_COPY:

        if (pDlgContext) {

            supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                pDlgContext->lvItemHit,
                pDlgContext->lvColumnHit);

        }

        break;

    case IDCANCEL:
        SendMessage(hwndDlg, WM_CLOSE, 0, 0);
        break;

    case ID_DRVLIST_DUMP:
        DrvDumpDriver(pDlgContext, FALSE);
        break;
    case ID_DRVLIST_DUMPFIXED:
        DrvDumpDriver(pDlgContext, TRUE);
        break;

    case ID_JUMPTOFILE:
        if (pDlgContext) {
            supJumpToFileListView(pDlgContext->ListView, COLUMN_DRVLIST_MODULE_NAME);
        }
        break;

    case ID_DRVLIST_SAVE:

        if (pDlgContext) {

            if (pDlgContext->DialogMode == DrvModeNormal)
                lpFileName = TEXT("Drivers.csv");
            else
                lpFileName = TEXT("UnloadedDrivers.csv");

            if (supListViewExportToFile(
                lpFileName,
                hwndDlg,
                pDlgContext->ListView))
            {
                supStatusBarSetText(pDlgContext->StatusBar, 1, T_LIST_EXPORT_SUCCESS);
            }
        }
        break;

    case ID_DRVLIST_PROP:
        if (pDlgContext) {
            DrvListViewProperties(pDlgContext);
        }
        break;

    case ID_DRVLIST_REFRESH:
        if (pDlgContext) {

            if (pDlgContext->DialogMode == DrvModeNormal) {

                DrvListDrivers(pDlgContext, TRUE);

            }
            else {

                DrvListUnloadedDrivers(pDlgContext, TRUE);

            }
        }
        break;

    case ID_CALC_HASH_MD5:
    case ID_CALC_HASH_SHA1:
    case ID_CALC_HASH_SHA256:
    case ID_CALC_HASH_SHA384:
    case ID_CALC_HASH_SHA512:
    case ID_CALC_HASH_PAGE_SHA1:
    case ID_CALC_HASH_PAGE_SHA256:
        DrvListCopyHash(pDlgContext, LOWORD(wParam));
        break;

    }
}

/*
* DrvListSetTooltip
*
* Purpose:
*
* Collect all information for tooltip and set it.
*
*/
VOID DrvListSetTooltip(
    _In_ EXTRASCONTEXT* Context,
    _In_ HWND ListViewHandle,
    _In_ INT iItem
)
{
    ULONG_PTR drvBase;
    BOOL bShimmed;
    GUID shimGUID;
    SUP_SHIM_INFO* shimInfo;
    SIZE_T cchText;
    SIZE_T cchRemaining;
    SIZE_T cchWritten;
    int charsWritten;
    WCHAR* lpText;

    WCHAR szBuffer[MAX_PATH];
    WCHAR szNameWithoutExt[MAX_PATH];

    if (Context == NULL)
        return;

    DrvTooltipFreeBuffer(Context);

    cchText = 4096;
    lpText = (WCHAR*)supHeapAlloc(cchText * sizeof(WCHAR));
    if (lpText == NULL)
        return;

    lpText[0] = 0;
    cchWritten = 0;

    //
    // Name
    //
    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
    supGetItemText2(ListViewHandle, iItem,
        COLUMN_DRVLIST_DRIVER_NAME, szBuffer, MAX_PATH);

    charsWritten = RtlStringCchPrintfSecure(&lpText[cchWritten],
        cchText,
        TEXT("%ws"),
        szBuffer);

    if (charsWritten > 0) {
        cchWritten += charsWritten;
    }

    szNameWithoutExt[0] = 0;
    _filename_noext(szNameWithoutExt, szBuffer);

    //
    // Base
    //
    szBuffer[0] = 0;
    supGetItemText2(ListViewHandle, iItem,
        COLUMN_DRVLIST_DRIVER_ADDRESS, szBuffer, 32);

    cchRemaining = cchText - cchWritten;
    if (cchRemaining) {
        charsWritten = RtlStringCchPrintfSecure(&lpText[cchWritten],
            cchRemaining,
            TEXT("\n%ws\n"),
            szBuffer);

        if (charsWritten > 0) {
            cchWritten += charsWritten;
        }
    }

    drvBase = hextou64(&szBuffer[2]);

    //
    // Module name
    //
    szBuffer[0] = 0;
    supGetItemText2(ListViewHandle, iItem,
        COLUMN_DRVLIST_MODULE_NAME, szBuffer, MAX_PATH);

    cchRemaining = cchText - cchWritten;
    if (cchRemaining) {
        charsWritten = RtlStringCchPrintfSecure(&lpText[cchWritten],
            cchRemaining,
            TEXT("%ws"),
            szBuffer);

        if (charsWritten > 0) {
            cchWritten += charsWritten;
        }
    }

    //
    // Filter driver mark
    //
    if (supFilterFindByName(&g_DrvFilterListHead, szNameWithoutExt)) {

        cchRemaining = cchText - cchWritten;
        if (cchRemaining) {
            charsWritten = RtlStringCchPrintfSecure(&lpText[cchWritten],
                cchRemaining,
                TEXT("\nRegistered as filter"));

            if (charsWritten > 0) {
                cchWritten += charsWritten;
            }
        }
    }

    //
    // Shim desc
    //
    szBuffer[0] = 0;
    supGetItemText2(ListViewHandle, iItem,
        COLUMN_DRVLIST_SHIMMED, szBuffer, MAX_PATH);

    if (szBuffer[0]) {

        bShimmed = supIsDriverShimmed(&g_kdctx.Data->KseEngineDump, (PVOID)drvBase, &shimGUID);
        if (bShimmed) {

            shimInfo = supGetDriverShimInformation(shimGUID);
            if (shimInfo) {

                cchRemaining = cchText - cchWritten;
                if (cchRemaining) {
                    charsWritten = RtlStringCchPrintfSecure(&lpText[cchWritten],
                        cchRemaining,
                        L"\n\n%ws\n%ws",
                        shimInfo->KseShimName,
                        shimInfo->Description);

                    if (charsWritten > 0) {
                        cchWritten += charsWritten;
                    }
                }

            }
        }
    }

    Context->TooltipBuffer = lpText;
}

/*
* DrvListViewHookProc
*
* Purpose:
*
* Drivers Dialog listview hook handler.
*
*/
LRESULT CALLBACK DrvListViewHookProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    HWND hwndTT;
    LVHITTESTINFO ht;
    TOOLINFO toolInfo;
    BOOL bCheckPass = FALSE;
    static int oldX = -1, oldY = -1;
    static int lastItem = -1;
    INT currentItem;

    hwndTT = (HWND)DrvDlgContext[DrvModeNormal].TooltipInfo;

    switch (uMsg) {

    case WM_MOUSEMOVE:

        RtlSecureZeroMemory(&ht, sizeof(ht));
        ht.pt.x = GET_X_LPARAM(lParam);
        ht.pt.y = GET_Y_LPARAM(lParam);

        if (ChildWindowFromPoint(hwnd, ht.pt) == hwnd) {
            if (ListView_SubItemHitTest(hwnd, &ht) != -1) {
                bCheckPass = (ht.iSubItem == COLUMN_DRVLIST_DRIVER_NAME);
            }
        }

        //
        // If tooltip window is not available, skip tooltip actions.
        //
        if (hwndTT == NULL || !IsWindow(hwndTT)) {
            lastItem = -1;
            oldX = oldY = -1;
            break;
        }

        //
        // Deactivate tooltip if not on the name column or no item.
        //
        if (!bCheckPass || !(ht.flags & LVHT_ONITEM)) {

            if (lastItem != -1) {
                RtlSecureZeroMemory(&toolInfo, sizeof(toolInfo));
                toolInfo.cbSize = sizeof(toolInfo);
                toolInfo.hwnd = DrvDlgContext[DrvModeNormal].hwndDlg;
                toolInfo.uFlags = TTF_TRACK | TTF_ABSOLUTE | TTF_IDISHWND;
                toolInfo.uId = (UINT_PTR)hwnd;
                SendMessage(hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM)&toolInfo);
            }

            lastItem = -1;
            oldX = oldY = -1;
            break;
        }

        //
        // At this point we are over a name subitem on an item.
        // Only update tooltip when the hovered item changed or cursor moved sufficiently.
        //
        currentItem = ht.iItem;
        if ((currentItem != lastItem) || (ht.pt.x != oldX) || (ht.pt.y != oldY)) {
            oldX = ht.pt.x;
            oldY = ht.pt.y;

            DrvListSetTooltip(&DrvDlgContext[DrvModeNormal], hwnd, currentItem);

            RtlSecureZeroMemory(&toolInfo, sizeof(toolInfo));
            toolInfo.cbSize = sizeof(toolInfo);
            toolInfo.hwnd = DrvDlgContext[DrvModeNormal].hwndDlg;
            toolInfo.uFlags = TTF_TRACK | TTF_ABSOLUTE | TTF_IDISHWND;
            toolInfo.uId = (UINT_PTR)hwnd;

            GetCursorPos(&ht.pt);
            SendMessage(hwndTT, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&toolInfo);
            ht.pt.x += 20;
            ht.pt.y += 20;
            SendMessage(hwndTT, TTM_TRACKPOSITION, 0, (LPARAM)MAKELONG(ht.pt.x, ht.pt.y));
            SendMessage(hwndTT, TTM_UPDATE, 0, 0);

            lastItem = currentItem;
        }

        break;
    }

    return CallWindowProc(g_OriginalListViewProc, hwnd, uMsg, wParam, lParam);
}

/*
* DrvDlgOnInit
*
* Purpose:
*
* Drivers Dialog WM_INITDIALOG handler.
*
*/
VOID DrvDlgOnInit(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1, iColumn;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParam;

    LVCOLUMNS_DATA* pvColumnsData;
    ULONG columnsCount;
    LPWSTR lpCaption;

    LVCOLUMNS_DATA columnDataDrvList[] =
    {
        { L"LoadOrder", 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, iImage },
        { L"Name", 150, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Address", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Size", 80, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Image Path", 280, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE }
    };

    LVCOLUMNS_DATA columnsDataUnloadedDrvList[] = {
        { L"Name", 150, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, iImage },
        { L"StartAddress", 140, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"EndAddress", 140, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"CurrentTime", 140, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE }
    };

    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)lParam);
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);

    pDlgContext->hwndDlg = hwndDlg;
    pDlgContext->lvColumnHit = -1;
    pDlgContext->lvItemHit = -1;

    switch (pDlgContext->DialogMode) {
    case DrvModeUnloaded:
        lpCaption = TEXT("Unloaded Drivers");
        pvColumnsData = columnsDataUnloadedDrvList;
        columnsCount = RTL_NUMBER_OF(columnsDataUnloadedDrvList);
        break;
    default:
        lpCaption = TEXT("Drivers");
        pvColumnsData = columnDataDrvList;
        columnsCount = RTL_NUMBER_OF(columnDataDrvList);
        break;
    }

    SetWindowText(hwndDlg, lpCaption);

    pDlgContext->TooltipBuffer = NULL;
    pDlgContext->StatusBar = GetDlgItem(hwndDlg, ID_EXTRASLIST_STATUSBAR);

    extrasSetDlgIcon(pDlgContext);

    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_EXTRASLIST);
    if (pDlgContext->ListView) {

        pDlgContext->lvColumnHit = -1;
        pDlgContext->lvItemHit = -1;

        //
        // Set listview imagelist, style flags and theme.
        //
        supSetListViewSettings(pDlgContext->ListView,
            LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_INFOTIP | LVS_EX_LABELTIP,
            FALSE,
            TRUE,
            g_ListViewImages,
            LVSIL_SMALL);

        if (pDlgContext->DialogMode == DrvModeNormal) {

            pDlgContext->TooltipInfo = (PVOID)supCreateTrackingToolTip(ID_EXTRASLIST, hwndDlg);
            if (pDlgContext->TooltipInfo) {
                g_OriginalListViewProc = (WNDPROC)SetWindowLongPtr(pDlgContext->ListView,
                    GWLP_WNDPROC,
                    (LONG_PTR)&DrvListViewHookProc);

            }

        }

        //
        // And columns and remember their count.
        //
        iColumn = supAddLVColumnsFromArray(
            pDlgContext->ListView,
            pvColumnsData,
            columnsCount);

        pDlgContext->lvColumnCount = iColumn;

        if (pDlgContext->DialogMode == DrvModeNormal) {

            //
            // Add "Shimmed" column on supported Windows version.
            //
            if (g_NtBuildNumber >= NT_WIN10_THRESHOLD1) {

                if (kdQueryKernelShims(&g_kdctx, FALSE)) {

                    supAddListViewColumn(pDlgContext->ListView,
                        iColumn,
                        iColumn,
                        iColumn,
                        I_IMAGENONE,
                        LVCFMT_CENTER | LVCFMT_BITMAP_ON_RIGHT,
                        TEXT("Shimmed"), 100);

                    DrvDlgShimsEnabled = TRUE;
                    pDlgContext->lvColumnCount += 1;
                }
            }

            DrvListDrivers(pDlgContext, FALSE);

        }
        else {

            DrvListUnloadedDrivers(pDlgContext, FALSE);

        }

        SendMessage(hwndDlg, WM_SIZE, 0, 0);
        SetFocus(pDlgContext->ListView);
    }
}

/*
* DrvDlgProc
*
* Purpose:
*
* Drivers Dialog window procedure.
*
*/
INT_PTR CALLBACK DrvDlgProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext;

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasHandleSettingsChange(pDlgContext);
            return TRUE;
        }
    }

    switch (uMsg) {

    case WM_INITDIALOG:
        DrvDlgOnInit(hwndDlg, lParam);
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                DRVLISTDLG_TRACKSIZE_MIN_X,
                DRVLISTDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_NOTIFY:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            DrvDlgHandleNotify(
                pDlgContext,
                lParam);

#pragma warning(push)
#pragma warning(disable: 26454)
            if (((LPNMHDR)lParam)->code == TTN_GETDISPINFO) {
#pragma warning(pop)
                LPNMTTDISPINFO lpnmtt;

                lpnmtt = (LPNMTTDISPINFO)lParam;

                if (pDlgContext->DialogMode == DrvModeNormal) {

                    if (pDlgContext->TooltipInfo &&
                        lpnmtt->hdr.hwndFrom == (HWND)pDlgContext->TooltipInfo)
                    {
                        if ((HWND)lpnmtt->hdr.idFrom == pDlgContext->ListView) {
                            lpnmtt->lpszText = pDlgContext->TooltipBuffer;
                        }
                    }
                }
            }
        }
        break;

    case WM_SIZE:
        extrasSimpleListResize(hwndDlg);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            if (pDlgContext->TooltipInfo)
                DestroyWindow((HWND)pDlgContext->TooltipInfo);

            DrvTooltipFreeBuffer(pDlgContext);

            extrasRemoveDlgIcon(pDlgContext);

            if (pDlgContext->DialogMode == DrvModeNormal) {
                kdDestroyShimmedDriversList(&g_kdctx.Data->KseEngineDump);
                supFilterDestroyList(&g_DrvFilterListHead);
                g_cDrvFilters = 0;
            }

        }
        if (DumpWorkerWindow) {
            SendMessage(DumpWorkerWindow, WM_CLOSE, 0, 0);
            DumpWorkerWindow = NULL;
        }
        DestroyWindow(hwndDlg);
        break;

    case WM_COMMAND:

        DrvDlgHandleWMCommand(hwndDlg, wParam, lParam);
        break;

    case WM_CONTEXTMENU:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)DrvHandlePopupMenu,
                pDlgContext);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* extrasDrvDlgWorkerThread
*
* Purpose:
*
* Drivers Dialog worker thread.
*
*/
DWORD extrasDrvDlgWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    HWND hwndDlg;
    HACCEL acceleratorTable;
    HANDLE prev;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)Parameter;
    MSG message;
    FAST_EVENT fastEvent;

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_EXTRASLIST),
        0,
        &DrvDlgProc,
        (LPARAM)pDlgContext);

    fastEvent = DrvDlgInitializedEvents[pDlgContext->DialogMode];
    supSetFastEvent(&fastEvent);

    acceleratorTable = LoadAccelerators(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

    if (hwndDlg) {
        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (IsDialogMessage(hwndDlg, &message)) {
                TranslateAccelerator(hwndDlg, acceleratorTable, &message);
            }
            else {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    supResetFastEvent(&fastEvent);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    prev = InterlockedExchangePointer((PVOID*)&DrvDlgThreadHandles[pDlgContext->DialogMode], NULL);
    if (prev) CloseHandle(prev);

    return 0;
}

/*
* extrasCreateDriversDialog
*
* Purpose:
*
* Run Drivers Dialog worker thread.
*
*/
VOID extrasCreateDriversDialog(
    _In_ DRIVERS_DLG_MODE Mode
)
{
    if (Mode < 0 || Mode >= DrvModeMax)
        return;

    if (!DrvDlgThreadHandles[Mode]) {
        RtlSecureZeroMemory(&DrvDlgContext[Mode], sizeof(EXTRASCONTEXT));
        DrvDlgContext[Mode].DialogMode = Mode;
        DrvDlgThreadHandles[Mode] = supCreateDialogWorkerThread(extrasDrvDlgWorkerThread, (PVOID)&DrvDlgContext[Mode], 0);
        if (DrvDlgThreadHandles[Mode])
            supWaitForFastEvent(&DrvDlgInitializedEvents[Mode], NULL);
    }
}

```

`Source/WinObjEx64/extras/extrasIPC.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2025
*
*  TITLE:       EXTRASIPC.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
*  IPC supported: Pipes, Mailslots
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"
#include "propDlg.h"
#include "props.h"

//mailslot root
#define DEVICE_MAILSLOT          L"\\Device\\Mailslot\\"
#define DEVICE_MAILSLOT_LENGTH   sizeof(DEVICE_MAILSLOT) - sizeof(WCHAR)

//named pipes root
#define DEVICE_NAMED_PIPE        L"\\Device\\NamedPipe\\"
#define DEVICE_NAMED_PIPE_LENGTH sizeof(DEVICE_NAMED_PIPE) - sizeof(WCHAR)

#define ID_IPCLIST_REFRESH  ID_VIEW_REFRESH

//maximum number of possible pages
#define EXTRAS_IPC_MAX_PAGE 2

#define IPC_QUERY_MAX_ENTRIES 1000

static HPROPSHEETPAGE IpcPages[EXTRAS_IPC_MAX_PAGE];//object, security
static EXTRASCONTEXT IpcDlgContext[EXTRAS_IPC_MAX_PAGE];

static HANDLE IpcDlgThreadHandles[EXTRAS_IPC_MAX_PAGE] = { NULL, NULL };
static FAST_EVENT IpcDlgInitializedEvents[EXTRAS_IPC_MAX_PAGE] = { FAST_EVENT_INIT, FAST_EVENT_INIT };

/*
* IpcDisplayError
*
* Purpose:
*
* Display last Win32 error.
*
*/
VOID IpcDisplayError(
    _In_ HWND hwndDlg,
    _In_ IPC_DLG_MODE DialogMode
)
{
    DWORD dwLastError;
    WCHAR szBuffer[MAX_PATH * 2];

    dwLastError = GetLastError();
    ShowWindow(GetDlgItem(hwndDlg, ID_PIPE_QUERYFAIL), SW_SHOW);

    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));

    switch (DialogMode) {
    case IpcModeMailSlots:
        _strcpy(szBuffer, TEXT("Cannot open mailslot because: "));
        break;
    case IpcModeNamedPipes:
    default:
        _strcpy(szBuffer, TEXT("Cannot open pipe because: "));
        break;
    }

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        0, _strend(szBuffer), MAX_PATH, NULL);
    SetDlgItemText(hwndDlg, ID_PIPE_QUERYFAIL, szBuffer);
}

/*
* IpcCreateObjectPathWithName
*
* Purpose:
*
* Create complete object name including directory.
* Caller responsible for cleanup with supHeapFree after use.
*
*/
LPWSTR IpcCreateObjectPathWithName(
    _In_ LPWSTR lpObjectName,
    _In_ IPC_DLG_MODE Mode
)
{
    LPWSTR lpFullName = NULL, lpRootDirectory = NULL;
    SIZE_T sz;

    sz = (1 + _strlen(lpObjectName)) * sizeof(WCHAR);

    switch (Mode) {
    case IpcModeNamedPipes:
        sz += DEVICE_NAMED_PIPE_LENGTH;
        lpRootDirectory = DEVICE_NAMED_PIPE;
        break;
    case IpcModeMailSlots:
        sz += DEVICE_MAILSLOT_LENGTH;
        lpRootDirectory = DEVICE_MAILSLOT;
        break;
    }

    if (lpRootDirectory) {
        lpFullName = (LPWSTR)supHeapAlloc(sz);
        if (lpFullName == NULL) {
            return NULL;
        }
        _strcpy(lpFullName, lpRootDirectory);
        _strcat(lpFullName, lpObjectName);
    }

    return lpFullName;
}

/*
* IpcOpenObjectMethod
*
* Purpose:
*
* Used by Security Editor to access object by name.
*
*/
BOOL CALLBACK IpcOpenObjectMethod(
    _In_ PROP_OBJECT_INFO* Context,
    _Inout_ PHANDLE phObject,
    _In_ ACCESS_MASK DesiredAccess
)
{
    BOOL                bResult = FALSE;
    HANDLE              hObject;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   obja;
    IO_STATUS_BLOCK     iost;

    *phObject = NULL;

    hObject = NULL;
    InitializeObjectAttributes(&obja, &Context->NtObjectPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hObject, DesiredAccess, &obja, &iost,
        FILE_SHARE_VALID_FLAGS, FILE_NON_DIRECTORY_FILE);

    if (NT_SUCCESS(status)) {
        *phObject = hObject;
    }
    SetLastError(RtlNtStatusToDosError(status));
    bResult = (NT_SUCCESS(status) && (hObject != NULL));
    return bResult;
}

/*
* IpcMailslotQueryInfo
*
* Purpose:
*
* Query basic info about mailslot.
*
*/
VOID IpcMailslotQueryInfo(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg
)
{
    HANDLE          hMailslot;
    NTSTATUS        status;
    WCHAR           szBuffer[MAX_PATH];
    IO_STATUS_BLOCK iost;

    FILE_MAILSLOT_QUERY_INFORMATION fmqi;

    hMailslot = NULL;
    if (!IpcOpenObjectMethod(Context, &hMailslot, GENERIC_READ)) {
        //on error display last win32 error
        IpcDisplayError(hwndDlg, IpcModeMailSlots);
        return;
    }

    supDisplayCurrentObjectPath(
        GetDlgItem(hwndDlg, ID_MAILSLOT_FULLPATH), 
        &Context->NtObjectPath, 
        FALSE);

    RtlSecureZeroMemory(&fmqi, sizeof(fmqi));
    status = NtQueryInformationFile(hMailslot, &iost, &fmqi, sizeof(fmqi), FileMailslotQueryInformation);
    if (NT_SUCCESS(status)) {
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

        //mailslot quota
        ultostr(fmqi.MailslotQuota, szBuffer);
        SetDlgItemText(hwndDlg, ID_MAILSLOT_QUOTA, szBuffer);

        //messages available
        ultostr(fmqi.MessagesAvailable, szBuffer);
        SetDlgItemText(hwndDlg, ID_MAILSLOT_MSGAVAILABLE, szBuffer);

        //next message
        ultohex(fmqi.NextMessageSize, szBuffer);
        SetDlgItemText(hwndDlg, ID_MAILSLOT_NEXTMSGSZ, szBuffer);

        //maximum message size
        ultostr(fmqi.MaximumMessageSize, szBuffer);
        SetDlgItemText(hwndDlg, ID_MAILSLOT_MAXMESSAGESZ, szBuffer);

        //read timeout
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        ultohex(fmqi.ReadTimeout.LowPart, szBuffer);
        _strcat(szBuffer, L":");
        ultohex(fmqi.ReadTimeout.HighPart, _strend(szBuffer));
        SetDlgItemText(hwndDlg, ID_MAILSLOT_READTIMEOUT, szBuffer);
    }
    NtClose(hMailslot);
}

/*
* IpcPipeQueryInfo
*
* Purpose:
*
* Query basic info about pipe.
*
*/
VOID IpcPipeQueryInfo(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg
)
{
    LPWSTR                      lpType;
    HANDLE                      hPipe;
    NTSTATUS                    status;
    WCHAR                       szBuffer[64];
    IO_STATUS_BLOCK             iost;
    FILE_PIPE_LOCAL_INFORMATION fpli;

    supDisplayCurrentObjectPath(GetDlgItem(hwndDlg, ID_PIPE_FULLPATH), 
        &Context->NtObjectPath, 
        FALSE);

    //open pipe
    hPipe = NULL;
    if (!IpcOpenObjectMethod(Context, &hPipe, GENERIC_READ)) {

        // for pipes created with PIPE_ACCESS_INBOUND open mode 
        // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea

        if (!IpcOpenObjectMethod(Context, &hPipe, GENERIC_WRITE | FILE_READ_ATTRIBUTES)) {
            IpcDisplayError(hwndDlg, IpcModeNamedPipes);
            return;
        }
    }

    RtlSecureZeroMemory(&fpli, sizeof(fpli));
    status = NtQueryInformationFile(hPipe, &iost, &fpli, sizeof(fpli), FilePipeLocalInformation);
    if (NT_SUCCESS(status)) {

        //Type
        lpType = TEXT("?");
        switch (fpli.NamedPipeType) {
        case FILE_PIPE_BYTE_STREAM_TYPE:
            lpType = TEXT("Byte stream");
            break;
        case FILE_PIPE_MESSAGE_TYPE:
            lpType = TEXT("Message");
            break;
        }
        SetDlgItemText(hwndDlg, ID_PIPE_TYPEMODE, lpType);

        //AccessMode
        lpType = TEXT("?");
        switch (fpli.NamedPipeConfiguration) {
        case FILE_PIPE_INBOUND:
            lpType = TEXT("Inbound");
            break;
        case FILE_PIPE_OUTBOUND:
            lpType = TEXT("Outbound");
            break;
        case FILE_PIPE_FULL_DUPLEX:
            lpType = TEXT("Duplex");
            break;
        }
        SetDlgItemText(hwndDlg, ID_PIPE_ACCESSMODE, lpType);

        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

        //CurrentInstances
        ultostr(fpli.CurrentInstances, szBuffer);
        SetDlgItemText(hwndDlg, ID_PIPE_CURINSTANCES, szBuffer);

        //MaximumInstances
        if (fpli.MaximumInstances == MAXDWORD) {
            _strcpy(szBuffer, TEXT("Unlimited"));
        }
        else {
            ultostr(fpli.MaximumInstances, szBuffer);
        }
        SetDlgItemText(hwndDlg, ID_PIPE_MAXINSTANCES, szBuffer);

        //InboundQuota
        ultostr(fpli.InboundQuota, szBuffer);
        SetDlgItemText(hwndDlg, ID_PIPE_INBUFFER, szBuffer);

        //OutboundQuota
        ultostr(fpli.OutboundQuota, szBuffer);
        SetDlgItemText(hwndDlg, ID_PIPE_OUTBUFFER, szBuffer);

        //WriteQuotaAvailable
        ultostr(fpli.WriteQuotaAvailable, szBuffer);
        SetDlgItemText(hwndDlg, ID_PIPE_WRITEQUOTAAVAIL, szBuffer);
    }
    else {
        //show detail on query error
        SetLastError(RtlNtStatusToDosError(status));
        IpcDisplayError(hwndDlg, IpcModeNamedPipes);
    }
    NtClose(hPipe);
}

/*
* IpcTypeDialogProc
*
* Purpose:
*
* Object Properties Dialog Procedure
*
*/
INT_PTR CALLBACK IpcTypeDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    PROPSHEETPAGE* pSheet = NULL;
    PROP_OBJECT_INFO* Context = NULL;
    HICON             hIcon;

    EXTRASCONTEXT* pDlgContext;

    switch (uMsg) {

    case WM_INITDIALOG:
        pSheet = (PROPSHEETPAGE*)lParam;
        if (pSheet) {
            SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
            Context = (PROP_OBJECT_INFO*)pSheet->lParam;
            if (Context) {
                pDlgContext = (EXTRASCONTEXT*)Context->ExtrasContext;
                if (pDlgContext) {

                    hIcon = ImageList_GetIcon(pDlgContext->ImageList,
                        0,
                        ILD_NORMAL | ILD_TRANSPARENT);
                    if (hIcon) {

                        SendDlgItemMessage(hwndDlg, ID_OBJECT_ICON,
                            STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

                        pDlgContext->ObjectIcon = hIcon;
                    }

                }
            }
        }
        return 1;
        break;

    case WM_SHOWWINDOW:
        if (wParam) {
            Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
            if (Context) {
                pDlgContext = (EXTRASCONTEXT*)Context->ExtrasContext;
                if (pDlgContext) {
                    switch (pDlgContext->DialogMode) {
                    case IpcModeMailSlots:
                        IpcMailslotQueryInfo(Context, hwndDlg);
                        break;
                    case IpcModeNamedPipes:
                        IpcPipeQueryInfo(Context, hwndDlg);
                        break;
                    }
                }
            }
        }
        return 1;
        break;

    case WM_DESTROY:
        Context = (PROP_OBJECT_INFO*)RemoveProp(hwndDlg, T_PROPCONTEXT);
        if (Context) {
            pDlgContext = (EXTRASCONTEXT*)Context->ExtrasContext;
            if (pDlgContext) {
                DestroyIcon(pDlgContext->ObjectIcon);
                pDlgContext->ObjectIcon = NULL;
            }
        }
        break;

    }
    return 0;
}

/*
* IpcDlgShowProperties
*
* Purpose:
*
* Show properties dialog for selected object.
* Because of Pipe special case we cannot use propCreateDialog.
*
*/
VOID IpcDlgShowProperties(
    _In_ INT iItem,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    INT nPages = 0;
    PROP_OBJECT_INFO* Context;
    HPROPSHEETPAGE SecurityPage = NULL;
    PROPSHEETPAGE Page;
    PROPSHEETHEADER PropHeader;
    WCHAR szCaption[MAX_PATH];
    PROP_CONFIG propConfig;

    LPWSTR objectName, objectPathCombined;
    UNICODE_STRING objectPathNt;

    objectName = supGetItemText(pDlgContext->ListView, iItem, 0, NULL);
    if (objectName == NULL)
        return;

    objectPathCombined = IpcCreateObjectPathWithName(objectName,
        (IPC_DLG_MODE)pDlgContext->DialogMode);
    if (objectPathCombined == NULL) {
        supHeapFree(objectName);
        return;
    }

    RtlSecureZeroMemory(&propConfig, sizeof(propConfig));
    propConfig.ContextType = propNormal;
    propConfig.ObjectTypeIndex = ObjectTypeFile;

    RtlInitUnicodeString(&objectPathNt, objectPathCombined); //freed by propContextDestroy
    propConfig.NtObjectPath = &objectPathNt;

    Context = propContextCreate(&propConfig);
    if (Context == NULL)
        return;

    Context->ExtrasContext = (PVOID)pDlgContext;

    supHeapFree(objectName);

    RtlSecureZeroMemory(&IpcPages, sizeof(IpcPages));
    //
    //Create object page
    //
    RtlSecureZeroMemory(&Page, sizeof(Page));
    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    Page.hInstance = g_WinObj.hInstance;
    Page.pfnDlgProc = IpcTypeDialogProc;

    switch (pDlgContext->DialogMode) {
    case IpcModeMailSlots:
        Page.pszTemplate = MAKEINTRESOURCE(IDD_PROP_MAILSLOT);
        Page.pszTitle = TEXT("Mailslot");
        break;
    case IpcModeNamedPipes:
    default:
        Page.pszTemplate = MAKEINTRESOURCE(IDD_PROP_PIPE);
        Page.pszTitle = TEXT("Pipe");
        break;
    }
    Page.lParam = (LPARAM)Context;
    IpcPages[nPages++] = CreatePropertySheetPage(&Page);

    //
    // Disconnected clients cannot query security (see msfs!MsCommonQuerySecurityInfo).
    //
    if (pDlgContext->DialogMode != IpcModeMailSlots) {

        //
        //Create Security Dialog if available
        //
        SecurityPage = propSecurityCreatePage(
            Context,
            (POPENOBJECTMETHOD)&IpcOpenObjectMethod,
            NULL, //use default close method
            SI_EDIT_AUDITS | SI_EDIT_OWNER | SI_EDIT_PERMS | //psiFlags
            SI_ADVANCED | SI_NO_ACL_PROTECT | SI_NO_TREE_APPLY |
            SI_PAGE_TITLE
        );
        if (SecurityPage != NULL) {
            IpcPages[nPages++] = SecurityPage;
        }
    }

    //
    //Create property sheet
    //
    _strcpy(szCaption, TEXT("Properties"));
    RtlSecureZeroMemory(&PropHeader, sizeof(PropHeader));
    PropHeader.dwSize = sizeof(PropHeader);
    PropHeader.phpage = IpcPages;
    PropHeader.nPages = nPages;
    PropHeader.dwFlags = PSH_DEFAULT | PSH_NOCONTEXTHELP;
    PropHeader.nStartPage = 0;
    PropHeader.hwndParent = pDlgContext->hwndDlg;
    PropHeader.hInstance = g_WinObj.hInstance;
    PropHeader.pszCaption = szCaption;

    PropertySheet(&PropHeader);
    propContextDestroy(Context);
}

/*
* IpcDlgCompareFunc
*
* Purpose:
*
* Ipc Dialog listview comparer function.
*
*/
INT CALLBACK IpcDlgCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort //pointer to EXTRASCALLBACK
)
{
    EXTRASCONTEXT* pDlgContext;
    EXTRASCALLBACK* CallbackParam = (EXTRASCALLBACK*)lParamSort;

    if (CallbackParam == NULL)
        return 0;

    pDlgContext = &IpcDlgContext[CallbackParam->Value];

    return supListViewBaseComparer(pDlgContext->ListView,
        pDlgContext->bInverseSort,
        lParam1,
        lParam2,
        (LPARAM)CallbackParam->lParam);
}

/*
* IpcDlgQueryInfo
*
* Purpose:
*
* List objects from device.
*
*/
VOID IpcDlgQueryInfo(
    _In_ IPC_DLG_MODE Mode,
    _In_ BOOL bRefresh,
    _In_ HWND ListView
)
{
    BOOLEAN                     bRestartScan;
    INT                         c;
    ULONG                       querySize, fnameChars;
    HANDLE                      hObject = NULL;
    LPWSTR                      lpObjectRoot;
    FILE_DIRECTORY_INFORMATION* DirectoryInfo = NULL;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           obja;
    UNICODE_STRING              uStr;
    IO_STATUS_BLOCK             iost;
    LVITEM                      lvitem;
    EXTRASCALLBACK              callbackParam;
    WCHAR                       nameBuf[MAX_PATH * 2];

    lpObjectRoot = (Mode == IpcModeMailSlots) ? DEVICE_MAILSLOT : DEVICE_NAMED_PIPE;

    if (bRefresh)
        ListView_DeleteAllItems(ListView);

    __try {

        RtlInitUnicodeString(&uStr, lpObjectRoot);
        InitializeObjectAttributes(&obja, &uStr, OBJ_CASE_INSENSITIVE, NULL, NULL);

        status = NtOpenFile(
            &hObject,
            FILE_LIST_DIRECTORY,
            &obja,
            &iost,
            FILE_SHARE_VALID_FLAGS,
            0);

        if (!NT_SUCCESS(status) || (hObject == NULL))
            __leave;

        querySize = PAGE_SIZE;
        DirectoryInfo = (FILE_DIRECTORY_INFORMATION*)supHeapAlloc((SIZE_T)querySize);
        if (DirectoryInfo == NULL)
            __leave;

        c = 0;
        bRestartScan = TRUE;
        while (TRUE) {

            RtlSecureZeroMemory(&iost, sizeof(iost));

            status = NtQueryDirectoryFile(hObject, NULL, NULL, NULL, &iost,
                DirectoryInfo,
                querySize,
                FileDirectoryInformation,
                TRUE, //ReturnSingleEntry
                NULL,
                bRestartScan //RestartScan
            );

            if ((!NT_SUCCESS(status)) ||
                (!NT_SUCCESS(iost.Status)) ||
                (iost.Information == 0))
            {
                break;
            }

            //Name
            fnameChars = (DirectoryInfo->FileNameLength / sizeof(WCHAR));
            if (fnameChars >= RTL_NUMBER_OF(nameBuf)) fnameChars = RTL_NUMBER_OF(nameBuf) - 1;
            RtlCopyMemory(nameBuf, DirectoryInfo->FileName, fnameChars * sizeof(WCHAR));
            nameBuf[fnameChars] = L'\0';

            RtlSecureZeroMemory(&lvitem, sizeof(lvitem));
            lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
            lvitem.pszText = nameBuf;
            lvitem.iItem = MAXINT;
            ListView_InsertItem(ListView, &lvitem);
            bRestartScan = FALSE;
            RtlSecureZeroMemory(DirectoryInfo, querySize);

            c++;
            if (c > IPC_QUERY_MAX_ENTRIES) {//its a trap
                break;
            }
        }
    }
    __finally {

        if (AbnormalTermination())
            supReportAbnormalTermination(__FUNCTIONW__);

        if (DirectoryInfo != NULL) {
            supHeapFree(DirectoryInfo);
        }

        if (hObject) {
            NtClose(hObject);
        }

        callbackParam.lParam = 0;
        callbackParam.Value = Mode;
        ListView_SortItemsEx(ListView, &IpcDlgCompareFunc, (LPARAM)&callbackParam);

    }
}

/*
* IpcDlgHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for dialog listview.
*
*/
BOOL IpcDlgHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    LVCOLUMN col;
    LPNMHDR  nhdr = (LPNMHDR)lParam;
    INT      item;

    EXTRASCONTEXT* pDlgContext;
    EXTRASCALLBACK CallbackParam;

    if (nhdr == NULL)
        return FALSE;

    if (nhdr->idFrom != ID_IPCOBJECTSLIST)
        return FALSE;

    pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_IPCDLGCONTEXT);
    if (pDlgContext == NULL)
        return FALSE;

    switch (nhdr->code) {

    case LVN_COLUMNCLICK:
        pDlgContext->bInverseSort = (~pDlgContext->bInverseSort) & 1;

        CallbackParam.lParam = 0;
        CallbackParam.Value = pDlgContext->DialogMode;
        ListView_SortItemsEx(pDlgContext->ListView, &IpcDlgCompareFunc, (LPARAM)&CallbackParam);

        RtlSecureZeroMemory(&col, sizeof(col));
        col.mask = LVCF_IMAGE;

        if (pDlgContext->bInverseSort)
            col.iImage = 1;
        else
            col.iImage = 2;

        ListView_SetColumn(pDlgContext->ListView, 0, &col);
        break;

    case NM_DBLCLK:
        item = ((LPNMLISTVIEW)lParam)->iItem;
        if (item >= 0) {
            IpcDlgShowProperties(item, pDlgContext);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* IpcDlgHandlePopupMenu
*
* Purpose:
*
* Popup menu construction.
*
*/
VOID IpcDlgHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    UINT uPos = 0;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_OBJECT_PROPERTIES, T_PROPERTIES);

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            uPos++,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }

        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_IPCLIST_REFRESH, T_VIEW_REFRESH);

        TrackPopupMenu(hMenu,
            TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            lpPoint->x,
            lpPoint->y,
            0,
            hwndDlg,
            NULL);

        DestroyMenu(hMenu);
    }
}

/*
* IpcDlgOnInit
*
* Purpose:
*
* Ipc dialog WM_INITDIALOG handler.
*
*/
VOID IpcDlgOnInit(
    _In_  HWND hwndDlg,
    _In_  LPARAM lParam
)
{
    INT iResId = 0;
    HICON hIcon;
    SIZE_T sz = 0;
    LPWSTR lpObjectsRoot = NULL, lpObjectRelativePath = NULL;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParam;

    SetProp(hwndDlg, T_IPCDLGCONTEXT, (HANDLE)lParam);
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);

    pDlgContext->lvColumnHit = -1;
    pDlgContext->lvItemHit = -1;
    pDlgContext->hwndDlg = hwndDlg;

    switch (pDlgContext->DialogMode) {
    case IpcModeMailSlots:
        iResId = IDI_ICON_MAILSLOT;
        sz = DEVICE_MAILSLOT_LENGTH;
        lpObjectsRoot = DEVICE_MAILSLOT;
        SetWindowText(hwndDlg, TEXT("Mailslots"));
        break;
    default:
        iResId = IDI_ICON_PIPE;
        sz = DEVICE_NAMED_PIPE_LENGTH;
        lpObjectsRoot = DEVICE_NAMED_PIPE;
        SetWindowText(hwndDlg, TEXT("Pipes"));
        break;
    }

    lpObjectRelativePath = (LPWSTR)supHeapAlloc(sz + 100);
    if (lpObjectRelativePath) {
        _strcpy(lpObjectRelativePath, TEXT("Relative Path ( "));
        _strcat(lpObjectRelativePath, lpObjectsRoot);
        _strcat(lpObjectRelativePath, TEXT(" )"));
        SetDlgItemText(hwndDlg, ID_IPCROOT, lpObjectRelativePath);
        supHeapFree(lpObjectRelativePath);
    }

    //setup dlg listview
    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_IPCOBJECTSLIST);
    if (pDlgContext->ListView) {
        pDlgContext->ImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 42, 8);
        if (pDlgContext->ImageList) {

            //set object icon
            hIcon = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(iResId), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);
            if (hIcon) {
                ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hIcon);
                DestroyIcon(hIcon);
            }
            //sort images
            hIcon = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_SORTUP), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);
            if (hIcon) {
                ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hIcon);
                DestroyIcon(hIcon);
            }
            hIcon = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_SORTDOWN), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);
            if (hIcon) {
                ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hIcon);
                DestroyIcon(hIcon);
            }
        }

        //
        // Set listview imagelist, style flags and theme.
        //
        supSetListViewSettings(pDlgContext->ListView,
            LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
            FALSE,
            TRUE,
            pDlgContext->ImageList,
            LVSIL_SMALL);

        supAddListViewColumn(pDlgContext->ListView, 0, 0, 0,
            2,
            LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,
            TEXT("Name"), 500);

        supDisableRedraw(pDlgContext->ListView);

        IpcDlgQueryInfo((IPC_DLG_MODE)pDlgContext->DialogMode, FALSE, pDlgContext->ListView);

        supEnableRedraw(pDlgContext->ListView);
    }
}

/*
* IpcDlgProc
*
* Purpose:
*
* Ipc objects window procedure.
*
*/
INT_PTR CALLBACK IpcDlgProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    INT nSelected;
    EXTRASCONTEXT* pDlgContext;

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_IPCDLGCONTEXT);
        if (pDlgContext) {
            extrasHandleSettingsChange(pDlgContext);
        }
        return TRUE;
    }

    switch (uMsg) {
    case WM_NOTIFY:
        return IpcDlgHandleNotify(hwndDlg, lParam);

    case WM_INITDIALOG:
        IpcDlgOnInit(hwndDlg, lParam);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_IPCDLGCONTEXT);
        if (pDlgContext) {
            ImageList_Destroy(pDlgContext->ImageList);
        }
        DestroyWindow(hwndDlg);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_IPCLIST_REFRESH:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_IPCDLGCONTEXT);
            if (pDlgContext) {

                supDisableRedraw(pDlgContext->ListView);

                IpcDlgQueryInfo((IPC_DLG_MODE)pDlgContext->DialogMode, TRUE, pDlgContext->ListView);

                supEnableRedraw(pDlgContext->ListView);

            }
            break;

        case ID_OBJECT_COPY:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_IPCDLGCONTEXT);
            if (pDlgContext) {
                supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                    pDlgContext->lvItemHit,
                    pDlgContext->lvColumnHit);
            }
            break;

        case ID_OBJECT_PROPERTIES:

            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_IPCDLGCONTEXT);
            if (pDlgContext) {
                if (ListView_GetSelectedCount(pDlgContext->ListView)) {
                    nSelected = ListView_GetSelectionMark(pDlgContext->ListView);
                    if (nSelected >= 0) {
                        IpcDlgShowProperties(nSelected, pDlgContext);
                    }
                }
            }

            break;
        }

        break;

    case WM_CONTEXTMENU:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_IPCDLGCONTEXT);
        if (pDlgContext) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)IpcDlgHandlePopupMenu,
                pDlgContext);
        }
        break;

    }

    return FALSE;
}

/*
* extrasIpcDialogWorkerThread
*
* Purpose:
*
* IPC objects dialog worker thread.
*
*/
DWORD extrasIpcDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    HANDLE prev;
    HWND hwndDlg;
    BOOL bResult;
    MSG message;
    HACCEL acceleratorTable;
    FAST_EVENT fastEvent;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)Parameter;

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_IPCOBJECTS),
        0,
        &IpcDlgProc,
        (LPARAM)pDlgContext);

    fastEvent = IpcDlgInitializedEvents[pDlgContext->DialogMode];
    supSetFastEvent(&fastEvent);

    acceleratorTable = LoadAccelerators(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

    if (hwndDlg) {
        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (IsDialogMessage(hwndDlg, &message)) {
                TranslateAccelerator(hwndDlg, acceleratorTable, &message);
            }
            else {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    supResetFastEvent(&fastEvent);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    prev = InterlockedExchangePointer((PVOID*)&IpcDlgThreadHandles[pDlgContext->DialogMode], NULL);
    if (prev) CloseHandle(prev);

    return 0;
}

/*
* extrasCreateIpcDialog
*
* Purpose:
*
* Run IPC objects dialog worker thread.
*
*/
VOID extrasCreateIpcDialog(
    _In_ IPC_DLG_MODE Mode
)
{
    if (Mode < 0 || Mode >= IpcMaxMode)
        return;

    if (!IpcDlgThreadHandles[Mode]) {
        RtlSecureZeroMemory(&IpcDlgContext[Mode], sizeof(EXTRASCONTEXT));
        IpcDlgContext[Mode].DialogMode = Mode;
        IpcDlgThreadHandles[Mode] = supCreateDialogWorkerThread(extrasIpcDialogWorkerThread, (PVOID)&IpcDlgContext[Mode], 0);
        if (IpcDlgThreadHandles[Mode])
            supWaitForFastEvent(&IpcDlgInitializedEvents[Mode], NULL);

    }
}

```

`Source/WinObjEx64/extras/extrasPN.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       EXTRASPN.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"
#include "propDlg.h"

EXTRASCONTEXT PnDlgContext;
ULONG PNSNumberOfObjects = 0;
HANDLE PNSObjectsHeap = NULL;

static HANDLE PnDlgThreadHandle = NULL;
static FAST_EVENT PnDlgInitializedEvent = FAST_EVENT_INIT;

#ifdef _USE_OWN_DRIVER
#define T_NAMESPACE_QUERY_FAILED TEXT("Unable to list namespaces! Make sure you run this program as Admin.")
#else
#define T_NAMESPACE_QUERY_FAILED TEXT("Unable to list namespaces! Make sure you run this program as Admin and Windows is in a DEBUG mode.")
#endif

#define T_NAMESPACE_NOTHING TEXT("No private namespaces found.")

#define COLUMN_PNLIST_ROOTDIRADDRESS 2

/*
* PNDlgResetOutput
*
* Purpose:
*
* Resets controls output.
*
*/
VOID PNDlgResetOutput()
{
    SetDlgItemText(PnDlgContext.hwndDlg, ID_NAMESPACE_ROOT, T_EmptyString);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_NAMESPACE_ADDR, T_EmptyString);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_SIZEOFBOUNDARYINFO, T_EmptyString);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_BDESCRIPTOR_ADDRESS, T_EmptyString);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_BDESCRIPTOR_NAME, T_EmptyString);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_BDESCRIPTOR_SID_ACCOUNT, T_CannotQuery);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_INTEGRITYLABEL, T_CannotQuery);
    SetDlgItemText(PnDlgContext.hwndDlg, ID_BDESCRIPTOR_ENTRIES, TEXT("0"));
    SendDlgItemMessage(PnDlgContext.hwndDlg, ID_BDESCRIPTOR_SID, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
    EnableWindow(GetDlgItem(PnDlgContext.hwndDlg, ID_BDESCRIPTOR_SID_COPY), FALSE);
}

/*
* PNDlgShowObjectProperties
*
* Purpose:
*
* Show selected object properties.
*
*/
VOID PNDlgShowObjectProperties(
    _In_ INT iItem
)
{
    POBJREF objRef = NULL;
    OBJREFPNS pnsInfo;
    PROP_NAMESPACE_INFO propNamespace;
    PROP_CONFIG propConfig;

    //
    // Only one namespace object properties dialog at the same time allowed.
    //
    supCloseKnownPropertiesDialog(propGetNamespaceWindow());

    //
    //  Get ref to object, failure here is critical.
    //
    if (!supGetListViewItemParam(PnDlgContext.ListView, iItem, (PVOID*)&objRef))
        return;

    pnsInfo = objRef->PrivateNamespace;
    RtlSecureZeroMemory(&propNamespace, sizeof(propNamespace));

    propNamespace.ObjectAddress = objRef->ObjectAddress;

    //
    // Dump boundary descriptor, failure here is critical.
    //
    if (!NT_SUCCESS(ObCopyBoundaryDescriptor((OBJECT_NAMESPACE_ENTRY*)pnsInfo.NamespaceLookupEntry,
        &propNamespace.BoundaryDescriptor,
        &propNamespace.SizeOfBoundaryDescriptor)))
    {
        return;
    }

    RtlSecureZeroMemory(&propConfig, sizeof(propConfig));

    propConfig.ContextType = propPrivateNamespace;
    propConfig.NtObjectName = &objRef->Name;
    propConfig.ObjectTypeIndex = objRef->ObjectTypeIndex;
    propConfig.u1.NamespaceObject = &propNamespace;
    propConfig.hwndParent = PnDlgContext.hwndDlg;
    propCreateDialog(&propConfig);

    //
    // propNamespace.BoundaryDescriptor will be freed by propDestroyContext.
    // 
}

/*
* PNListCompareFunc
*
* Purpose:
*
* Main window listview comparer function.
*
*/
INT CALLBACK PNListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    //
    // Sort addresses.
    //
    if (lParamSort == COLUMN_PNLIST_ROOTDIRADDRESS) {
        return supGetMaxOfTwoU64FromHex(PnDlgContext.ListView,
            lParam1,
            lParam2,
            lParamSort,
            PnDlgContext.bInverseSort);
    }

    return supListViewBaseComparer(PnDlgContext.ListView,
        PnDlgContext.bInverseSort,
        lParam1,
        lParam2,
        lParamSort);
}

/*
* PNDlgEnumerateCallback
*
* Purpose:
*
* Callback for private namespaces output.
*
*/
BOOL CALLBACK PNDlgEnumerateCallback(
    _In_ POBJREF Entry,
    _In_opt_ PVOID Context
)
{
    BOOL bNeedFree;
    INT  lvItemIndex;
    WOBJ_OBJECT_TYPE objectTypeIndex;

    LVITEM lvItem;
    WCHAR szBuffer[MAX_PATH + 1];

    UNICODE_STRING objectName;
    WOBJ_TYPE_DESC* typeDesc;

    UNREFERENCED_PARAMETER(Context);

    bNeedFree = supNormalizeUnicodeStringForDisplay(PNSObjectsHeap,
        &Entry->Name,
        &objectName);

    if (!bNeedFree)
        objectName = Entry->Name;

    objectTypeIndex = supGetObjectNameIndexByTypeIndex((PVOID)Entry->ObjectAddress, Entry->TypeIndex);
    typeDesc = ObManagerGetEntryByTypeIndex(objectTypeIndex);
    Entry->ObjectTypeIndex = objectTypeIndex;

    //Name
    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iItem = MAXINT;
    lvItem.iImage = typeDesc->ImageIndex;
    lvItem.pszText = objectName.Buffer;
    lvItem.lParam = (LPARAM)Entry;
    lvItemIndex = ListView_InsertItem(PnDlgContext.ListView, &lvItem);
    if (lvItemIndex >= 0) {
        //Type
        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 1;
        lvItem.pszText = typeDesc->Name;
        lvItem.iItem = lvItemIndex;
        ListView_SetItem(PnDlgContext.ListView, &lvItem);

        //RootDirectory address
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        szBuffer[2] = 0;
        u64tohex(Entry->PrivateNamespace.NamespaceDirectoryAddress, &szBuffer[2]);

        lvItem.iSubItem = 2;
        lvItem.pszText = szBuffer;
        ListView_SetItem(PnDlgContext.ListView, &lvItem);

        PNSNumberOfObjects += 1;
    }

    if (bNeedFree) {
        supFreeDuplicatedUnicodeString(PNSObjectsHeap,
            &objectName,
            FALSE);
    }

    return FALSE;
}

/*
* PNDlgQueryInfo
*
* Purpose:
*
* Query and ouput private namespaces info.
*
*/
BOOL PNDlgQueryInfo(
    VOID
)
{
    PNSNumberOfObjects = 0;

    ObEnumeratePrivateNamespaceTable(
        PNDlgEnumerateCallback,
        (PVOID)PNSObjectsHeap);

    return (PNSNumberOfObjects > 0);
}

#define MAX_LOOKUP_NAME 256

/*
* PNDlgOutputSelectedSidInformation
*
* Purpose:
*
* Output selected Sid information.
*
*/
VOID PNDlgOutputSelectedSidInformation(
    _In_ HWND hwndDlg,
    _In_opt_ PSID Sid
)
{
    BOOL bNeedFree = FALSE;
    HWND hComboBox;
    LRESULT nSelected;
    PSID pSid = NULL;
    LPWSTR lpSidType, lpEnd, lpSidValue;
    SIZE_T sidLength;

    DWORD cAccountName = 0, cReferencedDomainName = 0;

    WCHAR szName[MAX_LOOKUP_NAME];
    WCHAR szDomain[MAX_LOOKUP_NAME];
    WCHAR szAccountInfo[MAX_LOOKUP_NAME * 3];

    ULONG peUse;


    //
    // No SID specified, get current selection in combobox and use it as SID.
    //
    if (Sid == NULL) {
        hComboBox = GetDlgItem(hwndDlg, ID_BDESCRIPTOR_SID);

        nSelected = SendMessage(hComboBox, 
            CB_GETCURSEL, 
            (WPARAM)0, 
            (LPARAM)0);
        
        if (nSelected != CB_ERR) {

            sidLength = SendMessage(hComboBox,
                CB_GETLBTEXTLEN, 
                (WPARAM)nSelected, 
                0);
            
            if (sidLength) {

                lpSidValue = (LPWSTR)supHeapAlloc((1 + sidLength) * sizeof(WCHAR));
                if (lpSidValue) {

                    if (CB_ERR != SendMessage(hComboBox, 
                        CB_GETLBTEXT, 
                        nSelected, 
                        (LPARAM)lpSidValue)) 
                    {
                        bNeedFree = ConvertStringSidToSid(lpSidValue, &pSid);
                    }

                    supHeapFree(lpSidValue);
                }
            }
        }
    }
    else {
        pSid = Sid;
    }

    //
    // Convertion failure.
    //
    if (pSid == NULL)
        return;

    //
    // SID account domain\name (type).
    //
    RtlSecureZeroMemory(szName, sizeof(szName));
    RtlSecureZeroMemory(szDomain, sizeof(szDomain));
    cAccountName = MAX_LOOKUP_NAME;
    cReferencedDomainName = MAX_LOOKUP_NAME;
    RtlSecureZeroMemory(szAccountInfo, sizeof(szAccountInfo));

    if (LookupAccountSid(NULL,
        pSid,
        szName,
        &cAccountName,
        szDomain,
        &cReferencedDomainName,
        (SID_NAME_USE*)&peUse))
    {
        _strcpy(szAccountInfo, szDomain);
        if (cAccountName && cReferencedDomainName) {
            _strcat(szAccountInfo, TEXT("\\"));
        }
        lpEnd = _strcat(szAccountInfo, szName);

        //
        // Type of the account.
        //
        lpSidType = supGetSidNameUse((SID_NAME_USE)peUse);

        RtlStringCchPrintfSecure(lpEnd, 
            MAX_PATH, 
            TEXT(" (%ws)"),
            lpSidType);

    }
    else {
        _strcpy(szAccountInfo, T_CannotQuery);
    }

    SetDlgItemText(hwndDlg, ID_BDESCRIPTOR_SID_ACCOUNT, szAccountInfo);

    if (bNeedFree)
        LocalFree(pSid);
}

/*
* PNDlgBoundaryDescriptorCallback
*
* Purpose:
*
* Boundary descriptor enumerator callback.
*
*/
BOOL CALLBACK PNDlgBoundaryDescriptorCallback(
    _In_ OBJECT_BOUNDARY_ENTRY* Entry,
    _In_ PVOID Context
)
{
    PWSTR pString, lpName;
    PSID Sid;
    HWND hwndDlg = (HWND)Context;
    DWORD dwIL;

    WCHAR szBuffer[MAX_PATH];

    switch (Entry->EntryType) {

    case OBNS_Name:

        if (Entry->EntrySize <= sizeof(OBJECT_BOUNDARY_ENTRY))
            break;

        pString = (PWSTR)RtlOffsetToPointer(Entry, sizeof(OBJECT_BOUNDARY_ENTRY));
        lpName = (PWSTR)supHeapAlloc(Entry->EntrySize);
        if (lpName) {
            RtlCopyMemory(lpName, pString, Entry->EntrySize - sizeof(OBJECT_BOUNDARY_ENTRY));
            SetDlgItemText(hwndDlg, ID_BDESCRIPTOR_NAME, lpName);
            supHeapFree(lpName);
        }
        break;

    case OBNS_SID:

        Sid = (PSID)RtlOffsetToPointer(Entry, sizeof(OBJECT_BOUNDARY_ENTRY));
        if (ConvertSidToStringSid(Sid, &pString)) {

            SendDlgItemMessage(hwndDlg, ID_BDESCRIPTOR_SID,
                CB_ADDSTRING, (WPARAM)0, (LPARAM)pString);

            LocalFree(pString);
        }

        PNDlgOutputSelectedSidInformation(hwndDlg, Sid);
        break;

    case OBNS_IntegrityLabel:

        Sid = (PSID)RtlOffsetToPointer(Entry, sizeof(OBJECT_BOUNDARY_ENTRY));

        dwIL = *RtlSubAuthoritySid(Sid,
            (DWORD)(UCHAR)(*RtlSubAuthorityCountSid(Sid) - 1));

        pString = supIntegrityToString(dwIL);

        RtlStringCchPrintfSecure(szBuffer, MAX_PATH,
            TEXT("%ws (0x%lX)"),
            pString,
            dwIL);

        SetDlgItemText(hwndDlg, ID_INTEGRITYLABEL, szBuffer);
        break;

    }
    return FALSE;
}

/*
* PNDlgShowNamespaceInfo
*
* Purpose:
*
* Display selected private namespace info.
*
*/
VOID PNDlgShowNamespaceInfo(
    _In_ HWND hwndDlg,
    _In_ INT iItem
)
{
    NTSTATUS    ntStatus;
    LPARAM      nSid;
    ULONG_PTR   BoundaryDescriptorAddress = 0;
    POBJREF     objRef = NULL;
    OBJREFPNS   pnsInfo;

    POBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptor = NULL;

    WCHAR szBuffer[200];

    PNDlgResetOutput();

    if (iItem == -1)
        return;

    if (!supGetListViewItemParam(PnDlgContext.ListView, iItem, (PVOID*)&objRef))
        return;

    pnsInfo = objRef->PrivateNamespace;

    //
    // Boundary Descriptor Entries.
    //
    ntStatus = ObCopyBoundaryDescriptor(
        (OBJECT_NAMESPACE_ENTRY*)pnsInfo.NamespaceLookupEntry,
        &BoundaryDescriptor,
        NULL);

    if (NT_SUCCESS(ntStatus) && BoundaryDescriptor) {

        //
        // Namespace root directory.
        //
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        u64tohex(pnsInfo.NamespaceDirectoryAddress, &szBuffer[2]);
        SetDlgItemText(hwndDlg, ID_NAMESPACE_ROOT, szBuffer);

        //
        // Namespace Lookup table entry.
        //
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        u64tohex(pnsInfo.NamespaceLookupEntry, &szBuffer[2]);
        SetDlgItemText(hwndDlg, ID_NAMESPACE_ADDR, szBuffer);

        //
        // SizeOfBoundaryInformation.
        //
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        ultohex(pnsInfo.SizeOfBoundaryInformation, &szBuffer[2]);
        SetDlgItemText(hwndDlg, ID_SIZEOFBOUNDARYINFO, szBuffer);

        //
        // Boundary Descriptor Address.
        //
        BoundaryDescriptorAddress = (ULONG_PTR)RtlOffsetToPointer(
            pnsInfo.NamespaceLookupEntry,
            sizeof(OBJECT_NAMESPACE_ENTRY));

        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        u64tohex(BoundaryDescriptorAddress, &szBuffer[2]);
        SetDlgItemText(hwndDlg, ID_BDESCRIPTOR_ADDRESS, szBuffer);

        //
        // Number of entries.
        //
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        ultostr(BoundaryDescriptor->Items, &szBuffer[0]);
        SetDlgItemText(hwndDlg, ID_BDESCRIPTOR_ENTRIES, szBuffer);

        ObEnumerateBoundaryDescriptorEntries(BoundaryDescriptor,
            PNDlgBoundaryDescriptorCallback,
            (PVOID)hwndDlg);

        //
        // Select first SID if present.
        //
        nSid = SendDlgItemMessage(hwndDlg, ID_BDESCRIPTOR_SID, CB_GETCOUNT, 0, 0);

        EnableWindow(GetDlgItem(hwndDlg, ID_BDESCRIPTOR_SID), (nSid > 0) ? TRUE : FALSE);
        EnableWindow(GetDlgItem(hwndDlg, ID_BDESCRIPTOR_SID_COPY), (nSid > 0) ? TRUE : FALSE);

        SendDlgItemMessage(hwndDlg, ID_BDESCRIPTOR_SID, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

        supHeapFree(BoundaryDescriptor);
    }
    else {

        RtlStringCchPrintfSecure(szBuffer, 100,
            TEXT("%ws, error query PN for %p (NTSTATUS 0x%lX)"),
            __FUNCTIONW__,
            (PVOID)pnsInfo.NamespaceLookupEntry,
            ntStatus);

        logAdd(EntryTypeError, szBuffer);
    }

}

/*
* PNDlgHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for PNDialog listview.
*
*/
VOID PNDlgHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT nImageIndex;
    NM_LISTVIEW* pListView = (NM_LISTVIEW*)lParam;

    if (pListView == NULL)
        return;

    if (pListView->hdr.idFrom == ID_NAMESPACELIST) {

        switch (pListView->hdr.code) {

        case LVN_COLUMNCLICK:

            PnDlgContext.bInverseSort = (~PnDlgContext.bInverseSort) & 1;
            PnDlgContext.lvColumnToSort = pListView->iSubItem;
            ListView_SortItemsEx(PnDlgContext.ListView, &PNListCompareFunc, PnDlgContext.lvColumnToSort);

            nImageIndex = ImageList_GetImageCount(g_ListViewImages);
            if (PnDlgContext.bInverseSort)
                nImageIndex -= 2;
            else
                nImageIndex -= 1;

            supUpdateLvColumnHeaderImage(PnDlgContext.ListView,
                PnDlgContext.lvColumnCount,
                PnDlgContext.lvColumnToSort,
                nImageIndex);

            break;

        case LVN_ITEMCHANGED:

            if ((pListView->uNewState & LVIS_SELECTED) &&
                !(pListView->uOldState & LVIS_SELECTED))
            {
                PNDlgShowNamespaceInfo(hwndDlg, pListView->iItem);
            }
            break;

        case NM_DBLCLK:
            PNDlgShowObjectProperties(pListView->iItem);
            break;

        }
    }

}

/*
* PNDlgCopySelectedSid
*
* Purpose:
*
* Take selected sid entry and copy it as text to clipboard.
*
*/
VOID PNDlgCopySelectedSid(
    _In_ HWND hwndDlg
)
{
    HWND hComboBox = GetDlgItem(hwndDlg, ID_BDESCRIPTOR_SID);
    LPARAM nSelected = SendMessage(hComboBox, CB_GETCURSEL, 0, 0);
    LPARAM TextLength;
    PWCHAR lpStringSid;

    if (nSelected >= 0) {
        TextLength = SendMessage(hComboBox, CB_GETLBTEXTLEN, (WPARAM)nSelected, 0);
        if (TextLength) {
            lpStringSid = (PWCHAR)supHeapAlloc((1 + TextLength) * sizeof(WCHAR));
            if (lpStringSid) {
                SendMessage(hComboBox, CB_GETLBTEXT, nSelected, (LPARAM)lpStringSid);

                supClipboardCopy(lpStringSid, (TextLength * sizeof(WCHAR)));

                supHeapFree(lpStringSid);
            }
        }
    }
}

VOID PNDialogCreateDataHeap(
    _In_ BOOLEAN bRefresh
)
{
    if (bRefresh) {
        if (PNSObjectsHeap) supDestroyHeap(PNSObjectsHeap);
    }

    PNSObjectsHeap = supCreateHeap(HEAP_GROWABLE, TRUE);
}

/*
* PNDialogShowInfo
*
* Purpose:
*
* Display information about private namespaces or message if there is none or error.
*
*/
VOID PNDialogShowInfo(
    _In_ BOOLEAN bRefresh)
{
    ENUMCHILDWNDDATA ChildWndData;

    PNDialogCreateDataHeap(bRefresh);

    if (bRefresh) {
        ListView_DeleteAllItems(PnDlgContext.ListView);
        PNDlgResetOutput();
    }

    if (PNDlgQueryInfo()) {
        ListView_SortItemsEx(PnDlgContext.ListView, &PNListCompareFunc, 0);
    }
    else {
        if (GetWindowRect(PnDlgContext.hwndDlg, &ChildWndData.Rect)) {
            ChildWndData.nCmdShow = SW_HIDE;
            EnumChildWindows(PnDlgContext.hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
        }
        ShowWindow(GetDlgItem(PnDlgContext.hwndDlg, ID_PNAMESPACESINFO), SW_SHOW);

        if (PNSNumberOfObjects == 0) {
            SetDlgItemText(PnDlgContext.hwndDlg, ID_PNAMESPACESINFO, T_NAMESPACE_NOTHING);
        }
        else {
            SetDlgItemText(PnDlgContext.hwndDlg, ID_PNAMESPACESINFO, T_NAMESPACE_QUERY_FAILED);
        }
    }

    SetFocus(PnDlgContext.ListView);
}

/*
* PNDialogHandlePopup
*
* Purpose:
*
* List popup construction.
*
*/
VOID PNDialogHandlePopup(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    UINT uPos = 0;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_OBJECT_PROPERTIES, T_PROPERTIES);

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            uPos++,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_VIEW_REFRESH, T_VIEW_REFRESH);

            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* PNDialogOnClose
*
* Purpose:
*
* Private Namespace Dialog WM_CLOSE handler.
*
*/
VOID PNDialogOnClose(
    _In_ HWND hwndDlg
)
{
    if (PNSObjectsHeap) supDestroyHeap(PNSObjectsHeap);
    DestroyWindow(hwndDlg);
}

/*
* PNDialogOnInit
*
* Purpose:
*
* Private Namespace dialog WM_INITDIALOG handler.
*
*/
VOID PNDialogOnInit(
    _In_ HWND hwndDlg
)
{
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
}

/*
* PNDialogProc
*
* Purpose:
*
* Private Namespace Dialog window procedure.
*
*/
INT_PTR CALLBACK PNDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    INT nSelected;

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        extrasHandleSettingsChange(&PnDlgContext);
        return TRUE;
    }

    switch (uMsg) {
    case WM_NOTIFY:
        PNDlgHandleNotify(hwndDlg, lParam);
        break;

    case WM_INITDIALOG:
        PNDialogOnInit(hwndDlg);
        break;

    case WM_CONTEXTMENU:

        supHandleContextMenuMsgForListView(hwndDlg,
            wParam,
            lParam,
            PnDlgContext.ListView,
            (pfnPopupMenuHandler)PNDialogHandlePopup,
            (PVOID)&PnDlgContext);

        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        PNDialogOnClose(hwndDlg);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_VIEW_REFRESH:
            PNDialogShowInfo(TRUE);
            break;

        case ID_BDESCRIPTOR_SID:
            if (HIWORD(wParam) == CBN_SELCHANGE) {
                PNDlgOutputSelectedSidInformation(hwndDlg, NULL);
            }
            break;

            //copy selected sid value to clipboard
        case ID_BDESCRIPTOR_SID_COPY: 
            PNDlgCopySelectedSid(hwndDlg);
            break;

        case ID_OBJECT_COPY:
            supListViewCopyItemValueToClipboard(PnDlgContext.ListView,
                PnDlgContext.lvItemHit,
                PnDlgContext.lvColumnHit);
            break;

        case ID_OBJECT_PROPERTIES:

            if (ListView_GetSelectedCount(PnDlgContext.ListView)) {

                nSelected = ListView_GetSelectionMark(PnDlgContext.ListView);
                if (nSelected >= 0) {
                    PNDlgShowObjectProperties(nSelected);
                }

            }

            break;

        }

        break;
    }

    return FALSE;
}

/*
* PNSubDlgMsgHandler
*
* Purpose:
*
* Check window message against existing properties dialog.
*
*/
BOOL PNSubDlgMsgHandler(
    _In_ LPMSG lpMsg
)
{
    HWND hwnd;

    hwnd = propGetNamespaceWindow();
    if (hwnd != NULL)
        if (PropSheet_IsDialogMessage(hwnd, lpMsg))
            return TRUE;

    return FALSE;
}

/*
* extrasPNDialogWorkerThread
*
* Purpose:
*
* Private Namespaces Dialog worker thread.
*
*/
DWORD extrasPNDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;
    HACCEL acceleratorTable = NULL;

    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"Name", 280, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  iImage },
        { L"Type", 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"RootDirectory", 140, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    UNREFERENCED_PARAMETER(Parameter);

    RtlSecureZeroMemory(&PnDlgContext, sizeof(PnDlgContext));
    
    hwndDlg = CreateDialogParam(g_WinObj.hInstance, 
        MAKEINTRESOURCE(IDD_DIALOG_PNAMESPACE),
        0, 
        &PNDialogProc, 
        0);

    if (hwndDlg) {

        PnDlgContext.hwndDlg = hwndDlg;
        PnDlgContext.ListView = GetDlgItem(PnDlgContext.hwndDlg, ID_NAMESPACELIST);
        if (PnDlgContext.ListView) {

            PnDlgContext.lvColumnHit = -1;
            PnDlgContext.lvItemHit = -1;

            //
            // Set listview imagelist, style flags and theme.
            //
            supSetListViewSettings(PnDlgContext.ListView,
                LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
                FALSE,
                TRUE,
                g_ListViewImages,
                LVSIL_SMALL);

            //
            // And columns and remember their count.
            //
            PnDlgContext.lvColumnCount = supAddLVColumnsFromArray(
                PnDlgContext.ListView,
                columnData,
                RTL_NUMBER_OF(columnData));

            //
            // Initial call, nothing to refresh.
            //
            PNDialogShowInfo(FALSE);
        }

    }

    supSetFastEvent(&PnDlgInitializedEvent);

    if (hwndDlg) {

        acceleratorTable = LoadAccelerators(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (PNSubDlgMsgHandler(&message))
                continue;

            if (IsDialogMessage(hwndDlg, &message)) {
                TranslateAccelerator(hwndDlg, acceleratorTable, &message);
            }
            else {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);

    }

    supResetFastEvent(&PnDlgInitializedEvent);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    if (PnDlgThreadHandle) {
        NtClose(PnDlgThreadHandle);
        PnDlgThreadHandle = NULL;
    }

    return 0;
}

/*
* extrasCreatePNDialog
*
* Purpose:
*
* Create and initialize Private Namespaces Dialog.
*
*/
VOID extrasCreatePNDialog(
    VOID
)
{  
    if (!PnDlgThreadHandle) {
        PnDlgThreadHandle = supCreateDialogWorkerThread(extrasPNDialogWorkerThread, NULL, 0);
        if (PnDlgThreadHandle)
            supWaitForFastEvent(&PnDlgInitializedEvent, NULL);
    }
}

```

`Source/WinObjEx64/extras/extrasPSList.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       EXTRASPSLIST.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#define OEMRESOURCE
#include "global.h"
#include "propDlg.h"
#include "extras.h"
#include "treelist/treelist.h"

#define PS_COLOR_CURRENT_USER   0xffd0d0
#define PS_COLOR_SERVICE        0xd0d0ff
#define PS_COLOR_IMMERSIVE      0xeaea00
#define PS_COLOR_PROTECTED      0xe6ffe6

#define PSLIST_CELLS_COUNT 3

#define PSLIST_PID_CELL      0
#define PSLIST_OBJECT_CELL   1
#define PSLIST_USER_CELL     2

typedef struct _TL_SUBITEMS_PSLIST {
    ULONG       Count;
    ULONG       ColorFlags;
    COLORREF    BgColor;
    COLORREF    FontColor;
    PVOID       UserParam;
    LPTSTR      CustomTooltip;
    LPTSTR      Text[PSLIST_CELLS_COUNT];
} TL_SUBITEMS_PSLIST, * PTL_SUBITEMS_PSLIST;

/*
* PID -> HTREEITEM hash map for fast parent lookups
*/
#define PSLIST_PIDMAP_HASH_SIZE 512

typedef struct _PIDMAP_ENTRY {
    ULONG_PTR pid;
    HTREEITEM hItem;
    struct _PIDMAP_ENTRY* next;
} PIDMAP_ENTRY, * PPIDMAP_ENTRY;

typedef struct _PIDMAP {
    PPIDMAP_ENTRY buckets[PSLIST_PIDMAP_HASH_SIZE];
} PIDMAP, * PPIDMAP;

static PIDMAP PsListPidMap;

static size_t pidmap_hash(ULONG_PTR pid) {
    return (pid ^ (pid >> 16)) % PSLIST_PIDMAP_HASH_SIZE;
}

#define Y_SPLITTER_SIZE 4
#define Y_SPLITTER_MIN  200

#define PSLISTDLG_TRACKSIZE_MIN_X 640
#define PSLISTDLG_TRACKSIZE_MIN_Y 480

#define T_IDLE_PROCESS TEXT("Idle")
#define T_IDLE_PROCESS_LENGTH sizeof(T_IDLE_PROCESS)

static HANDLE PsListDlgThreadHandle = NULL;
static FAST_EVENT PsListDlgInitializedEvent = FAST_EVENT_INIT;

static EXTRASCONTEXT PsDlgContext;
static int y_splitter_pos = 300, y_capture_pos = 0, y_splitter_max = 0;

HANDLE g_PsListWait = NULL;
HANDLE g_PsListHeap = NULL;

BOOL g_IsDialogQuit;
BOOL g_IsRefresh;


LIST_ENTRY g_PsListHead;

#define COLUMN_THREADLIST_TID              0
#define COLUMN_THREADLIST_PRIORITY         1
#define COLUMN_THREADLIST_STATE            2
#define COLUMN_THREADLIST_ETHREAD          3
#define COLUMN_THREADLIST_STARTADDRESS     4
#define COLUMN_THREADLIST_MODULE           5

static LPWSTR T_WAITREASON[] = {
    L"Executive",
    L"FreePage",
    L"PageIn",
    L"PoolAllocation",
    L"DelayExecution",
    L"Suspended",
    L"UserRequest",
    L"WrExecutive",
    L"WrFreePage",
    L"WrPageIn",
    L"WrPoolAllocation",
    L"WrDelayExecution",
    L"WrSuspended",
    L"WrUserRequest",
    L"WrEventPair",
    L"WrQueue",
    L"WrLpcReceive",
    L"WrLpcReply",
    L"WrVirtualMemory",
    L"WrPageOut",
    L"WrRendezvous",
    L"WrKeyedEvent",
    L"WrTerminated",
    L"WrProcessInSwap",
    L"WrCpuRateControl",
    L"WrCalloutStack",
    L"WrKernel",
    L"WrResource",
    L"WrPushLock",
    L"WrMutex",
    L"WrQuantumEnd",
    L"WrDispatchInt",
    L"WrPreempted",
    L"WrYieldExecution",
    L"WrFastMutex",
    L"WrGuardedMutex",
    L"WrRundown",
    L"WrAlertByThreadId",
    L"WrDeferredPreempt",
    L"WrPhysicalFault"
};

typedef struct _LEGEND_MAP {
    UINT Control;
    UINT Color;
} LEGEND_MAP, * PLEGEND_MAP;

LEGEND_MAP LegendControls[] = {
    { IDC_PCTL_USERPROCESS, PS_COLOR_CURRENT_USER },
    { IDC_PCTL_SERVICE_PROCES, PS_COLOR_SERVICE },
    { IDC_PCTL_IMMERSIVE_PROCESS, PS_COLOR_IMMERSIVE },
    { IDC_PCTL_PROTECTED_PROCESS, PS_COLOR_PROTECTED }
};

/*
* PsListPidMapInit
*
* Purpose:
*
* Initializes the PID -> HTREEITEM hash map.
*
*/
VOID PsListPidMapInit(
    _In_ PPIDMAP map
)
{
    RtlSecureZeroMemory(map->buckets, sizeof(map->buckets));
}

/*
* PsListPidMapFree
*
* Purpose:
*
* Frees all entries in the PID -> HTREEITEM hash map.
*
*/
VOID PsListPidMapFree(
    _In_ PPIDMAP map
)
{
    for (size_t i = 0; i < PSLIST_PIDMAP_HASH_SIZE; ++i) {
        PPIDMAP_ENTRY entry = map->buckets[i];
        while (entry) {
            PPIDMAP_ENTRY tmp = entry;
            entry = entry->next;
            supHeapFree(tmp);
        }
        map->buckets[i] = NULL;
    }
}

/*
* PsListPidMapInsert
*
* Purpose:
*
* Inserts a new PID -> HTREEITEM mapping into the hash map.
*
*/
BOOL PsListPidMapInsert(
    _In_ PPIDMAP map,
    _In_ ULONG_PTR pid,
    _In_ HTREEITEM hItem
)
{
    size_t idx = pidmap_hash(pid);
    PPIDMAP_ENTRY entry = (PPIDMAP_ENTRY)supHeapAlloc(sizeof(PIDMAP_ENTRY));
    if (!entry) return FALSE;
    entry->pid = pid;
    entry->hItem = hItem;
    entry->next = map->buckets[idx];
    map->buckets[idx] = entry;
    return TRUE;
}

/*
* PsListPidMapFind
*
* Purpose:
*
* Looks up the HTREEITEM for a given PID in the hash map.
*
*/
HTREEITEM PsListPidMapFind(
    _In_ PPIDMAP map,
    _In_ ULONG_PTR pid
)
{
    size_t idx = pidmap_hash(pid);
    PPIDMAP_ENTRY entry = map->buckets[idx];
    while (entry) {
        if (entry->pid == pid)
            return entry->hItem;
        entry = entry->next;
    }
    return NULL;
}

/*
* PsLegendDialogProc
*
* Purpose:
*
* Legend dialog procedure.
*
*/
INT_PTR CALLBACK PsLegendDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UINT i;
    HDC hdc;
    HWND hwndControl;
    PAINTSTRUCT paint;
    RECT rect;
    HBRUSH hb;
    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        supCenterWindow(hwndDlg);
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
            return EndDialog(hwndDlg, TRUE);
        }
        break;

    case WM_CLOSE:
        EndDialog(hwndDlg, TRUE);
        return TRUE;

    case WM_PAINT:
        hdc = BeginPaint(hwndDlg, &paint);
        if (hdc) {

            for (i = 0; i < RTL_NUMBER_OF(LegendControls); i++) {

                hwndControl = GetDlgItem(hwndDlg, LegendControls[i].Control);
                if (hwndControl) {
                    RtlZeroMemory(&rect, sizeof(rect));
                    GetClientRect(hwndControl, (LPRECT)&rect);
                    MapWindowPoints(hwndControl, hwndDlg, (LPPOINT)&rect, 2);
                    hb = CreateSolidBrush(LegendControls[i].Color);
                    if (hb) {
                        FillRect(paint.hdc, &rect, hb);
                        DeleteObject(hb);
                    }
                }

            }
            EndPaint(hwndDlg, &paint);
        }

        break;
    }

    return 0;
}

VOID PsShowLegendDialog(
    _In_ HWND hwndParent
)
{
    DialogBoxParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_PSLISTLEGEND),
        hwndParent,
        PsLegendDialogProc,
        0);

}

/*
* PsxAllocateUnnamedObjectEntry
*
* Purpose:
*
* Allocate PROP_UNNAMED_OBJECT_INFO entry.
*
*/
PROP_UNNAMED_OBJECT_INFO* PsxAllocateUnnamedObjectEntry(
    _In_ PVOID Data,
    _In_ WOBJ_OBJECT_TYPE ObjectType
)
{
    PSYSTEM_PROCESS_INFORMATION processEntry;
    PSYSTEM_THREAD_INFORMATION threadEntry;
    PROP_UNNAMED_OBJECT_INFO* objectEntry;

    if (Data == NULL)
        return NULL;

    objectEntry = (PROP_UNNAMED_OBJECT_INFO*)supHeapAllocEx(g_PsListHeap,
        sizeof(PROP_UNNAMED_OBJECT_INFO));

    if (objectEntry == NULL)
        return NULL;

    if (ObjectType == ObjectTypeProcess) {

        processEntry = (PSYSTEM_PROCESS_INFORMATION)Data;
        objectEntry->ClientId.UniqueProcess = processEntry->UniqueProcessId;
        objectEntry->ClientId.UniqueThread = NULL;

        objectEntry->ImageName.MaximumLength = processEntry->ImageName.MaximumLength;
        objectEntry->ImageName.Buffer = (PWSTR)supHeapAllocEx(g_PsListHeap,
            objectEntry->ImageName.MaximumLength);

        if (objectEntry->ImageName.Buffer) {
            RtlCopyUnicodeString(&objectEntry->ImageName, &processEntry->ImageName);
        }
    }
    else if (ObjectType == ObjectTypeThread)
    {
        threadEntry = (PSYSTEM_THREAD_INFORMATION)Data;
        objectEntry->ClientId = threadEntry->ClientId;
        objectEntry->ThreadInformation = *threadEntry;
    }
    return objectEntry;
}

/*
* PsxSCMLookupCallback
*
* Purpose:
*
* qsort, bsearch callback.
*
*/
int __cdecl PsxSCMLookupCallback(
    void const* first,
    void const* second
)
{
    int i;
    ENUM_SERVICE_STATUS_PROCESS* elem1 = (ENUM_SERVICE_STATUS_PROCESS*)first;
    ENUM_SERVICE_STATUS_PROCESS* elem2 = (ENUM_SERVICE_STATUS_PROCESS*)second;

    if (elem1->ServiceStatusProcess.dwProcessId == elem2->ServiceStatusProcess.dwProcessId)
        i = 0;
    else
        if (elem1->ServiceStatusProcess.dwProcessId < elem2->ServiceStatusProcess.dwProcessId)
            i = -1;
        else
            i = 1;

    return i;
}

/*
* PsListDialogResize
*
* Purpose:
*
* WM_SIZE handler.
*
*/
INT_PTR PsListDialogResize(
    VOID
)
{
    RECT r, szr;

    RtlZeroMemory(&r, sizeof(RECT));
    RtlZeroMemory(&szr, sizeof(RECT));

    SendMessage(PsDlgContext.StatusBar, WM_SIZE, 0, 0);
    GetClientRect(PsDlgContext.hwndDlg, &r);
    GetClientRect(PsDlgContext.StatusBar, &szr);
    y_splitter_max = r.bottom - Y_SPLITTER_MIN;

    SetWindowPos(PsDlgContext.TreeList, 0,
        0, 0,
        r.right,
        y_splitter_pos,
        SWP_NOOWNERZORDER);

    SetWindowPos(PsDlgContext.ListView, 0,
        0, y_splitter_pos + Y_SPLITTER_SIZE,
        r.right,
        r.bottom - y_splitter_pos - Y_SPLITTER_SIZE - szr.bottom,
        SWP_NOOWNERZORDER);

    return 1;
}

/*
* PsListHandlePopupMenu
*
* Purpose:
*
* Processes/threads list popup construction
*
*/
VOID PsListHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT point,
    _In_ LPARAM lParam,
    _In_ BOOL fTreeList
)
{
    HMENU hMenu;
    UINT uPos = 0;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_OBJECT_PROPERTIES, T_PROPERTIES);

        if (fTreeList) {

            if (supTreeListAddCopyValueItem(hMenu,
                PsDlgContext.TreeList,
                ID_OBJECT_COPY,
                uPos++,
                lParam,
                &PsDlgContext.tlSubItemHit))
            {
                InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            }

        }
        else {

            if (supListViewAddCopyValueItem(hMenu,
                PsDlgContext.ListView,
                ID_OBJECT_COPY,
                uPos++,
                point,
                &PsDlgContext.lvItemHit,
                &PsDlgContext.lvColumnHit))
            {
                InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            }

        }

        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_VIEW_REFRESH, T_VIEW_REFRESH);
        TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, point->x, point->y, 0, hwndDlg, NULL);
        DestroyMenu(hMenu);
    }

}

/*
* PsListCompareFunc
*
* Purpose:
*
* Dialog listview comparer function.
*
*/
INT CALLBACK PsListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    switch (lParamSort) {
    case COLUMN_THREADLIST_TID: //TID
    case COLUMN_THREADLIST_PRIORITY: //BasePriority
        return supGetMaxOfTwoULongFromString(
            PsDlgContext.ListView,
            lParam1,
            lParam2,
            PsDlgContext.lvColumnToSort,
            PsDlgContext.bInverseSort);
    case COLUMN_THREADLIST_STATE: //string (fixed size)
    case COLUMN_THREADLIST_MODULE: //string (fixed size)
        return supGetMaxCompareTwoFixedStrings(
            PsDlgContext.ListView,
            lParam1,
            lParam2,
            PsDlgContext.lvColumnToSort,
            PsDlgContext.bInverseSort);
    case COLUMN_THREADLIST_ETHREAD: //ethread (hex)
    case COLUMN_THREADLIST_STARTADDRESS: //address (hex)
        return supGetMaxOfTwoU64FromHex(
            PsDlgContext.ListView,
            lParam1,
            lParam2,
            PsDlgContext.lvColumnToSort,
            PsDlgContext.bInverseSort);
    }

    return 0;
}

/*
* PsListGetObjectEntry
*
* Purpose:
*
* Return pointer to data from selected object list entry.
*
*/
PROP_UNNAMED_OBJECT_INFO* PsListGetObjectEntry(
    _In_ BOOL bTreeList,
    _In_opt_ HTREEITEM hTreeItem)
{
    INT nSelected;
    TVITEMEX itemex = { 0 };
    TL_SUBITEMS_PSLIST* subitems = NULL;
    PROP_UNNAMED_OBJECT_INFO* ObjectEntry = NULL;

    if (bTreeList) {

        if (hTreeItem) {
            itemex.hItem = hTreeItem;
        }
        else {
            itemex.hItem = TreeList_GetSelection(PsDlgContext.TreeList);
        }
        if (TreeList_GetTreeItem(PsDlgContext.TreeList, &itemex, &subitems))
            if (subitems)
                ObjectEntry = (PROP_UNNAMED_OBJECT_INFO*)subitems->UserParam;
    }
    else {
        if (ListView_GetSelectedCount(PsDlgContext.ListView)) {
            nSelected = ListView_GetSelectionMark(PsDlgContext.ListView);
            supGetListViewItemParam(PsDlgContext.ListView, nSelected, (PVOID*)&ObjectEntry);
        }
    }

    return ObjectEntry;
}

/*
* PsListHandleObjectProp
*
* Purpose:
*
* Show properties for selected object.
*
*/
VOID PsListHandleObjectProp(
    _In_ BOOL bProcessList,
    _In_ PROP_UNNAMED_OBJECT_INFO* ObjectEntry)
{
    SIZE_T sz;
    LPWSTR lpName;
    HWND hwndParent;
    HANDLE UniqueProcessId = NULL, ObjectHandle = NULL;

    PUNICODE_STRING ImageName = NULL;

    PROP_UNNAMED_OBJECT_INFO* tempEntry;
    PROP_CONFIG propConfig;
    UNICODE_STRING usObjectName;

    if (bProcessList) {

        //
        // Only one process/thread properties dialog at the same time allowed.
        //
        supCloseKnownPropertiesDialog(propGetProcessesWindow());
        hwndParent = PsDlgContext.TreeList;

        UniqueProcessId = ObjectEntry->ClientId.UniqueProcess;
        if (NT_SUCCESS(supOpenProcess(
            UniqueProcessId,
            PROCESS_QUERY_LIMITED_INFORMATION,
            &ObjectHandle)))
        {
            supQueryObjectFromHandle(ObjectHandle, &ObjectEntry->ObjectAddress, NULL);
            NtClose(ObjectHandle);
        }

        ImageName = &ObjectEntry->ImageName;
    }
    else {
        //
        // Only one process/thread properties dialog at the same time allowed.
        //
        supCloseKnownPropertiesDialog(propGetThreadsWindow());
        hwndParent = PsDlgContext.ListView;

        tempEntry = PsListGetObjectEntry(TRUE, NULL);
        if (tempEntry) {
            UniqueProcessId = tempEntry->ClientId.UniqueProcess;
            ImageName = &tempEntry->ImageName;

            if (NT_SUCCESS(supOpenThread(
                &ObjectEntry->ClientId,
                THREAD_QUERY_LIMITED_INFORMATION,
                &ObjectHandle)))
            {
                supQueryObjectFromHandle(ObjectHandle, &ObjectEntry->ObjectAddress, NULL);
                NtClose(ObjectHandle);
            }

        }
    }

    if (ImageName == NULL)
        return;

    //
    // Create fake name for display.
    //
    sz = sizeof(UNICODE_NULL) + 64 + ImageName->Length;
    lpName = (LPWSTR)supHeapAlloc(sz);
    if (lpName == NULL)
        return;

    if (ImageName->Length == 0) {
        if (UniqueProcessId == NULL) {
            _strcpy(lpName, T_IDLE_PROCESS);
        }
        else {
            _strcpy(lpName, TEXT("UnknownProcess"));
        }
    }
    else {
        RtlCopyMemory(lpName,
            ImageName->Buffer,
            ImageName->Length);
    }
    _strcat(lpName, TEXT(" PID:"));
    ultostr(HandleToULong(UniqueProcessId), _strend(lpName));

    if (!bProcessList) {
        _strcat(lpName, TEXT(" TID:"));
        ultostr(HandleToULong(ObjectEntry->ClientId.UniqueThread), _strend(lpName));
    }

    RtlSecureZeroMemory(&propConfig, sizeof(propConfig));
    RtlInitUnicodeString(&usObjectName, lpName);
    propConfig.NtObjectName = &usObjectName;
    propConfig.ObjectTypeIndex = (bProcessList) ? ObjectTypeProcess : ObjectTypeThread;
    propConfig.ContextType = propUnnamed;
    propConfig.u1.UnnamedObject = ObjectEntry;
    propConfig.hwndParent = hwndParent;
    propCreateDialog(&propConfig);

    supHeapFree(lpName);
}

/*
* PsListProcessInServicesList
*
* Purpose:
*
* Return TRUE if given process is in SCM snapshot.
*
*/
BOOLEAN PsListProcessInServicesList(
    _In_ HANDLE ProcessId,
    _In_ SCMDB* ServicesList
)
{
    ENUM_SERVICE_STATUS_PROCESS* SearchEntrySCM = NULL, EntrySCM;

    if (ProcessId == NULL) return FALSE;

    EntrySCM.ServiceStatusProcess.dwProcessId = HandleToUlong(ProcessId);

    SearchEntrySCM = (ENUM_SERVICE_STATUS_PROCESS*)supBSearch(&EntrySCM,
        ServicesList->Entries,
        ServicesList->NumberOfEntries,
        sizeof(ENUM_SERVICE_STATUS_PROCESS),
        PsxSCMLookupCallback);

    return (SearchEntrySCM != NULL);
}

/*
* AddProcessEntryTreeList
*
* Purpose:
*
* Insert process entry to the treelist.
*
*/
HTREEITEM AddProcessEntryTreeList(
    _In_opt_ HTREEITEM RootItem,
    _In_opt_ HANDLE ProcessHandle,
    _In_ PVOID Data,
    _In_ ULONG_PTR ObjectAddress,
    _In_opt_ SCMDB* ServicesList,
    _In_opt_ PSID OurSid,
    _In_opt_ LSA_HANDLE PolicyHandle
)
{
    HTREEITEM hTreeItem = NULL;
    PSID processSid = NULL;
    HANDLE uniqueProcessId;
    PROP_UNNAMED_OBJECT_INFO* objectEntry;
    TL_SUBITEMS_PSLIST subitems;

    SIZE_T cbProcessName;
    PWSTR lpProcessName = NULL, lpUserName = NULL;
    BOOL bIsProtected = FALSE;
    WCHAR szEPROCESS[32], szPid[32];

    objectEntry = PsxAllocateUnnamedObjectEntry(Data, ObjectTypeProcess);
    if (objectEntry == NULL)
        return NULL;

    uniqueProcessId = objectEntry->ClientId.UniqueProcess;

    //
    // Id + Name
    //
    cbProcessName = 32;
    if (objectEntry->ImageName.Length) {
        cbProcessName += objectEntry->ImageName.Length + sizeof(UNICODE_NULL);
    }
    else {
        if (uniqueProcessId == 0) {
            cbProcessName += T_IDLE_PROCESS_LENGTH;
        }
    }

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    lpProcessName = (PWSTR)supHeapAlloc(cbProcessName);
    if (lpProcessName) {

        if (uniqueProcessId == 0) {
            _strcpy(lpProcessName, T_IDLE_PROCESS);
        }
        else {
            if (objectEntry->ImageName.Buffer && objectEntry->ImageName.Length) {
                RtlCopyMemory(lpProcessName, objectEntry->ImageName.Buffer, objectEntry->ImageName.Length);
            }
            else {
                _strcpy(lpProcessName, T_Unknown);
            }
        }
    }

    //
    // PID
    //
    szPid[0] = 0;
    ultostr(HandleToULong(uniqueProcessId), szPid);

    //
    // EPROCESS value (can be NULL)
    //
    szEPROCESS[0] = 0;
    if (ObjectAddress) {
        szEPROCESS[0] = L'0';
        szEPROCESS[1] = L'x';
        u64tohex(ObjectAddress, &szEPROCESS[2]);
    }

    subitems.UserParam = (PVOID)objectEntry;
    subitems.Count = PSLIST_CELLS_COUNT;

    subitems.Text[PSLIST_PID_CELL] = szPid;
    subitems.Text[PSLIST_OBJECT_CELL] = szEPROCESS;
    subitems.Text[PSLIST_USER_CELL] = T_EmptyString;

    //
    // Colors (set order is sensitive).
    //

    //
    // 1. Services.
    //
    if (ProcessHandle) {
        processSid = supQueryProcessSid(ProcessHandle);
    }

    if (ServicesList) {

        if (PsListProcessInServicesList(uniqueProcessId, ServicesList) ||
            ((processSid) && supIsLocalServiceSid(processSid)))
        {
            subitems.ColorFlags = TLF_BGCOLOR_SET;
            subitems.BgColor = PS_COLOR_SERVICE;
        }

    }

    //
    // 2. Current user process.
    //
    if (processSid && OurSid) {
        if (RtlEqualSid(OurSid, processSid)) {
            subitems.ColorFlags = TLF_BGCOLOR_SET;
            subitems.BgColor = PS_COLOR_CURRENT_USER;
        }
    }

    //
    // 3. Store process.
    // 4. Protected process.
    //
    if (ProcessHandle) {

        if (supIsImmersiveProcess(ProcessHandle)) {
            subitems.ColorFlags = TLF_BGCOLOR_SET;
            subitems.BgColor = PS_COLOR_IMMERSIVE;
        }

        if (NT_SUCCESS(supIsProtectedProcess(ProcessHandle, &bIsProtected))) {
            if (bIsProtected) {
                subitems.ColorFlags = TLF_BGCOLOR_SET;
                subitems.BgColor = PS_COLOR_PROTECTED;
            }
        }

    }

    //
    // User.
    //
    if (processSid && PolicyHandle) {

        if (supLookupSidUserAndDomainEx(processSid, PolicyHandle, &lpUserName)) {
            subitems.Text[PSLIST_USER_CELL] = lpUserName;
        }

    }

    if (processSid)
        supHeapFree(processSid);

    hTreeItem = supTreeListAddItem(
        PsDlgContext.TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        lpProcessName,
        &subitems);

    if (lpUserName)
        supHeapFree(lpUserName);
    if (lpProcessName)
        supHeapFree(lpProcessName);
    
    PsListPidMapInsert(&PsListPidMap, HandleToULong(uniqueProcessId), hTreeItem);

    return hTreeItem;
}

/*
* FindParentItem
*
* Purpose:
*
* Return treelist item with given parent process id.
*
*/
HTREEITEM FindParentItem(
    _In_ HANDLE ParentProcessId
)
{
    if (!ParentProcessId)
        return NULL;

    return PsListPidMapFind(&PsListPidMap, HandleToULong(ParentProcessId));
}

/*
* PsListGetThreadStateAsString
*
* Purpose:
*
* Return thread state string description.
*
*/
LPWSTR PsListGetThreadStateAsString(
    _In_ THREAD_STATE ThreadState,
    _In_ KWAIT_REASON WaitReason,
    _In_ LPWSTR StateBuffer)
{
    LPWSTR lpState = T_Unknown;
    LPWSTR lpWaitReason = T_Unknown;

    if (ThreadState == StateWait) {

        _strcpy(StateBuffer, TEXT("Wait:"));
        lpWaitReason = T_WAITREASON[WaitReason];
        _strcat(StateBuffer, lpWaitReason);
    }
    else {


        switch (ThreadState) {
        case StateInitialized:
            lpState = TEXT("Initiailized");
            break;
        case StateReady:
            lpState = TEXT("Ready");
            break;
        case StateRunning:
            lpState = TEXT("Running");
            break;
        case StateStandby:
            lpState = TEXT("Standby");
            break;
        case StateTerminated:
            lpState = TEXT("Terminated");
            break;
        case StateTransition:
            lpState = TEXT("Transition");
            break;

        }

        _strcpy(StateBuffer, lpState);
    }
    return StateBuffer;
}

/*
* CreateThreadListProc
*
* Purpose:
*
* Build and output process threads list.
*
*/
DWORD WINAPI CreateThreadListProc(
    _In_ PROP_UNNAMED_OBJECT_INFO* ObjectEntry
)
{
    INT ItemIndex;
    ULONG i, ThreadCount, ErrorCount = 0;
    HANDLE UniqueProcessId;
    PVOID ProcessList = NULL;
    PSYSTEM_PROCESS_INFORMATION Process;
    PSYSTEM_THREAD_INFORMATION Thread;
    PRTL_PROCESS_MODULES pModules = NULL;
    PSUP_HANDLE_DUMP SortedHandleList = NULL;

    PROP_UNNAMED_OBJECT_INFO* objectEntry, * threadEntry;
    OBEX_THREAD_LOOKUP_ENTRY* stl = NULL, * stlptr;

    LVITEM lvitem;
    WCHAR szBuffer[MAX_PATH];

    ULONG_PTR startAddress = 0, objectAddress = 0;

    DWORD dwWaitResult;

    supDisableRedraw(PsDlgContext.ListView);

    __try {

        dwWaitResult = WaitForSingleObject(g_PsListWait, INFINITE);
        if (dwWaitResult == WAIT_OBJECT_0) {

            supSetWaitCursor(TRUE);

            ListView_DeleteAllItems(PsDlgContext.ListView);

            UniqueProcessId = ObjectEntry->ClientId.UniqueProcess;

            //
            // Refresh thread list.
            //
            ProcessList = supGetSystemInfo(SystemProcessInformation, NULL);
            if (ProcessList == NULL)
                __leave;

            //
            // Leave if process died.
            //
            if (!supQueryProcessEntryById(UniqueProcessId, ProcessList, &Process))
                __leave;

            pModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);

            ThreadCount = Process->ThreadCount;
            stl = (OBEX_THREAD_LOOKUP_ENTRY*)supHeapAlloc(ThreadCount * sizeof(OBEX_THREAD_LOOKUP_ENTRY));
            if (stl == NULL)
                __leave;

            stlptr = stl;

            for (i = 0, Thread = Process->Threads;
                i < ThreadCount;
                i++, Thread++, stlptr++)
            {
                objectEntry = PsxAllocateUnnamedObjectEntry(Thread, ObjectTypeThread);
                if (objectEntry) {

                    stlptr->EntryPtr = (PVOID)objectEntry;

                    if (!NT_SUCCESS(supOpenThread(&Thread->ClientId,
                        THREAD_QUERY_INFORMATION,
                        &stlptr->hThread)))
                    {
                        supOpenThread(&Thread->ClientId,
                            THREAD_QUERY_LIMITED_INFORMATION,
                            &stlptr->hThread);
                    }
                }
            }

            supHeapFree(ProcessList);
            ProcessList = NULL;

            SortedHandleList = supHandlesCreateFilteredAndSortedList(GetCurrentProcessId(), FALSE);
            stlptr = stl;

            for (i = 0; i < ThreadCount; i++, stlptr++) {

                threadEntry = (PROP_UNNAMED_OBJECT_INFO*)stlptr->EntryPtr;

                //
                // TID
                //               
                szBuffer[0] = 0;
                ultostr(HandleToULong(threadEntry->ClientId.UniqueThread), szBuffer);

                RtlZeroMemory(&lvitem, sizeof(lvitem));
                lvitem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvitem.iItem = MAXINT;
                lvitem.iImage = I_IMAGENONE;
                lvitem.pszText = szBuffer;
                lvitem.cchTextMax = MAX_PATH;
                lvitem.lParam = (LPARAM)threadEntry;
                ItemIndex = ListView_InsertItem(PsDlgContext.ListView, &lvitem);
                if (ItemIndex == -1)
                    continue;

                //
                // Priority
                //
                szBuffer[0] = 0;
                ultostr(threadEntry->ThreadInformation.Priority, szBuffer);

                lvitem.mask = LVIF_TEXT;
                lvitem.iSubItem++;
                lvitem.pszText = szBuffer;
                lvitem.iItem = ItemIndex;
                ListView_SetItem(PsDlgContext.ListView, &lvitem);

                //
                // State
                //
                lvitem.iSubItem++;
                lvitem.pszText = PsListGetThreadStateAsString(
                    threadEntry->ThreadInformation.State,
                    threadEntry->ThreadInformation.WaitReason, szBuffer);

                ListView_SetItem(PsDlgContext.ListView, &lvitem);

                // Query thread specific information - object and win32 start address (need elevation).
                startAddress = 0;
                objectAddress = 0;

                if (stlptr->hThread) {

                    if (!supQueryThreadWin32StartAddress(
                        stlptr->hThread,
                        &startAddress))
                    {
                        ErrorCount += 1;
                    }

                    if (SortedHandleList) {

                        if (!supHandlesQueryObjectAddress(
                            SortedHandleList,
                            stlptr->hThread,
                            &objectAddress))
                        {
                            ErrorCount += 1;
                        }

                    }
                    else {
                        ErrorCount += 1;
                    }

                    NtClose(stlptr->hThread);
                }

                if (startAddress == 0)
                    startAddress = (ULONG_PTR)threadEntry->ThreadInformation.StartAddress;

                //
                // ETHREAD
                //
                szBuffer[0] = TEXT('0');
                szBuffer[1] = TEXT('x');
                szBuffer[2] = 0;
                u64tohex(objectAddress, &szBuffer[2]);

                lvitem.iSubItem++;
                lvitem.pszText = szBuffer;
                ListView_SetItem(PsDlgContext.ListView, &lvitem);

                //
                // StartAddress (either Win32StartAddress if possible or StartAddress from NtQSI)
                //
                szBuffer[0] = TEXT('0');
                szBuffer[1] = TEXT('x');
                szBuffer[2] = 0;
                u64tohex((ULONG_PTR)startAddress, &szBuffer[2]);

                lvitem.iSubItem++;
                lvitem.pszText = szBuffer;
                ListView_SetItem(PsDlgContext.ListView, &lvitem);

                //
                // Module (for system threads)
                //
                szBuffer[0] = 0;
                if (startAddress > g_kdctx.SystemRangeStart && pModules) {
                    if (NULL == ntsupFindModuleNameByAddress(
                        pModules,
                        (PVOID)startAddress,
                        szBuffer,
                        MAX_PATH))
                    {
                        _strcpy(szBuffer, T_Unknown);
                    }
                }
                lvitem.iSubItem++;
                lvitem.pszText = szBuffer;
                ListView_SetItem(PsDlgContext.ListView, &lvitem);
            }

            if (ErrorCount != 0) {
                _strcpy(szBuffer, TEXT("Some queries for threads information are failed"));
            }
            else {
                _strcpy(szBuffer, TEXT("All queries for threads information are succeeded"));
            }

            supStatusBarSetText(PsDlgContext.StatusBar, 2, (LPWSTR)&szBuffer);

            ListView_SortItemsEx(
                PsDlgContext.ListView,
                PsListCompareFunc,
                PsDlgContext.lvColumnToSort);

        }
    }
    __finally {

        if (AbnormalTermination())
            supReportAbnormalTermination(__FUNCTIONW__);

        if (pModules) supHeapFree(pModules);
        if (stl) supHeapFree(stl);
        if (SortedHandleList) supHeapFree(SortedHandleList);

        if (ProcessList) supHeapFree(ProcessList);

        supSetWaitCursor(FALSE);

        ReleaseMutex(g_PsListWait);
        supEnableRedraw(PsDlgContext.ListView);
    }

    return 0;
}

/*
* CreateProcessListProc
*
* Purpose:
*
* Build and output process tree list.
*
*/
DWORD WINAPI CreateProcessListProc(
    PVOID Parameter
)
{
    BOOL bRefresh = (BOOL)PtrToInt(Parameter);
    DWORD ServiceEnumType, dwWaitResult;
    ULONG NextEntryDelta = 0, nProcesses = 0, nThreads = 0;

    HTREEITEM ViewRootHandle;

    ULONG_PTR ObjectAddress;

    HANDLE ProcessHandle = NULL;
    PVOID InfoBuffer = NULL;
    PSUP_HANDLE_DUMP SortedHandleList = NULL;
    PSID OurSid = NULL;
    PWSTR lpErrorMsg;

    LSA_HANDLE lsaPolicyHandle = NULL;

    SCMDB ServicesList;

    WCHAR szBuffer[100];

    union {
        PSYSTEM_PROCESS_INFORMATION ProcessEntry;
        PBYTE ListRef;
    } List;

    ServicesList.Entries = NULL;
    ServicesList.NumberOfEntries = 0;

    __try {
        dwWaitResult = WaitForSingleObject(g_PsListWait, INFINITE);
        if (dwWaitResult == WAIT_OBJECT_0) {

            InterlockedExchange((PLONG)&g_IsRefresh, TRUE);

            InitializeListHead(&g_PsListHead);

            supSetWaitCursor(TRUE);

            TreeList_ClearTree(PsDlgContext.TreeList);
            ListView_DeleteAllItems(PsDlgContext.ListView);
            PsListPidMapInit(&PsListPidMap);

            if (bRefresh) {
                supDestroyHeap(g_PsListHeap);
                g_PsListHeap = supCreateHeap(HEAP_GROWABLE, TRUE);
                if (g_PsListHeap == NULL) {
                    lpErrorMsg = TEXT("Could not allocate heap for process enumeration!");
                    supStatusBarSetText(PsDlgContext.StatusBar, 2, lpErrorMsg);
                    __leave;
                }
            }

            ServiceEnumType = SERVICE_WIN32 | SERVICE_INTERACTIVE_PROCESS;

            if (g_NtBuildNumber >= NT_WIN10_THRESHOLD1) {
                ServiceEnumType |= SERVICE_USER_SERVICE | SERVICE_USERSERVICE_INSTANCE;
            }

            if (!supCreateSCMSnapshot(ServiceEnumType, &ServicesList)) {
                lpErrorMsg = TEXT("Error building services list!");
                supStatusBarSetText(PsDlgContext.StatusBar, 2, lpErrorMsg);
                __leave;
            }

            RtlQuickSort(ServicesList.Entries,
                ServicesList.NumberOfEntries,
                sizeof(ENUM_SERVICE_STATUS_PROCESS),
                PsxSCMLookupCallback);

            InfoBuffer = supGetSystemInfo(SystemProcessInformation, NULL);
            if (InfoBuffer == NULL) {
                lpErrorMsg = TEXT("Error query process list!");
                supStatusBarSetText(PsDlgContext.StatusBar, 2, lpErrorMsg);
                __leave;
            }

            if (!supPHLCreate(&g_PsListHead,
                (PBYTE)InfoBuffer,
                &nProcesses,
                &nThreads))
            {
                lpErrorMsg = TEXT("Error building handle list!");
                supStatusBarSetText(PsDlgContext.StatusBar, 2, lpErrorMsg);
                __leave;
            }

            //
            // Show processes/threads count
            //
            _strcpy(szBuffer, TEXT("Processes: "));
            ultostr(nProcesses, _strend(szBuffer));
            supStatusBarSetText(PsDlgContext.StatusBar, 0, (LPWSTR)&szBuffer);

            _strcpy(szBuffer, TEXT("Threads: "));
            ultostr(nThreads, _strend(szBuffer));
            supStatusBarSetText(PsDlgContext.StatusBar, 1, (LPWSTR)&szBuffer);

            SortedHandleList = supHandlesCreateFilteredAndSortedList(GetCurrentProcessId(), FALSE);

            OurSid = supQueryProcessSid(NtCurrentProcess());

            lsaPolicyHandle = NULL;
            supLsaOpenMachinePolicy(POLICY_LOOKUP_NAMES, &lsaPolicyHandle);

            NextEntryDelta = 0;
            ViewRootHandle = NULL;
            List.ListRef = (PBYTE)InfoBuffer;

            do {
                List.ListRef += NextEntryDelta;
                NextEntryDelta = List.ProcessEntry->NextEntryDelta;

                if (List.ProcessEntry->UniqueProcessId == 0)
                    continue;

                ViewRootHandle = FindParentItem(List.ProcessEntry->InheritedFromUniqueProcessId);

                ObjectAddress = 0;
                ProcessHandle = supPHLGetEntry(&g_PsListHead, List.ProcessEntry->UniqueProcessId);

                if (SortedHandleList && ProcessHandle) {
                    supHandlesQueryObjectAddress(SortedHandleList,
                        ProcessHandle,
                        &ObjectAddress);
                }

                if (ViewRootHandle == NULL) {
                    ViewRootHandle = AddProcessEntryTreeList(NULL,
                        ProcessHandle,
                        (PVOID)List.ProcessEntry,
                        ObjectAddress,
                        &ServicesList,
                        OurSid,
                        lsaPolicyHandle);
                }
                else {
                    AddProcessEntryTreeList(ViewRootHandle,
                        ProcessHandle,
                        (PVOID)List.ProcessEntry,
                        ObjectAddress,
                        &ServicesList,
                        OurSid,
                        lsaPolicyHandle);
                }

                if (ProcessHandle) {
                    NtClose(ProcessHandle);
                }

            } while (NextEntryDelta);

            if (lsaPolicyHandle) LsaClose(lsaPolicyHandle);

        }
    }
    __finally {

        if (AbnormalTermination())
            supReportAbnormalTermination(__FUNCTIONW__);

        if (OurSid) supHeapFree(OurSid);
        if (InfoBuffer) supHeapFree(InfoBuffer);
        if (SortedHandleList) supHeapFree(SortedHandleList);
        supPHLFree(&g_PsListHead, FALSE);
        supFreeSCMSnapshot(&ServicesList);

        PsListPidMapFree(&PsListPidMap);

        supSetWaitCursor(FALSE);

        InterlockedExchange((PLONG)&g_IsRefresh, FALSE);
        ReleaseMutex(g_PsListWait);
    }
    return 0;
}

/*
* CreateObjectList
*
* Purpose:
*
* Build and output process/threads list.
*
*/
VOID CreateObjectList(
    _In_ BOOL ListThreads,
    _In_opt_ PVOID ThreadParam
)
{
    HANDLE hThread;
    LPTHREAD_START_ROUTINE lpThreadRoutine;

    if (InterlockedCompareExchange((PLONG)&g_IsDialogQuit,
        TRUE, TRUE) == TRUE) 
    {
        return;
    }

    if (ListThreads)
        lpThreadRoutine = (LPTHREAD_START_ROUTINE)CreateThreadListProc;
    else
        lpThreadRoutine = (LPTHREAD_START_ROUTINE)CreateProcessListProc;

    hThread = supCreateThread(lpThreadRoutine, ThreadParam, 0);
    if (hThread) {
        CloseHandle(hThread);
    }
}

/*
* PsShowPropertiesDialog
*
* Purpose:
*
* Show properties dialog for Process/Thread list item.
*
*/
INT_PTR PsShowPropertiesDialog(
    _In_opt_ HWND TreeControl
)
{
    PROP_UNNAMED_OBJECT_INFO* ObjectEntry;
    TVHITTESTINFO hti;
    POINT pt;

    //
    // Processes list item.
    //
    if (TreeControl) {

        GetCursorPos(&pt);
        hti.pt = pt;
        ScreenToClient(TreeControl, &hti.pt);
        if (TreeView_HitTest(TreeControl, &hti) &&
            (hti.flags & (TVHT_ONITEM | TVHT_ONITEMRIGHT)))
        {
            ObjectEntry = PsListGetObjectEntry(TRUE, hti.hItem);
            if (ObjectEntry) {
                PsListHandleObjectProp(TRUE, ObjectEntry);
            }
        }

    }
    else {
        //
        // Threads list item.
        //
        ObjectEntry = PsListGetObjectEntry(FALSE, NULL);
        if (ObjectEntry) {
            PsListHandleObjectProp(FALSE, ObjectEntry);
        }
    }

    return 1;
}

/*
* PsListHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for dialog listview.
*
*/
INT_PTR PsListHandleNotify(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    LPNMHDR nhdr = (LPNMHDR)lParam;
    INT     nImageIndex;

    HWND TreeControl;

    PROP_UNNAMED_OBJECT_INFO* ObjectEntry;

    if (nhdr == NULL)
        return 0;

    if (InterlockedCompareExchange((PLONG)&g_IsRefresh, TRUE, TRUE) == TRUE)
        return 0;

    if (InterlockedCompareExchange((PLONG)&g_IsDialogQuit, TRUE, TRUE) == TRUE)
        return 0;

    TreeControl = (HWND)TreeList_GetTreeControlWindow(PsDlgContext.TreeList);

    if (nhdr->hwndFrom == PsDlgContext.ListView) {

        switch (nhdr->code) {

        case NM_DBLCLK:
            return PsShowPropertiesDialog(NULL);

        case LVN_COLUMNCLICK:
            PsDlgContext.bInverseSort = (~PsDlgContext.bInverseSort) & 1;
            PsDlgContext.lvColumnToSort = ((NMLISTVIEW*)lParam)->iSubItem;

            ListView_SortItemsEx(PsDlgContext.ListView, &PsListCompareFunc, (LPARAM)PsDlgContext.lvColumnToSort);

            nImageIndex = ImageList_GetImageCount(g_ListViewImages);
            if (PsDlgContext.bInverseSort)
                nImageIndex -= 2;
            else
                nImageIndex -= 1;

            supUpdateLvColumnHeaderImage(
                PsDlgContext.ListView,
                PsDlgContext.lvColumnCount,
                PsDlgContext.lvColumnToSort,
                nImageIndex);

            return 1;

        }

    }
    else if (nhdr->hwndFrom == TreeControl) {

        switch (nhdr->code) {

        case NM_DBLCLK:
#pragma warning(push)
#pragma warning(disable: 26454)
            nhdr->code = NM_RETURN;
#pragma warning(pop)
            return PostMessage(hwndDlg, WM_NOTIFY, wParam, lParam);

        case NM_RETURN:
            return PsShowPropertiesDialog(TreeControl);

        case TVN_SELCHANGED:
            ObjectEntry = PsListGetObjectEntry(TRUE, NULL);
            if (ObjectEntry) {
                CreateObjectList(TRUE, ObjectEntry);
            }
            return 1;

        }

    }

    return 0;
}

/*
* PsListHandleThreadRefresh
*
* Purpose:
*
* Refresh thread list handler.
*
*/
VOID PsListHandleThreadRefresh(
    VOID
)
{
    PROP_UNNAMED_OBJECT_INFO* ObjectEntry;

    ObjectEntry = PsListGetObjectEntry(TRUE, NULL);
    if (ObjectEntry) {
        CreateObjectList(TRUE, ObjectEntry);
    }
}

/*
* PsListDialogProc
*
* Purpose:
*
* Drivers Dialog window procedure.
*
*/
INT_PTR CALLBACK PsListDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    INT dy;
    RECT crc;
    INT mark;
    HMENU hMenu;
    HWND TreeListControl, FocusWindow;

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        extrasHandleSettingsChange(&PsDlgContext);
        return TRUE;
    }

    switch (uMsg) {

    case WM_CONTEXTMENU:

        RtlZeroMemory(&crc, sizeof(crc));

        TreeListControl = TreeList_GetTreeControlWindow(PsDlgContext.TreeList);

        if ((HWND)wParam == TreeListControl) {
            GetCursorPos((LPPOINT)&crc);
            PsListHandlePopupMenu(hwndDlg, (LPPOINT)&crc, lParam, TRUE);
        }

        if ((HWND)wParam == PsDlgContext.ListView) {

            mark = ListView_GetSelectionMark(PsDlgContext.ListView);

            if (lParam == MAKELPARAM(-1, -1)) {
                ListView_GetItemRect(PsDlgContext.ListView, mark, &crc, TRUE);
                crc.top = crc.bottom;
                ClientToScreen(PsDlgContext.ListView, (LPPOINT)&crc);
            }
            else
                GetCursorPos((LPPOINT)&crc);

            PsListHandlePopupMenu(hwndDlg, (LPPOINT)&crc, 0, FALSE);
        }

        break;

    case WM_NOTIFY:
        return PsListHandleNotify(hwndDlg, wParam, lParam);

    case WM_SHOWWINDOW:
        if (wParam == TRUE)
            supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            return TRUE;

        case ID_OBJECT_COPY:
            FocusWindow = GetFocus();
            TreeListControl = TreeList_GetTreeControlWindow(PsDlgContext.TreeList);

            if (FocusWindow == TreeListControl) {

                supTreeListCopyItemValueToClipboard(PsDlgContext.TreeList,
                    PsDlgContext.tlSubItemHit);

            }
            else if (FocusWindow == PsDlgContext.ListView) {
                supListViewCopyItemValueToClipboard(PsDlgContext.ListView,
                    PsDlgContext.lvItemHit,
                    PsDlgContext.lvColumnHit);
            }

            break;

        case ID_VIEW_REFRESH:

            FocusWindow = GetFocus();
            TreeListControl = TreeList_GetTreeControlWindow(PsDlgContext.TreeList);

            if (FocusWindow == TreeListControl) {
                CreateObjectList(FALSE, IntToPtr(TRUE));
            }
            else if (FocusWindow == PsDlgContext.ListView) {
                PsListHandleThreadRefresh();
            }
            break;

        case ID_OBJECT_PROPERTIES:

            FocusWindow = GetFocus();
            TreeListControl = TreeList_GetTreeControlWindow(PsDlgContext.TreeList);
            if (FocusWindow == TreeListControl) {
                PsShowPropertiesDialog(TreeListControl);
            }
            else if (FocusWindow == PsDlgContext.ListView) {
                PsShowPropertiesDialog(NULL);
            }
            break;

        case ID_VIEW_LEGEND:
            PsShowLegendDialog(hwndDlg);
            break;

        }
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                PSLISTDLG_TRACKSIZE_MIN_X,
                PSLISTDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_SIZE:
        return PsListDialogResize();

    case WM_LBUTTONDOWN:
        SetCapture(hwndDlg);
        y_capture_pos = (int)(short)HIWORD(lParam);
        break;

    case WM_LBUTTONUP:
        ReleaseCapture();
        break;

    case WM_MOUSEMOVE:

        if (wParam & MK_LBUTTON) {
            dy = (int)(short)HIWORD(lParam) - y_capture_pos;
            if (dy != 0) {
                y_capture_pos = (int)(short)HIWORD(lParam);
                y_splitter_pos += dy;
                if (y_splitter_pos < Y_SPLITTER_MIN)
                {
                    y_splitter_pos = Y_SPLITTER_MIN;
                    y_capture_pos = Y_SPLITTER_MIN;
                }

                if (y_splitter_pos > y_splitter_max)
                {
                    y_splitter_pos = y_splitter_max;
                    y_capture_pos = y_splitter_max;
                }
                SendMessage(hwndDlg, WM_SIZE, 0, 0);
            }
        }

        break;

    case WM_CLOSE:

        InterlockedExchange((PLONG)&g_IsDialogQuit, TRUE);

        if (g_PsListWait) {
            CloseHandle(g_PsListWait);
            g_PsListWait = NULL;
        }

        hMenu = GetMenu(hwndDlg);
        if (hMenu) 
            DestroyMenu(hMenu);

        DestroyWindow(PsDlgContext.TreeList);
        DestroyWindow(hwndDlg);

        if (g_PsListHeap) {
            supDestroyHeap(g_PsListHeap);
            g_PsListHeap = NULL;
        }
        return TRUE;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    }

    return DefDlgProc(hwndDlg, uMsg, wParam, lParam);
}

/*
* PsSubDlgMsgHandler
*
* Purpose:
*
* Check window message against existing dialogs.
*
*/
BOOL PsSubDlgMsgHandler(
    _In_ LPMSG lpMsg
)
{
    HWND hwnd;

    hwnd = propGetTokenWindow();
    if (hwnd != NULL)
        if (PropSheet_IsDialogMessage(hwnd, lpMsg))
            return TRUE;

    hwnd = propGetProcessesWindow();
    if (hwnd != NULL)
        if (PropSheet_IsDialogMessage(hwnd, lpMsg))
            return TRUE;

    hwnd = propGetThreadsWindow();
    if (hwnd != NULL)
        if (PropSheet_IsDialogMessage(hwnd, lpMsg))
            return TRUE;

    return FALSE;
}

/*
* extrasPsListDialogWorkerThread
*
* Purpose:
*
* Process List Dialog worker thread.
*
*/
DWORD extrasPsListDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    LONG_PTR wndStyles;
    HDITEM hdritem;
    WNDCLASSEX wincls;

    HMENU hMenu;
    HWND hwndDlg;
    BOOL bResult;
    MSG message;
    HACCEL acceleratorTable = NULL;

    INT SbParts[] = { 160, 320, -1 };

    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"TID", 60, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  iImage },
        { L"Priority", 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"State", 150, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Object", 150, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"StartAddress", 140, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Module(System threads)", 200, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    UNREFERENCED_PARAMETER(Parameter);

    RtlSecureZeroMemory(&wincls, sizeof(wincls));
    wincls.cbSize = sizeof(WNDCLASSEX);
    wincls.lpfnWndProc = &PsListDialogProc;
    wincls.cbWndExtra = DLGWINDOWEXTRA;
    wincls.hInstance = g_WinObj.hInstance;
    wincls.hCursor = (HCURSOR)LoadImage(NULL,
        MAKEINTRESOURCE(OCR_SIZENS), IMAGE_CURSOR, 0, 0, LR_SHARED);
    wincls.hIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_MAIN), IMAGE_ICON, 0, 0, LR_SHARED);
    wincls.lpszClassName = WINOBJEX64_PSLISTCLASS;

    RegisterClassEx(&wincls);

    RtlSecureZeroMemory(&PsDlgContext, sizeof(PsDlgContext));
    
    hwndDlg = CreateDialogParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_PSLIST),
        0,
        NULL,
        0);

    if (hwndDlg) {

        hMenu = LoadMenu(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_PSLISTMENU));
        if (hMenu) SetMenu(hwndDlg, hMenu);

        PsDlgContext.hwndDlg = hwndDlg;

        if (g_kdctx.IsFullAdmin == FALSE) {
            SetWindowText(PsDlgContext.hwndDlg, TEXT("Processes (Non elevated mode, some information maybe unavailable)"));
        }

        PsDlgContext.tlSubItemHit = -1;

        PsDlgContext.ListView = GetDlgItem(PsDlgContext.hwndDlg, IDC_PSLIST_LISTVIEW);
        PsDlgContext.StatusBar = GetDlgItem(PsDlgContext.hwndDlg, IDC_PSLIST_STATUSBAR);
        PsDlgContext.TreeList = GetDlgItem(PsDlgContext.hwndDlg, IDC_PSLIST_TREELIST);

        SendMessage(PsDlgContext.StatusBar, SB_SETPARTS, 3, (LPARAM)&SbParts);

        if (PsDlgContext.ListView) {

            supSetListViewSettings(PsDlgContext.ListView,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_DOUBLEBUFFER,
                FALSE,
                TRUE,
                g_ListViewImages,
                LVSIL_SMALL);

            //
            // And columns and remember their count.
            //
            PsDlgContext.lvColumnCount = supAddLVColumnsFromArray(
                PsDlgContext.ListView,
                columnData,
                RTL_NUMBER_OF(columnData));
        }

        if (PsDlgContext.TreeList) {
            RtlZeroMemory(&hdritem, sizeof(hdritem));
            hdritem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
            hdritem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;
            hdritem.cxy = 300;
            hdritem.pszText = TEXT("Process");
            TreeList_InsertHeaderItem(PsDlgContext.TreeList, 0, &hdritem);

            hdritem.cxy = 80;
            hdritem.pszText = TEXT("PID");
            TreeList_InsertHeaderItem(PsDlgContext.TreeList, 1, &hdritem);

            hdritem.cxy = 130;
            hdritem.pszText = TEXT("Object");
            TreeList_InsertHeaderItem(PsDlgContext.TreeList, 2, &hdritem);

            hdritem.cxy = 180;
            hdritem.pszText = TEXT("User");
            TreeList_InsertHeaderItem(PsDlgContext.TreeList, 3, &hdritem);

            wndStyles = GetWindowLongPtr(PsDlgContext.TreeList, GWL_STYLE);
            SetWindowLongPtr(PsDlgContext.TreeList, GWL_STYLE, wndStyles | TLSTYLE_LINKLINES);
        }

        PsListDialogResize();

        g_IsDialogQuit = FALSE;
        g_IsRefresh = FALSE;

        g_PsListWait = CreateMutex(NULL, FALSE, NULL);
        if (g_PsListWait) {
            g_PsListHeap = supCreateHeap(HEAP_GROWABLE, TRUE);
            if (g_PsListHeap) {
                CreateObjectList(FALSE, NULL);
            }
        }

    }

    supSetFastEvent(&PsListDlgInitializedEvent);

    if (hwndDlg) {

        acceleratorTable = LoadAccelerators(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (PsSubDlgMsgHandler(&message))
                continue;

            if (IsDialogMessage(hwndDlg, &message)) {
                TranslateAccelerator(hwndDlg, acceleratorTable, &message);
            }
            else {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);

    }

    supResetFastEvent(&PsListDlgInitializedEvent);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    if (PsListDlgThreadHandle) {
        NtClose(PsListDlgThreadHandle);
        PsListDlgThreadHandle = NULL;
    }

    return 0;
}

/*
* extrasCreatePsListDialog
*
* Purpose:
*
* Create and initialize Process List Dialog.
*
*/
VOID extrasCreatePsListDialog(
    VOID
)
{
    if (!PsListDlgThreadHandle) {
        PsListDlgThreadHandle = supCreateDialogWorkerThread(extrasPsListDialogWorkerThread, NULL, 0);
        if (PsListDlgThreadHandle)
            supWaitForFastEvent(&PsListDlgInitializedEvent, NULL);
    }
}

```

`Source/WinObjEx64/extras/extrasSL.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       EXTRASSL.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"

typedef struct _SL_ENUM_CONTEXT {
    EXTRASCONTEXT* DialogContext;
    LPCWSTR lpFilterByName;
} SL_ENUM_CONTEXT, * PSL_ENUM_CONTEXT;

#define T_SLCACHE_READ_FAIL TEXT("Unable to read SL cache!")

static HANDLE SLCacheDlgThreadHandle = NULL;
static FAST_EVENT SLCacheDlgInitializedEvent = FAST_EVENT_INIT;

UINT g_SLCacheImageIndex;

/*
* SLCacheOnReadFailed
*
* Purpose:
*
* Hide controls in case of cache read general error.
*
*/
VOID SLCacheOnReadFailed(
    _In_ EXTRASCONTEXT* Context
)
{
    ENUMCHILDWNDDATA ChildWndData;

    //
    // Hide all controls in case of error and display warning.
    //
    if (GetWindowRect(Context->hwndDlg, &ChildWndData.Rect)) {
        ChildWndData.nCmdShow = SW_HIDE;
        EnumChildWindows(Context->hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
    }
    ShowWindow(GetDlgItem(Context->hwndDlg, ID_SLCACHEINFO), SW_SHOW);
    SetDlgItemText(Context->hwndDlg, ID_SLCACHEINFO, T_SLCACHE_READ_FAIL);

}

/*
* SLCacheListCompareFunc
*
* Purpose:
*
* Listview comparer function.
*
*/
INT CALLBACK SLCacheListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParamSort;

    return supListViewBaseComparer(pDlgContext->ListView,
        pDlgContext->bInverseSort,
        lParam1,
        lParam2,
        pDlgContext->lvColumnToSort);
}

/*
* xxxSLCacheGetSelectedDescriptor
*
* Purpose:
*
* Query selected listview item associated data.
*
*/
SL_KMEM_CACHE_VALUE_DESCRIPTOR* xxxSLCacheGetSelectedDescriptor(
    _In_ HWND hwndListView,
    _In_ INT iItem)
{
    SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor = NULL;

    //
    // Query associated data.
    //
    if (!supGetListViewItemParam(hwndListView,
        iItem,
        (PVOID*)&CacheDescriptor))
    {
        return NULL;
    }

    return CacheDescriptor;
}

/*
* xxxSLCacheGetDescriptorDataType
*
* Purpose:
*
* Return data type as string constant.
*
*/
LPWSTR xxxSLCacheGetDescriptorDataType(
    _In_ SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor
)
{
    LPWSTR DataType = NULL;

    switch (CacheDescriptor->Type) {
    case SL_DATA_SZ:
        DataType = TEXT("SL_DATA_SZ");
        break;
    case SL_DATA_DWORD:
        DataType = TEXT("SL_DATA_DWORD");
        break;
    case SL_DATA_BINARY:
        DataType = TEXT("SL_DATA_BINARY");
        break;
    case SL_DATA_MULTI_SZ:
        DataType = TEXT("SL_DATA_MULTI_SZ");
        break;
    case SL_DATA_SUM:
        DataType = TEXT("SL_DATA_SUM");
        break;
    }

    return DataType;
}

/*
* SLCacheDialogDisplayDescriptorData
*
* Purpose:
*
* Output descriptor data to controls.
*
*/
VOID SLCacheDialogDisplayDescriptorData(
    _In_ HWND hwndDlg,
    _In_ HWND hwndListView,
    _In_ INT iItem
)
{
    ULONG dwValue;
    SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor;
    LPWSTR lpText, DataType;
    PCHAR DataPtr;
    WCHAR szBuffer[32];

    //
    // Reset output controls.
    //
    SetDlgItemText(hwndDlg, IDC_SLVALUE, TEXT(""));
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_SIZE, TEXT("0"));
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_DATALENGTH, TEXT("0"));
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_ATTRIBUTES, TEXT("0"));
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_TYPE, T_CannotQuery);
    SetDlgItemText(hwndDlg, IDC_SLVALUE_NAME, TEXT(""));
    EnableWindow(GetDlgItem(hwndDlg, IDC_SLVALUE_VIEWWITH), FALSE);

    CacheDescriptor = xxxSLCacheGetSelectedDescriptor(hwndListView, iItem);
    if (CacheDescriptor == NULL)
        return;

    //
    // Attributes.
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    ultostr(CacheDescriptor->Attributes, szBuffer);
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_ATTRIBUTES, szBuffer);

    //
    // Size and DataLength.
    //
    szBuffer[0] = 0;
    ultostr(CacheDescriptor->Size, szBuffer);
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_SIZE, szBuffer);

    szBuffer[0] = 0;
    ultostr(CacheDescriptor->DataLength, szBuffer);
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_DATALENGTH, szBuffer);

    //
    // Data type.
    //
    DataType = xxxSLCacheGetDescriptorDataType(CacheDescriptor);
    if (DataType == NULL) DataType = T_CannotQuery;
    SetDlgItemText(hwndDlg, ID_SLDESCRIPTOR_TYPE, DataType);

    //
    // Name.
    //
    lpText = (LPWSTR)supHeapAlloc(CacheDescriptor->NameLength + sizeof(WCHAR));
    if (lpText) {
        RtlCopyMemory(lpText, CacheDescriptor->Name, CacheDescriptor->NameLength);
        SetDlgItemText(hwndDlg, IDC_SLVALUE_NAME, lpText);
        supHeapFree(lpText);
    }

    //
    // Display Data.
    //
    switch (CacheDescriptor->Type) {
    case SL_DATA_DWORD:
        DataPtr = RtlOffsetToPointer(CacheDescriptor,
            (ULONG_PTR)FIELD_OFFSET(SL_KMEM_CACHE_VALUE_DESCRIPTOR, Name) + CacheDescriptor->NameLength);
        if (CacheDescriptor->DataLength >= sizeof(ULONG)) {
            dwValue = *(PULONG)DataPtr;
            szBuffer[0] = 0;
            ultostr(dwValue, szBuffer);
            SetDlgItemText(hwndDlg, IDC_SLVALUE, szBuffer);
        }
        else {
            SetDlgItemText(hwndDlg, IDC_SLVALUE, TEXT("<invalid size>"));
        }
        break;

    case SL_DATA_SZ:
        lpText = (LPWSTR)supHeapAlloc(CacheDescriptor->DataLength + sizeof(WCHAR));
        if (lpText) {
            DataPtr = RtlOffsetToPointer(CacheDescriptor,
                (ULONG_PTR)FIELD_OFFSET(SL_KMEM_CACHE_VALUE_DESCRIPTOR, Name) + CacheDescriptor->NameLength);
            RtlCopyMemory(lpText, DataPtr, CacheDescriptor->DataLength);
            SetDlgItemText(hwndDlg, IDC_SLVALUE, lpText);
            supHeapFree(lpText);
        }
        break;

    case SL_DATA_BINARY:
        SetDlgItemText(hwndDlg, IDC_SLVALUE, TEXT("Binary data, use \"View\" button to open an external viewer"));
        EnableWindow(GetDlgItem(hwndDlg, IDC_SLVALUE_VIEWWITH), TRUE);
        break;
    }
}

/*
* SLCacheDialogViewBinaryData
*
* Purpose:
*
* Save selected binary data to disk and open it with external viewer (or spawn OpenWith dialog).
*
*/
VOID SLCacheDialogViewBinaryData(
    _In_ HWND hwndListView,
    _In_ INT iSelectedItem
)
{
    SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor;
    PCHAR DataPtr;

    WCHAR szFileName[MAX_PATH * 2];

    CacheDescriptor = xxxSLCacheGetSelectedDescriptor(hwndListView, iSelectedItem);
    if (CacheDescriptor == NULL)
        return;

    //
    // Only for SL_DATA_BINARY.
    //
    if (CacheDescriptor->Type != SL_DATA_BINARY)
        return;

    DataPtr = RtlOffsetToPointer(CacheDescriptor,
        (ULONG_PTR)FIELD_OFFSET(SL_KMEM_CACHE_VALUE_DESCRIPTOR, Name) + CacheDescriptor->NameLength);

    _strcpy(szFileName, g_WinObj.szTempDirectory);
    _strcat(szFileName, TEXT("\\SLData"));
    u64tohex((ULONG_PTR)CacheDescriptor, _strend(szFileName));
    _strcat(szFileName, TEXT(".bin"));

    if (CacheDescriptor->DataLength == supWriteBufferToFile(szFileName,
        (PVOID)DataPtr,
        (SIZE_T)CacheDescriptor->DataLength,
        TRUE,
        FALSE,
        NULL))
    {
        supShellExecInExplorerProcess(szFileName, NULL);
    }

}

/*
* SLCacheDialogHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for listview.
*
*/
BOOL SLCacheDialogHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPNMLISTVIEW pListView
)
{
    INT nImageIndex;
    EXTRASCONTEXT* pDlgContext;

    if (pListView == NULL)
        return FALSE;

    if (pListView->hdr.idFrom == ID_SLCACHELIST) {

        switch (pListView->hdr.code) {

        case LVN_COLUMNCLICK:

            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {

                pDlgContext->bInverseSort = (~pDlgContext->bInverseSort) & 1;
                pDlgContext->lvColumnToSort = pListView->iSubItem;
                ListView_SortItemsEx(pDlgContext->ListView, &SLCacheListCompareFunc, pDlgContext);

                nImageIndex = ImageList_GetImageCount(g_ListViewImages);
                if (pDlgContext->bInverseSort)
                    nImageIndex -= 2;
                else
                    nImageIndex -= 1;

                supUpdateLvColumnHeaderImage(
                    pDlgContext->ListView,
                    pDlgContext->lvColumnCount,
                    pDlgContext->lvColumnToSort,
                    nImageIndex);

            }
            break;

        case LVN_ITEMCHANGED:

            if ((pListView->uNewState & LVIS_SELECTED) &&
                !(pListView->uOldState & LVIS_SELECTED))
            {
                SLCacheDialogDisplayDescriptorData(hwndDlg,
                    pListView->hdr.hwndFrom,
                    pListView->iItem);
            }
            break;

        default:
            return FALSE;
        }
    }

    return TRUE;
}

/*
* SLCacheDialogHandlePopup
*
* Purpose:
*
* List popup construction.
*
*/
VOID SLCacheDialogHandlePopup(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            0,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* SLCacheEnumerateCallback
*
* Purpose:
*
* Callback used to output cache descriptor.
*
*/
BOOL CALLBACK SLCacheEnumerateCallback(
    _In_ SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor,
    _In_ SL_ENUM_CONTEXT* Context
)
{
    INT lvItemIndex;
    LPWSTR EntryName, EntryType;
    LVITEM lvItem;

    WCHAR szBuffer[100];

    EntryName = (LPWSTR)supHeapAlloc(CacheDescriptor->NameLength + sizeof(WCHAR));
    if (EntryName) {

        RtlCopyMemory(EntryName, CacheDescriptor->Name, CacheDescriptor->NameLength);

        if (Context->lpFilterByName) {

            if (_strstri(EntryName, Context->lpFilterByName) == NULL) {
                supHeapFree(EntryName);
                return FALSE;
            }
        }

        //Name
        RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        lvItem.iItem = MAXINT;
        lvItem.iImage = g_SLCacheImageIndex;
        lvItem.pszText = EntryName;
        lvItem.lParam = (LPARAM)CacheDescriptor;
        lvItemIndex = ListView_InsertItem(Context->DialogContext->ListView, &lvItem);

        EntryType = xxxSLCacheGetDescriptorDataType(CacheDescriptor);
        if (EntryType == NULL) {
            szBuffer[0] = 0;
            ultostr(CacheDescriptor->Type, szBuffer);
            EntryType = (LPWSTR)&szBuffer;
        }

        //Type
        if (lvItemIndex >= 0) {
            lvItem.mask = LVIF_TEXT;
            lvItem.iSubItem = 1;
            lvItem.pszText = EntryType;
            lvItem.iItem = lvItemIndex;
            ListView_SetItem(Context->DialogContext->ListView, &lvItem);
        }

        supHeapFree(EntryName);
    }
    return FALSE;
}

PVOID xxxSLCacheUpdateData(
    _In_ EXTRASCONTEXT* Context
)
{
    PVOID SLCacheData = (PVOID)Context->Reserved;
    if (SLCacheData) {
        supHeapFree(SLCacheData);
        Context->Reserved = 0;
    }
    SLCacheData = (PVOID)supSLCacheRead();
    if (SLCacheData)
        Context->Reserved = (ULONG_PTR)SLCacheData;

    return SLCacheData;
}

/*
* SLCacheListItems
*
* Purpose:
*
* Read and output SL cache items.
*
*/
VOID SLCacheListItems(
    _In_ EXTRASCONTEXT* Context,
    _In_opt_ LPCWSTR FilterByName,
    _In_ BOOL RefreshList
)
{
    PVOID SLCacheData = (PVOID)Context->Reserved;
    WCHAR szBuffer[100];

    SL_ENUM_CONTEXT enumContext;

    if (RefreshList) {
        ListView_DeleteAllItems(Context->ListView);
        SLCacheData = xxxSLCacheUpdateData(Context);
    }

    if (SLCacheData == NULL) {
        MessageBox(Context->hwndDlg, T_SLCACHE_READ_FAIL, NULL, MB_ICONERROR);
        return;
    }

    supDisableRedraw(Context->ListView);

    enumContext.lpFilterByName = FilterByName;
    enumContext.DialogContext = Context;

    supSLCacheEnumerate(SLCacheData,
        (PENUMERATE_SL_CACHE_VALUE_DESCRIPTORS_CALLBACK)SLCacheEnumerateCallback,
        &enumContext);

    RtlStringCchPrintfSecure(szBuffer, ARRAYSIZE(szBuffer),
        TEXT("Software Licensing Cache, descriptors: %i"),
        ListView_GetItemCount(Context->ListView));

    SetWindowText(Context->hwndDlg, szBuffer);

    supEnableRedraw(Context->ListView);
}

/*
* SLCacheDialogOnInit
*
* Purpose:
*
* SoftwareLicensingCache Dialog WM_INITDIALOG handler.
*
*/
VOID SLCacheDialogOnInit(
    _In_  HWND hwndDlg,
    _In_  LPARAM lParam
)
{
    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1;
    PVOID SLCacheData;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParam;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"Name", 450, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  iImage },
        { L"Type", 120, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)lParam);
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);

    pDlgContext->hwndDlg = hwndDlg;
    pDlgContext->lvItemHit = -1;
    pDlgContext->lvColumnHit = -1;

    extrasSetDlgIcon(pDlgContext);

    //
    // Read and enumerate cache.
    //
    SLCacheData = supSLCacheRead();
    if (SLCacheData) {

        //
        // Initialize main listview.
        //
        pDlgContext->ListView = GetDlgItem(pDlgContext->hwndDlg, ID_SLCACHELIST);
        if (pDlgContext->ListView) {

            //
            // Set listview imagelist, style flags and theme.
            //
            supSetListViewSettings(pDlgContext->ListView,
                LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
                FALSE,
                TRUE,
                g_ListViewImages,
                LVSIL_SMALL);

            //
            // And columns and remember their count.
            //
            pDlgContext->lvColumnCount = supAddLVColumnsFromArray(
                pDlgContext->ListView,
                columnData,
                RTL_NUMBER_OF(columnData));

            SendDlgItemMessage(pDlgContext->hwndDlg, IDC_SLSEARCH,
                EM_SETLIMITTEXT, (WPARAM)MAX_PATH, (LPARAM)0);

            //
            // Remember image index.
            //
            g_SLCacheImageIndex = g_TypeToken.ImageIndex;
            pDlgContext->Reserved = (ULONG_PTR)SLCacheData;
            SLCacheListItems(pDlgContext, NULL, FALSE);

        }
    }
    else {
        SLCacheOnReadFailed(pDlgContext);
    }
}

/*
* SLCacheDialogProc
*
* Purpose:
*
* SoftwareLicensingCache Dialog window procedure.
*
*/
INT_PTR CALLBACK SLCacheDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext;
    LPNMLISTVIEW nhdr = (LPNMLISTVIEW)lParam;
    LPCWSTR lpFilter = NULL;
    WCHAR szFilterOption[MAX_PATH + 1];

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasHandleSettingsChange(pDlgContext);
        }
        return TRUE;
    }

    switch (uMsg) {

    case WM_NOTIFY:
        return SLCacheDialogHandleNotify(hwndDlg, nhdr);

    case WM_INITDIALOG:
        SLCacheDialogOnInit(hwndDlg, lParam);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {

            extrasRemoveDlgIcon(pDlgContext);

            //
            // Free SL cache data
            //
            if (pDlgContext->Reserved) {
                supHeapFree((PVOID)pDlgContext->Reserved);
            }

            supHeapFree(pDlgContext);
        }
        return DestroyWindow(hwndDlg);

    case WM_CONTEXTMENU:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)SLCacheDialogHandlePopup,
                (PVOID)pDlgContext);
        }
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case IDC_SLVALUE_VIEWWITH:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {
                SLCacheDialogViewBinaryData(pDlgContext->ListView,
                    ListView_GetSelectionMark(pDlgContext->ListView));
            }
            break;

        case ID_OBJECT_COPY:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {
                supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                    pDlgContext->lvItemHit,
                    pDlgContext->lvColumnHit);
            }
            break;

        case IDC_SLSEARCH:

            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
                if (pDlgContext) {

                    RtlSecureZeroMemory(szFilterOption, sizeof(szFilterOption));
                    if (GetDlgItemText(hwndDlg,
                        IDC_SLSEARCH,
                        szFilterOption,
                        MAX_PATH))
                    {
                        if (szFilterOption[0] != 0) {
                            lpFilter = szFilterOption;
                        }
                    }

                    SLCacheListItems(pDlgContext, lpFilter, TRUE);
                }
            }
            break;

        }
    }

    return FALSE;
}

/*
* extrasSLCacheDialogWorkerThread
*
* Purpose:
*
* SoftwareLicensingCache Dialog worker thread.
*
*/
DWORD extrasSLCacheDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)Parameter;

    hwndDlg = CreateDialogParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_SLCACHE),
        0,
        &SLCacheDialogProc,
        (LPARAM)pDlgContext);

    supSetFastEvent(&SLCacheDlgInitializedEvent);

    if (hwndDlg) {
        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (!IsDialogMessage(hwndDlg, &message)) {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    supResetFastEvent(&SLCacheDlgInitializedEvent);

    if (SLCacheDlgThreadHandle) {
        NtClose(SLCacheDlgThreadHandle);
        SLCacheDlgThreadHandle = NULL;
    }

    return 0;
}

/*
* extrasCreateSLCacheDialog
*
* Purpose:
*
* Create and initialize SoftwareLicensingCache Dialog.
*
*/
VOID extrasCreateSLCacheDialog(
    VOID
)
{
    EXTRASCONTEXT* pDlgContext;

    if (!SLCacheDlgThreadHandle) {
        pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
        if (pDlgContext) {
            SLCacheDlgThreadHandle = supCreateDialogWorkerThread(extrasSLCacheDialogWorkerThread, pDlgContext, 0);
            if (SLCacheDlgThreadHandle == NULL) {
                supHeapFree(pDlgContext);
                return;
            }
            supWaitForFastEvent(&SLCacheDlgInitializedEvent, NULL);
        }
    }
}

```

`Source/WinObjEx64/extras/extrasSSDT.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       EXTRASSSDT.C
*
*  VERSION:     2.10
*
*  DATE:        03 Oct 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "hde/hde64.h"
#include "extras.h"
#include "ntos/ntldr.h"
#include "ksymbols.h"
#include "sup/w32k.h"

static EXTRASCONTEXT SSTDlgContext[SST_Max];
static HANDLE SdtDlgThreadHandles[SST_Max] = { NULL, NULL };
static FAST_EVENT SdtDlgInitializedEvents[SST_Max] = { FAST_EVENT_INIT, FAST_EVENT_INIT };

typedef struct _SDT_TABLE_ENTRY {
    ULONG ServiceId;
    ULONG_PTR Address;
    WCHAR Name[MAX_PATH + 1];
} SDT_TABLE_ENTRY, * PSDT_TABLE_ENTRY;

typedef struct _SDT_TABLE {
    BOOL Allocated;
    ULONG Limit;
    ULONG_PTR Base;
    PSDT_TABLE_ENTRY Table;
} SDT_TABLE, * PSDT_TABLE;

static SDT_CONTEXT g_SDTCtx = { 0 };

//
// UI part
//
#define ID_SDTLIST_SAVE 40002

#define SDTDLG_TRACKSIZE_MIN_X 640
#define SDTDLG_TRACKSIZE_MIN_Y 480

#define COLUMN_SDTLIST_INDEX    0
#define COLUMN_SDTLIST_NAME     1
#define COLUMN_SDTLIST_ADDRESS  2
#define COLUMN_SDTLIST_MODULE   3

//
// Globals
//
#define INVALID_SERVICE_ENTRY_ID 0xFFFFFFFF
#define WIN32K_START_INDEX 0x1000

SDT_TABLE KiServiceTable;
SDT_TABLE W32pServiceTable;



/*
* SdtListOutputTable
*
* Purpose:
*
* Output dumped and converted syscall table to listview.
*
*/
VOID SdtListOutputTable(
    _In_ HWND hwndDlg,
    _In_ PRTL_PROCESS_MODULES Modules,
    _In_ PSDT_TABLE SdtTableEntry
)
{
    INT lvIndex;
    ULONG i, iImage, moduleIndex = 0;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);

    LVITEM lvItem;
    WCHAR szBuffer[MAX_PATH + 1];

    LPWSTR lpBaseName, lpBaseLimit;

    if (Context->DialogMode == SST_Ntos) {
        lpBaseName = L"KiServiceTable";
        lpBaseLimit = L"KiServiceLimit";
    }
    else if (Context->DialogMode == SST_Win32k) {
        lpBaseName = L"W32pServiceTable";
        lpBaseLimit = L"W32pServiceLimit";
    }
    else
        return;

    RtlStringCchPrintfSecure(szBuffer,
        MAX_PATH,
        TEXT("%ws 0x%p / %ws %lu (0x%lX)"),
        lpBaseName,
        (PVOID)SdtTableEntry->Base,
        lpBaseLimit,
        SdtTableEntry->Limit,
        SdtTableEntry->Limit);

    supStatusBarSetText(Context->StatusBar, 0, (LPWSTR)&szBuffer); 
    iImage = g_TypeDevice.ImageIndex;

    ListView_DeleteAllItems(Context->ListView);

    //list table
    for (i = 0; i < SdtTableEntry->Limit; i++) {

        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        ultostr(SdtTableEntry->Table[i].ServiceId, szBuffer);

        //ServiceId
        RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvItem.iItem = MAXINT;
        lvItem.iImage = iImage; //imagelist id
        lvItem.pszText = szBuffer;
        lvIndex = ListView_InsertItem(Context->ListView, &lvItem);
        if (lvIndex >= 0) {

            //Name
            lvItem.mask = LVIF_TEXT;
            lvItem.iSubItem = 1;
            lvItem.pszText = (LPWSTR)SdtTableEntry->Table[i].Name;
            lvItem.iItem = lvIndex;
            ListView_SetItem(Context->ListView, &lvItem);

            //Address
            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
            szBuffer[0] = L'0';
            szBuffer[1] = L'x';
            u64tohex(SdtTableEntry->Table[i].Address, &szBuffer[2]);

            lvItem.iSubItem = 2;
            lvItem.pszText = szBuffer;
            ListView_SetItem(Context->ListView, &lvItem);

            //Module
            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

            if (ntsupFindModuleEntryByAddress(
                Modules,
                (PVOID)SdtTableEntry->Table[i].Address,
                &moduleIndex))
            {
                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    (LPCSTR)&Modules->Modules[moduleIndex].FullPathName,
                    -1,
                    szBuffer,
                    MAX_PATH);
            }
            else {
                _strcpy(szBuffer, TEXT("Unknown Module"));
            }

            lvItem.iSubItem = 3;
            lvItem.pszText = szBuffer;
            ListView_SetItem(Context->ListView, &lvItem);
        }
    }
}

/*
* SdtListCreateTable
*
* Purpose:
*
* KiServiceTable dump routine.
*
*/
BOOL SdtListCreateTable(
    VOID
)
{
    BOOL bResult = FALSE;
    ULONG EntrySize = 0;
    SIZE_T memIO;
    PUTable TableDump = NULL;
    PBYTE Module = NULL;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PDWORD ExportNames, ExportFunctions;
    PWORD NameOrdinals;

    PSDT_TABLE_ENTRY ServiceEntry;

    CHAR* ServiceName;
    CHAR* FunctionAddress;
    ULONG ServiceId, i, j;

    __try {

        if ((g_kdctx.Data->KeServiceDescriptorTable.Base == 0) ||
            (g_kdctx.Data->KeServiceDescriptorTable.Limit == 0))
        {
            if (!kdFindKiServiceTable(
                (ULONG_PTR)g_kdctx.NtOsImageMap,
                (ULONG_PTR)g_kdctx.NtOsBase,
                &g_kdctx.Data->KeServiceDescriptorTable))
            {
                __leave;
            }
        }

        //
        // If table empty, dump and prepare table
        //
        if (KiServiceTable.Allocated == FALSE) {

            Module = (PBYTE)GetModuleHandle(TEXT("ntdll.dll"));

            if (Module == NULL)
                __leave;

            ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                Module,
                TRUE,
                IMAGE_DIRECTORY_ENTRY_EXPORT,
                &EntrySize);

            if (ExportDirectory == NULL) {
                __leave;
            }

            ExportNames = (PDWORD)((PBYTE)Module + ExportDirectory->AddressOfNames);
            ExportFunctions = (PDWORD)((PBYTE)Module + ExportDirectory->AddressOfFunctions);
            NameOrdinals = (PWORD)((PBYTE)Module + ExportDirectory->AddressOfNameOrdinals);

            memIO = sizeof(SDT_TABLE_ENTRY) * ExportDirectory->NumberOfNames;

            KiServiceTable.Table = (PSDT_TABLE_ENTRY)supHeapAlloc(memIO);
            if (KiServiceTable.Table == NULL)
                __leave;

            KiServiceTable.Allocated = TRUE;

            if (!supDumpSyscallTableConverted(
                g_kdctx.Data->KeServiceDescriptorTable.Base,
                g_kdctx.Data->KeServiceDescriptorTable.Limit,
                &TableDump))
            {
                supHeapFree(KiServiceTable.Table);
                KiServiceTable.Allocated = FALSE;
                __leave;
            }

            KiServiceTable.Base = g_kdctx.Data->KeServiceDescriptorTable.Base;

            //
            // Walk for syscall stubs.
            //
            KiServiceTable.Limit = 0;
            for (i = 0; i < ExportDirectory->NumberOfNames; i++) {

                ServiceName = ((CHAR*)Module + ExportNames[i]);

                //
                // Use Zw alias to skip various Nt trash like NtdllDialogWndProc/NtGetTickCount.
                //

                if (*(USHORT*)ServiceName == 'wZ') {

                    MultiByteToWideChar(
                        CP_ACP,
                        0,
                        ServiceName,
                        -1,
                        KiServiceTable.Table[KiServiceTable.Limit].Name,
                        MAX_PATH);

                    //dirty hack
                    KiServiceTable.Table[KiServiceTable.Limit].Name[0] = L'N';
                    KiServiceTable.Table[KiServiceTable.Limit].Name[1] = L't';

                    FunctionAddress = (CHAR*)((CHAR*)Module + ExportFunctions[NameOrdinals[i]]);
                    ServiceEntry = &KiServiceTable.Table[KiServiceTable.Limit];

                    if (*(UCHAR*)((UCHAR*)FunctionAddress + 3) == 0xB8) {
                        ServiceId = *(ULONG*)((UCHAR*)FunctionAddress + 4);
                        if (ServiceId < g_kdctx.Data->KeServiceDescriptorTable.Limit) {
                            ServiceEntry->ServiceId = ServiceId;
                            ServiceEntry->Address = TableDump[ServiceId];
                            TableDump[ServiceId] = 0;
                        }
                        else {
                            kdDebugPrint(">>1 %s %lu\r\n", ServiceName, KiServiceTable.Limit);
                            ServiceEntry->ServiceId = INVALID_SERVICE_ENTRY_ID;
                        }
                    }
                    else {
                        kdDebugPrint(">>2 %s %lu\r\n", ServiceName, KiServiceTable.Limit);
                        ServiceEntry->ServiceId = INVALID_SERVICE_ENTRY_ID;
                    }

                    KiServiceTable.Limit += 1;

                }//wZ
            }//for

            for (i = 0; i < KiServiceTable.Limit; i++) {
                ServiceEntry = &KiServiceTable.Table[i];
                if (ServiceEntry->ServiceId == INVALID_SERVICE_ENTRY_ID) {
                    for (j = 0; j < g_kdctx.Data->KeServiceDescriptorTable.Limit; j++) {
                        if (TableDump[j] != 0) {
                            ServiceEntry->ServiceId = j;
                            ServiceEntry->Address = TableDump[j];
                            TableDump[j] = 0;
                            break;
                        }
                    }
                }
            }

            supHeapFree(TableDump);
            TableDump = NULL;
        }

        bResult = TRUE;

    }
    __finally {

        if (AbnormalTermination())
            supReportAbnormalTermination(__FUNCTIONW__);

        if (TableDump) {
            supHeapFree(TableDump);
        }
    }

    return bResult;
}


/*
* SdtListReportEvent
*
* Purpose:
*
* Add entry to WinObjEx64 runtime log accessible through main menu.
*
*/
VOID SdtListReportEvent(
    _In_ WOBJ_ENTRY_TYPE EventType,
    _In_ LPCWSTR FunctionName,
    _In_ LPCWSTR ErrorString
)
{
    WCHAR szBuffer[1024];

    RtlStringCchPrintfSecure(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("%ws, %ws"),
        FunctionName,
        ErrorString);

    logAdd(EventType, szBuffer);
}

/*
* SdtListErrorProcedureNotFound
*
* Purpose:
*
* Report function name resolve error.
*
*/
VOID SdtListErrorProcedureNotFound(
    _In_ LPCSTR FunctionName,
    _In_ PCUNICODE_STRING ModuleName
)
{
    PWCHAR pszErrorMsg;
    WCHAR szFunctionName[MAX_PATH];
    SIZE_T sz;

    sz = MAX_PATH +
        (_strlen_a(FunctionName) * sizeof(WCHAR)) +
        ModuleName->MaximumLength;

    pszErrorMsg = (PWCHAR)supHeapAlloc(sz);
    if (pszErrorMsg) {

        szFunctionName[0] = 0;
        MultiByteToWideChar(CP_ACP, 0, FunctionName, -1, szFunctionName, MAX_PATH);

        RtlStringCchPrintfSecure(pszErrorMsg, sz / sizeof(WCHAR),
            L"the entry point for %ws was not found in module %wZ",
            szFunctionName,
            ModuleName);

        SdtListReportEvent(EntryTypeError, __FUNCTIONW__, pszErrorMsg);

        supHeapFree(pszErrorMsg);
    }
}

/*
* SdtListReportResolveModuleError
*
* Purpose:
*
* Report module resolve error.
*
*/
VOID SdtListReportResolveModuleError(
    _In_ NTSTATUS Status,
    _In_ PRAW_SYSCALL_ENTRY Table,
    _In_ PUNICODE_STRING ResolvedModuleName,
    _In_ LPCWSTR ErrorSource
)
{
    WCHAR szErrorBuffer[512];

    szErrorBuffer[0] = 0;

    //
    // Most of this errors are not critical and ok.
    //

    switch (Status) {

    case STATUS_INTERNAL_ERROR:
        _strcpy(szErrorBuffer, TEXT("Internal error"));
        break;

    case STATUS_APISET_NOT_HOSTED:
        //
        // Corresponding apiset not found.
        //
        _strcpy(szErrorBuffer, TEXT("not an ApiSet adapter for "));
        MultiByteToWideChar(CP_ACP, 0, Table->Name, -1, _strend(szErrorBuffer), MAX_PATH);
        break;

    case STATUS_APISET_NOT_PRESENT:
        //
        // ApiSet extension present but empty.
        // 
        _strcpy(szErrorBuffer, TEXT("ApiSet host is empty for "));
        MultiByteToWideChar(CP_ACP, 0, Table->Name, -1, _strend(szErrorBuffer), MAX_PATH);
        break;

    case STATUS_PROCEDURE_NOT_FOUND:
        //
        // Not a critical issue. This mean we cannot pass this service next to forwarder lookup code.
        //
        _strcpy(szErrorBuffer, TEXT("could not resolve function name in module for "));
        MultiByteToWideChar(CP_ACP, 0, Table->Name, -1, _strend(szErrorBuffer), MAX_PATH);
        _strcat(szErrorBuffer, TEXT(", service id "));
        ultostr(Table->Index, _strend(szErrorBuffer));
        break;

    case STATUS_DLL_NOT_FOUND:

        RtlStringCchPrintfSecure(szErrorBuffer,
            RTL_NUMBER_OF(szErrorBuffer),
            L"could not load import dll %wZ",
            ResolvedModuleName);

        break;

    case STATUS_ILLEGAL_FUNCTION:

        MultiByteToWideChar(CP_ACP, 0, Table->Name, -1, szErrorBuffer, MAX_PATH);
        _strcpy(szErrorBuffer, TEXT(" code does not look like a import thunk"));
        break;

    default:
        //
        // Unexpected error code.
        //
        _strcpy(szErrorBuffer, TEXT("unexpected error 0x"));
        ultohex(Status, _strend(szErrorBuffer));
        break;
    }

    SdtListReportEvent(EntryTypeError, ErrorSource, szErrorBuffer);
}

/*
* SdtpSetDllDirectory
*
* Purpose:
*
* Insert/Remove SystemRoot\System32\Drivers to the loader directories search list.
*
*/
VOID SdtpSetDllDirectory(
    _In_ BOOLEAN bSet
)
{
    WCHAR szBuffer[MAX_PATH * 2];
    PWCHAR lpDirectory = NULL;

    if (bSet) {
        _strcpy(szBuffer, g_WinObj.szSystemDirectory);
        _strcat(szBuffer, TEXT("\\drivers"));
        lpDirectory = (PWCHAR)&szBuffer;
    }

    SetDllDirectory(lpDirectory);
}

/*
* SdtListCreateTableShadow
*
* Purpose:
*
* W32pServiceTable table parsing routine.
* Does optional function resolving to actual handlers.
*
* Note: This code only for Windows 10 RS1+
*
*/
BOOL SdtListCreateTableShadow(
    _In_ PRTL_PROCESS_MODULES pModules,
    _Out_ PULONG Status
)
{
    BOOL bResult = FALSE;
    ULONG i, ulInitStatus;
    NTSTATUS ntStatus;
    HMODULE forwardDll;
    LPCSTR lpFunctionName = NULL, lpForwarderDot, lpForwarderFunctionName;
    PBYTE functionPtr;
    PSDT_TABLE_ENTRY ServiceEntry;
    PRAW_SYSCALL_ENTRY tableEntry;
    RESOLVE_INFO resolveInfo;

    PRTL_PROCESS_MODULE_INFORMATION subModule, forwardModule;
    SDT_MODULE_ENTRY loadedModulesHead, sdtModule;
    UNICODE_STRING forwardModuleName;
    SDT_FUNCTION_NAME sdtFn;
    CHAR szForwarderModuleName[MAX_PATH];

    *Status = STATUS_SUCCESS;
    RtlSecureZeroMemory(&sdtModule, sizeof(SDT_MODULE_ENTRY));
    RtlSecureZeroMemory(&loadedModulesHead, sizeof(SDT_MODULE_ENTRY));

    __try {

        //
        // Check if table already built.
        //
        if (W32pServiceTable.Allocated == FALSE) {

            ulInitStatus = SdtWin32kInitializeOnce(pModules, &g_SDTCtx);
            if (ulInitStatus != 0) {
                *Status = ulInitStatus;

                if (ulInitStatus != ErrShadowApiSetNotFound)
                    __leave;
            }

            SdtpSetDllDirectory(TRUE);

            //
            // Build table.
            //
            for (i = 0; i < g_SDTCtx.KernelLimit; ++i) {

                tableEntry = g_SDTCtx.UserTable;
                while (tableEntry != 0) {

                    if (tableEntry->Index == i + WIN32K_START_INDEX) {

                        lpFunctionName = tableEntry->Name;

                        tableEntry->KernelStubAddress = g_SDTCtx.W32pServiceTableUserBase[i];
                        functionPtr = (PBYTE)g_SDTCtx.KernelModule + tableEntry->KernelStubAddress;
                        tableEntry->KernelStubAddress += g_SDTCtx.KernelBaseAddress;

                        sdtFn.ServiceName = tableEntry->Name;
                        sdtFn.ExportName = NULL;
                        sdtFn.ExportOrdinal = 0;

                        //
                        // Resolve module name for table entry and load this module to the memory.
                        //
                        if (g_SDTCtx.ApiSetSessionAware) {

                            ntStatus = SdtResolveServiceEntryModuleSessionAware(
                                &g_SDTCtx,
                                functionPtr,
                                pModules,
                                &sdtFn,
                                &loadedModulesHead,
                                &sdtModule);

                        }
                        else {

                            ntStatus = SdtResolveServiceEntryModule(
                                &g_SDTCtx,
                                functionPtr,
                                &loadedModulesHead,
                                &sdtModule);

                        }

                        if (!NT_SUCCESS(ntStatus)) {

                            SdtListReportResolveModuleError(ntStatus,
                                tableEntry,
                                &sdtModule.Name,
                                __FUNCTIONW__);

                            break;
                        }

                        //
                        // Check function forwarding.
                        //
                        RtlSecureZeroMemory(&resolveInfo, sizeof(resolveInfo));

                        if (sdtFn.ExportName)
                            lpFunctionName = sdtFn.ExportName;
                        else if (sdtFn.ExportOrdinal)
                            lpFunctionName = MAKEINTRESOURCEA(sdtFn.ExportOrdinal);

                        if (!NT_SUCCESS(NtRawGetProcAddress(sdtModule.ImageBase, lpFunctionName, &resolveInfo))) {
                            SdtListErrorProcedureNotFound(lpFunctionName, &sdtModule.Name);
                            break;
                        }

                        //
                        // Function is forward, resolve again.
                        //
                        if (resolveInfo.ResultType == ForwarderString) {

                            lpForwarderDot = _strchr_a(resolveInfo.ForwarderName, '.');
                            lpForwarderFunctionName = lpForwarderDot + 1;
                            if (lpForwarderFunctionName) {

                                //
                                // Build forwarder module name.
                                //
                                RtlSecureZeroMemory(szForwarderModuleName, sizeof(szForwarderModuleName));
                                _strncpy_a(szForwarderModuleName, sizeof(szForwarderModuleName),
                                    resolveInfo.ForwarderName, lpForwarderDot - &resolveInfo.ForwarderName[0]);

                                _strcat_a(szForwarderModuleName, ".SYS");

                                forwardModule = (PRTL_PROCESS_MODULE_INFORMATION)ntsupFindModuleEntryByName(pModules,
                                    szForwarderModuleName);

                                if (forwardModule) {

                                    if (RtlCreateUnicodeStringFromAsciiz(&forwardModuleName, szForwarderModuleName)) {

                                        if (NT_SUCCESS(SdtLoadAndRememberModule(&loadedModulesHead, &forwardModuleName, &sdtModule, TRUE))) {

                                            forwardDll = sdtModule.ImageBase;

                                            if (NT_SUCCESS(NtRawGetProcAddress(forwardDll, lpForwarderFunctionName, &resolveInfo))) {

                                                //
                                                // Calculate routine kernel mode address.
                                                //
                                                tableEntry->KernelStubTargetAddress =
                                                    (ULONG_PTR)forwardModule->ImageBase + ((ULONG_PTR)resolveInfo.Function - (ULONG_PTR)forwardDll);
                                            }

                                        }
                                        else {
                                            RtlFreeUnicodeString(&forwardModuleName);

                                            //
                                            // Log error.
                                            //
                                            SdtListReportEvent(EntryTypeError, __FUNCTIONW__, TEXT("could not load forwarded module"));
                                        }

                                    }

                                }

                            }

                        }
                        else {
                            //
                            // Calculate routine kernel mode address.
                            //                           
                            subModule = (PRTL_PROCESS_MODULE_INFORMATION)ntsupFindModuleEntryByName_U(pModules, sdtModule.Name.Buffer);
                            if (subModule) {
                                tableEntry->KernelStubTargetAddress =
                                    (ULONG_PTR)subModule->ImageBase + ((ULONG_PTR)resolveInfo.Function - (ULONG_PTR)sdtModule.ImageBase);
                            }

                        }

                    } // if (itable->Index == c + WIN32K_START_INDEX)

                    tableEntry = tableEntry->NextEntry;

                } //while (itable != 0);
            }

            //
            // Output table.
            //
            W32pServiceTable.Table = (PSDT_TABLE_ENTRY)supHeapAlloc(sizeof(SDT_TABLE_ENTRY) * g_SDTCtx.KernelLimit);
            if (W32pServiceTable.Table) {

                W32pServiceTable.Allocated = TRUE;
                W32pServiceTable.Base = g_SDTCtx.W32pServiceTableKernelBase;

                //
                // Convert table to output format.
                //
                W32pServiceTable.Limit = 0;
                tableEntry = g_SDTCtx.UserTable;
                while (tableEntry != 0) {

                    //
                    // Service Id.
                    //
                    ServiceEntry = &W32pServiceTable.Table[W32pServiceTable.Limit];

                    ServiceEntry->ServiceId = tableEntry->Index;

                    //
                    // Routine real address.
                    //
                    if (tableEntry->KernelStubTargetAddress) {
                        //
                        // Output stub target address.
                        //
                        ServiceEntry->Address = tableEntry->KernelStubTargetAddress;

                    }
                    else {
                        //
                        // Query failed, output stub address.
                        //
                        ServiceEntry->Address = tableEntry->KernelStubAddress;

                    }

                    //
                    // Remember service name.
                    //
                    MultiByteToWideChar(
                        CP_ACP,
                        0,
                        tableEntry->Name,
                        -1,
                        ServiceEntry->Name,
                        MAX_PATH);

                    W32pServiceTable.Limit += 1;

                    tableEntry = tableEntry->NextEntry;
                }

            }

        }

        bResult = W32pServiceTable.Allocated;

    }
    __finally {

        if (AbnormalTermination())
            supReportAbnormalTermination(__FUNCTIONW__);

        //
        // Unload all loaded modules.
        //
        SdtUnloadRememberedModules(&loadedModulesHead);
        SdtpSetDllDirectory(FALSE);
    }

    return bResult;
}

/*
* SdtDlgCompareFunc
*
* Purpose:
*
* KiServiceTable/W32pServiceTable Dialog listview comparer function.
*
*/
INT CALLBACK SdtDlgCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort //pointer to EXTRASCALLBACK
)
{
    INT nResult = 0;

    EXTRASCONTEXT* pDlgContext;
    EXTRASCALLBACK* CallbackParam = (EXTRASCALLBACK*)lParamSort;

    if (CallbackParam == NULL)
        return 0;

    pDlgContext = &SSTDlgContext[CallbackParam->Value];

    switch (pDlgContext->lvColumnToSort) {
    case COLUMN_SDTLIST_INDEX: //index
        return supGetMaxOfTwoULongFromString(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);
    case COLUMN_SDTLIST_ADDRESS: //address (hex)
        return supGetMaxOfTwoU64FromHex(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);
    case COLUMN_SDTLIST_NAME: //string (fixed size)
    case COLUMN_SDTLIST_MODULE: //string (fixed size)
        return supGetMaxCompareTwoFixedStrings(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);
    }

    return nResult;
}

/*
* SdtListCreate
*
* Purpose:
*
* (Re)Create service table list.
*
*/
VOID SdtListCreate(
    _In_ HWND hwndDlg,
    _In_ BOOL fRescan,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    BOOL bSuccess = FALSE;
    ULONG returnStatus;
    EXTRASCALLBACK CallbackParam;
    PRTL_PROCESS_MODULES pModules = NULL;
    LPWSTR lpModule;
    WCHAR szText[MAX_PATH];

    __try {

        supStatusBarSetText(pDlgContext->StatusBar, 1, TEXT("Initializing table view"));

        pModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
        if (pModules == NULL) {

            supStatusBarSetText(pDlgContext->StatusBar, 1,
                TEXT("Could not allocate memory for kernel modules list!"));

            __leave;
        }

        if (pDlgContext->DialogMode == SST_Ntos) {

            if (fRescan) {
                if (KiServiceTable.Allocated) {
                    KiServiceTable.Allocated = FALSE;
                    supHeapFree(KiServiceTable.Table);
                    KiServiceTable.Limit = 0;
                }
            }

            bSuccess = SdtListCreateTable();
            if (bSuccess) {
                SdtListOutputTable(hwndDlg, pModules, &KiServiceTable);
            }
            else {
                supStatusBarSetText(pDlgContext->StatusBar, 1, TEXT("Error dumping table"));
            }

        }
        else if (pDlgContext->DialogMode == SST_Win32k) {

            if (fRescan) {
                if (W32pServiceTable.Allocated) {
                    W32pServiceTable.Allocated = FALSE;
                    supHeapFree(W32pServiceTable.Table);
                    W32pServiceTable.Limit = 0;
                }
            }

            bSuccess = SdtListCreateTableShadow(pModules, &returnStatus);
            if (bSuccess) {

                if (returnStatus == ErrShadowApiSetNotFound) {
                    supStatusBarSetText(pDlgContext->StatusBar, 1,
                        TEXT("Win32kApiSet not found"));
                }

                SdtListOutputTable(hwndDlg, pModules, &W32pServiceTable);
            }
            else {

                switch (returnStatus) {

                case ErrShadowWin32kNotFound:

                    RtlStringCchPrintfSecure(szText,
                        RTL_NUMBER_OF(szText),
                        TEXT("Could not find %ws module"),
                        WIN32K_FILENAME);

                    break;

                case ErrShadowMemAllocFail:

                    _strcpy(szText, TEXT("Could not create heap for table"));
                    break;

                case ErrShadowWin32uLoadFail:
                case ErrShadowWin32kLoadFail:

                    switch (returnStatus) {
                    case ErrShadowWin32kLoadFail:
                        lpModule = WIN32K_FILENAME;
                        break;
                    default:
                    case ErrShadowWin32uLoadFail:
                        lpModule = WIN32U_FILENAME;
                        break;
                    }

                    RtlStringCchPrintfSecure(szText,
                        RTL_NUMBER_OF(szText),
                        TEXT("Could not load %ws module"),
                        lpModule);
                    break;

                case ErrShadowW32pServiceLimitNotFound:
                    _strcpy(szText, TEXT("W32pServiceLimit was not found in win32k module"));
                    break;

                case ErrShadowWin32uMismatch:
                    _strcpy(szText, TEXT("Not all services found in win32u"));
                    break;

                case ErrShadowW32pServiceTableNotFound:
                    _strcpy(szText, TEXT("W32pServiceTable was not found in win32k module"));
                    break;

                case ErrShadowApiSetSchemaVerUnknown:
                    _strcpy(szText, TEXT("ApiSetSchema version is unknown"));
                    break;

                case ErrShadowWin32kGlobalsNotFound:
                    _strcpy(szText, TEXT("Could not find win32k.sys globals variable"));
                    break;

                case ErrShadowWin32kOffsetNotFound:
                    _strcpy(szText, TEXT("Could not find win32k.sys Win32kApiSetTable offset"));
                    break;

                case ErrShadowWin32kGetStateNotFound:
                    _strcpy(szText, TEXT("Could not find win32k.sys W32GetSessionState pointer"));
                    break;

                default:
                    _strcpy(szText, TEXT("Unknown error"));
                    break;
                }

                supStatusBarSetText(pDlgContext->StatusBar, 1, szText);
            }
        }

    }
    __finally {

        if (AbnormalTermination())
            supReportAbnormalTermination(__FUNCTIONW__);

        if (pModules)
            supHeapFree(pModules);

    }

    if (bSuccess) {
        supStatusBarSetText(pDlgContext->StatusBar, 1, TEXT("Table read OK"));
        CallbackParam.lParam = 0;
        CallbackParam.Value = pDlgContext->DialogMode;
        ListView_SortItemsEx(pDlgContext->ListView, &SdtDlgCompareFunc, (LPARAM)&CallbackParam);
        SetForegroundWindow(pDlgContext->hwndDlg);
        SetFocus(pDlgContext->ListView);
    }
}

/*
* SdtHandlePopupMenu
*
* Purpose:
*
* Table list popup construction.
*
*/
VOID SdtHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    UINT uPos = 0;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            uPos,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            InsertMenu(hMenu, ++uPos, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }

        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_JUMPTOFILE, T_JUMPTOFILE);
        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_SDTLIST_SAVE, T_EXPORTTOFILE);
        InsertMenu(hMenu, uPos++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        InsertMenu(hMenu, uPos++, MF_BYCOMMAND, ID_VIEW_REFRESH, T_VIEW_REFRESH);

        TrackPopupMenu(hMenu,
            TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            lpPoint->x,
            lpPoint->y,
            0,
            hwndDlg,
            NULL);

        DestroyMenu(hMenu);
    }
}

/*
* SdtFreeGlobals
*
* Purpose:
*
* Release memory allocated for SDT table globals.
*
*/
BOOL CALLBACK SdtFreeGlobals(
    _In_opt_ PVOID Context
)
{
    UNREFERENCED_PARAMETER(Context);

    if (KiServiceTable.Allocated) {
        supHeapFree(KiServiceTable.Table);
        KiServiceTable.Allocated = FALSE;
    }
    if (W32pServiceTable.Allocated) {
        supHeapFree(W32pServiceTable.Table);
        W32pServiceTable.Allocated = FALSE;
    }

    return TRUE;
}

/*
* SdtDlgHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for dialog listview.
*
*/
BOOL SdtDlgHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT nImageIndex, iSelectionMark;
    LPNMLISTVIEW pListView = (LPNMLISTVIEW)lParam;
    LPWSTR lpItem, lpWin32Name;
    HWND hwndListView;

    EXTRASCONTEXT* pDlgContext;

    EXTRASCALLBACK CallbackParam;

    if (pListView == NULL)
        return FALSE;

    if (pListView->hdr.idFrom != ID_EXTRASLIST)
        return FALSE;

    hwndListView = pListView->hdr.hwndFrom;

    switch (pListView->hdr.code) {

    case LVN_COLUMNCLICK:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {

            pDlgContext->bInverseSort = (~pDlgContext->bInverseSort) & 1;
            pDlgContext->lvColumnToSort = pListView->iSubItem;
            CallbackParam.lParam = (LPARAM)pDlgContext->lvColumnToSort;
            CallbackParam.Value = pDlgContext->DialogMode;
            ListView_SortItemsEx(hwndListView, &SdtDlgCompareFunc, (LPARAM)&CallbackParam);

            nImageIndex = ImageList_GetImageCount(g_ListViewImages);
            if (pDlgContext->bInverseSort)
                nImageIndex -= 2;
            else
                nImageIndex -= 1;

            supUpdateLvColumnHeaderImage(
                hwndListView,
                pDlgContext->lvColumnCount,
                pDlgContext->lvColumnToSort,
                nImageIndex);
        }
        break;

    case NM_DBLCLK:

        iSelectionMark = ListView_GetSelectionMark(hwndListView);
        if (iSelectionMark >= 0) {
            lpItem = supGetItemText(hwndListView, iSelectionMark, 3, NULL);
            if (lpItem) {
                lpWin32Name = supGetWin32FileName(lpItem);
                if (lpWin32Name) {
                    supShowProperties(hwndDlg, lpWin32Name);
                    supHeapFree(lpWin32Name);
                }
                supHeapFree(lpItem);
            }
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* SdtDlgOnInit
*
* Purpose:
*
* KiServiceTable Dialog WM_INITDIALOG handler.
*
*/
VOID SdtDlgOnInit(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)lParam;

    INT SbParts[] = { 400, -1 };
    WCHAR szText[100];

    LVCOLUMNS_DATA columnData[] =
    {
        { L"Id", 80, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  iImage },
        { L"Service Name", 280, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Address", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Module", 220, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)lParam);
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);

    pDlgContext->lvColumnHit = -1;
    pDlgContext->lvItemHit = -1;

    pDlgContext->hwndDlg = hwndDlg;
    pDlgContext->StatusBar = GetDlgItem(hwndDlg, ID_EXTRASLIST_STATUSBAR);
    SendMessage(pDlgContext->StatusBar, SB_SETPARTS, 2, (LPARAM)&SbParts);

    _strcpy(szText, TEXT("Viewing "));
    if (pDlgContext->DialogMode == SST_Ntos)
        _strcat(szText, TEXT("ntoskrnl service table"));
    else
        _strcat(szText, TEXT("win32k service table"));

    SetWindowText(hwndDlg, szText);

    extrasSetDlgIcon(pDlgContext);

    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_EXTRASLIST);
    if (pDlgContext->ListView) {

        //
        // Set listview imagelist, style flags and theme.
        //
        supSetListViewSettings(pDlgContext->ListView,
            LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
            FALSE,
            TRUE,
            g_ListViewImages,
            LVSIL_SMALL);

        //
        // And columns and remember their count.
        //
        pDlgContext->lvColumnCount = supAddLVColumnsFromArray(
            pDlgContext->ListView,
            columnData,
            RTL_NUMBER_OF(columnData));

        SendMessage(hwndDlg, WM_SIZE, 0, 0);

        supDisableRedraw(pDlgContext->ListView);
        SdtListCreate(pDlgContext->hwndDlg, FALSE, pDlgContext);
        supEnableRedraw(pDlgContext->ListView);
    }
}

/*
* SdtDialogProc
*
* Purpose:
*
* KiServiceTable Dialog window procedure.
*
*/
INT_PTR CALLBACK SdtDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext;

    if (uMsg == g_WinObj.SettingsChangeMessage) {
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasHandleSettingsChange(pDlgContext);
        }
        return TRUE;
    }

    switch (uMsg) {

    case WM_INITDIALOG:
        SdtDlgOnInit(hwndDlg, lParam);
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                SDTDLG_TRACKSIZE_MIN_X,
                SDTDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_NOTIFY:
        return SdtDlgHandleNotify(hwndDlg, lParam);

    case WM_SIZE:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasSimpleListResize(hwndDlg);
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            extrasRemoveDlgIcon(pDlgContext);
        }
        DestroyWindow(hwndDlg);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_SDTLIST_SAVE:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {

                if (supListViewExportToFile(
                    TEXT("Table.csv"),
                    hwndDlg,
                    pDlgContext->ListView))
                {
                    supStatusBarSetText(pDlgContext->StatusBar, 1, T_LIST_EXPORT_SUCCESS);
                }

            }
            break;

        case ID_VIEW_REFRESH:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {
                supDisableRedraw(pDlgContext->ListView);
                SdtListCreate(hwndDlg, TRUE, pDlgContext);
                supEnableRedraw(pDlgContext->ListView);
            }
            break;

        case ID_JUMPTOFILE:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {
                supJumpToFileListView(pDlgContext->ListView, 3);
            }
            break;

        case ID_OBJECT_COPY:
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {
                supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                    pDlgContext->lvItemHit,
                    pDlgContext->lvColumnHit);
            }
            break;

        }

        break;

    case WM_CONTEXTMENU:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {

            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)SdtHandlePopupMenu,
                (PVOID)pDlgContext);

        }
        break;
    }

    return FALSE;
}

/*
* extrasSSDTDialogWorkerThread
*
* Purpose:
*
* SSDT Dialog worker thread.
*
*/
DWORD extrasSSDTDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    HANDLE prev;
    HWND hwndDlg;
    BOOL bResult;
    MSG message;
    HACCEL acceleratorTable;
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)Parameter;

    hwndDlg = CreateDialogParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_EXTRASLIST),
        0,
        &SdtDialogProc,
        (LPARAM)pDlgContext);

    supAddShutdownCallback(&SdtFreeGlobals, NULL);

    acceleratorTable = LoadAccelerators(g_WinObj.hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

    supSetFastEvent(&SdtDlgInitializedEvents[pDlgContext->DialogMode]);

    if (hwndDlg) {
        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (IsDialogMessage(hwndDlg, &message)) {
                TranslateAccelerator(hwndDlg, acceleratorTable, &message);
            }
            else {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    supResetFastEvent(&SdtDlgInitializedEvents[pDlgContext->DialogMode]);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    prev = InterlockedExchangePointer((PVOID*)&SdtDlgThreadHandles[pDlgContext->DialogMode], NULL); 
    if (prev) CloseHandle(prev);

    if (pDlgContext->DialogMode == SST_Win32k)
        SdtWin32kUninitialize(&g_SDTCtx);

    return 0;
}

/*
* extrasCreateSSDTDialog
*
* Purpose:
*
* Create and initialize SSDT Dialog.
*
*/
VOID extrasCreateSSDTDialog(
    _In_ SSDT_DLG_MODE Mode
)
{
    if (Mode < 0 || Mode >= SST_Max)
        return;

    if (!SdtDlgThreadHandles[Mode]) {
        RtlSecureZeroMemory(&SSTDlgContext[Mode], sizeof(EXTRASCONTEXT));
        SSTDlgContext[Mode].DialogMode = Mode;
        SdtDlgThreadHandles[Mode] = supCreateDialogWorkerThread(extrasSSDTDialogWorkerThread, (PVOID)&SSTDlgContext[Mode], 0);
        if (SdtDlgThreadHandles[Mode])
            supWaitForFastEvent(&SdtDlgInitializedEvents[Mode], NULL);
    }
}

```

`Source/WinObjEx64/extras/extrasUSD.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       EXTRASUSD.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "props.h"
#include "extras.h"
#include "treelist/treelist.h"

static EXTRASCONTEXT g_UsdDlgContext;
static HANDLE UsdDlgThreadHandle = NULL;
static FAST_EVENT UsdDlgInitializedEvent = FAST_EVENT_INIT;

VALUE_DESC T_PROCESSOR_FEATURES_WITH_VALUES[] = {
    { L"PF_FLOATING_POINT_PRECISION_ERRATA", PF_FLOATING_POINT_PRECISION_ERRATA },
    { L"PF_FLOATING_POINT_EMULATED", PF_FLOATING_POINT_EMULATED },
    { L"PF_COMPARE_EXCHANGE_DOUBLE", PF_COMPARE_EXCHANGE_DOUBLE },
    { L"PF_MMX_INSTRUCTIONS_AVAILABLE", PF_MMX_INSTRUCTIONS_AVAILABLE },
    { L"PF_XMMI_INSTRUCTIONS_AVAILABLE", PF_XMMI_INSTRUCTIONS_AVAILABLE },
    { L"PF_3DNOW_INSTRUCTIONS_AVAILABLE", PF_3DNOW_INSTRUCTIONS_AVAILABLE },
    { L"PF_RDTSC_INSTRUCTION_AVAILABLE", PF_RDTSC_INSTRUCTION_AVAILABLE },
    { L"PF_PAE_ENABLED", PF_PAE_ENABLED },
    { L"PF_XMMI64_INSTRUCTIONS_AVAILABLE", PF_XMMI64_INSTRUCTIONS_AVAILABLE },
    { L"PF_SSE_DAZ_MODE_AVAILABLE", PF_SSE_DAZ_MODE_AVAILABLE },
    { L"PF_NX_ENABLED", PF_NX_ENABLED },
    { L"PF_SSE3_INSTRUCTIONS_AVAILABLE", PF_SSE3_INSTRUCTIONS_AVAILABLE },
    { L"PF_COMPARE_EXCHANGE128", PF_COMPARE_EXCHANGE128 },
    { L"PF_COMPARE64_EXCHANGE128", PF_COMPARE64_EXCHANGE128 },
    { L"PF_CHANNELS_ENABLED", PF_CHANNELS_ENABLED },
    { L"PF_XSAVE_ENABLED", PF_XSAVE_ENABLED },
    { L"PF_SECOND_LEVEL_ADDRESS_TRANSLATION", PF_SECOND_LEVEL_ADDRESS_TRANSLATION },
    { L"PF_VIRT_FIRMWARE_ENABLED", PF_VIRT_FIRMWARE_ENABLED },
    { L"PF_RDWRFSGSBASE_AVAILABLE", PF_RDWRFSGSBASE_AVAILABLE },
    { L"PF_FASTFAIL_AVAILABLE", PF_FASTFAIL_AVAILABLE },
    { L"PF_RDRAND_INSTRUCTION_AVAILABLE", PF_RDRAND_INSTRUCTION_AVAILABLE },
    { L"PF_RDTSCP_INSTRUCTION_AVAILABLE", PF_RDTSCP_INSTRUCTION_AVAILABLE },
    { L"PF_RDPID_INSTRUCTION_AVAILABLE", PF_RDPID_INSTRUCTION_AVAILABLE },
    { L"PF_MONITORX_INSTRUCTION_AVAILABLE", PF_MONITORX_INSTRUCTION_AVAILABLE },
    { L"PF_SSSE3_INSTRUCTIONS_AVAILABLE", PF_SSSE3_INSTRUCTIONS_AVAILABLE },
    { L"PF_SSE4_1_INSTRUCTIONS_AVAILABLE", PF_SSE4_1_INSTRUCTIONS_AVAILABLE },
    { L"PF_SSE4_2_INSTRUCTIONS_AVAILABLE", PF_SSE4_2_INSTRUCTIONS_AVAILABLE },
    { L"PF_AVX_INSTRUCTIONS_AVAILABLE", PF_AVX_INSTRUCTIONS_AVAILABLE },
    { L"PF_AVX2_INSTRUCTIONS_AVAILABLE", PF_AVX2_INSTRUCTIONS_AVAILABLE },
    { L"PF_AVX512F_INSTRUCTIONS_AVAILABLE", PF_AVX512F_INSTRUCTIONS_AVAILABLE },
    { L"PF_ERMS_AVAILABLE", PF_ERMS_AVAILABLE },
    { L"PF_BMI2_INSTRUCTIONS_AVAILABLE", PF_BMI2_INSTRUCTIONS_AVAILABLE }
};

LPCWSTR T_SharedDataFlagsW7[] = {
    L"DbgErrorPortPresent",
    L"DbgElevationEnabled",
    L"DbgVirtEnabled",
    L"DbgInstallerDetectEnabled",
    L"DbgSystemDllRelocated",
    L"DbgDynProcessorEnabled",
    L"DbgSEHValidationEnabled"
};

LPCWSTR T_SharedDataFlags[] = {
    L"DbgErrorPortPresent",
    L"DbgElevationEnabled",
    L"DbgVirtEnabled",
    L"DbgInstallerDetectEnabled",
    L"DbgLkgEnabled",
    L"DbgDynProcessorEnabled",
    L"DbgConsoleBrokerEnabled",
    L"DbgSecureBootEnabled",
    L"DbgMultiSessionSku",
    L"DbgMultiUsersInSessionSku",
    L"DbgStateSeparationEnabled",
    L"DbgSplitTokenEnabled",
    L"DbgShadowAdminEnabled"
};

VALUE_DESC USD_SuiteMasks[] = {
    { L"ServerNT", VER_SERVER_NT },
    { L"WorkstationNT", VER_WORKSTATION_NT },
    { L"SmallBusiness", VER_SUITE_SMALLBUSINESS },
    { L"Enterprise", VER_SUITE_ENTERPRISE },
    { L"BackOffice", VER_SUITE_BACKOFFICE },
    { L"Communications", VER_SUITE_COMMUNICATIONS },
    { L"Terminal", VER_SUITE_TERMINAL },
    { L"SmallBussinessRestricted", VER_SUITE_SMALLBUSINESS_RESTRICTED },
    { L"EmbeddedNT", VER_SUITE_EMBEDDEDNT },
    { L"DataCenter", VER_SUITE_DATACENTER },
    { L"SingleUserTS", VER_SUITE_SINGLEUSERTS },
    { L"Personal", VER_SUITE_PERSONAL },
    { L"Blade", VER_SUITE_BLADE },
    { L"EmbeddedRestricted", VER_SUITE_EMBEDDED_RESTRICTED },
    { L"SecurityAppliance", VER_SUITE_SECURITY_APPLIANCE },
    { L"StorageServer", VER_SUITE_STORAGE_SERVER },
    { L"ComputeServer", VER_SUITE_COMPUTE_SERVER },
    { L"HomeServer", VER_SUITE_WH_SERVER },
    { L"MultiUserTS", VER_SUITE_MULTIUSERTS }
};

VALUE_DESC USD_NXSupportPolicyFlags[] = {
    { L"AlwaysOff", NX_SUPPORT_POLICY_ALWAYSOFF },
    { L"AlwaysOn", NX_SUPPORT_POLICY_ALWAYSON },
    { L"OptIn", NX_SUPPORT_POLICY_OPTIN },
    { L"OptOut", NX_SUPPORT_POLICY_OPTOUT }
};

VALUE_DESC USD_SEHValidationPolicyFlags[] = {
    { L"AlwaysOff", SEH_VALIDATION_POLICY_ON },
    { L"AlwaysOn", SEH_VALIDATION_POLICY_OFF },
    { L"Telemetry", SEH_VALIDATION_POLICY_TELEMETRY },
    { L"Defer", SEH_VALIDATION_POLICY_DEFER }
};

LPWSTR UsdCpuFeatureToText(
    _In_ ULONG featureIndex
)
{
    UINT i;
    for (i = 0; i < RTL_NUMBER_OF(T_PROCESSOR_FEATURES_WITH_VALUES); i++) {
        if (T_PROCESSOR_FEATURES_WITH_VALUES[i].dwValue == featureIndex)
            return T_PROCESSOR_FEATURES_WITH_VALUES[i].lpDescription;
    }

    return T_Unknown;
}

/*
* UsdDumpMitigationPolicies
*
* Purpose:
*
* Display dump of SEH and NX policies.
*
*/
VOID UsdDumpMitigationPolicies(
    _In_ HTREEITEM tviRoot,
    _In_ PKUSER_SHARED_DATA pUserSharedData
)
{
    HTREEITEM h_tviSubItem;
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[MAX_PATH + 1];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    //
    // Expanded to more values starting from Windows 8+
    //

    RtlSecureZeroMemory(szValue, sizeof(szValue));

    RtlStringCchPrintfSecure(szValue,
        MAX_PATH,
        TEXT("0x%02X"),
        pUserSharedData->MitigationPolicies);

    subitems.Text[0] = szValue;
    subitems.Count = 1;

    h_tviSubItem = supTreeListAddItem(
        g_UsdDlgContext.TreeList,
        tviRoot,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        TEXT("MitigationPolicies"),
        &subitems);

    if (h_tviSubItem) {

        propDumpEnumWithNames(
            g_UsdDlgContext.TreeList,
            h_tviSubItem,
            TEXT("NXSupportPolicy"),
            pUserSharedData->NXSupportPolicy,
            USD_NXSupportPolicyFlags,
            RTL_NUMBER_OF(USD_NXSupportPolicyFlags));

        propDumpEnumWithNames(
            g_UsdDlgContext.TreeList,
            h_tviSubItem,
            TEXT("SEHValidationPolicy"),
            pUserSharedData->SEHValidationPolicy,
            USD_SEHValidationPolicyFlags,
            RTL_NUMBER_OF(USD_SEHValidationPolicyFlags));

        propObDumpByte(
            g_UsdDlgContext.TreeList,
            h_tviSubItem,
            TEXT("CurDirDevicesSkippedForDlls"),
            (LPWSTR)NULL,
            pUserSharedData->CurDirDevicesSkippedForDlls,
            (COLORREF)0,
            (COLORREF)0,
            FALSE);
    }

}

/*
* UsdDumpSharedRegion
*
* Purpose:
*
* Display dump of SharedData.
*
*/
VOID UsdDumpSharedRegion(
    _In_ HWND hwndParent
)
{
    BOOL                bAny = FALSE;
    UINT                i;
    DWORD               cFlags;

    LPCWSTR* pvSharedFlagsDesc;

    HTREEITEM           h_tviRootItem, h_tviSubItem, h_tviLast = NULL;
    LPWSTR              lpType;
    TL_SUBITEMS_FIXED   subitems;
    TVITEMEX            itemex;
    WCHAR               szValue[MAX_PATH + 1];

    PKUSER_SHARED_DATA  pUserSharedData;


    __try {

        pUserSharedData = (KUSER_SHARED_DATA* const)MM_SHARED_USER_DATA_VA;

        if (!supInitTreeListForDump(hwndParent, &g_UsdDlgContext.TreeList))
            return;

        //
        // KUSER_SHARED_DATA
        //

        h_tviRootItem = supTreeListAddItem(
            g_UsdDlgContext.TreeList,
            (HTREEITEM)NULL,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            TEXT("KUSER_SHARED_DATA"),
            (PVOID)NULL);

        if (h_tviRootItem == NULL) {
            return;
        }

        //
        // NtSystemRoot
        //
        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        subitems.Text[0] = pUserSharedData->NtSystemRoot;
        subitems.Count = 1;

        supTreeListAddItem(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TVIF_TEXT | TVIF_STATE,
            (UINT)0,
            (UINT)0,
            TEXT("NtSystemRoot"),
            &subitems);

        //
        // NtProductType
        //
        switch (pUserSharedData->NtProductType) {
        case NtProductWinNt:
            lpType = TEXT("NtProductWinNt");
            break;
        case NtProductLanManNt:
            lpType = TEXT("NtProductLanManNt");
            break;
        case NtProductServer:
            lpType = TEXT("NtProductServer");
            break;
        default:
            lpType = T_UnknownType;
            break;
        }

        propObDumpUlong(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("NtProductType"),
            lpType,
            pUserSharedData->NtProductType,
            FALSE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

        propObDumpByte(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("ProductTypeIsValid"),
            (LPWSTR)NULL,
            pUserSharedData->ProductTypeIsValid,
            (COLORREF)0,
            (COLORREF)0,
            TRUE);

        //
        // NtMajorVersion
        //
        propObDumpUlong(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("NtMajorVersion"),
            (LPWSTR)NULL,
            pUserSharedData->NtMajorVersion,
            FALSE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

        //
        // NtMinorVersion
        // 
        propObDumpUlong(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("NtMinorVersion"),
            (LPWSTR)NULL,
            pUserSharedData->NtMinorVersion,
            FALSE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

        //
        // Prior to Windows 10 this field declared as reserved.
        //
        if (g_NtBuildNumber >= NT_WIN10_THRESHOLD1) {
            propObDumpUlong(
                g_UsdDlgContext.TreeList,
                h_tviRootItem,
                TEXT("NtBuildNumber"),
                (LPWSTR)NULL,
                pUserSharedData->NtBuildNumber,
                FALSE,
                FALSE,
                (COLORREF)0,
                (COLORREF)0);
        }

        //
        // ProcessorFeatures
        //
        h_tviSubItem = supTreeListAddItem(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TVIF_TEXT | TVIF_STATE,
            (UINT)0,
            (UINT)0,
            TEXT("ProcessorFeatures"),
            (PVOID)NULL);

        if (h_tviSubItem) {
            for (i = 0; i < PROCESSOR_FEATURE_MAX; i++) {
                if (pUserSharedData->ProcessorFeatures[i]) {
                    bAny = TRUE;
                    lpType = UsdCpuFeatureToText(i);
                    RtlSecureZeroMemory(&subitems, sizeof(subitems));

                    szValue[0] = 0;
                    ultostr(i, szValue);
                    subitems.Text[0] = szValue;
                    subitems.Text[1] = lpType;
                    subitems.Count = 2;
                    h_tviLast = supTreeListAddItem(
                        g_UsdDlgContext.TreeList,
                        h_tviSubItem,
                        TVIF_TEXT | TVIF_STATE,
                        (UINT)0,
                        (UINT)0,
                        (LPWSTR)T_EmptyString,
                        &subitems);
                }
            }

            //
            // Output dotted corner for processor features.
            //
            if (h_tviLast) {
                RtlSecureZeroMemory(&itemex, sizeof(itemex));

                itemex.hItem = h_tviLast;
                itemex.mask = TVIF_TEXT | TVIF_HANDLE;
                itemex.pszText = T_EMPTY;

                TreeList_SetTreeItem(g_UsdDlgContext.TreeList, &itemex, NULL);
            }

            if (bAny == FALSE) {
                RtlSecureZeroMemory(&subitems, sizeof(subitems));
                lpType = TEXT("-");
                _strcpy(szValue, TEXT("0"));
                subitems.Text[0] = szValue;
                subitems.Text[1] = lpType;
                subitems.Count = 2;
                supTreeListAddItem(
                    g_UsdDlgContext.TreeList,
                    h_tviSubItem,
                    TVIF_TEXT | TVIF_STATE,
                    (UINT)0,
                    (UINT)0,
                    (LPWSTR)T_EmptyString,
                    &subitems);
            }
        }

        //
        // AlternativeArchitecture
        //
        switch (pUserSharedData->AlternativeArchitecture) {
        case StandardDesign:
            lpType = TEXT("StandardDesign");
            break;
        case NEC98x86:
            lpType = TEXT("NEC98x86");
            break;
        default:
            lpType = T_UnknownType;
            break;
        }

        propObDumpUlong(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("AlternativeArchitecture"),
            lpType,
            pUserSharedData->AlternativeArchitecture,
            FALSE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

        //
        // SuiteMask
        //
        propDumpEnumWithNames(g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("SuiteMask"),
            pUserSharedData->SuiteMask,
            USD_SuiteMasks,
            RTL_NUMBER_OF(USD_SuiteMasks));

        // KdDebuggerEnabled
        //
        propObDumpByte(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("KdDebuggerEnabled"),
            (LPWSTR)NULL,
            pUserSharedData->KdDebuggerEnabled,
            (COLORREF)0,
            (COLORREF)0,
            TRUE);

        //
        // MitigationPolicies
        //

        if (g_NtBuildNumber < NT_WIN8_RTM) {

            propObDumpByte(
                g_UsdDlgContext.TreeList,
                h_tviRootItem,
                TEXT("NXSupportPolicy"),
                (LPWSTR)NULL,
                pUserSharedData->NXSupportPolicy,
                (COLORREF)0,
                (COLORREF)0,
                FALSE);

        }
        else {

            //
            // Expanded to more values starting from Windows 8+
            //
            UsdDumpMitigationPolicies(h_tviRootItem, pUserSharedData);

        }

        //
        // ActiveConsoleId
        //
        propObDumpUlong(g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("ActiveConsoleId"),
            NULL,
            pUserSharedData->ActiveConsoleId,
            TRUE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

        //
        // SafeBootMode
        //
        propObDumpByte(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("SafeBootMode"),
            (LPWSTR)NULL,
            pUserSharedData->SafeBootMode,
            (COLORREF)0,
            (COLORREF)0,
            TRUE);

        //
        // SharedDataFlags
        //
        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        RtlSecureZeroMemory(&szValue, sizeof(szValue));
        szValue[0] = TEXT('0');
        szValue[1] = TEXT('x');
        ultohex(pUserSharedData->SharedDataFlags, &szValue[2]);
        subitems.Text[0] = szValue;
        subitems.Count = 1;

        h_tviSubItem = supTreeListAddItem(
            g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TVIF_TEXT | TVIF_STATE,
            (UINT)0,
            (UINT)0,
            TEXT("SharedDataFlags"),
            &subitems);

        if (h_tviSubItem) {

            h_tviLast = NULL;

            if (g_NtBuildNumber < NT_WIN8_RTM) {
                pvSharedFlagsDesc = T_SharedDataFlagsW7;
                cFlags = RTL_NUMBER_OF(T_SharedDataFlagsW7);
            }
            else {
                pvSharedFlagsDesc = T_SharedDataFlags;
                cFlags = RTL_NUMBER_OF(T_SharedDataFlags);
            }

            for (i = 0; i < cFlags; i++) {
                if (GET_BIT(pUserSharedData->SharedDataFlags, i)) {
                    RtlSecureZeroMemory(&subitems, sizeof(subitems));
                    RtlSecureZeroMemory(&szValue, sizeof(szValue));
                    _strcpy(szValue, TEXT("BitPos: "));
                    ultostr(i, _strend(szValue));
                    subitems.Text[0] = szValue;
                    subitems.Text[1] = (LPWSTR)pvSharedFlagsDesc[i];
                    subitems.Count = 2;
                    h_tviLast = supTreeListAddItem(
                        g_UsdDlgContext.TreeList,
                        h_tviSubItem,
                        TVIF_TEXT | TVIF_STATE,
                        (UINT)0,
                        (UINT)0,
                        (LPWSTR)T_EmptyString,
                        &subitems);
                }
            }

            //
            // Output dotted corner for shared data flags
            //
            if (h_tviLast) {
                RtlSecureZeroMemory(&itemex, sizeof(itemex));

                itemex.hItem = h_tviLast;
                itemex.mask = TVIF_TEXT | TVIF_HANDLE;
                itemex.pszText = T_EMPTY;

                TreeList_SetTreeItem(g_UsdDlgContext.TreeList, &itemex, NULL);
            }

        }

        //
        // Cookie
        //
        propObDumpUlong(g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("Cookie"),
            NULL,
            pUserSharedData->Cookie,
            TRUE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

        //
        // ActiveProcessorCount
        //
        propObDumpUlong(g_UsdDlgContext.TreeList,
            h_tviRootItem,
            TEXT("ActiveProcessorCount"),
            NULL,
            pUserSharedData->ActiveProcessorCount,
            FALSE,
            FALSE,
            (COLORREF)0,
            (COLORREF)0);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return;
    }
}

/*
* UsdDialogHandlePopupMenu
*
* Purpose:
*
* Treelist popup construction
*
*/
VOID UsdDialogHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    HMENU hMenu;
    POINT pt1;

    if (GetCursorPos(&pt1) == FALSE)
        return;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supTreeListAddCopyValueItem(hMenu,
            g_UsdDlgContext.TreeList,
            ID_OBJECT_COPY,
            0,
            lParam,
            &g_UsdDlgContext.tlSubItemHit))
        {
            TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, pt1.x, pt1.y, 0, hwndDlg, NULL);
        }

        DestroyMenu(hMenu);

    }
}

/*
* UsdDialogOnInit
*
* Purpose:
*
* WM_INITDIALOG handler.
*
*/
VOID UsdDialogOnInit(
    _In_ HWND hwndDlg
)
{
    UsdDumpSharedRegion(hwndDlg);
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
}

/*
* UsdDialogProc
*
* Purpose:
*
* Usd Dialog Procedure
*
*/
INT_PTR CALLBACK UsdDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    switch (uMsg) {

    case WM_INITDIALOG:
        UsdDialogOnInit(hwndDlg);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        DestroyWindow(g_UsdDlgContext.TreeList);
        DestroyWindow(hwndDlg);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:

            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_OBJECT_COPY:

            supTreeListCopyItemValueToClipboard(g_UsdDlgContext.TreeList,
                g_UsdDlgContext.tlSubItemHit);

            break;

        }

        break;

    case WM_CONTEXTMENU:

        UsdDialogHandlePopupMenu(hwndDlg, lParam);
        break;
    }

    return FALSE;
}

/*
* extrasCreateUsdDialog
*
* Purpose:
*
* Create and initialize Usd Dialog.
*
*/
DWORD extrasUsdDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;

    UNREFERENCED_PARAMETER(Parameter);

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_USD),
        0,
        &UsdDialogProc,
        0);


    supSetFastEvent(&UsdDlgInitializedEvent);

    if (hwndDlg) {
        g_UsdDlgContext.hwndDlg = hwndDlg;

        do {

            bResult = GetMessage(&message, NULL, 0, 0);
            if (bResult == -1)
                break;

            if (!IsDialogMessage(hwndDlg, &message)) {
                TranslateMessage(&message);
                DispatchMessage(&message);
            }

        } while (bResult != 0);
    }

    supResetFastEvent(&UsdDlgInitializedEvent);

    if (UsdDlgThreadHandle) {
        NtClose(UsdDlgThreadHandle);
        UsdDlgThreadHandle = NULL;
    }

    return 0;
}

/*
* extrasCreateUsdDialog
*
* Purpose:
*
* Create and initialize Usd Dialog.
*
*/
VOID extrasCreateUsdDialog(
    VOID
)
{
    if (!UsdDlgThreadHandle) {
        RtlSecureZeroMemory(&g_UsdDlgContext, sizeof(g_UsdDlgContext));
        g_UsdDlgContext.tlSubItemHit = -1;
        UsdDlgThreadHandle = supCreateDialogWorkerThread(extrasUsdDialogWorkerThread, NULL, 0);
        if (UsdDlgThreadHandle)
            supWaitForFastEvent(&UsdDlgInitializedEvent, NULL);
    }
}

```

`Source/WinObjEx64/findDlg.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       FINDDLG.C
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

// Define custom message for search completion
#define WM_FINDOBJECT_SEARCHCOMPLETE (WM_USER + 100)

// Search parameters structure
typedef struct _FIND_SEARCH_PARAMS {
    HWND hwndDlg;
    BOOLEAN UseName;
    BOOLEAN UseType;
    WCHAR NameString[MAX_PATH * 2];
    WCHAR TypeString[MAX_PATH * 2];
} FIND_SEARCH_PARAMS, * PFIND_SEARCH_PARAMS;

#define FINDDLG_TRACKSIZE_MIN_X 548
#define FINDDLG_TRACKSIZE_MIN_Y 230

static HANDLE FindDialogThreadHandle = NULL;
static FAST_EVENT FindDialogInitializedEvent = FAST_EVENT_INIT;

typedef struct _FINDDLG_CONTEXT {
    //
    // Dialog controls and resources.
    //
    HWND DialogWindow;
    HWND StatusBar;
    HWND SearchList;
    HICON DialogIcon;

    INT ColumnCount;

    //
    // ListView selection.
    //
    INT iSelectedItem;
    INT iColumnHit;

    // ListView settings.
    INT SortColumn;
    BOOL SortInverse;

    //
    // Resize.
    //
    LONG sizes_init;
    LONG dx1;
    LONG dx2;
    LONG dx3;
    LONG dx4;
    LONG dx5;
    LONG dx6;
    LONG dx7;
    LONG dx8;
    LONG dx9;
    LONG dx10;
    LONG dx11;
    LONG dx12;
    LONG dx13;

    //
    // Search state
    //
    BOOLEAN SearchCancelled;
    HANDLE SearchThread;
} FINDDLG_CONTEXT, * PFINDDLGCONTEXT;

static FINDDLG_CONTEXT g_FindDlgContext;

/*
* FindDlgAddTypes
*
* Purpose:
*
* Enumerate object types and fill combobox with them.
*
*/
VOID FindDlgAddTypes(
    _In_ HWND hwnd
)
{
    ULONG  i;
    SIZE_T cbLen;
    LPWSTR lpType;
    HWND hComboBox = GetDlgItem(hwnd, ID_SEARCH_TYPE);

    POBTYPE_LIST objectTypesList = g_kdctx.Data->ObjectTypesList;
    POBTYPE_ENTRY objectEntry;

    SendMessage(hComboBox, CB_RESETCONTENT, 0, 0);

    if (objectTypesList == NULL) {
        SendMessage(hComboBox, CB_ADDSTRING, 0, (LPARAM)L"*");
        SendMessage(hComboBox, CB_SETCURSEL, 0, 0);
        return;
    }

    supDisableRedraw(hComboBox);

    for (i = 0; i < objectTypesList->NumberOfTypes; i++) {
        objectEntry = &objectTypesList->Types[i];
        cbLen = objectEntry->TypeName->MaximumLength + sizeof(UNICODE_NULL);
        lpType = (LPWSTR)supHeapAlloc(cbLen);
        if (lpType) {
            _strncpy(lpType,
                cbLen / sizeof(WCHAR),
                objectEntry->TypeName->Buffer,
                objectEntry->TypeName->Length / sizeof(WCHAR));

            SendMessage(hComboBox, CB_ADDSTRING, 0, (LPARAM)lpType);
            supHeapFree(lpType);
        }
    }

    SendMessage(hComboBox, CB_ADDSTRING, 0, (LPARAM)L"*");
    SendMessage(hComboBox, CB_SETCURSEL, 0, 0);
    supEnableRedraw(hComboBox);
}

/*
* FindDlgCompareFunc
*
* Purpose:
*
* FindDlg listview comparer function.
*
*/
INT CALLBACK FindDlgCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    return supListViewBaseComparer(g_FindDlgContext.SearchList,
        g_FindDlgContext.SortInverse,
        lParam1,
        lParam2,
        lParamSort);
}

/*
* FindDlgAddListItem
*
* Purpose:
*
* Add item to listview.
*
*/
VOID FindDlgAddListItem(
    _In_ HWND hList,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PUNICODE_STRING TypeName
)
{
    BOOL bNeedFree = FALSE;
    INT lvItemIndex;
    LVITEM lvItem;
    LPWSTR lpName;

    UNICODE_STRING normalizedString;

    bNeedFree = supNormalizeUnicodeStringForDisplay(g_obexHeap, ObjectName, &normalizedString);
    if (bNeedFree)
        lpName = normalizedString.Buffer;
    else
        lpName = ObjectName->Buffer;

    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.pszText = lpName;
    lvItem.iImage = ObManagerGetImageIndexByTypeName(TypeName->Buffer);
    lvItem.iItem = MAXINT;
    lvItemIndex = ListView_InsertItem(hList, &lvItem);
    if (lvItemIndex >= 0) {
        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 1;
        lvItem.pszText = TypeName->Buffer;
        lvItem.iItem = lvItemIndex;
        ListView_SetItem(hList, &lvItem);
    }
    if (bNeedFree)
        supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedString, FALSE);
}

/*
* FindDlgResize
*
* Purpose:
*
* FindDlg WM_SIZE handler, remember control position and move them according new window coordinates.
*
*/
VOID FindDlgResize(
    _In_ HWND hwndDlg,
    _In_ FINDDLG_CONTEXT* Context
)
{
    RECT  r1, r2;
    HWND  hwnd;
    POINT p0;
    HDWP hDeferPos;

    GetClientRect(hwndDlg, &r2);

    if (Context->sizes_init == 0) {
        Context->sizes_init = 1;

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_GROUPBOXOPTIONS), &r1);
        Context->dx1 = r2.right - (r1.right - r1.left);
        Context->dx2 = r1.bottom - r1.top;

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_GROUPBOX), &r1);
        Context->dx3 = r2.bottom - (r1.bottom - r1.top);

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_LIST), &r1);
        Context->dx4 = r2.right - (r1.right - r1.left);
        Context->dx5 = r2.bottom - (r1.bottom - r1.top);

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_NAME), &r1);
        Context->dx6 = r2.right - (r1.right - r1.left);
        Context->dx7 = r1.bottom - r1.top;

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_TYPE), &r1);
        p0.x = r1.left;
        p0.y = r1.top;
        ScreenToClient(hwndDlg, &p0);
        Context->dx8 = r2.right - p0.x;
        Context->dx9 = p0.y;

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_FIND), &r1);
        p0.x = r1.left;
        p0.y = r1.top;
        ScreenToClient(hwndDlg, &p0);
        Context->dx10 = r2.right - p0.x;
        Context->dx11 = p0.y;

        RtlSecureZeroMemory(&r1, sizeof(r1));
        GetWindowRect(GetDlgItem(hwndDlg, ID_SEARCH_TYPELABEL), &r1);
        p0.x = r1.left;
        p0.y = r1.top;
        ScreenToClient(hwndDlg, &p0);
        Context->dx12 = r2.right - p0.x;
        Context->dx13 = p0.y;
    }

    // Start batch window positioning for better performance
    hDeferPos = BeginDeferWindowPos(7);
    if (!hDeferPos) return;

    //resize groupbox search options
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_GROUPBOXOPTIONS);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            0, 0,
            r2.right - Context->dx1, Context->dx2,
            SWP_NOMOVE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    //resize groupbox results
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_GROUPBOX);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            0, 0,
            r2.right - Context->dx1, r2.bottom - Context->dx3,
            SWP_NOMOVE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    //resize listview
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_LIST);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            0, 0,
            r2.right - Context->dx4, r2.bottom - Context->dx5,
            SWP_NOMOVE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    //resize edit
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_NAME);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            0, 0,
            r2.right - Context->dx6, Context->dx7,
            SWP_NOMOVE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    //reposition combobox
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_TYPE);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            r2.right - Context->dx8, Context->dx9,
            0, 0,
            SWP_NOSIZE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    //reposition find button
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_FIND);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            r2.right - Context->dx10, Context->dx11,
            0, 0,
            SWP_NOSIZE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    //reposition Type label
    hwnd = GetDlgItem(hwndDlg, ID_SEARCH_TYPELABEL);
    if (hwnd) {
        hDeferPos = DeferWindowPos(hDeferPos, hwnd, 0,
            r2.right - Context->dx12, Context->dx13,
            0, 0,
            SWP_NOSIZE | SWP_NOZORDER);
        if (!hDeferPos) return;
    }

    // Apply all positioning changes at once
    EndDeferWindowPos(hDeferPos);

    // Update status bar separately (it needs special handling)
    SendMessage(Context->StatusBar, WM_SIZE, 0, 0);

    InvalidateRect(hwndDlg, NULL, FALSE);
}

/*
* FindDlgHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for FindDlg listview.
*
*/
BOOL FindDlgHandleNotify(
    _In_ LPNMLISTVIEW pListView
)
{
    INT      nImageIndex;
    LPWSTR   lpItemText;

    if (pListView->hdr.idFrom != ID_SEARCH_LIST)
        return FALSE;

    switch (pListView->hdr.code) {

    case LVN_ITEMCHANGED:

        if ((pListView->uNewState & LVIS_SELECTED) &&
            !(pListView->uOldState & LVIS_SELECTED))
        {

            lpItemText = supGetItemText(pListView->hdr.hwndFrom,
                pListView->iItem,
                0,
                NULL);

            if (lpItemText) {
                ListToObject(lpItemText);
                supHeapFree(lpItemText);
            }
        }

        break;

    case LVN_COLUMNCLICK:
        g_FindDlgContext.SortInverse = (~g_FindDlgContext.SortInverse) & 1;
        g_FindDlgContext.SortColumn = pListView->iSubItem;
        ListView_SortItemsEx(g_FindDlgContext.SearchList, &FindDlgCompareFunc, g_FindDlgContext.SortColumn);

        nImageIndex = ImageList_GetImageCount(g_ListViewImages);
        if (g_FindDlgContext.SortInverse)
            nImageIndex -= 2;
        else
            nImageIndex -= 1;

        supUpdateLvColumnHeaderImage(
            g_FindDlgContext.SearchList,
            g_FindDlgContext.ColumnCount,
            g_FindDlgContext.SortColumn,
            nImageIndex);

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* FindDlgHandleSettingsChange
*
* Purpose:
*
* Handle global settings change.
*
*/
VOID FindDlgHandleSettingsChange(
    _In_ FINDDLG_CONTEXT* Context
)
{
    DWORD lvExStyle;

    lvExStyle = ListView_GetExtendedListViewStyle(Context->SearchList);
    if (g_WinObj.ListViewDisplayGrid)
        lvExStyle |= LVS_EX_GRIDLINES;
    else
        lvExStyle &= ~LVS_EX_GRIDLINES;

    ListView_SetExtendedListViewStyle(Context->SearchList, lvExStyle);
}

/*
* FindDlgHandlePopupMenu
*
* Purpose:
*
* Search list popup construction.
*
*/
VOID FindDlgHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    UINT uPos = 0;
    FINDDLG_CONTEXT* Context = (FINDDLG_CONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->SearchList,
            ID_OBJECT_COPY,
            uPos,
            lpPoint,
            &Context->iSelectedItem,
            &Context->iColumnHit))
        {
            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }

        DestroyMenu(hMenu);
    }
}

/*
* FindDlgSearchWorkerThread
*
* Purpose:
*
* Background thread to perform object search.
*
*/
DWORD WINAPI FindDlgSearchWorkerThread(
    _In_ LPVOID lpParameter
)
{
    PFIND_SEARCH_PARAMS searchParams = (PFIND_SEARCH_PARAMS)lpParameter;
    HWND hwndDlg = searchParams->hwndDlg;
    PFO_LIST_ITEM flist = NULL;
    UNICODE_STRING usName, usType;
    PUNICODE_STRING pusName = NULL, pusType = NULL;

    // Set up search strings
    if (searchParams->UseName) {
        RtlInitUnicodeString(&usName, searchParams->NameString);
        pusName = &usName;
    }

    if (searchParams->UseType) {
        RtlInitUnicodeString(&usType, searchParams->TypeString);
        pusType = &usType;
    }

    // Perform search
    FindObject(ObGetPredefinedUnicodeString(OBP_ROOT), pusName, pusType, &flist);

    // Update UI from main thread
    SendMessage(hwndDlg, WM_FINDOBJECT_SEARCHCOMPLETE, (WPARAM)flist, 0);

    // Free search parameters
    supHeapFree(searchParams);
    return 0;
}

/*
* FindDlgHandleSearchComplete
*
* Purpose:
*
* Process search results from background thread.
*
*/
VOID FindDlgHandleSearchComplete(
    _In_ HWND hwndDlg,
    _In_ PFO_LIST_ITEM ResultList
)
{
    PFO_LIST_ITEM flist = ResultList;
    PFO_LIST_ITEM plist;
    ULONG cci = 0;
    WCHAR searchString[MAX_PATH + 1];

    // Return to search mode
    SetDlgItemText(hwndDlg, ID_SEARCH_FIND, TEXT("Search"));
    EnableWindow(GetDlgItem(hwndDlg, ID_SEARCH_FIND), TRUE);

    // Check if search was cancelled
    if (g_FindDlgContext.SearchCancelled) {
        g_FindDlgContext.SearchCancelled = FALSE;
        SetDlgItemText(hwndDlg, ID_SEARCH_STATUSBAR, TEXT("Search cancelled"));

        // Free the result list
        while (flist != NULL) {
            plist = flist->Prev;
            supHeapFree(flist);
            flist = plist;
        }

        if (g_FindDlgContext.SearchThread) {
            CloseHandle(g_FindDlgContext.SearchThread);
            g_FindDlgContext.SearchThread = NULL;
        }
        return;
    }

    // Begin batch processing
    supDisableRedraw(g_FindDlgContext.SearchList);

    // Process results
    while (flist != NULL) {
        FindDlgAddListItem(g_FindDlgContext.SearchList, &flist->ObjectName, &flist->ObjectType);
        plist = flist->Prev;
        supHeapFree(flist);
        flist = plist;
        cci++;
    }

    // Sort results
    ListView_SortItemsEx(g_FindDlgContext.SearchList,
        &FindDlgCompareFunc, g_FindDlgContext.SortColumn);

    // Update status
    ultostr(cci, searchString);
    _strcat(searchString, TEXT(" matching object(s)."));
    SetDlgItemText(hwndDlg, ID_SEARCH_STATUSBAR, searchString);

    // End batch processing
    supEnableRedraw(g_FindDlgContext.SearchList);

    // Clean up
    if (g_FindDlgContext.SearchThread) {
        CloseHandle(g_FindDlgContext.SearchThread);
        g_FindDlgContext.SearchThread = NULL;
    }
}

/*
* FindDlgHandleSearch
*
* Purpose:
*
* Search button click handler.
*
*/
VOID FindDlgHandleSearch(
    _In_ HWND hwndDlg
)
{
    WCHAR searchString[MAX_PATH + 1], typeName[MAX_PATH + 1];
    PFIND_SEARCH_PARAMS searchParams;

    // Cancel ongoing search if any
    if (g_FindDlgContext.SearchThread) {
        // Signal cancellation
        if (WaitForSingleObject(g_FindDlgContext.SearchThread, 0) == WAIT_TIMEOUT) {
            g_FindDlgContext.SearchCancelled = TRUE;
            SetDlgItemText(hwndDlg, ID_SEARCH_STATUSBAR, TEXT("Cancelling search..."));
            return;
        }

        CloseHandle(g_FindDlgContext.SearchThread);
        g_FindDlgContext.SearchThread = NULL;
    }

    // Prepare for new search
    g_FindDlgContext.SearchCancelled = FALSE;

    RtlSecureZeroMemory(&searchString, sizeof(searchString));
    RtlSecureZeroMemory(&typeName, sizeof(typeName));

    GetDlgItemText(hwndDlg, ID_SEARCH_NAME, (LPWSTR)&searchString, MAX_PATH);
    GetDlgItemText(hwndDlg, ID_SEARCH_TYPE, (LPWSTR)&typeName, MAX_PATH);

    // Update status and UI
    ListView_DeleteAllItems(g_FindDlgContext.SearchList);
    SetDlgItemText(hwndDlg, ID_SEARCH_STATUSBAR, TEXT("Searching..."));
    EnableWindow(GetDlgItem(hwndDlg, ID_SEARCH_FIND), FALSE);

    // Allocate search params
    searchParams = (PFIND_SEARCH_PARAMS)supHeapAlloc(sizeof(FIND_SEARCH_PARAMS));
    if (searchParams == NULL) {
        SetDlgItemText(hwndDlg, ID_SEARCH_STATUSBAR, TEXT("Memory allocation failed"));
        EnableWindow(GetDlgItem(hwndDlg, ID_SEARCH_FIND), TRUE);
        return;
    }

    searchParams->hwndDlg = hwndDlg;

    // Set up search parameters
    if (searchString[0] == 0) {
        searchParams->UseName = FALSE;
    }
    else {
        searchParams->UseName = TRUE;
        _strcpy(searchParams->NameString, searchString);
    }

    if (typeName[0] == L'*') {
        searchParams->UseType = FALSE;
    }
    else {
        searchParams->UseType = TRUE;
        _strcpy(searchParams->TypeString, typeName);
    }

    // Start search thread
    g_FindDlgContext.SearchThread = CreateThread(NULL, 0, FindDlgSearchWorkerThread, searchParams, 0, NULL);
    if (!g_FindDlgContext.SearchThread) {
        supHeapFree(searchParams);
        SetDlgItemText(hwndDlg, ID_SEARCH_STATUSBAR, TEXT("Failed to create search thread"));
        EnableWindow(GetDlgItem(hwndDlg, ID_SEARCH_FIND), TRUE);
    }
}

/*
* FindDlgOnInit
*
* Purpose:
*
* WM_INITDIALOG handler.
*
*/
VOID FindDlgOnInit(
    _In_ HWND hwndDlg
)
{
    INT iImage = ImageList_GetImageCount(g_ListViewImages) - 1;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"Name", 300, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  iImage },
        { L"Type", 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    g_FindDlgContext.DialogWindow = hwndDlg;
    g_FindDlgContext.StatusBar = GetDlgItem(hwndDlg, ID_SEARCH_STATUSBAR);
    g_FindDlgContext.iColumnHit = -1;
    g_FindDlgContext.iSelectedItem = -1;
    g_FindDlgContext.SearchThread = NULL;
    g_FindDlgContext.SearchCancelled = FALSE;

    //
    // Set dialog icon.
    //
    g_FindDlgContext.DialogIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_MAIN),
        IMAGE_ICON,
        32, 32,
        0);

    if (g_FindDlgContext.DialogIcon) {
        SendMessage(hwndDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)g_FindDlgContext.DialogIcon);
        SendMessage(hwndDlg, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)g_FindDlgContext.DialogIcon);
    }

    g_FindDlgContext.SearchList = GetDlgItem(hwndDlg, ID_SEARCH_LIST);
    if (g_FindDlgContext.SearchList) {

        //
        // Set listview imagelist, style flags and theme.
        //
        supSetListViewSettings(g_FindDlgContext.SearchList,
            LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
            FALSE,
            TRUE,
            g_ListViewImages,
            LVSIL_SMALL);

        //
        // And columns and remember their count.
        //
        g_FindDlgContext.ColumnCount = supAddLVColumnsFromArray(
            g_FindDlgContext.SearchList,
            columnData,
            RTL_NUMBER_OF(columnData));

    }

    FindDlgAddTypes(hwndDlg);
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
    FindDlgResize(hwndDlg, &g_FindDlgContext);
    SetActiveWindow(hwndDlg);
}

/*
* FindDlgProc
*
* Purpose:
*
* Find Dialog window procedure.
*
*/
INT_PTR CALLBACK FindDlgProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    if (uMsg == g_WinObj.SettingsChangeMessage) {
        FindDlgHandleSettingsChange(&g_FindDlgContext);
        return TRUE;
    }

    switch (uMsg) {

    case WM_FINDOBJECT_SEARCHCOMPLETE:
        FindDlgHandleSearchComplete(hwndDlg, (PFO_LIST_ITEM)wParam);
        return TRUE;

    case WM_NOTIFY:
        return FindDlgHandleNotify((LPNMLISTVIEW)lParam);

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                FINDDLG_TRACKSIZE_MIN_X,
                FINDDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_INITDIALOG:
        FindDlgOnInit(hwndDlg);
        break;

    case WM_SIZE:
        FindDlgResize(hwndDlg, &g_FindDlgContext);
        break;

    case WM_DESTROY:
        // Cancel any ongoing search
        if (g_FindDlgContext.SearchThread) {
            g_FindDlgContext.SearchCancelled = TRUE;
            WaitForSingleObject(g_FindDlgContext.SearchThread, 1000);
            CloseHandle(g_FindDlgContext.SearchThread);
            g_FindDlgContext.SearchThread = NULL;
        }
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        if (g_FindDlgContext.DialogIcon)
            DestroyIcon(g_FindDlgContext.DialogIcon);

        DestroyWindow(hwndDlg);
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case ID_OBJECT_COPY:

            supListViewCopyItemValueToClipboard(g_FindDlgContext.SearchList,
                g_FindDlgContext.iSelectedItem,
                g_FindDlgContext.iColumnHit);

            break;

        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_SEARCH_FIND:
            FindDlgHandleSearch(hwndDlg);
            break;

        }
        break;

    case WM_CONTEXTMENU:

        supHandleContextMenuMsgForListView(hwndDlg,
            wParam,
            lParam,
            g_FindDlgContext.SearchList,
            (pfnPopupMenuHandler)FindDlgHandlePopupMenu,
            &g_FindDlgContext);

        break;

    }

    return FALSE;
}

/*
* FindpDlgWorkerThread
*
* Purpose:
*
* Find Dialog thread.
*
*/
DWORD FindpDlgWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;

    UNREFERENCED_PARAMETER(Parameter);

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_SEARCH),
        0,
        &FindDlgProc,
        0);

    supSetFastEvent(&FindDialogInitializedEvent);

    do {

        bResult = GetMessage(&message, NULL, 0, 0);
        if (bResult == -1)
            break;

        if (!IsDialogMessage(hwndDlg, &message)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }

    } while (bResult != 0);

    supResetFastEvent(&FindDialogInitializedEvent);

    if (FindDialogThreadHandle) {
        NtClose(FindDialogThreadHandle);
        FindDialogThreadHandle = NULL;
    }
    return 0;
}

/*
* FindDlgCreate
*
* Purpose:
*
* Run Find Dialog.
*
*/
VOID FindDlgCreate(
    VOID
)
{
    HANDLE hThread;

    if (FindDialogThreadHandle)
        return;

    RtlSecureZeroMemory(&g_FindDlgContext, sizeof(g_FindDlgContext));
    hThread = supCreateDialogWorkerThread(FindpDlgWorkerThread, NULL, 0);
    if (hThread) {

        if (InterlockedCompareExchangePointer(&FindDialogThreadHandle,
            hThread,
            NULL) != NULL)
        {
            //
            // Another instance already created, close duplicate.
            //
            NtClose(hThread);
            return;
        }

        supWaitForFastEvent(&FindDialogInitializedEvent, NULL);
    }
}

```

`Source/WinObjEx64/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2024
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     2.05
*
*  DATE:        05 Jun 2024
*
*  Common header file for the Windows Object Explorer.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Strict UNICODE
//
#if !defined UNICODE
#error ANSI build is not supported
#endif

//
// Ignored warnings
//
#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4054) // 'type cast': from function pointer '%' to data pointer '%'
#pragma warning(disable: 4055) // 'type cast': from data pointer '%' to function pointer '%'
#pragma warning(disable: 4091) // 'typedef ': ignored on left of '%s' when no variable is declared
#pragma warning(disable: 4201) // nameless struct/union
#pragma warning(disable: 4390) // empty controlled statement
#pragma warning(disable: 5105) // macro expansion producing 'defined' has undefined behavior
#pragma warning(disable: 6320) // Exception-filter expression is the constant EXCEPTION_EXECUTE_HANDLER.
#pragma warning(disable: 6258) // Using TerminateThread does not allow proper thread clean up.

// C++ meaningless warnings
#pragma warning(disable: 26446)
#pragma warning(disable: 26481)
#pragma warning(disable: 26482)
#pragma warning(disable: 26485)
#pragma warning(disable: 26489)
#pragma warning(disable: 26493) // Don't use C style casts
#pragma warning(disable: 26494)
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'

//
// Included lib files used by program.
// Unless it is part of runtime unit (e.g. ntos/treelist) they must be listed here.
//
#pragma comment(lib, "Aclui.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "Setupapi.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "Version.lib")

#if defined (_MSC_VER) //for vs2015
#if (_MSC_VER <= 1900)
#pragma warning(disable: 4214)
#pragma warning(disable: 4204)
#endif
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1920)
#pragma comment(linker,"/merge:_RDATA=.rdata")
#endif
#endif

#include <Windows.h>
#include <Windowsx.h>
#include <commctrl.h>
#include <Uxtheme.h>
#include <ShlObj.h>
#include <ntstatus.h>
#include <sddl.h>
#include <slpublic.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <Richedit.h>
#include <Aclui.h>
#include <Aclapi.h>
#include <FltUser.h>
#include <assert.h>

#include "resource.h"
#include "sdk/extdef.h"

#include "minirtl/minirtl.h"
#include "minirtl/rtltypes.h"
#include "minirtl/_filename.h"

#include "ntos/ntos.h"
#include "ntos/ntalpc.h"
#include "ntos/ntsup.h"
#include "ntos/ntbuilds.h"
#include "ntuser/ntuser.h"

#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_

#include "symparser.h"
#include "objects.h"
#include "drivers/wdrvprv.h"
#include "log/log.h"
#include "kldbg.h"
#include "propCommon.h"
#include "ui.h"
#include "sup/sup.h"
#include "sup/wine.h"
#include "hash.h"
#include "extapi.h"
#include "list.h"
#include "excepth.h"
#include "plugmngr.h"
#include "tests/testunit.h"

#if defined(__cplusplus)
#include <malloc.h>
#endif

_Success_(return >= 0)
typedef int(__cdecl *pswprintf_s)(
    _Out_writes_opt_(sizeOfBuffer) _Always_(_Post_z_) wchar_t *buffer,
    _In_ size_t sizeOfBuffer,
    _In_z_ _Printf_format_string_params_(1) const wchar_t *format,
    ...);

typedef void(__cdecl *pqsort)(
    _Inout_updates_bytes_(_NumOfElements * _SizeOfElements) void*  _Base,
    _In_ size_t _NumOfElements,
    _In_ size_t _SizeOfElements,
    _In_ int(__cdecl* _PtFuncCompare)(void const*, void const*)
    );

//declared in main.c
extern pswprintf_s _swprintf_s;
extern pqsort _qsort;

#define RtlStringCchPrintfSecure _swprintf_s
#define RtlQuickSort _qsort

typedef struct _WINOBJ_STATS {
    ULONG TotalHeapAlloc;
    ULONG TotalHeapFree;
    ULONG TotalHeapsCreated;
    ULONG TotalHeapsDestroyed;
    ULONG TotalThreadsCreated;
    ULONG64 TotalHeapMemoryAllocated;
#ifdef _DEBUG
    ULONG64 MaxHeapAllocatedBlockSize;
#endif
} WINOBJ_STATS, *PWINOBJ_STATS;

extern WINOBJ_STATS g_WinObjStats;

#define OBEX_STATS_INC(Name) (InterlockedIncrement((LONG*)&g_WinObjStats.Name))
#define OBEX_STATS_INC64(Name, Value) (InterlockedAdd64((LONG64*)&g_WinObjStats.Name, Value))

typedef struct _WINOBJ_GLOBALS {
    BOOLEAN IsWine;
    BOOLEAN ListViewDisplayGrid;

    ATOM MainWindowClassAtom;
    ATOM TreeListAtom;

    HIMAGELIST ToolBarMenuImages;
    HIMAGELIST ListViewImages;

    HWND MainWindow;
    HWND MainWindowStatusBar;
    HWND MainWindowToolBar;
    HWND MainWindowSplitter;

    HWND ObjectListView;
    HWND ObjectTreeView;

    UINT SettingsChangeMessage;
    ULONG CurrentDPI;
    HINSTANCE hInstance;
    HANDLE Heap;
    
    LIST_ENTRY ObjectPathListHead;

    pfnHtmlHelpW HtmlHelpW;
    RTL_OSVERSIONINFOW osver;

    WCHAR szTempDirectory[MAX_PATH + 1]; //not including backslash
    WCHAR szWindowsDirectory[MAX_PATH + 1]; //not including backslash
    WCHAR szSystemDirectory[MAX_PATH + 1]; //not including backslash
    WCHAR szProgramDirectory[MAX_PATH + 1]; //not including backslash
} WINOBJ_GLOBALS, *PWINOBJ_GLOBALS;

extern WINOBJ_GLOBALS g_WinObj;

//
// Shared heap
//
#define g_obexHeap g_WinObj.Heap

//
// Current object path list
//
#define g_ObjectPathListHead g_WinObj.ObjectPathListHead

#define g_ListViewImages g_WinObj.ListViewImages
#define g_ToolBarMenuImages g_WinObj.ToolBarMenuImages
#define g_hwndObjectList g_WinObj.ObjectListView
#define g_hwndObjectTree g_WinObj.ObjectTreeView

//
// Main program window
//
#define g_hwndMain g_WinObj.MainWindow

#define g_hwndStatusBar g_WinObj.MainWindowStatusBar
#define g_hwndToolBar g_WinObj.MainWindowToolBar
#define g_hwndSplitter g_WinObj.MainWindowSplitter


```

`Source/WinObjEx64/hash.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2025
*
*  TITLE:       HASH.C
*
*  VERSION:     2.08
*
*  DATE:        12 Jun 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

#define DEFAULT_ALIGN_BYTES 8

/*
* CreateHashContext
*
* Purpose:
*
* Allocate CNG context for given algorithm
*
*/
NTSTATUS CreateHashContext(
    _In_ HANDLE HeapHandle,
    _In_ PCWSTR AlgId,
    _Out_ PCNG_CTX* Context
)
{
    NTSTATUS ntStatus;
    ULONG cbResult = 0;
    PCNG_CTX context;

    *Context = NULL;

    context = (PCNG_CTX)HeapAlloc(HeapHandle,
        HEAP_ZERO_MEMORY, sizeof(CNG_CTX));

    if (context == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    do {

        context->HeapHandle = HeapHandle;

        ntStatus = BCryptOpenAlgorithmProvider(&context->AlgHandle,
            AlgId,
            NULL,
            0);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = BCryptGetProperty(context->AlgHandle,
            BCRYPT_OBJECT_LENGTH,
            (PUCHAR)&context->HashObjectSize,
            sizeof(ULONG),
            &cbResult,
            0);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = BCryptGetProperty(context->AlgHandle,
            BCRYPT_HASH_LENGTH,
            (PUCHAR)&context->HashSize,
            sizeof(ULONG),
            &cbResult,
            0);

        if (!NT_SUCCESS(ntStatus))
            break;

        context->HashObject = (PVOID)HeapAlloc(HeapHandle,
            HEAP_ZERO_MEMORY,
            context->HashObjectSize);

        if (context->HashObject == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        context->Hash = (PVOID)HeapAlloc(HeapHandle,
            HEAP_ZERO_MEMORY,
            context->HashSize);

        if (context->Hash == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ntStatus = BCryptCreateHash(context->AlgHandle,
            &context->HashHandle,
            (PUCHAR)context->HashObject,
            context->HashObjectSize,
            NULL,
            0,
            0);

        if (!NT_SUCCESS(ntStatus))
            break;

        *Context = context;
        return STATUS_SUCCESS;

    } while (FALSE);

    if (context->Hash) HeapFree(HeapHandle, 0, context->Hash);
    if (context->HashObject) HeapFree(HeapHandle, 0, context->HashObject);
    if (context->AlgHandle) BCryptCloseAlgorithmProvider(context->AlgHandle, 0);
    HeapFree(HeapHandle, 0, context);

    return ntStatus;
}

/*
* DestroyHashContext
*
* Purpose:
*
* Release all resources allocated for CNG context
*
*/
VOID DestroyHashContext(
    _In_ PCNG_CTX Context
)
{
    HANDLE heapHandle;

    if (!Context) return;

    heapHandle = Context->HeapHandle;

    if (Context->AlgHandle)
        BCryptCloseAlgorithmProvider(Context->AlgHandle, 0);
    if (Context->HashHandle)
        BCryptDestroyHash(Context->HashHandle);
    if (Context->Hash)
        HeapFree(heapHandle, 0, Context->Hash);
    if (Context->HashObject)
        HeapFree(heapHandle, 0, Context->HashObject);

    HeapFree(heapHandle, 0, Context);
}

/*
* HashpAddPad
*
* Purpose:
*
* Calculate hash for pad bytes
*
*/
NTSTATUS HashpAddPad(
    _In_ ULONG PaddingSize,
    _In_ PCNG_CTX HashContext)
{
    static const UCHAR zeroPad[DEFAULT_ALIGN_BYTES] = { 0 };
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG remainingPad = PaddingSize;
    ULONG blockSize;

    if (PaddingSize == 0)
        return STATUS_SUCCESS;

    while (remainingPad > 0) {
        blockSize = min(remainingPad, DEFAULT_ALIGN_BYTES);
        ntStatus = BCryptHashData(HashContext->HashHandle,
            (PUCHAR)zeroPad, blockSize, 0);

        if (!NT_SUCCESS(ntStatus))
            break;

        remainingPad -= blockSize;
    }

    return ntStatus;
}

/*
* HashpGetSizeOfHeaders
*
* Purpose:
*
* Return PE OptionalHeader size of headers
*
*/
DWORD HashpGetSizeOfHeaders(
    _In_ PIMAGE_NT_HEADERS NtHeaders
)
{
    switch (NtHeaders->OptionalHeader.Magic) {
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        return ((PIMAGE_OPTIONAL_HEADER64)&NtHeaders->OptionalHeader)->SizeOfHeaders;
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        return ((PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader)->SizeOfHeaders;
    default:
        return 0;
    }
}

/*
* HashpGetExcludeRange
*
* Purpose:
*
* Retrieve data and offsets to be skipped during hash calculation
*
*/
BOOLEAN HashpGetExcludeRange(
    _In_ PFILE_VIEW_INFO ViewInformation
)
{
    ULONG securityOffset = 0, checksumOffset = 0, endOfLastSection, numberOfSections;
    PIMAGE_DATA_DIRECTORY dataDirectory = NULL;

    PIMAGE_SECTION_HEADER sectionTableEntry;
    PIMAGE_OPTIONAL_HEADER64 opt64 = NULL;
    PIMAGE_OPTIONAL_HEADER32 opt32 = NULL;
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)ViewInformation->ViewBase;

    switch (ViewInformation->NtHeaders->OptionalHeader.Magic) {

    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:

        checksumOffset = dosHeader->e_lfanew +
            UFIELD_OFFSET(IMAGE_NT_HEADERS64, OptionalHeader.CheckSum);
        securityOffset = dosHeader->e_lfanew +
            UFIELD_OFFSET(IMAGE_NT_HEADERS64, OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]);

        opt64 = (PIMAGE_OPTIONAL_HEADER64)&ViewInformation->NtHeaders->OptionalHeader;
        dataDirectory = &opt64->DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];

        break;

    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:

        checksumOffset = dosHeader->e_lfanew +
            UFIELD_OFFSET(IMAGE_NT_HEADERS32, OptionalHeader.CheckSum);
        securityOffset = dosHeader->e_lfanew +
            UFIELD_OFFSET(IMAGE_NT_HEADERS32, OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]);

        opt32 = (PIMAGE_OPTIONAL_HEADER32)&ViewInformation->NtHeaders->OptionalHeader;
        dataDirectory = &opt32->DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];

        break;

    default:
        ViewInformation->Status = StatusBadOptionalHeaderMagic;
        return FALSE;
    }

    if (dataDirectory->VirtualAddress) {

        numberOfSections = ViewInformation->NtHeaders->FileHeader.NumberOfSections;
        if (numberOfSections == 0) {
            ViewInformation->Status = StatusBadSectionCount;
            return FALSE;
        }

        sectionTableEntry = IMAGE_FIRST_SECTION(ViewInformation->NtHeaders);
        endOfLastSection = sectionTableEntry[numberOfSections - 1].PointerToRawData +
            sectionTableEntry[numberOfSections - 1].SizeOfRawData;

        if (dataDirectory->VirtualAddress < endOfLastSection) {
            ViewInformation->Status = StatusBadSecurityDirectoryVA;
            return FALSE;
        }

        if (dataDirectory->VirtualAddress >= ViewInformation->FileSize.LowPart) {
            ViewInformation->Status = StatusBadSecurityDirectoryVA;
            return FALSE;
        }

        if (dataDirectory->Size > (ViewInformation->FileSize.LowPart - dataDirectory->VirtualAddress)) {
            ViewInformation->Status = StatusBadSecurityDirectorySize;
            return FALSE;
        }

    }

    ViewInformation->ExcludeData.ChecksumOffset = checksumOffset;
    ViewInformation->ExcludeData.SecurityOffset = securityOffset;
    ViewInformation->ExcludeData.SecurityDirectory = dataDirectory;

    return TRUE;
}

/*
* HashLoadFile
*
* Purpose:
*
* Load PE file in memory and validate it structure
*
*/
NTSTATUS HashLoadFile(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ BOOLEAN PartialMap
)
{
    NTSTATUS ntStatus;

    ntStatus = supMapInputFileForRead(ViewInformation, PartialMap);
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = STATUS_INVALID_IMAGE_FORMAT;
        if (supIsValidImage(ViewInformation)) {
            ViewInformation->NtHeaders = RtlImageNtHeader(ViewInformation->ViewBase);
            if (ViewInformation->NtHeaders) {
                if (HashpGetExcludeRange(ViewInformation)) {
                    return STATUS_SUCCESS;
                }
            }
            else {
                ViewInformation->Status = StatusBadNtHeaders;
            }
        }
    }
    supDestroyFileViewInfo(ViewInformation);
    return ntStatus;
}

/*
* CalculateFirstPageHash
*
* Purpose:
*
* Compute page hash for PE headers (WDAC compliant), buffer based processing
*
*/
BOOLEAN CalculateFirstPageHash(
    _In_ ULONG PageSize,
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ PCNG_CTX HashContext
)
{
    ULONG offset;
    NTSTATUS ntStatus = STATUS_INVALID_IMAGE_FORMAT;
    ULONG sizeOfHeaders = HashpGetSizeOfHeaders(ViewInformation->NtHeaders);
    PVOID pvImage = ViewInformation->ViewBase;

    __try {
        offset = 0;

        while (offset < PageSize) {
            if (offset == ViewInformation->ExcludeData.ChecksumOffset)
                offset += RTL_FIELD_SIZE(IMAGE_OPTIONAL_HEADER, CheckSum);
            else if (offset == ViewInformation->ExcludeData.SecurityOffset)
                offset += sizeof(IMAGE_DATA_DIRECTORY);

            if (offset >= sizeOfHeaders)
                break;

            ntStatus = BCryptHashData(HashContext->HashHandle,
                (PUCHAR)RtlOffsetToPointer(pvImage, offset), sizeof(BYTE), 0);

            if (!NT_SUCCESS(ntStatus))
                return FALSE;

            offset += 1;
        }

        if (offset < PageSize) {
            ntStatus = HashpAddPad(PageSize - offset, HashContext);
            if (!NT_SUCCESS(ntStatus))
                return FALSE;
        }

        ntStatus = BCryptFinishHash(HashContext->HashHandle,
            (PUCHAR)HashContext->Hash,
            HashContext->HashSize,
            0);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ViewInformation->Status = StatusExceptionOccurred;
        return FALSE;
    }

    return NT_SUCCESS(ntStatus);
}

/*
* CalculateAuthenticodeHash
*
* Purpose:
*
* Compute authenticode hash for image file
*
*/
BOOLEAN CalculateAuthenticodeHash(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ PCNG_CTX HashContext
)
{
    NTSTATUS ntStatus = STATUS_INVALID_IMAGE_FORMAT;
    ULONG securityOffset, checksumOffset, paddingSize;
    ULONG fileOffset = 0, dataSize;
    PVOID imageBase;
    PIMAGE_DATA_DIRECTORY dataDirectory;

    __try {

        imageBase = ViewInformation->ViewBase;
        checksumOffset = ViewInformation->ExcludeData.ChecksumOffset;
        securityOffset = ViewInformation->ExcludeData.SecurityOffset;
        dataDirectory = ViewInformation->ExcludeData.SecurityDirectory;

        // 1. Start of file to checksum
        ntStatus = BCryptHashData(HashContext->HashHandle,
            (PUCHAR)imageBase, checksumOffset, 0);

        if (NT_SUCCESS(ntStatus)) {

            // Skip checksum
            fileOffset = checksumOffset + RTL_FIELD_SIZE(IMAGE_OPTIONAL_HEADER, CheckSum);

            // 2. After checksum to security directory
            dataSize = securityOffset - fileOffset;
            ntStatus = BCryptHashData(HashContext->HashHandle,
                (PUCHAR)RtlOffsetToPointer(imageBase, fileOffset), dataSize, 0);

            if (NT_SUCCESS(ntStatus)) {

                // Skip security directory
                fileOffset = securityOffset + sizeof(IMAGE_DATA_DIRECTORY);

                // 3. After security directory to end or certificate table
                if (dataDirectory->VirtualAddress == 0) {
                    dataSize = ViewInformation->FileSize.LowPart - fileOffset;
                }
                else {
                    dataSize = dataDirectory->VirtualAddress - fileOffset;
                }

                ntStatus = BCryptHashData(HashContext->HashHandle,
                    (PUCHAR)RtlOffsetToPointer(imageBase, fileOffset), dataSize, 0);

                if (NT_SUCCESS(ntStatus)) {

                    // 4. Add padding if needed
                    paddingSize = (dataSize % DEFAULT_ALIGN_BYTES);
                    if (paddingSize) {
                        paddingSize = (DEFAULT_ALIGN_BYTES - paddingSize);
                        ntStatus = HashpAddPad(paddingSize, HashContext);
                        if (!NT_SUCCESS(ntStatus))
                            return FALSE;
                    }

                    ntStatus = BCryptFinishHash(HashContext->HashHandle,
                        (PUCHAR)HashContext->Hash,
                        HashContext->HashSize,
                        0);

                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ViewInformation->Status = StatusExceptionOccurred;
        return FALSE;
    }

    return NT_SUCCESS(ntStatus);
}

LPWSTR ComputeHashForFile(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ LPCWSTR lpAlgId,
    _In_ DWORD PageSize,
    _In_ HANDLE HeapHandle,
    _In_ BOOLEAN FirstPageHashOnly
)
{
    BOOLEAN bComputed;
    PCNG_CTX hashContext;
    LPWSTR lpszHash = NULL;

    if (NT_SUCCESS(CreateHashContext(HeapHandle, lpAlgId, &hashContext))) {

        bComputed = FirstPageHashOnly ?
            CalculateFirstPageHash(PageSize, ViewInformation, hashContext) :
            CalculateAuthenticodeHash(ViewInformation, hashContext);

        if (bComputed) {
            lpszHash = (LPWSTR)supPrintHash((PUCHAR)hashContext->Hash,
                hashContext->HashSize,
                TRUE);
        }

        DestroyHashContext(hashContext);
    }

    return lpszHash;
}

```

`Source/WinObjEx64/hash.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2022
*
*  TITLE:       HASH.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Header file for the hash support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#include <bcrypt.h>
#pragma comment(lib, "Bcrypt.lib")

typedef struct _CNG_CTX {
    PVOID Hash;
    PVOID HashObject;
    ULONG HashSize;
    ULONG HashObjectSize;
    BCRYPT_ALG_HANDLE AlgHandle;
    BCRYPT_HASH_HANDLE HashHandle;
    HANDLE HeapHandle;
} CNG_CTX, * PCNG_CTX;

NTSTATUS CreateHashContext(
    _In_ HANDLE HeapHandle,
    _In_ PCWSTR AlgId,
    _Out_ PCNG_CTX* Context);

VOID DestroyHashContext(
    _In_ PCNG_CTX Context);

NTSTATUS HashLoadFile(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ BOOLEAN PartialMap);

FORCEINLINE VOID HashUnloadFile(
    _In_ PFILE_VIEW_INFO ViewInformation
)
{
    supDestroyFileViewInfo(ViewInformation);
}

LPWSTR ComputeHashForFile(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ LPCWSTR lpAlgId,
    _In_ DWORD PageSize,
    _In_ HANDLE HeapHandle,
    _In_ BOOLEAN FirstPageHashOnly);

```

`Source/WinObjEx64/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.h"
#include "table64.h"

#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)
#pragma warning(disable:26451)

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK; //-V594
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK; //-V594
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM; //-V594
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM; //-V594
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}
#pragma warning(pop)

```

`Source/WinObjEx64/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`Source/WinObjEx64/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2015 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`Source/WinObjEx64/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`Source/WinObjEx64/kldbg.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       KLDBG.C, based on KDSubmarine by Evilcry
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
*  MINIMUM SUPPORTED OS WINDOWS 7
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "ntos\ntldr.h"
#include "hde\hde64.h"
#include "kldbg_patterns.h"
#include "ksymbols.h"

//
// Global variables
//

//Context
KLDBGCONTEXT g_kdctx;

//Build number
ULONG g_NtBuildNumber;

WCHAR g_ObNameNormalizationSymbol = OBJ_NAME_NORMALIZATION_SYMBOL;

//Callbacks
NOTIFICATION_CALLBACKS g_SystemCallbacks;

//Context private data
KLDBGPDATA g_kdpdata;

static UNICODE_STRING g_usObjectsRootDirectory = {
    sizeof(KM_OBJECTS_ROOT_DIRECTORY) - sizeof(WCHAR),
    sizeof(KM_OBJECTS_ROOT_DIRECTORY),
    KM_OBJECTS_ROOT_DIRECTORY
};

static UNICODE_STRING g_usDirectoryType = {
    sizeof(OBTYPE_NAME_DIRECTORY) - sizeof(WCHAR),
    sizeof(OBTYPE_NAME_DIRECTORY),
    OBTYPE_NAME_DIRECTORY
};

static UNICODE_STRING g_usObjectTypesDirectory = {
    sizeof(OBTYPES_DIRECTORY) - sizeof(WCHAR),
    sizeof(OBTYPES_DIRECTORY),
    OBTYPES_DIRECTORY
};

static UNICODE_STRING g_usGlobalRoot = {
    sizeof(OB_GLOBALROOT) - sizeof(WCHAR),
    sizeof(OB_GLOBALROOT),
    OB_GLOBALROOT
};

static UNICODE_STRING g_usGlobalNamespace = {
    sizeof(OB_GLOBALNAMESPACE) - sizeof(WCHAR),
    sizeof(OB_GLOBALNAMESPACE),
    OB_GLOBALNAMESPACE
};

static PUNICODE_STRING g_predefinedUnicodeStrings[] = {
    &g_usObjectsRootDirectory,      // OBP_ROOT (0)
    &g_usDirectoryType,             // OBP_DIRECTORY (1)
    &g_usObjectTypesDirectory,      // OBP_OBTYPES (2)
    &g_usGlobalRoot,                // OBP_GLOBAL (3)
    &g_usGlobalNamespace            // OBP_GLOBALNAMESPACE (4)
};

/*
* ObGetPredefinedUnicodeString
*
* Purpose:
*
* Return pointer to constant unicode string by id.
*
*/
PUNICODE_STRING ObGetPredefinedUnicodeString(
    _In_ ULONG Index
)
{
    if (Index < ARRAYSIZE(g_predefinedUnicodeStrings)) {
        return g_predefinedUnicodeStrings[Index];
    }
    // Default to root directory for out-of-bounds indices
    return &g_usObjectsRootDirectory;
}

/*
* ObFindAddress
*
* Purpose:
*
* Scan code buffer for specified instruction pattern and extract address from it.
*
* Parameters:
*   ImageBase           - Base address of the image in target address space
*   MappedImageBase     - Base address of the mapped image in current process
*   ReqInstructionLength - Expected length of the instruction to match
*   PtrCode             - Pointer to code buffer to scan
*   NumberOfBytes       - Size of the code buffer in bytes
*   ScanPattern         - Pattern to search for
*   ScanPatternSize     - Size of the pattern in bytes
*
* Return Value:
*   Found address or 0 if pattern was not found or parameters are invalid
*/
ULONG_PTR ObFindAddress(
    _In_ ULONG_PTR ImageBase,
    _In_ ULONG_PTR MappedImageBase,
    _In_ ULONG ReqInstructionLength,
    _In_reads_bytes_(NumberOfBytes) PBYTE PtrCode,
    _In_ ULONG NumberOfBytes,
    _In_reads_bytes_(ScanPatternSize) PBYTE ScanPattern,
    _In_ ULONG ScanPatternSize)
{
    ULONG_PTR resultAddress = 0;
    ULONG currentIndex = 0, required;
    LONG relativeOffset = 0;
    hde64s decodedInstruction;

    if (!PtrCode || !ScanPattern || !ScanPatternSize || NumberOfBytes < ScanPatternSize)
        return 0;

    if (ScanPatternSize > ULONG_MAX - sizeof(LONG))
        return 0;

    while (currentIndex < NumberOfBytes) {

        required = ScanPatternSize + (ULONG)sizeof(LONG);
        if (required > NumberOfBytes || currentIndex > NumberOfBytes - required)
            break;

        hde64_disasm((void*)(PtrCode + currentIndex), &decodedInstruction);

        if (decodedInstruction.flags & F_ERROR)
            break;

        if (decodedInstruction.len == ReqInstructionLength) {

            if (ScanPatternSize == RtlCompareMemory(&PtrCode[currentIndex],
                ScanPattern,
                ScanPatternSize))
            {
                if (currentIndex <= NumberOfBytes - required) {
                    relativeOffset = *(PLONG)(PtrCode + currentIndex + ScanPatternSize);
                    resultAddress = (ULONG_PTR)PtrCode + currentIndex + decodedInstruction.len + relativeOffset;
                    resultAddress = ImageBase + resultAddress - MappedImageBase;

                    return resultAddress;
                }
            }
        }

        currentIndex += decodedInstruction.len;
    }

    return 0;
}

/*
* ObGetObjectHeaderOffset
*
* Purpose:
*
* Query requested structure offset for the given mask
*
*
* Object In Memory Disposition
*
* POOL_HEADER
* Various (version, dependent)
* OBJECT_HEADER_PROCESS_INFO
* OBJECT_HEADER_QUOTA_INFO
* OBJECT_HEADER_HANDLE_INFO
* OBJECT_HEADER_NAME_INFO
* OBJECT_HEADER_CREATOR_INFO
* OBJECT_HEADER
*
*/
BYTE ObGetObjectHeaderOffset(
    _In_ BYTE InfoMask,
    _In_ OBJ_HEADER_INFO_FLAG Flag
)
{
    BYTE OffsetMask, HeaderOffset = 0;

    if ((InfoMask & Flag) == 0)
        return 0;

    OffsetMask = InfoMask & (Flag | (Flag - 1));

    if ((OffsetMask & HeaderCreatorInfoFlag) != 0)
        HeaderOffset += (BYTE)sizeof(OBJECT_HEADER_CREATOR_INFO);

    if ((OffsetMask & HeaderNameInfoFlag) != 0)
        HeaderOffset += (BYTE)sizeof(OBJECT_HEADER_NAME_INFO);

    if ((OffsetMask & HeaderHandleInfoFlag) != 0)
        HeaderOffset += (BYTE)sizeof(OBJECT_HEADER_HANDLE_INFO);

    if ((OffsetMask & HeaderQuotaInfoFlag) != 0)
        HeaderOffset += (BYTE)sizeof(OBJECT_HEADER_QUOTA_INFO);

    if ((OffsetMask & HeaderProcessInfoFlag) != 0)
        HeaderOffset += (BYTE)sizeof(OBJECT_HEADER_PROCESS_INFO);

    return HeaderOffset;
}

/*
* ObHeaderToNameInfoAddress
*
* Purpose:
*
*   Calculate address of specific header information structure based on
*   object header flags and object address.
*
* Parameters:
*   ObjectInfoMask      - Information mask from object header
*   ObjectHeaderAddress - Address of the object header
*   HeaderInfoAddress   - Pointer to variable that receives calculated header info address
*   InfoFlag            - Type of header information to locate
*
* Return Value:
*   TRUE if address was successfully calculated and is valid
*   FALSE otherwise
*/
_Success_(return)
BOOL ObHeaderToNameInfoAddress(
    _In_ UCHAR ObjectInfoMask,
    _In_ ULONG_PTR ObjectHeaderAddress,
    _Out_ PULONG_PTR HeaderInfoAddress,
    _In_ OBJ_HEADER_INFO_FLAG InfoFlag
)
{
    BYTE headerOffset;
    ULONG_PTR calculatedAddress;

    if (HeaderInfoAddress == NULL)
        return FALSE;

    if (ObjectHeaderAddress < g_kdctx.SystemRangeStart)
        return FALSE;

    headerOffset = ObGetObjectHeaderOffset(ObjectInfoMask, InfoFlag);
    if (headerOffset == 0)
        return FALSE;

    if (headerOffset > ObjectHeaderAddress)
        return FALSE;

    calculatedAddress = ObjectHeaderAddress - headerOffset;
    if (calculatedAddress < g_kdctx.SystemRangeStart)
        return FALSE;

    *HeaderInfoAddress = calculatedAddress;
    return TRUE;
}

#ifndef STRSAFE_IGNORE_NULLS
#define STRSAFE_IGNORE_NULLS 0x00000100
#endif

/*
* ObIsValidUnicodeStringWorker
*
* Purpose:
*
* Validate UNICODE_STRING structure, from ntstrsafe.h usermode variant.
*
*/
NTSTATUS ObIsValidUnicodeStringWorker(
    _In_opt_ PCUNICODE_STRING SourceString,
    _In_ CONST SIZE_T cchMax,
    _In_ DWORD dwFlags
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    __try {

        //
        // Make it fail on null ptr if corresponding flag is specified.
        //
        if (SourceString || !(dwFlags & STRSAFE_IGNORE_NULLS)) {

            if ((SourceString->Buffer) && //-V522
                !kdAddressInUserModeRange((PVOID)SourceString->Buffer))
            {
                return STATUS_INVALID_PARAMETER;
            }

            if (((SourceString->Length % sizeof(WCHAR)) != 0) ||
                ((SourceString->MaximumLength % sizeof(WCHAR)) != 0) ||
                (SourceString->Length > SourceString->MaximumLength) ||
                (SourceString->MaximumLength > (cchMax * sizeof(WCHAR))))
            {
                ntStatus = STATUS_INVALID_PARAMETER;
            }
            else if ((SourceString->Buffer == NULL) &&
                ((SourceString->Length != 0) || (SourceString->MaximumLength != 0)))
            {
                ntStatus = STATUS_INVALID_PARAMETER;
            }


        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return STATUS_ACCESS_VIOLATION;
    }

    return ntStatus;
}

/*
* ObIsValidUnicodeString
*
* Purpose:
*
* Validate UNICODE_STRING structure contents.
*
*/
NTSTATUS ObIsValidUnicodeString(
    _In_ PCUNICODE_STRING SourceString
)
{
    return ObIsValidUnicodeStringWorker(SourceString, UNICODE_STRING_MAX_CHARS, 0);
}

/*
* ObIsValidUnicodeStringEx
*
* Purpose:
*
* Validate UNICODE_STRING structure contents.
*
*/
NTSTATUS ObIsValidUnicodeStringEx(
    _In_ PCUNICODE_STRING SourceString,
    _In_ DWORD dwFlags
)
{
    return ObIsValidUnicodeStringWorker(SourceString, UNICODE_STRING_MAX_CHARS, dwFlags);
}

/*
* ObCopyBoundaryDescriptor
*
* Purpose:
*
* Copy boundary descriptor from kernel to user.
* Use supHeapFree to free allocated buffer.
*
*/
NTSTATUS ObCopyBoundaryDescriptor(
    _In_ _Notnull_ OBJECT_NAMESPACE_ENTRY* NamespaceLookupEntry,
    _Outptr_result_maybenull_ POBJECT_BOUNDARY_DESCRIPTOR* BoundaryDescriptor,
    _Out_opt_ PULONG BoundaryDescriptorSize
)
{
    ULONG TotalSize;
    ULONG_PTR BoundaryDescriptorAddress;
    OBJECT_BOUNDARY_DESCRIPTOR BoundaryDescriptorHeader, * CopyDescriptor;

    *BoundaryDescriptor = NULL;

    BoundaryDescriptorAddress = (ULONG_PTR)RtlOffsetToPointer(NamespaceLookupEntry,
        sizeof(OBJECT_NAMESPACE_ENTRY));

    if (BoundaryDescriptorAddress < g_kdctx.SystemRangeStart)
        return STATUS_INVALID_PARAMETER;

    RtlSecureZeroMemory(&BoundaryDescriptorHeader, sizeof(BoundaryDescriptorHeader));

    //
    // Read header.
    //
    if (!kdReadSystemMemory(BoundaryDescriptorAddress,
        &BoundaryDescriptorHeader,
        sizeof(OBJECT_BOUNDARY_DESCRIPTOR)))
    {
        return STATUS_DEVICE_NOT_READY;
    }

    if (BoundaryDescriptorSize)
        *BoundaryDescriptorSize = 0;

    //
    // Validate header data.
    //
    TotalSize = BoundaryDescriptorHeader.TotalSize;

    if (TotalSize < sizeof(OBJECT_BOUNDARY_DESCRIPTOR))
        return STATUS_INVALID_PARAMETER;

    if (BoundaryDescriptorHeader.Version != KNOWN_BOUNDARY_DESCRIPTOR_VERSION)
        return STATUS_UNKNOWN_REVISION;

    if ((BoundaryDescriptorAddress + TotalSize) < BoundaryDescriptorAddress)
        return STATUS_INVALID_PARAMETER;

    //
    // Dump entire boundary descriptor.
    //
    CopyDescriptor = (OBJECT_BOUNDARY_DESCRIPTOR*)supHeapAlloc(TotalSize);
    if (CopyDescriptor == NULL)
        return STATUS_MEMORY_NOT_ALLOCATED;

    if (kdReadSystemMemory(BoundaryDescriptorAddress,
        CopyDescriptor,
        TotalSize))
    {
        *BoundaryDescriptor = CopyDescriptor;
        if (BoundaryDescriptorSize)
            *BoundaryDescriptorSize = TotalSize;
    }
    else {
        supHeapFree(CopyDescriptor);
        return STATUS_DEVICE_NOT_READY;
    }

    return STATUS_SUCCESS;
}

/*
* ObpValidateSidBuffer
*
* Purpose:
*
* Check if given SID is valid.
*
*/
BOOLEAN ObpValidateSidBuffer(
    PSID Sid,
    SIZE_T BufferSize
)
{
    PUCHAR Count;

    if (BufferSize < RtlLengthRequiredSid(0))
        return FALSE;

    Count = RtlSubAuthorityCountSid(Sid);
    if (BufferSize < RtlLengthRequiredSid(*Count))
        return FALSE;

    return RtlValidSid(Sid);
}

/*
* ObEnumerateBoundaryDescriptorEntries
*
* Purpose:
*
*   Walk each boundary descriptor entry, validate it and run callback.
*
* Parameters:
*   BoundaryDescriptor - Pointer to the boundary descriptor structure.
*   Callback           - Callback function to call for each entry.
*   Context            - Caller-defined context passed to the callback.
*
* Return Value:
*   NTSTATUS code indicating success or reason for failure.
*/
NTSTATUS ObEnumerateBoundaryDescriptorEntries(
    _In_ OBJECT_BOUNDARY_DESCRIPTOR* BoundaryDescriptor,
    _In_ PENUMERATE_BOUNDARY_DESCRIPTOR_CALLBACK Callback,
    _In_opt_ PVOID Context
)
{
    ULONG EntrySize, TotalItems = 0, NameEntries = 0, IntegrityLabelEntries = 0;
    ULONG BoundaryDescriptorItems = 0;
    ULONG_PTR DataEnd;
    OBJECT_BOUNDARY_ENTRY* CurrentEntry, * NextEntry;

    if (BoundaryDescriptor == NULL || Callback == NULL)
        return STATUS_INVALID_PARAMETER;

    __try {

        if (BoundaryDescriptor->TotalSize < sizeof(OBJECT_BOUNDARY_DESCRIPTOR))
            return STATUS_INVALID_PARAMETER;

        if (BoundaryDescriptor->Version != KNOWN_BOUNDARY_DESCRIPTOR_VERSION)
            return STATUS_INVALID_PARAMETER;

        DataEnd = (ULONG_PTR)RtlOffsetToPointer(BoundaryDescriptor, BoundaryDescriptor->TotalSize);
        if (DataEnd < (ULONG_PTR)BoundaryDescriptor)
            return STATUS_INVALID_PARAMETER;

        CurrentEntry = (OBJECT_BOUNDARY_ENTRY*)RtlOffsetToPointer(BoundaryDescriptor,
            sizeof(OBJECT_BOUNDARY_DESCRIPTOR));

        BoundaryDescriptorItems = BoundaryDescriptor->Items;

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }

    do {
        __try {
            EntrySize = CurrentEntry->EntrySize;
            if (EntrySize < sizeof(OBJECT_BOUNDARY_ENTRY))
                return STATUS_INVALID_PARAMETER;

            TotalItems++;

            if (((ULONG_PTR)CurrentEntry + EntrySize) < (ULONG_PTR)CurrentEntry) {
                return STATUS_INVALID_PARAMETER;
            }

            NextEntry = (OBJECT_BOUNDARY_ENTRY*)ALIGN_UP(((PBYTE)CurrentEntry + EntrySize), ULONG_PTR);
            if ((NextEntry < CurrentEntry) || ((ULONG_PTR)NextEntry > DataEnd))
                return STATUS_INVALID_PARAMETER;

            if (CurrentEntry->EntryType == OBNS_Name) {
                if (++NameEntries > MAX_BOUNDARY_DESCRIPTOR_NAME_ENTRIES)
                    return STATUS_DUPLICATE_NAME;
            }
            else

                if (CurrentEntry->EntryType == OBNS_SID) {
                    if (!ObpValidateSidBuffer((PSID)((PBYTE)CurrentEntry + sizeof(OBJECT_BOUNDARY_ENTRY)),
                        EntrySize - sizeof(OBJECT_BOUNDARY_ENTRY)))
                    {
                        return STATUS_INVALID_PARAMETER;
                    }
                }
                else
                    if (CurrentEntry->EntryType == OBNS_IntegrityLabel) {
                        if (++IntegrityLabelEntries > MAX_BOUNDARY_DESCRIPTOR_IL_ENTRIES)
                            return STATUS_DUPLICATE_OBJECTID;
                    }
        }
        __except (WOBJ_EXCEPTION_FILTER_LOG) {
            return GetExceptionCode();
        }

        if (Callback(CurrentEntry, Context))
            return STATUS_SUCCESS;

        CurrentEntry = NextEntry;

    } while ((ULONG_PTR)CurrentEntry < (ULONG_PTR)DataEnd);

    return (TotalItems != BoundaryDescriptorItems) ? STATUS_INVALID_PARAMETER : STATUS_SUCCESS;
}

/*
* ObpDumpObjectWithSpecifiedSize
*
* Purpose:
*
* Return dumped object version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObpDumpObjectWithSpecifiedSize(
    _In_ ULONG_PTR ObjectAddress,
    _In_ ULONG ObjectSize,
    _In_ ULONG ObjectVersion,
    _Out_ PULONG OutSize,
    _Out_ PULONG OutVersion
)
{
    PVOID ObjectBuffer = NULL;
    ULONG BufferSize = ALIGN_UP_BY(ObjectSize, PAGE_SIZE);

    *OutSize = 0;
    *OutVersion = 0;

    if (ObjectAddress < g_kdctx.SystemRangeStart)
        return NULL;

    ObjectBuffer = supVirtualAlloc(BufferSize);
    if (ObjectBuffer) {
        if (kdReadSystemMemory(ObjectAddress,
            ObjectBuffer,
            (ULONG)ObjectSize))
        {
            *OutSize = ObjectSize;
            *OutVersion = ObjectVersion;
        }
        else {
            supVirtualFree(ObjectBuffer);
            ObjectBuffer = NULL;
        }
    }
    return ObjectBuffer;
}

/*
* ObDumpObjectTypeVersionAware
*
* Purpose:
*
* Return dumped OBJECT_TYPE object version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpObjectTypeVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    switch (g_NtBuildNumber) {
    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
        objectSize = sizeof(OBJECT_TYPE_7);
        objectVersion = OBVERSION_OBJECT_TYPE_V1;
        break;
    case NT_WIN8_RTM:
    case NT_WIN8_BLUE:
    case NT_WIN10_THRESHOLD1:
    case NT_WIN10_THRESHOLD2:
        objectSize = sizeof(OBJECT_TYPE_8);
        objectVersion = OBVERSION_OBJECT_TYPE_V2;
        break;
    case NT_WIN10_REDSTONE1:
        objectSize = sizeof(OBJECT_TYPE_RS1);
        objectVersion = OBVERSION_OBJECT_TYPE_V3;
        break;
    default:
        objectSize = sizeof(OBJECT_TYPE_RS2);
        objectVersion = OBVERSION_OBJECT_TYPE_V4;
        break;
    }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress,
        objectSize,
        objectVersion,
        Size,
        Version);
}

/*
* ObDumpAlpcPortObjectVersionAware
*
* Purpose:
*
* Return dumped ALPC_PORT object version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpAlpcPortObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    switch (g_NtBuildNumber) {
    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
        objectSize = sizeof(ALPC_PORT_7600);
        objectVersion = OBVERSION_ALPCPORT_V1;
        break;
    case NT_WIN8_RTM:
        objectSize = sizeof(ALPC_PORT_9200);
        objectVersion = OBVERSION_ALPCPORT_V2;
        break;
    case NT_WIN8_BLUE:
        objectSize = sizeof(ALPC_PORT_9600);
        objectVersion = OBVERSION_ALPCPORT_V3;
        break;
    default:
        objectSize = sizeof(ALPC_PORT_10240);
        objectVersion = OBVERSION_ALPCPORT_V4;
        break;
    }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress,
        objectSize,
        objectVersion,
        Size,
        Version);
}

/*
* ObDumpDirectoryObjectVersionAware
*
* Purpose:
*
* Return dumped OBJECT_DIRECTORY object version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpDirectoryObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    switch (g_NtBuildNumber) {

    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
    case NT_WIN8_RTM:
    case NT_WIN8_BLUE:
        objectSize = sizeof(OBJECT_DIRECTORY);
        objectVersion = OBVERSION_DIRECTORY_V1;
        break;

    case NT_WIN10_THRESHOLD1:
    case NT_WIN10_THRESHOLD2:
    case NT_WIN10_REDSTONE1:
        objectSize = sizeof(OBJECT_DIRECTORY_V2);
        objectVersion = OBVERSION_DIRECTORY_V2;
        break;

    default:
        objectSize = sizeof(OBJECT_DIRECTORY_V3);
        objectVersion = OBVERSION_DIRECTORY_V3;
        break;
    }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress,
        objectSize,
        objectVersion,
        Size,
        Version);
}

/*
* ObDumpSymbolicLinkObjectVersionAware
*
* Purpose:
*
* Return dumped OBJEC_SYMBOLIC_LINK object version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpSymbolicLinkObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    switch (g_NtBuildNumber) {
    case NT_WIN7_RTM:
    case NT_WIN7_SP1:
    case NT_WIN8_RTM:
    case NT_WIN8_BLUE:
        objectSize = sizeof(OBJECT_SYMBOLIC_LINK_V1);
        objectVersion = OBVERSION_OBJECT_SYMBOLIC_LINK_V1;
        break;
    case NT_WIN10_THRESHOLD1:
    case NT_WIN10_THRESHOLD2:
        objectSize = sizeof(OBJECT_SYMBOLIC_LINK_V2);
        objectVersion = OBVERSION_OBJECT_SYMBOLIC_LINK_V2;
        break;
    case NT_WIN10_REDSTONE1:
        objectSize = sizeof(OBJECT_SYMBOLIC_LINK_V3);
        objectVersion = OBVERSION_OBJECT_SYMBOLIC_LINK_V3;
        break;
    case NT_WIN10_REDSTONE2:
    case NT_WIN10_REDSTONE3:
    case NT_WIN10_REDSTONE4:
    case NT_WIN10_REDSTONE5:
    case NT_WIN10_19H1:
    case NT_WIN10_19H2:
    case NT_WIN10_20H1:
    case NT_WIN10_20H2:
    case NT_WIN10_21H1:
    case NT_WIN10_21H2:
    case NT_WIN10_22H2:
        objectSize = sizeof(OBJECT_SYMBOLIC_LINK_V4);
        objectVersion = OBVERSION_OBJECT_SYMBOLIC_LINK_V4;
        break;
    case NT_WINSRV_21H1:
    case NT_WIN11_21H2:
    case NT_WIN11_22H2:
    case NT_WIN11_23H2:
    case NT_WIN11_24H2:
    default:
        objectSize = sizeof(OBJECT_SYMBOLIC_LINK_V5);
        objectVersion = OBVERSION_OBJECT_SYMBOLIC_LINK_V5;
        break;
    }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress,
        objectSize,
        objectVersion,
        Size,
        Version);
}

/*
* ObDumpDeviceMapVersionAware
*
* Purpose:
*
* Return dumped DEVICE_MAP structure version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpDeviceMapVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    if (g_NtBuildNumber >= NT_WIN7_RTM &&
        g_NtBuildNumber < NT_WIN10_REDSTONE1)
    {
        objectSize = sizeof(DEVICE_MAP_V1);
        objectVersion = OBVERSION_DEVICE_MAP_V1;
    }
    else
        if (g_NtBuildNumber >= NT_WIN10_REDSTONE1 &&
            g_NtBuildNumber < NT_WIN11_21H2)
        {
            objectSize = sizeof(DEVICE_MAP_V2);
            objectVersion = OBVERSION_DEVICE_MAP_V2;
        }
        else {
            objectSize = sizeof(DEVICE_MAP_V3);
            objectVersion = OBVERSION_DEVICE_MAP_V3;
        }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress,
        objectSize,
        objectVersion,
        Size,
        Version);
}

/*
* ObDumpDriverExtensionVersionAware
*
* Purpose:
*
* Return dumped DRIVER_EXTENSION structure version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpDriverExtensionVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    if (g_NtBuildNumber >= NT_WIN8_BLUE) {
        objectSize = sizeof(DRIVER_EXTENSION_V4);
        objectVersion = OBVERSION_DRIVER_EXTENSION_V4;
    }
    else {

        switch (g_NtBuildNumber) {
        case NT_WIN7_RTM:
        case NT_WIN7_SP1:
            objectSize = sizeof(DRIVER_EXTENSION_V2);
            objectVersion = OBVERSION_DRIVER_EXTENSION_V2;
            break;
        case NT_WIN8_RTM:
            objectSize = sizeof(DRIVER_EXTENSION_V3);
            objectVersion = OBVERSION_DRIVER_EXTENSION_V3;
            break;
        default:
            objectSize = sizeof(DRIVER_EXTENSION);
            objectVersion = OBVERSION_DRIVER_EXTENSION_V1;
            break;
        }
    }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress,
        objectSize,
        objectVersion,
        Size,
        Version);
}

/*
* ObDumpFltFilterObjectVersionAware
*
* Purpose:
*
* Return dumped FLT_FILTER structure version aware.
*
* Use supVirtualFree to free returned buffer.
*
*/
_Ret_maybenull_
PVOID ObDumpFltFilterObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version
)
{
    ULONG objectSize = 0;
    ULONG objectVersion = 0;

    //
    // Check the newest versions first.
    //
    if (g_NtBuildNumber >= NT_WIN11_21H2) {
        if (g_NtBuildNumber < NT_WIN11_24H2) {
            objectSize = sizeof(FLT_FILTER_V4);
            objectVersion = OBVERSION_FLT_FILTER_V4;
        }
        else {
            goto DefaultCase;
        }
    }
    else if (g_NtBuildNumber >= NT_WIN10_THRESHOLD1) {
        if (g_NtBuildNumber < NT_WINSRV_21H1) {
            objectSize = sizeof(FLT_FILTER_V3);
            objectVersion = OBVERSION_FLT_FILTER_V3;
        }
        else {
            goto DefaultCase;
        }
    }
    else if (g_NtBuildNumber >= NT_WIN8_RTM) {
        if (g_NtBuildNumber <= NT_WIN8_BLUE) {
            objectSize = sizeof(FLT_FILTER_V2);
            objectVersion = OBVERSION_FLT_FILTER_V2;
        }
        else {
            goto DefaultCase;
        }
    }
    else if (g_NtBuildNumber == NT_WIN7_RTM || g_NtBuildNumber == NT_WIN7_SP1) {
        objectSize = sizeof(FLT_FILTER_V1);
        objectVersion = OBVERSION_FLT_FILTER_V1;
    }
    else {
    DefaultCase:
        objectSize = sizeof(FLT_FILTER_V5);
        objectVersion = OBVERSION_FLT_FILTER_V5;
    }

    return ObpDumpObjectWithSpecifiedSize(ObjectAddress, objectSize, objectVersion, Size, Version);
}

/*
* kdDumpUnicodeString
*
* Purpose:
*
* Dump UNICODE_STRING from kernel space.
*
*/
_Success_(return)
BOOLEAN kdDumpUnicodeString(
    _In_ PUNICODE_STRING InputString,
    _Out_ PUNICODE_STRING OutputString,
    _Out_opt_ PVOID * ReferenceStringBuffer,
    _In_ BOOLEAN IsKernelPointer
)
{
    ULONG readBytes = 0;
    LPWSTR lpStringBuffer;
    UNICODE_STRING string;

    if (IsKernelPointer) {

        RtlInitEmptyUnicodeString(&string, NULL, 0);
        if (!kdReadSystemMemoryEx((ULONG_PTR)InputString,
            &string,
            sizeof(UNICODE_STRING),
            &readBytes))
        {
            return FALSE;
        }
        if (readBytes != sizeof(UNICODE_STRING))
            return FALSE;
    }
    else {
        string = *InputString;
    }

    if (string.Length == 0 || string.MaximumLength == 0)
        return FALSE;

    lpStringBuffer = (LPWSTR)supHeapAlloc(string.Length + sizeof(UNICODE_NULL));
    if (lpStringBuffer) {

        if (kdReadSystemMemoryEx((ULONG_PTR)string.Buffer,
            lpStringBuffer,
            string.Length,
            &readBytes))
        {
            if (readBytes == string.Length) {

                OutputString->Buffer = lpStringBuffer;
                OutputString->Length = string.Length;
                OutputString->MaximumLength = string.MaximumLength;

                if (ReferenceStringBuffer)
                    *ReferenceStringBuffer = string.Buffer;

                return TRUE;
            }
        }

        supHeapFree(lpStringBuffer);
    }

    return FALSE;
}

/*
* ObDecodeTypeIndex
*
* Purpose:
*
* Decode object TypeIndex, encoding introduced in win10
*
* Limitation:
*
* Only for Win10+ use
*
*/
UCHAR ObDecodeTypeIndex(
    _In_ PVOID Object,
    _In_ UCHAR EncodedTypeIndex
)
{
    UCHAR          TypeIndex;
    POBJECT_HEADER ObjectHeader;

    //
    // Cookie can be zero or we have no valid cookie data, return as is.
    //
    if (g_kdctx.Data->ObHeaderCookie.Valid == FALSE) {
        return EncodedTypeIndex;
    }

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
    TypeIndex = (EncodedTypeIndex ^
        (UCHAR)((ULONG_PTR)ObjectHeader >> OBJECT_SHIFT) ^
        g_kdctx.Data->ObHeaderCookie.Value);

    return TypeIndex;
}

/*
* ObpFindHeaderCookie
*
* Purpose:
*
* Parse ObGetObjectType and extract object header cookie variable address.
* Called once.
*
* Limitation:
*
* Only for Win10+ use
*
*/
BOOLEAN ObpFindHeaderCookie(
    _In_ PKLDBGCONTEXT Context
)
{
    UCHAR      cookieValue = 0;
    PBYTE      ptrCode;
    ULONG_PTR  lookupAddress;

    ULONG_PTR NtOsBase;
    HMODULE hNtOs;

    OBHEADER_COOKIE* Cookie;

    Cookie = &Context->Data->ObHeaderCookie;
    Cookie->Valid = FALSE;

    NtOsBase = (ULONG_PTR)Context->NtOsBase;
    hNtOs = (HMODULE)Context->NtOsImageMap;

    lookupAddress = 0;

    //
    // If symbols available, lookup address from them.
    //
    if (kdIsSymAvailable((PSYMCONTEXT)Context->NtOsSymContext)) {

        kdGetAddressFromSymbol(
            Context,
            KVAR_ObHeaderCookie,
            &lookupAddress);

    }

    //
    // No symbols available or there is an error, switch to signature search.
    //
    if (lookupAddress == 0) {

        ptrCode = (PBYTE)GetProcAddress(hNtOs, "ObGetObjectType");
        if (ptrCode) {

            lookupAddress = ObFindAddress(NtOsBase,
                (ULONG_PTR)hNtOs,
                IL_ObHeaderCookie,
                ptrCode,
                DA_ScanBytesObHeaderCookie,
                ObHeaderCookiePattern,
                sizeof(ObHeaderCookiePattern));

        }

        if (!kdAddressInNtOsImage((PVOID)lookupAddress))
            return FALSE;

    }

    if (kdReadSystemMemory(
        lookupAddress,
        &cookieValue,
        sizeof(cookieValue)))
    {
        Cookie->Valid = TRUE;
        Cookie->Value = cookieValue;
    }

    return Cookie->Valid;
}

/*
* ObpFindProcessObjectOffsets
*
* Purpose:
*
* Extract EPROCESS offsets from ntoskrnl routines.
*
*/
BOOLEAN ObpFindProcessObjectOffsets(
    _In_ PKLDBGCONTEXT Context
)
{
    PBYTE   ptrCode;

    HMODULE hNtOs;

    ULONG offsetValue;

    hde64s  hs;

    PEPROCESS_OFFSET pOffsetProcessId = &Context->Data->PsUniqueProcessId;
    PEPROCESS_OFFSET pOffsetImageName = &Context->Data->PsProcessImageName;

    hNtOs = (HMODULE)Context->NtOsImageMap;

    do {

        //
        // If symbols available try lookup field offset from them.
        //
        if (kdIsSymAvailable((PSYMCONTEXT)Context->NtOsSymContext)) {

            if (pOffsetProcessId->Valid == FALSE) {

                offsetValue = 0;
                if (kdGetFieldOffsetFromSymbol(
                    Context,
                    KSYM_EPROCESS,
                    KFLD_UniqueProcessId,
                    &offsetValue))
                {
                    pOffsetProcessId->OffsetValue = offsetValue;
                    pOffsetProcessId->Valid = TRUE;
                }

            }

            if (pOffsetImageName->Valid == FALSE) {

                offsetValue = 0;
                if (kdGetFieldOffsetFromSymbol(
                    Context,
                    KSYM_EPROCESS,
                    KFLD_ImageFileName,
                    &offsetValue))
                {
                    pOffsetImageName->OffsetValue = offsetValue;
                    pOffsetImageName->Valid = TRUE;
                }

            }
        }

        if (pOffsetProcessId->Valid == FALSE) {

            ptrCode = (PBYTE)GetProcAddress(hNtOs, "PsGetProcessId");
            if (ptrCode == NULL)
                break;

            hde64_disasm((void*)(ptrCode), &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len != 7)
                break;

            pOffsetProcessId->OffsetValue = *(PULONG)(ptrCode + 3);
            pOffsetProcessId->Valid = TRUE;

        }

        if (pOffsetImageName->Valid == FALSE) {

            ptrCode = (PBYTE)GetProcAddress(hNtOs, "PsGetProcessImageFileName");
            if (ptrCode == NULL)
                break;

            hde64_disasm((void*)(ptrCode), &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len != 7)
                break;

            pOffsetImageName->OffsetValue = *(PULONG)(ptrCode + 3);
            pOffsetImageName->Valid = TRUE;

        }

    } while (FALSE);

    return (pOffsetProcessId->Valid == TRUE && pOffsetImageName->Valid == TRUE);
}

/*
* ObFindPrivateNamespaceLookupTable2
*
* Purpose:
*
* Locate and return address of namespace table.
*
* Limitation:
*
* OS dependent, Windows 10 (RS1 - 19H1).
*
*/
PVOID ObFindPrivateNamespaceLookupTable2(
    _In_ PKLDBGCONTEXT Context
)
{
    ULONG_PTR varAddress = 0;

    PVOID   SectionBase;
    ULONG   SectionSize = 0;

    PBYTE   Signature;
    ULONG   SignatureSize;

    PBYTE   ptrCode = NULL;

    ESERVERSILO_GLOBALS PspHostSiloGlobals;

    HMODULE hNtOs = (HMODULE)Context->NtOsImageMap;

    do {

        //
        // Symbols lookup.
        //
        if (kdIsSymAvailable((PSYMCONTEXT)Context->NtOsSymContext)) {

            kdGetAddressFromSymbol(
                Context,
                KVAR_PspHostSiloGlobals,
                &varAddress);

        }

        //
        // Pattern search.
        //
        if (varAddress == 0) {

            //
            // Locate .text image section.
            //
            SectionBase = supLookupImageSectionByName(TEXT_SECTION,
                TEXT_SECTION_LENGTH,
                (PVOID)hNtOs,
                &SectionSize);

            if (SectionBase == NULL || SectionSize == 0)
                break;

            //
            // Locate starting point for search ->
            // PsGetServerSiloServiceSessionId for RS4+ and PsGetServerSiloGlobals for RS1-RS3.
            //
            if (g_NtBuildNumber >= NT_WIN10_REDSTONE4) {

                ptrCode = (PBYTE)GetProcAddress(hNtOs, "PsGetServerSiloServiceSessionId");

            }
            else {

                switch (g_NtBuildNumber) {

                case NT_WIN10_REDSTONE1:
                    SignatureSize = sizeof(PsGetServerSiloGlobalsPattern_14393);
                    Signature = PsGetServerSiloGlobalsPattern_14393;
                    break;
                case NT_WIN10_REDSTONE2:
                case NT_WIN10_REDSTONE3:
                    SignatureSize = sizeof(PsGetServerSiloGlobalsPattern_15064_16299);
                    Signature = PsGetServerSiloGlobalsPattern_15064_16299;
                    break;
                default:
                    //
                    // We need to fail if this is unknown release.
                    //
                    return NULL;
                }

                ptrCode = (PBYTE)supFindPattern((PBYTE)SectionBase,
                    SectionSize,
                    Signature,
                    SignatureSize);
            }

            if (ptrCode == NULL)
                break;

            //
            // Find address to PspHostSiloGlobals in code.
            //
            varAddress = ObFindAddress((ULONG_PTR)Context->NtOsBase,
                (ULONG_PTR)hNtOs,
                IL_PspHostSiloGlobals,
                ptrCode,
                DA_ScanBytesPNSVariant1,
                LeaPattern_PNS,
                sizeof(LeaPattern_PNS));

            if (!kdAddressInNtOsImage((PVOID)varAddress))
                return NULL;

        }

        //
        // Dump PspHostSiloGlobals.
        //
        RtlSecureZeroMemory(&PspHostSiloGlobals, sizeof(PspHostSiloGlobals));

        if (kdReadSystemMemory(varAddress,
            &PspHostSiloGlobals,
            sizeof(PspHostSiloGlobals)))
        {
            //
            // Return adjusted address of PrivateNamespaceLookupTable.
            //
            varAddress += FIELD_OFFSET(OBP_SILODRIVERSTATE, PrivateNamespaceLookupTable);

        }
        else {
            varAddress = 0;
        }


    } while (FALSE);

    return (PVOID)varAddress;
}

/*
* ObFindPrivateNamespaceLookupTable
*
* Purpose:
*
* Locate and return address of private namespace table.
*
*/
PVOID ObFindPrivateNamespaceLookupTable(
    _In_ PKLDBGCONTEXT Context
)
{
    PBYTE      Signature;
    ULONG      SignatureSize;

    ULONG_PTR  Address = 0;

    PBYTE      ptrCode = NULL;
    PVOID      SectionBase;
    ULONG      SectionSize = 0;

    HMODULE hNtOs = (HMODULE)Context->NtOsImageMap;

    if (g_NtBuildNumber > NT_WIN10_THRESHOLD2)
        return ObFindPrivateNamespaceLookupTable2(Context);

    do {

        //
        // Locate PAGE image section.
        //
        SectionBase = supLookupImageSectionByName(PAGE_SECTION,
            PAGE_SECTION_LENGTH,
            (PVOID)hNtOs,
            &SectionSize);

        if ((SectionBase == 0) || (SectionSize == 0))
            break;

        switch (g_NtBuildNumber) {

        case NT_WIN8_RTM:
            Signature = NamespacePattern8;
            SignatureSize = sizeof(NamespacePattern8);
            break;

        default:
            Signature = NamespacePattern;
            SignatureSize = sizeof(NamespacePattern);
            break;
        }

        ptrCode = (PBYTE)supFindPattern((PBYTE)SectionBase,
            SectionSize,
            Signature,
            SignatureSize);

        if (ptrCode == NULL)
            break;

        Address = ObFindAddress((ULONG_PTR)Context->NtOsBase,
            (ULONG_PTR)hNtOs,
            IL_PspHostSiloGlobals,
            ptrCode,
            DA_ScanBytesPNSVariant2,
            LeaPattern_PNS,
            sizeof(LeaPattern_PNS));

        if (!kdAddressInNtOsImage((PVOID)Address)) {
            Address = 0;
            break;
        }

    } while (FALSE);

    return (PVOID)Address;
}

/*
* ObGetCallbackBlockRoutine
*
* Purpose:
*
* Read callback block routine from kernel and return function pointer.
*
*/
PVOID ObGetCallbackBlockRoutine(
    _In_ PVOID CallbackBlock
)
{
    EX_CALLBACK_ROUTINE_BLOCK readBlock;

    readBlock.Function = NULL;

    if (!kdReadSystemMemory((ULONG_PTR)CallbackBlock,
        &readBlock,
        sizeof(EX_CALLBACK_ROUTINE_BLOCK)))
    {
        return NULL;
    }
    else {
        return readBlock.Function;
    }
}

/*
* kdpFindKiServiceTableByPattern
*
* Purpose:
*
* Signature pattern based search for service table address.
*
*/
BOOL kdpFindKiServiceTableByPattern(
    _In_ ULONG_PTR MappedImageBase,
    _In_ ULONG_PTR KernelImageBase,
    _Out_ ULONG_PTR * Address
)
{
    ULONG signatureSize;
    ULONG sectionSize;
    ULONG_PTR lookupAddress = 0, varAddress = 0, sectionBase = 0;

    *Address = 0;

    //
    // Locate .text image section.
    //
    sectionBase = (ULONG_PTR)supLookupImageSectionByName(TEXT_SECTION,
        TEXT_SECTION_LENGTH,
        (PVOID)MappedImageBase,
        &sectionSize);

    if (sectionBase == 0)
        return FALSE;

    signatureSize = sizeof(KiSystemServiceStartPattern);
    if (sectionSize < signatureSize)
        return FALSE;

    //
    // Find KiSystemServiceStart signature.
    //
    lookupAddress = (ULONG_PTR)supFindPattern(
        (PBYTE)sectionBase,
        sectionSize,
        (PBYTE)KiSystemServiceStartPattern,
        signatureSize);

    if (lookupAddress == 0)
        return FALSE;

    lookupAddress += signatureSize;

    //
    // Find KeServiceDescriptorTableShadow.
    //
    varAddress = ObFindAddress(KernelImageBase,
        (ULONG_PTR)MappedImageBase,
        IL_KeServiceDescriptorTableShadow,
        (PBYTE)lookupAddress,
        DA_ScanBytesKeServiceDescriptorTableShadow,
        LeaPattern_KeServiceDescriptorTableShadow,
        sizeof(LeaPattern_KeServiceDescriptorTableShadow));

    if (kdAddressInNtOsImage((PVOID)varAddress)) {
        *Address = varAddress;
        return TRUE;
    }

    return FALSE;
}

/*
* kdFindKiServiceTable
*
* Purpose:
*
* Find system service table pointer from ntoskrnl image.
*
*/
BOOL kdFindKiServiceTable(
    _In_ ULONG_PTR MappedImageBase,
    _In_ ULONG_PTR KernelImageBase,
    _Inout_ KSERVICE_TABLE_DESCRIPTOR * ServiceTable
)
{
    ULONG_PTR varAddress = 0;

    //
    // If KeServiceDescriptorTableShadow was not extracted then extract it otherwise use ready address.
    //
    if (g_kdctx.Data->KeServiceDescriptorTableShadowPtr) {

        varAddress = g_kdctx.Data->KeServiceDescriptorTableShadowPtr;

    }
    else {

        //
        // Symbols lookup.
        //
        if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {

            kdGetAddressFromSymbol(
                &g_kdctx,
                KVAR_KeServiceDescriptorTableShadow,
                &varAddress);

        }

        //
        // Pattern search.
        //
        if (varAddress == 0) {

            if (!kdpFindKiServiceTableByPattern(MappedImageBase,
                KernelImageBase,
                &varAddress))
            {
                return FALSE;
            }

        }

        g_kdctx.Data->KeServiceDescriptorTableShadowPtr = varAddress;

    }

    return kdReadSystemMemory(
        varAddress,
        ServiceTable,
        sizeof(KSERVICE_TABLE_DESCRIPTOR));
}

/*
* ObQueryNameStringFromAddress
*
* Purpose:
*
* Reads object name from kernel memory if present.
*
* If HeapHandle is g_WinObj use supHeapFree to release allocated memory.
*
*/
_Success_(return)
BOOL ObQueryNameStringFromAddress(
    _In_ HANDLE HeapHandle,
    _In_ ULONG_PTR NameInfoAddress,
    _Out_ PUNICODE_STRING NameString
)
{
    SIZE_T allocLength;
    LPWSTR objectName = NULL;
    OBJECT_HEADER_NAME_INFO nameInfo;

    RtlSecureZeroMemory(&nameInfo, sizeof(OBJECT_HEADER_NAME_INFO));

    if (kdReadSystemMemory(NameInfoAddress,
        &nameInfo,
        sizeof(OBJECT_HEADER_NAME_INFO)))
    {
        if (nameInfo.Name.Length &&
            supUnicodeStringValid(&nameInfo.Name)) {

            allocLength = nameInfo.Name.Length;

            objectName = (LPWSTR)supHeapAllocEx(HeapHandle,
                allocLength + sizeof(UNICODE_NULL));

            if (objectName != NULL) {

                NameInfoAddress = (ULONG_PTR)nameInfo.Name.Buffer;

                if (kdReadSystemMemory(NameInfoAddress,
                    objectName,
                    nameInfo.Name.Length))
                {
                    NameString->Buffer = objectName;
                    NameString->Length = nameInfo.Name.Length;
                    NameString->MaximumLength = nameInfo.Name.MaximumLength;

                    return TRUE;
                }
                else {

                    supHeapFreeEx(HeapHandle,
                        objectName);

                    objectName = NULL;
                }

            }
        }

    }

    return FALSE;
}

/*
* ObpCopyObjectBasicInfo
*
* Purpose:
*
*   Read object related data from kernel to local user copy.
*   Returned object must be freed wtih supHeapFree when no longer needed.
*
* Parameters:
*
*   ObjectAddress - kernel address of object specified type (e.g. DRIVER_OBJECT).
*   ObjectHeaderAddress - OBJECT_HEADER structure kernel address.
*   ObjectHeaderAddressValid - if set then ObjectHeaderAddress in already converted form.
*   DumpedObjectHeader - pointer to OBJECT_HEADER structure previously dumped.
*
* Return Value:
*
*   Pointer to OBJINFO structure allocated from WinObjEx heap and filled with kernel data.
*
*/
_Ret_maybenull_
POBEX_OBJECT_INFORMATION ObpCopyObjectBasicInfo(
    _In_ ULONG_PTR ObjectAddress,
    _In_ ULONG_PTR ObjectHeaderAddress,
    _In_ BOOL ObjectHeaderAddressValid,
    _In_opt_ POBJECT_HEADER DumpedObjectHeader
)
{
    ULONG_PTR HeaderAddress = 0, InfoHeaderAddress = 0;
    OBJECT_HEADER ObjectHeader, * pObjectHeader;
    POBEX_OBJECT_INFORMATION lpData = NULL;

    //
    // Convert object address to object header address.
    //
    HeaderAddress = ObjectHeaderAddressValid ? ObjectHeaderAddress : (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(ObjectAddress);

    //
    // ObjectHeader already dumped, copy it.
    //
    if (DumpedObjectHeader) {
        pObjectHeader = DumpedObjectHeader;
    }
    else {
        //
        // ObjectHeader wasn't dumped, validate it address and do dump.
        //
        if (HeaderAddress < g_kdctx.SystemRangeStart)
            return NULL;

        //
        // Read OBJECT_HEADER.
        //
        RtlSecureZeroMemory(&ObjectHeader, sizeof(OBJECT_HEADER));

        if (!kdReadSystemMemory(HeaderAddress,
            &ObjectHeader,
            sizeof(OBJECT_HEADER)))
        {
            kdReportReadErrorSimple(__FUNCTIONW__, HeaderAddress, sizeof(OBJECT_HEADER));
            return NULL;
        }

        pObjectHeader = &ObjectHeader;
    }

    //
    // Allocate OBJINFO structure, exit on fail.
    //
    lpData = (POBEX_OBJECT_INFORMATION)supHeapAlloc(sizeof(OBEX_OBJECT_INFORMATION));
    if (lpData == NULL)
        return NULL;

    lpData->ObjectAddress = ObjectAddress;
    lpData->HeaderAddress = HeaderAddress;

    //
    // Copy object header.
    //
    RtlCopyMemory(&lpData->ObjectHeader, pObjectHeader, sizeof(OBJECT_HEADER));

    //
    // Query and copy quota info if exist.
    //
    InfoHeaderAddress = 0;

    if (ObHeaderToNameInfoAddress(pObjectHeader->InfoMask,
        HeaderAddress,
        &InfoHeaderAddress,
        HeaderQuotaInfoFlag))
    {
        kdReadSystemMemory(InfoHeaderAddress,
            &lpData->ObjectQuotaHeader,
            sizeof(OBJECT_HEADER_QUOTA_INFO));
    }

    return lpData;
}

/*
* ObQueryObjectByAddress
*
* Purpose:
*
* Look for object at specified address.
* Returned object memory must be released with supHeapFree when object is no longer needed.
*
*/
_Ret_maybenull_
POBEX_OBJECT_INFORMATION ObQueryObjectByAddress(
    _In_ ULONG_PTR ObjectAddress
)
{
    ULONG_PTR ObjectHeaderAddress;
    OBJECT_HEADER ObjectHeader;

    if (ObjectAddress < g_kdctx.SystemRangeStart)
        return NULL;

    if (!kdConnectDriver())
        return NULL;

    //
    // Read object header, fail is critical.
    //
    RtlSecureZeroMemory(&ObjectHeader, sizeof(OBJECT_HEADER));
    ObjectHeaderAddress = (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(ObjectAddress);

    if (!kdReadSystemMemory(ObjectHeaderAddress,
        &ObjectHeader,
        sizeof(OBJECT_HEADER)))
    {
        kdReportReadErrorSimple(__FUNCTIONW__, ObjectHeaderAddress, sizeof(OBJECT_HEADER));
        return NULL;
    }

    return ObpCopyObjectBasicInfo(ObjectAddress,
        ObjectHeaderAddress,
        TRUE,
        &ObjectHeader);
}

/*
* ObpFindObjectInDirectory
*
* Purpose:
*
* Walks given directory and looks for specified object inside
* Returned object must be freed wtih supHeapFree when no longer needed.
*
* Note:
*
* OBJECT_DIRECTORY definition changed in Windows 10, however this doesn't require
* this routine change as we rely here only on HashBuckets which is on same offset.
*
*/
_Ret_maybenull_
POBEX_OBJECT_INFORMATION ObpFindObjectInDirectory(
    _In_ PUNICODE_STRING ObjectName,
    _In_ ULONG_PTR DirectoryAddress
)
{
    BOOL bFound = FALSE;
    ULONG i, iterationLimit = OB_MAX_DIRECTORY_ENUM_ITER;
    OBJECT_HEADER ObjectHeader;
    OBJECT_DIRECTORY DirectoryObject;
    OBJECT_DIRECTORY_ENTRY DirectoryEntry;

    ULONG_PTR ObjectHeaderAddress, HeadItem, LookupItem, InfoHeaderAddress;

    UNICODE_STRING NameString;

    RtlSecureZeroMemory(&DirectoryObject, sizeof(OBJECT_DIRECTORY));

    //
    // Read object directory at address.
    //
    if (!kdReadSystemMemory(DirectoryAddress,
        &DirectoryObject,
        sizeof(OBJECT_DIRECTORY)))
    {
        kdReportReadErrorSimple(__FUNCTIONW__, DirectoryAddress, sizeof(OBJECT_DIRECTORY));
        return NULL;
    }

    //
    // Check if root special case.
    //
    if (supIsRootDirectory(ObjectName)) {

        return ObpCopyObjectBasicInfo(DirectoryAddress,
            0,
            FALSE,
            NULL);

    }

    //
    // Not a root directory, scan given object directory.
    //
    for (i = 0; i < NUMBER_HASH_BUCKETS; i++) {

        HeadItem = (ULONG_PTR)DirectoryObject.HashBuckets[i];
        if (HeadItem != 0) {

            LookupItem = HeadItem;

            //
            // Iterate items in hash bucket with iteration guard.
            //
            while (LookupItem != 0 && iterationLimit--) {

                //
                // Read object directory entry, exit on fail.
                //
                RtlSecureZeroMemory(&DirectoryEntry, sizeof(OBJECT_DIRECTORY_ENTRY));

                if (!kdReadSystemMemory(LookupItem,
                    &DirectoryEntry,
                    sizeof(OBJECT_DIRECTORY_ENTRY)))
                {
                    kdReportReadErrorSimple(__FUNCTIONW__, LookupItem, sizeof(OBJECT_DIRECTORY_ENTRY));
                    break;
                }

                //
                // Read object header, skip entry on fail.
                //
                RtlSecureZeroMemory(&ObjectHeader, sizeof(OBJECT_HEADER));
                ObjectHeaderAddress = (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(DirectoryEntry.Object);

                if (!kdReadSystemMemory(ObjectHeaderAddress,
                    &ObjectHeader,
                    sizeof(OBJECT_HEADER)))
                {
                    kdReportReadErrorSimple(__FUNCTIONW__, ObjectHeaderAddress, sizeof(OBJECT_HEADER));
                    goto NextItem;
                }

                //
                // Check if object has name, skip entry on fail.
                //
                InfoHeaderAddress = 0;

                if (!ObHeaderToNameInfoAddress(ObjectHeader.InfoMask,
                    ObjectHeaderAddress,
                    &InfoHeaderAddress,
                    HeaderNameInfoFlag))
                {
                    goto NextItem;
                }

                //
                // If object has name, query it.
                //
                if (ObQueryNameStringFromAddress(g_obexHeap,
                    InfoHeaderAddress,
                    &NameString))
                {
                    //
                    // Compare object name with what we look for.
                    //
                    bFound = RtlEqualUnicodeString(ObjectName, &NameString, TRUE);
                    supHeapFreeEx(g_obexHeap, NameString.Buffer);

                    if (bFound) {

                        return ObpCopyObjectBasicInfo(
                            (ULONG_PTR)DirectoryEntry.Object,
                            ObjectHeaderAddress,
                            TRUE,
                            &ObjectHeader);

                    }

                }

            NextItem:
                LookupItem = (ULONG_PTR)DirectoryEntry.ChainLink;

            } //while


        } // HeadItem != 0
    } // for

    return NULL;
}

/*
* ObGetObjectAddressForDirectory
*
* Purpose:
*
* Obtain directory object kernel address by:
* 1) opening directory by name
* 2) quering resulted handle in NtQuerySystemInformation(SystemExtendedHandleInformation) handle dump
*
*/
_Success_(return)
BOOL ObGetObjectAddressForDirectory(
    _In_ PUNICODE_STRING DirectoryName,
    _Out_ PULONG_PTR lpRootAddress,
    _Out_opt_ PUSHORT lpTypeIndex
)
{
    BOOL bFound = FALSE;
    HANDLE hDirectory = NULL;

    if (!NT_SUCCESS(supOpenDirectoryEx(&hDirectory, NULL, DirectoryName, DIRECTORY_QUERY)))
        return FALSE;

    bFound = supQueryObjectFromHandle(hDirectory,
        lpRootAddress,
        lpTypeIndex);

    NtClose(hDirectory);

    return bFound;
}

/*
* ObQueryObjectInDirectory
*
* Purpose:
*
* Look for object inside specified directory.
* Returned object memory must be released with supHeapFree when object is no longer needed.
*
*/
_Ret_maybenull_
POBEX_OBJECT_INFORMATION ObQueryObjectInDirectory(
    _In_ PUNICODE_STRING ObjectName,
    _In_ PUNICODE_STRING DirectoryName
)
{
    ULONG_PTR directoryAddress = 0;

    if (!kdConnectDriver())
        return NULL;

    if (!ObGetObjectAddressForDirectory(DirectoryName,
        &directoryAddress,
        NULL))
    {
        return NULL;
    }

    return ObpFindObjectInDirectory(ObjectName, directoryAddress);
}

/*
* ObGetProcessId
*
* Purpose:
*
* Read UniqueProcessId field from object of Process type.
*
*/
_Success_(return)
BOOL ObGetProcessId(
    _In_ ULONG_PTR ProcessObject,
    _Out_ PHANDLE UniqueProcessId
)
{
    ULONG_PTR kernelAddress;
    HANDLE processId = 0;

    *UniqueProcessId = NULL;

    if (g_kdctx.Data->PsUniqueProcessId.Valid == FALSE)
        return FALSE;

    kernelAddress = ProcessObject + g_kdctx.Data->PsUniqueProcessId.OffsetValue;

    if (!kdReadSystemMemory(kernelAddress, &processId, sizeof(processId)))
        return FALSE;

    *UniqueProcessId = processId;

    return TRUE;
}

/*
* ObGetProcessImageFileName
*
* Purpose:
*
* Read ImageFileName field from object of Process type.
*
*/
_Success_(return)
BOOL ObGetProcessImageFileName(
    _In_ ULONG_PTR ProcessObject,
    _Inout_ PUNICODE_STRING ImageFileName
)
{
    ULONG_PTR kernelAddress;
    CHAR szImageFileName[16];

    if (g_kdctx.Data->PsProcessImageName.Valid == FALSE)
        return FALSE;

    kernelAddress = ProcessObject + g_kdctx.Data->PsProcessImageName.OffsetValue;

    szImageFileName[0] = 0;

    if (!kdReadSystemMemory(kernelAddress, &szImageFileName, sizeof(szImageFileName)))
        return FALSE;

    return NT_SUCCESS(ntsupConvertToUnicode(szImageFileName, ImageFileName));
}

/*
* ObpEnumeratePrivateNamespaceTable
*
* Purpose:
*
* Enumerate Object Manager private namespace objects.
*
* Note:
*
* OBJECT_DIRECTORY definition changed in Windows 10, however this doesn't require
* this routine change as we rely here only on HashBuckets which is on same offset.
*
*/
BOOL ObpEnumeratePrivateNamespaceTable(
    _In_ ULONG_PTR TableAddress,
    _In_ PENUMERATE_PRIVATE_NAMESPACE_CALLBACK Callback,
    _In_opt_ PVOID Context
)
{
    BOOL          bStopEnumeration = FALSE;
    ULONG         i, j = 0, dirIterLimit, chainIterLimit;
    ULONG_PTR     ObjectHeaderAddress, HeadItem, LookupItem, InfoHeaderAddress;
    HANDLE        ListHeap = (HANDLE)Context;
    PLIST_ENTRY   Next, Head;
    LIST_ENTRY    ListEntry;
    POBJREF       ObjectEntry;

    OBJECT_HEADER                ObjectHeader;
    OBJECT_DIRECTORY             DirObject;
    OBJECT_DIRECTORY_ENTRY       Entry;
    OBJECT_NAMESPACE_LOOKUPTABLE LookupTable;
    OBJECT_NAMESPACE_ENTRY       LookupEntry;

    if (ListHeap == NULL)
        ListHeap = g_obexHeap;

    if (ListHeap == NULL)
        return FALSE;

    //
    // Dump namespace lookup table.
    //
    RtlSecureZeroMemory(&LookupTable, sizeof(OBJECT_NAMESPACE_LOOKUPTABLE));

    if (!kdReadSystemMemory(TableAddress,
        &LookupTable,
        sizeof(OBJECT_NAMESPACE_LOOKUPTABLE)))
    {
        return FALSE;
    }

    for (i = 0; i < NUMBER_HASH_BUCKETS; i++) {

        dirIterLimit = OB_MAX_DIRECTORY_ENUM_ITER;
        ListEntry = LookupTable.HashBuckets[i];
        Head = (PLIST_ENTRY)(TableAddress + (i * sizeof(LIST_ENTRY)));
        Next = ListEntry.Flink;

        while (Next != Head && dirIterLimit--) {

            RtlSecureZeroMemory(&LookupEntry, sizeof(OBJECT_NAMESPACE_ENTRY));

            if (!kdReadSystemMemory((ULONG_PTR)Next,
                &LookupEntry,
                sizeof(OBJECT_NAMESPACE_ENTRY)))
            {
                break;
            }

            ListEntry = LookupEntry.ListEntry;

            RtlSecureZeroMemory(&DirObject, sizeof(OBJECT_DIRECTORY));

            if (!kdReadSystemMemory((ULONG_PTR)LookupEntry.NamespaceRootDirectory,
                &DirObject,
                sizeof(OBJECT_DIRECTORY)))
            {
                break;
            }

            for (j = 0; j < NUMBER_HASH_BUCKETS; j++) {

                chainIterLimit = OB_MAX_DIRECTORY_ENUM_ITER;

                HeadItem = (ULONG_PTR)DirObject.HashBuckets[j];
                if (HeadItem != 0) {

                    LookupItem = HeadItem;

                    while (LookupItem != 0 && chainIterLimit--) {

                        RtlSecureZeroMemory(&Entry, sizeof(OBJECT_DIRECTORY_ENTRY));

                        if (!kdReadSystemMemory(LookupItem,
                            &Entry,
                            sizeof(OBJECT_DIRECTORY_ENTRY)))
                        {
                            LookupItem = 0;
                            continue;
                        }

                        RtlSecureZeroMemory(&ObjectHeader, sizeof(OBJECT_HEADER));
                        ObjectHeaderAddress = (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(Entry.Object);

                        if (kdReadSystemMemory(ObjectHeaderAddress,
                            &ObjectHeader,
                            sizeof(OBJECT_HEADER)))
                        {

                            //
                            // Allocate object entry
                            //
                            ObjectEntry = (POBJREF)supHeapAllocEx(ListHeap,
                                sizeof(OBJREF));

                            if (ObjectEntry) {

                                //
                                // Save object address, header and type index.
                                //
                                ObjectEntry->ObjectAddress = (ULONG_PTR)Entry.Object;
                                ObjectEntry->HeaderAddress = ObjectHeaderAddress;

                                //
                                // Save index as is (decoded if needed later).
                                //
                                ObjectEntry->TypeIndex = ObjectHeader.TypeIndex;

                                //
                                // Save object namespace/lookup entry address.
                                //
                                ObjectEntry->PrivateNamespace.NamespaceDirectoryAddress =
                                    (ULONG_PTR)LookupEntry.NamespaceRootDirectory;

                                ObjectEntry->PrivateNamespace.NamespaceLookupEntry =
                                    (ULONG_PTR)Next;

                                ObjectEntry->PrivateNamespace.SizeOfBoundaryInformation =
                                    LookupEntry.SizeOfBoundaryInformation;

                                //
                                // Query object name.
                                //
                                InfoHeaderAddress = 0;

                                if (ObHeaderToNameInfoAddress(ObjectHeader.InfoMask,
                                    ObjectHeaderAddress,
                                    &InfoHeaderAddress,
                                    HeaderNameInfoFlag))
                                {
                                    //
                                    // Copy object name if exist.
                                    //
                                    ObQueryNameStringFromAddress(ListHeap, InfoHeaderAddress, &ObjectEntry->Name);

                                }

                                bStopEnumeration = Callback(ObjectEntry, Context);
                                if (bStopEnumeration)
                                    return TRUE;

                            } //if (ObjectEntry)
                        }
                        LookupItem = (ULONG_PTR)Entry.ChainLink;

                    } //while
                }
            }

            Next = ListEntry.Flink;
        }
    }

    return TRUE;
}

/*
* ObEnumeratePrivateNamespaceTable
*
* Purpose:
*
* Enumerate Object Manager private namespace objects.
*
*/
BOOL ObEnumeratePrivateNamespaceTable(
    _In_ PENUMERATE_PRIVATE_NAMESPACE_CALLBACK Callback,
    _In_opt_ PVOID Context
)
{
    if (!kdConnectDriver())
        return FALSE;

    if (g_kdctx.Data->PrivateNamespaceLookupTable == NULL)
        g_kdctx.Data->PrivateNamespaceLookupTable = ObFindPrivateNamespaceLookupTable(&g_kdctx);

    if (g_kdctx.Data->PrivateNamespaceLookupTable == NULL)
        return FALSE;

    return ObpEnumeratePrivateNamespaceTable(
        (ULONG_PTR)g_kdctx.Data->PrivateNamespaceLookupTable,
        Callback,
        Context);
}

typedef struct _OB_NAME_ELEMENT {
    LIST_ENTRY ListEntry;
    UNICODE_STRING Name;
} OB_NAME_ELEMENT, * POB_NAME_ELEMENT;

BOOL ObpAddNameElementEntry(
    _In_ PLIST_ENTRY ListHead,
    _In_ PUNICODE_STRING ElementName
)
{
    POB_NAME_ELEMENT pObElement;

    pObElement = (POB_NAME_ELEMENT)supHeapAlloc(sizeof(OB_NAME_ELEMENT));
    if (pObElement == NULL)
        return FALSE;

    pObElement->Name = *ElementName;

    InsertHeadList(ListHead, &pObElement->ListEntry);

    return TRUE;
}

BOOL ObpDumpNameElementSpecial(
    _In_ PLIST_ENTRY ListHead,
    _In_ LPWSTR SpecialElement,
    _In_ ULONG Size
)
{
    UNICODE_STRING element;

    element.Buffer = (PWSTR)supHeapAlloc(Size + sizeof(UNICODE_NULL));

    if (element.Buffer == NULL) {
        return FALSE;
    }

    _strcpy(element.Buffer, SpecialElement);
    element.Length = (USHORT)(Size - sizeof(UNICODE_NULL));
    element.MaximumLength = (USHORT)Size;

    if (!ObpAddNameElementEntry(ListHead, &element)) {
        supHeapFree(element.Buffer);
        return FALSE;
    }

    return TRUE;
}

BOOL ObpDumpNameElement(
    _In_ PLIST_ENTRY ListHead,
    _In_ POBJECT_HEADER_NAME_INFO NameInformation,
    _Out_ PSIZE_T ElementLength
)
{
    USHORT nameLength;
    LPWSTR stringBuffer;
    UNICODE_STRING element;

    *ElementLength = 0;

    nameLength = NameInformation->Name.Length;
    if (nameLength == 0)
        return FALSE;

    stringBuffer = (LPWSTR)supHeapAlloc(nameLength + sizeof(UNICODE_NULL));
    if (stringBuffer == NULL) {
        return FALSE;
    }

    if (!kdReadSystemMemory((ULONG_PTR)NameInformation->Name.Buffer,
        stringBuffer,
        nameLength))
    {
        supHeapFree(stringBuffer);
        return FALSE;
    }

    element.Buffer = stringBuffer;
    element.Length = nameLength;
    element.MaximumLength = nameLength + sizeof(UNICODE_NULL);

    if (!ObpAddNameElementEntry(ListHead, &element)) {
        supHeapFree(stringBuffer);
        return FALSE;
    }

    *ElementLength = nameLength;

    return TRUE;
}

SIZE_T ObpDumpObjectName(
    _In_ PLIST_ENTRY ListHead,
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG_PTR NextObject
)
{
    ULONG_PTR lookupObject = ObjectAddress;
    ULONG_PTR objectHeaderAddress;
    ULONG_PTR headerInfoAddress;
    OBJECT_HEADER objectHeader;
    OBJECT_HEADER_NAME_INFO nameInfo;
    SIZE_T pathLength = 0;

    *NextObject = 0;

    //
    // Process object first.
    //
    objectHeaderAddress = (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(lookupObject);
    RtlSecureZeroMemory(&objectHeader, sizeof(OBJECT_HEADER));
    if (!kdReadSystemMemory(objectHeaderAddress,
        &objectHeader,
        sizeof(OBJECT_HEADER)))
    {
        //
        // Nothing to process, object header is not available.
        //
        return 0;
    }

    //
    // Query OBJECT_HEADER_NAME_INFO address
    //
    headerInfoAddress = 0;
    if (!ObHeaderToNameInfoAddress(objectHeader.InfoMask,
        objectHeaderAddress,
        &headerInfoAddress,
        HeaderNameInfoFlag))
    {
        //
        // Nothing to process, object is unnamed.
        //
        return 0;
    }

    //
    // Dump OBJECT_HEADER_NAME_INFO
    //
    RtlSecureZeroMemory(&nameInfo, sizeof(nameInfo));

    if (!kdReadSystemMemory(headerInfoAddress,
        &nameInfo,
        sizeof(nameInfo)))
    {
        ObpDumpNameElementSpecial(ListHead, OBP_ERROR_NAME_LITERAL, OBP_ERROR_NAME_LITERAL_SIZE);
        return OBP_ERROR_NAME_LITERAL_SIZE + OBJ_NAME_PATH_SEPARATOR_SIZE;
    }

    *NextObject = (ULONG_PTR)nameInfo.Directory;

    if (ObpDumpNameElement(ListHead, &nameInfo, &pathLength))
        return pathLength + OBJ_NAME_PATH_SEPARATOR_SIZE;

    return 0;
}

/*
* ObQueryFullNamespacePath
*
* Purpose:
*
* This routine if possible builds full object namespace path for given object.
*
*/
_Success_(return)
BOOL ObQueryFullNamespacePath(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PUNICODE_STRING Path
)
{
    BOOL bResult = FALSE;
    ULONG_PTR LookupObject = ObjectAddress, NextObject;
    LIST_ENTRY ListHead;
    PLIST_ENTRY Next;
    POB_NAME_ELEMENT pathElement;
    PWSTR stringBuffer = NULL, string;
    SIZE_T memIO, length;

    UNICODE_STRING resultPath;

    if (LookupObject == g_kdctx.DirectoryRootObject) {

        return supDuplicateUnicodeString(g_obexHeap,
            Path,
            ObGetPredefinedUnicodeString(OBP_ROOT));

    }

    InitializeListHead(&ListHead);
    memIO = 0;

    while ((LookupObject != g_kdctx.DirectoryRootObject) && (LookupObject != 0)) {

        NextObject = 0;
        memIO += ObpDumpObjectName(&ListHead, LookupObject, &NextObject);
        if (memIO > UNICODE_STRING_MAX_BYTES)
            break;

        LookupObject = NextObject;
    }

    //
    // Build path.
    //
    if (!IsListEmpty(&ListHead)) {

        stringBuffer = (PWSTR)supHeapAlloc(memIO + sizeof(UNICODE_NULL));
        if (stringBuffer) {

            resultPath.MaximumLength = (USHORT)memIO + sizeof(UNICODE_NULL);
            resultPath.Buffer = stringBuffer;

            string = stringBuffer;
            length = 0;

            Next = ListHead.Flink;
            while ((Next != NULL) && (Next != &ListHead)) {

                pathElement = CONTAINING_RECORD(Next, OB_NAME_ELEMENT, ListEntry);

                *string++ = OBJ_NAME_PATH_SEPARATOR;
                length += OBJ_NAME_PATH_SEPARATOR_SIZE;

                RtlCopyMemory(string, pathElement->Name.Buffer, pathElement->Name.Length);
                string = (PWSTR)RtlOffsetToPointer(string, pathElement->Name.Length);
                length += pathElement->Name.Length;

                supFreeUnicodeString(g_obexHeap, &pathElement->Name);

                Next = Next->Flink;
                supHeapFree(pathElement);

            }

            resultPath.Length = (USHORT)length;
            *Path = resultPath;
            bResult = TRUE;
        }

    }

    return bResult;
}

/*
* ObQueryObjectDirectory
*
* Purpose:
*
*   Helper function to query directory objects with proper buffer allocation.
*   Returns allocated buffer with directory information or NULL on failure.
*
* Parameters:
*   DirectoryHandle - Handle to the directory object.
*   Context         - Pointer to the context variable (input/output).
*   IsWine          - TRUE if running under Wine, FALSE otherwise.
*   ReturnLength    - Pointer to variable to receive the buffer size used (optional).
*
* Return Value:
*   Pointer to allocated directory information buffer, or NULL on failure.
*/
_Ret_maybenull_
POBJECT_DIRECTORY_INFORMATION ObQueryObjectDirectory(
    _In_ HANDLE DirectoryHandle,
    _Inout_ PULONG Context,
    _In_ BOOL IsWine,
    _Out_ PULONG ReturnLength
)
{
    NTSTATUS status;
    ULONG bufferSize;
    POBJECT_DIRECTORY_INFORMATION buffer = NULL;

    // Wine has a different implementation, use fixed buffer size
    if (IsWine) {
        bufferSize = WINE_DIRECTORY_QUERY_BUFFER_SIZE;
    }
    else {
        // Request required buffer length for non-Wine systems
        bufferSize = 0;
        status = NtQueryDirectoryObject(DirectoryHandle, NULL, 0, TRUE, FALSE, Context, &bufferSize);
        if (status != STATUS_BUFFER_TOO_SMALL) {
            if (ReturnLength)
                *ReturnLength = bufferSize;
            return NULL;
        }
    }

    buffer = (POBJECT_DIRECTORY_INFORMATION)supHeapAlloc((SIZE_T)bufferSize);
    if (buffer) {
        status = NtQueryDirectoryObject(DirectoryHandle, buffer, bufferSize, TRUE, FALSE, Context, &bufferSize);
        if (!NT_SUCCESS(status)) {
            supHeapFree(buffer);
            buffer = NULL;
        }
    }

    if (ReturnLength)
        *ReturnLength = bufferSize;

    return buffer;
}

/*
* kdConnectDriver
*
* Purpose:
*
* Acquire handle of helper driver device if possible.
*
*/
BOOLEAN kdConnectDriver(
    VOID)
{
    WDRV_PROVIDER* provider;

    if (kdIoDriverLoaded()) return TRUE;

    provider = g_kdctx.DriverContext.Provider;

    if (provider == NULL) return FALSE;

    return NT_SUCCESS(provider->Callbacks.OpenDriver(&g_kdctx.DriverContext));
}

/*
* kdIoDriverLoaded
*
* Purpose:
*
* Return state of helper driver.
*
* N.B.
*
*   If current token is not elevated admin token function return FALSE.
*   If device handle is already present function return TRUE.
*
*/
BOOLEAN kdIoDriverLoaded(
    VOID)
{
    if (g_kdctx.IsFullAdmin == FALSE)
        return FALSE;

    if (g_kdctx.DriverContext.DeviceHandle != NULL)
        return TRUE;

    return FALSE;
}

/*
* kdGetAlpcPortTypeIndex
*
* Purpose:
*
* Return type index of ALPC Port object.
*
*/
USHORT kdGetAlpcPortTypeIndex()
{
    USHORT typeIndex = MAXWORD;

    if (g_kdctx.Data->AlpcPortTypeIndex.Valid == FALSE)
        supQueryAlpcPortObjectTypeIndex(&g_kdctx.Data->AlpcPortTypeIndex);

    if (g_kdctx.Data->AlpcPortTypeIndex.Valid)
        typeIndex = g_kdctx.Data->AlpcPortTypeIndex.TypeIndex;

    return typeIndex;
}

/*
* kdQueryIopInvalidDeviceRequest
*
* Purpose:
*
* Find IopInvalidDeviceRequest.
*
* 1. If symbols available - lookup value from them;
*
* 2. If they are not or there is an error, assume Windows assigned value to our helper driver IRP_MJ_CREATE_MAILSLOT.
*
* wo/kldbgdrv/winio only defined:
*    IRP_MJ_CREATE
*    IRP_MJ_CLOSE
*    IRP_MJ_DEVICE_CONTROL
*
* rkhdrv 5+ versions does not define own IRP_MJ_CREATE_MAILSLOT
*
*/
PVOID kdQueryIopInvalidDeviceRequest(
    VOID
)
{
    PVOID           pHandler = NULL;
    ULONG_PTR       drvObjectAddress;
    DRIVER_OBJECT   drvObject;
    PWDRV_PROVIDER  drvProvider;

    POBEX_OBJECT_INFORMATION selfDriverObject;

    UNICODE_STRING usDirectory, usName;

    //
    // Lookup using symbols.
    //
    if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {

        kdGetAddressFromSymbol(
            &g_kdctx,
            KVAR_IopInvalidDeviceRequest,
            (ULONG_PTR*)&pHandler);

    }

    //
    // Lookup from our helper driver object.
    //
    if (pHandler == NULL) {

        drvProvider = g_kdctx.DriverContext.Provider;
        if (drvProvider) {

            RtlInitUnicodeString(&usName, drvProvider->DriverName);
            RtlInitUnicodeString(&usDirectory, L"\\Driver");
            selfDriverObject = ObQueryObjectInDirectory(&usName, &usDirectory);
            if (selfDriverObject) {

                drvObjectAddress = selfDriverObject->ObjectAddress;

                RtlSecureZeroMemory(&drvObject, sizeof(drvObject));

                if (kdReadSystemMemory(drvObjectAddress,
                    &drvObject,
                    sizeof(drvObject)))
                {
                    pHandler = drvObject.MajorFunction[IRP_MJ_CREATE_MAILSLOT];

                    //
                    // IopInvalidDeviceRequest is a routine inside ntoskrnl.
                    //
                    if (!kdAddressInNtOsImage(pHandler)) {
                        pHandler = NULL;
                    }
                }
                supHeapFree(selfDriverObject);
            }
        }
    }
    return pHandler;
}

/*
* kdReportErrorByFunction
*
* Purpose:
*
* Log details about failed function call.
*
*/
VOID kdReportErrorByFunction(
    _In_ LPCWSTR FunctionName,
    _In_ LPCWSTR ErrorMessage
)
{
    WCHAR szBuffer[WOBJ_MAX_MESSAGE];

    RtlStringCchPrintfSecure(szBuffer,
        ARRAYSIZE(szBuffer),
        TEXT("%ws, %ws"),
        FunctionName, ErrorMessage);

    logAdd(EntryTypeError,
        szBuffer);
}

/*
* kdReportReadErrorSimple
*
* Purpose:
*
* Log details about failed driver call without additional info.
*
*/
VOID kdReportReadErrorSimple(
    _In_ LPCWSTR FunctionName,
    _In_ ULONG_PTR KernelAddress,
    _In_ ULONG InputBufferLength
)
{
    WCHAR szBuffer[512];

    RtlStringCchPrintfSecure(szBuffer,
        ARRAYSIZE(szBuffer),
        TEXT("%ws read at 0x%llX, InputBufferLength 0x%lX"),
        FunctionName,
        KernelAddress,
        InputBufferLength);

    logAdd(EntryTypeError,
        szBuffer);
}

/*
* kdReportReadError
*
* Purpose:
*
* Log details about failed driver call.
*
*/
VOID kdReportReadError(
    _In_ LPCWSTR FunctionName,
    _In_ ULONG_PTR KernelAddress,
    _In_ ULONG InputBufferLength,
    _In_ NTSTATUS Status,
    _In_ PIO_STATUS_BLOCK Iosb
)
{
    WCHAR szBuffer[512];

    RtlStringCchPrintfSecure(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        TEXT("%ws 0x%lX, read at 0x%llX, Iosb(0x%lX, 0x%lX), InputBufferLength 0x%lX"),
        FunctionName,
        Status,
        KernelAddress,
        Iosb->Status,
        Iosb->Information,
        InputBufferLength);

    logAdd(EntryTypeError,
        szBuffer);
}

/*
* kdReadSystemMemory2
*
* Purpose:
*
* Read system memory through driver callback.
*
*/
BOOL kdReadSystemMemory2(
    _In_opt_ LPCWSTR CallerFunction,
    _In_ ULONG_PTR Address,
    _Inout_updates_bytes_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead
)
{
    BOOL bResult = FALSE, fullRead = FALSE;
    NTSTATUS ntStatus;
    ULONG numberOfBytesRead = 0;
    LPCWSTR lpSrcFunction;
    IO_STATUS_BLOCK iostPartial;

    PWDRV_CONTEXT driverContext = &g_kdctx.DriverContext;

    if (NumberOfBytesRead)
        *NumberOfBytesRead = 0;

    if (driverContext->Provider == NULL)
        return FALSE;

    if (driverContext->Provider->Callbacks.ReadSystemMemory == NULL)
        return FALSE;

    bResult = driverContext->Provider->Callbacks.ReadSystemMemory(driverContext,
        Address,
        Buffer,
        BufferSize,
        &numberOfBytesRead);

    if (NumberOfBytesRead)
        *NumberOfBytesRead = numberOfBytesRead;

    lpSrcFunction = (CallerFunction ? CallerFunction : __FUNCTIONW__);
    ntStatus = driverContext->LastNtStatus;

    fullRead = (bResult && numberOfBytesRead == BufferSize);

    if (!bResult) {
        kdReportReadError(lpSrcFunction, Address, BufferSize, ntStatus, &driverContext->IoStatusBlock);
        return FALSE;
    }

    if (!fullRead) {
        iostPartial.Status = STATUS_PARTIAL_COPY;
        iostPartial.Information = numberOfBytesRead;
        kdReportReadError(lpSrcFunction, Address, BufferSize, ntStatus, &iostPartial);
        return FALSE;
    }

    return bResult;
}

/*
* kdLoadNtKernelImage
*
* Purpose:
*
* Query ntoskrnl name, load it as image and prepare symbols.
*
*/
BOOL kdLoadNtKernelImage(
    _In_ PKLDBGCONTEXT Context
)
{
    PUCHAR pModuleName;
    PRTL_PROCESS_MODULES pModulesList = NULL;

    WCHAR szFileName[(4 + MAX_PATH) * 2];

    pModulesList = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
    if (pModulesList) {

        _strcpy(szFileName, g_WinObj.szSystemDirectory);
        _strcat(szFileName, TEXT("\\"));

        Context->NtOsBase = pModulesList->Modules[0].ImageBase; //loaded kernel base
        Context->NtOsSize = pModulesList->Modules[0].ImageSize; //loaded kernel size

        pModuleName = &pModulesList->Modules[0].FullPathName[
            pModulesList->Modules[0].OffsetToFileName];

        MultiByteToWideChar(
            CP_ACP,
            0,
            (LPCSTR)pModuleName,
            -1,
            _strend(szFileName),
            MAX_PATH);

        supHeapFree(pModulesList);

        Context->NtOsImageMap = LoadLibraryEx(
            szFileName,
            NULL,
            DONT_RESOLVE_DLL_REFERENCES);

        if (Context->NtOsImageMap) {

            supLoadSymbolsForNtImage(
                (PSYMCONTEXT)g_kdctx.NtOsSymContext,
                szFileName,
                Context->NtOsImageMap,
                0);

        }

    }

    return (Context->NtOsImageMap != NULL);
}

/*
* kdQuerySystemInformation
*
* Purpose:
*
* Query required system information and offsets.
*
*/
BOOL kdQuerySystemInformation(
    _In_ PVOID lpParameter
)
{
    PKLDBGCONTEXT Context = (PKLDBGCONTEXT)lpParameter;

    if (Context->IsFullAdmin) {
        //
        // Query "\\" directory address and remember directory object type index.
        //
        ObGetObjectAddressForDirectory(ObGetPredefinedUnicodeString(OBP_ROOT),
            &Context->DirectoryRootObject,
            &Context->DirectoryTypeIndex);
    }

    //
    // Remember system range start value.
    //
    Context->SystemRangeStart = supQuerySystemRangeStart();
    if (Context->SystemRangeStart == 0) {
        if (g_NtBuildNumber < NT_WIN8_RTM) {
            Context->SystemRangeStart = MM_SYSTEM_RANGE_START_7;
        }
        else {
            Context->SystemRangeStart = MM_SYSTEM_RANGE_START_8;
        }
        logAdd(EntryTypeWarning, TEXT("SystemRangeStart fallback value applied"));
    }

    //
    // Query user mode accessible ranges.
    //
    if (!supQueryUserModeAccessibleRange(
        &Context->MinimumUserModeAddress,
        &Context->MaximumUserModeAddress))
    {
        Context->MinimumUserModeAddress = 0x10000;
        Context->MaximumUserModeAddress = 0x00007FFFFFFEFFFF;
    }

    supIsBootDriveVHD(&Context->IsOsDiskVhd);
    supGetFirmwareType(&Context->Data->FirmwareType);

    return kdLoadNtKernelImage(Context);
}

/*
* kdGetInstructionLength
*
* Purpose:
*
* Wrapper for hde64_disasm.
*
*/
UCHAR kdGetInstructionLength(
    _In_ PVOID ptrCode,
    _Out_ PULONG ptrFlags)
{
    hde64s  hs;

    __try {

        hde64_disasm((void*)ptrCode, &hs);
        if (hs.flags & F_ERROR) {
            *ptrFlags = hs.flags;
            return 0;
        }
        *ptrFlags = hs.flags;
        return hs.len;
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return 0;
    }
}

/*
* kdpQueryMmUnloadedDrivers
*
* Purpose:
*
* Locate MmUnloadedDrivers array address.
*
*/
BOOLEAN kdpQueryMmUnloadedDrivers(
    _In_ PKLDBGCONTEXT Context
)
{
    HMODULE   hNtOs;
    ULONG_PTR NtOsBase, lookupAddress = 0;

    PBYTE     ptrCode, sigPattern;
    PVOID     SectionBase;
    ULONG     SectionSize = 0;

    ULONG     sigSize;

    ULONG     Index = 0, instLength = 0, tempOffset;
    LONG      relativeValue = 0;
    hde64s    hs;

    PKLDBG_SYSTEM_ADDRESS kdpMmUnloadedDrivers = &Context->Data->MmUnloadedDrivers;

    if (kdpMmUnloadedDrivers->Valid)
        return TRUE;

    NtOsBase = (ULONG_PTR)g_kdctx.NtOsBase;
    hNtOs = (HMODULE)g_kdctx.NtOsImageMap;

    do {

        //
        // Symbols lookup.
        //
        if (kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext)) {

            kdGetAddressFromSymbol(
                &g_kdctx,
                KVAR_MmUnloadedDrivers,
                &lookupAddress);

        }

        //
        // Pattern search.
        //
        if (lookupAddress == 0) {

            //
            // Locate PAGE image section.
            //
            SectionBase = supLookupImageSectionByName(PAGE_SECTION,
                PAGE_SECTION_LENGTH,
                (PVOID)hNtOs,
                &SectionSize);

            if ((SectionBase == 0) || (SectionSize == 0))
                break;

            if (g_NtBuildNumber < NT_WIN10_20H1) {

                if (g_NtBuildNumber == NT_WIN10_THRESHOLD1)
                    MiRememberUnloadedDriverPattern[0] = FIX_WIN10_THRESHOULD_REG;

                sigPattern = MiRememberUnloadedDriverPattern;
                sigSize = sizeof(MiRememberUnloadedDriverPattern);

            }
            else {

                //
                // Use 19041+ specific patterns as an array allocation code has been changed.
                //
                switch (g_NtBuildNumber) {
                case NT_WIN11_24H2:
                case NT_WIN11_25H2:
                    sigPattern = MiRememberUnloadedDriverPattern24H2;
                    sigSize = sizeof(MiRememberUnloadedDriverPattern24H2);
                    break;
                default:
                    sigPattern = MiRememberUnloadedDriverPattern2;
                    sigSize = sizeof(MiRememberUnloadedDriverPattern2);
                    break;
                }

            }

            ptrCode = (PBYTE)supFindPattern((PBYTE)SectionBase,
                SectionSize,
                sigPattern,
                sigSize);

            if (ptrCode == NULL)
                break;

            if (RtlPointerToOffset(SectionBase, ptrCode) + sigSize + 32 > SectionSize)
                break;

            Index = sigSize;
            tempOffset = 0;

            do {

                hde64_disasm(RtlOffsetToPointer(ptrCode, Index), &hs);
                if (hs.flags & F_ERROR)
                    break;

                instLength = hs.len;

                //
                // Call ExAlloc/MiAlloc
                //
                if (instLength == 5 && ptrCode[Index] == 0xE8) {

                    //
                    // Fetch next instruction
                    //
                    tempOffset = Index + instLength;

                    hde64_disasm(RtlOffsetToPointer(ptrCode, tempOffset), &hs);
                    if (hs.flags & F_ERROR)
                        break;

                    //
                    // Must be MOV
                    //
                    if (hs.len == 7 && ptrCode[tempOffset] == 0x48) {
                        Index = tempOffset;
                        instLength = hs.len;
                        relativeValue = *(PLONG)(ptrCode + tempOffset + (hs.len - 4));
                        break;
                    }

                }

                Index += instLength;

            } while (Index < 32);

            if ((relativeValue == 0) || (instLength == 0))
                break;

            //
            // Resolve MmUnloadedDrivers.
            //
            lookupAddress = kdAdjustAddressToNtOsBase((ULONG_PTR)ptrCode, Index, instLength, relativeValue);
            if (!kdAddressInNtOsImage((PVOID)lookupAddress))
                break;

        }

        //
        // Read ptr value.
        //
        if (!kdReadSystemMemory(lookupAddress, &lookupAddress, sizeof(ULONG_PTR)))
            break;

        //
        // Store resolved array address in the private data context.
        //
        kdpMmUnloadedDrivers->Address = lookupAddress;
        kdpMmUnloadedDrivers->Valid = TRUE;

    } while (FALSE);

    return kdpMmUnloadedDrivers->Valid;
}

/*
* kdEnumerateMmUnloadedDrivers
*
* Purpose:
*
* Locate unloaded drivers array and walk through it entries.
*
*/
BOOL kdEnumerateMmUnloadedDrivers(
    _In_ PENUMERATE_UNLOADED_DRIVERS_CALLBACK Callback,
    _In_opt_ PVOID Context
)
{
    BOOL                bResult = FALSE, bStopEnumeration = FALSE;
    HMODULE             hNtOs;
    ULONG_PTR           NtOsBase, lookupAddress = 0;

    ULONG               bytesRead = 0;

    PUNLOADED_DRIVERS   pvDrivers = NULL;
    PWCHAR              pwStaticBuffer = NULL;
    WORD                wMax, wLength;

    ULONG               cbData;

    ULONG               Index = 0;

    PKLDBG_SYSTEM_ADDRESS kdpMmUnloadedDrivers = &g_kdctx.Data->MmUnloadedDrivers;

    NtOsBase = (ULONG_PTR)g_kdctx.NtOsBase;
    hNtOs = (HMODULE)g_kdctx.NtOsImageMap;

    if (!kdpQueryMmUnloadedDrivers(&g_kdctx))
        return FALSE;

    pwStaticBuffer = (PWCHAR)supHeapAlloc(UNICODE_STRING_MAX_BYTES + sizeof(UNICODE_NULL));
    if (pwStaticBuffer == NULL)
        return FALSE;

    lookupAddress = kdpMmUnloadedDrivers->Address;

    //
    // Dump array to user mode.
    //
    cbData = MI_UNLOADED_DRIVERS * sizeof(UNLOADED_DRIVERS);
    pvDrivers = (PUNLOADED_DRIVERS)supHeapAlloc(cbData);
    if (pvDrivers) {

        bResult = kdReadSystemMemory(lookupAddress, pvDrivers, cbData);

        if (bResult) {

            for (Index = 0; Index < MI_UNLOADED_DRIVERS; Index++) {

                wMax = pvDrivers[Index].Name.MaximumLength;
                wLength = pvDrivers[Index].Name.Length;

                if ((wMax && wLength) && (wLength <= wMax)) {

                    lookupAddress = (ULONG_PTR)pvDrivers[Index].Name.Buffer;
                    bytesRead = wMax;
                    *pwStaticBuffer = 0;

                    if (!kdReadSystemMemoryEx(lookupAddress,
                        pwStaticBuffer,
                        bytesRead,
                        &bytesRead))
                    {
                        bResult = FALSE;
                        break;
                    }

                    if (bytesRead < wLength) {
                        bResult = FALSE;
                        break;
                    }

                    pwStaticBuffer[bytesRead / sizeof(WCHAR)] = 0;

                    if (RtlCreateUnicodeString(&pvDrivers[Index].Name,
                        pwStaticBuffer))
                    {

                        if (Callback(&pvDrivers[Index], Context))
                            bStopEnumeration = TRUE;

                        RtlFreeUnicodeString(&pvDrivers[Index].Name);

                        if (bStopEnumeration)
                            break;
                    }
                }
            } //for

            supHeapFree(pvDrivers);

        }
    }

    supHeapFree(pwStaticBuffer);

    return bResult;
}

/*
* kdDestroyShimmedDriversList
*
* Purpose:
*
* Remove all items from shimmed drivers list and free memory.
*
*/
VOID kdDestroyShimmedDriversList(
    _In_ PKSE_ENGINE_DUMP KseEngineDump
)
{
    PLIST_ENTRY ListHead, Entry, NextEntry;
    KSE_SHIMMED_DRIVER* Item;

    ListHead = &KseEngineDump->ShimmedDriversDumpListHead;

    ASSERT_LIST_ENTRY_VALID(ListHead);

    if (IsListEmpty(ListHead))
        return;

    for (Entry = ListHead->Flink, NextEntry = Entry->Flink;
        Entry != ListHead;
        Entry = NextEntry, NextEntry = Entry->Flink)
    {
        Item = CONTAINING_RECORD(Entry, KSE_SHIMMED_DRIVER, ListEntry);
        RemoveEntryList(Entry);
        supHeapFree(Item);
    }
}

/*
* kdQueryKernelShims
*
* Purpose:
*
* Dump kernel shims information.
*
*/
BOOLEAN kdQueryKernelShims(
    _In_ PKLDBGCONTEXT Context,
    _In_ BOOLEAN RefreshList
)
{
    PBYTE      ptrCode;
    ULONG_PTR  lookupAddress = 0;

    BOOLEAN  KseEngineDumpValid = FALSE;

    ULONG_PTR NtOsBase;
    HMODULE hNtOs;

    ULONG_PTR KseShimmedDriversListHead;
    LIST_ENTRY ListEntry;
    KSE_SHIMMED_DRIVER* ShimmedDriver;

    PKSE_ENGINE_DUMP pKseEngineDump = &Context->Data->KseEngineDump;

    if (!kdConnectDriver())
        return FALSE;

    __try {

        //
        // If KseEngine not dumped, locate variable.
        //
        if (pKseEngineDump->Valid == FALSE) {

            //
            // If symbols available then lookup kernel variable address from them.
            //
            if (kdIsSymAvailable((PSYMCONTEXT)Context->NtOsSymContext)) {

                kdGetAddressFromSymbol(
                    Context,
                    KVAR_KseEngine,
                    &lookupAddress);

            }

            //
            // Lookup kernel variable address by pattern search.
            //
            if (lookupAddress == 0) {

                NtOsBase = (ULONG_PTR)Context->NtOsBase;
                hNtOs = (HMODULE)Context->NtOsImageMap;

                ptrCode = (PBYTE)GetProcAddress(hNtOs, "KseSetDeviceFlags");
                if (ptrCode == NULL) {
                    logAdd(EntryTypeError, TEXT("KseSetDeviceFlags not found"));
                    return FALSE;
                }

                lookupAddress = ObFindAddress(NtOsBase,
                    (ULONG_PTR)hNtOs,
                    IL_KseEngine,
                    ptrCode,
                    DA_ScanBytesKseEngine,
                    KseEnginePattern,
                    sizeof(KseEnginePattern));

                if (lookupAddress)
                    lookupAddress -= FIELD_OFFSET(KSE_ENGINE, State);

            }

            if (!kdAddressInNtOsImage((PVOID)lookupAddress)) {
                logAdd(EntryTypeError, TEXT("KseEngine address is invalid"));
                return FALSE;
            }

            pKseEngineDump->KseAddress = lookupAddress;
        }

        //
        // Reinitialize output list in case of refresh.
        //
        if (RefreshList) {
            kdDestroyShimmedDriversList(pKseEngineDump);
            InitializeListHead(&pKseEngineDump->ShimmedDriversDumpListHead);
        }

        //
        // Dump KseEngine double linked list.
        //

        KseShimmedDriversListHead = pKseEngineDump->KseAddress + FIELD_OFFSET(KSE_ENGINE, ShimmedDriversListHead);
        KseEngineDumpValid = TRUE;

        ListEntry.Blink = ListEntry.Flink = NULL;

        if (kdReadSystemMemory(KseShimmedDriversListHead,
            &ListEntry,
            sizeof(LIST_ENTRY)))
        {
            while ((ULONG_PTR)ListEntry.Flink != KseShimmedDriversListHead) {

                ShimmedDriver = (KSE_SHIMMED_DRIVER*)supHeapAlloc(sizeof(KSE_SHIMMED_DRIVER));
                if (ShimmedDriver == NULL) {
                    KseEngineDumpValid = FALSE;
                    break;
                }

                if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
                    ShimmedDriver,
                    sizeof(KSE_SHIMMED_DRIVER)))
                {
                    supHeapFree(ShimmedDriver);
                    KseEngineDumpValid = FALSE;
                    logAdd(EntryTypeError, TEXT("KseEngine entry read error"));
                    break;
                }

                ListEntry.Flink = ShimmedDriver->ListEntry.Flink;
                InsertHeadList(&pKseEngineDump->ShimmedDriversDumpListHead, &ShimmedDriver->ListEntry);
            }
        }
        else {
            logAdd(EntryTypeError, TEXT("KseEngine->ShimmedDriversListHead read error"));
            KseEngineDumpValid = FALSE;
        }

        pKseEngineDump->Valid = KseEngineDumpValid;

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return FALSE;
    }

    return KseEngineDumpValid;
}

/*
* kdQueryCmControlVector
*
* Purpose:
*
*   Find CM_CONTROL_VECTOR structure in mapped kernel image.
*   The function works by first locating the "ProtectionMode" string
*   and then finding the reference to it in the kernel image.
*
* Parameters:
*   Context - Kernel debugging context containing NtOsImageMap
*
* Return Value:
*   Pointer to CM_CONTROL_VECTOR if found, NULL otherwise
*/
PVOID kdQueryCmControlVector(
    _In_ PKLDBGCONTEXT Context
)
{
    ULONG i, offset;
    ULONG sectionSize;
    ULONG_PTR signatureAddress = 0, testValue;
    PVOID controlVector = NULL;
    PBYTE sectionBase;
    PBYTE currentPtr;
    IMAGE_NT_HEADERS* ntHeaders;
    IMAGE_SECTION_HEADER* sectionTableEntry;

    WCHAR szSignature[] = L"ProtectionMode";

    if (Context == NULL || Context->NtOsImageMap == NULL)
        return NULL;

    ntHeaders = RtlImageNtHeader(Context->NtOsImageMap);

    sectionTableEntry = IMAGE_FIRST_SECTION(ntHeaders);

    // First, find the address of the "ProtectionMode" string.
    for (i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionTableEntry++) {
        sectionBase = (PBYTE)Context->NtOsImageMap + sectionTableEntry->VirtualAddress;
        sectionSize = sectionTableEntry->Misc.VirtualSize;

        if (sectionSize == 0)
            continue;

        signatureAddress = (ULONG_PTR)supFindPattern(sectionBase,
            sectionSize,
            (CONST PBYTE)szSignature,
            sizeof(szSignature));

        if (signatureAddress)
            break;
    }

    if (signatureAddress == 0)
        return NULL;

    sectionTableEntry = IMAGE_FIRST_SECTION(ntHeaders);
    for (i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionTableEntry++) {
        sectionBase = (PBYTE)Context->NtOsImageMap + sectionTableEntry->VirtualAddress;
        sectionSize = sectionTableEntry->Misc.VirtualSize;

        if (sectionSize <= sizeof(ULONG_PTR))
            continue;

        for (offset = 0; offset < sectionSize - sizeof(ULONG_PTR); offset++) {

            currentPtr = sectionBase + offset;
            if (currentPtr + sizeof(ULONG_PTR) > sectionBase + sectionSize)
                break;

            testValue = *(PULONG_PTR)currentPtr;
            if (testValue == signatureAddress) {
                if (offset >= sizeof(ULONG_PTR)) {
                    controlVector = currentPtr - sizeof(ULONG_PTR);
                    break;
                }
            }
        }

        if (controlVector)
            break;
    }

    return controlVector;
}

/*
* kdIsSymAvailable
*
* Purpose:
*
* Return TRUE if symbols context is initialized.
*
*/
BOOLEAN kdIsSymAvailable(
    _In_opt_ SYMCONTEXT * SymContext
)
{
    if (SymContext == NULL)
        return FALSE;

    if (SymContext->ModuleBase == 0)
        return FALSE;

    return TRUE;
}

/*
* kdGetFieldOffsetFromSymbol
*
* Purpose:
*
* Get field offset by it name of the ntoskrnl symbol and the offset.
*
*/
BOOL kdGetFieldOffsetFromSymbol(
    _In_ KLDBGCONTEXT * Context,
    _In_ LPCWSTR SymbolName,
    _In_ LPCWSTR FieldName,
    _Out_ ULONG * Offset
)
{
    BOOL bResult = FALSE;
    PSYMCONTEXT symContext = (PSYMCONTEXT)Context->NtOsSymContext;

    *Offset = 0;

    WCHAR szLog[WOBJ_MAX_MESSAGE - 1];

    szLog[0] = 0;
    RtlStringCchPrintfSecure(szLog,
        RTL_NUMBER_OF(szLog),
        TEXT("%ws: Retrieving field \"%ws\" offset for symbol \"%ws\""),
        __FUNCTIONW__,
        FieldName,
        SymbolName);

    logAdd(EntryTypeInformation, szLog);

    __try {

        *Offset = symContext->Parser.GetFieldOffset(
            symContext,
            SymbolName,
            FieldName,
            &bResult);

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return FALSE;
    }

    szLog[0] = 0;
    RtlStringCchPrintfSecure(szLog,
        RTL_NUMBER_OF(szLog),
        TEXT("%ws(%ws): \"%ws->%ws\", offset 0x%lX"),
        __FUNCTIONW__,
        (bResult) ? L"SUCCESS" : L"FAIL",
        SymbolName,
        FieldName,
        *Offset);

    logAdd(EntryTypeInformation, szLog);

    return bResult;
}

/*
* kdGetAddressFromSymbolEx
*
* Purpose:
*
* Get fully adjusted address for symbol by it name.
*
*/
BOOL kdGetAddressFromSymbolEx(
    _In_ PSYMCONTEXT SymContext,
    _In_ LPCWSTR SymbolName,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ImageSize,
    _Inout_ ULONG_PTR * Address
)
{
    BOOL bResult = FALSE;
    ULONG_PTR address = 0;

    WCHAR szLog[WOBJ_MAX_MESSAGE - 1];

    szLog[0] = 0;
    RtlStringCchPrintfSecure(szLog,
        RTL_NUMBER_OF(szLog),
        TEXT("%ws: Retrieving address for symbol \"%ws\""),
        __FUNCTIONW__,
        SymbolName);

    logAdd(EntryTypeInformation, szLog);

    *Address = 0;

    //
    // Verify context data.
    //
    if (ImageBase == NULL || ImageSize == 0)
    {
        return FALSE;
    }

    __try {

        address = SymContext->Parser.LookupAddressBySymbol(
            SymContext,
            SymbolName,
            &bResult);

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return FALSE;
    }

    if (bResult && address) {

        //
        // Adjust address to image base. 
        //
        address = (ULONG_PTR)ImageBase + address - SymContext->ModuleBase;

        //
        // Validate resulting address value.
        //
        if (IN_REGION(address,
            ImageBase,
            ImageSize))
        {
            *Address = address;
        }
        else {
            //
            // This is bogus address not in ntoskrnl range, bail out.
            //
            bResult = FALSE;
        }

    }

    szLog[0] = 0;
    RtlStringCchPrintfSecure(szLog,
        RTL_NUMBER_OF(szLog),
        TEXT("%ws(%ws): \"%ws\" address 0x%llX"),
        __FUNCTIONW__,
        (bResult) ? L"SUCCESS" : L"FAIL",
        SymbolName,
        address);

    logAdd(EntryTypeInformation, szLog);

    return bResult;
}

/*
* kdGetAddressFromSymbol
*
* Purpose:
*
* Get fully adjusted address for ntoskrnl symbol by it name.
*
*/
BOOL kdGetAddressFromSymbol(
    _In_ KLDBGCONTEXT * Context,
    _In_ LPCWSTR SymbolName,
    _Inout_ ULONG_PTR * Address
)
{
    PSYMCONTEXT symContext = (PSYMCONTEXT)Context->NtOsSymContext;

    return kdGetAddressFromSymbolEx(symContext,
        SymbolName,
        Context->NtOsBase,
        Context->NtOsSize,
        Address);

}

/*
* symCallbackProc
*
* Purpose:
*
* DbgHelp callback procedure used for tracking symbols loading during startup.
*
*/
BOOL CALLBACK symCallbackProc(
    _In_ HANDLE hProcess,
    _In_ ULONG ActionCode,
    _In_ ULONG64 CallbackData,
    _In_ ULONG64 UserContext
)
{
    UNREFERENCED_PARAMETER(hProcess);

    switch (ActionCode) {

    case CBA_DEFERRED_SYMBOL_LOAD_START:
    case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
    case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
        supCallbackReportEvent(ActionCode,
            (PIMAGEHLP_DEFERRED_SYMBOL_LOAD)CallbackData,
            (PFNSUPSYMCALLBACK)UserContext);

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* symInit
*
* Purpose:
*
* Create symbol parser context if dbghelp available, called once.
*
*/
BOOL symInit(
    _In_opt_ LPWSTR lpSymbolPath,
    _In_opt_ LPWSTR lpDbgHelpDll
)
{
    ULONG cch;

    WCHAR szFileName[MAX_PATH * 2];
    LPWSTR dbgHelpDll = lpDbgHelpDll;

    if (g_kdctx.NtOsSymContext != NULL)
        return TRUE;

    if (lpDbgHelpDll == NULL) {

        szFileName[0] = 0;
        cch = GetCurrentDirectory(MAX_PATH, szFileName);
        if (cch > 0 && cch < MAX_PATH) {
            supPathAddBackSlash(szFileName);
            _strcat(szFileName, TEXT("symdll\\dbghelp.dll"));
            if (!PathFileExists(szFileName))
                return FALSE;
        }
        else {
            return FALSE;
        }

        dbgHelpDll = szFileName;

    }

    if (SymGlobalsInit(
        SYMOPT_CASE_INSENSITIVE |
        SYMOPT_UNDNAME |
        SYMOPT_FAIL_CRITICAL_ERRORS |
        SYMOPT_EXACT_SYMBOLS |
        SYMOPT_AUTO_PUBLICS,
        NULL,
        dbgHelpDll,
        lpSymbolPath,
        g_WinObj.szSystemDirectory,
        g_WinObj.szTempDirectory,
        (PSYMBOL_REGISTERED_CALLBACK64)symCallbackProc,
        (ULONG64)supSymCallbackReportEvent))
    {
        g_kdctx.NtOsSymContext = (PVOID)SymParserCreate();
    }

    return (g_kdctx.NtOsSymContext != NULL);
}

/*
* symShutdown
*
* Purpose:
*
* Deallocate symbol parser context, called once.
*
*/
VOID symShutdown()
{
    PSYMCONTEXT Context = (PSYMCONTEXT)g_kdctx.NtOsSymContext;

    if (Context) {
        if (Context->ModuleBase)
            Context->Parser.UnloadModule(Context);
    }

    SymGlobalsFree();
}

/*
* kdCreateObjectTypesList
*
* Purpose:
*
* Create simple list of system object types.
*
*/
_Ret_maybenull_
PVOID kdCreateObjectTypesList(
    VOID
)
{
    ULONG i;
    OBTYPE_LIST* list;
    POBJECT_TYPES_INFORMATION pObjectTypes = (POBJECT_TYPES_INFORMATION)supGetObjectTypesInfo();
    POBJECT_TYPE_INFORMATION pObject;
    BOOL bSuccess = FALSE;

    union {
        union {
            POBJECT_TYPE_INFORMATION Object;
            POBJECT_TYPE_INFORMATION_V2 ObjectV2;
        } u1;
        PBYTE Ref;
    } ObjectTypeEntry;

    if (pObjectTypes == NULL)
        return NULL;

    list = (OBTYPE_LIST*)supHeapAlloc(
        sizeof(OBTYPE_LIST) +
        sizeof(OBTYPE_ENTRY) * pObjectTypes->NumberOfTypes);

    if (list == NULL) {
        supHeapFree(pObjectTypes);
        return NULL;
    }

    list->Buffer = pObjectTypes;

    __try {
        pObject = OBJECT_TYPES_FIRST_ENTRY(pObjectTypes);

        for (i = 0; i < pObjectTypes->NumberOfTypes; i++) {

            ObjectTypeEntry.Ref = (PBYTE)pObject;

            if (g_NtBuildNumber >= NT_WIN8_RTM) {
                list->Types[i].TypeIndex = ObjectTypeEntry.u1.ObjectV2->TypeIndex;
                list->Types[i].TypeName = &ObjectTypeEntry.u1.ObjectV2->TypeName;
                list->Types[i].PoolType = ObjectTypeEntry.u1.ObjectV2->PoolType;
            }
            else {
                list->Types[i].TypeIndex = (i + 2);
                list->Types[i].TypeName = &ObjectTypeEntry.u1.Object->TypeName;
                list->Types[i].PoolType = ObjectTypeEntry.u1.Object->PoolType;
            }

            list->NumberOfTypes += 1;
            pObject = OBJECT_TYPES_NEXT_ENTRY(pObject);
        }
        bSuccess = TRUE;
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        bSuccess = FALSE;
    }

    if (!bSuccess) {
        supHeapFree(list->Buffer);
        supHeapFree(list);
        return NULL;
    }
    return list;
}

/*
* kdInit
*
* Purpose:
*
* Fire up KLDBG namespace and open/load helper driver.
*
*/
VOID kdInit(
    _In_ BOOLEAN IsFullAdmin
)
{
    NTSTATUS ntStatus;
    OBEX_CONFIG* obexConfig = supGetParametersBlock();
    WCHAR szBuffer[MAX_PATH * 2];
    LPWSTR lpSymbolPath = NULL, lpDbgHelpDll = NULL;

    RtlSecureZeroMemory(&g_kdctx, sizeof(g_kdctx));
    RtlSecureZeroMemory(&g_kdpdata, sizeof(g_kdpdata));
    RtlSecureZeroMemory(&g_SystemCallbacks, sizeof(g_SystemCallbacks));

    RtlSecureZeroMemory(obexConfig, sizeof(OBEX_CONFIG));

    if (supReadObexConfiguration(obexConfig)) {

        if (obexConfig->SymbolsDbgHelpDllValid)
            lpDbgHelpDll = obexConfig->szSymbolsDbgHelpDll;

        if (obexConfig->SymbolsPathValid)
            lpSymbolPath = obexConfig->szSymbolsPath;

        if (obexConfig->szNormalizationSymbol != 0)
            g_ObNameNormalizationSymbol = obexConfig->szNormalizationSymbol;

    }

    g_kdctx.DriverContext.LoadStatus = STATUS_DRIVER_UNABLE_TO_LOAD;
    g_kdctx.DriverContext.OpenStatus = STATUS_UNSUCCESSFUL;

    g_kdctx.IsFullAdmin = IsFullAdmin;

    g_kdctx.Data = &g_kdpdata;

    g_kdctx.MitigationFlags.ASLRPolicy = TRUE;

    NtpLdrExceptionFilter = (PFNNTLDR_EXCEPT_FILTER)exceptFilterWithLog;

    InitializeListHead(&g_kdctx.Data->KseEngineDump.ShimmedDriversDumpListHead);

    g_kdctx.Data->ObjectTypesList = (POBTYPE_LIST)kdCreateObjectTypesList();

    //
    // Minimum supported client is windows 7
    // However allow experiments on Vista too.
    // Everything below Vista - leave
    //
    if (g_WinObj.osver.dwMajorVersion < 6) {
        MessageBox(GetDesktopWindow(), TEXT("Operation system is not supported, see program requirements."), PROGRAM_NAME, MB_ICONERROR);
        return;
    }

    //
    // Init symbol parser.
    //
    symInit(lpSymbolPath, lpDbgHelpDll);

    //
    // Enable debug privileges for newest Windows 11.
    // 
    if (IsFullAdmin) {
        g_kdctx.IsDebugPrivAssigned = supEnablePrivilegeWithCheck(SE_DEBUG_PRIVILEGE, TRUE);
    }

    //
    // Query global variables.
    //
    kdQuerySystemInformation(&g_kdctx);

    //
    // No admin rights, leave.
    //
    if (IsFullAdmin == FALSE)
        return;

    //
    // Find EPROCESS offsets.
    //
    ObpFindProcessObjectOffsets(&g_kdctx);

    switch (WDrvGetActiveProviderType())
    {
        //
        // If the current driver provider is WinDbg then check Windows debug mode.
        // This is required by WinDbg kldbgdrv.
        //
    case wdrvMicrosoft:
        if (supIsKdEnabled(NULL, NULL) == FALSE)
            return;
        break;

    case wdrvWinIo:
        g_kdctx.MitigationFlags.ImageLoad = TRUE;
        g_kdctx.MitigationFlags.ExtensionPointDisable = TRUE;
        g_kdctx.MitigationFlags.Signature = TRUE;
        g_kdctx.MitigationFlags.ASLRPolicy = TRUE;
        break;
    }

    //
    // Create driver provider context.
    //
    ntStatus = WDrvProvCreate(g_kdctx.Data->FirmwareType, &g_kdctx.DriverContext);
    if (!NT_SUCCESS(ntStatus)) {

        RtlStringCchPrintfSecure(szBuffer,
            MAX_PATH,
            TEXT("Could not open/load helper driver.\r\nSome features maybe unavailable, error code 0x%lX"),
            ntStatus);

        MessageBox(GetDesktopWindow(), szBuffer, PROGRAM_NAME, MB_ICONINFORMATION);
        logAdd(EntryTypeError, szBuffer);
    }

    //
    // Init driver relying variables.
    //
    if (kdIoDriverLoaded()) {

        //
        // Locate and remember ObHeaderCookie, routine require driver usage, do not move.
        //
        if (g_WinObj.osver.dwMajorVersion >= 10) {
            ObpFindHeaderCookie(&g_kdctx);
        }

    }

}

/*
* kdShutdown
*
* Purpose:
*
* Close handle to the driver and unload it if it was loaded by our program,
* destroy object list, delete list lock.
* This routine called once, during program shutdown.
*
*/
VOID kdShutdown(
    VOID
)
{
    if (g_kdctx.Data->ObjectTypesList) {
        if (g_kdctx.Data->ObjectTypesList->Buffer)
            supHeapFree(g_kdctx.Data->ObjectTypesList->Buffer);
        supHeapFree(g_kdctx.Data->ObjectTypesList);
    }

    WDrvProvRelease(&g_kdctx.DriverContext);

    if (g_kdctx.NtOsImageMap) {
        FreeLibrary((HMODULE)g_kdctx.NtOsImageMap);
        g_kdctx.NtOsImageMap = NULL;
    }

    //
    // Deallocate symbols context if present.
    //
    symShutdown();
}

```

`Source/WinObjEx64/kldbg.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       KLDBG.H
*
*  VERSION:     2.09
*
*  DATE:        19 Aug 2025
*
*  Common header file for the Kernel Debugger Driver support.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define IOCTL_KD_PASS_THROUGH CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1, METHOD_NEITHER, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

/******************************************************************************
*
* Object type versions
* 
* ALPC_PORT
* DEVICE_MAP
* DIRECTORY_OBJECT
* DRIVER_EXTENSION
* OBJECT_TYPE
* OBJECT_SYMBOLIC_LINK
* FLT_FILTER
* 
*******************************************************************************/

// Structure version from W7 (7600)
#define OBVERSION_ALPCPORT_V1  (1)
// Structure version from W8 (9200)
#define OBVERSION_ALPCPORT_V2  (2)
// Structure version from W8 BLUE (9600)
#define OBVERSION_ALPCPORT_V3  (3)
// Structure version from W10 (10240)
#define OBVERSION_ALPCPORT_V4  (4)

// Structure version from W7 (7600) until W10 RS1
#define OBVERSION_DEVICE_MAP_V1  (1)
// Structure version from W10 RS1 (14393) until W11
#define OBVERSION_DEVICE_MAP_V2  (2)
// Structure version from W11 (22000)
#define OBVERSION_DEVICE_MAP_V3  (3)

// Structure version for W7-W8 BLUE (7600..9600)
#define OBVERSION_DIRECTORY_V1 (1)
// Structure version for W10 (10240..14393)
#define OBVERSION_DIRECTORY_V2 (2)
// Structure version for W10 (15063+)
#define OBVERSION_DIRECTORY_V3 (3)

// Public structure
#define OBVERSION_DRIVER_EXTENSION_V1 (1)
// Private, W7 (7600..7601)
#define OBVERSION_DRIVER_EXTENSION_V2 (2)
// Private, W8 (9200)
#define OBVERSION_DRIVER_EXTENSION_V3 (3)
// Private, since W8 BLUE (9600+)
#define OBVERSION_DRIVER_EXTENSION_V4 (4)

// Structure version W7 (7600..7601)
#define OBVERSION_OBJECT_TYPE_V1 (1)
// Structure version W8-W10 (9200..10586)
#define OBVERSION_OBJECT_TYPE_V2 (2)
// Structure version W10RS1 (14393)
#define OBVERSION_OBJECT_TYPE_V3 (3)
// Structure version W10RS2 (15063+)
#define OBVERSION_OBJECT_TYPE_V4 (4)

// Structure version W7-W8 BLUE (7600 - 9600)
#define OBVERSION_OBJECT_SYMBOLIC_LINK_V1 (1)
// Structure version W10 TH1/TH2 (10240..10586)
#define OBVERSION_OBJECT_SYMBOLIC_LINK_V2 (2)
// Structure version W10 RS1 (14393)
#define OBVERSION_OBJECT_SYMBOLIC_LINK_V3 (3)
// Structure version W10 RS3..21H1 (15063..19044)
#define OBVERSION_OBJECT_SYMBOLIC_LINK_V4 (4)
// Structure version W11 (22000)
#define OBVERSION_OBJECT_SYMBOLIC_LINK_V5 (5)

// Structure version W7 (7600 - 7601)
#define OBVERSION_FLT_FILTER_V1 (1)
// Structure version since W8 (9200..9600)
#define OBVERSION_FLT_FILTER_V2 (2)
// Structure version since W10 (10240+)
#define OBVERSION_FLT_FILTER_V3 (3)
// Structure version since W11
#define OBVERSION_FLT_FILTER_V4 (4)
// Structure version since W11 25H2
#define OBVERSION_FLT_FILTER_V5 (5)

#define NT_REG_PREP             L"\\Registry\\Machine"
#define DRIVER_REGKEY           L"%wS\\System\\CurrentControlSet\\Services\\%wS"
#define OBTYPES_DIRECTORY       L"\\ObjectTypes"
#define OB_GLOBALROOT           L"\\GLOBAL??\\GLOBALROOT"
#define OB_GLOBALNAMESPACE      L"\\??"

#define OBJECT_SHIFT 8

#define KM_OBJECTS_ROOT_DIRECTORY  L"\\"
#define OBJ_NAME_PATH_SEPARATOR L'\\'
#define OBJ_NAME_PATH_SEPARATOR_SIZE sizeof(WCHAR)

#define OBJ_NAME_NORMALIZATION_SYMBOL L'?'

#define MM_SYSTEM_RANGE_START_7 0xFFFF080000000000
#define MM_SYSTEM_RANGE_START_8 0xFFFF800000000000

#define TEXT_SECTION ".text"
#define TEXT_SECTION_LENGTH sizeof(TEXT_SECTION)

#define PAGE_SECTION "PAGE"
#define PAGE_SECTION_LENGTH sizeof(PAGE_SECTION)

#define INIT_SECTION "INIT"
#define INIT_SECTION_LENGTH sizeof(INIT_SECTION)

typedef ULONG_PTR *PUTable;

#define OBP_ERROR_NAME_LITERAL L"<error>"
#define OBP_ERROR_NAME_LITERAL_SIZE (sizeof(OBP_ERROR_NAME_LITERAL) - sizeof(UNICODE_NULL))
#define OBP_ERROR_NONAME_LITERAL L"<noname>"
#define OBP_ERROR_NONAME_LITERAL_SIZE (sizeof(OBP_ERROR_NONAME_LITERAL) - sizeof(UNICODE_NULL))

#define WINE_DIRECTORY_QUERY_BUFFER_SIZE (64 * 1024)
#define OB_MAX_DIRECTORY_ENUM_ITER (64 * 1024)

//
// Predefined strings
//
#define OBP_ROOT            0
#define OBP_DIRECTORY       1
#define OBP_OBTYPES         2 
#define OBP_GLOBAL          3
#define OBP_GLOBALNAMESPACE 4  

//enum with information flags used by ObGetObjectHeaderOffset
typedef enum _OBJ_HEADER_INFO_FLAG {
    HeaderCreatorInfoFlag = 0x1,
    HeaderNameInfoFlag = 0x2,
    HeaderHandleInfoFlag = 0x4,
    HeaderQuotaInfoFlag = 0x8,
    HeaderProcessInfoFlag = 0x10
} OBJ_HEADER_INFO_FLAG;

typedef struct _OBHEADER_COOKIE {
    BOOLEAN Valid;
    UCHAR Value;
} OBHEADER_COOKIE, * POBHEADER_COOKIE;

typedef struct _ALPCPORT_TYPE_INDEX {
    BOOLEAN Valid;
    USHORT TypeIndex;
} ALPCPORT_TYPE_INDEX, *PALPCPORT_TYPE_INDEX;

typedef struct _EPROCESS_OFFSET {
    BOOLEAN Valid;
    ULONG OffsetValue;
} EPROCESS_OFFSET, * PEPROCESS_OFFSET;

typedef struct _KSE_ENGINE_DUMP {
    BOOLEAN Valid;
    ULONG_PTR KseAddress;
    LIST_ENTRY ShimmedDriversDumpListHead;
} KSE_ENGINE_DUMP, * PKSE_ENGINE_DUMP;

typedef struct _KLDBG_SYSTEM_ADDRESS {
    BOOLEAN Valid;
    ULONG_PTR Address;
} KLDBG_SYSTEM_ADDRESS, * PKLDBG_SYSTEM_ADDRESS;

typedef struct _OBTYPE_ENTRY {
    PUNICODE_STRING TypeName;
    ULONG PoolType;
    ULONG TypeIndex;
} OBTYPE_ENTRY, * POBTYPE_ENTRY;

typedef struct _OBTYPE_LIST {
    ULONG NumberOfTypes;
    PVOID Buffer;
    OBTYPE_ENTRY Types[ANYSIZE_ARRAY];
} OBTYPE_LIST, * POBTYPE_LIST;

//
// KLDBG private data.
//
typedef struct _KLDBGPDATA {

    FIRMWARE_TYPE FirmwareType;

    //system object header cookie (win10+)
    OBHEADER_COOKIE ObHeaderCookie;

    //address of invalid request handler
    PVOID IopInvalidDeviceRequest;

    //address of ObpPrivateNamespaceLookupTable
    PVOID PrivateNamespaceLookupTable;

    //syscall tables related info
    ULONG_PTR KeServiceDescriptorTableShadowPtr;
    KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;

    //kernel shim engine dump and auxl ptrs
    KSE_ENGINE_DUMP KseEngineDump;

    //unloaded drivers array address
    KLDBG_SYSTEM_ADDRESS MmUnloadedDrivers; 

    //address of data in mapped ntoskrnl
    PVOID CmControlVector;

    //array of object type information
    POBTYPE_LIST ObjectTypesList;

    // ALPC Port type index
    ALPCPORT_TYPE_INDEX AlpcPortTypeIndex;

    //EPROCESS specific offsets
    EPROCESS_OFFSET PsUniqueProcessId;  
    EPROCESS_OFFSET PsProcessImageName; 

} KLDBGPDATA, * PKLDBGPDATA;

typedef struct _KLDBGCONTEXT {

    //Is user full admin
    BOOLEAN IsFullAdmin;

    //SecureBoot enabled?
    BOOLEAN IsSecureBoot;

    //VHD boot?
    BOOLEAN IsOsDiskVhd;

    //Debug privilege?
    BOOLEAN IsDebugPrivAssigned;

    union {
        struct {
            BOOLEAN Signature : 1;
            BOOLEAN ImageLoad : 1;
            BOOLEAN ExtensionPointDisable : 1;
            BOOLEAN ASLRPolicy : 1;
            BOOLEAN DynamicCode : 1;
            BOOLEAN Reserved : 3;
        } MitigationFlags;
    };

    //index of directory type and root address
    USHORT DirectoryTypeIndex;
    ULONG_PTR DirectoryRootObject;

    //ntoskrnl base and size
    PVOID NtOsBase;
    ULONG NtOsSize;

    //ntoskrnl mapped image
    PVOID NtOsImageMap;

    //system range start
    ULONG_PTR SystemRangeStart;

    //min/max user address
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;

    PVOID NtOsSymContext;

    WDRV_CONTEXT DriverContext;

    PKLDBGPDATA Data;

} KLDBGCONTEXT, *PKLDBGCONTEXT;

extern KLDBGCONTEXT g_kdctx;
extern ULONG g_NtBuildNumber;

typedef struct _KLDBG {
    SYSDBG_COMMAND SysDbgRequest;
    PVOID Buffer;
    DWORD BufferSize;
}KLDBG, *PKLDBG;

typedef struct _OBEX_OBJECT_INFORMATION {
    ULONG_PTR HeaderAddress;
    ULONG_PTR ObjectAddress;
    OBJECT_HEADER_QUOTA_INFO ObjectQuotaHeader;
    OBJECT_HEADER ObjectHeader;
} OBEX_OBJECT_INFORMATION, * POBEX_OBJECT_INFORMATION;

typedef struct _OBJREFPNS {
    ULONG SizeOfBoundaryInformation;
    ULONG_PTR NamespaceDirectoryAddress; //point to OBJECT_DIRECTORY
    ULONG_PTR NamespaceLookupEntry; //point to OBJECT_NAMESPACE_ENTRY
} OBJREFPNS, *POBJREFPNS;

typedef struct _OBJREF {
    LIST_ENTRY ListEntry;
    UNICODE_STRING Name;
    ULONG_PTR HeaderAddress;
    ULONG_PTR ObjectAddress;
    UCHAR TypeIndex;
    WOBJ_OBJECT_TYPE ObjectTypeIndex;
    OBJREFPNS PrivateNamespace;
} OBJREF, *POBJREF;

//
// Defines for boundary descriptors
//

#define KNOWN_BOUNDARY_DESCRIPTOR_VERSION       1
#define MAX_BOUNDARY_DESCRIPTOR_NAME_ENTRIES    1
#define MAX_BOUNDARY_DESCRIPTOR_IL_ENTRIES      1

//
// Callbacks support.
//

//
// Actual limits, not variables.
//
#define PspNotifyRoutinesLimit                  64
#define PspCreateProcessNotifyRoutineExCount    64
#define PspCreateThreadNotifyRoutineCount       64
#define PspLoadImageNotifyRoutineCount          64
#define DbgkLmdCount                            8
#define PopCoalescingCallbackRoutineCount_V1    8
#define PopCoalescingCallbackRoutineCount_V2    32

typedef struct _NOTIFICATION_CALLBACKS {
    ULONG_PTR PspCreateProcessNotifyRoutine;
    ULONG_PTR PspCreateThreadNotifyRoutine;
    ULONG_PTR PspLoadImageNotifyRoutine;
    ULONG_PTR KeBugCheckCallbackHead;
    ULONG_PTR KeBugCheckReasonCallbackHead;
    ULONG_PTR CmCallbackListHead;
    ULONG_PTR IopNotifyShutdownQueueHead;
    ULONG_PTR IopNotifyLastChanceShutdownQueueHead;
    ULONG_PTR ObProcessCallbackHead;
    ULONG_PTR ObThreadCallbackHead;
    ULONG_PTR ObDesktopCallbackHead;
    ULONG_PTR SeFileSystemNotifyRoutinesHead;
    ULONG_PTR SeFileSystemNotifyRoutinesExHead;
    ULONG_PTR PopRegisteredPowerSettingCallbacks;
    ULONG_PTR RtlpDebugPrintCallbackList;
    ULONG_PTR IopFsNotifyChangeQueueHead;
    ULONG_PTR IopDiskFileSystemQueueHead;
    ULONG_PTR IopCdRomFileSystemQueueHead;
    ULONG_PTR IopTapeFileSystemQueueHead;
    ULONG_PTR IopNetworkFileSystemQueueHead;
    ULONG_PTR DbgkLmdCallbacks;
    ULONG_PTR PsAltSystemCallHandlers;
    ULONG_PTR CiCallbacks;
    ULONG_PTR ExpHostListHead;
    ULONG_PTR ExpCallbackListHead;
    ULONG_PTR PoCoalescingCallbacks;
    ULONG_PTR PspPicoProviderRoutines;
    ULONG_PTR KiNmiCallbackListHead;
    ULONG_PTR PspSiloMonitorList;
    ULONG_PTR EmpCallbackListHead;
    ULONG_PTR PnpDeviceClassNotifyList;
} NOTIFICATION_CALLBACKS, *PNOTIFICATION_CALLBACKS;

//
// Callbacks global.
// (defined in kldbg.c)
//
extern NOTIFICATION_CALLBACKS g_SystemCallbacks;

//
// Normalization symbol
// (defined in kldbg.c)
//
extern WCHAR g_ObNameNormalizationSymbol;

typedef struct _W32K_API_SET_LOOKUP_PATTERN {
    ULONG Size;
    PVOID Data;
} W32K_API_SET_LOOKUP_PATTERN, *PW32K_API_SET_LOOKUP_PATTERN;

typedef struct _W32K_API_SET_TABLE_HOST {
    PWCHAR HostName;
    PCHAR TableName;
    PCHAR TableSizeName;
    ULONG HostEntriesCount;
} W32K_API_SET_TABLE_HOST, * PW32K_API_SET_TABLE_HOST;

typedef struct _W32K_API_SET_TABLE_ENTRY {
    PVOID HostEntriesArray;
    W32K_API_SET_TABLE_HOST* Host;
} W32K_API_SET_TABLE_ENTRY, * PW32K_API_SET_TABLE_ENTRY;

typedef struct _W32K_API_SET_TABLE_ENTRY_V2 {
    PVOID HostEntriesArray;
    W32K_API_SET_TABLE_HOST* Host;
    W32K_API_SET_TABLE_HOST* AliasHost;
} W32K_API_SET_TABLE_ENTRY_V2, * PW32K_API_SET_TABLE_ENTRY_V2;

// return true to stop enumeration
typedef BOOL(CALLBACK* PENUMERATE_PRIVATE_NAMESPACE_CALLBACK)(
    _In_ POBJREF Entry,
    _In_opt_ PVOID Context
    );

// return true to stop enumeration
typedef BOOL(CALLBACK *PENUMERATE_BOUNDARY_DESCRIPTOR_CALLBACK)(
    _In_ OBJECT_BOUNDARY_ENTRY *Entry,
    _In_opt_ PVOID Context
    );

// return true to stop enumeration
typedef BOOL(CALLBACK* PENUMERATE_UNLOADED_DRIVERS_CALLBACK)(
    _In_ PUNLOADED_DRIVERS Entry,
    _In_opt_ PVOID Context
    );

PUNICODE_STRING ObGetPredefinedUnicodeString(
    _In_ ULONG Index);

NTSTATUS ObIsValidUnicodeString(
    _In_ PCUNICODE_STRING SourceString);

NTSTATUS ObIsValidUnicodeStringEx(
    _In_ PCUNICODE_STRING SourceString,
    _In_ DWORD dwFlags);

NTSTATUS ObCopyBoundaryDescriptor(
    _In_ _Notnull_ OBJECT_NAMESPACE_ENTRY* NamespaceLookupEntry,
    _Outptr_result_maybenull_ POBJECT_BOUNDARY_DESCRIPTOR* BoundaryDescriptor,
    _Out_opt_ PULONG BoundaryDescriptorSize);

NTSTATUS ObEnumerateBoundaryDescriptorEntries(
    _In_ OBJECT_BOUNDARY_DESCRIPTOR *BoundaryDescriptor,
    _In_ PENUMERATE_BOUNDARY_DESCRIPTOR_CALLBACK Callback,
    _In_opt_ PVOID Context);

BOOL ObEnumeratePrivateNamespaceTable(
    _In_ PENUMERATE_PRIVATE_NAMESPACE_CALLBACK Callback,
    _In_opt_ PVOID Context);

UCHAR ObDecodeTypeIndex(
    _In_ PVOID Object,
    _In_ UCHAR EncodedTypeIndex);

_Ret_maybenull_
PVOID ObDumpDirectoryObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
PVOID ObDumpObjectTypeVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
PVOID ObDumpAlpcPortObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
PVOID ObDumpSymbolicLinkObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
PVOID ObDumpDeviceMapVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
PVOID ObDumpDriverExtensionVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
PVOID ObDumpFltFilterObjectVersionAware(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PULONG Size,
    _Out_ PULONG Version);

_Ret_maybenull_
POBEX_OBJECT_INFORMATION ObQueryObjectByAddress(
    _In_ ULONG_PTR ObjectAddress);

_Success_(return)
BOOL ObGetProcessImageFileName(
    _In_ ULONG_PTR ProcessObject,
    _Inout_ PUNICODE_STRING ImageFileName);

_Success_(return)
BOOL ObGetProcessId(
    _In_ ULONG_PTR ProcessObject,
    _Out_ PHANDLE UniqueProcessId);

_Success_(return)
BOOL ObHeaderToNameInfoAddress(
    _In_ UCHAR ObjectInfoMask,
    _In_ ULONG_PTR ObjectHeaderAddress,
    _Out_ PULONG_PTR HeaderInfoAddress,
    _In_ OBJ_HEADER_INFO_FLAG InfoFlag);

_Success_(return)
BOOL ObQueryNameStringFromAddress(
    _In_ HANDLE HeapHandle,
    _In_ ULONG_PTR NameInfoAddress,
    _Out_ PUNICODE_STRING NameString);

_Success_(return)
BOOL ObGetObjectAddressForDirectory(
    _In_ PUNICODE_STRING DirectoryName,
    _Out_ PULONG_PTR lpRootAddress,
    _Out_opt_ PUSHORT lpTypeIndex);

_Ret_maybenull_
POBEX_OBJECT_INFORMATION ObQueryObjectInDirectory(
    _In_ PUNICODE_STRING ObjectName,
    _In_ PUNICODE_STRING DirectoryName);

PVOID ObGetCallbackBlockRoutine(
    _In_ PVOID CallbackBlock);

_Success_(return)
BOOL ObQueryFullNamespacePath(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PUNICODE_STRING Path);

_Ret_maybenull_
POBJECT_DIRECTORY_INFORMATION ObQueryObjectDirectory(
    _In_ HANDLE DirectoryHandle,
    _Inout_ PULONG Context,
    _In_ BOOL IsWine,
    _Out_ PULONG ReturnLength);

_Ret_maybenull_
PVOID kdCreateObjectTypesList(
    VOID);

VOID kdReportErrorByFunction(
    _In_ LPCWSTR FunctionName,
    _In_ LPCWSTR ErrorMessage);

VOID kdReportReadErrorSimple(
    _In_ LPCWSTR FunctionName,
    _In_ ULONG_PTR KernelAddress,
    _In_ ULONG InputBufferLength);

VOID kdReportReadError(
    _In_ LPCWSTR FunctionName,
    _In_ ULONG_PTR KernelAddress,
    _In_ ULONG InputBufferLength,
    _In_ NTSTATUS Status,
    _In_ PIO_STATUS_BLOCK Iosb);

BOOLEAN kdIoDriverLoaded(
    VOID);

BOOLEAN kdConnectDriver(
    VOID);

PVOID kdQueryIopInvalidDeviceRequest(
    VOID);

BOOL kdFindKiServiceTable(
    _In_ ULONG_PTR MappedImageBase,
    _In_ ULONG_PTR KernelImageBase,
    _Inout_ KSERVICE_TABLE_DESCRIPTOR* ServiceTable);

BOOL kdReadSystemMemory2(
    _In_opt_ LPCWSTR CallerFunction,
    _In_ ULONG_PTR Address,
    _Inout_updates_bytes_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

#define kdReadSystemMemory(Address, Buffer, BufferSize) \
    kdReadSystemMemory2(__FUNCTIONW__, Address, Buffer, BufferSize, NULL)

#define kdReadSystemMemoryEx(Address, Buffer, BufferSize, NumberOfBytesRead) \
    kdReadSystemMemory2(NULL, Address, Buffer, BufferSize, NumberOfBytesRead)

#ifdef _DEBUG
#define kdDebugPrint(f, ...) DbgPrint(f, __VA_ARGS__)
#else
#define kdDebugPrint(f, ...) 
#endif

VOID kdInit(
    _In_ BOOLEAN IsFullAdmin);

VOID kdShutdown(
    VOID);

UCHAR kdGetInstructionLength(
    _In_ PVOID ptrCode,
    _Out_ PULONG ptrFlags);

VOID kdDestroyShimmedDriversList(
    _In_ PKSE_ENGINE_DUMP KseEngineDump);

BOOLEAN kdQueryKernelShims(
    _In_ PKLDBGCONTEXT Context,
    _In_ BOOLEAN RefreshList);

PVOID kdQueryCmControlVector(
    _In_ PKLDBGCONTEXT Context);

BOOL kdEnumerateMmUnloadedDrivers(
    _In_ PENUMERATE_UNLOADED_DRIVERS_CALLBACK Callback,
    _In_opt_ PVOID Context);

BOOLEAN kdIsSymAvailable(
    _In_opt_ SYMCONTEXT* SymContext);

BOOL kdGetFieldOffsetFromSymbol(
    _In_ KLDBGCONTEXT* Context,
    _In_ LPCWSTR SymbolName,
    _In_ LPCWSTR FieldName,
    _Out_ ULONG* Offset);

BOOL kdGetAddressFromSymbol(
    _In_ KLDBGCONTEXT* Context,
    _In_ LPCWSTR SymbolName,
    _Inout_ ULONG_PTR* Address);

BOOL kdGetAddressFromSymbolEx(
    _In_ PSYMCONTEXT SymContext,
    _In_ LPCWSTR SymbolName,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ImageSize,
    _Inout_ ULONG_PTR* Address);

_Success_(return)
BOOLEAN kdDumpUnicodeString(
    _In_ PUNICODE_STRING InputString,
    _Out_ PUNICODE_STRING OutputString,
    _Out_opt_ PVOID* ReferenceStringBuffer,
    _In_ BOOLEAN IsKernelPointer);

USHORT kdGetAlpcPortTypeIndex();

/*
* ObGetObjectFastReference
*
* Purpose:
*
* Return unbiased pointer.
*
*/
__forceinline PVOID ObGetObjectFastReference(
    _In_ EX_FAST_REF FastRef) //-V813
{
    return (PVOID)(FastRef.Value & ~MAX_FAST_REFS);
}

/*
* kdAddressInNtOsImage
*
* Purpose:
*
* Test if given address in range of ntoskrnl.
*
*/
__forceinline BOOL kdAddressInNtOsImage(
    _In_opt_ PVOID Address)
{
    return IN_REGION(Address,
        g_kdctx.NtOsBase,
        g_kdctx.NtOsSize);
}

/*
* kdAddressInUserModeRange
*
* Purpose:
*
* Test if given address in user mode accessible range.
*
*/
__forceinline BOOL kdAddressInUserModeRange(
    _In_opt_ PVOID Address)
{
    return ((ULONG_PTR)Address >= g_kdctx.MinimumUserModeAddress &&
        (ULONG_PTR)Address < g_kdctx.MaximumUserModeAddress);
}

/*
* kdAdjustAddressToNtOsBase
*
* Purpose:
*
* Adjust address to address in ntos kernel image.
*
*/
__forceinline ULONG_PTR kdAdjustAddressToNtOsBase(
    _In_ ULONG_PTR CodeBase,
    _In_ ULONG_PTR Offset,
    _In_ ULONG InstructionLength,
    _In_ LONG Relative
)
{
    return (ULONG_PTR)g_kdctx.NtOsBase + ((CodeBase + Offset + InstructionLength + Relative) 
        - (ULONG_PTR)g_kdctx.NtOsImageMap);
}

```

`Source/WinObjEx64/kldbg_patterns.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2024
*
*  TITLE:       KLDBG_PATTERNS.H
*
*  VERSION:     2.05
*
*  DATE:        11 Jul 2024
*
*  Header with search patterns used by KLDBG.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

// lea rax, PspHostSiloGlobals
#define IL_PspHostSiloGlobals                   7

// Number of bytes to scan for table lookup var 1
#define DA_ScanBytesPNSVariant1                 64

// Number of bytes to scan for table lookup var 2
#define DA_ScanBytesPNSVariant2                 128

//  movzx   ecx, byte ptr cs:ObHeaderCookie
#define IL_ObHeaderCookie                       7

// Number of bytes to scan
#define DA_ScanBytesObHeaderCookie              256

//
// ObHeaderCookie
//
BYTE ObHeaderCookiePattern[] = {
    0x0F, 0xB6, 0x0D
};

//
// ObpLookupNamespaceEntry signatures
//

// 7600, 7601, 9600, 10240
BYTE NamespacePattern[] = {
    0x0F, 0xB6, 0x7A, 0x28, 0x48, 0x8D, 0x05
};

// 9200 (8 failed even here)
BYTE NamespacePattern8[] = {
    0x0F, 0xB6, 0x79, 0x28, 0x48, 0x8D, 0x05
};

/*+++

 Host Server Silo signature patterns

+++*/

//
// PrivateNamespaces redesigned in Windows 10 starting from 10586.
//

BYTE PsGetServerSiloGlobalsPattern_14393[] = {
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x83, 0xF9, 0xFF
};

BYTE PsGetServerSiloGlobalsPattern_15064_16299[] = {
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0xC1, 0x48, 0x83, 0xF9, 0xFF
};

//
// lea rax, ObpPrivateNamespaceLookupTable
//
BYTE LeaPattern_PNS[] = {
    0x48, 0x8d, 0x05
};

//KiSystemServiceStartPattern(KiSystemServiceRepeat) signature

BYTE  KiSystemServiceStartPattern[] = { 0x8B, 0xF8, 0xC1, 0xEF, 0x07, 0x83, 0xE7, 0x20, 0x25, 0xFF, 0x0F, 0x00, 0x00 };

//
// lea r10, KeServiceDescriptorTable
//
BYTE LeaPattern_KeServiceDescriptorTable[] = {
    0x4c, 0x8d, 0x15
};

//
// lea r11, KeServiceDescriptorTableShadow
//
BYTE LeaPattern_KeServiceDescriptorTableShadow[] = {
    0x4c, 0x8d, 0x1d
};

// lea
#define IL_KeServiceDescriptorTableShadow               7

// Number of bytes to scan
#define DA_ScanBytesKeServiceDescriptorTableShadow      128

//
// KSE
//

#define IL_KseEngine 6
#define DA_ScanBytesKseEngine 64

BYTE KseEnginePattern[] = {
    0x8B, 0x05
};

//
// PAGE: MiRememberUnloadedDriver
//
// mov reg, 7D0h ;  -> NumberOfBytes = MI_UNLOADED_DRIVERS * sizeof (UNLOADED_DRIVERS);
//
BYTE MiRememberUnloadedDriverPattern[] = {
    0xBB, 0xD0, 0x07, 0x00, 0x00
};

//
// PAGE: MiRememberUnloadedDriver
//
// mov reg, 7D0h ;  -> NumberOfBytes = MI_UNLOADED_DRIVERS * sizeof (UNLOADED_DRIVERS);
// mov ecx, 40h  ;
//
BYTE MiRememberUnloadedDriverPattern2[] = {
   0xBA, 0xD0, 0x07, 0x00, 0x00,  // mov     edx, 7D0h
   0xB9, 0x40, 0x00, 0x00, 0x00   // mov     ecx, 40h
};

#define FIX_WIN10_THRESHOULD_REG 0xBF

BYTE MiRememberUnloadedDriverPattern24H2[] = {
    0xBA, 0xD0, 0x07, 0x00, 0x00,  // mov    edx, 7D0h
    0x41, 0x8D, 0x4E, 0x40         // lea    ecx, [r14+40h]
};

```

`Source/WinObjEx64/ksymbols.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2024
*
*  TITLE:       KSYMBOLS.H
*
*  VERSION:     2.05
*
*  DATE:        12 Mar 2024
*
*  Header file for kernel symbol names.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define KVAR_KeServiceDescriptorTableShadow         L"KeServiceDescriptorTableShadow"
#define KVAR_KseEngine                              L"KseEngine"
#define KVAR_ObHeaderCookie                         L"ObHeaderCookie"
#define KVAR_IopInvalidDeviceRequest                L"IopInvalidDeviceRequest"
#define KVAR_MmUnloadedDrivers                      L"MmUnloadedDrivers"
#define KVAR_PspHostSiloGlobals                     L"PspHostSiloGlobals"

#define KVAR_SeCiCallbacks                          L"SeCiCallbacks"
#define KVAR_g_CiCallbacks                          L"g_CiCallbacks"

#define KVAR_gSessionGlobalSlots                    L"gSessionGlobalSlots"

#define KVAR_IopFsNotifyChangeQueueHead             L"IopFsNotifyChangeQueueHead"
#define KVAR_RtlpDebugPrintCallbackList             L"RtlpDebugPrintCallbackList"
#define KVAR_PopRegisteredPowerSettingCallbacks     L"PopRegisteredPowerSettingCallbacks"

#define KVAR_IopCdRomFileSystemQueueHead            L"IopCdRomFileSystemQueueHead"
#define KVAR_IopDiskFileSystemQueueHead             L"IopDiskFileSystemQueueHead"
#define KVAR_IopTapeFileSystemQueueHead             L"IopTapeFileSystemQueueHead"
#define KVAR_IopNetworkFileSystemQueueHead          L"IopNetworkFileSystemQueueHead"

#define KVAR_SeFileSystemNotifyRoutinesHead         L"SeFileSystemNotifyRoutinesHead"
#define KVAR_SeFileSystemNotifyRoutinesExHead       L"SeFileSystemNotifyRoutinesExHead"

#define KVAR_IopNotifyShutdownQueueHead             L"IopNotifyShutdownQueueHead"
#define KVAR_IopNotifyLastChanceShutdownQueueHead   L"IopNotifyLastChanceShutdownQueueHead"

#define KVAR_CallbackListHead                       L"CallbackListHead"

#define KVAR_KeBugCheckCallbackListHead             L"KeBugCheckCallbackListHead"
#define KVAR_KeBugCheckReasonCallbackListHead       L"KeBugCheckReasonCallbackListHead"

#define KVAR_PspLoadImageNotifyRoutine              L"PspLoadImageNotifyRoutine"
#define KVAR_PspCreateThreadNotifyRoutine           L"PspCreateThreadNotifyRoutine"
#define KVAR_PspCreateProcessNotifyRoutine          L"PspCreateProcessNotifyRoutine"

#define KVAR_DbgkLmdCallbacks                       L"DbgkLmdCallbacks"

#define KVAR_PsAltSystemCallHandlers                L"PsAltSystemCallHandlers"

#define KVAR_ExpHostList                            L"ExpHostList"

#define KVAR_PopCoalescingCallbackRoutine           L"PopCoalescingCallbackRoutine"
#define KVAR_PopCoalRegistrationList                L"PopCoalRegistrationList"

#define KVAR_PspPicoProviderRoutines                L"PspPicoProviderRoutines"

#define KVAR_KiNmiCallbackListHead                  L"KiNmiCallbackListHead"

#define KVAR_PspSiloMonitorList                     L"PspSiloMonitorList"

#define KVAR_EmpCallbackListHead                    L"EmpCallbackListHead"

#define KVAR_PnpDeviceClassNotifyList               L"PnpDeviceClassNotifyList"

#define KVAR_Win32kApiSetTable                      L"Win32kApiSetTable"

#define KFLD_UniqueProcessId                        L"UniqueProcessId"
#define KFLD_ImageFileName                          L"ImageFileName"

#define KSYM_EPROCESS                               L"_EPROCESS"
#define KSYM_CONTROL_AREA                           L"_CONTROL_AREA"

```

`Source/WinObjEx64/list.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       LIST.C
*
*  VERSION:     2.10
*
*  DATE:        03 Oct 2025
*
*  Program main object listing and search logic.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "props/propTypeConsts.h"

HANDLE ListObjectsHeap = NULL;
HANDLE TreeObjectsHeap = NULL;

BOOLEAN ListHeapCreate(
    _Inout_ _At_(*HeapHandle, _Pre_valid_) _At_(*HeapHandle, _Post_valid_) PHANDLE HeapHandle
)
{
    HANDLE handle;

    if (HeapHandle == NULL) 
        return FALSE;

    if (*HeapHandle)
        supDestroyHeap(*HeapHandle);

    handle = supCreateHeap(HEAP_GROWABLE, TRUE);
    *HeapHandle = handle;

    return (handle != NULL);
}

VOID ListHeapDestroy(
    VOID
)
{
    if (ListObjectsHeap) {
        supDestroyHeap(ListObjectsHeap);
        ListObjectsHeap = NULL;
    }

    if (TreeObjectsHeap) {
        supDestroyHeap(TreeObjectsHeap);
        TreeObjectsHeap = NULL;
    }
}

/*
* AllocateObjectItem
*
* Purpose:
*
* Create an OBEX_ITEM.
*
*/
POBEX_ITEM AllocateObjectItem(
    _In_ HANDLE HeapHandle,
    _In_ WOBJ_OBJECT_TYPE TypeIndex,
    _In_ PUNICODE_STRING Name,
    _In_ PUNICODE_STRING TypeName,
    _In_opt_ OBEX_ITEM* Parent
)
{
    POBEX_ITEM item;

    item = (OBEX_ITEM*)supHeapAllocEx(HeapHandle, sizeof(OBEX_ITEM));
    if (item == NULL) {
        return NULL;
    }

    item->Prev = Parent;
    item->TypeIndex = TypeIndex;

    if (!supDuplicateUnicodeString(HeapHandle, &item->Name, Name)) {
        supHeapFreeEx(HeapHandle, item);
        return NULL;
    }

    if (!supDuplicateUnicodeString(HeapHandle, &item->TypeName, TypeName)) {
        supFreeDuplicatedUnicodeString(HeapHandle, &item->Name, FALSE);
        supHeapFreeEx(HeapHandle, item);
        return NULL;
    }

    return item;
}

/*
* GetNextSub
*
* Purpose:
*
* Returns next subitem in object full pathname.
*
*/
LPWSTR GetNextSub(
    _In_ _Notnull_ LPWSTR ObjectFullPathName,
    _Out_writes_(MAX_PATH + 1) LPWSTR Sub
)
{
    SIZE_T i;

    for (i = 0; (*ObjectFullPathName != 0) && (*ObjectFullPathName != L'\\')
        && (i < MAX_PATH); i++, ObjectFullPathName++)
    {
        Sub[i] = *ObjectFullPathName;
    }
    Sub[i] = 0;

    if (*ObjectFullPathName == L'\\')
        ObjectFullPathName++;

    return ObjectFullPathName;
}

/*
* ListToObject
*
* Purpose:
*
* Select and focus list view item by given object name.
*
*/
VOID ListToObject(
    _In_z_ LPWSTR ObjectName
)
{
    INT         i, iSelectedItem, listItemCount;
    HTREEITEM   lastfound, item;
    LPWSTR      pathPtr, nextPathPtr;
    LVITEM      lvitem;
    TVITEMEX    ritem;
    WCHAR       object[MAX_PATH + 1], sobject[MAX_PATH + 1];

    if (ObjectName == NULL)
        return;

    if (*ObjectName != L'\\')
        return;

    object[0] = 0;
    pathPtr = ObjectName + 1;
    item = TreeView_GetRoot(g_hwndObjectTree);
    lastfound = item;

    while ((item != NULL) && (*pathPtr != 0)) {

        item = TreeView_GetChild(g_hwndObjectTree, item);
        RtlSecureZeroMemory(object, sizeof(object));
        nextPathPtr = GetNextSub(pathPtr, object);

        while (item != NULL) {
            RtlSecureZeroMemory(&ritem, sizeof(ritem));
            RtlSecureZeroMemory(&sobject, sizeof(sobject));
            ritem.mask = TVIF_TEXT;
            ritem.hItem = item;
            ritem.cchTextMax = MAX_PATH;
            ritem.pszText = sobject;

            if (!TreeView_GetItem(g_hwndObjectTree, &ritem))
                break;

            if (_strcmpi(sobject, object) == 0) {
                lastfound = item;
                break;
            }

            item = TreeView_GetNextSibling(g_hwndObjectTree, item);
        }

        // Matching node found, continue with next path component
        if ((item != NULL) && (*nextPathPtr != 0)) {
            pathPtr = nextPathPtr;
            continue;
        }

        // Last component found, select it and return
        if ((item != NULL) && (*nextPathPtr == 0)) {
            TreeView_SelectItem(g_hwndObjectTree, lastfound);
            SetFocus(g_hwndObjectTree);
            return;
        }

        // Not found
        break;
    }

    TreeView_SelectItem(g_hwndObjectTree, lastfound);

    listItemCount = ListView_GetItemCount(g_hwndObjectList);
    for (i = 0; i < listItemCount; i++) {
        RtlSecureZeroMemory(&lvitem, sizeof(lvitem));
        RtlSecureZeroMemory(&sobject, sizeof(sobject));
        lvitem.mask = LVIF_TEXT;
        lvitem.iItem = i;
        lvitem.cchTextMax = MAX_PATH;
        lvitem.pszText = sobject;
        if (!ListView_GetItem(g_hwndObjectList, &lvitem))
            break;

        if (_strcmpi(sobject, object) == 0) {

            iSelectedItem = ListView_GetSelectionMark(g_hwndObjectList);
            lvitem.mask = LVIF_STATE;
            lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

            if (iSelectedItem >= 0) {
                lvitem.iItem = iSelectedItem;
                lvitem.state = 0;
                ListView_SetItem(g_hwndObjectList, &lvitem);
            }

            lvitem.iItem = i;
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            ListView_SetItem(g_hwndObjectList, &lvitem);
            ListView_EnsureVisible(g_hwndObjectList, i, FALSE);
            ListView_SetSelectionMark(g_hwndObjectList, i);
            SetFocus(g_hwndObjectList);
            return;
        }
    }
}

/*
* AddTreeViewItem
*
* Purpose:
*
* Add item to the tree view.
*
*/
HTREEITEM AddTreeViewItem(
    _In_ HANDLE HeapHandle,
    _In_ PUNICODE_STRING ItemName,
    _In_opt_ HTREEITEM Root,
    _Inout_opt_ OBEX_ITEM** Parent
)
{
    BOOL bNeedFree = FALSE;
    HTREEITEM result;
    TVINSERTSTRUCT treeItem;
    OBEX_ITEM* objectRef;
    UNICODE_STRING objectName;

    bNeedFree = supNormalizeUnicodeStringForDisplay(g_obexHeap,
        ItemName,
        &objectName);

    if (!bNeedFree)
        objectName = *ItemName;

    RtlSecureZeroMemory(&treeItem, sizeof(treeItem));
    treeItem.hParent = Root;
    treeItem.item.mask = TVIF_TEXT | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    if (Root == NULL) {
        treeItem.item.mask |= TVIF_STATE;
        treeItem.item.state = TVIS_EXPANDED;
        treeItem.item.stateMask = TVIS_EXPANDED;
    }

    treeItem.item.iSelectedImage = 1;

    treeItem.item.pszText = objectName.Buffer;

    objectRef = AllocateObjectItem(HeapHandle,
        ObjectTypeDirectory,
        ItemName,
        ObGetPredefinedUnicodeString(OBP_DIRECTORY),
        (Parent == NULL) ? NULL : *Parent);

    if (Parent) *Parent = objectRef;

    treeItem.item.lParam = (LPARAM)objectRef;

    result = TreeView_InsertItem(g_hwndObjectTree, &treeItem);
    if (result == NULL) {
        // Failed to insert item, clean up the allocated object
        if (objectRef != NULL) {
            supFreeDuplicatedUnicodeString(HeapHandle, &objectRef->Name, FALSE);
            supFreeDuplicatedUnicodeString(HeapHandle, &objectRef->TypeName, FALSE);
            supHeapFreeEx(HeapHandle, objectRef);
        }
        if (Parent) *Parent = NULL;
    }

    if (bNeedFree)
        supFreeUnicodeString(g_obexHeap, &objectName);

    return result;
}

/*
* AppendDirectoryPath
*
* Purpose:
*
* Helper function to construct full object path.
*
*/
BOOLEAN AppendDirectoryPath(
    _In_ PUNICODE_STRING DirectoryName,
    _In_ PUNICODE_STRING ObjectName,
    _Out_ PUNICODE_STRING FullPath
)
{
    SIZE_T pathLength, allocSize;
    PWCH target, source;

    // Calculate required buffer size
    pathLength = DirectoryName->Length;
    if (!supIsRootDirectory(DirectoryName))
        pathLength += OBJ_NAME_PATH_SEPARATOR_SIZE;

    pathLength += ObjectName->Length + sizeof(UNICODE_NULL);
    allocSize = pathLength;

    // Allocate buffer
    FullPath->Buffer = (PWSTR)supHeapAlloc(allocSize);
    if (!FullPath->Buffer)
        return FALSE;

    // Copy directory path
    target = FullPath->Buffer;
    source = DirectoryName->Buffer;
    RtlCopyMemory(target, source, DirectoryName->Length);
    target = (PWCH)RtlOffsetToPointer(target, DirectoryName->Length);

    // Add separator if not root
    if (!supIsRootDirectory(DirectoryName))
        *target++ = OBJ_NAME_PATH_SEPARATOR;

    // Copy object name
    RtlCopyMemory(target, ObjectName->Buffer, ObjectName->Length);
    target = (PWCH)RtlOffsetToPointer(target, ObjectName->Length);
    *target = UNICODE_NULL;

    // Set string properties
    FullPath->Length = (USHORT)(pathLength - sizeof(UNICODE_NULL));
    FullPath->MaximumLength = (USHORT)allocSize;

    return TRUE;
}

/*
* xxxListObjectDirectoryTree
*
* Purpose:
*
* List given directory to the treeview.
*
*/
VOID xxxListObjectDirectoryTree(
    _In_ HANDLE HeapHandle,
    _In_ PUNICODE_STRING SubDirName,
    _In_opt_ HANDLE RootHandle,
    _In_opt_ HTREEITEM ViewRootHandle,
    _In_opt_ OBEX_ITEM* Parent
)
{
    ULONG queryContext = 0, rLength;
    HANDLE directoryHandle = NULL;
    OBEX_ITEM* prevItem = Parent;

    POBJECT_DIRECTORY_INFORMATION directoryEntry;

    ViewRootHandle = AddTreeViewItem(HeapHandle, SubDirName, ViewRootHandle, &prevItem);
    if (ViewRootHandle == NULL)
        return;

    supOpenDirectoryEx(&directoryHandle, RootHandle, SubDirName, DIRECTORY_QUERY);
    if (directoryHandle == NULL) {
        return;
    }

    // Suspend tree redraw for batch operations
    supDisableRedraw(g_hwndObjectTree);

    __try {
        do {
            directoryEntry = ObQueryObjectDirectory(directoryHandle, &queryContext, g_WinObj.IsWine, &rLength);
            if (directoryEntry == NULL)
                break;

            if (RtlEqualUnicodeString(
                &directoryEntry->TypeName,
                ObGetPredefinedUnicodeString(OBP_DIRECTORY),
                TRUE))
            {
                xxxListObjectDirectoryTree(HeapHandle,
                    &directoryEntry->Name,
                    directoryHandle,
                    ViewRootHandle,
                    prevItem);
            }
            supHeapFree(directoryEntry);
        } while (TRUE);
    }
    __finally {
        NtClose(directoryHandle);
        supEnableRedraw(g_hwndObjectTree);
    }
}

/*
* ListObjectDirectoryTree
*
* Purpose:
*
* List given directory to the treeview.
*
*/
VOID ListObjectDirectoryTree(
    _In_ PUNICODE_STRING SubDirName,
    _In_opt_ HANDLE RootHandle,
    _In_opt_ HTREEITEM ViewRootHandle
)
{
    ListHeapCreate(&TreeObjectsHeap);
    if (TreeObjectsHeap)
        xxxListObjectDirectoryTree(TreeObjectsHeap, SubDirName, RootHandle, ViewRootHandle, NULL);
}

/*
* AddListViewItem
*
* Purpose:
*
* Add item to the object listview.
*
*/
VOID AddListViewItem(
    _In_ HANDLE HeapHandle,
    _In_ HANDLE RootDirectoryHandle,
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_ OBEX_ITEM* Parent
)
{
    BOOL bFound = FALSE, bNameAllocated;
    INT lvItemIndex;
    PWSTR objectTypeName;
    LVITEM lvItem;
    WCHAR szBuffer[MAX_PATH + 1];

    WOBJ_TYPE_DESC* typeDesc;
    OBEX_ITEM* objRef;
    UNICODE_STRING objectName, normalizedLinkTarget;

    objectTypeName = Entry->TypeName.Buffer;
    typeDesc = ObManagerGetEntryByTypeName(objectTypeName);

    bNameAllocated = supNormalizeUnicodeStringForDisplay(g_obexHeap,
        &Entry->Name,
        &objectName);

    if (!bNameAllocated)
        objectName = Entry->Name;

    //
    // Object name column.
    //
    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.pszText = objectName.Buffer;
    lvItem.iItem = MAXINT;
    lvItem.iImage = typeDesc->ImageIndex;

    objRef = AllocateObjectItem(HeapHandle,
        typeDesc->Index,
        &Entry->Name,
        &Entry->TypeName,
        Parent);

    lvItem.lParam = (LPARAM)objRef;
    lvItemIndex = ListView_InsertItem(g_hwndObjectList, &lvItem);

    //
    // Object type column.
    //
    lvItem.mask = LVIF_TEXT;
    lvItem.iSubItem = 1;
    lvItem.pszText = objectTypeName;
    lvItem.iItem = lvItemIndex;
    ListView_SetItem(g_hwndObjectList, &lvItem);

    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));

    // Special case for symbolic links as their link targets must be normalized before output.
    // Do not set bFound to TRUE so we will fall through the end of routine.
    if (typeDesc->NameHash == OBTYPE_HASH_SYMBOLIC_LINK) {

        if (supResolveSymbolicLinkTargetNormalized(
            NULL,
            RootDirectoryHandle,
            &Entry->Name,
            &normalizedLinkTarget))
        {
            lvItem.mask = LVIF_TEXT;
            lvItem.iSubItem = 2;
            lvItem.pszText = normalizedLinkTarget.Buffer;
            lvItem.iItem = lvItemIndex;
            ListView_SetItem(g_hwndObjectList, &lvItem);
            supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedLinkTarget, FALSE);
        }

    }
    else {
        // Look for object type in well known type names hashes.
        // If found - query information for additional description field.
        switch (typeDesc->NameHash) {
        case OBTYPE_HASH_SECTION:
            bFound = supQuerySectionFileInfo(RootDirectoryHandle,
                &Entry->Name,
                szBuffer,
                MAX_PATH);
            break;

        case OBTYPE_HASH_DRIVER:
            bFound = supQueryDriverDescription(objectName.Buffer,
                szBuffer,
                MAX_PATH);
            break;

        case OBTYPE_HASH_DEVICE:
            bFound = supQueryDeviceDescription(NULL,
                &Entry->Name,
                szBuffer,
                MAX_PATH);
            break;

        case OBTYPE_HASH_WINSTATION:
            bFound = supQueryWinstationDescription(objectName.Buffer,
                szBuffer,
                MAX_PATH);
            break;

        case OBTYPE_HASH_TYPE:
            bFound = supQueryTypeInfo(&Entry->Name,
                szBuffer,
                MAX_PATH,
                MAX_KNOWN_POOL_TYPES,
                a_PoolTypes);
            break;
        }
    }

    // Finally add information column if something found.
    if (bFound != FALSE) {
        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 2;
        lvItem.pszText = szBuffer;
        lvItem.iItem = lvItemIndex;
        ListView_SetItem(g_hwndObjectList, &lvItem);
    }

    if (bNameAllocated)
        supFreeUnicodeString(g_obexHeap, &objectName);
}

/*
* xxxListCurrentDirectoryObjects
*
* Purpose:
*
* List directory objects to the listview.
*
*/
VOID xxxListCurrentDirectoryObjects(
    _In_ HANDLE HeapHandle,
    _In_ OBEX_ITEM* Parent
)
{
    ULONG queryContext = 0, rLength;
    HANDLE directoryHandle = NULL;
    UNICODE_STRING usDirectoryName;

    POBJECT_DIRECTORY_INFORMATION infoBuffer;

    ListView_DeleteAllItems(g_hwndObjectList);

    if (supGetCurrentObjectPath(TRUE, &usDirectoryName)) {
        supOpenDirectoryEx(&directoryHandle, NULL, &usDirectoryName, DIRECTORY_QUERY);
        supFreeDuplicatedUnicodeString(g_obexHeap, &usDirectoryName, FALSE);
    }

    if (directoryHandle == NULL)
        return;

    supDisableRedraw(g_hwndObjectList);

    do {
        infoBuffer = ObQueryObjectDirectory(directoryHandle, &queryContext, g_WinObj.IsWine, &rLength);
        if (infoBuffer) {
            AddListViewItem(HeapHandle, directoryHandle, infoBuffer, Parent);
            supHeapFree(infoBuffer);
        }
        else {
            break;
        }
    } while (TRUE);

    supEnableRedraw(g_hwndObjectList);

    NtClose(directoryHandle);
}

/*
* ListCurrentDirectoryObjects
*
* Purpose:
*
* List directory objects to the listview.
*
*/
VOID ListCurrentDirectoryObjects(
    _In_ HTREEITEM ViewRootHandle
)
{
    OBEX_ITEM* objRef = NULL;

    ListHeapCreate(&ListObjectsHeap);
    if (ListObjectsHeap) {

        if (supGetTreeViewItemParam(g_hwndObjectTree,
            ViewRootHandle,
            (PVOID*)&objRef))
        {
            xxxListCurrentDirectoryObjects(ListObjectsHeap, objRef);
        }

    }
}

/*
* AllocateFoundItem
*
* Purpose:
*
* Allocate item for search dialog results.
*
*/
PFO_LIST_ITEM AllocateFoundItem(
    _In_ PFO_LIST_ITEM Previous,
    _In_ PUNICODE_STRING DirectoryName,
    _In_ POBJECT_DIRECTORY_INFORMATION InfoBuffer
)
{
    PFO_LIST_ITEM Item;
    SIZE_T BufferLength;
    UNICODE_STRING fullPath;

    // Calculate the full objectname path and store it in fullPath
    RtlInitEmptyUnicodeString(&fullPath, NULL, 0);
    if (!AppendDirectoryPath(DirectoryName, &InfoBuffer->Name, &fullPath)) {
        return NULL;
    }

    // Allocate memory for the item structure and string data
    BufferLength = sizeof(FO_LIST_ITEM) +
        fullPath.MaximumLength +
        InfoBuffer->TypeName.Length + sizeof(UNICODE_NULL);

    Item = (PFO_LIST_ITEM)supHeapAlloc(BufferLength);
    if (Item == NULL) {
        supHeapFree(fullPath.Buffer);
        return NULL;
    }

    // Setup the item
    Item->Prev = Previous;

    // Set up the ObjectName
    Item->ObjectName.Buffer = (PWSTR)Item->NameBuffer;
    Item->ObjectName.Length = fullPath.Length;
    Item->ObjectName.MaximumLength = fullPath.MaximumLength;
    RtlCopyMemory(Item->ObjectName.Buffer, fullPath.Buffer, fullPath.Length);
    Item->ObjectName.Buffer[fullPath.Length / sizeof(WCHAR)] = UNICODE_NULL;

    // Set up the ObjectType
    Item->ObjectType.Buffer = (PWSTR)(Item->NameBuffer + (fullPath.MaximumLength / sizeof(WCHAR)));
    Item->ObjectType.Length = InfoBuffer->TypeName.Length;
    Item->ObjectType.MaximumLength = InfoBuffer->TypeName.Length + sizeof(UNICODE_NULL);
    RtlCopyMemory(Item->ObjectType.Buffer, InfoBuffer->TypeName.Buffer, InfoBuffer->TypeName.Length);
    Item->ObjectType.Buffer[InfoBuffer->TypeName.Length / sizeof(WCHAR)] = UNICODE_NULL;

    // Free temporary buffer
    supHeapFree(fullPath.Buffer);

    return Item;
}

/*
* FindObject
*
* Purpose:
*
* Find object by given name in object directory.
*
*/
VOID FindObject(
    _In_ PUNICODE_STRING DirectoryName,
    _In_opt_ PUNICODE_STRING NameSubstring,
    _In_opt_ PUNICODE_STRING TypeName,
    _In_ PFO_LIST_ITEM* List
)
{
    ULONG ctx, rlen;
    HANDLE directoryHandle = NULL;

    PFO_LIST_ITEM item;
    UNICODE_STRING subDirectory;

    POBJECT_DIRECTORY_INFORMATION infoBuffer;

    supOpenDirectoryEx(&directoryHandle, NULL, DirectoryName, DIRECTORY_QUERY);
    if (directoryHandle == NULL)
        return;

    ctx = 0;
    do {
        infoBuffer = ObQueryObjectDirectory(directoryHandle, &ctx, g_WinObj.IsWine, &rlen);
        if (!infoBuffer)
            break;

        if (TypeName) {
            if (RtlEqualUnicodeString(&infoBuffer->TypeName, TypeName, TRUE)) {
                if (NameSubstring) {
                    if (ULLONG_MAX != supFindUnicodeStringSubString(&infoBuffer->Name, NameSubstring)) {
                        item = AllocateFoundItem(*List, DirectoryName, infoBuffer);
                        if (item) *List = item;
                    }
                }
                else {
                    item = AllocateFoundItem(*List, DirectoryName, infoBuffer);
                    if (item) *List = item;
                }
            }
        }
        else if (NameSubstring) {
            // Only name substring specified - check for substring
            if (ULLONG_MAX != supFindUnicodeStringSubString(&infoBuffer->Name, NameSubstring)) {
                item = AllocateFoundItem(*List, DirectoryName, infoBuffer);
                if (item) *List = item;
            }
        }
        else {
            // No filter specified - add all objects
            item = AllocateFoundItem(*List, DirectoryName, infoBuffer);
            if (item) *List = item;
        }

        // If this is directory, go inside.
        RtlInitEmptyUnicodeString(&subDirectory, NULL, 0);
        if (RtlEqualUnicodeString(&infoBuffer->TypeName,
            ObGetPredefinedUnicodeString(OBP_DIRECTORY),
            TRUE))
        {
            if (AppendDirectoryPath(DirectoryName, &infoBuffer->Name, &subDirectory)) {
                FindObject(&subDirectory, NameSubstring, TypeName, List);
                supHeapFree(subDirectory.Buffer);
                subDirectory.Buffer = NULL;
            }
        }

        supHeapFree(infoBuffer);

    } while (TRUE);

    NtClose(directoryHandle);
}

```

`Source/WinObjEx64/list.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       LIST.H
*
*  VERSION:     2.09
*
*  DATE:        19 Aug 2025
*
*  Common header file for the program object listing logic.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef	struct _FO_LIST_ITEM {
    struct _FO_LIST_ITEM *Prev;
    UNICODE_STRING ObjectName;
    UNICODE_STRING ObjectType;
    WCHAR NameBuffer[2];
} FO_LIST_ITEM, *PFO_LIST_ITEM;

typedef struct _OBEX_ITEM {
    struct _OBEX_ITEM *Prev;
    WOBJ_OBJECT_TYPE TypeIndex;
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBEX_ITEM, * POBEX_ITEM;

typedef struct _OBEX_PATH_ELEMENT {
    LIST_ENTRY ListEntry;
    WOBJ_OBJECT_TYPE TypeIndex;
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBEX_PATH_ELEMENT, * POBEX_PATH_ELEMENT;

VOID ListHeapDestroy(
    VOID);

VOID ListToObject(
    _In_z_ LPWSTR ObjectName);

VOID ListObjectDirectoryTree(
    _In_ PUNICODE_STRING SubDirName,
    _In_opt_ HANDLE RootHandle,
    _In_opt_ HTREEITEM ViewRootHandle);

VOID FindObject(
    _In_ PUNICODE_STRING DirectoryName,
    _In_opt_ PUNICODE_STRING NameSubstring,
    _In_opt_ PUNICODE_STRING TypeName,
    _In_ PFO_LIST_ITEM *List);

VOID ListCurrentDirectoryObjects(
    _In_ HTREEITEM ViewRootHandle);

```

`Source/WinObjEx64/log/log.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       LOG.C
*
*  VERSION:     2.09
*
*  DATE:        20 Aug 2025
*
*  Simplified log.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

//
// Map entry type to text and highlight flag.
//
typedef struct _LOG_TYPE_MAP {
    WOBJ_ENTRY_TYPE Type;
    LPCWSTR TypeText;
    BOOL Highlight;
} LOG_TYPE_MAP;

static const LOG_TYPE_MAP g_LogTypeMap[] = {
    { EntryTypeError, L"Error", TRUE },
    { EntryTypeSuccess, L"Success", FALSE },
    { EntryTypeInformation, L"Information", FALSE },
    { EntryTypeWarning, L"Warning", TRUE }
};

static WOBJ_LOG g_WinObjLog;

/*
* logCreate
*
* Purpose:
*
* Initialize log structure.
*
*/
VOID logCreate()
{
    RtlSecureZeroMemory(&g_WinObjLog, sizeof(g_WinObjLog));
    InitializeCriticalSection(&g_WinObjLog.Lock);
    g_WinObjLog.LockInitialized = TRUE;

    g_WinObjLog.Entries = (WOBJ_LOG_ENTRY*)supVirtualAlloc(
        sizeof(WOBJ_LOG_ENTRY) * WOBJ_MAX_LOG_CAPACITY);
    if (g_WinObjLog.Entries) {
        g_WinObjLog.Initialized = TRUE;
        logAdd(EntryTypeInformation, TEXT("Program startup, log created"));
    }
}

/*
* logFree
*
* Purpose:
*
* Destroy log.
*
*/
VOID logFree()
{
    if (!g_WinObjLog.LockInitialized)
        return;

    EnterCriticalSection(&g_WinObjLog.Lock);
    g_WinObjLog.Initialized = FALSE;
    if (g_WinObjLog.Entries) {
        supVirtualFree(g_WinObjLog.Entries);
        g_WinObjLog.Entries = NULL;
    }
    g_WinObjLog.Count = 0;
    g_WinObjLog.TotalWritten = 0;
    LeaveCriticalSection(&g_WinObjLog.Lock);
    DeleteCriticalSection(&g_WinObjLog.Lock);
    g_WinObjLog.LockInitialized = FALSE;
}

/*
* logAdd
*
* Purpose:
*
* Add entry to log.
*
* N.B. If entry count exceeds log capacity log will be overwritten.
*
*/
VOID logAdd(
    _In_ WOBJ_ENTRY_TYPE EntryType,
    _In_ const WCHAR* Message
)
{
    ULONG Index;

    if (!g_WinObjLog.LockInitialized)
        return;

    EnterCriticalSection(&g_WinObjLog.Lock);

    if (g_WinObjLog.Initialized) {

        Index = g_WinObjLog.Count;

        g_WinObjLog.Entries[Index].Type = EntryType;
        GetSystemTimeAsFileTime((PFILETIME)&g_WinObjLog.Entries[Index].LoggedTime); //-V1027
        _strncpy(g_WinObjLog.Entries[Index].MessageData,
            WOBJ_MAX_MESSAGE,
            Message ? Message : L"(null)",
            WOBJ_MAX_MESSAGE);

        Index += 1;
        if (Index >= WOBJ_MAX_LOG_CAPACITY)
            Index = 0;

        g_WinObjLog.Count = Index;
        g_WinObjLog.TotalWritten++;
    }

    LeaveCriticalSection(&g_WinObjLog.Lock);
}

/*
* logEnumEntries
*
* Purpose:
*
* Enumerate log entries.
*
*/
BOOL logEnumEntries(
    _In_ PLOGENUMERATECALLBACK EnumCallback,
    _In_ PVOID CallbackContext
)
{
    ULONG i, start, idx, cap, logicalCount;
    BOOL bResult = FALSE;

    if (EnumCallback == NULL)
        return FALSE;

    if (!g_WinObjLog.LockInitialized)
        return FALSE;

    __try {
        EnterCriticalSection(&g_WinObjLog.Lock);
        if (g_WinObjLog.Initialized && g_WinObjLog.Entries) {
            cap = WOBJ_MAX_LOG_CAPACITY;

            if (g_WinObjLog.TotalWritten < cap) {
                logicalCount = g_WinObjLog.Count;
                start = 0;
            }
            else {
                logicalCount = cap;
                start = g_WinObjLog.Count; // oldest entry index when wrapped
            }

            for (i = 0; i < logicalCount; i++) {
                idx = (start + i) % cap;
                if (!EnumCallback(&g_WinObjLog.Entries[idx], CallbackContext))
                    break;
            }
        }
        bResult = TRUE;
    }
    __finally {
        LeaveCriticalSection(&g_WinObjLog.Lock);
    }

    return bResult;
}

/*
* LogViewerPrintEntry
*
* Purpose:
*
* Output entry to richedit.
*
*/
VOID LogViewerPrintEntry(
    _In_ HWND hwndRichEdit,
    _In_ LPWSTR lpMessage,
    _In_ BOOL bHighlight)
{
    LONG startPos, endPos;
    CHARFORMAT format;
    CHARRANGE range;

    // Move caret to end
    range.cpMax = range.cpMin = INT_MAX;
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&range);

    // Insert newline if not the first line
    if (SendMessage(hwndRichEdit, WM_GETTEXTLENGTH, 0, 0) > 0)
        SendMessage(hwndRichEdit, EM_REPLACESEL, 0, (LPARAM)L"\r\n");

    // After inserting newline, get start position for new entry
    SendMessage(hwndRichEdit, EM_EXGETSEL, 0, (LPARAM)&range);
    startPos = range.cpMin;

    // Insert the message
    SendMessage(hwndRichEdit, EM_REPLACESEL, 0, (LPARAM)lpMessage);

    // Get end position after message insertion
    SendMessage(hwndRichEdit, EM_EXGETSEL, 0, (LPARAM)&range);
    endPos = range.cpMin;

    // Select just inserted message
    range.cpMin = startPos;
    range.cpMax = endPos;
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&range);

    // Apply formatting (bold when highlight requested)
    RtlSecureZeroMemory(&format, sizeof(format));
    format.cbSize = sizeof(format);
    format.dwMask = CFM_BOLD;
    format.dwEffects = bHighlight ? CFE_BOLD : 0;
    SendMessage(hwndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&format);
}

/*
* LogViewerAddEntryCallback
*
* Purpose:
*
* Log entry enumeration callback.
*
*/
BOOL CALLBACK LogViewerAddEntryCallback(
    _In_ WOBJ_LOG_ENTRY* Entry,
    _In_ PVOID CallbackContext
)
{
    BOOL bHighlight = FALSE, found = FALSE;
    SIZE_T j;
    HWND hwndList = (HWND)CallbackContext;
    TIME_FIELDS tFields = { 0, 0, 0, 0, 0, 0, 0, 0 };
    LPWSTR lpType = L"Unspecified";
    WCHAR szMessage[WOBJ_MAX_MESSAGE + 128];

    for (j = 0; j < RTL_NUMBER_OF(g_LogTypeMap); j++) {
        if (g_LogTypeMap[j].Type == Entry->Type) {
            lpType = (LPWSTR)g_LogTypeMap[j].TypeText;
            bHighlight = g_LogTypeMap[j].Highlight;
            found = TRUE;
            break;
        }
    }
    if (!found) {
        bHighlight = FALSE;
    }

    szMessage[0] = 0;

    RtlTimeToTimeFields(&Entry->LoggedTime, &tFields);
    RtlStringCchPrintfSecure(szMessage,
        RTL_NUMBER_OF(szMessage),
        L"%02hd:%02hd:%02hd.%03hd (%ws): %ws",
        tFields.Hour,
        tFields.Minute,
        tFields.Second,
        tFields.Milliseconds,
        lpType,
        Entry->MessageData);

    LogViewerPrintEntry(hwndList, szMessage, bHighlight);

    return TRUE; //continue with next entry
}

/*
* LogViewerListLog
*
* Purpose:
*
* Ouput log entries.
*
*/
VOID LogViewerListLog(
    _In_ HWND hwndParent
)
{
    CHARRANGE charRange;
    HWND hwndList = GetDlgItem(hwndParent, IDC_LOGLIST);
    PARAFORMAT ParaFormat;

    //
    // Prepare RichEdit.
    //
    SendMessage(hwndList, EM_SETEVENTMASK, (WPARAM)0, (LPARAM)0);
    SendMessage(hwndList, WM_SETREDRAW, (WPARAM)0, (LPARAM)0);

    RtlSecureZeroMemory(&ParaFormat, sizeof(ParaFormat));
    ParaFormat.cbSize = sizeof(ParaFormat);
    ParaFormat.cTabCount = 1;
    ParaFormat.dwMask = PFM_TABSTOPS;
    ParaFormat.rgxTabs[0] = 3500;
    SendMessage(hwndList, EM_SETPARAFORMAT, (WPARAM)0, (LPARAM)&ParaFormat);

    logEnumEntries(LogViewerAddEntryCallback, (PVOID)hwndList);

    //
    // End work with RichEdit.
    //

    SendMessage(hwndList, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
    InvalidateRect(hwndList, NULL, TRUE);

    SendMessage(hwndList, EM_SETEVENTMASK, (WPARAM)0, (LPARAM)ENM_SELCHANGE);

    charRange.cpMax = 0;
    charRange.cpMin = 0;
    SendMessage(hwndList, EM_EXSETSEL, (WPARAM)0, (LPARAM)&charRange);
}

/*
* LogViewerCopyToClipboard
*
* Purpose:
*
* Copy log entries to the clipboard.
*
*/
VOID LogViewerCopyToClipboard(
    _In_ HWND hwndDlg
)
{
    SIZE_T BufferSizeChars, AllocSize;
    PWCHAR Buffer = NULL;

    GETTEXTLENGTHEX gtl;
    GETTEXTEX gt;

    HWND hwndControl = GetDlgItem(hwndDlg, IDC_LOGLIST);

    gtl.flags = GTL_USECRLF;
    gtl.codepage = 1200;

    BufferSizeChars = SendMessage(hwndControl, EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0);
    if (BufferSizeChars) {
        AllocSize = (BufferSizeChars + 1) * sizeof(WCHAR);
        Buffer = (PWCHAR)supHeapAlloc(AllocSize);
        if (Buffer) {

            gt.flags = GT_USECRLF;
            gt.cb = (ULONG)AllocSize;

            gt.codepage = 1200;
            gt.lpDefaultChar = NULL;
            gt.lpUsedDefChar = NULL;
            SendMessage(hwndControl, EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)Buffer);

            Buffer[BufferSizeChars] = L'\0';

            supClipboardCopy(Buffer, AllocSize);

            supHeapFree(Buffer);
        }
    }
}

/*
* LogViewerDialogProc
*
* Purpose:
*
* LogViewer Dialog Window Dialog Procedure
*
* During WM_INITDIALOG centers window and initializes with current log entries.
*
*/
INT_PTR CALLBACK LogViewerDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        supCenterWindow(hwndDlg);
        LogViewerListLog(hwndDlg);
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            return EndDialog(hwndDlg, S_OK);
        case ID_OBJECT_COPY:
            LogViewerCopyToClipboard(hwndDlg);
            break;
        }

    }
    return 0;
}

/*
* LogViewerShowDialog
*
* Purpose:
*
* Create and show log viewer window.
*
*/
VOID LogViewerShowDialog(
    _In_ HWND hwndParent)
{
    if (!supRichEdit32Load()) {
        MessageBox(hwndParent, TEXT("Could not load RichEdit library"), NULL, MB_ICONERROR);
        return;
    }

    DialogBoxParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_LOGVIEWER),
        hwndParent,
        (DLGPROC)&LogViewerDialogProc,
        0);
}

```

`Source/WinObjEx64/log/log.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       LOG.H
*
*  VERSION:     2.09
*
*  DATE:        13 Aug 2025
*
*  Header file for simplified log support.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef enum _WOBJ_ENTRY_TYPE {
    EntryTypeError = 0,
    EntryTypeSuccess,
    EntryTypeInformation,
    EntryTypeWarning,
    EntryTypeMax
} WOBJ_ENTRY_TYPE;

//
// Maximum messages in log.
//
#define WOBJ_MAX_LOG_CAPACITY 4096

//
// Maximum length of message in log.
//
#define WOBJ_MAX_MESSAGE 2000

typedef struct _WOBJ_LOG_ENTRY {
    WOBJ_ENTRY_TYPE Type;
    LARGE_INTEGER LoggedTime;
    WCHAR MessageData[WOBJ_MAX_MESSAGE];
    BYTE Reserved[74];
} WOBJ_LOG_ENTRY, * PWOBJ_LOG_ENTRY;

typedef struct _WOBJ_LOG {
    BOOL Initialized;
    BOOL LockInitialized;
    ULONG Count;
    ULONGLONG TotalWritten;
    CRITICAL_SECTION Lock;
    WOBJ_LOG_ENTRY *Entries;
} WOBJ_LOG, * PWOBJ_LOG;

typedef BOOL(CALLBACK* PLOGENUMERATECALLBACK)(
    _In_ WOBJ_LOG_ENTRY *Entry,
    _In_ PVOID CallbackContext);

VOID logCreate();
VOID logFree();

VOID logAdd(
    _In_ WOBJ_ENTRY_TYPE EntryType,
    _In_ const WCHAR* Message);

BOOL logEnumEntries(
    _In_ PLOGENUMERATECALLBACK EnumCallback,
    _In_ PVOID CallbackContext);

VOID LogViewerShowDialog(
    _In_ HWND hwndParent);

```

`Source/WinObjEx64/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       MAIN.C
*
*  VERSION:     2.10
*
*  DATE:        20 Nov 2025
*
*  Program entry point and main window handler.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#define OEMRESOURCE
#include "global.h"
#include "treelist/treelist.h"
#include "props/propDlg.h"
#include "extras/extras.h"

#define MAINWND_TRACKSIZE_MIN_X 400
#define MAINWND_TRACKSIZE_MIN_Y 256

pswprintf_s _swprintf_s;
pqsort _qsort;

static LONG	g_SplitterPos = 180;
static LONG	g_SortColumn = 0;

HTREEITEM ObjectTreeSelectedItem;
BOOL bMainWndSortInverse = FALSE;

//
// Global UI variables.
//
WINOBJ_GLOBALS g_WinObj;

// Global stats
WINOBJ_STATS g_WinObjStats;

/*
* guiExtrasDisableAdminFeatures
*
* Purpose:
*
* Disable menu items require admin privileges.
*
*/
VOID guiExtrasDisableAdminFeatures(
    _In_ HWND hWnd
)
{
    HICON hIcon;
    HMENU hExtrasSubMenu = GetSubMenu(GetMenu(hWnd), IDMM_EXTRAS);

    MENUITEMINFO mii;

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE;
    mii.fState = MFS_DISABLED;

    //
    // These features are not unsupported in Wine.
    //
    if (g_WinObj.IsWine) {
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_CALLBACKS, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_DRIVERS, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_UNLOADEDDRIVERS, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_PRIVATENAMESPACES, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_SOFTWARELICENSECACHE, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_SSDT, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_W32PSERVICETABLE, FALSE, &mii);
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_CMCONTROLVECTOR, FALSE, &mii);
        return;
    }

    //
    // Elevated launch.
    //
    if (g_kdctx.IsFullAdmin) {

        //
        // This feature is not supported in Windows 10 10586.
        //
        if (g_NtBuildNumber == NT_WIN10_THRESHOLD2) {
            SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_PRIVATENAMESPACES, FALSE, &mii);
        }

    }
    else {
        //
        // Non elevated launch set shield icon.
        //
        hIcon = supGetStockIcon(SIID_SHIELD, SHGSI_ICON | SHGFI_SMALLICON);
        if (hIcon) {
            supSetMenuIcon(hExtrasSubMenu, ID_EXTRAS_SSDT, hIcon);
            supSetMenuIcon(hExtrasSubMenu, ID_EXTRAS_PRIVATENAMESPACES, hIcon);
            supSetMenuIcon(hExtrasSubMenu, ID_EXTRAS_CALLBACKS, hIcon);
            supSetMenuIcon(hExtrasSubMenu, ID_EXTRAS_UNLOADEDDRIVERS, hIcon);
            if (g_NtBuildNumber > NT_WIN11_22H2) {
                supSetMenuIcon(hExtrasSubMenu, ID_EXTRAS_W32PSERVICETABLE, hIcon);
                supSetMenuIcon(hExtrasSubMenu, ID_EXTRAS_DRIVERS, hIcon);
            }
        }

    }

    //
    // This feature is only supported starting from Windows 10 14393 (RS1).
    //
    if (g_NtBuildNumber < NT_WIN10_REDSTONE1) {
        SetMenuItemInfo(hExtrasSubMenu, ID_EXTRAS_W32PSERVICETABLE, FALSE, &mii);
    }
}

/*
* MainWindowObjectListCompareFunc
*
* Purpose:
*
* Main window listview comparer function.
*
*/
INT CALLBACK MainWindowObjectListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort
)
{
    return supListViewBaseComparer(g_hwndObjectList,
        bMainWndSortInverse,
        lParam1,
        lParam2,
        lParamSort);
}

/*
* MainWindowHandleObjectViewSD
*
* Purpose:
*
* Handler for View Security Descriptor menu.
*
*/
VOID MainWindowHandleObjectViewSD(
    _In_ BOOL fList
)
{
    OBEX_ITEM* objRef;
    WOBJ_OBJECT_TYPE wobjType = ObjectTypeUnknown;

    if (fList) {

        if (supGetListViewItemParam(g_hwndObjectList,
            ListView_GetSelectionMark(g_hwndObjectList),
            (PVOID*)&objRef))
        {

            if (objRef)
                wobjType = objRef->TypeIndex;

        }

    }
    else {
        wobjType = ObjectTypeDirectory;
    }

    SDViewDialogCreate(wobjType);

}

/*
* MainWindowCopyObjectName
*
* Purpose:
*
* Handler for Copy Name / Copy Name (Bin) menu.
*
*/
VOID MainWindowCopyObjectName(
    _In_ UINT ControlId
)
{
    INT nSelected;
    OBEX_ITEM* objRef = NULL;
    HWND hwndFocus;

    UNICODE_STRING normalizedName;

    hwndFocus = GetFocus();
    if (hwndFocus != g_hwndObjectList &&
        hwndFocus != g_hwndObjectTree)
    {
        return;
    }

    if (hwndFocus == g_hwndObjectList) {
        
        nSelected = ListView_GetSelectionMark(g_hwndObjectList);
        if (nSelected >= 0) {
            if (!supGetListViewItemParam(g_hwndObjectList, nSelected, (PVOID*)&objRef))
                return;
        }

    }
    else {

        if (ObjectTreeSelectedItem) {
            if (!supGetTreeViewItemParam(g_hwndObjectTree, ObjectTreeSelectedItem, (PVOID*)&objRef))
                return;
        }

    }

    if (objRef == NULL)
        return;

    if (ControlId == ID_OBJECT_COPY_NAME) {
        if (supNormalizeUnicodeStringForDisplay(g_obexHeap,
            &objRef->Name,
            &normalizedName))
        {
            supClipboardCopy(normalizedName.Buffer, normalizedName.Length);
            supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedName, FALSE);
        }
    }
    else {
        supClipboardCopyUnicodeStringRaw(&objRef->Name);
    }
}

/*
* MainWindowShowObjectProperties
*
* Purpose:
*
* Display properties dialog for a selected item.
*
*/
VOID MainWindowShowObjectProperties(
    _In_ HWND hwnd
)
{
    INT nSelected;
    HWND hwndFocus;
    OBEX_ITEM* objRef = NULL;
    PROP_CONFIG propConfig;
    UNICODE_STRING objectPath;

    hwndFocus = GetFocus();
    if (hwndFocus != g_hwndObjectList &&
        hwndFocus != g_hwndObjectTree)
    {
        return;
    }

    //
    // Get current object path.
    //
    if (!supGetCurrentObjectPath(FALSE, &objectPath))
        return;

    //
    // Only one object properties dialog allowed at same time.
    //
    supCloseKnownPropertiesDialog(propGetCommonWindow());

    if (hwndFocus == g_hwndObjectList) {

        //
        // Query selected index, leave on failure.
        //
        nSelected = ListView_GetSelectionMark(g_hwndObjectList);
        if (nSelected >= 0) {
            supGetListViewItemParam(g_hwndObjectList, nSelected, (PVOID*)&objRef);
        }

    }
    else {

        if (ObjectTreeSelectedItem) {
            supGetTreeViewItemParam(g_hwndObjectTree, ObjectTreeSelectedItem, (PVOID*)&objRef);
        }
    }

    if (objRef) {
        RtlSecureZeroMemory(&propConfig, sizeof(propConfig));
        propConfig.hwndParent = hwnd;
        propConfig.ObjectTypeIndex = objRef->TypeIndex;
        propConfig.NtObjectName = &objRef->Name;
        propConfig.NtObjectPath = &objectPath;
        propCreateDialog(&propConfig);
    }

    supFreeUnicodeString(g_obexHeap, &objectPath);
}

/*
* MainWindowOnRefresh
*
* Purpose:
*
* Main Window Refresh handler.
*
*/
VOID MainWindowOnRefresh(
    VOID
)
{
    BOOL bOkay;
    UNICODE_STRING currentPath, normalizedPath;

    supSetWaitCursor(TRUE);

    supFreeSCMSnapshot(NULL);
    sapiFreeSnapshot();

    supCreateSCMSnapshot(SERVICE_DRIVER, NULL);
    sapiCreateSetupDBSnapshot();

    bOkay = supGetCurrentObjectPath(TRUE, &currentPath);

    TreeView_DeleteAllItems(g_hwndObjectTree);
    ListObjectDirectoryTree(ObGetPredefinedUnicodeString(OBP_ROOT), NULL, NULL);

    if (bOkay) {
        if (supNormalizeUnicodeStringForDisplay(g_obexHeap,
            &currentPath,
            &normalizedPath))
        {
            ListToObject(normalizedPath.Buffer);
            supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedPath, FALSE);
        }
        supFreeDuplicatedUnicodeString(g_obexHeap, &currentPath, FALSE);
    }

    supSetWaitCursor(FALSE);
}

/*
* MainWindowEnumWndProc
*
* Purpose:
*
* Settings update enum callback.
*
*/
BOOL CALLBACK MainWindowEnumWndProc(
    _In_ HWND hwnd,
    _In_ LPARAM lParam
)
{
    DWORD dwProcessId;
    DWORD dwCurrentProcessId = (DWORD)lParam;

    if (GetWindowThreadProcessId(hwnd, &dwProcessId)) {
        if (dwProcessId == dwCurrentProcessId)
            PostMessage(hwnd, g_WinObj.SettingsChangeMessage, 0, 0);
    }
    return TRUE;
}

/*
* MainWindowOnDisplayGridChange
*
* Purpose:
*
* Handle listview grid settings change and broadcast it to all WinObjEx64 sub dialogs.
*
*/
VOID MainWindowOnDisplayGridChange(
    VOID
)
{
    DWORD lvExStyle;
    DWORD dwProcessId = GetCurrentProcessId();
    g_WinObj.ListViewDisplayGrid = (~g_WinObj.ListViewDisplayGrid) & 1;
    lvExStyle = ListView_GetExtendedListViewStyle(g_hwndObjectList);
    if (g_WinObj.ListViewDisplayGrid)
        lvExStyle |= LVS_EX_GRIDLINES;
    else
        lvExStyle &= ~LVS_EX_GRIDLINES;

    ListView_SetExtendedListViewStyle(g_hwndObjectList, lvExStyle);

    EnumWindows((WNDENUMPROC)MainWindowEnumWndProc, (LPARAM)dwProcessId);
}

/*
* MainWindowHandleGotoLinkTarget
*
* Purpose:
*
* Resolve symbolic link target and select it in winobjex window.
*
*/
VOID MainWindowHandleGotoLinkTarget(
    VOID
)
{
    UNICODE_STRING linkName, linkTarget, normalizedLinkTarget;

    if (!supGetCurrentObjectPath(TRUE, &linkName))
        return;

    // Global??
    if (RtlEqualUnicodeString(&linkName,
        ObGetPredefinedUnicodeString(OBP_GLOBAL),
        TRUE))
    {
        ListToObject(KM_OBJECTS_ROOT_DIRECTORY);
    }

    if (supResolveSymbolicLinkTarget(NULL, NULL, &linkName, &linkTarget)) {

        //
        // Check against \\GLOBAL??
        //
        if (RtlEqualUnicodeString(&linkTarget,
            ObGetPredefinedUnicodeString(OBP_GLOBALNAMESPACE),
            TRUE))
        {
            // DosDevices
            ListToObject(L"\\GLOBAL??");
        }
        else {

            //
            // Usual link, prepare it for output and do the listing.
            //
            if (supNormalizeUnicodeStringForDisplay(g_obexHeap,
                &linkTarget,
                &normalizedLinkTarget))
            {
                ListToObject(normalizedLinkTarget.Buffer);
                supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedLinkTarget, FALSE);
            }
        }

        supFreeDuplicatedUnicodeString(g_obexHeap, &linkTarget, FALSE);
    }

    supFreeDuplicatedUnicodeString(g_obexHeap, &linkName, FALSE);
}

/*
* MainWindowHandleWMCommand
*
* Purpose:
*
* Main window WM_COMMAND handler.
*
*/
LRESULT MainWindowHandleWMCommand(
    _In_ HWND hwnd,
    _In_ WPARAM wParam
)
{
    WORD ControlId = LOWORD(wParam);

    switch (ControlId) {

    case ID_FILE_RUNASADMIN:
        if (g_kdctx.IsFullAdmin) {
            supRunAsLocalSystem(hwnd);
        }
        else {
            supRunAsAdmin();
        }
        break;

    case ID_FILE_EXIT:
        PostQuitMessage(0);
        break;

    case ID_FILE_VIEW_PLUGINS:
        PmViewPlugins();
        break;

    case ID_OBJECT_PROPERTIES:
        MainWindowShowObjectProperties(hwnd);
        break;

    case ID_OBJECT_COPY_NAME:
    case ID_OBJECT_COPY_NAME_BINARY:
        MainWindowCopyObjectName(ControlId);
        break;

    case ID_OBJECT_GOTOLINKTARGET:

        MainWindowHandleGotoLinkTarget();
        break;

    case ID_VIEW_SECURITYDESCRIPTOR:
        MainWindowHandleObjectViewSD((GetFocus() == g_hwndObjectList));
        break;

    case ID_FIND_FINDOBJECT:
        FindDlgCreate();
        break;

    case ID_VIEW_REFRESH:
        MainWindowOnRefresh();
        break;

    case ID_VIEW_DISPLAYGRID:
        MainWindowOnDisplayGridChange();
        break;

    case ID_EXTRAS_PIPES:
    case ID_EXTRAS_MAILSLOTS:
    case ID_EXTRAS_USERSHAREDDATA:
    case ID_EXTRAS_PRIVATENAMESPACES:
    case ID_EXTRAS_SSDT:
    case ID_EXTRAS_W32PSERVICETABLE:
    case ID_EXTRAS_DRIVERS:
    case ID_EXTRAS_UNLOADEDDRIVERS:
    case ID_EXTRAS_PROCESSLIST:
    case ID_EXTRAS_CALLBACKS:
    case ID_EXTRAS_SOFTWARELICENSECACHE:
    case ID_EXTRAS_CMCONTROLVECTOR:
        //
        // Extras -> Pipes
        //           Mailslots
        //           UserSharedData
        //           Private Namespaces
        //           KiServiceTable
        //           W32pServiceTable
        //           Drivers
        //           Unloaded Drivers
        //           Process List
        //           Callbacks
        //           Software Licensing Cache
        //           CmControlVector
        //
        extrasShowDialogById(ControlId);
        break;

    case ID_HELP_STATISTICS:
        ShowStatsDialog();
        break;

    case ID_HELP_ABOUT:

        DialogBoxParam(
            g_WinObj.hInstance,
            MAKEINTRESOURCE(IDD_DIALOG_ABOUT),
            hwnd,
            (DLGPROC)&AboutDialogProc,
            0);

        break;

    case ID_HELP_HELP:
        supShowHelp(hwnd);
        break;

    case ID_HELP_SHOWLOG:
        LogViewerShowDialog(hwnd);
        break;

    case ID_VIEW_SYSINFO:
        ShowSysInfoDialog(hwnd);
        break;

    }

    if ((ControlId >= ID_MENU_PLUGINS) && (ControlId < ID_MENU_PLUGINS_MAX)) {
        PmProcessEntry(GetFocus(), ControlId);
    }

    return FALSE;
}

/*
* MainWindowPopupMenuInsertViewSD
*
* Purpose:
*
* Add "View Security Descriptor" menu item to the popup menu.
*
*/
VOID MainWindowPopupMenuInsertViewSD(
    _In_ HMENU hMenu,
    _In_ UINT uPosition
)
{
    HICON hIcon;

    InsertMenu(hMenu, uPosition, MF_BYCOMMAND, ID_VIEW_SECURITYDESCRIPTOR, T_VIEWSD);

    hIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_SECURITY),
        IMAGE_ICON,
        0,
        0,
        LR_SHARED);

    if (hIcon) {

        supSetMenuIcon(hMenu,
            ID_VIEW_SECURITYDESCRIPTOR,
            hIcon);

    }
}

/*
* MainWindowHandleTreePopupMenu
*
* Purpose:
*
* Object Tree popup menu builder.
*
*/
VOID MainWindowHandleTreePopupMenu(
    _In_ HWND hwnd,
    _In_ LPPOINT point
)
{
    HMENU hMenu;
    UINT uPosition = 0;

    hMenu = CreatePopupMenu();
    if (hMenu) {
        InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_COPY_NAME, T_COPY_OBJECT_NAME);
        InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_COPY_NAME_BINARY, T_COPY_OBJECT_NAME_BIN);
        InsertMenu(hMenu, uPosition++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_PROPERTIES, T_PROPERTIES);

        supSetMenuIcon(hMenu, ID_OBJECT_PROPERTIES,
            ImageList_ExtractIcon(g_WinObj.hInstance, g_ToolBarMenuImages, 0));

        MainWindowPopupMenuInsertViewSD(hMenu, uPosition++);

        PmBuildPluginPopupMenuByObjectType(hMenu, ObjectTypeDirectory);

        TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, point->x, point->y, 0, hwnd, NULL);
        DestroyMenu(hMenu);
    }
}

/*
* MainWindowHandleObjectPopupMenu
*
* Purpose:
*
* Object List popup menu builder.
*
*/
VOID MainWindowHandleObjectPopupMenu(
    _In_ HWND hwnd,
    _In_ HWND hwndlv,
    _In_ INT iItem,
    _In_ LPPOINT point
)
{
    HMENU hMenu;
    UINT  uGotoSymLinkEnable = MF_BYCOMMAND | MF_GRAYED, uPosition = 0;

    WOBJ_OBJECT_TYPE objType;

    hMenu = CreatePopupMenu();
    if (hMenu == NULL) return;

    InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_COPY_NAME, T_COPY_OBJECT_NAME);
    InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_COPY_NAME_BINARY, T_COPY_OBJECT_NAME_BIN);
    InsertMenu(hMenu, uPosition++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
    InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_PROPERTIES, T_PROPERTIES);

    supSetMenuIcon(hMenu, ID_OBJECT_PROPERTIES,
        ImageList_ExtractIcon(g_WinObj.hInstance, g_ToolBarMenuImages, 0));

    objType = supObjectListGetObjectType(hwndlv, iItem);

    switch (objType) {

        //
        // Insert "Go To Link Target"
        //
    case ObjectTypeSymbolicLink:

        InsertMenu(hMenu, uPosition++, MF_BYCOMMAND, ID_OBJECT_GOTOLINKTARGET, T_GOTOLINKTARGET);

        supSetMenuIcon(hMenu, ID_OBJECT_GOTOLINKTARGET,
            ImageList_ExtractIcon(g_WinObj.hInstance,
                g_ListViewImages,
                g_TypeSymbolicLink.ImageIndex));

        uGotoSymLinkEnable = MF_BYCOMMAND; //-V796

        //
        // Intentionally do not 'break' here.
        //

    case ObjectTypeDirectory:
    case ObjectTypeDevice:
    case ObjectTypeEvent:
    case ObjectTypeEventPair:
    case ObjectTypeIoCompletion:
    case ObjectTypeJob:
    case ObjectTypeKey:
    case ObjectTypeKeyedEvent:
    case ObjectTypeMemoryPartition:
    case ObjectTypeMutant:
    case ObjectTypePort:
    case ObjectTypeSection:
    case ObjectTypeSemaphore:
    case ObjectTypeSession:
    case ObjectTypeTimer:
    case ObjectTypeRegistryTransaction:

        MainWindowPopupMenuInsertViewSD(hMenu, uPosition);
        break;

    }

    EnableMenuItem(GetSubMenu(GetMenu(hwnd), IDMM_OBJECT), ID_OBJECT_GOTOLINKTARGET, uGotoSymLinkEnable);

    PmBuildPluginPopupMenuByObjectType(
        hMenu,
        (UCHAR)objType);

    TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, point->x, point->y, 0, hwnd, NULL);
    DestroyMenu(hMenu);
}

/*
* MainWindowHandleWMNotify
*
* Purpose:
*
* Main window WM_NOTIFY handler.
*
*/
LRESULT MainWindowHandleWMNotify(
    _In_ HWND hwnd,
    _In_ LPARAM lParam
)
{
    INT             nImageIndex;
    LPNMHDR         hdr = (LPNMHDR)lParam;
    LPTOOLTIPTEXT   lpttt;
    LPNMLISTVIEW    lvn;
    LPNMTREEVIEW    lpnmTreeView;
    LVITEM          lvitem;
    TVHITTESTINFO   tvhti;
    LVHITTESTINFO   lvhti;
    POINT           pt;
    OBEX_ITEM       *objRef = NULL;

    if (hdr) {

        //
        // TreeList notify.
        //
        if (hdr->hwndFrom == g_hwndObjectTree) {
            switch (hdr->code) {
            case TVN_ITEMEXPANDED:
            case TVN_SELCHANGED:
                SetFocus(g_hwndObjectTree);
                supSetWaitCursor(TRUE);
                lpnmTreeView = (LPNMTREEVIEW)lParam;
                if (lpnmTreeView) {
                    ObjectTreeSelectedItem = lpnmTreeView->itemNew.hItem;

                    supBuildCurrentObjectList((OBEX_ITEM*)lpnmTreeView->itemNew.lParam);
                    ListCurrentDirectoryObjects(ObjectTreeSelectedItem);

                    supDisplayCurrentObjectPath(g_hwndStatusBar, NULL, TRUE);

                    ListView_SortItemsEx(g_hwndObjectList, &MainWindowObjectListCompareFunc, g_SortColumn);
                }

                supSetGotoLinkTargetToolButtonState(hwnd, 0, 0, TRUE, FALSE);

                supSetWaitCursor(FALSE);
            
                break;

            case NM_RCLICK:
                GetCursorPos(&pt);
                tvhti.pt = pt;
                ScreenToClient(hdr->hwndFrom, &tvhti.pt);
                if (TreeView_HitTest(hdr->hwndFrom, &tvhti) &&
                    (tvhti.flags & (TVHT_ONITEM | TVHT_ONITEMRIGHT)))
                {
                    ObjectTreeSelectedItem = tvhti.hItem;
                    TreeView_SelectItem(g_hwndObjectTree, ObjectTreeSelectedItem);

                    if (supGetTreeViewItemParam(g_hwndObjectTree, ObjectTreeSelectedItem, (PVOID*)&objRef))
                        supBuildCurrentObjectList(objRef);
                    
                    supDisplayCurrentObjectPath(g_hwndStatusBar, NULL, TRUE);

                    supSetGotoLinkTargetToolButtonState(hwnd, 0, 0, TRUE, FALSE);
                }
                break;

            case NM_DBLCLK:
                GetCursorPos(&pt);
                tvhti.pt = pt;
                ScreenToClient(hdr->hwndFrom, &tvhti.pt);
                if (TreeView_HitTest(hdr->hwndFrom, &tvhti) &&
                    (tvhti.flags & (TVHT_ONITEM | TVHT_ONITEMRIGHT)))
                {
                    MainWindowShowObjectProperties(hwnd);
                }
                break;
            }

        }

        //
        // ListView notify.
        //
        if (hdr->hwndFrom == g_hwndObjectList) {
            switch (hdr->code) {
            case NM_SETFOCUS:
                if (ListView_GetSelectionMark(g_hwndObjectList) == -1) {
                    lvitem.mask = LVIF_STATE;
                    lvitem.iItem = 0;
                    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
                    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    ListView_SetItem(g_hwndObjectList, &lvitem);
                }
                break;

            case LVN_ITEMCHANGED:
                lvn = (LPNMLISTVIEW)lParam;
                if ((lvn->uNewState & LVIS_SELECTED) &&
                    !(lvn->uOldState & LVIS_SELECTED))
                {
                    if (supGetListViewItemParam(g_hwndObjectList, lvn->iItem, (PVOID*)&objRef)) {
                        supBuildCurrentObjectList(objRef);
                    }

                    supDisplayCurrentObjectPath(g_hwndStatusBar, NULL, TRUE);
                    supSetGotoLinkTargetToolButtonState(hwnd, g_hwndObjectList, lvn->iItem, FALSE, FALSE);

                }
                break;

                //handle sort by column
            case LVN_COLUMNCLICK:
                bMainWndSortInverse = (~bMainWndSortInverse) & 1;
                g_SortColumn = ((NMLISTVIEW*)lParam)->iSubItem;
                ListView_SortItemsEx(g_hwndObjectList, &MainWindowObjectListCompareFunc, g_SortColumn);

                nImageIndex = ImageList_GetImageCount(g_ListViewImages);
                if (bMainWndSortInverse)
                    nImageIndex -= 2; //sort down/up images are always at the end of g_ListViewImages
                else
                    nImageIndex -= 1;

                supUpdateLvColumnHeaderImage(
                    g_hwndObjectList,
                    MAIN_OBJLIST_COLUMN_COUNT,
                    g_SortColumn,
                    nImageIndex);

                break;

            case NM_RCLICK:
                GetCursorPos(&pt);
                lvhti.pt = pt;
                lvhti.iItem = -1;
                ScreenToClient(hdr->hwndFrom, &lvhti.pt);
                ListView_HitTest(hdr->hwndFrom, &lvhti);
                if (lvhti.flags & LVHT_ONITEM) {
                    lvn = (LPNMLISTVIEW)lParam;
                    if (supGetListViewItemParam(g_hwndObjectList, lvn->iItem, (PVOID*)&objRef)) {
                        supBuildCurrentObjectList(objRef);
                    }

                    supDisplayCurrentObjectPath(g_hwndStatusBar, NULL, TRUE);
                    supSetGotoLinkTargetToolButtonState(hwnd, g_hwndObjectList, lvn->iItem, FALSE, FALSE);
                }
                break;

            case NM_DBLCLK:
                GetCursorPos(&pt);
                lvhti.pt = pt;
                lvhti.iItem = -1;
                ScreenToClient(hdr->hwndFrom, &lvhti.pt);
                ListView_HitTest(hdr->hwndFrom, &lvhti);
                if (lvhti.flags & LVHT_ONITEM) {
                    MainWindowShowObjectProperties(hwnd);
                }
                break;

            }
        }

        //handle tooltip
#pragma warning(push)
#pragma warning(disable: 26454)
        if (hdr->code == TTN_GETDISPINFO) {
#pragma warning(pop)
            lpttt = (LPTOOLTIPTEXT)lParam;

            switch (lpttt->hdr.idFrom) {

            case ID_OBJECT_PROPERTIES:
            case ID_VIEW_REFRESH:
            case ID_VIEW_DISPLAYGRID:
            case ID_FIND_FINDOBJECT:
                lpttt->hinst = g_WinObj.hInstance;
                lpttt->lpszText = MAKEINTRESOURCE(lpttt->hdr.idFrom);
                lpttt->uFlags |= TTF_DI_SETITEM;
                break;

            }
        }
    }
    return FALSE;
}

/*
* MainWindowResizeHandler
*
* Purpose:
*
* Main window WM_SIZE handler.
*
*/
VOID MainWindowResizeHandler(
    _In_ LONG sPos
)
{
    RECT ToolBarRect, StatusBarRect;
    LONG posY, sizeY, sizeX;

    if (g_hwndToolBar != NULL) {

        SendMessage(g_hwndToolBar, WM_SIZE, 0, 0);
        SendMessage(g_hwndStatusBar, WM_SIZE, 0, 0);

        if (GetWindowRect(g_hwndToolBar, &ToolBarRect) &&
            GetWindowRect(g_hwndStatusBar, &StatusBarRect)) {

            sizeX = ToolBarRect.right - ToolBarRect.left;
            if (sPos > sizeX - SplitterMargin)
                sPos = sizeX - SplitterMargin - 1;

            sizeY = StatusBarRect.top - ToolBarRect.bottom;
            posY = ToolBarRect.bottom - ToolBarRect.top;
            sizeX = ToolBarRect.right - ToolBarRect.left - sPos - SplitterSize;

            SetWindowPos(g_hwndObjectTree, NULL, 0, posY, sPos, sizeY, 0);
            SetWindowPos(g_hwndObjectList, NULL, sPos + SplitterSize, posY, sizeX, sizeY, 0);
            SetWindowPos(g_hwndSplitter, NULL, sPos, posY, SplitterSize, sizeY, 0);
        }
    }
}

/*
* MainWindowOnContextMenu
*
* Purpose:
*
* Main window WM_CONTEXTMENU handler.
*
*/
VOID MainWindowOnContextMenu(
    _In_ HWND hwnd,
    _In_ HWND hwndFrom,
    _In_ LPARAM lParam
)
{
    RECT crc;
    TVHITTESTINFO tvhti;
    LVHITTESTINFO lvhti;
    POINT pt;

    if (hwndFrom == g_hwndObjectTree) {

        GetCursorPos(&pt);
        tvhti.pt = pt;
        ScreenToClient(g_hwndObjectTree, &tvhti.pt);
        if (TreeView_HitTest(g_hwndObjectTree, &tvhti) &&
            (tvhti.flags & (TVHT_ONITEM | TVHT_ONITEMRIGHT)))
        {
            RtlSecureZeroMemory(&crc, sizeof(crc));

            TreeView_GetItemRect(g_hwndObjectTree,
                TreeView_GetSelection(g_hwndObjectTree), &crc, TRUE);

            crc.top = crc.bottom;
            ClientToScreen(g_hwndObjectTree, (LPPOINT)&crc);
            MainWindowHandleTreePopupMenu(hwnd, (LPPOINT)&crc);
        }

    }
    else if (hwndFrom == g_hwndObjectList) {

        GetCursorPos(&pt);
        lvhti.pt = pt;
        lvhti.iItem = -1;
        ScreenToClient(g_hwndObjectList, &lvhti.pt);
        ListView_HitTest(g_hwndObjectList, &lvhti);
        if (lvhti.flags & LVHT_ONITEM) {
            if (lParam == MAKELPARAM(-1, -1)) 
            {
                RtlSecureZeroMemory(&crc, sizeof(crc));

                ListView_GetItemRect(g_hwndObjectList, lvhti.iItem, &crc, TRUE);
                crc.top = crc.bottom;
                ClientToScreen(g_hwndObjectList, (LPPOINT)&crc);
            }
            else
                GetCursorPos((LPPOINT)&crc);

            MainWindowHandleObjectPopupMenu(hwnd, g_hwndObjectList, lvhti.iItem, (LPPOINT)&crc);
        }
    }
}

/*
* MainWindowProc
*
* Purpose:
*
* Main window procedure.
*
*/
LRESULT CALLBACK MainWindowProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    LONG NewSplitterPos;
    RECT ToolBarRect;
    LPDRAWITEMSTRUCT pds;
    LPMEASUREITEMSTRUCT pms;

    switch (uMsg) {
    case WM_CONTEXTMENU:
        MainWindowOnContextMenu(hwnd, (HWND)wParam, lParam);
        break;

    case WM_COMMAND:
        MainWindowHandleWMCommand(hwnd, wParam);
        break;

    case WM_NOTIFY:
        MainWindowHandleWMNotify(hwnd, lParam);
        break;

    case WM_MEASUREITEM:
        pms = (LPMEASUREITEMSTRUCT)lParam;
        if (pms && pms->CtlType == ODT_MENU) {
            pms->itemWidth = 16;
            pms->itemHeight = 16;
        }
        break;

    case WM_DRAWITEM:
        pds = (LPDRAWITEMSTRUCT)lParam;
        if (pds && pds->CtlType == ODT_MENU) {
            DrawIconEx(pds->hDC, pds->rcItem.left - 15,
                pds->rcItem.top,
                (HICON)pds->itemData,
                16, 16, 0, NULL, DI_NORMAL);
        }
        break;

    case WM_CLOSE:
        PostQuitMessage(0);
        break;

    case WM_LBUTTONDOWN:
        SetCapture(g_hwndMain);
        break;

    case WM_LBUTTONUP:
        ReleaseCapture();
        break;

    case WM_MOUSEMOVE:
        if ((wParam & MK_LBUTTON) != 0) {
            GetClientRect(g_hwndMain, &ToolBarRect);
            NewSplitterPos = (SHORT)LOWORD(lParam);
            if (NewSplitterPos < SplitterMargin)
                NewSplitterPos = SplitterMargin;
            if (NewSplitterPos > ToolBarRect.right - SplitterMargin)
                NewSplitterPos = ToolBarRect.right - SplitterMargin;
            if (g_SplitterPos != NewSplitterPos) {
                g_SplitterPos = NewSplitterPos;
                SendMessage(g_hwndMain, WM_SIZE, 0, 0);
                UpdateWindow(g_hwndMain);
            }
        }
        break;

    case WM_SIZE:
        if (!IsIconic(hwnd)) {
            MainWindowResizeHandler(g_SplitterPos);
        }
        break;

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                MAINWND_TRACKSIZE_MIN_X,
                MAINWND_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*
* MainWindowDlgMsgHandler
*
* Purpose:
*
* Check window message against existing dialogs.
*
*/
BOOL MainWindowDlgMsgHandler(
    _In_ LPMSG lpMsg
)
{
    HWND hwnd;
    
    hwnd = propGetDesktopWindow();
    if (hwnd != NULL)
        if (PropSheet_IsDialogMessage(hwnd, lpMsg))
            return TRUE;
    
    hwnd = propGetCommonWindow();
    if (hwnd != NULL)
        if (PropSheet_IsDialogMessage(hwnd, lpMsg))
            return TRUE;

    return FALSE;
}

/*
* guiInitGlobals
*
* Purpose:
*
* Initialize WinObjEx global variables.
*
*/
DWORD guiInitGlobals(
    _In_ BOOLEAN IsWine,
    _In_ WINOBJ_GLOBALS* Globals)
{
    SIZE_T cch;
    DWORD dwResult = INIT_ERROR_UNSPECIFIED;


    do {

        Globals->IsWine = IsWine;
        Globals->ListViewDisplayGrid = TRUE;

        //
        // Query version info.
        //
        Globals->osver.dwOSVersionInfoSize = sizeof(Globals->osver);
        RtlGetVersion(&Globals->osver);

        g_NtBuildNumber = Globals->osver.dwBuildNumber;

        //
        // Remember hInstance.
        //
        Globals->hInstance = GetModuleHandle(NULL);

        //
        // Create dedicated heap.
        //
        Globals->Heap = supCreateHeap(HEAP_GROWABLE, TRUE);
        if (Globals->Heap == NULL) {
            dwResult = INIT_ERROR_NOHEAP;
            break;
        }

        //
        // Remember %TEMP% directory.
        //
        cch = ExpandEnvironmentStrings(L"%temp%", Globals->szTempDirectory, MAX_PATH);
        if ((cch == 0) || (cch > MAX_PATH)) {
            dwResult = INIT_ERROR_NOTEMP;
            break;
        }

        //
        // Remember Windows directory.
        //
        cch = GetWindowsDirectory(Globals->szWindowsDirectory, MAX_PATH);
        if ((cch == 0) || (cch > MAX_PATH)) {
            dwResult = INIT_ERROR_NOWINDIR;
            break;
        }

        //
        // Remember System32 directory.
        //
        cch = GetSystemDirectory(Globals->szSystemDirectory, MAX_PATH);
        if ((cch == 0) || (cch > MAX_PATH)) {
            dwResult = INIT_ERROR_NOSYS32DIR;
            break;
        }

        //
        // Remember program current directory.
        //
        cch = GetCurrentDirectory(MAX_PATH, Globals->szProgramDirectory);
        if ((cch == 0) || (cch > MAX_PATH)) {
            dwResult = INIT_ERROR_NOPROGDIR;
            break;
        }

        dwResult = INIT_NO_ERROR;

    } while (FALSE);

    if (dwResult != INIT_NO_ERROR) {
        if (Globals->Heap)
            supDestroyHeap(Globals->Heap);
    }

    return dwResult;
}

/*
* guiCreateObjectListColumns
*
* Purpose:
*
* Add object list columns.
*
*/
VOID guiCreateObjectListColumns()
{
    LVCOLUMNS_DATA columnData[] =
    {
        { TEXT("Name"), 300, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  g_ListViewImages ? ImageList_GetImageCount(g_ListViewImages) - 1 : I_IMAGENONE },
        { TEXT("Type"), 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { TEXT("Additional Information"), 170, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    supAddLVColumnsFromArray(g_hwndObjectList, columnData, RTL_NUMBER_OF(columnData));
}

/*
* guiUnregisterClassAtoms
*
* Purpose:
*
* Deregister main window and treelist class.
*
*/
VOID guiUnregisterClassAtoms(
    VOID
)
{
    ATOM classAtom;

    classAtom = g_WinObj.MainWindowClassAtom;
    if (classAtom != 0)
        UnregisterClass(MAKEINTATOM(classAtom), g_WinObj.hInstance);

    classAtom = g_WinObj.TreeListAtom;
    if (classAtom != 0)
        UnregisterClass(MAKEINTATOM(classAtom), g_WinObj.hInstance);
}

/*
* guiSetMainMenuImages
*
* Purpose:
*
* Load menu icons (Four-F legacy stuff).
*
*/
VOID guiSetMainMenuImages(
    VOID
)
{
    HMENU hMenu;
    HICON hIcon;
    HIMAGELIST hToolBarMenuImages = g_ToolBarMenuImages;

    //
    // Set help menu image.
    //
    hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_HELP);
    if (hMenu) {

        hIcon = supGetStockIcon(SIID_HELP, SHGSI_ICON | SHGFI_SMALLICON);
        if (hIcon)
            supSetMenuIcon(hMenu, ID_HELP_HELP, hIcon);

    }

    if (hToolBarMenuImages == NULL)
        return;

    //set menu icons
    hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_VIEW);
    if (hMenu) {
        supSetMenuIcon(hMenu, ID_VIEW_REFRESH,
            ImageList_ExtractIcon(g_WinObj.hInstance, hToolBarMenuImages, 1));
        supSetMenuIcon(hMenu, ID_VIEW_DISPLAYGRID,
            ImageList_ExtractIcon(g_WinObj.hInstance, hToolBarMenuImages, 7));
        hIcon = supGetStockIcon(SIID_INFO, SHGSI_ICON | SHGFI_SMALLICON);
        if (hIcon)
            supSetMenuIcon(hMenu, ID_VIEW_SYSINFO, hIcon);
    }
    hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_OBJECT);
    if (hMenu && g_ListViewImages) {

        supSetMenuIcon(hMenu, ID_OBJECT_PROPERTIES,
            ImageList_ExtractIcon(g_WinObj.hInstance, hToolBarMenuImages, 0));

        supSetMenuIcon(hMenu, ID_OBJECT_GOTOLINKTARGET,
            ImageList_ExtractIcon(g_WinObj.hInstance,
                g_ListViewImages,
                g_TypeSymbolicLink.ImageIndex));
    }

    //set object -> find object menu image
    hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_FIND);
    if (hMenu) {

        supSetMenuIcon(hMenu, ID_FIND_FINDOBJECT,
            ImageList_ExtractIcon(g_WinObj.hInstance, hToolBarMenuImages, 2));

    }

    //
    // Set extras -> menu images.
    //
    hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_EXTRAS);
    if (hMenu) {

        //
        // Pipes & mailslots images.
        //
        supSetMenuIcon(hMenu, ID_EXTRAS_MAILSLOTS,
            ImageList_ExtractIcon(g_WinObj.hInstance, hToolBarMenuImages, 5));
        supSetMenuIcon(hMenu, ID_EXTRAS_PIPES,
            ImageList_ExtractIcon(g_WinObj.hInstance, hToolBarMenuImages, 6));

    }

}

/*
* guiProcessMainMessageLoop
*
* Purpose:
*
* Process messages loop for the main window and sub dialogs.
* 
* Returns 0 on normal exit (WM_QUIT received),
* Returns non-zero on error (GetMessage returned -1).
*
*/
INT guiProcessMainMessageLoop(
    _In_ HINSTANCE hInstance
)
{
    BOOL bResult;
    HACCEL acceleratorTable;
    MSG message;

    acceleratorTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

    do {

        bResult = GetMessage(&message, NULL, 0, 0);
        if (bResult == -1)
            break;

        if (MainWindowDlgMsgHandler(&message))
            continue;

        if (IsDialogMessage(g_hwndMain, &message)) {
            TranslateAccelerator(g_hwndMain, acceleratorTable, &message);
        }
        else {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }

    } while (bResult != 0);

    if (acceleratorTable)
        DestroyAcceleratorTable(acceleratorTable);

    return bResult;
}

/*
* guiInsertRunAsMainMenuEntry
*
* Purpose:
*
* Insert run as admin/local system menu entry if not under Wine.
*
*/
VOID guiInsertRunAsMainMenuEntry(
    _In_ BOOLEAN bIsFullAdmin
)
{
    BOOL bLocalSystem;
    HICON hIcon;
    HMENU hMenu;
    HANDLE processToken;
    WCHAR  szWindowTitle[100];

    if (g_WinObj.IsWine == FALSE) {
        //
        // We are running as user, add menu item to request elevation.
        //
        if (bIsFullAdmin == FALSE) {
            hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_FILE);
            InsertMenu(hMenu, 0, MF_BYPOSITION, ID_FILE_RUNASADMIN, T_RUNASADMIN);
            InsertMenu(hMenu, 1, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

            //
            // Set menu shield icon.
            //
            hIcon = supGetStockIcon(SIID_SHIELD, SHGSI_ICON | SHGFI_SMALLICON);
            if (hIcon)
                supSetMenuIcon(hMenu, ID_FILE_RUNASADMIN, hIcon);

        }
        else {
            //
            // We are running with admin privileges, determine if we need to 
            // insert run as LocalSystem menu entry.
            //
            processToken = supGetCurrentProcessToken();
            if (processToken) {
                if (NT_SUCCESS(supIsLocalSystem(processToken, &bLocalSystem))) {
                    if (bLocalSystem == FALSE) {
                        //
                        // Not LocalSystem account, insert item.
                        //
                        hMenu = GetSubMenu(GetMenu(g_hwndMain), IDMM_FILE);
                        InsertMenu(hMenu, 0, MF_BYPOSITION, ID_FILE_RUNASADMIN, T_RUNASSYSTEM);
                        InsertMenu(hMenu, 1, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

                        //
                        // Set menu LocalSystem icon.
                        //
                        hIcon = supGetStockIcon(SIID_DESKTOPPC, SHGSI_ICON | SHGFI_SMALLICON);
                        if (hIcon)
                            supSetMenuIcon(hMenu, ID_FILE_RUNASADMIN, hIcon);

                    }
                    else {
                        //
                        // LocalSystem account, update window title.
                        //
                        RtlSecureZeroMemory(szWindowTitle, sizeof(szWindowTitle));
                        _strcpy(szWindowTitle, PROGRAM_NAME);
                        _strcat(szWindowTitle, TEXT(" (LocalSystem)"));
                        SetWindowText(g_hwndMain, szWindowTitle);
                    }
                }
                NtClose(processToken);
            }
        }
    }
}

/*
* guiCreateMainWindowAndComponents
*
* Purpose:
*
* Register new window class and create main window, listview, treelist, statusbar etc.
*
*/
DWORD guiCreateMainWindowAndComponents(
    _In_ BOOLEAN bIsFullAdmin,
    _In_ WINOBJ_GLOBALS* Globals
)
{
    ATOM classAtom;
    DWORD dwResult = INIT_NO_ERROR;
    HICON hIcon;
    HWND hwndMain, hwndObjectList, hwndObjectTree, hwndToolBar;
    HIMAGELIST treeViewImages;
    INITCOMMONCONTROLSEX iccx;
    WNDCLASSEX wndClass;
    HINSTANCE hInstance = Globals->hInstance;
    WCHAR szWindowTitle[100];

    do {

        iccx.dwSize = sizeof(iccx);
        iccx.dwICC = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_BAR_CLASSES | ICC_TAB_CLASSES | ICC_LINK_CLASS;
        if (!InitCommonControlsEx(&iccx)) {
            dwResult = INIT_ERROR_NOICCX;
            break;
        }

        wndClass.cbSize = sizeof(WNDCLASSEX);
        wndClass.style = 0;
        wndClass.lpfnWndProc = &MainWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;

        wndClass.hIcon = (HICON)LoadImage(
            hInstance,
            MAKEINTRESOURCE(IDI_ICON_MAIN),
            IMAGE_ICON,
            0,
            0,
            LR_SHARED);

        wndClass.hCursor = (HCURSOR)LoadImage(
            NULL,
            MAKEINTRESOURCE(OCR_SIZEWE),
            IMAGE_CURSOR,
            0,
            0,
            LR_SHARED);

        wndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wndClass.lpszMenuName = MAKEINTRESOURCE(IDR_MAINMENU);
        wndClass.lpszClassName = WINOBJEX64_WNDCLASS;
        wndClass.hIconSm = 0;

        classAtom = RegisterClassEx(&wndClass);
        if (classAtom == 0) {
            dwResult = INIT_ERROR_NOCLASS;
            break;
        }

        Globals->MainWindowClassAtom = classAtom;

        RtlSecureZeroMemory(szWindowTitle, sizeof(szWindowTitle));
        _strcpy(szWindowTitle, PROGRAM_NAME);
        if (bIsFullAdmin != FALSE) {
            _strcat(szWindowTitle, TEXT(" (Administrator)"));
        }

        if (Globals->IsWine != FALSE) {
            _strcat(szWindowTitle, TEXT(" (Wine)"));
        }

        //
        // Create main window.
        //
        hwndMain = CreateWindowEx(
            0,
            MAKEINTATOM(classAtom),
            szWindowTitle,
            WS_VISIBLE | WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            SCALE_DPI_VALUE(800, Globals->CurrentDPI),
            SCALE_DPI_VALUE(600, Globals->CurrentDPI),
            NULL,
            NULL,
            hInstance,
            NULL);

        if (hwndMain == NULL) {
            dwResult = INIT_ERROR_NOMAINWND;
            break;
        }

        Globals->MainWindow = hwndMain;
        Globals->SettingsChangeMessage = RegisterWindowMessage(T_MSG_SETTINGS_CHANGE);

        //
        // Status Bar window.
        //
        Globals->MainWindowStatusBar = CreateWindowEx(
            0,
            STATUSCLASSNAME,
            NULL,
            WS_VISIBLE | WS_CHILD,
            0,
            0,
            0,
            0,
            hwndMain,
            (HMENU)1001,
            hInstance,
            NULL);

        //
        // TreeView window.
        //
        hwndObjectTree = CreateWindowEx(
            WS_EX_CLIENTEDGE,
            WC_TREEVIEW,
            NULL,
            WS_VISIBLE | WS_CHILD | WS_TABSTOP |
            TVS_DISABLEDRAGDROP | TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_TRACKSELECT,
            0,
            0,
            0,
            0,
            hwndMain,
            (HMENU)1002,
            hInstance,
            NULL);

        if (hwndObjectTree == NULL) {
            dwResult = INIT_ERROR_NOTREEWND;
            break;
        }

        Globals->ObjectTreeView = hwndObjectTree;

        //
        // ListView window.
        //
        hwndObjectList = CreateWindowEx(
            WS_EX_CLIENTEDGE,
            WC_LISTVIEW,
            NULL,
            WS_VISIBLE | WS_CHILD | WS_TABSTOP |
            LVS_AUTOARRANGE | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_SINGLESEL | LVS_SHAREIMAGELISTS,
            0,
            0,
            0,
            0,
            hwndMain,
            (HMENU)1003,
            hInstance,
            NULL);

        if (hwndObjectList == NULL) {
            dwResult = INIT_ERROR_NOLISTWND;
            break;
        }

        Globals->ObjectListView = hwndObjectList;

        //
        // Set treeview imagelist.
        //
        treeViewImages = supLoadImageList(hInstance,
            IDI_ICON_VIEW_DEFAULT,
            IDI_ICON_VIEW_SELECTED);

        if (treeViewImages) {
            TreeView_SetImageList(hwndObjectTree, treeViewImages, TVSIL_NORMAL);
        }

        //
        // Load listview images for object types.
        //
        Globals->ListViewImages = ObManagerLoadImageList();
        if (Globals->ListViewImages) {
            //
            // Append two column sorting images to the end of the listview imagelist.
            //
            hIcon = (HICON)LoadImage(hInstance, MAKEINTRESOURCE(IDI_ICON_SORTUP), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);
            if (hIcon) {
                ImageList_ReplaceIcon(Globals->ListViewImages, -1, hIcon);
                DestroyIcon(hIcon);
            }
            hIcon = (HICON)LoadImage(hInstance, MAKEINTRESOURCE(IDI_ICON_SORTDOWN), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);
            if (hIcon) {
                ImageList_ReplaceIcon(Globals->ListViewImages, -1, hIcon);
                DestroyIcon(hIcon);
            }
            ListView_SetImageList(hwndObjectList, Globals->ListViewImages, LVSIL_SMALL);
        }

        ListView_SetExtendedListViewStyle(hwndObjectList,
            LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_DOUBLEBUFFER | LVS_EX_GRIDLINES);

        //
        // Apply Window theme.
        //
        SetWindowTheme(hwndObjectList, TEXT("Explorer"), NULL);
        SetWindowTheme(hwndObjectTree, TEXT("Explorer"), NULL);

        //
        // Toolbar window.
        //
        hwndToolBar = CreateWindowEx(
            0,
            TOOLBARCLASSNAME,
            NULL,
            WS_VISIBLE | WS_CHILD | CCS_TOP |
            TBSTYLE_FLAT | TBSTYLE_TRANSPARENT | TBSTYLE_TOOLTIPS,
            0,
            0,
            0,
            0,
            hwndMain,
            (HMENU)1004,
            hInstance,
            NULL);

        if (hwndToolBar == NULL) {
            dwResult = INIT_ERROR_NOTLBARWND;
            break;
        }

        Globals->MainWindowToolBar = hwndToolBar;

        SendMessage(hwndToolBar, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DOUBLEBUFFER);

        //
        // Load toolbar images.
        //
        Globals->ToolBarMenuImages = ImageList_LoadImage(
            hInstance,
            MAKEINTRESOURCE(IDB_BITMAP1),
            16,
            8,
            CLR_DEFAULT,
            IMAGE_BITMAP,
            LR_CREATEDIBSECTION);

        if (Globals->ToolBarMenuImages) {
            supCreateToolbarButtons(hwndToolBar, Globals->ToolBarMenuImages);
        }

        //
        // Spliter window.
        //
        Globals->MainWindowSplitter = CreateWindowEx(
            0,
            WC_STATIC,
            NULL,
            WS_VISIBLE | WS_CHILD,
            0,
            0,
            0,
            0,
            hwndMain,
            (HMENU)1005,
            hInstance,
            NULL);

        if (Globals->MainWindowSplitter == NULL)
            dwResult = INIT_ERROR_NOSPLITTERWND;

        //
        // Bring main window to front.
        //
        if (g_kdctx.NtOsSymContext != NULL) {
            SetForegroundWindow(Globals->MainWindow);
            SetActiveWindow(Globals->MainWindow);
        }

    } while (FALSE);

    return dwResult;
}

/*
* InitMSVCRT
*
* Purpose:
*
* Initialize MS CRT routines from ntdll (either msvcrt).
*
*/
BOOL InitMSVCRT(
    VOID
)
{
    HMODULE DllHandle;

    DllHandle = GetModuleHandle(TEXT("ntdll.dll"));

    if (DllHandle) {
        _swprintf_s = (pswprintf_s)GetProcAddress(DllHandle, "swprintf_s");
        _qsort = (pqsort)GetProcAddress(DllHandle, "qsort");
    }

    if (_swprintf_s == NULL ||
        _qsort == NULL)
    {
        DllHandle = GetModuleHandle(TEXT("msvcrt.dll"));
        if (DllHandle == NULL)
            DllHandle = LoadLibraryEx(TEXT("msvcrt.dll"), NULL, 0);

        if (DllHandle) {
            _swprintf_s = (pswprintf_s)GetProcAddress(DllHandle, "swprintf_s");
            _qsort = (pqsort)GetProcAddress(DllHandle, "qsort");
        }
    }

    return ((_swprintf_s != NULL) && (_qsort != NULL));
}

/*
* ShowInitError
*
* Purpose:
*
* Display initialization error depending on it type.
*
*/
VOID ShowInitError(
    _In_ DWORD ErrorType
)
{
    WCHAR szErrorBuffer[MAX_PATH * 2];
    LPWSTR lpError;

    //
    // CRT not initialized, no fancy swprinfs for you.
    //
    if (ErrorType == INIT_ERROR_NOCRT) {

        MessageBox(GetDesktopWindow(),
            (LPCWSTR)T_WOBJINIT_NOCRT,
            (LPCWSTR)PROGRAM_NAME,
            MB_ICONWARNING | MB_OK);

        return;
    }

    switch (ErrorType) {

    case INIT_ERROR_NOHEAP:
        lpError = L"Heap not allocated";
        break;

    case INIT_ERROR_NOTEMP:
        lpError = L"%temp% not resolved";
        break;

    case INIT_ERROR_NOWINDIR:
        lpError = L"Windows directory not resolved";
        break;

    case INIT_ERROR_NOSYS32DIR:
        lpError = L"System32 directory not resolved";
        break;

    case INIT_ERROR_NOPROGDIR:
        lpError = L"Program directory not resolved";
        break;

    case INIT_ERROR_NOCLASS:
        lpError = L"Main window class not registered";
        break;

    case INIT_ERROR_NOMAINWND:
        lpError = L"Main window not created";
        break;

    case INIT_ERROR_NOICCX:
        lpError = L"Common Controls Library";
        break;

    case INIT_ERROR_NOLISTWND:
        lpError = L"Main list window not created";
        break;

    case INIT_ERROR_NOTREEWND:
        lpError = L"Main tree window not created";
        break;

    case INIT_ERROR_NOTLBARWND:
        lpError = L"Main toolbar window not created";
        break;

    case INIT_ERROR_NOSPLITTERWND:
        lpError = L"Main splitter window not created";
        break;

    default:
        lpError = L"Unknown initialization error";
        break;
    }

    RtlStringCchPrintfSecure(szErrorBuffer,
        MAX_PATH * 2,
        TEXT("WinObjEx64 failed to initialize: %ws, abort"),
        lpError);

    MessageBox(GetDesktopWindow(),
        (LPWSTR)szErrorBuffer,
        (LPCWSTR)PROGRAM_NAME,
        MB_ICONWARNING | MB_OK);

}

/*
* WinObjExMain
*
* Purpose:
*
* Initialize subsystems, create windows and process message loop.
*
*/
UINT WinObjExMain()
{
    BOOLEAN bIsWine = FALSE, bIsFullAdmin = FALSE;
    UINT result = ERROR_SUCCESS;
    DWORD initResult;

    RtlSecureZeroMemory(&g_WinObjStats, sizeof(g_WinObjStats));

    logCreate();

    bIsFullAdmin = ntsupUserIsFullAdmin();
    bIsWine = (IsWine() == 1);
    if (bIsWine) bIsFullAdmin = FALSE; // On Wine drop admin related features as they require driver.

    if (!InitMSVCRT()) {
        ShowInitError(INIT_ERROR_NOCRT);
        return ERROR_APP_INIT_FAILURE;
    }

    //
    // Wine 1.6 xenial does not support this routine.
    //
    if (bIsWine == FALSE) {
        RtlSetHeapInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0);
    }

    RtlSecureZeroMemory(&g_WinObj, sizeof(g_WinObj));
    initResult = guiInitGlobals(bIsWine, &g_WinObj);
    if (initResult != INIT_NO_ERROR) {
        ShowInitError(initResult);
        return ERROR_APP_INIT_FAILURE;
    }

    supInit(bIsFullAdmin);

    BeginTests();

    initResult = guiCreateMainWindowAndComponents(bIsFullAdmin, &g_WinObj);
    if (initResult != INIT_NO_ERROR) {
        ShowInitError(initResult);
        result = ERROR_APP_INIT_FAILURE;
    }
    else {

        SendMessage(g_hwndMain, WM_SIZE, 0, 0);

        g_WinObj.TreeListAtom = InitializeTreeListControl(); // Register treelist control class.

        guiInsertRunAsMainMenuEntry(bIsFullAdmin);

        guiExtrasDisableAdminFeatures(g_hwndMain); // Hide admin only stuff.

        guiSetMainMenuImages();

        PmCreate(g_hwndMain); // Plugin manager initialization

        guiCreateObjectListColumns();

        ListObjectDirectoryTree(ObGetPredefinedUnicodeString(OBP_ROOT), NULL, NULL);

        TreeView_SelectItem(g_hwndObjectTree, TreeView_GetRoot(g_hwndObjectTree));
        SetFocus(g_hwndObjectTree);

        result = guiProcessMainMessageLoop(g_WinObj.hInstance);
    }

    guiUnregisterClassAtoms();

    PmDestroy(); // Destroy plugin manager.

    //
    // Do not move anywhere.
    //
    ListHeapDestroy();
    supShutdown();
    logFree();

    EndTests();

    return result;
}

/*
* WinMain/main
*
* Purpose:
*
* Program entry point.
*
*/
#if !defined(__cplusplus)
#pragma comment(linker, "/ENTRY:main")
void main()
{
    __security_init_cookie();
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)exceptFilterUnhandled);
    ExitProcess(WinObjExMain());
}
#else
#pragma comment(linker, "/ENTRY:WinMain")
int CALLBACK WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR     lpCmdLine,
    _In_ int       nCmdShow
)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)exceptFilterUnhandled);
    ExitProcess(WinObjExMain());
}
#endif

```

`Source/WinObjEx64/msvcver.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2025
*
*  TITLE:       MSVCVER.H
*
*  VERSION:     2.10
*
*  DATE:        29 Nov 2025
*
*  Visual Studio compiler version determination. 
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#if defined _MSC_VER && _MSC_FULL_VER

    // Visual Studio 2026 (18.x)
    #if (_MSC_VER >= 1950)
        #if (_MSC_VER >= 1951)
            #define VC_VER L"MSVC 2026 (v18.1+)"
        #elif (_MSC_VER == 1950)
            #define VC_VER L"MSVC 2026 (v18.0)"
        #else
            #define VC_VER L"MSVC 2026"
        #endif

    // Visual Studio 2022 (17.x)
    #elif (_MSC_VER >= 1930 && _MSC_VER < 1950)
        #if (_MSC_VER >= 1938)
            #define VC_VER L"MSVC 2022 (v17.8)"
        #elif (_MSC_VER >= 1937)
            #define VC_VER L"MSVC 2022 (v17.7)"
        #elif (_MSC_VER >= 1936)
            #define VC_VER L"MSVC 2022 (v17.6)"
        #elif (_MSC_VER >= 1935)
            #define VC_VER L"MSVC 2022 (v17.5)"
        #elif (_MSC_VER >= 1934)
            #define VC_VER L"MSVC 2022 (v17.4)"
        #elif (_MSC_VER >= 1932 && _MSC_VER < 1934)
            #define VC_VER L"MSVC 2022 (v17.2-v17.3)"
        #elif (_MSC_VER >= 1931)
            #define VC_VER L"MSVC 2022 (v17.1)"
        #elif (_MSC_VER == 1930)
            #define VC_VER L"MSVC 2022 (v17.0)"
        #else
            #define VC_VER L"MSVC 2022"
        #endif

    // Visual Studio 2019 (16.x)
    #elif (_MSC_VER >= 1920 && _MSC_VER < 1930)
        #if (_MSC_VER == 1929)
            #define VC_VER L"MSVC 2019 (v16.10-v16. 11)"
        #elif (_MSC_VER == 1928)
            #define VC_VER L"MSVC 2019 (v16.8-v16.9)"
        #elif (_MSC_VER == 1927)
            #define VC_VER L"MSVC 2019 (v16.7)"
        #elif (_MSC_VER == 1926)
            #define VC_VER L"MSVC 2019 (v16.6)"
        #elif (_MSC_VER == 1925)
            #define VC_VER L"MSVC 2019 (v16.5)"
        #elif (_MSC_VER == 1924)
            #define VC_VER L"MSVC 2019 (v16. 4)"
        #elif (_MSC_VER == 1923)
            #define VC_VER L"MSVC 2019 (v16.3)"
        #elif (_MSC_VER == 1922)
            #define VC_VER L"MSVC 2019 (v16.2)"
        #elif (_MSC_VER == 1921)
            #define VC_VER L"MSVC 2019 (v16.1)"
        #elif (_MSC_VER == 1920)
            #define VC_VER L"MSVC 2019 (v16.0)"
        #else
            #define VC_VER L"MSVC 2019"
    #endif

    // Visual Studio 2017 (15.x)
    #elif (_MSC_VER >= 1910 && _MSC_VER < 1920)
    #if (_MSC_VER == 1916)
        #define VC_VER L"MSVC 2017 (v15.9)"
    #elif (_MSC_VER == 1915)
        #define VC_VER L"MSVC 2017 (v15.8)"
    #elif (_MSC_VER == 1914)
        #define VC_VER L"MSVC 2017 (v15.7)"
    #elif (_MSC_VER == 1913)
        #define VC_VER L"MSVC 2017 (v15. 6)"
    #elif (_MSC_VER == 1912)
        #define VC_VER L"MSVC 2017 (v15.5)"
    #elif (_MSC_VER == 1911)
        #define VC_VER L"MSVC 2017 (v15.3-v15.4)"
    #elif (_MSC_VER == 1910)
        #define VC_VER L"MSVC 2017 (v15.0-v15.2)"
    #else
        #define VC_VER L"MSVC 2017"
    #endif

    // Other versions
    #else
        #define VC_VER L"Unknown MSVC Version"
    #endif

#else 
    #define VC_VER L"Unknown Compiler"
#endif
```

`Source/WinObjEx64/objects.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2025
*
*  TITLE:       OBJECTS.C
*
*  VERSION:     2.10
*
*  DATE:        22 Nov 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

WOBJ_TYPE_DESC g_TypeUnknown = { OBTYPE_NAME_UNKNOWN, 0, ObjectTypeUnknown, IDI_ICON_UNKNOWN, IDS_DESC_UNKNOWN };

WOBJ_TYPE_DESC g_TypeActivationObject = { L"ActivationObject", 0xde960015, ObjectTypeActivationObject, IDI_ICON_ACTIVATIONOBJECT, IDS_DESC_ACTIVATIONOBJECT };
WOBJ_TYPE_DESC g_TypeActivityReference = { L"ActivityReference", 0x44db295c, ObjectTypeActivityReference, IDI_ICON_ACTIVITYREFERENCE, IDS_DESC_ACTIVITYREFERENCE };
WOBJ_TYPE_DESC g_TypeAdapter = { L"Adapter", 0x5b4bfe0f, ObjectTypeAdapter, IDI_ICON_ADAPTER, IDS_DESC_ADAPTER };
WOBJ_TYPE_DESC g_TypeALPCPort = { L"ALPC Port", 0xfc99f003, ObjectTypePort, IDI_ICON_PORT, IDS_DESC_PORT };
WOBJ_TYPE_DESC g_TypeCallback = { L"Callback", 0xd619e0a5, ObjectTypeCallback, IDI_ICON_CALLBACK, IDS_DESC_CALLBACK };
WOBJ_TYPE_DESC g_TypeComposition = { L"Composition", 0xf009caea, ObjectTypeComposition, IDI_ICON_DXOBJECT, IDS_DESC_COMPOSITION };
WOBJ_TYPE_DESC g_TypeController = { L"Controller", 0x38a0df3c, ObjectTypeController, IDI_ICON_CONTROLLER, IDS_DESC_CONTROLLER };
WOBJ_TYPE_DESC g_TypeCoreMessaging = { L"CoreMessaging", 0x86bcebe5, ObjectTypeCoreMessaging, IDI_ICON_COREMESSAGING, IDS_DESC_COREMESSAGING };
WOBJ_TYPE_DESC g_TypeCoverageSampler = { L"CoverageSampler", 0xb6a0f960, ObjectTypeCoverageSampler, IDI_ICON_COVERAGESAMPLER, IDS_DESC_COVERAGESAMPLER };
WOBJ_TYPE_DESC g_TypeCpuPartition = { L"CpuPartition", 0xafdf1c82, ObjectTypeCpuPartition, IDI_ICON_CPUPARTITION, IDS_DESC_CPUPARTITION };
WOBJ_TYPE_DESC g_TypeCrossVmEvent = { L"CrossVmEvent", 0x6eb9ebe3, ObjectTypeCrossVmEvent, IDI_ICON_CROSSVMEVENT, IDS_DESC_CROSSVMEVENT };
WOBJ_TYPE_DESC g_TypeCrossVmMutant = { L"CrossVmMutant", 0x4c942872, ObjectTypeCrossVmMutant, IDI_ICON_CROSSVMMUTANT, IDS_DESC_CROSSVMMUTANT };
WOBJ_TYPE_DESC g_TypeDebugObject = { L"DebugObject", 0x8282e52, ObjectTypeDebugObject, IDI_ICON_DEBUGOBJECT, IDS_DESC_DEBUGOBJECT };
WOBJ_TYPE_DESC g_TypeDesktop = { OBTYPE_NAME_DESKTOP, 0xd1ffc79c, ObjectTypeDesktop, IDI_ICON_DESKTOP, IDS_DESC_DESKTOP };
WOBJ_TYPE_DESC g_TypeDevice = { L"Device", OBTYPE_HASH_DEVICE, ObjectTypeDevice, IDI_ICON_DEVICE, IDS_DESC_DEVICE };
WOBJ_TYPE_DESC g_TypeDirectory = { OBTYPE_NAME_DIRECTORY, OBTYPE_HASH_DIRECTORY, ObjectTypeDirectory, IDI_ICON_DIRECTORY, IDS_DESC_DIRECTORY };
WOBJ_TYPE_DESC g_TypeDmaAdapter = { L"DmaAdapter", 0x2201d697, ObjectTypeDmaAdapter, IDI_ICON_HALDMA, IDS_DESC_DMAADAPTER };
WOBJ_TYPE_DESC g_TypeDmaDomain = { L"DmaDomain", 0xfe7e671c, ObjectTypeDmaDomain, IDI_ICON_HALDMA, IDS_DESC_DMADOMAIN };
WOBJ_TYPE_DESC g_TypeDriver = { L"Driver", OBTYPE_HASH_DRIVER, ObjectTypeDriver, IDI_ICON_DRIVER, IDS_DESC_DRIVER };
WOBJ_TYPE_DESC g_TypeDxgkCompositionObject = { L"DxgkCompositionObject", 0xf2bf1f91, ObjectTypeDxgkComposition, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_COMPOSITION_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkCurrentDxgProcessObject = { L"DxgkCurrentDxgProcessObject", 0xc27e9d7c, ObjectTypeDxgkCurrentDxgProcessObject, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_CURRENT_DXG_PROCESS_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkCurrentDxgThreadObject = { L"DxgkCurrentDxgThreadObject", 0xc8d07f5b, ObjectTypeDxgkCurrentDxgThreadObject, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_CURRENT_DXG_THREAD_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkDisplayManagerObject = { L"DxgkDisplayManagerObject", 0x5afc4062, ObjectTypeDxgkDisplayManager, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_DISPLAY_MANAGER_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkDisplayMuxSwitch = { L"DxgkDisplayMuxSwitch", 0x180e2a1a, ObjectTypeDxgkDisplayMuxSwitch, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_DISPLAYMUXSWITCH };
WOBJ_TYPE_DESC g_TypeDxgkSharedBundleObject = { L"DxgkSharedBundleObject", 0xf7e4ab9e, ObjectTypeDxgkSharedBundle, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_SHARED_BUNDLE_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkSharedKeyedMutexObject = { L"DxgkSharedKeyedMutexObject", 0xd6c628fd, ObjectTypeDxgkSharedKeyedMutex, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_SHARED_KEYED_MUTEX_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkSharedProtectedSessionObject = { L"DxgkSharedProtectedSessionObject", 0xa9676f44, ObjectTypeDxgkSharedProtectedSession, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_SHARED_PROTECTED_SESSION_OBJECT };
WOBJ_TYPE_DESC g_TypeDxgkSharedResource = { L"DxgkSharedResource", 0x632e6c2b, ObjectTypeDxgkSharedResource, IDI_ICON_DXOBJECT, IDS_DESC_DXGKSHAREDRES };
WOBJ_TYPE_DESC g_TypeDxgkSharedSwapChainObject = { L"DxgkSharedSwapChainObject", 0xf5053210, ObjectTypeDxgkSharedSwapChain, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_SHARED_SWAPCHAIN };
WOBJ_TYPE_DESC g_TypeDxgkSharedSyncObject = { L"DxgkSharedSyncObject", 0xa29968d7, ObjectTypeDxgkSharedSyncObject, IDI_ICON_DXOBJECT, IDS_DESC_DXGK_SHARED_SYNC };
WOBJ_TYPE_DESC g_TypeEnergyTracker = { L"EnergyTracker", 0x4dcec6d0, ObjectTypeEnergyTracker, IDI_ICON_ENERGYTRACKER, IDS_DESC_ENERGYTRACKER };
WOBJ_TYPE_DESC g_TypeEtwConsumer = { L"EtwConsumer", 0x31a53abe, ObjectTypeETWConsumer, IDI_ICON_ETWCONSUMER, IDS_DESC_ETWCONSUMER };
WOBJ_TYPE_DESC g_TypeEtwRegistration = { L"EtwRegistration", 0x89b06481, ObjectTypeETWRegistration, IDI_ICON_ETWREGISTRATION, IDS_DESC_ETWREGISTRATION };
WOBJ_TYPE_DESC g_TypeEtwSessionDemuxEntry = { L"EtwSessionDemuxEntry", 0x4ce2d111, ObjectTypeEtwSessionDemuxEntry, IDI_ICON_ETWSESSIONDEMUXENTRY, IDS_DESC_ETWSESSIONDEMUXENTRY };
WOBJ_TYPE_DESC g_TypeEvent = { L"Event", 0xf3040cba, ObjectTypeEvent, IDI_ICON_EVENT, IDS_DESC_EVENT };
WOBJ_TYPE_DESC g_TypeEventPair = { L"EventPair", 0x97834894, ObjectTypeEventPair, IDI_ICON_EVENTPAIR, IDS_DESC_EVENTPAIR };
WOBJ_TYPE_DESC g_TypeFile = { OBTYPE_NAME_FILE, 0xecfd8b1c, ObjectTypeFile, IDI_ICON_FILE, IDS_DESC_FILE };
WOBJ_TYPE_DESC g_TypeFilterCommunicationPort = { L"FilterCommunicationPort", 0x7849195f, ObjectTypeFltComnPort, IDI_ICON_FLTCOMMPORT, IDS_DESC_FLT_COMM_PORT };
WOBJ_TYPE_DESC g_TypeFilterConnectionPort = { L"FilterConnectionPort", 0x4598bf7, ObjectTypeFltConnPort, IDI_ICON_FLTCONNPORT, IDS_DESC_FLT_CONN_PORT };
WOBJ_TYPE_DESC g_TypeIoCompletion = { L"IoCompletion", 0xbc81c342, ObjectTypeIoCompletion, IDI_ICON_IOCOMPLETION, IDS_DESC_IOCOMPLETION };
WOBJ_TYPE_DESC g_TypeIoCompletionReserve = { L"IoCompletionReserve", 0xca6e211a, ObjectTypeIoCompletionReserve, IDI_ICON_IOCOMPLETION, IDS_DESC_IOCOMPLETIONRESERVE };
WOBJ_TYPE_DESC g_TypeIoRing = { L"IoRing", 0xe17640f6, ObjectTypeIoRing, IDI_ICON_IORING, IDS_DESC_IORING };
WOBJ_TYPE_DESC g_TypeIRTimer = { L"IRTimer", 0xc161a6dc, ObjectTypeIRTimer, IDI_ICON_IRTIMER, IDS_DESC_IRTIMER };
WOBJ_TYPE_DESC g_TypeJob = { L"Job", 0x24df96fd, ObjectTypeJob, IDI_ICON_JOB, IDS_DESC_JOB };
WOBJ_TYPE_DESC g_TypeKey = { L"Key", 0x2553a41f, ObjectTypeKey, IDI_ICON_KEY, IDS_DESC_KEY };
WOBJ_TYPE_DESC g_TypeKeyedEvent = { L"KeyedEvent", 0x6c3a045c, ObjectTypeKeyedEvent, IDI_ICON_KEYEDEVENT, IDS_DESC_KEYEDEVENT };
WOBJ_TYPE_DESC g_TypeMutant = { L"Mutant", 0xfba93d5b, ObjectTypeMutant, IDI_ICON_MUTANT, IDS_DESC_MUTANT };
WOBJ_TYPE_DESC g_TypeNdisCmState = { L"NdisCmState", 0x28077967, ObjectTypeNdisCmState, IDI_ICON_NDISCMSTATE, IDS_DESC_NDISCMSTATE };
WOBJ_TYPE_DESC g_TypePartition = { L"Partition", 0x5227054a, ObjectTypeMemoryPartition, IDI_ICON_MEMORYPARTITION, IDS_DESC_MEMORY_PARTITION };
WOBJ_TYPE_DESC g_TypePcwObject = { L"PcwObject", 0xe3f801c3, ObjectTypePcwObject, IDI_ICON_PCWOBJECT, IDS_DESC_PCWOBJECT };
WOBJ_TYPE_DESC g_TypePowerRequest = { L"PowerRequest", 0xb5a1b3ea, ObjectTypePowerRequest, IDI_ICON_POWERREQUEST, IDS_DESC_POWERREQUEST };
WOBJ_TYPE_DESC g_TypeProcess = { OBTYPE_NAME_PROCESS, 0x70fcfc4f, ObjectTypeProcess, IDI_ICON_PROCESS, IDS_DESC_PROCESS };
WOBJ_TYPE_DESC g_TypeProcessStateChange = { L"ProcessStateChange", 0x6fd57b92, ObjectTypeProcessStateChange, IDI_ICON_PROCESSSTATECHANGE, IDS_DESC_PROCESSSTATECHANGE };
WOBJ_TYPE_DESC g_TypeProfile = { L"Profile", 0xfe82aac9, ObjectTypeProfile, IDI_ICON_PROFILE, IDS_DESC_PROFILE };
WOBJ_TYPE_DESC g_TypePsSiloContextNonPaged = { L"PsSiloContextNonPaged", 0xe2c391fb, ObjectTypePsSiloContextNonPaged, IDI_ICON_PSSILOCONTEXT, IDS_DESC_PSSILOCONTEXTNP };
WOBJ_TYPE_DESC g_TypePsSiloContextPaged = { L"PsSiloContextPaged", 0x8f91f0a2, ObjectTypePsSiloContextPaged, IDI_ICON_PSSILOCONTEXT, IDS_DESC_PSSILOCONTEXT };
WOBJ_TYPE_DESC g_TypeRawInputManager = { L"RawInputManager", 0xf28870cb, ObjectTypeRawInputManager, IDI_ICON_RAWINPUTMANAGER, IDS_DESC_RAWINPUTMANAGER };
WOBJ_TYPE_DESC g_TypeRegistryTransaction = { L"RegistryTransaction", 0xba530c61, ObjectTypeRegistryTransaction, IDI_ICON_KEY, IDS_DESC_REGISTRY_TRANSACTION };
WOBJ_TYPE_DESC g_TypeSchedulerSharedData = { L"SchedulerSharedData", 0xa4930ca, ObjectTypeSchedulerSharedData, IDI_ICON_SCHEDULERSHAREDDATA, IDS_DESC_SCHEDULERSHAREDDATA };
WOBJ_TYPE_DESC g_TypeSection = { L"Section", OBTYPE_HASH_SECTION, ObjectTypeSection, IDI_ICON_SECTION, IDS_DESC_SECTION };
WOBJ_TYPE_DESC g_TypeSemaphore = { L"Semaphore", 0x33b553e4, ObjectTypeSemaphore, IDI_ICON_SEMAPHORE, IDS_DESC_SEMAPHORE };
WOBJ_TYPE_DESC g_TypeSession = { L"Session", 0xcd4f9c96, ObjectTypeSession, IDI_ICON_SESSION, IDS_DESC_SESSION };
WOBJ_TYPE_DESC g_TypeSymbolicLink = { L"SymbolicLink", OBTYPE_HASH_SYMBOLIC_LINK, ObjectTypeSymbolicLink, IDI_ICON_SYMLINK, IDS_DESC_SYMLINK };
WOBJ_TYPE_DESC g_TypeTerminal = { L"Terminal", 0x17fd8d1c, ObjectTypeTerminal, IDI_ICON_TERMINAL, IDS_DESC_TERMINAL };
WOBJ_TYPE_DESC g_TypeTerminalEventQueue = { L"TerminalEventQueue", 0x87c5d493, ObjectTypeTerminalEventQueue, IDI_ICON_TERMINALEVENTQUEUE, IDS_DESC_TERMINALEVENTQUEUE };
WOBJ_TYPE_DESC g_TypeThread = { OBTYPE_NAME_THREAD, 0xc8bcac4a, ObjectTypeThread, IDI_ICON_THREAD, IDS_DESC_THREAD };
WOBJ_TYPE_DESC g_TypeThreadStateChange = { L"ThreadStateChange", 0x88afedd7, ObjectTypeThreadStateChange, IDI_ICON_THREADSTATECHANGE, IDS_DESC_THREADSTATECHANGE };
WOBJ_TYPE_DESC g_TypeTimer = { L"Timer", 0x94ec7de5, ObjectTypeTimer, IDI_ICON_TIMER, IDS_DESC_TIMER };
WOBJ_TYPE_DESC g_TypeTmEn = { L"TmEn", 0x7a2e2a02, ObjectTypeTmEn, IDI_ICON_TMEN, IDS_DESC_TMEN };
WOBJ_TYPE_DESC g_TypeTmRm = { L"TmRm", 0x7a3b2d34, ObjectTypeTmRm, IDI_ICON_TMRM, IDS_DESC_TMRM };
WOBJ_TYPE_DESC g_TypeTmTm = { L"TmTm", 0x7a3d2db2, ObjectTypeTmTm, IDI_ICON_TMTM, IDS_DESC_TMTM };
WOBJ_TYPE_DESC g_TypeTmTx = { L"TmTx", 0x7a3d2dbd, ObjectTypeTmTx, IDI_ICON_TMTX, IDS_DESC_TMTX };
WOBJ_TYPE_DESC g_TypeToken = { OBTYPE_NAME_TOKEN, 0xab194359, ObjectTypeToken, IDI_ICON_TOKEN, IDS_DESC_TOKEN };
WOBJ_TYPE_DESC g_TypeTpWorkerFactory = { L"TpWorkerFactory", 0x84a8cd0, ObjectTypeTpWorkerFactory, IDI_ICON_TPWORKERFACTORY,IDS_DESC_TPWORKERFACTORY };
WOBJ_TYPE_DESC g_TypeType = { L"Type", OBTYPE_HASH_TYPE, ObjectTypeType, IDI_ICON_TYPE, IDS_DESC_TYPE };
WOBJ_TYPE_DESC g_TypeUserApcReserve = { L"UserApcReserve", 0xa3fa2453, ObjectTypeUserApcReserve, IDI_ICON_USERAPCRESERVE, IDS_DESC_USERAPCRESERVE };
WOBJ_TYPE_DESC g_TypeVirtualKey = { L"VirtualKey", 0x77158ef4, ObjectTypeVirtualKey, IDI_ICON_VIRTUALKEY, IDS_DESC_VIRTUALKEY };
WOBJ_TYPE_DESC g_TypeVRegConfigurationContext = { L"VRegConfigurationContext", 0x783eeab7, ObjectTypeVRegConfigurationContext, IDI_ICON_VREGCFGCTX, IDS_DESC_VREGCFGCTX };
WOBJ_TYPE_DESC g_TypeWaitablePort = { L"WaitablePort", 0x66debaf0, ObjectTypeWaitablePort, IDI_ICON_WAITABLEPORT, IDS_DESC_WAITABLEPORT };
WOBJ_TYPE_DESC g_TypeWaitCompletionPacket = { L"WaitCompletionPacket", 0xdaa80e19, ObjectTypeWaitCompletionPacket, IDI_ICON_WAITCOMPLETIONPACKET, IDS_DESC_WAITCOMPLETIONPACKET };
WOBJ_TYPE_DESC g_TypeWinstation = { L"WindowStation", OBTYPE_HASH_WINSTATION, ObjectTypeWinstation, IDI_ICON_WINSTATION, IDS_DESC_WINSTATION };
WOBJ_TYPE_DESC g_TypeWmiGuid = { L"WmiGuid", 0x36d9823c, ObjectTypeWMIGuid, IDI_ICON_WMIGUID, IDS_DESC_WMIGUID };

// Maximum object type index value for lookup table sizing
#define MAX_OBJECT_TYPE_INDEX    ObjectTypeUnknown

#define OBJECT_TYPE_ENTRIES \
    X(g_TypeActivationObject) \
    X(g_TypeActivityReference) \
    X(g_TypeAdapter) \
    X(g_TypeALPCPort) \
    X(g_TypeCallback) \
    X(g_TypeComposition) \
    X(g_TypeController) \
    X(g_TypeCoreMessaging) \
    X(g_TypeCoverageSampler) \
    X(g_TypeCpuPartition) \
    X(g_TypeCrossVmEvent) \
    X(g_TypeCrossVmMutant) \
    X(g_TypeDebugObject) \
    X(g_TypeDesktop) \
    X(g_TypeDevice) \
    X(g_TypeDirectory) \
    X(g_TypeDmaAdapter) \
    X(g_TypeDmaDomain) \
    X(g_TypeDriver) \
    X(g_TypeDxgkCompositionObject) \
    X(g_TypeDxgkCurrentDxgProcessObject) \
    X(g_TypeDxgkCurrentDxgThreadObject) \
    X(g_TypeDxgkDisplayManagerObject) \
    X(g_TypeDxgkDisplayMuxSwitch) \
    X(g_TypeDxgkSharedBundleObject) \
    X(g_TypeDxgkSharedKeyedMutexObject) \
    X(g_TypeDxgkSharedProtectedSessionObject) \
    X(g_TypeDxgkSharedResource) \
    X(g_TypeDxgkSharedSwapChainObject) \
    X(g_TypeDxgkSharedSyncObject) \
    X(g_TypeEnergyTracker) \
    X(g_TypeEtwConsumer) \
    X(g_TypeEtwRegistration) \
    X(g_TypeEtwSessionDemuxEntry) \
    X(g_TypeEvent) \
    X(g_TypeEventPair) \
    X(g_TypeFile) \
    X(g_TypeFilterCommunicationPort) \
    X(g_TypeFilterConnectionPort) \
    X(g_TypeIoCompletion) \
    X(g_TypeIoCompletionReserve) \
    X(g_TypeIoRing) \
    X(g_TypeIRTimer) \
    X(g_TypeJob) \
    X(g_TypeKey) \
    X(g_TypeKeyedEvent) \
    X(g_TypeMutant) \
    X(g_TypeNdisCmState) \
    X(g_TypePartition) \
    X(g_TypePcwObject) \
    X(g_TypePowerRequest) \
    X(g_TypeProcess) \
    X(g_TypeProcessStateChange) \
    X(g_TypeProfile) \
    X(g_TypePsSiloContextNonPaged) \
    X(g_TypePsSiloContextPaged) \
    X(g_TypeRawInputManager) \
    X(g_TypeRegistryTransaction) \
    X(g_TypeSchedulerSharedData) \
    X(g_TypeSection) \
    X(g_TypeSemaphore) \
    X(g_TypeSession) \
    X(g_TypeSymbolicLink) \
    X(g_TypeTerminal) \
    X(g_TypeTerminalEventQueue) \
    X(g_TypeThread) \
    X(g_TypeThreadStateChange) \
    X(g_TypeTimer) \
    X(g_TypeTmEn) \
    X(g_TypeTmRm) \
    X(g_TypeTmTm) \
    X(g_TypeTmTx) \
    X(g_TypeToken) \
    X(g_TypeTpWorkerFactory) \
    X(g_TypeType) \
    X(g_TypeUserApcReserve) \
    X(g_TypeVirtualKey) \
    X(g_TypeVRegConfigurationContext) \
    X(g_TypeWaitablePort) \
    X(g_TypeWaitCompletionPacket) \
    X(g_TypeWinstation) \
    X(g_TypeWmiGuid)

//
// Array items must be always sorted by object type name.
//
static WOBJ_TYPE_DESC* gpObjectTypes[] = {
#define X(type) &type,
    OBJECT_TYPE_ENTRIES
#undef X
};

//
// Number of items in gpObjectTypes array
//
ULONG g_ObjectTypesCount = RTL_NUMBER_OF(gpObjectTypes);

// Lookup table for access by type index
static WOBJ_TYPE_DESC* g_TypeIndexLookup[MAX_OBJECT_TYPE_INDEX + 1];

// Hash table for type names
typedef struct _OBTYPE_HASH_NODE {
    ULONG NameHash;
    WOBJ_TYPE_DESC* TypeDesc;
    struct _OBTYPE_HASH_NODE* Next;
} OBTYPE_HASH_NODE, * POBTYPE_HASH_NODE;

// Hashtable for types
#define HASH_TABLE_SIZE 256
static OBTYPE_HASH_NODE* g_TypeHashTable[HASH_TABLE_SIZE];
static OBTYPE_HASH_NODE g_HashNodePool[ObjectTypeMax];

// One-time init
static INIT_ONCE g_LookupTablesInitOnce = INIT_ONCE_STATIC_INIT;

/*
* ObManagerComparerName
*
* Purpose:
*
* Support comparer routine to work with objects array.
*
*/
INT ObManagerComparerName(
    _In_ PCVOID FirstObject,
    _In_ PCVOID SecondObject
)
{
    WOBJ_TYPE_DESC* firstObject = (WOBJ_TYPE_DESC*)FirstObject;
    WOBJ_TYPE_DESC* secondObject = *(WOBJ_TYPE_DESC**)SecondObject;

    return (_strcmpi(firstObject->Name, secondObject->Name));
}

/*
* ObManagerInitOnceCallback
*
* Purpose:
*
* Initialize lookup tables for faster object type searching.
*
*/
BOOL CALLBACK ObManagerInitOnceCallback(
    _Inout_ PINIT_ONCE InitOnce,
    _Inout_opt_ PVOID Parameter,
    _Out_opt_ PVOID* Context
)
{
    ULONG i, hashIndex;
    POBTYPE_HASH_NODE node;
    WOBJ_OBJECT_TYPE typeIndex;
#ifdef _DEBUG
    ULONG k;
#endif

    UNREFERENCED_PARAMETER(InitOnce);
    UNREFERENCED_PARAMETER(Parameter);

    RtlSecureZeroMemory(g_TypeIndexLookup, sizeof(g_TypeIndexLookup));
    RtlSecureZeroMemory(g_TypeHashTable, sizeof(g_TypeHashTable));
    RtlSecureZeroMemory(g_HashNodePool, sizeof(g_HashNodePool));

#if _DEBUG
    if (g_ObjectTypesCount > 1) {
        for (k = 1; k < g_ObjectTypesCount; k++) {
            if (_strcmpi(gpObjectTypes[k - 1]->Name, gpObjectTypes[k]->Name) > 0) {
                kdDebugPrint("gpObjectTypes ordering error at %lu: %ws > %ws\r\n",
                    k, gpObjectTypes[k - 1]->Name, gpObjectTypes[k]->Name);
                break;
            }
        }
    }
#endif

    for (i = 0; i < g_ObjectTypesCount; i++) {

        typeIndex = gpObjectTypes[i]->Index;
        if (typeIndex >= 0 && (ULONG)typeIndex <= MAX_OBJECT_TYPE_INDEX) {
            g_TypeIndexLookup[typeIndex] = gpObjectTypes[i];
        }
#if _DEBUG
        else {
            kdDebugPrint("Type index out of bounds for %ws (%lu)\r\n",
                gpObjectTypes[i]->Name, (ULONG)typeIndex);
        }
#endif

        if (gpObjectTypes[i]->NameHash != 0) {
            hashIndex = gpObjectTypes[i]->NameHash & (HASH_TABLE_SIZE - 1);

            node = &g_HashNodePool[i];
            node->NameHash = gpObjectTypes[i]->NameHash;
            node->TypeDesc = gpObjectTypes[i];
            node->Next = g_TypeHashTable[hashIndex];
            g_TypeHashTable[hashIndex] = node;
        }
    }
    
    if (Context) *Context = ULongToPtr(1);
    return TRUE;
}

/*
* ObManagerEnsureInitialized
*
* Purpose:
*
* Ensure lookup tables are initialized exactly once.
*
*/
VOID ObManagerEnsureInitialized(
    VOID
)
{
    InitOnceExecuteOnce(&g_LookupTablesInitOnce, ObManagerInitOnceCallback, NULL, NULL);
}

/*
* ObManagerInitLookupTables
*
* Purpose:
*
* Initialize lookup tables for faster object type searching.
*
*/
VOID ObManagerInitLookupTables(VOID)
{
    ObManagerEnsureInitialized();
}

/*
* ObManagerGetNameByIndex
*
* Purpose:
*
* Returns object name by index of known type.
*
*/
LPWSTR ObManagerGetNameByIndex(
    _In_ WOBJ_OBJECT_TYPE TypeIndex
)
{
    ObManagerEnsureInitialized();

    if (TypeIndex >= 0 && (ULONG)TypeIndex <= MAX_OBJECT_TYPE_INDEX &&
        g_TypeIndexLookup[TypeIndex] != NULL)
    {
        return g_TypeIndexLookup[TypeIndex]->Name;
    }

    return OBTYPE_NAME_UNKNOWN;
}

/*
* ObManagerGetEntryByTypeIndex
*
* Purpose:
*
* Returns object entry by type index.
*
*/
WOBJ_TYPE_DESC* ObManagerGetEntryByTypeIndex(
    _In_ WOBJ_OBJECT_TYPE TypeIndex
)
{
    ObManagerEnsureInitialized();

    if (TypeIndex >= 0 && (ULONG)TypeIndex <= MAX_OBJECT_TYPE_INDEX &&
        g_TypeIndexLookup[TypeIndex] != NULL)
    {
        return g_TypeIndexLookup[TypeIndex];
    }

    return &g_TypeUnknown;
}

/*
* ObManagerLookupByHash
*
* Purpose:
*
* Fast lookup by hash value.
*
*/
WOBJ_TYPE_DESC* ObManagerLookupByHash(
    _In_ ULONG NameHash
)
{
    ULONG hashIndex;
    POBTYPE_HASH_NODE node;

    if (NameHash == 0)
        return NULL;

    hashIndex = NameHash & (HASH_TABLE_SIZE - 1);
    node = g_TypeHashTable[hashIndex];

    while (node != NULL) {
        if (node->NameHash == NameHash)
            return node->TypeDesc;
        node = node->Next;
    }

    return NULL;
}

/*
* ObManagerGetEntryByTypeName
*
* Purpose:
*
* Returns object description entry by type name or g_TypeUnknown if none found.
*
*/
WOBJ_TYPE_DESC* ObManagerGetEntryByTypeName(
    _In_opt_ LPCWSTR lpTypeName
)
{
    WOBJ_TYPE_DESC searchItem;
    WOBJ_TYPE_DESC* result;
    PVOID lookupItem;
    ULONG nameHash;

    if (lpTypeName == NULL) {
        return &g_TypeUnknown;
    }

    ObManagerEnsureInitialized();

    // Try fast lookup by hash first
    nameHash = supHashString(lpTypeName, (ULONG)_strlen(lpTypeName));
    result = ObManagerLookupByHash(nameHash);
    if (result != NULL) {
        // Verify name matches (in case of hash collision)
        if (_strcmpi(result->Name, lpTypeName) == 0)
            return result;
    }

    // Fall back to binary search
    searchItem.Name = (LPWSTR)lpTypeName;

    lookupItem = supBSearch((PCVOID)&searchItem,
        (PCVOID)gpObjectTypes,
        g_ObjectTypesCount,
        sizeof(PVOID),
        ObManagerComparerName);

    if (lookupItem == NULL) {
        result = &g_TypeUnknown;
    }
    else {
        result = *(WOBJ_TYPE_DESC**)lookupItem;
    }

    return result;
}

/*
* ObManagerGetIndexByTypeName
*
* Purpose:
*
* Returns object index of known type.
*
*/
WOBJ_OBJECT_TYPE ObManagerGetIndexByTypeName(
    _In_opt_ LPCWSTR lpTypeName
)
{
    WOBJ_TYPE_DESC* lookupItem = ObManagerGetEntryByTypeName(lpTypeName);

    return lookupItem->Index;
}

/*
* ObManagerGetImageIndexByTypeName
*
* Purpose:
*
* Returns object image index of known type.
*
*/
INT ObManagerGetImageIndexByTypeName(
    _In_opt_ LPCWSTR lpTypeName
)
{
    WOBJ_TYPE_DESC* lookupItem = ObManagerGetEntryByTypeName(lpTypeName);

    return lookupItem->ImageIndex;
}

/*
* ObManagerLoadImageForType
*
* Purpose:
*
* Load image of the given id.
*
*/
INT ObManagerLoadImageForType(
    _In_ HIMAGELIST ImageList,
    _In_ INT ResourceImageId
)
{
    INT ImageIndex = I_IMAGENONE;
    HICON hIcon;

    hIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(ResourceImageId),
        IMAGE_ICON,
        16,
        16,
        LR_DEFAULTCOLOR);

    if (hIcon) {
        ImageIndex = ImageList_ReplaceIcon(ImageList, -1, hIcon);
        DestroyIcon(hIcon);
    }

    return ImageIndex;
}

/*
* ObManagerLoadImageList
*
* Purpose:
*
* Create and load image list from icon resource type.
*
*/
HIMAGELIST ObManagerLoadImageList(
    VOID
)
{
    UINT i;
    HIMAGELIST ImageList;
    HICON hIcon;

    ObManagerEnsureInitialized();

    ImageList = ImageList_Create(
        16,
        16,
        ILC_COLOR32 | ILC_MASK,
        g_ObjectTypesCount,
        8);

    if (!ImageList)
        return NULL;

    for (i = 0; i < g_ObjectTypesCount; i++) {
        hIcon = (HICON)LoadImage(g_WinObj.hInstance,
            MAKEINTRESOURCE(gpObjectTypes[i]->ResourceImageId),
            IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

        if (hIcon) {
            gpObjectTypes[i]->ImageIndex = ImageList_AddIcon(ImageList, hIcon);
            DestroyIcon(hIcon);
        }
        else {
            gpObjectTypes[i]->ImageIndex = I_IMAGENONE;
        }
    }

    // Load the unknown type icon
    g_TypeUnknown.ImageIndex = ObManagerLoadImageForType(ImageList,
        g_TypeUnknown.ResourceImageId);

    return ImageList;
}

PVOID ObManagerTable()
{
    return (PVOID)gpObjectTypes;
}

VOID ObManagerTest()
{
    ULONG hashValue;
    UINT i;

    for (i = 0; i < g_ObjectTypesCount; i++)
        kdDebugPrint("%ws\r\n", gpObjectTypes[i]->Name);

    for (i = 0; i < g_ObjectTypesCount; i++) {

        hashValue = supHashString(gpObjectTypes[i]->Name, (ULONG)_strlen(gpObjectTypes[i]->Name));
        kdDebugPrint("%ws = 0x%lx\r\n", gpObjectTypes[i]->Name, hashValue);
        if (hashValue != gpObjectTypes[i]->NameHash)
            MessageBox(GetDesktopWindow(), L"Wrong type hash", gpObjectTypes[i]->Name, MB_OK);

    }
}

```

`Source/WinObjEx64/objects.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       OBJECTS.H
*
*  VERSION:     2.10
*
*  DATE:        03 Oct 2025
*
*  Header file for internal Windows object types handling.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Object Type Indexes Used By Program Only 
//
// NOT RELATED TO KERNEL OBJECT TYPE INDEXES
// ObjectTypeUnknown and ObjectTypeMax always end this list
//
typedef enum _WOBJ_OBJECT_TYPE {
    ObjectTypeDevice = 0,
    ObjectTypeDriver = 1,
    ObjectTypeSection = 2,
    ObjectTypePort = 3,
    ObjectTypeSymbolicLink = 4,
    ObjectTypeKey = 5,
    ObjectTypeEvent = 6,
    ObjectTypeJob = 7,
    ObjectTypeMutant = 8,
    ObjectTypeKeyedEvent = 9,
    ObjectTypeType = 10,
    ObjectTypeDirectory = 11,
    ObjectTypeWinstation = 12,
    ObjectTypeCallback = 13,
    ObjectTypeSemaphore = 14,
    ObjectTypeWaitablePort = 15,
    ObjectTypeTimer = 16,
    ObjectTypeSession = 17,
    ObjectTypeController = 18,
    ObjectTypeProfile = 19,
    ObjectTypeEventPair = 20,
    ObjectTypeDesktop = 21,
    ObjectTypeFile = 22,
    ObjectTypeWMIGuid = 23,
    ObjectTypeDebugObject = 24,
    ObjectTypeIoCompletion = 25,
    ObjectTypeProcess = 26,
    ObjectTypeAdapter = 27,
    ObjectTypeToken = 28,
    ObjectTypeETWRegistration = 29,
    ObjectTypeThread = 30,
    ObjectTypeTmTx = 31,
    ObjectTypeTmTm = 32,
    ObjectTypeTmRm = 33,
    ObjectTypeTmEn = 34,
    ObjectTypePcwObject = 35,
    ObjectTypeFltConnPort = 36,
    ObjectTypeFltComnPort = 37,
    ObjectTypePowerRequest = 38,
    ObjectTypeETWConsumer = 39,
    ObjectTypeTpWorkerFactory = 40,
    ObjectTypeComposition = 41,
    ObjectTypeIRTimer = 42,
    ObjectTypeDxgkSharedResource = 43,
    ObjectTypeDxgkSharedSwapChain = 44,
    ObjectTypeDxgkSharedSyncObject = 45,
    ObjectTypeDxgkCurrentDxgProcessObject = 46,
    ObjectTypeDxgkCurrentDxgThreadObject = 47,
    ObjectTypeDxgkDisplayManager = 48,
    ObjectTypeDxgkDisplayMuxSwitch = 49,
    ObjectTypeDxgkSharedBundle = 50,
    ObjectTypeDxgkSharedProtectedSession = 51,
    ObjectTypeDxgkComposition = 52,
    ObjectTypeDxgkSharedKeyedMutex = 53,
    ObjectTypeMemoryPartition = 54,
    ObjectTypeRegistryTransaction = 55,
    ObjectTypeDmaAdapter = 56,
    ObjectTypeDmaDomain = 57,
    ObjectTypeCoverageSampler = 58,
    ObjectTypeActivationObject = 59,
    ObjectTypeActivityReference = 60,
    ObjectTypeCoreMessaging = 61,
    ObjectTypeRawInputManager = 62,
    ObjectTypeWaitCompletionPacket = 63,
    ObjectTypeIoCompletionReserve = 64,
    ObjectTypeUserApcReserve = 65,
    ObjectTypeIoRing = 66,
    ObjectTypeTerminal = 67,
    ObjectTypeTerminalEventQueue = 68,
    ObjectTypeEnergyTracker = 69,
    ObjectTypeVRegConfigurationContext = 70,
    ObjectTypePsSiloContextNonPaged = 71,
    ObjectTypePsSiloContextPaged = 72,
    ObjectTypeEtwSessionDemuxEntry = 73,
    ObjectTypeNdisCmState = 74,
    ObjectTypeProcessStateChange = 75,
    ObjectTypeThreadStateChange = 76,
    ObjectTypeCrossVmEvent = 77,
    ObjectTypeCrossVmMutant = 78,
    ObjectTypeSchedulerSharedData = 79,
    ObjectTypeCpuPartition = 80,
    ObjectTypeVirtualKey = 81,
    ObjectTypeUnknown = 82,
    ObjectTypeMax
} WOBJ_OBJECT_TYPE;

typedef struct _WOBJ_TYPE_DESC {
    // Object type name.
    LPWSTR Name;

    // Hash of object name.
    ULONG NameHash;

    // Object type index.
    WOBJ_OBJECT_TYPE Index; 

    // Resouce id for icon.
    INT ResourceImageId; 
    
    // Resource id in stringtable.
    INT ResourceStringId; 
    
    // Individual image id for each object type (maybe the same for few objects).
    INT ImageIndex;
} WOBJ_TYPE_DESC, *PWOBJ_TYPE_DESC;

#define OBTYPE_NAME_DESKTOP         L"Desktop"
#define OBTYPE_NAME_DIRECTORY       L"Directory"
#define OBTYPE_NAME_FILE            L"File"
#define OBTYPE_NAME_PROCESS         L"Process"
#define OBTYPE_NAME_THREAD          L"Thread"
#define OBTYPE_NAME_TOKEN           L"Token"
#define OBTYPE_NAME_UNKNOWN         L""

//
// Well known type name(case sensitive) hashes.
//
// Generated by supHashUnicodeString.
//
#define OBTYPE_HASH_SYMBOLIC_LINK   0x7f82e7ac
#define OBTYPE_HASH_SECTION         0xbd107d45
#define OBTYPE_HASH_DRIVER          0x72d80048
#define OBTYPE_HASH_DEVICE          0x5646fcd6
#define OBTYPE_HASH_WINSTATION      0x1551ade4
#define OBTYPE_HASH_TYPE            0x8041ee9a
#define OBTYPE_HASH_DIRECTORY       0xa4531c4d

//
// For plugins support.
//
#define ObjectTypeAnyType 0xfe
#define ObjectTypeNone 0xff

//
// Unused id's
//
#define UNUSED_IDI_ICON                 IDI_ICON_UNKNOWN
#define UNUSED_IDS_DESC                 IDS_DESC_UNKNOWN

#define IDI_ICON_IORING                 UNUSED_IDI_ICON
#define IDI_ICON_ACTIVATIONOBJECT       UNUSED_IDI_ICON
#define IDI_ICON_ACTIVITYREFERENCE      UNUSED_IDI_ICON
#define IDI_ICON_COREMESSAGING          UNUSED_IDI_ICON
#define IDI_ICON_COVERAGESAMPLER        UNUSED_IDI_ICON
#define IDI_ICON_RAWINPUTMANAGER        UNUSED_IDI_ICON
#define IDI_ICON_WAITCOMPLETIONPACKET   UNUSED_IDI_ICON
#define IDI_ICON_IOCOMPLETION_RESERVE   UNUSED_IDI_ICON
#define IDI_ICON_USERAPCRESERVE         UNUSED_IDI_ICON
#define IDI_ICON_ENERGYTRACKER          UNUSED_IDI_ICON
#define IDI_ICON_TERMINAL               UNUSED_IDI_ICON
#define IDI_ICON_TERMINALEVENTQUEUE     UNUSED_IDI_ICON
#define IDI_ICON_ETWSESSIONDEMUXENTRY   UNUSED_IDI_ICON
#define IDI_ICON_NDISCMSTATE            UNUSED_IDI_ICON
#define IDI_ICON_PSSILOCONTEXT          UNUSED_IDI_ICON
#define IDI_ICON_VIRTUALKEY             UNUSED_IDI_ICON
#define IDI_ICON_VREGCFGCTX             UNUSED_IDI_ICON
#define IDI_ICON_PROCESSSTATECHANGE     UNUSED_IDI_ICON
#define IDI_ICON_THREADSTATECHANGE      UNUSED_IDI_ICON
#define IDI_ICON_CPUPARTITION           UNUSED_IDI_ICON
#define IDI_ICON_SCHEDULERSHAREDDATA    UNUSED_IDI_ICON
#define IDI_ICON_CROSSVMEVENT           UNUSED_IDI_ICON
#define IDI_ICON_CROSSVMMUTANT          UNUSED_IDI_ICON

extern WOBJ_TYPE_DESC g_TypeUnknown;
extern WOBJ_TYPE_DESC g_TypeSymbolicLink;
extern WOBJ_TYPE_DESC g_TypeDevice;
extern WOBJ_TYPE_DESC g_TypeDriver;
extern WOBJ_TYPE_DESC g_TypeKey;
extern WOBJ_TYPE_DESC g_TypeToken;
extern ULONG g_ObjectTypesCount;

HIMAGELIST ObManagerLoadImageList(
    VOID);

INT ObManagerGetImageIndexByTypeName(
    _In_opt_ LPCWSTR lpTypeName);

WOBJ_OBJECT_TYPE ObManagerGetIndexByTypeName(
    _In_opt_ LPCWSTR lpTypeName);

LPWSTR ObManagerGetNameByIndex(
    _In_ WOBJ_OBJECT_TYPE TypeIndex);

WOBJ_TYPE_DESC* ObManagerGetEntryByTypeIndex(
    _In_ WOBJ_OBJECT_TYPE TypeIndex);

WOBJ_TYPE_DESC *ObManagerGetEntryByTypeName(
    _In_opt_ LPCWSTR lpTypeName);

PVOID ObManagerTable();

VOID ObManagerTest();

```

`Source/WinObjEx64/plugmngr.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2026
*
*  TITLE:       PLUGMNGR.C
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
*  Plugin manager.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#define OEMRESOURCE
#include "global.h"

static LIST_ENTRY g_PluginsListHead;
volatile UINT g_PluginCount = 0;

static HANDLE PmDlgThreadHandle = NULL;
static FAST_EVENT PmDlgInitializedEvent = FAST_EVENT_INIT;

/*
* PmpReadSystemMemoryEx
*
* Purpose:
*
* Read system memory function wrapper for plugins.
*
*/
BOOL PmpReadSystemMemoryEx(
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead
)
{
    return kdReadSystemMemory2(NULL, Address, Buffer, BufferSize, NumberOfBytesRead);
}

/*
* PmpOpenObjectByType
*
* Purpose:
*
* Open object by type (plugin version).
*
*/
NTSTATUS PmpOpenObjectByType(
    _Out_ HANDLE* ObjectHandle,
    _In_ ULONG TypeIndex,
    _In_ PUNICODE_STRING ObjectDirectory,
    _In_ PUNICODE_STRING ObjectName,
    _In_ ACCESS_MASK DesiredAccess
)
{
    __try {
        return supOpenNamedObjectByType(ObjectHandle,
            TypeIndex,
            ObjectDirectory,
            ObjectName,
            DesiredAccess);
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }
}

/*
* PmpReportInvalidPlugin
*
* Purpose:
*
* Log invalid plugin load attempt.
*
*/
VOID PmpReportInvalidPlugin(
    _In_ LPWSTR lpszPluginFileName
)
{
    LPWSTR lpCombined;
    SIZE_T cbSize;
    SIZE_T cchFileName;

    static const WCHAR szPrefix[] = TEXT("File ");
    static const WCHAR szSuffix[] = TEXT(" is not a valid WinObjEx64 plugin");

    cchFileName = _strlen(lpszPluginFileName);

    cbSize = (RTL_NUMBER_OF(szPrefix) - 1 +
        cchFileName +
        RTL_NUMBER_OF(szSuffix) - 1 +
        1) * sizeof(WCHAR);

    lpCombined = (LPWSTR)supHeapAlloc(cbSize);
    if (lpCombined) {
        _strcpy(lpCombined, szPrefix);
        _strcat(lpCombined, lpszPluginFileName);
        _strcat(lpCombined, szSuffix);
        logAdd(EntryTypeInformation, lpCombined);
        supHeapFree(lpCombined);
    }
}

/*
* PmpIsValidPlugin
*
* Purpose:
*
* Validate plugin by version info description.
*
*/
BOOL PmpIsValidPlugin(
    _In_ LPWSTR lpszPluginName
)
{
    BOOL bResult = FALSE;
    DWORD dwHandle, dwSize;
    PVOID versionInfo = NULL;
    LPTRANSLATE lpTranslate = NULL;
    LPWSTR lpFileDescription;
    UINT uLength;

    WCHAR szBuffer[100];

    // Get required size first
    dwSize = GetFileVersionInfoSizeEx(0, lpszPluginName, &dwHandle);
    if (dwSize == 0)
        return FALSE;

    // Allocate memory
    versionInfo = supHeapAlloc((SIZE_T)dwSize);
    if (versionInfo == NULL)
        return FALSE;

    do {
#pragma warning(push)
#pragma warning(disable: 6388) //disable warning regarding reserved parameter
        if (!GetFileVersionInfoEx(0, lpszPluginName, dwHandle, dwSize, versionInfo))
            break;
#pragma warning(pop)

        // Get translation info
        if (!VerQueryValue(versionInfo,
            T_VERSION_TRANSLATION,
            (LPVOID*)&lpTranslate,
            &uLength) || uLength == 0)
        {
            break;
        }

        // Format version string
        RtlStringCchPrintfSecure(
            szBuffer,
            RTL_NUMBER_OF(szBuffer),
            FORMAT_VERSION_DESCRIPTION,
            lpTranslate[0].wLanguage,
            lpTranslate[0].wCodePage);

        // Query description
        lpFileDescription = NULL;
        if (VerQueryValue(
            versionInfo,
            szBuffer,
            (LPVOID*)&lpFileDescription,
            &uLength) && uLength > 0)
        {
            bResult = (_strcmp(lpFileDescription, WINOBJEX_PLUGIN_DESCRIPTION) == 0);
        }

    } while (FALSE);

    supHeapFree(versionInfo);

    return bResult;
}

/*
* PmpStateChangeCallback
*
* Purpose:
*
* Callback to be called by plugins on state change events.
*
*/
VOID CALLBACK PmpStateChangeCallback(
    _In_ PWINOBJEX_PLUGIN PluginData,
    _In_ WINOBJEX_PLUGIN_STATE NewState,
    _Reserved_ PVOID Reserved)
{
    UNREFERENCED_PARAMETER(Reserved);

    __try {
        PluginData->State = NewState;
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return;
    }
}

/*
* PmGuiShutdownCallback
*
* Purpose:
*
* Callback to be called by plugins uppon gui shutdown.
*
*/
VOID CALLBACK PmGuiShutdownCallback(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ HINSTANCE PluginInstance,
    _Reserved_ PVOID Reserved
)
{
    UNREFERENCED_PARAMETER(Reserved);

    WCHAR szClassName[100];

    RtlStringCchPrintfSecure(szClassName,
        RTL_NUMBER_OF(szClassName),
        TEXT("%wsWndClass"),
        PluginData->Name);

    UnregisterClass(szClassName, PluginInstance);
}

/*
* PmGuiInitCallback
*
* Purpose:
*
* Callback to be called by plugins uppon gui initialization.
*
*/
BOOL CALLBACK PmGuiInitCallback(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ HINSTANCE PluginInstance,
    _In_ WNDPROC WndProc,
    _Reserved_ PVOID Reserved
)
{
    ATOM classAtom;
    DWORD dwLastError;
    WNDCLASSEX  wincls;
    WCHAR szClassName[MAX_PLUGIN_NAME + sizeof(L"WndClass") + 1];

    UNREFERENCED_PARAMETER(Reserved);

    __try {

        RtlSecureZeroMemory(&szClassName, sizeof(szClassName));

        //
        // Register window class once.
        //
        RtlStringCchPrintfSecure(szClassName,
            RTL_NUMBER_OF(szClassName),
            TEXT("%wsWndClass"),
            PluginData->Name);

        RtlSecureZeroMemory(&wincls, sizeof(wincls));
        wincls.cbSize = sizeof(WNDCLASSEX);
        wincls.lpfnWndProc = WndProc;
        wincls.hInstance = PluginInstance;
        wincls.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wincls.lpszClassName = szClassName;

        wincls.hCursor = (HCURSOR)LoadImage(NULL,
            MAKEINTRESOURCE(OCR_SIZENS),
            IMAGE_CURSOR,
            0,
            0,
            LR_SHARED);

        wincls.hIcon = (HICON)LoadImage(
            g_WinObj.hInstance,
            MAKEINTRESOURCE(IDI_ICON_MAIN),
            IMAGE_ICON,
            0,
            0,
            LR_SHARED);

        classAtom = RegisterClassEx(&wincls);
        dwLastError = GetLastError();

        if ((classAtom == 0) && (dwLastError != ERROR_CLASS_ALREADY_EXISTS))
            kdDebugPrint("Could not register window class, err = %lu\r\n", dwLastError);

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return FALSE;
    }

    return TRUE;
}

/*
* PmpShowInitializationError
*
* Purpose:
*
* Output PluginInit error.
*
*/
VOID PmpShowInitializationError(
    _In_ HWND ParentWindow,
    _In_ ULONG ErrorCode,
    _In_ LPWSTR FileName //limited to MAX_PATH as per WIN32_FIND_DATA
)
{
    WCHAR szMessage[1024];

    _strcpy(szMessage, TEXT("There is an error "));
    ultohex(ErrorCode, _strend(szMessage));
    _strcat(szMessage, TEXT(" while initializing plugin\r\n"));
    _strcat(szMessage, FileName);
    _strcat(szMessage, TEXT("\r\n\nThis plugin will be skipped."));
    MessageBox(ParentWindow, szMessage, NULL, MB_ICONERROR);
}

/*
* PmpWorkerThread
*
* Purpose:
*
* Worker thread for building list of available plugins.
*
*/
DWORD WINAPI PmpWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOLEAN PluginInitialized;
    HWND ParentWindow = (HWND)Parameter;
    BOOL MenuInitialized = FALSE;

    WCHAR szSearchDirectory[1024];
    WCHAR szPluginPath[1024];

    DWORD dwSize;

    SIZE_T Length;
    HANDLE hFile;
    WIN32_FIND_DATA fdata;

    INT cMenu;
    HMENU hMainMenu = GetMenu(ParentWindow), hPluginMenu = NULL, hMenuFile;
    MENUITEMINFO MenuItem;

    WINOBJEX_PLUGIN_INTERNAL* PluginEntry;
    pfnPluginInit PluginInit;
    HMODULE hPlugin;

    InitializeListHead(&g_PluginsListHead);

    //
    // Query working directory.
    //
    RtlSecureZeroMemory(szSearchDirectory, sizeof(szSearchDirectory));
    dwSize = GetCurrentDirectory(MAX_PATH, szSearchDirectory);
    if ((dwSize == 0) || (dwSize > MAX_PATH))
        ExitThread((DWORD)-1);

    _strcat(szSearchDirectory, TEXT("\\plugins\\"));

    //
    // Build plugin path.
    //
    RtlSecureZeroMemory(szPluginPath, sizeof(szPluginPath));
    _strcpy(szPluginPath, szSearchDirectory);
    _strcat(szSearchDirectory, TEXT("*.dll"));

    Length = _strlen(szPluginPath);

    //
    // Look for dlls in the plugin subdirectory.
    //
    hFile = FindFirstFileEx(szSearchDirectory, FindExInfoBasic, &fdata, FindExSearchNameMatch, NULL, 0);
    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if (g_PluginCount >= WINOBJEX_MAX_PLUGINS)
                break;

            szPluginPath[Length] = 0;
            if ((Length + _strlen(fdata.cFileName) + 1) < RTL_NUMBER_OF(szPluginPath)) {
                _strcat(szPluginPath, fdata.cFileName);
            }
            else {
                continue;
            }

            //
            // Validate plugin dll.
            //
            if (!PmpIsValidPlugin(szPluginPath)) {
                PmpReportInvalidPlugin(szPluginPath);
                continue;
            }

            //
            // Load library and query plugin export.
            //
            hPlugin = LoadLibraryEx(szPluginPath, NULL, 0);
            if (hPlugin) {

                PluginInit = (pfnPluginInit)GetProcAddress(hPlugin, WINOBJEX_PLUGIN_EXPORT);
                if (PluginInit == NULL) {
                    FreeLibrary(hPlugin);
                }
                else {

                    PluginEntry = (WINOBJEX_PLUGIN_INTERNAL*)supHeapAlloc(sizeof(WINOBJEX_PLUGIN_INTERNAL));
                    if (PluginEntry) {

                        //
                        // Initialize plugin and initialize main menu entry if not initialized.
                        //
                        __try {
                            PluginEntry->Plugin.cbSize = sizeof(WINOBJEX_PLUGIN);
                            PluginEntry->Plugin.AbiVersion = WINOBJEX_PLUGIN_ABI_VERSION;
                            PluginInitialized = PluginInit(&PluginEntry->Plugin);
                        }
                        __except (WOBJ_EXCEPTION_FILTER_LOG) {
                            PmpShowInitializationError(ParentWindow, GetExceptionCode(), fdata.cFileName);
                            PluginInitialized = FALSE;
                        }

                        // Strict check ABI
                        if (PluginInitialized) {
                            if (PluginEntry->Plugin.cbSize < sizeof(WINOBJEX_PLUGIN) ||
                                PluginEntry->Plugin.AbiVersion != WINOBJEX_PLUGIN_ABI_VERSION ||
                                PluginEntry->Plugin.RequiredPluginSystemVersion > WOBJ_PLUGIN_SYSTEM_VERSION)
                            {
                                // Incompatible plugin, report and skip
                                PmpReportInvalidPlugin(szPluginPath);
                                PluginInitialized = FALSE;
                            }
                        }

                        if (PluginInitialized) {

                            InsertHeadList(&g_PluginsListHead, &PluginEntry->ListEntry);

                            //
                            // Set callbacks here.
                            //
                            PluginEntry->Plugin.StateChangeCallback = (pfnStateChangeCallback)&PmpStateChangeCallback;
                            PluginEntry->Plugin.GuiInitCallback = (pfnGuiInitCallback)&PmGuiInitCallback;
                            PluginEntry->Plugin.GuiShutdownCallback = (pfnGuiShutdownCallback)&PmGuiShutdownCallback;

                            //
                            // Remember plugin id.
                            //
                            PluginEntry->Id = ID_MENU_PLUGINS + g_PluginCount;
                            g_PluginCount += 1;

                            PluginEntry->Module = hPlugin;

                            //
                            // List general purpose plugins.
                            //
                            if (PluginEntry->Plugin.Type == DefaultPlugin) {

                                if (MenuInitialized == FALSE) {

                                    hPluginMenu = CreatePopupMenu();
                                    if (hPluginMenu) {

                                        RtlSecureZeroMemory(&MenuItem, sizeof(MenuItem));
                                        MenuItem.cbSize = sizeof(MenuItem);
                                        MenuItem.fMask = MIIM_SUBMENU | MIIM_STRING;
                                        MenuItem.dwTypeData = TEXT("Plugins");
                                        MenuItem.hSubMenu = hPluginMenu;

                                        MenuInitialized = InsertMenuItem(hMainMenu,
                                            GetMenuItemCount(hMainMenu) - 1,
                                            TRUE,
                                            &MenuItem);

                                        if (MenuInitialized)
                                            DrawMenuBar(ParentWindow);

                                    }
                                }

                                //
                                // Add menu entry.
                                //
                                if ((MenuInitialized) && (hPluginMenu)) {

                                    RtlSecureZeroMemory(&MenuItem, sizeof(MenuItem));
                                    MenuItem.cbSize = sizeof(MenuItem);
                                    MenuItem.fMask = MIIM_STRING | MIIM_ID;
                                    MenuItem.dwTypeData = PluginEntry->Plugin.Name;

                                    //
                                    // Associate menu entry id with plugin id for further searches.
                                    //
                                    MenuItem.wID = PluginEntry->Id;

                                    InsertMenuItem(hPluginMenu,
                                        PluginEntry->Id,
                                        FALSE,
                                        &MenuItem);

                                }
                            }
                        } // if PluginInitialized
                        else {
                            supHeapFree(PluginEntry);
                            FreeLibrary(hPlugin);
                        }
                    } //if PluginEntry
                    else {
                        FreeLibrary(hPlugin);
                    }
                }

            }

        } while (FindNextFile(hFile, &fdata));
        FindClose(hFile);
    }

    //
    // Must be called after plugin manager startup as plugins are not signed by MS.
    //
    supSetProcessMitigationImagesPolicy();

    if (g_PluginCount) {
        hMenuFile = GetSubMenu(hMainMenu, IDMM_FILE);
        if (hMenuFile) {
            cMenu = GetMenuItemCount(hMenuFile);
            InsertMenu(hMenuFile, cMenu - 1, MF_BYPOSITION, ID_FILE_VIEW_PLUGINS, T_VIEW_PLUGINS);
            InsertMenu(hMenuFile, cMenu, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }
    }

    ExitThread(0);
}

/*
* PluginManagerCreate
*
* Purpose:
*
* Create list of available plugins.
*
*/
VOID PmCreate(
    _In_ HWND ParentWindow
)
{
    HANDLE hThread = supCreateThread(
        (LPTHREAD_START_ROUTINE)PmpWorkerThread,
        (PVOID)ParentWindow,
        0);

    if (hThread) CloseHandle(hThread);
}

/*
* PluginManagerDestroy
*
* Purpose:
*
* Destroy list of available plugins.
*
*/
VOID PmDestroy()
{
    PLIST_ENTRY Head, Next;
    WINOBJEX_PLUGIN_INTERNAL* PluginEntry;

    Head = &g_PluginsListHead;

    ASSERT_LIST_ENTRY_VALID(Head);
    if (IsListEmpty(Head))
        return;

    Next = Head->Flink;
    while ((Next != NULL) && (Next != Head)) {
        PluginEntry = CONTAINING_RECORD(Next, WINOBJEX_PLUGIN_INTERNAL, ListEntry);
        Next = Next->Flink;

        __try {
            if (PluginEntry->Plugin.StopPlugin)
                PluginEntry->Plugin.StopPlugin();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
        supHeapFree(PluginEntry);
    }
}

/*
* PmpGetEntryById
*
* Purpose:
*
* Lookup entry in plugins list by plugin id.
*
*/
WINOBJEX_PLUGIN_INTERNAL* PmpGetEntryById(
    _In_ UINT Id
)
{
    PLIST_ENTRY Head, Next;
    WINOBJEX_PLUGIN_INTERNAL* PluginEntry;

    Head = &g_PluginsListHead;

    ASSERT_LIST_ENTRY_VALID_ERROR_X(Head, NULL);
    if (IsListEmpty(Head))
        return NULL;

    Next = Head->Flink;
    while ((Next != NULL) && (Next != Head)) {
        PluginEntry = CONTAINING_RECORD(Next, WINOBJEX_PLUGIN_INTERNAL, ListEntry);
        if (PluginEntry->Id == Id) {
            return PluginEntry;
        }
        Next = Next->Flink;
    }

    return NULL;
}

/*
* PmpFreeObjectData
*
* Purpose:
*
* Free plugin object data.
*
*/
VOID PmpFreeObjectData(
    _In_ PWINOBJEX_PARAM_OBJECT ParamObject
)
{
    supFreeDuplicatedUnicodeString(g_obexHeap, &ParamObject->Directory, FALSE);
    supFreeDuplicatedUnicodeString(g_obexHeap, &ParamObject->Name, FALSE);
}

/*
* PmpAllocateObjectData
*
* Purpose:
*
* Allocate fields of plugin object and copy current object data.
*
*/
BOOL PmpAllocateObjectData(
    _In_ PWINOBJEX_PARAM_OBJECT ParamObject
)
{
    return supGetCurrentObjectPath(FALSE, &ParamObject->Directory) && 
        supGetCurrentObjectName(&ParamObject->Name);
}

/*
* PmProcessEntry
*
* Purpose:
*
* Handler for plugins activation.
*
*/
VOID PmProcessEntry(
    _In_ HWND ParentWindow,
    _In_ UINT Id
)
{
    NTSTATUS ntStatus;
    WINOBJEX_PLUGIN_INTERNAL* PluginEntry;

    WINOBJEX_PARAM_BLOCK ParamBlock;

    WCHAR szMessage[MAX_PATH * 2];

    __try {
        PluginEntry = PmpGetEntryById(Id);
        if (PluginEntry) {

            if ((PluginEntry->Plugin.StartPlugin == NULL) ||
                (PluginEntry->Plugin.StopPlugin == NULL))
                return;

            if (!PluginEntry->Plugin.Capabilities.u1.SupportMultipleInstances) {
                if (PluginEntry->Plugin.State == PluginRunning) {

                    _strcpy(szMessage, TEXT("The following plugin \""));
                    _strcat(szMessage, PluginEntry->Plugin.Name);
                    _strcat(szMessage, TEXT("\" reports it is already running.\r\n\nRestart it?"));

                    if (MessageBox(ParentWindow,
                        szMessage,
                        PROGRAM_NAME,
                        MB_ICONQUESTION | MB_YESNO) == IDYES)
                    {
                        //
                        // Force restart plugin.
                        //
                        __try {
                            PluginEntry->Plugin.StopPlugin();
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER) {
                            _strcpy(szMessage, TEXT("There is an error during plugin stop, code = "));
                            ultohex(GetExceptionCode(), _strend(szMessage));
                            MessageBox(ParentWindow, szMessage, NULL, MB_ICONERROR);
                        }
                    }
                    else {
                        //
                        // Restart option not selected, leave.
                        //
                        return;
                    }
                }
            }

            //
            // Check plugin requirements.
            //

            if (g_WinObj.IsWine && PluginEntry->Plugin.Capabilities.u1.SupportWine == FALSE) {
                
                MessageBox(ParentWindow, 
                    TEXT("This plugin does not support Wine"), 
                    PROGRAM_NAME, MB_ICONINFORMATION);

                return;
            }

            if (PluginEntry->Plugin.Capabilities.u1.NeedAdmin && g_kdctx.IsFullAdmin == FALSE) {
                
                MessageBox(ParentWindow, 
                    TEXT("This plugin requires administrator privileges and cannot be run.\n\nIf your account is in an Administrator group make sure you run WinObjEx64 elevated."), 
                    PROGRAM_NAME, MB_ICONINFORMATION);

                return;
            }

            if (PluginEntry->Plugin.Capabilities.u1.NeedDriver && kdIoDriverLoaded() == FALSE) {
                
                MessageBox(ParentWindow, 
                    TEXT("This plugin requires driver usage to run"), 
                    PROGRAM_NAME, MB_ICONINFORMATION);

                return;
            }

            RtlSecureZeroMemory(&ParamBlock, sizeof(ParamBlock));

            //
            // Copy selected object data to plugin object.
            //
            if (PluginEntry->Plugin.Type == ContextPlugin) {

                if (!PmpAllocateObjectData(&ParamBlock.Object)) {
                    
                    MessageBox(ParentWindow, 
                        TEXT("Cannot allocate memory for plugin data"), 
                        PROGRAM_NAME, MB_ICONERROR);
                    
                    return;
                }
            }

            ParamBlock.ParentWindow = ParentWindow;
            ParamBlock.Instance = g_WinObj.hInstance;
            ParamBlock.SystemRangeStart = g_kdctx.SystemRangeStart;
            ParamBlock.CurrentDPI = g_WinObj.CurrentDPI;

            //
            // Function pointers.
            // 
            ParamBlock.ReadSystemMemoryEx = (pfnReadSystemMemoryEx)&PmpReadSystemMemoryEx;
            ParamBlock.GetInstructionLength = (pfnGetInstructionLength)&kdGetInstructionLength;
            ParamBlock.OpenNamedObjectByType = (pfnOpenNamedObjectByType)&PmpOpenObjectByType;

            //
            // Version.
            //
            ParamBlock.Version = g_WinObj.osver;

            ntStatus = PluginEntry->Plugin.StartPlugin(&ParamBlock);

            if (!NT_SUCCESS(ntStatus)) {
                _strcpy(szMessage, TEXT("Could not start plugin, error code 0x"));
                ultohex((ULONG)ntStatus, _strend(szMessage));
                MessageBox(ParentWindow, szMessage, NULL, MB_ICONERROR);
            }

            if (PluginEntry->Plugin.Type == ContextPlugin) {
                PmpFreeObjectData(&ParamBlock.Object);
            }

        }

    }
    __except (WOBJ_EXCEPTION_FILTER) {
        return;
    }
}

/*
* PmpIsSupportedObject
*
* Purpose:
*
* Return TRUE if the given object type is supported by plugin.
*
*/
BOOLEAN PmpIsSupportedObject(
    _In_ WINOBJEX_PLUGIN* Plugin,
    _In_ UCHAR ObjectType
)
{
    UCHAR i;

    if (Plugin->SupportedObjectsIds[0] == ObjectTypeAnyType)
        return TRUE;

    for (i = 0; i < PLUGIN_MAX_SUPPORTED_OBJECT_ID; i++)
        if (Plugin->SupportedObjectsIds[i] != ObjectTypeNone)
            if (Plugin->SupportedObjectsIds[i] == ObjectType)
                return TRUE;

    return FALSE;
}

/*
* PmBuildPluginPopupMenuByObjectType
*
* Purpose:
*
* Builds popup menu with plugins dedicated for currently selected object type.
*
*/
VOID PmBuildPluginPopupMenuByObjectType(
    _In_ HMENU ContextMenu,
    _In_ UCHAR ObjectType)
{
    BOOL bInitOk = FALSE;
    PLIST_ENTRY ptrHead, ptrNext;
    WINOBJEX_PLUGIN_INTERNAL* pluginEntry;
    MENUITEMINFO menuItem;

    ptrHead = &g_PluginsListHead;

    ASSERT_LIST_ENTRY_VALID(ptrHead);
    if (IsListEmpty(ptrHead))
        return;

    ptrNext = ptrHead->Flink;
    while ((ptrNext != NULL) && (ptrNext != ptrHead)) {
        pluginEntry = CONTAINING_RECORD(ptrNext, WINOBJEX_PLUGIN_INTERNAL, ListEntry);
        if (pluginEntry->Plugin.Type == ContextPlugin) {
            if (PmpIsSupportedObject(&pluginEntry->Plugin, ObjectType)) {

                //
                // Insert separator.
                //
                if (bInitOk == FALSE) {
                    RtlSecureZeroMemory(&menuItem, sizeof(menuItem));
                    menuItem.cbSize = sizeof(menuItem);
                    menuItem.fType = MFT_SEPARATOR;
                    menuItem.fMask = MIIM_TYPE;

                    bInitOk = InsertMenuItem(ContextMenu,
                        GetMenuItemCount(ContextMenu),
                        TRUE,
                        &menuItem);
                }

                RtlSecureZeroMemory(&menuItem, sizeof(menuItem));
                menuItem.cbSize = sizeof(menuItem);
                menuItem.fMask = MIIM_STRING | MIIM_ID;
                menuItem.dwTypeData = pluginEntry->Plugin.Name;

                //
                // Associate menu entry id with plugin id for further searches.
                //
                menuItem.wID = pluginEntry->Id;

                InsertMenuItem(ContextMenu,
                    pluginEntry->Id,
                    FALSE,
                    &menuItem);

            }
        }
        ptrNext = ptrNext->Flink;
    }

}

/*
* PmpEnumerateEntries
*
* Purpose:
*
* Fill listview with loaded plugins.
*
*/
VOID PmpEnumerateEntries(
    _In_ HWND hwndDlg)
{
    HWND ListView = GetDlgItem(hwndDlg, IDC_PLUGINLIST);
    PLIST_ENTRY Head, Next;
    WINOBJEX_PLUGIN_INTERNAL* PluginEntry;
    LPWSTR lpType;

    LVITEM  lvItem;
    INT lvItemIndex;
    WCHAR szBuffer[100];

    LVCOLUMNS_DATA columnData[] =
    {
        { L"Name", 200, LVCFMT_LEFT,  I_IMAGENONE },
        { L"Authors", 80, LVCFMT_CENTER,  I_IMAGENONE },
        { L"Type", 80, LVCFMT_CENTER,  I_IMAGENONE },
        { L"Version", 80, LVCFMT_CENTER,  I_IMAGENONE }
    };

    supSetListViewSettings(ListView,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        NULL,
        0);

    supAddLVColumnsFromArray(
        ListView,
        columnData,
        RTL_NUMBER_OF(columnData));

    Head = &g_PluginsListHead;
    Next = Head->Flink;
    while ((Next != NULL) && (Next != Head)) {

        PluginEntry = CONTAINING_RECORD(Next, WINOBJEX_PLUGIN_INTERNAL, ListEntry);

        RtlSecureZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.pszText = PluginEntry->Plugin.Name;
        lvItem.iItem = MAXINT;
        lvItem.lParam = (LPARAM)PluginEntry;
        lvItemIndex = ListView_InsertItem(ListView, &lvItem);

        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 1;
        lvItem.pszText = PluginEntry->Plugin.Authors;
        lvItem.iItem = lvItemIndex;
        ListView_SetItem(ListView, &lvItem);

        if (PluginEntry->Plugin.Type == DefaultPlugin)
            lpType = TEXT("Default");
        else if (PluginEntry->Plugin.Type == ContextPlugin)
            lpType = TEXT("Context");
        else
            lpType = T_UnknownType;

        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 2;
        lvItem.pszText = lpType;
        lvItem.iItem = lvItemIndex;
        ListView_SetItem(ListView, &lvItem);

        RtlStringCchPrintfSecure(szBuffer,
            100,
            TEXT("%lu.%lu"),
            PluginEntry->Plugin.MajorVersion,
            PluginEntry->Plugin.MinorVersion);

        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 3;
        lvItem.pszText = szBuffer;
        lvItem.iItem = lvItemIndex;
        ListView_SetItem(ListView, &lvItem);

        Next = Next->Flink;
    }
    SetFocus(GetDlgItem(hwndDlg, IDCANCEL));
}

/*
* PmpListSupportedObjectTypes
*
* Purpose:
*
* List plugin supported object types.
*
*/
VOID PmpListSupportedObjectTypes(
    _In_ HWND hwndCB,
    _In_ PWINOBJEX_PLUGIN Plugin
)
{
    UCHAR i;
    LPWSTR lpObjectType;

    supDisableRedraw(hwndCB);
    if (Plugin->SupportedObjectsIds[0] == ObjectTypeAnyType) {
        lpObjectType = TEXT("Any");
        SendMessage(hwndCB, CB_ADDSTRING, (WPARAM)0, (LPARAM)lpObjectType);
    }
    else {

        for (i = 0; i < PLUGIN_MAX_SUPPORTED_OBJECT_ID; i++)
            if (Plugin->SupportedObjectsIds[i] != ObjectTypeNone) {
                lpObjectType = ObManagerGetNameByIndex((WOBJ_OBJECT_TYPE)Plugin->SupportedObjectsIds[i]);
                SendMessage(hwndCB, CB_ADDSTRING, (WPARAM)0, (LPARAM)lpObjectType);
            }

    }
    supEnableRedraw(hwndCB);
}

/*
* PmpShowPluginInfo
*
* Purpose:
*
* Show selected plugin information.
*
*/
VOID PmpShowPluginInfo(
    _In_ HWND hwndDlg,
    _In_ HWND hwndListView,
    _In_ INT itemIndex
)
{
    PWINOBJEX_PLUGIN_INTERNAL PluginData = NULL;
    LPWSTR lpType;
    HWND hwndCB;
    INT nCount;

    WCHAR szModuleName[MAX_PATH + 1];

    if (!supGetListViewItemParam(hwndListView,
        itemIndex,
        (PVOID*)&PluginData))
    {
        return;
    }

    hwndCB = GetDlgItem(hwndDlg, IDC_PLUGIN_OBJECTTYPE);
    SendMessage(hwndCB, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

    supDisableRedraw(hwndDlg);

    if (PluginData->Plugin.Capabilities.u1.NeedAdmin)
        lpType = TEXT("Yes");
    else
        lpType = TEXT("No");

    SetDlgItemText(hwndDlg, IDC_PLUGIN_ADMIN, lpType);

    if (PluginData->Plugin.Capabilities.u1.NeedDriver)
        lpType = TEXT("Yes");
    else
        lpType = TEXT("No");

    SetDlgItemText(hwndDlg, IDC_PLUGIN_DRIVER, lpType);

    if (PluginData->Plugin.Capabilities.u1.SupportWine)
        lpType = TEXT("Yes");
    else
        lpType = TEXT("No");

    SetDlgItemText(hwndDlg, IDC_PLUGIN_WINE, lpType);

    if (PluginData->Plugin.Capabilities.u1.SupportMultipleInstances)
        lpType = TEXT("Yes");
    else
        lpType = TEXT("No");

    SetDlgItemText(hwndDlg, IDC_PLUGIN_MINSTANCES, lpType);

    SetDlgItemText(hwndDlg, IDC_PLUGIN_DESC, PluginData->Plugin.Description);

    if (PluginData->Plugin.Type == ContextPlugin) {
        PmpListSupportedObjectTypes(hwndCB, &PluginData->Plugin);
    }

    nCount = (INT)SendMessage(hwndCB, CB_GETCOUNT, 0, 0);
    EnableWindow(hwndCB, (nCount > 0) ? TRUE : FALSE);
    SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

    RtlSecureZeroMemory(szModuleName, sizeof(szModuleName));
    GetModuleFileName(PluginData->Module, (LPWSTR)&szModuleName, MAX_PATH);
    SetDlgItemText(hwndDlg, IDC_PLUGIN_FILENAME, szModuleName);

    supEnableRedraw(hwndDlg);
}

/*
* PmpHandleNotify
*
* Purpose:
*
* Plugin Manager dialog WM_NOTIFY handler.
*
*/
VOID PmpHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    LPNMLISTVIEW pListView = (LPNMLISTVIEW)lParam;


    if (pListView->hdr.idFrom != IDC_PLUGINLIST)
        return;

    switch (pListView->hdr.code) {

    case NM_CLICK:

        PmpShowPluginInfo(hwndDlg, 
            pListView->hdr.hwndFrom,
            pListView->iItem);

        break;

    case LVN_ITEMCHANGED:

        if ((pListView->uNewState & LVIS_SELECTED) &&
            !(pListView->uOldState & LVIS_SELECTED))
        {
            PmpShowPluginInfo(hwndDlg,
                pListView->hdr.hwndFrom,
                pListView->iItem);
        }

        break;

    }

}

/*
* PmpHandleSettingsChange
*
* Purpose:
*
* Handle global settings change.
*
*/
VOID PmpHandleSettingsChange(
    _In_ HWND hwndDlg
)
{
    DWORD lvExStyle;
    HWND hwndList = GetDlgItem(hwndDlg, IDC_PLUGINLIST);

    lvExStyle = ListView_GetExtendedListViewStyle(hwndList);
    if (g_WinObj.ListViewDisplayGrid)
        lvExStyle |= LVS_EX_GRIDLINES;
    else
        lvExStyle &= ~LVS_EX_GRIDLINES;

    ListView_SetExtendedListViewStyle(hwndList, lvExStyle);
}

/*
* PmpDialogProc
*
* Purpose:
*
* Plugin Manager Window dialog procedure.
*
*/
INT_PTR CALLBACK PmpDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    if (uMsg == g_WinObj.SettingsChangeMessage) {
        PmpHandleSettingsChange(hwndDlg);
        return TRUE;
    }

    switch (uMsg) {

    case WM_INITDIALOG:
        supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
        PmpEnumerateEntries(hwndDlg);
        break;

    case WM_COMMAND:

        if (LOWORD(wParam) == IDCANCEL) {
            DestroyWindow(hwndDlg);
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_NOTIFY:
        PmpHandleNotify(hwndDlg, lParam);
        break;

    }

    return FALSE;
}

/*
* PmViewPluginsWorkerThread
*
* Purpose:
*
* Plugins view dialog worker thread.
*
*/
DWORD PmViewPluginsWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwndDlg;

    UNREFERENCED_PARAMETER(Parameter);

    hwndDlg = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_VIEWPLUGINS),
        0,
        &PmpDialogProc,
        0);

    supSetFastEvent(&PmDlgInitializedEvent);

    do {

        bResult = GetMessage(&message, NULL, 0, 0);
        if (bResult == -1)
            break;

        if (!IsDialogMessage(hwndDlg, &message)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }

    } while (bResult != 0);

    supResetFastEvent(&PmDlgInitializedEvent);

    if (PmDlgThreadHandle) {
        NtClose(PmDlgThreadHandle);
        PmDlgThreadHandle = NULL;
    }

    return 0;
}

/*
* PmViewPlugins
*
* Purpose:
*
* Show plugins view dialog.
*
*/
VOID PmViewPlugins(
    VOID
)
{
    if (!PmDlgThreadHandle) {
        PmDlgThreadHandle = supCreateDialogWorkerThread(PmViewPluginsWorkerThread, NULL, 0);
        if (PmDlgThreadHandle)
            supWaitForFastEvent(&PmDlgInitializedEvent, NULL);
    }
}

```

`Source/WinObjEx64/plugmngr.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       PLUGINMNGR.H
*
*  VERSION:     2.08
*
*  DATE:        14 Jun 2025
*
*  Common header file for the plugin manager.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define WOBJ_PLUGIN_SYSTEM_VERSION 25006

//
// Plugin ABI/capabilities version
//
#define WINOBJEX_PLUGIN_ABI_VERSION 0x0100

//
// Plugin init routine name.
//
#define WINOBJEX_PLUGIN_EXPORT "PluginInit"

//
// Plugin text consts, must include terminating 0.
//
#define MAX_PLUGIN_NAME 32
#define MAX_AUTHORS_NAME 32
#define MAX_PLUGIN_DESCRIPTION 128

#define ID_MENU_PLUGINS       60000
#define WINOBJEX_MAX_PLUGINS  20
#define ID_MENU_PLUGINS_MAX   (ID_MENU_PLUGINS + WINOBJEX_MAX_PLUGINS)

//
// VERSION_INFO "FileDescription" value used for validating plugin.
//
// Plugins prior to 1.87 had "WinObjEx64 Plugin" description field.
// Make a new one to distinguish them because changes in plugin system are too complex.
//
#define WINOBJEX_PLUGIN_DESCRIPTION TEXT("WinObjEx64 Plugin V1.2")

typedef BOOL(CALLBACK* pfnReadSystemMemoryEx)(
    _In_ ULONG_PTR Address,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

typedef UCHAR(CALLBACK* pfnGetInstructionLength)(
    _In_ PVOID ptrCode,
    _Out_ PULONG ptrFlags);

typedef NTSTATUS(*pfnOpenNamedObjectByType)(
    _Out_ HANDLE* ObjectHandle,
    _In_ ULONG TypeIndex,
    _In_ PUNICODE_STRING ObjectDirectory,
    _In_ PUNICODE_STRING ObjectName,
    _In_ ACCESS_MASK DesiredAccess);

typedef struct _WINOBJEX_PARAM_OBJECT {
    UNICODE_STRING Name;
    UNICODE_STRING Directory;
} WINOBJEX_PARAM_OBJECT, * PWINOBJEX_PARAM_OBJECT;

typedef struct _WINOBJEX_PARAM_BLOCK {
    ULONG cbSize;
    HWND ParentWindow;
    HINSTANCE Instance;
    ULONG_PTR SystemRangeStart;
    UINT CurrentDPI;
    RTL_OSVERSIONINFOW Version;
    WINOBJEX_PARAM_OBJECT Object; // used only by Context plugins during StartPlugin callback

    //sys
    pfnReadSystemMemoryEx ReadSystemMemoryEx;
    pfnGetInstructionLength GetInstructionLength;
    pfnOpenNamedObjectByType OpenNamedObjectByType;

    ULONG Reserved[8];
} WINOBJEX_PARAM_BLOCK, * PWINOBJEX_PARAM_BLOCK;

typedef NTSTATUS(CALLBACK* pfnStartPlugin)(
    _In_ PWINOBJEX_PARAM_BLOCK ParamBlock);

typedef void(CALLBACK* pfnStopPlugin)(
    VOID);

typedef struct _WINOBJEX_PLUGIN WINOBJEX_PLUGIN;

typedef enum _WINOBJEX_PLUGIN_STATE {
    PluginInitialization = 0,
    PluginStopped = 1,
    PluginRunning = 2,
    PluginError = 3,
    MaxPluginState
} WINOBJEX_PLUGIN_STATE;

typedef enum _WINOBJEX_PLUGIN_TYPE {
    DefaultPlugin = 0, // General purpose plugin (shown in main menu under "Plugins")
    ContextPlugin = 1, // Object type specific plugin (shown in popup menu for specified object types)
    InvalidPluginType
} WINOBJEX_PLUGIN_TYPE;

typedef void(CALLBACK* pfnStateChangeCallback)(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ WINOBJEX_PLUGIN_STATE NewState,
    _Reserved_ PVOID Reserved);

typedef BOOL(CALLBACK* pfnGuiInitCallback)(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ HINSTANCE PluginInstance,
    _In_ WNDPROC WndProc,
    _Reserved_ PVOID Reserved
    );

typedef VOID(CALLBACK* pfnGuiShutdownCallback)(
    _In_ WINOBJEX_PLUGIN* PluginData,
    _In_ HINSTANCE PluginInstance,
    _Reserved_ PVOID Reserved
    );

#define PLUGIN_MAX_SUPPORTED_OBJECT_ID 0xff

typedef struct _WINOBJEX_PLUGIN {
    ULONG cbSize;
    ULONG AbiVersion;
    union {
        ULONG Flags;
        struct {
            ULONG NeedAdmin : 1;
            ULONG NeedDriver : 1;
            ULONG SupportWine : 1;
            ULONG SupportMultipleInstances : 1;
            ULONG Reserved : 28;
        } u1;
    } Capabilities;
    WINOBJEX_PLUGIN_TYPE Type;
    WINOBJEX_PLUGIN_STATE State;
    WORD MajorVersion;
    WORD MinorVersion;
    ULONG RequiredPluginSystemVersion;
    UCHAR SupportedObjectsIds[PLUGIN_MAX_SUPPORTED_OBJECT_ID]; // Ignored if plugin Type is DefaultPlugin
    WCHAR Name[MAX_PLUGIN_NAME];
    WCHAR Authors[MAX_AUTHORS_NAME];
    WCHAR Description[MAX_PLUGIN_DESCRIPTION];
    pfnStartPlugin StartPlugin;
    pfnStopPlugin StopPlugin;
    pfnStateChangeCallback StateChangeCallback;
    pfnGuiInitCallback GuiInitCallback;
    pfnGuiShutdownCallback GuiShutdownCallback;

    ULONG Reserved[8];
} WINOBJEX_PLUGIN, * PWINOBJEX_PLUGIN;

typedef struct _WINOBJEX_PLUGIN_INTERNAL {
    LIST_ENTRY ListEntry;
    UINT Id;
    HMODULE Module;
    WINOBJEX_PLUGIN Plugin;
} WINOBJEX_PLUGIN_INTERNAL, * PWINOBJEX_PLUGIN_INTERNAL;

typedef BOOLEAN(CALLBACK* pfnPluginInit)(
    _Inout_ PWINOBJEX_PLUGIN PluginData
    );

VOID PmCreate(_In_ HWND ParentWindow);
VOID PmDestroy();

VOID PmProcessEntry(
    _In_ HWND ParentWindow,
    _In_ UINT Id);

VOID PmBuildPluginPopupMenuByObjectType(
    _In_ HMENU ContextMenu,
    _In_ UCHAR ObjectType);

VOID PmViewPlugins(
    VOID);

```

`Source/WinObjEx64/props/propAlpcPort.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2025
*
*  TITLE:       PROPALPCPORT.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"

#define COLUMN_ALPCLIST_SERVER_PORT         0
#define COLUMN_ALPCLIST_CLIENT_PORT         1
#define COLUMN_ALPCLIST_CLIENT_EPROCESS     2
#define COLUMN_ALPCLIST_PROCESSNAME         3

/*
* AlpcPortListHandlePopupMenu
*
* Purpose:
*
* List popup construction.
*
*/
VOID AlpcPortListHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            0,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* AlpcPortListCompareFunc
*
* Purpose:
*
* Listview comparer function.
*
*/
INT CALLBACK AlpcPortListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lpContextParam
)
{
    EXTRASCONTEXT* pDlgContext;

    pDlgContext = (EXTRASCONTEXT*)lpContextParam;
    if (pDlgContext == NULL)
        return 0;

    switch (pDlgContext->lvColumnToSort) {

    case COLUMN_ALPCLIST_SERVER_PORT:
    case COLUMN_ALPCLIST_CLIENT_PORT:
    case COLUMN_ALPCLIST_CLIENT_EPROCESS:
        return supGetMaxOfTwoU64FromHex(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);

    case COLUMN_ALPCLIST_PROCESSNAME:
        return supGetMaxCompareTwoFixedStrings(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            pDlgContext->lvColumnToSort,
            pDlgContext->bInverseSort);

    }

    return 0;
}

/*
* AlpcPortListHandleWMCommand
*
* Purpose:
*
* WM_COMMAND handler.
*
*/
VOID AlpcPortListHandleWMCommand(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    EXTRASCONTEXT* pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);

    UNREFERENCED_PARAMETER(lParam);

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case ID_OBJECT_COPY:

        if (pDlgContext) {

            supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                pDlgContext->lvItemHit,
                pDlgContext->lvColumnHit);

        }

        break;
    }
}

/*
* AlpcPortListHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for page listview.
*
*/
BOOL AlpcPortListHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT nImageIndex;
    LPNMLISTVIEW nhdr = (LPNMLISTVIEW)lParam;
    EXTRASCONTEXT* pDlgContext;

    if (nhdr == NULL) {
        return FALSE;
    }

    if (nhdr->hdr.idFrom != ID_ALPCLIST) {
        return FALSE;
    }

    switch (nhdr->hdr.code) {

    case LVN_COLUMNCLICK:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            pDlgContext->bInverseSort = (~pDlgContext->bInverseSort) & 1;
            pDlgContext->lvColumnToSort = ((NMLISTVIEW*)nhdr)->iSubItem;

            ListView_SortItemsEx(
                pDlgContext->ListView,
                &AlpcPortListCompareFunc,
                pDlgContext);

            if (pDlgContext->bInverseSort)
                nImageIndex = 1;
            else
                nImageIndex = 2;

            supUpdateLvColumnHeaderImage(
                pDlgContext->ListView,
                pDlgContext->lvColumnCount,
                pDlgContext->lvColumnToSort,
                nImageIndex);
        }
        break;

    }

    return FALSE;
}

typedef VOID(CALLBACK* POUTPUT_CLIENTS_CALLBACK)(
    _In_ HWND ListView,
    _In_ ULONG_PTR ServerPortAddress,
    _In_ ULONG_PTR ClientPortAddress,
    _In_ ULONG_PTR OwnerProcess
    );

typedef struct _ALPC_PORT_REF {
    union {
        union {
            ALPC_PORT_7600* Port7600;
            ALPC_PORT_9200* Port9200;
            ALPC_PORT_9600* Port9600;
            ALPC_PORT_10240* Port10240;
        } u1;
        PBYTE Ref;
    };
} ALPC_PORT_REF, * PALPC_PORT_REF;

/*
* AlpcPortEnumerateClients
*
* Purpose:
*
* Enumerate connected clients for given port.
*
*/
BOOL AlpcPortEnumerateClients(
    _In_ ULONG_PTR PortAddress,
    _In_ POUTPUT_CLIENTS_CALLBACK OutputCallback,
    _In_ HWND ListView,
    _Out_ PSIZE_T NumberOfClients
)
{
    BOOLEAN bSuccess = FALSE;
    ULONG objectSize = 0, objectVersion = 0;
    SIZE_T cEntries = 0;
    ULONG_PTR kernelAddress, listHead, serverPortAddress, clientPortAddress;
    LIST_ENTRY listEntry, nextEntry;
    ALPC_PORT_REF selfPort, clientPort;
    ALPC_COMMUNICATION_INFO_COMPAT comsInfo;
    ULONG offset = FIELD_OFFSET(ALPC_COMMUNICATION_INFO_COMPAT, CommunicationList);

    *NumberOfClients = 0;

    //
    // Dump ALPC_PORT.
    //
    selfPort.Ref = (PBYTE)ObDumpAlpcPortObjectVersionAware(PortAddress,
        &objectSize,
        &objectVersion);

    if (selfPort.Ref == NULL) {
        return FALSE;
    }

    do {

        kernelAddress = (ULONG_PTR)selfPort.u1.Port7600->CommunicationInfo;
        listHead = kernelAddress + offset;

        listEntry.Flink = listEntry.Blink = NULL;

        //
        // Read entry head.
        //
        if (!kdReadSystemMemory(listHead,
            &listEntry,
            sizeof(LIST_ENTRY)))
        {
            break;
        }

        //
        // Walk list entries.
        //
        while ((ULONG_PTR)listEntry.Flink != listHead) {

            kernelAddress = (ULONG_PTR)listEntry.Flink - offset;

            RtlSecureZeroMemory(&comsInfo, sizeof(comsInfo));
            if (!kdReadSystemMemory(kernelAddress,
                &comsInfo,
                sizeof(comsInfo)))
            {
                break;
            }


            serverPortAddress = (ULONG_PTR)comsInfo.ServerCommunicationPort;
            clientPortAddress = (ULONG_PTR)comsInfo.ClientCommunicationPort;
            clientPort.Ref = (PBYTE)ObDumpAlpcPortObjectVersionAware(clientPortAddress,
                &objectSize,
                &objectVersion);

            if (clientPort.Ref) {
                OutputCallback(
                    ListView,
                    serverPortAddress,
                    clientPortAddress,
                    (ULONG_PTR)clientPort.u1.Port7600->OwnerProcess);

                cEntries += 1;
                supVirtualFree(clientPort.Ref);
            }
            else {
                break;
            }

            //
            // Read next entry.
            //
            listEntry = comsInfo.CommunicationList;
            nextEntry.Flink = nextEntry.Blink = NULL;
            if (!kdReadSystemMemory(
                (ULONG_PTR)listEntry.Flink,
                &nextEntry,
                sizeof(LIST_ENTRY)))
            {
                break;
            }

            if (nextEntry.Flink == NULL)
                break;
        }

        bSuccess = TRUE;

    } while (FALSE);

    *NumberOfClients = cEntries;

    supVirtualFree(selfPort.Ref);

    return bSuccess;
}

/*
* AlpcPortEnumerateCallback
*
* Purpose:
*
* Connected clients enumeration output callback.
*
*/
VOID CALLBACK AlpcPortEnumerateCallback(
    _In_ HWND ListView,
    _In_ ULONG_PTR ServerPortAddress,
    _In_ ULONG_PTR ClientPortAddress,
    _In_ ULONG_PTR OwnerProcess
)
{
    BOOLEAN bExtQuery = FALSE;
    UNICODE_STRING usImageFileName;
    PUNICODE_STRING pusFileName = NULL;

    INT nIndex;
    LVITEM lvitem;

    HANDLE processId = NULL;

    WCHAR szBuffer[MAX_PATH * 2];

    //
    // ServerPortAddress
    //
    szBuffer[0] = L'0';
    szBuffer[1] = L'x';
    szBuffer[2] = 0;
    u64tohex(ServerPortAddress, &szBuffer[2]);

    RtlSecureZeroMemory(&lvitem, sizeof(lvitem));

    lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvitem.pszText = szBuffer;
    lvitem.iItem = MAXINT;
    nIndex = ListView_InsertItem(ListView, &lvitem);
    if (nIndex == -1)
        return;

    //
    // ClientPortAddress
    //
    szBuffer[0] = L'0';
    szBuffer[1] = L'x';
    szBuffer[2] = 0;
    u64tohex(ClientPortAddress, &szBuffer[2]);

    lvitem.mask = LVIF_TEXT;
    lvitem.iSubItem++;
    lvitem.iItem = nIndex;
    ListView_SetItem(ListView, &lvitem);

    //
    // EPROCESS
    //
    szBuffer[0] = L'0';
    szBuffer[1] = L'x';
    szBuffer[2] = 0;
    u64tohex(OwnerProcess, &szBuffer[2]);

    lvitem.iSubItem++;
    ListView_SetItem(ListView, &lvitem);

    //
    // Process Name
    //
    RtlInitEmptyUnicodeString(&usImageFileName, NULL, 0);

    if (ObGetProcessId(OwnerProcess, &processId)) {

        bExtQuery = NT_SUCCESS(supQueryProcessImageFileNameWin32(processId, &pusFileName));

        if (bExtQuery) {

            if (pusFileName->Buffer && pusFileName->Length) {

                lvitem.pszText = supExtractFileName(pusFileName->Buffer);

            }
            else {
                bExtQuery = FALSE;
            }
            
        }

    }

    if (bExtQuery == FALSE) {

        if (ObGetProcessImageFileName(OwnerProcess, &usImageFileName)) {
            lvitem.pszText = usImageFileName.Buffer;
        }
        else {
            _strcpy(szBuffer, T_Unknown);
            lvitem.pszText = szBuffer;
        }
    
    }

    lvitem.iSubItem++;
    ListView_SetItem(ListView, &lvitem);

    if (pusFileName)
        supHeapFree(pusFileName);

    if (usImageFileName.Buffer)
        RtlFreeUnicodeString(&usImageFileName);
}

/*
* AlpcPortListSetInfo
*
* Purpose:
*
* Query information and fill listview.
* Called each time when page became visible.
*
*/
VOID AlpcPortListSetInfo(
    _In_ HWND hwndDlg,
    _In_ PROP_OBJECT_INFO* Context,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    SIZE_T cEntries = 0;
    WCHAR szBuffer[100];

    ListView_DeleteAllItems(pDlgContext->ListView);
    supDisableRedraw(pDlgContext->ListView);

    if (AlpcPortEnumerateClients(Context->ObjectInfo.ObjectAddress,
        (POUTPUT_CLIENTS_CALLBACK)AlpcPortEnumerateCallback,
        pDlgContext->ListView,
        &cEntries))
    {

        RtlStringCchPrintfSecure(szBuffer, 100, TEXT("%llu connections"), cEntries);
        SetDlgItemText(hwndDlg, ID_ALPCLISTMSG, szBuffer);

    }
    else {

        SetDlgItemText(hwndDlg, ID_ALPCLISTMSG, TEXT("Error, not all connections listed"));

    }
    supEnableRedraw(pDlgContext->ListView);
}

/*
* AlpcPortListCreate
*
* Purpose:
*
* Initialize listview.
* Called once.
*
*/
VOID AlpcPortListCreate(
    _In_ HWND hwndDlg,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    HICON hImage;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"Server Port", 140, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, 2 },
        { L"Client Port", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Client EPROCESS", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE },
        { L"Client Name", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT, I_IMAGENONE }
    };

    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_ALPCLIST);
    if (pDlgContext->ListView == NULL)
        return;

    pDlgContext->ImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 8, 8);
    if (pDlgContext->ImageList) {

        //port image
        hImage = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_PORT),
            IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

        if (hImage) {
            ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hImage);
            DestroyIcon(hImage);
        }

        //sort images
        hImage = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_SORTUP),
            IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

        if (hImage) {
            ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hImage);
            DestroyIcon(hImage);
        }
        hImage = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_SORTDOWN),
            IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

        if (hImage) {
            ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hImage);
            DestroyIcon(hImage);
        }

    }

    //
    // Set listview imagelist, style flags and theme.
    //
    supSetListViewSettings(pDlgContext->ListView,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        pDlgContext->ImageList,
        LVSIL_SMALL);

    //
    // And columns and remember their count.
    //
    pDlgContext->lvColumnCount = supAddLVColumnsFromArray(
        pDlgContext->ListView,
        columnData,
        RTL_NUMBER_OF(columnData));

}

/*
* AlpcPortListDialogProc
*
* Purpose:
*
* ALPC Port connections list page.
*
* WM_INITDIALOG - Initialize listview.
* WM_NOTIFY - Handle list view notifications.
* WM_SHOWWINDOW - Collect info and fill list.
* WM_DESTROY - Free image list.
*
*/
INT_PTR CALLBACK AlpcPortListDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    PROPSHEETPAGE* pSheet;
    PROP_OBJECT_INFO* Context = NULL;
    EXTRASCONTEXT* pDlgContext = NULL;

    switch (uMsg) {

    case WM_SHOWWINDOW:
        if (wParam) {
            Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (Context && pDlgContext) {

                AlpcPortListSetInfo(hwndDlg, Context, pDlgContext);
                if (pDlgContext->ListView) {

                    ListView_SortItemsEx(
                        pDlgContext->ListView,
                        &AlpcPortListCompareFunc,
                        pDlgContext);
                }

            }
        }
        break;

    case WM_NOTIFY:
        return AlpcPortListHandleNotify(hwndDlg, lParam);

    case WM_COMMAND:      
        AlpcPortListHandleWMCommand(hwndDlg, wParam, lParam);
        break;

    case WM_DESTROY:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            if (pDlgContext->ImageList) {
                ImageList_Destroy(pDlgContext->ImageList);
            }
            supHeapFree(pDlgContext);
        }
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        break;

    case WM_INITDIALOG:
        pSheet = (PROPSHEETPAGE*)lParam;
        if (pSheet) {
            SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
            pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
            if (pDlgContext) {
                pDlgContext->lvColumnHit = -1;
                pDlgContext->lvItemHit = -1;
                SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pDlgContext);
                AlpcPortListCreate(hwndDlg, pDlgContext);
            }
        }
        break;

    case WM_CONTEXTMENU:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)AlpcPortListHandlePopupMenu,
                pDlgContext);
        }
        break;

    default:
        return FALSE;

    }
    return TRUE;
}

```

`Source/WinObjEx64/props/propBasic.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       PROPBASIC.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "propDlg.h"
#include "propBasicConsts.h"

typedef VOID(CALLBACK* pfnPropQueryInfoRoutine)(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg,
    _In_ BOOL ExtendedInfoAvailable);

#define PROP_QUERY_INFORMATION_ROUTINE(n) VOID n(   \
    _In_ PROP_OBJECT_INFO* Context,                 \
    _In_ HWND hwndDlg,                              \
    _In_ BOOL ExtendedInfoAvailable)

typedef struct _MITIGATION_BIT_MAP {
    DWORD BitPosition;
    PCWSTR Text;
} MITIGATION_BIT_MAP, * PMITIGATION_BIT_MAP;

// ExtensionPointDisablePolicy
static const MITIGATION_BIT_MAP g_ExtensionPointDisablePolicyMap[] = {
    { 0, TEXT("Extension points disabled") },           // DisableExtensionPoints : 1
};

// ASLRPolicy
static const MITIGATION_BIT_MAP g_ASLRPolicyMap[] = {
    { 0, TEXT("ASLR (Bottom-up)") },                // EnableBottomUpRandomization : 1
    { 1, TEXT("ASLR (Force relocate)") },           // EnableForceRelocateImages : 1
    { 2, TEXT("ASLR (High entropy)") },             // EnableHighEntropy : 1
    { 3, TEXT("ASLR (Disallow stripped images)") }, // DisallowStrippedImages : 1
};

// DynamicCodePolicy
static const MITIGATION_BIT_MAP g_DynamicCodePolicyMap[] = {
    { 0, TEXT("Dynamic code prohibited") },                 // ProhibitDynamicCode : 1
    { 3, TEXT("Dynamic code audit prohibit") },             // AuditProhibitDynamicCode : 1
    { 1, TEXT("Dynamic code prohibited (per-thread)") },    // AllowThreadOptOut : 1
    { 2, TEXT("Dynamic code downgradable") },               // AllowRemoteDowngrade : 1
};

// StrictHandleCheckPolicy
static const MITIGATION_BIT_MAP g_StrictHandleCheckPolicyMap[] = {
    { 0, TEXT("Strict handle checks") },               // RaiseExceptionOnInvalidHandleReference : 1
    { 1, TEXT("Handle exceptions permanently") },      // HandleExceptionsPermanentlyEnabled : 1
};

// SystemCallDisablePolicy
static const MITIGATION_BIT_MAP g_SystemCallDisablePolicyMap[] = {
    { 0, TEXT("Disallow Win32k system calls") },           // DisallowWin32kSystemCalls : 1
    { 1, TEXT("Disallow Win32k system calls (Audit)") },   // AuditDisallowWin32kSystemCalls : 1
    { 2, TEXT("Disallow Fsctl system calls") },            // DisallowFsctlSystemCalls : 1
    { 3, TEXT("Disallow Fsctl system calls (Audit)") },    // AuditDisallowFsctlSystemCalls : 1
};

// SignaturePolicy
static const MITIGATION_BIT_MAP g_SignaturePolicyMap[] = {
    { 0, TEXT("Signatures restricted (Microsoft only)") },        // MicrosoftSignedOnly : 1
    { 1, TEXT("Signatures restricted (Store only)") },            // StoreSignedOnly : 1
    { 2, TEXT("Signatures restricted (Microsoft only, Audit)") }, // AuditMicrosoftSignedOnly : 1
    { 3, TEXT("Signatures restricted (Store only, Audit)") },     // AuditStoreSignedOnly : 1
    { 4, TEXT("Signatures opt-in restriction") },                 // MitigationOptIn : 1
};

// ImageLoadPolicy
static const MITIGATION_BIT_MAP g_ImageLoadPolicyMap[] = {
    { 0, TEXT("Prefer system32 images") },                        // PreferSystem32Images : 1
    { 1, TEXT("Restricted remote images") },                      // NoRemoteImages : 1
    { 2, TEXT("Restricted low mandatory label images") },         // NoLowMandatoryLabelImages : 1
    { 3, TEXT("Restricted remote images (Audit)") },              // AuditNoRemoteImages : 1
    { 4, TEXT("Low integrity images blocked (Audit)") },          // AuditNoLowMandatoryLabelImages : 1
};

// FontDisablePolicy
static const MITIGATION_BIT_MAP g_FontDisablePolicyMap[] = {
    { 0, TEXT("Non-system fonts disabled") },           // DisableNonSystemFonts : 1
    { 1, TEXT("Non-system font loading (Audit)") },     // AuditNonSystemFontLoading : 1
};

// ControlFlowGuardPolicy
static const MITIGATION_BIT_MAP g_ControlFlowGuardPolicyMap[] = {
    { 0, TEXT("Control Flow Guard (CFG) enabled") },    // EnableControlFlowGuard : 1
    { 1, TEXT("Export suppression enabled") },          // EnableExportSuppression : 1
    { 2, TEXT("CFG strict mode") },                     // StrictMode : 1
    { 3, TEXT("eXtended Flow Guard (XFG) enabled") },   // EnableXfg : 1
    { 4, TEXT("XFG audit mode") },                      // EnableXfgAuditMode : 1
};

// PayloadRestrictionPolicy
static const MITIGATION_BIT_MAP g_PayloadRestrictionPolicyMap[] = {
    { 0,  TEXT("Export address filter enabled") },      // EnableExportAddressFilter : 1
    { 1,  TEXT("Export address filter (Audit)") },      // AuditExportAddressFilter : 1
    { 2,  TEXT("Export address filter plus enabled") }, // EnableExportAddressFilterPlus : 1
    { 3,  TEXT("Export address filter plus (Audit)") }, // AuditExportAddressFilterPlus : 1
    { 4,  TEXT("Import address filter enabled") },      // EnableImportAddressFilter : 1
    { 5,  TEXT("Import address filter (Audit)") },      // AuditImportAddressFilter : 1
    { 6,  TEXT("ROP stack pivot enabled") },            // EnableRopStackPivot : 1
    { 7,  TEXT("ROP stack pivot (Audit)") },            // AuditRopStackPivot : 1
    { 8,  TEXT("ROP caller check enabled") },           // EnableRopCallerCheck : 1
    { 9,  TEXT("ROP caller check (Audit)") },           // AuditRopCallerCheck : 1
    { 10, TEXT("ROP sim exec enabled") },               // EnableRopSimExec : 1
    { 11, TEXT("ROP sim exec (Audit)") },               // AuditRopSimExec : 1
};

// SideChannelIsolationPolicy
static const MITIGATION_BIT_MAP g_SideChannelIsolationPolicyMap[] = {
    { 0, TEXT("Page combining disabled") },                 // DisablePageCombine : 1
    { 1, TEXT("Distinct security domain") },                // IsolateSecurityDomain : 1
    { 2, TEXT("SMT branch target isolation") },             // SmtBranchTargetIsolation : 1
    { 3, TEXT("Speculative execution protection (SSBD)") }, // SpeculativeStoreBypassDisable : 1
};

// UserShadowStackPolicy
static const MITIGATION_BIT_MAP g_UserShadowStackPolicyMap[] = {
    { 0, TEXT("Shadow Stack enabled") },                  // EnableUserShadowStack : 1
    { 1, TEXT("Shadow Stack (Audit)") },                  // AuditUserShadowStack : 1
    { 2, TEXT("SetContext IP validation enabled") },      // SetContextIpValidation : 1
    { 3, TEXT("SetContext IP validation (Audit)") },      // AuditSetContextIpValidation : 1
    { 4, TEXT("Shadow Stack strict mode") },              // EnableUserShadowStackStrictMode : 1
    { 5, TEXT("Non-CET binaries blocked") },              // BlockNonCetBinaries : 1
    { 6, TEXT("Non-CET binaries (non-EHCont) blocked") }, // BlockNonCetBinariesNonEhcont : 1
    { 7, TEXT("Non-CET binaries blocked (Audit)") },      // AuditBlockNonCetBinaries : 1
    { 8, TEXT("CET dynamic APIs (out-of-proc only)") },   // CetDynamicApisOutOfProcOnly : 1
};

// RedirectionTrustPolicy
// RedirectionTrustPolicy (W10 version - matches struct definition)
static const MITIGATION_BIT_MAP g_RedirectionTrustPolicyMap[] = {
    { 0, TEXT("Redirection Trust enforced") },           // EnforceRedirectionTrust : 1
    { 1, TEXT("Redirection Trust (Audit)") },            // AuditRedirectionTrust : 1
};

// UserPointerAuthPolicy (W11 version)
static const MITIGATION_BIT_MAP g_UserPointerAuthPolicyMap[] = {
    { 0, TEXT("Pointer Authentication (User IP) enabled") }, // EnablePointerAuthUserIp : 1
};

// ChildProcessPolicy
static const MITIGATION_BIT_MAP g_ChildProcessPolicyMap[] = {
    { 0, TEXT("Child process creation blocked") },       // NoChildProcessCreation : 1
    { 1, TEXT("Child process creation (Audit)") },       // AuditNoChildProcessCreation : 1
    { 2, TEXT("Secure child processes allowed") },       // AllowSecureProcessCreation : 1
};

// SEHOPPolicy (W11 version)
static const MITIGATION_BIT_MAP g_SEHOPPolicyMap[] = {
    { 0, TEXT("SEH Overwrite Protection enabled") },     // EnableSehop : 1
};

//
// Forward.
//
VOID propSetBasicInfoEx(
    _In_ HWND hwndDlg,
    _In_ POBEX_OBJECT_INFORMATION InfoObject);

/*
* propSetObjectHeaderAddressInfo
*
* Purpose:
*
* Set Object & Header address controls text.
*
*/
VOID propSetObjectHeaderAddressInfo(
    _In_ HWND hwndDlg,
    _In_ ULONG_PTR ObjectAddress,
    _In_ ULONG_PTR HeaderAddress
)
{
    WCHAR szBuffer[64];
    LPWSTR lpText;

    //
    // Object Address
    //
    if (ObjectAddress) {
        szBuffer[0] = TEXT('0');
        szBuffer[1] = TEXT('x');
        szBuffer[2] = 0;
        u64tohex(ObjectAddress, &szBuffer[2]);
        lpText = szBuffer;
    }
    else {
        lpText = T_EmptyString;
    }

    SetDlgItemText(hwndDlg, ID_OBJECT_ADDR, lpText);

    //
    // Header Address
    //
    if (HeaderAddress) {
        szBuffer[0] = TEXT('0');
        szBuffer[1] = TEXT('x');
        szBuffer[2] = 0;
        u64tohex(HeaderAddress, &szBuffer[2]);
        lpText = szBuffer;
    }
    else {
        lpText = T_EmptyString;
    }

    SetDlgItemText(hwndDlg, ID_OBJECT_HEADER, lpText);
}

/*
* AddMitigationBitMapStrings
*
* Purpose:
*
* Process mitigation options map and output values to the combobox.
*
*/
VOID AddMitigationBitMapStrings(
    _In_ HWND hwndCB,
    _In_ DWORD Flags,
    _In_reads_(Count) const MITIGATION_BIT_MAP* Map,
    _In_ SIZE_T Count
)
{
    SIZE_T i;
    for (i = 0; i < Count; i++) {
        if ((Flags >> Map[i].BitPosition) & 1) {
            ComboBox_AddString(hwndCB, (LPWSTR)Map[i].Text);
        }
    }
}

/*
* AddASLRPolicyString
*
* Purpose:
*
* Output ASLR policy.
*
*/
VOID AddASLRPolicyString(
    _In_ HWND hwndCB,
    _In_ DWORD Flags
)
{
    WCHAR szBuffer[512];
    BOOL bFirst = TRUE;
    SIZE_T i;

    if (Flags == 0) {
        ComboBox_AddString(hwndCB, TEXT("ASLR (Disabled)"));
        return;
    }

    _strcpy(szBuffer, TEXT("ASLR "));

    for (i = 0; i < RTL_NUMBER_OF(g_ASLRPolicyMap); i++) {
        if ((Flags >> g_ASLRPolicyMap[i].BitPosition) & 1) {
            if (!bFirst) {
                _strcat(szBuffer, TEXT(" "));
            }

            if (g_ASLRPolicyMap[i].BitPosition == 0) {
                _strcat(szBuffer, TEXT("(Bottom-up)"));
            }
            else if (g_ASLRPolicyMap[i].BitPosition == 1) {
                _strcat(szBuffer, TEXT("(Force relocate)"));
            }
            else if (g_ASLRPolicyMap[i].BitPosition == 2) {
                _strcat(szBuffer, TEXT("(High entropy)"));
            }
            else if (g_ASLRPolicyMap[i].BitPosition == 3) {
                _strcat(szBuffer, TEXT("(No stripped images)"));
            }

            bFirst = FALSE;
        }
    }

    ComboBox_AddString(hwndCB, szBuffer);
}

/*
* propSetProcessMitigationsInfo
*
* Purpose:
*
* Set Process mitigation information if it specified for this object.
*
*/
VOID propSetProcessMitigationsInfo(
    _In_ HANDLE hProcess,
    _In_ BOOL wow64Process,
    _In_ HWND hwndDlg
)
{
    BOOL bQuery;
    LRESULT lResult;
    HWND hwndCB = GetDlgItem(hwndDlg, IDC_PROCESS_MITIGATIONS);
    PROCESS_MITIGATION_POLICIES_ALL Policies;

    WCHAR szBuffer[1000];

    RtlSecureZeroMemory(&Policies, sizeof(Policies));

    ComboBox_ResetContent(hwndCB);

    // DEP state.
    // Always ON for 64bit.
    bQuery = TRUE;
    Policies.DEPPolicy.Enable = 1;
    Policies.DEPPolicy.Permanent = 1;

    if (wow64Process) {
        Policies.DEPPolicy.Flags = 0;
        bQuery = supGetProcessDepState(hProcess,
            &Policies.DEPPolicy);
    }  

    if (bQuery && Policies.DEPPolicy.Flags) {
        RtlStringCchPrintfSecure(szBuffer, ARRAYSIZE(szBuffer), 
            TEXT("DEP %ws%ws"),
            Policies.DEPPolicy.Permanent ? TEXT("(Permanent)") :
            Policies.DEPPolicy.Enable ? TEXT("(Enabled)") : TEXT("(Disabled)"),
            Policies.DEPPolicy.DisableAtlThunkEmulation ? TEXT(" (ATL thunk disabled)") : TEXT(""));
        ComboBox_AddString(hwndCB, szBuffer);
    }

    // ASLR state.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessASLRPolicy,
        sizeof(Policies.ASLRPolicy),
        &Policies.ASLRPolicy))
    {
        AddASLRPolicyString(hwndCB, Policies.ASLRPolicy.Flags);
    }

    // Dynamic code.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessDynamicCodePolicy,
        sizeof(Policies.DynamicCodePolicy),
        &Policies.DynamicCodePolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.DynamicCodePolicy.Flags, 
            g_DynamicCodePolicyMap, RTL_NUMBER_OF(g_DynamicCodePolicyMap));
    }

    // Strict handle check.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessStrictHandleCheckPolicy,
        sizeof(Policies.StrictHandleCheckPolicy),
        &Policies.StrictHandleCheckPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.StrictHandleCheckPolicy.Flags, 
            g_StrictHandleCheckPolicyMap, RTL_NUMBER_OF(g_StrictHandleCheckPolicyMap));
    }

    // System call disable.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessSystemCallDisablePolicy,
        sizeof(Policies.SystemCallDisablePolicy),
        &Policies.SystemCallDisablePolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.SystemCallDisablePolicy.Flags,
            g_SystemCallDisablePolicyMap, RTL_NUMBER_OF(g_SystemCallDisablePolicyMap));
    }

    // Extension point disable.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessExtensionPointDisablePolicy,
        sizeof(Policies.ExtensionPointDisablePolicy),
        &Policies.ExtensionPointDisablePolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.ExtensionPointDisablePolicy.Flags,
            g_ExtensionPointDisablePolicyMap, RTL_NUMBER_OF(g_ExtensionPointDisablePolicyMap));
    }

    // CFG.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessControlFlowGuardPolicy,
        sizeof(Policies.ControlFlowGuardPolicy),
        &Policies.ControlFlowGuardPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.ControlFlowGuardPolicy.Flags,
            g_ControlFlowGuardPolicyMap, RTL_NUMBER_OF(g_ControlFlowGuardPolicyMap));
    }

    // Signature.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessSignaturePolicy,
        sizeof(Policies.SignaturePolicy),
        &Policies.SignaturePolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.SignaturePolicy.Flags,
            g_SignaturePolicyMap, RTL_NUMBER_OF(g_SignaturePolicyMap));
    }

    // Font disable.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessFontDisablePolicy,
        sizeof(Policies.FontDisablePolicy),
        &Policies.FontDisablePolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.FontDisablePolicy.Flags,
            g_FontDisablePolicyMap, RTL_NUMBER_OF(g_FontDisablePolicyMap));
    }

    // Image load.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessImageLoadPolicy,
        sizeof(Policies.ImageLoadPolicy),
        &Policies.ImageLoadPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.ImageLoadPolicy.Flags,
            g_ImageLoadPolicyMap, RTL_NUMBER_OF(g_ImageLoadPolicyMap));
    }

    // Payload restriction.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessPayloadRestrictionPolicy,
        sizeof(Policies.PayloadRestrictionPolicy),
        &Policies.PayloadRestrictionPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.PayloadRestrictionPolicy.Flags,
            g_PayloadRestrictionPolicyMap, RTL_NUMBER_OF(g_PayloadRestrictionPolicyMap));
    }

    // Child process.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessChildProcessPolicy,
        sizeof(Policies.ChildProcessPolicy),
        &Policies.ChildProcessPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.ChildProcessPolicy.Flags,
            g_ChildProcessPolicyMap, RTL_NUMBER_OF(g_ChildProcessPolicyMap));
    }

    // Side channel.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessSideChannelIsolationPolicy,
        sizeof(Policies.SideChannelIsolationPolicy),
        &Policies.SideChannelIsolationPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.SideChannelIsolationPolicy.Flags,
            g_SideChannelIsolationPolicyMap, RTL_NUMBER_OF(g_SideChannelIsolationPolicyMap));
    }

    // User shadow stack.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessUserShadowStackPolicy,
        sizeof(Policies.UserShadowStackPolicy),
        &Policies.UserShadowStackPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.UserShadowStackPolicy.Flags,
            g_UserShadowStackPolicyMap, RTL_NUMBER_OF(g_UserShadowStackPolicyMap));
    }

    // Redirection Trust.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessRedirectionTrustPolicy,
        sizeof(Policies.RedirectionTrustPolicy),
        &Policies.RedirectionTrustPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.RedirectionTrustPolicy.Flags,
            g_RedirectionTrustPolicyMap, RTL_NUMBER_OF(g_RedirectionTrustPolicyMap));
    }

    // User Pointer Auth Policy.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessUserPointerAuthPolicy,
        sizeof(Policies.UserPointerAuthPolicy),
        &Policies.UserPointerAuthPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.UserPointerAuthPolicy.Flags,
            g_UserPointerAuthPolicyMap, RTL_NUMBER_OF(g_UserPointerAuthPolicyMap));
    }

    // SEHOPPolicy Policy.
    if (supGetProcessMitigationPolicy(hProcess,
        (PROCESS_MITIGATION_POLICY)ProcessSEHOPPolicy,
        sizeof(Policies.SEHOPPolicy),
        &Policies.SEHOPPolicy))
    {
        AddMitigationBitMapStrings(hwndCB, Policies.SEHOPPolicy.Flags,
            g_SEHOPPolicyMap, RTL_NUMBER_OF(g_SEHOPPolicyMap));
    }
    
    lResult = ComboBox_GetCount(hwndCB);
    if (lResult != CB_ERR && lResult > 0) {
        EnableWindow(hwndCB, TRUE);
        ComboBox_SetCurSel(hwndCB, 0);
    }
}

/*
* propSetProcessTrustLabelInfo
*
* Purpose:
*
* Set Process Trust Label if it specified for this object.
*
*/
VOID propSetProcessTrustLabelInfo(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg
)
{
    BOOL bFail = TRUE;
    HANDLE hObject = NULL;

    ULONG ProtectionType = 0, ProtectionLevel = 0, i;

    LPWSTR lpType = T_EmptyString, lpLevel = T_EmptyString;

    WCHAR szBuffer[128];

    //
    // Re-open current object as we need READ_CONTROL.
    //
    if (!propOpenCurrentObject(Context, &hObject, READ_CONTROL)) {
        ShowWindow(GetDlgItem(hwndDlg, ID_OBJECT_TRUSTLABEL), SW_HIDE);
        return;
    }

    if (NT_SUCCESS(supQueryObjectTrustLabel(hObject,
        &ProtectionType,
        &ProtectionLevel)))
    {
        szBuffer[0] = 0;

        for (i = 0; i < MAX_KNOWN_TRUSTLABEL_PROTECTIONTYPE; i++)
            if (TrustLabelProtectionType[i].dwValue == ProtectionType)
            {
                lpType = TrustLabelProtectionType[i].lpDescription;
                break;
            }

        for (i = 0; i < MAX_KNOWN_TRUSTLABEL_PROTECTIONLEVEL; i++)
            if (TrustLabelProtectionLevel[i].dwValue == ProtectionLevel)
            {
                lpLevel = TrustLabelProtectionLevel[i].lpDescription;
                break;
            }

        if ((lpType) && (lpLevel)) {
            _strcpy(szBuffer, lpType);
            _strcat(szBuffer, TEXT("-"));
            _strcat(szBuffer, lpLevel);

            ShowWindow(GetDlgItem(hwndDlg, ID_PTL_CAPTION), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, ID_OBJECT_TRUSTLABEL), SW_SHOW);
            SetDlgItemText(hwndDlg, ID_OBJECT_TRUSTLABEL, szBuffer);
            bFail = FALSE;
        }
    }

    propCloseCurrentObject(Context, hObject);

    if (bFail) {
        ShowWindow(GetDlgItem(hwndDlg, ID_OBJECT_TRUSTLABEL), SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, ID_PTL_CAPTION), SW_HIDE);
    }
}

/*
* propSetDefaultInfo
*
* Purpose:
*
* Set information values for Basic page window, obtained from NtQueryObject calls
*
* ObjectBasicInformation and ObjectTypeInformation used
*
*/
VOID propSetDefaultInfo(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg,
    _In_ HANDLE hObject
)
{
    INT      i;
    HWND     hwndCB;
    NTSTATUS ntStatus;
    ULONG    returnLength;
    WCHAR    szBuffer[100];

    OBJECT_BASIC_INFORMATION obi;
    POBJECT_TYPE_INFORMATION TypeInfo = NULL;

    //
    // Query object basic information.
    //
    RtlSecureZeroMemory(&obi, sizeof(obi));

    ntStatus = NtQueryObject(hObject, 
        ObjectBasicInformation, 
        &obi,
        sizeof(OBJECT_BASIC_INFORMATION), 
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {

        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

        //Reference Count
        u64tostr(obi.PointerCount, szBuffer);
        SetDlgItemText(hwndDlg, ID_OBJECT_REFC, szBuffer);

        //Handle Count
        szBuffer[0] = 0;
        u64tostr(obi.HandleCount, szBuffer);
        SetDlgItemText(hwndDlg, ID_OBJECT_HANDLES, szBuffer);

        //NonPagedPoolCharge
        szBuffer[0] = 0;
        u64tostr(obi.NonPagedPoolCharge, szBuffer);
        SetDlgItemText(hwndDlg, ID_OBJECT_NP_CHARGE, szBuffer);

        //PagedPoolCharge
        szBuffer[0] = 0;
        u64tostr(obi.PagedPoolCharge, szBuffer);
        SetDlgItemText(hwndDlg, ID_OBJECT_PP_CHARGE, szBuffer);

        //Attributes
        hwndCB = GetDlgItem(hwndDlg, IDC_OBJECT_FLAGS);
        if (hwndCB) {
            SendMessage(hwndCB, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            EnableWindow(hwndCB, (obi.Attributes > 0) ? TRUE : FALSE);
            if (obi.Attributes != 0) {
                for (i = 0; i < 8; i++) {
                    if (GET_BIT(obi.Attributes, i))
                        SendMessage(hwndCB, CB_ADDSTRING, (WPARAM)0, (LPARAM)T_ObjectFlags[i]);
                }
                SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
            }
        }
    }

    //
    // Set flag bit for next usage on Type page.
    //
    ntStatus = supQueryObjectInformation(hObject,
        ObjectTypeInformation,
        &TypeInfo,
        NULL);

    if (NT_SUCCESS(ntStatus)) {

        if (TypeInfo->SecurityRequired) {
            SET_BIT(Context->ObjectFlags, 3);
        }
        if (TypeInfo->MaintainHandleCount) {
            SET_BIT(Context->ObjectFlags, 4);
        }

        supHeapFree(TypeInfo);
    }
    else {
        SetLastError(RtlNtStatusToDosError(ntStatus));
    }
}

/*
* propBasicQueryDirectory
*
* Purpose:
*
* Set information values for Directory object type
*
* No Additional info required
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryDirectory)
{
    HANDLE hObject = NULL;

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    //
    // Open object directory and query info.
    //
    if (propOpenCurrentObject(Context, &hObject, DIRECTORY_QUERY)) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
        propCloseCurrentObject(Context, hObject);
    }
}

/*
* propBasicQuerySemaphore
*
* Purpose:
*
* Set information values for Semaphore object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQuerySemaphore)
{
    NTSTATUS  status;
    ULONG     bytesNeeded;
    HANDLE    hObject = NULL;
    WCHAR	  szBuffer[64];

    SEMAPHORE_BASIC_INFORMATION sbi;

    SetDlgItemText(hwndDlg, ID_SEMAPHORECURRENT, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_SEMAPHOREMAXCOUNT, T_CannotQuery);

    //
    // Open semaphore object.
    //
    if (!propOpenCurrentObject(Context, &hObject, SEMAPHORE_QUERY_STATE)) {
        return;
    }

    RtlSecureZeroMemory(&sbi, sizeof(SEMAPHORE_BASIC_INFORMATION));

    status = NtQuerySemaphore(hObject, 
        SemaphoreBasicInformation, 
        &sbi,
        sizeof(SEMAPHORE_BASIC_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        //Current count
        szBuffer[0] = 0;
        RtlStringCchPrintfSecure(szBuffer, 64, 
            TEXT("0x%lX (%lu)"), 
            sbi.CurrentCount,
            sbi.CurrentCount);
        
        SetDlgItemText(hwndDlg, ID_SEMAPHORECURRENT, szBuffer);

        //Maximum count
        szBuffer[0] = 0;
        RtlStringCchPrintfSecure(szBuffer, 64, 
            TEXT("0x%lX (%lu)"), 
            sbi.MaximumCount,
            sbi.MaximumCount);

        SetDlgItemText(hwndDlg, ID_SEMAPHOREMAXCOUNT, szBuffer);
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryIoCompletion
*
* Purpose:
*
* Set information values for IoCompletion object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryIoCompletion)
{
    NTSTATUS status;
    ULONG    bytesNeeded;
    HANDLE   hObject = NULL;

    IO_COMPLETION_BASIC_INFORMATION iobi;

    SetDlgItemText(hwndDlg, ID_IOCOMPLETIONSTATE, T_CannotQuery);

    //
    // Open IoCompletion object.
    //
    if (!propOpenCurrentObject(Context, &hObject, IO_COMPLETION_QUERY_STATE)) {
        return;
    }

    RtlSecureZeroMemory(&iobi, sizeof(IO_COMPLETION_BASIC_INFORMATION));
    
    status = NtQueryIoCompletion(hObject, 
        IoCompletionBasicInformation,
        &iobi,
        sizeof(iobi), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {
        SetDlgItemText(hwndDlg, ID_IOCOMPLETIONSTATE,
            (iobi.Depth > 0) ? TEXT("Signaled") : TEXT("Nonsignaled"));
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryTimer
*
* Purpose:
*
* Set information values for Timer object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryTimer)
{
    NTSTATUS    status;
    ULONG       bytesNeeded;
    HANDLE      hObject = NULL;
    ULONGLONG   ConvertedSeconds, Hours;
    CSHORT      Minutes, Seconds;
    WCHAR       szBuffer[MAX_PATH + 1];

    TIMER_BASIC_INFORMATION tbi;

    SetDlgItemText(hwndDlg, ID_TIMERSTATE, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_TIMERREMAINING, T_CannotQuery);

    //
    // Open Timer object.
    //
    if (!propOpenCurrentObject(Context, &hObject, TIMER_QUERY_STATE)) {
        return;
    }

    RtlSecureZeroMemory(&tbi, sizeof(TIMER_BASIC_INFORMATION));
    
    status = NtQueryTimer(hObject, 
        TimerBasicInformation, 
        &tbi,
        sizeof(TIMER_BASIC_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        //Timer state
        SetDlgItemText(hwndDlg, ID_TIMERSTATE,
            (tbi.TimerState) ? TEXT("Signaled") : TEXT("Nonsignaled"));

        if (tbi.TimerState != TRUE) {
            ConvertedSeconds = (tbi.RemainingTime.QuadPart / 10000000LL);
            Seconds = (CSHORT)(ConvertedSeconds % 60);
            Minutes = (CSHORT)((ConvertedSeconds / 60) % 60);
            Hours = ConvertedSeconds / 3600;

            //Timer remaining
            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

            RtlStringCchPrintfSecure(szBuffer,
                MAX_PATH,
                FORMAT_TIME_VALUE,
                Hours,
                Minutes,
                Seconds);

            SetDlgItemText(hwndDlg, ID_TIMERREMAINING, szBuffer);
        }
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryEvent
*
* Purpose:
*
* Set information values for Event object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryEvent)
{
    NTSTATUS status;
    ULONG    bytesNeeded;
    HANDLE   hObject = NULL;
    LPWSTR   lpInfo;
    EVENT_BASIC_INFORMATION	ebi;

    SetDlgItemText(hwndDlg, ID_EVENTTYPE, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_EVENTSTATE, T_CannotQuery);

    //
    // Open Event object.
    //
    if (!propOpenCurrentObject(Context, &hObject, EVENT_QUERY_STATE)) {
        return;
    }

    RtlSecureZeroMemory(&ebi, sizeof(EVENT_BASIC_INFORMATION));
    
    status = NtQueryEvent(hObject, 
        EventBasicInformation, 
        &ebi,
        sizeof(EVENT_BASIC_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        //Event type
        switch (ebi.EventType) {
        case NotificationEvent:
            lpInfo = TEXT("Notification");
            break;
        case SynchronizationEvent:
            lpInfo = TEXT("Synchronization");
            break;
        default:
            lpInfo = T_UnknownType;
            break;
        }
        SetDlgItemText(hwndDlg, ID_EVENTTYPE, lpInfo);

        //Event state
        switch (ebi.EventState) {
        case 0:
            lpInfo = TEXT("Nonsignaled");
            break;
        case 1:
            lpInfo = TEXT("Signaled");
            break;
        default:
            lpInfo = TEXT("UnknownState");
            break;
        }
        SetDlgItemText(hwndDlg, ID_EVENTSTATE, lpInfo);
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQuerySymlink
*
* Purpose:
*
* Set information values for SymbolicLink object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQuerySymlink)
{
    NTSTATUS    status;
    ULONG       bytesNeeded;
    HANDLE      hObject = NULL;
    WCHAR       szBuffer[MAX_PATH + 1];

    OBJECT_BASIC_INFORMATION obi;
    UNICODE_STRING objectName, normalizedName;

    SetDlgItemText(hwndDlg, ID_OBJECT_SYMLINK_TARGET, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_OBJECT_SYMLINK_CREATION, T_CannotQuery);

    //
    // Open SymbolicLink object.
    //
    if (!propOpenCurrentObject(Context, &hObject, SYMBOLIC_LINK_QUERY)) {
        return;
    }

    if (supCreateObjectPathFromElements(&Context->NtObjectName,
        &Context->NtObjectPath,
        &objectName,
        TRUE))
    {
        if (supResolveSymbolicLinkTargetNormalized(
            hObject,
            NULL,
            &objectName,
            &normalizedName))
        {
            SetDlgItemText(hwndDlg, ID_OBJECT_SYMLINK_TARGET, normalizedName.Buffer);
            supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedName, FALSE);
        }

        supFreeDuplicatedUnicodeString(g_obexHeap, &objectName, FALSE);
    }
  
    //Query Link Creation Time
    RtlSecureZeroMemory(&obi, sizeof(OBJECT_BASIC_INFORMATION));

    status = NtQueryObject(hObject, 
        ObjectBasicInformation, 
        &obi,
        sizeof(OBJECT_BASIC_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {
        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        if (supPrintTimeConverted(&obi.CreationTime, szBuffer, MAX_PATH))
            SetDlgItemText(hwndDlg, ID_OBJECT_SYMLINK_CREATION, szBuffer);
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryKey
*
* Purpose:
*
* Set information values for Key object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryKey)
{
    NTSTATUS    status;
    ULONG       bytesNeeded;
    HANDLE      hObject = NULL;
    WCHAR       szBuffer[MAX_PATH];

    KEY_FULL_INFORMATION  kfi;

    SetDlgItemText(hwndDlg, ID_KEYSUBKEYS, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_KEYVALUES, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_KEYLASTWRITE, T_CannotQuery);

    //
    // Open Key object.
    //
    if (!propOpenCurrentObject(Context, &hObject, KEY_QUERY_VALUE)) {
        return;
    }

    RtlSecureZeroMemory(&kfi, sizeof(KEY_FULL_INFORMATION));
    
    status = NtQueryKey(hObject, 
        KeyFullInformation, 
        &kfi,
        sizeof(KEY_FULL_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        //Subkeys count
        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        ultostr(kfi.SubKeys, szBuffer);
        SetDlgItemText(hwndDlg, ID_KEYSUBKEYS, szBuffer);

        //Values count
        szBuffer[0] = 0;
        ultostr(kfi.Values, szBuffer);
        SetDlgItemText(hwndDlg, ID_KEYVALUES, szBuffer);

        //LastWrite time
        szBuffer[0] = 0;
        if (supPrintTimeConverted(&kfi.LastWriteTime, szBuffer, MAX_PATH))
            SetDlgItemText(hwndDlg, ID_KEYLASTWRITE, szBuffer);
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryMutant
*
* Purpose:
*
* Set information values for Mutant object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryMutant)
{
    NTSTATUS status;
    ULONG    bytesNeeded;
    HANDLE   hObject = NULL;
    WCHAR    szBuffer[MAX_PATH];

    MUTANT_BASIC_INFORMATION mbi;

    SetDlgItemText(hwndDlg, ID_MUTANTABANDONED, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_MUTANTSTATE, T_CannotQuery);

    //
    // Open Mutant object.
    //
    if (!propOpenCurrentObject(Context, &hObject, MUTANT_QUERY_STATE)) {
        return;
    }

    RtlSecureZeroMemory(&mbi, sizeof(MUTANT_BASIC_INFORMATION));

    status = NtQueryMutant(hObject, 
        MutantBasicInformation, 
        &mbi,
        sizeof(MUTANT_BASIC_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        //
        // Show Abandoned state.
        //
        SetDlgItemText(hwndDlg, ID_MUTANTABANDONED, (mbi.AbandonedState) ? TEXT("Yes") : TEXT("No"));

        //
        // Show state.
        //
        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        if (mbi.OwnedByCaller) {

            RtlStringCchPrintfSecure(szBuffer,
                MAX_PATH,
                TEXT("Held recursively %d times"),
                mbi.CurrentCount);

        }
        else {
            _strcpy(szBuffer, TEXT("Not Held"));
        }
        SetDlgItemText(hwndDlg, ID_MUTANTSTATE, szBuffer);
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }
    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQuerySection
*
* Purpose:
*
* Set information values for Section object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQuerySection)
{
    BOOL      bSet;
    NTSTATUS  status;
    HANDLE    hObject = NULL;
    SIZE_T    bytesNeeded;
    LPWSTR    lpType;
    WCHAR     szBuffer[MAX_PATH * 2];

    SECTION_BASIC_INFORMATION sbi;
    SECTION_IMAGE_INFORMATION sii;

    ENUMCHILDWNDDATA ChildWndData;

    SetDlgItemText(hwndDlg, ID_SECTION_ATTR, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_SECTIONSIZE, T_CannotQuery);

    //
    // Open Section object.
    //
    if (!propOpenCurrentObject(Context, &hObject, SECTION_QUERY)) {
        return;
    }

    //query basic information
    RtlSecureZeroMemory(&sbi, sizeof(SECTION_BASIC_INFORMATION));

    status = NtQuerySection(hObject, 
        SectionBasicInformation,
        &sbi,
        sizeof(SECTION_BASIC_INFORMATION),
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        bSet = FALSE;
        szBuffer[0] = 0;
        if (sbi.AllocationAttributes & SEC_BASED) {
            _strcat(szBuffer, TEXT("Based"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_NO_CHANGE) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("NoChange"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_FILE) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("File"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_IMAGE) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("Image"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_RESERVE) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("Reserve"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_COMMIT) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("Commit"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_NOCACHE) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("NoCache"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_GLOBAL) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("Global"));
            bSet = TRUE;
        }
        if (sbi.AllocationAttributes & SEC_LARGE_PAGES) {
            if (bSet) _strcat(szBuffer, TEXT(" + "));
            _strcat(szBuffer, TEXT("LargePages"));
        }
        SetDlgItemText(hwndDlg, ID_SECTION_ATTR, szBuffer);

        //Size
        szBuffer[0] = 0;
        RtlStringCchPrintfSecure(szBuffer,
            MAX_PATH,
            TEXT("0x%I64X"),
            sbi.MaximumSize.QuadPart);

        SetDlgItemText(hwndDlg, ID_SECTIONSIZE, szBuffer);

        //query image information
        if (supIsFileImageSection(sbi.AllocationAttributes)) {
            
            RtlSecureZeroMemory(&sii, sizeof(SECTION_IMAGE_INFORMATION));
            
            status = NtQuerySection(hObject, 
                SectionImageInformation, 
                &sii,
                sizeof(SECTION_IMAGE_INFORMATION), 
                &bytesNeeded);

            if (NT_SUCCESS(status)) {

                //show hidden controls
                if (GetWindowRect(GetDlgItem(hwndDlg, ID_IMAGEINFO), &ChildWndData.Rect)) {
                    ChildWndData.nCmdShow = SW_SHOW;
                    EnumChildWindows(hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
                }

                //Entry			
                szBuffer[0] = 0;
                RtlStringCchPrintfSecure(szBuffer,
                    MAX_PATH,
                    TEXT("0x%I64X"),
                    (ULONG_PTR)sii.TransferAddress);

                SetDlgItemText(hwndDlg, ID_IMAGE_ENTRY, szBuffer);

                //Stack Reserve
                szBuffer[0] = 0;
                RtlStringCchPrintfSecure(szBuffer,
                    MAX_PATH,
                    TEXT("0x%I64X"),
                    sii.MaximumStackSize);

                SetDlgItemText(hwndDlg, ID_IMAGE_STACKRESERVE, szBuffer);

                //Stack Commit
                szBuffer[0] = 0;
                RtlStringCchPrintfSecure(szBuffer,
                    MAX_PATH,
                    TEXT("0x%I64X"),
                    sii.CommittedStackSize);

                SetDlgItemText(hwndDlg, ID_IMAGE_STACKCOMMIT, szBuffer);

                //Executable			
                SetDlgItemText(hwndDlg, ID_IMAGE_EXECUTABLE,
                    (sii.ImageContainsCode) ? TEXT("Yes") : TEXT("No"));

                //Subsystem               
                switch (sii.SubSystemType) {
                case IMAGE_SUBSYSTEM_NATIVE:
                    lpType = TEXT("Native");
                    break;
                case IMAGE_SUBSYSTEM_WINDOWS_GUI:
                    lpType = TEXT("Windows GUI");
                    break;
                case IMAGE_SUBSYSTEM_WINDOWS_CUI:
                    lpType = TEXT("Windows Console");
                    break;
                case IMAGE_SUBSYSTEM_OS2_CUI:
                    lpType = TEXT("OS/2 Console");
                    break;
                case IMAGE_SUBSYSTEM_POSIX_CUI:
                    lpType = TEXT("Posix Console");
                    break;
                case IMAGE_SUBSYSTEM_XBOX:
                    lpType = TEXT("XBox");
                    break;
                case IMAGE_SUBSYSTEM_EFI_APPLICATION:
                    lpType = TEXT("EFI Application");
                    break;
                case IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
                    lpType = TEXT("EFI Boot Service Driver");
                    break;
                case IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
                    lpType = TEXT("EFI Runtime Driver");
                    break;
                case IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION:
                    lpType = TEXT("Windows Boot Application");
                    break;
                case IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG:
                    lpType = TEXT("XBox Code Catalog");
                    break;
                default:
                    lpType = T_Unknown;
                    break;
                }
                SetDlgItemText(hwndDlg, ID_IMAGE_SUBSYSTEM, lpType);

                //Major Version
                szBuffer[0] = 0;
                ultostr(sii.SubSystemMajorVersion, szBuffer);
                SetDlgItemText(hwndDlg, ID_IMAGE_MJV, szBuffer);

                //Minor Version
                szBuffer[0] = 0;
                ultostr(sii.SubSystemMinorVersion, szBuffer);
                SetDlgItemText(hwndDlg, ID_IMAGE_MNV, szBuffer);

                //Image Flags
                szBuffer[0] = 0;
                ultostr(sii.ImageFlags, szBuffer);
                SetDlgItemText(hwndDlg, ID_IMAGE_FLAGS, szBuffer);
            }
        }
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }
    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryWindowStation
*
* Purpose:
*
* Set information values for WindowStation object type (managed by win32k services)
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryWindowStation)
{
    DWORD           bytesNeeded;
    HWINSTA         hObject = NULL;
    USEROBJECTFLAGS userFlags;

    SetDlgItemText(hwndDlg, ID_WINSTATIONVISIBLE, T_CannotQuery);

    //
    // Open Winstation object.
    //
    if (!propOpenCurrentObject(Context, (PHANDLE)&hObject, WINSTA_READATTRIBUTES)) {
        return;
    }

    RtlSecureZeroMemory(&userFlags, sizeof(userFlags));

    if (GetUserObjectInformation(hObject, 
        UOI_FLAGS, 
        &userFlags,
        sizeof(USEROBJECTFLAGS), 
        &bytesNeeded))
    {
        SetDlgItemText(hwndDlg, ID_WINSTATIONVISIBLE,
            (userFlags.dwFlags & WSF_VISIBLE) ? TEXT("Yes") : TEXT("No"));
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }

    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryDriver
*
* Purpose:
*
* Set information values for Driver object type
*
* Viewing \Drivers subdirectory requires full access token
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryDriver)
{
    ENUMCHILDWNDDATA ChildWndData;

    WCHAR szBuffer[MAX_PATH + 1];

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
    if (supQueryDriverDescription(Context->NtObjectName.Buffer,
        szBuffer,
        MAX_PATH))
    {
        //show hidden controls
        if (GetWindowRect(GetDlgItem(hwndDlg, ID_DRIVERINFO), &ChildWndData.Rect)) {
            ChildWndData.nCmdShow = SW_SHOW;
            EnumChildWindows(hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
        }
        SetDlgItemText(hwndDlg, ID_DRIVERDISPLAYNAME, szBuffer);
    }

}

/*
* propBasicQueryDevice
*
* Purpose:
*
* Set information values for Device object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryDevice)
{
    ENUMCHILDWNDDATA ChildWndData;

    WCHAR szBuffer[MAX_PATH + 1];

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
    if (supQueryDeviceDescription(
        &Context->NtObjectPath,
        &Context->NtObjectName,
        szBuffer,
        MAX_PATH))
    {
        //show hidden controls
        if (GetWindowRect(GetDlgItem(hwndDlg, ID_DEVICEINFO), &ChildWndData.Rect)) {
            ChildWndData.nCmdShow = SW_SHOW;
            EnumChildWindows(hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
        }
        SetDlgItemText(hwndDlg, ID_DEVICEDESCRIPTION, szBuffer);
    }

}

/*
* propBasicQueryMemoryPartition
*
* Purpose:
*
* Set information values for MemoryPartition object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryMemoryPartition)
{
    HANDLE hObject = NULL;

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    //
    // Open Memory Partition object.
    //
    if (!propOpenCurrentObject(Context, &hObject, MEMORY_PARTITION_QUERY_ACCESS))
        return;

    //
    // Query object basic and type info if needed.
    //
    propSetDefaultInfo(Context, hwndDlg, hObject);
    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryRegistryTransaction
*
* Purpose:
*
* Set information values for RegistryTransaction object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryRegistryTransaction)
{
    HANDLE hObject = NULL;

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    //
    // Open Registry Transaction object.
    //
    if (!propOpenCurrentObject(Context, &hObject, TRANSACTION_QUERY_INFORMATION))
        return;

    //
    // Query object basic and type info if needed.
    //
    propSetDefaultInfo(Context, hwndDlg, hObject);
    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryProcess
*
* Purpose:
*
* Set information values for Process object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryProcess)
{
    BOOL ProcessParametersRead = FALSE;
    BOOL RemotePebRead = FALSE;
    BOOL bSuccess = FALSE;

    ULONG i, BreakOnTermination = 0;
    HANDLE hObject = NULL;
    PROCESS_EXTENDED_BASIC_INFORMATION exbi;
    RTL_USER_PROCESS_PARAMETERS UserProcessParameters;
    PEB RemotePeb;

    PUNICODE_STRING pusInformation = NULL;
    SIZE_T readBytes;

    PS_PROTECTION PsProtection;

    HWND hwndCB;

    LPWSTR Name;
    PBYTE Buffer;
    WCHAR szBuffer[100];
    KERNEL_USER_TIMES KernelUserTimes;

    //
    // Open Process object.
    //
    bSuccess = propOpenCurrentObject(Context, &hObject, MAXIMUM_ALLOWED);
    if (!bSuccess) {
        bSuccess = propOpenCurrentObject(Context, &hObject, PROCESS_QUERY_INFORMATION);
        if (!bSuccess) {
            bSuccess = propOpenCurrentObject(Context, &hObject, PROCESS_QUERY_LIMITED_INFORMATION);
        }
    }
    if (bSuccess) {

        RtlSecureZeroMemory(&UserProcessParameters, sizeof(UserProcessParameters));
        RtlSecureZeroMemory(&exbi, sizeof(exbi));

        exbi.Size = sizeof(PROCESS_EXTENDED_BASIC_INFORMATION);

        if (NT_SUCCESS(NtQueryInformationProcess(hObject,
            ProcessBasicInformation,
            (PVOID)&exbi,
            sizeof(PROCESS_EXTENDED_BASIC_INFORMATION),
            &i)))
        {
            //
            // Start time.
            //
            RtlSecureZeroMemory(&KernelUserTimes, sizeof(KERNEL_USER_TIMES));
            NtQueryInformationProcess(hObject, ProcessTimes,
                (PVOID)&KernelUserTimes, sizeof(KERNEL_USER_TIMES), &i);

            SetDlgItemText(hwndDlg, IDC_PROCESS_STARTED, T_CannotQuery);

            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
            if (supPrintTimeConverted(
                &KernelUserTimes.CreateTime,
                szBuffer,
                RTL_NUMBER_OF(szBuffer)))
            {
                SetDlgItemText(hwndDlg, IDC_PROCESS_STARTED, szBuffer);
            }

            //
            // Process type flags
            //
            hwndCB = GetDlgItem(hwndDlg, IDC_PROCESS_TYPE_FLAGS);

            EnableWindow(hwndCB, (exbi.Flags > 0) ? TRUE : FALSE);
            SendMessage(hwndCB, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            if (exbi.Flags > 0) {
                for (i = 0; i < MAX_KNOWN_PROCESS_TYPE_FLAGS; i++) {

                    if (GET_BIT(exbi.Flags, i))

                        SendMessage(hwndCB,
                            CB_ADDSTRING,
                            (WPARAM)0,
                            (LPARAM)T_ProcessTypeFlags[i]);
                }
                SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
            }

            if (exbi.BasicInfo.PebBaseAddress) {

                RtlSecureZeroMemory(&RemotePeb, sizeof(PEB));

                RemotePebRead = NT_SUCCESS(NtReadVirtualMemory(
                    hObject,
                    exbi.BasicInfo.PebBaseAddress,
                    &RemotePeb,
                    sizeof(PEB),
                    &readBytes));

                if (RemotePebRead) {

                    ProcessParametersRead = (NT_SUCCESS(NtReadVirtualMemory(
                        hObject,
                        (PVOID)RemotePeb.ProcessParameters,
                        &UserProcessParameters,
                        sizeof(RTL_USER_PROCESS_PARAMETERS),
                        &readBytes)));
                }
            }
        }

        //
        // Process image file.
        //
        bSuccess = FALSE;

        if (NT_SUCCESS(supQueryProcessInformation(hObject,
            ProcessImageFileNameWin32,
            &pusInformation,
            NULL)))
        {
            if ((pusInformation->Length) && (pusInformation->MaximumLength)) {

                Name = (LPWSTR)supHeapAlloc(sizeof(UNICODE_NULL) + pusInformation->MaximumLength);
                if (Name) {

                    RtlCopyMemory(Name, pusInformation->Buffer, pusInformation->Length);
                    SetDlgItemText(hwndDlg, IDC_PROCESS_FILENAME, Name);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_PROCESS_BROWSE), TRUE);
                    bSuccess = TRUE;

                    supHeapFree(Name);
                    Name = NULL;
                }
            }

            supHeapFree(pusInformation);
        }

        if (bSuccess == FALSE) {
            SetDlgItemText(hwndDlg, IDC_PROCESS_FILENAME, T_COULD_NOT_QUERY);
        }

        //
        // Process Command Line.
        //
        bSuccess = FALSE;
        if (g_NtBuildNumber >= NT_WIN8_BLUE) {
            //
            // Use new NtQIP info class to get command line.
            //
            if (NT_SUCCESS(supQueryProcessInformation(hObject,
                ProcessCommandLineInformation,
                &pusInformation,
                NULL)))
            {
                if ((pusInformation->Length) && (pusInformation->MaximumLength)) {

                    Name = (LPWSTR)supHeapAlloc((SIZE_T)pusInformation->MaximumLength + sizeof(UNICODE_NULL));
                    if (Name) {

                        RtlCopyMemory(Name, pusInformation->Buffer, pusInformation->Length);

                        SetDlgItemText(hwndDlg, IDC_PROCESS_CMDLINE, Name);
                        bSuccess = TRUE;

                        supHeapFree(Name);
                        Name = NULL;
                    }
                }
                supHeapFree(pusInformation);
            }

        }
        else {
            //
            // Read command line from PEB.
            //
            if (ProcessParametersRead) {

                readBytes = UserProcessParameters.CommandLine.MaximumLength;
                Buffer = (PBYTE)supHeapAlloc(readBytes + sizeof(UNICODE_NULL));
                if (Buffer) {

                    if (NT_SUCCESS(NtReadVirtualMemory(
                        hObject,
                        UserProcessParameters.CommandLine.Buffer,
                        Buffer,
                        UserProcessParameters.CommandLine.Length,
                        &readBytes)))
                    {
                        SetDlgItemText(hwndDlg, IDC_PROCESS_CMDLINE, (LPCWSTR)Buffer);
                        bSuccess = TRUE;
                    }

                    supHeapFree(Buffer);
                }
            }
        }

        if (bSuccess == FALSE) {
            SetDlgItemText(hwndDlg, IDC_PROCESS_CMDLINE, T_COULD_NOT_QUERY);
        }

        //
        // Process Current Directory.
        //
        bSuccess = FALSE;
        if (ProcessParametersRead) {
            readBytes = UserProcessParameters.CurrentDirectory.DosPath.MaximumLength;
            Buffer = (PBYTE)supHeapAlloc(readBytes + sizeof(UNICODE_NULL));
            if (Buffer) {

                if (NT_SUCCESS(NtReadVirtualMemory(
                    hObject,
                    UserProcessParameters.CurrentDirectory.DosPath.Buffer,
                    Buffer,
                    readBytes,
                    &readBytes)))
                {
                    SetDlgItemText(hwndDlg, IDC_PROCESS_CURDIR, (LPCWSTR)Buffer);
                    bSuccess = TRUE;
                }

                supHeapFree(Buffer);
            }
        }

        if (bSuccess == FALSE) {
            SetDlgItemText(hwndDlg, IDC_PROCESS_CURDIR, T_COULD_NOT_QUERY);
        }

        //
        // Protection
        //
        PsProtection.Level = 0;
        if (NT_SUCCESS(NtQueryInformationProcess(
            hObject,
            ProcessProtectionInformation,
            &PsProtection,
            sizeof(ULONG),
            &i)))
        {
            if (PsProtection.Level) {

                if (PsProtection.Type < MAX_KNOWN_PS_PROTECTED_TYPE)
                    Name = T_PSPROTECTED_TYPE[PsProtection.Type];
                else
                    Name = T_Unknown;

                _strcpy(szBuffer, Name);
                _strcat(szBuffer, TEXT("-"));

                if (PsProtection.Signer < MAX_KNOWN_PS_PROTECTED_SIGNER)
                    Name = T_PSPROTECTED_SIGNER[PsProtection.Signer];
                else
                    Name = T_Unknown;

                _strcat(szBuffer, Name);

                SetDlgItemText(hwndDlg, IDC_PROCESS_PROTECTION, szBuffer);
            }
        }

        //
        // Critical Process
        //
        if (NT_SUCCESS(NtQueryInformationProcess(
            hObject,
            ProcessBreakOnTermination,
            &BreakOnTermination,
            sizeof(ULONG),
            &i)))
        {
            SetDlgItemText(hwndDlg, IDC_PROCESS_CRITICAL,
                (BreakOnTermination != 0) ? TEXT("Yes") : TEXT("No"));
        }

        //
        // Mitigations
        //
        propSetProcessMitigationsInfo(hObject, exbi.IsWow64Process, hwndDlg);

        //
        // Query object basic and type info if needed.
        //
        if (ExtendedInfoAvailable == FALSE) {
            propSetDefaultInfo(Context, hwndDlg, hObject);
        }
        propCloseCurrentObject(Context, hObject);
    }
}

/*
* propBasicQueryThread
*
* Purpose:
*
* Set information values for Thread object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryThread)
{
    BOOL bSuccess;
    ULONG ulCriticalThread, dummy;
    HANDLE hObject = NULL;

    WCHAR szBuffer[100];

    PSYSTEM_THREAD_INFORMATION Thread;
    LPWSTR TempBuffer;

    PROCESSOR_NUMBER IdealProcessor;
    THREAD_NAME_INFORMATION *NameInformation;


    Thread = &Context->u1.UnnamedObjectInfo.ThreadInformation;

    //
    // Open Thread object.
    //
    bSuccess = propOpenCurrentObject(Context, &hObject, MAXIMUM_ALLOWED);
    if (!bSuccess) {
        bSuccess = propOpenCurrentObject(Context, &hObject, THREAD_QUERY_INFORMATION);
        if (!bSuccess) {
            bSuccess = propOpenCurrentObject(Context, &hObject, THREAD_QUERY_LIMITED_INFORMATION);
        }
    }
    if (bSuccess) {

        //
        // Start time.
        //
        SetDlgItemText(hwndDlg, IDC_THREAD_STARTED, T_CannotQuery);

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        if (supPrintTimeConverted(
            &Thread->CreateTime,
            szBuffer,
            RTL_NUMBER_OF(szBuffer)))
        {
            SetDlgItemText(hwndDlg, IDC_THREAD_STARTED, szBuffer);
        }

        //
        // Kernel/User time.
        //
        szBuffer[0] = 0;
        supPrintTimeToBuffer(&Thread->KernelTime, szBuffer, RTL_NUMBER_OF(szBuffer));
        SetDlgItemText(hwndDlg, IDC_THREAD_KERNELTIME, szBuffer);

        szBuffer[0] = 0;
        supPrintTimeToBuffer(&Thread->UserTime, szBuffer, RTL_NUMBER_OF(szBuffer));
        SetDlgItemText(hwndDlg, IDC_THREAD_USERTIME, szBuffer);

        //
        // Context switches.
        //
        szBuffer[0] = 0;
        ultostr(Thread->ContextSwitchCount, szBuffer);
        SetDlgItemText(hwndDlg, IDC_THREAD_CONTEXTSWITCHES, szBuffer);

        //
        // Priority.
        //
        szBuffer[0] = 0;
        ultostr(Thread->BasePriority, szBuffer);
        SetDlgItemText(hwndDlg, IDC_THREAD_BASEPRIORITY, szBuffer);
        szBuffer[0] = 0;
        ultostr(Thread->Priority, szBuffer);
        SetDlgItemText(hwndDlg, IDC_THREAD_DYNPRIORITY, szBuffer);

        //
        // Ideal processor.
        //
        if (NT_SUCCESS(NtQueryInformationThread(hObject, 
            ThreadIdealProcessorEx,
            (PVOID)&IdealProcessor, 
            sizeof(PROCESSOR_NUMBER), 
            &dummy)))
        {
            szBuffer[0] = 0;
            ultostr(IdealProcessor.Number, szBuffer);
            SetDlgItemText(hwndDlg, IDC_THREAD_IDEALPROCESSOR, szBuffer);
        }

        //
        // Is thread critical.
        //
        ulCriticalThread = 0;
        if (NT_SUCCESS(NtQueryInformationThread(hObject, 
            ThreadBreakOnTermination,
            (PVOID)&ulCriticalThread,
            sizeof(ULONG), 
            &dummy)))
        {
            SetDlgItemText(hwndDlg, IDC_THREAD_CRITICAL, 
                (ulCriticalThread > 0) ? TEXT("Yes") : TEXT("No"));
        }

        //
        // Thread name.
        //
        SetDlgItemText(hwndDlg, IDC_THREAD_NAME, T_CannotQuery);

        if (NT_SUCCESS(supQueryThreadInformation(hObject,
            ThreadNameInformation, &NameInformation, &dummy)))
        {
            if (NameInformation->ThreadName.Length && NameInformation->ThreadName.MaximumLength) {

                TempBuffer = (LPWSTR)supHeapAlloc(NameInformation->ThreadName.Length + sizeof(UNICODE_NULL));
                if (TempBuffer) {
                    RtlCopyMemory(TempBuffer, NameInformation->ThreadName.Buffer, NameInformation->ThreadName.Length);
                    TempBuffer[NameInformation->ThreadName.Length / sizeof(WCHAR)] = 0;
                    SetDlgItemText(hwndDlg, IDC_THREAD_NAME, TempBuffer);
                    supHeapFree(TempBuffer);
                }
                
            }

            supHeapFree(NameInformation);
        }


        //
        // Query object basic and type info if needed.
        //
        if (ExtendedInfoAvailable == FALSE) {
            propSetDefaultInfo(Context, hwndDlg, hObject);
        }
        propCloseCurrentObject(Context, hObject);
    }
}

/*
* propBasicQueryAlpcPort
*
* Purpose:
*
* Set information values for AlpcPort object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryAlpcPort)
{
    BOOL bQueryResult;
    ULONG_PTR ownerProcess;
    HANDLE ownerProcessId = 0;
    ULONG objectSize = 0, objectVersion = 0;
    UNICODE_STRING usImageFileName;
    PUNICODE_STRING pusFileName = NULL;
    LPWSTR lpProcessName, pEnd;
    SIZE_T cchBuffer;

    WCHAR szBuffer[MAX_PATH * 4];

    union {
        union {
            ALPC_PORT_7600* Port7600;
            ALPC_PORT_9200* Port9200;
            ALPC_PORT_9600* Port9600;
            ALPC_PORT_10240* Port10240;
        } u1;
        PBYTE Ref;
    } AlpcPort;

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    AlpcPort.Ref = (PBYTE)ObDumpAlpcPortObjectVersionAware(Context->ObjectInfo.ObjectAddress,
        &objectSize,
        &objectVersion);

    if (AlpcPort.Ref == NULL) {
        SetDlgItemText(hwndDlg, ID_ALPC_OWNERPROCESS, T_CannotQuery);
        return;
    }

    RtlInitEmptyUnicodeString(&usImageFileName, NULL, 0);

    //
    // Determine owner process.
    //
    ownerProcess = (ULONG_PTR)AlpcPort.u1.Port7600->OwnerProcess;
    if (ownerProcess) {
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        szBuffer[2] = 0;
        u64tohex(ownerProcess, &szBuffer[2]);

        pEnd = _strcat(szBuffer, TEXT(" ("));

        bQueryResult = FALSE;
        lpProcessName = T_CannotQuery;

        if (ObGetProcessId(ownerProcess, &ownerProcessId)) {

            bQueryResult = NT_SUCCESS(supQueryProcessImageFileNameWin32(ownerProcessId,
                &pusFileName));

            if (bQueryResult) {

                if (pusFileName->Buffer && pusFileName->Length) {

                    lpProcessName = supExtractFileName(pusFileName->Buffer);

                }
                else {

                    bQueryResult = FALSE;

                }

            }

        }

        if (bQueryResult == FALSE) {

            if (ObGetProcessImageFileName(ownerProcess, &usImageFileName)) {

                lpProcessName = usImageFileName.Buffer;

            }

        }

        cchBuffer = RTL_NUMBER_OF(szBuffer) - _strlen(szBuffer) - 4;

        _strncpy(pEnd, cchBuffer, lpProcessName, _strlen(lpProcessName));

        _strcat(szBuffer, TEXT(")"));

        if (pusFileName)
            supHeapFree(pusFileName);

        if (usImageFileName.Buffer)
            RtlFreeUnicodeString(&usImageFileName);

    }
    else {
        _strcpy(szBuffer, T_CannotQuery);
    }
    SetDlgItemText(hwndDlg, ID_ALPC_OWNERPROCESS, szBuffer);

    supVirtualFree(AlpcPort.Ref);
}

/*
* propBasicQueryJob
*
* Purpose:
*
* Set information values for Job object type
*
* If ExtendedInfoAvailable is FALSE then it calls propSetDefaultInfo to set Basic page properties
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryJob)
{
    DWORD       i;
    HWND        hwndCB;
    HANDLE      hObject = NULL;
    NTSTATUS    status;
    ULONG       bytesNeeded;
    ULONG_PTR   ProcessId;
    PVOID       ProcessList;
    WCHAR       szProcessName[MAX_PATH + 1];
    WCHAR       szBuffer[MAX_PATH * 2];

    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jbai;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST       pJobProcList;

    SetDlgItemText(hwndDlg, ID_JOBTOTALPROCS, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_JOBACTIVEPROCS, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_JOBTERMINATEDPROCS, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_JOBTOTALUMTIME, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_JOBTOTALKMTIME, T_CannotQuery);
    SetDlgItemText(hwndDlg, ID_JOBTOTALPF, T_CannotQuery);

    //
    // Open Job object.
    //
    if (!propOpenCurrentObject(Context, &hObject, JOB_OBJECT_QUERY)) {
        return;
    }

    //query basic information
    RtlSecureZeroMemory(&jbai, sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION));

    status = NtQueryInformationJobObject(hObject, 
        JobObjectBasicAccountingInformation,
        &jbai, 
        sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION), 
        &bytesNeeded);

    if (NT_SUCCESS(status)) {

        //Total processes
        szBuffer[0] = 0;
        ultostr(jbai.TotalProcesses, szBuffer);
        SetDlgItemText(hwndDlg, ID_JOBTOTALPROCS, szBuffer);

        //Active processes
        szBuffer[0] = 0;
        ultostr(jbai.ActiveProcesses, szBuffer);
        SetDlgItemText(hwndDlg, ID_JOBACTIVEPROCS, szBuffer);

        //Terminated processes
        szBuffer[0] = 0;
        ultostr(jbai.TotalTerminatedProcesses, szBuffer);
        SetDlgItemText(hwndDlg, ID_JOBTERMINATEDPROCS, szBuffer);

        //Total user time
        szBuffer[0] = 0;
        supPrintTimeToBuffer(&jbai.TotalUserTime, szBuffer, MAX_PATH);
        SetDlgItemText(hwndDlg, ID_JOBTOTALUMTIME, szBuffer);

        //Total kernel time
        szBuffer[0] = 0;
        supPrintTimeToBuffer(&jbai.TotalKernelTime, szBuffer, MAX_PATH);
        SetDlgItemText(hwndDlg, ID_JOBTOTALKMTIME, szBuffer);

        //This Period Total kernel time
        szBuffer[0] = 0;
        supPrintTimeToBuffer(&jbai.ThisPeriodTotalKernelTime, szBuffer, MAX_PATH);
        SetDlgItemText(hwndDlg, ID_JOBTPTOTALKMTIME, szBuffer);

        //This Period Total user time
        szBuffer[0] = 0;
        supPrintTimeToBuffer(&jbai.ThisPeriodTotalUserTime, szBuffer, MAX_PATH);
        SetDlgItemText(hwndDlg, ID_JOBTPTOTALUMTIME, szBuffer);

        //Page faults
        szBuffer[0] = 0;
        ultostr(jbai.TotalPageFaultCount, szBuffer);
        SetDlgItemText(hwndDlg, ID_JOBTOTALPF, szBuffer);

        //Job process list
        pJobProcList = NULL;
        do {

            hwndCB = GetDlgItem(hwndDlg, IDC_JOB_PLIST);
            if (hwndCB == NULL)
                break;

            //allocate default size
            bytesNeeded = PAGE_SIZE;
            pJobProcList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST)supVirtualAlloc(bytesNeeded);
            if (pJobProcList == NULL)
                break;

            //if buffer is not enough, reallocate it
            status = NtQueryInformationJobObject(hObject,
                JobObjectBasicProcessIdList,
                pJobProcList,
                bytesNeeded,
                &bytesNeeded);

            if (status == STATUS_BUFFER_OVERFLOW) {

                supVirtualFree(pJobProcList);
                pJobProcList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST)supVirtualAlloc(bytesNeeded);
                if (pJobProcList == NULL)
                    break;

                status = NtQueryInformationJobObject(hObject,
                    JobObjectBasicProcessIdList,
                    pJobProcList,
                    bytesNeeded,
                    &bytesNeeded);

                if (!NT_SUCCESS(status))
                    break;
            }
            EnableWindow(hwndCB, (pJobProcList->NumberOfProcessIdsInList > 0) ? TRUE : FALSE);
            SendMessage(hwndCB, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

            // 
            // If any present then output processes in the list.
            //
            if (pJobProcList->NumberOfProcessIdsInList > 0) {
                ProcessList = supGetSystemInfo(SystemProcessInformation, NULL);
                if (ProcessList) {
                    for (i = 0; i < pJobProcList->NumberOfProcessIdsInList; i++) {
                        ProcessId = pJobProcList->ProcessIdList[i];
                        RtlSecureZeroMemory(szProcessName, sizeof(szProcessName));

                        //
                        // Query process name.
                        //
                        if (!supQueryProcessName(
                            ProcessId,
                            ProcessList,
                            szProcessName,
                            MAX_PATH))
                        {
                            _strcpy(szProcessName, T_UnknownProcess);
                        }

                        //
                        // Build final string.
                        //
                        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

                        RtlStringCchPrintfSecure(szBuffer,
                            RTL_NUMBER_OF(szBuffer),
                            TEXT("[0x%I64X:%I64u] %wS"),
                            ProcessId,
                            ProcessId,
                            szProcessName);

                        SendMessage(hwndCB, CB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);
                    }
                    SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                    supHeapFree(ProcessList);
                }
            }
        } while (FALSE);

        if (pJobProcList != NULL) {
            supVirtualFree(pJobProcList);
        }
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }
    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQuerySession
*
* Purpose:
*
* Set information values for Session object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQuerySession)
{
    HANDLE hObject = NULL;

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    //
    // Open Session object.
    //
    if (!propOpenCurrentObject(Context, &hObject, SESSION_QUERY_ACCESS)) {
        return;
    }

    //
    // Query object basic and type info if needed.
    //
    propSetDefaultInfo(Context, hwndDlg, hObject);

    propCloseCurrentObject(Context, hObject);
}

/*
* propFormatTokenAttribute
*
* Purpose:
*
* Convert token attributes to the readable string.
*
*/
LPWSTR propFormatTokenAttribute(
    _In_ PTOKEN_SECURITY_ATTRIBUTE_V1 Attribute,
    _In_ ULONG ValueIndex
)
{
    BOOLEAN IsSimpleConvert = FALSE;
    LPWSTR  Result = NULL, TempString = NULL;
    PSID    TempSid = NULL;
    SIZE_T  ResultLength = 0, nameChars = 0, needChars = 0, currentLen, remainingChars;
    SIZE_T  MinimumResultLength = 100;

    UNICODE_STRING* TempUstringPtr;
    TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE* TempFQBNPtr;
    WCHAR szTemp[MAX_PATH];


    __try { //rely on private structures

        switch (Attribute->ValueType) {
        case TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64:
            RtlSecureZeroMemory(szTemp, sizeof(szTemp));
            i64tostr(Attribute->Values.pInt64[ValueIndex], szTemp);
            IsSimpleConvert = TRUE;
            break;

        case TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64:
            RtlSecureZeroMemory(szTemp, sizeof(szTemp));
            u64tostr(Attribute->Values.pUint64[ValueIndex], szTemp);
            IsSimpleConvert = TRUE;
            break;

        case TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN:
            _strcpy(szTemp, Attribute->Values.pInt64[ValueIndex] != 0 ?
                TEXT("True") : TEXT("False"));

            IsSimpleConvert = TRUE;
            break;

        case TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING:
            _strcpy(szTemp, TEXT("(Octet String)"));
            IsSimpleConvert = TRUE;
            break;

        case TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN:
            TempFQBNPtr = &Attribute->Values.pFqbn[ValueIndex];
            nameChars = TempFQBNPtr->Name.Length / sizeof(WCHAR);
            if (nameChars == 0)
                break;

            needChars = MinimumResultLength + nameChars + 1;
            Result = (LPWSTR)supHeapAlloc(needChars * sizeof(WCHAR));
            if (Result == NULL)
                break;

            RtlStringCchPrintfSecure(Result,
                needChars,
                TEXT("[%lu] Version %I64u: "),
                ValueIndex,
                TempFQBNPtr->Version);

            RtlCopyMemory(_strend(Result),
                TempFQBNPtr->Name.Buffer,
                TempFQBNPtr->Name.Length);

            currentLen = _strlen(Result);
            remainingChars = needChars - currentLen - 1;

            if (nameChars <= remainingChars) {
                RtlCopyMemory(Result + currentLen,
                    TempFQBNPtr->Name.Buffer,
                    TempFQBNPtr->Name.Length);
                Result[currentLen + nameChars] = 0;
            }
            else {
                supHeapFree(Result);
                Result = NULL;
            }
            break;

        case TOKEN_SECURITY_ATTRIBUTE_TYPE_SID:
            TempSid = Attribute->Values.pOctetString[ValueIndex].pValue;
            if (!RtlValidSid(TempSid))
                break;

            if (ConvertSidToStringSid(TempSid, &TempString)) {
                ResultLength = _strlen(TempString);
                Result = (LPWSTR)supHeapAlloc((MinimumResultLength + ResultLength) * sizeof(WCHAR));
                if (Result) {

                    RtlStringCchPrintfSecure(Result,
                        MinimumResultLength + ResultLength,
                        TEXT("[%lu] %s"),
                        ValueIndex,
                        TempString);

                }
                LocalFree(TempString);
            }
            break;

        case TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING:
            TempUstringPtr = &Attribute->Values.pString[ValueIndex];
            nameChars = TempUstringPtr->Length / sizeof(WCHAR);
            if (nameChars == 0)
                break;

            needChars = MinimumResultLength + nameChars + 1;

            Result = (LPWSTR)supHeapAlloc(needChars * sizeof(WCHAR));
            if (Result == NULL)
                break;

            RtlStringCchPrintfSecure(Result,
                needChars,
                TEXT("[%lu] "),
                ValueIndex);

            currentLen = _strlen(Result);
            remainingChars = needChars - currentLen - 1;

            if (nameChars <= remainingChars) {
                RtlCopyMemory(Result + currentLen,
                    TempUstringPtr->Buffer,
                    TempUstringPtr->Length);
                Result[currentLen + nameChars] = 0;
            }
            else {
                supHeapFree(Result);
                Result = NULL;
            }
            break;

        default:

            szTemp[0] = 0;
            RtlStringCchPrintfSecure(szTemp,
                MinimumResultLength,
                TEXT("(Unknown: %lu)"),
                Attribute->ValueType);

            IsSimpleConvert = TRUE;
            break;

        }

        if (IsSimpleConvert) {
            ResultLength = _strlen(szTemp);
            needChars = MinimumResultLength + ResultLength + 1;

            Result = (LPWSTR)supHeapAlloc(needChars * sizeof(WCHAR));
            if (Result) {

                RtlStringCchPrintfSecure(Result,
                    needChars,
                    TEXT("[%lu] %s"),
                    ValueIndex,
                    szTemp);

            }
        }
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        if (Result) {
            supHeapFree(Result);
        }
        return NULL;
    }
    return Result;
}

/*
* propBasicQueryToken
*
* Purpose:
*
* Set information values for Token object type
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryToken)
{
    BOOLEAN bFlagSet = FALSE;
    HANDLE hObject = NULL;
    PTOKEN_SECURITY_ATTRIBUTES_INFORMATION SecurityAttributes;
    PTOKEN_SECURITY_ATTRIBUTE_V1 Attribute;
    ULONG ReturnLength = 0, i, j;

    TVINSERTSTRUCT TVItem;
    HTREEITEM RootItem;
    LPWSTR lpType;

    WCHAR szBuffer[MAX_PATH];

    HWND TreeView = GetDlgItem(hwndDlg, IDC_TOKEN_ATTRLIST);

    SetWindowTheme(TreeView, TEXT("Explorer"), NULL);
    TreeView_DeleteAllItems(TreeView);

    //
    // Open Token object.
    //
    if (!propOpenCurrentObject(Context, &hObject, TOKEN_QUERY)) {
        return;
    }

    //
    // List security attributes.
    //
    SecurityAttributes = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)
        supGetTokenInfo(hObject, TokenSecurityAttributes, &ReturnLength);

    if (SecurityAttributes) {

        for (i = 0; i < SecurityAttributes->AttributeCount; i++) {

            Attribute = &SecurityAttributes->Attribute.pAttributeV1[i];

            //
            // Atribute Name (root element).
            //
            RtlSecureZeroMemory(&TVItem, sizeof(TVItem));
            TVItem.hParent = NULL;
            TVItem.item.mask = TVIF_TEXT | TVIF_STATE;
            TVItem.item.state = TVIS_EXPANDED;
            TVItem.item.stateMask = TVIS_EXPANDED;

            lpType = (LPWSTR)supHeapAlloc(Attribute->Name.Length + sizeof(UNICODE_NULL));
            if (lpType) {
                RtlCopyMemory(lpType, Attribute->Name.Buffer, Attribute->Name.Length);
                TVItem.item.pszText = lpType;
            }
            else
                TVItem.item.pszText = Attribute->Name.Buffer;
            RootItem = TreeView_InsertItem(TreeView, &TVItem);
            if (lpType) supHeapFree(lpType);

            //
            // Attribute ValueType
            //
            switch (Attribute->ValueType) {
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID:
                lpType = T_Invalid;
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64:
                lpType = TEXT("Int64");
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64:
                lpType = TEXT("UInt64");
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING:
                lpType = TEXT("String");
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN:
                lpType = TEXT("FQBN");
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_SID:
                lpType = TEXT("SID");
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN:
                lpType = TEXT("Boolean");
                break;
            case TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING:
                lpType = TEXT("Octet string");
                break;
            default:
                lpType = T_Unknown;
                break;
            }
            _strcpy(szBuffer, TEXT("Type: "));
            _strcat(szBuffer, lpType);
            TVItem.hParent = RootItem;
            TVItem.item.mask = TVIF_TEXT;
            TVItem.item.pszText = szBuffer;
            TreeView_InsertItem(TreeView, &TVItem);

            //
            // Attribute Flags
            //
            _strcpy(szBuffer, TEXT("Flags: "));

            if (Attribute->Flags == 0) {
                _strcat(szBuffer, T_NoneValue);
            }
            else {

                _strcat(szBuffer, TEXT("("));
                ultohex(Attribute->Flags, _strend(szBuffer));
                _strcat(szBuffer, TEXT(") "));

                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Non-inheritable"));
                    bFlagSet = TRUE;
                }
                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Case-sensitive"));
                    bFlagSet = TRUE;
                }
                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Use for deny only"));
                    bFlagSet = TRUE;
                }
                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Default disabled"));
                    bFlagSet = TRUE;
                }
                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_DISABLED) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Disabled"));
                    bFlagSet = TRUE;
                }
                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_MANDATORY) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Mandatory"));
                    bFlagSet = TRUE;
                }
                if (Attribute->Flags & TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE) {
                    if (bFlagSet) _strcat(szBuffer, TEXT(", "));
                    _strcat(szBuffer, TEXT("Compare-ignore"));
                }

            }
            TreeView_InsertItem(TreeView, &TVItem);

            _strcpy(szBuffer, TEXT("Values"));
            TVItem.hParent = RootItem;
            TVItem.item.mask = TVIF_TEXT | TVIF_STATE;
            TVItem.item.state = TVIS_EXPANDED;
            TVItem.item.stateMask = TVIS_EXPANDED;
            TVItem.item.pszText = szBuffer;
            RootItem = TreeView_InsertItem(TreeView, &TVItem);

            for (j = 0; j < Attribute->ValueCount; j++) {

                TVItem.hParent = RootItem;
                TVItem.item.mask = TVIF_TEXT;

                lpType = propFormatTokenAttribute(Attribute, j);
                if (lpType) {
                    TVItem.item.pszText = lpType;
                }
                else {
                    TVItem.item.pszText = T_InvalidValue;
                }

                TreeView_InsertItem(TreeView, &TVItem);

                if (lpType)
                    supHeapFree(lpType);

            }
        }

        supHeapFree(SecurityAttributes);
    }

    //
    // Query object basic and type info if needed.
    //
    if (ExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hObject);
    }
    propCloseCurrentObject(Context, hObject);
}

/*
* propBasicQueryDesktop
*
* Purpose:
*
* Set information values for Desktop object type
*
* Support is very limited because of win32k type origin.
*
*/
PROP_QUERY_INFORMATION_ROUTINE(propBasicQueryDesktop)
{
    BOOL        bExtendedInfoAvailable;
    HANDLE      hDesktop = NULL;
    ULONG_PTR   ObjectAddress = 0, HeaderAddress = 0, InfoHeaderAddress = 0;

    OBEX_OBJECT_INFORMATION InfoObject;

    UNREFERENCED_PARAMETER(ExtendedInfoAvailable);

    //
    // Open Desktop object.
    //
    // Restriction: 
    // This will open only current winsta desktops
    //
    if (!propOpenCurrentObject(Context, &hDesktop, DESKTOP_READOBJECTS)) {
        return;
    }

    bExtendedInfoAvailable = FALSE;

    if (supQueryObjectFromHandle(hDesktop, &ObjectAddress, NULL)) {

        if (ObjectAddress)
            HeaderAddress = (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(ObjectAddress);

        //
        // If we can use driver, query extended information.
        //
        if (HeaderAddress && kdConnectDriver()) {
            RtlSecureZeroMemory(&InfoObject, sizeof(InfoObject));
            InfoObject.HeaderAddress = HeaderAddress;
            InfoObject.ObjectAddress = ObjectAddress;

            //dump object header
            bExtendedInfoAvailable = kdReadSystemMemory(HeaderAddress,
                &InfoObject.ObjectHeader, 
                sizeof(OBJECT_HEADER));

            if (bExtendedInfoAvailable) {
                //dump quota info
                if (ObHeaderToNameInfoAddress(InfoObject.ObjectHeader.InfoMask,
                    HeaderAddress, &InfoHeaderAddress, HeaderQuotaInfoFlag))
                {
                    kdReadSystemMemory(InfoHeaderAddress,
                        &InfoObject.ObjectQuotaHeader, sizeof(OBJECT_HEADER_QUOTA_INFO));
                }
                propSetBasicInfoEx(hwndDlg, &InfoObject);
            }
        }

        //cannot query extended info, output what we have
        if (bExtendedInfoAvailable == FALSE) {

            //Object and Header address
            propSetObjectHeaderAddressInfo(
                hwndDlg,
                ObjectAddress,
                HeaderAddress);

        }
    }

    //
    // Query object basic and type info if needed.
    //
    if (bExtendedInfoAvailable == FALSE) {
        propSetDefaultInfo(Context, hwndDlg, hDesktop);
    }
    propCloseCurrentObject(Context, (HANDLE)hDesktop);
}

/*
* propSetBasicInfoEx
*
* Purpose:
*
* Set information values received with kldbgdrv help
*
*/
VOID propSetBasicInfoEx(
    _In_ HWND hwndDlg,
    _In_ POBEX_OBJECT_INFORMATION InfoObject
)
{
    INT     i;
    HWND    hwndCB;
    WCHAR   szBuffer[MAX_PATH];


    //Object & Header Address
    propSetObjectHeaderAddressInfo(
        hwndDlg,
        InfoObject->ObjectAddress,
        InfoObject->HeaderAddress);

    //Reference Count
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    i64tostr(InfoObject->ObjectHeader.PointerCount, szBuffer);
    SetDlgItemText(hwndDlg, ID_OBJECT_REFC, szBuffer);

    //Handle Count
    i64tostr(InfoObject->ObjectHeader.HandleCount, szBuffer);
    SetDlgItemText(hwndDlg, ID_OBJECT_HANDLES, szBuffer);

    //NonPagedPoolCharge
    ultostr(InfoObject->ObjectQuotaHeader.NonPagedPoolCharge, szBuffer);
    SetDlgItemText(hwndDlg, ID_OBJECT_NP_CHARGE, szBuffer);

    //PagedPoolCharge
    ultostr(InfoObject->ObjectQuotaHeader.PagedPoolCharge, szBuffer);
    SetDlgItemText(hwndDlg, ID_OBJECT_PP_CHARGE, szBuffer);

    //Attributes
    hwndCB = GetDlgItem(hwndDlg, IDC_OBJECT_FLAGS);
    if (hwndCB) {
        EnableWindow(hwndCB, (InfoObject->ObjectHeader.Flags > 0) ? TRUE : FALSE);
        SendMessage(hwndCB, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
        if (InfoObject->ObjectHeader.Flags > 0) {
            for (i = 0; i < 8; i++) {

                if (GET_BIT(InfoObject->ObjectHeader.Flags, i))

                    SendMessage(hwndCB,
                        CB_ADDSTRING,
                        (WPARAM)0,
                        (LPARAM)T_ObjectFlags[i]);
            }
            SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
        }
    }
}

/*
* propSetBasicInfo
*
* Purpose:
*
* Set information values for Basic properties page
*
*/
VOID propSetBasicInfo(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg
)
{
    BOOL ExtendedInfoAvailable = FALSE, bQueryTrustLabel = FALSE;
    POBEX_OBJECT_INFORMATION InfoObject = NULL;

    pfnPropQueryInfoRoutine propQueryInfoRoutine;

    UNICODE_STRING usObjectName;

    if (supNormalizeUnicodeStringForDisplay(g_obexHeap,
        &Context->NtObjectName,
        &usObjectName))
    {
        SetDlgItemText(hwndDlg, ID_OBJECT_NAME, usObjectName.Buffer);
        supFreeDuplicatedUnicodeString(g_obexHeap, &usObjectName, FALSE);
    }
    else {
        SetDlgItemText(hwndDlg, ID_OBJECT_NAME, Context->NtObjectName.Buffer);
    }

    SetDlgItemText(hwndDlg, ID_OBJECT_TYPE, Context->TypeDescription->Name);

    //
    // Desktops should be parsed differently.
    //
    if (Context->ObjectTypeIndex != ObjectTypeDesktop) {

        //
        // Dump object information depending on context type.
        //
        switch (Context->ContextType) {

        case propPrivateNamespace:
            InfoObject = ObQueryObjectByAddress(Context->u1.NamespaceInfo.ObjectAddress);
            break;

        case propUnnamed:
            InfoObject = ObQueryObjectByAddress(Context->u1.UnnamedObjectInfo.ObjectAddress);
            break;

        case propNormal:
        default:
            InfoObject = ObQueryObjectInDirectory(&Context->NtObjectName, &Context->NtObjectPath);
            break;
        }

        ExtendedInfoAvailable = (InfoObject != NULL);
        if (InfoObject == NULL) {

            if (Context->ContextType == propUnnamed) {

                if (Context->u1.UnnamedObjectInfo.ObjectAddress) {
                    propSetObjectHeaderAddressInfo(
                        hwndDlg,
                        Context->u1.UnnamedObjectInfo.ObjectAddress,
                        (ULONG_PTR)OBJECT_TO_OBJECT_HEADER(Context->u1.UnnamedObjectInfo.ObjectAddress));
                }
            }
            else {
                SetDlgItemText(hwndDlg, ID_OBJECT_ADDR, TEXT(""));
                SetDlgItemText(hwndDlg, ID_OBJECT_HEADER, TEXT(""));
            }
        }
        else {
            //make copy of received dump
            RtlCopyMemory(&Context->ObjectInfo, InfoObject, sizeof(OBEX_OBJECT_INFORMATION));

            //
            // Set Object Address, Header Address, NP/PP Charge, RefCount, HandleCount, Attributes.
            //
            propSetBasicInfoEx(hwndDlg, InfoObject);

            //
            // Special case for AlpcPort object type.
            // The only information we can get is from driver here as we cannot open port directly.
            // 
            if (Context->ObjectTypeIndex == ObjectTypePort) {
                propBasicQueryAlpcPort(Context, hwndDlg, FALSE);
            }

            supHeapFree(InfoObject);
        }
    }

    //
    // Query Basic Information extended fields per Type.
    // If extended info not available each routine should query basic info itself.
    //
    propQueryInfoRoutine = NULL;

    switch (Context->ObjectTypeIndex) {
    case ObjectTypeDirectory:
        bQueryTrustLabel = TRUE;
        //if TRUE skip this because directory is basic dialog and basic info already set
        if (ExtendedInfoAvailable == FALSE) {
            propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryDirectory;
        }
        break;
    case ObjectTypeDriver:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryDriver;
        break;
    case ObjectTypeDevice:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryDevice;
        break;
    case ObjectTypeSymbolicLink:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQuerySymlink;
        break;
    case ObjectTypeKey:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryKey;
        break;
    case ObjectTypeMutant:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryMutant;
        break;
    case ObjectTypeEvent:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryEvent;
        break;
    case ObjectTypeTimer:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryTimer;
        break;
    case ObjectTypeSemaphore:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQuerySemaphore;
        break;
    case ObjectTypeSection:
        bQueryTrustLabel = TRUE;
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQuerySection;
        break;
    case ObjectTypeWinstation:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryWindowStation;
        break;
    case ObjectTypeJob:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryJob;
        break;
    case ObjectTypeSession:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQuerySession;
        break;
    case ObjectTypeDesktop:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryDesktop;
        break;
    case ObjectTypeIoCompletion:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryIoCompletion;
        break;
    case ObjectTypeMemoryPartition:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryMemoryPartition;
        break;
    case ObjectTypeRegistryTransaction:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryRegistryTransaction;
        break;
    case ObjectTypeProcess:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryProcess;
        break;
    case ObjectTypeThread:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryThread;
        break;
    case ObjectTypeToken:
        propQueryInfoRoutine = (pfnPropQueryInfoRoutine)propBasicQueryToken;
        break;
    }

    //
    // Query object information by type.
    //
    if (propQueryInfoRoutine)
        propQueryInfoRoutine(Context, hwndDlg, ExtendedInfoAvailable);

    //
    // Set TrustLabel information for enabled object types.
    //
    if (bQueryTrustLabel)
        propSetProcessTrustLabelInfo(Context, hwndDlg);

}

/*
* BasicPropDialogOnCommand
*
* Purpose:
*
* Basic Properties Dialog WM_COMMAND handler.
*
*/
INT_PTR BasicPropDialogOnCommand(
    _In_  HWND hwndDlg,
    _In_  WPARAM wParam
)
{
    INT_PTR iResult = 0;
    SIZE_T bufferSize;
    PWCHAR lpImageFileName;
    HWND hwndImageFileName = GetDlgItem(hwndDlg, IDC_PROCESS_FILENAME);

    if (LOWORD(wParam) == IDC_PROCESS_BROWSE) {
        bufferSize = UNICODE_STRING_MAX_BYTES + 1;
        lpImageFileName = (LPWSTR)supHeapAlloc(bufferSize);
        if (lpImageFileName) {
            GetWindowText(hwndImageFileName, lpImageFileName, UNICODE_STRING_MAX_BYTES / sizeof(WCHAR));
            supJumpToFile(lpImageFileName);
            supHeapFree(lpImageFileName);
        }
        iResult = 1;
    }

    return iResult;
}

/*
* BasicPropDialogOnInit
*
* Purpose:
*
* Basic Properties Dialog WM_INITDIALOG handler.
*
*/
VOID BasicPropDialogOnInit(
    _In_  HWND hwndDlg,
    _In_  LPARAM lParam
)
{
    PROPSHEETPAGE* pSheet = NULL;

    pSheet = (PROPSHEETPAGE*)lParam;
    if (pSheet) {
        SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
        supLoadIconForObjectType(hwndDlg,
            (PROP_OBJECT_INFO*)pSheet->lParam,
            g_ListViewImages,
            FALSE);
    }
}

/*
* BasicPropDialogProc
*
* Purpose:
*
* Basic Properties Dialog Procedure
*
* WM_INITDIALOG - set context window prop.
* WM_SHOWWINDOW - when wParam is TRUE it sets "Basic" page object information.
* WM_COMMAND - handle specific controls commands.
* WM_DESTROY - remove context window prop.
*
*/
INT_PTR CALLBACK BasicPropDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    PROP_OBJECT_INFO* Context = NULL;

    switch (uMsg) {

    case WM_INITDIALOG:
        BasicPropDialogOnInit(hwndDlg, lParam);
        return 1;

    case WM_SHOWWINDOW:
        if (wParam) {
            Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
            if (Context) {
                propSetBasicInfo(Context, hwndDlg);
                return 1;
            }
        }
        break;

    case WM_COMMAND:
        return BasicPropDialogOnCommand(hwndDlg, wParam);

    case WM_DESTROY:
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        break;

    }
    return 0;
}

```

`Source/WinObjEx64/props/propBasicConsts.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPBASICCONSTS.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Consts header file for Basic property sheet.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define T_COULD_NOT_QUERY TEXT("*Could not query requested information*")

//OBJECT_HEADER Flags
static LPCWSTR T_ObjectFlags[8] = {
    L"NewObject",
    L"KernelObject",
    L"KernelOnlyAccess",
    L"Exclusive",
    L"Permanent",
    L"DefSecurityQuota",
    L"SingleHandleEntry",
    L"DeletedInline"
};

//
// Process Trust Label related descriptions.
//

#define MAX_KNOWN_TRUSTLABEL_PROTECTIONTYPE 3
static VALUE_DESC TrustLabelProtectionType[MAX_KNOWN_TRUSTLABEL_PROTECTIONTYPE] = {
    { L"None",  0x0 },
    { L"PPL", 0x200 },
    { L"PP", 0x400 }
};

#define MAX_KNOWN_TRUSTLABEL_PROTECTIONLEVEL 6
static VALUE_DESC TrustLabelProtectionLevel[MAX_KNOWN_TRUSTLABEL_PROTECTIONLEVEL] = {
    { L"None",  0x0 },
    { L"Authenticode", 0x400 },
    { L"Antimalware", 0x600 },
    { L"App", 0x800 },
    { L"Windows", 0x1000 },
    { L"WinTcb", 0x2000 }
};

#define MAX_KNOWN_PROCESS_TYPE_FLAGS 9
LPCWSTR T_ProcessTypeFlags[MAX_KNOWN_PROCESS_TYPE_FLAGS] = {
    L"ProtectedProcess",
    L"Wow64Process",
    L"ProcessDeleting",
    L"CrossSessionCreate",
    L"Frozen",
    L"Background",
    L"StronglyNamed",
    L"SecureProcess",
    L"SubsystemProcess"
};

#define MAX_KNOWN_PS_PROTECTED_SIGNER 9
static LPWSTR T_PSPROTECTED_SIGNER[MAX_KNOWN_PS_PROTECTED_SIGNER] = {
    L"None",
    L"Authenticode",
    L"CodeGen",
    L"Antimalware",
    L"Lsa",
    L"Windows",
    L"WinTcb",
    L"WinSystem",
    L"App"
};

#define MAX_KNOWN_PS_PROTECTED_TYPE 3
static LPWSTR T_PSPROTECTED_TYPE[MAX_KNOWN_PS_PROTECTED_TYPE] = {
    L"None",
    L"ProtectedLight",
    L"Protected"
};


```

`Source/WinObjEx64/props/propCommon.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       PROPCOMMON.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Common header file for the property sheet based dialogs.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

typedef enum _PROP_CONTEXT_TYPE {
    propNormal = 0,
    propPrivateNamespace = 1,
    propUnnamed = 2,
    propMax = 3
} PROP_CONTEXT_TYPE;

typedef struct _PROP_NAMESPACE_INFO {
    ULONG Reserved;
    ULONG SizeOfBoundaryDescriptor;
    OBJECT_BOUNDARY_DESCRIPTOR* BoundaryDescriptor;
    ULONG_PTR ObjectAddress;
} PROP_NAMESPACE_INFO, * PPROP_NAMESPACE_INFO;

typedef struct _PROP_UNNAMED_OBJECT_INFO {
    BOOL IsThreadToken;
    ULONG_PTR ObjectAddress;
    CLIENT_ID ClientId;
    SYSTEM_THREAD_INFORMATION ThreadInformation;
    UNICODE_STRING ImageName;
} PROP_UNNAMED_OBJECT_INFO, * PPROP_UNNAMED_OBJECT_INFO;

typedef struct _PROP_OBJECT_INFO {

    PROP_CONTEXT_TYPE ContextType;
    WOBJ_OBJECT_TYPE ObjectTypeIndex;

    //
    // Object specific flags
    //
    DWORD ObjectFlags;
   
    //
    // Unicode strings for object name/path where used.
    //
    UNICODE_STRING NtObjectName;
    UNICODE_STRING NtObjectPath;

    //
    // Context specific data.
    //
    PVOID ExtrasContext;

    //
    // Reference to object type description entry in global array.
    //
    WOBJ_TYPE_DESC* TypeDescription; 
    WOBJ_TYPE_DESC* ShadowTypeDescription; //valid only for types, same as TypeDescription for everything else.

    //
    // Icons assigned during runtime.
    //
    HICON ObjectIcon;
    HICON ObjectTypeIcon;

    OBEX_OBJECT_INFORMATION ObjectInfo; //object dump related structures

    //
    // Private namespace or unnamed object (process/thread/token) information.
    //
    union {
        PROP_NAMESPACE_INFO NamespaceInfo;
        PROP_UNNAMED_OBJECT_INFO UnnamedObjectInfo;
    } u1;

} PROP_OBJECT_INFO, * PPROP_OBJECT_INFO;

typedef struct _PROP_CONFIG {
    PROP_CONTEXT_TYPE ContextType;
    HWND hwndParent;

    WOBJ_OBJECT_TYPE ObjectTypeIndex;

    PUNICODE_STRING NtObjectName;
    PUNICODE_STRING NtObjectPath;

    union {
        PVOID ObjectData;
        union {
            PROP_NAMESPACE_INFO* NamespaceObject;
            PROP_UNNAMED_OBJECT_INFO* UnnamedObject;
        } u1;
    };
} PROP_CONFIG, * PPROP_CONFIG;

//open object method (propOpenCurrentObject)
typedef BOOL(CALLBACK* POPENOBJECTMETHOD)(
    _In_ PROP_OBJECT_INFO* Context,
    _Inout_ PHANDLE	phObject,
    _In_ ACCESS_MASK DesiredAccess
    );

//close object method (propCloseCurrentObject)
typedef VOID(CALLBACK* PCLOSEOBJECTMETHOD)(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HANDLE hObject
    );

```

`Source/WinObjEx64/props/propDesktop.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPDESKTOP.C
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "propDlg.h"
#include "extras.h"

typedef struct _DLG_ENUM_CALLBACK_CONTEXT {
    PROP_OBJECT_INFO* ObjectContext;
    EXTRASCONTEXT* DialogContext;
} DLG_ENUM_CALLBACK_CONTEXT, * PDLG_ENUM_CALLBACK_CONTEXT;

/*
* DesktopListEnumProc
*
* Purpose:
*
* EnumDesktops callback.
*
*/
BOOL CALLBACK DesktopListEnumProc(
    _In_ LPWSTR lpszDesktop,
    _In_ LPARAM lParam
)
{
    BOOL bSucc;
    INT	nIndex;
    DWORD bytesNeeded, dwDesktopHeapSize;
    LPWSTR lpName, StringSid;
    PSID pSID;
    SIZE_T sz;
    HDESK hDesktop;
    LVITEM lvitem;
    WCHAR szHeap[64];

    DLG_ENUM_CALLBACK_CONTEXT* enumParam = (DLG_ENUM_CALLBACK_CONTEXT*)lParam;
    if (enumParam == NULL) {
        return FALSE;
    }

    // Object
    sz = (1 + _strlen(lpszDesktop)) * sizeof(WCHAR);
    lpName = (LPWSTR)supHeapAlloc(sz);
    if (lpName == NULL)
        return 0;

    _strcpy(lpName, lpszDesktop);

    //Name
    RtlSecureZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvitem.pszText = lpName;
    lvitem.iItem = MAXINT;
    nIndex = ListView_InsertItem(enumParam->DialogContext->ListView, &lvitem);

    supHeapFree(lpName);

    //
    // Query desktop objects information.
    //
    bSucc = FALSE;
    StringSid = NULL;
    hDesktop = OpenDesktop(lpszDesktop, 0, FALSE, DESKTOP_READOBJECTS);
    if (hDesktop) {

        //
        // Query SID.
        //
        bytesNeeded = 0;
        GetUserObjectInformation(hDesktop, UOI_USER_SID, NULL, 0, &bytesNeeded);

        //
        // User associated with desktop present, query sid.
        //
        if (bytesNeeded) {
            //
            // Allocate memory for sid.
            //
            pSID = supHeapAlloc(bytesNeeded);
            if (pSID) {
                if (GetUserObjectInformation(hDesktop,
                    UOI_USER_SID, pSID, bytesNeeded, &bytesNeeded))
                {
                    bSucc = ConvertSidToStringSid(pSID, &StringSid);
                }
                supHeapFree(pSID);
            }
        }

        //
        // Add SID string to the list.
        //
        if (bSucc && StringSid) {
            lvitem.mask = LVIF_TEXT;
            lvitem.iSubItem = 1;
            lvitem.pszText = StringSid;
            lvitem.iItem = nIndex;
            ListView_SetItem(enumParam->DialogContext->ListView, &lvitem);
            LocalFree(StringSid);
        }

        //
        // Add Desktop Heap Size, returned in KBytes.
        //
        dwDesktopHeapSize = 0;
        if (GetUserObjectInformation(hDesktop,
            UOI_HEAPSIZE,
            &dwDesktopHeapSize,
            sizeof(dwDesktopHeapSize),
            &bytesNeeded))
        {
            if (dwDesktopHeapSize) {
                szHeap[0] = 0;
                ultostr(dwDesktopHeapSize / 1024, szHeap);
                _strcat(szHeap, TEXT(" Mb"));
                lvitem.pszText = szHeap;
            }
            else {
                lvitem.pszText = T_EmptyString;
            }

            lvitem.mask = LVIF_TEXT;
            lvitem.iSubItem = 2;
            lvitem.iItem = nIndex;
            ListView_SetItem(enumParam->DialogContext->ListView, &lvitem);
        }
        CloseDesktop(hDesktop);
    }
    return TRUE;
}

/*
* DesktopListSetInfo
*
* Purpose:
*
* Query information and fill listview.
* Called each time when page became visible.
*
*/
VOID DesktopListSetInfo(
    _In_ HWND hwndDlg,
    _In_ PROP_OBJECT_INFO* Context,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    BOOL    bResult = FALSE;
    HWINSTA hObject;

    DLG_ENUM_CALLBACK_CONTEXT enumParam;

    ListView_DeleteAllItems(pDlgContext->ListView);

    hObject = supOpenWindowStationFromContext(Context, FALSE, WINSTA_ENUMDESKTOPS);
    if (hObject) {

        enumParam.ObjectContext = Context;
        enumParam.DialogContext = pDlgContext;

        EnumDesktops(hObject, DesktopListEnumProc, (LPARAM)&enumParam);

        CloseWindowStation(hObject);
        bResult = TRUE;
    }
    ShowWindow(GetDlgItem(hwndDlg, ID_DESKTOPSNOTALL), (bResult == FALSE) ? SW_SHOW : SW_HIDE);
}

/*
* DesktopListCreate
*
* Purpose:
*
* Initialize listview for desktop list.
* Called once.
*
*/
VOID DesktopListCreate(
    _In_ HWND hwndDlg,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    HICON hImage;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"Name", 200, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  2 },
        { L"SID", 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Heap Size", 100, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_DESKTOPSLIST);
    if (pDlgContext->ListView == NULL)
        return;

    pDlgContext->ImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 8, 8);
    if (pDlgContext->ImageList) {

        //desktop image
        hImage = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_DESKTOP),
            IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

        if (hImage) {
            ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hImage);
            DestroyIcon(hImage);
        }

        //sort images
        hImage = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_SORTUP),
            IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

        if (hImage) {
            ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hImage);
            DestroyIcon(hImage);
        }
        hImage = (HICON)LoadImage(g_WinObj.hInstance, MAKEINTRESOURCE(IDI_ICON_SORTDOWN),
            IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

        if (hImage) {
            ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hImage);
            DestroyIcon(hImage);
        }

    }

    //
    // Set listview imagelist, style flags and theme.
    //
    supSetListViewSettings(pDlgContext->ListView,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        pDlgContext->ImageList,
        LVSIL_SMALL);

    //
    // And columns and remember their count.
    //
    pDlgContext->lvColumnCount = supAddLVColumnsFromArray(
        pDlgContext->ListView,
        columnData,
        RTL_NUMBER_OF(columnData));
}

/*
* DesktopListCompareFunc
*
* Purpose:
*
* Listview comparer function.
*
*/
INT CALLBACK DesktopListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lpContextParam
)
{
    EXTRASCONTEXT* pDlgContext;

    pDlgContext = (EXTRASCONTEXT*)lpContextParam;
    if (pDlgContext == NULL)
        return 0;

    return supListViewBaseComparer(pDlgContext->ListView,
        pDlgContext->bInverseSort,
        lParam1,
        lParam2,
        pDlgContext->lvColumnToSort);
}

/*
* DesktopListShowProperties
*
* Purpose:
*
* Properies double click handler.
*
*/
VOID DesktopListShowProperties(
    _In_ HWND hwndDlg
)
{
    EXTRASCONTEXT* pDlgContext;
    LPWSTR lpName;
    UNICODE_STRING usObjectName;

    PROP_CONFIG propConfig;

    //
    // Allow only one dialog at same time.
    //
    supCloseKnownPropertiesDialog(propGetDesktopWindow());

    //
    // A very basic support for this type.
    // Desktop described by win32k PDESKTOP structure which is totally undocumented.
    //
    pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
    if (pDlgContext) {

        lpName = supGetItemText(
            pDlgContext->ListView,
            ListView_GetSelectionMark(pDlgContext->ListView),
            0,
            NULL);

        if (lpName) {

            RtlInitUnicodeString(&usObjectName, lpName);

            RtlSecureZeroMemory(&propConfig, sizeof(propConfig));
            propConfig.hwndParent = hwndDlg;
            propConfig.NtObjectName = &usObjectName;
            propConfig.ObjectTypeIndex = ObjectTypeDesktop;

            propCreateDialog(&propConfig);

            supHeapFree(lpName);
        }
    }
}

/*
* DesktopListHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for page listview.
*
*/
BOOL DesktopListHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT nImageIndex;
    LPNMLISTVIEW nhdr = (LPNMLISTVIEW)lParam;
    EXTRASCONTEXT* pDlgContext;

    if (nhdr == NULL) {
        return FALSE;
    }

    if (nhdr->hdr.idFrom != ID_DESKTOPSLIST) {
        return FALSE;
    }

    switch (nhdr->hdr.code) {

    case LVN_COLUMNCLICK:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            pDlgContext->bInverseSort = (~pDlgContext->bInverseSort) & 1;
            pDlgContext->lvColumnToSort = ((NMLISTVIEW*)nhdr)->iSubItem;

            ListView_SortItemsEx(
                pDlgContext->ListView,
                &DesktopListCompareFunc,
                pDlgContext);

            if (pDlgContext->bInverseSort)
                nImageIndex = 1;
            else
                nImageIndex = 2;

            supUpdateLvColumnHeaderImage(
                pDlgContext->ListView,
                pDlgContext->lvColumnCount,
                pDlgContext->lvColumnToSort,
                nImageIndex);
        }
        break;

    case NM_DBLCLK:
        DesktopListShowProperties(hwndDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* DesktopListDialogProc
*
* Purpose:
*
* Desktop list page.
*
* WM_INITDIALOG - Initialize listview.
* WM_NOTIFY - Handle list view notifications.
* WM_SHOWWINDOW - Collect desktop info and fill list.
* WM_DESTROY - Free image list.
*
*/
INT_PTR CALLBACK DesktopListDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    PROPSHEETPAGE* pSheet;
    PROP_OBJECT_INFO* Context = NULL;
    EXTRASCONTEXT* pDlgContext = NULL;

    switch (uMsg) {

    case WM_SHOWWINDOW:
        if (wParam) {
            Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (Context && pDlgContext) {

                DesktopListSetInfo(hwndDlg, Context, pDlgContext);
                if (pDlgContext->ListView) {

                    ListView_SortItemsEx(
                        pDlgContext->ListView,
                        &DesktopListCompareFunc,
                        pDlgContext);
                }

            }
        }
        break;

    case WM_NOTIFY:
        return DesktopListHandleNotify(hwndDlg, lParam);

    case WM_DESTROY:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            if (pDlgContext->ImageList) {
                ImageList_Destroy(pDlgContext->ImageList);
            }
            supHeapFree(pDlgContext);
        }
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        break;

    case WM_INITDIALOG:
        pSheet = (PROPSHEETPAGE*)lParam;
        if (pSheet) {
            SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
            pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
            if (pDlgContext) {
                SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pDlgContext);
                DesktopListCreate(hwndDlg, pDlgContext);
            }
        }
        break;
    default:
        return FALSE;

    }
    return TRUE;
}

```

`Source/WinObjEx64/props/propDlg.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPDLG.C
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "props.h"

//previously focused window
HWND PreviousFocus = NULL;

//maximum number of possible pages, include space reserved for future use
#define MAX_PAGE 10
HPROPSHEETPAGE PropPages[MAX_PAGE];

//original window procedure of PropertySheet
WNDPROC PropSheetOriginalWndProc = NULL;

//handle to the PropertySheet window
HWND CommonPropWindow = NULL;
HWND ProcessesPropWindow = NULL;
HWND ThreadsPropWindow = NULL;
HWND TokenPropWindow = NULL;
HWND DesktopPropWindow = NULL;
HWND NamespacePropWindow = NULL;

HWND propGetCommonWindow()
{
    return CommonPropWindow;
}

HWND propGetProcessesWindow()
{
    return ProcessesPropWindow;
}

HWND propGetThreadsWindow()
{
    return ThreadsPropWindow;
}

HWND propGetTokenWindow()
{
    return TokenPropWindow;
}

HWND propGetDesktopWindow()
{
    return DesktopPropWindow;
}

HWND propGetNamespaceWindow()
{
    return NamespacePropWindow;
}

/*
* propCloseCurrentObject
*
* Purpose:
*
* Close handle opened with propOpenCurrentObject.
*
*/
BOOL propCloseCurrentObject(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HANDLE hObject
)
{
    return supCloseObjectFromContext(Context, hObject);
}

/*
* propIsUnsupportedTypeForOpen
*
* Purpose:
*
* Filter object opening by type as we cannot open everything.
*
*/
BOOL propIsUnsupportedTypeForOpen(
    _In_ WOBJ_OBJECT_TYPE TypeIndex
)
{
    WOBJ_OBJECT_TYPE propUnsupportedTypes[] = {
        ObjectTypeUnknown,
        ObjectTypeFltConnPort,
        ObjectTypeFltComnPort,
        ObjectTypeWaitablePort
    };

    ULONG i;
    for (i = 0; i < RTL_NUMBER_OF(propUnsupportedTypes); i++)
        if (TypeIndex == propUnsupportedTypes[i])
            return TRUE;

    return FALSE;
}

/*
* propOpenCurrentObject
*
* Purpose:
*
* Opens currently viewed object depending on type
*
*/
_Success_(return)
BOOL propOpenCurrentObject(
    _In_ PROP_OBJECT_INFO* Context,
    _Out_ PHANDLE phObject,
    _In_ ACCESS_MASK DesiredAccess
)
{
    BOOL bResult;
    HANDLE hObject, hDirectory;
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;

    bResult = FALSE;

    //
    // Filter unsupported types.
    //
    if (propIsUnsupportedTypeForOpen(Context->ObjectTypeIndex)) {
        SetLastError(ERROR_UNSUPPORTED_TYPE);
        return FALSE;
    }

    //
    // Handle window station type.
    //
    if (Context->ObjectTypeIndex == ObjectTypeWinstation) {
        hObject = supOpenWindowStationFromContext(Context, FALSE, DesiredAccess); //WINSTA_READATTRIBUTES for query
        bResult = (hObject != NULL);
        if (bResult) {
            *phObject = hObject;
        }

        return bResult;
    }

    //
    // Handle desktop type.
    //
    if (Context->ObjectTypeIndex == ObjectTypeDesktop) {

        hObject = OpenDesktop(Context->NtObjectName.Buffer, 0, FALSE, DesiredAccess); //DESKTOP_READOBJECTS for query
        bResult = (hObject != NULL);
        if (bResult) {
            *phObject = hObject;
        }

        return bResult;
    }

    //
    // Objects without name must be handled in a special way.
    //
    if (Context->ContextType == propUnnamed) {

        InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);

        hObject = supOpenObjectFromContext(
            Context,
            &obja,
            DesiredAccess,
            &status);

        SetLastError(RtlNtStatusToDosError(status));
        bResult = ((NT_SUCCESS(status)) && (hObject != NULL));
        if (bResult) {
            *phObject = hObject;
        }
        return bResult;
    }

    //
    // Namespace objects must be handled in a special way.
    //
    if (Context->ContextType == propPrivateNamespace) {

        InitializeObjectAttributes(&obja, &Context->NtObjectName, 
            OBJ_CASE_INSENSITIVE, NULL, NULL);

        hObject = supOpenObjectFromContext(
            Context,
            &obja,
            DesiredAccess,
            &status);

        SetLastError(RtlNtStatusToDosError(status));
        bResult = ((NT_SUCCESS(status)) && (hObject != NULL));
        if (bResult) {
            *phObject = hObject;
        }
        return bResult;
    }

    hDirectory = NULL;

    if (DesiredAccess == 0) {
        DesiredAccess = 1;
    }

    //
    // Handle directory type.
    //
    if (Context->ObjectTypeIndex == ObjectTypeDirectory) {

        //
        // If this is root, then root hDirectory = NULL.
        //
        if (!supIsRootDirectory(&Context->NtObjectName)) {
            //
            // Otherwise open directory that keep this object.
            //
            supOpenDirectoryEx(&hDirectory, NULL, &Context->NtObjectPath, DIRECTORY_QUERY);
            if (hDirectory == NULL) {
                SetLastError(ERROR_OBJECT_NOT_FOUND);
                return bResult;
            }
        }

        //
        // Open object in directory.
        //

        status = supOpenDirectoryEx(&hObject, 
            hDirectory, 
            &Context->NtObjectName, 
            DesiredAccess);

        if (!NT_SUCCESS(status)) {
            SetLastError(RtlNtStatusToDosError(status));
        }

        bResult = (hObject != NULL);

        if (bResult) {
            *phObject = hObject;
        }

        //dont forget to close directory handle if it was opened
        if (hDirectory != NULL) {
            NtClose(hDirectory);
        }
        return bResult;
    }

    //
    // Open directory which current object belongs.
    //
    supOpenDirectoryEx(&hDirectory, NULL, &Context->NtObjectPath, DIRECTORY_QUERY);
    if (hDirectory == NULL) {
        SetLastError(ERROR_OBJECT_NOT_FOUND);
        return bResult;
    }

    InitializeObjectAttributes(&obja, &Context->NtObjectName, OBJ_CASE_INSENSITIVE, hDirectory, NULL);

    status = STATUS_UNSUCCESSFUL;
    hObject = NULL;

    //
    // Handle supported objects.
    //
    hObject = supOpenObjectFromContext(
        Context,
        &obja,
        DesiredAccess,
        &status);

    SetLastError(RtlNtStatusToDosError(status));
    NtClose(hDirectory);

    bResult = ((NT_SUCCESS(status)) && (hObject != NULL));
    if (bResult) {
        *phObject = hObject;
    }
    return bResult;
}

/*
* propContextCreate
*
* Purpose:
*
* Initialize property sheet object context
*
*/
PPROP_OBJECT_INFO propContextCreate(
    _In_ PROP_CONFIG* Config
)
{
    PROP_OBJECT_INFO* propContext;

    union {
        PVOID Ref;
        union {
            PROP_NAMESPACE_INFO* NamespaceObject;
            PROP_UNNAMED_OBJECT_INFO* UnnamedObject;
        };
    } ObjectRef;

    //
    // Allocate context structure.
    //
    propContext = (PROP_OBJECT_INFO*)supHeapAlloc(sizeof(PROP_OBJECT_INFO));
    if (propContext == NULL)
        return NULL;

    propContext->ObjectTypeIndex = Config->ObjectTypeIndex;

    //
    // Copy object name if given.
    //
    if (Config->NtObjectName) {
        supDuplicateUnicodeString(g_obexHeap, &propContext->NtObjectName, Config->NtObjectName);
    }

    //
    // Copy object path if given because dialog is modeless.
    //
    if (Config->NtObjectPath) {
        supDuplicateUnicodeString(g_obexHeap, &propContext->NtObjectPath, Config->NtObjectPath);
    }

    propContext->TypeDescription = ObManagerGetEntryByTypeIndex(propContext->ObjectTypeIndex);

    //
    // Check if object is Type object.
    // Type objects handled differently.
    //
    if (propContext->ObjectTypeIndex == ObjectTypeType) {
        propContext->ShadowTypeDescription = ObManagerGetEntryByTypeName(propContext->NtObjectName.Buffer);
    }
    else {
        //
        // Use the same type descriptor by default for shadow.
        //
        propContext->ShadowTypeDescription = propContext->TypeDescription;
    }

    //
    // Remember namespace or unnamed object info.
    // Always last.
    //
    ObjectRef.Ref = Config->ObjectData;

    if (Config->ContextType == propPrivateNamespace) {

        propContext->ContextType = propPrivateNamespace;
        propContext->u1.NamespaceInfo = *ObjectRef.NamespaceObject;

    }
    else if (Config->ContextType == propUnnamed) {

        propContext->ContextType = propUnnamed;
        //
        // Copy generic data.
        //
        propContext->u1.UnnamedObjectInfo.ObjectAddress = ObjectRef.UnnamedObject->ObjectAddress;
        propContext->u1.UnnamedObjectInfo.ClientId = ObjectRef.UnnamedObject->ClientId;
        if (propContext->ObjectTypeIndex == ObjectTypeThread) {
            propContext->u1.UnnamedObjectInfo.ThreadInformation = ObjectRef.UnnamedObject->ThreadInformation;
        }

        //
        // Copy image name if present.
        //
        supDuplicateUnicodeString(g_obexHeap,
            &propContext->u1.UnnamedObjectInfo.ImageName,
            &ObjectRef.UnnamedObject->ImageName);

    }

    return propContext;
}

/*
* propContextDestroy
*
* Purpose:
*
* Destroys property sheet object context
*
*/
VOID propContextDestroy(
    _In_ PROP_OBJECT_INFO* Context
)
{
    //free associated icons
    if (Context->ObjectTypeIndex == ObjectTypeType) {
        if (Context->ObjectTypeIcon) {
            DestroyIcon(Context->ObjectTypeIcon);
        }
    }
    if (Context->ObjectIcon) {
        DestroyIcon(Context->ObjectIcon);
    }

    //free boundary descriptor
    if (Context->ContextType == propPrivateNamespace) {
        if (Context->u1.NamespaceInfo.BoundaryDescriptor) {
            supHeapFree(Context->u1.NamespaceInfo.BoundaryDescriptor);
        }
    }
    else  if (Context->ContextType == propUnnamed) {
        //free unnamed object info
        supFreeDuplicatedUnicodeString(g_obexHeap, &Context->u1.UnnamedObjectInfo.ImageName, FALSE);
    }

    supFreeDuplicatedUnicodeString(g_obexHeap, &Context->NtObjectName, FALSE);
    supFreeDuplicatedUnicodeString(g_obexHeap, &Context->NtObjectPath, FALSE);

    //free context itself
    supHeapFree(Context);
}

VOID propSetSharedHwnd(
    _In_ HWND hwnd
)
{
    if (hwnd == TokenPropWindow) {
        TokenPropWindow = NULL;
    }
    else if (hwnd == ProcessesPropWindow) {
        if (TokenPropWindow) {
            TokenPropWindow = NULL;
        }
        if (ThreadsPropWindow) {
            ThreadsPropWindow = NULL;
        }
        ProcessesPropWindow = NULL;
    }
    else if (hwnd == ThreadsPropWindow) {
        ThreadsPropWindow = NULL;
    }
    else if (hwnd == NamespacePropWindow) {
        NamespacePropWindow = NULL;
    }
    else if (hwnd == DesktopPropWindow) {
        DesktopPropWindow = NULL;
    }
    if (hwnd == CommonPropWindow) {
        if (DesktopPropWindow) {
            DesktopPropWindow = NULL;
        }
        //restore previous focus
        if (PreviousFocus && IsWindow(PreviousFocus)) {
            SetFocus(PreviousFocus);
        }
        CommonPropWindow = NULL;
    }
}

/*
* PropSheetCustomWndProc
*
* Purpose:
*
* Custom Modeless PropSheet Window Procedure
*
* During WM_DESTROY releases memory allocated for global current object pointers.
*
*/
LRESULT WINAPI PropSheetCustomWndProc(
    _In_ HWND hwnd,
    _In_ UINT Msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    PROP_OBJECT_INFO* Context = NULL;

    switch (Msg) {

    case WM_SYSCOMMAND:
        if (LOWORD(wParam) == SC_CLOSE) {
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        break;

    case WM_DESTROY:
        Context = (PROP_OBJECT_INFO*)RemoveProp(hwnd, T_PROPCONTEXT);
        if (Context) {
            propContextDestroy(Context);
        }
        break;

    case WM_CLOSE:
        propSetSharedHwnd(hwnd);
        DestroyWindow(hwnd);
        break;

    case WM_COMMAND:
        if ((LOWORD(wParam) == IDOK) || (LOWORD(wParam) == IDCANCEL)) {
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            return TRUE;
        }
        break;

    }

    return CallWindowProc(PropSheetOriginalWndProc, hwnd, Msg, wParam, lParam);
}

HPROPSHEETPAGE propAddPage(
    _In_ LPCWSTR pszTitle,
    _In_ DLGPROC pfnDlgProc,
    _In_ LPCWSTR pszTemplate,
    _In_ LPARAM lParam
)
{
    PROPSHEETPAGE propPage;

    RtlSecureZeroMemory(&propPage, sizeof(propPage));
    propPage.dwSize = sizeof(PROPSHEETPAGE);
    propPage.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    propPage.hInstance = g_WinObj.hInstance;
    propPage.lParam = lParam;
    propPage.pfnDlgProc = pfnDlgProc;
    propPage.pszTemplate = pszTemplate;
    propPage.pszTitle = pszTitle;

    return CreatePropertySheetPage(&propPage);
}

INT propCreatePages(
    _In_ PROP_OBJECT_INFO* Context
)
{
    BOOL IsDriverAssisted;
    INT nPages = 0;
    LPCWSTR pszTemplate;
    HPROPSHEETPAGE hSecurityPage;

    IsDriverAssisted = kdConnectDriver();

    nPages = 0;
    RtlSecureZeroMemory(PropPages, sizeof(PropPages));

    //
    // Properties: 
    // Basic->[Object]->[Process]->[Desktops]->[Registry]->Type->[Security]
    //

    //
    // Basic Info Page.
    //

    //
    // Select dialog for basic info.
    //
    switch (Context->ObjectTypeIndex) {
    case ObjectTypeTimer:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_TIMER);
        break;
    case ObjectTypeMutant:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_MUTANT);
        break;
    case ObjectTypeSemaphore:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_SEMAPHORE);
        break;
    case ObjectTypeJob:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_JOB);
        break;
    case ObjectTypeWinstation:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_WINSTATION);
        break;
    case ObjectTypeEvent:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_EVENT);
        break;
    case ObjectTypeSymbolicLink:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_SYMLINK);
        break;
    case ObjectTypeKey:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_KEY);
        break;
    case ObjectTypeSection:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_SECTION);
        break;
    case ObjectTypeDriver:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_DRIVER);
        break;
    case ObjectTypeDevice:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_DEVICE);
        break;
    case ObjectTypeIoCompletion:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_IOCOMPLETION);
        break;
    case ObjectTypePort:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_ALPCPORT);
        break;
    case ObjectTypeProcess:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_PROCESS);
        break;
    case ObjectTypeThread:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_THREAD);
        break;
    case ObjectTypeToken:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_TOKEN);
        break;
    case ObjectTypeType:
    default:
        pszTemplate = MAKEINTRESOURCE(IDD_PROP_BASIC);
        break;
    }

    PropPages[nPages++] = propAddPage(
        TEXT("Basic"),
        BasicPropDialogProc,
        pszTemplate,
        (LPARAM)Context);

    //
    // Create Objects page for supported types.
    //
    if (IsDriverAssisted) {
        switch (Context->ObjectTypeIndex) {
        case ObjectTypeDirectory:
        case ObjectTypeDriver:
        case ObjectTypeDevice:
        case ObjectTypeEvent:
        case ObjectTypeMutant:
        case ObjectTypePort:
        case ObjectTypeSemaphore:
        case ObjectTypeTimer:
        case ObjectTypeIoCompletion:
        case ObjectTypeFltConnPort:
        case ObjectTypeType:
        case ObjectTypeCallback:
        case ObjectTypeSymbolicLink:

            PropPages[nPages++] = propAddPage(
                TEXT("Object"),
                ObjectDumpDialogProc,
                MAKEINTRESOURCE(IDD_PROP_OBJECTDUMP),
                (LPARAM)Context);

            break;
        }
    }

    //
    // Create specific page for Process/Thread objects.
    //
    if ((Context->ObjectTypeIndex == ObjectTypeProcess) ||
        (Context->ObjectTypeIndex == ObjectTypeThread))
    {
        PropPages[nPages++] = propAddPage(
            TEXT("Token"),
            TokenPageDialogProc,
            MAKEINTRESOURCE(IDD_DIALOG_TOKEN),
            (LPARAM)Context);
    }

    //
    // Create additional page(s), depending on object type.
    //
    switch (Context->ObjectTypeIndex) {
    case ObjectTypeDirectory:
    case ObjectTypePort:
    case ObjectTypeFltComnPort:
    case ObjectTypeFltConnPort:
    case ObjectTypeEvent:
    case ObjectTypeMutant:
    case ObjectTypeSemaphore:
    case ObjectTypeSection:
    case ObjectTypeSymbolicLink:
    case ObjectTypeTimer:
    case ObjectTypeJob:
    case ObjectTypeSession:
    case ObjectTypeIoCompletion:
    case ObjectTypeMemoryPartition:
    case ObjectTypeRegistryTransaction:
    case ObjectTypeProcess:
    case ObjectTypeThread:
    case ObjectTypeWinstation:
    case ObjectTypeToken:

        PropPages[nPages++] = propAddPage(
            TEXT("Process"),
            ProcessListDialogProc,
            MAKEINTRESOURCE(IDD_PROP_PROCESSLIST),
            (LPARAM)Context);

        //
        // Add desktop list for selected desktop, located here because of sheets order.
        //
        //  WinStation->Basic->Process->[Desktops]->Security
        //
        if (Context->ObjectTypeIndex == ObjectTypeWinstation) {

            PropPages[nPages++] = propAddPage(
                TEXT("Desktops"),
                DesktopListDialogProc,
                MAKEINTRESOURCE(IDD_PROP_DESKTOPS),
                (LPARAM)Context);
        }

        break;
    case ObjectTypeDriver:
        //
        // Add registry page.
        //
        PropPages[nPages++] = propAddPage(
            TEXT("Registry"),
            DriverRegistryDialogProc,
            MAKEINTRESOURCE(IDD_PROP_SERVICE),
            (LPARAM)Context);

        break;
    }

    //
    // Add Section object specific page, driver assistance required.
    //
    // This feature implemented only for Windows 10 as structures are too variable.
    //

    if (g_NtBuildNumber >= NT_WIN10_THRESHOLD1 &&
        Context->ObjectTypeIndex == ObjectTypeSection
        && IsDriverAssisted)
    {
        PropPages[nPages++] = propAddPage(
            TEXT("Object"),
            SectionPropertiesDialogProc,
            MAKEINTRESOURCE(IDD_PROP_OBJECTDUMP),
            (LPARAM)Context);
    }

    //
    // Add ALPC port specific page, driver assistance required.
    //
    if (Context->ObjectTypeIndex == ObjectTypePort && IsDriverAssisted) {

        PropPages[nPages++] = propAddPage(
            TEXT("Connections"),
            AlpcPortListDialogProc,
            MAKEINTRESOURCE(IDD_PROP_ALPCPORTLIST),
            (LPARAM)Context);
    }

    //
    // Type Info Page.
    //
    PropPages[nPages++] = propAddPage(
        TEXT("Type"),
        TypePropDialogProc,
        MAKEINTRESOURCE(IDD_PROP_TYPE),
        (LPARAM)Context);

    //
    // Create Security Dialog if available.
    //
    hSecurityPage = propSecurityCreatePage(
        Context,                                             //Context
        (POPENOBJECTMETHOD)&propOpenCurrentObject,           //OpenObjectMethod
        (PCLOSEOBJECTMETHOD)&propCloseCurrentObject,         //CloseObjectMethod
        SI_EDIT_OWNER | SI_EDIT_PERMS |                      //psiFlags
        SI_ADVANCED | SI_NO_ACL_PROTECT | SI_NO_TREE_APPLY |
        SI_PAGE_TITLE
    );
    if (hSecurityPage != NULL) {
        PropPages[nPages++] = hSecurityPage;
    }

    return nPages;
}

/*
* propCreateDialog
*
* Purpose:
*
* Initialize and create PropertySheet Window for selected object properties.
*
* Sets custom Window Procedure for PropertySheet.
*
*/
VOID propCreateDialog(
    _In_ PROP_CONFIG* Config
)
{
    INT nPages;
    HWND hwnd, topLevelOwner;
    PROP_OBJECT_INFO* propContext = NULL;
    PROPSHEETHEADER PropHeader;
    WOBJ_TYPE_DESC* typeEntry;
    WCHAR szCaption[MAX_PATH * 2];

    //
    // Allocate context variable, copy name, type, object path.
    //
    propContext = propContextCreate(Config);
    if (propContext == NULL)
        return;

    //
    // Remember previously focused window.
    // Except special types: Desktop.
    //
    if (propContext->ObjectTypeIndex != ObjectTypeDesktop) {
        PreviousFocus = GetFocus();
    }

    nPages = propCreatePages(propContext);

    //
    // Finally create property sheet.
    //
    if (propContext->ObjectTypeIndex == ObjectTypeType) {

       _strncpy(szCaption, 
           MAX_PATH, 
           propContext->NtObjectName.Buffer, 
           propContext->NtObjectName.Length / sizeof(WCHAR));

    }
    else {
        typeEntry = propContext->TypeDescription;
        if (typeEntry->Index != ObjectTypeUnknown) {
            _strncpy(szCaption, MAX_PATH, typeEntry->Name, _strlen(typeEntry->Name));
        }
        else {
            _strcpy(szCaption, TEXT("Unknown Type"));
        }
    }

    topLevelOwner = Config->hwndParent;

    _strcat(szCaption, TEXT(" Properties"));
    RtlSecureZeroMemory(&PropHeader, sizeof(PropHeader));
    PropHeader.dwSize = sizeof(PropHeader);
    PropHeader.phpage = PropPages;
    PropHeader.nPages = nPages;
    PropHeader.nStartPage = 0;
    PropHeader.dwFlags = PSH_NOCONTEXTHELP | PSH_MODELESS | PSH_USEPSTARTPAGE;
    PropHeader.hwndParent = topLevelOwner;
    PropHeader.hInstance = g_WinObj.hInstance;
    PropHeader.pszCaption = szCaption;

    hwnd = (HWND)PropertySheet(&PropHeader);

    if (!hwnd) {
        if (topLevelOwner)
            EnableWindow(topLevelOwner, TRUE);
        
        propContextDestroy(propContext);
        return;
    }

    if (propContext->ContextType == propPrivateNamespace) {
        NamespacePropWindow = hwnd;
    }
    else {

        switch (propContext->ObjectTypeIndex) {
        case ObjectTypeProcess:
            ProcessesPropWindow = hwnd;
            break;
        case ObjectTypeThread:
            ThreadsPropWindow = hwnd;
            break;
        case ObjectTypeToken:
            TokenPropWindow = hwnd;
            break;
        case ObjectTypeDesktop:
            DesktopPropWindow = hwnd;
            break;
        default:
            CommonPropWindow = hwnd;
            break;
        }

    }

    SetProp(hwnd, T_PROPCONTEXT, (HANDLE)propContext);

    PropSheetOriginalWndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    if (PropSheetOriginalWndProc) {
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)&PropSheetCustomWndProc);
    }

}

```

`Source/WinObjEx64/props/propDlg.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPDLG.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Common header file for properties dialog.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

HWND propGetCommonWindow();
HWND propGetProcessesWindow();
HWND propGetThreadsWindow();
HWND propGetTokenWindow();
HWND propGetDesktopWindow();
HWND propGetNamespaceWindow();

_Success_(return)
BOOL propOpenCurrentObject(
    _In_ PROP_OBJECT_INFO *Context,
    _Out_ PHANDLE phObject,
    _In_ ACCESS_MASK DesiredAccess);

BOOL propCloseCurrentObject(
    _In_ PROP_OBJECT_INFO *Context,
    _In_ HANDLE hObject);

VOID propCreateDialog(
    _In_ PROP_CONFIG *Config);

PPROP_OBJECT_INFO propContextCreate(
    _In_ PROP_CONFIG* Config);

VOID propContextDestroy(
    _In_ PROP_OBJECT_INFO *Context);

```

`Source/WinObjEx64/props/propDriver.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPDRIVER.C
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "props.h"

#define REGEDITWNDCLASS           L"RegEdit_RegEdit"
#define REGEDIT_EXE               L"regedit.exe"
#define SHELL_OPEN_VERB           L"open"

//
// Path to navigate in the regedit window treeview.
//
#define PROPDRVREGSERVICESKEY     L"\\HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\"
#define PROPDRVREGSERVICESKEYLEN  sizeof(PROPDRVREGSERVICESKEY) - sizeof(WCHAR)


/*
* DriverShowChildWindows
*
* Purpose:
*
* Makes window controls visible/invisible
*
*/
BOOL WINAPI DriverShowChildWindows(
    _In_ HWND hwnd,
    _In_ LPARAM lParam
)
{
    ShowWindow(hwnd, (INT)lParam);
    return TRUE;
}

/*
* DriverSetInfo
*
* Purpose:
*
* Sets registry info for selected driver object
*
*/
VOID DriverSetInfo(
    _In_ PROP_OBJECT_INFO *Context,
    _In_ HWND hwndDlg
)
{
    BOOL                    bResult = FALSE, fGroup, bRet;
    INT                     nEndOfList, nEnd, nStart;
    DWORD                   i, bytesNeeded, dwServices, dwGroups;
    LPWSTR                  lpType;
    SC_HANDLE               SchSCManager = NULL, schService = NULL;
    LPENUM_SERVICE_STATUS   lpDependencies = NULL;
    LPQUERY_SERVICE_CONFIG  psci = NULL;
    LPSERVICE_DESCRIPTION   psd;
    SERVICE_STATUS_PROCESS  ssp;
    ENUM_SERVICE_STATUS     ess;
    WCHAR                   szBuffer[MAX_PATH + 1];

    __try {

        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);

        do {
            SchSCManager = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

            if (SchSCManager == NULL)
                break;

            schService = OpenService(
                SchSCManager,
                Context->NtObjectName.Buffer,
                SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);

            if (schService == NULL)
                break;

            bytesNeeded = 0;
            bResult = QueryServiceConfig(
                schService,
                NULL,
                0,
                &bytesNeeded);

            if ((bResult == FALSE) && (bytesNeeded == 0))
                break;

            psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);
            if (psci == NULL)
                break;

            //disable comboboxes
            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);

            bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);
            if (bResult) {
                //set key name (identical to object name)
                SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->NtObjectName.Buffer);
                //set image path info
                SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);
                //set display name
                SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);
                //set load order group
                SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup);

                //Service Type
                lpType = T_UnknownType;
                switch (psci->dwServiceType) {
                case SERVICE_KERNEL_DRIVER:
                    lpType = TEXT("Kernel-Mode Driver");
                    break;
                case SERVICE_FILE_SYSTEM_DRIVER:
                    lpType = TEXT("File System Driver");
                    break;
                case SERVICE_ADAPTER:
                    lpType = TEXT("Adapter");
                    break;
                case SERVICE_RECOGNIZER_DRIVER:
                    lpType = TEXT("File System Recognizer");
                    break;
                case SERVICE_WIN32_OWN_PROCESS:
                    lpType = TEXT("Own Process");
                    break;
                case SERVICE_WIN32_SHARE_PROCESS:
                    lpType = TEXT("Share Process");
                    break;
                case (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS):
                    lpType = TEXT("Own Process (Interactive)");
                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);
                    break;
                case (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS):
                    lpType = TEXT("Share Process (Interactive)");
                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);
                    break;
                case SERVICE_PKG_SERVICE:
                    lpType = TEXT("Package");
                    break;
                }
                SetDlgItemText(hwndDlg, ID_SERVICE_TYPE, lpType);

                //Start Type
                lpType = T_UnknownType;
                switch (psci->dwStartType) {
                case SERVICE_BOOT_START:
                    lpType = TEXT("Boot");
                    break;
                case SERVICE_SYSTEM_START:
                    lpType = TEXT("System");
                    break;
                case SERVICE_AUTO_START:
                    lpType = TEXT("Auto");
                    break;
                case SERVICE_DEMAND_START:
                    lpType = TEXT("On Demand");
                    break;
                case SERVICE_DISABLED:
                    lpType = TEXT("Disabled");
                    break;
                }
                SetDlgItemText(hwndDlg, ID_SERVICE_START, lpType);

                //Error Control
                lpType = T_Unknown;
                switch (psci->dwErrorControl) {
                case SERVICE_ERROR_IGNORE:
                    lpType = TEXT("Ignore");
                    break;
                case SERVICE_ERROR_NORMAL:
                    lpType = TEXT("Normal");
                    break;
                case SERVICE_ERROR_SEVERE:
                    lpType = TEXT("Severe");
                    break;
                case SERVICE_ERROR_CRITICAL:
                    lpType = TEXT("Critical");
                    break;
                }
                SetDlgItemText(hwndDlg, ID_SERVICE_ERROR, lpType);

                //dwTagId
                if (psci->dwTagId) {
                    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
                    ultostr(psci->dwTagId, szBuffer);
                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, szBuffer);
                }
                else {
                    //not assigned tag
                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, T_NotAssigned);
                }

                //State
                RtlSecureZeroMemory(&ssp, sizeof(ssp));
                if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,
                    (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded))
                {
                    lpType = T_Unknown;
                    switch (ssp.dwCurrentState) {
                    case SERVICE_STOPPED:
                        lpType = TEXT("Stopped");
                        break;
                    case SERVICE_START_PENDING:
                        lpType = TEXT("Start Pending");
                        break;
                    case SERVICE_STOP_PENDING:
                        lpType = TEXT("Stop Pending");
                        break;
                    case SERVICE_RUNNING:
                        lpType = TEXT("Running");
                        break;
                    case SERVICE_CONTINUE_PENDING:
                        lpType = TEXT("Continue Pending");
                        break;
                    case SERVICE_PAUSE_PENDING:
                        lpType = TEXT("Pause Pending");
                        break;
                    case SERVICE_PAUSED:
                        lpType = TEXT("Paused");
                        break;
                    }
                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, lpType);
                }
                else {
                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, T_CannotQuery);
                }

                //Service Description
                bRet = FALSE;
                SetDlgItemText(hwndDlg, ID_SERVICE_DESCRIPTION, T_EmptyString);
                bytesNeeded = 0x1000;
                psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);
                if (psd) {

                    bRet = QueryServiceConfig2(
                        schService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (LPBYTE)psd,
                        bytesNeeded,
                        &bytesNeeded);

                    if ((bRet == FALSE) && (bytesNeeded != 0)) {
                        supHeapFree(psd);
                        psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);
                    }
                    if (psd) {
                        //set description or hide window
                        bRet = QueryServiceConfig2(
                            schService,
                            SERVICE_CONFIG_DESCRIPTION,
                            (LPBYTE)psd,
                            bytesNeeded,
                            &bytesNeeded);

                        if (bRet) {
                            SetDlgItemText(hwndDlg, IDC_SERVICE_DESCRIPTION, psd->lpDescription);
                        }
                        supHeapFree(psd);
                    }
                }
                if (bRet == FALSE) {
                    //not enough memory, hide description window
                    ShowWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DESCRIPTION), SW_HIDE);
                }


                //Service Dependencies
                if (psci->lpDependencies) {

                    //first list DependsOnService, DependsOnGroup

                    nEndOfList = 0;
                    nEnd = 0;
                    nStart = 0;
                    dwGroups = 0;
                    dwServices = 0;

                    //calc total number of symbols
                    while ((psci->lpDependencies[nEndOfList] != L'\0') || (psci->lpDependencies[nEndOfList + 1] != L'\0'))
                        nEndOfList++;

                    if (nEndOfList > 0) {

                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

                        //iterate through MULTI_SZ string
                        do {
                            while (psci->lpDependencies[nEnd] != TEXT('\0')) {
                                nEnd++;
                            }

                            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
                            //maximum bytes that can be copied is sizeof(szBuffer)
                            _strncpy(szBuffer, sizeof(szBuffer), &psci->lpDependencies[nStart], nEnd);

                            //check if dependency is a group (has "+" before name)
                            fGroup = (szBuffer[0] == SC_GROUP_IDENTIFIER);
                            if (fGroup) {
                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_ADDSTRING,
                                    (WPARAM)0, (LPARAM)&szBuffer[1]);
                                dwGroups++;
                            }
                            else {
                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_ADDSTRING,
                                    (WPARAM)0, (LPARAM)&szBuffer);
                                dwServices++;
                            }
                            nEnd++;
                            nStart = nEnd;
                        } while (nEnd < nEndOfList);

                        //group present, enable combobox
                        if (dwGroups > 0) {
                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), TRUE);
                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_SETCURSEL,
                                (WPARAM)0, (LPARAM)0);
                        }
                        //service present, enable combobox
                        if (dwServices > 0) {
                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), TRUE);
                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_SETCURSEL,
                                (WPARAM)0, (LPARAM)0);
                        }
                    } //if (nEndOfList > 0)

                    //second list services that depends on this service
                    SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES, CB_RESETCONTENT,
                        (WPARAM)0, (LPARAM)0);

                    dwServices = 0;
                    bytesNeeded = 1024;
                    bRet = FALSE;

                    //avoid SCM unexpected behaviour by using preallocated buffer
                    lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc(bytesNeeded);
                    if (lpDependencies) {

                        bRet = EnumDependentServices(
                            schService,
                            SERVICE_STATE_ALL,
                            lpDependencies,
                            bytesNeeded,
                            &bytesNeeded,
                            &dwServices);

                        if (bRet && (GetLastError() == ERROR_MORE_DATA)) {
                            //more memory needed for enum
                            supHeapFree(lpDependencies);
                            dwServices = 0;
                            lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc((SIZE_T)bytesNeeded);
                            if (lpDependencies) {

                                bRet = EnumDependentServices(
                                    schService,
                                    SERVICE_STATE_ALL,
                                    lpDependencies,
                                    bytesNeeded,
                                    &bytesNeeded,
                                    &dwServices);

                            }
                        }

                        if (lpDependencies) {
                            //list dependents
                            if (bRet && dwServices) {
                                for (i = 0; i < dwServices; i++) {
                                    ess = *(lpDependencies + i);

                                    SendDlgItemMessage(
                                        hwndDlg,
                                        IDC_SERVICE_DEPENDENTSERVICES,
                                        CB_ADDSTRING,
                                        (WPARAM)0,
                                        (LPARAM)ess.lpServiceName);
                                }
                                //enable combobox and set current selection to the first item
                                EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), TRUE);

                                SendDlgItemMessage(
                                    hwndDlg,
                                    IDC_SERVICE_DEPENDENTSERVICES,
                                    CB_SETCURSEL,
                                    (WPARAM)0,
                                    (LPARAM)0);
                            }
                            supHeapFree(lpDependencies);
                        }
                    }
                } //if (psi->lpDependencies)
            } //bResult != FALSE

            CloseServiceHandle(schService);
            schService = NULL;
        } while (FALSE);

        if (psci != NULL)
            supHeapFree(psci);

        if (schService)
            CloseServiceHandle(schService);

        if (SchSCManager)
            CloseServiceHandle(SchSCManager);

        if (bResult == FALSE) {
            EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);
        }
        else {
            SetFocus(GetDlgItem(hwndDlg, ID_SERVICE_JUMPTOKEY));
        }

    }
    __except (WOBJ_EXCEPTION_FILTER) {
        EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);
        return;
    }
}

/*
* DriverJumpToKey
*
* Purpose:
*
* JumpToKey button handler.
*
*/
VOID DriverJumpToKey(
    _In_ PROP_OBJECT_INFO *Context
)
{
    DWORD             dwProcessId;
    WCHAR            *ch;
    HWND              regeditHwnd, regeditMainHwnd;
    SIZE_T            sz;
    LPWSTR            lpRegPath = NULL;
    HANDLE            hRegeditProcess = NULL;
    SHELLEXECUTEINFO  seinfo;

    WCHAR             szBuffer[MAX_PATH * 2];

    //
    // NtObjectName does not require normalization because regedit cannot handle bogus names anyway.
    //

    do {

        sz = _strlen(Context->NtObjectName.Buffer);
        if (sz == 0)
            break;

        //
        // Create regkeypath buffer to navigate for.
        //
        sz += PROPDRVREGSERVICESKEYLEN;
        sz = (1 + sz) * sizeof(WCHAR);
        lpRegPath = (LPWSTR)supHeapAlloc(sz);
        if (lpRegPath == NULL)
            break;

        _strcpy(lpRegPath, PROPDRVREGSERVICESKEY);
        _strcat(lpRegPath, Context->NtObjectName.Buffer);

        //
        // Start RegEdit.
        //
        // If it already started then open process for sync.
        //
        regeditHwnd = NULL;
        regeditMainHwnd = FindWindow(REGEDITWNDCLASS, NULL);
        if (regeditMainHwnd == NULL) {

            _strcpy(szBuffer, g_WinObj.szWindowsDirectory);
            _strcat(szBuffer, L"\\");
            _strcat(szBuffer, REGEDIT_EXE);

            RtlSecureZeroMemory(&seinfo, sizeof(seinfo));
            seinfo.cbSize = sizeof(seinfo);
            seinfo.fMask = SEE_MASK_NOCLOSEPROCESS;
            seinfo.lpVerb = SHELL_OPEN_VERB;
            seinfo.lpFile = szBuffer;
            seinfo.nShow = SW_SHOWNORMAL;
            ShellExecuteEx(&seinfo);
            hRegeditProcess = seinfo.hProcess;
            if (hRegeditProcess == NULL) {
                break;
            }
            WaitForInputIdle(hRegeditProcess, 10000);
            regeditMainHwnd = FindWindow(REGEDITWNDCLASS, NULL);
        }
        else {
            //
            // Regedit already started, open process for sync.
            //
            dwProcessId = 0;
            GetWindowThreadProcessId(regeditMainHwnd, &dwProcessId);
            hRegeditProcess = OpenProcess(SYNCHRONIZE, FALSE, dwProcessId);
        }

        //
        // Check if we failed to launch regedit.
        //
        if ((hRegeditProcess == NULL) || (regeditMainHwnd == NULL))
            break;

        //
        // Restore regedit window.
        //
        if (IsIconic(regeditMainHwnd)) {
            ShowWindow(regeditMainHwnd, SW_RESTORE);
        }
        else {
            ShowWindow(regeditMainHwnd, SW_SHOW);
        }
        SetForegroundWindow(regeditMainHwnd);
        SetFocus(regeditMainHwnd);
        WaitForInputIdle(hRegeditProcess, 10000);

        //
        // Get treeview window.
        //
        regeditHwnd = FindWindowEx(regeditMainHwnd, NULL, WC_TREEVIEW, NULL);
        if (regeditHwnd == NULL)
            break;

        //
        // Set focus on treeview.
        //
        SetForegroundWindow(regeditHwnd);
        SetFocus(regeditHwnd);

        //
        // Go to the tree root.
        //
        SendMessage(regeditHwnd, WM_KEYDOWN, VK_HOME, 0);

        //
        // Open path, expand if needed, select item.
        //
        for (ch = lpRegPath; *ch; ++ch) {

            if (*ch == L'\\') {
                SendMessage(regeditHwnd, WM_KEYDOWN, VK_RIGHT, 0);
                WaitForInputIdle(hRegeditProcess, 1000);
            }
            else {
#pragma warning(push)
#pragma warning(disable: 4306)
                SendMessage(regeditHwnd,
                    WM_CHAR,
                    (WPARAM)CharUpper((LPWSTR)*ch),
                    (LPARAM)0);
#pragma warning(pop)
                WaitForInputIdle(hRegeditProcess, 1000);
            }
        }

        //
        // Update window focus.
        //
        SetForegroundWindow(regeditMainHwnd);
        SetFocus(regeditMainHwnd);

    } while (FALSE);

    if (lpRegPath) {
        supHeapFree(lpRegPath);
    }
    if (hRegeditProcess) {
        CloseHandle(hRegeditProcess);
    }
}

/*
* DriverRegistryDialogProc
*
* Purpose:
*
* Registry page for Driver object
*
*/
INT_PTR CALLBACK DriverRegistryDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    PROPSHEETPAGE    *pSheet = NULL;
    PROP_OBJECT_INFO *Context = NULL;

    switch (uMsg) {

    case WM_SHOWWINDOW:
        if (wParam) {
            Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
            DriverSetInfo(Context, hwndDlg);
        }
        return 1;
        break;

    case WM_INITDIALOG:
        pSheet = (PROPSHEETPAGE *)lParam;
        if (pSheet) {
            SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
        }
        return 1;
        break;

    case WM_COMMAND:
        if (LOWORD(wParam) == ID_SERVICE_JUMPTOKEY) {
            Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
            DriverJumpToKey(Context);
        }
        return 1;
        break;

    case WM_DESTROY:
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        break;
    }
    return 0;
}

```

`Source/WinObjEx64/props/propObjectDump.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       PROPOBJECTDUMP.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "treelist/treelist.h"
#include "propTypeConsts.h"
#include "propObjectDumpConsts.h"

typedef struct _OBJECT_DUMP_DLG_CONTEXT {
    HWND TreeList;
    INT tlSubItemHit;
} OBJECT_DUMP_DLG_CONTEXT, * POBJECT_DUMP_DLG_CONTEXT;

typedef VOID(NTAPI* pfnObDumpRoutine)(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg,
    _In_ HWND hwndTreeList);

#define PROP_OBJECT_DUMP_ROUTINE(n) VOID n(   \
    _In_ PROP_OBJECT_INFO* Context,           \
    _In_ HWND hwndDlg,                        \
    _In_ HWND hwndTreeList)

/*
* propDumpEnumWithNames
*
* Purpose:
*
* Dump given enumeration to the treelist (simple output).
*
*/
VOID propDumpEnumWithNames(
    _In_ HWND TreeList,
    _In_ HTREEITEM ParentItem,
    _In_ LPWSTR EnumName,
    _In_ ULONG EnumValue,
    _In_ PVALUE_DESC EnumNames,
    _In_ ULONG EnumNamesCount
)
{
    ULONG i, mask;
    HTREEITEM h_tviSubItem, h_tviLast = NULL;

    TVITEMEX itemex;

    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[MAX_PATH + 1];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    szValue[0] = TEXT('0');
    szValue[1] = TEXT('x');
    ultohex(EnumValue, &szValue[2]);
    subitems.Text[0] = szValue;
    subitems.Count = 1;

    h_tviSubItem = supTreeListAddItem(
        TreeList,
        ParentItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        (LPWSTR)EnumName,
        &subitems);

    if (h_tviSubItem) {
        h_tviLast = NULL;
        mask = EnumValue;
        for (i = 0; i < EnumNamesCount; i++) {
            if (mask & EnumNames->dwValue) {
                RtlSecureZeroMemory(&subitems, sizeof(subitems));
                RtlSecureZeroMemory(&szValue, sizeof(szValue));
                szValue[0] = TEXT('0');
                szValue[1] = TEXT('x');
                ultohex(EnumNames->dwValue, &szValue[2]);
                subitems.Text[0] = szValue;
                subitems.Text[1] = EnumNames->lpDescription;
                subitems.Count = 2;

                h_tviLast = supTreeListAddItem(
                    TreeList,
                    h_tviSubItem,
                    TVIF_TEXT | TVIF_STATE,
                    (UINT)0,
                    (UINT)0,
                    (LPWSTR)T_EmptyString,
                    &subitems);

                mask &= ~EnumNames->dwValue;
            }

            EnumNames++;
        }
    }


    //
    // Output dotted corner.
    //
    if (h_tviLast) {
        RtlSecureZeroMemory(&itemex, sizeof(itemex));

        itemex.hItem = h_tviLast;
        itemex.mask = TVIF_TEXT | TVIF_HANDLE;
        itemex.pszText = T_EMPTY;

        TreeList_SetTreeItem(TreeList, &itemex, NULL);
    }
}

/*
* propObDumpGUID
*
* Purpose:
*
* Dump given GUID to the treelist.
*
*/
VOID propObDumpGUID(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_ GUID* Guid
)
{
    TL_SUBITEMS_FIXED  subitems;
    WCHAR              szValue[100];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;

    RtlStringCchPrintfSecure(szValue,
        RTL_NUMBER_OF(szValue),
        TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
        Guid->Data1, Guid->Data2, Guid->Data3,
        Guid->Data4[0],
        Guid->Data4[1],
        Guid->Data4[2],
        Guid->Data4[3],
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]);

    subitems.Text[0] = szValue;
    subitems.Text[1] = T_GUID;

    supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpAddress
*
* Purpose:
*
* Dump given Address to the treelist.
*
*/
HTREEITEM propObDumpAddress(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc, //additional text to be displayed
    _In_opt_ PVOID Address,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;

    if (Address == NULL) {
        subitems.Text[0] = T_NULL;
    }
    else {
        RtlSecureZeroMemory(&szValue, sizeof(szValue));
        szValue[0] = L'0';
        szValue[1] = L'x';
        u64tohex((ULONG_PTR)Address, &szValue[2]);
        subitems.Text[0] = szValue;
    }
    if (lpszDesc) {
        if (BgColor != 0) {
            subitems.ColorFlags |= TLF_BGCOLOR_SET;
            subitems.BgColor = BgColor;
        }
        if (FontColor != 0) {
            subitems.ColorFlags |= TLF_FONTCOLOR_SET;
            subitems.FontColor = FontColor;
        }
        subitems.Text[1] = lpszDesc;
    }
    else {
        subitems.Text[1] = T_EmptyString;
    }

    return supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpAddressWithModuleEx
*
* Purpose:
*
* Dump given Address to the treelist with module check, add offset to output if required.
*
*/
VOID propObDumpAddressWithModuleEx(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR Name,
    _In_opt_ PVOID Address,
    _In_ PRTL_PROCESS_MODULES pModules,
    _In_opt_ PVOID SelfDriverBase,
    _In_ ULONG SelfDriverSize,
    _In_ BOOL AddOffset
)
{
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32], szOffset[64], szModuleName[MAX_PATH * 2];
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry;
    ULONG_PTR offset;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = T_NULL;
    subitems.Text[1] = T_EmptyString;

    if (Address != NULL) {

        RtlSecureZeroMemory(&szValue, sizeof(szValue));
        szValue[0] = L'0';
        szValue[1] = L'x';
        u64tohex((ULONG_PTR)Address, &szValue[2]);
        subitems.Text[0] = szValue;

        RtlSecureZeroMemory(&szModuleName, sizeof(szModuleName));

        //if SelfDriverBase & SelfDriverSize present, look if Address routine points to current driver
        if (SelfDriverBase != NULL && SelfDriverSize) {
            if (!IN_REGION(Address, SelfDriverBase, SelfDriverSize)) {
                _strcpy(szModuleName, L"Hooked by ");
                subitems.ColorFlags = TLF_BGCOLOR_SET;
                subitems.BgColor = CLR_HOOK;
            }
        }

        moduleEntry = (PRTL_PROCESS_MODULE_INFORMATION)ntsupFindModuleNameByAddress(pModules, 
            Address, 
            _strend(szModuleName), 
            MAX_PATH);

        if (NULL != moduleEntry) {
            if (AddOffset) {
                offset = (ULONG_PTR)Address - (ULONG_PTR)moduleEntry->ImageBase;
                RtlStringCchPrintfSecure(szOffset, RTL_NUMBER_OF(szOffset), L"+0x%lX", offset);
                _strcat(szModuleName, szOffset);
            }
            subitems.Text[1] = szModuleName;
        }
        else {
            //unknown address outside any visible modules, warn
            subitems.Text[1] = T_Unknown;
            subitems.ColorFlags = TLF_BGCOLOR_SET;
            subitems.BgColor = CLR_WARN;
        }
    }

    supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        Name,
        &subitems);
}

#define propObDumpAddressWithModule(TreeList, hParent, Name, Address, pModules, SelfDriverBase, SelfDriverSize) \
    propObDumpAddressWithModuleEx(TreeList, hParent, Name, Address, pModules, SelfDriverBase, SelfDriverSize, FALSE)

/*
* propObDumpPushLock
*
* Purpose:
*
* Dump EX_PUSH_LOCK to the treelist.
*
*/
VOID propObDumpPushLock(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ PVOID PushLockPtr,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED   subitems;
    HTREEITEM h_tviSubItem;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = T_EmptyString;
    subitems.Text[1] = T_EX_PUSH_LOCK;

    h_tviSubItem = supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        TEXT("Lock"),
        &subitems);

    propObDumpAddress(TreeList, h_tviSubItem, TEXT("Ptr"), NULL, PushLockPtr, BgColor, FontColor);
}

/*
* propObDumpByte
*
* Purpose:
*
* Dump BYTE to the treelist.
* Dump BOOL if IsBool set.
* You must handle BOOLEAN differently.
*
*/
VOID propObDumpByte(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_ BYTE Value,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor,
    _In_ BOOL IsBool
)
{
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    subitems.Count = 1;
    if (lpszDesc != NULL) {
        subitems.Count = 2;
        subitems.Text[1] = lpszDesc;
    }

    RtlSecureZeroMemory(szValue, sizeof(szValue));
    if (IsBool) {
        _strcpy(szValue, (BOOL)(Value) ? L"TRUE" : L"FALSE");
    }
    else {

        RtlStringCchPrintfSecure(szValue,
            RTL_NUMBER_OF(szValue),
            FORMAT_HEXBYTE,
            Value);

    }

    subitems.Text[0] = szValue;

    if (BgColor != 0) {
        subitems.ColorFlags |= TLF_BGCOLOR_SET;
        subitems.BgColor = BgColor;
    }
    if (FontColor != 0) {
        subitems.ColorFlags |= TLF_FONTCOLOR_SET;
        subitems.FontColor = FontColor;
    }

    supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpSetString
*
* Purpose:
*
* Put string to the treelist.
*
*/
HTREEITEM propObDumpSetString(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_opt_ LPWSTR lpszValue,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED   subitems;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    subitems.Count = 1;
    if (lpszValue) {
        subitems.Text[0] = lpszValue;
    }
    else {
        subitems.Text[0] = T_EmptyString;
    }

    if (lpszDesc != NULL) {
        subitems.Count = 2;
        subitems.Text[1] = lpszDesc;
    }

    if (BgColor != 0) {
        subitems.ColorFlags |= TLF_BGCOLOR_SET;
        subitems.BgColor = BgColor;
    }
    if (FontColor != 0) {
        subitems.ColorFlags |= TLF_FONTCOLOR_SET;
        subitems.FontColor = FontColor;
    }

    return supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpUlong
*
* Purpose:
*
* Dump ULONG 4 bytes / USHORT 2 bytes to the treelist.
*
*/
HTREEITEM propObDumpUlong(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc, //additional text to be displayed
    _In_ ULONG Value,
    _In_ BOOL HexDump,
    _In_ BOOL IsUShort,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED   subitems;
    WCHAR               szValue[32];

    RtlSecureZeroMemory(&szValue, sizeof(szValue));
    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    if (lpszDesc != NULL) {
        subitems.Count = 2;
        subitems.Text[1] = lpszDesc;
    }
    else {
        subitems.Count = 1;
    }

    if (HexDump) {
        if (IsUShort) {

            RtlStringCchPrintfSecure(szValue,
                RTL_NUMBER_OF(szValue),
                FORMAT_HEXUSHORT,
                Value);

        }
        else {
            szValue[0] = L'0';
            szValue[1] = L'x';
            ultohex(Value, &szValue[2]);
        }
    }
    else {
        if (IsUShort) {

            RtlStringCchPrintfSecure(szValue,
                RTL_NUMBER_OF(szValue),
                FORMAT_USHORT,
                Value);

        }
        else {
            ultostr(Value, szValue);
        }
    }
    subitems.Text[0] = szValue;

    if (BgColor != 0) {
        subitems.ColorFlags |= TLF_BGCOLOR_SET;
        subitems.BgColor = BgColor;
    }
    if (FontColor != 0) {
        subitems.ColorFlags |= TLF_FONTCOLOR_SET;
        subitems.FontColor = FontColor;
    }

    return supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpLong
*
* Purpose:
*
* Dump LONG 4 bytes to the treelist.
*
*/
HTREEITEM propObDumpLong(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc, //additional text to be displayed
    _In_ LONG Value,
    _In_ BOOL HexDump,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];

    RtlSecureZeroMemory(&szValue, sizeof(szValue));
    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    if (lpszDesc != NULL) {
        subitems.Count = 2;
        subitems.Text[1] = lpszDesc;
    }
    else {
        subitems.Count = 1;
    }

    if (HexDump) {
        RtlStringCchPrintfSecure(szValue,
            RTL_NUMBER_OF(szValue),
            FORMAT_HEXLONG, Value);
    }
    else {

        itostr(Value, szValue);

    }
    subitems.Text[0] = szValue;

    if (BgColor != 0) {
        subitems.ColorFlags |= TLF_BGCOLOR_SET;
        subitems.BgColor = BgColor;
    }
    if (FontColor != 0) {
        subitems.ColorFlags |= TLF_FONTCOLOR_SET;
        subitems.FontColor = FontColor;
    }

    return supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpUlong64
*
* Purpose:
*
* Dump ULONG 8 byte to the treelist.
*
*/
VOID propObDumpUlong64(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc, //additional text to be displayed
    _In_ ULONG64 Value,
    _In_ BOOL OutAsHex,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;

    RtlSecureZeroMemory(&szValue, sizeof(szValue));

    if (OutAsHex) {
        szValue[0] = TEXT('0');
        szValue[1] = TEXT('x');
        u64tohex(Value, &szValue[2]);
    }
    else {
        u64tostr(Value, szValue);
    }
    subitems.Text[0] = szValue;

    if (lpszDesc) {
        if (BgColor != 0) {
            subitems.ColorFlags |= TLF_BGCOLOR_SET;
            subitems.BgColor = BgColor;
        }
        if (FontColor != 0) {
            subitems.ColorFlags |= TLF_FONTCOLOR_SET;
            subitems.FontColor = FontColor;
        }
        subitems.Text[1] = lpszDesc;
    }
    else {
        subitems.Text[1] = T_EmptyString;
    }

    supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObDumpLong64
*
* Purpose:
*
* Dump LONG 8 byte to the treelist.
*
*/
VOID propObDumpLong64(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc, //additional text to be displayed
    _In_ LONG64 Value,
    _In_ BOOL OutAsHex,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor
)
{
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;

    RtlSecureZeroMemory(&szValue, sizeof(szValue));

    if (OutAsHex) {
        szValue[0] = TEXT('0');
        szValue[1] = TEXT('x');
        u64tohex((ULONG64)Value, &szValue[2]);
    }
    else {
        i64tostr(Value, szValue);
    }
    subitems.Text[0] = szValue;

    if (lpszDesc) {
        if (BgColor != 0) {
            subitems.ColorFlags |= TLF_BGCOLOR_SET;
            subitems.BgColor = BgColor;
        }
        if (FontColor != 0) {
            subitems.ColorFlags |= TLF_FONTCOLOR_SET;
            subitems.FontColor = FontColor;
        }
        subitems.Text[1] = lpszDesc;
    }
    else {
        subitems.Text[1] = T_EmptyString;
    }

    supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        lpszName,
        &subitems);
}

/*
* propObAddHexValue
*
* Purpose:
*
* Add ULONG/ULONG64 value as hex to the treelist.
*
*/
HTREEITEM propObAddHexValue(
    _In_ HWND TreeList,
    _In_ HTREEITEM ParentItem,
    _In_ LPWSTR EntryName,
    _In_ ULONG64 Value,
    _In_ BOOL AsPointer
)
{
    WCHAR szValue[32];
    TL_SUBITEMS_FIXED subitems;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 1;

    if (AsPointer && Value == 0) {
        subitems.Text[0] = T_NULL;
    }
    else {
        RtlSecureZeroMemory(&szValue, sizeof(szValue));
        szValue[0] = L'0';
        szValue[1] = L'x';

        if (Value > MAXULONG32) {
            u64tohex(Value, &szValue[2]);
        }
        else {
            if (AsPointer) {
                u64tohex(Value, &szValue[2]);
            }
            else {
                ultohex((ULONG)Value, &szValue[2]);
            }
        }
        subitems.Text[0] = szValue;
    }

    return supTreeListAddItem(
        TreeList,
        ParentItem,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        0,
        EntryName,
        &subitems);
}

/*
* propObDumpULargeInteger
*
* Purpose:
*
* Dump ULARGE_INTEGER members to the treelist.
*
*/
VOID propObDumpULargeInteger(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR ListEntryName,
    _In_opt_ PULARGE_INTEGER Value
)
{
    HTREEITEM h_tviSubItem;

    h_tviSubItem = supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        0,
        ListEntryName,
        NULL);

    if (h_tviSubItem == NULL) {
        return;
    }

    //add large integer entry item to treelist and exit if value is null
    if (Value) {
        propObAddHexValue(TreeList, h_tviSubItem, L"LowPart", Value->LowPart, FALSE);
        propObAddHexValue(TreeList, h_tviSubItem, L"HighPart", Value->HighPart, FALSE);
    }
}

/*
* propObDumpListEntry
*
* Purpose:
*
* Dump LIST_ENTRY members to the treelist.
*
*/
VOID propObDumpListEntry(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR ListEntryName,
    _In_opt_ PLIST_ENTRY ListEntry
)
{
    HTREEITEM         h_tviSubItem;
    TL_SUBITEMS_FIXED subitems;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = T_EmptyString;
    subitems.Text[1] = T_LIST_ENTRY;

    h_tviSubItem = supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        0,
        ListEntryName,
        &subitems);

    if (h_tviSubItem == NULL) {
        return;
    }

    //add list entry item to treelist and exit if listentry is null
    if (ListEntry) {
        propObAddHexValue(TreeList, h_tviSubItem, L"Flink", (ULONG64)ListEntry->Flink, TRUE);
        propObAddHexValue(TreeList, h_tviSubItem, L"Blink", (ULONG64)ListEntry->Blink, TRUE);
    }
}

/*
* propObDumpUSHORT
*
* Purpose:
*
* Dump USHORT value to the treelist.
*
*/
VOID propObDumpUSHORT(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR Name,
    _In_ USHORT Value,
    _In_ BOOLEAN HexOutput
)
{
    LPCWSTR lpFormat;
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    RtlSecureZeroMemory(szValue, sizeof(szValue));

    lpFormat = (HexOutput) ? FORMAT_HEXUSHORT : FORMAT_USHORT;

    RtlStringCchPrintfSecure(szValue,
        RTL_NUMBER_OF(szValue),
        lpFormat,
        Value);

    subitems.Count = 2;
    subitems.Text[0] = szValue;
    subitems.Text[1] = T_EmptyString;

    supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        Name,
        &subitems);
}

/*
* propObDumpUnicodeStringInternal
*
* Purpose:
*
* Dump UNICODE_STRING members to the treelist.
*
*/
VOID propObDumpUnicodeStringInternal(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR StringName,
    _In_opt_ PUNICODE_STRING String,
    _In_opt_ PVOID ReferenceBufferAddress,
    _In_ BOOLEAN IsKernelPointer
)
{
    BOOL bNormalized = FALSE;
    HTREEITEM h_tviSubItem;
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[32];
    UNICODE_STRING displayString;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;

    subitems.Text[0] = T_EmptyString;
    subitems.Text[1] = (IsKernelPointer) ? T_PUNICODE_STRING : T_UNICODE_STRING;

    //
    // Add root node.
    //
    h_tviSubItem = supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        0,
        StringName,
        &subitems);

    //
    // String points to nowhere, only root entry added.
    //
    if (String == NULL) {
        return;
    }

    if (h_tviSubItem) {

        //
        // UNICODE_STRING.Length
        //
        propObDumpUSHORT(TreeList,
            h_tviSubItem,
            T_LENGTH,
            String->Length,
            TRUE);

        //
        // UNICODE_STRING.MaximumLength
        //
        propObDumpUSHORT(TreeList,
            h_tviSubItem,
            T_MAXIMUMLENGTH,
            String->MaximumLength,
            TRUE);

        //
        // UNICODDE_STRING.Buffer
        //

        if (String->Buffer == NULL) {
            subitems.Text[0] = T_NULL;
            subitems.Text[1] = T_EmptyString;
        }
        else {

            RtlSecureZeroMemory(&szValue, sizeof(szValue));
            if (ReferenceBufferAddress == NULL) {
                subitems.Text[0] = T_NULL;
            }
            else {
                RtlSecureZeroMemory(&szValue, sizeof(szValue));
                szValue[0] = TEXT('0');
                szValue[1] = TEXT('x');
                u64tohex((ULONG_PTR)ReferenceBufferAddress, &szValue[2]);
                subitems.Text[0] = szValue;
            }

            bNormalized = supNormalizeUnicodeStringForDisplay(g_obexHeap,
                String,
                &displayString);
            if (bNormalized)
            {
                subitems.Text[1] = displayString.Buffer;
            }
            else {
                subitems.Text[1] = String->Buffer;
            }

        }

        supTreeListAddItem(
            TreeList,
            h_tviSubItem,
            TVIF_TEXT | TVIF_STATE,
            0,
            0,
            T_BUFFER,
            &subitems);

    }

    if (bNormalized)
        supFreeDuplicatedUnicodeString(g_obexHeap, &displayString, FALSE);
}

/*
* propObDumpUnicodeString
*
* Purpose:
*
* Dump UNICODE_STRING members to the treelist.
*
*/
VOID propObDumpUnicodeString(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR StringName,
    _In_ PUNICODE_STRING InputString,
    _In_ BOOLEAN IsKernelPointer
)
{
    UNICODE_STRING dumpedString;
    PVOID pvRefAddr;
    BOOL bDumpOk;

    RtlInitEmptyUnicodeString(&dumpedString, NULL, 0);

    bDumpOk = kdDumpUnicodeString(InputString,
        &dumpedString,
        &pvRefAddr,
        IsKernelPointer);

    propObDumpUnicodeStringInternal(TreeList,
        hParent,
        StringName,
        &dumpedString,
        pvRefAddr,
        IsKernelPointer);

    if (bDumpOk)
        supHeapFree(dumpedString.Buffer);
}

/*
* propDumpQueryFullNamespaceNormalizedPath
*
* Purpose:
*
* Query full namespace path for object with a normalization for output.
*
*/
_Success_(return)
BOOL propDumpQueryFullNamespaceNormalizedPath(
    _In_ ULONG_PTR ObjectAddress,
    _Out_ PUNICODE_STRING NormalizedPath
)
{
    BOOL bResult = FALSE;
    UNICODE_STRING objectName;

    if (ObQueryFullNamespacePath(ObjectAddress, &objectName)) {

        bResult = supNormalizeUnicodeStringForDisplay(g_obexHeap,
            &objectName, NormalizedPath);

        supFreeUnicodeString(g_obexHeap, &objectName);
    }

    return bResult;
}

/*
* propDumpObjectForAddress
*
* Purpose:
*
* Dump object name (if present) with full namespace path to the treelist.
*
*/
VOID propDumpObjectForAddress(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpObjectLiteral,
    _In_ PVOID pvObject,
    _In_ COLORREF crErrorBgColor,
    _In_ LPWSTR lpErrorLiteral
)
{
    BOOL bOkay = FALSE;
    COLORREF bgColor = 0;
    ULONG_PTR objectAddress = (ULONG_PTR)pvObject;
    LPWSTR lpName = NULL;

    UNICODE_STRING normalizedName;

    if (objectAddress) {

        bOkay = propDumpQueryFullNamespaceNormalizedPath(objectAddress, &normalizedName);
        if (bOkay) {
            lpName = normalizedName.Buffer;
        }
        else {
            lpName = lpErrorLiteral;
            bgColor = crErrorBgColor;
        }

    }

    propObDumpAddress(TreeList,
        hParent,
        lpObjectLiteral,
        lpName,
        pvObject,
        (COLORREF)bgColor,
        (COLORREF)0);

    if (bOkay)
        supFreeUnicodeString(g_obexHeap, &normalizedName);
}

/*
* propObDumpDispatcherHeader
*
* Purpose:
*
* Dump DISPATCHER_HEADER members to the treelist.
*
*/
VOID propObDumpDispatcherHeader(
    _In_ HWND TreeList,
    _In_ HTREEITEM ParentItem,
    _In_ DISPATCHER_HEADER* Header,
    _In_opt_ LPWSTR lpDescType,
    _In_opt_ LPWSTR lpDescSignalState,
    _In_opt_ LPWSTR lpDescSize
)
{
    HTREEITEM h_tviSubItem;

    h_tviSubItem = supTreeListAddItem(
        TreeList,
        ParentItem,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        TEXT("Header"),
        NULL);

    if (h_tviSubItem) {

        //Header->Type
        propObDumpUlong(TreeList, h_tviSubItem, L"Type", lpDescType, Header->Type, TRUE, TRUE, 0, 0);
        //Header->Absolute
        propObDumpUlong(TreeList, h_tviSubItem, L"Absolute", NULL, Header->Absolute, TRUE, TRUE, 0, 0);
        //Header->Size
        propObDumpUlong(TreeList, h_tviSubItem, L"Size", lpDescSize, Header->Size, TRUE, TRUE, 0, 0);
        //Header->Inserted
        propObDumpByte(TreeList, h_tviSubItem, L"Inserted", NULL, Header->Inserted, 0, 0, TRUE);
        //Header->SignalState
        propObDumpUlong(TreeList, h_tviSubItem, L"SignalState", lpDescSignalState, Header->SignalState, TRUE, FALSE, 0, 0);
        //Header->WaitListHead
        propObDumpListEntry(TreeList, h_tviSubItem, L"WaitListHead", &Header->WaitListHead);
    }
}

/*
* propObDumpSqos
*
* Purpose:
*
* Dump SECURITY_QUALITY_OF_SERVICE to the treelist.
*
*/
VOID propObDumpSqos(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ SECURITY_QUALITY_OF_SERVICE* SecurityQos
)
{
    LPWSTR lpType;
    HTREEITEM h_tviSubItem;
    TL_SUBITEMS_FIXED subitems;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = T_EmptyString;
    subitems.Text[1] = TEXT("SECURITY_QUALITY_OF_SERVICE");

    h_tviSubItem = supTreeListAddItem(
        TreeList,
        hParent,
        TVIF_TEXT,
        0,
        0,
        TEXT("SecurityQos"),
        &subitems);

    propObDumpUlong(
        TreeList,
        h_tviSubItem,
        TEXT("Length"),
        NULL,
        SecurityQos->Length,
        TRUE,
        FALSE,
        0,
        0);

    switch (SecurityQos->ImpersonationLevel) {
    case SecurityIdentification:
        lpType = TEXT("SecurityIdentification");
        break;
    case SecurityImpersonation:
        lpType = TEXT("SecurityImpersonation");
        break;
    case SecurityDelegation:
        lpType = TEXT("SecurityDelegation");
        break;
    case SecurityAnonymous:
        lpType = TEXT("SecurityAnonymous");
        break;
    default:
        lpType = T_UnknownType;
        break;
    }

    propObDumpUlong(
        TreeList,
        h_tviSubItem,
        TEXT("ImpersonationLevel"),
        lpType,
        SecurityQos->ImpersonationLevel,
        FALSE,
        FALSE,
        0,
        0);

    if (SecurityQos->ContextTrackingMode)
        lpType = TEXT("SECURITY_DYNAMIC_TRACKING");
    else
        lpType = TEXT("SECURITY_STATIC_TRACKING");

    propObDumpByte(
        TreeList,
        h_tviSubItem,
        TEXT("ContextTrackingMode"),
        lpType,
        SecurityQos->ContextTrackingMode,
        0,
        0,
        TRUE);

    propObDumpByte(
        TreeList,
        h_tviSubItem,
        TEXT("EffectiveOnly"),
        NULL,
        SecurityQos->EffectiveOnly,
        0,
        0,
        TRUE);
}

/*
* propObDumpDriverExtension
*
* Purpose:
*
* Dump DRIVER_EXTENSION members to the treelist.
*
*/
VOID propObDumpDriverExtension(
    _In_ HWND TreeList,
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDRIVER_EXTENSION DriverExtension,
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PLDR_DATA_TABLE_ENTRY LoaderEntry
)
{
    union {
        union {
            DRIVER_EXTENSION* DriverExtensionCompatible;
            DRIVER_EXTENSION_V2* DriverExtensionV2;
            DRIVER_EXTENSION_V3* DriverExtensionV3;
            DRIVER_EXTENSION_V4* DriverExtensionV4;
        } Versions;
        PVOID Ref;
    } DrvExt;

    BOOL bPathAllocated;

    HTREEITEM h_tviRootItem;

    COLORREF BgColor;
    PDRIVER_OBJECT SelfDriverObject;
    LPWSTR lpDesc;
    PVOID DriverExtensionPtr;
    ULONG ObjectSize = 0;
    ULONG ObjectVersion = 0;

    UNICODE_STRING normalizedPath;

    DriverExtensionPtr = ObDumpDriverExtensionVersionAware((ULONG_PTR)DriverExtension,
        &ObjectSize,
        &ObjectVersion);

    if (DriverExtensionPtr) {

        DrvExt.Ref = DriverExtensionPtr;

        h_tviRootItem = supTreeListAddItem(
            TreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            0,
            TEXT("DRIVER_EXTENSION"),
            NULL);

        if (h_tviRootItem) {

            //
            // DRIVER_EXTENSION.DriverObject
            //
            BgColor = 0;
            lpDesc = NULL;
            bPathAllocated = FALSE;

            //must be self-ref
            SelfDriverObject = DrvExt.Versions.DriverExtensionCompatible->DriverObject;

            if ((ULONG_PTR)SelfDriverObject != (ULONG_PTR)DriverObject) {
                lpDesc = T_BADDRIVEROBJECT;
                BgColor = CLR_WARN;
            }
            else {
                //find ref
                if (SelfDriverObject != NULL) {

                    bPathAllocated = propDumpQueryFullNamespaceNormalizedPath(
                        (ULONG_PTR)SelfDriverObject, &normalizedPath);
                    if (bPathAllocated) {
                        lpDesc = normalizedPath.Buffer;
                    }
                    else {
                        //sef-ref not found, notify, could be object outside directory so we don't know it name etc
                        lpDesc = T_REFNOTFOUND;
                        BgColor = CLR_INVL;
                    }

                }
            }

            propObDumpAddress(TreeList, h_tviRootItem, T_FIELD_DRIVER_OBJECT,
                lpDesc, SelfDriverObject, BgColor, 0);

            if (bPathAllocated)
                supFreeDuplicatedUnicodeString(g_obexHeap, &normalizedPath, FALSE);

            //AddDevice
            propObDumpAddressWithModule(TreeList, 
                h_tviRootItem, 
                TEXT("AddDevice"),
                DrvExt.Versions.DriverExtensionCompatible->AddDevice,
                ModulesList,
                LoaderEntry->DllBase,
                LoaderEntry->SizeOfImage);

            //Count
            propObDumpUlong(TreeList, h_tviRootItem, TEXT("Count"), NULL,
                DrvExt.Versions.DriverExtensionCompatible->Count, FALSE, FALSE, 0, 0);

            //ServiceKeyName
            propObDumpUnicodeString(TreeList, h_tviRootItem, T_FIELD_SERVICE_KEYNAME,
                &DrvExt.Versions.DriverExtensionCompatible->ServiceKeyName,
                FALSE);

            // All brand new private fields
            if (ObjectVersion > OBVERSION_DRIVER_EXTENSION_V1) {

                propObDumpAddress(TreeList, h_tviRootItem, TEXT("ClientDriverExtension"),
                    TEXT("PIO_CLIENT_EXTENSION"), DrvExt.Versions.DriverExtensionV2->ClientDriverExtension, 0, 0);

                propObDumpAddress(TreeList, h_tviRootItem, TEXT("FsFilterCallbacks"),
                    TEXT("PFS_FILTER_CALLBACKS"), DrvExt.Versions.DriverExtensionV2->FsFilterCallbacks, 0, 0);
            }

            if (ObjectVersion > OBVERSION_DRIVER_EXTENSION_V2) {
                propObDumpAddress(TreeList, h_tviRootItem, TEXT("KseCallbacks"),
                    NULL, DrvExt.Versions.DriverExtensionV3->KseCallbacks, 0, 0);
                propObDumpAddress(TreeList, h_tviRootItem, TEXT("DvCallbacks"),
                    NULL, DrvExt.Versions.DriverExtensionV3->DvCallbacks, 0, 0);
            }

            if (ObjectVersion > OBVERSION_DRIVER_EXTENSION_V3) {
                propObDumpAddress(TreeList, h_tviRootItem, TEXT("VerifierContext"),
                    NULL, DrvExt.Versions.DriverExtensionV4->VerifierContext, 0, 0);
            }
        }

        supVirtualFree(DriverExtensionPtr);
    }
}

/*
* propObDumpDriverObject
*
* Purpose:
*
* Dump DRIVER_OBJECT members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpDriverObject)
{
    BOOL                    bOkay;
    INT                     i, j;
    HTREEITEM               h_tviRootItem, h_tviSubItem;
    PRTL_PROCESS_MODULES    pModules;
    PVOID                   pObj, IopInvalidDeviceRequest;
    LPWSTR                  lpType;
    DRIVER_OBJECT           drvObject;
    FAST_IO_DISPATCH        fastIoDispatch;
    LDR_DATA_TABLE_ENTRY    ldrEntry, ntosEntry;
    TL_SUBITEMS_FIXED       subitems;
    COLORREF                BgColor;
    WCHAR                   szValue1[MAX_PATH + 1];

    bOkay = FALSE;

    RtlSecureZeroMemory(&drvObject, sizeof(drvObject));
    RtlSecureZeroMemory(&ldrEntry, sizeof(ldrEntry));

    do {

        //dump drvObject
        if (!kdReadSystemMemory(
            Context->ObjectInfo.ObjectAddress,
            &drvObject,
            sizeof(drvObject)))
        {
            break;
        }

        //we need to dump drvObject
        //consider dump failures for anything else as not critical
        bOkay = TRUE;

        //dump drvObject->DriverSection
        if (!kdReadSystemMemory(
            (ULONG_PTR)drvObject.DriverSection,
            &ldrEntry,
            sizeof(ldrEntry)))
        {
            break;
        }

    } while (FALSE);

    //any errors - abort
    if (!bOkay) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //
    //DRIVER_OBJECT
    //

    h_tviRootItem = supTreeListAddItem(
        hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        TEXT("DRIVER_OBJECT"),
        NULL);

    //Type
    BgColor = 0;
    lpType = TEXT("IO_TYPE_DRIVER");
    if (drvObject.Type != IO_TYPE_DRIVER) {
        lpType = TEXT("! Must be IO_TYPE_DRIVER");
        BgColor = CLR_WARN;
    }
    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("Type"), lpType, drvObject.Type, TRUE, TRUE, BgColor, 0);

    //Size
    BgColor = 0;
    lpType = NULL;
    if (drvObject.Size != sizeof(DRIVER_OBJECT)) {
        lpType = TEXT("! Must be sizeof(DRIVER_OBJECT)");
        BgColor = CLR_WARN;
    }
    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("Size"), lpType, drvObject.Size, TRUE, TRUE, BgColor, 0);

    //DeviceObject
    propDumpObjectForAddress(hwndTreeList, h_tviRootItem,
        TEXT("DeviceObject"), drvObject.DeviceObject, CLR_LGRY, T_UNNAMED);

    //Flags
    RtlSecureZeroMemory(&szValue1, sizeof(szValue1));
    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    j = 0;
    lpType = NULL;
    if (drvObject.Flags) {
        for (i = 0; i < MAX_KNOWN_DRV_FLAGS; i++) {
            if (drvObject.Flags & drvFlags[i].dwValue) {
                lpType = drvFlags[i].lpDescription;
                subitems.Count = 2;

                //add first entry with name
                if (j == 0) {
                    szValue1[0] = L'0';
                    szValue1[1] = L'x';
                    ultohex(drvObject.Flags, &szValue1[2]);

                    subitems.Text[0] = szValue1;
                    subitems.Text[1] = lpType;
                }
                else {
                    //add subentry
                    subitems.Text[0] = T_EmptyString;
                    subitems.Text[1] = lpType;
                }

                supTreeListAddItem(
                    hwndTreeList,
                    h_tviRootItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    0,
                    (j == 0) ? T_FLAGS : T_EmptyString,
                    &subitems);

                drvObject.Flags &= ~drvFlags[i].dwValue;
                j++;
            }
            if (drvObject.Flags == 0) {
                break;
            }
        }
    }
    else {
        //add named entry with zero data
        propObDumpUlong(hwndTreeList, h_tviRootItem, T_FLAGS, NULL, 0, TRUE, FALSE, 0, 0);
    }

    //DriverStart
    propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DriverStart"), NULL, drvObject.DriverStart, 0, 0);

    //DriverSize
    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("DriverSize"), NULL, drvObject.DriverSize, TRUE, FALSE, 0, 0);

    //DriverSection
    propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DriverSection"), T_PLDR_DATA_TABLE_ENTRY, drvObject.DriverSection, 0, 0);

    //DriverExtension
    propObDumpAddress(hwndTreeList, h_tviRootItem, T_FIELD_DRIVER_EXTENSION, T_PDRIVER_EXTENSION, drvObject.DriverExtension, 0, 0);

    //DriverName
    propObDumpUnicodeString(hwndTreeList, h_tviRootItem, TEXT("DriverName"), &drvObject.DriverName, FALSE);

    //HardwareDatabase
    propObDumpUnicodeString(hwndTreeList, h_tviRootItem, TEXT("HardwareDatabase"), drvObject.HardwareDatabase, TRUE);

    //FastIoDispatch
    propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("FastIoDispatch"), T_PFAST_IO_DISPATCH, drvObject.FastIoDispatch, 0, 0);

    //DriverInit
    propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DriverInit"), NULL, drvObject.DriverInit, 0, 0);

    //DriverStartIo
    propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DriverStartIo"), NULL, drvObject.DriverStartIo, 0, 0);

    //DriverUnload
    propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DriverUnload"), NULL, drvObject.DriverUnload, 0, 0);

    //MajorFunction
    RtlSecureZeroMemory(&szValue1, sizeof(szValue1));
    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = TEXT("{...}");
    subitems.Text[1] = T_EmptyString;

    h_tviSubItem = supTreeListAddItem(
        hwndTreeList,
        h_tviRootItem,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        TEXT("MajorFunction"),
        &subitems);

    RtlSecureZeroMemory(&ntosEntry, sizeof(ntosEntry));
    pModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);

    if (g_kdctx.Data->IopInvalidDeviceRequest == NULL) {
        g_kdctx.Data->IopInvalidDeviceRequest = kdQueryIopInvalidDeviceRequest();
    }

    IopInvalidDeviceRequest = g_kdctx.Data->IopInvalidDeviceRequest;

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {

        if (drvObject.MajorFunction[i] == NULL) {
            continue;
        }

        //
        // Skip ntoskrnl default IRP handler.
        // 
        // WARNING: This may skip actual trampoline hook.
        //
        if (IopInvalidDeviceRequest) {
            if ((ULONG_PTR)drvObject.MajorFunction[i] == (ULONG_PTR)IopInvalidDeviceRequest) {

                propObDumpAddress(
                    hwndTreeList,
                    h_tviSubItem,
                    T_IRP_MJ_FUNCTION[i],
                    T_INVALID_REQUEST,
                    drvObject.MajorFunction[i],
                    CLR_INVL,
                    0);

                continue;
            }
        }

        //DRIVER_OBJECT->MajorFunction[i]
        propObDumpAddressWithModuleEx(hwndTreeList,
            h_tviSubItem,
            T_IRP_MJ_FUNCTION[i],
            drvObject.MajorFunction[i],
            pModules,
            ldrEntry.DllBase,
            ldrEntry.SizeOfImage,
            TRUE);
    }

    //
    //LDR_DATA_TABLE_ENTRY
    //

    if (drvObject.DriverSection != NULL) {

        //root itself
        h_tviRootItem = supTreeListAddItem(
            hwndTreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            0,
            T_LDR_DATA_TABLE_ENTRY,
            NULL);

        //InLoadOrderLinks
        propObDumpListEntry(hwndTreeList, h_tviRootItem, TEXT("InLoadOrderLinks"), &ldrEntry.InLoadOrderLinks);

        //InMemoryOrderLinks
        propObDumpListEntry(hwndTreeList, h_tviRootItem, TEXT("InMemoryOrderLinks"), &ldrEntry.InMemoryOrderLinks);

        //InInitializationOrderLinks/InProgressLinks
        lpType = TEXT("InInitializationOrderLinks");
        if (g_NtBuildNumber >= NT_WIN8_BLUE) {
            lpType = TEXT("InProgressLinks");
        }
        propObDumpListEntry(hwndTreeList, h_tviRootItem, lpType, &ldrEntry.DUMMYUNION0.InInitializationOrderLinks);

        //DllBase
        propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DllBase"), NULL, ldrEntry.DllBase, 0, 0);

        //EntryPoint
        propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("EntryPoint"), NULL, ldrEntry.EntryPoint, 0, 0);

        //SizeOfImage
        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("SizeOfImage"), NULL, ldrEntry.SizeOfImage, TRUE, FALSE, 0, 0);

        //FullDllName
        propObDumpUnicodeString(hwndTreeList, h_tviRootItem, TEXT("FullDllName"), &ldrEntry.FullDllName, FALSE);

        //BaseDllName
        propObDumpUnicodeString(hwndTreeList, h_tviRootItem, TEXT("BaseDllName"), &ldrEntry.BaseDllName, FALSE);

        //Flags
        propObDumpUlong(hwndTreeList, h_tviRootItem, T_FLAGS, NULL, ldrEntry.ENTRYFLAGSUNION.Flags, TRUE, FALSE, 0, 0);

        //LoadCount
        lpType = TEXT("ObsoleteLoadCount");
        if (g_NtBuildNumber < NT_WIN8_RTM) {
            lpType = TEXT("LoadCount");
        }
        propObDumpUlong(hwndTreeList, h_tviRootItem, lpType, NULL, ldrEntry.ObsoleteLoadCount, TRUE, TRUE, 0, 0);

        //TlsIndex
        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("TlsIndex"), NULL, ldrEntry.TlsIndex, TRUE, TRUE, 0, 0);

        //SectionPointer
        propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("SectionPointer"), NULL, ldrEntry.DUMMYUNION1.SectionPointer, 0, 0);

        //CheckSum
        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("CheckSum"), NULL, ldrEntry.DUMMYUNION1.CheckSum, TRUE, FALSE, 0, 0);

        //LoadedImports
        if (g_NtBuildNumber < NT_WIN8_RTM) {
            propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("LoadedImports"), NULL, ldrEntry.DUMMYUNION2.LoadedImports, 0, 0);
        }

    } //LDR_DATA_TABLE_ENTRY


    //
    //FAST_IO_DISPATCH
    //

    if (drvObject.FastIoDispatch != NULL) {

        RtlSecureZeroMemory(&fastIoDispatch, sizeof(fastIoDispatch));

        if (kdReadSystemMemory(
            (ULONG_PTR)drvObject.FastIoDispatch,
            &fastIoDispatch,
            sizeof(fastIoDispatch)))
        {

            h_tviRootItem = supTreeListAddItem(
                hwndTreeList,
                NULL,
                TVIF_TEXT | TVIF_STATE,
                0,
                0,
                TEXT("FAST_IO_DISPATCH"),
                NULL);

            //SizeOfFastIoDispatch
            BgColor = 0;
            lpType = NULL;

            if (fastIoDispatch.SizeOfFastIoDispatch != sizeof(FAST_IO_DISPATCH)) {
                lpType = TEXT("! Must be sizeof(FAST_IO_DISPATCH)");
                BgColor = CLR_WARN;
                bOkay = FALSE;//<-set flag invalid structure
            }

            propObDumpUlong(hwndTreeList,
                h_tviRootItem,
                TEXT("SizeOfFastIoDispatch"),
                lpType,
                fastIoDispatch.SizeOfFastIoDispatch,
                TRUE,
                FALSE,
                BgColor,
                0);

            //valid structure
            if (bOkay) {
                for (i = 0; i < RTL_NUMBER_OF(T_FAST_IO_DISPATCH); i++) {
                    pObj = ((PVOID*)(&fastIoDispatch.FastIoCheckIfPossible))[i];
                    if (pObj == NULL) {
                        continue;
                    }

                    propObDumpAddressWithModule(hwndTreeList,
                        h_tviRootItem,
                        T_FAST_IO_DISPATCH[i],
                        pObj,
                        pModules,
                        ldrEntry.DllBase,
                        ldrEntry.SizeOfImage);

                }
            }

        } //kdReadSystemMemory
    } //if

    //
    //PDRIVER_EXTENSION
    //
    if (drvObject.DriverExtension != NULL) {

        propObDumpDriverExtension(hwndTreeList,
            (PDRIVER_OBJECT)Context->ObjectInfo.ObjectAddress,
            drvObject.DriverExtension,
            pModules,
            &ldrEntry);

    }


    //
    //Cleanup
    //
    if (pModules) {
        supHeapFree(pModules);
    }

}

/*
* propObDumpDeviceObject
*
* Purpose:
*
* Dump DEVICE_OBJECT members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpDeviceObject)
{
    BOOL                bOkay;
    INT                 i, j;
    HTREEITEM           h_tviRootItem, h_tviWcb, h_tviSubItem, h_tviWaitEntry;
    LPWSTR              lpType;
    TL_SUBITEMS_FIXED   subitems;
    DEVICE_OBJECT       devObject;
    DEVOBJ_EXTENSION    devObjExt;
    COLORREF            BgColor;
    WCHAR               szValue1[MAX_PATH + 1];

    bOkay = FALSE;

    //dump devObject
    RtlSecureZeroMemory(&devObject, sizeof(devObject));

    if (!kdReadSystemMemory(
        Context->ObjectInfo.ObjectAddress,
        &devObject,
        sizeof(devObject)))
    {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //
    //DEVICE_OBJECT
    //

    h_tviRootItem = supTreeListAddItem(hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        L"DEVICE_OBJECT",
        NULL);

    //Type
    BgColor = 0;
    lpType = L"IO_TYPE_DEVICE";
    if (devObject.Type != IO_TYPE_DEVICE) {
        lpType = L"! Must be IO_TYPE_DEVICE";
        BgColor = CLR_WARN;
    }
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"Type", lpType, devObject.Type, TRUE, TRUE, BgColor, 0);

    //Size
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"Size", NULL, devObject.Size, TRUE, TRUE, 0, 0);

    //ReferenceCount
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"ReferenceCount", NULL, devObject.ReferenceCount, FALSE, FALSE, 0, 0);

    //
    // DriverObject
    //
    propDumpObjectForAddress(hwndTreeList, h_tviRootItem, T_FIELD_DRIVER_OBJECT,
        devObject.DriverObject, CLR_INVL, T_REFNOTFOUND);

    //
    // NextDevice
    //
    propDumpObjectForAddress(hwndTreeList, h_tviRootItem, L"NextDevice",
        devObject.NextDevice, CLR_LGRY, T_UNNAMED);

    //
    // AttachedDevice
    //
    propDumpObjectForAddress(hwndTreeList, h_tviRootItem, L"AttachedDevice",
        devObject.AttachedDevice, CLR_LGRY, T_UNNAMED);

    //CurrentIrp
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"CurrentIrp", NULL, devObject.CurrentIrp, 0, 0);

    //Timer
    lpType = L"PIO_TIMER";
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"Timer", lpType, devObject.Timer, 0, 0);

    //Flags
    RtlSecureZeroMemory(&szValue1, sizeof(szValue1));
    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    lpType = NULL;
    j = 0;
    if (devObject.Flags) {
        for (i = 0; i < MAX_KNOWN_DEV_FLAGS; i++) {
            if (devObject.Flags & devFlags[i].dwValue) {
                lpType = devFlags[i].lpDescription;
                subitems.Count = 2;

                if (j == 0) {
                    //add first entry with flag description
                    szValue1[0] = L'0';
                    szValue1[1] = L'x';
                    ultohex(devObject.Flags, &szValue1[2]);

                    subitems.Text[0] = szValue1;
                    subitems.Text[1] = lpType;
                }
                else {
                    //add subentry
                    subitems.Text[0] = T_EmptyString;
                    subitems.Text[1] = lpType;
                }

                supTreeListAddItem(hwndTreeList,
                    h_tviRootItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    TVIS_EXPANDED,
                    (j == 0) ? T_FLAGS : T_EmptyString,
                    &subitems);

                devObject.Flags &= ~devFlags[i].dwValue;
                j++;
            }
            if (devObject.Flags == 0) {
                break;
            }
        }
    }
    else {
        //add named entry with zero data
        propObDumpUlong(hwndTreeList, h_tviRootItem, T_FLAGS, NULL, 0, TRUE, FALSE, 0, 0);
    }

    //Characteristics
    RtlSecureZeroMemory(&szValue1, sizeof(szValue1));
    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    lpType = NULL;
    j = 0;
    if (devObject.Characteristics) {
        for (i = 0; i < MAX_KNOWN_CHR_FLAGS; i++) {

            if (devObject.Characteristics & devChars[i].dwValue) {
                lpType = devChars[i].lpDescription;
                subitems.Count = 2;

                if (j == 0) {
                    //add first entry with chr description
                    szValue1[0] = L'0';
                    szValue1[1] = L'x';
                    ultohex(devObject.Characteristics, &szValue1[2]);
                    subitems.Text[0] = szValue1;
                    subitems.Text[1] = lpType;
                }
                else {
                    //add subentry
                    subitems.Text[0] = T_EmptyString;
                    subitems.Text[1] = lpType;
                }

                supTreeListAddItem(hwndTreeList,
                    h_tviRootItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    0,
                    (j == 0) ? T_CHARACTERISTICS : T_EmptyString,
                    &subitems);

                devObject.Characteristics &= ~devChars[i].dwValue;
                j++;
            }

            if (devObject.Characteristics == 0) {
                break;
            }
        }
    }
    else {
        //add zero value
        propObDumpUlong(hwndTreeList, h_tviRootItem, T_CHARACTERISTICS, NULL, 0, TRUE, FALSE, 0, 0);
    }

    //Vpb
    lpType = L"PVPB";
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"Vpb", lpType, devObject.Vpb, 0, 0);

    //DeviceExtension
    BgColor = 0;
    lpType = NULL;

    //
    // Check DeviceExtension to be valid as it size is a part of total DEVICE_OBJECT allocation size.
    //
    if (devObject.DeviceExtension != NULL) {
        if (devObject.Size == sizeof(DEVICE_OBJECT)) {
            BgColor = CLR_WARN;
            lpType = L"! Must be NULL";
        }
    }
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"DeviceExtension", lpType, devObject.DeviceExtension, BgColor, 0);

    //DeviceType
    lpType = NULL;
    for (i = 0; i < MAX_DEVOBJ_CHARS; i++) {
        if (devObjChars[i].dwValue == devObject.DeviceType) {
            lpType = devObjChars[i].lpDescription;
            break;
        }
    }
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"DeviceType", lpType, devObject.DeviceType, TRUE, FALSE, 0, 0);

    //StackSize
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"StackSize", NULL, devObject.StackSize, FALSE, FALSE, 0, 0);

    //Queue
    h_tviSubItem = supTreeListAddItem(hwndTreeList, h_tviRootItem, TVIF_TEXT | TVIF_STATE, 0,
        TVIS_EXPANDED, L"Queue", NULL);

    //Queue->Wcb
    h_tviWcb = supTreeListAddItem(hwndTreeList, h_tviSubItem, TVIF_TEXT | TVIF_STATE, 0,
        TVIS_EXPANDED, L"Wcb", NULL);

    //Queue->Wcb->WaitQueueEntry
    h_tviWaitEntry = supTreeListAddItem(hwndTreeList, h_tviWcb, TVIF_TEXT | TVIF_STATE, 0,
        TVIS_EXPANDED, L"WaitQueueEntry", NULL);

    //Queue->Wcb->WaitQueueEntry->DeviceListEntry
    propObDumpListEntry(hwndTreeList, h_tviWaitEntry, L"DeviceListEntry", &devObject.Queue.Wcb.WaitQueueEntry.DeviceListEntry);

    //Queue->Wcb->WaitQueueEntry->SortKey
    propObDumpUlong(hwndTreeList, h_tviWaitEntry, L"SortKey", NULL, devObject.Queue.Wcb.WaitQueueEntry.SortKey, TRUE, FALSE, 0, 0);

    //Queue->Wcb->WaitQueueEntry->Inserted
    propObDumpByte(hwndTreeList, h_tviWaitEntry, L"Inserted", NULL, devObject.Queue.Wcb.WaitQueueEntry.Inserted, 0, 0, TRUE);

    //Queue->Wcb->DmaWaitEntry
    propObDumpListEntry(hwndTreeList, h_tviWcb, L"DmaWaitEntry", &devObject.Queue.Wcb.DmaWaitEntry);

    //Queue->Wcb->NumberOfChannels
    propObDumpUlong(hwndTreeList, h_tviWcb, L"NumberOfChannels", NULL, devObject.Queue.Wcb.NumberOfChannels, FALSE, FALSE, 0, 0);

    //Queue->Wcb->SyncCallback
    propObDumpUlong(hwndTreeList, h_tviWcb, L"SyncCallback", NULL, devObject.Queue.Wcb.SyncCallback, FALSE, FALSE, 0, 0);

    //Queue->Wcb->DmaContext
    propObDumpUlong(hwndTreeList, h_tviWcb, L"DmaContext", NULL, devObject.Queue.Wcb.DmaContext, FALSE, FALSE, 0, 0);

    //Queue->Wcb->DeviceRoutine
    lpType = L"PDRIVER_CONTROL";
    propObDumpAddress(hwndTreeList, h_tviWcb, L"DeviceRoutine", lpType, devObject.Queue.Wcb.DeviceRoutine, 0, 0);

    //Queue->Wcb->DeviceContext
    propObDumpAddress(hwndTreeList, h_tviWcb, L"DeviceContext", NULL, devObject.Queue.Wcb.DeviceContext, 0, 0);

    //Queue->Wcb->NumberOfMapRegisters
    propObDumpUlong(hwndTreeList, h_tviWcb, L"NumberOfMapRegisters", NULL, devObject.Queue.Wcb.NumberOfMapRegisters, FALSE, FALSE, 0, 0);

    //Queue->Wcb->DeviceObject
    propDumpObjectForAddress(hwndTreeList, h_tviWcb, L"DeviceObject",
        devObject.Queue.Wcb.DeviceObject,
        CLR_LGRY,
        T_UNNAMED);

    //Queue->Wcb->CurrentIrp
    propObDumpAddress(hwndTreeList, h_tviWcb, L"CurrentIrp", NULL, devObject.Queue.Wcb.CurrentIrp, 0, 0);

    //Queue->Wcb->BufferChainingDpc
    lpType = T_PKDPC;
    propObDumpAddress(hwndTreeList, h_tviWcb, L"BufferChainingDpc", lpType, devObject.Queue.Wcb.BufferChainingDpc, 0, 0);

    //AlignmentRequirement
    lpType = NULL;
    for (i = 0; i < MAX_KNOWN_FILEALIGN; i++) {
        if (fileAlign[i].dwValue == devObject.AlignmentRequirement) {
            lpType = fileAlign[i].lpDescription;
            break;
        }
    }
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"AlignmentRequirement", lpType, devObject.AlignmentRequirement, TRUE, FALSE, 0, 0);

    //DeviceQueue
    h_tviSubItem = supTreeListAddItem(hwndTreeList, h_tviRootItem, TVIF_TEXT | TVIF_STATE, 0,
        TVIS_EXPANDED, L"DeviceQueue", NULL);

    //DeviceQueue->Type
    lpType = L"KOBJECTS";
    propObDumpUlong(hwndTreeList, h_tviSubItem, L"Type", lpType, devObject.DeviceQueue.Type, TRUE, TRUE, 0, 0);

    //DeviceQueue->Size
    propObDumpUlong(hwndTreeList, h_tviSubItem, L"Size", NULL, devObject.DeviceQueue.Size, TRUE, TRUE, 0, 0);

    //DeviceQueue->DeviceListHead
    propObDumpListEntry(hwndTreeList, h_tviSubItem, L"DeviceListHead", &devObject.DeviceQueue.DeviceListHead);

    //DeviceQueue->Lock
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"Lock", NULL, (PVOID)devObject.DeviceQueue.Lock, 0, 0);

    //DeviceQueue->Busy
    propObDumpByte(hwndTreeList, h_tviSubItem, L"Busy", NULL, devObject.DeviceQueue.Busy, 0, 0, TRUE);

    //DeviceQueue->Hint
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"Hint", NULL, (PVOID)devObject.DeviceQueue.Hint, 0, 0);

    //
    //DEVICE_OBJECT->Dpc
    //
    h_tviSubItem = supTreeListAddItem(hwndTreeList, h_tviRootItem, TVIF_TEXT | TVIF_STATE, 0,
        TVIS_EXPANDED, L"Dpc", NULL);

    lpType = NULL;
    if (devObject.Dpc.Type == DPC_NORMAL) lpType = L"DPC_NORMAL";
    if (devObject.Dpc.Type == DPC_THREADED) lpType = L"DPC_THREADED";
    propObDumpUlong(hwndTreeList, h_tviSubItem, L"Type", lpType, devObject.Dpc.Type, TRUE, TRUE, 0, 0);
    lpType = NULL;
    if (devObject.Dpc.Importance == LowImportance) lpType = L"LowImportance";
    if (devObject.Dpc.Importance == MediumImportance) lpType = L"MediumImportance";
    if (devObject.Dpc.Importance == HighImportance) lpType = L"HighImportance";
    propObDumpUlong(hwndTreeList, h_tviSubItem, L"Importance", lpType, devObject.Dpc.Importance, TRUE, TRUE, 0, 0);
    propObDumpUlong(hwndTreeList, h_tviSubItem, L"Number", NULL, devObject.Dpc.Number, TRUE, TRUE, 0, 0);

    //Dpc->DpcListEntry
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"DpcListEntry", NULL, (PVOID)devObject.Dpc.DpcListEntry.Next, 0, 0);

    //Dpc->ProcessorHistory
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"ProcessorHistory", NULL, (PVOID)devObject.Dpc.ProcessorHistory, 0, 0);

    //Dpc->DeferredRoutine
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"DeferredRoutine", NULL, devObject.Dpc.DeferredRoutine, 0, 0);

    //Dpc->DeferredContext
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"DeferredContext", NULL, devObject.Dpc.DeferredContext, 0, 0);

    //Dpc->SystemArgument1
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"SystemArgument1", NULL, devObject.Dpc.SystemArgument1, 0, 0);

    //Dpc->SystemArgument2
    propObDumpAddress(hwndTreeList, h_tviSubItem, L"SystemArgument2", NULL, devObject.Dpc.SystemArgument2, 0, 0);

    //ActiveThreadCount
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"ActiveThreadCount", NULL, devObject.ActiveThreadCount, FALSE, FALSE, 0, 0);

    //SecurityDescriptor
    lpType = L"PSECURITY_DESCRIPTOR";
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"SecurityDescriptor", lpType, devObject.SecurityDescriptor, 0, 0);

    //DeviceLock
    h_tviWaitEntry = supTreeListAddItem(hwndTreeList, h_tviRootItem, TVIF_TEXT | TVIF_STATE, 0,
        TVIS_EXPANDED, L"DeviceLock", NULL);

    //DeviceLock->Header
    propObDumpDispatcherHeader(hwndTreeList, h_tviWaitEntry, &devObject.DeviceLock.Header, NULL, NULL, NULL);

    //SectorSize
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"SectorSize", NULL, devObject.SectorSize, TRUE, TRUE, 0, 0);
    //Spare
    propObDumpUlong(hwndTreeList, h_tviRootItem, L"Spare1", NULL, devObject.Spare1, TRUE, TRUE, 0, 0);

    //DeviceObjectExtension
    lpType = L"PDEVOBJ_EXTENSION";
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"DeviceObjectExtension", lpType, devObject.DeviceObjectExtension, 0, 0);

    //Reserved
    propObDumpAddress(hwndTreeList, h_tviRootItem, L"Reserved", NULL, devObject.Reserved, 0, 0);

    //
    //DEVOBJ_EXTENSION
    //

    if (devObject.DeviceObjectExtension) {

        RtlSecureZeroMemory(&devObjExt, sizeof(devObjExt));

        if (!kdReadSystemMemory(
            (ULONG_PTR)devObject.DeviceObjectExtension,
            &devObjExt,
            sizeof(devObjExt)))
        {
            return; //safe to exit, nothing after this
        }

        h_tviRootItem = supTreeListAddItem(hwndTreeList, NULL, TVIF_TEXT | TVIF_STATE, 0,
            TVIS_EXPANDED, L"DEVOBJ_EXTENSION", NULL);

        BgColor = 0;
        lpType = L"IO_TYPE_DEVICE_OBJECT_EXTENSION";
        if (devObjExt.Type != IO_TYPE_DEVICE_OBJECT_EXTENSION) {
            lpType = L"! Must be IO_TYPE_DEVICE_OBJECT_EXTENSION";
            BgColor = CLR_WARN;
        }
        //Type
        propObDumpUlong(hwndTreeList, h_tviRootItem, L"Type", lpType, devObjExt.Type, TRUE, TRUE, BgColor, 0);
        //Size
        propObDumpUlong(hwndTreeList, h_tviRootItem, L"Size", NULL, devObjExt.Size, TRUE, TRUE, 0, 0);

        //DeviceObject
        propDumpObjectForAddress(hwndTreeList, h_tviRootItem, L"DeviceObject",
            devObjExt.DeviceObject,
            CLR_LGRY,
            T_UNNAMED);

        //PowerFlags
        propObDumpUlong(hwndTreeList, h_tviRootItem, L"PowerFlags", NULL, devObjExt.PowerFlags, TRUE, FALSE, 0, 0);

        //Dope
        lpType = L"PDEVICE_OBJECT_POWER_EXTENSION";
        propObDumpAddress(hwndTreeList, h_tviRootItem, L"Dope", lpType, devObjExt.Dope, 0, 0);

        //ExtensionFlags
        propObDumpUlong(hwndTreeList, h_tviRootItem, L"ExtensionFlags", NULL, devObjExt.ExtensionFlags, TRUE, FALSE, 0, 0);

        //DeviceNode
        lpType = L"PDEVICE_NODE";
        propObDumpAddress(hwndTreeList, h_tviRootItem, L"DeviceNode", lpType, devObjExt.DeviceNode, 0, 0);

        //AttachedTo
        propDumpObjectForAddress(hwndTreeList, h_tviRootItem, L"AttachedTo",
            devObjExt.AttachedTo,
            CLR_LGRY,
            T_UNNAMED);

    }

}

/*
* propObDumpSessionIdVersionAware
*
* Purpose:
*
* Dump OBJECT_DIRECTORY SessionId.
*
*/
VOID propObDumpSessionIdVersionAware(
    _In_ HWND hwndTreeList,
    _In_ HTREEITEM h_tviRootItem,
    _In_ ULONG SessionId
)
{
    LPWSTR lpType;

    if (SessionId == OBJ_INVALID_SESSION_ID)
        lpType = T_OBJ_INVALID_SESSION_ID;
    else
        lpType = NULL;

    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("SessionId"), lpType, SessionId, TRUE, FALSE, 0, 0);
}

LPWSTR propObGetDosDriveTypeDesc(
    _In_ UCHAR DosDrive)
{
    ULONG i;

    for (i = 0; i < MAX_KNOWN_DOS_DRIVE_TYPE; i++) {
        if (dosDeviceDriveType[i].dwValue == DosDrive)
            return dosDeviceDriveType[i].lpDescription;

    }

    return T_UnknownType;
}

/*
* propObDumpDeviceMap
*
* Purpose:
*
* Dump DEVICE_MAP to the treelist.
*
*/
VOID propObDumpDeviceMap(
    _In_ HWND TreeList,
    _In_ HTREEITEM ParentItem,
    _In_ PDEVICE_MAP DeviceMapAddress
)
{
    union {
        union {
            DEVICE_MAP_V1* DeviceMapV1;
            DEVICE_MAP_V2* DeviceMapV2;
            DEVICE_MAP_V3* DeviceMapV3;
            DEVICE_MAP_V2* DeviceMapCompat;
        } Versions;
        PVOID Ref;
    } DeviceMapStruct;

    HTREEITEM h_tviSubItem, h_tviDriveType;
    TL_SUBITEMS_FIXED subitems;

    LPWSTR lpType;
    PVOID DeviceMapPtr;
    ULONG ObjectSize = 0;
    ULONG ObjectVersion = 0;
    ULONG i, driveMap;

    BYTE driveType;
    WCHAR szBuffer[MAX_PATH + 1];

    DeviceMapPtr = ObDumpDeviceMapVersionAware((ULONG_PTR)DeviceMapAddress,
        &ObjectSize,
        &ObjectVersion);

    if (DeviceMapPtr) {

        DeviceMapStruct.Ref = DeviceMapPtr;

        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        subitems.Count = 2;

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        szBuffer[0] = L'0';
        szBuffer[1] = L'x';
        u64tohex((ULONG_PTR)DeviceMapAddress, &szBuffer[2]);

        subitems.Text[0] = szBuffer;
        subitems.Text[1] = T_PDEVICE_MAP;

        h_tviSubItem = supTreeListAddItem(TreeList,
            ParentItem,
            TVIF_TEXT | TVIF_STATE,
            0,
            0,
            T_FIELD_DEVICE_MAP,
            &subitems);

        if (h_tviSubItem) {

            if (DeviceMapStruct.Versions.DeviceMapCompat->DosDevicesDirectory)
                lpType = T_POBJECT_DIRECTORY;
            else
                lpType = T_EMPTY;

            propObDumpAddress(TreeList, h_tviSubItem, T_DEVICEMAP_DOSDEVICESDIRECTORY, lpType,
                (PVOID)DeviceMapStruct.Versions.DeviceMapCompat->DosDevicesDirectory, 0, 0);

            if (DeviceMapStruct.Versions.DeviceMapCompat->GlobalDosDevicesDirectory)
                lpType = T_POBJECT_DIRECTORY;
            else
                lpType = T_EMPTY;

            propObDumpAddress(TreeList, h_tviSubItem, T_DEVICEMAP_GLOBALDOSDEVICESDIRECTORY, lpType,
                (PVOID)DeviceMapStruct.Versions.DeviceMapCompat->GlobalDosDevicesDirectory, 0, 0);

            if (ObjectVersion > OBVERSION_DEVICE_MAP_V2) {
                propObDumpAddress(TreeList, h_tviSubItem, T_DEVICEMAP_DOSDEVICESDIRECTORYHANDLE, NULL,
                    (PVOID)DeviceMapStruct.Versions.DeviceMapV3->DosDevicesDirectoryHandle, 0, 0);
            }
            else {

                propObDumpAddress(TreeList, h_tviSubItem, T_DEVICEMAP_DOSDEVICESDIRECTORYHANDLE, NULL,
                    (PVOID)DeviceMapStruct.Versions.DeviceMapCompat->DosDevicesDirectoryHandle, 0, 0);

            }

            //
            // ReferenceCount
            //
            switch (ObjectVersion) {
            case OBVERSION_DEVICE_MAP_V1:
                propObDumpUlong(TreeList, h_tviSubItem, T_REFERENCECOUNT, NULL,
                    DeviceMapStruct.Versions.DeviceMapV1->ReferenceCount, TRUE, FALSE, 0, 0);
                break;
            case OBVERSION_DEVICE_MAP_V2:
                propObDumpLong(TreeList, h_tviSubItem, T_REFERENCECOUNT, NULL,
                    DeviceMapStruct.Versions.DeviceMapV2->ReferenceCount, TRUE, 0, 0);
                break;
            case OBVERSION_DEVICE_MAP_V3:
            default:
                propObDumpLong64(TreeList, h_tviSubItem, T_REFERENCECOUNT, NULL,
                    DeviceMapStruct.Versions.DeviceMapV3->ReferenceCount, TRUE, 0, 0);
                break;
            }

            //
            // DriveMap
            //
            if (ObjectVersion > OBVERSION_DEVICE_MAP_V2) {
                driveMap = DeviceMapStruct.Versions.DeviceMapV3->DriveMap;
            }
            else {
                driveMap = DeviceMapStruct.Versions.DeviceMapCompat->DriveMap;
            }

            propObDumpUlong(TreeList, h_tviSubItem, T_DRIVEMAP, NULL,
                driveMap, TRUE, FALSE, 0, 0);

            //
            // Display DriveType array.
            //
            RtlSecureZeroMemory(&subitems, sizeof(subitems));

            subitems.Count = 2;
            subitems.Text[0] = T_EmptyString;
            subitems.Text[1] = T_EmptyString;

            h_tviDriveType = supTreeListAddItem(TreeList,
                h_tviSubItem,
                TVIF_TEXT | TVIF_STATE,
                0,
                0,
                T_DRIVETYPE,
                &subitems);

            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

            for (i = 0; i < RTL_NUMBER_OF(DeviceMapStruct.Versions.DeviceMapCompat->DriveType); i++) {

                RtlStringCchPrintfSecure(szBuffer,
                    RTL_NUMBER_OF(szBuffer),
                    TEXT("[ %i ]"),
                    i);

                if (ObjectVersion > OBVERSION_DEVICE_MAP_V2) {
                    driveType = DeviceMapStruct.Versions.DeviceMapV3->DriveType[i];
                }
                else {
                    driveType = DeviceMapStruct.Versions.DeviceMapCompat->DriveType[i];
                }

                lpType = propObGetDosDriveTypeDesc(driveType);

                propObDumpByte(TreeList, h_tviDriveType,
                    szBuffer,
                    lpType,
                    driveType,
                    0,
                    0,
                    FALSE);

            }

            if (ObjectVersion > OBVERSION_DEVICE_MAP_V1) {

                if (ObjectVersion > OBVERSION_DEVICE_MAP_V2) {
                    propObDumpAddress(TreeList, h_tviSubItem, T_SERVERSILO, T_PEJOB,
                        (PVOID)DeviceMapStruct.Versions.DeviceMapV3->ServerSilo, 0, 0);
                }
                else {
                    propObDumpAddress(TreeList, h_tviSubItem, T_SERVERSILO, T_PEJOB,
                        (PVOID)DeviceMapStruct.Versions.DeviceMapCompat->ServerSilo, 0, 0);
                }
            }

        }

        supVirtualFree(DeviceMapPtr);
    }
    else {

        //
        // Output as is in case of error.
        //

        propObDumpAddress(TreeList, ParentItem, T_FIELD_DEVICE_MAP, T_PDEVICE_MAP,
            (PVOID)DeviceMapAddress, 0, 0);

    }
}

/*
* propObDumpDirectoryObjectInternal
*
* Purpose:
*
* Dump OBJECT_DIRECTORY members (including ShadowDirectory) to the treelist.
*
*/
VOID propObDumpDirectoryObjectInternal(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_opt_ HWND ParentWindow,
    _In_ ULONG_PTR ObjectAddress,
    _In_ BOOLEAN DumpShadow,
    _In_ BOOLEAN ShowErrors
)
{
    INT                     i, j;
    ULONG                   SessionId, ObjectFlags;
    HTREEITEM               h_tviRootItem, h_tviSubItem, h_tviEntry;
    LPWSTR                  lpType;
    TL_SUBITEMS_FIXED       subitems;
    WCHAR                   szId[100], szValue[100];

    ULONG ObjectVersion = 0;
    ULONG ObjectSize = 0;

    PVOID DirectoryObjectPtr = NULL, NamespaceEntry;
    OBJECT_DIRECTORY_ENTRY dirEntry;
    LIST_ENTRY             ChainLink;

    union {
        union {
            OBJECT_DIRECTORY* DirObjectV1;
            OBJECT_DIRECTORY_V2* DirObjectV2;
            OBJECT_DIRECTORY_V3* DirObjectV3;
            OBJECT_DIRECTORY_V3* CompatDirObject;//has all field members
        } Versions;
        PVOID Ref;
    } DirObject;


    DirectoryObjectPtr = ObDumpDirectoryObjectVersionAware(ObjectAddress,
        &ObjectSize,
        &ObjectVersion);

    if (DirectoryObjectPtr == NULL) {
        if (ShowErrors)
            supObDumpShowError(ParentWindow, NULL);
        return;
    }

    DirObject.Ref = DirectoryObjectPtr;

    //
    //OBJECT_DIRECTORY
    //
    h_tviRootItem = RootItem;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 1;
    subitems.Text[0] = TEXT("{...}");

    h_tviSubItem = supTreeListAddItem(TreeList,
        h_tviRootItem,
        TVIF_TEXT | TVIF_STATE,
        0,
        0,
        TEXT("HashBuckets"),
        &subitems);

    for (i = 0; i < NUMBER_HASH_BUCKETS; i++) {
        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        subitems.Count = 2;

        RtlSecureZeroMemory(szId, sizeof(szId));

        RtlStringCchPrintfSecure(szId,
            RTL_NUMBER_OF(szId),
            TEXT("[ %i ]"),
            i);


        if (DirObject.Versions.CompatDirObject->HashBuckets[i]) {
            RtlSecureZeroMemory(szValue, sizeof(szValue));
            szValue[0] = TEXT('0');
            szValue[1] = TEXT('x');
            u64tohex((ULONG_PTR)DirObject.Versions.CompatDirObject->HashBuckets[i], &szValue[2]);
            subitems.Text[0] = szValue;
            subitems.Text[1] = T_POBJECT_DIRECTORY_ENTRY;
        }
        else {
            subitems.Text[0] = T_NULL;
            subitems.Text[1] = T_EmptyString;
        }

        h_tviEntry = supTreeListAddItem(TreeList,
            h_tviSubItem,
            TVIF_TEXT | TVIF_STATE,
            0,
            0,
            szId,
            &subitems);

        //dump entry if available
        if (DirObject.Versions.CompatDirObject->HashBuckets[i]) {

            RtlSecureZeroMemory(&dirEntry, sizeof(dirEntry));

            if (kdReadSystemMemory((ULONG_PTR)DirObject.Versions.CompatDirObject->HashBuckets[i],
                &dirEntry,
                sizeof(dirEntry)))
            {

                ChainLink.Blink = NULL;
                ChainLink.Flink = NULL;
                lpType = TEXT("ChainLink");
                if (dirEntry.ChainLink == NULL) {
                    propObDumpAddress(TreeList, h_tviEntry, lpType, T_EMPTY, NULL, 0, 0);
                }
                else {
                    if (kdReadSystemMemory(
                        (ULONG_PTR)dirEntry.ChainLink,
                        &ChainLink,
                        sizeof(ChainLink)))
                    {
                        propObDumpListEntry(TreeList, h_tviEntry, lpType, &ChainLink);
                    }
                    else {
                        //
                        // Failed to read listentry, display as is.
                        //
                        propObDumpAddress(TreeList, h_tviEntry, lpType, T_PLIST_ENTRY, dirEntry.ChainLink, 0, 0);
                    }
                }
                propObDumpAddress(TreeList, h_tviEntry, TEXT("Object"), NULL, dirEntry.Object, 0, 0);
                propObDumpUlong(TreeList, h_tviEntry, TEXT("HashValue"), NULL, dirEntry.HashValue, TRUE, FALSE, 0, 0);
            }
        }
    }

    //EX_PUSH_LOCK
    propObDumpPushLock(TreeList, h_tviRootItem,
        DirObject.Versions.CompatDirObject->Lock.Ptr, 0, 0);

    //DeviceMap
    if (DumpShadow) {
        propObDumpDeviceMap(TreeList, h_tviRootItem,
            DirObject.Versions.CompatDirObject->DeviceMap);
    }
    else {
        propObDumpAddress(TreeList, h_tviRootItem, TEXT("DeviceMap"), NULL,
            DirObject.Versions.CompatDirObject->DeviceMap, 0, 0);
    }

    //ShadowDirectory
    if (ObjectVersion != OBVERSION_DIRECTORY_V1) {


        if (DirObject.Versions.CompatDirObject->ShadowDirectory) {
            if (DumpShadow) {

                RtlSecureZeroMemory(&subitems, sizeof(subitems));
                subitems.Count = 2;

                RtlSecureZeroMemory(&szValue, sizeof(szValue));
                szValue[0] = L'0';
                szValue[1] = L'x';
                u64tohex((ULONG_PTR)DirObject.Versions.CompatDirObject->ShadowDirectory, &szValue[2]);

                subitems.Text[0] = szValue;
                subitems.Text[1] = T_POBJECT_DIRECTORY;

                h_tviSubItem = supTreeListAddItem(TreeList,
                    h_tviRootItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    0,
                    T_FIELD_SHADOW_DIRECTORY,
                    &subitems);

                propObDumpDirectoryObjectInternal(TreeList,
                    h_tviSubItem,
                    ParentWindow,
                    (ULONG_PTR)DirObject.Versions.CompatDirObject->ShadowDirectory,
                    FALSE, //do not allow recursion, only first level dir listed.
                    FALSE);
            }
        }
        else {
            //
            // No ShadowDirectory, display 0
            //
            propObDumpAddress(TreeList,
                h_tviRootItem,
                T_FIELD_SHADOW_DIRECTORY,
                T_POBJECT_DIRECTORY,
                0,
                0,
                0);

        }
    }

    //
    // Handle different object versions fields order.
    //

    //
    // SessionId
    //
    switch (ObjectVersion) {
    case OBVERSION_DIRECTORY_V1:
        SessionId = DirObject.Versions.DirObjectV1->SessionId;
        break;
    case OBVERSION_DIRECTORY_V2:
        SessionId = DirObject.Versions.DirObjectV2->SessionId;
        break;
    case OBVERSION_DIRECTORY_V3:
    default:
        SessionId = DirObject.Versions.DirObjectV3->SessionId;
        break;

    }

    //
    // SessionId is the last member of OBJECT_DIRECTORY_V3, so it will be listed in the end of routine.
    //
    //
    if (ObjectVersion != OBVERSION_DIRECTORY_V3) {
        propObDumpSessionIdVersionAware(TreeList, h_tviRootItem, SessionId);
    }

    //
    // NamespaceEntry
    //
    switch (ObjectVersion) {
    case OBVERSION_DIRECTORY_V1:
        NamespaceEntry = DirObject.Versions.DirObjectV1->NamespaceEntry;
        break;
    case OBVERSION_DIRECTORY_V2:
        NamespaceEntry = DirObject.Versions.DirObjectV2->NamespaceEntry;
        break;
    case OBVERSION_DIRECTORY_V3:
    default:
        NamespaceEntry = DirObject.Versions.DirObjectV3->NamespaceEntry;
        break;

    }

    propObDumpAddress(TreeList, h_tviRootItem, TEXT("NamespaceEntry"), NULL, NamespaceEntry, 0, 0);

    //
    // SessionObject
    //
    if (ObjectVersion == OBVERSION_DIRECTORY_V3) {

        propObDumpAddress(TreeList,
            h_tviRootItem,
            TEXT("SessionObject"),
            NULL,
            DirObject.Versions.DirObjectV3->SessionObject,
            0, 0);

    }

    //
    // ObjectDirectory flags.
    //       
    switch (ObjectVersion) {
    case OBVERSION_DIRECTORY_V1:
        ObjectFlags = DirObject.Versions.DirObjectV1->Flags;
        break;
    case OBVERSION_DIRECTORY_V2:
        ObjectFlags = DirObject.Versions.DirObjectV2->Flags;
        break;
    case OBVERSION_DIRECTORY_V3:
    default:
        ObjectFlags = DirObject.Versions.DirObjectV3->Flags;
        break;

    }

    if (ObjectFlags == 0) {
        propObDumpUlong(TreeList, h_tviRootItem, TEXT("Flags"), NULL, 0, TRUE, FALSE, 0, 0);
    }
    else {

        //
        // List flags.
        //
        RtlSecureZeroMemory(&szValue, sizeof(szValue));
        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        j = 0;
        lpType = NULL;
        for (i = 0; i < MAX_KNOWN_OBJ_DIR_FLAGS; i++) {
            if (ObjectFlags & objDirFlags[i].dwValue) {
                lpType = objDirFlags[i].lpDescription;
                subitems.Count = 2;
                //add first entry with name
                if (j == 0) {
                    szValue[0] = L'0';
                    szValue[1] = L'x';
                    ultohex(ObjectFlags, &szValue[2]);

                    subitems.Text[0] = szValue;
                    subitems.Text[1] = lpType;
                }
                else {
                    //add subentry
                    subitems.Text[0] = T_EmptyString;
                    subitems.Text[1] = lpType;
                }

                supTreeListAddItem(
                    TreeList,
                    h_tviRootItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    0,
                    (j == 0) ? T_FLAGS : T_EmptyString,
                    &subitems);

                ObjectFlags &= ~objDirFlags[i].dwValue;
                j++;

            }
            if (ObjectFlags == 0) {
                break;
            }
        }

    }

    //
    // SessionId is the last member of OBJECT_DIRECTORY_V3
    //
    if (ObjectVersion == OBVERSION_DIRECTORY_V3) {

        propObDumpSessionIdVersionAware(TreeList,
            h_tviRootItem,
            SessionId);
    }

    supVirtualFree(DirectoryObjectPtr);
}

/*
* propObDumpDirectoryObject
*
* Purpose:
*
* Initialize treelist for dump, creates root node and call actual dump function.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpDirectoryObject)
{
    HTREEITEM rootItem;


    if (Context->ObjectInfo.ObjectAddress == 0) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //
    //OBJECT_DIRECTORY
    //
    rootItem = supTreeListAddItem(hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        T_OBJECT_DIRECTORY,
        NULL);

    if (rootItem) {

        propObDumpDirectoryObjectInternal(
            hwndTreeList,
            rootItem,
            hwndDlg,
            (ULONG_PTR)Context->ObjectInfo.ObjectAddress,
            TRUE,
            TRUE);

    }

}

/*
* propObDumpSyncObject
*
* Purpose:
*
* Dump KEVENT/KMUTANT/KSEMAPHORE/KTIMER members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpSyncObject)
{
    PKMUTANT            Mutant = NULL;
    PKEVENT             Event = NULL;
    PKSEMAPHORE         Semaphore = NULL;
    PKTIMER             Timer = NULL;
    PDISPATCHER_HEADER  Header = NULL;

    HTREEITEM h_tviRootItem;
    LPWSTR    lpType = NULL, lpDescType = NULL, lpDesc1 = NULL, lpDesc2 = NULL;
    PVOID     Object = NULL;
    ULONG     ObjectSize = 0UL;
    WCHAR     szValue[MAX_PATH + 1];


    switch (Context->ObjectTypeIndex) {

    case ObjectTypeEvent:
        ObjectSize = sizeof(KEVENT);
        break;

    case ObjectTypeMutant:
        ObjectSize = sizeof(KMUTANT);
        break;

    case ObjectTypeSemaphore:
        ObjectSize = sizeof(KSEMAPHORE);
        break;

    case ObjectTypeTimer:
        ObjectSize = sizeof(KTIMER);
        break;

    }

    Object = supHeapAlloc(ObjectSize);
    if (Object == NULL) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //dump object
    if (!kdReadSystemMemory(
        Context->ObjectInfo.ObjectAddress,
        Object,
        ObjectSize))
    {
        supObDumpShowError(hwndDlg, NULL);
        supHeapFree(Object);
        return;
    }

    //
    // Object name
    //
    Header = NULL;
    switch (Context->ObjectTypeIndex) {
    case ObjectTypeEvent:
        lpType = T_KEVENT;
        Event = (KEVENT*)Object;
        Header = &Event->Header;

        lpDescType = T_UnknownType;
        switch (Header->Type) {
        case NotificationEvent:
            lpDescType = T_EVENT_NOTIFICATION;
            break;
        case SynchronizationEvent:
            lpDescType = T_EVENT_SYNC;
            break;
        }

        //Event state
        lpDesc1 = T_Unknown;
        switch (Header->SignalState) {
        case 0:
            lpDesc1 = T_NONSIGNALED;
            break;
        case 1:
            lpDesc1 = T_SIGNALED;
            break;
        }

        lpDesc2 = NULL;
        if (Header->Size == (sizeof(KEVENT) / sizeof(ULONG))) {
            lpDesc2 = TEXT("sizeof(KEVENT)/sizeof(ULONG)");
        }
        break;

    case ObjectTypeMutant:
        lpType = T_KMUTANT;
        Mutant = (KMUTANT*)Object;
        Header = &Mutant->Header;
        lpDesc1 = TEXT("Not Held");

        RtlSecureZeroMemory(szValue, sizeof(szValue));
        if (Mutant->OwnerThread != NULL) {

            RtlStringCchPrintfSecure(szValue,
                RTL_NUMBER_OF(szValue),
                TEXT("Held %d times"),
                Header->SignalState);

            lpDesc1 = szValue;
        }

        lpDesc2 = NULL;
        if (Header->Size == (sizeof(KMUTANT) / sizeof(ULONG))) {
            lpDesc2 = TEXT("sizeof(KMUTANT)/sizeof(ULONG)");
        }
        break;

    case ObjectTypeSemaphore:
        lpType = T_KSEMAPHORE;
        Semaphore = (KSEMAPHORE*)Object;
        Header = &Semaphore->Header;

        lpDesc1 = TEXT("Count");
        lpDesc2 = NULL;
        if (Header->Size == (sizeof(KSEMAPHORE) / sizeof(ULONG))) {
            lpDesc2 = TEXT("sizeof(KSEMAPHORE)/sizeof(ULONG)");
        }
        break;

    case ObjectTypeTimer:
        lpType = T_KTIMER;
        Timer = (KTIMER*)Object;
        Header = &Timer->Header;

        lpDescType = T_TIMER_SYNC;
        if (Header->TimerType == 8) {
            lpDescType = T_TIMER_NOTIFICATION;
        }
        //Timer state
        lpDesc1 = T_Unknown;
        switch (Header->SignalState) {
        case 0:
            lpDesc1 = T_NONSIGNALED;
            break;
        case 1:
            lpDesc1 = T_SIGNALED;
            break;
        }
        lpDesc2 = NULL;
        break;

    }

    if (Header == NULL) {
        supObDumpShowError(hwndDlg, NULL);
        supHeapFree(Object);
        return;
    }

    h_tviRootItem = supTreeListAddItem(
        hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        lpType,
        NULL);

    //Header
    propObDumpDispatcherHeader(hwndTreeList, h_tviRootItem, Header, lpDescType, lpDesc1, lpDesc2);

    //type specific values
    switch (Context->ObjectTypeIndex) {
    case ObjectTypeMutant:
        if (Mutant) {
            propObDumpListEntry(hwndTreeList, h_tviRootItem, L"MutantListEntry", &Mutant->MutantListEntry);
            propObDumpAddress(hwndTreeList, h_tviRootItem, L"OwnerThread", T_PKTHREAD, Mutant->OwnerThread, 0, 0);
            propObDumpByte(hwndTreeList, h_tviRootItem, L"Abandoned", NULL, Mutant->Abandoned, 0, 0, TRUE);
            propObDumpByte(hwndTreeList, h_tviRootItem, L"ApcDisable", NULL, Mutant->ApcDisable, 0, 0, FALSE);
        }
        break;

    case ObjectTypeSemaphore:
        if (Semaphore) {
            propObDumpUlong(hwndTreeList, h_tviRootItem, L"Limit", NULL, Semaphore->Limit, TRUE, FALSE, 0, 0);
        }
        break;

    case ObjectTypeTimer:
        if (Timer) {
            propObDumpULargeInteger(hwndTreeList, h_tviRootItem, L"DueTime", &Timer->DueTime); //dumped as hex, not important
            propObDumpListEntry(hwndTreeList, h_tviRootItem, L"TimerListEntry", &Timer->TimerListEntry);
            propObDumpAddress(hwndTreeList, h_tviRootItem, L"Dpc", T_PKDPC, Timer->Dpc, 0, 0);
            propObDumpUlong(hwndTreeList, h_tviRootItem, L"Processor", NULL, Timer->Processor, TRUE, FALSE, 0, 0);
            propObDumpUlong(hwndTreeList, h_tviRootItem, L"Period", NULL, Timer->Period, TRUE, FALSE, 0, 0);
        }
        break;

    }

    supHeapFree(Object);

}

/*
* propObDumpObjectTypeFlags
*
* Purpose:
*
* Dump ObjectTypeFlags/ObjectTypeFlags2 bits to the treelist.
*
*/
VOID propObDumpObjectTypeFlags(
    _In_ HWND TreeList,
    _In_ LPWSTR EntryName,
    _In_ UCHAR ObjectTypeFlags,
    _In_ HTREEITEM h_tviSubItem,
    _In_ LPWSTR* ObjectTypeFlagsText,
    _In_ BOOLEAN SetEntry
)
{
    ULONG i, j;
    LPWSTR lpType;
    TL_SUBITEMS_FIXED TreeListSubitems;

    WCHAR szValue[32];

    if (ObjectTypeFlags) {

        RtlSecureZeroMemory(&TreeListSubitems, sizeof(TreeListSubitems));
        TreeListSubitems.Count = 2;

        j = 0;
        for (i = 0; i < 8; i++) {
            if (GET_BIT(ObjectTypeFlags, i)) {
                lpType = (LPWSTR)ObjectTypeFlagsText[i];
                TreeListSubitems.Text[0] = T_EmptyString;
                if (j == 0) {

                    RtlSecureZeroMemory(szValue, sizeof(szValue));
                    RtlStringCchPrintfSecure(szValue,
                        RTL_NUMBER_OF(szValue),
                        FORMAT_HEXBYTE,
                        ObjectTypeFlags);

                    TreeListSubitems.Text[0] = szValue;
                }
                TreeListSubitems.Text[1] = lpType;
                supTreeListAddItem(TreeList,
                    h_tviSubItem,
                    TVIF_TEXT | TVIF_STATE,
                    0,
                    0,
                    (j == 0) ? ((SetEntry) ? EntryName : T_EmptyString) : T_EmptyString,
                    &TreeListSubitems);
                j++;
            }
        }
    }
    else {
        if (SetEntry)
            propObDumpByte(TreeList, h_tviSubItem, EntryName, NULL, ObjectTypeFlags, 0, 0, FALSE);
    }
}

/*
* propObDumpObjectType
*
* Purpose:
*
* Dump OBJECT_TYPE members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpObjectType)
{
    BOOL bOkay;
    HTREEITEM h_tviRootItem, h_tviSubItem, h_tviGenericMapping;
    UINT i;
    LPWSTR lpType = NULL;
    PVOID ObjectTypeInformation = NULL;
    PRTL_PROCESS_MODULES ModulesList = NULL;
    TL_SUBITEMS_FIXED TreeListSubItems;
    PVOID TypeProcs[MAX_KNOWN_OBJECT_TYPE_PROCEDURES];
    PVOID SelfDriverBase;
    ULONG SelfDriverSize;

    POBEX_OBJECT_INFORMATION CurrentObject = NULL;
    ULONG ObjectSize = 0;
    ULONG ObjectVersion = 0;

    BOOLEAN bSetEntry;

    ULONG Key;
    PVOID LockPtr;
    PLIST_ENTRY pListEntry;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;

    union {
        union {
            OBJECT_TYPE_COMPATIBLE* ObjectTypeCompatible;
            OBJECT_TYPE_7* ObjectType_7;
            OBJECT_TYPE_8* ObjectType_8;
            OBJECT_TYPE_RS1* ObjectType_RS1;
            OBJECT_TYPE_RS2* ObjectType_RS2;
        } Versions;
        PVOID Ref;
    } ObjectType;

    do {

        bOkay = FALSE;

        //
        // Get loaded modules list.
        //
        ModulesList = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
        if (ModulesList == NULL)
            break;

        //
        // Get the reference to the object.
        //
        CurrentObject = ObQueryObjectInDirectory(
            &Context->NtObjectName,
            ObGetPredefinedUnicodeString(OBP_OBTYPES));

        if (CurrentObject == NULL)
            break;

        //
        // Dump object information version aware.
        //
        ObjectTypeInformation = ObDumpObjectTypeVersionAware(
            CurrentObject->ObjectAddress,
            &ObjectSize,
            &ObjectVersion);

        if (ObjectTypeInformation == NULL)
            break;

        //
        // For listing common fields.
        //
        ObjectType.Ref = ObjectTypeInformation;

        //
        // Add treelist root item ("OBJECT_TYPE").
        //
        h_tviRootItem = supTreeListAddItem(
            hwndTreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            T_OBJECT_TYPE,
            NULL);

        //
        // This fields are structure version unaware.
        //
        propObDumpListEntry(hwndTreeList, h_tviRootItem, TEXT("TypeList"),
            &ObjectType.Versions.ObjectTypeCompatible->TypeList);

        propObDumpUnicodeString(hwndTreeList, h_tviRootItem, TEXT("Name"),
            &ObjectType.Versions.ObjectTypeCompatible->Name, FALSE);

        propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("DefaultObject"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->DefaultObject, 0, 0);

        propObDumpByte(hwndTreeList, h_tviRootItem, T_TYPEINDEX, NULL,
            ObjectType.Versions.ObjectTypeCompatible->Index, 0, 0, FALSE);

        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("TotalNumberOfObjects"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TotalNumberOfObjects, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("TotalNumberOfHandles"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TotalNumberOfHandles, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("HighWaterNumberOfObjects"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->HighWaterNumberOfObjects, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("HighWaterNumberOfHandles"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->HighWaterNumberOfHandles, TRUE, FALSE, 0, 0);

        //
        // OBJECT_TYPE_INITIALIZER
        //
        RtlSecureZeroMemory(&TreeListSubItems, sizeof(TreeListSubItems));

        TreeListSubItems.Count = 2;
        TreeListSubItems.Text[0] = T_EmptyString;
        TreeListSubItems.Text[1] = T_OBJECT_TYPE_INITIALIZER;
        h_tviSubItem = supTreeListAddItem(hwndTreeList, h_tviRootItem, TVIF_TEXT | TVIF_STATE, 0,
            0, TEXT("TypeInfo"), &TreeListSubItems);

        propObDumpUlong(hwndTreeList, h_tviSubItem, T_LENGTH, NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.Length, TRUE, TRUE, 0, 0);

        //
        // Dump Object Type Flags / Extended Object Type Flags
        //
        propObDumpObjectTypeFlags(hwndTreeList,
            T_OBJECT_TYPE_FLAGS,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.ObjectTypeFlags,
            h_tviSubItem,
            (LPWSTR*)T_ObjectTypeFlags,
            TRUE);

        if (ObjectVersion > OBVERSION_OBJECT_TYPE_V2) {

            if (ObjectVersion == OBVERSION_OBJECT_TYPE_V3) {
                bSetEntry = TRUE;
                lpType = T_OBJECT_TYPE_FLAGS2; //fu ms
            }
            else {
                bSetEntry = FALSE;
                lpType = T_OBJECT_TYPE_FLAGS;
            }

            propObDumpObjectTypeFlags(hwndTreeList,
                lpType,
                ObjectType.Versions.ObjectType_RS1->TypeInfo.ObjectTypeFlags2,
                h_tviSubItem,
                (LPWSTR*)T_ObjectTypeFlags2,
                bSetEntry);

        }

        //
        // Structure version independent fields.
        //
        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("ObjectTypeCode"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.ObjectTypeCode, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("InvalidAttributes"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.InvalidAttributes, TRUE, FALSE, 0, 0);

        RtlSecureZeroMemory(&TreeListSubItems, sizeof(TreeListSubItems));
        TreeListSubItems.Count = 2;
        TreeListSubItems.Text[0] = T_EmptyString;
        TreeListSubItems.Text[1] = T_GENERIC_MAPPING;
        h_tviGenericMapping = supTreeListAddItem(hwndTreeList, h_tviSubItem, TVIF_TEXT | TVIF_STATE, 0,
            0, TEXT("GenericMapping"), &TreeListSubItems);

        propObDumpUlong(hwndTreeList, h_tviGenericMapping, TEXT("GenericRead"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.GenericMapping.GenericRead, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviGenericMapping, TEXT("GenericWrite"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.GenericMapping.GenericWrite, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviGenericMapping, TEXT("GenericExecute"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.GenericMapping.GenericExecute, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviGenericMapping, TEXT("GenericAll"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.GenericMapping.GenericAll, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("ValidAccessMask"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.ValidAccessMask, TRUE, FALSE, 0, 0);
        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("RetainAccess"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.RetainAccess, TRUE, FALSE, 0, 0);

        //Pool Type
        lpType = T_Unknown;
        for (i = 0; i < MAX_KNOWN_POOL_TYPES; i++) {
            if (ObjectType.Versions.ObjectTypeCompatible->TypeInfo.PoolType == (POOL_TYPE)a_PoolTypes[i].dwValue) {
                lpType = a_PoolTypes[i].lpDescription;
                break;
            }
        }

        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("PoolType"), lpType,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.PoolType, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("DefaultPagedPoolCharge"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.DefaultPagedPoolCharge, TRUE, FALSE, 0, 0);

        propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("DefaultNonPagedPoolCharge"), NULL,
            ObjectType.Versions.ObjectTypeCompatible->TypeInfo.DefaultNonPagedPoolCharge, TRUE, FALSE, 0, 0);

        //
        // List callback procedures.
        //
        // Copy type procedures to temp array, assume DumpProcedure always first.
        //
        RtlSecureZeroMemory(TypeProcs, sizeof(TypeProcs));

        RtlCopyMemory(&TypeProcs,  //-V512
            &ObjectType.Versions.ObjectTypeCompatible->TypeInfo.DumpProcedure, 
            sizeof(TypeProcs));

        //assume ntoskrnl first in list and list initialized
        SelfDriverBase = ModulesList->Modules[0].ImageBase;
        SelfDriverSize = ModulesList->Modules[0].ImageSize;

        for (i = 0; i < MAX_KNOWN_OBJECT_TYPE_PROCEDURES; i++) {
            if (TypeProcs[i]) {
                propObDumpAddressWithModule(hwndTreeList, h_tviSubItem, T_TYPEPROCEDURES[i], TypeProcs[i],
                    ModulesList, SelfDriverBase, SelfDriverSize);
            }
            else {
                propObDumpAddress(hwndTreeList, h_tviSubItem, T_TYPEPROCEDURES[i], NULL, TypeProcs[i], 0, 0);
            }
        }

        if (ObjectVersion > OBVERSION_OBJECT_TYPE_V1) {

            switch (ObjectVersion) {
            case OBVERSION_OBJECT_TYPE_V2:
                WaitObjectFlagMask = ObjectType.Versions.ObjectType_8->TypeInfo.WaitObjectFlagMask;
                WaitObjectFlagOffset = ObjectType.Versions.ObjectType_8->TypeInfo.WaitObjectFlagOffset;
                WaitObjectPointerOffset = ObjectType.Versions.ObjectType_8->TypeInfo.WaitObjectPointerOffset;
                break;
            case OBVERSION_OBJECT_TYPE_V3:
                WaitObjectFlagMask = ObjectType.Versions.ObjectType_RS1->TypeInfo.WaitObjectFlagMask;
                WaitObjectFlagOffset = ObjectType.Versions.ObjectType_RS1->TypeInfo.WaitObjectFlagOffset;
                WaitObjectPointerOffset = ObjectType.Versions.ObjectType_RS1->TypeInfo.WaitObjectPointerOffset;
                break;
            default:
                WaitObjectFlagMask = ObjectType.Versions.ObjectType_RS2->TypeInfo.WaitObjectFlagMask;
                WaitObjectFlagOffset = ObjectType.Versions.ObjectType_RS2->TypeInfo.WaitObjectFlagOffset;
                WaitObjectPointerOffset = ObjectType.Versions.ObjectType_RS2->TypeInfo.WaitObjectPointerOffset;
                break;
            }

            propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("WaitObjectFlagMask"), NULL, WaitObjectFlagMask, TRUE, FALSE, 0, 0);
            propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("WaitObjectFlagOffset"), NULL, WaitObjectFlagOffset, TRUE, TRUE, 0, 0);
            propObDumpUlong(hwndTreeList, h_tviSubItem, TEXT("WaitObjectPointerOffset"), NULL, WaitObjectPointerOffset, TRUE, TRUE, 0, 0);

        }

        //
        // Rest of OBJECT_TYPE
        //
        switch (ObjectVersion) {
        case OBVERSION_OBJECT_TYPE_V1: //7
            Key = ObjectType.Versions.ObjectType_7->Key;
            LockPtr = ObjectType.Versions.ObjectType_7->TypeLock.Ptr;
            pListEntry = &ObjectType.Versions.ObjectType_7->CallbackList;
            break;

        case OBVERSION_OBJECT_TYPE_V2: //8+
            Key = ObjectType.Versions.ObjectType_8->Key;
            LockPtr = ObjectType.Versions.ObjectType_8->TypeLock.Ptr;
            pListEntry = &ObjectType.Versions.ObjectType_8->CallbackList;
            break;

        case OBVERSION_OBJECT_TYPE_V3: //RS1
            Key = ObjectType.Versions.ObjectType_RS1->Key;
            LockPtr = ObjectType.Versions.ObjectType_RS1->TypeLock.Ptr;
            pListEntry = &ObjectType.Versions.ObjectType_RS1->CallbackList;
            break;

        default: //RS2+
            Key = ObjectType.Versions.ObjectType_RS2->Key;
            LockPtr = ObjectType.Versions.ObjectType_RS2->TypeLock.Ptr;
            pListEntry = &ObjectType.Versions.ObjectType_RS2->CallbackList;
            break;
        }

        propObDumpPushLock(hwndTreeList, h_tviRootItem, LockPtr, 0, 0);
        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("Key"), NULL, Key, TRUE, FALSE, 0, 0);
        propObDumpListEntry(hwndTreeList, h_tviRootItem, TEXT("CallbackList"), pListEntry);

        bOkay = TRUE;

    } while (FALSE);

    //
    // Cleanup.
    //
    if (ModulesList) supHeapFree(ModulesList);
    if (ObjectTypeInformation) supVirtualFree(ObjectTypeInformation);
    if (CurrentObject) supHeapFree(CurrentObject);

    //
    // Show error message on failure.
    //
    if (bOkay == FALSE) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }
}

/*
* propObDumpQueueObject
*
* Purpose:
*
* Dump KQUEUE members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpQueueObject)
{
    HTREEITEM h_tviRootItem;
    LPWSTR    lpDesc2;
    KQUEUE    Queue;

    //dump Queue object
    RtlSecureZeroMemory(&Queue, sizeof(Queue));

    if (!kdReadSystemMemory(
        Context->ObjectInfo.ObjectAddress,
        &Queue,
        sizeof(Queue)))
    {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    lpDesc2 = NULL;
    if (Queue.Header.Size == (sizeof(KQUEUE) / sizeof(ULONG))) {
        lpDesc2 = TEXT("sizeof(KQUEUE)/sizeof(ULONG)");
    }

    h_tviRootItem = supTreeListAddItem(
        hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        T_KQUEUE,
        NULL);

    //Header
    propObDumpDispatcherHeader(hwndTreeList, h_tviRootItem, &Queue.Header, NULL, NULL, lpDesc2);

    //EntryListHead
    propObDumpListEntry(hwndTreeList, h_tviRootItem, TEXT("EntryListHead"), &Queue.EntryListHead);

    //CurrentCount
    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("CurrentCount"), NULL, Queue.CurrentCount, TRUE, FALSE, 0, 0);

    //MaximumCount
    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("MaximumCount"), NULL, Queue.MaximumCount, TRUE, FALSE, 0, 0);

    //ThreadListHead
    propObDumpListEntry(hwndTreeList, h_tviRootItem, TEXT("ThreadListHead"), &Queue.ThreadListHead);

}

/*
* propObxComposeFltFilterCompatibleForm
*
* Purpose:
*
* Build easy to access object structure from different structure variants.
*
*/
VOID propObxComposeFltFilterCompatibleForm(
    _In_ PVOID ObjectBuffer,
    _In_ ULONG ObjectVersion,
    _Out_ FLT_FILTER_COMPATIBLE* ComposedObject
)
{
    union {
        union {
            FLT_FILTER_V1* V1;
            FLT_FILTER_V2* V2;
            FLT_FILTER_V3* V3;
            FLT_FILTER_V4* V4;
            FLT_FILTER_V5* V5;
        } u1;
        PBYTE Ref;
    } FltFilter;

    RtlSecureZeroMemory(ComposedObject, sizeof(FLT_FILTER_COMPATIBLE));

    FltFilter.Ref = (PBYTE)ObjectBuffer;

    if (ObjectVersion == OBVERSION_FLT_FILTER_V5)
    {
        RtlCopyMemory(&ComposedObject->Base, &FltFilter.u1.V5->Base, sizeof(FLT_OBJECT_V3));
    }
    else {
        //
        // Same offset.
        //
        RtlCopyMemory(&ComposedObject->Base, &FltFilter.u1.V1->Base, sizeof(FLT_OBJECT));

        //
        // UniqueIdentifier
        //
        if (ObjectVersion >= OBVERSION_FLT_FILTER_V3)
            ComposedObject->Base.UniqueIdentifier = FltFilter.u1.V3->Base.UniqueIdentifier;
    }

    switch (ObjectVersion) {

    case OBVERSION_FLT_FILTER_V1:
    case OBVERSION_FLT_FILTER_V2:
        ComposedObject->Frame = FltFilter.u1.V1->Frame;
        ComposedObject->Name = FltFilter.u1.V1->Name;
        ComposedObject->DefaultAltitude = FltFilter.u1.V1->DefaultAltitude;
        ComposedObject->DriverObject = FltFilter.u1.V1->DriverObject;
        ComposedObject->VerifiedFiltersLink = FltFilter.u1.V1->VerifiedFiltersLink;
        ComposedObject->FilterUnload = FltFilter.u1.V1->FilterUnload;
        ComposedObject->InstanceSetup = FltFilter.u1.V1->InstanceSetup;
        ComposedObject->InstanceQueryTeardown = FltFilter.u1.V1->InstanceQueryTeardown;
        ComposedObject->InstanceTeardownStart = FltFilter.u1.V1->InstanceTeardownStart;
        ComposedObject->InstanceTeardownComplete = FltFilter.u1.V1->InstanceTeardownComplete;
        ComposedObject->PreVolumeMount = FltFilter.u1.V1->PreVolumeMount;
        ComposedObject->PostVolumeMount = FltFilter.u1.V1->PostVolumeMount;
        ComposedObject->GenerateFileName = FltFilter.u1.V1->GenerateFileName;
        ComposedObject->NormalizeNameComponent = FltFilter.u1.V1->NormalizeNameComponent;
        ComposedObject->NormalizeNameComponentEx = FltFilter.u1.V1->NormalizeNameComponentEx;
        ComposedObject->NormalizeContextCleanup = FltFilter.u1.V1->NormalizeContextCleanup;
        ComposedObject->KtmNotification = FltFilter.u1.V1->KtmNotification;
        if (ObjectVersion == OBVERSION_FLT_FILTER_V2) {
            ComposedObject->SectionNotification = FltFilter.u1.V2->SectionNotification;
            ComposedObject->OldDriverUnload = FltFilter.u1.V2->OldDriverUnload;
        }
        else {
            ComposedObject->OldDriverUnload = FltFilter.u1.V1->OldDriverUnload;
        }

        break;

    case OBVERSION_FLT_FILTER_V3:
    case OBVERSION_FLT_FILTER_V4:
        ComposedObject->Frame = FltFilter.u1.V3->Frame;
        ComposedObject->Name = FltFilter.u1.V3->Name;
        ComposedObject->DefaultAltitude = FltFilter.u1.V3->DefaultAltitude;
        ComposedObject->DriverObject = FltFilter.u1.V3->DriverObject;
        ComposedObject->VerifiedFiltersLink = FltFilter.u1.V3->VerifiedFiltersLink;
        ComposedObject->FilterUnload = FltFilter.u1.V3->FilterUnload;
        ComposedObject->InstanceSetup = FltFilter.u1.V3->InstanceSetup;
        ComposedObject->InstanceQueryTeardown = FltFilter.u1.V3->InstanceQueryTeardown;
        ComposedObject->InstanceTeardownStart = FltFilter.u1.V3->InstanceTeardownStart;
        ComposedObject->InstanceTeardownComplete = FltFilter.u1.V3->InstanceTeardownComplete;
        ComposedObject->PreVolumeMount = FltFilter.u1.V3->PreVolumeMount;
        ComposedObject->PostVolumeMount = FltFilter.u1.V3->PostVolumeMount;
        ComposedObject->GenerateFileName = FltFilter.u1.V3->GenerateFileName;
        ComposedObject->NormalizeNameComponent = FltFilter.u1.V3->NormalizeNameComponent;
        ComposedObject->NormalizeNameComponentEx = FltFilter.u1.V3->NormalizeNameComponentEx;
        ComposedObject->NormalizeContextCleanup = FltFilter.u1.V3->NormalizeContextCleanup;
        ComposedObject->KtmNotification = FltFilter.u1.V3->KtmNotification;
        ComposedObject->SectionNotification = FltFilter.u1.V3->SectionNotification;
        ComposedObject->OldDriverUnload = FltFilter.u1.V3->OldDriverUnload;
        break;
    case OBVERSION_FLT_FILTER_V5:
    default:
        ComposedObject->Frame = FltFilter.u1.V5->Frame;
        ComposedObject->Name = FltFilter.u1.V5->Name;
        ComposedObject->DefaultAltitude = FltFilter.u1.V5->DefaultAltitude;
        ComposedObject->DriverObject = FltFilter.u1.V5->DriverObject;
        ComposedObject->VerifiedFiltersLink = FltFilter.u1.V5->VerifiedFiltersLink;
        ComposedObject->FilterUnload = FltFilter.u1.V5->FilterUnload;
        ComposedObject->InstanceSetup = FltFilter.u1.V5->InstanceSetup;
        ComposedObject->InstanceQueryTeardown = FltFilter.u1.V5->InstanceQueryTeardown;
        ComposedObject->InstanceTeardownStart = FltFilter.u1.V5->InstanceTeardownStart;
        ComposedObject->InstanceTeardownComplete = FltFilter.u1.V5->InstanceTeardownComplete;
        ComposedObject->PreVolumeMount = FltFilter.u1.V5->PreVolumeMount;
        ComposedObject->PostVolumeMount = FltFilter.u1.V5->PostVolumeMount;
        ComposedObject->GenerateFileName = FltFilter.u1.V5->GenerateFileName;
        ComposedObject->NormalizeNameComponent = FltFilter.u1.V5->NormalizeNameComponent;
        ComposedObject->NormalizeNameComponentEx = FltFilter.u1.V5->NormalizeNameComponentEx;
        ComposedObject->NormalizeContextCleanup = FltFilter.u1.V5->NormalizeContextCleanup;
        ComposedObject->KtmNotification = FltFilter.u1.V5->KtmNotification;
        ComposedObject->SectionNotification = FltFilter.u1.V5->SectionNotification;
        ComposedObject->OldDriverUnload = FltFilter.u1.V5->OldDriverUnload;
        break;
    }
}

/*
* propObxDumpFltFilter
*
* Purpose:
*
* Dump FLT_FILTER members to the treelist.
*
*/
VOID propObxDumpFltFilter(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ PVOID Address,
    _In_ PRTL_PROCESS_MODULES LoadedModules
)
{
    HTREEITEM parentSubItem, subItem;
    ULONG objectVersion, objectSize = 0;
    PVOID pvFltObject;
    TL_SUBITEMS_FIXED subitems;
    WCHAR szValue[MAX_TEXT_CONVERSION_ULONG64];

    FLT_FILTER_COMPATIBLE compatObject;

    pvFltObject = ObDumpFltFilterObjectVersionAware((ULONG_PTR)Address, &objectSize, &objectVersion);

    if (pvFltObject == NULL) {
        //
        // Cannot read, abort.
        //
        propObDumpAddress(TreeList, RootItem, T_FILTER, T_PFLT_FILTER, Address, 0, 0);
        return;
    }

    propObxComposeFltFilterCompatibleForm(pvFltObject, objectVersion, &compatObject);

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    szValue[0] = L'0';
    szValue[1] = L'x';
    szValue[2] = 0;
    u64tohex((ULONG_PTR)Address, &szValue[2]);
    subitems.Text[0] = szValue;
    subitems.Text[1] = T_PFLT_FILTER;
    subitems.Count = 2;

    parentSubItem = supTreeListAddItem(
        TreeList,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        T_FILTER,
        &subitems);

    if (parentSubItem) {

        //
        // Base (FLT_OBJECT)
        //

        RtlSecureZeroMemory(&subitems, sizeof(subitems));
        subitems.Text[0] = T_EmptyString;
        subitems.Text[1] = T_FLT_OBJECT;
        subitems.Count = 2;

        subItem = supTreeListAddItem(
            TreeList,
            parentSubItem,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            TEXT("Base"),
            &subitems);

        if (subItem) {

            propObDumpUlong(TreeList,
                subItem,
                T_FLAGS,
                NULL,
                compatObject.Base.Flags, //FLT_OBJECT_FLAGS
                TRUE, FALSE,
                (COLORREF)0,
                (COLORREF)0);

            propObDumpUlong(TreeList,
                subItem,
                TEXT("PointerCount"),
                NULL,
                compatObject.Base.PointerCount,
                TRUE, FALSE,
                (COLORREF)0,
                (COLORREF)0);

            propObDumpAddress(TreeList,
                subItem,
                TEXT("RundownRef"),
                T_EX_RUNDOWN_REF,
                compatObject.Base.RundownRef.Ptr,
                (COLORREF)0,
                (COLORREF)0);

            propObDumpListEntry(TreeList,
                subItem,
                TEXT("PrimaryLinks"),
                &compatObject.Base.PrimaryLink);

            if (objectVersion >= OBVERSION_FLT_FILTER_V3) {
                propObDumpGUID(TreeList,
                    subItem,
                    TEXT("UniqueIdentifier"),
                    &compatObject.Base.UniqueIdentifier);
            }

        } // FLT_OBJECT Base;

        //
        // Frame.
        //
        propObDumpAddress(TreeList, parentSubItem, TEXT("Frame"), T_PFLTP_FRAME, compatObject.Frame, 0, 0);

        //
        // Name.
        //        
        propObDumpUnicodeString(TreeList,
            parentSubItem,
            TEXT("Name"),
            &compatObject.Name,
            FALSE);

        //
        // DefaultAltitude.
        //
        propObDumpUnicodeString(TreeList,
            parentSubItem,
            TEXT("DefaultAltitude"),
            &compatObject.DefaultAltitude,
            FALSE);

        //
        // DriverObject.
        //
        propDumpObjectForAddress(TreeList,
            parentSubItem,
            T_FIELD_DRIVER_OBJECT,
            compatObject.DriverObject,
            CLR_INVL,
            T_REFNOTFOUND);

        if (compatObject.FilterUnload) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("FilterUnload"),
                compatObject.FilterUnload,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.InstanceSetup) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("InstanceSetup"),
                compatObject.InstanceSetup,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.InstanceQueryTeardown) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("InstanceQueryTeardown"),
                compatObject.InstanceQueryTeardown,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.InstanceTeardownStart) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("InstanceTeardownStart"),
                compatObject.InstanceTeardownStart,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.InstanceTeardownComplete) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("InstanceTeardownComplete"),
                compatObject.InstanceTeardownComplete,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.PreVolumeMount) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("PreVolumeMount"),
                compatObject.PreVolumeMount,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.PostVolumeMount) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("PostVolumeMount"),
                compatObject.PostVolumeMount,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.GenerateFileName) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("GenerateFileName"),
                compatObject.GenerateFileName,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.NormalizeNameComponent) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("NormalizeNameComponent"),
                compatObject.NormalizeNameComponent,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.NormalizeNameComponentEx) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("NormalizeNameComponentEx"),
                compatObject.NormalizeNameComponentEx,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.NormalizeContextCleanup) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("NormalizeContextCleanup"),
                compatObject.NormalizeContextCleanup,
                LoadedModules,
                NULL, 0);
        }

        if (compatObject.KtmNotification) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("KtmNotification"),
                compatObject.KtmNotification,
                LoadedModules,
                NULL, 0);
        }


        if (compatObject.SectionNotification) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("SectionNotification"),
                compatObject.SectionNotification,
                LoadedModules,
                NULL, 0);
        }


        if (compatObject.OldDriverUnload) {
            propObDumpAddressWithModule(TreeList,
                parentSubItem,
                TEXT("OldDriverUnload"),
                compatObject.OldDriverUnload,
                LoadedModules,
                NULL, 0);
        }

    }

    supVirtualFree(pvFltObject);
}

/*
* propObDumpFltServerPort
*
* Purpose:
*
* Dump FLT_SERVER_PORT_OBJECT members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpFltServerPort)
{
    HTREEITEM h_tviRootItem;
    PRTL_PROCESS_MODULES pModules = NULL;
    FLT_SERVER_PORT_OBJECT FltServerPortObject;

    //dump PortObject
    RtlSecureZeroMemory(&FltServerPortObject, sizeof(FltServerPortObject));

    if (!kdReadSystemMemory(
        Context->ObjectInfo.ObjectAddress,
        &FltServerPortObject,
        sizeof(FltServerPortObject)))
    {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    pModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
    if (pModules) {

        h_tviRootItem = supTreeListAddItem(
            hwndTreeList,
            NULL,
            TVIF_TEXT | TVIF_STATE,
            TVIS_EXPANDED,
            TVIS_EXPANDED,
            T_FLT_SERVER_PORT_OBJECT,
            NULL);

        if (h_tviRootItem) {

            propObDumpListEntry(hwndTreeList, h_tviRootItem, L"FilterLink", &FltServerPortObject.FilterLink);

            propObDumpAddressWithModule(hwndTreeList, h_tviRootItem, L"ConnectNotify",
                FltServerPortObject.ConnectNotify, pModules, NULL, 0);

            propObDumpAddressWithModule(hwndTreeList, h_tviRootItem, L"DisconnectNotify",
                FltServerPortObject.DisconnectNotify, pModules, NULL, 0);

            propObDumpAddressWithModule(hwndTreeList, h_tviRootItem, L"MessageNotify",
                FltServerPortObject.MessageNotify, pModules, NULL, 0);

            propObxDumpFltFilter(hwndTreeList, h_tviRootItem, FltServerPortObject.Filter, pModules);

            propObDumpAddress(hwndTreeList, h_tviRootItem, L"Cookie", NULL, FltServerPortObject.Cookie, 0, 0);
            propObDumpUlong(hwndTreeList, h_tviRootItem, L"Flags", NULL, FltServerPortObject.Flags, TRUE, FALSE, 0, 0);
            propObDumpLong(hwndTreeList, h_tviRootItem, L"NumberOfConnections", NULL, FltServerPortObject.NumberOfConnections, TRUE, 0, 0);
            propObDumpLong(hwndTreeList, h_tviRootItem, L"MaxConnections", NULL, FltServerPortObject.MaxConnections, TRUE, 0, 0);

        }

        supHeapFree(pModules);
    }
    else {
        supObDumpShowError(hwndDlg, NULL);
    }
}

/*
* propObxDumpAlpcPortCommunicationInfo
*
* Purpose:
*
* Dump ALPC_PORT->CommunicationInfo substructure to the treelist.
*
*/
VOID propObxDumpAlpcPortCommunicationInfo(
    _In_ HWND TreeList,
    _In_ ULONG StructureVersion,
    _In_ ULONG_PTR StructureAddress,
    _In_ HTREEITEM h_tviRootItem
)
{
    HTREEITEM h_tviSubItem;
    PBYTE dumpBuffer = NULL;
    ULONG bufferSize = 0, readSize = 0;

    union {
        union {
            ALPC_COMMUNICATION_INFO_V1* CommInfoV1;
            ALPC_COMMUNICATION_INFO_V2* CommInfoV2;
        } u1;
        PBYTE Ref;
    } AlpcPortCommunicationInfo;

    if ((StructureVersion == 0) || (StructureVersion > 2)) return;

    if (StructureVersion == 1) {
        bufferSize = sizeof(ALPC_COMMUNICATION_INFO_V1);
    }
    else {
        bufferSize = sizeof(ALPC_COMMUNICATION_INFO_V2);
    }

    readSize = bufferSize;
    bufferSize = ALIGN_UP_BY(bufferSize, PAGE_SIZE);
    dumpBuffer = (PBYTE)supVirtualAlloc(bufferSize);
    if (dumpBuffer == NULL)
        return;

    if (!kdReadSystemMemory(
        StructureAddress,
        dumpBuffer,
        readSize))
    {
        supVirtualFree(dumpBuffer);
        return;
    }

    AlpcPortCommunicationInfo.Ref = dumpBuffer;

    //
    // Dump version unaffected fields.
    //
    propObDumpAddress(
        TreeList,
        h_tviRootItem,
        TEXT("ConnectionPort"),
        T_PALPC_PORT_OBJECT,
        (PVOID)AlpcPortCommunicationInfo.u1.CommInfoV1->ConnectionPort,
        0,
        0);

    propObDumpAddress(
        TreeList,
        h_tviRootItem,
        TEXT("ServerCommunicationPort"),
        T_PALPC_PORT_OBJECT,
        (PVOID)AlpcPortCommunicationInfo.u1.CommInfoV1->ServerCommunicationPort,
        0,
        0);

    propObDumpAddress(
        TreeList,
        h_tviRootItem,
        TEXT("ClientCommunicationPort"),
        T_PALPC_PORT_OBJECT,
        (PVOID)AlpcPortCommunicationInfo.u1.CommInfoV1->ClientCommunicationPort,
        0,
        0);

    propObDumpListEntry(
        TreeList,
        h_tviRootItem,
        TEXT("CommunicationList"),
        &AlpcPortCommunicationInfo.u1.CommInfoV1->CommunicationList);

    //
    //  PALPC_HANDLE_ENTRY dump.
    //
    h_tviSubItem = supTreeListAddItem(
        TreeList,
        h_tviRootItem,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        T_ALPC_HANDLE_TABLE,
        NULL);

    propObDumpAddress(
        TreeList,
        h_tviSubItem,
        TEXT("Handles"),
        TEXT("PALPC_HANDLE_ENTRY"),
        (PVOID)AlpcPortCommunicationInfo.u1.CommInfoV1->HandleTable.Handles,
        0,
        0);

    propObDumpUlong(
        TreeList,
        h_tviSubItem,
        TEXT("TotalHandles"),
        NULL,
        AlpcPortCommunicationInfo.u1.CommInfoV1->HandleTable.TotalHandles,
        TRUE,
        FALSE,
        0,
        0);

    propObDumpUlong(
        TreeList,
        h_tviSubItem,
        TEXT("Flags"),
        NULL,
        AlpcPortCommunicationInfo.u1.CommInfoV1->HandleTable.Flags,
        TRUE,
        FALSE,
        0,
        0);

    propObDumpPushLock(
        TreeList,
        h_tviSubItem,
        AlpcPortCommunicationInfo.u1.CommInfoV1->HandleTable.Lock.Ptr,
        0,
        0);

    //
    // Version specific field.
    //
    if (StructureVersion == 2) {
        propObDumpAddress(
            TreeList,
            h_tviRootItem,
            TEXT("CloseMessage"),
            TEXT("PKALPC_MESSAGE"),
            (PVOID)AlpcPortCommunicationInfo.u1.CommInfoV2->CloseMessage,
            0,
            0);
    }
    supVirtualFree(dumpBuffer);
}

/*
* propObDumpAlpcPort
*
* Purpose:
*
* Dump ALPC_PORT members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpAlpcPort)
{
    ULONG BufferSize = 0, ObjectVersion = 0, i, c;
    HTREEITEM h_tviRootItem, h_tviSubItem;

    PBYTE PortDumpBuffer = NULL;
    ALPC_PORT_ATTRIBUTES* PortAttributes;
    ALPC_PORT_STATE PortState;
    TL_SUBITEMS_FIXED subitems;

    WCHAR szValue[32];

    union {
        union {
            ALPC_PORT_7600* Port7600;
            ALPC_PORT_9200* Port9200;
            ALPC_PORT_9600* Port9600;
            ALPC_PORT_10240* Port10240;
        } u1;
        PBYTE Ref;
    } AlpcPort;

    PortDumpBuffer = (PBYTE)ObDumpAlpcPortObjectVersionAware(
        Context->ObjectInfo.ObjectAddress,
        &BufferSize,
        &ObjectVersion);

    if (PortDumpBuffer == NULL) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    AlpcPort.Ref = PortDumpBuffer;

    h_tviRootItem = supTreeListAddItem(
        hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        T_ALPC_PORT_OBJECT,
        NULL);

    //
    //  Dump AlpcPort->PortListEntry, same offset for every supported Windows.
    //   
    propObDumpListEntry(
        hwndTreeList,
        h_tviRootItem,
        TEXT("PortListEntry"),
        &AlpcPort.u1.Port7600->PortListEntry);

    //
    //  Dump AlpcPort->CommunicationInfo, same offset for every supported Windows, however target structure is version aware.
    // 

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;

    szValue[0] = L'0';
    szValue[1] = L'x';
    szValue[2] = 0;
    u64tohex((ULONG_PTR)AlpcPort.u1.Port7600->CommunicationInfo, &szValue[2]);
    subitems.Text[0] = szValue;
    subitems.Text[1] = TEXT("PALPC_COMMUNICATION_INFO");

    h_tviSubItem = supTreeListAddItem(
        hwndTreeList,
        h_tviRootItem,
        TVIF_TEXT,
        0,
        0,
        TEXT("CommunicationInfo"),
        &subitems);

    propObxDumpAlpcPortCommunicationInfo(hwndTreeList,
        (ObjectVersion > OBVERSION_ALPCPORT_V2) ? 2 : 1,
        (ULONG_PTR)AlpcPort.u1.Port7600->CommunicationInfo,
        h_tviSubItem);

    //
    //  Dump AlpcPort->OwnerProcess, same offset for every supported Windows, however target structure is version aware.
    //
    propObDumpAddress(
        hwndTreeList,
        h_tviRootItem,
        TEXT("Owner"),
        TEXT("PEPROCESS"),
        (PVOID)AlpcPort.u1.Port7600->OwnerProcess,
        0,
        0);

    //
    //  Dump AlpcPort->CompletionPort, same offset for every supported Windows.
    //
    propObDumpAddress(
        hwndTreeList,
        h_tviRootItem,
        TEXT("CompletionPort"),
        NULL,
        (PVOID)AlpcPort.u1.Port7600->CompletionPort,
        0,
        0);

    //
    //  Dump AlpcPort->CompletionKey, same offset for every supported Windows.
    //
    propObDumpAddress(
        hwndTreeList,
        h_tviRootItem,
        TEXT("CompletionKey"),
        NULL,
        (PVOID)AlpcPort.u1.Port7600->CompletionKey,
        0,
        0);

    //
    //  Dump AlpcPort->CompletionPacketLookaside, same offset for every supported Windows, however target structure is version aware.
    //
    propObDumpAddress(
        hwndTreeList,
        h_tviRootItem,
        TEXT("CompletionPacketLookaside"),
        TEXT("PALPC_COMPLETION_PACKET_LOOKASIDE"),
        (PVOID)AlpcPort.u1.Port7600->CompletionPacketLookaside,
        0,
        0);

    //
    //  Dump AlpcPort->PortContext, same offset for every supported Windows.
    //
    propObDumpAddress(
        hwndTreeList,
        h_tviRootItem,
        TEXT("PortContext"),
        NULL,
        (PVOID)AlpcPort.u1.Port7600->PortContext,
        0,
        0);

    //
    //  Dump AlpcPort->StaticSecurity, same offset for every supported Windows.
    //
    /*
    propObDumpSqos(
        hwndTreeList,
        h_tviRootItem,
        &AlpcPort.u1.Port7600->StaticSecurity.SecurityQos);
    */

    //
    // Dump AlpcPort->PortAttributes, offset is version aware.
    //
    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = T_EmptyString;
    subitems.Text[1] = TEXT("ALPC_PORT_ATTRIBUTES");

    h_tviSubItem = supTreeListAddItem(
        hwndTreeList,
        h_tviRootItem,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        TEXT("PortAttributes"),
        &subitems);

    switch (ObjectVersion) {
    case OBVERSION_ALPCPORT_V1:
        PortAttributes = &AlpcPort.u1.Port7600->PortAttributes;
        break;
    case OBVERSION_ALPCPORT_V2:
        PortAttributes = &AlpcPort.u1.Port9200->PortAttributes;
        break;
    case OBVERSION_ALPCPORT_V3:
        PortAttributes = &AlpcPort.u1.Port9600->PortAttributes;
        break;
    case OBVERSION_ALPCPORT_V4:
        PortAttributes = &AlpcPort.u1.Port10240->PortAttributes;
        break;
    default:
        PortAttributes = NULL;
        break;
    }

    if (PortAttributes) {

        propObDumpUlong(
            hwndTreeList,
            h_tviSubItem,
            T_FLAGS,
            NULL,
            PortAttributes->Flags,
            TRUE,
            FALSE,
            0,
            0);

        propObDumpSqos(
            hwndTreeList,
            h_tviSubItem,
            &PortAttributes->SecurityQos);

        propObDumpUlong64(
            hwndTreeList,
            h_tviSubItem,
            TEXT("MaxMessageLength"),
            NULL,
            (ULONG64)PortAttributes->MaxMessageLength,
            FALSE,
            0,
            0);

        propObDumpUlong64(
            hwndTreeList,
            h_tviSubItem,
            TEXT("MemoryBandwidth"),
            NULL,
            (ULONG64)PortAttributes->MemoryBandwidth,
            FALSE,
            0,
            0);

        propObDumpUlong64(
            hwndTreeList,
            h_tviSubItem,
            TEXT("MaxPoolUsage"),
            NULL,
            (ULONG64)PortAttributes->MaxPoolUsage,
            FALSE,
            0,
            0);

        propObDumpUlong64(
            hwndTreeList,
            h_tviSubItem,
            TEXT("MaxSectionSize"),
            NULL,
            (ULONG64)PortAttributes->MaxSectionSize,
            FALSE,
            0,
            0);

        propObDumpUlong64(
            hwndTreeList,
            h_tviSubItem,
            TEXT("MaxViewSize"),
            NULL,
            (ULONG64)PortAttributes->MaxViewSize,
            FALSE,
            0,
            0);

        propObDumpUlong64(
            hwndTreeList,
            h_tviSubItem,
            TEXT("MaxTotalSectionSize"),
            NULL,
            (ULONG64)PortAttributes->MaxTotalSectionSize,
            FALSE,
            0,
            0);

        propObDumpUlong(
            hwndTreeList,
            h_tviSubItem,
            TEXT("DupObjectTypes"),
            NULL,
            PortAttributes->DupObjectTypes,
            FALSE,
            FALSE,
            0,
            0);
    }

    //
    // Dump AlpcPort->State, offset is version aware.
    //
    h_tviSubItem = supTreeListAddItem(
        hwndTreeList,
        h_tviRootItem,
        TVIF_TEXT,
        0,
        0,
        TEXT("State"),
        NULL);

    PortState.State = 0;

    switch (ObjectVersion) {
    case OBVERSION_ALPCPORT_V1:
        PortState.State = AlpcPort.u1.Port7600->u1.State;
        break;
    case OBVERSION_ALPCPORT_V2:
        PortState.State = AlpcPort.u1.Port9200->u1.State;
        break;
    case OBVERSION_ALPCPORT_V3:
        PortState.State = AlpcPort.u1.Port9600->u1.State;
        break;
    case OBVERSION_ALPCPORT_V4:
        PortState.State = AlpcPort.u1.Port10240->u1.State;
        break;
    }

    for (i = 0; i < RTL_NUMBER_OF(T_ALPC_PORT_STATE); i++) {
        if (i == 1) {
            c = (BYTE)PortState.s1.Type;
        }
        else {
            c = GET_BIT(PortState.State, i);
        }
        propObDumpByte(
            hwndTreeList,
            h_tviSubItem,
            T_ALPC_PORT_STATE[i],
            NULL,
            (BYTE)c,
            0,
            0,
            FALSE);

    }
    supVirtualFree(PortDumpBuffer);
}

/*
* propObDumpCallback
*
* Purpose:
*
* Dump CALLBACK_OBJECT callback members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpCallback)
{
    SIZE_T Count;
    ULONG_PTR ListHead;
    HTREEITEM h_tviRootItem;

    LIST_ENTRY ListEntry;

    PRTL_PROCESS_MODULES Modules;

    CALLBACK_OBJECT ObjectDump;
    CALLBACK_REGISTRATION CallbackRegistration;

    UNICODE_STRING NormalizedName;
    LPWSTR ObjectName;

    //
    // Read object body.
    //
    RtlSecureZeroMemory(&ObjectDump, sizeof(CALLBACK_OBJECT));

    if (!kdReadSystemMemory(
        Context->ObjectInfo.ObjectAddress,
        (PVOID)&ObjectDump,
        sizeof(ObjectDump)))
    {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //
    // Verify object signature.
    //
    if (ObjectDump.Signature != EX_CALLBACK_SIGNATURE) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //
    // Create a snapshot list of loaded modules.
    //
    Modules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
    if (Modules == NULL) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    //
    // Add root item to the treelist in expanded state.
    //
    h_tviRootItem = supTreeListAddItem(
        hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        TEXT("Callbacks"),
        NULL);

    //
    // Walk RegisteredCallback list entry.
    //
    ListHead = Context->ObjectInfo.ObjectAddress + FIELD_OFFSET(CALLBACK_OBJECT, RegisteredCallbacks);
    ListEntry.Flink = ObjectDump.RegisteredCallbacks.Flink;
    Count = 0;

    if (supNormalizeUnicodeStringForDisplay(g_obexHeap, &Context->NtObjectName, &NormalizedName)) {
        ObjectName = NormalizedName.Buffer;
    }
    else {
        ObjectName = Context->NtObjectName.Buffer;
    }

    while ((ULONG_PTR)ListEntry.Flink != ListHead) {

        //
        // Read callback registration data.
        //
        RtlSecureZeroMemory(&CallbackRegistration, sizeof(CallbackRegistration));
        if (!kdReadSystemMemory((ULONG_PTR)ListEntry.Flink,
            (PVOID)&CallbackRegistration,
            sizeof(CallbackRegistration)))
        {
            //
            // Abort all output on error.
            //
            supObDumpShowError(hwndDlg, NULL);
            break;
        }

        Count += 1;
        ListEntry.Flink = CallbackRegistration.Link.Flink;

        propObDumpAddressWithModule(hwndTreeList,
            h_tviRootItem,
            ObjectName,
            CallbackRegistration.CallbackFunction,
            Modules,
            NULL,
            0);
    }

    //
    // If nothing found (or possible query error) output this message.
    //
    if (Count == 0) {
        supObDumpShowError(hwndDlg,
            TEXT("This object has no registered callbacks or there is an query error."));
    }

    supFreeDuplicatedUnicodeString(g_obexHeap, &NormalizedName, FALSE);
    supHeapFree(Modules);
}

/*
* propObDumpSymbolicLink
*
* Purpose:
*
* Dump OBJECT_SYMBOLIC_LINK members to the treelist.
*
*/
PROP_OBJECT_DUMP_ROUTINE(propObDumpSymbolicLink)
{
    BOOLEAN IsCallbackLink = FALSE;
    HTREEITEM h_tviRootItem;

    LPWSTR IntegrityLevelString;

    PBYTE SymLinkDumpBuffer = NULL;

    ULONG BufferSize = 0, ObjectVersion = 0;

    TL_SUBITEMS_FIXED subitems;

    PRTL_PROCESS_MODULES pModules;

    union {
        union {
            OBJECT_SYMBOLIC_LINK_V1* LinkV1;
            OBJECT_SYMBOLIC_LINK_V2* LinkV2;
            OBJECT_SYMBOLIC_LINK_V3* LinkV3;
            OBJECT_SYMBOLIC_LINK_V4* LinkV4;
            OBJECT_SYMBOLIC_LINK_V5* LinkV5;
        } u1;
        PBYTE Ref;
    } SymbolicLink;

    WCHAR szTime[64], szConvert[64];


    SymLinkDumpBuffer = (PBYTE)ObDumpSymbolicLinkObjectVersionAware(
        Context->ObjectInfo.ObjectAddress,
        &BufferSize,
        &ObjectVersion);

    if (SymLinkDumpBuffer == NULL) {
        supObDumpShowError(hwndDlg, NULL);
        return;
    }

    SymbolicLink.Ref = SymLinkDumpBuffer;

    //
    // Add root item to the treelist in expanded state.
    //
    h_tviRootItem = supTreeListAddItem(
        hwndTreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        T_OBJECT_SYMBOLIC_LINK,
        NULL);

    //
    // Output CreationTime.
    //
    szTime[0] = 0;
    supPrintTimeConverted(&SymbolicLink.u1.LinkV1->CreationTime, szTime, RTL_NUMBER_OF(szTime));

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    szConvert[0] = TEXT('0');
    szConvert[1] = TEXT('x');
    szConvert[2] = 0;
    u64tohex((ULONG64)SymbolicLink.u1.LinkV1->CreationTime.QuadPart, &szConvert[2]);

    subitems.Count = 2;
    subitems.Text[0] = szConvert;
    subitems.Text[1] = szTime;

    supTreeListAddItem(
        hwndTreeList,
        h_tviRootItem,
        TVIF_TEXT,
        0,
        0,
        TEXT("CreationTime"),
        &subitems);

    if (ObjectVersion > OBVERSION_OBJECT_SYMBOLIC_LINK_V3) {
        IsCallbackLink = (SymbolicLink.u1.LinkV4->Flags & 0x10);
    }

    if (IsCallbackLink) {

        pModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(NULL);
        if (pModules) {

            propObDumpAddressWithModule(hwndTreeList, h_tviRootItem, TEXT("Callback"),
                SymbolicLink.u1.LinkV4->u1.Callback, pModules, NULL, 0);

            supHeapFree(pModules);
        }
        else {

            propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("Callback"), NULL,
                SymbolicLink.u1.LinkV4->u1.Callback, 0, 0);

        }

        propObDumpAddress(hwndTreeList, h_tviRootItem, TEXT("CallbackContext"), NULL,
            SymbolicLink.u1.LinkV4->u1.CallbackContext, 0, 0);
    }
    else {
        propObDumpUnicodeString(hwndTreeList, h_tviRootItem, TEXT("LinkTarget"), &SymbolicLink.u1.LinkV1->LinkTarget, FALSE);
    }

    propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("DosDeviceDriveIndex"), NULL, SymbolicLink.u1.LinkV1->DosDeviceDriveIndex, TRUE, FALSE, 0, 0);

    //
    // Output new Windows 10 values.
    //
    if (ObjectVersion > OBVERSION_OBJECT_SYMBOLIC_LINK_V1)
        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("Flags"), NULL,
            SymbolicLink.u1.LinkV2->Flags, TRUE, FALSE, 0, 0);

    if (ObjectVersion > OBVERSION_OBJECT_SYMBOLIC_LINK_V2)
        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("AccessMask"), NULL,
            SymbolicLink.u1.LinkV3->AccessMask, TRUE, FALSE, 0, 0);

    if (ObjectVersion > OBVERSION_OBJECT_SYMBOLIC_LINK_V4) {
        IntegrityLevelString = supIntegrityToString(SymbolicLink.u1.LinkV5->IntegrityLevel);

        propObDumpUlong(hwndTreeList, h_tviRootItem, TEXT("IntegrityLevel"), IntegrityLevelString,
            SymbolicLink.u1.LinkV5->IntegrityLevel, TRUE, FALSE, 0, 0);
    }

    supVirtualFree(SymLinkDumpBuffer);
}

/*
* ObjectDumpOnInit
*
* Purpose:
*
* Object window WM_INITDIALOG handler.
*
* Show load banner and proceed with actual info dump.
*
*/
INT_PTR ObjectDumpOnInit(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    OBJECT_DUMP_DLG_CONTEXT* pvDlgContext;
    pfnObDumpRoutine ObDumpRoutine = NULL;
    PROP_OBJECT_INFO* Context = NULL;
    PROPSHEETPAGE* pSheet = (PROPSHEETPAGE*)lParam;

    Context = (PROP_OBJECT_INFO*)pSheet->lParam;
    if (Context == NULL)
        return 1;

    //
    // Allocate dlg context to hold specific window data.
    //
    pvDlgContext = (OBJECT_DUMP_DLG_CONTEXT*)supHeapAlloc(sizeof(OBJECT_DUMP_DLG_CONTEXT));
    if (pvDlgContext == NULL)
        return 1;

    pvDlgContext->tlSubItemHit = -1;
    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pvDlgContext);

    switch (Context->ObjectTypeIndex) {

    case ObjectTypeDirectory:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpDirectoryObject;
        break;

    case ObjectTypeDriver:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpDriverObject;
        break;

    case ObjectTypeDevice:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpDeviceObject;
        break;

    case ObjectTypeEvent:
    case ObjectTypeMutant:
    case ObjectTypeSemaphore:
    case ObjectTypeTimer:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpSyncObject;
        break;

    case ObjectTypePort:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpAlpcPort;
        break;

    case ObjectTypeIoCompletion:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpQueueObject;
        break;

    case ObjectTypeFltConnPort:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpFltServerPort;
        break;

    case ObjectTypeCallback:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpCallback;
        break;

    case ObjectTypeSymbolicLink:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpSymbolicLink;
        break;

    case ObjectTypeType:
        ObDumpRoutine = (pfnObDumpRoutine)propObDumpObjectType;
        break;

    default:
        ObDumpRoutine = NULL;
        break;
    }

    if (ObDumpRoutine) {

        //
        // Initialize treelist, abort on error.
        //
        if (supInitTreeListForDump(hwndDlg, &pvDlgContext->TreeList)) {
            supTreeListEnableRedraw(pvDlgContext->TreeList, FALSE);

            ObDumpRoutine(Context, hwndDlg, pvDlgContext->TreeList);

            supTreeListEnableRedraw(pvDlgContext->TreeList, TRUE);
        }
        else {
            supObDumpShowError(hwndDlg, NULL);
        }
    }

    return 1;
}

/*
* ObjectDumpOnDestroy
*
* Purpose:
*
* Object window WM_DESTROY handler.
*
*/
VOID ObjectDumpOnDestroy(
    _In_ HWND hwndDlg
)
{
    OBJECT_DUMP_DLG_CONTEXT* pDlgContext;

    pDlgContext = (OBJECT_DUMP_DLG_CONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
    if (pDlgContext) {
        DestroyWindow(pDlgContext->TreeList);
        supHeapFree(pDlgContext);
    }

}

/*
* ObjectDumpOnWMCommand
*
* Purpose:
*
* Object window WM_COMMAND handler.
*
*/
VOID ObjectDumpOnWMCommand(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    OBJECT_DUMP_DLG_CONTEXT* pvDlgContext;

    UNREFERENCED_PARAMETER(lParam);

    pvDlgContext = (OBJECT_DUMP_DLG_CONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
    if (pvDlgContext == NULL)
        return;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case ID_OBJECT_COPY:

        supTreeListCopyItemValueToClipboard(pvDlgContext->TreeList,
            pvDlgContext->tlSubItemHit);

        break;
    }
}

/*
* ObjectDumpOnWMContextMenu
*
* Purpose:
*
* Object window WM_CONTEXTMENU handler.
*
*/
VOID ObjectDumpOnWMContextMenu(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    OBJECT_DUMP_DLG_CONTEXT* pvDlgContext;

    pvDlgContext = (OBJECT_DUMP_DLG_CONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
    if (pvDlgContext == NULL)
        return;

    supObjectDumpHandlePopupMenu(hwndDlg,
        pvDlgContext->TreeList,
        &pvDlgContext->tlSubItemHit,
        lParam);
}

/*
* ObjectDumpDialogProc
*
* Purpose:
*
* Object window procedure and object dump select.
*
*/
INT_PTR CALLBACK ObjectDumpDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    switch (uMsg) {

    case WM_CONTEXTMENU:
        ObjectDumpOnWMContextMenu(hwndDlg, lParam);
        break;

    case WM_COMMAND:
        ObjectDumpOnWMCommand(hwndDlg, wParam, lParam);
        break;

    case WM_DESTROY:
        ObjectDumpOnDestroy(hwndDlg);
        break;

    case WM_INITDIALOG:

        return ObjectDumpOnInit(
            hwndDlg,
            lParam);

    }
    return 0;
}

```

`Source/WinObjEx64/props/propObjectDumpConsts.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPOBJECTDUMPCONSTS.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Consts header file for structured object dumps.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once


#define CLR_HOOK 0x80ff80 //light green
#define CLR_WARN 0x5050ff //red
#define CLR_INVL 0xa9a9a9 //silver
#define CLR_LGRY 0xd3d3d3 //light grey

#define FORMAT_HEXBYTE      L"0x%02X"
#define FORMAT_HEXUSHORT    L"0x%04X"
#define FORMAT_HEXDWORD     L"0x%08X"
#define FORMAT_HEXLONG      L"0x%08lX"
#define FORMAT_ULONG        L"%u"
#define FORMAT_USHORT       L"%04u"
#define FORMAT_POINTER      L"0x%p"
#define T_NULL              L"NULL"
#define T_UNNAMED           L"Unnamed"

#define T_GUID                      L"GUID"

#define T_LIST_ENTRY                L"LIST_ENTRY"
#define T_PLIST_ENTRY               L"PLIST_ENTRY"

#define T_LDR_DATA_TABLE_ENTRY      L"LDR_DATA_TABLE_ENTRY"
#define T_PLDR_DATA_TABLE_ENTRY     L"PLDR_DATA_TABLE_ENTRY"

#define T_EX_PUSH_LOCK              L"EX_PUSH_LOCK"

#define T_OBJ_INVALID_SESSION_ID    L"OBJ_INVALID_SESSION_ID"

#define T_POBJECT_DIRECTORY_ENTRY   L"POBJECT_DIRECTORY_ENTRY"
#define T_POBJECT_DIRECTORY         L"POBJECT_DIRECTORY"
#define T_OBJECT_DIRECTORY          L"OBJECT_DIRECTORY"

#define T_OBJECT_TYPE               L"OBJECT_TYPE"
#define T_OBJECT_TYPE_INITIALIZER   L"OBJECT_TYPE_INITIALIZER"

#define T_PFAST_IO_DISPATCH         L"PFAST_IO_DISPATCH"

#define T_PDEVICE_MAP               L"PDEVICE_MAP"

#define T_PUNICODE_STRING           L"PUNICODE_STRING"
#define T_UNICODE_STRING            L"UNICODE_STRING"

#define T_PKTHREAD                  L"PKTHREAD"
#define T_PEPROCESS                 L"PEPROCESS"

#define T_KEVENT                    L"KEVENT"
#define T_KMUTANT                   L"KMUTANT"
#define T_KSEMAPHORE                L"KSEMAPHORE"
#define T_KTIMER                    L"KTIMER"
#define T_KQUEUE                    L"KQUEUE"
#define T_PKDPC                     L"PKDPC"

#define T_GENERIC_MAPPING           L"GENERIC_MAPPING"

#define T_EX_RUNDOWN_REF            L"EX_RUNDOWN_REF"

#define T_PEJOB                     L"PEJOB"

#define T_PDRIVER_EXTENSION         L"PDRIVER_EXTENSION"

#define T_PCONTROL_AREA             L"PCONTROL_AREA"
#define T_PSEGMENT                  L"PSEGMENT"
#define T_PMI_REVERSE_VIEW_MAP      L"PMI_REVERSE_VIEW_MAP"
#define T_SEGMENT_FLAGS             L"SEGMENT_FLAGS"

#define T_PFILE_OBJECT              L"PFILE_OBJECT"
#define T_PDRIVER_OBJECT            L"PDRIVER_OBJECT"

#define T_FILTER                    L"Filter"
#define T_FLT_SERVER_PORT_OBJECT    L"FLT_SERVER_PORT_OBJECT"
#define T_PFLT_FILTER               L"PFLT_FILTER"
#define T_FLT_OBJECT                L"FLT_OBJECT"
#define T_PFLTP_FRAME               L"PFLTP_FRAME"
#define T_FLT_FILTER_FLAGS          L"FLT_FILTER_FLAGS"
#define T_FLT_RESOURCE_LIST_HEAD    L"FLT_RESOURCE_LIST_HEAD"
#define T_PFLT_VERIFIER_EXTENSION   L"PFLT_VERIFIER_EXTENSION"
#define T_PALLOCATE_CONTEXT_HEADER  L"PALLOCATE_CONTEXT_HEADER"
#define T_FLT_MUTEX_LIST_HEAD       L"FLT_MUTEX_LIST_HEAD"

#define T_OBJECT_SYMBOLIC_LINK      L"OBJECT_SYMBOLIC_LINK"

#define T_ALPC_PORT_OBJECT          L"ALPC_PORT"
#define T_PALPC_PORT_OBJECT         L"PALPC_PORT"
#define T_ALPC_HANDLE_TABLE         L"ALPC_HANDLE_TABLE"

#define T_EVENT_NOTIFICATION        L"NotificationEvent"
#define T_EVENT_SYNC                L"SynchronizationEvent"
#define T_SIGNALED                  L"Signaled"
#define T_NONSIGNALED               L"Nonsignaled"

#define T_OBJECT_TYPE_FLAGS         L"ObjectTypeFlags"
#define T_OBJECT_TYPE_FLAGS2        L"ObjectTypeFlags2"

#define T_FIELD_SHADOW_DIRECTORY    L"ShadowDirectory"
#define T_FIELD_DEVICE_MAP          L"DeviceMap"
#define T_FIELD_DRIVER_EXTENSION    L"DriverExtension"
#define T_FIELD_DRIVER_OBJECT       L"DriverObject"

#define T_FIELD_SERVICE_KEYNAME     L"ServiceKeyName"

#define T_DRIVEMAP                  L"DriveMap"
#define T_DRIVETYPE                 L"DriveType"
#define T_REFERENCECOUNT            L"ReferenceCount"
#define T_SERVERSILO                L"ServerSilo"

#define T_TIMER_NOTIFICATION        L"NotificationTimer"
#define T_TIMER_SYNC                L"SynchronizationTimer"
#define T_CHARACTERISTICS           L"Characteristics"
#define T_FLAGS                     L"Flags"
#define T_LENGTH                    L"Length"
#define T_MAXIMUMLENGTH             L"MaximumLength"
#define T_BUFFER                    L"Buffer"
#define T_TYPEINDEX                 L"Index"
#define T_REFNOTFOUND               L"! Reference not found"
#define T_BADDRIVEROBJECT           L"! Bad DRIVER_OBJECT"
#define T_INVALID_REQUEST           L"nt!IopInvalidDeviceRequest"

#define T_PMI_SECTION_IMAGE_INFORMATION L"PMI_SECTION_IMAGE_INFORMATION"
#define T_PFLT_OPERATION_REGISTRATION L"PFLT_OPERATION_REGISTRATION"
#define T_EX_PUSH_LOCK_AUTO_EXPAND L"EX_PUSH_LOCK_AUTO_EXPAND"

#define T_DEVICEMAP_DOSDEVICESDIRECTORY L"DosDevicesDirectory"
#define T_DEVICEMAP_GLOBALDOSDEVICESDIRECTORY L"GlobalDosDevicesDirectory"
#define T_DEVICEMAP_DOSDEVICESDIRECTORYHANDLE L"DosDevicesDirectoryHandle"

#define MAX_KNONW_FLTOBJ_FLAGS 5
static VALUE_DESC fltObjFlags[MAX_KNONW_FLTOBJ_FLAGS] = {
    { L"FLT_OBFL_DRAINING", FLT_OBFL_DRAINING },
    { L"FLT_OBFL_ZOMBIED", FLT_OBFL_ZOMBIED },
    { L"FLT_OBFL_TYPE_INSTANCE", FLT_OBFL_TYPE_INSTANCE },
    { L"FLT_OBFL_TYPE_FILTER", FLT_OBFL_TYPE_FILTER },
    { L"FLT_OBFL_TYPE_VOLUME", FLT_OBFL_TYPE_VOLUME }
};

#define MAX_KNOWN_DRV_FLAGS 8
static VALUE_DESC drvFlags[MAX_KNOWN_DRV_FLAGS] = {
    { L"DRVO_UNLOAD_INVOKED", DRVO_UNLOAD_INVOKED },
    { L"DRVO_LEGACY_DRIVER", DRVO_LEGACY_DRIVER },
    { L"DRVO_BUILTIN_DRIVER", DRVO_BUILTIN_DRIVER },
    { L"DRVO_REINIT_REGISTERED", DRVO_REINIT_REGISTERED },
    { L"DRVO_INITIALIZED", DRVO_INITIALIZED },
    { L"DRVO_BOOTREINIT_REGISTERED", DRVO_BOOTREINIT_REGISTERED },
    { L"DRVO_LEGACY_RESOURCES", DRVO_LEGACY_RESOURCES },
    { L"DRVO_BASE_FILESYSTEM_DRIVER", DRVO_BASE_FILESYSTEM_DRIVER }
};

#define MAX_KNOWN_DEV_FLAGS 19
static VALUE_DESC devFlags[MAX_KNOWN_DEV_FLAGS] = {
    { L"DO_VERIFY_VOLUME", DO_VERIFY_VOLUME },
    { L"DO_BUFFERED_IO", DO_BUFFERED_IO },
    { L"DO_EXCLUSIVE", DO_EXCLUSIVE },
    { L"DO_DIRECT_IO", DO_DIRECT_IO },
    { L"DO_MAP_IO_BUFFER", DO_MAP_IO_BUFFER },
    { L"DO_DEVICE_HAS_NAME", DO_DEVICE_HAS_NAME },
    { L"DO_DEVICE_INITIALIZING", DO_DEVICE_INITIALIZING },
    { L"DO_SYSTEM_BOOT_PARTITION", DO_SYSTEM_BOOT_PARTITION },
    { L"DO_LONG_TERM_REQUESTS", DO_LONG_TERM_REQUESTS },
    { L"DO_NEVER_LAST_DEVICE", DO_NEVER_LAST_DEVICE },
    { L"DO_SHUTDOWN_REGISTERED", DO_SHUTDOWN_REGISTERED },
    { L"DO_BUS_ENUMERATED_DEVICE", DO_BUS_ENUMERATED_DEVICE },
    { L"DO_POWER_PAGABLE", DO_POWER_PAGABLE },
    { L"DO_POWER_INRUSH", DO_POWER_INRUSH },
    { L"DO_POWER_NOOP", DO_POWER_NOOP },
    { L"DO_LOW_PRIORITY_FILESYSTEM", DO_LOW_PRIORITY_FILESYSTEM },
    { L"DO_XIP", DO_XIP },
    { L"DO_DEVICE_TO_BE_RESET", DO_DEVICE_TO_BE_RESET },
    { L"DO_DAX_VOLUME", DO_DAX_VOLUME }
};

#define MAX_KNOWN_CHR_FLAGS 15
static VALUE_DESC devChars[MAX_KNOWN_CHR_FLAGS] = {
    { L"FILE_REMOVABLE_MEDIA", FILE_REMOVABLE_MEDIA },
    { L"FILE_READ_ONLY_DEVICE", FILE_READ_ONLY_DEVICE },
    { L"FILE_FLOPPY_DISKETTE", FILE_FLOPPY_DISKETTE },
    { L"FILE_WRITE_ONCE_MEDIA", FILE_WRITE_ONCE_MEDIA },
    { L"FILE_REMOTE_DEVICE", FILE_REMOTE_DEVICE },
    { L"FILE_DEVICE_IS_MOUNTED", FILE_DEVICE_IS_MOUNTED },
    { L"FILE_VIRTUAL_VOLUME", FILE_VIRTUAL_VOLUME },
    { L"FILE_AUTOGENERATED_DEVICE_NAME", FILE_AUTOGENERATED_DEVICE_NAME },
    { L"FILE_DEVICE_SECURE_OPEN", FILE_DEVICE_SECURE_OPEN },
    { L"FILE_CHARACTERISTIC_PNP_DEVICE", FILE_CHARACTERISTIC_PNP_DEVICE },
    { L"FILE_CHARACTERISTIC_TS_DEVICE", FILE_CHARACTERISTIC_TS_DEVICE },
    { L"FILE_CHARACTERISTIC_WEBDAV_DEVICE", FILE_CHARACTERISTIC_WEBDAV_DEVICE },
    { L"FILE_CHARACTERISTIC_CSV", FILE_CHARACTERISTIC_CSV },
    { L"FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL", FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL },
    { L"FILE_PORTABLE_DEVICE", FILE_PORTABLE_DEVICE }
};

static LPWSTR T_IRP_MJ_FUNCTION[] = {
    L"IRP_MJ_CREATE",                   //0x00
    L"IRP_MJ_CREATE_NAMED_PIPE",        //0x01
    L"IRP_MJ_CLOSE",                    //0x02
    L"IRP_MJ_READ",                     //0x03
    L"IRP_MJ_WRITE",                    //0x04
    L"IRP_MJ_QUERY_INFORMATION",        //0x05
    L"IRP_MJ_SET_INFORMATION",          //0x06
    L"IRP_MJ_QUERY_EA",                 //0x07
    L"IRP_MJ_SET_EA",                   //0x08
    L"IRP_MJ_FLUSH_BUFFERS",            //0x09
    L"IRP_MJ_QUERY_VOLUME_INFORMATION", //0x0a
    L"IRP_MJ_SET_VOLUME_INFORMATION",   //0x0b
    L"IRP_MJ_DIRECTORY_CONTROL",        //0x0c
    L"IRP_MJ_FILE_SYSTEM_CONTROL",      //0x0d
    L"IRP_MJ_DEVICE_CONTROL",           //0x0e
    L"IRP_MJ_INTERNAL_DEVICE_CONTROL",  //0x0f
    L"IRP_MJ_SHUTDOWN",                 //0x10
    L"IRP_MJ_LOCK_CONTROL",             //0x11
    L"IRP_MJ_CLEANUP",                  //0x12
    L"IRP_MJ_CREATE_MAILSLOT",          //0x13
    L"IRP_MJ_QUERY_SECURITY",           //0x14
    L"IRP_MJ_SET_SECURITY",             //0x15
    L"IRP_MJ_POWER",                    //0x16
    L"IRP_MJ_SYSTEM_CONTROL",           //0x17
    L"IRP_MJ_DEVICE_CHANGE",            //0x18
    L"IRP_MJ_QUERY_QUOTA",              //0x19
    L"IRP_MJ_SET_QUOTA",                //0x1a
    L"IRP_MJ_PNP"                       //0x1b
};

static LPWSTR T_FAST_IO_DISPATCH[] = {
    L"FastIoCheckIfPossible",
    L"FastIoRead",
    L"FastIoWrite",
    L"FastIoQueryBasicInfo",
    L"FastIoQueryStandardInfo",
    L"FastIoLock",
    L"FastIoUnlockSingle",
    L"FastIoUnlockAll",
    L"FastIoUnlockAllByKey",
    L"FastIoDeviceControl",
    L"AcquireFileForNtCreateSection",
    L"ReleaseFileForNtCreateSection",
    L"FastIoDetachDevice",
    L"FastIoQueryNetworkOpenInfo",
    L"AcquireForModWrite",
    L"MdlRead",
    L"MdlReadComplete",
    L"PrepareMdlWrite",
    L"MdlWriteComplete",
    L"FastIoReadCompressed",
    L"FastIoWriteCompressed",
    L"MdlReadCompleteCompressed",
    L"MdlWriteCompleteCompressed",
    L"FastIoQueryOpen",
    L"ReleaseForModWrite",
    L"AcquireForCcFlush",
    L"ReleaseForCcFlush"
};

static LPWSTR T_ALPC_PORT_STATE[] = {
    L"Initialized",
    L"Type",
    L"ConnectionPending",
    L"ConnectionRefused",
    L"Disconnected",
    L"Closed",
    L"NoFlushOnClose",
    L"ReturnExtendedInfo",
    L"Waitable",
    L"DynamicSecurity",
    L"Wow64CompletionList",
    L"Lpc",
    L"LpcToLpc",
    L"HasCompletionList",
    L"HadCompletionList",
    L"EnableCompletionList"
};

#define MAX_DEVOBJ_CHARS 85
static VALUE_DESC devObjChars[MAX_DEVOBJ_CHARS] = {
    { L"FILE_DEVICE_BEEP", FILE_DEVICE_BEEP },
    { L"FILE_DEVICE_CD_ROM", FILE_DEVICE_CD_ROM },
    { L"FILE_DEVICE_CD_ROM_FILE_SYSTEM", FILE_DEVICE_CD_ROM_FILE_SYSTEM },
    { L"FILE_DEVICE_CONTROLLER", FILE_DEVICE_CONTROLLER },
    { L"FILE_DEVICE_DATALINK", FILE_DEVICE_DATALINK },
    { L"FILE_DEVICE_DFS", FILE_DEVICE_DFS },
    { L"FILE_DEVICE_DISK", FILE_DEVICE_DISK },
    { L"FILE_DEVICE_DISK_FILE_SYSTEM", FILE_DEVICE_DISK_FILE_SYSTEM },
    { L"FILE_DEVICE_FILE_SYSTEM", FILE_DEVICE_FILE_SYSTEM },
    { L"FILE_DEVICE_INPORT_PORT", FILE_DEVICE_INPORT_PORT },
    { L"FILE_DEVICE_KEYBOARD", FILE_DEVICE_KEYBOARD },
    { L"FILE_DEVICE_MAILSLOT", FILE_DEVICE_MAILSLOT },
    { L"FILE_DEVICE_MIDI_IN", FILE_DEVICE_MIDI_IN },
    { L"FILE_DEVICE_MIDI_OUT", FILE_DEVICE_MIDI_OUT },
    { L"FILE_DEVICE_MOUSE", FILE_DEVICE_MOUSE },
    { L"FILE_DEVICE_MULTI_UNC_PROVIDER", FILE_DEVICE_MULTI_UNC_PROVIDER },
    { L"FILE_DEVICE_NAMED_PIPE", FILE_DEVICE_NAMED_PIPE },
    { L"FILE_DEVICE_NETWORK", FILE_DEVICE_NETWORK },
    { L"FILE_DEVICE_NETWORK_BROWSER", FILE_DEVICE_NETWORK_BROWSER },
    { L"FILE_DEVICE_NETWORK_FILE_SYSTEM", FILE_DEVICE_NETWORK_FILE_SYSTEM },
    { L"FILE_DEVICE_NULL", FILE_DEVICE_NULL },
    { L"FILE_DEVICE_PARALLEL_PORT", FILE_DEVICE_PARALLEL_PORT },
    { L"FILE_DEVICE_PHYSICAL_NETCARD", FILE_DEVICE_PHYSICAL_NETCARD },
    { L"FILE_DEVICE_PRINTER", FILE_DEVICE_PRINTER },
    { L"FILE_DEVICE_SCANNER", FILE_DEVICE_SCANNER },
    { L"FILE_DEVICE_SERIAL_MOUSE_PORT", FILE_DEVICE_SERIAL_MOUSE_PORT },
    { L"FILE_DEVICE_SERIAL_PORT", FILE_DEVICE_SERIAL_PORT },
    { L"FILE_DEVICE_SCREEN", FILE_DEVICE_SCREEN },
    { L"FILE_DEVICE_SOUND", FILE_DEVICE_SOUND },
    { L"FILE_DEVICE_STREAMS", FILE_DEVICE_STREAMS },
    { L"FILE_DEVICE_TAPE", FILE_DEVICE_TAPE },
    { L"FILE_DEVICE_TAPE_FILE_SYSTEM", FILE_DEVICE_TAPE_FILE_SYSTEM },
    { L"FILE_DEVICE_TRANSPORT", FILE_DEVICE_TRANSPORT },
    { L"FILE_DEVICE_UNKNOWN", FILE_DEVICE_UNKNOWN },
    { L"FILE_DEVICE_VIDEO", FILE_DEVICE_VIDEO },
    { L"FILE_DEVICE_VIRTUAL_DISK", FILE_DEVICE_VIRTUAL_DISK },
    { L"FILE_DEVICE_WAVE_IN", FILE_DEVICE_WAVE_IN },
    { L"FILE_DEVICE_WAVE_OUT", FILE_DEVICE_WAVE_OUT },
    { L"FILE_DEVICE_8042_PORT", FILE_DEVICE_8042_PORT },
    { L"FILE_DEVICE_NETWORK_REDIRECTOR", FILE_DEVICE_NETWORK_REDIRECTOR },
    { L"FILE_DEVICE_BATTERY", FILE_DEVICE_BATTERY },
    { L"FILE_DEVICE_BUS_EXTENDER", FILE_DEVICE_BUS_EXTENDER },
    { L"FILE_DEVICE_MODEM", FILE_DEVICE_MODEM },
    { L"FILE_DEVICE_VDM", FILE_DEVICE_VDM },
    { L"FILE_DEVICE_MASS_STORAGE", FILE_DEVICE_MASS_STORAGE },
    { L"FILE_DEVICE_SMB", FILE_DEVICE_SMB },
    { L"FILE_DEVICE_KS", FILE_DEVICE_KS },
    { L"FILE_DEVICE_CHANGER", FILE_DEVICE_CHANGER },
    { L"FILE_DEVICE_SMARTCARD", FILE_DEVICE_SMARTCARD },
    { L"FILE_DEVICE_ACPI", FILE_DEVICE_ACPI },
    { L"FILE_DEVICE_DVD", FILE_DEVICE_DVD },
    { L"FILE_DEVICE_FULLSCREEN_VIDEO", FILE_DEVICE_FULLSCREEN_VIDEO },
    { L"FILE_DEVICE_DFS_FILE_SYSTEM", FILE_DEVICE_DFS_FILE_SYSTEM },
    { L"FILE_DEVICE_DFS_VOLUME", FILE_DEVICE_DFS_VOLUME },
    { L"FILE_DEVICE_SERENUM", FILE_DEVICE_SERENUM },
    { L"FILE_DEVICE_TERMSRV", FILE_DEVICE_TERMSRV },
    { L"FILE_DEVICE_KSEC", FILE_DEVICE_KSEC },
    { L"FILE_DEVICE_FIPS", FILE_DEVICE_FIPS },
    { L"FILE_DEVICE_INFINIBAND", FILE_DEVICE_INFINIBAND },
    { L"FILE_DEVICE_VMBUS", FILE_DEVICE_VMBUS },
    { L"FILE_DEVICE_CRYPT_PROVIDER", FILE_DEVICE_CRYPT_PROVIDER },
    { L"FILE_DEVICE_WPD", FILE_DEVICE_WPD },
    { L"FILE_DEVICE_BLUETOOTH", FILE_DEVICE_BLUETOOTH },
    { L"FILE_DEVICE_MT_COMPOSITE", FILE_DEVICE_MT_COMPOSITE },
    { L"FILE_DEVICE_MT_TRANSPORT", FILE_DEVICE_MT_TRANSPORT },
    { L"FILE_DEVICE_BIOMETRIC", FILE_DEVICE_BIOMETRIC },
    { L"FILE_DEVICE_PMI", FILE_DEVICE_PMI },
    { L"FILE_DEVICE_EHSTOR", FILE_DEVICE_EHSTOR },
    { L"FILE_DEVICE_DEVAPI", FILE_DEVICE_DEVAPI },
    { L"FILE_DEVICE_GPIO", FILE_DEVICE_GPIO },
    { L"FILE_DEVICE_USBEX", FILE_DEVICE_USBEX },
    { L"FILE_DEVICE_CONSOLE", FILE_DEVICE_CONSOLE },
    { L"FILE_DEVICE_NFP", FILE_DEVICE_NFP },
    { L"FILE_DEVICE_SYSENV", FILE_DEVICE_SYSENV },
    { L"FILE_DEVICE_VIRTUAL_BLOCK", FILE_DEVICE_VIRTUAL_BLOCK },
    { L"FILE_DEVICE_POINT_OF_SERVICE", FILE_DEVICE_POINT_OF_SERVICE },
    { L"FILE_DEVICE_STORAGE_REPLICATION", FILE_DEVICE_STORAGE_REPLICATION },
    { L"FILE_DEVICE_TRUST_ENV", FILE_DEVICE_TRUST_ENV },
    { L"FILE_DEVICE_UCM", FILE_DEVICE_UCM },
    { L"FILE_DEVICE_UCMTCPCI", FILE_DEVICE_UCMTCPCI },
    { L"FILE_DEVICE_PERSISTENT_MEMORY", FILE_DEVICE_PERSISTENT_MEMORY },
    { L"FILE_DEVICE_NVDIMM", FILE_DEVICE_NVDIMM },
    { L"FILE_DEVICE_HOLOGRAPHIC", FILE_DEVICE_HOLOGRAPHIC },
    { L"FILE_DEVICE_SDFXHCI", FILE_DEVICE_SDFXHCI },
    { L"FILE_DEVICE_UCMUCSI", FILE_DEVICE_UCMUCSI }
};

#define MAX_KNOWN_FILEALIGN 10
static VALUE_DESC fileAlign[MAX_KNOWN_FILEALIGN] = {
    { L"FILE_BYTE_ALIGNMENT", FILE_BYTE_ALIGNMENT },
    { L"FILE_WORD_ALIGNMENT", FILE_WORD_ALIGNMENT },
    { L"FILE_LONG_ALIGNMENT", FILE_LONG_ALIGNMENT },
    { L"FILE_QUAD_ALIGNMENT", FILE_QUAD_ALIGNMENT },
    { L"FILE_OCTA_ALIGNMENT", FILE_OCTA_ALIGNMENT },
    { L"FILE_32_BYTE_ALIGNMENT", FILE_32_BYTE_ALIGNMENT },
    { L"FILE_64_BYTE_ALIGNMENT", FILE_64_BYTE_ALIGNMENT },
    { L"FILE_128_BYTE_ALIGNMENT", FILE_128_BYTE_ALIGNMENT },
    { L"FILE_256_BYTE_ALIGNMENT", FILE_256_BYTE_ALIGNMENT },
    { L"FILE_512_BYTE_ALIGNMENT", FILE_512_BYTE_ALIGNMENT }
};

#define MAX_KNOWN_OBJ_DIR_FLAGS 2
static VALUE_DESC objDirFlags[MAX_KNOWN_OBJ_DIR_FLAGS] = {
    { L"OBJDIR_FLAG_SHADOW_PRESENT", OBJDIR_FLAG_SHADOW_PRESENT },
    { L"OBJDIR_FLAG_SANDBOX", OBJDIR_FLAG_SANDBOX }
};

#define MAX_KNOWN_DOS_DRIVE_TYPE 7
static VALUE_DESC dosDeviceDriveType[MAX_KNOWN_DOS_DRIVE_TYPE] = {
    { L"DOSDEVICE_DRIVE_UNKNOWN", DOSDEVICE_DRIVE_UNKNOWN },
    { L"DOSDEVICE_DRIVE_CALCULATE", DOSDEVICE_DRIVE_CALCULATE },
    { L"DOSDEVICE_DRIVE_REMOVABLE", DOSDEVICE_DRIVE_REMOVABLE },
    { L"DOSDEVICE_DRIVE_FIXED", DOSDEVICE_DRIVE_FIXED },
    { L"DOSDEVICE_DRIVE_REMOTE", DOSDEVICE_DRIVE_REMOTE },
    { L"DOSDEVICE_DRIVE_CDROM", DOSDEVICE_DRIVE_CDROM },
    { L"DOSDEVICE_DRIVE_RAMDISK", DOSDEVICE_DRIVE_RAMDISK }
};

```

`Source/WinObjEx64/props/propProcess.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       PROPPROCESS.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "propDlg.h"
#include "extras.h"

#define COLUMN_PSLIST_NAME          0
#define COLUMN_PSLIST_ID            1
#define COLUMN_PSLIST_HANDLE        2
#define COLUMN_PSLIST_GRANTEDACCESS 3

/*
* ProcessListCompareFunc
*
* Purpose:
*
* Process page listview comparer function.
*
*/
INT CALLBACK ProcessListCompareFunc(
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lpContextParam
)
{
    INT       nResult = 0;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL, FirstToCompare, SecondToCompare;
    ULONG_PTR Value1, Value2;

    LPARAM lvColumnToSort;

    EXTRASCONTEXT* pDlgContext;

    pDlgContext = (EXTRASCONTEXT*)lpContextParam;
    if (pDlgContext == NULL)
        return 0;

    lvColumnToSort = (LPARAM)pDlgContext->lvColumnToSort;

    //
    // Sort Handle/GrantedAccess value column.
    //
    if ((lvColumnToSort == COLUMN_PSLIST_HANDLE) || 
        (lvColumnToSort == COLUMN_PSLIST_GRANTEDACCESS)) 
    {
        return supGetMaxOfTwoU64FromHex(
            pDlgContext->ListView,
            lParam1,
            lParam2,
            lvColumnToSort,
            pDlgContext->bInverseSort);
    }


    lpItem1 = supGetItemText(
        pDlgContext->ListView,
        (INT)lParam1,
        (INT)lvColumnToSort,
        NULL);

    if (lpItem1 == NULL) //can't be 0 for this dialog
        goto Done;

    lpItem2 = supGetItemText(
        pDlgContext->ListView,
        (INT)lParam2,
        (INT)lvColumnToSort,
        NULL);

    if (lpItem2 == NULL) //can't be 0 for this dialog
        goto Done;

    switch (lvColumnToSort) {
    case COLUMN_PSLIST_NAME:
        //
        // Name column.
        //
        if (pDlgContext->bInverseSort) {
            FirstToCompare = lpItem2;
            SecondToCompare = lpItem1;
        }
        else
        {
            FirstToCompare = lpItem1;
            SecondToCompare = lpItem2;
        }

        nResult = _strcmpi(FirstToCompare, SecondToCompare);
        break;

    case COLUMN_PSLIST_ID:
        //
        // Id column.
        //
        Value1 = strtou64(lpItem1);
        Value2 = strtou64(lpItem2);
        if (Value1 < Value2)
            nResult = pDlgContext->bInverseSort ? 1 : -1;
        else if (Value1 > Value2)
            nResult = pDlgContext->bInverseSort ? -1 : 1;
        else
            nResult = 0;
        break;

    }

Done:
    if (lpItem1) supHeapFree(lpItem1);
    if (lpItem2) supHeapFree(lpItem2);
    return nResult;
}

/*
* ProcessShowProperties
*
* Purpose:
*
* Query full target path and execute Windows shell properties dialog.
*
*/
VOID ProcessShowProperties(
    _In_ HWND hwndDlg,
    _In_ HWND hwndListView,
    _In_ INT iItem
)
{
    HANDLE          processId;
    PUNICODE_STRING pusFileName = NULL;

    WCHAR szBuffer[100];

    //
    // Query process id.
    //
    szBuffer[0] = 0;
    supGetItemText2(hwndListView, iItem, 1, szBuffer, RTL_NUMBER_OF(szBuffer));
    processId = UlongToHandle(_strtoul(szBuffer));

    //
    // Query process image filename and show shell properties dialog.
    //
    if (NT_SUCCESS(supQueryProcessImageFileNameWin32(processId, &pusFileName))) {

        if (pusFileName->Buffer && pusFileName->Length)
            supShowProperties(hwndDlg, pusFileName->Buffer);

        supHeapFree(pusFileName);
    }

}

/*
* ProcessListHandleNotify
*
* Purpose:
*
* WM_NOTIFY processing for Process page listview.
*
*/
BOOL ProcessListHandleNotify(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    INT     nImageIndex;
    EXTRASCONTEXT* pDlgContext;
    NMLISTVIEW* pListView = (NMLISTVIEW*)lParam;
    HWND hwndListView;

    if (pListView == NULL)
        return FALSE;

    if (pListView->hdr.idFrom != ID_PROCESSLIST)
        return FALSE;

    hwndListView = pListView->hdr.hwndFrom;

    switch (pListView->hdr.code) {

    case LVN_COLUMNCLICK:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            pDlgContext->bInverseSort = (~pDlgContext->bInverseSort) & 1;
            pDlgContext->lvColumnToSort = pListView->iSubItem;

            ListView_SortItemsEx(
                hwndListView,
                &ProcessListCompareFunc,
                pDlgContext);

            if (pDlgContext->bInverseSort)
                nImageIndex = 1;
            else
                nImageIndex = 2;

            supUpdateLvColumnHeaderImage(
                hwndListView,
                pDlgContext->lvColumnCount,
                pDlgContext->lvColumnToSort,
                nImageIndex);
        }
        break;

    case NM_DBLCLK:

        ProcessShowProperties(
            hwndDlg,
            hwndListView,
            pListView->iItem);

        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*
* ProcessQueryInfo
*
* Purpose:
*
* Extracts icon resource from given process for use in listview and determines process WOW64 status.
*
*/
VOID ProcessQueryInfo(
    _In_ ULONG_PTR ProcessId,
    _Out_ HICON* pProcessIcon,
    _Out_ BOOL* pbIs32
)
{
    HANDLE          hProcess;
    NTSTATUS        ntStatus;

    HICON           hIcon = NULL;
    PUNICODE_STRING pusFileName = NULL;

    *pProcessIcon = NULL;
    *pbIs32 = FALSE;

    ntStatus = supOpenProcess((HANDLE)ProcessId,
        PROCESS_QUERY_LIMITED_INFORMATION,
        &hProcess);

    if (NT_SUCCESS(ntStatus)) {

        //
        // Query if this is wow64 process.
        //
        *pbIs32 = supIsProcess32bit(hProcess);

        //
        // Query process icon, first query win32 imagefilename then parse image resources.
        //
        ntStatus = supQueryProcessInformation(hProcess,
            ProcessImageFileNameWin32,
            &pusFileName,
            NULL);

        if (NT_SUCCESS(ntStatus)) {
            if (pusFileName->Buffer && pusFileName->Length) {
                hIcon = supGetMainIcon(pusFileName->Buffer, 16, 16);
                if (hIcon) {
                    *pProcessIcon = hIcon;
                }
            }
            supHeapFree(pusFileName);
        }

        NtClose(hProcess);
    }

}

/*
* ProcessListAddItem
*
* Purpose:
*
* Adds an item to the listview.
*
*/
VOID ProcessListAddItem(
    _In_ HWND hwndListView,
    _In_ HIMAGELIST ImageList,
    _In_ PVOID ProcessesList,
    _In_ PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX phti
)
{
    BOOL     bIsWow64;
    INT      nIndex, iImage;
    HICON    hIcon;
    LVITEM   lvitem;
    WCHAR    szBuffer[MAX_PATH * 2];

    if ((phti == NULL) || (ProcessesList == NULL)) {
        return;
    }

    //
    // Default image index.
    //
    iImage = 0;

    //
    // Set default process name as Unknown.
    //
    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
    _strcpy(szBuffer, T_Unknown);

    if (supQueryProcessName(
        phti->UniqueProcessId,
        ProcessesList,
        szBuffer,
        MAX_PATH))
    {
        //
        // Id exists, extract icon
        // Skip idle, system
        //
        if (phti->UniqueProcessId > 4) {

            hIcon = NULL;
            bIsWow64 = FALSE;
            ProcessQueryInfo(phti->UniqueProcessId, &hIcon, &bIsWow64);

            if (hIcon) {
                iImage = ImageList_ReplaceIcon(ImageList, -1, hIcon);
                DestroyIcon(hIcon);
            }
            if (bIsWow64) {
                _strcat(szBuffer, L"*32");
            }
            
        }
    }

    RtlSecureZeroMemory(&lvitem, sizeof(lvitem));

    //
    // Process Name.
    //
    lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvitem.iImage = iImage;
    lvitem.pszText = szBuffer;
    lvitem.iItem = MAXINT;
    nIndex = ListView_InsertItem(hwndListView, &lvitem);

    //
    // ProcessId.
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    u64tostr(phti->UniqueProcessId, szBuffer);
    lvitem.mask = LVIF_TEXT;
    lvitem.iSubItem = 1;
    lvitem.iItem = nIndex;
    ListView_SetItem(hwndListView, &lvitem);

    //
    // Handle Value.
    //
    _strcpy(szBuffer, L"0x");
    u64tohex(phti->HandleValue, _strend(szBuffer));
    lvitem.iSubItem = 2;
    ListView_SetItem(hwndListView, &lvitem);

    //
    // Handle GrantedAccess.
    //
    _strcpy(szBuffer, L"0x");
    ultohex(phti->GrantedAccess, _strend(szBuffer));
    lvitem.iSubItem = 3;
    ListView_SetItem(hwndListView, &lvitem);
}

/*
* ProcessEnumHandlesCallback
*
* Purpose:
*
* Handles enumeration callback.
*
*/
BOOL ProcessEnumHandlesCallback(
    _In_ SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* HandleEntry,
    _In_ PVOID UserContext
)
{
    PHANDLE_DUMP_ENUM_CONTEXT userCtx = (PHANDLE_DUMP_ENUM_CONTEXT)UserContext;

    //
    // Is this what we want?
    //
    if (HandleEntry->ObjectTypeIndex == userCtx->ObjectTypeIndex) {
        if ((ULONG_PTR)HandleEntry->Object == userCtx->ObjectAddress) {

            //
            // Decode and add information to the list.
            //
            ProcessListAddItem(userCtx->ListView,
                userCtx->ImageList,
                userCtx->ProcessList,
                HandleEntry);
        }
    }
    // Continue enumeration
    return FALSE;
}

/*
* ProcessListSetInfo
*
* Purpose:
*
* Query information and fill listview.
* Called each time when page became visible.
*
*/
VOID ProcessListSetInfo(
    _In_ HWND hwndDlg,
    _In_ PROP_OBJECT_INFO* Context,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    BOOL                            bObjectFound = FALSE;
    USHORT                          ObjectTypeIndex = 0;
    ULONG_PTR                       ObjectAddress = 0;
    ACCESS_MASK                     DesiredAccess;
    PVOID                           ProcessList = NULL;
    HANDLE                          hObject = NULL;
    HICON                           hIcon;
    PSYSTEM_HANDLE_INFORMATION_EX   pHandles = NULL;

    HANDLE_DUMP_ENUM_CONTEXT        enumContext;

    //empty process list images
    ImageList_RemoveAll(pDlgContext->ImageList);

    //empty process list
    ListView_DeleteAllItems(GetDlgItem(hwndDlg, ID_PROCESSLIST));

    //set default app icon
    hIcon = LoadIcon(NULL, IDI_APPLICATION);

    if (hIcon) {
        ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hIcon);
        DestroyIcon(hIcon);
    }

    //sort image up
    hIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_SORTUP), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

    if (hIcon) {
        ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hIcon);
        DestroyIcon(hIcon);
    }

    //sort image down
    hIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_SORTDOWN), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);

    if (hIcon) {
        ImageList_ReplaceIcon(pDlgContext->ImageList, -1, hIcon);
        DestroyIcon(hIcon);
    }

    //
    // Check if additional info is available.
    //
    if (Context->ObjectInfo.ObjectAddress != 0) {

        ObjectAddress = Context->ObjectInfo.ObjectAddress;

        ObjectTypeIndex = ObDecodeTypeIndex((PVOID)ObjectAddress,
            Context->ObjectInfo.ObjectHeader.TypeIndex);

        bObjectFound = TRUE;
    }

    do {
        //
        // When object address is unknown, open object and query it address.
        // This DesiredAccess flag is used to open currently viewed object.
        //
        if (ObjectAddress == 0) {

            DesiredAccess = READ_CONTROL;
            bObjectFound = FALSE;

            //
            // Open temporary object handle to query object address.
            //
            if (propOpenCurrentObject(Context, &hObject, DesiredAccess)) {

                pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation, NULL);
                if (pHandles) {

                    //
                    // Find our handle object by handle value.
                    //
                    bObjectFound = supQueryObjectFromHandleEx(pHandles,
                        hObject,
                        &ObjectAddress,
                        &ObjectTypeIndex);

                    supHeapFree(pHandles);
                }

                supCloseObjectFromContext(Context, hObject);
            }

        }

        //
        // Nothing to compare.
        //
        if (bObjectFound == FALSE)
            break;

        //
        // Take process and handles snapshot.
        //
        ProcessList = supGetSystemInfo(SystemProcessInformation, NULL);
        if (ProcessList == NULL)
            break;

        pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation, NULL);
        if (pHandles) {

            //
            // Find any handles with the same object address and object type.
            //
            enumContext.ImageList = pDlgContext->ImageList;
            enumContext.ListView = pDlgContext->ListView;
            enumContext.ProcessList = ProcessList;
            enumContext.ObjectAddress = ObjectAddress;
            enumContext.ObjectTypeIndex = ObjectTypeIndex;

            supDisableRedraw(pDlgContext->ListView);

            supEnumHandleDump(pHandles,
                (PENUMERATE_HANDLE_DUMP_CALLBACK)ProcessEnumHandlesCallback,
                &enumContext);

            supEnableRedraw(pDlgContext->ListView);

            supHeapFree(pHandles);
            pHandles = NULL;
        }


    } while (FALSE);

    //
    // Cleanup.
    //
    if (pHandles) {
        supHeapFree(pHandles);
    }
    if (ProcessList) {
        supHeapFree(ProcessList);
    }

    //
    // Show/hide notification text.
    //
    ShowWindow(GetDlgItem(hwndDlg, ID_PROCESSLISTNOALL), (ObjectAddress == 0) ? SW_SHOW : SW_HIDE);
}

/*
* ProcessInitListView
*
* Purpose:
*
* Initialize listview for process list.
* Called once.
*
*/
BOOL ProcessInitListView(
    _In_ HWND hwndDlg,
    _In_ EXTRASCONTEXT* pDlgContext
)
{
    LVCOLUMNS_DATA columnData[] =
    {
        { L"Process", 160, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  2 },
        { L"ID", 60, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Handle", 130, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE },
        { L"Access", 80, LVCFMT_LEFT | LVCFMT_BITMAP_ON_RIGHT,  I_IMAGENONE }
    };

    pDlgContext->ListView = GetDlgItem(hwndDlg, ID_PROCESSLIST);
    if (pDlgContext->ListView == NULL)
        return FALSE;

    pDlgContext->ImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 32, 8);

    //
    // Set listview imagelist, style flags and theme.
    //
    supSetListViewSettings(pDlgContext->ListView,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        pDlgContext->ImageList,
        LVSIL_SMALL);

    //
    // And columns and remember their count.
    //
    pDlgContext->lvColumnCount = supAddLVColumnsFromArray(
        pDlgContext->ListView,
        columnData,
        RTL_NUMBER_OF(columnData));

    return TRUE;
}

/*
* ProcessHandlePopupMenu
*
* Purpose:
*
* Process list popup construction
*
*/
VOID ProcessHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    EXTRASCONTEXT* Context = (EXTRASCONTEXT*)lpUserParam;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            Context->ListView,
            ID_OBJECT_COPY,
            0,
            lpPoint,
            &Context->lvItemHit,
            &Context->lvColumnHit))
        {
            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* ProcessListDialogProc
*
* Purpose:
*
* Process list page for various object types.
*
* WM_INITDIALOG - Initialize listview, set window prop with context,
* collect processes info and fill list.
*
* WM_NOTIFY - Handle list view notifications.
*
* WM_DESTROY - Free image list and remove window prop.
*
* WM_CONTEXTMENU - Handle popup menu.
*
*/
INT_PTR CALLBACK ProcessListDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    PROPSHEETPAGE* pSheet = NULL;
    PROP_OBJECT_INFO* Context = NULL;
    EXTRASCONTEXT* pDlgContext = NULL;

    switch (uMsg) {

    case WM_CONTEXTMENU:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pDlgContext->ListView,
                (pfnPopupMenuHandler)ProcessHandlePopupMenu,
                pDlgContext);
        }
        break;

    case WM_COMMAND:

        if (GET_WM_COMMAND_ID(wParam, lParam) == ID_OBJECT_COPY) {
            pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (pDlgContext) {

                supListViewCopyItemValueToClipboard(pDlgContext->ListView,
                    pDlgContext->lvItemHit,
                    pDlgContext->lvColumnHit);

            }
        }
        break;

    case WM_NOTIFY:
        return ProcessListHandleNotify(hwndDlg, lParam);

    case WM_DESTROY:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            if (pDlgContext->ImageList) {
                ImageList_Destroy(pDlgContext->ImageList);
            }
            supHeapFree(pDlgContext);
        }
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        RemoveProp(hwndDlg, T_DLGCONTEXT);
        break;

    case WM_INITDIALOG:

        pSheet = (PROPSHEETPAGE*)lParam;
        if (pSheet) {
            Context = (PROP_OBJECT_INFO*)pSheet->lParam;
            SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)Context);

            pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
            if (pDlgContext) {

                pDlgContext->lvColumnHit = -1;
                pDlgContext->lvItemHit = -1;

                SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pDlgContext);

                if (ProcessInitListView(hwndDlg, pDlgContext)) {

                    ProcessListSetInfo(hwndDlg, Context, pDlgContext);

                    ListView_SortItemsEx(
                        pDlgContext->ListView,
                        &ProcessListCompareFunc,
                        pDlgContext);
                }
            }
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

```

`Source/WinObjEx64/props/propSection.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2025
*
*  TITLE:       PROPSECTION.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "extras.h"
#include "props.h"
#include "propObjectDumpConsts.h"

#define COLUMN_SECTION_VIEW_OBJECT   0
#define COLUMN_SECTION_VIEW_ADDRESS  1

typedef VOID(CALLBACK* POUTPUT_SECTION_CONTROL_AREA)(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Address,
    _In_ PCONTROL_AREA_COMPAT ControlArea
    );

typedef VOID(CALLBACK* POUTPUT_SECTION_SEGMENT)(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Address,
    _In_ PSEGMENT Segment,
    _In_ PCONTROL_AREA_COMPAT ControlArea
    );

typedef VOID(CALLBACK* POUTPUT_SECTION_MI_REVERSE_VIEW_MAP)(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Address,
    _In_ PMI_REVERSE_VIEW_MAP ReserveViewMap
    );

typedef HTREEITEM(CALLBACK* POUTPUT_SECTION_CREATE_NODE)(
    _In_ HWND TreeList,
    _In_ LPWSTR Name,
    _In_opt_ LPWSTR FirstValue,
    _In_opt_ LPWSTR SecondValue);

//
// MMSECTION_FLAGS (as of Win10)
//
LPCWSTR T_SectionFlags[] = {
    L"BeingDeleted",
    L"BeingCreated",
    L"BeingPurged",
    L"NoModifiedWriting",
    L"FailAllIo",
    L"Image",
    L"Based",
    L"File",
    L"AttemptingDelete",
    L"PrefetchCreated",
    L"PhysicalMemory",
    L"ImageControlAreaOnRemovableMedia",
    L"Reserve",
    L"Commit",
    L"NoChange",
    L"WasPurged",
    L"UserReference",
    L"GlobalMemory",
    L"DeleteOnClose",
    L"FilePointerNull",
    L"PreferredNode",
    L"GlobalOnlyPerSession",
    L"UserWritable",
    L"SystemVaAllocated",
    L"PreferredFsCompressionBoundary",
    L"UsingFileExtents",
    L"PageSize64K"
};

BOOLEAN IsValidSegment(
    _In_ ULONG_PTR ControlAreaAddress,
    _In_ PSEGMENT Segment
)
{
    return ((ULONG_PTR)Segment->ControlArea == ControlAreaAddress);
}

/*
* SectionControlAreaOutput
*
* Purpose:
*
* Output basic CONTROL_AREA information to the treelist.
*
*/
VOID CALLBACK SectionControlAreaOutput(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Address,
    _In_ PCONTROL_AREA_COMPAT ControlArea
)
{
    HTREEITEM treeItem, treeSubItem;
    PVOID fileObject;
    UINT i, j;

    treeItem = propObDumpAddress(TreeList,
        RootItem,
        TEXT("ControlArea"),
        T_PCONTROL_AREA,
        (PVOID)Address,
        0, 0);

    if (treeItem) {

        propObDumpAddress(TreeList,
            treeItem,
            TEXT("Segment"),
            T_PSEGMENT,
            (PVOID)ControlArea->Segment,
            0, 0);

        propObDumpListEntry(TreeList,
            treeItem,
            TEXT("ListHead"),
            &ControlArea->ListHead);

        propObDumpUlong64(TreeList,
            treeItem,
            TEXT("NumberOfSectionReferences"),
            NULL,
            ControlArea->NumberOfSectionReferences,
            TRUE,
            0, 0);

        propObDumpUlong64(TreeList,
            treeItem,
            TEXT("NumberOfPfnReferences"),
            NULL,
            ControlArea->NumberOfPfnReferences,
            TRUE,
            0, 0);

        propObDumpUlong64(TreeList,
            treeItem,
            TEXT("NumberOfMappedViews"),
            NULL,
            ControlArea->NumberOfMappedViews,
            TRUE,
            0, 0);

        propObDumpUlong64(TreeList,
            treeItem,
            TEXT("NumberOfUserReferences"),
            NULL,
            ControlArea->NumberOfUserReferences,
            TRUE,
            0, 0);

        treeSubItem = propObDumpUlong(TreeList,
            treeItem,
            TEXT("u.LongFlags"),
            NULL,
            ControlArea->u.LongFlags,
            TRUE,
            FALSE,
            0, 0);

        if (treeSubItem) {

            i = 0;
            j = 0;
            do {
                //
                // Special case. This flag is 6 bits.
                //
                if (i == 20) {
                    propObDumpUlong(TreeList,
                        treeSubItem,
                        (LPWSTR)T_SectionFlags[20],
                        NULL,
                        (ULONG)ControlArea->u.Flags.PreferredNode,
                        TRUE,
                        FALSE,
                        0, 0);

                    i += 6;

                }
                else {
                    propObDumpByte(TreeList,
                        treeSubItem,
                        (LPWSTR)T_SectionFlags[j],
                        NULL,
                        GET_BIT(ControlArea->u.LongFlags, i),
                        0, 0,
                        FALSE);

                    i += 1;
                }

                j++;

            } while (i < 32);

        }

        //
        // These flags are way too variadic even between Win10 releases.
        //
        propObDumpUlong(TreeList,
            treeItem,
            TEXT("u1.LongFlags"),
            NULL,
            ControlArea->u1.LongFlags,
            TRUE,
            FALSE,
            0, 0);

        fileObject = ObGetObjectFastReference(ControlArea->FilePointer);

        propObDumpAddress(TreeList,
            treeItem,
            TEXT("FilePointer"),
            T_PFILE_OBJECT,
            fileObject,
            0, 0);

    }
}

/*
* SectionSegmentOutput
*
* Purpose:
*
* Output basic SEGMENT information to the treelist.
*
*/
VOID CALLBACK SectionSegmentOutput(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Address,
    _In_ PSEGMENT Segment,
    _In_ PCONTROL_AREA_COMPAT ControlArea
)
{
    HTREEITEM nodeRootItem, subItem;
    LPWSTR lpFieldName;
    LPWSTR lpDesc;

    nodeRootItem = propObDumpAddress(TreeList,
        RootItem,
        TEXT("Segment"),
        T_PSEGMENT,
        (PVOID)Address,
        0, 0);

    if (nodeRootItem) {

        subItem = propObDumpSetString(TreeList,
            nodeRootItem,
            TEXT("SegmentFlags"),
            T_SEGMENT_FLAGS,
            NULL,
            0, 0);

        if (subItem) {

            propObDumpUlong(TreeList,
                subItem,
                TEXT("Short0"),
                NULL,
                Segment->SegmentFlags.Short0,
                TRUE,
                TRUE,
                0, 0);

            propObDumpByte(TreeList,
                subItem,
                TEXT("UChar1"),
                NULL,
                Segment->SegmentFlags.UChar1,
                0, 0,
                FALSE);

            propObDumpByte(TreeList,
                subItem,
                TEXT("UChar2"),
                NULL,
                Segment->SegmentFlags.UChar2,
                0, 0,
                FALSE);

        }

        lpFieldName = TEXT("FirstMappedVa");
        lpDesc = T_EmptyString;

        if (ControlArea->u.Flags.Image) {
            lpFieldName = TEXT("ImageInformation");
            lpDesc = T_PMI_SECTION_IMAGE_INFORMATION;
        }

        propObDumpAddress(TreeList,
            nodeRootItem,
            lpFieldName,
            lpDesc,
            (PVOID)Segment->u3.FirstMappedVa,
            0, 0);

    }
}

/*
* SectionMiReverseViewMapOutput
*
* Purpose:
*
* Output basic MI_REVERSE_VIEW_MAP information to the treelist.
*
*/
VOID CALLBACK SectionMiReverseViewMapOutput(
    _In_ HWND TreeList,
    _In_ HTREEITEM RootItem,
    _In_ ULONG_PTR Address,
    _In_ PMI_REVERSE_VIEW_MAP ReverseViewMap
)
{
    BOOL bExtQuery = FALSE;
    ULONG_PTR viewMapType;
    HTREEITEM treeItem;
    HANDLE processId;
    ULONG_PTR kernelAddress;
    PUNICODE_STRING pusFileName = NULL;
    LPWSTR lpProcessName = NULL, lpFieldName = NULL;

    UNICODE_STRING usImageFileName;

    //
    // MI_REVERSE_VIEW_MAP
    //
    treeItem = propObDumpAddress(TreeList,
        RootItem,
        TEXT("ViewMap"),
        T_PMI_REVERSE_VIEW_MAP,
        (PVOID)Address,
        0, 0);

    if (treeItem) {

        //
        // MI_REVERSE_VIEW_MAP->Type
        //
        propObDumpUlong(TreeList,
            treeItem,
            TEXT("Type"),
            NULL,
            ReverseViewMap->u1.Type,
            FALSE,
            FALSE,
            0, 0);

        RtlInitEmptyUnicodeString(&usImageFileName, NULL, 0);

        viewMapType = ReverseViewMap->u1.Type;
        kernelAddress = (ULONG_PTR)ReverseViewMap->u1.VadsProcess & ~viewMapType;

        switch (viewMapType) {

        case VIEW_MAP_TYPE_PROCESS:

            //
            // Process map view.
            //
            lpFieldName = TEXT("VadsProcess");
            if (ObGetProcessId(kernelAddress, &processId)) {

                bExtQuery = NT_SUCCESS(supQueryProcessImageFileNameWin32(processId, &pusFileName));

                if (bExtQuery) {

                    if (pusFileName->Buffer && pusFileName->Length) {

                        lpProcessName = supExtractFileName(pusFileName->Buffer);

                    }
                    else {
                        bExtQuery = FALSE;
                    }

                }

            }

            if (bExtQuery == FALSE) {
                if (ObGetProcessImageFileName(kernelAddress, &usImageFileName)) {
                    lpProcessName = usImageFileName.Buffer;
                }
                else {
                    lpProcessName = T_Unknown;
                }
            }

            break;

        case VIEW_MAP_TYPE_SESSION:

            //
            // MMVIEW
            //

            //
            // Session view.
            //
            lpFieldName = TEXT("SessionViewVa");
            break;

        case VIEW_MAP_TYPE_SYSTEM_CACHE:

            //
            // MI_IMAGE_ENTRY_IN_SESSION
            //

            //
            // System cache view.
            //
            lpFieldName = TEXT("SystemCacheVa");
            break;

        default:
            //
            // Unknown.
            //
            lpFieldName = TEXT("Unrecognized");
            break;
        }

        propObDumpAddress(TreeList,
            treeItem,
            lpFieldName,
            lpProcessName,
            (PVOID)kernelAddress,
            0, 0);

        if (ReverseViewMap->u1.Type == VIEW_MAP_TYPE_PROCESS) {
            if (pusFileName)
                supHeapFree(pusFileName);

            if (usImageFileName.Buffer)
                RtlFreeUnicodeString(&usImageFileName);
        }
    }
}

/*
* SectionObjectCreateNode
*
* Purpose:
*
* Create a new node for output construction.
*
*/
HTREEITEM CALLBACK SectionObjectCreateNode(
    _In_ HWND TreeList,
    _In_ LPWSTR Name,
    _In_opt_ LPWSTR FirstValue,
    _In_opt_ LPWSTR SecondValue
)
{
    TL_SUBITEMS_FIXED subitems;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));
    subitems.Count = 2;
    subitems.Text[0] = (FirstValue != NULL) ? FirstValue : T_EmptyString;
    subitems.Text[1] = (SecondValue != NULL) ? SecondValue : T_EmptyString;

    return supTreeListAddItem(TreeList,
        NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        Name,
        &subitems);
}

#define SECTION_ENUM_MEMORY_READ_FAILURE    1
#define SECTION_ENUM_CORRUPT_SEGMENT        2
#define SECTION_ENUM_UNSUPPORTED_FLAGS      3

/*
* SectionObjectEnumerateFields
*
* Purpose:
*
* Enum section object basic information.
*
*/
ULONG SectionObjectEnumerateFields(
    _In_ HWND TreeList,
    _In_ ULONG_PTR SectionObject,
    _In_ HTREEITEM RootItem,
    _In_ POUTPUT_SECTION_CREATE_NODE CreateNodeCallback,
    _In_ POUTPUT_SECTION_CONTROL_AREA ControlAreaOutput,
    _In_ POUTPUT_SECTION_SEGMENT SegmentOutput,
    _In_ POUTPUT_SECTION_MI_REVERSE_VIEW_MAP MiReverseMapOutput
)
{
    ULONG ulResult = ERROR_SUCCESS;
    ULONG_PTR numberOfMappedViews;
    ULONG_PTR viewLinksHead, kernelAddress;
    HTREEITEM mapViewRoot;

    SECTION_COMPAT dumpedSection;
    SEGMENT dumpedSegment;
    CONTROL_AREA_COMPAT dumpedControlArea;
    MI_REVERSE_VIEW_MAP dumpedViewMap;
    //MMVAD dumpedVad;
    LIST_ENTRY viewLinks;

    do {
        //
        // Dump _SECTION structure.
        //
        RtlSecureZeroMemory(&dumpedSection, sizeof(dumpedSection));
        if (!kdReadSystemMemory(SectionObject,
            &dumpedSection,
            sizeof(dumpedSection)))
        {
            ulResult = SECTION_ENUM_MEMORY_READ_FAILURE;
            break;
        }

        if (dumpedSection.u1.RemoteDataFileObject ||
            dumpedSection.u1.RemoteImageFileObject)
        {
            ulResult = SECTION_ENUM_UNSUPPORTED_FLAGS;
            break;
        }

        //
        // Dump CONTROL_AREA
        //
        RtlSecureZeroMemory(&dumpedControlArea, sizeof(dumpedControlArea));
        if (!kdReadSystemMemory((ULONG_PTR)dumpedSection.u1.ControlArea,
            &dumpedControlArea,
            sizeof(dumpedControlArea)))
        {
            ulResult = SECTION_ENUM_MEMORY_READ_FAILURE;
            break;
        }

        //
        // Dump ControlArea->SEGMENT
        //
        RtlSecureZeroMemory(&dumpedSegment, sizeof(dumpedSegment));
        if (!kdReadSystemMemory((ULONG_PTR)dumpedControlArea.Segment,
            &dumpedSegment,
            sizeof(dumpedSegment)))
        {
            ulResult = SECTION_ENUM_MEMORY_READ_FAILURE;
            break;
        }

        if (!IsValidSegment((ULONG_PTR)dumpedSection.u1.ControlArea,
            &dumpedSegment))
        {
            ulResult = SECTION_ENUM_CORRUPT_SEGMENT;
            break;
        }

        numberOfMappedViews = dumpedControlArea.NumberOfMappedViews;

        ControlAreaOutput(TreeList,
            RootItem,
            (ULONG_PTR)dumpedSection.u1.ControlArea,
            &dumpedControlArea);

        SegmentOutput(TreeList,
            RootItem,
            (ULONG_PTR)dumpedControlArea.Segment,
            &dumpedSegment,
            &dumpedControlArea);

        if (numberOfMappedViews) {

            mapViewRoot = CreateNodeCallback(TreeList,
                TEXT("ReverseViewMap"),
                NULL, 
                T_PMI_REVERSE_VIEW_MAP);

            if (mapViewRoot) {

                viewLinks = dumpedControlArea.ListHead;
                viewLinksHead = (ULONG_PTR)dumpedSection.u1.ControlArea + FIELD_OFFSET(CONTROL_AREA_COMPAT, ListHead);

                //
                // Ignore all errors from this.
                //
                ulResult = ERROR_SUCCESS;

                //
                // Walk list entries.
                //
                while ((ULONG_PTR)viewLinks.Flink != viewLinksHead && numberOfMappedViews) {

                    RtlSecureZeroMemory(&dumpedViewMap, sizeof(dumpedViewMap));
                    kernelAddress = (ULONG_PTR)viewLinks.Flink;
                    if (!kdReadSystemMemory(kernelAddress,
                        &dumpedViewMap,
                        sizeof(dumpedViewMap)))
                    {
                        break;
                    }

                    /*kernelAddress -= FIELD_OFFSET(MMVAD, ViewLinks);

                     RtlSecureZeroMemory(&dumpedVad, sizeof(dumpedVad));
                     if (!kdReadSystemMemory(kernelAddress,
                         &dumpedVad,
                         sizeof(dumpedVad)))
                     {
                         break;
                     }*/

                    MiReverseMapOutput(TreeList,
                        mapViewRoot,
                        (ULONG_PTR)viewLinks.Flink,
                        &dumpedViewMap);

                    //
                    // Next entry.
                    //
                    viewLinks = dumpedViewMap.ViewLinks;
                    if (viewLinks.Flink == NULL)
                        break;

                    numberOfMappedViews--;
                }

            }
        }

    } while (FALSE);

    return ulResult;
}

/*
* SectionPropertiesCreate
*
* Purpose:
*
* Initialize information view.
* Called once.
*
*/
VOID SectionPropertiesCreate(
    _In_ HWND hwndDlg,
    _In_ PROP_OBJECT_INFO* ObjectContext,
    _In_ EXTRASCONTEXT* DlgContext
)
{
    ULONG ulResult;
    HTREEITEM rootItem;
    LPWSTR lpError = NULL;

    if (supInitTreeListForDump(hwndDlg, &DlgContext->TreeList)) {

        supTreeListEnableRedraw(DlgContext->TreeList, FALSE);

        rootItem = SectionObjectCreateNode(DlgContext->TreeList,
            TEXT("SECTION"),
            NULL,
            NULL);

        if (rootItem) {

            ulResult = SectionObjectEnumerateFields(DlgContext->TreeList,
                ObjectContext->ObjectInfo.ObjectAddress,
                rootItem,
                (POUTPUT_SECTION_CREATE_NODE)SectionObjectCreateNode,
                (POUTPUT_SECTION_CONTROL_AREA)SectionControlAreaOutput,
                (POUTPUT_SECTION_SEGMENT)SectionSegmentOutput,
                (POUTPUT_SECTION_MI_REVERSE_VIEW_MAP)SectionMiReverseViewMapOutput);

            if (ERROR_SUCCESS != ulResult)
            {
                switch (ulResult) {

                case SECTION_ENUM_MEMORY_READ_FAILURE:
                    lpError = TEXT("Memory could not be read or unspecified read error.");
                    break;

                case SECTION_ENUM_CORRUPT_SEGMENT:
                    lpError = TEXT("SEGMENT is corrupt or paged out - bad control area backlink.");
                    break;

                case SECTION_ENUM_UNSUPPORTED_FLAGS:
                    lpError = TEXT("Object flags are not supported.");
                    break;

                }
                supObDumpShowError(hwndDlg, lpError);
            }

        }

        supTreeListEnableRedraw(DlgContext->TreeList, TRUE);
    }
}

/*
* SectionPropertiesDialogProc
*
* Purpose:
*
* Section object properties page.
*
*/
INT_PTR CALLBACK SectionPropertiesDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    PROPSHEETPAGE* pSheet;
    EXTRASCONTEXT* pDlgContext = NULL;

    switch (uMsg) {

    case WM_CONTEXTMENU:
        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            
            supObjectDumpHandlePopupMenu(hwndDlg, 
                pDlgContext->TreeList, 
                &pDlgContext->tlSubItemHit, 
                lParam);
        
        }
        break;

    case WM_COMMAND:

        pDlgContext = (EXTRASCONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case ID_OBJECT_COPY:
            if (pDlgContext) {

                supTreeListCopyItemValueToClipboard(pDlgContext->TreeList,
                    pDlgContext->tlSubItemHit);
            }
            break;
        }
        break;

    case WM_DESTROY:
        pDlgContext = (EXTRASCONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pDlgContext) {
            DestroyWindow(pDlgContext->TreeList);
            supHeapFree(pDlgContext);
        }
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        break;

    case WM_INITDIALOG:
        pSheet = (PROPSHEETPAGE*)lParam;
        if (pSheet) {
            SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
            pDlgContext = (EXTRASCONTEXT*)supHeapAlloc(sizeof(EXTRASCONTEXT));
            if (pDlgContext) {
                pDlgContext->tlSubItemHit = -1;
                SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pDlgContext);
                SectionPropertiesCreate(hwndDlg, (PROP_OBJECT_INFO*)pSheet->lParam, pDlgContext);
            }
        }
        break;

    default:
        return FALSE;

    }
    return TRUE;
}

```

`Source/WinObjEx64/props/propSecurity.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       PROPSECURITY.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "propSecurityConsts.h"

typedef struct _ObjectSecurityVtbl ObjectSecurityVtbl, * PObjectSecurityVtbl;

//class
typedef struct _IObjectSecurity {
    ObjectSecurityVtbl* lpVtbl;
    ULONG RefCount;
    ULONG psiFlags;
    ULONG dwAccessMax;
    GENERIC_MAPPING GenericMapping;
    ACCESS_MASK ValidAccessMask;
    HINSTANCE hInstance;
    PROP_OBJECT_INFO* ObjectContext;
    PSI_ACCESS AccessTable;//dynamically allocated access table
    POPENOBJECTMETHOD OpenObjectMethod;
    PCLOSEOBJECTMETHOD CloseObjectMethod;
} IObjectSecurity, * PIObjectSecurity;


//Vtbl prototypes

typedef HRESULT(STDMETHODCALLTYPE* pQueryInterface)(
    _In_ IObjectSecurity* This,
    _In_ REFIID riid,
    _Out_ void** ppvObject);

typedef ULONG(STDMETHODCALLTYPE* pAddRef)(
    _In_ IObjectSecurity* This);

typedef ULONG(STDMETHODCALLTYPE* pRelease)(
    _In_ IObjectSecurity* This);

// *** ISecurityInformation methods ***
typedef HRESULT(STDMETHODCALLTYPE* pGetObjectInformation)(
    _In_ IObjectSecurity* This,
    _Out_ PSI_OBJECT_INFO pObjectInfo);

typedef HRESULT(STDMETHODCALLTYPE* pGetSecurity)(
    _In_ IObjectSecurity* This,
    _In_ SECURITY_INFORMATION RequestedInformation,
    _Out_ PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
    _In_ BOOL fDefault);

typedef HRESULT(STDMETHODCALLTYPE* pSetSecurity)(
    _In_ IObjectSecurity* This,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR pSecurityDescriptor);

typedef HRESULT(STDMETHODCALLTYPE* pGetAccessRights)(
    _In_ IObjectSecurity* This,
    _In_ const GUID* pguidObjectType,
    _In_ DWORD dwFlags,
    _Out_ PSI_ACCESS* ppAccess,
    _Out_ ULONG* pcAccesses,
    _Out_ ULONG* piDefaultAccess);

typedef HRESULT(STDMETHODCALLTYPE* pMapGeneric)(
    _In_ IObjectSecurity* This,
    _In_ const GUID* pguidObjectType,
    _In_ UCHAR* pAceFlags,
    _In_ ACCESS_MASK* pMask);

typedef HRESULT(STDMETHODCALLTYPE* pGetInheritTypes)(
    _In_ IObjectSecurity* This,
    _Out_ PSI_INHERIT_TYPE* ppInheritTypes,
    _Out_ ULONG* pcInheritTypes);

typedef HRESULT(STDMETHODCALLTYPE* pPropertySheetPageCallback)(
    _In_ IObjectSecurity* This,
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ SI_PAGE_TYPE uPage);

typedef struct _ObjectSecurityVtbl {
    pQueryInterface             QueryInterface;
    pAddRef                     AddRef;
    pRelease                    Release;
    pGetObjectInformation       GetObjectInformation;
    pGetSecurity                GetSecurity;
    pSetSecurity                SetSecurity;
    pGetAccessRights            GetAccessRights;
    pMapGeneric                 MapGeneric;
    pGetInheritTypes            GetInheritTypes;
    pPropertySheetPageCallback  PropertySheetPageCallback;
} ObjectSecurityVtbl, * PObjectSecurityVtbl;

/*
* propSecurityObjectSupported
*
* Purpose:
*
* Check we can show security for the given object type.
*
*/
BOOL propSecurityObjectSupported(
    _In_ WOBJ_OBJECT_TYPE nTypeIndex
)
{
    WOBJ_OBJECT_TYPE SecuritySupportedTypes[] = {
        ObjectTypeDesktop,
        ObjectTypeDevice,
        ObjectTypeDirectory,
        ObjectTypeEvent,
        ObjectTypeEventPair,
        ObjectTypeFile,
        ObjectTypeIoCompletion,
        ObjectTypeJob,
        ObjectTypeKey,
        ObjectTypeMemoryPartition,
        ObjectTypeMutant,
        ObjectTypePort,
        ObjectTypeProcess,
        ObjectTypeRegistryTransaction,
        ObjectTypeSection,
        ObjectTypeSemaphore,
        ObjectTypeSession,
        ObjectTypeSymbolicLink,
        ObjectTypeThread,
        ObjectTypeTimer,
        ObjectTypeToken,
        ObjectTypeWinstation
    };

    UINT i;
    for (i = 0; i < RTL_NUMBER_OF(SecuritySupportedTypes); i++) {
        if (SecuritySupportedTypes[i] == nTypeIndex)
            return TRUE;
    }

    return FALSE;
}

/*
* propGetAccessTable
*
* Purpose:
*
* Return access rights table and set generic mappings depending on object type.
*
*/
PSI_ACCESS propGetAccessTable(
    _In_ IObjectSecurity* This
)
{
    SI_ACCESS* AccessTable = NULL;

    switch (This->ObjectContext->ObjectTypeIndex) {

    case ObjectTypeDirectory:
        This->dwAccessMax = MAX_KNOWN_DIRECTORY_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&DirectoryAccessValues;
        break;

    case ObjectTypeFile:
    case ObjectTypeDevice:
        This->dwAccessMax = MAX_KNOWN_FILE_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&FileAccessValues;
        break;

    case ObjectTypeSection:
        This->dwAccessMax = MAX_KNOWN_SECTION_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&SectionAccessValues;
        break;

    case ObjectTypeEvent:
        This->dwAccessMax = MAX_KNOWN_EVENT_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&EventAccessValues;
        break;

    case ObjectTypeMutant:
        This->dwAccessMax = MAX_KNOWN_MUTANT_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&MutantAccessValues;
        break;

    case ObjectTypeDesktop:
        This->dwAccessMax = MAX_KNOWN_DESKTOP_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&DesktopAccessValues;
        break;

    case ObjectTypeWinstation:
        This->dwAccessMax = MAX_KNOWN_WINSTATION_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&WinStationAccessValues;
        break;

    case ObjectTypeKey:
        This->dwAccessMax = MAX_KNOWN_KEY_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&KeyAccessValues;
        break;

    case ObjectTypeSemaphore:
        This->dwAccessMax = MAX_KNOWN_SEMAPHORE_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&SemaphoreAccessValues;
        break;

    case ObjectTypeSymbolicLink:
        This->dwAccessMax = MAX_KNOWN_SYMLINK_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&SymlinkAccessValues;
        break;

    case ObjectTypeTimer:
        This->dwAccessMax = MAX_KNOWN_TIMER_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&TimerAccessValues;
        break;

    case ObjectTypeJob:
        This->dwAccessMax = MAX_KNOWN_JOB_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&JobAccessValues;
        break;

    case ObjectTypeSession:
        This->dwAccessMax = MAX_KNOWN_SESSION_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&SessionAccessValues;
        break;

    case ObjectTypeIoCompletion:
    case ObjectTypeIoCompletionReserve:
        This->dwAccessMax = MAX_KNOWN_IOCOMPLETION_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&IoCompletionAccessValues;
        break;

    case ObjectTypeMemoryPartition:
        This->dwAccessMax = MAX_KNOWN_MEMORYPARTITION_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&MemoryPartitionAccessValues;
        break;

    case ObjectTypeProcess:
        This->dwAccessMax = MAX_KNOWN_PROCESS_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&ProcessAccessValues;
        break;

    case ObjectTypeThread:
        This->dwAccessMax = MAX_KNOWN_THREAD_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&ThreadAccessValues;
        break;

    case ObjectTypeToken:
        This->dwAccessMax = MAX_KNOWN_TOKEN_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&TokenAccessValues;
        break;

    case ObjectTypePort:
        This->dwAccessMax = MAX_KNOWN_PORT_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&PortAccessValues;
        break;

    case ObjectTypeRegistryTransaction:
        This->dwAccessMax = MAX_KNOWN_TRANSACTION_ACCESS_VALUE;
        AccessTable = (PSI_ACCESS)&TransactionAccessValues;
        break;
    }

    return AccessTable;
}

/*
* propGetObjectAccessMask
*
* Purpose:
*
* Query required access mask to get/set object security.
*
*/
ACCESS_MASK propGetObjectAccessMask(
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ BOOL fSet
)
{
    ACCESS_MASK AccessMask = 0;

    if (fSet) {
        if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
            (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
            (SecurityInformation & LABEL_SECURITY_INFORMATION))
        {
            AccessMask |= WRITE_OWNER;
        }

        if ((SecurityInformation & DACL_SECURITY_INFORMATION) ||
            (SecurityInformation & ATTRIBUTE_SECURITY_INFORMATION) ||
            (SecurityInformation & PROTECTED_DACL_SECURITY_INFORMATION) ||
            (SecurityInformation & UNPROTECTED_DACL_SECURITY_INFORMATION))
        {
            AccessMask |= WRITE_DAC;
        }

        if ((SecurityInformation & SACL_SECURITY_INFORMATION) ||
            (SecurityInformation & SCOPE_SECURITY_INFORMATION) ||
            (SecurityInformation & PROTECTED_SACL_SECURITY_INFORMATION) ||
            (SecurityInformation & UNPROTECTED_SACL_SECURITY_INFORMATION))
        {
            AccessMask |= ACCESS_SYSTEM_SECURITY;
        }

        if (SecurityInformation & BACKUP_SECURITY_INFORMATION) {

            AccessMask |= WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY;
        }
    }
    else {
        //get
        if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
            (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
            (SecurityInformation & DACL_SECURITY_INFORMATION) ||
            (SecurityInformation & LABEL_SECURITY_INFORMATION) ||
            (SecurityInformation & ATTRIBUTE_SECURITY_INFORMATION) ||
            (SecurityInformation & SCOPE_SECURITY_INFORMATION))
        {
            AccessMask |= READ_CONTROL;
        }

        if (SecurityInformation & SACL_SECURITY_INFORMATION) {
            AccessMask |= ACCESS_SYSTEM_SECURITY;
        }

        if (SecurityInformation & BACKUP_SECURITY_INFORMATION) {
            AccessMask |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
        }

    }
    return AccessMask;
}

HRESULT STDMETHODCALLTYPE QueryInterface(
    _In_ IObjectSecurity* This,
    _In_ REFIID riid,
    _Out_ void** ppvObject
)
{
#if defined(__cplusplus)
    if (IsEqualIID(riid, IID_ISecurityInformation) ||
        IsEqualIID(riid, IID_IUnknown))
#else
    if (IsEqualIID(riid, &IID_ISecurityInformation) ||
        IsEqualIID(riid, &IID_IUnknown))
#endif
    {
        *ppvObject = This;
        This->lpVtbl->AddRef(This);
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE AddRef(
    _In_ IObjectSecurity* This
)
{
    return ++This->RefCount;
}

ULONG STDMETHODCALLTYPE Release(
    _In_ IObjectSecurity* This
)
{
    This->RefCount--;

    if (This->RefCount == 0) {
        if (This->AccessTable) {
            supHeapFree(This->AccessTable);
        }
        supHeapFree(This);
        return S_OK;
    }
    return This->RefCount;
}

HRESULT STDMETHODCALLTYPE GetObjectInformation(
    _In_ IObjectSecurity* This,
    _Out_ PSI_OBJECT_INFO pObjectInfo
)
{
    pObjectInfo->dwFlags = This->psiFlags;
    pObjectInfo->hInstance = This->hInstance;
    pObjectInfo->pszPageTitle = TEXT("Security");
    pObjectInfo->pszObjectName = This->ObjectContext->NtObjectName.Buffer;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE GetAccessRights(
    _In_ IObjectSecurity* This,
    _In_ const GUID* pguidObjectType,
    _In_ DWORD dwFlags,
    _Out_ PSI_ACCESS* ppAccess,
    _Out_ ULONG* pcAccesses,
    _Out_ ULONG* piDefaultAccess
)
{
    UNREFERENCED_PARAMETER(pguidObjectType);
    UNREFERENCED_PARAMETER(dwFlags);

    *ppAccess = This->AccessTable;
    *pcAccesses = This->dwAccessMax;
    *piDefaultAccess = 0;

    return S_OK;
}

/*
* GetSecurity
*
* Purpose:
*
* Query object security descriptor and return it to security UI.
*
*/
HRESULT STDMETHODCALLTYPE GetSecurity(
    _In_ IObjectSecurity* This,
    _In_ SECURITY_INFORMATION RequestedInformation,
    _Out_ PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
    _In_ BOOL fDefault
)
{
    HRESULT                hResult = E_FAIL;
    HANDLE                 hObject = NULL;
    ULONG                  bytesNeeded = 0x100;
    NTSTATUS               status;
    ACCESS_MASK            DesiredAccess;
    PSECURITY_DESCRIPTOR   pSD;

    if (fDefault) {
        return E_NOTIMPL;
    }

    //open object
    DesiredAccess = propGetObjectAccessMask(RequestedInformation, FALSE);
    if (!This->OpenObjectMethod(This->ObjectContext, &hObject, DesiredAccess)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    do {
        //query object SD
        //warning: system free SD with LocalFree on security dialog destroy
        pSD = LocalAlloc(LPTR, bytesNeeded);
        if (pSD == NULL) {
            hResult = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        status = NtQuerySecurityObject(hObject,
            RequestedInformation,
            pSD,
            bytesNeeded,
            &bytesNeeded);

        if (status == STATUS_BUFFER_TOO_SMALL) {
            LocalFree(pSD);
            pSD = LocalAlloc(LPTR, bytesNeeded);
            if (pSD == NULL) {
                hResult = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            status = NtQuerySecurityObject(
                hObject,
                RequestedInformation,
                pSD,
                bytesNeeded,
                &bytesNeeded);
        }

        if (!NT_SUCCESS(status)) {
            hResult = HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));
            break;
        }

        *ppSecurityDescriptor = pSD;
        pSD = NULL; //ownership transfered to caller
        hResult = S_OK;

    } while (FALSE);

    // cleanup
    This->CloseObjectMethod(This->ObjectContext, hObject);
    if (pSD) {
        LocalFree(pSD);
    }
    return hResult;
}

HRESULT STDMETHODCALLTYPE SetSecurity(
    _In_ IObjectSecurity* This,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR pSecurityDescriptor
)
{
    NTSTATUS       status;
    HANDLE         hObject = NULL;
    ACCESS_MASK    DesiredAccess;

    DesiredAccess = propGetObjectAccessMask(SecurityInformation, TRUE);
    if (!This->OpenObjectMethod(This->ObjectContext, &hObject, DesiredAccess)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    status = NtSetSecurityObject(hObject, SecurityInformation, pSecurityDescriptor);

    //cleanup
    This->CloseObjectMethod(This->ObjectContext, hObject);
    return HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));
}

HRESULT STDMETHODCALLTYPE MapGeneric(
    _In_ IObjectSecurity* This,
    _In_ const GUID* pguidObjectType,
    _In_ UCHAR* pAceFlags,
    _In_ ACCESS_MASK* pMask
)
{
    UNREFERENCED_PARAMETER(pguidObjectType);
    UNREFERENCED_PARAMETER(pAceFlags);

    RtlMapGenericMask(pMask, &This->GenericMapping);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE GetInheritTypes(
    _In_ IObjectSecurity* This,
    _Out_ PSI_INHERIT_TYPE* ppInheritTypes,
    _Out_ ULONG* pcInheritTypes
)
{
    UNREFERENCED_PARAMETER(This);
    UNREFERENCED_PARAMETER(ppInheritTypes);
    UNREFERENCED_PARAMETER(pcInheritTypes);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE PropertySheetPageCallback(
    _In_ IObjectSecurity* This,
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ SI_PAGE_TYPE uPage
)
{
    UNREFERENCED_PARAMETER(This);
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(uPage);

    return E_NOTIMPL;
}

//class methods
ObjectSecurityVtbl g_Vtbl = {
    QueryInterface,
    AddRef,
    Release,
    GetObjectInformation,
    GetSecurity,
    SetSecurity,
    GetAccessRights,
    MapGeneric,
    GetInheritTypes,
    PropertySheetPageCallback
};

/*
* propSecurityConstructor
*
* Purpose:
*
* Initialize class object, query type info, Vtbl, AccessTable, object specific methods.
*
*/
HRESULT propSecurityConstructor(
    _In_ IObjectSecurity* This,
    _In_ PROP_OBJECT_INFO* Context,
    _In_ POPENOBJECTMETHOD OpenObjectMethod,
    _In_opt_ PCLOSEOBJECTMETHOD CloseObjectMethod,
    _In_ ULONG psiFlags
)
{
    ULONG                       bytesNeeded = 0L;
    NTSTATUS                    status;
    SIZE_T                      Size;
    HRESULT                     hResult;
    HANDLE                      hObject = NULL;
    PSI_ACCESS                  TypeAccessTable = NULL;
    POBJECT_TYPE_INFORMATION    TypeInfo = NULL;

    This->ObjectContext = Context;
    This->OpenObjectMethod = OpenObjectMethod;

    if (CloseObjectMethod == NULL) {
        This->CloseObjectMethod = (PCLOSEOBJECTMETHOD)supCloseObjectFromContext;
    }
    else {
        This->CloseObjectMethod = CloseObjectMethod;
    }

    do {

        if (!This->OpenObjectMethod(Context, &hObject, READ_CONTROL)) {
            hResult = E_ACCESSDENIED;
            break;
        }

        status = supQueryObjectInformation(hObject,
            ObjectTypeInformation,
            &TypeInfo,
            &bytesNeeded);

        if (!NT_SUCCESS(status)) {
            hResult = HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));
            break;
        }

        This->GenericMapping = TypeInfo->GenericMapping;
        This->ValidAccessMask = TypeInfo->ValidAccessMask;

        supHeapFree(TypeInfo);
        TypeInfo = NULL;

        This->lpVtbl = &g_Vtbl;
        This->hInstance = g_WinObj.hInstance;
        This->psiFlags = psiFlags;

        TypeAccessTable = propGetAccessTable(This);

        //allocate access table
        Size = (MAX_KNOWN_GENERAL_ACCESS_VALUE + (SIZE_T)This->dwAccessMax) * sizeof(SI_ACCESS);
        This->AccessTable = (PSI_ACCESS)supHeapAlloc(Size);
        if (This->AccessTable == NULL) {
            hResult = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //copy object specific access table if it present
        if (TypeAccessTable && This->dwAccessMax) {

            RtlCopyMemory(This->AccessTable,
                TypeAccessTable,
                This->dwAccessMax * sizeof(SI_ACCESS));

        }

        if (This->ValidAccessMask & DELETE) {
            RtlCopyMemory(&This->AccessTable[This->dwAccessMax++],
                &GeneralAccessValues[0], sizeof(SI_ACCESS));
        }
        if (This->ValidAccessMask & READ_CONTROL) {
            RtlCopyMemory(&This->AccessTable[This->dwAccessMax++],
                &GeneralAccessValues[1], sizeof(SI_ACCESS));
        }
        if (This->ValidAccessMask & WRITE_DAC) {
            RtlCopyMemory(&This->AccessTable[This->dwAccessMax++],
                &GeneralAccessValues[2], sizeof(SI_ACCESS));
        }
        if (This->ValidAccessMask & WRITE_OWNER) {
            RtlCopyMemory(&This->AccessTable[This->dwAccessMax++],
                &GeneralAccessValues[3], sizeof(SI_ACCESS));
        }
        if (This->ValidAccessMask & SYNCHRONIZE) {
            RtlCopyMemory(&This->AccessTable[This->dwAccessMax++],
                &GeneralAccessValues[4], sizeof(SI_ACCESS));
        }
        hResult = S_OK;

    } while (FALSE);

    //cleanup
    if (hObject) This->CloseObjectMethod(Context, hObject);
    if (TypeInfo) {
        supHeapFree(TypeInfo);
    }
    return hResult;
}

/*
* propSecurityCreatePage
*
* Purpose:
*
* Create Security page.
*
*
* Page creation methods call sequence:
* AddRef->QueryInterface->GetObjectInformation->PropertySheetPageCallback.
*
* Page query info call sequence:
* PropertySheetPageCallback->GetObjectInformation->GetAccessRights->GetSecurity->MapGeneric.
*
* Page close call sequence:
* PropertySheetPageCallback->Release.
*
*/
HPROPSHEETPAGE propSecurityCreatePage(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ POPENOBJECTMETHOD OpenObjectMethod,
    _In_opt_ PCLOSEOBJECTMETHOD CloseObjectMethod,
    _In_ ULONG psiFlags
)
{
    IObjectSecurity* psi;

    if (!propSecurityObjectSupported(Context->ObjectTypeIndex)) {
        return NULL;
    }

    psi = (IObjectSecurity*)supHeapAlloc(sizeof(IObjectSecurity));
    if (psi == NULL)
        return NULL;

    if (S_OK != propSecurityConstructor(
        psi,
        Context,
        OpenObjectMethod,
        CloseObjectMethod,
        psiFlags))
    {
        supHeapFree(psi);
        return NULL;
    }

    return CreateSecurityPage((LPSECURITYINFO)psi); //-V1027
}

```

`Source/WinObjEx64/props/propSecurityConsts.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPSECURITYCONSTS.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Consts header file for Security property sheet.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

/********************************************************************************
*
* Access values for supported types
*
*********************************************************************************/

#define SI_ACCESS_DEFAULT_FLAGS SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC

#define SI_ACCESS_DEFAULT_ENTRY(Access, Name) { &GUID_NULL, Access, Name, SI_ACCESS_DEFAULT_FLAGS }

//
//General Access Values
//
#define MAX_KNOWN_GENERAL_ACCESS_VALUE 5
static SI_ACCESS GeneralAccessValues[MAX_KNOWN_GENERAL_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(DELETE, L"Delete"),
    SI_ACCESS_DEFAULT_ENTRY(READ_CONTROL, L"Read Control"),
    SI_ACCESS_DEFAULT_ENTRY(WRITE_DAC, L"Write DAC"),
    SI_ACCESS_DEFAULT_ENTRY(WRITE_OWNER, L"Write Owner"),
    SI_ACCESS_DEFAULT_ENTRY(SYNCHRONIZE, L"Synchronize")
};

//
//Section Access Values
//
#define MAX_KNOWN_SECTION_ACCESS_VALUE 5
static SI_ACCESS SectionAccessValues[MAX_KNOWN_SECTION_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(SECTION_QUERY, L"Query"),
    SI_ACCESS_DEFAULT_ENTRY(SECTION_MAP_WRITE, L"Map Write"),
    SI_ACCESS_DEFAULT_ENTRY(SECTION_MAP_READ, L"Map Read"),
    SI_ACCESS_DEFAULT_ENTRY(SECTION_MAP_EXECUTE, L"Map Execute"),
    SI_ACCESS_DEFAULT_ENTRY(SECTION_EXTEND_SIZE, L"Extend Size")
};

//
//Directory Access Values
//
#define MAX_KNOWN_DIRECTORY_ACCESS_VALUE 4
static SI_ACCESS DirectoryAccessValues[MAX_KNOWN_DIRECTORY_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(DIRECTORY_QUERY, L"Query"),
    SI_ACCESS_DEFAULT_ENTRY(DIRECTORY_TRAVERSE, L"Traverse"),
    SI_ACCESS_DEFAULT_ENTRY(DIRECTORY_CREATE_OBJECT, L"Create Object"),
    SI_ACCESS_DEFAULT_ENTRY(DIRECTORY_CREATE_SUBDIRECTORY, L"Create SubDirectory")
};

//
//File Access Values
//
#define MAX_KNOWN_FILE_ACCESS_VALUE 14
static SI_ACCESS FileAccessValues[MAX_KNOWN_FILE_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(FILE_READ_DATA, L"Read Data"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_LIST_DIRECTORY, L"List Directory"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_WRITE_DATA, L"Write Data"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_ADD_FILE, L"Add File"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_APPEND_DATA, L"Append Data"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_ADD_SUBDIRECTORY, L"Add SubDirectory"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_CREATE_PIPE_INSTANCE, L"Create Pipe Instance"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_READ_EA, L"Read EA"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_WRITE_EA, L"Write EA"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_EXECUTE, L"Execute"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_TRAVERSE, L"Traverse"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_DELETE_CHILD, L"Delete Child"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_READ_ATTRIBUTES, L"Read Attributes"),
    SI_ACCESS_DEFAULT_ENTRY(FILE_WRITE_ATTRIBUTES, L"Write Attributes")
};

//
//Event Access Values
//
#define MAX_KNOWN_EVENT_ACCESS_VALUE 2
static SI_ACCESS EventAccessValues[MAX_KNOWN_EVENT_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(EVENT_QUERY_STATE, L"Query State"),
    SI_ACCESS_DEFAULT_ENTRY(EVENT_MODIFY_STATE, L"Modify State")
};

//
//Mutant Access Values
//
#define MAX_KNOWN_MUTANT_ACCESS_VALUE 1
static SI_ACCESS MutantAccessValues[MAX_KNOWN_MUTANT_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(MUTANT_QUERY_STATE, L"Query State")
};

//
//Desktop Access Values
//
#define MAX_KNOWN_DESKTOP_ACCESS_VALUE 9
static SI_ACCESS DesktopAccessValues[MAX_KNOWN_DESKTOP_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_READOBJECTS, L"Read Objects"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_CREATEWINDOW, L"Create Window"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_CREATEMENU, L"Create Menu"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_HOOKCONTROL, L"Hook Control"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_JOURNALRECORD, L"Journal Record"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_JOURNALPLAYBACK, L"Journal Playback"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_ENUMERATE, L"Enumerate"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_WRITEOBJECTS, L"Write Objects"),
    SI_ACCESS_DEFAULT_ENTRY(DESKTOP_SWITCHDESKTOP, L"Switch Desktop")
};

//
//WinStation Access Values
//
#define MAX_KNOWN_WINSTATION_ACCESS_VALUE 9
static SI_ACCESS WinStationAccessValues[MAX_KNOWN_WINSTATION_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_ENUMDESKTOPS, L"Enumerate Desktops"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_READATTRIBUTES, L"Read Attributes"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_ACCESSCLIPBOARD, L"Access Clipboard"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_CREATEDESKTOP, L"Create Desktop"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_WRITEATTRIBUTES, L"Write Attributes"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_ACCESSGLOBALATOMS, L"Access Global Atoms"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_EXITWINDOWS, L"Exit Windows"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_ENUMERATE, L"Enumerate"),
    SI_ACCESS_DEFAULT_ENTRY(WINSTA_READSCREEN, L"Read Screen")
};

//
//Key Access Values
//
#define MAX_KNOWN_KEY_ACCESS_VALUE 8
static SI_ACCESS KeyAccessValues[MAX_KNOWN_KEY_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(KEY_QUERY_VALUE, L"Query Value"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_SET_VALUE, L"Set Value"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_CREATE_SUB_KEY, L"Create Subkey"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_ENUMERATE_SUB_KEYS, L"Enumerate Subkeys"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_NOTIFY, L"Notify"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_CREATE_LINK, L"Create Link"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_WOW64_64KEY, L"Access 64 bit key"),
    SI_ACCESS_DEFAULT_ENTRY(KEY_WOW64_32KEY, L"Access 32 bit key")
};

//
//Semaphore Access Values
//
#define MAX_KNOWN_SEMAPHORE_ACCESS_VALUE 2
static SI_ACCESS SemaphoreAccessValues[MAX_KNOWN_SEMAPHORE_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(SEMAPHORE_QUERY_STATE, L"Query State"),
    SI_ACCESS_DEFAULT_ENTRY(SEMAPHORE_MODIFY_STATE, L"Modify State")
};

//
//Symlink Access Values
//
#define MAX_KNOWN_SYMLINK_ACCESS_VALUE 2
static SI_ACCESS SymlinkAccessValues[MAX_KNOWN_SYMLINK_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(SYMBOLIC_LINK_QUERY, L"Link Query"),
    SI_ACCESS_DEFAULT_ENTRY(SYMBOLIC_LINK_SET, L"Link Set")
};

//
//Timer Access Values
//
#define MAX_KNOWN_TIMER_ACCESS_VALUE 2
static SI_ACCESS TimerAccessValues[MAX_KNOWN_TIMER_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(TIMER_QUERY_STATE, L"Query State"),
    SI_ACCESS_DEFAULT_ENTRY(TIMER_MODIFY_STATE, L"Modify State")
};

//
//Job Access Values
//
#define MAX_KNOWN_JOB_ACCESS_VALUE 5
static SI_ACCESS JobAccessValues[MAX_KNOWN_JOB_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(JOB_OBJECT_ASSIGN_PROCESS, L"Assign Process"),
    SI_ACCESS_DEFAULT_ENTRY(JOB_OBJECT_SET_ATTRIBUTES, L"Set Attributes"),
    SI_ACCESS_DEFAULT_ENTRY(JOB_OBJECT_QUERY, L"Query"),
    SI_ACCESS_DEFAULT_ENTRY(JOB_OBJECT_TERMINATE, L"Terminate"),
    SI_ACCESS_DEFAULT_ENTRY(JOB_OBJECT_SET_SECURITY_ATTRIBUTES, L"Set Security Attributes")
};

//
//Port Access Values
//
#define MAX_KNOWN_PORT_ACCESS_VALUE 1
static SI_ACCESS PortAccessValues[MAX_KNOWN_PORT_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(PORT_CONNECT, L"Connect")
};

//
//Session Access Values
//
#define MAX_KNOWN_SESSION_ACCESS_VALUE 2
static SI_ACCESS SessionAccessValues[MAX_KNOWN_SESSION_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(SESSION_QUERY_ACCESS, L"Query"),
    SI_ACCESS_DEFAULT_ENTRY(SESSION_MODIFY_ACCESS, L"Modify")
};

//
//IoCompletion Access Values
//
#define MAX_KNOWN_IOCOMPLETION_ACCESS_VALUE 2
static SI_ACCESS IoCompletionAccessValues[MAX_KNOWN_IOCOMPLETION_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(IO_COMPLETION_QUERY_STATE, L"Query State"),
    SI_ACCESS_DEFAULT_ENTRY(IO_COMPLETION_MODIFY_STATE, L"Modify State")
};

//
//MemoryPartition Access Values
//
#define MAX_KNOWN_MEMORYPARTITION_ACCESS_VALUE 2
static SI_ACCESS MemoryPartitionAccessValues[MAX_KNOWN_MEMORYPARTITION_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(MEMORY_PARTITION_QUERY_ACCESS, L"Query"),
    SI_ACCESS_DEFAULT_ENTRY(MEMORY_PARTITION_MODIFY_ACCESS, L"Modify")
};

//
//Process Access Values
//
#define MAX_KNOWN_PROCESS_ACCESS_VALUE 14
static SI_ACCESS ProcessAccessValues[MAX_KNOWN_PROCESS_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_TERMINATE, L"Terminate"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_CREATE_THREAD, L"Create Thread"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_SET_SESSIONID, L"Set Session Id"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_VM_OPERATION, L"VM Operation"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_VM_READ, L"VM Read"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_VM_WRITE, L"VM Write"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_DUP_HANDLE, L"Duplicate Handle"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_CREATE_PROCESS, L"Create Process"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_SET_QUOTA, L"Set Quota"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_SET_INFORMATION, L"Set Information"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_QUERY_INFORMATION, L"Query Information"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_SUSPEND_RESUME, L"Suspend Resume"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_QUERY_LIMITED_INFORMATION, L"Query Limited Information"),
    SI_ACCESS_DEFAULT_ENTRY(PROCESS_SET_LIMITED_INFORMATION, L"Set Limited Information")
};

//
//Thread Access Values
//
#define MAX_KNOWN_THREAD_ACCESS_VALUE 13
static SI_ACCESS ThreadAccessValues[MAX_KNOWN_THREAD_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(THREAD_TERMINATE, L"Terminate"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_SUSPEND_RESUME, L"Suspend Resume"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_ALERT, L"Alert"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_GET_CONTEXT, L"Get Context"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_SET_CONTEXT, L"Set Context"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_QUERY_INFORMATION, L"Query Information"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_SET_INFORMATION, L"Set Information"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_SET_THREAD_TOKEN, L"Set Thread Token"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_IMPERSONATE, L"Impersonate"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_DIRECT_IMPERSONATION, L"Direct Impersonation"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_SET_LIMITED_INFORMATION, L"Set Limited Information"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_QUERY_LIMITED_INFORMATION, L"Query Limited Information"),
    SI_ACCESS_DEFAULT_ENTRY(THREAD_RESUME, L"Resume")
};

//
//Token Access Values
//
#define MAX_KNOWN_TOKEN_ACCESS_VALUE 9

static SI_ACCESS TokenAccessValues[MAX_KNOWN_TOKEN_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_ASSIGN_PRIMARY, L"Assign Primary"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_DUPLICATE, L"Duplicate"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_IMPERSONATE, L"Impersonate"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_QUERY, L"Query"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_QUERY_SOURCE, L"Query Source"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_ADJUST_PRIVILEGES, L"Adjust Privileges"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_ADJUST_GROUPS, L"Adjust Groups"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_ADJUST_DEFAULT, L"Adjust Default"),
    SI_ACCESS_DEFAULT_ENTRY(TOKEN_ADJUST_SESSIONID, L"Adjust SessionId")
};

#define MAX_KNOWN_TRANSACTION_ACCESS_VALUE 7
static SI_ACCESS TransactionAccessValues[MAX_KNOWN_TRANSACTION_ACCESS_VALUE] = {
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_QUERY_INFORMATION, L"Query Information"),
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_SET_INFORMATION, L"Set Information"),
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_ENLIST, L"Enlist"),
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_COMMIT, L"Commit"),
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_ROLLBACK, L"Rollback"),
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_PROPAGATE, L"Propagate"),
    SI_ACCESS_DEFAULT_ENTRY(TRANSACTION_RIGHT_RESERVED1, L"Right Reserved1")
};

```

`Source/WinObjEx64/props/propToken.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       PROPTOKEN.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "propDlg.h"

#define T_TOKEN_PROP_CID_PID    TEXT("propTokenPid")
#define T_TOKEN_PROP_CID_TID    TEXT("propTokenTid")
#define T_TOKEN_PROP_TYPE       TEXT("propTokenType")

//
// Small context for this dialog.
//
typedef struct _TOKEN_PAGE_CONTEXT {
    HWND hwndList;
    INT  lvSelectedItem;
    INT  lvColumnHit;
} TOKEN_PAGE_CONTEXT, * PTOKEN_PAGE_CONTEXT;

static PTOKEN_PAGE_CONTEXT TokenPageGetContext(
    _In_ HWND hwndDlg
)
{
    return (PTOKEN_PAGE_CONTEXT)GetProp(hwndDlg, T_DLGCONTEXT);
}

/*
* TokenPageShowError
*
* Purpose:
*
* Hide all windows for given hwnd and display error text with custom text if specified.
*
*/
VOID TokenPageShowError(
    _In_ HWND hwndDlg,
    _In_opt_ LPWSTR lpMessageText
)
{
    ENUMCHILDWNDDATA ChildWndData;

    if (GetWindowRect(hwndDlg, &ChildWndData.Rect)) {
        ChildWndData.nCmdShow = SW_HIDE;
        EnumChildWindows(hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
    }

    if (lpMessageText) {
        SetDlgItemText(hwndDlg, IDC_TOKEN_ERROR, lpMessageText);
    }
    ShowWindow(GetDlgItem(hwndDlg, IDC_TOKEN_ERROR), SW_SHOW);
}

/*
* TokenPageInitControls
*
* Purpose:
*
* Initialize page controls.
*
*/
VOID TokenPageInitControls(
    _In_ HWND hwndDlg,
    _In_ BOOLEAN IsAppContainer
)
{
    LVGROUP lvg;
    PTOKEN_PAGE_CONTEXT pCtx;

    pCtx = TokenPageGetContext(hwndDlg);
    if (pCtx == NULL) {
        return;
    }

    pCtx->hwndList = GetDlgItem(hwndDlg, IDC_TOKEN_PRIVLIST);
    pCtx->lvSelectedItem = -1;
    pCtx->lvColumnHit = -1;

    //
    // Set listview style flags and theme.
    //
    supSetListViewSettings(pCtx->hwndList,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        NULL,
        0);

    SendMessage(pCtx->hwndList, LVM_ENABLEGROUPVIEW, 1, 0);

    supAddListViewColumn(pCtx->hwndList, 0, 0, 0,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("Name"), 400);

    supAddListViewColumn(pCtx->hwndList, 1, 1, 1,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("Status"), 150);

    RtlSecureZeroMemory(&lvg, sizeof(lvg));
    lvg.cbSize = sizeof(LVGROUP);
    lvg.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID;
    lvg.uAlign = LVGA_HEADER_LEFT;

    lvg.pszHeader = TEXT("Privileges");
    lvg.cchHeader = (INT)_strlen(lvg.pszHeader);
    lvg.iGroupId = 0;
    SendMessage(pCtx->hwndList, LVM_INSERTGROUP, (WPARAM)0, (LPARAM)&lvg);

    lvg.pszHeader = TEXT("Groups");
    lvg.cchHeader = (INT)_strlen(lvg.pszHeader);
    lvg.iGroupId = 1;
    SendMessage(pCtx->hwndList, LVM_INSERTGROUP, (WPARAM)1, (LPARAM)&lvg);

    if (IsAppContainer) {
        lvg.pszHeader = TEXT("Capabilities");
        lvg.cchHeader = (INT)_strlen(lvg.pszHeader);
        lvg.iGroupId = 2;
        SendMessage(pCtx->hwndList, LVM_INSERTGROUP, (WPARAM)2, (LPARAM)&lvg);
    }

    SetDlgItemText(hwndDlg, IDC_TOKEN_USER, T_CannotQuery);
    SetDlgItemText(hwndDlg, IDC_TOKEN_SID, T_CannotQuery);
    SetDlgItemText(hwndDlg, IDC_TOKEN_APPCONTAINER, T_CannotQuery);
}

/*
* TokenPageListAdd
*
* Purpose:
*
* Add item to page listview.
*
*/
VOID TokenPageListAdd(
    _In_ INT GroupIndex,
    _In_ LPWSTR lpName,
    _In_ LPWSTR lpStatus,
    _In_ HWND hwndDlg
)
{
    INT nIndex;
    LVITEM lvitem;
    PTOKEN_PAGE_CONTEXT pCtx;

    pCtx = TokenPageGetContext(hwndDlg);
    if (pCtx == NULL)
        return;

    RtlSecureZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT | LVIF_GROUPID;
    lvitem.pszText = lpName;
    lvitem.iItem = MAXINT;
    lvitem.iGroupId = GroupIndex;
    nIndex = ListView_InsertItem(pCtx->hwndList, &lvitem);
    if (nIndex == -1) { // insertion failed
        return;
    }

    lvitem.mask = LVIF_TEXT;
    lvitem.iSubItem = 1;
    lvitem.pszText = lpStatus;
    lvitem.iItem = nIndex;
    ListView_SetItem(pCtx->hwndList, &lvitem);
}

/*
* TokenPageListInfo
*
* Purpose:
*
* Query and list token information.
*
*/
VOID TokenPageListInfo(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg
)
{
    BOOLEAN IsAppContainer = FALSE;
    ULONG i, cchName, r;
    NTSTATUS Status;
    LPWSTR ErrMsg = NULL, ElementName, UserAndDomain, pString;
    HANDLE ObjectHandle = NULL;
    HANDLE TokenHandle = NULL, LinkedTokenHandle = NULL;
    ACCESS_MASK DesiredAccessLv1, DesiredAccessLv2;

    PTOKEN_PRIVILEGES pTokenPrivs;
    PTOKEN_USER pTokenUser;
    PTOKEN_MANDATORY_LABEL pTokenIntegrity;
    PTOKEN_GROUPS pTokenGroups;
    PTOKEN_APPCONTAINER_INFORMATION pTokenAppContainer;
    TOKEN_ELEVATION TokenElv;
    TOKEN_ELEVATION_TYPE TokenElevType;
    TOKEN_STATISTICS TokenStats;

    WCHAR szBuffer[MAX_PATH], szPrivName[MAX_PATH + 1];

    if (Context->ObjectTypeIndex == ObjectTypeProcess) {
        DesiredAccessLv1 = PROCESS_QUERY_INFORMATION;
        DesiredAccessLv2 = PROCESS_QUERY_LIMITED_INFORMATION;
    }
    else {
        DesiredAccessLv1 = THREAD_QUERY_INFORMATION;
        DesiredAccessLv2 = THREAD_QUERY_LIMITED_INFORMATION;
    }

    if (!propOpenCurrentObject(Context, &ObjectHandle, MAXIMUM_ALLOWED)) {
        if (!propOpenCurrentObject(Context, &ObjectHandle, DesiredAccessLv1)) {
            propOpenCurrentObject(Context, &ObjectHandle, DesiredAccessLv2);
        }
    }

    if (ObjectHandle == NULL) {
        TokenPageShowError(hwndDlg, NULL);
        return;
    }

    if (Context->ObjectTypeIndex == ObjectTypeProcess) {

        Status = supOpenProcessTokenEx(ObjectHandle, &TokenHandle);
        if (!NT_SUCCESS(Status))
            Status = NtOpenProcessToken(ObjectHandle, TOKEN_QUERY, &TokenHandle);

    }
    else {
        Status = NtOpenThreadToken(ObjectHandle, TOKEN_QUERY, TRUE, &TokenHandle);
    }

    if (NT_SUCCESS(Status) && TokenHandle != NULL) {


        i = 0;
        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenIsAppContainer, (PVOID)&i, sizeof(ULONG), &r))) {
            IsAppContainer = (i > 0);
        }

        TokenPageInitControls(hwndDlg, IsAppContainer);

        //
        // List token privileges.
        //
        pTokenPrivs = (PTOKEN_PRIVILEGES)supGetTokenInfo(TokenHandle, TokenPrivileges, NULL);
        if (pTokenPrivs) {

            for (i = 0; i < pTokenPrivs->PrivilegeCount; i++) {

                //
                // Output privilege flags like Process Explorer.
                //
                szPrivName[0] = 0;
                cchName = MAX_PATH;
                if (LookupPrivilegeName(NULL, &pTokenPrivs->Privileges[i].Luid,
                    szPrivName, &cchName))
                {
                    ElementName = TEXT("Disabled");
                    if (pTokenPrivs->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) {
                        ElementName = TEXT("Enabled");
                    }

                    _strcpy(szBuffer, ElementName);

                    if (pTokenPrivs->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT) {
                        _strcat(szBuffer, TEXT(", Default Enabled"));
                    }

                    TokenPageListAdd(0, szPrivName, szBuffer, hwndDlg);
                }

            }

            supHeapFree(pTokenPrivs);
        }

        //
        // List token groups.
        //
        pTokenGroups = (PTOKEN_GROUPS)supGetTokenInfo(TokenHandle, TokenGroups, NULL);
        if (pTokenGroups) {

            for (i = 0; i < pTokenGroups->GroupCount; i++) {

                UserAndDomain = NULL;
                if (supLookupSidUserAndDomain(pTokenGroups->Groups[i].Sid, &UserAndDomain)) {

                    r = pTokenGroups->Groups[i].Attributes;
                    pString = NULL;
                    szBuffer[0] = 0;
                    if (r & SE_GROUP_USE_FOR_DENY_ONLY)
                        pString = _strcpy(szBuffer, TEXT("Deny"));

                    if (r & SE_GROUP_RESOURCE) {
                        if (pString)
                            _strcat(szBuffer, TEXT(", "));
                        pString = _strcat(szBuffer, TEXT("Domain-Local"));
                    }

                    if ((r & SE_GROUP_MANDATORY) && (!(r & SE_GROUP_OWNER))) {
                        if (pString)
                            _strcat(szBuffer, TEXT(", "));
                        pString = _strcat(szBuffer, TEXT("Mandatory"));
                    }
                    if (r & SE_GROUP_OWNER) {
                        if (pString)
                            _strcat(szBuffer, TEXT(", "));
                        pString = _strcat(szBuffer, TEXT("Owner"));
                    }
                    if (r & SE_GROUP_INTEGRITY) {
                        if (pString)
                            _strcat(szBuffer, TEXT(", "));
                        ElementName = TEXT("Integrity");
                        if (!(r & SE_GROUP_INTEGRITY_ENABLED)) {
                            ElementName = TEXT("DesktopIntegrity");
                        }
                        _strcat(szBuffer, ElementName);
                    }

                    TokenPageListAdd(1, UserAndDomain, szBuffer, hwndDlg);

                    supHeapFree(UserAndDomain);
                }

            }

            supHeapFree(pTokenGroups);
        }

        //
        // Token elevated.
        //
        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenElevation,
            (PVOID)&TokenElv, sizeof(TokenElv), &r)))
        {
            if (TokenElv.TokenIsElevated) {
                _strcpy(szBuffer, TEXT("Yes"));
                if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenElevationType,
                    &TokenElevType, sizeof(TokenElevType), &r)))
                {
                    switch (TokenElevType) {
                    case TokenElevationTypeDefault:
                        _strcat(szBuffer, TEXT(" (Default)")); // User is not using a split token, so they cannot elevate.
                        break;
                    case TokenElevationTypeFull: // User has a split token, and the process is running elevated.
                        _strcat(szBuffer, TEXT(" (Full)"));
                        break;
                    case TokenElevationTypeLimited: // User has a split token, but the process is not running elevated.
                        _strcat(szBuffer, TEXT(" (Limited)"));
                        break;
                    default:
                        _strcat(szBuffer, TEXT(" (Unknown)"));
                        break;
                    }

                }
            }
            else
                _strcpy(szBuffer, TEXT("No"));


            SetDlgItemText(hwndDlg, IDC_TOKEN_ELEVATED, szBuffer);
        }

        //
        // Token virtualization.
        //
        i = 0;
        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenVirtualizationAllowed,
            (PVOID)&i, sizeof(i), &r)))
        {
            if (i > 0) {
                i = 0;
                if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenVirtualizationEnabled,
                    (PVOID)&i, sizeof(i), &r)))
                {
                    ElementName = (i > 0) ? TEXT("Yes") : TEXT("No");
                    SetDlgItemText(hwndDlg, IDC_TOKEN_VIRTUALIZED, ElementName);
                }
            }
        }
        else {
            SetDlgItemText(hwndDlg, IDC_TOKEN_VIRTUALIZED, TEXT("Not allowed"));
        }

        //
        // Token integrity level.
        //
        pTokenIntegrity = (PTOKEN_MANDATORY_LABEL)supGetTokenInfo(TokenHandle, TokenIntegrityLevel, NULL);
        if (pTokenIntegrity) {
            i = *RtlSubAuthoritySid(pTokenIntegrity->Label.Sid,
                (DWORD)(UCHAR)(*RtlSubAuthorityCountSid(pTokenIntegrity->Label.Sid) - 1));
            ElementName = supIntegrityToString(i);
            SetDlgItemText(hwndDlg, IDC_TOKEN_INTEGRITYLEVEL, ElementName);
            supHeapFree(pTokenIntegrity);
        }

        //
        // Token session id.
        //
        i = 0;
        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenSessionId,
            (PVOID)&i, sizeof(i), &r)))
        {
            szBuffer[0] = 0;
            ultostr(i, szBuffer);
            SetDlgItemText(hwndDlg, IDC_TOKEN_SESSION, szBuffer);
        }

        //
        // Token user.
        //
        pTokenUser = (PTOKEN_USER)supGetTokenInfo(TokenHandle, TokenUser, NULL);
        if (pTokenUser) {
            ElementName = NULL;
            if (ConvertSidToStringSid(pTokenUser->User.Sid, &ElementName)) {
                SetDlgItemText(hwndDlg, IDC_TOKEN_SID, ElementName);
                LocalFree(ElementName);
            }

            ElementName = NULL;
            if (supLookupSidUserAndDomain(pTokenUser->User.Sid, &ElementName)) {
                SetDlgItemText(hwndDlg, IDC_TOKEN_USER, ElementName);
                supHeapFree(ElementName);
            }
            supHeapFree(pTokenUser);
        }

        //
        // AppContainer related.
        //
        if (IsAppContainer) {

            //
            // Token AppContainer SID.
            //
            pTokenAppContainer = (PTOKEN_APPCONTAINER_INFORMATION)supGetTokenInfo(TokenHandle, TokenAppContainerSid, NULL);
            if (pTokenAppContainer) {
                ElementName = NULL;
                if (pTokenAppContainer->TokenAppContainer) {
                    if (ConvertSidToStringSid(pTokenAppContainer->TokenAppContainer, &ElementName)) {
                        SetDlgItemText(hwndDlg, IDC_TOKEN_APPCONTAINER, ElementName);
                        LocalFree(ElementName);
                    }
                }
                supHeapFree(pTokenAppContainer);
            }


            pTokenGroups = (PTOKEN_GROUPS)supGetTokenInfo(TokenHandle, TokenCapabilities, NULL);
            if (pTokenGroups) {

                for (i = 0; i < pTokenGroups->GroupCount; i++) {
                    if (pTokenGroups->Groups[i].Sid) {
                        ElementName = NULL;
                        if (ConvertSidToStringSid(pTokenGroups->Groups[i].Sid, &ElementName)) {
                            TokenPageListAdd(2, ElementName, TEXT("Capabilities"), hwndDlg);
                            LocalFree(ElementName);
                        }
                    }
                }
                supHeapFree(pTokenGroups);
            }
        }
        //
        // UIAccess
        //
        i = 0;
        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenUIAccess,
            (PVOID)&i, sizeof(i), &r)))
        {
            ElementName = (i > 0) ? TEXT("Yes") : TEXT("No");
            SetDlgItemText(hwndDlg, IDC_TOKEN_UIACCESS, ElementName);
        }

        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle, TokenStatistics,
            (PVOID)&TokenStats, sizeof(TOKEN_STATISTICS), &r)))
        {
            szBuffer[0] = 0;
            RtlStringCchPrintfSecure(szBuffer, MAX_PATH, L"0x%x-%x$",
                TokenStats.AuthenticationId.HighPart,
                TokenStats.AuthenticationId.LowPart);
            SetDlgItemText(hwndDlg, IDC_TOKEN_AUTHID, szBuffer);
        }

        //
        // Linked token.
        //
        Status = supOpenLinkedToken(TokenHandle, &LinkedTokenHandle);
        if (NT_SUCCESS(Status)) NtClose(LinkedTokenHandle);
        EnableWindow(GetDlgItem(hwndDlg, IDC_TOKEN_LINKED), NT_SUCCESS(Status));

        NtClose(TokenHandle);
    }
    else {
        if (Status == STATUS_NO_TOKEN)
            ErrMsg = TEXT("Token doesn't exist, thread is not impersonating a client.");

        TokenPageShowError(hwndDlg, ErrMsg);
    }

    NtClose(ObjectHandle);
}

/*
* TokenPageShowLinkedTokenProperties
*
* Purpose:
*
* Show properties of selected linked token object.
*
*/
VOID TokenPageShowLinkedTokenProperties(
    _In_ HWND hwndDlg
)
{
    NTSTATUS Status;
    HANDLE TokenHandle, LinkedTokenHandle;
    PROP_UNNAMED_OBJECT_INFO TokenObject, LinkedTokenObject;
    OBJECT_ATTRIBUTES ObjectAttributes = RTL_INIT_OBJECT_ATTRIBUTES((PUNICODE_STRING)NULL, 0);

    LPWSTR FormatStringLinkedTokenProcess = TEXT("Linked Token, PID:%llu");

    UNICODE_STRING usObjectName;
    PROP_CONFIG propConfig;

    WCHAR szBuffer[MAX_PATH + 1];

    RtlSecureZeroMemory(&TokenObject, sizeof(PROP_UNNAMED_OBJECT_INFO));

    TokenObject.ClientId.UniqueProcess =
        GetProp(hwndDlg, T_TOKEN_PROP_CID_PID);

    TokenObject.ClientId.UniqueThread =
        GetProp(hwndDlg, T_TOKEN_PROP_CID_TID);

    TokenObject.IsThreadToken =
        (BOOL)HandleToULong(GetProp(hwndDlg, T_TOKEN_PROP_TYPE));

    Status = supOpenTokenByParam(&TokenObject.ClientId,
        &ObjectAttributes,
        TOKEN_QUERY,
        TokenObject.IsThreadToken,
        &TokenHandle);

    if (NT_SUCCESS(Status)) {

        Status = supOpenLinkedToken(TokenHandle, &LinkedTokenHandle);
        if (NT_SUCCESS(Status)) {

            RtlSecureZeroMemory(&LinkedTokenObject, sizeof(LinkedTokenObject));
            LinkedTokenObject.ClientId = TokenObject.ClientId;

            supQueryObjectFromHandle(LinkedTokenHandle, &LinkedTokenObject.ObjectAddress, NULL);

            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

            RtlStringCchPrintfSecure(szBuffer,
                MAX_PATH,
                FormatStringLinkedTokenProcess,
                LinkedTokenObject.ClientId.UniqueProcess);

            RtlInitUnicodeString(&usObjectName, szBuffer);

            RtlSecureZeroMemory(&propConfig, sizeof(propConfig));

            propConfig.hwndParent = hwndDlg;
            propConfig.NtObjectName = &usObjectName;
            propConfig.ObjectTypeIndex = ObjectTypeToken;
            propConfig.ContextType = propUnnamed;
            propConfig.u1.UnnamedObject = &LinkedTokenObject;

            propCreateDialog(&propConfig);

            NtClose(LinkedTokenHandle);
        }
        else {
            RtlStringCchPrintfSecure(szBuffer, MAX_PATH, TEXT("Unable to open linked token, NTSTATUS: 0x%lX"), Status);
            TokenPageShowError(hwndDlg, szBuffer);
        }
        NtClose(TokenHandle);
    }
    else {
        RtlStringCchPrintfSecure(szBuffer, MAX_PATH, TEXT("Unable to open token, NTSTATUS: 0x%lX"), Status);
        TokenPageShowError(hwndDlg, szBuffer);
    }

}

/*
* TokenPageShowAdvancedProperties
*
* Purpose:
*
* Show properties of selected token object.
*
*/
VOID TokenPageShowAdvancedProperties(
    _In_ HWND hwndDlg)
{
    OBJECT_ATTRIBUTES ObjectAttributes = RTL_INIT_OBJECT_ATTRIBUTES((PUNICODE_STRING)NULL, 0);
    PROP_UNNAMED_OBJECT_INFO TokenObject;
    PROP_CONFIG propConfig;

    LPWSTR FormatStringTokenProcess = TEXT("Process Token, PID:%llu");
    LPWSTR FormatStringTokenThread = TEXT("Thread Token, PID:%llu, TID:%llu");

    HANDLE TokenHandle = NULL;
    WCHAR szFakeName[MAX_PATH + 1];

    UNICODE_STRING usObjectName;

    //
    // Only one token properties dialog at the same time allowed.
    //
    supCloseKnownPropertiesDialog(propGetTokenWindow());

    RtlSecureZeroMemory(&TokenObject, sizeof(PROP_UNNAMED_OBJECT_INFO));

    TokenObject.ClientId.UniqueProcess =
        GetProp(hwndDlg, T_TOKEN_PROP_CID_PID);

    TokenObject.ClientId.UniqueThread =
        GetProp(hwndDlg, T_TOKEN_PROP_CID_TID);

    TokenObject.IsThreadToken =
        (BOOL)HandleToULong(GetProp(hwndDlg, T_TOKEN_PROP_TYPE));

    RtlSecureZeroMemory(szFakeName, sizeof(szFakeName));

    if (NT_SUCCESS(supOpenTokenByParam(&TokenObject.ClientId,
        &ObjectAttributes,
        TOKEN_QUERY,
        TokenObject.IsThreadToken,
        &TokenHandle)))
    {
        supQueryObjectFromHandle(TokenHandle, &TokenObject.ObjectAddress, NULL);
        NtClose(TokenHandle);
    }

    RtlSecureZeroMemory(&propConfig, sizeof(propConfig));

    if (TokenObject.IsThreadToken) {

        RtlStringCchPrintfSecure(szFakeName,
            MAX_PATH,
            FormatStringTokenThread,
            TokenObject.ClientId.UniqueProcess,
            TokenObject.ClientId.UniqueThread);

    }
    else {

        RtlStringCchPrintfSecure(szFakeName,
            MAX_PATH,
            FormatStringTokenProcess,
            TokenObject.ClientId.UniqueProcess);

    }

    RtlInitUnicodeString(&usObjectName, szFakeName);

    propConfig.hwndParent = hwndDlg;
    propConfig.NtObjectName = &usObjectName;
    propConfig.ObjectTypeIndex = ObjectTypeToken;
    propConfig.ContextType = propUnnamed;
    propConfig.u1.UnnamedObject = &TokenObject;

    propCreateDialog(&propConfig);
}

/*
* TokenPageHandlePopup
*
* Purpose:
*
* Token page list popup construction.
*
*/
VOID TokenPageHandlePopup(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    PTOKEN_PAGE_CONTEXT pCtx;

    UNREFERENCED_PARAMETER(lpUserParam);

    pCtx = TokenPageGetContext(hwndDlg);
    if (pCtx == NULL)
        return;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            pCtx->hwndList,
            ID_OBJECT_COPY,
            0,
            lpPoint,
            &pCtx->lvSelectedItem,
            &pCtx->lvColumnHit))
        {
            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* TokenPageDialogOnCommand
*
* Purpose:
*
* Token page WM_COMMAND handler.
*
*/
INT_PTR TokenPageDialogOnCommand(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    INT_PTR Result = 0;
    PTOKEN_PAGE_CONTEXT pCtx;

    UNREFERENCED_PARAMETER(lParam);

    pCtx = TokenPageGetContext(hwndDlg);
    if (pCtx == NULL)
        return 0;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case ID_OBJECT_COPY:

        supListViewCopyItemValueToClipboard(pCtx->hwndList,
            pCtx->lvSelectedItem,
            pCtx->lvColumnHit);

        Result = 1;
        break;
    case IDC_TOKEN_ADVANCED:
        TokenPageShowAdvancedProperties(hwndDlg);
        Result = 1;
        break;

    case IDC_TOKEN_LINKED:
        TokenPageShowLinkedTokenProperties(hwndDlg);
        Result = 1;
        break;

    }

    return Result;
}

/*
* TokenPageDialogOnInit
*
* Purpose:
*
* Token page WM_INITDIALOG handler.
*
*/
INT_PTR TokenPageDialogOnInit(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam)
{
    PROPSHEETPAGE* pSheet = NULL;
    PROP_OBJECT_INFO* Context = NULL;
    PTOKEN_PAGE_CONTEXT pCtx;

    pSheet = (PROPSHEETPAGE*)lParam;
    if (pSheet) {
        Context = (PROP_OBJECT_INFO*)pSheet->lParam;

        //
        // Allocate and attach per-dialog context.
        //
        pCtx = (PTOKEN_PAGE_CONTEXT)supHeapAlloc(sizeof(TOKEN_PAGE_CONTEXT));
        if (pCtx) {
            pCtx->hwndList = NULL;
            pCtx->lvSelectedItem = -1;
            pCtx->lvColumnHit = -1;
            SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)pCtx);
        }

        //
        // Remember client id.
        //
        SetProp(hwndDlg,
            T_TOKEN_PROP_CID_PID,
            Context->u1.UnnamedObjectInfo.ClientId.UniqueProcess);

        SetProp(hwndDlg,
            T_TOKEN_PROP_CID_TID,
            Context->u1.UnnamedObjectInfo.ClientId.UniqueThread);

        SetProp(hwndDlg,
            T_TOKEN_PROP_TYPE,
            UlongToHandle((ULONG)(Context->TypeDescription->Index == ObjectTypeThread)));

        //
        // Show token summary information.
        //
        TokenPageListInfo(Context, hwndDlg);
    }

    return 1;
}

/*
* TokenPageDialogProc
*
* Purpose:
*
* Token page for Process/Thread object type.
*
* WM_INITDIALOG - Initialize listview, set window prop with context,
* collect token info and fill list.
*
*/
INT_PTR CALLBACK TokenPageDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam
)
{
    PTOKEN_PAGE_CONTEXT pCtx;

    switch (uMsg) {

    case WM_CONTEXTMENU:

        pCtx = TokenPageGetContext(hwndDlg);
        if (pCtx) {
            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                pCtx->hwndList,
                (pfnPopupMenuHandler)TokenPageHandlePopup,
                NULL);
        }
        break;

    case WM_COMMAND:
        return TokenPageDialogOnCommand(hwndDlg, wParam, lParam);

    case WM_INITDIALOG:
        return TokenPageDialogOnInit(hwndDlg, lParam);

    case WM_DESTROY:
        pCtx = (PTOKEN_PAGE_CONTEXT)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (pCtx) {
            supHeapFree(pCtx);
        }
        RemoveProp(hwndDlg, T_TOKEN_PROP_CID_PID);
        RemoveProp(hwndDlg, T_TOKEN_PROP_CID_TID);
        RemoveProp(hwndDlg, T_TOKEN_PROP_TYPE);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

```

`Source/WinObjEx64/props/propType.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       PROPTYPE.C
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "propTypeConsts.h"

/*
* propSetTypeFlagValue
*
* Purpose:
*
* Add value to the access rights listview
*
*/
VOID propSetTypeFlagValue(
    _In_ HWND	hListView,
    _In_ LPWSTR lpFlag,
    _In_ DWORD	Value
)
{
    INT    nIndex;
    LVITEM lvitem;
    WCHAR  szBuffer[MAX_PATH];

    if (lpFlag == NULL)
        return;

    RtlSecureZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;
    lvitem.pszText = lpFlag;
    lvitem.iItem = MAXINT;
    nIndex = ListView_InsertItem(hListView, &lvitem);
    if (nIndex == -1)
        return;

    RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
    szBuffer[0] = L'0';
    szBuffer[1] = L'x';
    ultohex(Value, &szBuffer[2]);

    lvitem.iSubItem = 1;
    lvitem.pszText = szBuffer;
    lvitem.iItem = nIndex;
    ListView_SetItem(hListView, &lvitem);
}

/*
* propSetTypeDecodeValue
*
* Purpose:
*
* Decode Access Right Attributes depending on object type
*
*/
VOID propSetTypeDecodeValue(
    _In_ HWND hListView,
    _In_ DWORD Value,
    _In_ INT TypeIndex
)
{
    INT	        i, Count, bitIndex;
    DWORD       u;
    PVALUE_DESC Desc = NULL;

    switch (TypeIndex) {

    case ObjectTypeWMIGuid:
        Desc = a_WmiGuidProp;
        Count = MAX_KNOWN_WMIGUID_ATTRIBUTES;
        break;

    case ObjectTypeWinstation:
        Desc = a_WinstaProp;
        Count = MAX_KNOWN_WINSTA_ATTRIBUTES;
        break;

    case ObjectTypeToken:
        Desc = a_TokenProp;
        Count = MAX_KNOWN_TOKEN_ATTRIBUTES;
        break;

    case ObjectTypeThread:
        Desc = a_ThreadProp;
        Count = MAX_KNOWN_THREAD_ATTRIBUTES;
        break;

    case ObjectTypeIRTimer:
    case ObjectTypeTimer:
        Desc = a_TimerProp;
        Count = MAX_KNOWN_TIMER_ATTRIBUTES;
        break;

    case ObjectTypeProcess:
        Desc = a_ProcessProp;
        Count = MAX_KNOWN_PROCESS_ATTRIBUTES;
        break;

    case ObjectTypeKeyedEvent:
        Desc = a_KeyedEventProp;
        Count = MAX_KNOWN_KEYEDEVENT_ATTRIBUTES;
        break;

    case ObjectTypeJob:
        Desc = a_JobProp;
        Count = MAX_KNOWN_JOB_ATTRIBUTES;
        break;

    case ObjectTypeSession:
        Desc = a_SessionProp;
        Count = MAX_KNOWN_SESSION_ATTRIBUTES;
        break;

    case ObjectTypeDesktop:
        Desc = a_DesktopObjectProp;
        Count = MAX_KNOWN_DESKTOP_ATTRIBUTES;
        break;

    case ObjectTypeDebugObject:
        Desc = a_DebugObjectProp;
        Count = MAX_KNOWN_DEBUGOBJECT_ATTRIBUTES;
        break;

    case ObjectTypeCallback:
        Desc = a_CallbackProp;
        Count = MAX_KNOWN_CALLBACK_ATTRIBUTES;
        break;

    case ObjectTypeAdapter:
    case ObjectTypeController:
    case ObjectTypeDevice:
    case ObjectTypeDriver:
    case ObjectTypeFile:
        Desc = a_FileProp;
        Count = MAX_KNOWN_FILE_ATTRIBUTES;
        break;

    case ObjectTypeKey:
        Desc = a_KeyProp;
        Count = MAX_KNOWN_KEY_ATTRIBUTES;
        break;

    case ObjectTypeType:
        Desc = a_TypeProp;
        Count = MAX_KNOWN_TYPE_ATTRIBUTES;
        break;

    case ObjectTypeSymbolicLink:
        Desc = a_SymLinkProp;
        Count = MAX_KNOWN_SYMLINK_ATTRIBUTES;
        break;

    case ObjectTypeDirectory:
        Desc = a_DirProp;
        Count = MAX_KNOWN_DIRECTORY_ATTRIBUTES;
        break;

    case ObjectTypeEvent:
        Desc = a_EventProp;
        Count = MAX_KNOWN_EVENT_ATTRIBUTES;
        break;

    case ObjectTypeMutant:
        Desc = a_MutantProp;
        Count = MAX_KNOWN_MUTANT_ATTRIBUTES;
        break;

        //all ports
    case ObjectTypeFltComnPort:
    case ObjectTypeFltConnPort:
    case ObjectTypeWaitablePort:
    case ObjectTypePort:
        Desc = a_PortProp;
        Count = MAX_KNOWN_PORT_ATTRIBUTES;
        break;

    case ObjectTypeProfile:
        Desc = a_ProfileProp;
        Count = MAX_KNOWN_PROFILE_ATTRIBUTES;
        break;

    case ObjectTypeSection:
        Desc = a_SectionProp;
        Count = MAX_KNOWN_SECTION_ATTRIBUTES;
        break;

    case ObjectTypeSemaphore:
        Desc = a_SemaphoreProp;
        Count = MAX_KNOWN_SEMAPHORE_ATTRIBUTES;
        break;

    case ObjectTypeIoCompletion:
    case ObjectTypeIoCompletionReserve:
        Desc = a_IoCompletionProp;
        Count = MAX_KNOWN_IOCOMPLETION_ATTRIBUTES;
        break;

        //RegistryTransaction/Transaction Object
    case ObjectTypeRegistryTransaction:
    case ObjectTypeTmTx:
        Desc = a_TmTxProp;
        Count = MAX_KNOWN_TMTX_ATTRIBUTES;
        break;

        //Transaction Resource Manager Object
    case ObjectTypeTmRm:
        Desc = a_TmRmProp;
        Count = MAX_KNOWN_TMRM_ATTRIBUTES;
        break;

        //Transaction Enlistment Object 
    case ObjectTypeTmEn:
        Desc = a_TmEnProp;
        Count = MAX_KNOWN_TMEN_ATTRIBUTES;
        break;

        //Transaction Manager Object
    case ObjectTypeTmTm:
        Desc = a_TmTmProp;
        Count = MAX_KNOWN_TMTM_ATTRIBUTES;
        break;

    case ObjectTypeTpWorkerFactory:
        Desc = a_TpwfProp;
        Count = MAX_KNOWN_TPWORKERFACTORY_ATTRIBUTES;
        break;

    case ObjectTypePcwObject:
        Desc = a_PcwProp;
        Count = MAX_KNOWN_PCWOBJECT_ATTRIBUTES;
        break;

    case ObjectTypeComposition:
        Desc = a_CompositionProp;
        Count = MAX_KNOWN_COMPOSITION_ATTRIBUTES;
        break;

        //Parition object
    case ObjectTypeMemoryPartition:
        Desc = a_MemPartProp;
        Count = MAX_KNOWN_MEMPARTITION_ATTRIBUTES;
        break;

    default:
        Count = 0;
        break;
    }

    //list for selected type
    if (Desc) {
        for (i = 0; i < Count; i++) {
            if (Value & Desc[i].dwValue) {
                propSetTypeFlagValue(hListView, Desc[i].lpDescription, Desc[i].dwValue);
                Value &= ~Desc[i].dwValue;
            }
        }
    }

    //list Standard Access Rights if anything left
    if (Value != 0) {
        Desc = a_Standard;
        Count = MAX_KNOWN_STANDARD_ATTRIBUTES;
        for (i = 0; i < Count; i++) {
            if (Value & Desc[i].dwValue) {
                propSetTypeFlagValue(hListView, Desc[i].lpDescription, Desc[i].dwValue);
                Value &= ~Desc[i].dwValue;
            }
        }
    }
    //set unknown to anything else
    if (Value != 0) {
        for (bitIndex = 0; bitIndex < 32 && Value != 0; bitIndex++) {
            u = (1U << bitIndex);
            if (Value & u) {
                propSetTypeFlagValue(hListView, T_Unknown, u);
                Value &= ~u;
            }
        }
    }
}

/*
* propSetTypeFlags
*
* Purpose:
*
* Set object type flags descriptions at the Type page
*
*/
VOID propSetTypeFlags(
    HWND hwndDlg,
    DWORD ObjectFlags
)
{
    INT  i;
    HWND hwndCB;
    BOOL bObjectFlagsSet = FALSE;

    hwndCB = GetDlgItem(hwndDlg, IDC_TYPE_FLAGS);
    if (hwndCB) {
        bObjectFlagsSet = (ObjectFlags != 0);
        EnableWindow(hwndCB, bObjectFlagsSet);
        SendMessage(hwndCB, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
        if (bObjectFlagsSet) {
            EnableWindow(hwndCB, TRUE);
            for (i = 0; i < 8; i++)
                if (GET_BIT(ObjectFlags, i)) {

                    SendMessage(hwndCB,
                        CB_ADDSTRING,
                        (WPARAM)0,
                        (LPARAM)T_ObjectTypeFlags[i]);
                }

            SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
        }
    }
}

/*
* propSetTypeAttributes
*
* Purpose:
*
* List attributes depending on object type
*
*/
VOID propSetTypeAttributes(
    _In_ HWND hwndDlg,
    _In_ POBJECT_TYPE_COMPATIBLE ObjectTypeDump
)
{
    LRESULT nIndex;
    HWND    hListAttrbites;
    WCHAR   szBuffer[MAX_PATH + 1];

    if (ObjectTypeDump == NULL)
        return;

    hListAttrbites = GetDlgItem(hwndDlg, ID_TYPE_ATTRLIST);
    if (hListAttrbites == NULL)
        return;

    SendMessage(hListAttrbites, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

    //Invalid attributes
    nIndex = SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&T_InvalidAttributes);
    SendMessage(hListAttrbites, LB_SETITEMDATA, (WPARAM)nIndex,
        (LPARAM)ObjectTypeDump->TypeInfo.InvalidAttributes);

    _strcpy(szBuffer, T_FORMATTED_ATTRIBUTE);
    ultohex(ObjectTypeDump->TypeInfo.InvalidAttributes, _strend(szBuffer));
    SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);

    //Valid access
    nIndex = SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&T_ValidAccess);
    SendMessage(hListAttrbites, LB_SETITEMDATA, (WPARAM)nIndex,
        (LPARAM)ObjectTypeDump->TypeInfo.ValidAccessMask);

    _strcpy(szBuffer, T_FORMATTED_ATTRIBUTE);
    ultohex(ObjectTypeDump->TypeInfo.ValidAccessMask, _strend(szBuffer));
    SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);

    //Generic Read
    nIndex = SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&T_GenericRead);
    SendMessage(hListAttrbites, LB_SETITEMDATA, (WPARAM)nIndex,
        (LPARAM)ObjectTypeDump->TypeInfo.GenericMapping.GenericRead);

    _strcpy(szBuffer, T_FORMATTED_ATTRIBUTE);
    ultohex(ObjectTypeDump->TypeInfo.GenericMapping.GenericRead, _strend(szBuffer));
    SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);

    //Generic Write
    nIndex = SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&T_GenericWrite);
    SendMessage(hListAttrbites, LB_SETITEMDATA, (WPARAM)nIndex,
        (LPARAM)ObjectTypeDump->TypeInfo.GenericMapping.GenericWrite);

    _strcpy(szBuffer, T_FORMATTED_ATTRIBUTE);
    ultohex(ObjectTypeDump->TypeInfo.GenericMapping.GenericWrite, _strend(szBuffer));
    SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);

    //Generic Execute
    nIndex = SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&T_GenericExecute);
    SendMessage(hListAttrbites, LB_SETITEMDATA, (WPARAM)nIndex,
        (LPARAM)ObjectTypeDump->TypeInfo.GenericMapping.GenericExecute);

    _strcpy(szBuffer, T_FORMATTED_ATTRIBUTE);
    ultohex(ObjectTypeDump->TypeInfo.GenericMapping.GenericExecute, _strend(szBuffer));
    SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);

    //Generic All
    nIndex = SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&T_GenericAll);
    SendMessage(hListAttrbites, LB_SETITEMDATA, (WPARAM)nIndex,
        (LPARAM)ObjectTypeDump->TypeInfo.GenericMapping.GenericAll);

    _strcpy(szBuffer, T_FORMATTED_ATTRIBUTE);
    ultohex(ObjectTypeDump->TypeInfo.GenericMapping.GenericAll, _strend(szBuffer));
    SendMessage(hListAttrbites, LB_ADDSTRING, (WPARAM)0, (LPARAM)&szBuffer);
}

/*
* propSetTypeDecodedAttributes
*
* Purpose:
*
* Handler for listbox with access rights and invalid attributes click
*
*/
VOID propSetTypeDecodedAttributes(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HWND hwndDlg
)
{
    HWND            hListRights, hListAttrbites;
    LRESULT         curSel;
    DWORD           i, dwFlags, a_Count;
    PVALUE_DESC     a_Desc;

    hListRights = GetDlgItem(hwndDlg, ID_TYPE_ACL_LIST);
    if (hListRights == NULL) {
        return;
    }

    ListView_DeleteAllItems(hListRights);

    hListAttrbites = GetDlgItem(hwndDlg, ID_TYPE_ATTRLIST);
    if (hListAttrbites == NULL) {
        return;
    }

    curSel = SendMessage(hListAttrbites, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    if (curSel == LB_ERR)
        return;

    if (curSel % 2 != 0) {
        curSel--;
        SendMessage(hListAttrbites, LB_SETCURSEL, (WPARAM)curSel, (LPARAM)0);
    }

    dwFlags = (DWORD)SendMessage(hListAttrbites, LB_GETITEMDATA, (WPARAM)curSel, (LPARAM)0);
    if (dwFlags == 0)
        return;

    //
    // Depending on selection, decode attributes to the list.
    //
    if (curSel == 0) {

        //
        // List all known attributes.
        //
        a_Count = MAX_KNOWN_OBJECT_ATTRIBUTES;
        a_Desc = a_ObjProp;

        for (i = 0; i < a_Count; i++) {
            if (dwFlags & a_Desc[i].dwValue) {
                propSetTypeFlagValue(hListRights, a_Desc[i].lpDescription, a_Desc[i].dwValue);
                dwFlags &= ~a_Desc[i].dwValue;
            }
        }

        //
        // List any other.
        //
        if (dwFlags != 0) {
            propSetTypeFlagValue(hListRights, T_Unknown, dwFlags);
        }
    }
    else {
        propSetTypeDecodeValue(hListRights, dwFlags, Context->ShadowTypeDescription->Index);
    }
}

/*
* propSetTypeListView
*
* Purpose:
*
* Create listview for object access rights enumeration.
*
* This routine must be called once.
*
*/
VOID propSetTypeListView(
    _In_ HWND hwndDlg
)
{
    HWND hListRights;

    hListRights = GetDlgItem(hwndDlg, ID_TYPE_ACL_LIST);
    if (hListRights == NULL)
        return;

    supSetListViewSettings(hListRights,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        TRUE, //override global settings for this listview
        TRUE,
        NULL,
        0);

    supAddListViewColumn(hListRights, 0, 0, 0,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("Flag"), 190);

    supAddListViewColumn(hListRights, 1, 1, 1,
        I_IMAGENONE,
        LVCFMT_LEFT,
        TEXT("Value"), 80);
}

/*
* propQueryTypeInfo
*
* Purpose:
*
* Query Type information depending on object type.
*
* Used if object dumped info not available (restricted user, no driver etc).
*
*/
_Success_(return)
BOOL propQueryTypeInfo(
    _In_ PUNICODE_STRING ObjectType,
    _Out_ POBJECT_TYPE_COMPATIBLE Information
)
{
    BOOL     bResult = FALSE;
    ULONG    i;

    POBJECT_TYPES_INFORMATION pObjectTypes = NULL;
    POBJECT_TYPE_INFORMATION  pObject;

    pObjectTypes = (POBJECT_TYPES_INFORMATION)supGetObjectTypesInfo();
    if (pObjectTypes == NULL)
        return FALSE;

    pObject = OBJECT_TYPES_FIRST_ENTRY(pObjectTypes);

    __try {

        //
        // Warning: older Wine/Staging incorrectly implement memory structure layout for this structure and therefore will crash.            
        //
        for (i = 0; i < pObjectTypes->NumberOfTypes; i++) {

            if (RtlEqualUnicodeString(ObjectType, &pObject->TypeName, TRUE)) {
                Information->TotalNumberOfHandles = pObject->TotalNumberOfHandles;
                Information->TotalNumberOfObjects = pObject->TotalNumberOfObjects;
                Information->TypeInfo.InvalidAttributes = pObject->InvalidAttributes;
                Information->TypeInfo.GenericMapping = pObject->GenericMapping;
                Information->TypeInfo.ValidAccessMask = pObject->ValidAccessMask;
                Information->TypeInfo.DefaultNonPagedPoolCharge = pObject->DefaultNonPagedPoolCharge;
                Information->TypeInfo.DefaultPagedPoolCharge = pObject->DefaultPagedPoolCharge;
                Information->HighWaterNumberOfHandles = pObject->HighWaterNumberOfHandles;
                Information->HighWaterNumberOfObjects = pObject->HighWaterNumberOfObjects;
                Information->TypeInfo.PoolType = (POOL_TYPE)pObject->PoolType;
                if (pObject->SecurityRequired) {
                    SET_BIT(Information->TypeInfo.ObjectTypeFlags, 3);
                }
                if (pObject->MaintainHandleCount) {
                    SET_BIT(Information->TypeInfo.ObjectTypeFlags, 4);
                }
                bResult = TRUE;
                break;
            }
            pObject = OBJECT_TYPES_NEXT_ENTRY(pObject);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        supReportAbnormalTermination(__FUNCTIONW__);
        return FALSE;
    }

    supHeapFree(pObjectTypes);
    return bResult;
}

/*
* propSetTypeInfo
*
* Purpose:
*
* Set type information depending on object name or type
* Handle special case when user selected \ObjectTypes to provide per type information
*
*/
VOID propSetTypeInfo(
    _In_ PROP_OBJECT_INFO * Context,
    _In_ HWND hwndDlg
)
{
    BOOL bOkay;
    WOBJ_OBJECT_TYPE RealTypeIndex;
    INT i;
    LPCWSTR lpTypeDescription = NULL;
    OBJECT_TYPE_COMPATIBLE ObjectTypeDump;
    WCHAR szConvertBuffer[64];
    WCHAR szType[MAX_PATH * 2];

    POBEX_OBJECT_INFORMATION pObject = NULL;
    UNICODE_STRING usName;

    lpTypeDescription = Context->TypeDescription->Name;

    RealTypeIndex = Context->ShadowTypeDescription->Index;
    if (RealTypeIndex > ObjectTypeUnknown) {
        RealTypeIndex = ObjectTypeUnknown;
    }

    //if type is not known set it description to it type name
    if (RealTypeIndex != ObjectTypeUnknown) {

        //set description
        RtlSecureZeroMemory(&szType, sizeof(szType));
        if (LoadString(
            g_WinObj.hInstance,
            Context->TypeDescription->ResourceStringId,
            szType,
            RTL_NUMBER_OF(szType)))
        {
            lpTypeDescription = szType;
        }

    }

    //check if we have object address and dump object
    if (Context->ObjectInfo.ObjectAddress == 0) {
        propSetTypeFlags(hwndDlg, Context->ObjectFlags);
    }

    //
    // Handle special case.
    // Current object is Type object, display Type Info.
    //
    bOkay = FALSE;
    RtlSecureZeroMemory(&ObjectTypeDump, sizeof(ObjectTypeDump));
    if (Context->ObjectTypeIndex == ObjectTypeType) {

        //query object by name, thus were giving us proper object type dump
        pObject = ObQueryObjectInDirectory(
            &Context->NtObjectName,
            ObGetPredefinedUnicodeString(OBP_OBTYPES));

        //cannot query, no driver or other error, try second method
        if (pObject == NULL) {
            bOkay = propQueryTypeInfo(&Context->NtObjectName, &ObjectTypeDump);
        }

        //if type is not known set it description to it type name
        if (RealTypeIndex == ObjectTypeUnknown) {
            lpTypeDescription = Context->NtObjectName.Buffer;
        }
        else {
            //set description
            RtlSecureZeroMemory(&szType, sizeof(szType));
            if (LoadString(
                g_WinObj.hInstance,
                Context->ShadowTypeDescription->ResourceStringId,
                szType,
                RTL_NUMBER_OF(szType)))
            {
                lpTypeDescription = szType;
            }
            else {
                lpTypeDescription = Context->TypeDescription->Name;
            }
        }
    }
    else {

        //
        // Query object type object.
        //
        pObject = ObQueryObjectInDirectory(
            &Context->NtObjectName,
            ObGetPredefinedUnicodeString(OBP_OBTYPES));

        //
        // If we cannot query because of no driver or other error, try second method.
        //
        if (pObject == NULL) {
            RtlInitUnicodeString(&usName, Context->TypeDescription->Name);
            bOkay = propQueryTypeInfo(&usName, &ObjectTypeDump);
        }

    }

    //
    // Set description label.
    //
    SetDlgItemText(hwndDlg, ID_TYPE_DESCRIPTION, lpTypeDescription);

    //
    // Driver info available, dump type.
    //
    if (pObject != NULL) {
        
        bOkay = kdReadSystemMemory(pObject->ObjectAddress, 
            &ObjectTypeDump, 
            sizeof(OBJECT_TYPE_COMPATIBLE));

        supHeapFree(pObject);
    }

    if (bOkay) {
        RtlSecureZeroMemory(szConvertBuffer, sizeof(szConvertBuffer));

        //Object count
        u64tostr(ObjectTypeDump.TotalNumberOfObjects, szConvertBuffer);
        SetDlgItemText(hwndDlg, ID_TYPE_COUNT, szConvertBuffer);

        //Handle count
        szConvertBuffer[0] = 0;
        u64tostr(ObjectTypeDump.TotalNumberOfHandles, szConvertBuffer);
        SetDlgItemText(hwndDlg, ID_TYPE_HANDLECOUNT, szConvertBuffer);

        //Peek object count
        szConvertBuffer[0] = 0;
        u64tostr(ObjectTypeDump.HighWaterNumberOfObjects, szConvertBuffer);
        SetDlgItemText(hwndDlg, ID_TYPE_PEAKCOUNT, szConvertBuffer);

        //Peek handle count
        szConvertBuffer[0] = 0;
        u64tostr(ObjectTypeDump.HighWaterNumberOfHandles, szConvertBuffer);
        SetDlgItemText(hwndDlg, ID_TYPE_PEAKHANDLECOUNT, szConvertBuffer);

        //PoolType
        lpTypeDescription = T_Unknown;
        for (i = 0; i < MAX_KNOWN_POOL_TYPES; i++) {
            if (ObjectTypeDump.TypeInfo.PoolType == (POOL_TYPE)a_PoolTypes[i].dwValue) {
                lpTypeDescription = a_PoolTypes[i].lpDescription;
                break;
            }
        }
        SetDlgItemText(hwndDlg, ID_TYPE_POOLTYPE, lpTypeDescription);

        //Default NonPagedPoolCharge
        szConvertBuffer[0] = 0;
        u64tostr(ObjectTypeDump.TypeInfo.DefaultNonPagedPoolCharge, szConvertBuffer);
        SetDlgItemText(hwndDlg, ID_TYPE_NPCHARGE, szConvertBuffer);

        //Default PagedPoolCharge
        szConvertBuffer[0] = 0;
        u64tostr(ObjectTypeDump.TypeInfo.DefaultPagedPoolCharge, szConvertBuffer);
        SetDlgItemText(hwndDlg, ID_TYPE_PPCHARGE, szConvertBuffer);

        //Type flags
        propSetTypeFlags(hwndDlg, ObjectTypeDump.TypeInfo.ObjectTypeFlags);

        //Access rights
        propSetTypeAttributes(hwndDlg, &ObjectTypeDump);
    }
}

/*
* TypePropDialogOnInit
*
* Purpose:
*
* Type Dialog WM_INITDIALOG handler.
*
*/
VOID TypePropDialogOnInit(
    _In_  HWND hwndDlg,
    _In_  LPARAM lParam)
{
    PROPSHEETPAGE* pSheet = NULL;

    pSheet = (PROPSHEETPAGE*)lParam;
    if (pSheet) {
        SetProp(hwndDlg, T_PROPCONTEXT, (HANDLE)pSheet->lParam);
        supLoadIconForObjectType(hwndDlg,
            (PROP_OBJECT_INFO*)pSheet->lParam,
            g_ListViewImages,
            TRUE);
    }
    propSetTypeListView(hwndDlg);
}

/*
* TypePropDialogProc
*
* Purpose:
*
* Type Properties Dialog Procedure
*
* WM_SHOWWINDOW - when wParam is TRUE it sets "Type" page object information.
* WM_INITDIALOG - initialize object attributes listview, set context window prop.
* WM_DESTROY - remove context window prop.
*
*/
INT_PTR CALLBACK TypePropDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    PROP_OBJECT_INFO* Context = NULL;

    switch (uMsg) {
    case WM_SHOWWINDOW:
        Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
        if (Context) {
            //show window
            if (wParam) {
                propSetTypeInfo(Context, hwndDlg);
                SendDlgItemMessage(hwndDlg, ID_TYPE_ATTRLIST, LB_SETCURSEL,
                    (WPARAM)0, (LPARAM)0);
                SendMessage(hwndDlg, WM_COMMAND,
                    MAKEWPARAM(ID_TYPE_ATTRLIST, LBN_SELCHANGE), 0);
            }
        }
        return 1;

    case WM_INITDIALOG:
        TypePropDialogOnInit(hwndDlg, lParam);
        return 1;

    case WM_COMMAND:
        if (LOWORD(wParam) == ID_TYPE_ATTRLIST) {
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                Context = (PROP_OBJECT_INFO*)GetProp(hwndDlg, T_PROPCONTEXT);
                if (Context) {
                    propSetTypeDecodedAttributes(Context, hwndDlg);
                }
            }
        }
        return 1;

    case WM_DESTROY:
        RemoveProp(hwndDlg, T_PROPCONTEXT);
        break;
    }
    return 0;
}

```

`Source/WinObjEx64/props/propTypeConsts.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       PROPTYPECONSTS.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Consts header file for Type property sheet.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//Unknown object attribute
#define T_Unknown			L"Unknown"
#define T_NULL				L"NULL"

/*
** Object Attributes, Access Rights, etc
*/
#define T_StandardUnknown			L"StandardUnknown"
#define T_SpecificAccessRight		L"SpecificAccessRight"
#define T_GenericAll				L"Generic All"
#define T_GenericExecute			L"Generic Execute"
#define T_GenericWrite				L"Generic Write"
#define T_GenericRead				L"Generic Read"
#define T_ValidAccess				L"Valid Access"
#define	T_InvalidAttributes			L"Invalid Attributes"            

//OBJECT_TYPE->OBJECT_TYPE_INITIALIZER Flags
static LPCWSTR T_ObjectTypeFlags[] = {
    L"CaseInsensitive",         //0
    L"UnnamedObjectsOnly",      //1
    L"UseDefaultObject",        //2
    L"SecurityRequired",        //3
    L"MaintainHandleCount",     //4
    L"MaintainTypeList",        //5
    L"SupportsObjectCallbacks", //6
    L"CacheAligned"             //7
};

static LPCWSTR T_ObjectTypeFlags2[] = {
   L"UseExtendedParameters",    //8
   L"UnknownFlag",
   L"UnknownFlag",
   L"UnknownFlag",
   L"UnknownFlag",
   L"UnknownFlag",
   L"UnknownFlag",
   L"UnknownFlag"
};

//Known Object Attributes
#define MAX_KNOWN_OBJECT_ATTRIBUTES	10
static VALUE_DESC a_ObjProp[MAX_KNOWN_OBJECT_ATTRIBUTES] = {
    { L"OBJ_INHERIT", OBJ_INHERIT },
    { L"OBJ_PERMANENT", OBJ_PERMANENT },
    { L"OBJ_EXCLUSIVE", OBJ_EXCLUSIVE },
    { L"OBJ_CASE_INSENSITIVE", OBJ_CASE_INSENSITIVE },
    { L"OBJ_OPENIF", OBJ_OPENIF },
    { L"OBJ_OPENLINK", OBJ_OPENLINK },
    { L"OBJ_KERNEL_HANDLE", OBJ_KERNEL_HANDLE },
    { L"OBJ_FORCE_ACCESS_CHECK", OBJ_FORCE_ACCESS_CHECK },
    { L"OBJ_IGNORE_IMPERSONATED_DEVICEMAP", OBJ_IGNORE_IMPERSONATED_DEVICEMAP },
    { L"OBJ_DONT_REPARSE", OBJ_DONT_REPARSE }
};

//Standard Access Rights
#define MAX_KNOWN_STANDARD_ATTRIBUTES 11
static VALUE_DESC a_Standard[MAX_KNOWN_STANDARD_ATTRIBUTES] = {
    { L"DELETE", DELETE },
    { L"READ_CONTROL", READ_CONTROL },
    { L"WRITE_DAC", WRITE_DAC },
    { L"WRITE_OWNER", WRITE_OWNER },
    { L"SYNCHRONIZE", SYNCHRONIZE },
    { L"ACCESS_SYSTEM_SECURITY", ACCESS_SYSTEM_SECURITY },
    { L"MAXIMUM_ALLOWED", MAXIMUM_ALLOWED },
    { L"GENERIC_READ", GENERIC_READ },
    { L"GENERIC_WRITE", GENERIC_WRITE },
    { L"GENERIC_EXECUTE", GENERIC_EXECUTE },
    { L"GENERIC_ALL", GENERIC_ALL }
};

//Known pool types
#define MAX_KNOWN_POOL_TYPES 7
static VALUE_DESC a_PoolTypes[MAX_KNOWN_POOL_TYPES] = {
    { L"NonPagedPool", NonPagedPool },
    { L"PagedPool", PagedPool },
    { L"NonPagedPoolCacheAligned", NonPagedPoolCacheAligned },
    { L"PagedPoolCacheAligned", PagedPoolCacheAligned },
    { L"NonPagedPoolNx", NonPagedPoolNx },
    { L"NonPagedPoolNxCacheAligned", NonPagedPoolNxCacheAligned },
    { L"NonPagedPoolSessionNx", NonPagedPoolSessionNx }
};

//Known Directory Access Rights
#define MAX_KNOWN_DIRECTORY_ATTRIBUTES 4
static VALUE_DESC a_DirProp[MAX_KNOWN_DIRECTORY_ATTRIBUTES] = {
    { L"DIRECTORY_QUERY", DIRECTORY_QUERY },
    { L"DIRECTORY_TRAVERSE", DIRECTORY_TRAVERSE },
    { L"DIRECTORY_CREATE_OBJECT", DIRECTORY_CREATE_OBJECT },
    { L"DIRECTORY_CREATE_SUBDIRECTORY", DIRECTORY_CREATE_SUBDIRECTORY }
};

//Known Section Access Rights
#define MAX_KNOWN_SECTION_ATTRIBUTES 6
static VALUE_DESC a_SectionProp[MAX_KNOWN_SECTION_ATTRIBUTES] = {
    { L"SECTION_QUERY", SECTION_QUERY },
    { L"SECTION_MAP_WRITE", SECTION_MAP_WRITE },
    { L"SECTION_MAP_READ", SECTION_MAP_READ },
    { L"SECTION_MAP_EXECUTE", SECTION_MAP_EXECUTE },
    { L"SECTION_EXTEND_SIZE", SECTION_EXTEND_SIZE },
    { L"SECTION_MAP_EXECUTE_EXPLICIT", SECTION_MAP_EXECUTE_EXPLICIT }
};

//Known Event Access Rights
#define MAX_KNOWN_EVENT_ATTRIBUTES 2
static VALUE_DESC a_EventProp[MAX_KNOWN_EVENT_ATTRIBUTES] = {
    { L"EVENT_QUERY_STATE", EVENT_QUERY_STATE },
    { L"EVENT_MODIFY_STATE", EVENT_MODIFY_STATE }
};

//Known Event Access Rights
#define MAX_KNOWN_IOCOMPLETION_ATTRIBUTES 2
static VALUE_DESC a_IoCompletionProp[MAX_KNOWN_IOCOMPLETION_ATTRIBUTES] = {
    { L"IO_COMPLETION_QUERY_STATE", IO_COMPLETION_QUERY_STATE },
    { L"IO_COMPLETION_MODIFY_STATE", IO_COMPLETION_MODIFY_STATE }
};

//Known Mutant Access Rights
#define MAX_KNOWN_MUTANT_ATTRIBUTES 1
static VALUE_DESC a_MutantProp[MAX_KNOWN_MUTANT_ATTRIBUTES] = {
    { L"MUTANT_QUERY_STATE", MUTANT_QUERY_STATE }
};

//Known Port Access Rights
#define MAX_KNOWN_PORT_ATTRIBUTES 1
static VALUE_DESC a_PortProp[MAX_KNOWN_PORT_ATTRIBUTES] = {
    { L"PORT_CONNECT", PORT_CONNECT }
};

//Known Profile Access Rights
#define MAX_KNOWN_PROFILE_ATTRIBUTES 1
static VALUE_DESC a_ProfileProp[MAX_KNOWN_PROFILE_ATTRIBUTES] = {
    { L"PROFILE_CONTROL", PROFILE_CONTROL }
};

//Known Semaphore Access Rights
#define MAX_KNOWN_SEMAPHORE_ATTRIBUTES 2
static VALUE_DESC a_SemaphoreProp[MAX_KNOWN_SEMAPHORE_ATTRIBUTES] = {
    { L"SEMAPHORE_QUERY_STATE", SEMAPHORE_QUERY_STATE },
    { L"SEMAPHORE_MODIFY_STATE", SEMAPHORE_MODIFY_STATE }
};

//Known SymLink Access Rights
#define MAX_KNOWN_SYMLINK_ATTRIBUTES 2
static VALUE_DESC a_SymLinkProp[MAX_KNOWN_SYMLINK_ATTRIBUTES] = {
    { L"SYMBOLIC_LINK_QUERY", SYMBOLIC_LINK_QUERY },
    { L"SYMBOLIC_LINK_SET", SYMBOLIC_LINK_SET }
};

//Known Type Access Rights
#define MAX_KNOWN_TYPE_ATTRIBUTES 1
static VALUE_DESC a_TypeProp[MAX_KNOWN_TYPE_ATTRIBUTES] = {
    { L"OBJECT_TYPE_CREATE", OBJECT_TYPE_CREATE }
};

//Known Key Access Rights
#define MAX_KNOWN_KEY_ATTRIBUTES 8
static VALUE_DESC a_KeyProp[MAX_KNOWN_KEY_ATTRIBUTES] = {
    { L"KEY_QUERY_VALUE", KEY_QUERY_VALUE },
    { L"KEY_SET_VALUE", KEY_SET_VALUE },
    { L"KEY_CREATE_SUB_KEY", KEY_CREATE_SUB_KEY },
    { L"KEY_ENUMERATE_SUB_KEYS", KEY_ENUMERATE_SUB_KEYS },
    { L"KEY_NOTIFY", KEY_NOTIFY },
    { L"KEY_CREATE_LINK", KEY_CREATE_LINK },
    { L"KEY_WOW64_64KEY", KEY_WOW64_64KEY },
    { L"KEY_WOW64_32KEY", KEY_WOW64_32KEY }
};

//Known File Access Rights
#define MAX_KNOWN_FILE_ATTRIBUTES 14
static VALUE_DESC a_FileProp[MAX_KNOWN_FILE_ATTRIBUTES] = {
    { L"FILE_READ_DATA", FILE_READ_DATA },
    { L"FILE_LIST_DIRECTORY", FILE_LIST_DIRECTORY },
    { L"FILE_WRITE_DATA", FILE_WRITE_DATA },
    { L"FILE_ADD_FILE", FILE_ADD_FILE },
    { L"FILE_APPEND_DATA", FILE_APPEND_DATA },
    { L"FILE_ADD_SUBDIRECTORY", FILE_ADD_SUBDIRECTORY },
    { L"FILE_CREATE_PIPE_INSTANCE", FILE_CREATE_PIPE_INSTANCE },
    { L"FILE_READ_EA", FILE_READ_EA },
    { L"FILE_WRITE_EA", FILE_WRITE_EA },
    { L"FILE_EXECUTE", FILE_EXECUTE },
    { L"FILE_TRAVERSE", FILE_TRAVERSE },
    { L"FILE_DELETE_CHILD", FILE_DELETE_CHILD },
    { L"FILE_READ_ATTRIBUTES", FILE_READ_ATTRIBUTES },
    { L"FILE_WRITE_ATTRIBUTES", FILE_WRITE_ATTRIBUTES }
};

//Known Callback Access Rights
#define MAX_KNOWN_CALLBACK_ATTRIBUTES 1
static VALUE_DESC a_CallbackProp[MAX_KNOWN_CALLBACK_ATTRIBUTES] = {
    { L"CALLBACK_MODIFY_STATE", CALLBACK_MODIFY_STATE }
};

//Known DebugObject Access Rights
#define MAX_KNOWN_DEBUGOBJECT_ATTRIBUTES 4
static VALUE_DESC a_DebugObjectProp[MAX_KNOWN_DEBUGOBJECT_ATTRIBUTES] = {
    { L"DEBUG_READ_EVENT", DEBUG_READ_EVENT },
    { L"DEBUG_PROCESS_ASSIGN", DEBUG_PROCESS_ASSIGN },
    { L"DEBUG_SET_INFORMATION", DEBUG_SET_INFORMATION },
    { L"DEBUG_QUERY_INFORMATION", DEBUG_QUERY_INFORMATION }
};

//Known Desktop Access Rights
#define MAX_KNOWN_DESKTOP_ATTRIBUTES 9
static VALUE_DESC a_DesktopObjectProp[MAX_KNOWN_DESKTOP_ATTRIBUTES] = {
    { L"DESKTOP_READOBJECTS", DESKTOP_READOBJECTS },
    { L"DESKTOP_CREATEWINDOW", DESKTOP_CREATEWINDOW },
    { L"DESKTOP_CREATEMENU", DESKTOP_CREATEMENU },
    { L"DESKTOP_HOOKCONTROL", DESKTOP_HOOKCONTROL },
    { L"DESKTOP_JOURNALRECORD", DESKTOP_JOURNALRECORD },
    { L"DESKTOP_JOURNALPLAYBACK", DESKTOP_JOURNALPLAYBACK },
    { L"DESKTOP_ENUMERATE", DESKTOP_ENUMERATE },
    { L"DESKTOP_WRITEOBJECTS", DESKTOP_WRITEOBJECTS },
    { L"DESKTOP_SWITCHDESKTOP", DESKTOP_SWITCHDESKTOP }
};

//Known Job Access Rights
#define MAX_KNOWN_JOB_ATTRIBUTES 5
static VALUE_DESC a_JobProp[MAX_KNOWN_JOB_ATTRIBUTES] = {
    { L"JOB_OBJECT_ASSIGN_PROCESS", JOB_OBJECT_ASSIGN_PROCESS },
    { L"JOB_OBJECT_SET_ATTRIBUTES", JOB_OBJECT_SET_ATTRIBUTES },
    { L"JOB_OBJECT_QUERY", JOB_OBJECT_QUERY },
    { L"JOB_OBJECT_TERMINATE", JOB_OBJECT_TERMINATE },
    { L"JOB_OBJECT_SET_SECURITY_ATTRIBUTES", JOB_OBJECT_SET_SECURITY_ATTRIBUTES }
};

//Known Session Access Rights
#define MAX_KNOWN_SESSION_ATTRIBUTES 2
static VALUE_DESC a_SessionProp[MAX_KNOWN_SESSION_ATTRIBUTES] = {
    { L"SESSION_QUERY_ACCESS", SESSION_QUERY_ACCESS },
    { L"SESSION_MODIFY_ACCESS", SESSION_MODIFY_ACCESS }
};

//Known KeyedEvent Access Rights
#define MAX_KNOWN_KEYEDEVENT_ATTRIBUTES 2
static VALUE_DESC a_KeyedEventProp[MAX_KNOWN_KEYEDEVENT_ATTRIBUTES] = {
    { L"KEYEDEVENT_WAIT", KEYEDEVENT_WAIT },
    { L"KEYEDEVENT_WAKE", KEYEDEVENT_WAKE }
};

//Known Process Access Rights
#define MAX_KNOWN_PROCESS_ATTRIBUTES 16
static VALUE_DESC a_ProcessProp[MAX_KNOWN_PROCESS_ATTRIBUTES] = {
    { L"PROCESS_TERMINATE", PROCESS_TERMINATE },
    { L"PROCESS_CREATE_THREAD", PROCESS_CREATE_THREAD },
    { L"PROCESS_SET_SESSIONID", PROCESS_SET_SESSIONID },
    { L"PROCESS_VM_OPERATION", PROCESS_VM_OPERATION },
    { L"PROCESS_VM_READ", PROCESS_VM_READ },
    { L"PROCESS_VM_WRITE", PROCESS_VM_WRITE },
    { L"PROCESS_DUP_HANDLE", PROCESS_DUP_HANDLE },
    { L"PROCESS_CREATE_PROCESS", PROCESS_CREATE_PROCESS },
    { L"PROCESS_SET_QUOTA", PROCESS_SET_QUOTA },
    { L"PROCESS_SET_INFORMATION", PROCESS_SET_INFORMATION },
    { L"PROCESS_QUERY_INFORMATION", PROCESS_QUERY_INFORMATION },
    { L"PROCESS_SUSPEND_RESUME", PROCESS_SUSPEND_RESUME },
    { L"PROCESS_QUERY_LIMITED_INFORMATION", PROCESS_QUERY_LIMITED_INFORMATION },
    { L"PROCESS_SET_LIMITED_INFORMATION", PROCESS_SET_LIMITED_INFORMATION },
    { L"PROCESS_RESERVED1", (0x4000) },
    { L"PROCESS_RESERVED2", (0x8000) }
};

//Known Timer Access Rights
#define MAX_KNOWN_TIMER_ATTRIBUTES 2
static VALUE_DESC a_TimerProp[MAX_KNOWN_TIMER_ATTRIBUTES] = {
    { L"TIMER_QUERY_STATE", TIMER_QUERY_STATE },
    { L"TIMER_MODIFY_STATE", TIMER_MODIFY_STATE }
};

//Known Thread Access Rights
#define MAX_KNOWN_THREAD_ATTRIBUTES 16
static VALUE_DESC a_ThreadProp[MAX_KNOWN_THREAD_ATTRIBUTES] = {
    { L"THREAD_TERMINATE", THREAD_TERMINATE },
    { L"THREAD_SUSPEND_RESUME", THREAD_SUSPEND_RESUME },
    { L"THREAD_ALERT", THREAD_ALERT },
    { L"THREAD_GET_CONTEXT", THREAD_GET_CONTEXT },
    { L"THREAD_SET_CONTEXT", THREAD_SET_CONTEXT },
    { L"THREAD_QUERY_INFORMATION", THREAD_QUERY_INFORMATION },
    { L"THREAD_SET_INFORMATION", THREAD_SET_INFORMATION },
    { L"THREAD_SET_THREAD_TOKEN", THREAD_SET_THREAD_TOKEN },
    { L"THREAD_IMPERSONATE", THREAD_IMPERSONATE },
    { L"THREAD_DIRECT_IMPERSONATION", THREAD_DIRECT_IMPERSONATION },
    { L"THREAD_SET_LIMITED_INFORMATION", THREAD_SET_LIMITED_INFORMATION },
    { L"THREAD_QUERY_LIMITED_INFORMATION", THREAD_QUERY_LIMITED_INFORMATION },
    { L"THREAD_RESUME", THREAD_RESUME },
    { L"THREAD_RESERVED1", (0x2000) },
    { L"THREAD_RESERVED2", (0x4000) },
    { L"THREAD_RESERVED3", (0x8000) }
};

//Known Token Access Rights
#define MAX_KNOWN_TOKEN_ATTRIBUTES 9
static VALUE_DESC a_TokenProp[MAX_KNOWN_TOKEN_ATTRIBUTES] = {
    { L"TOKEN_ASSIGN_PRIMARY", TOKEN_ASSIGN_PRIMARY },
    { L"TOKEN_DUPLICATE", TOKEN_DUPLICATE },
    { L"TOKEN_IMPERSONATE", TOKEN_IMPERSONATE },
    { L"TOKEN_QUERY", TOKEN_QUERY },
    { L"TOKEN_QUERY_SOURCE", TOKEN_QUERY_SOURCE },
    { L"TOKEN_ADJUST_PRIVILEGES", TOKEN_ADJUST_PRIVILEGES },
    { L"TOKEN_ADJUST_GROUPS", TOKEN_ADJUST_GROUPS },
    { L"TOKEN_ADJUST_DEFAULT", TOKEN_ADJUST_DEFAULT },
    { L"TOKEN_ADJUST_SESSIONID", TOKEN_ADJUST_SESSIONID }
};

//Known WinStation Access Rights
#define MAX_KNOWN_WINSTA_ATTRIBUTES 9
static VALUE_DESC a_WinstaProp[MAX_KNOWN_WINSTA_ATTRIBUTES] = {
    { L"WINSTA_ENUMDESKTOPS", WINSTA_ENUMDESKTOPS },
    { L"WINSTA_READATTRIBUTES", WINSTA_READATTRIBUTES },
    { L"WINSTA_ACCESSCLIPBOARD", WINSTA_ACCESSCLIPBOARD },
    { L"WINSTA_CREATEDESKTOP", WINSTA_CREATEDESKTOP },
    { L"WINSTA_WRITEATTRIBUTES", WINSTA_WRITEATTRIBUTES },
    { L"WINSTA_ACCESSGLOBALATOMS", WINSTA_ACCESSGLOBALATOMS },
    { L"WINSTA_EXITWINDOWS", WINSTA_EXITWINDOWS },
    { L"WINSTA_ENUMERATE", WINSTA_ENUMERATE },
    { L"WINSTA_READSCREEN", WINSTA_READSCREEN }
};

//Known WmiGuid Access Rights
#define MAX_KNOWN_WMIGUID_ATTRIBUTES 13
static VALUE_DESC a_WmiGuidProp[MAX_KNOWN_WMIGUID_ATTRIBUTES] = {
    { L"WMIGUID_QUERY", WMIGUID_QUERY },
    { L"WMIGUID_SET", WMIGUID_SET },
    { L"WMIGUID_NOTIFICATION", WMIGUID_NOTIFICATION },
    { L"WMIGUID_READ_DESCRIPTION", WMIGUID_READ_DESCRIPTION },
    { L"WMIGUID_EXECUTE", WMIGUID_EXECUTE },
    { L"TRACELOG_CREATE_REALTIME", TRACELOG_CREATE_REALTIME },
    { L"TRACELOG_CREATE_ONDISK", TRACELOG_CREATE_ONDISK },
    { L"TRACELOG_GUID_ENABLE", TRACELOG_GUID_ENABLE },
    { L"TRACELOG_ACCESS_KERNEL_LOGGER", TRACELOG_ACCESS_KERNEL_LOGGER },
    { L"TRACELOG_LOG_EVENT", TRACELOG_LOG_EVENT },
    { L"TRACELOG_ACCESS_REALTIME", TRACELOG_ACCESS_REALTIME },
    { L"TRACELOG_REGISTER_GUIDS", TRACELOG_REGISTER_GUIDS },
    { L"TRACELOG_JOIN_GROUP", TRACELOG_JOIN_GROUP }
};

//Known TmTx/RegistryTransaction Access Rights
#define MAX_KNOWN_TMTX_ATTRIBUTES 7
static VALUE_DESC a_TmTxProp[MAX_KNOWN_TMTX_ATTRIBUTES] = {
    { L"TRANSACTION_QUERY_INFORMATION", TRANSACTION_QUERY_INFORMATION },
    { L"TRANSACTION_SET_INFORMATION", TRANSACTION_SET_INFORMATION },
    { L"TRANSACTION_ENLIST", TRANSACTION_ENLIST },
    { L"TRANSACTION_COMMIT", TRANSACTION_COMMIT },
    { L"TRANSACTION_ROLLBACK", TRANSACTION_ROLLBACK },
    { L"TRANSACTION_PROPAGATE", TRANSACTION_PROPAGATE },
    { L"TRANSACTION_RIGHT_RESERVED1", TRANSACTION_RIGHT_RESERVED1 }
};

//Known TmRm Access Rights
#define MAX_KNOWN_TMRM_ATTRIBUTES 7
static VALUE_DESC a_TmRmProp[MAX_KNOWN_TMRM_ATTRIBUTES] = {
    { L"RESOURCEMANAGER_QUERY_INFORMATION", RESOURCEMANAGER_QUERY_INFORMATION },
    { L"RESOURCEMANAGER_SET_INFORMATION", RESOURCEMANAGER_SET_INFORMATION },
    { L"RESOURCEMANAGER_RECOVER", RESOURCEMANAGER_RECOVER },
    { L"RESOURCEMANAGER_ENLIST", RESOURCEMANAGER_ENLIST },
    { L"RESOURCEMANAGER_GET_NOTIFICATION", RESOURCEMANAGER_GET_NOTIFICATION },
    { L"RESOURCEMANAGER_REGISTER_PROTOCOL", RESOURCEMANAGER_REGISTER_PROTOCOL },
    { L"RESOURCEMANAGER_COMPLETE_PROPAGATION", RESOURCEMANAGER_COMPLETE_PROPAGATION }
};

//Known TmEn Access Rights
#define MAX_KNOWN_TMEN_ATTRIBUTES 5
static VALUE_DESC a_TmEnProp[MAX_KNOWN_TMEN_ATTRIBUTES] = {
    { L"ENLISTMENT_QUERY_INFORMATION", ENLISTMENT_QUERY_INFORMATION },
    { L"ENLISTMENT_SET_INFORMATION", ENLISTMENT_SET_INFORMATION },
    { L"ENLISTMENT_RECOVER", ENLISTMENT_RECOVER },
    { L"ENLISTMENT_SUBORDINATE_RIGHTS", ENLISTMENT_SUBORDINATE_RIGHTS },
    { L"ENLISTMENT_SUPERIOR_RIGHTS", ENLISTMENT_SUPERIOR_RIGHTS }
};

//Known TmTm Access Rights
#define MAX_KNOWN_TMTM_ATTRIBUTES 6
static VALUE_DESC a_TmTmProp[MAX_KNOWN_TMTM_ATTRIBUTES] = {
    { L"TRANSACTIONMANAGER_QUERY_INFORMATION", TRANSACTIONMANAGER_QUERY_INFORMATION },
    { L"TRANSACTIONMANAGER_SET_INFORMATION", TRANSACTIONMANAGER_SET_INFORMATION },
    { L"TRANSACTIONMANAGER_RECOVER", TRANSACTIONMANAGER_RECOVER },
    { L"TRANSACTIONMANAGER_RENAME", TRANSACTIONMANAGER_RENAME },
    { L"TRANSACTIONMANAGER_CREATE_RM", TRANSACTIONMANAGER_CREATE_RM },
    { L"TRANSACTIONMANAGER_BIND_TRANSACTION", TRANSACTIONMANAGER_BIND_TRANSACTION }
};

//Known TpWorkerFactory Access Rights
#define MAX_KNOWN_TPWORKERFACTORY_ATTRIBUTES 8
static VALUE_DESC a_TpwfProp[MAX_KNOWN_TPWORKERFACTORY_ATTRIBUTES] = {
    { L"WORKER_FACTORY_RELEASE_WORKER", WORKER_FACTORY_RELEASE_WORKER },
    { L"WORKER_FACTORY_WAIT", WORKER_FACTORY_WAIT },
    { L"WORKER_FACTORY_SET_INFORMATION", WORKER_FACTORY_SET_INFORMATION },
    { L"WORKER_FACTORY_QUERY_INFORMATION", WORKER_FACTORY_QUERY_INFORMATION },
    { L"WORKER_FACTORY_READY_WORKER", WORKER_FACTORY_READY_WORKER },
    { L"WORKER_FACTORY_SHUTDOWN", WORKER_FACTORY_SHUTDOWN },
    { L"WORKER_FACTORY_RESERVED1", 0x0040 },
    { L"WORKER_FACTORY_RESERVED2", 0x0080 }
};

//Known PcwObject Access Rights
#define MAX_KNOWN_PCWOBJECT_ATTRIBUTES 2
static VALUE_DESC a_PcwProp[MAX_KNOWN_PCWOBJECT_ATTRIBUTES] = {
    { L"PCW_QUERY_ACCESS", 0x0001L },
    { L"PCW_MODIFY_ACCESS", 0x0002L }
};

//Known Composition Access Rights
#define MAX_KNOWN_COMPOSITION_ATTRIBUTES 2
static VALUE_DESC a_CompositionProp[MAX_KNOWN_COMPOSITION_ATTRIBUTES] = {
    { L"COMPOSITIONSURFACE_READ", COMPOSITIONSURFACE_READ },
    { L"COMPOSITIONSURFACE_WRITE", COMPOSITIONSURFACE_WRITE }
};

//Known Memory Partition Access Rights
#define MAX_KNOWN_MEMPARTITION_ATTRIBUTES 2
static VALUE_DESC a_MemPartProp[MAX_KNOWN_MEMPARTITION_ATTRIBUTES] = {
    { L"MEMORY_PARTITION_QUERY_ACCESS", MEMORY_PARTITION_QUERY_ACCESS },
    { L"MEMORY_PARTITION_MODIFY_ACCESS", MEMORY_PARTITION_MODIFY_ACCESS }
};

//Known Object Type Initializers
#define MAX_KNOWN_OBJECT_TYPE_PROCEDURES 8
static LPWSTR T_TYPEPROCEDURES[MAX_KNOWN_OBJECT_TYPE_PROCEDURES] = {
    L"DumpProcedure",
    L"OpenProcedure",
    L"CloseProcedure",
    L"DeleteProcedure",
    L"ParseProcedure",
    L"SecurityProcedure",
    L"QueryNameProcedure",
    L"OkayToCloseProcedure"
};

```

`Source/WinObjEx64/props/props.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2024
*
*  TITLE:       PROPS.H
*
*  VERSION:     2.05
*
*  DATE:        11 Mar 2024
*
*  Common header file for properties dialog definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Dialog procs.
//

INT_PTR CALLBACK AlpcPortListDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK BasicPropDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK DesktopListDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK DriverRegistryDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK ObjectDumpDialogProc(
    _In_  HWND hwndDlg,
    _In_  UINT uMsg,
    _In_  WPARAM wParam,
    _In_  LPARAM lParam);

INT_PTR CALLBACK ProcessListDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK SectionPropertiesDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK TokenPageDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

INT_PTR CALLBACK TypePropDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

//
// Security page.
//
HPROPSHEETPAGE propSecurityCreatePage(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ POPENOBJECTMETHOD OpenObjectMethod,
    _In_opt_ PCLOSEOBJECTMETHOD CloseObjectMethod,
    _In_ ULONG psiFlags);

//
// Object dump
//
HTREEITEM propObDumpUlong(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_ ULONG Value,
    _In_ BOOL HexDump,
    _In_ BOOL IsUShort,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor);

VOID propObDumpUlong64(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_ ULONG64 Value,
    _In_ BOOL OutAsHex,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor);

VOID propObDumpByte(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_ BYTE Value,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor,
    _In_ BOOL IsBool);

HTREEITEM propObDumpAddress(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_opt_ PVOID Address,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor);

HTREEITEM propObDumpSetString(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_opt_ LPWSTR lpszValue,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor);

HTREEITEM propObDumpLong(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_ LONG Value,
    _In_ BOOL HexDump,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor);

VOID propObDumpLong64(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR lpszName,
    _In_opt_ LPWSTR lpszDesc,
    _In_opt_ LONG64 Value,
    _In_ BOOL OutAsHex,
    _In_ COLORREF BgColor,
    _In_ COLORREF FontColor);

VOID propObDumpListEntry(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR ListEntryName,
    _In_opt_ PLIST_ENTRY ListEntry);

VOID propObDumpUSHORT(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR Name,
    _In_ USHORT Value,
    _In_ BOOLEAN HexOutput);

VOID propObDumpUnicodeString(
    _In_ HWND TreeList,
    _In_ HTREEITEM hParent,
    _In_ LPWSTR StringName,
    _In_ PUNICODE_STRING InputString,
    _In_ BOOLEAN IsKernelPointer);

VOID propDumpEnumWithNames(
    _In_ HWND TreeList,
    _In_ HTREEITEM ParentItem,
    _In_ LPWSTR EnumName,
    _In_ ULONG EnumValue,
    _In_ PVALUE_DESC EnumNames,
    _In_ ULONG EnumNamesCount);

```

`Source/WinObjEx64/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDS_DESC_DEVICE                 100
#define IDS_DESC_DRIVER                 101
#define IDR_MAINMENU                    101
#define IDS_DESC_SECTION                102
#define IDS_DESC_PORT                   103
#define IDS_DESC_SYMLINK                104
#define IDS_DESC_KEY                    105
#define IDS_DESC_EVENT                  106
#define IDS_DESC_JOB                    107
#define IDS_DESC_MUTANT                 108
#define IDS_DESC_KEYEDEVENT             109
#define IDS_DESC_TYPE                   110
#define IDS_DESC_DIRECTORY              111
#define IDS_DESC_WINSTATION             112
#define IDS_DESC_CALLBACK               113
#define IDS_DESC_SEMAPHORE              114
#define IDS_DESC_WAITABLEPORT           115
#define IDS_DESC_TIMER                  116
#define IDS_DESC_SESSION                117
#define IDS_DESC_CONTROLLER             118
#define IDS_DESC_PROFILE                119
#define IDS_DESC_EVENTPAIR              120
#define IDS_DESC_DESKTOP                121
#define IDS_DESC_FILE                   122
#define IDS_DESC_WMIGUID                123
#define IDS_DESC_DEBUGOBJECT            124
#define IDS_DESC_IOCOMPLETION           125
#define IDS_DESC_PROCESS                126
#define IDS_DESC_ADAPTER                127
#define ID_ABOUT_ICON                   128
#define IDS_DESC_TOKEN                  128
#define IDS_DESC_ETWREGISTRATION        129
#define IDS_DESC_THREAD                 130
#define IDS_DESC_TMTX                   131
#define IDS_DESC_TMTM                   132
#define IDS_DESC_TMRM                   133
#define IDS_DESC_TMEN                   134
#define IDS_DESC_PCWOBJECT              135
#define IDS_DESC_FLT_CONN_PORT          136
#define IDS_DESC_FLT_COMM_PORT          137
#define IDS_DESC_POWERREQUEST           138
#define IDS_DESC_ETWCONSUMER            139
#define IDS_DESC_TPWORKERFACTORY        140
#define IDS_DESC_COMPOSITION            141
#define IDS_DESC_IRTIMER                142
#define IDS_DESC_DXGKSHAREDRES          143
#define IDS_DESC_DXGK_SHARED_RESOURCE   143
#define IDS_DESC_DXGK_SHARED_SWAPCHAIN  144
#define IDS_DESC_DXGK_SHARED_SYNC       145
#define IDS_DESC_DXGK_CURRENT_DXG_PROCESS_OBJECT 146
#define IDS_DESC_DXGK_DISPLAY_MANAGER_OBJECT 147
#define IDS_DESC_DXGK_SHARED_BUNDLE_OBJECT 148
#define IDS_DESC_DXGK_SHARED_PROTECTED_SESSION_OBJECT 149
#define IDS_DESC_DXGK_COMPOSITION_OBJECT 150
#define IDS_DESC_DXGK_SHARED_KEYED_MUTEX_OBJECT 151
#define IDS_DESC_MEMORY_PARTITION       152
#define IDS_DESC_REGISTRY_TRANSACTION   153
#define IDS_DESC_DMAADAPTER             154
#define IDS_DESC_DMACONTROLLER          155
#define IDS_DESC_DMADOMAIN              155
#define IDS_DESC_DXGK_CURRENT_DXG_THREAD_OBJECT 156
#define IDS_DESC_COVERAGESAMPLER        157
#define IDS_DESC_ACTIVATIONOBJECT       158
#define IDS_DESC_ACTIVITYREFERENCE      159
#define IDS_DESC_COREMESSAGING          160
#define IDS_DESC_RAWINPUTMANAGER        161
#define IDS_DESC_WAITCOMPLETIONPACKET   162
#define IDS_DESC_IOCOMPLETIONRESERVE    163
#define IDD_DIALOG_ABOUT                164
#define IDS_DESC_USERAPCRESERVE         164
#define IDB_BITMAP1                     165
#define IDS_DESC_IORING                 165
#define IDR_ACCELERATOR1                166
#define IDS_DESC_TERMINAL               166
#define IDD_DIALOG_SEARCH               167
#define IDS_DESC_TERMINALEVENTQUEUE     167
#define IDS_DESC_ENERGYTRACKER          168
#define IDS_DESC_DXGK_DISPLAYMUXSWITCH  169
#define IDR_KDBGDRV                     170
#define IDS_DESC_VREGCFGCTX             170
#define IDD_PROP_BASIC                  171
#define IDS_DESC_PSSILOCONTEXTNP        171
#define IDD_PROP_PROCESSLIST            172
#define IDS_DESC_PSSILOCONTEXT          172
#define IDD_PROP_SERVICE                173
#define IDS_DESC_ETWSESSIONDEMUXENTRY   173
#define IDI_ICON_MAIN                   174
#define IDD_PROP_SYMLINK                174
#define IDS_DESC_NDISCMSTATE            174
#define IDD_PROP_SECTION                175
#define IDS_DESC_PROCESSSTATECHANGE     175
#define IDD_PROP_SEMAPHORE              176
#define IDS_DESC_THREADSTATECHANGE      176
#define IDD_PROP_EVENT                  177
#define IDS_DESC_CROSSVMEVENT           177
#define IDD_PROP_MUTANT                 178
#define IDS_DESC_CROSSVMMUTANT          178
#define IDD_PROP_TIMER                  179
#define IDS_DESC_SCHEDULERSHAREDDATA    179
#define IDD_PROP_KEY                    180
#define IDS_DESC_CPUPARTITION           180
#define IDD_PROP_JOB                    181
#define IDS_STRING181                   181
#define IDS_DESC_VIRTUALKEY             181
#define IDD_PROP_WINSTATION             183
#define IDD_PROP_DRIVER                 184
#define IDD_PROP_DEVICE                 185
#define IDD_PROP_OBJECTDUMP             186
#define IDD_PROP_TYPE                   187
#define IDD_PROP_DESKTOPS               189
#define IDD_PROP_IOCOMPLETION           190
#define IDD_PROP_PIPE                   192
#define IDD_DIALOG_USD                  193
#define IDD_DIALOG_PNAMESPACE           194
#define IDD_DIALOG_EXTRASLIST           195
#define IDD_DIALOG_IPCOBJECTS           196
#define IDD_PROP_MAILSLOT               197
#define IDD_PROP_ALPCPORT               198
#define IDI_ICON_VIEW_DEFAULT           207
#define IDI_ICON_VIEW_SELECTED          208
#define IDI_ICON_PIPE                   213
#define IDI_ICON_MAILSLOT               214
#define IDD_DIALOG_CALLBACKS            241
#define IDD_DIALOG_PSLIST               242
#define IDI_ICON_HALDMA                 243
#define IDD_PROP_PROCESS                243
#define IDD_PROP_THREAD                 244
#define IDD_DIALOG_TOKEN                245
#define IDD_DIALOG_SLCACHE              246
#define IDD_DIALOG_GLOBALS              247
#define IDD_PROP_TOKEN                  248
#define IDD_DIALOG_LOGVIEWER            249
#define IDD_DIALOG_VIEWPLUGINS          251
#define IDI_ICON1                       254
#define IDI_ICON_SECURITY               254
#define IDD_DIALOG_VIEWSD               255
#define IDD_DIALOG_SDVIEW               255
#define IDD_PROP_PROCESSLIST1           256
#define IDD_PROP_PORTLIST               256
#define IDD_PROP_ALPCPORTLIST           256
#define IDD_DIALOG_LOADLIST             257
#define IDD_DIALOG_STATS                260
#define IDD_DIALOG_PROGRESS             262
#define IDR_PSLISTMENU                  264
#define IDD_DIALOG1                     265
#define IDD_DIALOG_PSLISTLEGEND         265
#define IDI_ICON_DEVICE                 300
#define IDS_DESC_UNKNOWN                300
#define IDI_ICON_DRIVER                 301
#define IDI_ICON_SECTION                302
#define IDI_ICON_PORT                   303
#define IDI_ICON_SYMLINK                304
#define IDI_ICON_KEY                    305
#define IDI_ICON_EVENT                  306
#define IDI_ICON_JOB                    307
#define IDI_ICON_MUTANT                 308
#define IDI_ICON_KEYEDEVENT             309
#define IDI_ICON_TYPE                   310
#define IDI_ICON_DIRECTORY              311
#define IDI_ICON_WINSTATION             312
#define IDI_ICON_CALLBACK               313
#define IDI_ICON_SEMAPHORE              314
#define IDI_ICON_WAITABLEPORT           315
#define IDI_ICON_TIMER                  316
#define IDI_ICON_SESSION                317
#define IDI_ICON_CONTROLLER             318
#define IDI_ICON_PROFILE                319
#define IDI_ICON_EVENTPAIR              320
#define IDI_ICON_DESKTOP                321
#define IDI_ICON_FILE                   322
#define IDI_ICON_WMIGUID                323
#define IDI_ICON_DEBUGOBJECT            324
#define IDI_ICON_IOCOMPLETION           325
#define IDI_ICON_PROCESS                326
#define IDI_ICON_ADAPTER                327
#define IDI_ICON_TOKEN                  328
#define IDI_ICON_ETWREGISTRATION        329
#define IDI_ICON_THREAD                 330
#define IDI_ICON_TMTX                   331
#define IDI_ICON_TMTM                   332
#define IDI_ICON_TMRM                   333
#define IDI_ICON_TMEN                   334
#define IDI_ICON_PCWOBJECT              335
#define IDI_ICON_FLTCONNPORT            336
#define IDI_ICON_FLTCOMMPORT            337
#define IDI_ICON_POWERREQUEST           338
#define IDI_ICON_ETWCONSUMER            339
#define IDI_ICON_TPWORKERFACTORY        340
#define IDI_ICON_COMPOSITION            341
#define IDI_ICON_IRTIMER                342
#define IDI_ICON_DXOBJECT               343
#define IDI_ICON_MEMORYPARTITION        350
#define IDI_ICON_UNKNOWN                352
#define IDC_OBJECT_FLAGS                700
#define ID_DEVICEDESCRIPTION            1001
#define ID_SECTION_ATTR                 1002
#define IDC_TYPE_FLAGS                  1002
#define ID_SECTIONSIZE                  1003
#define ID_SEMAPHORECURRENT             1004
#define IDC_JOB_PLIST                   1004
#define ID_IMAGE_ENTRY                  1005
#define ID_SEMAPHOREMAXCOUNT            1006
#define ID_DESKTOPSNOTALL               1006
#define ID_DESKTOPSLIST                 1007
#define ID_EVENTTYPE                    1008
#define IDC_QUERYFAIL                   1008
#define ID_EVENTSTATE                   1009
#define IDC_SERVICE_DEPENDSONGROUP      1009
#define ID_IMAGE_STACKRESERVE           1010
#define IDC_SERVICE_DEPENDSONSERVICE    1010
#define ID_MUTANTABANDONED              1011
#define IDC_SERVICE_DEPENDENTSERVICES   1011
#define ID_IMAGE_STACKCOMMIT            1012
#define IDC_SERVICE_DESCRIPTION         1012
#define ID_IMAGE_SUBSYSTEM              1013
#define ID_MUTANTSTATE                  1014
#define IDC_SERVICE_IMAGEPATH           1014
#define ID_IMAGE_MJV                    1015
#define IDC_SERVICE_DISPLAYNAME         1015
#define ID_IOCOMPLETIONSTATE            1015
#define ID_OBJECT_SYMLINK_CREATION      1016
#define IDC_SERVICE_KEYNAME             1016
#define IDC_SERVICE_KEYNAME2            1017
#define IDC_SERVICE_LOADORDERGROUP      1017
#define ID_USDLIST                      1017
#define ID_OBJECT_SYMLINK_TARGET        1018
#define ID_NAMESPACELIST                1018
#define ID_IMAGE_MNV                    1019
#define ID_PNAMESPACESNOTALL            1019
#define ID_PNAMESPACESINFO              1019
#define ID_TIMERREMAINING               1020
#define ID_IMAGE_MNV2                   1020
#define ID_IMAGE_FLAGS                  1020
#define ID_IMAGE_EXECUTABLE             1021
#define ID_EXTRASLIST                   1021
#define ID_TIMERSTATE                   1022
#define IDC_PSLIST_STATUSBAR            1022
#define ID_KEYSUBKEYS                   1023
#define ID_IPCOBJECTSLIST               1023
#define ID_KEYLASTWRITE                 1024
#define ID_IPCROOT                      1024
#define ID_KEYVALUES                    1025
#define ID_MAILSLOT_FULLPATH            1025
#define ID_JOBTOTALPROCS                1026
#define ID_MAILSLOT_MAXMESSAGESZ        1026
#define ID_JOBACTIVEPROCS               1027
#define ID_MAILSLOT_QUOTA               1027
#define ID_JOBTERMINATEDPROCS           1028
#define ID_MAILSLOT_NEXTMSGSZ           1028
#define ID_MAILSLOT_READTIMEOUT         1029
#define ID_JOBTOTALUMTIME               1030
#define ID_MAILSLOT_MSGAVAILABLE        1030
#define ID_JOBTOTALKMTIME               1032
#define ID_JOBTPTOTALKMTIME             1033
#define ID_JOBTOTALPF                   1034
#define ID_SIZEOFBOUNDARYINFO           1035
#define ID_JOBTPTOTALKMTIME2            1035
#define ID_JOBTPTOTALUMTIME             1035
#define ID_INTEGRITYLABEL               1036
#define ID_TYPE_COUNT                   1037
#define ID_BDESCRIPTOR_ENTRIES          1037
#define ID_TYPE_HANDLECOUNT             1038
#define ID_TYPE_PEAKCOUNT               1039
#define ID_BDESCRIPTOR_NAME2            1039
#define ID_TYPE_PEAKHANDLECOUNT         1040
#define ID_BDESCRIPTOR_SID_COPY         1040
#define ID_TYPE_POOLTYPE                1041
#define IDC_ABOUT_GLOBALS               1041
#define ID_ALPC_OWNERPROCESS            1043
#define IDC_LOADING_MSG                 1044
#define ID_TYPE_ACL_LIST                1045
#define IDC_PSLIST_LISTVIEW             1045
#define IDC_LOADING_MSG2                1045
#define ID_TYPE_ATTRLIST                1046
#define IDC_GLOBALS_COPY                1046
#define IDC_PSLIST_TREELIST             1047
#define ID_SEARCH_STATUSBAR             1048
#define ID_EXTRASLIST_STATUSBAR         1049
#define ID_PROCESSINFO                  1050
#define ID_THREADINFO                   1051
#define ID_OBJECT_NAME                  1053
#define ID_OBJECT_TYPE                  1054
#define ID_OBJECT_REFC                  1056
#define ID_OBJECT_HANDLES               1057
#define ID_OBJECT_PP_CHARGE             1058
#define ID_OBJECT_NP_CHARGE             1059
#define ID_OBJECT_TRUSTLABEL            1060
#define IDC_PROCESS_STARTED             1060
#define ID_OBJECT_SYMLINKINFO           1061
#define ID_SECTIONINFO                  1061
#define ID_SEMAPHOREINFO                1061
#define ID_WINSTATIONINFO               1061
#define IDC_PROCESS_CMDLINE             1061
#define IDC_PROCESS_CURDIR              1062
#define ID_PIPE_CURINSTANCES            1063
#define IDC_PROCESS_FILENAME            1063
#define ID_OBJECT_HEADER                1064
#define ID_TYPE_PPCHARGE                1065
#define IDC_PROCESS_IMAGETYPE           1065
#define IDC_THREAD_NAME                 1065
#define IDC_PROCESS_BROWSE              1066
#define ID_PIPE_MAXINSTANCES            1067
#define IDC_PROCESS_MITIGATIONS         1067
#define ID_OBJECT_ADDR                  1068
#define ID_PIPE_QUERYFAIL               1068
#define IDC_PROCESS_STARTED2            1069
#define IDC_PROCESS_PROTECTION          1069
#define IDC_THREAD_STARTED              1069
#define IDC_PROCESS_TYPE_FLAGS          1070
#define IDC_THREAD_KERNELTIME           1070
#define IDC_TOKEN_PRIVLIST              1070
#define IDC_PROCESS_CRITICAL            1071
#define IDC_THREAD_USERTIME             1071
#define IDC_TOKEN_ERROR                 1071
#define ID_TYPE_NPCHARGE                1072
#define IDC_THREAD_CONTEXTSWITCHES      1072
#define IDC_TOKEN_USER                  1072
#define IDC_THREAD_BASEPRIORITY         1073
#define IDC_TOKEN_                      1073
#define IDC_TOKEN_SID                   1073
#define IDC_THREAD_DYNPRIORITY          1074
#define IDC_TOKEN_SESSION               1074
#define IDC_THREAD_AFFINITYMASK         1075
#define IDC_THREAD_IDEALPROCESSOR       1075
#define IDC_TOKEN_ELEVATED              1075
#define IDC_THREAD_CRITICAL             1076
#define IDC_TOKEN_VIRTUALIZED           1076
#define IDC_TOKEN_INTEGRITYLEVEL        1077
#define IDC_TOKEN_UIACCESS              1078
#define IDC_TOKEN_APPCONTAINER          1079
#define ID_SLCACHELIST                  1080
#define IDC_TOKEN_AUTHID                1080
#define ID_TYPE_DESCRIPTION             1081
#define ID_SLCACHEINFO                  1081
#define ID_IMAGEINFO                    1082
#define ID_DEVICEINFO                   1082
#define ID_DRIVERINFO                   1082
#define ID_SLCACHELIST2                 1082
#define ID_SLDATALIST                   1082
#define IDC_SLVALUE                     1083
#define ID_IMAGE_STACKRESERVELABEL      1084
#define IDC_SLVALUE_VIEWWITH            1084
#define ID_IMAGE_STACKCOMMITLABEL       1085
#define ID_SLDESCRIPTOR_SIZE            1085
#define ID_IMAGE_EXECUTABLELABEL        1086
#define ID_SLDESCRIPTOR_DATALENGTH      1086
#define ID_IMAGE_SUBSYSLABEL            1087
#define ID_SLDESCRIPTOR_ATTRIBUTES      1087
#define ID_IMAGE_MJVLABEL               1088
#define ID_SLDESCRIPTOR_TYPE            1088
#define ID_IMAGE_MNVLABEL               1089
#define IDC_SLVALUE_NAME                1089
#define IDC_GLOBALS                     1089
#define ID_WINSTATIONVISIBLE            1090
#define IDC_SYSINFO                     1090
#define IDC_TOKEN_ADVANCED              1091
#define IDC_TOKEN_ADVANCED2             1092
#define IDC_TOKEN_LINKED                1092
#define ID_IMAGE_ENTRYLABEL             1093
#define IDC_TOKEN_ATTRLIST              1093
#define IDC_PLUGINLIST                  1094
#define IDC_SDVIEW_LIST                 1094
#define IDC_GLOBALS_CLOSE               1096
#define IDC_CANCEL                      1096
#define ID_PIPE_FULLPATH                1097
#define ID_PIPE_INBUFFER                1098
#define ID_PIPE_OUTBUFFER               1099
#define IDC_LOGLIST                     1099
#define ID_PIPE_TYPEMODE                1100
#define IDC_IMAGE_SERVICE_PROCES        1100
#define IDC_PCTL_SERVICE_PROCES         1100
#define ID_PIPE_ACCESSMODE              1101
#define IDC_IMAGE_PROTECTED_PROCESS     1101
#define IDC_PCTL_PROTECTED_PROCESS      1101
#define ID_PROCESSLIST                  1102
#define IDC_IMAGE_USER_PROCESS          1102
#define IDC_PCTL_USERPROCESS            1102
#define ID_PROCESSLISTNOALL             1103
#define ID_PIPE_WRITEQUOTAAVAIL         1103
#define IDC_PLUGIN_DESC                 1103
#define IDC_PLUGIN_FILENAME             1104
#define IDC_IMAGE_IMMERSIVE_PROCESS     1104
#define IDC_PCTL_IMMERSIVE_PROCESS      1104
#define IDC_PLUGIN_ADMIN                1105
#define ID_SEARCH_FIND                  1106
#define IDC_PLUGIN_OBJECTTYPE           1106
#define IDC_PLUGIN_DRIVER               1107
#define IDC_LIST                        1107
#define ID_SEARCH_NAME                  1108
#define IDC_PLUGIN_WINE                 1108
#define IDC_SDVIEW_OWNER                1108
#define ID_SEARCH_TYPE                  1109
#define IDC_PLUGIN_MINSTANCES           1109
#define ID_SEARCH_LIST                  1110
#define IDC_SDVIEW_STATUSBAR            1110
#define ID_ALPCLISTNOALL                1111
#define ID_ALPCLISTMSG                  1111
#define ID_SEARCH_GROUPBOX              1112
#define ID_ALPCLIST                     1112
#define ID_SEARCH_GROUPBOXOPTIONS       1113
#define ID_SEARCH_TYPELABEL             1114
#define IDC_EDIT1                       1115
#define IDC_SLSEARCH                    1115
#define IDC_SYSLINK1                    1116
#define IDC_ABOUT_SYSLINK               1116
#define IDC_STATS_TOTALHEAPALLOC        1117
#define IDC_STATS_TOTALHEAPFREE         1118
#define IDC_STATS_TOTALHEAPSCREATED     1119
#define IDC_STATS_TOTALHEAPSDESTROYED   1120
#define ID_DRIVERDISPLAYNAME            1121
#define IDC_STATS_TOTALTHREADSCREATED   1121
#define IDC_STATS_TOTALTHREADSCREATED2  1122
#define IDC_STATS_TOTALTHEAPMEMORYALLOCATED 1122
#define IDC_STATS_MAXHEAPALLOCATEDSIZE  1123
#define IDC_STATS_MAXHEAPALLOCATEDSIZE_STATIC 1124
#define IDC_PROGRESS                    1125
#define ID_SERVICE_TYPE                 1133
#define ID_SERVICE_START                1134
#define ID_SERVICE_ERROR                1135
#define ID_SERVICE_NAME                 1136
#define ID_SERVICE_CURRENT              1137
#define ID_SERVICE_DISPLAYNAME          1138
#define ID_SERVICE_IMAGEPATH            1139
#define ID_SERVICE_DESCRIPTION          1140
#define ID_SERVICE_DEPENDSONGROUP       1143
#define ID_SERVICE_LOADORDER            1144
#define ID_SERVICE_DEPENDSONSERVICE     1145
#define ID_SERVICE_DEPENDENTSERVICES    1146
#define ID_SERVICE_QUERYFAIL            1147
#define ID_SERVICE_TAG                  1148
#define ID_SERVICE_JUMPTOKEY            1149
#define ID_OBJECTDUMPERROR              1161
#define ID_OBJECDUMPHIDELABEL           1170
#define ID_PTL_CAPTION                  1234
#define ID_NAMESPACE_ROOT               1300
#define ID_NAMESPACE_ADDR               1301
#define ID_BDESCRIPTOR_ADDRESS          1302
#define ID_BDESCRIPTOR_NAME             1304
#define ID_BDESCRIPTOR_SID              1305
#define ID_BDESCRIPTOR_SID_ACCOUNT      1306
#define IDC_STATUS_TEXT                 1401
#define IDC_TIME_ELAPSED                1402
#define IDI_ICON_SORTUP                 6001
#define IDI_ICON_SORTDOWN               6002
#define ID_REGISTRYINFO                 7000
#define ID_REGISTRYDESC                 7001
#define ID_ABOUT_PROGRAM                11260
#define ID_ABOUT_BUILDDATE              11261
#define ID_ABOUT_OSNAME                 11262
#define ID_ABOUT_ADVINFO                11263
#define ID_ABOUT_OSNAME2                11264
#define ID_ABOUT_BUILDINFO              22011
#define ID_ABOUT_COMPILERINFO           22015
#define ID_FILE_EXIT                    40001
#define ID_FILE_RUNASADMIN              40002
#define ID_VIEW_REFRESH                 40003
#define ID_OBJECT_PROPERTIES            40004
#define ID_OBJECT_GOTOLINKTARGET        40005
#define ID_FIND_FINDOBJECT              40006
#define ID_HELP_ABOUT                   40007
#define ID_OBJECT_COPY                  40008
#define ID_ADDINFO_COPY                 40009
#define ID_HELP_HELP                    40016
#define ID_EXTRAS_PIPES                 40020
#define ID_EXTRAS_USERSHAREDDATA        40023
#define ID_EXTRAS_PRIVATENAMESPACES     40026
#define ID_EXTRAS_SSDT                  40030
#define ID_EXTRAS_DRIVERS               40033
#define ID_EXTRAS_MAILSLOTS             40036
#define ID_EXTRAS_W32PSERVICETABLE      40039
#define ID_EXTRAS_PROCESSLIST           40042
#define ID_EXTRAS_CALLBACKS             40043
#define ID_EXTRAS_SOFTWARELICENSECACHE  40044
#define ID_EXTRASCAPTION                40045
#define ID_OBJECTDUMPGROUPBOX           40046
#define ID_USDDUMPGROUPBOX              40047
#define ID_OBJECT_ICON                  40048
#define ID_HELP_SHOWLOG                 40049
#define ID_FILE_VIEW_PLUGINS            40050
#define ID_VIEW_DISPLAYGRID             40051
#define ID_VIEW_SECURITYDESCRIPTOR      40052
#define ID_JUMPTOFILE                   40053
#define ID_EXTRAS_UNLOADEDDRIVERS       40054
#define ID_EXTRAS_CMCONTROLVECTOR       40055
#define ID_VIEW_SYSINFO                 40057
#define ID_HELP_STATISTICS              40059
#define ID_OBJECT_COPY_NAME             40060
#define ID_OBJECT_COPY_NAME_BINARY      40061
#define ID_VIEW_LEGEND                  40062

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        279
#define _APS_NEXT_COMMAND_VALUE         40063
#define _APS_NEXT_CONTROL_VALUE         1400
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/WinObjEx64/rsrc/obex.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
    <assemblyIdentity 
        type="win32" 
        name="WinObjEx64"
        version="1.0.0.0"
        processorArchitecture="*"
    />
    <description> WinObjEx64 </description>
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel
                    level="asInvoker"
                    uiAccess="false"
                />	
            </requestedPrivileges>
        </security>
    </trustInfo>
    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
        <application> 
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
            <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
        </application> 
    </compatibility>

  <dependency>
    <dependentAssembly>
      <assemblyIdentity                 
        type="win32"
        name="Microsoft.Windows.Common-Controls"
        version="6.0.0.0"
        publicKeyToken="6595b64144ccf1df"
        language="*"
        processorArchitecture="*"
        />
    </dependentAssembly>
  </dependency>

</assembly>
```

`Source/WinObjEx64/sdviewDlg.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       SDVIEWDLG.C
*
*  VERSION:     2.09
*
*  DATE:        22 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

#define SDVIEWDLG_TRACKSIZE_MIN_X 480
#define SDVIEWDLG_TRACKSIZE_MIN_Y 320

HWND SDViewDialogWindow = NULL;
static HANDLE SDViewDialogThreadHandle = NULL;
static FAST_EVENT SDViewDialogInitializedEvent = FAST_EVENT_INIT;
static FAST_EVENT SDViewDialogFinalizedEvent;

//
// SDView Dialog context structure.
//

typedef struct _SDVIEW_CONTEXT {
    //
    // Dialog controls and resources.
    //
    HWND DialogWindow;
    HWND StatusBar;
    HWND AceList;
    HICON DialogIcon;

    //
    // Viewed object data.
    //
    WOBJ_OBJECT_TYPE Type;
    UNICODE_STRING NtObjectDirectory;
    UNICODE_STRING NtObjectName;

    //
    // ListView selection.
    //
    INT iSelectedItem;
    INT iColumnHit;

    //
    // Window controls layout.
    //
    RECT WindowRect;
    RECT ListRect;
} SDVIEW_CONTEXT, * PSDVIEW_CONTEXT;

//
// Ace list dump callback data structure.
//

typedef struct _ACE_DUMP_ENTRY {
    _In_ LPWSTR lpAceType;
    _In_ LPWSTR lpAceFlags;
    _In_ LPWSTR lpAccessMask;
    _In_opt_ LPWSTR lpDomain;
    _In_opt_ LPWSTR lpName;
    _In_ LPWSTR lpSidNameUse;
    _In_ PUNICODE_STRING SidString;
} ACE_DUMP_ENTRY, * PACE_DUMP_ENTRY;

typedef VOID(CALLBACK* pfnSidOutputCallback)(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ LPWSTR Information,
    _In_opt_ PVOID CallbackContext
    );

typedef VOID(CALLBACK* pfnAceOutputCallback)(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ PACE_DUMP_ENTRY Entry,
    _In_opt_ PVOID CallbackContext
    );

/*
* FreeSDViewContext
*
* Purpose:
*
* Free memory allocated for per-dialog context structure.
*
*/
VOID FreeSDViewContext(
    _In_ SDVIEW_CONTEXT* Context
)
{
    supFreeDuplicatedUnicodeString(g_obexHeap, &Context->NtObjectDirectory, FALSE);
    supFreeDuplicatedUnicodeString(g_obexHeap, &Context->NtObjectName, FALSE);

    supHeapFree(Context);
}

/*
* AllocateSDViewContext
*
* Purpose:
*
* Allocate memory for per-dialog context structure and fill it.
*
*/
SDVIEW_CONTEXT* AllocateSDViewContext(
    _In_ WOBJ_OBJECT_TYPE ObjectType
)
{
    SDVIEW_CONTEXT* ctx;

    ctx = (SDVIEW_CONTEXT*)supHeapAlloc(sizeof(SDVIEW_CONTEXT));
    if (ctx == NULL)
        return NULL;

    ctx->Type = ObjectType;
 
    if (!supGetCurrentObjectPath(FALSE, &ctx->NtObjectDirectory)) {
        supHeapFree(ctx);
        return NULL;
    }

    if (!supGetCurrentObjectName(&ctx->NtObjectName)) {
        supFreeDuplicatedUnicodeString(g_obexHeap, &ctx->NtObjectDirectory, FALSE);
        supHeapFree(ctx);
        return NULL;
    }

    return ctx;
}

/*
* OutputSidCallback
*
* Purpose:
*
* Output SID information callback.
*
*/
VOID CALLBACK OutputSidCallback(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ LPWSTR SidInformation,
    _In_opt_ PVOID CallbackContext
)
{
    UNREFERENCED_PARAMETER(CallbackContext);

    SetDlgItemText(Context->DialogWindow, IDC_SDVIEW_OWNER, SidInformation);
}

/*
* OutputAclEntryCallback
*
* Purpose:
*
* Output ACL entry information callback.
*
*/
VOID CALLBACK OutputAclEntryCallback(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ PACE_DUMP_ENTRY Entry,
    _In_ PVOID CallbackContext
)
{
    INT lvItemIndex;
    HWND hwndList = Context->AceList;

    LVITEM lvItem;
    WCHAR szBuffer[1040];


    RtlSecureZeroMemory(&lvItem, sizeof(lvItem));

    //
    // Ace type.
    //
    lvItem.mask = LVIF_TEXT | LVIF_GROUPID;
    lvItem.iItem = MAXINT;
    lvItem.iImage = I_IMAGENONE;
    lvItem.iGroupId = PtrToInt(CallbackContext);
    lvItem.pszText = Entry->lpAceType;
    lvItem.cchTextMax = (INT)_strlen(lvItem.pszText);
    lvItemIndex = ListView_InsertItem(hwndList, &lvItem);
    if (lvItemIndex == -1)
        return;

    lvItem.mask = LVIF_TEXT;

    //
    // Ace flags.
    //
    lvItem.pszText = Entry->lpAceFlags;
    lvItem.cchTextMax = (INT)_strlen(lvItem.pszText);
    lvItem.iItem = lvItemIndex;
    ++lvItem.iSubItem;
    ListView_SetItem(hwndList, &lvItem);

    //
    // Acess mask.
    //
    lvItem.pszText = Entry->lpAccessMask;
    lvItem.cchTextMax = (INT)_strlen(lvItem.pszText);
    ++lvItem.iSubItem;
    ListView_SetItem(hwndList, &lvItem);

    //
    // SID.
    //
    RtlStringCchPrintfSecure(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        L"%wZ",
        Entry->SidString);

    lvItem.pszText = szBuffer;
    lvItem.cchTextMax = (INT)_strlen(szBuffer);
    ++lvItem.iSubItem;
    ListView_SetItem(hwndList, &lvItem);

    //
    // Domain and Name
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    if (Entry->lpDomain) {
        _strcpy(szBuffer, Entry->lpDomain);
        if (Entry->lpName) {
            _strcat(szBuffer, TEXT("\\"));
            _strcat(szBuffer, Entry->lpName);
        }
    }
    else {
        if (Entry->lpName)
            _strcpy(szBuffer, Entry->lpName);
        else
            _strcpy(szBuffer, T_NotAssigned);
    }

    lvItem.pszText = szBuffer;
    lvItem.cchTextMax = (INT)_strlen(szBuffer);
    ++lvItem.iSubItem;
    ListView_SetItem(hwndList, &lvItem);

    //
    // Alias.
    //
    lvItem.pszText = Entry->lpSidNameUse;
    lvItem.cchTextMax = (INT)_strlen(lvItem.pszText);
    ++lvItem.iSubItem;
    ListView_SetItem(hwndList, &lvItem);
}

/*
* SDViewUpdateStatusBar
*
* Purpose:
*
* Set dialog status bar text.
*
*/
VOID SDViewUpdateStatusBar(
    _In_ SDVIEW_CONTEXT* Context,
    ULONG DaclCount,
    ULONG SaclCount
)
{
    WCHAR szBuffer[100];

    RtlStringCchPrintfSecure(szBuffer,
        RTL_NUMBER_OF(szBuffer),
        L"DACL Entries: %lu, SACL Entries: %lu",
        DaclCount,
        SaclCount);

    supStatusBarSetText(Context->StatusBar, 0, szBuffer);
}

/*
* SDViewDumpAceList
*
* Purpose:
*
* Output ACE list members.
*
*/
ULONG SDViewDumpAceList(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ ULONG AceCount,
    _In_ PVOID FirstAce,
    _In_ LSA_HANDLE PolicyHandle,
    _In_ pfnAceOutputCallback OutputCallback,
    _In_ PVOID CallbackContext
)
{
    ULONG domainIndex, nCount, domainsEntries = 0, totalEntries = 0;
    NTSTATUS ntStatus;
    BOOL bDomainNamePresent = FALSE, bNamePresent = FALSE;

    PLSA_TRANSLATED_NAME translatedNames = NULL, pNames = NULL;
    PLSA_REFERENCED_DOMAIN_LIST referencedDomains = NULL;
    PUNICODE_STRING pusDomainName, pusName;
    PSID* lookupSids;
    PSID aceSid;
    ULONG sidCount = 0;
    ACCESS_MASK accessMask;

    UNICODE_STRING stringSid, usEmpty;

    SID_NAME_USE sidNameUse;

    WCHAR szDomain[512], szName[512];
    WCHAR szAccessMask[32], szAceType[32], szAceFlags[32];
    LPWSTR lpAceType;

    ACE_DUMP_ENTRY dumpData;

    union {
        PBYTE ListRef;
        PACE_HEADER Header;
        PACCESS_ALLOWED_ACE AccessAllowed;
    } aceList;

    aceList.ListRef = (PBYTE)FirstAce;

    //
    // Allocate array of sids for LsaLookupSids.
    //
    lookupSids = (PSID*)supHeapAlloc(AceCount * sizeof(PSID));
    if (lookupSids == NULL)
        return 0;

    __try {

        //
        // Fill sids array for LsaLookupSids.
        //
        nCount = AceCount;

        do {

            aceSid = supGetSidFromAce(aceList.Header);

            if (RtlValidSid(aceSid)) {
                lookupSids[sidCount++] = aceSid;
            }

            aceList.ListRef += aceList.Header->AceSize;

        } while (--nCount);

        //
        // Lookup sids.
        //
        ntStatus = LsaLookupSids(PolicyHandle,
            sidCount,
            lookupSids,
            &referencedDomains,
            &translatedNames);

        if (NT_SUCCESS(ntStatus)) {

            pNames = translatedNames;
            domainsEntries = referencedDomains->Entries;

        }

        aceList.ListRef = (PBYTE)FirstAce;
        nCount = AceCount;

        RtlInitEmptyUnicodeString(&stringSid, NULL, 0);
        RtlInitEmptyUnicodeString(&usEmpty, NULL, 0);

        //
        // List aces.
        //

        do {

            aceSid = supGetSidFromAce(aceList.Header);
            if (!RtlValidSid(aceSid)) {
                continue;
            }

            //
            // Convert SID to string, on failure zero result so RtlFreeUnicodeString won't fuckup.
            //
            if (!NT_SUCCESS(RtlConvertSidToUnicodeString(&stringSid,
                aceSid,
                TRUE)))
            {
                stringSid.Buffer = NULL;
                stringSid.Length = 0;
            }

            sidNameUse = SidTypeUnknown;
            pusDomainName = &usEmpty;
            pusName = &usEmpty;

            //
            // Link domain, name and sid name use.
            //

            if (pNames) {

                domainIndex = pNames->DomainIndex;
                if (domainIndex < domainsEntries)
                    pusDomainName = &referencedDomains->Domains[domainIndex].Name;

                pusName = &pNames->Name;
                sidNameUse = pNames->Use;
                pNames++;

            }

            bDomainNamePresent = (pusDomainName->Length > 0);
            bNamePresent = (pusName->Length > 0);

            accessMask = aceList.AccessAllowed->Mask;

            szAccessMask[0] = L'0';
            szAccessMask[1] = L'x';
            szAccessMask[2] = 0;
            ultohex((ULONG)accessMask, &szAccessMask[2]);

            szAceFlags[0] = L'0';
            szAceFlags[1] = L'x';
            szAceFlags[2] = 0;
            ultohex((ULONG)aceList.Header->AceFlags, &szAceFlags[2]);

            switch (aceList.Header->AceType) {

            case ACCESS_ALLOWED_ACE_TYPE:
                lpAceType = L"AccessAllowed";
                break;

            case ACCESS_DENIED_ACE_TYPE:
                lpAceType = L"AccessDenied";
                break;

            case SYSTEM_MANDATORY_LABEL_ACE_TYPE:
                lpAceType = L"Mandatory";
                szAccessMask[0] = accessMask & SYSTEM_MANDATORY_LABEL_NO_READ_UP ? L'R' : L'-';
                szAccessMask[1] = accessMask & SYSTEM_MANDATORY_LABEL_NO_WRITE_UP ? L'W' : L'-';
                szAccessMask[2] = accessMask & SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP ? L'E' : L'-';
                szAccessMask[3] = 0;
                break;

            case SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE:
                lpAceType = L"TrustLabel";
                break;

            case SYSTEM_ACCESS_FILTER_ACE_TYPE:
                lpAceType = L"AccessFilter";
                break;

            default:
                //
                // Irrelevant, report as is.
                //
                szAceType[0] = L'0';
                szAceType[1] = L'x';
                szAceType[2] = 0;
                ultohex((ULONG)aceList.Header->AceType, &szAceType[2]);
                lpAceType = (LPWSTR)&szAceType;
                break;
            }

            //
            // Domain and name.
            //
            RtlSecureZeroMemory(&szDomain, sizeof(szDomain));
            szDomain[0] = 0;
            RtlSecureZeroMemory(&szName, sizeof(szName));
            szName[0] = 0;

            switch (sidNameUse) {
            case SidTypeInvalid:
            case SidTypeUnknown:
                //
                // Invalid or unknown, skip domain and name.
                //
                break;

            default:

                if (bNamePresent) {

                    RtlStringCchPrintfSecure(szName,
                        RTL_NUMBER_OF(szName),
                        L"%wZ",
                        pusName);

                }

                if (bDomainNamePresent) {

                    RtlStringCchPrintfSecure(szDomain,
                        RTL_NUMBER_OF(szDomain),
                        L"%wZ",
                        pusDomainName);

                }

                break;
            }

            dumpData.lpAccessMask = szAccessMask;
            dumpData.lpAceFlags = szAceFlags;
            dumpData.lpAceType = lpAceType;
            dumpData.lpDomain = bDomainNamePresent ? szDomain : NULL;
            dumpData.lpName = bNamePresent ? szName : NULL;
            dumpData.lpSidNameUse = supGetSidNameUse(sidNameUse);
            dumpData.SidString = &stringSid;

            OutputCallback(Context, &dumpData, CallbackContext);
            totalEntries++;

            RtlFreeUnicodeString(&stringSid);

        } while (aceList.ListRef += aceList.Header->AceSize, --nCount);

    }
    __finally {
        supHeapFree(lookupSids);
        if (referencedDomains) LsaFreeMemory(referencedDomains);
        if (translatedNames) LsaFreeMemory(translatedNames);
    }

    return totalEntries;
}

/*
* SDViewDumpAcl
*
* Purpose:
*
* Output ACL information.
*
*/
ULONG SDViewDumpAcl(
    _In_ SDVIEW_CONTEXT* Context,
    _In_opt_ PACL Acl,
    _In_ LSA_HANDLE PolicyHandle,
    _In_ pfnAceOutputCallback OutputCallback,
    _In_ PVOID CallbackContext
)
{
    PVOID firstAce = NULL;

    if (Acl == NULL) {
        return 0;
    }

    if (Acl->AceCount == 0) {
        return 0;
    }

    if (NT_SUCCESS(RtlGetAce(Acl, 0, &firstAce))) {

        return SDViewDumpAceList(Context,
            Acl->AceCount,
            firstAce,
            PolicyHandle,
            OutputCallback,
            CallbackContext);

    }

    return 0;
}

/*
* SDViewDumpSid
*
* Purpose:
*
* Output SID information.
*
*/
VOID SDViewDumpSid(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ PSID Sid,
    _In_ LSA_HANDLE PolicyHandle,
    _In_ pfnSidOutputCallback OutputCallback,
    _In_opt_ PVOID CallbackContext
)
{
    ULONG domainIndex, domainsEntries;
    NTSTATUS ntStatus;
    PLSA_TRANSLATED_NAME translatedNames = NULL, pNames;
    PLSA_REFERENCED_DOMAIN_LIST referencedDomains = NULL;
    PUNICODE_STRING pusDomainName, pusName;
    LPWSTR pSidNameUseString = NULL;

    UNICODE_STRING stringSid, usEmpty;

    SID_NAME_USE sidNameUse;

    WCHAR szBuffer[1024];

    //
    // Do we have anything to show?
    //
    if (!RtlValidSid(Sid))
        return;

    __try {

        pNames = NULL;
        domainsEntries = 0;

        ntStatus = LsaLookupSids(PolicyHandle,
            1,
            &Sid,
            &referencedDomains,
            &translatedNames);

        if (NT_SUCCESS(ntStatus)) {
            pNames = translatedNames;
            domainsEntries = referencedDomains->Entries;
        }

        RtlInitEmptyUnicodeString(&stringSid, NULL, 0);
        RtlInitEmptyUnicodeString(&usEmpty, NULL, 0);

        //
        // Convert SID to string, on failure zero result so RtlFreeUnicodeString won't fuckup.
        //
        if (!NT_SUCCESS(RtlConvertSidToUnicodeString(&stringSid,
            Sid,
            TRUE)))
        {
            stringSid.Buffer = NULL;
            stringSid.Length = 0;
        }

        sidNameUse = SidTypeUnknown;
        pusDomainName = &usEmpty;
        pusName = &usEmpty;

        //
        // Link domain, name and sid name use.
        //
        if (pNames) {

            domainIndex = pNames->DomainIndex;
            if (domainIndex < domainsEntries)
                pusDomainName = &referencedDomains->Domains[domainIndex].Name;

            pusName = &pNames->Name;
            sidNameUse = pNames->Use;
            pNames++;

        }

        RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
        pSidNameUseString = supGetSidNameUse(sidNameUse);

        //
        // Dump sid name use.
        //
        switch (sidNameUse) {
        case SidTypeInvalid:
        case SidTypeUnknown:

            RtlStringCchPrintfSecure(szBuffer,
                RTL_NUMBER_OF(szBuffer),
                TEXT("[%wZ] [%wS]"),
                &stringSid,
                pSidNameUseString);

            break;

        default:

            RtlStringCchPrintfSecure(szBuffer,
                RTL_NUMBER_OF(szBuffer),
                TEXT("[%wZ] '%wZ\\%wZ' [%wS]"),
                &stringSid,
                pusDomainName,
                pusName,
                pSidNameUseString);

            break;
        }

        RtlFreeUnicodeString(&stringSid);
        OutputCallback(Context, szBuffer, CallbackContext);

    }
    __finally {
        if (referencedDomains) LsaFreeMemory(referencedDomains);
        if (translatedNames) LsaFreeMemory(translatedNames);
    }
}

/*
* SDViewDumpObjectSecurity
*
* Purpose:
*
* Dump object security information (dacl, sacl, sid).
*
*/
NTSTATUS SDViewDumpObjectSecurity(
    _In_ SDVIEW_CONTEXT* Context
)
{
    NTSTATUS ntStatus, ntQueryStatus;
    ULONG daclCount = 0, saclCount = 0;
    HANDLE hObject = NULL;
    LSA_HANDLE hPolicy = NULL;
    LSA_OBJECT_ATTRIBUTES lsaOa;

    PACL pAcl;
    PSID pOwnerSid;
    PSECURITY_DESCRIPTOR pSD = NULL;

    BOOLEAN bDefaulted = FALSE, bPresent = FALSE;

    __try {

        ntStatus = supOpenNamedObjectByType(&hObject,
            Context->Type,
            &Context->NtObjectDirectory,
            &Context->NtObjectName,
            READ_CONTROL);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        InitializeObjectAttributes((OBJECT_ATTRIBUTES*)&lsaOa, NULL, 0, 0, NULL);

        ntStatus = LsaOpenPolicy(NULL, &lsaOa, POLICY_LOOKUP_NAMES, &hPolicy);
        if (!NT_SUCCESS(ntStatus))
            __leave;

        ntStatus = supQuerySecurityInformation(
            hObject,
            OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
            LABEL_SECURITY_INFORMATION | PROCESS_TRUST_LABEL_SECURITY_INFORMATION,
            &pSD,
            NULL);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        pOwnerSid = NULL;
        ntQueryStatus = RtlGetOwnerSecurityDescriptor(pSD, &pOwnerSid, &bDefaulted);
        if (NT_SUCCESS(ntQueryStatus)) {

            SDViewDumpSid(Context, pOwnerSid, hPolicy,
                &OutputSidCallback, NULL);

        }

        pAcl = NULL;
        ntQueryStatus = RtlGetDaclSecurityDescriptor(pSD, &bPresent, &pAcl, &bDefaulted);
        if (NT_SUCCESS(ntQueryStatus)) {

            daclCount = SDViewDumpAcl(Context, pAcl, hPolicy,
                &OutputAclEntryCallback, IntToPtr(0));

        }

        pAcl = NULL;
        ntQueryStatus = RtlGetSaclSecurityDescriptor(pSD, &bPresent, &pAcl, &bDefaulted);
        if (NT_SUCCESS(ntQueryStatus)) {

            saclCount = SDViewDumpAcl(Context, pAcl, hPolicy,
                &OutputAclEntryCallback, IntToPtr(1));

        }

        SDViewUpdateStatusBar(Context, daclCount, saclCount);

    }
    __finally {
        if (pSD) supHeapFree(pSD);
        if (hPolicy) LsaClose(hPolicy);
        if (hObject) NtClose(hObject);
    }

    return ntStatus;
}

/*
* SDViewInitControls
*
* Purpose:
*
* Initialize controls.
*
*/
VOID SDViewInitControls(
    _In_ HWND hwndDlg,
    _In_ SDVIEW_CONTEXT* Context
)
{
    LVGROUP lvg;
    LVCOLUMNS_DATA columnData[] =
    {
        { L"AceType", 80, LVCFMT_CENTER, I_IMAGENONE },
        { L"AceFlags", 80, LVCFMT_CENTER, I_IMAGENONE },
        { L"AccessMask", 120, LVCFMT_CENTER, I_IMAGENONE },
        { L"SID", 120, LVCFMT_LEFT, I_IMAGENONE },
        { L"Domain\\Name", 200, LVCFMT_LEFT, I_IMAGENONE },
        { L"UseName", 120, LVCFMT_LEFT, I_IMAGENONE }
    };

    struct LVGroups {
        LPWSTR Name;
        INT Id;
    } groupData[] = {
        { L"ACL", 0 },
        { L"SACL", 1 }
    };

    INT i;
    HWND aclList = GetDlgItem(hwndDlg, IDC_SDVIEW_LIST);
    HWND sidOwner = GetDlgItem(hwndDlg, IDC_SDVIEW_OWNER);

    UNICODE_STRING objectName, normalizedName;
    LPWSTR caption;
    ULONG captionLength;

    //
    // Set listview style flags and theme.
    //
    supSetListViewSettings(aclList,
        LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER | LVS_EX_LABELTIP,
        FALSE,
        TRUE,
        NULL,
        0);

    SendMessage(aclList, LVM_ENABLEGROUPVIEW, 1, 0);

    //
    // Add listview columns.
    //
    supAddLVColumnsFromArray(
        aclList,
        columnData,
        RTL_NUMBER_OF(columnData));

    RtlSecureZeroMemory(&lvg, sizeof(lvg));
    lvg.cbSize = sizeof(LVGROUP);
    lvg.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID;
    lvg.uAlign = LVGA_HEADER_LEFT;

    for (i = 0; i < RTL_NUMBER_OF(groupData); i++) {
        lvg.pszHeader = groupData[i].Name;
        lvg.cchHeader = (INT)_strlen(lvg.pszHeader);
        lvg.iGroupId = groupData[i].Id;
        SendMessage(aclList, LVM_INSERTGROUP, (WPARAM)i, (LPARAM)&lvg);
    }

    SetWindowText(sidOwner, T_EmptyString);

    GetClientRect(hwndDlg, &Context->WindowRect);
    GetWindowRect(aclList, &Context->ListRect);

    //
    // Set dialog caption.
    //
    if (supCreateObjectPathFromElements(&Context->NtObjectName,
        &Context->NtObjectDirectory,
        &objectName,
        TRUE))
    {
        if (supNormalizeUnicodeStringForDisplay(g_obexHeap, &objectName, &normalizedName)) {

            captionLength = normalizedName.Length + MAX_PATH;
            caption = (LPWSTR)supHeapAlloc(captionLength);
            if (caption) {

                RtlStringCchPrintfSecure(caption,
                    captionLength / sizeof(WCHAR),
                    TEXT("Security Descriptor: %ws"),
                    normalizedName.Buffer);

                SetWindowText(hwndDlg, caption);

                supHeapFree(caption);
            }
            supFreeUnicodeString(g_obexHeap, &normalizedName);
        }

        supFreeUnicodeString(g_obexHeap, &objectName);
    }
}

/*
* SdViewHandlePopup
*
* Purpose:
*
* List popup construction.
*
*/
VOID SDViewHandlePopup(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_ PVOID lpUserParam
)
{
    HMENU hMenu;
    SDVIEW_CONTEXT* Context = (SDVIEW_CONTEXT*)lpUserParam;
    HWND hwndList = GetDlgItem(hwndDlg, IDC_SDVIEW_LIST);

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supListViewAddCopyValueItem(hMenu,
            hwndList,
            ID_OBJECT_COPY,
            0,
            lpPoint,
            &Context->iSelectedItem,
            &Context->iColumnHit))
        {
            TrackPopupMenu(hMenu,
                TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                lpPoint->x,
                lpPoint->y,
                0,
                hwndDlg,
                NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* SDViewOnResize
*
* Purpose:
*
* WM_SIZE handler.
*
*/
VOID SDViewOnResize(
    _In_ SDVIEW_CONTEXT* Context,
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    HWND hwndList = GetDlgItem(hwndDlg, IDC_SDVIEW_LIST);
    WORD dlgWidth = LOWORD(lParam), dlgHeight = HIWORD(lParam);

    INT dx, dy;

    dx = Context->WindowRect.right - Context->ListRect.right;
    dy = Context->WindowRect.bottom - Context->ListRect.bottom;

    SetWindowPos(hwndList, NULL, 0, 0,
        dlgWidth - dx - Context->ListRect.left,
        dlgHeight - dy - Context->ListRect.top,
        SWP_NOMOVE);

    SendMessage(Context->StatusBar, WM_SIZE, 0, 0);
    RedrawWindow(hwndDlg, NULL, 0, RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW);
}

/*
* SDViewDialogOnInit
*
* Purpose:
*
* WM_INITDIALOG handler.
*
*/
VOID SDViewDialogOnInit(
    _In_ HWND hwndDlg,
    _In_ LPARAM lParam
)
{
    NTSTATUS ntStatus;
    HICON hIcon;
    LPWSTR lpText;
    SDVIEW_CONTEXT* dlgContext;
    ENUMCHILDWNDDATA wndData;

    SDViewDialogWindow = hwndDlg;
    supCenterWindowSpecifyParent(hwndDlg, g_hwndMain);
    dlgContext = (SDVIEW_CONTEXT*)lParam;
    SetProp(hwndDlg, T_DLGCONTEXT, (HANDLE)lParam);

    dlgContext->DialogWindow = hwndDlg;
    dlgContext->AceList = GetDlgItem(hwndDlg, IDC_SDVIEW_LIST);
    dlgContext->StatusBar = GetDlgItem(hwndDlg, IDC_SDVIEW_STATUSBAR);

    //
    // Set dialog icon.
    //
    hIcon = (HICON)LoadImage(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDI_ICON_MAIN),
        IMAGE_ICON,
        32, 32,
        0);

    if (hIcon) {
        SendMessage(hwndDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hwndDlg, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)hIcon);
        dlgContext->DialogIcon = hIcon;
    }

    SDViewInitControls(hwndDlg, dlgContext);

    //
    // Dump object security information.
    //
    ntStatus = SDViewDumpObjectSecurity(dlgContext);
    if (NT_SUCCESS(ntStatus)) {
        SetFocus(dlgContext->AceList);
    }
    else {
        //
        // On error - hide all child windows and show details of the error.
        //
        if (GetWindowRect(hwndDlg, &wndData.Rect)) {
            wndData.nCmdShow = SW_HIDE;
            EnumChildWindows(hwndDlg, supCallbackShowChildWindow, (LPARAM)&wndData);
        }
        ShowWindow(GetDlgItem(hwndDlg, ID_OBJECTDUMPERROR), SW_SHOW);
        lpText = supFormatNtError(ntStatus);
        if (lpText) {
            SetDlgItemText(hwndDlg, ID_OBJECTDUMPERROR, lpText);
            LocalFree((HLOCAL)lpText);
        }
    }

}

/*
* SDViewDialogProc
*
* Purpose:
*
* View Security Descriptor Dialog Window Procedure
*
* During WM_INITDIALOG centers window and initializes security descriptor info
*
*/
INT_PTR CALLBACK SDViewDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    SDVIEW_CONTEXT* dlgContext;

    switch (uMsg) {

    case WM_INITDIALOG:
        SDViewDialogOnInit(hwndDlg, lParam);
        break;

    case WM_CONTEXTMENU:

        dlgContext = (SDVIEW_CONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (dlgContext) {

            supHandleContextMenuMsgForListView(hwndDlg,
                wParam,
                lParam,
                dlgContext->AceList,
                (pfnPopupMenuHandler)SDViewHandlePopup,
                (PVOID)dlgContext);

        }
        break;

    case WM_SIZE:
        dlgContext = (SDVIEW_CONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
        if (dlgContext) {
            SDViewOnResize(dlgContext, hwndDlg, lParam);
        }
        break;

    case WM_DESTROY:
        SDViewDialogWindow = NULL;
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        dlgContext = (SDVIEW_CONTEXT*)RemoveProp(hwndDlg, T_DLGCONTEXT);
        if (dlgContext) {
            if (dlgContext->DialogIcon)
                DestroyIcon(dlgContext->DialogIcon);

            FreeSDViewContext(dlgContext);
        }
        return DestroyWindow(hwndDlg);

    case WM_GETMINMAXINFO:
        if (lParam) {
            supSetMinMaxTrackSize((PMINMAXINFO)lParam,
                SDVIEWDLG_TRACKSIZE_MIN_X,
                SDVIEWDLG_TRACKSIZE_MIN_Y,
                TRUE);
        }
        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            break;

        case ID_OBJECT_COPY:
            dlgContext = (SDVIEW_CONTEXT*)GetProp(hwndDlg, T_DLGCONTEXT);
            if (dlgContext) {
                supListViewCopyItemValueToClipboard(dlgContext->AceList,
                    dlgContext->iSelectedItem,
                    dlgContext->iColumnHit);
            }
            break;

        }
    default:
        return FALSE;
    }

    return TRUE;
}

/*
* SDViewDialogWorkerThread
*
* Purpose:
*
* Create and initialize ViewSecurityDescriptor Dialog.
*
*/
DWORD SDViewDialogWorkerThread(
    _In_ PVOID Parameter
)
{
    BOOL bResult;
    MSG message;
    HWND hwnd;
    SDVIEW_CONTEXT* context = (SDVIEW_CONTEXT*)Parameter;

    hwnd = CreateDialogParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_SDVIEW),
        0,
        (DLGPROC)&SDViewDialogProc,
        (LPARAM)context);

    supSetFastEvent(&SDViewDialogInitializedEvent);

    do {

        bResult = GetMessage(&message, NULL, 0, 0);
        if (bResult == -1)
            break;

        if (!IsDialogMessage(hwnd, &message)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }

    } while (bResult != 0);

    supResetFastEvent(&SDViewDialogInitializedEvent);

    if (SDViewDialogThreadHandle) {
        NtClose(SDViewDialogThreadHandle);
        SDViewDialogThreadHandle = NULL;
    }

    supSetFastEvent(&SDViewDialogFinalizedEvent);

    return 0;
}

/*
* SDViewDialogCreate
*
* Purpose:
*
* Create dialog worker thread.
*
*/
VOID SDViewDialogCreate(
    _In_ WOBJ_OBJECT_TYPE ObjectType
)
{
    SDVIEW_CONTEXT* context;

    if (SDViewDialogThreadHandle) {
        PostMessage(SDViewDialogWindow, WM_CLOSE, 0, 0);
        supWaitForFastEvent(&SDViewDialogFinalizedEvent, NULL);
    }

    context = AllocateSDViewContext(ObjectType);
    if (context) {
        supInitFastEvent(&SDViewDialogFinalizedEvent);
        SDViewDialogThreadHandle = supCreateDialogWorkerThread(SDViewDialogWorkerThread, context, 0);
        if (SDViewDialogThreadHandle == NULL) {
            FreeSDViewContext(context);
            return;
        }
        supWaitForFastEvent(&SDViewDialogInitializedEvent, NULL);
    }
}

```

`Source/WinObjEx64/sup/sup.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       SUP.C
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "treelist/treelist.h"

#ifndef OBEX_DEFINE_GUID
#define OBEX_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
     EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }  
#endif

OBEX_DEFINE_GUID(ShimDriverScope, 0xBC04AB45, 0xEA7E, 0x4A11, 0xA7, 0xBB, 0x97, 0x76, 0x15, 0xF4, 0xCA, 0xAE);
OBEX_DEFINE_GUID(ShimVersionLie1, 0x3E28B2D1, 0xE633, 0x408C, 0x8E, 0x9B, 0x2A, 0xFA, 0x6F, 0x47, 0xFC, 0xC3);
OBEX_DEFINE_GUID(ShimVersionLie2, 0x47712F55, 0xBD93, 0x43FC, 0x92, 0x48, 0xB9, 0xA8, 0x37, 0x10, 0x06, 0x6E);
OBEX_DEFINE_GUID(ShimVersionLie3, 0x21C4FB58, 0xD477, 0x4839, 0xA7, 0xEA, 0xAD, 0x69, 0x18, 0xFB, 0xC5, 0x18);
OBEX_DEFINE_GUID(ShimSkipDriverUnload, 0x3E8C2CA6, 0x34E2, 0x4DE6, 0x8A, 0x1E, 0x96, 0x92, 0xDD, 0x3E, 0x31, 0x6B);
OBEX_DEFINE_GUID(ShimZeroPool, 0x6B847429, 0xC430, 0x4682, 0xB5, 0x5F, 0xFD, 0x11, 0xA7, 0xB5, 0x54, 0x65);
OBEX_DEFINE_GUID(ShimClearPCIDBits, 0xB4678DFF, 0xBD3E, 0x46C9, 0x92, 0x3B, 0xB5, 0x73, 0x34, 0x83, 0xB0, 0xB3);
OBEX_DEFINE_GUID(ShimKaspersky, 0xB4678DFF, 0xCC3E, 0x46C9, 0x92, 0x3B, 0xB5, 0x73, 0x34, 0x83, 0xB0, 0xB3);
OBEX_DEFINE_GUID(ShimMemcpy, 0x8A2517C1, 0x35D6, 0x4CA8, 0x9E, 0xC8, 0x98, 0xA1, 0x27, 0x62, 0x89, 0x1B);
OBEX_DEFINE_GUID(ShimKernelPadSectionsOverride, 0x4F55C0DB, 0x73D3, 0x43F2, 0x97, 0x23, 0x8A, 0x9C, 0x7F, 0x79, 0xD3, 0x9D);
OBEX_DEFINE_GUID(ShimNdisVersionLie, 0x49691313, 0x1362, 0x4E75, 0x8C, 0x2A, 0x2D, 0xD7, 0x29, 0x28, 0xEB, 0xA5);
OBEX_DEFINE_GUID(ShimSrb, 0x434ABAFD, 0x08FA, 0x4C3D, 0xA8, 0x8D, 0xD0, 0x9A, 0x88, 0xE2, 0xAB, 0x17);
OBEX_DEFINE_GUID(ShimDeviceId, 0x0332EC62, 0x865A, 0x4A39, 0xB4, 0x8F, 0xCD, 0xA6, 0xE8, 0x55, 0xF4, 0x23);
OBEX_DEFINE_GUID(ShimATADeviceId, 0x26665D57, 0x2158, 0x4E4B, 0xA9, 0x59, 0xC9, 0x17, 0xD0, 0x3A, 0x0D, 0x7E);
OBEX_DEFINE_GUID(ShimBluetoothFilterPower, 0x6AD90DAD, 0xC144, 0x4E9D, 0xA0, 0xCF, 0xAE, 0x9F, 0xCB, 0x90, 0x1E, 0xBD);
OBEX_DEFINE_GUID(ShimUsbConexant, 0xFD8FD62E, 0x4D94, 0x4FC7, 0x8A, 0x68, 0xBF, 0xF7, 0x86, 0x5A, 0x70, 0x6B);
OBEX_DEFINE_GUID(ShimNokiaPCSuite, 0x7DD60997, 0x651F, 0x4ECB, 0xB8, 0x93, 0xBE, 0xC8, 0x05, 0x0F, 0x3B, 0xD7);
OBEX_DEFINE_GUID(ShimCetCompat, 0x31971B07, 0x71A4, 0x480A, 0x87, 0xA9, 0xD9, 0xD2, 0x76, 0x99, 0xA0, 0x7E);

SUP_SHIM_INFO KsepShimInformation[] = {
    { L"DriverScope", (GUID*)&ShimDriverScope, L"ETW event logger", L"ntos" },
    { L"VersionLie 7",  (GUID*)&ShimVersionLie1, L"Reports previous version of OS", L"ntos" },
    { L"VersionLie 8",  (GUID*)&ShimVersionLie2, L"Reports previous version of OS", L"ntos" },
    { L"VersionLie 8.1",  (GUID*)&ShimVersionLie3, L"Reports previous version of OS", L"ntos" },
    { L"SkipDriverUnload", (GUID*)&ShimSkipDriverUnload, L"Replaces driver unload with ETW hook", L"ntos" },
    { L"ZeroPool", (GUID*)&ShimZeroPool, L"ExAllocatePool hook that forces zeroes allocation", L"ntos" },
    { L"ClearPCIDBits", (GUID*)&ShimClearPCIDBits, L"Clears PCID bits for some ISV", L"ntos" },
    { L"Kaspersky", (GUID*)&ShimKaspersky, L"Kaspersky driver forced bugfix", L"ntos" },
    { L"memcpy", (GUID*)&ShimMemcpy, L"The memcpy hook to \"safer\" variant", L"ntos" },
    { L"KernelPadSectionsOverride", (GUID*)&ShimKernelPadSectionsOverride, L"Blocks drivers discardable section disposal", L"ntos" },
    { L"NdisVersionLie", (GUID*)&ShimNdisVersionLie, L"Reports NDIS version 6.40", L"ndis" },
    { L"SrbShim", (GUID*)&ShimSrb, L"SCSI request IOCTL_STORAGE_QUERY_PROPERTY compatibility hook", L"storport" },
    { L"DeviceIdShim", (GUID*)&ShimDeviceId, L"RAID compatibility shim", L"storport" },
    { L"ATADeviceIdShim", (GUID*)&ShimATADeviceId, L"SATA compatibility shim", L"storport" },
    { L"BluetoothFilterPowerShim", (GUID*)&ShimBluetoothFilterPower, L"Bluetooth filter driver compatibility shim", L"bthport" },
    { L"UsbConexantShim", (GUID*)&ShimUsbConexant, L"USB modem compatibility shim", L"usbd" },
    { L"NokiaShim", (GUID*)&ShimNokiaPCSuite, L"Nokia PC Suite compatibility shim", L"usbd" },
    { L"UserCetBasicModeAllowRetTargetNotCetCompat", (GUID*)&ShimCetCompat, L"Intel CET compatibility shim", L"ntos"}
};

LIST_ENTRY supShutdownListHead;
CRITICAL_SECTION supShutdownListLock;

HANDLE ObjectPathHeap = NULL;

OBEX_CONFIG g_LoadedParametersBlock;

//
// Setup info/SCM database.
//
SAPIDB g_sapiDB;
SCMDB g_scmDB;

SYM_LOADING_STATE g_SymLoadState;

int __cdecl supxHandlesLookupCallback(
    void const* first,
    void const* second);

int __cdecl supxHandlesLookupCallback2(
    void const* first,
    void const* second);

/*
* supCreateHeap
*
* Purpose:
*
* Wrapper around RtlCreateHeap with statistics support.
*
*/
HANDLE supCreateHeap(
    _In_ ULONG HeapFlags,
    _In_ BOOL TerminateOnCorruption
)
{
    HANDLE heapHandle;

    heapHandle = RtlCreateHeap(HeapFlags, NULL, 0, 0, NULL, NULL);
    if (heapHandle == NULL)
        return NULL;

    if (TerminateOnCorruption && g_WinObj.IsWine == FALSE) {
        RtlSetHeapInformation(heapHandle, HeapEnableTerminationOnCorruption, NULL, 0);
    }

    OBEX_STATS_INC(TotalHeapsCreated);

    return heapHandle;
}

/*
* supDestroyHeap
*
* Purpose:
*
* Wrapper around RtlDestroyHeap with statistics support.
*
*/
BOOL supDestroyHeap(
    _In_ HANDLE HeapHandle
)
{
    BOOL bResult;

    bResult = (RtlDestroyHeap(HeapHandle) == NULL);
    if (bResult)
        OBEX_STATS_INC(TotalHeapsDestroyed);

    return bResult;
}

/*
* supHeapAllocEx
*
* Purpose:
*
* Wrapper for RtlAllocateHeap with statistics support.
*
*/
FORCEINLINE PVOID supHeapAllocEx(
    _In_ HANDLE Heap,
    _In_ SIZE_T Size
)
{
    PVOID Buffer;

#ifdef _DEBUG
    ULONG64 MaxHeapAllocatedBlockSize;
#endif

    Buffer = RtlAllocateHeap(Heap, HEAP_ZERO_MEMORY, Size);

    if (Buffer) {

        OBEX_STATS_INC(TotalHeapAlloc);
        OBEX_STATS_INC64(TotalHeapMemoryAllocated, Size);

#ifdef _DEBUG
        MaxHeapAllocatedBlockSize = g_WinObjStats.MaxHeapAllocatedBlockSize;

        while (1) {

            if (Size <= MaxHeapAllocatedBlockSize)
                break;

            MaxHeapAllocatedBlockSize = InterlockedCompareExchange64(
                (LONG64*)&g_WinObjStats.MaxHeapAllocatedBlockSize,
                (LONG64)Size,
                (LONG64)MaxHeapAllocatedBlockSize);

        }
#endif
    }

    return Buffer;
}

/*
* supHeapFreeEx
*
* Purpose:
*
* Wrapper for RtlFreeHeap with statistics support.
*
*/
FORCEINLINE BOOL supHeapFreeEx(
    _In_ HANDLE Heap,
    _In_ PVOID Memory
)
{
    BOOL Result;

    Result = RtlFreeHeap(Heap, 0, Memory);

    if (Result) {

        OBEX_STATS_INC(TotalHeapFree);

    }

    return Result;
}

/*
* supHeapAlloc
*
* Purpose:
*
* Wrapper for RtlAllocateHeap with WinObjEx heap.
*
*/
FORCEINLINE PVOID supHeapAlloc(
    _In_ SIZE_T Size)
{
    return supHeapAllocEx(g_obexHeap, Size);
}

/*
* supHeapReAlloc
*
* Purpose:
*
* Wrapper for supHeapReAlloc with WinObjEx heap.
*
*/
PVOID supHeapReAlloc(
    _When_(Size == 0, _Frees_ptr_opt_)
    _When_(Size > 0 && Memory != NULL, _In_)
    _When_(Size > 0 && Memory == NULL, _Null_)
    PVOID Memory,
    _In_ SIZE_T Size
)
{
    if (Size == 0) {
        if (Memory != NULL)
            supHeapFree(Memory);
        return NULL;
    }
    if (Memory != NULL) {
        return RtlReAllocateHeap(g_obexHeap, HEAP_ZERO_MEMORY, Memory, Size);
    }
    return supHeapAllocEx(g_obexHeap, Size);
}

/*
* supHeapFree
*
* Purpose:
*
* Wrapper for RtlFreeHeap with WinObjEx heap.
*
*/
FORCEINLINE BOOL supHeapFree(
    _In_ PVOID Memory)
{
    return supHeapFreeEx(g_obexHeap, Memory);
}

/*
* supGetDPIValue
*
* Purpose:
*
* Return DPI value for system or specific window (win10+).
*
*/
UINT supGetDPIValue(
    _In_opt_ HWND hWnd
)
{
    HDC hDc;

    UINT uDpi = DefaultSystemDpi;
    DPI_AWARENESS dpiAwareness;

    if (g_NtBuildNumber >= NT_WIN10_REDSTONE1) {

        dpiAwareness = g_ExtApiSet.GetAwarenessFromDpiAwarenessContext(
            g_ExtApiSet.GetThreadDpiAwarenessContext());

        switch (dpiAwareness) {

            // Scale the window to the system DPI
        case DPI_AWARENESS_SYSTEM_AWARE:
            uDpi = g_ExtApiSet.GetDpiForSystem();
            break;

            // Scale the window to the monitor DPI
        case DPI_AWARENESS_PER_MONITOR_AWARE:
            if (hWnd) uDpi = g_ExtApiSet.GetDpiForWindow(hWnd);
            break;
        }

    }
    else {
        hDc = GetDC(0);
        if (hDc) {
            uDpi = (UINT)GetDeviceCaps(hDc, LOGPIXELSX);
            ReleaseDC(0, hDc);
        }
    }

    return uDpi;
}

/*
* supTreeListEnableRedraw
*
* Purpose:
*
* Change treelist redraw state.
*
*/
VOID supTreeListEnableRedraw(
    _In_ HWND TreeList,
    _In_ BOOL fEnable
)
{
    if (fEnable) {
        TreeList_RedrawEnableAndUpdateNow(TreeList);
    }
    else {
        TreeList_RedrawDisable(TreeList);
    }
}

/*
* supTreeListAddItem
*
* Purpose:
*
* Insert new treelist item.
*
*/
HTREEITEM supTreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems
)
{
    TVINSERTSTRUCT  tvitem;
    PTL_SUBITEMS    si = (PTL_SUBITEMS)subitems;

    RtlSecureZeroMemory(&tvitem, sizeof(tvitem));
    tvitem.hParent = hParent;
    tvitem.item.mask = mask;
    tvitem.item.state = state;
    tvitem.item.stateMask = stateMask;
    tvitem.item.pszText = pszText;
    tvitem.hInsertAfter = TVI_LAST;
    return TreeList_InsertTreeItem(TreeList, &tvitem, si);
}

/*
* supInitTreeListForDump
*
* Purpose:
*
* Intialize TreeList control for object dump sheet.
*
*/
BOOL supInitTreeListForDump(
    _In_ HWND hwndParent,
    _Out_ HWND* pTreeListHwnd
)
{
    HWND     TreeList, hWndGroupBox;
    HDITEM   hdritem;
    RECT     rc;

    UINT uDpi;
    INT dpiScaledX, dpiScaledY, iScaledWidth, iScaledHeight, iScaleSub;

    if (pTreeListHwnd == NULL) {
        return FALSE;
    }

    uDpi = supGetDPIValue(NULL);
    dpiScaledX = MulDiv(TreeListDumpObjWndPosX, uDpi, DefaultSystemDpi);
    dpiScaledY = MulDiv(TreeListDumpObjWndPosY, uDpi, DefaultSystemDpi);

    hWndGroupBox = GetDlgItem(hwndParent, ID_OBJECTDUMPGROUPBOX);
    GetWindowRect(hWndGroupBox, &rc);
    iScaleSub = MulDiv(TreeListDumpObjWndScaleSub, uDpi, DefaultSystemDpi);
    iScaledWidth = (rc.right - rc.left) - dpiScaledX - iScaleSub;
    iScaledHeight = (rc.bottom - rc.top) - dpiScaledY - iScaleSub;

    TreeList = CreateWindowEx(WS_EX_STATICEDGE, WC_TREELIST, NULL,
        WS_VISIBLE | WS_CHILD | WS_TABSTOP | TLSTYLE_COLAUTOEXPAND | TLSTYLE_LINKLINES,
        dpiScaledX, dpiScaledY,
        iScaledWidth, iScaledHeight, hwndParent, NULL, NULL, NULL);

    if (TreeList == NULL) {
        *pTreeListHwnd = NULL;
        return FALSE;
    }

    *pTreeListHwnd = TreeList;

    RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
    hdritem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
    hdritem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;
    hdritem.cxy = SCALE_DPI_VALUE(220, g_WinObj.CurrentDPI);
    hdritem.pszText = TEXT("Field");
    TreeList_InsertHeaderItem(TreeList, 0, &hdritem);
    hdritem.cxy = SCALE_DPI_VALUE(130, g_WinObj.CurrentDPI);
    hdritem.pszText = TEXT("Value");
    TreeList_InsertHeaderItem(TreeList, 1, &hdritem);
    hdritem.cxy = SCALE_DPI_VALUE(210, g_WinObj.CurrentDPI);
    hdritem.pszText = TEXT("Additional Information");
    TreeList_InsertHeaderItem(TreeList, 2, &hdritem);

    return TRUE;
}

/*
* supClipboardCopy
*
* Purpose:
*
* Copy text to the clipboard.
*
*/
VOID supClipboardCopy(
    _In_ LPCWSTR lpText,
    _In_ SIZE_T cbTextInBytes
)
{
    LPWSTR  lptstrCopy;
    HGLOBAL hglbCopy = NULL;
    SIZE_T  dwSize;
    BOOL    dataSet = FALSE;

    if (!OpenClipboard(NULL))
        return;

    __try {
        EmptyClipboard();
        dwSize = cbTextInBytes + sizeof(UNICODE_NULL);
        hglbCopy = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize);
        if (hglbCopy == NULL)
            __leave;

        lptstrCopy = (LPWSTR)GlobalLock(hglbCopy);
        if (lptstrCopy == NULL)
            __leave;

        RtlCopyMemory(lptstrCopy, lpText, cbTextInBytes);
        GlobalUnlock(hglbCopy);

        dataSet = SetClipboardData(CF_UNICODETEXT, hglbCopy) != NULL;
        if (dataSet) {
            hglbCopy = NULL;
        }
    }
    __finally {
        CloseClipboard();
        if (hglbCopy != NULL) {
            GlobalFree(hglbCopy);
        }
    }
}

/*
* supQueryObjectFromHandleEx
*
* Purpose:
*
* Return object kernel address from handle in current process handle table.
* Handle table dump supplied as parameter.
*
*/
BOOL supQueryObjectFromHandleEx(
    _In_ PSYSTEM_HANDLE_INFORMATION_EX HandlesDump,
    _In_ HANDLE Object,
    _Out_opt_ ULONG_PTR* Address,
    _Out_opt_ USHORT* TypeIndex
)
{
    USHORT      objectTypeIndex = 0;
    BOOL        bFound = FALSE;
    DWORD       CurrentProcessId = GetCurrentProcessId();
    ULONG_PTR   i, objectAddress = 0;

    for (i = 0; i < HandlesDump->NumberOfHandles; i++) {
        if (HandlesDump->Handles[i].UniqueProcessId == (ULONG_PTR)CurrentProcessId) {
            if (HandlesDump->Handles[i].HandleValue == (ULONG_PTR)Object) {
                if (Address) {
                    objectAddress = (ULONG_PTR)HandlesDump->Handles[i].Object;
                }
                if (TypeIndex) {
                    objectTypeIndex = HandlesDump->Handles[i].ObjectTypeIndex;
                }
                bFound = TRUE;
                break;
            }
        }
    }

    if (Address)
        *Address = objectAddress;
    if (TypeIndex)
        *TypeIndex = objectTypeIndex;

    return bFound;
}

/*
* supQueryObjectFromHandle
*
* Purpose:
*
* Return object kernel address from handle in current process handle table.
*
*/
BOOL supQueryObjectFromHandle(
    _In_ HANDLE Object,
    _Out_ ULONG_PTR* Address,
    _Out_opt_ USHORT* TypeIndex
)
{
    BOOL bFound = FALSE;
    PSYSTEM_HANDLE_INFORMATION_EX pHandles;

    if (Address == NULL) {
        return bFound;
    }

    if (TypeIndex)
        *TypeIndex = 0;

    pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation, NULL);
    if (pHandles) {

        bFound = supQueryObjectFromHandleEx(pHandles,
            Object,
            Address,
            TypeIndex);

        supHeapFree(pHandles);
    }

    if (!bFound) *Address = 0;

    return bFound;
}

/*
* supDumpSyscallTableConverted
*
* Purpose:
*
* Read service table and convert it.
*
*/
BOOL supDumpSyscallTableConverted(
    _In_ ULONG_PTR ServiceTableAddress,
    _In_ ULONG ServiceLimit,
    _Out_ PUTable* Table
)
{
    ULONG   ServiceId, memIO;
    BOOL    bResult = FALSE;
    PULONG  ServiceTableDumped = NULL;
    PUTable ConvertedTable;

    LONG32 Offset;

    *Table = NULL;

    if (ServiceLimit == 0)
        return FALSE;

    if (ServiceLimit > (ULONG_MAX / sizeof(ULONG)))
        return FALSE;

    memIO = ServiceLimit * sizeof(ULONG);

    ServiceTableDumped = (PULONG)supHeapAlloc(memIO);
    if (ServiceTableDumped) {
        if (kdReadSystemMemory(
            ServiceTableAddress,
            (PVOID)ServiceTableDumped,
            memIO))
        {
            ConvertedTable = (PULONG_PTR)supHeapAlloc(ServiceLimit * sizeof(ULONG_PTR));

            if (ConvertedTable) {

                *Table = ConvertedTable;
                for (ServiceId = 0; ServiceId < ServiceLimit; ServiceId++) {
                    Offset = ((LONG32)ServiceTableDumped[ServiceId] >> 4);
                    ConvertedTable[ServiceId] = (ULONG_PTR)(ServiceTableAddress + Offset);
                }
                bResult = TRUE;
            }
        }
        supHeapFree(ServiceTableDumped);
    }
    return bResult;
}

/*
* supShowHelp
*
* Purpose:
*
* Display help file if available.
*
*/
VOID supShowHelp(
    _In_ HWND ParentWindow
)
{
    DWORD   dwSize, dwType = 0;
    HKEY    hKey;
    LRESULT lRet;
    HMODULE hHtmlOcx;
    LPWSTR  s;
    WCHAR   szOcxPath[MAX_PATH];
    WCHAR   szBuffer[MAX_PATH * 2];
    WCHAR   szHelpFile[MAX_PATH * 2];
    BOOL    bHelpFileFound = FALSE;
    WCHAR   szHelpFileName[] = L"\\winobjex64.chm";
    WCHAR   szExeName[MAX_PATH];
    WCHAR   szExePath[MAX_PATH];

    //
    //  Check if CHM file exist and remember filename.
    //
    RtlSecureZeroMemory(szHelpFile, sizeof(szHelpFile));
    if (GetCurrentDirectory(MAX_PATH, szHelpFile)) {
        _strcat(szHelpFile, szHelpFileName);
        if (PathFileExists(szHelpFile)) {
            bHelpFileFound = TRUE;
        }
    }

    //
    // If not found, check executable's directory.
    //
    if (!bHelpFileFound) {
        RtlSecureZeroMemory(szExeName, sizeof(szExeName));
        RtlSecureZeroMemory(szExePath, sizeof(szExePath));
        RtlSecureZeroMemory(szHelpFile, sizeof(szHelpFile));
        if (GetModuleFileName(NULL, szExeName, MAX_PATH)) {
            _filepath(szExeName, szExePath);
            _strcpy(szHelpFile, szExePath);
            _strcat(szHelpFile, szHelpFileName + 1);  // Path seperator is already included
            if (PathFileExists(szHelpFile)) {
                bHelpFileFound = TRUE;
            }
        }
    }

    if (!bHelpFileFound) {
        s = (LPWSTR)supHeapAlloc((MAX_PATH + _strlen(szHelpFile)) * sizeof(WCHAR));
        if (s) {
            _strcpy(s, TEXT("Help file could not be found - "));
            _strcat(s, szHelpFile);
            MessageBox(ParentWindow, s, NULL, MB_ICONINFORMATION);
            supHeapFree(s);
        }
        return;
    }

    //
    // Query OCX path from registry.
    //
    RtlSecureZeroMemory(szOcxPath, sizeof(szOcxPath));
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, HHCTRLOCXKEY, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {
        dwSize = MAX_PATH * sizeof(WCHAR);
        lRet = RegQueryValueEx(hKey, L"", NULL, &dwType, (LPBYTE)szBuffer, &dwSize);
        RegCloseKey(hKey);

        if (lRet == ERROR_SUCCESS) {
            if (dwType == REG_EXPAND_SZ) {
                if (ExpandEnvironmentStrings(szBuffer, szOcxPath, MAX_PATH) == 0)
                    lRet = ERROR_SECRET_TOO_LONG;
            }
            else {
                _strncpy(szOcxPath, MAX_PATH, szBuffer, MAX_PATH);
            }
        }
    }
    if (lRet != ERROR_SUCCESS) {
        _strcpy(szOcxPath, HHCTRLOCX);
    }

    //
    // Load OCX and call help.
    //
    hHtmlOcx = GetModuleHandle(HHCTRLOCX);
    if (hHtmlOcx == NULL) {
        hHtmlOcx = LoadLibrary(szOcxPath);
        if (hHtmlOcx == NULL) {
            return;
        }
    }
    if (g_WinObj.HtmlHelpW == NULL) {
        g_WinObj.HtmlHelpW = (pfnHtmlHelpW)GetProcAddress(hHtmlOcx, MAKEINTRESOURCEA(0xF));
        if (g_WinObj.HtmlHelpW == NULL) {
            FreeLibrary(hHtmlOcx);
            return;
        }
    }
    g_WinObj.HtmlHelpW(GetDesktopWindow(), szHelpFile, 0, 0);
}

/*
* supEnumIconCallback
*
* Purpose:
*
* Resource enumerator callback.
*
*/
BOOL supEnumIconCallback(
    _In_opt_ HMODULE hModule,
    _In_ LPCWSTR lpType,
    _In_ LPWSTR lpName,
    _In_ LONG_PTR lParam
)
{
    PENUMICONINFO pin;

    UNREFERENCED_PARAMETER(lpType);

    pin = (PENUMICONINFO)lParam;
    if (pin == NULL) {
        return FALSE;
    }

    pin->hIcon = (HICON)LoadImage(hModule, lpName, IMAGE_ICON, pin->cx, pin->cy, 0);
    return FALSE;
}

/*
* supGetMainIcon
*
* Purpose:
*
* Extract main icon if it exists in executable image.
*
*/
HICON supGetMainIcon(
    _In_ LPCWSTR lpFileName,
    _In_ INT cx,
    _In_ INT cy
)
{
    HMODULE      hModule;
    ENUMICONINFO pin;

    pin.cx = cx;
    pin.cy = cy;
    pin.hIcon = 0;

    hModule = LoadLibraryEx(lpFileName, 0, LOAD_LIBRARY_AS_DATAFILE);
    if (hModule != NULL) {
        EnumResourceNames(hModule, RT_GROUP_ICON, (ENUMRESNAMEPROC)&supEnumIconCallback,
            (LONG_PTR)&pin);
        FreeLibrary(hModule);
    }
    return pin.hIcon;
}

/*
* supFreeUnicodeString
*
* Purpose:
*
* Release memory allocated for string.
*
*/
_Success_(return)
BOOL supFreeUnicodeString(
    _In_ HANDLE HeapHandle,
    _Inout_ PUNICODE_STRING String
)
{
    if (String->Buffer) {
        return supHeapFreeEx(HeapHandle, String->Buffer);
    }
    return FALSE;
}

/*
* supFreeDuplicatedUnicodeString
*
* Purpose:
*
* Release memory allocated for duplicated string.
*
*/
_Success_(return)
BOOL supFreeDuplicatedUnicodeString(
    _In_ HANDLE HeapHandle,
    _Inout_ PUNICODE_STRING DuplicatedString,
    _In_ BOOL DoZeroMemory
)
{
    BOOL bResult = FALSE;
    if (DuplicatedString->Buffer) {
        bResult = supHeapFreeEx(HeapHandle, DuplicatedString->Buffer);
        if (DoZeroMemory) {
            DuplicatedString->Buffer = NULL;
            DuplicatedString->Length = DuplicatedString->MaximumLength = 0;
        }
    }
    return bResult;
}

/*
* supDuplicateUnicodeString
*
* Purpose:
*
* Duplicate existing UNICODE_STRING to another without RtlDuplicateUnicodeString.
*
* Note: Use supFreeDuplicatedUnicodeString to release allocated memory.
*
*/
_Success_(return)
BOOL supDuplicateUnicodeString(
    _In_ HANDLE HeapHandle,
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString
)
{
    USHORT maxLength = SourceString->MaximumLength;
    PWCHAR strBuffer;

    if (maxLength == 0 || maxLength < SourceString->Length)
        return FALSE;

    strBuffer = (PWCHAR)supHeapAllocEx(HeapHandle, (SIZE_T)maxLength);
    if (strBuffer) {
        DestinationString->Buffer = strBuffer;
        DestinationString->MaximumLength = maxLength;
        RtlCopyUnicodeString(DestinationString, SourceString);
        return TRUE;
    }

    return FALSE;
}

/*
* supCreateObjectPathFromElements
*
* Purpose:
*
* Build object path with provided directory and name.
*
* Note: Use supFreeDuplicatedUnicodeString to release allocated memory.
*
*/
_Success_(return)
BOOL supCreateObjectPathFromElements(
    _In_ PUNICODE_STRING ObjectName,
    _In_ PUNICODE_STRING DirectoryName,
    _Out_ PUNICODE_STRING ObjectPath,
    _In_ BOOLEAN NullTerminate
)
{
    BOOL bResult = FALSE, bIsRootDirectory;
    PWSTR nameBuffer, string = NULL;
    ULONG memIO;
    USHORT bufferLength;

    //
    // Must be valid strings.
    //
    if (ObjectName->Length == 0 ||
        DirectoryName->Length == 0)
    {
        return FALSE;
    }

    bIsRootDirectory = supIsRootDirectory(DirectoryName);
    memIO = ObjectName->Length + DirectoryName->Length;

    if (!bIsRootDirectory)
        memIO += OBJ_NAME_PATH_SEPARATOR_SIZE;

    if (NullTerminate)
        memIO += sizeof(UNICODE_NULL);

    nameBuffer = (PWSTR)supHeapAlloc(memIO);
    string = nameBuffer;

    if (string) {

        RtlCopyMemory(string, DirectoryName->Buffer, DirectoryName->Length);
        string = (PWSTR)RtlOffsetToPointer(string, DirectoryName->Length);

        if (!supIsRootDirectory(ObjectName)) {

            if (!bIsRootDirectory)
                *string++ = OBJ_NAME_PATH_SEPARATOR;

            RtlCopyMemory(string, ObjectName->Buffer, ObjectName->Length);
            string = (PWSTR)RtlOffsetToPointer(string, ObjectName->Length);

        }

        if (NullTerminate)
            *string++ = UNICODE_NULL;

        bResult = TRUE;
    }

    bufferLength = (USHORT)((ULONG_PTR)string - (ULONG_PTR)nameBuffer);
    ObjectPath->Buffer = nameBuffer;
    if (NullTerminate)
        ObjectPath->Length = (USHORT)(bufferLength - sizeof(UNICODE_NULL));
    else
        ObjectPath->Length = (USHORT)bufferLength;

    ObjectPath->MaximumLength = (USHORT)memIO;

    return bResult;
}

/*
* supCreateObjectPathFromCurrentPath
*
* Purpose:
*
* Build string that include current directory and object name.
*
*/
_Success_(return)
BOOL supCreateObjectPathFromCurrentPath(
    _In_ PUNICODE_STRING ObjectName,
    _Out_ PUNICODE_STRING ObjectPath,
    _In_ BOOLEAN NullTerminate
)
{
    USHORT bufferLength;
    BOOL bResult = FALSE, bIsRootDirectory;
    PWSTR nameBuffer, string = NULL;
    ULONG memIO;
    UNICODE_STRING currentPath;

    if (ObjectName->Length == 0)
        return FALSE;

    //
    // If ObjectName is root, return root.
    //
    if (supIsRootDirectory(ObjectName)) {
        return supDuplicateUnicodeString(g_obexHeap, ObjectPath, ObjectName);
    }

    if (!supGetCurrentObjectPath(TRUE, &currentPath))
        return FALSE;

    bIsRootDirectory = supIsRootDirectory(&currentPath);

    memIO = ObjectName->Length + currentPath.Length;

    if (!bIsRootDirectory)
        memIO += OBJ_NAME_PATH_SEPARATOR_SIZE;

    if (NullTerminate)
        memIO += sizeof(UNICODE_NULL);

    nameBuffer = (PWSTR)supHeapAlloc(memIO);
    string = nameBuffer;

    if (string) {

        RtlCopyMemory(string, currentPath.Buffer, currentPath.Length);
        string = (PWSTR)RtlOffsetToPointer(string, currentPath.Length);

        if (!bIsRootDirectory)
            *string++ = OBJ_NAME_PATH_SEPARATOR;

        RtlCopyMemory(string, ObjectName->Buffer, ObjectName->Length);
        string = (PWSTR)RtlOffsetToPointer(string, ObjectName->Length);

        if (NullTerminate)
            *string++ = UNICODE_NULL;

        bResult = TRUE;
    }

    bufferLength = (USHORT)((ULONG_PTR)string - (ULONG_PTR)nameBuffer);
    ObjectPath->Buffer = nameBuffer;
    if (NullTerminate)
        ObjectPath->Length = (USHORT)(bufferLength - sizeof(UNICODE_NULL));
    else
        ObjectPath->Length = (USHORT)bufferLength;

    ObjectPath->MaximumLength = (USHORT)memIO;

    supFreeDuplicatedUnicodeString(g_obexHeap, &currentPath, FALSE);
    return bResult;
}

/*
* supSetWaitCursor
*
* Purpose:
*
* Sets cursor state.
*
*/
VOID supSetWaitCursor(
    _In_ BOOL fSet
)
{
    ShowCursor(fSet);
    SetCursor(LoadCursor(NULL, fSet ? IDC_WAIT : IDC_ARROW));
}

/*
* supCenterWindowSpecifyParent
*
* Purpose:
*
* Centers given window relative to it parent window.
*
*/
VOID supCenterWindowSpecifyParent(
    _In_ HWND hwnd,
    _In_opt_ HWND parent
)
{
    RECT rc, rcDlg, rcOwner;

    //center window
    if (parent) {
        GetWindowRect(parent, &rcOwner);
        GetWindowRect(hwnd, &rcDlg);
        CopyRect(&rc, &rcOwner);
        OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
        OffsetRect(&rc, -rc.left, -rc.top);
        OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);
        SetWindowPos(hwnd,
            HWND_TOP,
            rcOwner.left + (rc.right / 2),
            rcOwner.top + (rc.bottom / 2),
            0, 0,
            SWP_NOSIZE);
    }
}

/*
* supCenterWindow
*
* Purpose:
*
* Centers given window relative to it parent window.
*
*/
VOID supCenterWindow(
    _In_ HWND hwnd
)
{
    supCenterWindowSpecifyParent(hwnd, GetParent(hwnd));
}

/*
* supCenterWindowPerScreen
*
* Purpose:
*
* Centers given window relative to screen.
*
*/
VOID supCenterWindowPerScreen(
    _In_ HWND hwnd
)
{
    RECT rc;
    INT posX = GetSystemMetrics(SM_CXSCREEN);
    INT posY = GetSystemMetrics(SM_CYSCREEN);

    if (GetWindowRect(hwnd, &rc)) {

        posX = (posX - rc.right) / 2;
        posY = (posY - rc.bottom) / 2;

        SetWindowPos(hwnd,
            NULL,
            posX,
            posY,
            0,
            0,
            SWP_NOZORDER | SWP_NOSIZE);
    }
}

/*
* supGetTokenInfo
*
* Purpose:
*
* Returns buffer with token information by given TokenInformationClass.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
PVOID supGetTokenInfo(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_opt_ PULONG ReturnLength
)
{
    PVOID Buffer = NULL;
    ULONG returnLength = 0;

    if (ReturnLength)
        *ReturnLength = 0;

    NtQueryInformationToken(TokenHandle,
        TokenInformationClass,
        NULL,
        0,
        &returnLength);

    Buffer = supHeapAlloc((SIZE_T)returnLength);
    if (Buffer) {

        if (NT_SUCCESS(NtQueryInformationToken(TokenHandle,
            TokenInformationClass,
            Buffer,
            returnLength,
            &returnLength)))
        {
            if (ReturnLength)
                *ReturnLength = returnLength;
            return Buffer;
        }
        else {
            supHeapFree(Buffer);
            return NULL;
        }
    }

    return Buffer;
}

/*
* supGetLoadedModulesList
*
* Purpose:
*
* Read list of loaded kernel modules.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
PVOID supGetLoadedModulesList(
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(FALSE,
        ReturnLength,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);
}

/*
* supGetLoadedModulesList2
*
* Purpose:
*
* Read list of loaded kernel modules.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
PVOID supGetLoadedModulesList2(
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(TRUE,
        ReturnLength,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);
}

/*
* supGetSystemInfo
*
* Purpose:
*
* Returns buffer with system information by given SystemInformationClass.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetSystemInfoEx(
        SystemInformationClass,
        ReturnLength,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);
}

/*
* supxFreeObjectTypes
*
* Purpose:
*
* Free object types memory callback.
*
*/
BOOL CALLBACK supxFreeObjectTypes(
    _In_opt_ PVOID Context
)
{
    if (Context)
        supHeapFree(Context);

    return TRUE;
}

/*
* supGetObjectTypesInfo
*
* Purpose:
*
* Returns buffer with system types information.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
PVOID supGetObjectTypesInfo(
    VOID
)
{
    PVOID       buffer = NULL;
    ULONG       bufferSize = 1024 * 16;
    NTSTATUS    ntStatus;
    ULONG       returnedLength = 0;

    buffer = supHeapAlloc((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    while ((ntStatus = NtQueryObject(
        NULL,
        ObjectTypesInformation,
        buffer,
        bufferSize,
        &returnedLength)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        supHeapFree(buffer);
        bufferSize *= 2;

        if (bufferSize > (16 * 1024 * 1024))
            return NULL;

        buffer = supHeapAlloc((SIZE_T)bufferSize);
    }

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    if (buffer)
        supHeapFree(buffer);

    return NULL;
}

/*
* supGetItemText
*
* Purpose:
*
* Returns buffer with text from the given listview item.
*
* Returned buffer must be freed with supHeapFree after usage.
*
*/
LPWSTR supGetItemText(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _Out_opt_ PSIZE_T lpSize // length in bytes
)
{
    INT len = MAX_PATH;
    INT sz = -1;
    LV_ITEM item;
    LPWSTR buffer = NULL;

    RtlSecureZeroMemory(&item, sizeof(item));
    item.iItem = nItem;
    item.iSubItem = nSubItem;

    do {
        if (buffer) {
            supHeapFree(buffer);
            buffer = NULL;
        }

        buffer = (LPWSTR)supHeapAlloc(len * sizeof(WCHAR));
        if (buffer == NULL) {
            sz = 0;
            break;
        }

        item.pszText = buffer;
        item.cchTextMax = len;

        sz = (INT)SendMessage(ListView, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&item);
        if (sz < 0) {
            // general fuckup
            supHeapFree(buffer);
            buffer = NULL;
            sz = 0;
            break;
        }

        if (sz < len - 1) {
            break;
        }

        if (len > INT_MAX / 2) {
            break;
        }
        len *= 2;

    } while (TRUE);

    if (sz == 0 && buffer) {
        supHeapFree(buffer);
        buffer = NULL;
    }

    if (lpSize) {
        *lpSize = (SIZE_T)sz * sizeof(WCHAR);
    }

    return buffer;
}

/*
* supGetItemText2
*
* Purpose:
*
* Returns text from the given listview item.
*
*/
LPWSTR supGetItemText2(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _In_ WCHAR * pszText,
    _In_ UINT cchText
)
{
    LV_ITEM item;

    RtlSecureZeroMemory(&item, sizeof(item));

    item.iItem = nItem;
    item.iSubItem = nSubItem;
    item.pszText = pszText;
    item.cchTextMax = (SIZE_T)cchText;
    SendMessage(ListView, LVM_GETITEMTEXT, (WPARAM)item.iItem, (LPARAM)&item);

    return item.pszText;
}

/*
* supLoadImageList
*
* Purpose:
*
* Create and load image list from icon resource type.
*
*/
HIMAGELIST supLoadImageList(
    _In_ HINSTANCE hInst,
    _In_ UINT FirstId,
    _In_ UINT LastId
)
{
    UINT       i;
    HIMAGELIST list;
    HICON      hIcon;

    list = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 2, 8);
    if (list) {
        for (i = FirstId; i <= LastId; i++) {
            hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(i), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
            if (hIcon) {
                ImageList_ReplaceIcon(list, -1, hIcon);
                DestroyIcon(hIcon);
            }
        }
    }
    return list;
}

/*
* supGetObjectNameIndexByTypeIndex
*
* Purpose:
*
* Returns object index of known type.
*
* Known type names listed in objects.c, objects.h
*
*/
WOBJ_OBJECT_TYPE supGetObjectNameIndexByTypeIndex(
    _In_ PVOID Object,
    _In_ UCHAR TypeIndex
)
{
    UINT   typeIndex;
    ULONG  i;
    POBTYPE_LIST objectTypesList;

    if (Object == NULL)
        return ObjectTypeUnknown;

    objectTypesList = g_kdctx.Data->ObjectTypesList;
    if (objectTypesList == NULL)
        return ObjectTypeUnknown;

    typeIndex = ObDecodeTypeIndex(Object, TypeIndex);
    for (i = 0; i < objectTypesList->NumberOfTypes; i++) {
        if (objectTypesList->Types[i].TypeIndex == typeIndex) {
            return ObManagerGetIndexByTypeName(
                objectTypesList->Types[i].TypeName->Buffer);

        }
    }

    return ObjectTypeUnknown;
}

/*
* supRunAsAdmin
*
* Purpose:
*
* Restarts application requesting full admin rights.
*
*/
VOID supRunAsAdmin(
    VOID
)
{
    SHELLEXECUTEINFO shinfo;
    WCHAR szPath[MAX_PATH + 1];

    RtlSecureZeroMemory(&szPath, sizeof(szPath));
    if (GetModuleFileName(NULL, szPath, MAX_PATH)) {
        RtlSecureZeroMemory(&shinfo, sizeof(shinfo));
        shinfo.cbSize = sizeof(shinfo);
        shinfo.lpVerb = TEXT("runas");
        shinfo.lpFile = szPath;
        shinfo.lpDirectory = g_WinObj.szProgramDirectory;
        shinfo.nShow = SW_SHOW;
        if (ShellExecuteEx(&shinfo)) {
            PostQuitMessage(0);
        }
    }
}

/*
* supShowProperties
*
* Purpose:
*
* Show file properties Windows dialog.
*
*/
VOID supShowProperties(
    _In_ HWND hwndDlg,
    _In_ LPWSTR lpFileName
)
{
    SHELLEXECUTEINFO shinfo;

    if (lpFileName == NULL) {
        return;
    }

    RtlSecureZeroMemory(&shinfo, sizeof(shinfo));
    shinfo.cbSize = sizeof(shinfo);
    shinfo.fMask = SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_NO_UI;
    shinfo.hwnd = hwndDlg;
    shinfo.lpVerb = TEXT("properties");
    shinfo.lpFile = lpFileName;
    shinfo.nShow = SW_SHOWNORMAL;
    ShellExecuteEx(&shinfo);
}

/*
* supJumpToFile
*
* Purpose:
*
* Open explorer window for given path.
*
*/
VOID supJumpToFile(
    _In_ LPCWSTR lpFilePath
)
{
    LPITEMIDLIST pidList;
    HRESULT hr = E_FAIL;
    SIZE_T sz;
    LPWSTR lpCommand;
    WCHAR szExplorer[MAX_PATH * 2];

    pidList = ILCreateFromPath(lpFilePath);
    if (pidList) {
        hr = SHOpenFolderAndSelectItems(pidList, 0, NULL, 0);
        ILFree(pidList);
    }

    if (FAILED(hr)) {

        sz = MAX_PATH + _strlen(g_WinObj.szWindowsDirectory) + _strlen(lpFilePath);

        lpCommand = (LPWSTR)supHeapAlloc(sz * sizeof(WCHAR));
        if (lpCommand) {
            _strcpy(lpCommand, TEXT(" /select, \""));
            _strcat(lpCommand, lpFilePath);
            _strcat(lpCommand, TEXT("\""));

            _strcpy(szExplorer, g_WinObj.szWindowsDirectory);
            _strcat(szExplorer, TEXT("\\explorer.exe"));

            supShellExecInExplorerProcess(szExplorer, lpCommand);
            supHeapFree(lpCommand);
        }

    }
}

/*
* supObjectListGetObjectType
*
* Purpose:
*
* Return object type of given listview entry.
*
*/
WOBJ_OBJECT_TYPE supObjectListGetObjectType(
    _In_ HWND hwndList,
    _In_ INT iItem
)
{
    OBEX_ITEM* objectReference;

    LVITEM lvItem;

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iItem;
    lvItem.iSubItem = 0;
    lvItem.lParam = 0;
    ListView_GetItem(hwndList, &lvItem);

    objectReference = (OBEX_ITEM*)lvItem.lParam;
    if (objectReference)
        return objectReference->TypeIndex;

    return ObjectTypeUnknown;
}

/*
* supSetGotoLinkTargetToolButtonState
*
* Purpose:
*
* Enable/Disable Go To Link Target tool button.
*
*/
VOID supSetGotoLinkTargetToolButtonState(
    _In_ HWND hwnd,
    _In_opt_ HWND hwndlv,
    _In_ INT iItem,
    _In_ BOOL bForce,
    _In_ BOOL bForceEnable
)
{
    UINT uEnable = MF_BYCOMMAND | MF_GRAYED;

    if (bForce) {
        if (bForceEnable)
            uEnable = MF_BYCOMMAND;
    }
    else {
        if (hwndlv) {
            if (ObjectTypeSymbolicLink == supObjectListGetObjectType(hwndlv, iItem)) {
                uEnable = MF_BYCOMMAND;
            }
        }
    }
    EnableMenuItem(GetSubMenu(GetMenu(hwnd), IDMM_OBJECT), ID_OBJECT_GOTOLINKTARGET, uEnable);
}

/*
* supTreeListAddCopyValueItem
*
* Purpose:
*
* Add copy to clipboard menu item depending on hit treelist header item.
*
*/
BOOL supTreeListAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndTreeList,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ LPARAM lParam,
    _In_ INT * pSubItemHit
)
{
    HDHITTESTINFO hti;
    HD_ITEM hdItem;
    WCHAR szHeaderText[MAX_PATH + 1];
    WCHAR szItem[MAX_PATH * 2];

    *pSubItemHit = -1;

    hti.iItem = -1;
    hti.pt.x = LOWORD(lParam);
    hti.pt.y = HIWORD(lParam);
    ScreenToClient(hwndTreeList, &hti.pt);

    hti.pt.y = 1;
    if (TreeList_HeaderHittest(hwndTreeList, &hti) < 0)
        return FALSE;

    RtlSecureZeroMemory(&hdItem, sizeof(hdItem));

    szHeaderText[0] = 0;
    hdItem.mask = HDI_TEXT;

    hdItem.cchTextMax = sizeof(szHeaderText) - 1;

    hdItem.pszText = szHeaderText;
    if (TreeList_GetHeaderItem(hwndTreeList, hti.iItem, &hdItem)) {

        *pSubItemHit = hti.iItem;

        _strcpy(szItem, TEXT("Copy \""));
        _strcat(szItem, szHeaderText);
        _strcat(szItem, TEXT("\""));
        if (InsertMenu(hMenu, uPos, MF_BYCOMMAND, uId, szItem)) {
            return TRUE;
        }
    }

    return FALSE;
}

/*
* supListViewAddCopyValueItem
*
* Purpose:
*
* Add copy to clipboard menu item depending on hit column.
*
*/
BOOL supListViewAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndLv,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ POINT * lpPoint,
    _Out_ INT * pItemHit,
    _Out_ INT * pColumnHit
)
{
    LVHITTESTINFO lvht;
    LVCOLUMN lvc;
    WCHAR szItem[MAX_PATH * 2];
    WCHAR szColumn[MAX_PATH + 1];

    *pColumnHit = -1;
    *pItemHit = -1;

    RtlSecureZeroMemory(&lvht, sizeof(lvht));
    lvht.pt.x = lpPoint->x;
    lvht.pt.y = lpPoint->y;
    ScreenToClient(hwndLv, &lvht.pt);
    if (ListView_SubItemHitTest(hwndLv, &lvht) == -1)
        return FALSE;

    RtlSecureZeroMemory(&lvc, sizeof(lvc));
    RtlSecureZeroMemory(&szColumn, sizeof(szColumn));

    lvc.mask = LVCF_TEXT;
    lvc.pszText = szColumn;
    lvc.cchTextMax = MAX_PATH;
    if (ListView_GetColumn(hwndLv, lvht.iSubItem, &lvc)) {
        _strcpy(szItem, TEXT("Copy \""));
        _strcat(szItem, szColumn);
        _strcat(szItem, TEXT("\""));
        if (InsertMenu(hMenu, uPos, MF_BYCOMMAND, uId, szItem)) {
            *pColumnHit = lvht.iSubItem;
            *pItemHit = lvht.iItem;
            return TRUE;
        }
    }

    return FALSE;
}

/*
* supTreeListCopyItemValueToClipboard
*
* Purpose:
*
* Copy selected treelist item text to the clipboard.
*
*/
BOOL supTreeListCopyItemValueToClipboard(
    _In_ HWND hwndTreeList,
    _In_ INT tlSubItemHit
)
{
    INT         nIndex;
    LPWSTR      lpCopyData = NULL;
    SIZE_T      cbCopyData = 0;
    TVITEMEX    itemex;
    WCHAR       szText[MAX_PATH + 1];

    TL_SUBITEMS_FIXED* pSubItems = NULL;

    szText[0] = 0;
    RtlSecureZeroMemory(&itemex, sizeof(itemex));
    itemex.mask = TVIF_TEXT;
    itemex.hItem = TreeList_GetSelection(hwndTreeList);
    itemex.pszText = szText;
    itemex.cchTextMax = MAX_PATH;

    if (TreeList_GetTreeItem(hwndTreeList, &itemex, &pSubItems)) {

        if ((tlSubItemHit > 0) && (pSubItems != NULL)) {

            nIndex = (tlSubItemHit - 1);
            if (nIndex < (INT)pSubItems->Count) {

                lpCopyData = pSubItems->Text[nIndex];
                cbCopyData = _strlen(lpCopyData) * sizeof(WCHAR);

            }

        }
        else {
            if (tlSubItemHit == 0) {
                lpCopyData = szText;
                cbCopyData = sizeof(szText);
            }
        }

        if (lpCopyData && cbCopyData) {
            supClipboardCopy(lpCopyData, cbCopyData);
            return TRUE;
        }
        else {
            if (OpenClipboard(NULL)) {
                EmptyClipboard();
                CloseClipboard();
            }
        }
    }

    return FALSE;
}

/*
* supListViewCopyItemValueToClipboard
*
* Purpose:
*
* Copy selected item text to the clipboard.
*
*/
BOOL supListViewCopyItemValueToClipboard(
    _In_ HWND hwndListView,
    _In_ INT iItem,
    _In_ INT iSubItem
)
{
    SIZE_T cbText;
    LPWSTR lpText;

    if ((iSubItem < 0) || (iItem < 0))
        return FALSE;

    lpText = supGetItemText(hwndListView,
        iItem,
        iSubItem,
        NULL);

    if (lpText) {
        cbText = _strlen(lpText) * sizeof(WCHAR);
        supClipboardCopy(lpText, cbText);
        supHeapFree(lpText);
        return TRUE;
    }
    else {
        if (OpenClipboard(NULL)) {
            EmptyClipboard();
            CloseClipboard();
        }
    }

    return FALSE;
}

/*
* supSetMenuIcon
*
* Purpose:
*
* Associates icon data with given menu item.
*
*/
VOID supSetMenuIcon(
    _In_ HMENU hMenu,
    _In_ UINT iItem,
    _In_ HICON hIcon
)
{
    MENUITEMINFO mii;
    RtlSecureZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_BITMAP | MIIM_DATA;
    mii.hbmpItem = HBMMENU_CALLBACK;
    mii.dwItemData = (ULONG_PTR)hIcon;
    SetMenuItemInfo(hMenu, iItem, FALSE, &mii);
}

/*
* supCreateToolbarButtons
*
* Purpose:
*
* Main window toolbar initialization.
*
*/
VOID supCreateToolbarButtons(
    _In_ HWND hWndToolbar,
    _In_ HIMAGELIST hImageList
)
{
    TBBUTTON tbButtons[] = {
        { 0, ID_OBJECT_PROPERTIES, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, -1 },
        { 10, 0, 0, BTNS_SEP, {0}, 0, -1 },
        { 1, ID_VIEW_REFRESH, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, -1 },
        { 7, ID_VIEW_DISPLAYGRID, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, -1 },
        { 10, 0, 0, BTNS_SEP, {0}, 0, -1 },
        { 2, ID_FIND_FINDOBJECT, TBSTATE_ENABLED, BTNS_BUTTON, {0}, 0, -1 }
    };

    SendMessage(hWndToolbar, TB_SETIMAGELIST, 0, (LPARAM)hImageList);
    SendMessage(hWndToolbar, TB_LOADIMAGES, (WPARAM)IDB_STD_SMALL_COLOR, (LPARAM)HINST_COMMCTRL);
    SendMessage(hWndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    SendMessage(hWndToolbar, TB_ADDBUTTONS, (WPARAM)RTL_NUMBER_OF(tbButtons), (LPARAM)&tbButtons);
    SendMessage(hWndToolbar, TB_AUTOSIZE, 0, 0);
}

/*
* supSetProcessMitigationImagesPolicy
*
* Purpose:
*
* Enable images policy mitigation.
*
* N.B. Must be called after plugin manager initialization.
*
*/
VOID supSetProcessMitigationImagesPolicy()
{
    PROCESS_MITIGATION_POLICY_INFORMATION policyInfo;

    if (g_kdctx.MitigationFlags.Signature) {

        policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessSignaturePolicy;
        policyInfo.SignaturePolicy.Flags = 0;
        policyInfo.SignaturePolicy.MicrosoftSignedOnly = TRUE;
        policyInfo.SignaturePolicy.MitigationOptIn = TRUE;

        NtSetInformationProcess(NtCurrentProcess(),
            ProcessMitigationPolicy,
            &policyInfo,
            sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    }

    if (g_kdctx.MitigationFlags.ImageLoad) {

        policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessImageLoadPolicy;
        policyInfo.ImageLoadPolicy.Flags = 0;
        policyInfo.ImageLoadPolicy.PreferSystem32Images = TRUE;
        policyInfo.ImageLoadPolicy.NoLowMandatoryLabelImages = TRUE;

        NtSetInformationProcess(NtCurrentProcess(),
            ProcessMitigationPolicy,
            &policyInfo,
            sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    }
}

/*
* supxSetProcessMitigationPolicies
*
* Purpose:
*
* Enable mitigations.
*
*/
VOID supxSetProcessMitigationPolicies()
{
    PROCESS_MITIGATION_POLICY_INFORMATION policyInfo;

    if (g_kdctx.MitigationFlags.ExtensionPointDisable) {

        policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessExtensionPointDisablePolicy;
        policyInfo.ExtensionPointDisablePolicy.Flags = 0;
        policyInfo.ExtensionPointDisablePolicy.DisableExtensionPoints = TRUE;

        NtSetInformationProcess(NtCurrentProcess(),
            ProcessMitigationPolicy,
            &policyInfo,
            sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

    }

    if (g_kdctx.MitigationFlags.ASLRPolicy) {
        policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessASLRPolicy;
        policyInfo.ASLRPolicy.Flags = 0;
        policyInfo.ASLRPolicy.EnableHighEntropy = TRUE;
        policyInfo.ASLRPolicy.EnableBottomUpRandomization = TRUE;
        policyInfo.ASLRPolicy.EnableForceRelocateImages = TRUE;

        NtSetInformationProcess(NtCurrentProcess(),
            ProcessMitigationPolicy,
            &policyInfo,
            sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));
    }

    if (g_kdctx.MitigationFlags.DynamicCode) {

        //
        // Disabled due to multiple incompatibilities, including their own HtmlHelp functions
        // Fixes WOX2007-005.
        //
        if (g_NtBuildNumber > NT_WIN8_BLUE) {

            policyInfo.Policy = (PROCESS_MITIGATION_POLICY)ProcessDynamicCodePolicy;
            policyInfo.DynamicCodePolicy.Flags = 0;
            policyInfo.DynamicCodePolicy.ProhibitDynamicCode = TRUE;

            NtSetInformationProcess(NtCurrentProcess(),
                ProcessMitigationPolicy,
                &policyInfo,
                sizeof(PROCESS_MITIGATION_POLICY_INFORMATION));

        }
    }
}

/*
* supxFreeCurrentObjectList
*
* Purpose:
*
* Destroy object path heap.
*
* Must be called once during program shutdown once
*
*/
BOOL supxFreeCurrentObjectList(
    _In_ PVOID Unused
)
{
    UNREFERENCED_PARAMETER(Unused);

    if (ObjectPathHeap)
        supDestroyHeap(ObjectPathHeap);

    return TRUE;
}

/*
* supInit
*
* Purpose:
*
* Initializes support subset related resources including kldbg subset.
*
* Must be called once during program startup
*
*/
VOID supInit(
    _In_ BOOLEAN IsFullAdmin
)
{
    WCHAR szError[200];
    NTSTATUS status;

    RtlInitializeCriticalSection(&supShutdownListLock);
    InitializeListHead(&supShutdownListHead);

    supxSetProcessMitigationPolicies();

#pragma warning(push)
#pragma warning(disable: 6031)
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
#pragma warning(pop)

    kdInit(IsFullAdmin);

    RtlInitializeCriticalSection(&g_sapiDB.Lock);
    RtlInitializeCriticalSection(&g_scmDB.Lock);

    if (IsFullAdmin) supCreateSCMSnapshot(SERVICE_DRIVER, NULL);
    sapiCreateSetupDBSnapshot();

    status = ExApiSetInit();
    if (!NT_SUCCESS(status)) {
        _strcpy(szError, TEXT("ExApiSetInit() failed, 0x"));
        ultohex(status, _strend(szError));
        logAdd(EntryTypeError, szError);
    }

    //
    // Remember current DPI value.
    // 
    g_WinObj.CurrentDPI = supGetDPIValue(NULL);
    supAddShutdownCallback(supxFreeCurrentObjectList, NULL);
}

/*
* supAddShutdownCallback
*
* Purpose:
*
* Allocate shutdown callback entry and insert it to the list.
*
*/
VOID supAddShutdownCallback(
    _In_ PSUPSHUTDOWNCALLBACK Callback,
    _In_opt_ PVOID Context
)
{
    SUP_SHUTDOWN_CALLBACK* entry;

    entry = (SUP_SHUTDOWN_CALLBACK*)supHeapAlloc(sizeof(SUP_SHUTDOWN_CALLBACK));
    if (entry == NULL)
        return;

    entry->Callback = Callback;
    entry->Context = Context;

    EnterCriticalSection(&supShutdownListLock);
    InsertHeadList(&supShutdownListHead, &entry->ListEntry);
    LeaveCriticalSection(&supShutdownListLock);
}

/*
* supxCallShutdownCallbacks
*
* Purpose:
*
* Call each shutdown callback entry and free list.
*
*/
VOID supxCallShutdownCallbacks(
    VOID
)
{
    PLIST_ENTRY entry, listHead, nextEntry;
    SUP_SHUTDOWN_CALLBACK* callback;

    EnterCriticalSection(&supShutdownListLock);

    listHead = &supShutdownListHead;

    for (entry = listHead->Flink, nextEntry = entry->Flink;
        entry != listHead;
        entry = nextEntry, nextEntry = entry->Flink)
    {
        callback = CONTAINING_RECORD(entry, SUP_SHUTDOWN_CALLBACK, ListEntry);
        callback->Callback(callback->Context);
        supHeapFree(callback);
    }

    LeaveCriticalSection(&supShutdownListLock);
}

/*
* supShutdown
*
* Purpose:
*
* Free support subset related resources.
*
* Must be called once at the end of program execution.
*
*/
VOID supShutdown(
    VOID
)
{
    kdShutdown();

    supFreeSCMSnapshot(NULL);
    sapiFreeSnapshot();

    RtlDeleteCriticalSection(&g_sapiDB.Lock);
    RtlDeleteCriticalSection(&g_scmDB.Lock);

    supxCallShutdownCallbacks();
    RtlDeleteCriticalSection(&supShutdownListLock);
}

/*
* supxEnumServicesStatus
*
* Purpose:
*
* Enumerate services status to the buffer.
*
*/
BOOL supxEnumServicesStatus(
    _In_ SC_HANDLE schSCManager,
    _In_ ULONG ServiceType,
    _Out_ PBYTE * Services,
    _Out_ DWORD * ServicesReturned
)
{
    LPBYTE servicesBuffer = NULL;
    DWORD dwSize = 64 * 1024, dwSizeNeeded = 0, dwNumServices = 0, dwResume = 0;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cMaxLoops = 4, cLoop = 0;

    do {

        servicesBuffer = (LPBYTE)supHeapAlloc(dwSize);
        if (servicesBuffer == NULL)
            break;

        dwError = ERROR_SUCCESS;
        dwResume = 0;

        if (!EnumServicesStatusEx(
            schSCManager,
            SC_ENUM_PROCESS_INFO,
            ServiceType,
            SERVICE_STATE_ALL,
            servicesBuffer,
            dwSize,
            &dwSizeNeeded,
            &dwNumServices,
            &dwResume,
            NULL))
        {
            dwError = GetLastError();
            supHeapFree(servicesBuffer);
            dwSize += dwSizeNeeded;
        }

    } while ((dwError == ERROR_MORE_DATA) && (++cLoop < cMaxLoops));

    if ((dwError == ERROR_SUCCESS) && dwNumServices) {
        *ServicesReturned = dwNumServices;
        *Services = servicesBuffer;
    }
    else {
        if (servicesBuffer)
            supHeapFree(servicesBuffer);

        *ServicesReturned = 0;
        *Services = NULL;
    }

    return (dwNumServices > 0);
}

/*
* supCreateSCMSnapshot
*
* Purpose:
*
* Collects SCM information for drivers description.
*
* Use supFreeSCMSnapshot to free returned buffer.
*
*/
BOOL supCreateSCMSnapshot(
    _In_ ULONG ServiceType,
    _Out_opt_ SCMDB * Snapshot
)
{
    SC_HANDLE schSCManager;
    DWORD     dwNumServices = 0;
    PVOID     Services = NULL;

    if (Snapshot) {
        Snapshot->Entries = NULL;
        Snapshot->NumberOfEntries = 0;
    }

    schSCManager = OpenSCManager(NULL, NULL,
        SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    if (schSCManager) {

        if (supxEnumServicesStatus(schSCManager,
            ServiceType,
            (PBYTE*)&Services,
            &dwNumServices))
        {
            if (Snapshot) {
                Snapshot->Entries = Services;
                Snapshot->NumberOfEntries = dwNumServices;
            }
            else {
                EnterCriticalSection(&g_scmDB.Lock);
                g_scmDB.Entries = Services;
                g_scmDB.NumberOfEntries = dwNumServices;
                LeaveCriticalSection(&g_scmDB.Lock);
            }
        }

        CloseServiceHandle(schSCManager);
    }

    return (dwNumServices > 0);
}

/*
* supFreeSCMSnapshot
*
* Purpose:
*
* Destroys SCM snapshot buffer.
*
*/
VOID supFreeSCMSnapshot(
    _In_opt_ SCMDB * Snapshot)
{
    if (Snapshot) {
        if ((Snapshot->Entries) && (Snapshot->NumberOfEntries))
            supHeapFree(Snapshot->Entries);
        Snapshot->NumberOfEntries = 0;
        Snapshot->Entries = NULL;
    }
    else {
        EnterCriticalSection(&g_scmDB.Lock);
        __try {
            supHeapFree(g_scmDB.Entries);
            g_scmDB.Entries = NULL;
            g_scmDB.NumberOfEntries = 0;
        }
        __finally {
            LeaveCriticalSection(&g_scmDB.Lock);
        }
    }
}

/*
* sapiQueryDeviceProperty
*
* Purpose:
*
* Query Device Propery from snapshot data.
*
*/
BOOL sapiQueryDeviceProperty(
    _In_ HANDLE SnapshotHeap,
    _In_ HDEVINFO hDevInfo,
    _In_ SP_DEVINFO_DATA * pDevInfoData,
    _In_ ULONG Property,
    _Out_ LPWSTR * PropertyBuffer,
    _Out_opt_ ULONG * PropertyBufferSize
)
{
    BOOL   result;
    DWORD  dataType = 0, dataSize, returnLength = 0;
    LPWSTR lpProperty;

    *PropertyBuffer = NULL;

    if (PropertyBufferSize)
        *PropertyBufferSize = 0;

    dataSize = (MAX_PATH * sizeof(WCHAR)) + sizeof(UNICODE_NULL);
    lpProperty = (LPWSTR)supHeapAllocEx(SnapshotHeap, dataSize);
    if (lpProperty == NULL)
        return FALSE;

    result = SetupDiGetDeviceRegistryProperty(hDevInfo,
        pDevInfoData,
        Property,
        &dataType,
        (PBYTE)lpProperty,
        dataSize,
        &returnLength);

    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

        supHeapFreeEx(SnapshotHeap, lpProperty);
        dataSize = returnLength;
        lpProperty = (LPWSTR)supHeapAllocEx(SnapshotHeap, dataSize);
        if (lpProperty) {

            result = SetupDiGetDeviceRegistryProperty(hDevInfo,
                pDevInfoData,
                Property,
                &dataType,
                (PBYTE)lpProperty,
                dataSize,
                &returnLength);

        }

    }

    if (!result) {
        if (lpProperty) {
            supHeapFreeEx(SnapshotHeap, lpProperty);
            lpProperty = NULL;
        }
        dataSize = 0;
    }

    *PropertyBuffer = lpProperty;
    if (PropertyBufferSize)
        *PropertyBufferSize = dataSize;
    return result;
}

/*
* sapiCreateSetupDBSnapshot
*
* Purpose:
*
* Collects Setup API information to the linked list.
*
*/
BOOL sapiCreateSetupDBSnapshot(
    VOID
)
{
    BOOL            bResult = FALSE, bFailed = FALSE;
    DWORD           i, ReturnedDataSize = 0;
    SP_DEVINFO_DATA DeviceInfoData;
    PSAPIDBENTRY    Entry;
    HANDLE          Heap;
    HDEVINFO        hDevInfo;

    Heap = supCreateHeap(HEAP_GROWABLE, TRUE);
    if (Heap == NULL) {
        return FALSE;
    }

    g_sapiDB.HeapHandle = Heap;

    hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);
    if (hDevInfo != INVALID_HANDLE_VALUE) {

        InitializeListHead(&g_sapiDB.ListHead);

        RtlSecureZeroMemory(&DeviceInfoData, sizeof(DeviceInfoData));
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        for (i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &DeviceInfoData); i++) {

            Entry = (PSAPIDBENTRY)supHeapAllocEx(Heap, sizeof(SAPIDBENTRY));
            if (Entry == NULL) {
                bFailed = TRUE;
                break;
            }

            //
            // Query Device Name.
            //
            sapiQueryDeviceProperty(Heap,
                hDevInfo,
                &DeviceInfoData,
                SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                &Entry->lpDeviceName,
                &ReturnedDataSize);

            //
            // Query Device Description.
            //
            sapiQueryDeviceProperty(Heap,
                hDevInfo,
                &DeviceInfoData,
                SPDRP_DEVICEDESC,
                &Entry->lpDeviceDesc,
                &ReturnedDataSize);

            InsertHeadList(&g_sapiDB.ListHead, &Entry->ListEntry);

        }

        SetupDiDestroyDeviceInfoList(hDevInfo);

        if (bFailed == FALSE)
            bResult = TRUE;
    }

    if (bFailed) {
        supDestroyHeap(Heap);
        RtlSecureZeroMemory(&g_sapiDB, sizeof(g_sapiDB));
    }
    return bResult;
}

/*
* sapiFreeSnapshot
*
* Purpose:
*
* Destroys snapshot heap and zero linked list.
*
*/
VOID sapiFreeSnapshot(
    VOID
)
{
    EnterCriticalSection(&g_sapiDB.Lock);

    __try {
        supDestroyHeap(g_sapiDB.HeapHandle);
        g_sapiDB.HeapHandle = NULL;
        g_sapiDB.ListHead.Blink = NULL;
        g_sapiDB.ListHead.Flink = NULL;
    }
    __finally {
        LeaveCriticalSection(&g_sapiDB.Lock);
    }
}

/*
* supCallbackShowChildWindow
*
* Purpose:
*
* Makes window controls (in)visible in the given rectangle type dialog
*
*/
BOOL WINAPI supCallbackShowChildWindow(
    _In_ HWND hwnd,
    _In_ LPARAM lParam
)
{
    RECT r1;
    ENUMCHILDWNDDATA* Data = (PENUMCHILDWNDDATA)lParam;

    if (GetWindowRect(hwnd, &r1)) {
        if (PtInRect(&Data->Rect, *(POINT*)&r1))
            ShowWindow(hwnd, Data->nCmdShow);
    }
    return TRUE;
}

/*
* supQueryWinstationDescription
*
* Purpose:
*
* Query predefined window station types, if found equal copy to buffer it friendly name.
*
* Input buffer size must be at least MAX_PATH size.
*
*/
BOOL supQueryWinstationDescription(
    _In_ LPCWSTR lpWindowStationName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cchBuffer //size of buffer in chars
)
{
    BOOL    bFound = FALSE;
    LPCWSTR lpType = T_UnknownType;

    ULONG i;

    struct {
        LPCWSTR lpszWinSta;
        LPCWSTR lpszDesc;
    } lpWinstationDescriptions[] = {
        { T_WINSTA_SYSTEM, L"System" },
        { T_WINSTA_ANONYMOUS, L"Anonymous" },
        { T_WINSTA_LOCALSERVICE, L"Local Service" },
        { T_WINSTA_NETWORK_SERVICE, L"Network Service" }
    };

    if (lpWindowStationName == NULL ||
        cchBuffer < MAX_PATH)
    {
        return bFound;
    }

    for (i = 0; i < RTL_NUMBER_OF(lpWinstationDescriptions); i++) {

        bFound = (_strstri(lpWindowStationName,
            lpWinstationDescriptions[i].lpszWinSta) != NULL);

        if (bFound) {
            lpType = lpWinstationDescriptions[i].lpszDesc;
            break;
        }

    }

    _strcpy(Buffer, lpType);
    _strcat(Buffer, TEXT(" logon session"));

    return bFound;
}

/*
* supQueryTypeInfo
*
* Purpose:
*
* Query specific type info for output in listview.
*
* Input buffer size must be at least MAX_PATH size.
*
*/
BOOL supQueryTypeInfo(
    _In_ PUNICODE_STRING TypeName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD BufferSize, //size of buffer in chars
    _In_ DWORD KnownPoolTypesCount,
    _In_ PVALUE_DESC PoolTypes
)
{
    BOOL  bResult = FALSE;
    ULONG i, nPool;

    POBTYPE_LIST objectTypesList;
    POBTYPE_ENTRY objectEntry;

    if (Buffer == NULL ||
        BufferSize < MAX_PATH)
    {
        return FALSE;
    }

    objectTypesList = g_kdctx.Data->ObjectTypesList;
    if (objectTypesList == NULL)
        return FALSE;

    for (i = 0; i < objectTypesList->NumberOfTypes; i++) {

        objectEntry = &objectTypesList->Types[i];

        if (RtlEqualUnicodeString(objectEntry->TypeName, TypeName, TRUE)) {

            for (nPool = 0; nPool < KnownPoolTypesCount; nPool++) {
                if (objectEntry->PoolType == PoolTypes[nPool].dwValue) {
                    _strncpy(Buffer,
                        BufferSize,
                        PoolTypes[nPool].lpDescription,
                        _strlen(PoolTypes[nPool].lpDescription));
                    break;
                }
            }

            bResult = TRUE;
            break;
        }

    }

    return bResult;
}

/*
* supQueryDeviceDescription
*
* Purpose:
*
* Query device description from Setup API DB dump.
*
* Buffer should be at least MAX_PATH length in chars.
*
*/
BOOL supQueryDeviceDescription(
    _In_opt_ PUNICODE_STRING Path,
    _In_ PUNICODE_STRING Name,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cchBuffer //size of buffer in chars
)
{
    BOOL         bResult;
    PLIST_ENTRY  Entry;
    PSAPIDBENTRY Item;
    SIZE_T       deviceLength;

    UNICODE_STRING deviceName;

    bResult = FALSE;

    RtlInitEmptyUnicodeString(&deviceName, NULL, 0);

    if (Path == NULL) {
        if (!supCreateObjectPathFromCurrentPath(Name, &deviceName, TRUE))
            return FALSE;
    }
    else {
        if (!supCreateObjectPathFromElements(Name, Path, &deviceName, TRUE))
            return FALSE;
    }

    EnterCriticalSection(&g_sapiDB.Lock);

    //
    // Enumerate devices.
    //
    Entry = g_sapiDB.ListHead.Flink;
    while (Entry && Entry != &g_sapiDB.ListHead) {

        Item = CONTAINING_RECORD(Entry, SAPIDBENTRY, ListEntry);
        if (Item->lpDeviceName != NULL) {

            //
            // lpDeviceName expects to be zero terminated.
            //
            deviceLength = _strlen(deviceName.Buffer);

            if (_strncmpi(deviceName.Buffer, Item->lpDeviceName, deviceLength) == 0) {

                if (Item->lpDeviceDesc != NULL) {

                    _strncpy(
                        Buffer,
                        cchBuffer,
                        Item->lpDeviceDesc,
                        _strlen(Item->lpDeviceDesc));

                }
                bResult = TRUE;
                break;
            }
        }

        Entry = Entry->Flink;
    }

    LeaveCriticalSection(&g_sapiDB.Lock);

    supFreeDuplicatedUnicodeString(g_obexHeap, &deviceName, FALSE);
    return bResult;
}

/*
* supQueryDriverDescription
*
* Purpose:
*
* Query driver description from SCM dump or from file version info
*
* Buffer should be at least MAX_PATH length in chars.
*
*/
BOOL supQueryDriverDescription(
    _In_ LPCWSTR lpDriverName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cchBuffer //size of buffer in chars
)
{
    BOOL    bResult;
    LPWSTR  lpServiceName = NULL;
    LPWSTR  lpDisplayName = NULL;
    LPWSTR  lpRegKey = NULL;
    SIZE_T  i, sz;

    PVOID   vinfo = NULL;
    DWORD   dwSize, dwHandle;
    LRESULT lRet;
    HKEY    hKey = NULL;

    WCHAR   szBuffer[MAX_PATH + 1];
    WCHAR   szImagePath[MAX_PATH + 1];

    LPTRANSLATE	                  lpTranslate = NULL;
    LPENUM_SERVICE_STATUS_PROCESS pInfo = NULL;

    bResult = FALSE;

    //
    // First attempt - look in SCM database.
    //

    RtlEnterCriticalSection(&g_scmDB.Lock);

    if (g_scmDB.Entries != NULL) {
        pInfo = (LPENUM_SERVICE_STATUS_PROCESS)g_scmDB.Entries;
        for (i = 0; i < g_scmDB.NumberOfEntries; i++) {

            lpServiceName = pInfo[i].lpServiceName;
            if (lpServiceName == NULL)
                continue;

            // not our driver - skip
            if (_strcmpi(lpServiceName, lpDriverName) != 0)
                continue;

            lpDisplayName = pInfo[i].lpDisplayName;
            if (lpDisplayName == NULL)
                continue;

            // driver has the same name as service - skip, there is no description available
            if (_strcmpi(lpDisplayName, lpDriverName) == 0)
                continue;

            sz = _strlen(lpDisplayName);
            _strncpy(Buffer, cchBuffer, lpDisplayName, sz);
            bResult = TRUE;
            break;
        }
    }

    RtlLeaveCriticalSection(&g_scmDB.Lock);

    // second attempt - query through registry and fs
    if (bResult == FALSE) {

        do {
            sz = _strlen(lpDriverName);
            if (sz == 0)
                break;

            sz += supServicesRegPathSize;
            sz = (1 + sz) * sizeof(WCHAR);

            lpRegKey = (LPWSTR)supHeapAlloc(sz);
            if (lpRegKey == NULL)
                break;

            _strcpy(lpRegKey, supServicesRegPath);
            _strcat(lpRegKey, lpDriverName);

            hKey = NULL;
            lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegKey, 0, KEY_QUERY_VALUE, &hKey);
            if (ERROR_SUCCESS != lRet)
                break;

            RtlSecureZeroMemory(szImagePath, sizeof(szImagePath));
            dwSize = sizeof(szImagePath) - sizeof(UNICODE_NULL);
            lRet = RegQueryValueEx(hKey, TEXT("ImagePath"), NULL, NULL, (LPBYTE)szImagePath, &dwSize);
            RegCloseKey(hKey);
            hKey = NULL;

            if (ERROR_SUCCESS == lRet) {

                dwHandle = 0;
                dwSize = GetFileVersionInfoSizeEx(0, szImagePath, &dwHandle);
                if (dwSize == 0)
                    break;

                // allocate memory for version_info structure
                vinfo = supHeapAlloc(dwSize);
                if (vinfo == NULL)
                    break;

                // query it from file
                if (!GetFileVersionInfoEx(0, szImagePath, 0, dwSize, vinfo))
                    break;

                // query codepage and language id info
                dwSize = 0;
                if (!VerQueryValue(vinfo, T_VERSION_TRANSLATION, (LPVOID*)&lpTranslate, (PUINT)&dwSize))
                    break;

                if (dwSize == 0)
                    break;

                // query filedescription from file with given codepage & language id
                RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

                RtlStringCchPrintfSecure(szBuffer,
                    MAX_PATH,
                    FORMAT_VERSION_DESCRIPTION,
                    lpTranslate[0].wLanguage,
                    lpTranslate[0].wCodePage);

                // finally query pointer to version_info filedescription block data
                lpDisplayName = NULL;
                dwSize = 0;
                bResult = VerQueryValue(vinfo, szBuffer, (LPVOID*)&lpDisplayName, (PUINT)&dwSize);
                if (bResult) {
                    _strncpy(Buffer, cchBuffer, lpDisplayName, dwSize);
                }

            }

        } while (FALSE);

        if (vinfo) {
            supHeapFree(vinfo);
        }
        if (lpRegKey) {
            supHeapFree(lpRegKey);
        }

        if (hKey != NULL) {
            RegCloseKey(hKey);
        }
    }
    return bResult;
}

/*
* supGetVersionInfoFromSection
*
* Purpose:
*
* Return RT_VERSION data and size in VERSION.DLL friendly view.
*
*/
BOOL supGetVersionInfoFromSection(
    _In_ HANDLE SectionHandle,
    _Out_opt_ PDWORD VersionInfoSize,
    _Out_ LPVOID * VersionData
)
{
    HANDLE sectionHandle = NULL;
    VERHEAD* pVerHead = NULL;
    ULONG_PTR idPath[3];
    PBYTE dataPtr = NULL, dllBase = NULL;
    PVOID versionPtr = NULL;
    SIZE_T dllVirtualSize = 0, verSize = 0;
    ULONG_PTR sizeOfData = 0;
    NTSTATUS ntStatus;
    DWORD dwTemp = 0;

    idPath[0] = (ULONG_PTR)RT_VERSION; //type
    idPath[1] = 1;                     //id
    idPath[2] = 0;                     //lang

    if (VersionInfoSize)
        *VersionInfoSize = 0;

    if (VersionData)
        *VersionData = NULL;
    else
        return FALSE; //this param is required

    __try {

        ntStatus = NtDuplicateObject(NtCurrentProcess(),
            SectionHandle,
            NtCurrentProcess(),
            &sectionHandle,
            SECTION_MAP_READ,
            0,
            0);

        if (!NT_SUCCESS(ntStatus)) {
            supReportAPIError(__FUNCTIONW__, ntStatus);
            __leave;
        }

        ntStatus = NtMapViewOfSection(sectionHandle, NtCurrentProcess(), (PVOID*)&dllBase,
            0, 0, NULL, &dllVirtualSize, ViewUnmap, 0, PAGE_READONLY);
        if (!NT_SUCCESS(ntStatus)) {
            supReportAPIError(__FUNCTIONW__, ntStatus);
            __leave;
        }

        ntStatus = LdrResSearchResource(dllBase, (ULONG_PTR*)&idPath, 3, 0,
            (LPVOID*)&dataPtr, (ULONG_PTR*)&sizeOfData, NULL, NULL);
        if (!NT_SUCCESS(ntStatus)) {
            if ((ntStatus != STATUS_RESOURCE_DATA_NOT_FOUND) &&
                (ntStatus != STATUS_RESOURCE_TYPE_NOT_FOUND) &&
                (ntStatus != STATUS_RESOURCE_NAME_NOT_FOUND))
            {
                supReportAPIError(__FUNCTIONW__, ntStatus);
            }
            __leave;
        }

        pVerHead = (VERHEAD*)dataPtr;
        if (pVerHead->wTotLen > sizeOfData) {
            supReportAPIError(__FUNCTIONW__, STATUS_INVALID_BUFFER_SIZE);
            __leave;
        }

        if (pVerHead->vsf.dwSignature != VS_FFI_SIGNATURE) {
            supReportAPIError(__FUNCTIONW__, STATUS_INVALID_IMAGE_FORMAT);
            __leave;
        }

        dwTemp = (DWORD)pVerHead->wTotLen;
        dwTemp = DWORDUP(dwTemp);

        verSize = ((ULONG_PTR)dwTemp * 2) + VER2_SIG_LENGTH;

        if (VersionInfoSize)
            *VersionInfoSize = (DWORD)verSize;

        versionPtr = supHeapAlloc(verSize);
        if (versionPtr == NULL) {
            __leave;
        }

        RtlCopyMemory(versionPtr, pVerHead, dwTemp);

        //
        // Do as GetFileVersionInfo does.
        //
        *((PDWORD)((ULONG_PTR)versionPtr + dwTemp)) = VER2_SIG;

        *VersionData = versionPtr;

    }
    __finally {

        if (AbnormalTermination()) {

            dwTemp = 0;

            if (versionPtr)
                supHeapFree(versionPtr);

            supReportAbnormalTermination(__FUNCTIONW__);
        }

        if (dllBase)
            NtUnmapViewOfSection(NtCurrentProcess(), dllBase);

        if (sectionHandle)
            NtClose(sectionHandle);

    }

    return (dwTemp != 0);
}

/*
* supQuerySectionFileInfo
*
* Purpose:
*
* Query section object type File + Image description from version info block
*
* Buffer should be at least MAX_PATH length in chars.
*
*/
BOOL supQuerySectionFileInfo(
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING ObjectName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD ccBuffer //size of buffer in chars
)
{
    BOOL                        bResult;
    HANDLE                      hSection;
    PVOID                       vinfo;
    LPWSTR                      pcValue;
    LPTRANSLATE                 lpTranslate;
    SIZE_T                      cLength = 0;
    NTSTATUS                    status;
    DWORD                       dwInfoSize;
    OBJECT_ATTRIBUTES           Obja;
    SECTION_BASIC_INFORMATION   sbi;
    SECTION_IMAGE_INFORMATION   sii;
    WCHAR                       szQueryBlock[MAX_PATH + 1];

    bResult = FALSE;
    vinfo = NULL;
    hSection = NULL;

    do {
        //oleaut32.dll does not have FileDescription

        //  open section with query access
        InitializeObjectAttributes(&Obja, ObjectName, OBJ_CASE_INSENSITIVE, RootDirectoryHandle, NULL);
        status = NtOpenSection(&hSection, SECTION_QUERY, &Obja);
        if (!NT_SUCCESS(status))
            break;

        //  query section flags
        RtlSecureZeroMemory(&sbi, sizeof(sbi));
        status = NtQuerySection(hSection, SectionBasicInformation, (PVOID)&sbi, sizeof(sbi), &cLength);
        if (!NT_SUCCESS(status))
            break;

        //  check if section is SEC_IMAGE | SEC_FILE
        if (!((sbi.AllocationAttributes & SEC_IMAGE) && (sbi.AllocationAttributes & SEC_FILE)))
            break;

        // check image machine type
        RtlSecureZeroMemory(&sii, sizeof(sii));
        status = NtQuerySection(hSection, SectionImageInformation, (PVOID)&sii, sizeof(sii), &cLength);
        if (!NT_SUCCESS(status))
            break;

        if (!supGetVersionInfoFromSection(hSection, NULL, &vinfo))
            break;

        if (vinfo == NULL)
            break;

        // query codepage and language id info
        if (!VerQueryValue(vinfo, T_VERSION_TRANSLATION, (LPVOID*)&lpTranslate, (PUINT)&dwInfoSize))
            break;
        if (dwInfoSize == 0)
            break;

        // query filedescription from file with given codepage & language id
        RtlSecureZeroMemory(szQueryBlock, sizeof(szQueryBlock));

        RtlStringCchPrintfSecure(szQueryBlock,
            MAX_PATH,
            FORMAT_VERSION_DESCRIPTION,
            lpTranslate[0].wLanguage,
            lpTranslate[0].wCodePage);

        // finally query pointer to version_info filedescription block data
        pcValue = NULL;
        dwInfoSize = 0;
        bResult = VerQueryValue(vinfo, szQueryBlock, (LPVOID*)&pcValue, (PUINT)&dwInfoSize);
        if (bResult) {
            _strncpy(Buffer, ccBuffer, pcValue, dwInfoSize);
        }

    } while (FALSE);

    if (hSection) NtClose(hSection);
    if (vinfo) supHeapFree(vinfo);
    return bResult;
}

/*
* supSaveDialogExecute
*
* Purpose:
*
* Display SaveDialog.
*
*/
BOOL supSaveDialogExecute(
    _In_ HWND OwnerWindow,
    _Inout_ LPWSTR SaveFileName,
    _In_ LPCWSTR DialogFilter
)
{
    OPENFILENAME tag1;

    RtlSecureZeroMemory(&tag1, sizeof(OPENFILENAME));

    tag1.lStructSize = sizeof(OPENFILENAME);
    tag1.hwndOwner = OwnerWindow;
    tag1.lpstrFilter = DialogFilter;
    tag1.lpstrFile = SaveFileName;
    tag1.nMaxFile = MAX_PATH;
    tag1.lpstrInitialDir = NULL;
    tag1.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    return GetSaveFileName(&tag1);
}

/*
* supSetListViewSettings
*
* Purpose:
*
* Set listview imagelist, style flags and theme.
*
*/
VOID supSetListViewSettings(
    _In_ HWND hwndLV,
    _In_ DWORD dwExtendedStyle,
    _In_ BOOL fIgnoreGlobalSettings,
    _In_ BOOL fSetTheme,
    _In_opt_ HIMAGELIST hImageList,
    _In_ INT iImageList
)
{
    DWORD dwFlags = dwExtendedStyle;

    if (!fIgnoreGlobalSettings) {
        if (g_WinObj.ListViewDisplayGrid)
            dwFlags |= LVS_EX_GRIDLINES;
    }

    ListView_SetExtendedListViewStyle(hwndLV, dwFlags);

    if (hImageList) {
        ListView_SetImageList(hwndLV, hImageList, iImageList);
    }

    if (fSetTheme) {
        SetWindowTheme(hwndLV, TEXT("Explorer"), NULL);
    }
}

/*
* supGetStockIcon
*
* Purpose:
*
* Retrieve stock icon of given id.
*
*/
HICON supGetStockIcon(
    _In_ SHSTOCKICONID siid,
    _In_ UINT uFlags)
{
    SHSTOCKICONINFO sii;

    RtlSecureZeroMemory(&sii, sizeof(sii));
    sii.cbSize = sizeof(sii);

    if (SHGetStockIconInfo(siid, uFlags, &sii) == S_OK) {
        return sii.hIcon;
    }
    return NULL;
}

//
// Conversion buffer size
//
#define CONVERT_NTNAME_BUFFER_SIZE 512

/*
* supxConvertFileName
*
* Purpose:
*
* Translate Nt path name to Dos path name.
*
*/
BOOL supxConvertFileName(
    _In_ LPWSTR NtFileName,
    _Inout_ LPWSTR DosFileName,
    _In_ SIZE_T ccDosFileName
)
{
    BOOL bFound = FALSE;

    SIZE_T nLen;

    WCHAR szDrive[3];
    WCHAR szName[MAX_PATH];
    WCHAR szTemp[CONVERT_NTNAME_BUFFER_SIZE];
    WCHAR* pszTemp;

    //
    // All input parameters are validated by caller before.
    //

    //
    // Drive template.
    //
    szDrive[0] = L'X';
    szDrive[1] = L':';
    szDrive[2] = 0;

    //
    // Query array of logical disk drive strings.
    //
    szTemp[0] = 0;
    if (GetLogicalDriveStrings(RTL_NUMBER_OF(szTemp), szTemp) == 0)
        return FALSE;

    pszTemp = szTemp;

    do {

        //
        // Copy the drive letter to the template string.
        //
        *szDrive = *pszTemp;
        szName[0] = 0;

        //
        // Lookup each device name.
        //
        if (QueryDosDevice(szDrive, szName, MAX_PATH)) {

            nLen = _strlen(szName);

            if (nLen < MAX_PATH) {

                //
                // Match device name.
                //
                bFound = ((_strncmpi(NtFileName, szName, nLen) == 0)
                    && *(NtFileName + nLen) == L'\\');

                if (bFound) {

                    //
                    // Build output name.
                    //
                    RtlStringCchPrintfSecure(
                        DosFileName,
                        ccDosFileName,
                        TEXT("%ws%ws"),
                        szDrive,
                        NtFileName + nLen);

                }

            }

        }

        //
        // Go to the next NULL character, i.e. the next drive name.
        //
        while (*pszTemp++);

    } while (!bFound && *pszTemp);

    return bFound;
}

/*
* supGetWin32FileName
*
* Purpose:
*
* Query filename by handle.
*
*/
LPWSTR supGetWin32FileName(
    _In_ LPCWSTR NtFileName
)
{
    BOOL                bResult = FALSE;
    LPWSTR              lpWin32Name = NULL;
    NTSTATUS            ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE              hFile = NULL;
    UNICODE_STRING      usNtFileName;
    OBJECT_ATTRIBUTES   obja;
    IO_STATUS_BLOCK     iost;
    ULONG               size;

    BYTE* Buffer = NULL;

    RtlInitUnicodeString(&usNtFileName, NtFileName);
    InitializeObjectAttributes(&obja, &usNtFileName, OBJ_CASE_INSENSITIVE, 0, NULL);

    do {

        ntStatus = NtCreateFile(&hFile,
            SYNCHRONIZE,
            &obja,
            &iost,
            NULL,
            0,
            FILE_SHARE_VALID_FLAGS,
            FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
            NULL, 0);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = supQueryObjectInformation(hFile,
            ObjectNameInformation,
            &Buffer,
            NULL);

        if (!NT_SUCCESS(ntStatus))
            break;

        size = UNICODE_STRING_MAX_CHARS * sizeof(WCHAR);
        lpWin32Name = (LPWSTR)supHeapAlloc(size);

        if (lpWin32Name == NULL)
            break;

        bResult = supxConvertFileName(((POBJECT_NAME_INFORMATION)Buffer)->Name.Buffer,
            lpWin32Name,
            size / sizeof(WCHAR));

    } while (FALSE);

    if (Buffer) supHeapFree(Buffer);
    if (hFile) NtClose(hFile);
    if (bResult == FALSE && lpWin32Name) {
        supHeapFree(lpWin32Name);
        lpWin32Name = NULL;
    }

    return lpWin32Name;
}

/*
* supQuerySecureBootState
*
* Purpose:
*
* Query Firmware type and SecureBoot state if firmware is EFI.
*
*/
BOOLEAN supQuerySecureBootState(
    _Out_ PBOOLEAN pbSecureBoot
)
{
    BOOLEAN bSecureBoot = FALSE;
    HKEY    hKey;
    DWORD   dwState, dwSize, returnLength;
    LSTATUS lRet;

    SYSTEM_SECUREBOOT_INFORMATION sbi;

    if (pbSecureBoot)
        *pbSecureBoot = FALSE;

    //
    // 1) query firmware environment variable, will not work if not fulladmin.
    //
    if (supEnablePrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE, TRUE)) {

        bSecureBoot = FALSE;

        returnLength = GetFirmwareEnvironmentVariable(
            L"SecureBoot",
            L"{8be4df61-93ca-11d2-aa0d-00e098032b8c}",
            &bSecureBoot,
            sizeof(BOOLEAN));

        supEnablePrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE, FALSE);
        if (returnLength != 0) {
            if (pbSecureBoot) {
                *pbSecureBoot = bSecureBoot;
            }
            return TRUE;
        }
    }

    //
    // 2) NtQSI(SystemSecureBootInformation).
    //
    RtlSecureZeroMemory(&sbi, sizeof(sbi));
    if (NT_SUCCESS(NtQuerySystemInformation(SystemSecureBootInformation,
        &sbi,
        sizeof(SYSTEM_SECUREBOOT_INFORMATION),
        &returnLength)))
    {
        if (sbi.SecureBootCapable == FALSE) {
            if (pbSecureBoot)
                *pbSecureBoot = FALSE;
        }
        else {
            if (pbSecureBoot)
                *pbSecureBoot = sbi.SecureBootEnabled;
        }

        return TRUE;
    }

    //
    // 3) Query state from registry.
    //
    hKey = NULL;
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, T_SECUREBOOTSTATEKEY, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {
        dwState = 0;
        dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey, T_SECUREBOOTSTATEVALUE, NULL, NULL, (LPBYTE)&dwState, &dwSize);
        RegCloseKey(hKey);

        if (lRet == ERROR_SUCCESS) {

            if (pbSecureBoot) {
                *pbSecureBoot = (dwState == 1);
            }
            return TRUE;
        }
    }

    //
    // 4) Query state from user shared data.
    //
    dwState = USER_SHARED_DATA->DbgSecureBootEnabled;
    if (pbSecureBoot) {
        *pbSecureBoot = (dwState == 1);
        return TRUE;
    }

    return FALSE;
}

/*
* supxGetWindowStationName
*
* Purpose:
*
* Build current windows station object path based on SessionId value from PEB.
*
*/
BOOLEAN supxGetWindowStationName(
    _Out_ UNICODE_STRING * pusWinstaName
)
{
    LPWSTR WindowStationsDir = L"\\Windows\\WindowStations";
    LPWSTR SourceString;
    ULONG SessionId = NtCurrentPeb()->SessionId;

    WCHAR szWinsta[MAX_PATH];

    if (SessionId) {
        _strcpy(szWinsta, L"\\Sessions\\");
        ultostr(SessionId, _strend(szWinsta));
        _strcat(szWinsta, WindowStationsDir);
        SourceString = szWinsta;
    }
    else {
        SourceString = WindowStationsDir;
    }
    return RtlCreateUnicodeString(pusWinstaName, SourceString);
}

/*
* supOpenWindowStationFromContext
*
* Purpose:
*
* Open Window station with hardcoded object path check.
*
*/
HWINSTA supOpenWindowStationFromContext(
    _In_ PROP_OBJECT_INFO * Context,
    _In_ BOOL fInherit,
    _In_ ACCESS_MASK dwDesiredAccess)
{
    HWINSTA hObject = NULL;
    UNICODE_STRING CurrentWinstaDir;

    DWORD LastError = ERROR_ACCESS_DENIED;

    if (supxGetWindowStationName(&CurrentWinstaDir)) {
        if (RtlEqualUnicodeString(&Context->NtObjectPath, &CurrentWinstaDir, TRUE)) {
            hObject = OpenWindowStation(Context->NtObjectName.Buffer, fInherit, dwDesiredAccess);
            LastError = GetLastError();
        }
        RtlFreeUnicodeString(&CurrentWinstaDir);
    }

    SetLastError(LastError);
    return hObject;
}

/*
* supQueryObjectTrustLabel
*
* Purpose:
*
* Query object trust label protection origin and level.
*
* Note: hObject must be opened with READ_CONTROL.
*
*/
NTSTATUS supQueryObjectTrustLabel(
    _In_ HANDLE hObject,
    _Out_ PULONG ProtectionType,
    _Out_ PULONG ProtectionLevel)
{
    BOOLEAN                         saclPresent = FALSE, saclDefaulted = FALSE;
    ULONG                           i;
    NTSTATUS                        ntStatus;

    PSID                            aceSID;
    PACL                            sacl = NULL;
    PACE_HEADER                     aceHeader;
    PSYSTEM_PROCESS_TRUST_LABEL_ACE ace;

    ACL_SIZE_INFORMATION            aclSize;
    PSECURITY_DESCRIPTOR            pSD = NULL;

    *ProtectionType = 0;
    *ProtectionLevel = 0;

    do {

        //
        // Query Security Descriptor for given object.
        //

        ntStatus = supQuerySecurityInformation(hObject,
            PROCESS_TRUST_LABEL_SECURITY_INFORMATION,
            &pSD,
            NULL);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        //
        // Query SACL from SD.
        //
        ntStatus = RtlGetSaclSecurityDescriptor(pSD,
            &saclPresent,
            &sacl,
            &saclDefaulted);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        if (!sacl) {
            ntStatus = STATUS_INVALID_SID;
            break;
        }

        //
        // Query SACL size.
        //
        ntStatus = RtlQueryInformationAcl(sacl,
            &aclSize,
            sizeof(aclSize),
            AclSizeInformation);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        //
        // Locate trust label ace.
        //
        for (i = 0; i < aclSize.AceCount; i++) {
            if (NT_SUCCESS(RtlGetAce(sacl, i, (PVOID*)&aceHeader))) {
                if (aceHeader->AceType == SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE) {
                    ace = (SYSTEM_PROCESS_TRUST_LABEL_ACE*)aceHeader;
                    aceSID = (PSID)(&ace->SidStart);
                    *ProtectionType = *RtlSubAuthoritySid(aceSID, 0);
                    *ProtectionLevel = *RtlSubAuthoritySid(aceSID, 1);
                    ntStatus = STATUS_SUCCESS;
                    break;
                }
            }
        }

    } while (FALSE);

    if (pSD) supHeapFree(pSD);

    return ntStatus;
}

/*
* supQueryTokenUserSid
*
* Purpose:
*
* Return SID of given token.
*
* Use supHeapFree to free memory allocated for result.
*
*/
PSID supQueryTokenUserSid(
    _In_ HANDLE ProcessToken
)
{
    PSID resultSid = NULL;
    PTOKEN_USER ptu;
    NTSTATUS status;
    ULONG sidLength = 0, allocLength;

    status = NtQueryInformationToken(
        ProcessToken,
        TokenUser,
        NULL, 0, &sidLength);

    if (status == STATUS_BUFFER_TOO_SMALL) {

        ptu = (PTOKEN_USER)supHeapAlloc(sidLength);

        if (ptu) {

            status = NtQueryInformationToken(
                ProcessToken,
                TokenUser,
                ptu,
                sidLength,
                &sidLength);

            if (NT_SUCCESS(status)) {

                allocLength = SECURITY_MAX_SID_SIZE;
                if (sidLength > allocLength)
                    allocLength = sidLength;

                resultSid = (PSID)supHeapAlloc(allocLength);
                if (resultSid) {

                    status = RtlCopySid(
                        allocLength,
                        resultSid,
                        ptu->User.Sid);

                }
            }

            supHeapFree(ptu);
        }
    }

    return (NT_SUCCESS(status)) ? resultSid : NULL;
}

/*
* supQueryProcessSid
*
* Purpose:
*
* Return SID for the given process.
*
* Use supHeapFree to free memory allocated for result.
*
*/
PSID supQueryProcessSid(
    _In_ HANDLE ProcessHandle
)
{
    HANDLE processToken = NULL;
    PSID resultSid = NULL;

    if (NT_SUCCESS(NtOpenProcessToken(
        ProcessHandle,
        TOKEN_QUERY,
        &processToken)))
    {
        resultSid = supQueryTokenUserSid(processToken);

        NtClose(processToken);
    }

    return resultSid;
}

/*
* supIsImmersiveProcess
*
* Purpose:
*
* Wrapper for IsImmersiveProcess, since it is not present on Win7.
*
*/
BOOL supIsImmersiveProcess(
    _In_ HANDLE hProcess
)
{
    if (g_ExtApiSet.IsImmersiveProcess)
        return g_ExtApiSet.IsImmersiveProcess(hProcess);

    return FALSE;
}

/*
* supIsProtectedProcess
*
* Purpose:
*
* Check if given process is protected process.
*
*/
NTSTATUS supIsProtectedProcess(
    _In_ HANDLE hProcess,
    _Out_ PBOOL pbProtected
)
{
    NTSTATUS ntStatus;
    ULONG requredLength = 0;
    PROCESS_EXTENDED_BASIC_INFORMATION exbi;

    exbi.Size = sizeof(PROCESS_EXTENDED_BASIC_INFORMATION);
    ntStatus = NtQueryInformationProcess(hProcess, ProcessBasicInformation,
        &exbi, sizeof(exbi), &requredLength);

    if (NT_SUCCESS(ntStatus)) {
        *pbProtected = (exbi.IsProtectedProcess != 0);
    }

    return ntStatus;
}

/*
* supIsLocalSystem
*
* Purpose:
*
* pbResult will be set to TRUE if current account is run by system user, FALSE otherwise.
*
* Function return operation status code.
*
*/
NTSTATUS supIsLocalSystem(
    _In_ HANDLE hToken,
    _Out_ PBOOL pbResult)
{
    BOOL                     bResult = FALSE;
    NTSTATUS                 status = STATUS_UNSUCCESSFUL;
    PSID                     SystemSid = NULL, TokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;

    //
    // Assume failure.
    //
    if (pbResult)
        *pbResult = FALSE;

    //
    // Get current user SID.
    //
    TokenSid = supQueryTokenUserSid(hToken);
    if (TokenSid == NULL)
        return status;

    //
    // Get System SID.
    //
    status = RtlAllocateAndInitializeSid(
        &NtAuth,
        1,
        SECURITY_LOCAL_SYSTEM_RID,
        0, 0, 0, 0, 0, 0, 0,
        &SystemSid);

    if (NT_SUCCESS(status)) {

        //
        // Compare SIDs.
        //
        bResult = RtlEqualSid(TokenSid, SystemSid);
        RtlFreeSid(SystemSid);
    }

    supHeapFree(TokenSid);

    if (pbResult)
        *pbResult = bResult;

    return status;
}

/*
* supIsLocalServiceSid
*
* Purpose:
*
* Check if given sid is sid of local service.
*
*/
BOOLEAN supIsLocalServiceSid(
    _In_ PSID Sid
)
{
    SID sidLocalService = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, { SECURITY_LOCAL_SERVICE_RID } };

    return RtlEqualSid(&sidLocalService, Sid);
}

/*
* supxGetSystemToken
*
* Purpose:
*
* Find winlogon process and duplicate it token.
*
*/
NTSTATUS supxGetSystemToken(
    _In_ PVOID ProcessList,
    _Out_ PHANDLE SystemToken)
{
    BOOL bSystemToken = FALSE, bEnabled = FALSE;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG NextEntryDelta = 0;
    HANDLE hObject = NULL;
    HANDLE hToken = NULL;

    ULONG WinlogonSessionId;
    UNICODE_STRING usWinlogon = RTL_CONSTANT_STRING(L"winlogon.exe");

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } List;

    *SystemToken = NULL;

    WinlogonSessionId = WTSGetActiveConsoleSessionId();
    if (WinlogonSessionId == 0xFFFFFFFF)
        return STATUS_INVALID_SESSION;

    List.ListRef = (PBYTE)ProcessList;

    do {

        List.ListRef += NextEntryDelta;

        if (RtlEqualUnicodeString(&usWinlogon, &List.Process->ImageName, TRUE)) {

            if (List.Process->SessionId == WinlogonSessionId) {

                Status = supOpenProcess(
                    List.Process->UniqueProcessId,
                    PROCESS_QUERY_LIMITED_INFORMATION,
                    &hObject);

                if (NT_SUCCESS(Status)) {

                    Status = NtOpenProcessToken(
                        hObject,
                        TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_IMPERSONATE | TOKEN_QUERY,
                        &hToken);

                    if (NT_SUCCESS(Status)) {

                        Status = supIsLocalSystem(hToken, &bSystemToken);

                        if (NT_SUCCESS(Status) && (bSystemToken)) {

                            Status = supPrivilegeEnabled(hToken, SE_TCB_PRIVILEGE, &bEnabled);
                            if (NT_SUCCESS(Status)) {
                                if (bEnabled) {
                                    NtClose(hObject);
                                    *SystemToken = hToken;
                                    return STATUS_SUCCESS;
                                }
                                else {
                                    Status = STATUS_PRIVILEGE_NOT_HELD;
                                }
                            }
                        }
                        NtClose(hToken);
                    }

                    NtClose(hObject);
                }

            }
        }

        NextEntryDelta = List.Process->NextEntryDelta;

    } while (NextEntryDelta);

    return Status;
}

/*
* supRunAsLocalSystem
*
* Purpose:
*
* Restart WinObjEx64 in local system account.
*
* Note: Elevated instance required.
*
*/
BOOL supRunAsLocalSystem(
    _In_ HWND hwndParent)
{
    BOOL bSuccess = FALSE;
    NTSTATUS Status;
    PVOID ProcessList;
    ULONG SessionId = NtCurrentPeb()->SessionId, dummy;

    HANDLE hSystemToken = NULL, hPrimaryToken = NULL, hImpersonationToken = NULL;

    BOOLEAN bThreadImpersonated = FALSE;

    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    SECURITY_QUALITY_OF_SERVICE sqos;
    OBJECT_ATTRIBUTES obja;
    TOKEN_PRIVILEGES* TokenPrivileges;

    BYTE TokenPrivBufffer[sizeof(TOKEN_PRIVILEGES) +
        (1 * sizeof(LUID_AND_ATTRIBUTES))];

    WCHAR szApplication[MAX_PATH * 2];

    //
    // Remember our application name.
    //
    RtlSecureZeroMemory(szApplication, sizeof(szApplication));
    GetModuleFileName(NULL, szApplication, MAX_PATH);

    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;
    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
    obja.SecurityQualityOfService = &sqos;

    ProcessList = supGetSystemInfo(SystemProcessInformation, NULL);
    if (ProcessList == NULL) {
        MessageBox(
            hwndParent,
            TEXT("Could not allocate process list, abort."),
            PROGRAM_NAME,
            MB_ICONINFORMATION);

        return FALSE;
    }

    //
    // Get LocalSystem token from winlogon.
    //
    Status = supxGetSystemToken(ProcessList, &hSystemToken);

    supHeapFree(ProcessList);

    do {
        //
        // Check supxGetSystemToken result.
        //
        if (!NT_SUCCESS(Status) || (hSystemToken == NULL)) {

            supShowNtStatus(hwndParent,
                TEXT("No suitable system token found. Make sure you are running as administrator, code 0x"),
                Status);

            break;
        }

        //
        // Duplicate as impersonation token.
        //
        Status = NtDuplicateToken(
            hSystemToken,
            TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY |
            TOKEN_ASSIGN_PRIMARY | TOKEN_ADJUST_PRIVILEGES,
            &obja,
            FALSE,
            TokenImpersonation,
            &hImpersonationToken);

        if (!NT_SUCCESS(Status)) {

            supShowNtStatus(hwndParent, TEXT("Error duplicating impersonation token, code 0x"), Status);
            break;
        }

        //
        // Duplicate as primary token.
        //
        Status = NtDuplicateToken(
            hSystemToken,
            TOKEN_ALL_ACCESS,
            &obja,
            FALSE,
            TokenPrimary,
            &hPrimaryToken);

        if (!NT_SUCCESS(Status)) {

            supShowNtStatus(hwndParent, TEXT("Error duplicating primary token, code 0x"), Status);
            break;
        }

        //
        // Impersonate system token.
        //
        Status = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hImpersonationToken,
            sizeof(HANDLE));

        if (!NT_SUCCESS(Status)) {

            supShowNtStatus(hwndParent, TEXT("Error while impersonating primary token, code 0x"), Status);
            break;
        }

        bThreadImpersonated = TRUE;

        //
        // Turn on AssignPrimaryToken privilege in impersonated token.
        //
        TokenPrivileges = (TOKEN_PRIVILEGES*)&TokenPrivBufffer;
        TokenPrivileges->PrivilegeCount = 1;
        TokenPrivileges->Privileges[0].Luid.LowPart = SE_ASSIGNPRIMARYTOKEN_PRIVILEGE;
        TokenPrivileges->Privileges[0].Luid.HighPart = 0;
        TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        Status = NtAdjustPrivilegesToken(
            hImpersonationToken,
            FALSE,
            TokenPrivileges,
            0,
            NULL,
            (PULONG)&dummy);

        if (!NT_SUCCESS(Status)) {
            supShowNtStatus(hwndParent, TEXT("Error adjusting token privileges, code 0x"), Status);
            break;
        }

        //
        // Set session id to primary token.
        //
        Status = NtSetInformationToken(
            hPrimaryToken,
            TokenSessionId,
            &SessionId,
            sizeof(ULONG));

        if (!NT_SUCCESS(Status)) {
            supShowNtStatus(hwndParent, TEXT("Error setting session id, code 0x"), Status);
            break;
        }

        si.cb = sizeof(si);
        GetStartupInfo(&si);

        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_SHOWNORMAL;

        //
        // Run new instance with prepared primary token.
        //
        bSuccess = CreateProcessAsUser(
            hPrimaryToken,
            szApplication,
            NULL,
            NULL,
            NULL,
            FALSE,
            CREATE_DEFAULT_ERROR_MODE,
            NULL,
            g_WinObj.szProgramDirectory,
            &si,
            &pi);

        if (bSuccess) {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        else {
            supShowLastError(hwndParent, TEXT("Run as LocalSystem"), GetLastError());
        }

    } while (FALSE);

    if (hImpersonationToken) {
        NtClose(hImpersonationToken);
    }

    //
    // Revert To Self.
    //
    if (bThreadImpersonated) {
        hImpersonationToken = NULL;
        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            (PVOID)&hImpersonationToken,
            sizeof(HANDLE));
    }

    if (hPrimaryToken) NtClose(hPrimaryToken);
    if (hSystemToken) NtClose(hSystemToken);

    //
    // Quit.
    //
    if (bSuccess)
        PostQuitMessage(0);

    return bSuccess;
}

/*
* supAddListViewColumn
*
* Purpose:
*
* Wrapper for ListView_InsertColumn.
*
*/
INT supAddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT ImageIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width
)
{
    LVCOLUMN column;

    column.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH | LVCF_ORDER | LVCF_IMAGE;
    column.fmt = Format;
    column.cx = SCALE_DPI_VALUE(Width, g_WinObj.CurrentDPI);
    column.pszText = Text;
    column.iSubItem = SubItemIndex;
    column.iOrder = OrderIndex;
    column.iImage = ImageIndex;

    return ListView_InsertColumn(ListViewHwnd, ColumnIndex, &column);
}

/*
* supUpdateLvColumnHeaderImage
*
* Purpose:
*
* Set new image for selected column and reset for all the rest.
*
*/
VOID supUpdateLvColumnHeaderImage(
    _In_ HWND ListView,
    _In_ INT NumberOfColumns,
    _In_ INT UpdateColumn,
    _In_ INT ImageIndex
)
{
    INT i;
    LVCOLUMN col;

    RtlSecureZeroMemory(&col, sizeof(col));
    col.mask = LVCF_IMAGE;

    for (i = 0; i < NumberOfColumns; i++) {
        if (i == UpdateColumn) {
            col.iImage = ImageIndex;
        }
        else {
            col.iImage = I_IMAGENONE;
        }
        ListView_SetColumn(ListView, i, &col);
    }
}

/*
* supGetMaxOfTwoUlongFromHex
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxOfTwoUlongFromHex(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL;
    ULONG     ad1, ad2;
    WCHAR     szText[MAX_TEXT_CONVERSION_ULONG64];

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    ad1 = hextoul(&lpItem1[2]);

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    ad2 = hextoul(&lpItem2[2]);

    if (Inverse)
        nResult = ad1 < ad2;
    else
        nResult = ad1 > ad2;

    return nResult;
}

/*
* supGetMaxOfTwoU64FromHex
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxOfTwoU64FromHex(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL;
    ULONG_PTR ad1, ad2;
    WCHAR     szText[MAX_TEXT_CONVERSION_ULONG64];

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    ad1 = hextou64(&lpItem1[2]);

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    ad2 = hextou64(&lpItem2[2]);

    if (Inverse)
        nResult = ad1 < ad2;
    else
        nResult = ad1 > ad2;

    return nResult;
}

/*
* supGetMaxOfTwoLongFromString
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxOfTwoLongFromString(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL;
    LONG_PTR  value1, value2;
    WCHAR     szText[MAX_TEXT_CONVERSION_ULONG64];

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    value1 = strtoi64(lpItem1);

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    value2 = strtoi64(lpItem2);

    if (Inverse)
        nResult = value1 < value2;
    else
        nResult = value1 > value2;

    return nResult;
}

/*
* supGetMaxOfTwoULongFromString
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxOfTwoULongFromString(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL;
    ULONG_PTR value1, value2;
    WCHAR     szText[MAX_TEXT_CONVERSION_ULONG64];

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    value1 = strtou64(lpItem1);

    RtlSecureZeroMemory(&szText, sizeof(szText));

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szText,
        MAX_TEXT_CONVERSION_ULONG64);

    value2 = strtou64(lpItem2);

    if (Inverse)
        nResult = value1 < value2;
    else
        nResult = value1 > value2;

    return nResult;
}

/*
* supGetMaxCompareTwoFixedStrings
*
* Purpose:
*
* Returned value used in listview comparer functions.
*
*/
INT supGetMaxCompareTwoFixedStrings(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse
)
{
    INT       nResult;
    LPWSTR    lpItem1 = NULL, lpItem2 = NULL, FirstToCompare, SecondToCompare;
    WCHAR     szString1[MAX_PATH + 1], szString2[MAX_PATH + 1];

    szString1[0] = 0;

    lpItem1 = supGetItemText2(
        ListView,
        (INT)lParam1,
        (INT)lParamSort,
        szString1,
        MAX_PATH);

    szString2[0] = 0;

    lpItem2 = supGetItemText2(
        ListView,
        (INT)lParam2,
        (INT)lParamSort,
        szString2,
        MAX_PATH);

    if (Inverse) {
        FirstToCompare = lpItem2;
        SecondToCompare = lpItem1;
    }
    else {
        FirstToCompare = lpItem1;
        SecondToCompare = lpItem2;
    }

    nResult = _strcmpi(FirstToCompare, SecondToCompare);

    return nResult;
}

/*
* supListViewBaseComparer
*
* Purpose:
*
* Base comparer for listviews.
*
*/
INT supListViewBaseComparer(
    _In_ HWND ListViewHandle,
    _In_ BOOL InverseSort,
    _In_ LPARAM FirstItem,
    _In_ LPARAM SecondItem,
    _In_ LPARAM ColumnToSort
)
{
    INT    nResult = 0;
    LPWSTR lpItem1 = NULL, lpItem2 = NULL, FirstToCompare, SecondToCompare;

    lpItem1 = supGetItemText(ListViewHandle, (INT)FirstItem, (INT)ColumnToSort, NULL);
    lpItem2 = supGetItemText(ListViewHandle, (INT)SecondItem, (INT)ColumnToSort, NULL);

    if ((lpItem1 == NULL) && (lpItem2 == NULL)) {
        nResult = 0;
        goto Done;
    }
    if ((lpItem1 == NULL) && (lpItem2 != NULL)) {
        nResult = (InverseSort) ? 1 : -1;
        goto Done;
    }
    if ((lpItem2 == NULL) && (lpItem1 != NULL)) {
        nResult = (InverseSort) ? -1 : 1;
        goto Done;
    }

    if (InverseSort) {
        FirstToCompare = lpItem2;
        SecondToCompare = lpItem1;
    }
    else {
        FirstToCompare = lpItem1;
        SecondToCompare = lpItem2;
    }

    nResult = _strcmpi(FirstToCompare, SecondToCompare);

Done:
    if (lpItem1) supHeapFree(lpItem1);
    if (lpItem2) supHeapFree(lpItem2);
    return nResult;
}

/*
* supOpenLinkedToken
*
* Purpose:
*
* Query token linked token handle.
*
*/
NTSTATUS supOpenLinkedToken(
    _In_ HANDLE TokenHandle,
    _Out_ PHANDLE LinkedTokenHandle
)
{
    ULONG rLen;
    NTSTATUS ntStatus;
    TOKEN_LINKED_TOKEN linkedToken;

    ntStatus = NtQueryInformationToken(
        TokenHandle,
        TokenLinkedToken,
        &linkedToken,
        sizeof(TOKEN_LINKED_TOKEN),
        &rLen);

    *LinkedTokenHandle = linkedToken.LinkedToken;

    return ntStatus;
}

/*
* supOpenTokenByParam
*
* Purpose:
*
* Open token handle with given desired access for process/thread.
*
*/
NTSTATUS supOpenTokenByParam(
    _In_ CLIENT_ID * ClientId,
    _In_ OBJECT_ATTRIBUTES * ObjectAttributes,
    _In_ ACCESS_MASK TokenDesiredAccess,
    _In_ BOOL IsThreadToken,
    _Out_ PHANDLE TokenHandle)
{
    NTSTATUS Status = STATUS_ACCESS_DENIED;
    HANDLE TokenOwnerHandle = NULL, ObjectHandle = NULL;

    *TokenHandle = NULL;

    if (IsThreadToken) {

        Status = NtOpenThread(&TokenOwnerHandle,
            THREAD_QUERY_INFORMATION,
            ObjectAttributes,
            ClientId);
        if (NT_SUCCESS(Status)) {
            Status = NtOpenThreadToken(TokenOwnerHandle, TokenDesiredAccess, FALSE, &ObjectHandle);
            NtClose(TokenOwnerHandle);
        }

    }
    else {

        Status = supOpenProcess(ClientId->UniqueProcess,
            PROCESS_QUERY_INFORMATION,
            &TokenOwnerHandle);
        if (NT_SUCCESS(Status)) {
            Status = NtOpenProcessToken(TokenOwnerHandle, TokenDesiredAccess, &ObjectHandle);
            NtClose(TokenOwnerHandle);
        }
    }

    *TokenHandle = ObjectHandle;

    return Status;
}

/*
* supOpenDeviceObject
*
* Purpose:
*
* Open handle for device object (NtOpenFile).
*
*/
NTSTATUS supOpenDeviceObject(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
)
{
    IO_STATUS_BLOCK iost;

    return NtOpenFile(ObjectHandle,
        DesiredAccess,
        ObjectAttributes,
        &iost,
        FILE_SHARE_VALID_FLAGS,
        0);
}

/*
* supOpenDeviceObjectEx
*
* Purpose:
*
* Open handle for device object (NtCreateFile).
*
*/
NTSTATUS supOpenDeviceObjectEx(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
)
{
    IO_STATUS_BLOCK iost;

    return NtCreateFile(ObjectHandle,
        DesiredAccess,
        ObjectAttributes,
        &iost,
        NULL,
        0,
        FILE_SHARE_VALID_FLAGS,
        FILE_OPEN,
        0,
        NULL,
        0);
}

BOOL supxCanOpenObjectType(
    _In_ UINT nTypeIndex
)
{
    UINT SupportedNamedTypes[] = {
        ObjectTypeDirectory,
        ObjectTypeDevice,
        ObjectTypeEvent,
        ObjectTypeEventPair,
        ObjectTypeIoCompletion,
        ObjectTypeJob,
        ObjectTypeKey,
        ObjectTypeKeyedEvent,
        ObjectTypeMutant,
        ObjectTypeMemoryPartition,
        ObjectTypePort,
        ObjectTypeRegistryTransaction,
        ObjectTypeSemaphore,
        ObjectTypeTimer,
        ObjectTypeSymbolicLink,
        ObjectTypeSection,
        ObjectTypeSession
    };

    UINT i;
    for (i = 0; i < RTL_NUMBER_OF(SupportedNamedTypes); i++) {
        if (SupportedNamedTypes[i] == nTypeIndex)
            return TRUE;
    }

    return FALSE;
}

/*
* supOpenNamedObjectByType
*
* Purpose:
*
* Open object of supported type and return handle to it.
*
* Supported types are list in SupportedNamedTypes array.
*
*/
NTSTATUS supOpenNamedObjectByType(
    _Out_ HANDLE * ObjectHandle,
    _In_ ULONG TypeIndex,
    _In_ PUNICODE_STRING ObjectDirectory,
    _In_ PUNICODE_STRING ObjectName,
    _In_ ACCESS_MASK DesiredAccess
)
{
    HANDLE rootHandle = NULL, objectHandle = NULL;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PNTOBJECTOPENPROCEDURE ObjectOpenProcedure = NULL;

    UNICODE_STRING portName;
    OBJECT_ATTRIBUTES obja;

    *ObjectHandle = NULL;

    if (ObjectDirectory == NULL)
        return STATUS_INVALID_PARAMETER_3;

    if (ObjectName == NULL)
        return STATUS_INVALID_PARAMETER_4;

    if (!supxCanOpenObjectType(TypeIndex))
        return STATUS_NOT_SUPPORTED;

    //
    // Special ALPC port case.
    //
    if (TypeIndex == ObjectTypePort) {

        RtlInitEmptyUnicodeString(&portName, NULL, 0);
        if (supCreateObjectPathFromElements(ObjectName,
            ObjectDirectory,
            &portName,
            TRUE))
        {
            //
            // Open port by name.
            //
            ntStatus = supOpenPortObjectByName(ObjectHandle,
                DesiredAccess,
                &portName);

            supHeapFree(portName.Buffer);
        }

        return ntStatus;
    }

    //
    // Handle directory type.
    //
    if (TypeIndex == ObjectTypeDirectory) {

        //
        // If this is root, then root rootHandle = NULL.
        //
        if (!supIsRootDirectory(ObjectName)) {
            //
            // Otherwise open directory that keep this object.
            //
            ntStatus = supOpenDirectoryEx(&rootHandle, NULL, ObjectDirectory, DIRECTORY_QUERY);
            if (!NT_SUCCESS(ntStatus))
                return ntStatus;
        }

        //
        // Open object in directory.
        //
        ntStatus = supOpenDirectoryEx(&objectHandle, rootHandle, ObjectName, DesiredAccess);

        if (rootHandle)
            NtClose(rootHandle);

        *ObjectHandle = objectHandle;
        return ntStatus;
    }

    //
    // Open directory which object belongs.
    //
    ntStatus = supOpenDirectoryEx(&rootHandle, NULL, ObjectDirectory, DIRECTORY_QUERY);
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    //
    // Select open object procedure.
    //
    switch (TypeIndex) {
    case ObjectTypeDevice:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)supOpenDeviceObject;
        break;

    case ObjectTypeMutant:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenMutant;
        break;

    case ObjectTypeKey:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenKey;
        break;

    case ObjectTypeSemaphore:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenSemaphore;
        break;

    case ObjectTypeTimer:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenTimer;
        break;

    case ObjectTypeEvent:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenEvent;
        break;

    case ObjectTypeEventPair:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenEventPair;
        break;

    case ObjectTypeKeyedEvent:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenKeyedEvent;
        break;

    case ObjectTypeSymbolicLink:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenSymbolicLinkObject;
        break;

    case ObjectTypeIoCompletion:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenIoCompletion;
        break;

    case ObjectTypeSection:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenSection;
        break;

    case ObjectTypeJob:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenJobObject;
        break;

    case ObjectTypeSession:
        ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)NtOpenSession;
        break;

    case ObjectTypeMemoryPartition:
        if (g_ExtApiSet.NtOpenPartition) {
            ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)g_ExtApiSet.NtOpenPartition;
        }
        break;
    case ObjectTypeRegistryTransaction:
        if (g_ExtApiSet.NtOpenRegistryTransaction) {
            ObjectOpenProcedure = (PNTOBJECTOPENPROCEDURE)g_ExtApiSet.NtOpenRegistryTransaction;
        }
        break;
    default:
        ObjectOpenProcedure = NULL;
        break;
    }

    if (ObjectOpenProcedure == NULL) {

        ntStatus = STATUS_PROCEDURE_NOT_FOUND;

    }
    else {

        //
        // Open object of the given type.
        //
        InitializeObjectAttributes(&obja, ObjectName, OBJ_CASE_INSENSITIVE, rootHandle, NULL);

        ntStatus = ObjectOpenProcedure(
            &objectHandle,
            DesiredAccess,
            &obja);

        if (NT_SUCCESS(ntStatus))
            *ObjectHandle = objectHandle;
    }

    NtClose(rootHandle);

    return ntStatus;
}

/*
* supEnumHandleDump
*
* Purpose:
*
* Execute callback over each handle dump entry.
*
* Return TRUE if enumeration callback stops enumeration.
*
*/
BOOL supEnumHandleDump(
    _In_ PSYSTEM_HANDLE_INFORMATION_EX HandleDump,
    _In_ PENUMERATE_HANDLE_DUMP_CALLBACK EnumCallback,
    _In_ PVOID UserContext
)
{
    ULONG_PTR i;

    for (i = 0; i < HandleDump->NumberOfHandles; i++) {
        if (EnumCallback(&HandleDump->Handles[i],
            UserContext))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*
* supxEnumAlpcPortsCallback
*
* Purpose:
*
* Port handles enumeration callback.
*
*/
BOOL supxEnumAlpcPortsCallback(
    _In_ SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * HandleEntry,
    _In_opt_ PVOID UserContext)
{
    BOOL        fSelfProcess = FALSE, fAlloc = FALSE, bStopEnum = FALSE;
    ULONG       bufferSize = 4096;
    ULONG       returnedLength = 0;
    NTSTATUS    ntStatus;
    HANDLE      objectHandle = NULL, processHandle = NULL;
    BYTE        buffer[4096], * pBuffer = (PBYTE)&buffer;

    PALPCPORT_ENUM_CONTEXT enumContext = (PALPCPORT_ENUM_CONTEXT)UserContext;
    PUNICODE_STRING pusObjectName;

    do {

        if (enumContext == NULL)
            break;

        //
        // Not an ALPC port, skip.
        //
        if (HandleEntry->ObjectTypeIndex != enumContext->AlpcPortTypeIndex)
            break;

        //
        // Not our handle, open process.
        //
        if (HandleEntry->UniqueProcessId != GetCurrentProcessId()) {

            ntStatus = supOpenProcessEx((HANDLE)HandleEntry->UniqueProcessId,
                PROCESS_DUP_HANDLE,
                &processHandle);

            if (!NT_SUCCESS(ntStatus))
                break;

        }
        else {
            //
            // Our handle.
            //
            processHandle = NtCurrentProcess();
            fSelfProcess = TRUE;
        }

        //
        // Duplicate handle.
        //
        ntStatus = NtDuplicateObject(processHandle,
            (HANDLE)HandleEntry->HandleValue,
            NtCurrentProcess(),
            &objectHandle,
            STANDARD_RIGHTS_ALL,
            0,
            0);

        if (!fSelfProcess)
            NtClose(processHandle);

        if (!NT_SUCCESS(ntStatus))
            break;

        //
        // Query object name, static buffer used for performance.
        //
        ntStatus = NtQueryObject(objectHandle,
            ObjectNameInformation,
            pBuffer,
            bufferSize,
            &returnedLength);

        if (ntStatus == STATUS_INFO_LENGTH_MISMATCH) {

            pBuffer = (PBYTE)supHeapAlloc((SIZE_T)returnedLength);
            if (pBuffer) {

                fAlloc = TRUE;

                ntStatus = NtQueryObject(objectHandle,
                    ObjectNameInformation,
                    pBuffer,
                    returnedLength,
                    &returnedLength);

            }

        }

        if (NT_SUCCESS(ntStatus)) {

            pusObjectName = (PUNICODE_STRING)pBuffer;
            if (pusObjectName->Buffer && pusObjectName->Length) {

                if (RtlEqualUnicodeString(enumContext->ObjectName, pusObjectName, TRUE)) {
                    enumContext->ObjectHandle = objectHandle;
                    bStopEnum = TRUE;
                    break;
                }
            }

        }

        NtClose(objectHandle);

    } while (FALSE);

    if (fAlloc && pBuffer)
        supHeapFree(pBuffer);


    //
    // Do not stop enumeration until condition.
    //
    return bStopEnum;
}

/*
* supOpenPortObjectByName
*
* Purpose:
*
* Open handle for ALPC port object type with handle duplication.
*
* NOTE:
* Windows only gives you handle to the port in two cases:
*
* 1. When you create it (NtCreatePort and similar);
* 2. When you connect to the specified port.
*
*/
NTSTATUS supOpenPortObjectByName(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PUNICODE_STRING ObjectName
)
{
    USHORT alpcPortTypeIndex;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PSYSTEM_HANDLE_INFORMATION_EX pHandles = NULL;
    ALPCPORT_ENUM_CONTEXT enumContext;

    if (ObjectHandle)
        *ObjectHandle = NULL;

    do {

        //
        // Allocate handle dump.
        //
        pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation,
            NULL);
        if (pHandles == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Query AlpcPort type index.
        //
        alpcPortTypeIndex = kdGetAlpcPortTypeIndex();
        if (alpcPortTypeIndex == MAXWORD) {
            ntStatus = STATUS_PORT_UNREACHABLE;
            break;
        }

        //
        // Walk handle table looking for our named port.
        //
        enumContext.AlpcPortTypeIndex = alpcPortTypeIndex;
        enumContext.ObjectName = ObjectName;
        enumContext.ObjectHandle = NULL;

        if (supEnumHandleDump(pHandles,
            supxEnumAlpcPortsCallback,
            &enumContext))
        {
            if (enumContext.ObjectHandle) {

                //
                // Duplicate copy with requested desired access.
                //
                ntStatus = NtDuplicateObject(NtCurrentProcess(),
                    enumContext.ObjectHandle,
                    NtCurrentProcess(),
                    ObjectHandle,
                    DesiredAccess,
                    0,
                    0);

                NtClose(enumContext.ObjectHandle);

            }
            else {
                ntStatus = STATUS_INVALID_HANDLE;
            }
        }
        else {
            ntStatus = STATUS_PORT_CONNECTION_REFUSED;
        }

    } while (FALSE);

    if (pHandles)
        supHeapFree(pHandles);

    return ntStatus;
}

/*
* supOpenPortObjectFromContext
*
* Purpose:
*
* Open handle for ALPC port object type.
*
*/
NTSTATUS supOpenPortObjectFromContext(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PROP_OBJECT_INFO * Context
)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    UNICODE_STRING portName;

    *ObjectHandle = NULL;

    RtlInitEmptyUnicodeString(&portName, NULL, 0);
    if (supCreateObjectPathFromElements(
        &Context->NtObjectName,
        &Context->NtObjectPath,
        &portName,
        TRUE))
    {
        ntStatus = supOpenPortObjectByName(ObjectHandle,
            DesiredAccess,
            &portName);

        supHeapFree(portName.Buffer);
    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*
* supOpenObjectFromContext
*
* Purpose:
*
* Return handle (query rights) for the given named object.
*
*/
HANDLE supOpenObjectFromContext(
    _In_ PROP_OBJECT_INFO * Context,
    _In_ OBJECT_ATTRIBUTES * ObjectAttributes,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ NTSTATUS * Status
)
{
    HANDLE hObject = NULL, hPrivateNamespace = NULL;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES objaNamespace;

    if (Context->ContextType == propPrivateNamespace) {

        //
        // Open private namespace.
        //
        InitializeObjectAttributes(&objaNamespace, NULL, OBJ_CASE_INSENSITIVE, NULL, NULL);

        ntStatus = NtOpenPrivateNamespace(
            &hPrivateNamespace,
            MAXIMUM_ALLOWED,
            &objaNamespace,
            Context->u1.NamespaceInfo.BoundaryDescriptor);

        if (!NT_SUCCESS(ntStatus)) {
            *Status = ntStatus;
            return NULL;
        }

        //
        // Modify OBJECT_ATTRIBUTES RootDirectory.
        //
        ObjectAttributes->RootDirectory = hPrivateNamespace;
    }

    //
    // Open object of common type.
    //

    switch (Context->ObjectTypeIndex) {

    case ObjectTypeProcess:

        if (Context->ContextType == propUnnamed) {

            ntStatus = supOpenProcessEx(
                Context->u1.UnnamedObjectInfo.ClientId.UniqueProcess,
                PROCESS_ALL_ACCESS,
                &hObject);

        }
        else
            ntStatus = STATUS_INVALID_PARAMETER;

        break;

    case ObjectTypeThread:

        if (Context->ContextType == propUnnamed) {

            ntStatus = NtOpenThread(
                &hObject,
                DesiredAccess,
                ObjectAttributes,
                &Context->u1.UnnamedObjectInfo.ClientId);

        }
        else
            ntStatus = STATUS_INVALID_PARAMETER;

        break;

    case ObjectTypeToken:

        if (Context->ContextType == propUnnamed) {

            ntStatus = supOpenTokenByParam(
                &Context->u1.UnnamedObjectInfo.ClientId,
                ObjectAttributes,
                DesiredAccess,
                Context->u1.UnnamedObjectInfo.IsThreadToken,
                &hObject);

        }
        else
            ntStatus = STATUS_INVALID_PARAMETER;

        break;

    case ObjectTypeDevice:

        ntStatus = supOpenDeviceObjectEx(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeMutant:

        ntStatus = NtOpenMutant(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeKey:

        ntStatus = NtOpenKey(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeSemaphore:

        ntStatus = NtOpenSemaphore(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeTimer:

        ntStatus = NtOpenTimer(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeEvent:

        ntStatus = NtOpenEvent(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeEventPair:

        ntStatus = NtOpenEventPair(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeSymbolicLink:

        ntStatus = NtOpenSymbolicLinkObject(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeIoCompletion:

        ntStatus = NtOpenIoCompletion(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeSection:

        ntStatus = NtOpenSection(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeJob:

        ntStatus = NtOpenJobObject(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeSession:

        ntStatus = NtOpenSession(
            &hObject,
            DesiredAccess,
            ObjectAttributes);

        break;

    case ObjectTypeMemoryPartition:

        if (g_ExtApiSet.NtOpenPartition) {

            ntStatus = g_ExtApiSet.NtOpenPartition(
                &hObject,
                DesiredAccess,
                ObjectAttributes);

        }
        else
            ntStatus = STATUS_PROCEDURE_NOT_FOUND;

        break;

    case ObjectTypePort:

        ntStatus = supOpenPortObjectFromContext(
            &hObject,
            DesiredAccess,
            Context);

        break;

    case ObjectTypeRegistryTransaction:

        if (g_ExtApiSet.NtOpenRegistryTransaction) {

            ntStatus = g_ExtApiSet.NtOpenRegistryTransaction(
                &hObject,
                DesiredAccess,
                ObjectAttributes);
        }
        else
            ntStatus = STATUS_PROCEDURE_NOT_FOUND;

        break;

    default:
        ntStatus = STATUS_OBJECTID_NOT_FOUND;
        break;
    }

    *Status = ntStatus;

    if (hPrivateNamespace) NtClose(hPrivateNamespace);

    return hObject;
}

/*
* supCloseObjectFromContext
*
* Purpose:
*
* Close handle opened with propOpenCurrentObject.
*
*/
BOOL supCloseObjectFromContext(
    _In_ PROP_OBJECT_INFO * Context,
    _In_ HANDLE hObject
)
{
    BOOL bResult = FALSE;

    if (Context == NULL) {
        if (hObject != NULL)
            bResult = NT_SUCCESS(NtClose(hObject));
        return bResult;
    }

    else {

        switch (Context->ObjectTypeIndex) {
        case ObjectTypeWinstation:
            bResult = CloseWindowStation((HWINSTA)hObject);
            break;
        case ObjectTypeDesktop:
            bResult = CloseDesktop((HDESK)hObject);
            break;
        default:
            bResult = NT_SUCCESS(NtClose(hObject));
            break;
        }
    }

    return bResult;
}

/*
* supShowError
*
* Purpose:
*
* Display detailed last error to user.
*
*/
VOID supShowLastError(
    _In_ HWND hWnd,
    _In_ LPCWSTR Source,
    _In_ DWORD LastError
)
{
    LPWSTR lpMsgBuf = NULL;

    if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        LastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&lpMsgBuf,
        0,
        NULL))
    {
        MessageBox(hWnd, lpMsgBuf, Source, MB_TOPMOST | MB_ICONERROR);
        LocalFree(lpMsgBuf);
    }
}

/*
* supShowNtStatus
*
* Purpose:
*
* Display detailed last nt status to user.
*
*/
VOID supShowNtStatus(
    _In_ HWND hWnd,
    _In_ LPCWSTR lpText,
    _In_ NTSTATUS Status
)
{
    PWCHAR lpMsg;
    SIZE_T Length = _strlen(lpText);
    lpMsg = (PWCHAR)supHeapAlloc(Length + 100);
    if (lpMsg) {
        _strcpy(lpMsg, lpText);
        ultohex((ULONG)Status, _strend(lpMsg));
        MessageBox(hWnd, lpMsg, PROGRAM_NAME, MB_ICONERROR);
        supHeapFree(lpMsg);
    }
    else {
        kdDebugPrint("Memory allocation failure\r\n");
    }
}

/*
* supFormatNtError
*
* Purpose:
*
* Format details about NT error to be displayed later.
*
* Uppon success use LocalFree on returned buffer.
*
*/
LPWSTR supFormatNtError(
    _In_ NTSTATUS NtError
)
{
    LPWSTR lpMessage = NULL;

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        (LPCVOID)GetModuleHandle(L"ntdll.dll"),
        NtError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&lpMessage,
        0,
        NULL);

    return lpMessage;
}

/*
* supBSearch
*
* Purpose:
*
* Binary search, https://github.com/torvalds/linux/blob/master/lib/bsearch.c
*
*/
PVOID supBSearch(
    _In_ PCVOID key,
    _In_ PCVOID base,
    _In_ SIZE_T num,
    _In_ SIZE_T size,
    _In_ int(*cmp)(
        _In_ PCVOID key,
        _In_ PCVOID elt
        )
)
{
    const char* pivot;
    int result;

    while (num > 0) {
        pivot = (char*)base + (num >> 1) * size;
        result = cmp(key, pivot);

        if (result == 0)
            return (void*)pivot;

        if (result > 0) {
            base = pivot + size;
            num--;
        }
        num >>= 1;
    }

    return NULL;
}

/*
* supGetProcessMitigationPolicy
*
* Purpose:
*
* Request process mitigation policy values.
*
*/
_Success_(return != FALSE)
BOOL supGetProcessMitigationPolicy(
    _In_ HANDLE hProcess,
    _In_ PROCESS_MITIGATION_POLICY Policy,
    _In_ SIZE_T Size,
    _Out_writes_bytes_(Size) PVOID Buffer
)
{
    ULONG Length = 0;
    PROCESS_MITIGATION_POLICY_RAW_DATA MitigationPolicy;

    if (Size == sizeof(DWORD)) {

        MitigationPolicy.Policy = (PROCESS_MITIGATION_POLICY)Policy;

        if (NT_SUCCESS(NtQueryInformationProcess(
            hProcess,
            ProcessMitigationPolicy,
            &MitigationPolicy,
            sizeof(PROCESS_MITIGATION_POLICY_RAW_DATA),
            &Length)))
        {
            RtlCopyMemory(Buffer, &MitigationPolicy.Value, Size);
            return TRUE;
        }

    }

    return FALSE;
}

/*
* supGetProcessDepState
*
* Purpose:
*
* Query DEP state for process from ProcessExecuteFlags.
*
*/
_Success_(return != FALSE)
BOOL supGetProcessDepState(
    _In_ HANDLE hProcess,
    _Out_ PPROCESS_MITIGATION_DEP_POLICY DepPolicy
)
{
    ULONG ExecuteFlags = 0;

    if (NT_SUCCESS(NtQueryInformationProcess(
        hProcess,
        ProcessExecuteFlags,
        (PVOID)&ExecuteFlags,
        sizeof(ULONG),
        NULL)))
    {
        if (ExecuteFlags & MEM_EXECUTE_OPTION_ENABLE)
            DepPolicy->Enable = 0;
        else
            DepPolicy->Enable = 1;

        if (ExecuteFlags & MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION)
            DepPolicy->DisableAtlThunkEmulation = 1;
        else
            DepPolicy->DisableAtlThunkEmulation = 0;

        if (ExecuteFlags & MEM_EXECUTE_OPTION_PERMANENT)
            DepPolicy->Permanent = 1;
        else
            DepPolicy->Permanent = 0;

        return TRUE;
    }

    return FALSE;
}

/*
* supDeviceIoControlProcExp
*
* Purpose:
*
* Send request to Process Explorer driver.
*
*/
NTSTATUS supDeviceIoControlProcExp(
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
)
{
    NTSTATUS status;
    HANDLE deviceHandle = NULL;

    UNICODE_STRING usDevName = RTL_CONSTANT_STRING(T_DEVICE_PROCEXP152);
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iost;

    if (g_kdctx.IsFullAdmin == FALSE)
        return STATUS_ACCESS_DENIED;

    InitializeObjectAttributes(&obja, &usDevName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(
        &deviceHandle,
        GENERIC_READ | GENERIC_WRITE,
        &obja,
        &iost,
        NULL,
        0,
        0,
        FILE_OPEN,
        0,
        NULL,
        0);

    if (NT_SUCCESS(status)) {

        status = NtDeviceIoControlFile(
            deviceHandle,
            NULL,
            NULL,
            NULL,
            &iost,
            IoControlCode,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength);

        NtClose(deviceHandle);
    }
    return status;
}

/*
* supOpenProcessEx
*
* Purpose:
*
* Open process via SysInternals Process Explorer driver.
*
* Desired access: PROCESS_ALL_ACCESS
*
*/
NTSTATUS supOpenProcessEx(
    _In_ HANDLE UniqueProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    NTSTATUS status;
    HANDLE processHandle = NULL;

    *ProcessHandle = NULL;

    status = supDeviceIoControlProcExp(
        (ULONG)IOCTL_PE_OPEN_PROCESS,
        (PVOID)&UniqueProcessId,
        sizeof(UniqueProcessId),
        (PVOID)&processHandle,
        sizeof(processHandle));

    if (!NT_SUCCESS(status)) {
        status = supOpenProcess(UniqueProcessId,
            DesiredAccess,
            &processHandle);
    }

    *ProcessHandle = processHandle;
    return status;
}

/*
* supOpenProcessTokenEx
*
* Purpose:
*
* Open process token via SysInternals Process Explorer driver.
*
* Desired access: TOKEN_QUERY
*
*/
NTSTATUS supOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _Out_ PHANDLE TokenHandle
)
{
    NTSTATUS status;
    HANDLE tokenHandle = NULL;

    *TokenHandle = NULL;

    status = supDeviceIoControlProcExp(
        (ULONG)IOCTL_PE_OPEN_PROCESS_TOKEN,
        (PVOID)&ProcessHandle,
        sizeof(ProcessHandle),
        (PVOID)&tokenHandle,
        sizeof(tokenHandle));

    if (NT_SUCCESS(status))
        *TokenHandle = tokenHandle;

    return status;
}

/*
* supPrintTimeToBuffer
*
* Purpose:
*
* Print  time to string buffer.
*
*/
INT supPrintTimeToBuffer(
    _In_ PLARGE_INTEGER Time,
    _In_ WCHAR * lpszBuffer,
    _In_ SIZE_T cchBuffer
)
{
    TIME_FIELDS TimeFields = { 0, 0, 0, 0, 0, 0, 0, 0 };

    RtlTimeToTimeFields(Time, &TimeFields);

    return RtlStringCchPrintfSecure(lpszBuffer,
        cchBuffer,
        FORMAT_TIME_VALUE_MS,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second,
        TimeFields.Milliseconds);
}

/*
* supPrintTimeConverted
*
* Purpose:
*
* Print local converted time to string buffer.
*
*/
BOOL supPrintTimeConverted(
    _In_ PLARGE_INTEGER Time,
    _In_ WCHAR * lpszBuffer,
    _In_ SIZE_T cchBuffer
)
{
    FILETIME ConvertedTime = { 0, 0 };
    TIME_FIELDS TimeFields = { 0, 0, 0, 0, 0, 0, 0, 0 };
    LPCWSTR lpszMonths[12] = {
        L"Jan",
        L"Feb",
        L"Mar",
        L"Apr",
        L"May",
        L"Jun",
        L"Jul",
        L"Aug",
        L"Sep",
        L"Oct",
        L"Nov",
        L"Dec"
    };

    if (FileTimeToLocalFileTime((PFILETIME)Time, (PFILETIME)&ConvertedTime)) { //-V1027
        RtlTimeToTimeFields((PLARGE_INTEGER)&ConvertedTime, (PTIME_FIELDS)&TimeFields); //-V1027

        if (TimeFields.Month - 1 < 0) TimeFields.Month = 1;
        if (TimeFields.Month > 12) TimeFields.Month = 12;

        RtlStringCchPrintfSecure(
            lpszBuffer,
            cchBuffer,
            FORMAT_TIME_DATE_VALUE,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second,
            TimeFields.Day,
            lpszMonths[TimeFields.Month - 1],
            TimeFields.Year);

        return TRUE;
    }

    return FALSE;
}

/*
* supGetTreeViewItemParam
*
* Purpose:
*
* Return TreeView item associated parameter.
*
*/
_Success_(return)
BOOL supGetTreeViewItemParam(
    _In_ HWND hwndTreeView,
    _In_ HTREEITEM hTreeItem,
    _Out_ PVOID * outParam
)
{
    TV_ITEM tvi;

    RtlSecureZeroMemory(&tvi, sizeof(TV_ITEM));

    tvi.mask = TVIF_PARAM;
    tvi.hItem = hTreeItem;
    if (!TreeView_GetItem(hwndTreeView, &tvi))
        return FALSE;

    *outParam = (PVOID)tvi.lParam;

    return TRUE;
}

/*
* supGetListViewItemParam
*
* Purpose:
*
* Return ListView item associated parameter.
*
*/
_Success_(return)
BOOL supGetListViewItemParam(
    _In_ HWND hwndListView,
    _In_ INT itemIndex,
    _Out_ PVOID * outParam
)
{
    LVITEM lvItem;

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = itemIndex;
    lvItem.iSubItem = 0;
    lvItem.lParam = 0;

    if (!ListView_GetItem(hwndListView, &lvItem))
        return FALSE;

    *outParam = (PVOID)lvItem.lParam;

    return TRUE;
}

/*
* supSetMinMaxTrackSize
*
* Purpose:
*
* WM_GETMINMAXINFO handler for dialogs.
*
*/
VOID supSetMinMaxTrackSize(
    _In_ PMINMAXINFO MinMaxInfo,
    _In_ INT MinX,
    _In_ INT MinY,
    _In_ BOOL Scaled
)
{
    if (Scaled) {
        MinMaxInfo->ptMinTrackSize.x = SCALE_DPI_VALUE(MinX, g_WinObj.CurrentDPI);
        MinMaxInfo->ptMinTrackSize.y = SCALE_DPI_VALUE(MinY, g_WinObj.CurrentDPI);
    }
    else {
        MinMaxInfo->ptMinTrackSize.x = MinX;
        MinMaxInfo->ptMinTrackSize.y = MinY;
    }
}

/*
* supGetSidNameUse
*
* Purpose:
*
* Translate SidNameUse to string name.
*
*/
LPWSTR supGetSidNameUse(
    _In_ SID_NAME_USE SidNameUse
)
{
    ULONG nameUse = (ULONG)SidNameUse;

    switch (nameUse) {
    case sidTypeUser:
        return L"User";
    case sidTypeGroup:
        return L"Group";
    case sidTypeDomain:
        return L"Domain";
    case sidTypeAlias:
        return L"Alias";
    case sidTypeWellKnownGroup:
        return L"WellKnownGroup";
    case sidTypeDeletedAccount:
        return L"DeletedAccount";
    case sidTypeInvalid:
        return L"Invalid";
    case sidTypeComputer:
        return L"Computer";
    case sidTypeLogonSession:
        return L"LogonSession";
    case sidTypeLabel:
        return L"Label";
    case sidTypeUnknown:
    default:
        return T_Unknown;
    }
}

/*
* supIntegrityToString
*
* Purpose:
*
* Translate integrity level to string name.
*
*/
LPWSTR supIntegrityToString(
    _In_ DWORD IntegrityLevel
)
{
    LPWSTR lpValue = L"Unknown";

    if (IntegrityLevel == SECURITY_MANDATORY_UNTRUSTED_RID) {
        lpValue = L"Untrusted";
    }
    else if (IntegrityLevel == SECURITY_MANDATORY_LOW_RID) {
        lpValue = L"Low";
    }
    else if (IntegrityLevel >= SECURITY_MANDATORY_MEDIUM_RID &&
        IntegrityLevel < SECURITY_MANDATORY_HIGH_RID)
    {
        if (IntegrityLevel == SECURITY_MANDATORY_MEDIUM_PLUS_RID)
            lpValue = L"MediumPlus";
        else
            lpValue = L"Medium";
    }
    else if (IntegrityLevel >= SECURITY_MANDATORY_HIGH_RID &&
        IntegrityLevel < SECURITY_MANDATORY_SYSTEM_RID)
    {
        lpValue = L"High";
    }
    else if (IntegrityLevel >= SECURITY_MANDATORY_SYSTEM_RID &&
        IntegrityLevel < SECURITY_MANDATORY_PROTECTED_PROCESS_RID)
    {
        lpValue = L"System";
    }
    else if (IntegrityLevel >= SECURITY_MANDATORY_PROTECTED_PROCESS_RID)
    {
        lpValue = L"ProtectedProcess";
    }

    return lpValue;
}

/*
* supLookupSidUserAndDomainEx
*
* Purpose:
*
* Query user and domain name from given sid and policy handle.
*
*/
BOOL supLookupSidUserAndDomainEx(
    _In_ PSID Sid,
    _In_ LSA_HANDLE PolicyHandle,
    _Out_ LPWSTR * lpSidUserAndDomain
)
{
    BOOL bResult = FALSE;
    NTSTATUS Status;
    ULONG Length;
    LPWSTR UserAndDomainName = NULL, P;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;

    *lpSidUserAndDomain = NULL;

    Status = LsaLookupSids(
        PolicyHandle,
        1,
        (PSID*)&Sid,
        (PLSA_REFERENCED_DOMAIN_LIST*)&ReferencedDomains,
        (PLSA_TRANSLATED_NAME*)&Names);

    if ((NT_SUCCESS(Status)) && (Status != STATUS_SOME_NOT_MAPPED)) {

        Length = 0;

        if ((ReferencedDomains != NULL) && (Names != NULL)) {

            Length = 4 + ReferencedDomains->Domains[0].Name.MaximumLength +
                Names->Name.MaximumLength;

            UserAndDomainName = (LPWSTR)supHeapAlloc(Length);
            if (UserAndDomainName) {
                P = UserAndDomainName;
                if (ReferencedDomains->Domains[0].Name.Length) {
                    RtlCopyMemory(UserAndDomainName,
                        ReferencedDomains->Domains[0].Name.Buffer,
                        ReferencedDomains->Domains[0].Name.Length);

                    P = _strcat(UserAndDomainName, TEXT("\\"));
                }

                RtlCopyMemory(P,
                    Names->Name.Buffer,
                    Names->Name.Length);

                *lpSidUserAndDomain = UserAndDomainName;
                bResult = TRUE;
            }
        }
        if (ReferencedDomains) LsaFreeMemory(ReferencedDomains);
        if (Names) LsaFreeMemory(Names);
    }

    return bResult;
}

/*
* supLookupSidUserAndDomain
*
* Purpose:
*
* Query user and domain name from given sid.
*
*/
BOOL supLookupSidUserAndDomain(
    _In_ PSID Sid,
    _Out_ LPWSTR * lpSidUserAndDomain
)
{
    BOOL bResult = FALSE;
    LSA_HANDLE PolicyHandle = NULL;

    *lpSidUserAndDomain = NULL;

    if (NT_SUCCESS(supLsaOpenMachinePolicy(POLICY_LOOKUP_NAMES,
        &PolicyHandle)))
    {
        bResult = supLookupSidUserAndDomainEx(Sid,
            PolicyHandle,
            lpSidUserAndDomain);

        LsaClose(PolicyHandle);
    }

    return bResult;
}

/*
* supLsaOpenMachinePolicy
*
* Purpose:
*
* Open local machine policy.
*
*/
NTSTATUS supLsaOpenMachinePolicy(
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PLSA_HANDLE PolicyHandle
)
{
    LSA_OBJECT_ATTRIBUTES lobja;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    InitializeObjectAttributes(
        &lobja,
        NULL,
        0L,
        NULL,
        NULL);

    lobja.SecurityQualityOfService = &SecurityQualityOfService;

    return LsaOpenPolicy(
        NULL,
        (PLSA_OBJECT_ATTRIBUTES)&lobja,
        DesiredAccess,
        PolicyHandle);
}

/*
* supxHandlesLookupCallback
*
* Purpose:
*
* qsort, bsearch callback.
*
*/
int __cdecl supxHandlesLookupCallback(
    void const* first,
    void const* second
)
{
    int i;
    PSUP_HANDLE_DUMP_ENTRY elem1 = (PSUP_HANDLE_DUMP_ENTRY)first;
    PSUP_HANDLE_DUMP_ENTRY elem2 = (PSUP_HANDLE_DUMP_ENTRY)second;

    if (elem1->HandleValue == elem2->HandleValue)
        i = 0;
    else
        if (elem1->HandleValue < elem2->HandleValue)
            i = -1;
        else
            i = 1;

    return i;
}

/*
* supxHandlesLookupCallback2
*
* Purpose:
*
* qsort, bsearch callback.
*
*/
int __cdecl supxHandlesLookupCallback2(
    void const* first,
    void const* second
)
{
    int i;
    PSUP_HANDLE_DUMP_ENTRY elem1 = (PSUP_HANDLE_DUMP_ENTRY)first;
    PSUP_HANDLE_DUMP_ENTRY elem2 = (PSUP_HANDLE_DUMP_ENTRY)second;

    ULONG_PTR FirstObject = (ULONG_PTR)elem1->Object;
    ULONG_PTR SecondObject = (ULONG_PTR)elem2->Object;

    if (FirstObject == SecondObject)
        i = 0;
    else
        if (FirstObject < SecondObject)
            i = -1;
        else
            i = 1;

    return i;
}

/*
* supHandlesCreateFilteredAndSortedList
*
* Purpose:
*
* Create sorted handles list of given process.
*
* Use supHeapFree to release allocated memory.
*
*/
PSUP_HANDLE_DUMP supHandlesCreateFilteredAndSortedList(
    _In_ ULONG_PTR FilterUniqueProcessId,
    _In_ BOOLEAN fObject
)
{
    PSYSTEM_HANDLE_INFORMATION_EX handleDump;
    PSUP_HANDLE_DUMP resultSnapshot;
    ULONG_PTR i, cLast = 0;

    ULONG returnLength = 0;
    SIZE_T stBufferSize;

    handleDump = (PSYSTEM_HANDLE_INFORMATION_EX)ntsupGetSystemInfoEx(
        SystemExtendedHandleInformation,
        &returnLength,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);

    if (handleDump == NULL)
        return NULL;

    stBufferSize = sizeof(SUP_HANDLE_DUMP) +
        handleDump->NumberOfHandles * sizeof(PSUP_HANDLE_DUMP_ENTRY);

    resultSnapshot = (PSUP_HANDLE_DUMP)supHeapAlloc(stBufferSize);

    if (resultSnapshot) {
        for (i = 0; i < handleDump->NumberOfHandles; i++) {
            if (handleDump->Handles[i].UniqueProcessId == FilterUniqueProcessId) {
                resultSnapshot->Handles[cLast].Object = handleDump->Handles[i].Object;
                resultSnapshot->Handles[cLast].HandleValue = handleDump->Handles[i].HandleValue;
                cLast++;
            }
        }

        resultSnapshot->NumberOfHandles = cLast;

        RtlQuickSort((PVOID)&resultSnapshot->Handles,
            resultSnapshot->NumberOfHandles,
            sizeof(SUP_HANDLE_DUMP_ENTRY),
            (fObject) ? supxHandlesLookupCallback2 : supxHandlesLookupCallback);
    }

    supHeapFree(handleDump);

    return resultSnapshot;
}

/*
* supHandlesQueryObjectAddress
*
* Purpose:
*
* Find object address for given handle.
*
*/
BOOL supHandlesQueryObjectAddress(
    _In_ PSUP_HANDLE_DUMP SortedHandleList,
    _In_ HANDLE ObjectHandle,
    _Out_ PULONG_PTR ObjectAddress
)
{
    SUP_HANDLE_DUMP_ENTRY* SearchResult, SearchEntry;

    SearchEntry.HandleValue = (ULONG_PTR)ObjectHandle;

    SearchResult = (PSUP_HANDLE_DUMP_ENTRY)supBSearch(
        (PCVOID)&SearchEntry,
        SortedHandleList->Handles,
        SortedHandleList->NumberOfHandles,
        sizeof(SUP_HANDLE_DUMP_ENTRY),
        supxHandlesLookupCallback);

    if (SearchResult) {
        *ObjectAddress = (ULONG_PTR)SearchResult->Object;
        return TRUE;
    }

    *ObjectAddress = 0;
    return FALSE;
}

/*
* supPHLGetEntry
*
* Purpose:
*
* Return handle from handle list by process id.
*
*/
HANDLE supPHLGetEntry(
    _In_ PLIST_ENTRY ListHead,
    _In_ HANDLE UniqueProcessId
)
{
    PLIST_ENTRY Next, Head = ListHead;
    PHL_ENTRY* Item;

    if (!IsListEmpty(Head)) {
        Next = Head->Flink;
        while ((Next != NULL) && (Next != Head)) {
            Item = CONTAINING_RECORD(Next, PHL_ENTRY, ListEntry);
            if (Item->UniqueProcessId == UniqueProcessId)
                return Item->ProcessHandle;
            Next = Next->Flink;
        }
    }
    return NULL;
}

/*
* supPHLFree
*
* Purpose:
*
* Free list of handles.
*
*/
VOID supPHLFree(
    _In_ PLIST_ENTRY ListHead,
    _In_ BOOLEAN fClose
)
{
    PLIST_ENTRY Entry, NextEntry;
    PHL_ENTRY* Item;

    if (IsListEmpty(ListHead))
        return;

    for (Entry = ListHead->Flink, NextEntry = Entry->Flink;
        Entry != ListHead;
        Entry = NextEntry, NextEntry = Entry->Flink)
    {
        Item = CONTAINING_RECORD(Entry, PHL_ENTRY, ListEntry);
        RemoveEntryList(Entry);
        if (fClose) {
            if (Item->ProcessHandle)
                NtClose(Item->ProcessHandle);
        }
        supHeapFree(Item);
    }

}

/*
* supPHLCreate
*
* Purpose:
*
* Create simple handle list of running processes.
*
*/
BOOL supPHLCreate(
    _Inout_ PLIST_ENTRY ListHead,
    _In_ PBYTE ProcessList,
    _Out_ PULONG NumberOfProcesses,
    _Out_ PULONG NumberOfThreads
)
{
    ULONG NextEntryDelta = 0;
    ULONG numberOfThreads = 0, numberOfProcesses = 0, cEntries = 0;
    PHL_ENTRY* PsListItem;
    union {
        PSYSTEM_PROCESS_INFORMATION ProcessEntry;
        PBYTE ListRef;
    } List;

    List.ListRef = ProcessList;

    do {

        List.ListRef += NextEntryDelta;

        numberOfThreads += List.ProcessEntry->ThreadCount;
        numberOfProcesses += 1;
        NextEntryDelta = List.ProcessEntry->NextEntryDelta;

        PsListItem = (PHL_ENTRY*)supHeapAlloc(sizeof(PHL_ENTRY));
        if (PsListItem) {

            PsListItem->UniqueProcessId = List.ProcessEntry->UniqueProcessId;
            PsListItem->DataPtr = (PVOID)List.ProcessEntry;

            if (List.ProcessEntry->ThreadCount) {

                supOpenProcess(
                    List.ProcessEntry->UniqueProcessId,
                    PROCESS_QUERY_LIMITED_INFORMATION,
                    &PsListItem->ProcessHandle);

            }

            InsertHeadList(ListHead, &PsListItem->ListEntry);
            cEntries += 1;
        }

    } while (NextEntryDelta);

    *NumberOfThreads = numberOfThreads;
    *NumberOfProcesses = numberOfProcesses;

    return cEntries > 0;
}

/*
* supxEnumerateSLCacheValueDescriptors
*
* Purpose:
*
* Walk each SL cache value descriptor entry, validate it and run optional callback.
*
*/
NTSTATUS supxEnumerateSLCacheValueDescriptors(
    _In_ SL_KMEM_CACHE * Cache,
    _In_opt_ PENUMERATE_SL_CACHE_VALUE_DESCRIPTORS_CALLBACK Callback,
    _In_opt_ PVOID Context
)
{
    ULONG_PTR CurrentPosition, MaxPosition;
    SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor;

    __try {

        if (Cache->TotalSize < sizeof(SL_KMEM_CACHE))
            return STATUS_INVALID_PARAMETER;

        if (Cache->Version != 1)
            return STATUS_INVALID_PARAMETER;

        MaxPosition = (ULONG_PTR)RtlOffsetToPointer(Cache, Cache->TotalSize);
        if (MaxPosition < (ULONG_PTR)Cache)
            return STATUS_INVALID_PARAMETER;

        CacheDescriptor = (SL_KMEM_CACHE_VALUE_DESCRIPTOR*)&Cache->Descriptors;
        CurrentPosition = (ULONG_PTR)CacheDescriptor;
        MaxPosition = (ULONG_PTR)RtlOffsetToPointer(CacheDescriptor, Cache->SizeOfData);

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }

    do {
        __try {
            if ((CacheDescriptor->NameLength >= CacheDescriptor->Size) ||
                (CacheDescriptor->DataLength >= CacheDescriptor->Size))
            {
                return STATUS_INTERNAL_ERROR;
            }
        }
        __except (WOBJ_EXCEPTION_FILTER_LOG) {
            return GetExceptionCode();
        }

        if (Callback) {
            if (Callback(CacheDescriptor, Context))
                break;
        }

        __try {

            CurrentPosition += CacheDescriptor->Size;
            if (CurrentPosition >= MaxPosition)
                break;

            CacheDescriptor = (SL_KMEM_CACHE_VALUE_DESCRIPTOR*)RtlOffsetToPointer(CacheDescriptor, CacheDescriptor->Size);
        }
        __except (WOBJ_EXCEPTION_FILTER_LOG) {
            return GetExceptionCode();
        }

    } while (TRUE);

    return STATUS_SUCCESS;
}

/*
* supSLCacheRead
*
* Purpose:
*
* Read software licensing cache.
*
* N.B.
*
* Use supHeapFree to release allocated memory.
*
*/
PVOID supSLCacheRead(
    VOID)
{
    NTSTATUS Status;
    ULONG DataLength = 0;
    PVOID ReturnData = NULL;
    HANDLE KeyHandle = NULL;
    UNICODE_STRING ProductPolicyValue = RTL_CONSTANT_STRING(L"ProductPolicy");
    UNICODE_STRING ProductOptionsKey = RTL_CONSTANT_STRING(L"\\REGISTRY\\MACHINE\\System\\CurrentControlSet\\Control\\ProductOptions");
    OBJECT_ATTRIBUTES ObjectAttributes;

    KEY_VALUE_PARTIAL_INFORMATION* PolicyData;

    InitializeObjectAttributes(&ObjectAttributes, &ProductOptionsKey, OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenKey(&KeyHandle, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status))
        return NULL;

    Status = NtQueryValueKey(KeyHandle, &ProductPolicyValue,
        KeyValuePartialInformation, NULL, 0, &DataLength);

    if (Status == STATUS_BUFFER_TOO_SMALL) {
        PolicyData = (KEY_VALUE_PARTIAL_INFORMATION*)supHeapAlloc(DataLength + sizeof(KEY_VALUE_PARTIAL_INFORMATION));
        if (PolicyData) {

            Status = NtQueryValueKey(KeyHandle,
                &ProductPolicyValue,
                KeyValuePartialInformation,
                PolicyData,
                DataLength,
                &DataLength);

            if (NT_SUCCESS(Status) && (PolicyData->Type == REG_BINARY)) {
                ReturnData = PolicyData;
            }
            else {
                supHeapFree(PolicyData);
            }
        }
    }
    NtClose(KeyHandle);

    return ReturnData;
}

/*
* supSLCacheEnumerate
*
* Purpose:
*
* Enumerate SL value descriptors and run optional callback.
*
*/
BOOLEAN supSLCacheEnumerate(
    _In_ PVOID CacheData,
    _In_opt_ PENUMERATE_SL_CACHE_VALUE_DESCRIPTORS_CALLBACK Callback,
    _In_opt_ PVOID Context)
{
    SL_KMEM_CACHE* Cache;

    Cache = (SL_KMEM_CACHE*)((KEY_VALUE_PARTIAL_INFORMATION*)(CacheData))->Data;

    return NT_SUCCESS(supxEnumerateSLCacheValueDescriptors(
        Cache,
        Callback,
        Context));
}

/*
* supxGetShellViewForDesktop
*
* Purpose:
*
* Use the shell view for the desktop using the shell windows automation to find the
* desktop web browser and then grabs its view.
*
*/
HRESULT supxGetShellViewForDesktop(
    REFIID riid,
    void** ppv
)
{
    IShellWindows* psw = NULL;
    HRESULT hr;
    HWND hwnd = NULL;
    IDispatch* pdisp = NULL;
    IShellBrowser* psb = NULL;
    VARIANT vtEmpty;
    IShellView* psv = NULL;

    if (ppv == NULL)
        return E_POINTER;

    *ppv = NULL;

#ifdef __cplusplus

    hr = CoCreateInstance(CLSID_ShellWindows, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARGS(&psw));
    if (SUCCEEDED(hr))
    {
        VariantInit(&vtEmpty);

        if (S_OK == psw->FindWindowSW(&vtEmpty, &vtEmpty, SWC_DESKTOP, (long*)(LONG_PTR)&hwnd, SWFO_NEEDDISPATCH, &pdisp))
        {
            hr = IUnknown_QueryService(pdisp, SID_STopLevelBrowser, IID_PPV_ARGS(&psb));
            if (SUCCEEDED(hr))
            {
                hr = psb->QueryActiveShellView(&psv);
                if (SUCCEEDED(hr))
                {
                    hr = psv->QueryInterface(riid, ppv);
                    psv->Release();
                }
                psb->Release();
            }
            pdisp->Release();
        }
        else
        {
            hr = E_FAIL;
        }
        psw->Release();
    }

#else

    VariantInit(&vtEmpty);

    hr = CoCreateInstance(&CLSID_ShellWindows, NULL, CLSCTX_LOCAL_SERVER, &IID_IShellWindows, (void**)&psw);
    if (SUCCEEDED(hr))
    {
        if (S_OK == psw->lpVtbl->FindWindowSW(psw, &vtEmpty, &vtEmpty, SWC_DESKTOP, (long*)(LONG_PTR)&hwnd, SWFO_NEEDDISPATCH, &pdisp))
        {
            hr = IUnknown_QueryService((IUnknown*)pdisp, &SID_STopLevelBrowser, &IID_IShellBrowser, (void**)&psb); //-V1027
            if (SUCCEEDED(hr))
            {
                hr = psb->lpVtbl->QueryActiveShellView(psb, &psv);
                if (SUCCEEDED(hr))
                {
                    hr = psv->lpVtbl->QueryInterface(psv, riid, ppv);
                    psv->lpVtbl->Release(psv);
                }
                psb->lpVtbl->Release(psb);
            }
            pdisp->lpVtbl->Release(pdisp);
        }
        else
        {
            hr = E_FAIL;
        }
        psw->lpVtbl->Release(psw);
    }

#endif
    return hr;
}

/*
* supxGetShellDispatchFromView
*
* Purpose:
*
* From a shell view object gets its automation interface and from that gets the shell
* application object that implements IShellDispatch2 and related interfaces.
*
*/
HRESULT supxGetShellDispatchFromView(
    IShellView * psv,
    REFIID riid,
    void** ppv
)
{
    HRESULT hr;
    IDispatch* pdispBackground = NULL;
    IShellFolderViewDual* psfvd = NULL;
    IDispatch* pdisp = NULL;

    if (ppv == NULL)
        return E_POINTER;
    if (psv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

#ifdef __cplusplus

    hr = psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARGS(&pdispBackground));
    if (SUCCEEDED(hr))
    {
        hr = pdispBackground->QueryInterface(IID_PPV_ARGS(&psfvd));
        if (SUCCEEDED(hr))
        {
            hr = psfvd->get_Application(&pdisp);
            if (SUCCEEDED(hr))
            {
                hr = pdisp->QueryInterface(riid, ppv);
                pdisp->Release();
            }
            psfvd->Release();
        }
        pdispBackground->Release();
    }

#else

    hr = psv->lpVtbl->GetItemObject(psv, SVGIO_BACKGROUND, &IID_IDispatch, (void**)&pdispBackground);
    if (SUCCEEDED(hr))
    {
        hr = pdispBackground->lpVtbl->QueryInterface(pdispBackground, &IID_IShellFolderViewDual, (void**)&psfvd);
        if (SUCCEEDED(hr))
        {
            hr = psfvd->lpVtbl->get_Application(psfvd, &pdisp);
            if (SUCCEEDED(hr))
            {
                hr = pdisp->lpVtbl->QueryInterface(pdisp, riid, ppv);
                pdisp->lpVtbl->Release(pdisp);
            }
            psfvd->lpVtbl->Release(psfvd);
        }
        pdispBackground->lpVtbl->Release(pdispBackground);
    }

#endif
    return hr;
}

/*
* supShellExecInExplorerProcess
*
* Purpose:
*
* Run ShellExecute from Windows Explorer process through shell interfaces
* making it run with IL of Windows Explorer and not WinObjEx64.
*
*/
HRESULT supShellExecInExplorerProcess(
    _In_ PCWSTR pszFile,
    _In_opt_ PCWSTR pszArguments
)
{
    HRESULT hr;
    IShellView* psv = NULL;
    IShellDispatch2* psd = NULL;
    BSTR bstrFile = NULL, bstrArgs = NULL;
    VARIANT vtEmpty, vtArgs;

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
        return hr;

    if (!pszFile) {
        CoUninitialize();
        return E_INVALIDARG;
    }

    VariantInit(&vtEmpty);
    VariantInit(&vtArgs);

#ifdef __cplusplus

    hr = supxGetShellViewForDesktop(IID_PPV_ARGS(&psv));
    if (FAILED(hr)) goto Cleanup;

    hr = supxGetShellDispatchFromView(psv, IID_PPV_ARGS(&psd));
    if (FAILED(hr)) goto Cleanup;

    bstrFile = SysAllocString(pszFile);
    if (!bstrFile) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pszArguments) {
        bstrArgs = SysAllocString(pszArguments);
        if (!bstrArgs) {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        vtArgs.vt = VT_BSTR;
        vtArgs.bstrVal = bstrArgs;

        hr = psd->ShellExecuteW(bstrFile,
            vtArgs, vtEmpty, vtEmpty, vtEmpty);
    }
    else {
        hr = psd->ShellExecuteW(bstrFile,
            vtEmpty, vtEmpty, vtEmpty, vtEmpty);
    }

#else

    hr = supxGetShellViewForDesktop(&IID_IShellView, &psv);
    if (FAILED(hr)) goto Cleanup;

    hr = supxGetShellDispatchFromView(psv, &IID_IShellDispatch2, &psd);
    if (FAILED(hr)) goto Cleanup;

    bstrFile = SysAllocString(pszFile);
    if (!bstrFile) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pszArguments) {
        bstrArgs = SysAllocString(pszArguments);
        if (!bstrArgs) {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        vtArgs.vt = VT_BSTR;
        vtArgs.bstrVal = bstrArgs;

        hr = psd->lpVtbl->ShellExecuteW(psd, bstrFile,
            vtArgs, vtEmpty, vtEmpty, vtEmpty);
    }
    else {
        hr = psd->lpVtbl->ShellExecuteW(psd, bstrFile,
            vtEmpty, vtEmpty, vtEmpty, vtEmpty);
    }

#endif

Cleanup:

#ifdef __cplusplus
    if (psd) psd->Release();
    if (psv) psv->Release();
#else
    if (psd) psd->lpVtbl->Release(psd);
    if (psv) psv->lpVtbl->Release(psv);
#endif

    if (bstrArgs) SysFreeString(bstrArgs);
    if (bstrFile) SysFreeString(bstrFile);

    CoUninitialize();
    return hr;
}

/*
* supLoadIconForObjectType
*
* Purpose:
*
* Load icon for object (or its type) which properties is currently viewed.
*
*/
BOOLEAN supLoadIconForObjectType(
    _In_ HWND hwndDlg,
    _In_ PROP_OBJECT_INFO * Context,
    _In_ HIMAGELIST ImageList,
    _In_ BOOLEAN IsShadow)
{
    HICON hIcon;
    INT ImageIndex;

    if (IsShadow)
        ImageIndex = Context->ShadowTypeDescription->ImageIndex;
    else
        ImageIndex = Context->TypeDescription->ImageIndex;

    hIcon = ImageList_GetIcon(
        ImageList,
        ImageIndex,
        ILD_NORMAL | ILD_TRANSPARENT);

    if (hIcon) {

        SendDlgItemMessage(hwndDlg, ID_OBJECT_ICON,
            STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

        if (IsShadow)
            Context->ObjectTypeIcon = hIcon;
        else
            Context->ObjectIcon = hIcon;

        return TRUE;
    }

    return FALSE;
}

typedef struct _REGSTACK_ENTRY {
    WCHAR SubKey[MAX_PATH + 1];
} REGSTACK_ENTRY, * PREGSTACK_ENTRY;

/*
* supxDeleteKeyTreeWorker
*
* Purpose:
*
* Delete key and it subkeys/values.
*
*/
BOOL supxDeleteKeyTreeWorker(
    _In_ HKEY hKeyRoot,
    _In_ LPWSTR lpSubKey
)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwSize;
    FILETIME ftWrite;
    WCHAR szName[MAX_PATH + 1];
    WCHAR workingPath[MAX_PATH * 2];
    USHORT depthStack[256]; // depth (path length in WCHARs, excluding terminator)
    INT sp = -1;
    SIZE_T baseLen, curLen;
    SIZE_T nameLen;
    BOOL hasTrailingSlash;
    PWCHAR p;

    if (lpSubKey == NULL || lpSubKey[0] == 0)
        return FALSE;

    RtlSecureZeroMemory(depthStack, sizeof(depthStack));
    _strncpy(workingPath, RTL_NUMBER_OF(workingPath), lpSubKey, RTL_NUMBER_OF(workingPath) - 1);

    //
    // Try fast delete first.
    //
    lResult = RegDeleteKey(hKeyRoot, workingPath);
    if (lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND)
        return TRUE;

    lResult = RegOpenKeyEx(hKeyRoot, workingPath, 0, KEY_READ, &hKey);
    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_FILE_NOT_FOUND)
            return TRUE;
        return FALSE;
    }
    RegCloseKey(hKey);

    //
    // Normalize base path: remove trailing backslashes (keep root form if any).
    //
    baseLen = _strlen(workingPath);
    while (baseLen > 0 && workingPath[baseLen - 1] == L'\\') {
        workingPath[baseLen - 1] = 0;
        baseLen--;
    }
    if (baseLen == 0)
        return FALSE;

    ++sp;
    depthStack[sp] = (USHORT)baseLen;

    while (sp >= 0) {

        curLen = depthStack[sp];
        workingPath[curLen] = 0;

        lResult = RegOpenKeyEx(hKeyRoot, workingPath, 0, KEY_READ, &hKey);
        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_FILE_NOT_FOUND) {
                sp--;
                continue;
            }
            return FALSE;
        }

        dwSize = MAX_PATH;
        lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL, NULL, NULL, &ftWrite);

        if (lResult == ERROR_NO_MORE_ITEMS) {

            RegCloseKey(hKey);
            RegDeleteKey(hKeyRoot, workingPath);
            sp--;
            continue;
        }

        if (lResult != ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);

        //
        // Append child: workingPath + '\' + child + '\'.
        //
        nameLen = dwSize;
        hasTrailingSlash = (curLen > 0 && workingPath[curLen - 1] == L'\\');

        //
        // Ensure capacity: base + optional '\' + name + optional '\' + 0.
        //
        if (curLen + (hasTrailingSlash ? 0 : 1) + nameLen + 1 + 1 >= RTL_NUMBER_OF(workingPath))
            return FALSE;

        p = workingPath + curLen;
        if (!hasTrailingSlash) {
            *p++ = L'\\';
            curLen++;
        }

        _strncpy(p, RTL_NUMBER_OF(workingPath) - curLen, szName, nameLen);
        p[nameLen] = 0;
        curLen += nameLen;

        //
        // Add trailing backslash to simplify appending next level.
        //
        p = workingPath + curLen;
        *p++ = L'\\';
        *p = 0;
        curLen++;

        if (++sp >= (INT)RTL_NUMBER_OF(depthStack))
            return FALSE;

        depthStack[sp] = (USHORT)curLen;
    }

    return TRUE;
}

/*
* supRegDeleteKeyTree
*
* Purpose:
*
* Delete key and all it subkeys/values.
*
* Remark:
*
* SubKey should not be longer than 260 chars.
*
*/
BOOL supRegDeleteKeyTree(
    _In_ HKEY hKeyRoot,
    _In_ LPCWSTR lpSubKey)
{
    WCHAR szKeyName[MAX_PATH * 2];

    if (lpSubKey == NULL)
        return FALSE;

    RtlSecureZeroMemory(szKeyName, sizeof(szKeyName));
    _strncpy(szKeyName, RTL_NUMBER_OF(szKeyName), lpSubKey, RTL_NUMBER_OF(szKeyName) - 1);

    return supxDeleteKeyTreeWorker(hKeyRoot, szKeyName);
}

/*
* supHashString
*
* Purpose:
*
* Create sdbm hash for given string.
*
* N.B. Case sensitive.
*
*/
ULONG supHashString(
    _In_ PCWSTR String,
    _In_ ULONG Length)
{
    ULONG hashValue = 0, nChars = Length;
    PCWSTR stringBuffer = String;

    while (nChars-- != 0)
        hashValue = (hashValue * 65599) + *stringBuffer++;

    return hashValue;
}

/*
* supHashStringAnsi
*
* Purpose:
*
* Create sdbm hash for given string.
*
* N.B. Case sensitive.
*
*/
ULONG supHashStringAnsi(
    _In_ PCSTR String,
    _In_ ULONG Length)
{
    ULONG hashValue = 0, nChars = Length;
    PCSTR stringBuffer = String;

    while (nChars-- != 0)
        hashValue = (hashValue * 65599) + *stringBuffer++;

    return hashValue;
}

/*
* supHashUnicodeString
*
* Purpose:
*
* Create sdbm hash for given UNICODE_STRING.
*
* N.B. Case sensitive.
*
*/
ULONG supHashUnicodeString(
    _In_ CONST UNICODE_STRING * String)
{
    return supHashString(String->Buffer, String->Length / sizeof(WCHAR));
}

/*
* supCreateSystemAdminAccessSD
*
* Purpose:
*
* Create security descriptor with Admin/System ACL set.
*
*/
NTSTATUS supCreateSystemAdminAccessSD(
    _Out_ PSECURITY_DESCRIPTOR * SecurityDescriptor,
    _Out_ PACL * DefaultAcl
)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    ULONG aclSize = 0;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;

    UCHAR sidBuffer[2 * sizeof(SID)];

    *SecurityDescriptor = NULL;
    *DefaultAcl = NULL;

    do {

        RtlSecureZeroMemory(sidBuffer, sizeof(sidBuffer));

        securityDescriptor = (PSECURITY_DESCRIPTOR)supHeapAlloc(sizeof(SECURITY_DESCRIPTOR));
        if (securityDescriptor == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        aclSize += RtlLengthRequiredSid(1); //LocalSystem sid
        aclSize += RtlLengthRequiredSid(2); //Admin group sid
        aclSize += sizeof(ACL);
        aclSize += 2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG));

        pAcl = (PACL)supHeapAlloc(aclSize);
        if (pAcl == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ntStatus = RtlCreateAcl(pAcl, aclSize, ACL_REVISION);
        if (!NT_SUCCESS(ntStatus))
            break;

        //
        // Local System - Generic All.
        //
        RtlInitializeSid(sidBuffer, &ntAuthority, 1);
        *(RtlSubAuthoritySid(sidBuffer, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        RtlAddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, (PSID)sidBuffer);

        //
        // Admins - Generic All.
        //
        RtlInitializeSid(sidBuffer, &ntAuthority, 2);
        *(RtlSubAuthoritySid(sidBuffer, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid(sidBuffer, 1)) = DOMAIN_ALIAS_RID_ADMINS;
        RtlAddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, (PSID)sidBuffer);

        ntStatus = RtlCreateSecurityDescriptor(securityDescriptor,
            SECURITY_DESCRIPTOR_REVISION1);
        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlSetDaclSecurityDescriptor(securityDescriptor,
            TRUE,
            pAcl,
            FALSE);

        if (!NT_SUCCESS(ntStatus))
            break;

        *SecurityDescriptor = securityDescriptor;
        *DefaultAcl = pAcl;

    } while (FALSE);

    if (!NT_SUCCESS(ntStatus)) {

        if (pAcl) supHeapFree(pAcl);

        if (securityDescriptor) {
            supHeapFree(securityDescriptor);
        }

        *SecurityDescriptor = NULL;
        *DefaultAcl = NULL;
    }

    return ntStatus;
}

/*
* supRichEdit32Load
*
* Purpose:
*
* Preload richedit32 library and classes.
*
*/
BOOL supRichEdit32Load()
{
    WCHAR szBuffer[MAX_PATH * 2];
    HMODULE hRichEdit;

    hRichEdit = GetModuleHandle(T_RICHEDIT_LIB);
    if (hRichEdit == NULL) {

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));

        RtlStringCchPrintfSecure(szBuffer,
            sizeof(szBuffer) / sizeof(szBuffer[0]),
            TEXT("%s\\%s"),
            g_WinObj.szSystemDirectory,
            T_RICHEDIT_LIB);

        hRichEdit = LoadLibraryEx(szBuffer, NULL, 0);
    }

    return (hRichEdit != NULL);
}

/*
* supReportAbnormalTermination
*
* Purpose:
*
* Log abnormal terminations from try/finally blocks.
*
*/
VOID supReportAbnormalTermination(
    _In_ LPCWSTR FunctionName
)
{
    WCHAR szBuffer[512];

    _strcpy(szBuffer, TEXT("AbnormalTermination of "));
    _strcat(szBuffer, FunctionName);

    logAdd(EntryTypeError, szBuffer);
}

/*
* supReportException
*
* Purpose:
*
* Log details about exception.
*
*/
VOID supReportException(
    _In_ ULONG ExceptionCode,
    _In_opt_ PEXCEPTION_POINTERS ExceptionPointers
)
{
    WCHAR szBuffer[512];

    _strcpy(szBuffer, TEXT("Exception 0x"));
    ultohex(ExceptionCode, _strend(szBuffer));

    if (ExceptionPointers) {
        if (ExceptionCode == STATUS_ACCESS_VIOLATION) {
            switch (ExceptionPointers->ExceptionRecord->ExceptionInformation[0]) {
            case 0:
                _strcat(szBuffer, TEXT(", read at address: 0x"));
                break;
            case 1:
                _strcat(szBuffer, TEXT(", write at address: 0x"));
                break;
            }
            u64tohex(ExceptionPointers->ExceptionRecord->ExceptionInformation[1], _strend(szBuffer));
        }
    }

    logAdd(EntryTypeError, szBuffer);
}

/*
* supReportAPIError
*
* Purpose:
*
* Log details about failed API call.
*
*/
VOID supReportAPIError(
    _In_ LPCWSTR FunctionName,
    _In_ NTSTATUS NtStatus
)
{
    WCHAR szBuffer[512];

    RtlStringCchPrintfSecure(szBuffer,
        512,
        TEXT("%ws 0x%lX"),
        FunctionName,
        NtStatus);

    logAdd(EntryTypeError, szBuffer);
}

/*
* supIsFileImageSection
*
* Purpose:
*
* Return TRUE if section attributes include image and file flags.
*
*/
BOOLEAN supIsFileImageSection(
    _In_ ULONG AllocationAttributes)
{
    return ((AllocationAttributes & SEC_IMAGE) && (AllocationAttributes & SEC_FILE));
}

/*
* supIsDriverShimmed
*
* Purpose:
*
* Return TRUE if driver shimmed by KSE.
*
*/
BOOLEAN supIsDriverShimmed(
    _In_ PKSE_ENGINE_DUMP KseEngineDump,
    _In_ PVOID DriverBaseAddress,
    _Out_opt_ GUID * ShimGUID)
{
    PLIST_ENTRY Entry, NextEntry, ListHead;
    KSE_SHIMMED_DRIVER* ShimmedDriver;

    if (ShimGUID)
        *ShimGUID = GUID_NULL;

    if (KseEngineDump->Valid == FALSE)
        return FALSE;

    ListHead = &KseEngineDump->ShimmedDriversDumpListHead;

    ASSERT_LIST_ENTRY_VALID_BOOLEAN(ListHead);

    if (IsListEmpty(ListHead))
        return FALSE;

    for (Entry = ListHead->Flink, NextEntry = Entry->Flink;
        Entry != ListHead;
        Entry = NextEntry, NextEntry = Entry->Flink)
    {
        ShimmedDriver = CONTAINING_RECORD(Entry, KSE_SHIMMED_DRIVER, ListEntry);
        if (DriverBaseAddress == ShimmedDriver->DriverBaseAddress) {

            if (ShimGUID) {
                if (ShimmedDriver->ShimGuid)
                    kdReadSystemMemory((ULONG_PTR)ShimmedDriver->ShimGuid,
                        ShimGUID,
                        sizeof(GUID));
            }

            return TRUE;
        }
    }

    return FALSE;
}

/*
* supGetDriverShimInformation
*
* Purpose:
*
* Return TRUE if driver shimmed by KSE.
*
*/
SUP_SHIM_INFO* supGetDriverShimInformation(
    _In_ GUID ShimGuid
)
{
    ULONG i;

    for (i = 0; i < RTL_NUMBER_OF(KsepShimInformation); i++) {
        if (RtlCompareMemory(
            (PVOID)KsepShimInformation[i].Guid,
            (PVOID)&ShimGuid,
            sizeof(GUID)) == sizeof(GUID))
        {
            return &KsepShimInformation[i];
        }
    }

    return NULL;
}

size_t supxEscStrlen(wchar_t* s)
{
    size_t  result = 2;
    wchar_t* s0 = s;

    while (*s)
    {
        if (*s == L'"')
            ++result;
        ++s;
    }

    return result + (s - s0);
}

wchar_t* supxEscStrcpy(wchar_t* dst, wchar_t* src)
{
    *(dst++) = L'"';

    while ((*dst = *src) != L'\0')
    {
        if (*src == L'"')
            *(++dst) = L'"';

        ++src;
        ++dst;
    }

    *(dst++) = L'"';
    *dst = L'\0';

    return dst;
}

/*
* supxListViewExportCSV
*
* Purpose:
*
* Export listview entries into file in csv format.
*
*/
BOOL supxListViewExportCSV(
    _In_ HWND List,
    _In_ PWCHAR FileName)
{
    HWND            hdr = ListView_GetHeader(List);
    int             pass, i, c, col_count = Header_GetItemCount(hdr), icount = 1 + ListView_GetItemCount(List);
    HDITEM          ih;
    LVITEM          lvi;
    PWCHAR          text, buffer0 = NULL, buffer = NULL;
    BOOL            result = FALSE;
    SIZE_T          total_length;
    DWORD           iobytes;
    HANDLE          f;

    text = (PWCHAR)supVirtualAlloc(32768 * sizeof(WCHAR));
    if (!text)
        return FALSE;

    RtlSecureZeroMemory(&ih, sizeof(HDITEM));
    RtlSecureZeroMemory(&lvi, sizeof(LVITEM));

    ih.pszText = lvi.pszText = text;
    ih.cchTextMax = lvi.cchTextMax = 32767;

    for (pass = 0; pass < 2; ++pass)
    {
        total_length = 0;

        for (i = 0; i < icount; ++i)
        {
            for (c = 0; c < col_count; ++c)
            {
                text[0] = L'\0';
                if (i == 0)
                {
                    ih.mask = HDI_TEXT | HDI_ORDER;
                    ih.iOrder = c;
                    Header_GetItem(hdr, c, &ih);
                }
                else
                {
                    lvi.mask = LVIF_TEXT;
                    lvi.iItem = i - 1;
                    lvi.iSubItem = c;
                    ListView_GetItem(List, &lvi);
                }
                total_length += supxEscStrlen(text) + 1;

                if (buffer)
                {
                    buffer = supxEscStrcpy(buffer, text);
                    if (c != col_count - 1)
                    {
                        *(buffer++) = L',';
                    }
                    else
                    {
                        *(buffer++) = L'\r';
                        *(buffer++) = L'\n';
                    }
                }
            }
            ++total_length;
        }

        if (buffer0 == NULL)
        {
            buffer0 = (PWCHAR)supVirtualAlloc((1 + total_length) * sizeof(WCHAR));
            if (!buffer0)
                break;
        }
        else
        {
            f = CreateFile(FileName,
                GENERIC_WRITE | SYNCHRONIZE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

            if (f != INVALID_HANDLE_VALUE) {

                WriteFile(f, buffer0,
                    (DWORD)(total_length * sizeof(WCHAR)),
                    &iobytes, NULL);

                CloseHandle(f);
                result = TRUE;
            }
            supVirtualFree(buffer0);
        }
        buffer = buffer0;
    }

    supVirtualFree(text);
    return result;
}

/*
* supListViewExportToFile
*
* Purpose:
*
* Export listview contents to the specified file.
*
*/
BOOL supListViewExportToFile(
    _In_ LPCWSTR FileName,
    _In_ HWND WindowHandle,
    _In_ HWND ListView
)
{
    BOOL bResult = FALSE;
    WCHAR szExportFileName[MAX_PATH + 1];

    RtlSecureZeroMemory(&szExportFileName, sizeof(szExportFileName));

    _strcpy(szExportFileName, FileName);
    if (supSaveDialogExecute(WindowHandle,
        (LPWSTR)&szExportFileName,
        T_CSV_FILE_FILTER))
    {
        SetCapture(WindowHandle);
        supSetWaitCursor(TRUE);

        bResult = supxListViewExportCSV(ListView, szExportFileName);

        supSetWaitCursor(FALSE);
        ReleaseCapture();
    }

    return bResult;
}

/*
* supStatusBarSetText
*
* Purpose:
*
* Display status in status bar part.
*
*/
VOID supStatusBarSetText(
    _In_ HWND hwndStatusBar,
    _In_ WPARAM partIndex,
    _In_ LPCWSTR lpText
)
{
    SendMessage(hwndStatusBar, SB_SETTEXT, partIndex, (LPARAM)lpText);
}

/*
* supJumpToFileListView
*
* Purpose:
*
* Jump from listview to file on disk.
*
*/
VOID supJumpToFileListView(
    _In_ HWND hwndList,
    _In_ INT iFileNameColumn
)
{
    INT iPos;
    LPWSTR lpDriverName = NULL, lpConvertedName = NULL;
    SIZE_T sz;

    do {

        iPos = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
        if (iPos < 0)
            break;

        lpConvertedName = (LPWSTR)supHeapAlloc(UNICODE_STRING_MAX_BYTES);
        if (lpConvertedName == NULL)
            break;

        sz = 0;
        lpDriverName = supGetItemText(hwndList, iPos, iFileNameColumn, &sz);
        if (lpDriverName == NULL)
            break;

        lpConvertedName = supGetWin32FileName(lpDriverName);
        if (lpConvertedName) {
            supJumpToFile(lpConvertedName);
            supHeapFree(lpConvertedName);
        }

    } while (FALSE);

    if (lpDriverName) supHeapFree(lpDriverName);
}

/*
* supQueryAlpcPortObjectTypeIndex
*
* Purpose:
*
* Create dummy WinObjEx ALPC port, remember it object type index and destroy port.
*
*/
VOID supQueryAlpcPortObjectTypeIndex(
    _In_ PVOID PortIndexData
)
{
    PALPCPORT_TYPE_INDEX portIndexData = (PALPCPORT_TYPE_INDEX)PortIndexData;
    NTSTATUS ntStatus;
    HANDLE portHandle = NULL;
    UNICODE_STRING portName = RTL_CONSTANT_STRING(L"\\Rpc Control\\WinObjEx64Port");
    OBJECT_ATTRIBUTES objectAttributes;
    PSYSTEM_HANDLE_INFORMATION_EX pHandles = NULL;

    ULONG sdLength;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID SeWorldSid = NULL;
    PSID SeRestrictedSid = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;

    do {

        SeWorldSid = supHeapAlloc(RtlLengthRequiredSid(1));
        if (SeWorldSid == NULL)
            break;

        RtlInitializeSid(SeWorldSid, &WorldSidAuthority, 1);
        *(RtlSubAuthoritySid(SeWorldSid, 0)) = SECURITY_WORLD_RID;

        ntStatus = RtlAllocateAndInitializeSid(&NtAuthority,
            1,
            SECURITY_RESTRICTED_CODE_RID,
            0, 0, 0, 0, 0, 0, 0,
            &SeRestrictedSid);

        if (!NT_SUCCESS(ntStatus))
            break;

        sdLength = SECURITY_DESCRIPTOR_MIN_LENGTH +
            (ULONG)sizeof(ACL) +
            (ULONG)(2 * sizeof(ACCESS_ALLOWED_ACE)) +
            RtlLengthSid(SeWorldSid) +
            RtlLengthSid(SeRestrictedSid) +
            8;

        pSD = supHeapAlloc(sdLength);
        if (pSD == NULL)
            break;

        pDacl = (PACL)((PCHAR)pSD + SECURITY_DESCRIPTOR_MIN_LENGTH);

        ntStatus = RtlCreateSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlCreateAcl(pDacl, (ULONG)(sdLength - SECURITY_DESCRIPTOR_MIN_LENGTH), ACL_REVISION2);
        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlAddAccessAllowedAce(pDacl,
            ACL_REVISION2,
            PORT_ALL_ACCESS,
            SeWorldSid);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlAddAccessAllowedAce(pDacl,
            ACL_REVISION2,
            PORT_ALL_ACCESS,
            SeRestrictedSid);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlSetDaclSecurityDescriptor(pSD,
            TRUE,
            pDacl,
            FALSE);

        if (!NT_SUCCESS(ntStatus))
            break;

        InitializeObjectAttributes(&objectAttributes, &portName, OBJ_CASE_INSENSITIVE, NULL, pSD);

        ntStatus = NtCreatePort(&portHandle,
            &objectAttributes,
            0,
            sizeof(PORT_MESSAGE),
            0);

        if (NT_SUCCESS(ntStatus)) {

            pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation,
                NULL);
            if (pHandles) {

                //
                // Query ALPC port object type.
                //
                if (supQueryObjectFromHandleEx(pHandles,
                    portHandle,
                    NULL,
                    &portIndexData->TypeIndex))
                {
                    portIndexData->Valid = TRUE;
                }

                supHeapFree(pHandles);
            }

            //
            // Destroy port object.
            //
            NtClose(portHandle);
        }

    } while (FALSE);

    if (SeWorldSid) supHeapFree(SeWorldSid);
    if (SeRestrictedSid) RtlFreeSid(SeRestrictedSid);
    if (pSD) supHeapFree(pSD);

}

/*
* supQueryProcessImageFileNameWin32
*
* Purpose:
*
* Query Win32 process filename.
*
*/
NTSTATUS supQueryProcessImageFileNameWin32(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING * ProcessImageFileName
)
{
    NTSTATUS ntStatus;
    HANDLE hProcess = NULL;

    *ProcessImageFileName = NULL;

    ntStatus = supOpenProcess(UniqueProcessId,
        PROCESS_QUERY_LIMITED_INFORMATION,
        &hProcess);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = supQueryProcessInformation(hProcess,
            ProcessImageFileNameWin32,
            ProcessImageFileName,
            NULL);

        NtClose(hProcess);

    }

    return ntStatus;
}

/*
* supQueryProcessImageFileNameByProcessId
*
* Purpose:
*
* Query process filename by process id in native format.
*
*/
NTSTATUS supQueryProcessImageFileNameByProcessId(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING ProcessImageFileName
)
{
    return ntsupQueryProcessImageFileNameByProcessId(UniqueProcessId,
        ProcessImageFileName,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);
}

/*
* supGetSidFromAce
*
* Purpose:
*
* Return Sid associated with Ace.
*
*/
PSID supGetSidFromAce(
    _In_ PACE_HEADER AceHeader
)
{
    PACCESS_ALLOWED_OBJECT_ACE paoa = (PACCESS_ALLOWED_OBJECT_ACE)AceHeader;

    if (AceHeader->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
        AceHeader->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)
    {
        switch (paoa->Flags & (ACE_OBJECT_TYPE_PRESENT | ACE_INHERITED_OBJECT_TYPE_PRESENT)) {
        case 0:
            return &((PACCESS_ALLOWED_OBJECT_ACE)AceHeader)->ObjectType;
        case ACE_OBJECT_TYPE_PRESENT:
        case ACE_INHERITED_OBJECT_TYPE_PRESENT:
            return &((PACCESS_ALLOWED_OBJECT_ACE)AceHeader)->InheritedObjectType;
        default:
            return &((PACCESS_ALLOWED_OBJECT_ACE)AceHeader)->SidStart;
        }
    }

    return &((PACCESS_ALLOWED_ACE)AceHeader)->SidStart;
}

/*
* supHandleContextMenuMsgForListView
*
* Purpose:
*
* WM_CONTEXT handler for dialogs with a listview.
*
*/
VOID supHandleContextMenuMsgForListView(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam,
    _In_ HWND hwndControl,
    _In_ pfnPopupMenuHandler MenuHandler,
    _In_opt_ PVOID lpUserParam
)
{
    INT mark;
    RECT crc;

    if ((HWND)wParam == hwndControl) {

        mark = ListView_GetSelectionMark(hwndControl);

        RtlSecureZeroMemory(&crc, sizeof(crc));
        if (lParam == MAKELPARAM(-1, -1)) {
            ListView_GetItemRect(hwndControl, mark, &crc, TRUE);
            crc.top = crc.bottom;
            ClientToScreen(hwndControl, (LPPOINT)&crc);
        }
        else
            GetCursorPos((LPPOINT)&crc);

        MenuHandler(hwndDlg, (LPPOINT)&crc, lpUserParam);

    }
}

/*
* supAddLVColumnsFromArray
*
* Purpose:
*
* Add columns from array to the listview.
*
*/
ULONG supAddLVColumnsFromArray(
    _In_ HWND ListView,
    _In_ PLVCOLUMNS_DATA ColumnsData,
    _In_ ULONG NumberOfColumns
)
{
    ULONG iColumn;

    for (iColumn = 0; iColumn < NumberOfColumns; iColumn++) {

        if (-1 == supAddListViewColumn(ListView,
            iColumn,
            iColumn,
            iColumn,
            ColumnsData[iColumn].ImageIndex,
            ColumnsData[iColumn].Format,
            ColumnsData[iColumn].Name,
            ColumnsData[iColumn].Width))
        {
            break;
        }
    }

    return iColumn;
}

/*
* supExtractFileName
*
* Purpose:
*
* Return filename part from given path.
*
*/
wchar_t* supExtractFileName(
    _In_ const wchar_t* lpFullPath
)
{
    wchar_t* p = (wchar_t*)lpFullPath;

    if (lpFullPath == 0)
        return 0;

    while (*lpFullPath != (wchar_t)0) {
        if (*lpFullPath == (wchar_t)'\\')
            p = (wchar_t*)lpFullPath + 1;
        lpFullPath++;
    }
    return p;
}

/*
* supObjectDumpHandlePopupMenu
*
* Purpose:
*
* Object dump popup construction
*
*/
VOID supObjectDumpHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ HWND hwndTreeList,
    _In_ INT * pSubItemHit,
    _In_ LPARAM lParam
)
{
    POINT pt1;
    HMENU hMenu;

    if (GetCursorPos(&pt1) == FALSE)
        return;

    hMenu = CreatePopupMenu();
    if (hMenu) {

        if (supTreeListAddCopyValueItem(hMenu,
            hwndTreeList,
            ID_OBJECT_COPY,
            0,
            lParam,
            pSubItemHit))
        {
            TrackPopupMenu(hMenu, TPM_RIGHTBUTTON | TPM_LEFTALIGN, pt1.x, pt1.y, 0, hwndDlg, NULL);
        }
        DestroyMenu(hMenu);
    }
}

/*
* supObDumpShowError
*
* Purpose:
*
* Hide all windows for given hwnd and display error text with custom text if specified.
*
*/
VOID supObDumpShowError(
    _In_ HWND hwndDlg,
    _In_opt_ LPWSTR lpMessageText
)
{
    ENUMCHILDWNDDATA ChildWndData;

    if (GetWindowRect(hwndDlg, &ChildWndData.Rect)) {
        ChildWndData.nCmdShow = SW_HIDE;
        EnumChildWindows(hwndDlg, supCallbackShowChildWindow, (LPARAM)&ChildWndData);
    }

    if (lpMessageText) {
        SetDlgItemText(hwndDlg, ID_OBJECTDUMPERROR, lpMessageText);
    }

    ShowWindow(GetDlgItem(hwndDlg, ID_OBJECTDUMPERROR), SW_SHOW);
}

/*
* supGetFirmwareType
*
* Purpose:
*
* Return firmware type.
*
*/
NTSTATUS supGetFirmwareType(
    _Out_ PFIRMWARE_TYPE FirmwareType
)
{
    NTSTATUS ntStatus;
    ULONG returnLength = 0;
    SYSTEM_BOOT_ENVIRONMENT_INFORMATION sbei;

    *FirmwareType = FirmwareTypeUnknown;

    RtlSecureZeroMemory(&sbei, sizeof(sbei));

    ntStatus = NtQuerySystemInformation(SystemBootEnvironmentInformation,
        &sbei,
        sizeof(sbei),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        *FirmwareType = sbei.FirmwareType;

    }

    return ntStatus;
}

/*
* supIsBootDriveVHD
*
* Purpose:
*
* Query if the current boot drive is VHD type.
*
*/
NTSTATUS supIsBootDriveVHD(
    _Out_ PBOOLEAN IsVHD
)
{
    NTSTATUS ntStatus;
    ULONG returnLength = 0;
    SYSTEM_VHD_BOOT_INFORMATION* psvbi;

    *IsVHD = FALSE;

    psvbi = (SYSTEM_VHD_BOOT_INFORMATION*)supHeapAlloc(PAGE_SIZE);
    if (psvbi) {
        ntStatus = NtQuerySystemInformation(SystemVhdBootInformation, psvbi, PAGE_SIZE, &returnLength);
        if (NT_SUCCESS(ntStatus)) {
            *IsVHD = psvbi->OsDiskIsVhd;
        }
        supHeapFree(psvbi);
    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*
* supPathAddBackSlash
*
* Purpose:
*
* Add trailing backslash to the path if it doesn't have one.
*
*/
LPWSTR supPathAddBackSlash(
    _In_ LPWSTR lpszPath
)
{
    SIZE_T nLength;
    LPWSTR lpszEnd, lpszPrev, lpszResult = NULL;

    nLength = _strlen(lpszPath);

    if (nLength) {

        lpszEnd = lpszPath + nLength;

        if (lpszPath == lpszEnd)
            lpszPrev = lpszPath;
        else
            lpszPrev = (LPWSTR)lpszEnd - 1;

        if (*lpszPrev != TEXT('\\')) {
            *lpszEnd++ = TEXT('\\');
            *lpszEnd = TEXT('\0');
        }

        lpszResult = lpszEnd;

    }

    return lpszResult;
}

__inline WCHAR nibbletoh(BYTE c, BOOLEAN upcase)
{
    if (c < 10)
        return L'0' + c;

    c -= 10;

    if (upcase)
        return L'A' + c;

    return L'a' + c;
}

/*
* supPrintHash
*
* Purpose:
*
* Output hash.
* Returned buffer must be freed with supHeapFree when no longer needed.
*
*/
LPWSTR supPrintHash(
    _In_reads_bytes_(Length) LPBYTE Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN UpcaseHex
)
{
    ULONG   c;
    PWCHAR  lpText;
    BYTE    x;

    lpText = (LPWSTR)supHeapAlloc((2 * (SIZE_T)Length + 1) * sizeof(WCHAR));
    if (lpText) {

        for (c = 0; c < Length; ++c) {
            x = Buffer[c];

            lpText[c * 2] = nibbletoh(x >> 4, UpcaseHex);
            lpText[c * 2 + 1] = nibbletoh(x & 15, UpcaseHex);
        }
#pragma warning(push)
#pragma warning(disable: 6305)
        lpText[Length * 2] = 0;
#pragma warning(pop)
    }

    return lpText;
}

/*
* supDestroyFileViewInfo
*
* Purpose:
*
* Deallocate file view information resources.
*
*/
VOID supDestroyFileViewInfo(
    _In_ PFILE_VIEW_INFO ViewInformation
)
{
    if (ViewInformation->FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(ViewInformation->FileHandle);
        ViewInformation->FileHandle = INVALID_HANDLE_VALUE;
    }
    if (ViewInformation->SectionHandle) {
        NtClose(ViewInformation->SectionHandle);
        ViewInformation->SectionHandle = NULL;
    }
    if (ViewInformation->ViewBase) {
        if (NT_SUCCESS(NtUnmapViewOfSection(NtCurrentProcess(),
            ViewInformation->ViewBase)))
        {
            ViewInformation->ViewBase = NULL;
            ViewInformation->ViewSize = 0;
        }
    }

    ViewInformation->NtHeaders = NULL;
    ViewInformation->FileSize.QuadPart = 0;
}

/*
* supxInitializeFileViewInfo
*
* Purpose:
*
* Open file for mapping, create section, remember file size.
*
*/
NTSTATUS supxInitializeFileViewInfo(
    _In_ PFILE_VIEW_INFO ViewInformation
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE fileHandle, sectionHandle = NULL;
    LARGE_INTEGER fileSize;

    fileSize.QuadPart = 0;
    fileHandle = CreateFile(ViewInformation->FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_SUPPORTS_BLOCK_REFCOUNTING | FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (fileHandle != INVALID_HANDLE_VALUE) {

        if (!GetFileSizeEx(fileHandle, &fileSize)) {
            CloseHandle(fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;
            ntStatus = STATUS_FILE_INVALID;
        }
        else {

            ntStatus = NtCreateSection(
                &sectionHandle,
                SECTION_QUERY | SECTION_MAP_READ,
                NULL,
                &fileSize,
                PAGE_READONLY,
                SEC_COMMIT,
                fileHandle);

            if (!NT_SUCCESS(ntStatus)) {
                CloseHandle(fileHandle);
                fileHandle = INVALID_HANDLE_VALUE;
            }

        }

    }
    else {
        ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    ViewInformation->Status = StatusOk;
    ViewInformation->FileHandle = fileHandle;
    ViewInformation->FileSize = fileSize;
    ViewInformation->SectionHandle = sectionHandle;

    return ntStatus;
}

/*
* supMapInputFileForRead
*
* Purpose:
*
* Create mapped section from input file.
*
*/
NTSTATUS supMapInputFileForRead(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ BOOLEAN PartialMap
)
{
    NTSTATUS ntStatus;
    SIZE_T viewSize;

    ntStatus = supxInitializeFileViewInfo(ViewInformation);
    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    if (PartialMap) {

        if (ViewInformation->FileSize.QuadPart < RTL_MEG)
            viewSize = (SIZE_T)ViewInformation->FileSize.QuadPart;
        else
            viewSize = (SIZE_T)RTL_MEG;

    }
    else {

        viewSize = (SIZE_T)ViewInformation->FileSize.QuadPart;

    }

    ntStatus = NtMapViewOfSection(ViewInformation->SectionHandle,
        NtCurrentProcess(),
        &ViewInformation->ViewBase,
        0,
        0,
        NULL,
        &viewSize,
        ViewShare,
        0,
        PAGE_READONLY);

    if (NT_SUCCESS(ntStatus))
        ViewInformation->ViewSize = viewSize;

    return ntStatus;
}

#pragma warning(push)
#pragma warning(disable: 4319)

/*
* supxValidateNtHeader
*
* Purpose:
*
* Common validation for file image header.
*
*/
BOOLEAN supxValidateNtHeader(
    _In_ PIMAGE_NT_HEADERS Header,
    _Out_ PIMAGE_VERIFY_STATUS VerifyStatus
)
{
    INT i;
    ULONG64 lastSectionVA;
    PIMAGE_NT_HEADERS32 pHdr32;
    PIMAGE_NT_HEADERS64 pHdr64;
    PIMAGE_SECTION_HEADER pSection;

    if (Header->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {

        pHdr64 = (PIMAGE_NT_HEADERS64)(Header);

        if (((pHdr64->OptionalHeader.FileAlignment & 511) != 0) &&
            (pHdr64->OptionalHeader.FileAlignment != pHdr64->OptionalHeader.SectionAlignment))
        {
            *VerifyStatus = StatusBadFileAlignment;
            return FALSE;
        }

        if (pHdr64->OptionalHeader.FileAlignment == 0) {
            *VerifyStatus = StatusBadFileAlignment;
            return FALSE;
        }

        if (((pHdr64->OptionalHeader.SectionAlignment - 1) &
            pHdr64->OptionalHeader.SectionAlignment) != 0)
        {
            *VerifyStatus = StatusBadSectionAlignment;
            return FALSE;
        }

        if (((pHdr64->OptionalHeader.FileAlignment - 1) &
            pHdr64->OptionalHeader.FileAlignment) != 0)
        {
            *VerifyStatus = StatusBadFileAlignment;
            return FALSE;
        }

        if (pHdr64->OptionalHeader.SectionAlignment < pHdr64->OptionalHeader.FileAlignment) {
            *VerifyStatus = StatusBadSectionAlignment;
            return FALSE;
        }

        if (pHdr64->OptionalHeader.SizeOfImage > MM_SIZE_OF_LARGEST_IMAGE) {
            *VerifyStatus = StatusBadSizeOfImage;
            return FALSE;
        }

        if (pHdr64->FileHeader.NumberOfSections > MM_MAXIMUM_IMAGE_SECTIONS) {
            *VerifyStatus = StatusBadSectionCount;
            return FALSE;
        }

        if (pHdr64->FileHeader.Machine != IMAGE_FILE_MACHINE_IA64 &&
            pHdr64->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
        {
            *VerifyStatus = StatusBadFileHeaderMachine;
            return FALSE;
        }

    }
    else if (Header->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {

        pHdr32 = (PIMAGE_NT_HEADERS32)(Header);

        if (((pHdr32->OptionalHeader.FileAlignment & 511) != 0) &&
            (pHdr32->OptionalHeader.FileAlignment != pHdr32->OptionalHeader.SectionAlignment))
        {
            *VerifyStatus = StatusBadFileAlignment;
            return FALSE;
        }

        if (pHdr32->OptionalHeader.FileAlignment == 0) {
            *VerifyStatus = StatusBadFileAlignment;
            return FALSE;
        }

        if (((pHdr32->OptionalHeader.SectionAlignment - 1) &
            pHdr32->OptionalHeader.SectionAlignment) != 0)
        {
            *VerifyStatus = StatusBadSectionAlignment;
            return FALSE;
        }

        if (((pHdr32->OptionalHeader.FileAlignment - 1) &
            pHdr32->OptionalHeader.FileAlignment) != 0)
        {
            *VerifyStatus = StatusBadFileAlignment;
            return FALSE;
        }

        if (pHdr32->OptionalHeader.SectionAlignment < pHdr32->OptionalHeader.FileAlignment) {
            *VerifyStatus = StatusBadSectionAlignment;
            return FALSE;
        }

        if (pHdr32->OptionalHeader.SizeOfImage > MM_SIZE_OF_LARGEST_IMAGE) {
            *VerifyStatus = StatusBadSizeOfImage;
            return FALSE;
        }

        if (pHdr32->FileHeader.NumberOfSections > MM_MAXIMUM_IMAGE_SECTIONS) {
            *VerifyStatus = StatusBadSectionCount;
            return FALSE;
        }

        if ((pHdr32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &&
            !(pHdr32->FileHeader.Machine == IMAGE_FILE_MACHINE_I386))
        {
            *VerifyStatus = StatusBadFileHeaderMachine;
            return FALSE;
        }

    }
    else {
        *VerifyStatus = StatusBadOptionalHeaderMagic;
        return FALSE;
    }

    pSection = IMAGE_FIRST_SECTION(Header);

    lastSectionVA = (ULONG64)pSection->VirtualAddress;

    for (i = 0; i < Header->FileHeader.NumberOfSections; i++, pSection++) {

        if (pSection->VirtualAddress != lastSectionVA) {
            *VerifyStatus = StatusBadNtHeaders;
            return FALSE;
        }

        lastSectionVA += ALIGN_UP_BY(pSection->Misc.VirtualSize,
            Header->OptionalHeader.SectionAlignment);

    }

    if (lastSectionVA != Header->OptionalHeader.SizeOfImage) {
        *VerifyStatus = StatusBadNtHeaders;
        return FALSE;
    }

    *VerifyStatus = StatusOk;
    return TRUE;
}

#pragma warning(pop)

/*
* supIsValidImage
*
* Purpose:
*
* Check whatever image is in valid PE format.
*
*/
BOOLEAN supIsValidImage(
    _In_ PFILE_VIEW_INFO ViewInformation
)
{
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_NT_HEADERS ntHeaders;
    ULONG fileSize, ntOffset, neededSize;
    USHORT secCount;

    ViewInformation->Status = StatusUnknownError;

    if (ViewInformation->ViewBase == NULL)
        return FALSE;

    fileSize = ViewInformation->FileSize.LowPart;

    __try {

        if (fileSize < sizeof(IMAGE_DOS_HEADER)) {
            ViewInformation->Status = StatusBadDosMagic;
            return FALSE;
        }

        dosHeader = (PIMAGE_DOS_HEADER)ViewInformation->ViewBase;

        if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            ViewInformation->Status = StatusBadDosMagic;
            return FALSE;
        }

        ntOffset = (ULONG)dosHeader->e_lfanew;

        if (ntOffset == 0 ||
            ntOffset > RTLP_IMAGE_MAX_DOS_HEADER ||
            ntOffset > fileSize - sizeof(IMAGE_NT_HEADERS)) {
            ViewInformation->Status = StatusBadNewExeOffset;
            return FALSE;
        }

        ntHeaders = (PIMAGE_NT_HEADERS)((PBYTE)ViewInformation->ViewBase + ntOffset);

        if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) {
            ViewInformation->Status = StatusBadNtSignature;
            return FALSE;
        }

        secCount = ntHeaders->FileHeader.NumberOfSections;

        if (secCount == 0 || secCount > MM_MAXIMUM_IMAGE_SECTIONS) {
            ViewInformation->Status = StatusBadSectionCount;
            return FALSE;
        }

        //
        // Ensure section headers array fits in file.
        //
        neededSize = ntOffset +
            sizeof(IMAGE_NT_HEADERS) +
            (secCount - 1) * sizeof(IMAGE_SECTION_HEADER);

        if (neededSize < ntOffset || neededSize > fileSize) {
            ViewInformation->Status = StatusBadNtHeaders;
            return FALSE;
        }

        if (ntHeaders->FileHeader.SizeOfOptionalHeader == 0 ||
            (ntHeaders->FileHeader.SizeOfOptionalHeader & (sizeof(ULONG_PTR) - 1))) {
            ViewInformation->Status = StatusBadOptionalHeader;
            return FALSE;
        }

        if (!(ntHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
            ViewInformation->Status = StatusBadFileHeaderCharacteristics;
            return FALSE;
        }

        if (ntHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64 &&
            ntHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) {
            ViewInformation->Status = StatusBadFileHeaderMachine;
            return FALSE;
        }

        if (!supxValidateNtHeader(ntHeaders, &ViewInformation->Status))
            return FALSE;

        ViewInformation->NtHeaders = ntHeaders;
        return TRUE;

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ViewInformation->Status = StatusExceptionOccurred;
        return FALSE;
    }
}

/*
* supxCreateDriverEntry
*
* Purpose:
*
* Creating registry entry for driver.
*
*/
NTSTATUS supxCreateDriverEntry(
    _In_opt_ LPCWSTR DriverPath,
    _In_ LPCWSTR KeyName
)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    DWORD dwData, dwResult;
    HKEY keyHandle = NULL;
    UNICODE_STRING driverImagePath;

    RtlInitEmptyUnicodeString(&driverImagePath, NULL, 0);

    if (DriverPath) {
        if (!RtlDosPathNameToNtPathName_U(DriverPath,
            &driverImagePath,
            NULL,
            NULL))
        {
            return STATUS_INVALID_PARAMETER_2;
        }
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
        KeyName,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &keyHandle,
        NULL))
    {
        status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    dwResult = ERROR_SUCCESS;

    do {

        dwData = SERVICE_ERROR_NORMAL;
        dwResult = RegSetValueEx(keyHandle,
            TEXT("ErrorControl"),
            0,
            REG_DWORD,
            (BYTE*)&dwData,
            sizeof(dwData));
        if (dwResult != ERROR_SUCCESS)
            break;

        dwData = SERVICE_KERNEL_DRIVER;
        dwResult = RegSetValueEx(keyHandle,
            TEXT("Type"),
            0,
            REG_DWORD,
            (BYTE*)&dwData,
            sizeof(dwData));
        if (dwResult != ERROR_SUCCESS)
            break;

        dwData = SERVICE_DEMAND_START;
        dwResult = RegSetValueEx(keyHandle,
            TEXT("Start"),
            0,
            REG_DWORD,
            (BYTE*)&dwData,
            sizeof(dwData));

        if (dwResult != ERROR_SUCCESS)
            break;

        if (DriverPath) {
            dwResult = RegSetValueEx(keyHandle,
                TEXT("ImagePath"),
                0,
                REG_EXPAND_SZ,
                (BYTE*)driverImagePath.Buffer,
                (DWORD)driverImagePath.Length + sizeof(UNICODE_NULL));
        }

    } while (FALSE);

    RegCloseKey(keyHandle);

    if (dwResult != ERROR_SUCCESS) {
        status = STATUS_ACCESS_DENIED;
    }
    else
    {
        status = STATUS_SUCCESS;
    }

Cleanup:
    if (DriverPath) {
        if (driverImagePath.Buffer) {
            RtlFreeUnicodeString(&driverImagePath);
        }
    }
    return status;
}

/*
* supLoadDriverEx
*
* Purpose:
*
* Install driver and load it.
*
* N.B.
* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.
*
*/
NTSTATUS supLoadDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam
)
{
    SIZE_T keyOffset;
    NTSTATUS status;
    UNICODE_STRING driverServiceName;

    WCHAR szBuffer[MAX_PATH + 1];

    if (DriverName == NULL)
        return STATUS_INVALID_PARAMETER_1;
    if (DriverPath == NULL)
        return STATUS_INVALID_PARAMETER_2;

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

    keyOffset = RTL_NUMBER_OF(NT_REG_PREP);

    if (FAILED(RtlStringCchPrintfSecure(szBuffer, MAX_PATH,
        DRIVER_REGKEY,
        NT_REG_PREP,
        DriverName)))
    {
        return STATUS_INVALID_PARAMETER_1;
    }

    status = supxCreateDriverEntry(DriverPath,
        &szBuffer[keyOffset]);

    if (!NT_SUCCESS(status))
        return status;

    RtlInitUnicodeString(&driverServiceName, szBuffer);

    if (Callback) {
        status = Callback(&driverServiceName, CallbackParam);
        if (!NT_SUCCESS(status))
            return status;
    }

    if (supEnablePrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE)) {

        status = NtLoadDriver(&driverServiceName);

        if (UnloadPreviousInstance) {
            if ((status == STATUS_IMAGE_ALREADY_LOADED) ||
                (status == STATUS_OBJECT_NAME_COLLISION) ||
                (status == STATUS_OBJECT_NAME_EXISTS))
            {
                status = NtUnloadDriver(&driverServiceName);
                if (NT_SUCCESS(status)) {
                    status = NtLoadDriver(&driverServiceName);
                }
            }
        }
        else {
            if (status == STATUS_OBJECT_NAME_EXISTS)
                status = STATUS_SUCCESS;
        }

        supEnablePrivilege(SE_LOAD_DRIVER_PRIVILEGE, FALSE);
    }
    else {
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    return status;
}

/*
* supLoadDriver
*
* Purpose:
*
* Install driver and load it.
*
* N.B.
* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.
*
*/
NTSTATUS supLoadDriver(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance
)
{
    return supLoadDriverEx(DriverName,
        DriverPath,
        UnloadPreviousInstance,
        NULL,
        NULL);
}

/*
* supUnloadDriver
*
* Purpose:
*
* Call driver unload and remove corresponding registry key.
*
* N.B.
* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.
*
*/
NTSTATUS supUnloadDriver(
    _In_ LPCWSTR DriverName,
    _In_ BOOLEAN fRemove
)
{
    NTSTATUS status;
    SIZE_T keyOffset;
    UNICODE_STRING driverServiceName;

    WCHAR szBuffer[MAX_PATH + 1];

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

    if (FAILED(RtlStringCchPrintfSecure(szBuffer, MAX_PATH,
        DRIVER_REGKEY,
        NT_REG_PREP,
        DriverName)))
    {
        return STATUS_INVALID_PARAMETER_1;
    }

    keyOffset = RTL_NUMBER_OF(NT_REG_PREP);

    status = supxCreateDriverEntry(NULL,
        &szBuffer[keyOffset]);

    if (!NT_SUCCESS(status))
        return status;

    if (supEnablePrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE)) {

        RtlInitUnicodeString(&driverServiceName, szBuffer);
        status = NtUnloadDriver(&driverServiceName);

        supEnablePrivilege(SE_LOAD_DRIVER_PRIVILEGE, FALSE);
    }
    else {
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    if (NT_SUCCESS(status)) {
        if (fRemove)
            supRegDeleteKeyTree(HKEY_LOCAL_MACHINE, &szBuffer[keyOffset]);
    }

    return status;
}

/*
* supOpenDriverEx
*
* Purpose:
*
* Open handle for driver.
*
*/
NTSTATUS supOpenDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE DeviceHandle
)
{
    HANDLE deviceHandle = NULL;
    UNICODE_STRING usDeviceLink;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iost;

    NTSTATUS ntStatus;

    RtlInitUnicodeString(&usDeviceLink, DriverName);
    InitializeObjectAttributes(&obja, &usDeviceLink, OBJ_CASE_INSENSITIVE, NULL, NULL);

    ntStatus = NtCreateFile(&deviceHandle,
        DesiredAccess,
        &obja,
        &iost,
        NULL,
        0,
        0,
        FILE_OPEN,
        0,
        NULL,
        0);

    if (NT_SUCCESS(ntStatus)) {
        if (DeviceHandle)
            *DeviceHandle = deviceHandle;
    }

    return ntStatus;
}

/*
* supOpenDriver
*
* Purpose:
*
* Open handle for driver through \\DosDevices.
*
*/
NTSTATUS supOpenDriver(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE DeviceHandle
)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    WCHAR szDeviceLink[MAX_PATH + 1];

    // assume failure
    if (DeviceHandle)
        *DeviceHandle = NULL;
    else
        return STATUS_INVALID_PARAMETER_2;

    if (DriverName) {

        RtlSecureZeroMemory(szDeviceLink, sizeof(szDeviceLink));

        if (FAILED(RtlStringCchPrintfSecure(szDeviceLink,
            MAX_PATH,
            TEXT("\\DosDevices\\%wS"),
            DriverName)))
        {
            return STATUS_INVALID_PARAMETER_1;
        }

        status = supOpenDriverEx(szDeviceLink,
            DesiredAccess,
            DeviceHandle);

        if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
            status == STATUS_NO_SUCH_DEVICE)
        {

            //
            // Check the case when no symlink available.
            //

            RtlSecureZeroMemory(szDeviceLink, sizeof(szDeviceLink));

            if (FAILED(RtlStringCchPrintfSecure(szDeviceLink,
                MAX_PATH,
                TEXT("\\Device\\%wS"),
                DriverName)))
            {
                return STATUS_INVALID_PARAMETER_1;
            }

            status = supOpenDriverEx(szDeviceLink,
                DesiredAccess,
                DeviceHandle);

        }

    }
    else {
        status = STATUS_INVALID_PARAMETER_1;
    }

    return status;
}

/*
* supDeleteFileWithWait
*
* Purpose:
*
* Removes file from disk.
*
*/
BOOL supDeleteFileWithWait(
    _In_ ULONG WaitMilliseconds,
    _In_ ULONG NumberOfAttempts,
    _In_ LPCWSTR lpFileName
)
{
    ULONG retryCount = NumberOfAttempts;

    do {

        Sleep(WaitMilliseconds);
        if (DeleteFile(lpFileName)) {
            return TRUE;
        }

        retryCount--;

    } while (retryCount);

    return FALSE;
}

/*
* supCallDriver
*
* Purpose:
*
* Call driver.
*
*/
NTSTATUS supCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength)
{
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);
}

/*
* supIsLongTermServicingWindows
*
* Purpose:
*
* Attempt to detect LTSC/LTSB product type.
*
*/
BOOLEAN supIsLongTermServicingWindows(
    VOID
)
{
    NTSTATUS ntStatus;
    ULONG dataLicense = 0, dataSize = 0, dataType = 0, i;

    UNICODE_STRING usLicenseValue = RTL_CONSTANT_STRING(L"Kernel-ProductInfo");

    DWORD suiteType[] = {
        PRODUCT_ENTERPRISE_S,              // LTSB/C
        PRODUCT_ENTERPRISE_S_N,            // LTSB/C N
        PRODUCT_ENTERPRISE_S_EVALUATION,   // LTSB/C Evaluation
        PRODUCT_ENTERPRISE_S_N_EVALUATION, // LTSB/C N Evaluation
        PRODUCT_IOTENTERPRISES             // IoT Enterprise LTSC
    };

    ntStatus = NtQueryLicenseValue(
        &usLicenseValue,
        &dataType,
        (PVOID)&dataLicense,
        sizeof(DWORD),
        &dataSize);

    if (NT_SUCCESS(ntStatus) &&
        dataType == REG_DWORD &&
        dataSize == sizeof(DWORD))
    {
        for (i = 0; i < RTL_NUMBER_OF(suiteType); i++) {
            if (dataLicense == suiteType[i]) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/*
* supCreateThread
*
* Purpose:
*
* CreateThread wrapper.
* Returned handle must be closed by caller.
*
*/
HANDLE supCreateThread(
    _In_ LPTHREAD_START_ROUTINE lpStartAddress,
    _In_opt_ __drv_aliasesMem LPVOID lpParameter,
    _In_ DWORD dwCreationFlags
)
{
    HANDLE threadHandle;

    threadHandle = CreateThread(NULL,
        0,
        lpStartAddress,
        lpParameter,
        dwCreationFlags,
        NULL);

    if (threadHandle) {
        OBEX_STATS_INC(TotalThreadsCreated);
    }

    return threadHandle;
}

/*
* supCreateDialogWorkerThread
*
* Purpose:
*
* Create thread dedicated for dialog with specified name.
*
*/
HANDLE supCreateDialogWorkerThread(
    _In_ LPTHREAD_START_ROUTINE lpStartAddress,
    _In_opt_ __drv_aliasesMem LPVOID lpParameter,
    _In_ DWORD dwCreationFlags
)
{
    WCHAR szBuffer[100];
    THREAD_NAME_INFORMATION tni;
    HANDLE threadHandle = supCreateThread(lpStartAddress, lpParameter, dwCreationFlags | CREATE_SUSPENDED);

    if (threadHandle) {

        RtlStringCchPrintfSecure(szBuffer, RTL_NUMBER_OF(szBuffer),
            TEXT("DialogWorker_%p"),
            lpStartAddress);

        RtlInitUnicodeString(&tni.ThreadName, szBuffer);
        NtSetInformationThread(threadHandle, ThreadNameInformation, (PVOID)&tni, sizeof(tni));

        ResumeThread(threadHandle);
    }

    return threadHandle;
}

/*
* supGetCurrentObjectPath
*
* Purpose:
*
* Build full path to current object.
*
* If IncludeName is FALSE then result path does not
* include object name except for root directory.
*
* e.g.
* For \\              result will be \\
* For \\ABC           result will be \\
* For \\ABC\\DEF      result will be \\ABC
*
* If IncludeName is TRUE then result path *will*
* include object name
*
* e.g.
* For \\              result will be \\
* For \\ABC           result will be \\ABC
* For \\ABC\\DEF      result will be \\ABC\\DEF
*/
_Success_(return != FALSE)
BOOL supGetCurrentObjectPath(
    _In_ BOOLEAN IncludeName,
    _Out_ PUNICODE_STRING ObjectPath
)
{
    OBEX_PATH_ELEMENT* ObjectPathEntry;
    PLIST_ENTRY Head, Entry, FinalEntry, ObjectRootEntry = NULL;

    ULONG NameInfoSize, BufferLength;
    PWCH StringBuffer, ObjectName;

    PUNICODE_STRING String;

    RtlInitEmptyUnicodeString(ObjectPath, NULL, 0);

    if (IsListEmpty(&g_ObjectPathListHead))
        return FALSE;

    NameInfoSize = sizeof(UNICODE_NULL);

    Head = &g_ObjectPathListHead;
    Entry = Head->Blink;             // Beginning of path

    if (IncludeName) {
        FinalEntry = Head;
    }
    else {
        FinalEntry = Head->Flink;    // Current object name
    }

    ObjectRootEntry = Entry;
    while ((Entry) && (Entry != FinalEntry)) {

        ObjectPathEntry = CONTAINING_RECORD(Entry, OBEX_PATH_ELEMENT, ListEntry);
        NameInfoSize += ObjectPathEntry->Name.Length;

        //
        // If not last and first then add separator size.
        //
        if ((Entry != ObjectRootEntry) && (Entry->Blink != FinalEntry))
            NameInfoSize += OBJ_NAME_PATH_SEPARATOR_SIZE;

        Entry = Entry->Blink;
    }

    //
    // If this is root then leave.
    //
    if (NameInfoSize == sizeof(UNICODE_NULL)) {
        return supDuplicateUnicodeString(g_obexHeap, ObjectPath, ObGetPredefinedUnicodeString(OBP_ROOT));
    }

    ObjectName = (PWCH)supHeapAlloc(NameInfoSize);
    if (ObjectName == NULL)
        return FALSE;

    StringBuffer = ObjectName;

    Head = &g_ObjectPathListHead;
    Entry = Head->Blink;             // Beginning of path

    if (IncludeName) {
        FinalEntry = Head;
    }
    else {
        FinalEntry = Head->Flink;    // Current object name
    }

    ObjectRootEntry = Entry;
    while ((Entry) && (Entry != FinalEntry)) {

        ObjectPathEntry = CONTAINING_RECORD(Entry, OBEX_PATH_ELEMENT, ListEntry);

        String = &ObjectPathEntry->Name;

        RtlCopyMemory(StringBuffer, String->Buffer, String->Length);
        StringBuffer = (PWCH)((PCH)StringBuffer + String->Length);

        //
        // If not last and first then add separator.
        //
        if ((Entry != ObjectRootEntry) && (Entry->Blink != FinalEntry))
            *StringBuffer++ = OBJ_NAME_PATH_SEPARATOR;

        Entry = Entry->Blink;
    }

    *StringBuffer++ = UNICODE_NULL;

    BufferLength = (USHORT)((ULONG_PTR)StringBuffer - (ULONG_PTR)ObjectName);
    ObjectPath->Buffer = ObjectName;
    ObjectPath->Length = (USHORT)(BufferLength - sizeof(UNICODE_NULL));
    ObjectPath->MaximumLength = (USHORT)BufferLength;

    return TRUE;
}

/*
* supGetCurrentObjectName
*
* Purpose:
*
* Return name of currently selected object.
*
*/
_Success_(return)
BOOL supGetCurrentObjectName(
    _Out_ PUNICODE_STRING ObjectName
)
{
    OBEX_PATH_ELEMENT* entry = NULL;
    LIST_ENTRY* listEntry, * head;

    RtlInitEmptyUnicodeString(ObjectName, NULL, 0);

    if (IsListEmpty(&g_ObjectPathListHead))
        return FALSE;

    head = &g_ObjectPathListHead;
    listEntry = head->Flink;
    if (listEntry) {
        entry = CONTAINING_RECORD(listEntry, OBEX_PATH_ELEMENT, ListEntry);
        return supDuplicateUnicodeString(g_obexHeap, ObjectName, &entry->Name);
    }

    return FALSE;
}

/*
* supBuildCurrentObjectList
*
* Purpose:
*
* Create list of current object path elements including name.
*
*/
VOID supBuildCurrentObjectList(
    _In_ PVOID ListHead
)
{
    OBEX_ITEM* nextItem;
    OBEX_PATH_ELEMENT* entry = NULL;

    if (ObjectPathHeap)
        supDestroyHeap(ObjectPathHeap);

    ObjectPathHeap = supCreateHeap(HEAP_GROWABLE, TRUE);
    if (ObjectPathHeap == NULL)
        return;

    InitializeListHead(&g_ObjectPathListHead);

    nextItem = (OBEX_ITEM*)ListHead;
    while (nextItem) {
        entry = (OBEX_PATH_ELEMENT*)supHeapAllocEx(ObjectPathHeap, sizeof(OBEX_PATH_ELEMENT));
        if (entry) {
            entry->TypeIndex = nextItem->TypeIndex;
            supDuplicateUnicodeString(ObjectPathHeap, &entry->Name, &nextItem->Name);
            supDuplicateUnicodeString(ObjectPathHeap, &entry->TypeName, &nextItem->TypeName);
            InsertTailList(&g_ObjectPathListHead, &entry->ListEntry);
        }
        nextItem = nextItem->Prev;
    }

}

/*
* supNormalizeUnicodeStringForDisplay
*
* Purpose:
*
* Create a copy of unicode string, friendly for output.
*
*/
_Success_(return)
BOOL supNormalizeUnicodeStringForDisplay(
    _In_ HANDLE HeapHandle,
    _In_ PUNICODE_STRING SourceString,
    _Out_ PUNICODE_STRING NormalizedString
)
{
    PWCH stringBuffer, src, dst;
    ULONG i;

    stringBuffer = (PWCH)supHeapAllocEx(HeapHandle,
        SourceString->Length + sizeof(UNICODE_NULL));

    if (stringBuffer) {

        dst = stringBuffer;
        src = SourceString->Buffer;

        i = SourceString->Length / sizeof(WCHAR);
        while (i--) {

            if (*src == 0)
                *dst = g_ObNameNormalizationSymbol;
            else
                *dst = *src;

            src++;
            dst++;
        }

        *dst = UNICODE_NULL;

        RtlInitUnicodeString(NormalizedString, stringBuffer);
        return TRUE;
    }

    return FALSE;
}

/*
* supDisplayCurrentObjectPath
*
* Purpose:
*
* Output current object path to the control.
*
*/
VOID supDisplayCurrentObjectPath(
    _In_ HWND hwnd,
    _In_opt_ PUNICODE_STRING Path,
    _In_ BOOLEAN NormalizePath
)
{
    BOOL bNeedFree = FALSE;
    UNICODE_STRING us, ns;

    if (Path) {
        us = *Path;
    }
    else {
        if (!supGetCurrentObjectPath(TRUE, &us))
            return;

        bNeedFree = TRUE;
    }

    if (NormalizePath) {
        if (supNormalizeUnicodeStringForDisplay(g_obexHeap, &us, &ns)) {

            SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)ns.Buffer);

            supFreeUnicodeString(g_obexHeap, &ns);
        }
    }
    else {
        SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)us.Buffer);
    }

    if (bNeedFree)
        supFreeDuplicatedUnicodeString(g_obexHeap, &us, FALSE);

}

/*
* supResolveSymbolicLinkTarget
*
* Purpose:
*
* Resolve symbolic link target and copy it to the supplied buffer.
*
* Return FALSE on error.
*
*/
_Success_(return)
BOOL supResolveSymbolicLinkTarget(
    _In_opt_ HANDLE LinkHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Out_ PUNICODE_STRING LinkTarget
)
{
    BOOL bResult = FALSE;
    HANDLE hObject = NULL;
    ULONG rLen = 0;
    NTSTATUS ntStatus;
    UNICODE_STRING linkTarget;
    OBJECT_ATTRIBUTES obja;
    PWCH stringBuffer = NULL;

    RtlInitEmptyUnicodeString(LinkTarget, NULL, 0);

    do {
        //
        // If there is no handle - open it.
        //
        if (LinkHandle == NULL) {
            InitializeObjectAttributes(&obja, LinkName, OBJ_CASE_INSENSITIVE, RootDirectoryHandle, NULL);
            ntStatus = NtOpenSymbolicLinkObject(&hObject, SYMBOLIC_LINK_QUERY, &obja);
            if (!NT_SUCCESS(ntStatus))
                break;
        }
        else {
            hObject = LinkHandle;
        }

        RtlInitEmptyUnicodeString(&linkTarget, NULL, 0);
        ntStatus = NtQuerySymbolicLinkObject(hObject, &linkTarget, &rLen);

        //
        // Test if empty string and return appropriate result.
        //
        if (NT_SUCCESS(ntStatus) && rLen == 0) {

            LinkTarget->Buffer = (PWCH)supHeapAlloc(sizeof(WCHAR));
            if (LinkTarget->Buffer) {
                LinkTarget->Buffer[0] = 0;
                LinkTarget->Length = 0; //-V1048
                LinkTarget->MaximumLength = (USHORT)sizeof(WCHAR);
                bResult = TRUE;
            }
            break;
        }

        if (ntStatus == STATUS_BUFFER_TOO_SMALL ||
            ntStatus == STATUS_BUFFER_OVERFLOW ||
            (NT_SUCCESS(ntStatus) && rLen > 0))
        {
            //
            // Make sure there is a space for terminator.
            //
            if (rLen > UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))
                break;

            stringBuffer = (PWCH)supHeapAlloc(rLen + sizeof(UNICODE_NULL));
            if (stringBuffer == NULL)
                break;

            linkTarget.Buffer = stringBuffer;
            linkTarget.Length = 0;
            linkTarget.MaximumLength = (USHORT)rLen;

            ntStatus = NtQuerySymbolicLinkObject(hObject, &linkTarget, &rLen);
            if (NT_SUCCESS(ntStatus)) {
                LinkTarget->Buffer = stringBuffer;
                LinkTarget->Length = linkTarget.Length;
                LinkTarget->MaximumLength = linkTarget.MaximumLength;
                bResult = TRUE;
            }
        }

    } while (FALSE);

    if (!bResult) {
        if (stringBuffer)
            supHeapFree(stringBuffer);
        RtlInitEmptyUnicodeString(LinkTarget, NULL, 0);
    }

    //
    // If there is no input handle close what we have opened.
    //
    if (LinkHandle == NULL && hObject)
        NtClose(hObject);

    return bResult;
}

/*
* supResolveSymbolicLinkTargetNormalized
*
* Purpose:
*
* Resolve symbolic link target in a GUI friendly output form.
*
* Return FALSE on error.
*
*/
_Success_(return)
BOOL supResolveSymbolicLinkTargetNormalized(
    _In_opt_ HANDLE LinkHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Out_ PUNICODE_STRING NormalizedLinkTarget
)
{
    BOOL bResult;
    UNICODE_STRING linkTarget;

    if (!supResolveSymbolicLinkTarget(
        LinkHandle,
        RootDirectoryHandle,
        LinkName,
        &linkTarget))
    {
        return FALSE;
    }

    bResult = supNormalizeUnicodeStringForDisplay(g_obexHeap, &linkTarget, NormalizedLinkTarget);

    supFreeDuplicatedUnicodeString(g_obexHeap, &linkTarget, FALSE);

    return bResult;
}

/*
* supClipboardCopyUnicodeStringRaw
*
* Purpose:
*
* Copy UNICODE_STRING buffer to the clipboard as C array.
*
*/
VOID supClipboardCopyUnicodeStringRaw(
    _In_ PUNICODE_STRING String
)
{
    SIZE_T bytes;
    BYTE* src, * end;
    PWCH copyBuffer, dst;
    BYTE x;

    //
    // '0', 'x', ',', ' ', 'A', 'B' = 6 * sizeof(WCHAR)
    //
    bytes = 100 + ((SIZE_T)String->Length * 12);
    copyBuffer = (PWCH)supHeapAlloc(bytes);
    if (copyBuffer == NULL)
        return;

    _strcpy(copyBuffer, TEXT("unsigned char data["));
    ultostr(String->Length, _strend(copyBuffer));
    dst = _strcat(copyBuffer, TEXT("] = {"));

    src = (BYTE*)String->Buffer;
    end = (BYTE*)RtlOffsetToPointer(String->Buffer, String->Length);
    while (src < end) {

        *dst++ = '0';
        *dst++ = 'x';
        x = *src++;

        *dst++ = nibbletoh(x >> 4, TRUE);
        *dst++ = nibbletoh(x & 15, TRUE);

        if (src != end) {
            *dst++ = ',';
            *dst++ = ' ';
        }
    }

    *dst++ = '}';
    *dst++ = ';';
    *dst++ = ' ';
    *dst = 0;

    supClipboardCopy(copyBuffer, _strlen(copyBuffer) * sizeof(WCHAR));
    supHeapFree(copyBuffer);
}

/*
* supFindUnicodeStringSubString
*
* Purpose:
*
* Return offset to substring if found and ULLONG_MAX instead.
*
* Case Insensitive.
*
*/
SIZE_T supFindUnicodeStringSubString(
    _In_ PUNICODE_STRING String,
    _In_ PUNICODE_STRING SubString
)
{
    SIZE_T lenMain;
    SIZE_T lenSub;
    WCHAR c0;
    SIZE_T i;

    if (SubString == NULL || String == NULL)
        return ULLONG_MAX;

    lenMain = String->Length / sizeof(WCHAR);
    lenSub = SubString->Length / sizeof(WCHAR);

    if (lenSub == 0)
        return 0;
    if (lenSub > lenMain)
        return ULLONG_MAX;

    c0 = RtlUpcaseUnicodeChar(SubString->Buffer[0]);
    for (i = 0; i <= lenMain - lenSub; i++) {
        if (RtlUpcaseUnicodeChar(String->Buffer[i]) == c0) {
            UNICODE_STRING m, s;
            m.Buffer = &String->Buffer[i];
            m.Length = (USHORT)(lenSub * sizeof(WCHAR));
            s = *SubString;
            if (RtlEqualUnicodeString(&m, &s, TRUE))
                return i;
        }
    }
    return ULLONG_MAX;
}

/*
* supImageFixSections
*
* Purpose:
*
* Fix sections after dump.
*
*/
BOOL supImageFixSections(
    _In_ LPVOID Buffer
)
{
    PIMAGE_DOS_HEADER dos;
    PIMAGE_NT_HEADERS nth;
    PIMAGE_FILE_HEADER fh;
    PIMAGE_SECTION_HEADER sec;
    DWORD i;
    DWORD secalign;
    ULONGLONG vaddr, addSize;
    WORD numberOfSections;

    __try {

        dos = (PIMAGE_DOS_HEADER)Buffer;
        if (dos->e_magic != IMAGE_DOS_SIGNATURE)
            return FALSE;

        if (dos->e_lfanew == 0 ||
            dos->e_lfanew > RTLP_IMAGE_MAX_DOS_HEADER)
            return FALSE;

        nth = (PIMAGE_NT_HEADERS)((PBYTE)Buffer + dos->e_lfanew);
        if (nth->Signature != IMAGE_NT_SIGNATURE)
            return FALSE;

        fh = &nth->FileHeader;
        numberOfSections = fh->NumberOfSections;

        if (numberOfSections == 0 ||
            numberOfSections > MM_MAXIMUM_IMAGE_SECTIONS)
            return FALSE;

        if (nth->OptionalHeader.SectionAlignment == 0)
            return FALSE;

        secalign = nth->OptionalHeader.SectionAlignment;

        sec = IMAGE_FIRST_SECTION(nth);
        vaddr = sec->VirtualAddress;

        for (i = 0; i < numberOfSections; i++, sec++) {

            DWORD vsize, alignedSize;

            vsize = sec->Misc.VirtualSize;
            if (vsize == 0)
                vsize = sec->SizeOfRawData;

            addSize = vsize;
            addSize = (addSize + (secalign - 1)) & ~(ULONGLONG)(secalign - 1);

            if (addSize > ULONG_MAX)
                return FALSE;

            alignedSize = (DWORD)addSize;

            sec->SizeOfRawData = alignedSize;
            sec->PointerToRawData = (DWORD)vaddr;

            vaddr += alignedSize;
            if (vaddr > ULONG_MAX) 
                return FALSE;
        }

        return TRUE;

    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return FALSE;
    }
}

/*
* supCloseKnownPropertiesDialog
*
* Purpose:
*
* Send WM_CLOSE to known properties dialog if it present.
*
*/
VOID supCloseKnownPropertiesDialog(
    _In_opt_ HWND hwndDlg
)
{
    if (hwndDlg)
        SendMessage(hwndDlg, WM_CLOSE, 0, 0);
}

/*
* supReadObexConfiguration
*
* Purpose:
*
* Reads program configuration data from registry if present.
*
*/
_Success_(return)
BOOL supReadObexConfiguration(
    _Out_ POBEX_CONFIG Configuration
)
{
    HKEY hKey;
    DWORD data = 0, cbData, dwType;
    WCHAR szBuffer[MAX_PATH + 1];
    WCHAR symbol;

    INT i;
    WCHAR szValidSymbols[] = {
        '!', '"', '#', '$', '%', '\'',
        '(', ')','*', '+',  '-', '.',
        ':', ';', '<', '>', '=', '?',
        '@', ']', '[', '^', '_', '`',
        '{', '}', '~' };

    Configuration->SymbolsPathValid = FALSE;
    Configuration->SymbolsDbgHelpDllValid = FALSE;
    Configuration->szNormalizationSymbol = OBJ_NAME_NORMALIZATION_SYMBOL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, supObexConfiguration, 0, KEY_READ, &hKey)) {

        cbData = sizeof(DWORD);
        dwType = REG_DWORD;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, supObexNormalizationSymbol,
            NULL, &dwType, (LPBYTE)&data, &cbData))
        {
            if (dwType == REG_DWORD && cbData == sizeof(DWORD)) {
                symbol = (WCHAR)data;
                for (i = 0; i < RTL_NUMBER_OF(szValidSymbols); i++) {
                    if (szValidSymbols[i] == symbol) {
                        Configuration->szNormalizationSymbol = symbol;
                        break;
                    }
                }
            }
        }

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        cbData = MAX_PATH * sizeof(WCHAR);
        dwType = REG_SZ;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, supObexSymPath,
            NULL, &dwType, (LPBYTE)&szBuffer, &cbData))
        {
            if (dwType == REG_SZ && cbData > sizeof(UNICODE_NULL)) {
                _strcpy(Configuration->szSymbolsPath, szBuffer);
                Configuration->SymbolsPathValid = TRUE;
            }
        }

        RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
        cbData = MAX_PATH * sizeof(WCHAR);
        dwType = REG_SZ;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, supObexSymDbgHelpDll,
            NULL, &dwType, (LPBYTE)&szBuffer, &cbData))
        {
            if (dwType == REG_SZ && cbData > sizeof(UNICODE_NULL)) {
                _strcpy(Configuration->szSymbolsDbgHelpDll, szBuffer);
                Configuration->SymbolsDbgHelpDllValid = TRUE;
            }
        }

        RegCloseKey(hKey);
        return TRUE;
    }

    return FALSE;
}

/*
* supGetParametersBlock
*
* Purpose:
*
* Return pointer to program parameters block.
*
*/
POBEX_CONFIG supGetParametersBlock(
    VOID)
{
    return &g_LoadedParametersBlock;
}

/*
* supCreateTrackingToolTip
*
* Purpose:
*
* Create tracking tooltip.
*
*/
HWND supCreateTrackingToolTip(
    _In_ INT toolID,
    _In_ HWND hwndOwner)
{
    HWND hwndTip;
    TOOLINFO toolInfo;

    hwndTip = CreateWindowEx(0, TOOLTIPS_CLASS, NULL,
        WS_POPUP,
        CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT,
        hwndOwner, NULL,
        g_WinObj.hInstance, NULL);

    if (hwndTip)
    {
        RtlSecureZeroMemory(&toolInfo, sizeof(toolInfo));
        toolInfo.cbSize = sizeof(toolInfo);
        toolInfo.hwnd = hwndOwner;
        toolInfo.uFlags = TTF_TRACK | TTF_ABSOLUTE | TTF_IDISHWND;
        toolInfo.uId = (UINT_PTR)GetDlgItem(hwndOwner, toolID);
        toolInfo.lpszText = LPSTR_TEXTCALLBACK;

        SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&toolInfo);
        SendMessage(hwndTip, TTM_SETMAXTIPWIDTH, 0, MAX_PATH * 2);
    }

    return hwndTip;
}

/*
* supIsPrivilegeEnabledForClient
*
* Purpose:
*
* Tests if given privilege is enabled for client.
*
*/
BOOL supIsPrivilegeEnabledForClient(
    _In_ ULONG Privilege
)
{
    BOOL bResult = FALSE;
    NTSTATUS ntStatus;
    HANDLE tokenHandle;

    //
    // Cannot use new fancy consts as this code must work pre Win10/11.
    // 

    ntStatus = NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle);

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = supPrivilegeEnabled(tokenHandle, Privilege, &bResult);
        NtClose(tokenHandle);
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

/*
* supEnablePrivilegeWithCheck
*
* Purpose:
*
* Enable/Disable privilege with check if it was previously enabled.
*
*/
BOOLEAN supEnablePrivilegeWithCheck(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable
)
{
    BOOLEAN bResult = FALSE, bWasEnabled = FALSE;
    NTSTATUS status;
    PRIVILEGE_SET privSet;
    ULONG returnLength;
    NTSTATUS ntStatus;
    HANDLE tokenHandle;
    PTOKEN_PRIVILEGES newState;
    UCHAR rawBuffer[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];

    do {
        ntStatus = NtOpenProcessToken(
            NtCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &tokenHandle);

        if (!NT_SUCCESS(ntStatus))
            break;

        privSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
        privSet.PrivilegeCount = 1;
        privSet.Privilege[0].Luid.LowPart = Privilege;
        privSet.Privilege[0].Luid.HighPart = 0;
        privSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED;

        status = NtPrivilegeCheck(tokenHandle, &privSet, &bWasEnabled);

        //
        // Already enabled, leave.
        //
        if (Enable && bWasEnabled) {
            bResult = TRUE;
            break;
        }
        //
        // Already disabled, leave.
        //
        if (!Enable && !bWasEnabled) {
            bResult = TRUE;
            break;
        }

        newState = (PTOKEN_PRIVILEGES)rawBuffer;

        newState->PrivilegeCount = 1;
        newState->Privileges[0].Luid = RtlConvertUlongToLuid(Privilege);
        newState->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

        ntStatus = NtAdjustPrivilegesToken(
            tokenHandle,
            FALSE,
            newState,
            sizeof(rawBuffer),
            NULL,
            &returnLength);

        if (ntStatus == STATUS_NOT_ALL_ASSIGNED) {
            ntStatus = STATUS_PRIVILEGE_NOT_HELD;
        }

        bResult = NT_SUCCESS(ntStatus);

    } while (FALSE);

    if (tokenHandle)
        NtClose(tokenHandle);

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

/*
* supFilterDeviceIoControl
*
* Purpose:
*
* Call filter driver.
*
* Simplified fltlib!FilterpDeviceIoControl
*
*/
NTSTATUS supFilterDeviceIoControl(
    _In_ HANDLE Handle,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_(InBufferSize) PVOID InBuffer,
    _In_ ULONG InBufferSize,
    _Out_writes_bytes_to_opt_(OutBufferSize, *BytesReturned) PVOID OutBuffer,
    _In_ ULONG OutBufferSize,
    _Out_opt_ PULONG BytesReturned
)
{
    NTSTATUS ntStatus;

    if (BytesReturned)
        *BytesReturned = 0;

    IO_STATUS_BLOCK ioStatusBlock;

    if (DEVICE_TYPE_FROM_CTL_CODE(IoControlCode) == FILE_DEVICE_FILE_SYSTEM) {
        ntStatus = NtFsControlFile(Handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IoControlCode,
            InBuffer,
            InBufferSize,
            OutBuffer,
            OutBufferSize);
    }
    else {

        ntStatus = NtDeviceIoControlFile(Handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IoControlCode,
            InBuffer,
            InBufferSize,
            OutBuffer,
            OutBufferSize);
    }

    if (ntStatus == STATUS_PENDING) {
        ntStatus = NtWaitForSingleObject(Handle, FALSE, NULL);
        if (NT_SUCCESS(ntStatus))
            ntStatus = ioStatusBlock.Status;
    }

    if (BytesReturned)
        *BytesReturned = (ULONG)ioStatusBlock.Information;

    return ntStatus;
}

/*
* supxFilterFindFirst
*
* Purpose:
*
* Simplified fltlib!FilterFindFirst.
*
*/
NTSTATUS supxFilterFindFirst(
    _In_ HANDLE FltMgrHandle,
    _In_ FILTER_INFORMATION_CLASS InformationClass,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize
)
{
    FILTER_INFORMATION_CLASS infoClass = InformationClass;
    NTSTATUS ntStatus;
    DWORD linkInfo[2];

    linkInfo[0] = 3; //type of callback, 3 is for filters.
    linkInfo[1] = 0;

    ntStatus = supFilterDeviceIoControl(FltMgrHandle,
        IOCTL_FLTMGR_LINK_HANDLE,
        &linkInfo,
        sizeof(linkInfo),
        NULL,
        0,
        NULL);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = supFilterDeviceIoControl(FltMgrHandle,
            IOCTL_FLTMGR_FIND_FIRST,
            &infoClass,
            sizeof(infoClass),
            Buffer,
            BufferSize,
            NULL);

    }

    return ntStatus;
}

/*
* supxFilterFindNext
*
* Purpose:
*
* Simplified fltlib!supxFilterFindNext.
*
*/
NTSTATUS supxFilterFindNext(
    _In_ HANDLE FltMgrHandle,
    _In_ FILTER_INFORMATION_CLASS InformationClass,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize
)
{
    FILTER_INFORMATION_CLASS infoClass = InformationClass;

    return supFilterDeviceIoControl(FltMgrHandle,
        IOCTL_FLTMGR_FIND_NEXT,
        &infoClass,
        sizeof(infoClass),
        Buffer,
        BufferSize,
        NULL);
}

/*
* supFilterFindByName
*
* Purpose:
*
* Find filter by name.
*
* N.B. Case insensitive since filter and driver names seems case insensitive as declared without matching.
*
*/
BOOL supFilterFindByName(
    _In_ PLIST_ENTRY FltListHead,
    _In_ LPCWSTR Name
)
{
    PLIST_ENTRY ListHead = FltListHead, Entry, NextEntry;
    PSUP_FLT_ENTRY Item;

    ASSERT_LIST_ENTRY_VALID_BOOLEAN(ListHead);

    if (IsListEmpty(ListHead))
        return FALSE;

    for (Entry = ListHead->Flink, NextEntry = Entry->Flink;
        Entry != ListHead;
        Entry = NextEntry, NextEntry = Entry->Flink)
    {
        Item = CONTAINING_RECORD(Entry, SUP_FLT_ENTRY, ListEntry);

        if (_strcmpi(Item->FilterNameBuffer, Name) == 0)
            return TRUE;
    }

    return FALSE;
}

/*
* supFilterDestroyList
*
* Purpose:
*
* Remove all items from filter drivers list and free memory.
*
*/
VOID supFilterDestroyList(
    _In_ PLIST_ENTRY FltListHead
)
{
    PLIST_ENTRY ListHead = FltListHead, Entry, NextEntry;
    PSUP_FLT_ENTRY Item;

    ASSERT_LIST_ENTRY_VALID(ListHead);

    if (IsListEmpty(ListHead))
        return;

    for (Entry = ListHead->Flink, NextEntry = Entry->Flink;
        Entry != ListHead;
        Entry = NextEntry, NextEntry = Entry->Flink)
    {
        Item = CONTAINING_RECORD(Entry, SUP_FLT_ENTRY, ListEntry);

        if (Item->FilterNameBuffer)
            supHeapFree(Item->FilterNameBuffer);

        RemoveEntryList(Entry);
        supHeapFree(Item);
    }
}

/*
* supFilterCreateList
*
* Purpose:
*
* Enumerate registered filter drivers into linked list of SUP_FLT_ENTRY structures.
*
*/
ULONG supFilterCreateList(
    _In_ PLIST_ENTRY FltListHead
)
{
    DWORD bufferSize;
    ULONG cFlt = 0;
    PFILTER_FULL_INFORMATION buffer = NULL;
    HANDLE fltMgrHandle = NULL;
    NTSTATUS ntStatus;
    UNICODE_STRING usDeviceName;
    IO_STATUS_BLOCK iost;
    OBJECT_ATTRIBUTES obja;
    PSUP_FLT_ENTRY pFltEntry;

    bufferSize = sizeof(FILTER_FULL_INFORMATION) + MAX_PATH * 2;
    buffer = (PFILTER_FULL_INFORMATION)supHeapAlloc((SIZE_T)bufferSize);
    if (buffer) {

        RtlInitUnicodeString(&usDeviceName, L"\\??\\FltMgr");
        InitializeObjectAttributes(&obja, &usDeviceName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        ntStatus = NtCreateFile(&fltMgrHandle,
            GENERIC_READ,
            &obja,
            &iost,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN,
            0,
            NULL,
            0);

        if (NT_SUCCESS(ntStatus)) {

            if (NT_SUCCESS(supxFilterFindFirst(fltMgrHandle, FilterFullInformation, buffer, bufferSize))) {

                do {
                    pFltEntry = (PSUP_FLT_ENTRY)supHeapAlloc(sizeof(SUP_FLT_ENTRY));
                    if (pFltEntry) {

                        pFltEntry->FrameID = buffer->FrameID;
                        pFltEntry->NumberOfInstances = buffer->NumberOfInstances;
                        pFltEntry->FilterNameLength = buffer->FilterNameLength;

                        pFltEntry->FilterNameBuffer = (PWCHAR)supHeapAlloc(pFltEntry->FilterNameLength);
                        if (pFltEntry->FilterNameBuffer) {

                            RtlCopyMemory(pFltEntry->FilterNameBuffer,
                                buffer->FilterNameBuffer,
                                pFltEntry->FilterNameLength);
                        }

                        InsertHeadList(FltListHead, &pFltEntry->ListEntry);
                        cFlt += 1;
                    }

                } while (supxFilterFindNext(fltMgrHandle,
                    FilterFullInformation,
                    buffer, bufferSize) != STATUS_NO_MORE_ENTRIES);

            }
        }
        NtClose(fltMgrHandle);
        supHeapFree(buffer);
    }

    return cFlt;
}

/*
* supSymLoadWorker
*
* Purpose:
*
* Worker thread to load symbols while keeping UI responsive.
*
*/
DWORD WINAPI supSymLoadWorker(LPVOID lpParameter)
{
    PSYMBOL_LOAD_PARAMS pParams;
    BOOL bResult = FALSE;

    pParams = (PSYMBOL_LOAD_PARAMS)lpParameter;
    if (!pParams)
        return 0;

    __try {
        bResult = pParams->SymContext->Parser.LoadModule(
            pParams->SymContext,
            pParams->ImageFileName,
            pParams->ImageBase,
            pParams->SizeOfImage);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        bResult = FALSE;
    }

    SetEvent(pParams->hCompletionEvent);

    return bResult ? 1 : 0;
}

/*
* supCallbackReportEvent
*
* Purpose:
*
* Add event to the log and output it into optional callback.
*
*/
VOID supCallbackReportEvent(
    _In_ ULONG ActionCode,
    _In_ PIMAGEHLP_DEFERRED_SYMBOL_LOAD Action,
    _In_ PFNSUPSYMCALLBACK UserCallback
)
{
    WCHAR szLogMessage[MAX_PATH * 2];
    WCHAR szStatusText[MAX_PATH];
    WOBJ_ENTRY_TYPE entryType = EntryTypeInformation;

    szLogMessage[0] = 0;
    szStatusText[0] = 0;

    switch (ActionCode) {
    case CBA_DEFERRED_SYMBOL_LOAD_START:
        RtlStringCchPrintfSecure(szLogMessage, RTL_NUMBER_OF(szLogMessage),
            TEXT("Loading symbols for 0x%p %ws..."),
            Action->BaseOfImage,
            Action->FileName);

        RtlStringCchPrintfSecure(szStatusText, RTL_NUMBER_OF(szStatusText),
            TEXT("Loading symbols..."));
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
        RtlStringCchPrintfSecure(szLogMessage, RTL_NUMBER_OF(szLogMessage),
            TEXT("Loaded symbols for 0x%p %ws"),
            Action->BaseOfImage,
            Action->FileName);

        RtlStringCchPrintfSecure(szStatusText, RTL_NUMBER_OF(szStatusText),
            TEXT("Symbols loaded successfully"));
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
        RtlStringCchPrintfSecure(szLogMessage, RTL_NUMBER_OF(szLogMessage),
            TEXT("*** ERROR: Could not load symbols for 0x%p %ws"),
            Action->BaseOfImage,
            Action->FileName);

        RtlStringCchPrintfSecure(szStatusText, RTL_NUMBER_OF(szStatusText),
            TEXT("Failed to load symbols"));

        entryType = EntryTypeError;
        break;
    }

    logAdd(entryType, szLogMessage);

    if (UserCallback)
        UserCallback(szLogMessage, szStatusText);
}

/*
* supSymCallbackReportEvent
*
* Purpose:
*
* Banner output callback for symbols loading.
*
*/
VOID CALLBACK supSymCallbackReportEvent(
    _In_ LPCWSTR EventText,
    _In_opt_ LPCWSTR StatusText
)
{
    HWND hwndBanner = g_SymLoadState.hBannerDialog;;

    if (!hwndBanner || !IsWindow(hwndBanner))
        return;

    if (EventText) {
        SendDlgItemMessage(hwndBanner, IDC_LOADING_MSG, EM_REPLACESEL, (WPARAM)0, (LPARAM)EventText);
        SendDlgItemMessage(hwndBanner, IDC_LOADING_MSG, EM_REPLACESEL, (WPARAM)0, (LPARAM)(LPWSTR)L"\r\n");
        SendDlgItemMessage(hwndBanner, IDC_LOADING_MSG, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
    }

    if (StatusText) {
        SetDlgItemText(hwndBanner, IDC_STATUS_TEXT, StatusText);
    }
}

/*
* supxLoadBannerDialog
*
* Purpose:
*
* Wait window banner dialog procedure.
*
*/
INT_PTR CALLBACK supxLoadBannerDialog(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    static DWORD64 dwStartTime = 0;
    static DWORD64 dwElapsedSecs = 0;
    static HANDLE hCancelEvent = NULL;
    static BOOL bAllowCancel = FALSE;
    static BOOL bClosePending = FALSE;
    static DWORD64 dwCloseStartTime = 0;

    WCHAR szTimeElapsed[64];
    SUP_BANNER_DATA* pvData;

    switch (uMsg) {
    case WM_INITDIALOG:
        if (lParam) {
            pvData = (SUP_BANNER_DATA*)lParam;
            SendDlgItemMessage(hwndDlg, IDC_LOADING_MSG, EM_SETLIMITTEXT, 0, 0);
            supCenterWindowPerScreen(hwndDlg);

            if (pvData->lpCaption)
                SetWindowText(hwndDlg, pvData->lpCaption);

            SendDlgItemMessage(hwndDlg, IDC_LOADING_MSG, EM_REPLACESEL, (WPARAM)0, (LPARAM)pvData->lpText);

            hCancelEvent = pvData->hCancelEvent;
            bAllowCancel = (hCancelEvent != NULL);

            dwStartTime = GetTickCount64();
            dwElapsedSecs = 0;
            bClosePending = FALSE;

            SetTimer(hwndDlg, 1, 100, NULL);
        }
        return TRUE;

    case WM_TIMER:
        if (wParam == 1) {
            // Update elapsed time every second
            if ((GetTickCount64() - dwStartTime) / 1000 != dwElapsedSecs) {
                dwElapsedSecs = (GetTickCount64() - dwStartTime) / 1000;
                RtlStringCchPrintfSecure(szTimeElapsed, RTL_NUMBER_OF(szTimeElapsed),
                    TEXT("Time elapsed: %02u:%02u"), (DWORD)(dwElapsedSecs / 60), (DWORD)(dwElapsedSecs % 60));
                SetDlgItemText(hwndDlg, IDC_TIME_ELAPSED, szTimeElapsed);
            }

            if (bClosePending) {
                if ((GetTickCount64() - dwCloseStartTime) >= 500) {
                    bClosePending = FALSE;
                    SendMessage(hwndDlg, WM_CLOSE, 0, 0);
                    return TRUE;
                }
            }
            else if (g_SymLoadState.IsCompleted) {
                bClosePending = TRUE;
                dwCloseStartTime = GetTickCount64();
            }
        }
        break;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL && bAllowCancel) {
            InterlockedExchange((PLONG)&g_SymLoadState.IsCancelled, 1);
            if (hCancelEvent) {
                SetEvent(hCancelEvent);
            }
            SendMessage(hwndDlg, WM_CLOSE, 0, 0);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        KillTimer(hwndDlg, 1);
        DestroyWindow(hwndDlg);
        PostQuitMessage(0);
        return TRUE;
    }

    return FALSE;
}

/*
* supSymLoadDialogThreadProc
*
* Purpose:
*
* Thread procedure for displaying and managing the symbol loading dialog.
*
*/
DWORD WINAPI supSymLoadDialogThreadProc(
    _In_ LPVOID lpParameter
)
{
    BOOL bRet;
    PSUP_BANNER_DATA pParams = (PSUP_BANNER_DATA)lpParameter;
    MSG msg;
    SUP_BANNER_DATA bannerData;

    if (!pParams)
        return 0;

    bannerData.lpText = pParams->lpText;
    bannerData.lpCaption = pParams->lpCaption;
    bannerData.hCancelEvent = pParams->hCancelEvent;

    pParams->hDialogWindow = CreateDialogParam(
        g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_LOADLIST),
        NULL,
        supxLoadBannerDialog,
        (LPARAM)&bannerData);

    if (pParams->hDialogWindow) {
        g_SymLoadState.hBannerDialog = pParams->hDialogWindow;
        ShowWindow(pParams->hDialogWindow, SW_SHOW);
        UpdateWindow(pParams->hDialogWindow);

        SetEvent(pParams->hDialogInitialized);

        while ((bRet = GetMessage(&msg, NULL, 0, 0)) != 0) {
            if (bRet == -1)
                break;

            if (WaitForSingleObject(pParams->hCompletionEvent, 0) == WAIT_OBJECT_0) {
                g_SymLoadState.IsCompleted = TRUE;
            }

            if (!IsDialogMessage(pParams->hDialogWindow, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        g_SymLoadState.hBannerDialog = NULL;
    }
    else {
        SetEvent(pParams->hDialogInitialized);
    }

    return 0;
}

/*
* supLoadSymbolsForNtImage
*
* Purpose:
*
* Load symbols for OS mapped image.
*
*/
BOOL supLoadSymbolsForNtImage(
    _In_ PSYMCONTEXT SymContext,
    _In_ LPCWSTR ImageFileName,
    _In_ PVOID ImageBase,
    _In_ DWORD SizeOfImage
)
{
    BOOL bResult = FALSE;
    HANDLE hDialogThread = NULL;
    HANDLE hSymLoadingThread = NULL;
    HANDLE hDialogInitialized = NULL;
    HANDLE hCompletionEvent = NULL;
    HANDLE hCancelEvent = NULL;
    SUP_BANNER_DATA dialogParams;
    SYMBOL_LOAD_PARAMS symbolParams;
    DWORD dwExitCode = 0;
    DWORD dwWaitResult;

    HANDLE waitHandles[2];

    if (SymContext == NULL)
        return FALSE;

    if (SymContext->ModuleBase != 0)
        return TRUE;

    g_SymLoadState.IsCompleted = FALSE;
    g_SymLoadState.IsCancelled = FALSE;
    g_SymLoadState.hBannerDialog = NULL;

    hDialogInitialized = CreateEvent(NULL, TRUE, FALSE, NULL);
    hCompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    hCancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!hDialogInitialized || !hCompletionEvent || !hCancelEvent) {
        if (hDialogInitialized) CloseHandle(hDialogInitialized);
        if (hCompletionEvent) CloseHandle(hCompletionEvent);
        if (hCancelEvent) CloseHandle(hCancelEvent);
        return FALSE;
    }

    dialogParams.lpText = L"Loading symbols, please wait...\r\n";
    dialogParams.lpCaption = L"Symbol Loading";
    dialogParams.hDialogInitialized = hDialogInitialized;
    dialogParams.hCancelEvent = hCancelEvent;
    dialogParams.hCompletionEvent = hCompletionEvent;
    dialogParams.hDialogWindow = NULL;

    hDialogThread = supCreateThread(supSymLoadDialogThreadProc, &dialogParams, 0);
    if (!hDialogThread) {
        CloseHandle(hDialogInitialized);
        CloseHandle(hCompletionEvent);
        CloseHandle(hCancelEvent);
        return FALSE;
    }

    WaitForSingleObject(hDialogInitialized, INFINITE);
    CloseHandle(hDialogInitialized);

    symbolParams.SymContext = SymContext;
    symbolParams.ImageFileName = ImageFileName;
    symbolParams.ImageBase = (DWORD64)ImageBase;
    symbolParams.SizeOfImage = SizeOfImage;
    symbolParams.hCancelEvent = hCancelEvent;
    symbolParams.hCompletionEvent = hCompletionEvent;

    hSymLoadingThread = supCreateThread(supSymLoadWorker, &symbolParams, 0);
    if (!hSymLoadingThread) {
        SetEvent(hCompletionEvent);
        WaitForSingleObject(hDialogThread, INFINITE);

        CloseHandle(hDialogThread);
        CloseHandle(hCompletionEvent);
        CloseHandle(hCancelEvent);
        return FALSE;
    }

    waitHandles[0] = hCompletionEvent;
    waitHandles[1] = hCancelEvent;

    while (TRUE) {
        dwWaitResult = WaitForMultipleObjects(2, waitHandles, FALSE, 100);
        if (dwWaitResult != WAIT_TIMEOUT)
            break;

        if (g_SymLoadState.IsCancelled) {
            TerminateThread(hSymLoadingThread, 0);
            logAdd(EntryTypeWarning, TEXT("Symbols loading are interrupted by user"));
            break;
        }
    }

    if (dwWaitResult == WAIT_OBJECT_0) {
        GetExitCodeThread(hSymLoadingThread, &dwExitCode);
        bResult = (dwExitCode != 0);
    }
    else {
        bResult = FALSE;
    }

    CloseHandle(hSymLoadingThread);

    SetEvent(hCompletionEvent);
    g_SymLoadState.IsCompleted = TRUE;

    WaitForSingleObject(hDialogThread, 3000);
    CloseHandle(hDialogThread);

    CloseHandle(hCompletionEvent);
    CloseHandle(hCancelEvent);

    return bResult;
}

```

`Source/WinObjEx64/sup/sup.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*
*  TITLE:       SUP.H
*
*  VERSION:     2.09
*
*  DATE:        21 Aug 2025
*
*  Common header file for the program support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define T_DEVICE_PROCEXP152 L"\\Device\\ProcExp152"
#define PE_DEVICE_TYPE 0x8335

#define IOCTL_PE_OPEN_PROCESS_TOKEN     CTL_CODE(PE_DEVICE_TYPE, 0x3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PE_OPEN_PROCESS           CTL_CODE(PE_DEVICE_TYPE, 0xF, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define T_SECUREBOOTSTATEKEY        L"System\\CurrentControlSet\\Control\\SecureBoot\\State"
#define T_SECUREBOOTSTATEVALUE      L"UEFISecureBootEnabled"

#define T_VERSION_TRANSLATION       L"\\VarFileInfo\\Translation"
#define FORMAT_VERSION_DESCRIPTION  L"\\StringFileInfo\\%04x%04x\\FileDescription"
#define HHCTRLOCXKEY                L"CLSID\\{ADB880A6-D8FF-11CF-9377-00AA003B7A11}\\InprocServer32"
#define T_OBJECT_TYPES              L"ObjectTypes"

#define FORMAT_TIME_DATE_VALUE      L"%02hd:%02hd:%02hd, %02hd %ws %04hd"
#define FORMAT_TIME_VALUE           L"%I64u:%02hd:%02hd"
#define FORMAT_TIME_VALUE_MS        L"%hd:%02hd:%02hd.%03hd"
#define T_FORMATTED_ATTRIBUTE       L"           0x"

#define HHCTRLOCX                   L"hhctrl.ocx"

#define T_WINSTA_SYSTEM L"-0x0-3e7$"
#define T_WINSTA_ANONYMOUS L"-0x0-3e6$"
#define T_WINSTA_LOCALSERVICE L"-0x0-3e5$"
#define T_WINSTA_NETWORK_SERVICE L"-0x0-3e4$"

#define supServicesRegPath          L"System\\CurrentControlSet\\Services\\"
#define supServicesRegPathSize      sizeof(supServicesRegPath) - sizeof(WCHAR)

#define supObexConfiguration        L"Software\\WinObjEx64"
#define supObexSymPath              L"SymPath"
#define supObexSymDbgHelpDll        L"SymDbgHelpDll"
#define supObexNormalizationSymbol  L"NormalizationSymbol"

// All relatives to supObexConfiguration
typedef struct _OBEX_CONFIG {
    BOOLEAN SymbolsPathValid;
    BOOLEAN SymbolsDbgHelpDllValid;
    WCHAR szNormalizationSymbol;                 //supObexNormalizationSymbol
    WCHAR szSymbolsPath[MAX_PATH + 1];           //supObexSymbolsPath
    WCHAR szSymbolsDbgHelpDll[MAX_PATH + 1];     //supObexSymbolsDbgHelpDll
} OBEX_CONFIG, * POBEX_CONFIG;

#define INITIAL_BUFFER_SIZE (256) * (1024)

#define GET_BIT(Integer, Bit) (((Integer) >> (Bit)) & 0x1)
#define SET_BIT(Integer, Bit) ((Integer) |= 1 << (Bit))
#define CLEAR_BIT(Integer, Bit) ((Integer) &= ~(1 << (Bit)))

#define PathFileExists(lpszPath) (GetFileAttributes(lpszPath) != (DWORD)-1)

typedef struct _SAPIDB {
    LIST_ENTRY ListHead;
    HANDLE     HeapHandle;
    CRITICAL_SECTION Lock;
} SAPIDB, *PSAPIDB;

typedef struct _SCMDB {
    ULONG NumberOfEntries;
    PVOID Entries;
    CRITICAL_SECTION Lock;
} SCMDB, *PSCMDB;

typedef struct _ENUMICONINFO {
    HICON hIcon;
    INT cx, cy;
} ENUMICONINFO, *PENUMICONINFO;

typedef	struct _PHL_ENTRY {
    LIST_ENTRY ListEntry;
    HANDLE ProcessHandle;
    HANDLE UniqueProcessId;
    PVOID DataPtr;
} PHL_ENTRY, *PPHL_ENTRY;

typedef struct _SUP_HANDLE_DUMP_ENTRY {
    PVOID Object;
    ULONG_PTR HandleValue;
} SUP_HANDLE_DUMP_ENTRY, * PSUP_HANDLE_DUMP_ENTRY;

typedef struct _SUP_HANDLE_DUMP {
    ULONG_PTR NumberOfHandles;
    SUP_HANDLE_DUMP_ENTRY Handles[ANYSIZE_ARRAY];
} SUP_HANDLE_DUMP, * PSUP_HANDLE_DUMP;

typedef struct _SUP_FLT_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG FrameID;
    ULONG NumberOfInstances;
    USHORT FilterNameLength; //in bytes
    PWCHAR FilterNameBuffer;
} SUP_FLT_ENTRY, * PSUP_FLT_ENTRY;

typedef struct _SUP_BANNER_DATA {
    LPCWSTR lpText;
    LPCWSTR lpCaption;
    HANDLE hDialogInitialized;
    HANDLE hCancelEvent;
    HANDLE hCompletionEvent;
    HWND hDialogWindow;
} SUP_BANNER_DATA, * PSUP_BANNER_DATA;

typedef struct _SYMBOL_LOAD_PARAMS {
    PSYMCONTEXT SymContext;
    LPCWSTR ImageFileName;
    DWORD64 ImageBase;
    DWORD SizeOfImage;
    HANDLE hCancelEvent;
    HANDLE hCompletionEvent;
} SYMBOL_LOAD_PARAMS, * PSYMBOL_LOAD_PARAMS;

typedef struct _SYM_LOADING_STATE {
    BOOL IsCancelled;
    BOOL IsCompleted;
    HWND hBannerDialog;
} SYM_LOADING_STATE, * PSYM_LOADING_STATE;

extern SYM_LOADING_STATE g_SymLoadState;

#define FLTMGR_LINK_HANDLE_FUNCID 3
#define FLTMGR_FIND_FIRST_FUNCID  9
#define FLTMGR_FIND_NEXT_FUNCID   0xA

#define IOCTL_FLTMGR_LINK_HANDLE    \
    CTL_CODE(FILE_DEVICE_DISK_FILE_SYSTEM, FLTMGR_LINK_HANDLE_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_FLTMGR_FIND_FIRST     \
    CTL_CODE(FILE_DEVICE_DISK_FILE_SYSTEM, FLTMGR_FIND_FIRST_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_FLTMGR_FIND_NEXT      \
    CTL_CODE(FILE_DEVICE_DISK_FILE_SYSTEM, FLTMGR_FIND_NEXT_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _OBEX_PROCESS_LOOKUP_ENTRY {
    HANDLE hProcess;
    union {
        PUCHAR EntryPtr;
        PSYSTEM_PROCESS_INFORMATION ProcessInformation;
    };
} OBEX_PROCESS_LOOKUP_ENTRY, *POBEX_PROCESS_LOOKUP_ENTRY;

typedef struct _OBEX_THREAD_LOOKUP_ENTRY {
    HANDLE hThread;
    PVOID EntryPtr;
} OBEX_THREAD_LOOKUP_ENTRY, *POBEX_THREAD_LOOKUP_ENTRY;

typedef struct _ALPCPORT_ENUM_CONTEXT {
    _In_ USHORT AlpcPortTypeIndex;
    _In_ PUNICODE_STRING ObjectName;
    _Out_ HANDLE ObjectHandle;
} ALPCPORT_ENUM_CONTEXT, * PALPCPORT_ENUM_CONTEXT;

typedef struct _HANDLE_DUMP_ENUM_CONTEXT {
    _In_ USHORT ObjectTypeIndex;
    _In_ ULONG_PTR ObjectAddress;
    _In_ HWND ListView;
    _In_ HIMAGELIST ImageList;
    _In_ PVOID ProcessList;
} HANDLE_DUMP_ENUM_CONTEXT, *PHANDLE_DUMP_ENUM_CONTEXT;

typedef struct _WINSTA_DESC {
    LPCWSTR lpszWinSta;
    LPCWSTR lpszDesc;
} WINSTA_DESC, * PWINSTA_DESC;

typedef BOOL(CALLBACK* PSUPSHUTDOWNCALLBACK)(
    _In_opt_ PVOID Context
    );

typedef struct _SUP_SHUTDOWN_CALLBACK {
    LIST_ENTRY ListEntry;
    PSUPSHUTDOWNCALLBACK Callback;
    PVOID Context;
} SUP_SHUTDOWN_CALLBACK, PSUP_SHUTDOWN_CALLBACK;

// return true to stop enumeration
typedef BOOL(CALLBACK* PENUMERATE_SL_CACHE_VALUE_DESCRIPTORS_CALLBACK)(
    _In_ SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor,
    _In_opt_ PVOID Context
    );

// return true to stop enumeration
typedef BOOL(CALLBACK* PENUMERATE_HANDLE_DUMP_CALLBACK)(
    _In_ SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* HandleEntry,
    _In_opt_ PVOID UserContext
    );

typedef NTSTATUS(NTAPI* PNTOBJECTOPENPROCEDURE)(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

typedef NTSTATUS(CALLBACK* pfnLoadDriverCallback)(
    _In_ PUNICODE_STRING RegistryPath,
    _In_opt_ PVOID Param
    );

typedef VOID(CALLBACK* PFNSUPSYMCALLBACK)(
    _In_ LPCWSTR EventText,
    _In_opt_ LPCWSTR StatusText
    );

typedef struct _PROCESS_MITIGATION_POLICIES_ALL {
    PROCESS_MITIGATION_DEP_POLICY DEPPolicy;
    PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
    PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
    PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
    PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 SystemCallDisablePolicy;
    PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
    PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
    PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
    PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
    PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
    PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
    PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
    PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
    PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 SideChannelIsolationPolicy;
    PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 UserShadowStackPolicy;
    PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 RedirectionTrustPolicy;
    PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 UserPointerAuthPolicy;
    PROCESS_MITIGATION_SEHOP_POLICY_W11 SEHOPPolicy;
} PROCESS_MITIGATION_POLICIES_ALL, *PPROCESS_MITIGATION_POLICIES;

typedef struct _PROCESS_MITIGATION_POLICY_RAW_DATA {
    PROCESS_MITIGATION_POLICY Policy;
    ULONG Value;
} PROCESS_MITIGATION_POLICY_RAW_DATA, *PPROCESS_MITIGATION_POLICY_RAW_DATA;

typedef struct _ENUMCHILDWNDDATA {
    RECT Rect;
    INT nCmdShow;
} ENUMCHILDWNDDATA, *PENUMCHILDWNDDATA;

typedef struct _LANGANDCODEPAGE {
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCODEPAGE, *LPTRANSLATE;

typedef struct _SAPIDBENTRY {
    LIST_ENTRY ListEntry;
    LPWSTR lpDeviceName;
    LPWSTR lpDeviceDesc;
} SAPIDBENTRY, *PSAPIDBENTRY;

typedef struct tagVERBLOCK {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    WCHAR szKey[1];
} VERBLOCK;

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    WCHAR szKey[(sizeof("VS_VERSION_INFO") + 3) & ~3];
    VS_FIXEDFILEINFO vsf;
} VERHEAD;

#define VER2_SIG 'X2EF'
#define VER2_SIG_LENGTH sizeof(DWORD)

#define DWORDUP(x) (((x)+3)&~3)

typedef enum _IMAGE_VERIFY_STATUS {
    StatusOk = 0,
    StatusBadNtSignature = 1,
    StatusBadOptionalHeader = 2,
    StatusBadOptionalHeaderMagic = 3,
    StatusBadFileHeaderMagic = 4,
    StatusBadFileHeaderCharacteristics = 5,
    StatusBadFileHeaderMachine = 6,
    StatusBadNtHeaders = 7,
    StatusBadFileAlignment = 8,
    StatusBadSectionAlignment = 9,
    StatusBadSizeOfHeaders = 10,
    StatusBadSizeOfImage = 11,
    StatusBadNewExeOffset = 12,
    StatusBadDosMagic = 13,
    StatusExceptionOccurred = 14,
    StatusBadSectionCount = 15,
    StatusBadSecurityDirectoryVA = 16,
    StatusBadSecurityDirectorySize = 17,
    StatusUnknownError = 0xff
} IMAGE_VERIFY_STATUS, * PIMAGE_VERIFY_STATUS;

typedef struct _FILE_EXCLUDE_DATA {
    ULONG ChecksumOffset;
    ULONG SecurityOffset;
    PIMAGE_DATA_DIRECTORY SecurityDirectory;
} FILE_EXCLUDE_DATA, * PFILE_EXCLUDE_DATA;

typedef struct _FILE_VIEW_INFO {
    IMAGE_VERIFY_STATUS Status;
    LPCWSTR FileName;
    HANDLE FileHandle;
    HANDLE SectionHandle;
    PVOID ViewBase;
    SIZE_T ViewSize;
    LARGE_INTEGER FileSize;
    PIMAGE_NT_HEADERS NtHeaders;
    FILE_EXCLUDE_DATA ExcludeData;
} FILE_VIEW_INFO, * PFILE_VIEW_INFO;

//
// Fast event
//
typedef struct _FAST_EVENT {
    union {
        ULONG_PTR Value;
        USHORT Set : 1;
        USHORT RefCount : 15;
        UCHAR Reserved;
        UCHAR AvailableForUse;
#ifdef _WIN64
        ULONG Spare;
#endif
    };
    HANDLE EventHandle;
} FAST_EVENT, * PFAST_EVENT;

#define FAST_EVENT_SET 0x1
#define FAST_EVENT_SET_SHIFT 0
#define FAST_EVENT_REFCOUNT_SHIFT 1
#define FAST_EVENT_REFCOUNT_INC 0x2
#define FAST_EVENT_REFCOUNT_MASK (((ULONG_PTR)1 << 15) - 1)
#define FAST_EVENT_INIT { { FAST_EVENT_REFCOUNT_INC }, NULL } 

VOID supInitFastEvent(
    _In_ PFAST_EVENT Event);

VOID supReferenceFastEvent(
    _In_ PFAST_EVENT Event);

VOID supDereferenceFastEvent(
    _In_ PFAST_EVENT Event,
    _In_opt_ HANDLE EventHandle);

VOID supSetFastEvent(
    _In_ PFAST_EVENT Event);

BOOLEAN supTestFastEvent(
    _In_ PFAST_EVENT Event);

VOID supResetFastEvent(
    _In_ PFAST_EVENT Event);

BOOLEAN supWaitForFastEvent(
    _In_ PFAST_EVENT Event,
    _In_opt_ PLARGE_INTEGER Timeout);

typedef struct _SUP_SHIM_INFO {
    LPCWSTR KseShimName;
    GUID *Guid;
    LPCWSTR Description;
    LPCWSTR OwnerModule;
} SUP_SHIM_INFO, * PSUP_SHIM_INFO;

//
// Heap memory allocations
//
HANDLE supCreateHeap(
    _In_ ULONG HeapFlags,
    _In_ BOOL TerminateOnCorruption);

BOOL supDestroyHeap(
    _In_ HANDLE HeapHandle);

PVOID supHeapAllocEx(
    _In_ HANDLE Heap,
    _In_ SIZE_T Size);

BOOL supHeapFreeEx(
    _In_ HANDLE Heap,
    _In_ PVOID Memory);

PVOID supHeapAlloc(
    _In_ SIZE_T Size);

BOOL supHeapFree(
    _In_ PVOID Memory);

//
// Use shared NTSUP forward.
//

#define supGetSystemInfoEx ntsupGetSystemInfoEx
#define supVirtualAllocEx ntsupVirtualAllocEx
#define supVirtualAlloc ntsupVirtualAlloc
#define supVirtualFree ntsupVirtualFree
#define supEnablePrivilege ntsupEnablePrivilege
#define supGetCurrentProcessToken ntsupGetCurrentProcessToken
#define supQuerySystemRangeStart ntsupQuerySystemRangeStart
#define supQueryUserModeAccessibleRange ntsupQueryUserModeAccessibleRange
#define supIsProcess32bit ntsupIsProcess32bit
#define supQueryThreadWin32StartAddress ntsupQueryThreadWin32StartAddress
#define supOpenDirectoryEx ntsupOpenDirectoryEx
#define supQueryProcessName ntsupQueryProcessName
#define supQueryProcessEntryById ntsupQueryProcessEntryById
#define supWriteBufferToFile ntsupWriteBufferToFile
#define supQueryVsmProtectionInformation ntsupQueryVsmProtectionInformation
#define supQueryHVCIState ntsupQueryHVCIState
#define supLookupImageSectionByName ntsupLookupImageSectionByName
#define supFindPattern ntsupFindPattern
#define supFindPatternEx ntsupFindPatternEx
#define supOpenProcess ntsupOpenProcess
#define supOpenThread ntsupOpenThread
#define supCICustomKernelSignersAllowed ntsupCICustomKernelSignersAllowed
#define supPrivilegeEnabled ntsupPrivilegeEnabled
#define supIsObjectExists ntsupIsObjectExists
#define supIsKdEnabled ntsupIsKdEnabled
#define supIsLxssAvailable() ntsupIsObjectExists(TEXT("\\Device"), TEXT("Lxss"))
#define supDisableRedraw(hwnd) SendMessage((hwnd), WM_SETREDRAW, (WPARAM)FALSE, 0)
#define supEnableRedraw(hwnd) SendMessage((hwnd), WM_SETREDRAW, (WPARAM)TRUE, 0); \
    InvalidateRect((hwnd), NULL, TRUE); \
    UpdateWindow(hwnd)

//
// NTSUP defines for common information query
//

#define supQuerySecurityInformation(ObjectHandle, SecurityInformationClass, Buffer, ReturnLength) \
    ntsupQuerySecurityInformation(ObjectHandle, SecurityInformationClass, Buffer, ReturnLength, supHeapAlloc, supHeapFree)

#define supQueryObjectInformation(ObjectHandle, ObjectInformationClass, Buffer, ReturnLength) \
    ntsupQueryObjectInformation(ObjectHandle, ObjectInformationClass, Buffer, ReturnLength, supHeapAlloc, supHeapFree)

#define supQueryProcessInformation(ProcessHandle, ProcessInformationClass, Buffer, ReturnLength) \
    ntsupQueryProcessInformation(ProcessHandle, ProcessInformationClass, Buffer, ReturnLength, supHeapAlloc, supHeapFree)

#define supQueryThreadInformation(ThreadHandle, ThreadInformationClass, Buffer, ReturnLength) \
    ntsupQueryThreadInformation(ThreadHandle, ThreadInformationClass, Buffer, ReturnLength, supHeapAlloc, supHeapFree)

FORCEINLINE BOOLEAN supUnicodeStringValid(
    _In_ PUNICODE_STRING SourceString
)
{
    if (SourceString == NULL)
        return FALSE;

    if (((SourceString->Length % sizeof(WCHAR)) != 0) ||
        ((SourceString->MaximumLength % sizeof(WCHAR)) != 0) ||
        (SourceString->Length > SourceString->MaximumLength) ||
        (SourceString->MaximumLength > (UNICODE_STRING_MAX_CHARS * sizeof(WCHAR))))
    {
        return FALSE;
    }
    else if ((SourceString->Buffer == NULL) &&
        ((SourceString->Length != 0) || (SourceString->MaximumLength != 0)))
    {
        return FALSE;
    }

    return TRUE;
}

#define supIsRootDirectory(DirectoryName) RtlEqualUnicodeString(ObGetPredefinedUnicodeString(OBP_ROOT), DirectoryName, TRUE)

BOOL supInitMSVCRT(
    VOID);

VOID supTreeListEnableRedraw(
    _In_ HWND TreeList,
    _In_ BOOL fEnable);

HTREEITEM supTreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems);

BOOL supInitTreeListForDump(
    _In_  HWND  hwndParent,
    _Out_ HWND* pTreeListHwnd);

VOID supShowHelp(
    _In_ HWND ParentWindow);

BOOL supQueryObjectFromHandleEx(
    _In_ PSYSTEM_HANDLE_INFORMATION_EX HandlesDump,
    _In_ HANDLE Object,
    _Out_opt_ ULONG_PTR* Address,
    _Out_opt_ USHORT* TypeIndex);

BOOL supQueryObjectFromHandle(
    _In_ HANDLE Object,
    _Out_ ULONG_PTR* Address,
    _Out_opt_ USHORT* TypeIndex);

HICON supGetMainIcon(
    _In_ LPCWSTR lpFileName,
    _In_ INT cx,
    _In_ INT cy);

_Success_(return)
BOOL supNormalizeUnicodeStringForDisplay(
    _In_ HANDLE HeapHandle,
    _In_ PUNICODE_STRING SourceString,
    _Out_ PUNICODE_STRING NormalizedString);

_Success_(return)
BOOL supFreeUnicodeString(
    _In_ HANDLE HeapHandle,
    _Inout_ PUNICODE_STRING String);

_Success_(return)
BOOL supFreeDuplicatedUnicodeString(
    _In_ HANDLE HeapHandle,
    _Inout_ PUNICODE_STRING DuplicatedString,
    _In_ BOOL DoZeroMemory);

_Success_(return)
BOOL supDuplicateUnicodeString(
    _In_ HANDLE HeapHandle,
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

_Success_(return)
BOOL supCreateObjectPathFromElements(
    _In_ PUNICODE_STRING ObjectName,
    _In_ PUNICODE_STRING DirectoryName,
    _Out_ PUNICODE_STRING ObjectPath,
    _In_ BOOLEAN NullTerminate);

_Success_(return)
BOOL supCreateObjectPathFromCurrentPath(
    _In_ PUNICODE_STRING ObjectName,
    _Out_ PUNICODE_STRING ObjectPath,
    _In_ BOOLEAN NullTerminate);

SIZE_T supFindUnicodeStringSubString(
    _In_ PUNICODE_STRING String,
    _In_ PUNICODE_STRING SubString);

VOID supCenterWindow(
    _In_ HWND hwnd);

VOID supCenterWindowSpecifyParent(
    _In_ HWND hwnd,
    _In_opt_ HWND parent);

VOID supCenterWindowPerScreen(
    _In_ HWND hwnd);

VOID supSetWaitCursor(
    _In_ BOOL fSet);

HIMAGELIST supLoadImageList(
    _In_ HINSTANCE hInst,
    _In_ UINT FirstId,
    _In_ UINT LastId);

PVOID supGetObjectTypesInfo(
    VOID);

WOBJ_OBJECT_TYPE supGetObjectNameIndexByTypeIndex(
    _In_ PVOID Object,
    _In_ UCHAR TypeIndex);

VOID supRunAsAdmin(
    VOID);

BOOL supTreeListCopyItemValueToClipboard(
    _In_ HWND hwndTreeList,
    _In_ INT tlSubItemHit);

BOOL supListViewCopyItemValueToClipboard(
    _In_ HWND hwndListView,
    _In_ INT iItem,
    _In_ INT iSubItem);

BOOL supTreeListAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndTreeList,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ LPARAM lParam,
    _In_ INT* pSubItemHit);

BOOL supListViewAddCopyValueItem(
    _In_ HMENU hMenu,
    _In_ HWND hwndLv,
    _In_ UINT uId,
    _In_ UINT uPos,
    _In_ POINT* lpPoint,
    _Out_ INT* pItemHit,
    _Out_ INT* pColumnHit);

VOID supSetMenuIcon(
    _In_ HMENU hMenu,
    _In_ UINT iItem,
    _In_ HICON hIcon);

VOID supSetGotoLinkTargetToolButtonState(
    _In_ HWND hwnd,
    _In_opt_ HWND hwndlv,
    _In_ INT iItem,
    _In_ BOOL bForce,
    _In_ BOOL bForceEnable);

WOBJ_OBJECT_TYPE supObjectListGetObjectType(
    _In_ HWND hwndList,
    _In_ INT iItem);

VOID supCreateToolbarButtons(
    _In_ HWND hWndToolbar,
    _In_ HIMAGELIST hImageList);

VOID supAddShutdownCallback(
    _In_ PSUPSHUTDOWNCALLBACK Callback,
    _In_opt_ PVOID Context);

VOID supInit(
    _In_ BOOLEAN IsFullAdmin);

VOID supShutdown(
    VOID);

PVOID supCreateObjectTypesList(
    VOID);

VOID supShowProperties(
    _In_ HWND hwndDlg,
    _In_ LPWSTR lpFileName);

VOID supClipboardCopy(
    _In_ LPCWSTR lpText,
    _In_ SIZE_T cbTextInBytes);

LPWSTR supGetItemText(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _Out_opt_ PSIZE_T lpSize);

LPWSTR supGetItemText2(
    _In_ HWND ListView,
    _In_ INT nItem,
    _In_ INT nSubItem,
    _In_ WCHAR* pszText,
    _In_ UINT cchText);

BOOL supQuerySectionFileInfo(
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING ObjectName,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD ccBuffer);

BOOL supQueryTypeInfo(
    _In_ PUNICODE_STRING TypeName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD BufferSize,
    _In_ DWORD KnownPoolTypesCount,
    _In_ PVALUE_DESC PoolTypes);

BOOL supQueryDriverDescription(
    _In_ LPCWSTR lpDriverName,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD cchBuffer);

BOOL supQueryDeviceDescription(
    _In_opt_ PUNICODE_STRING Path,
    _In_ PUNICODE_STRING Name,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD ccBuffer);

BOOL supQueryWinstationDescription(
    _In_ LPCWSTR lpWindowStationName,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD cchBuffer);

PVOID supGetTokenInfo(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_opt_ PULONG ReturnLength);

PVOID supGetLoadedModulesList(
    _Out_opt_ PULONG ReturnLength);

PVOID supGetLoadedModulesList2(
    _Out_opt_ PULONG ReturnLength);

PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS supOpenDeviceObject(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS supOpenDeviceObjectEx(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

BOOL supDumpSyscallTableConverted(
    _In_ ULONG_PTR ServiceTableAddress,
    _In_ ULONG ServiceLimit,
    _Out_ PUTable* Table);

BOOL supCreateSCMSnapshot(
    _In_ ULONG ServiceType,
    _Out_opt_ SCMDB* Snapshot);

VOID supFreeSCMSnapshot(
    _In_opt_ SCMDB* Snapshot);

BOOL sapiCreateSetupDBSnapshot(
    VOID);

VOID sapiFreeSnapshot(
    VOID);

BOOL supSaveDialogExecute(
    _In_ HWND OwnerWindow,
    _Inout_ LPWSTR SaveFileName,
    _In_ LPCWSTR DialogFilter);

VOID supSetListViewSettings(
    _In_ HWND hwndLV,
    _In_ DWORD dwExtendedStyle,
    _In_ BOOL fIgnoreGlobalSettings,
    _In_ BOOL fSetTheme,
    _In_opt_ HIMAGELIST hImageList,
    _In_ INT iImageList);

HICON supGetStockIcon(
    _In_ SHSTOCKICONID siid,
    _In_ UINT uFlags);

LPWSTR supGetWin32FileName(
    _In_ LPCWSTR NtFileName);

BOOLEAN supQuerySecureBootState(
    _Out_ PBOOLEAN pbSecureBoot);

HWINSTA supOpenWindowStationFromContext(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ BOOL fInherit,
    _In_ ACCESS_MASK dwDesiredAccess);

NTSTATUS supQueryObjectTrustLabel(
    _In_ HANDLE hObject,
    _Out_ PULONG ProtectionType,
    _Out_ PULONG ProtectionLevel);

BOOL supIsImmersiveProcess(
    _In_ HANDLE hProcess);

NTSTATUS supIsProtectedProcess(
    _In_ HANDLE hProcess,
    _Out_ PBOOL pbProtected);

NTSTATUS supIsLocalSystem(
    _In_ HANDLE hToken,
    _Out_ PBOOL pbResult);

BOOL supRunAsLocalSystem(
    _In_ HWND hwndParent);

BOOLEAN supIsLocalServiceSid(
    _In_ PSID Sid);

VOID supUpdateLvColumnHeaderImage(
    _In_ HWND ListView,
    _In_ INT NumberOfColumns,
    _In_ INT UpdateColumn,
    _In_ INT ImageIndex);

INT supGetMaxOfTwoUlongFromHex(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

INT supGetMaxOfTwoU64FromHex(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

INT supGetMaxOfTwoLongFromString(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

INT supGetMaxOfTwoULongFromString(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

INT supGetMaxCompareTwoFixedStrings(
    _In_ HWND ListView,
    _In_ LPARAM lParam1,
    _In_ LPARAM lParam2,
    _In_ LPARAM lParamSort,
    _In_ BOOL Inverse);

NTSTATUS supOpenNamedObjectByType(
    _Out_ HANDLE* ObjectHandle,
    _In_ ULONG TypeIndex,
    _In_ PUNICODE_STRING ObjectDirectory,
    _In_ PUNICODE_STRING ObjectName,
    _In_ ACCESS_MASK DesiredAccess);

HANDLE supOpenObjectFromContext(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ OBJECT_ATTRIBUTES* ObjectAttributes,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ NTSTATUS* Status);

BOOL supCloseObjectFromContext(
    _In_ PROP_OBJECT_INFO* Context,
    _In_ HANDLE hObject);

VOID supShowLastError(
    _In_ HWND hWnd,
    _In_ LPCWSTR Source,
    _In_ DWORD LastError);

LPWSTR supFormatNtError(
    _In_ NTSTATUS NtError);

PSID supQueryTokenUserSid(
    _In_ HANDLE ProcessToken);

PSID supQueryProcessSid(
    _In_ HANDLE ProcessHandle);

VOID supJumpToFile(
    _In_ LPCWSTR lpFilePath);

PVOID supBSearch(
    _In_ PCVOID key,
    _In_ PCVOID base,
    _In_ SIZE_T num,
    _In_ SIZE_T size,
    _In_ int(*cmp)(
        _In_ PCVOID key,
        _In_ PCVOID elt
        ));

_Success_(return != FALSE)
BOOL supGetProcessDepState(
    _In_ HANDLE hProcess,
    _Out_ PPROCESS_MITIGATION_DEP_POLICY DepPolicy);

_Success_(return != FALSE)
BOOL supGetProcessMitigationPolicy(
    _In_ HANDLE hProcess,
    _In_ PROCESS_MITIGATION_POLICY Policy,
    _In_ SIZE_T Size,
    _Out_writes_bytes_(Size) PVOID Buffer);

NTSTATUS supOpenProcessEx(
    _In_ HANDLE UniqueProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

NTSTATUS supOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _Out_ PHANDLE TokenHandle);

INT supPrintTimeToBuffer(
    _In_ PLARGE_INTEGER Time,
    _In_ WCHAR * lpszBuffer,
    _In_ SIZE_T cchBuffer);

BOOL supPrintTimeConverted(
    _In_ PLARGE_INTEGER Time,
    _In_ WCHAR* lpszBuffer,
    _In_ SIZE_T cchBuffer);

_Success_(return)
BOOL supGetTreeViewItemParam(
    _In_ HWND hwndTreeView,
    _In_ HTREEITEM hTreeItem,
    _Out_ PVOID * outParam);

_Success_(return)
BOOL supGetListViewItemParam(
    _In_ HWND hwndListView,
    _In_ INT itemIndex,
    _Out_ PVOID* outParam);

VOID supSetMinMaxTrackSize(
    _In_ PMINMAXINFO MinMaxInfo,
    _In_ INT MinX,
    _In_ INT MinY,
    _In_ BOOL Scaled);

BOOL WINAPI supCallbackShowChildWindow(
    _In_ HWND hwnd,
    _In_ LPARAM lParam);

LPWSTR supGetSidNameUse(
    _In_ SID_NAME_USE SidNameUse);

LPWSTR supIntegrityToString(
    _In_ DWORD IntegrityLevel);

BOOL supLookupSidUserAndDomainEx(
    _In_ PSID Sid,
    _In_ LSA_HANDLE PolicyHandle,
    _Out_ LPWSTR* lpSidUserAndDomain);

BOOL supLookupSidUserAndDomain(
    _In_ PSID Sid,
    _Out_ LPWSTR* lpSidUserAndDomain);

NTSTATUS supLsaOpenMachinePolicy(
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PLSA_HANDLE PolicyHandle);

PSUP_HANDLE_DUMP supHandlesCreateFilteredAndSortedList(
    _In_ ULONG_PTR FilterUniqueProcessId,
    _In_ BOOLEAN fObject);

BOOL supHandlesQueryObjectAddress(
    _In_ PSUP_HANDLE_DUMP SortedHandleList,
    _In_ HANDLE ObjectHandle,
    _Out_ PULONG_PTR ObjectAddress);

BOOL supPHLCreate(
    _Inout_ PLIST_ENTRY ListHead,
    _In_ PBYTE ProcessList,
    _Out_ PULONG NumberOfProcesses,
    _Out_ PULONG NumberOfThreads);

VOID supPHLFree(
    _In_ PLIST_ENTRY ListHead,
    _In_ BOOLEAN fClose);

HANDLE supPHLGetEntry(
    _In_ PLIST_ENTRY ListHead,
    _In_ HANDLE UniqueProcessId);

PVOID supSLCacheRead(
    VOID);

BOOLEAN supSLCacheEnumerate(
    _In_ PVOID CacheData,
    _In_opt_ PENUMERATE_SL_CACHE_VALUE_DESCRIPTORS_CALLBACK Callback,
    _In_opt_ PVOID Context);

HRESULT supShellExecInExplorerProcess(
    _In_ PCWSTR pszFile,
    _In_opt_ PCWSTR pszArguments);

VOID supShowNtStatus(
    _In_ HWND hWnd,
    _In_ LPCWSTR lpText,
    _In_ NTSTATUS Status);

UINT supGetDPIValue(
    _In_opt_ HWND hWnd);

BOOLEAN supLoadIconForObjectType(
    _In_ HWND hwndDlg,
    _In_ PROP_OBJECT_INFO * Context,
    _In_ HIMAGELIST ImageList,
    _In_ BOOLEAN IsShadow);

NTSTATUS supOpenLinkedToken(
    _In_ HANDLE TokenHandle,
    _Out_ PHANDLE LinkedTokenHandle);

NTSTATUS supOpenTokenByParam(
    _In_ CLIENT_ID * ClientId,
    _In_ OBJECT_ATTRIBUTES * ObjectAttributes,
    _In_ ACCESS_MASK TokenDesiredAccess,
    _In_ BOOL IsThreadToken,
    _Out_ PHANDLE TokenHandle);

BOOL supRegDeleteKeyTree(
    _In_ HKEY hKeyRoot,
    _In_ LPCWSTR lpSubKey);

INT supAddListViewColumn(
    _In_ HWND ListViewHwnd,
    _In_ INT ColumnIndex,
    _In_ INT SubItemIndex,
    _In_ INT OrderIndex,
    _In_ INT ImageIndex,
    _In_ INT Format,
    _In_ LPWSTR Text,
    _In_ INT Width);

INT supListViewBaseComparer(
    _In_ HWND ListViewHandle,
    _In_ BOOL InverseSort,
    _In_ LPARAM FirstItem,
    _In_ LPARAM SecondItem,
    _In_ LPARAM ColumnToSort);

ULONG supHashString(
    _In_ PCWSTR String,
    _In_ ULONG Length);

ULONG supHashStringAnsi(
    _In_ PCSTR String,
    _In_ ULONG Length);

ULONG supHashUnicodeString(
    _In_ CONST UNICODE_STRING * String);

NTSTATUS supCreateSystemAdminAccessSD(
    _Out_ PSECURITY_DESCRIPTOR * SecurityDescriptor,
    _Out_ PACL * DefaultAcl);

VOID supSetProcessMitigationImagesPolicy();

BOOL supRichEdit32Load();

VOID supReportAbnormalTermination(
    _In_ LPCWSTR FunctionName);

VOID supReportException(
    _In_ ULONG ExceptionCode,
    _In_opt_ PEXCEPTION_POINTERS ExceptionPointers);

BOOL supGetVersionInfoFromSection(
    _In_ HANDLE SectionHandle,
    _Out_opt_ PDWORD VersionInfoSize,
    _Out_ LPVOID * VersionData);

VOID supReportAPIError(
    _In_ LPCWSTR FunctionName,
    _In_ NTSTATUS NtStatus);

BOOLEAN supIsFileImageSection(
    _In_ ULONG AllocationAttributes);

BOOLEAN supIsDriverShimmed(
    _In_ PKSE_ENGINE_DUMP KseEngineDump,
    _In_ PVOID DriverBaseAddress,
    _Out_opt_ GUID* ShimGUID);

SUP_SHIM_INFO* supGetDriverShimInformation(
    _In_ GUID ShimGuid);

BOOL supListViewExportToFile(
    _In_ LPCWSTR FileName,
    _In_ HWND WindowHandle,
    _In_ HWND ListView);

VOID supStatusBarSetText(
    _In_ HWND hwndStatusBar,
    _In_ WPARAM partIndex,
    _In_ LPCWSTR lpText);

VOID supJumpToFileListView(
    _In_ HWND hwndList,
    _In_ INT iFileNameColumn);

VOID supQueryAlpcPortObjectTypeIndex(
    _In_ PVOID PortIndexData);

BOOL supEnumHandleDump(
    _In_ PSYSTEM_HANDLE_INFORMATION_EX HandleDump,
    _In_ PENUMERATE_HANDLE_DUMP_CALLBACK EnumCallback,
    _In_ PVOID UserContext);

NTSTATUS supOpenPortObjectByName(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PUNICODE_STRING ObjectName);

NTSTATUS supOpenPortObjectFromContext(
    _Out_ PHANDLE ObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PROP_OBJECT_INFO * Context);

NTSTATUS supQueryProcessImageFileNameWin32(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING * ProcessImageFileName);

PSID supGetSidFromAce(
    _In_ PACE_HEADER AceHeader);

typedef VOID(CALLBACK* pfnPopupMenuHandler)(
    _In_ HWND hwndDlg,
    _In_ LPPOINT lpPoint,
    _In_opt_ PVOID lpUserParam
    );

VOID supHandleContextMenuMsgForListView(
    _In_ HWND hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam,
    _In_ HWND hwndControl,
    _In_ pfnPopupMenuHandler MenuHandler,
    _In_opt_ PVOID lpUserParam);

ULONG supAddLVColumnsFromArray(
    _In_ HWND ListView,
    _In_ PLVCOLUMNS_DATA ColumnsData,
    _In_ ULONG NumberOfColumns);

wchar_t* supExtractFileName(
    _In_ const wchar_t* lpFullPath);

VOID supObjectDumpHandlePopupMenu(
    _In_ HWND hwndDlg,
    _In_ HWND hwndTreeList,
    _In_ INT* pSubItemHit,
    _In_ LPARAM lParam);

VOID supObDumpShowError(
    _In_ HWND hwndDlg,
    _In_opt_ LPWSTR lpMessageText);

NTSTATUS supGetFirmwareType(
    _Out_ PFIRMWARE_TYPE FirmwareType);

NTSTATUS supIsBootDriveVHD(
    _Out_ PBOOLEAN IsVHD);

LPWSTR supPathAddBackSlash(
    _In_ LPWSTR lpszPath);

NTSTATUS supQueryProcessImageFileNameByProcessId(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING ProcessImageFileName);

LPWSTR supPrintHash(
    _In_reads_bytes_(Length) LPBYTE Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN UpcaseHex);

NTSTATUS supMapInputFileForRead(
    _In_ PFILE_VIEW_INFO ViewInformation,
    _In_ BOOLEAN PartialMap);

VOID supDestroyFileViewInfo(
    _In_ PFILE_VIEW_INFO ViewInformation);

BOOLEAN supIsValidImage(
    _In_ PFILE_VIEW_INFO ViewInformation);

NTSTATUS supLoadDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam);

NTSTATUS supLoadDriver(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance);

NTSTATUS supUnloadDriver(
    _In_ LPCWSTR DriverName,
    _In_ BOOLEAN fRemove);

NTSTATUS supOpenDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE DeviceHandle);

NTSTATUS supOpenDriver(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE DeviceHandle);

BOOL supDeleteFileWithWait(
    _In_ ULONG WaitMilliseconds,
    _In_ ULONG NumberOfAttempts,
    _In_ LPCWSTR lpFileName);

NTSTATUS supCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

BOOLEAN supIsLongTermServicingWindows(
    VOID);

HANDLE supCreateThread(
    _In_ LPTHREAD_START_ROUTINE lpStartAddress,
    _In_opt_ __drv_aliasesMem LPVOID lpParameter,
    _In_ DWORD dwCreationFlags);

HANDLE supCreateDialogWorkerThread(
    _In_ LPTHREAD_START_ROUTINE lpStartAddress,
    _In_opt_ __drv_aliasesMem LPVOID lpParameter,
    _In_ DWORD dwCreationFlags);

VOID supBuildCurrentObjectList(
    _In_ PVOID ListHead);

_Success_(return != FALSE)
BOOL supGetCurrentObjectPath(
    _In_ BOOLEAN IncludeName,
    _Out_ PUNICODE_STRING ObjectPath);

_Success_(return)
BOOL supGetCurrentObjectName(
    _Out_ PUNICODE_STRING ObjectName);

VOID supDisplayCurrentObjectPath(
    _In_ HWND hwnd,
    _In_opt_ PUNICODE_STRING Path,
    _In_ BOOLEAN NormalizePath);

_Success_(return)
BOOL supResolveSymbolicLinkTarget(
    _In_opt_ HANDLE LinkHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Out_ PUNICODE_STRING LinkTarget);

_Success_(return)
BOOL supResolveSymbolicLinkTargetNormalized(
    _In_opt_ HANDLE LinkHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Out_ PUNICODE_STRING NormalizedLinkTarget);

VOID supClipboardCopyUnicodeStringRaw(
    _In_ PUNICODE_STRING String);

BOOL supImageFixSections(
    _In_ LPVOID Buffer);

VOID supCloseKnownPropertiesDialog(
    _In_opt_ HWND hwndDlg);

_Success_(return)
BOOL supReadObexConfiguration(
    _Out_ POBEX_CONFIG Configuration);

POBEX_CONFIG supGetParametersBlock(
    VOID);

HWND supCreateTrackingToolTip(
    _In_ INT toolID,
    _In_ HWND hwndOwner);

BOOLEAN supEnablePrivilegeWithCheck(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable);

BOOL supIsPrivilegeEnabledForClient(
    _In_ ULONG Privilege);

ULONG supFilterCreateList(
    _In_ PLIST_ENTRY FltListHead);

VOID supFilterDestroyList(
    _In_ PLIST_ENTRY FltListHead);

BOOL supFilterFindByName(
    _In_ PLIST_ENTRY FltListHead,
    _In_ LPCWSTR Name);

BOOL supLoadSymbolsForNtImage(
    _In_ PSYMCONTEXT SymContext,
    _In_ LPCWSTR ImageFileName,
    _In_ PVOID ImageBase,
    _In_ DWORD SizeOfImage);

VOID CALLBACK supSymCallbackReportEvent(
    _In_ LPCWSTR EventText,
    _In_opt_ LPCWSTR StatusText);

VOID supCallbackReportEvent(
    _In_ ULONG ActionCode,
    _In_ PIMAGEHLP_DEFERRED_SYMBOL_LOAD Action,
    _In_ PFNSUPSYMCALLBACK UserCallback);

```

`Source/WinObjEx64/sup/sync.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       SYNC.C
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Synchronization primitives.
* 
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

/*
*
* Fast events, taken from ph2
*
*/

/*
* supInitFastEvent
*
* Purpose:
*
* Initialize fast event.
*
*/
VOID supInitFastEvent(
    _In_ PFAST_EVENT Event
)
{
    Event->Value = FAST_EVENT_REFCOUNT_INC;
    Event->EventHandle = NULL;
}

/*
* supReferenceFastEvent
*
* Purpose:
*
* Make a reference for fast event.
*
*/
VOID supReferenceFastEvent(
    _In_ PFAST_EVENT Event
)
{
    _InterlockedExchangeAddPointer((PLONG_PTR)&Event->Value, FAST_EVENT_REFCOUNT_INC);
}

/*
* supDereferenceFastEvent
*
* Purpose:
*
* Remove reference from fast event.
*
*/
VOID supDereferenceFastEvent(
    _In_ PFAST_EVENT Event,
    _In_opt_ HANDLE EventHandle
)
{
    ULONG_PTR value;

    value = _InterlockedExchangeAddPointer((PLONG_PTR)&Event->Value, -FAST_EVENT_REFCOUNT_INC);
    if (((value >> FAST_EVENT_REFCOUNT_SHIFT) & FAST_EVENT_REFCOUNT_MASK) - 1 == 0)
    {
        if (EventHandle)
        {
            NtClose(EventHandle);
            Event->EventHandle = NULL;
        }
    }
}

/*
* supSetFastEvent
*
* Purpose:
*
* Set event to signaled state.
*
*/
VOID supSetFastEvent(
    _In_ PFAST_EVENT Event
)
{
    HANDLE eventHandle;
    if (!_InterlockedBitTestAndSetPointer((PLONG_PTR)&Event->Value, FAST_EVENT_SET_SHIFT)) {
        eventHandle = Event->EventHandle;

        if (eventHandle)
        {
            NtSetEvent(eventHandle, NULL);
        }
    }
}

/*
* supTestFastEvent
*
* Purpose:
*
* Returns fast event state.
*
*/
BOOLEAN supTestFastEvent(
    _In_ PFAST_EVENT Event
)
{
    return (BOOLEAN)Event->Set; //-V724
}

/*
* supResetFastEvent
*
* Purpose:
*
* Perform fast event manual reset.
*
*/
VOID supResetFastEvent(
    _In_ PFAST_EVENT Event
)
{
    if (Event == NULL)
        return;

    if (supTestFastEvent(Event))
        Event->Value = FAST_EVENT_REFCOUNT_INC;
}

/*
* supWaitForFastEvent
*
* Purpose:
*
* Do the wait for event, if event object not allocated - allocate it.
*
*/
BOOLEAN supWaitForFastEvent(
    _In_ PFAST_EVENT Event,
    _In_opt_ PLARGE_INTEGER Timeout
)
{
    BOOLEAN result;
    ULONG_PTR value;
    HANDLE eventHandle;

    value = Event->Value;
    if (value & FAST_EVENT_SET)
        return TRUE;

    if (Timeout && Timeout->QuadPart == 0)
        return FALSE;

    supReferenceFastEvent(Event);
    eventHandle = Event->EventHandle;

    if (eventHandle == NULL) {

        NtCreateEvent(&eventHandle, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
        assert(eventHandle);

        if (NULL != _InterlockedCompareExchangePointer(
            &Event->EventHandle,
            eventHandle,
            NULL))
        {
            NtClose(eventHandle);
            eventHandle = Event->EventHandle;
        }

    }

    if (!(Event->Value & FAST_EVENT_SET)) {
        result = (NtWaitForSingleObject(eventHandle, FALSE, Timeout) == STATUS_WAIT_0);
    }
    else {
        result = TRUE;
    }

    supDereferenceFastEvent(Event, eventHandle);

    return result;
}

```

`Source/WinObjEx64/sup/w32k.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023 - 2025
*
*  TITLE:       W32K.C
*
*  VERSION:     2.10
*
*  DATE:        03 Oct 2025
*
*  Win32k syscall table actual handlers resolving routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "ntos/ntldr.h"
#include "hde/hde64.h"
#include "ksymbols.h"
#include "sup/w32k.h"

//
// Win32kApiSetTable signatures
//

//
// Win32kApiSetTable adapter patterns
//
BYTE Win32kApiSetAdapterPattern1[] = {
   0x4C, 0x8B, 0x15
};
BYTE Win32kApiSetAdapterPattern2[] = {
   0x48, 0x8B, 0x05
};
BYTE Win32kApiSetAdapterPattern3[] = {
   0x4C, 0x8B, 0x1D // mov r11, value
};

W32K_API_SET_LOOKUP_PATTERN W32kApiSetAdapters[] = {
    { sizeof(Win32kApiSetAdapterPattern1), Win32kApiSetAdapterPattern1 },
    { sizeof(Win32kApiSetAdapterPattern2), Win32kApiSetAdapterPattern2 },
    { sizeof(Win32kApiSetAdapterPattern3), Win32kApiSetAdapterPattern3 }
};

typedef struct _SDT_SEARCH_CONTEXT {
    PBYTE Result;
} SDT_SEARCH_CONTEXT, * PSDT_SEARCH_CONTEXT;

BOOL CALLBACK ApiSetSearchPatternCallback(
    _In_ PBYTE Buffer,
    _In_ ULONG PatternSize,
    _In_ PVOID CallbackContext
)
{
    UNREFERENCED_PARAMETER(PatternSize);

    PSDT_SEARCH_CONTEXT context = (PSDT_SEARCH_CONTEXT)CallbackContext;
    context->Result = Buffer;

    return TRUE;
}

/*
* ApiSetFindWin32kApiSetTableRef
*
* Purpose:
*
* Locate prologue of win32k!InitializeWin32kCall.
*
*/
PBYTE ApiSetFindWin32kApiSetTableRef(
    _In_ PVOID SectionBase,
    _In_ ULONG SectionSize
)
{
    PBYTE result = NULL;
    PATTERN_SEARCH_PARAMS params;
    SDT_SEARCH_CONTEXT scontext;

    BYTE pbPattern[] = {
        0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x48, 0x89, 0x7C, 0x24, 0x20 };
    BYTE pbMask[] = {
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00, 0x11, 0x11 };

    scontext.Result = NULL;
    params.Buffer = (PBYTE)SectionBase;
    params.BufferSize = SectionSize;
    params.Callback = ApiSetSearchPatternCallback;
    params.CallbackContext = &scontext;

    params.Pattern = pbPattern;
    params.PatternSize = sizeof(pbPattern);
    params.Mask = pbMask;

    if (supFindPatternEx(&params))
        result = scontext.Result;

    return result;
}

/*
* SdtpQueryWin32kApiSetTable
*
* Purpose:
*
* Locate address of win32k!Win32kApiSetTable structure.
*
*/
ULONG_PTR SdtpQueryWin32kApiSetTable(
    _In_ HMODULE hModule,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ImageSize,
    _In_opt_ SYMCONTEXT* SymContext
)
{
    LONG relativeValue = 0;
    ULONG SectionSize = 0, Index;
    PBYTE ptrCode = (PBYTE)hModule;
    PVOID SectionBase;
    ULONG_PTR tableAddress = 0, instructionLength = 0;
    hde64s hs;

    if (SymContext) {

        if (kdGetAddressFromSymbolEx(SymContext,
            KVAR_Win32kApiSetTable,
            ImageBase,
            ImageSize,
            &tableAddress))
        {
            tableAddress = tableAddress - (ULONG_PTR)ImageBase + (ULONG_PTR)hModule;
        }

    }

    if (tableAddress == 0) {

        //
        // Locate .text image section as required variable is always in .text.
        //
        SectionBase = supLookupImageSectionByName(TEXT_SECTION,
            TEXT_SECTION_LENGTH,
            (PVOID)hModule,
            &SectionSize);

        if (SectionBase == 0 || SectionSize == 0)
            return 0;

        //
        // Locate Win32kApiSetTable ref routine.
        //
        ptrCode = ApiSetFindWin32kApiSetTableRef(SectionBase,
            SectionSize);

        if (ptrCode == NULL) {
            return 0;
        }

        Index = 0;
        instructionLength = 0;

        do {

            hde64_disasm((void*)(ptrCode + Index), &hs);
            if (hs.flags & F_ERROR)
                break;

            // lea reg, Win32kApiSetTable
            if ((hs.len == 7) &&
                (hs.flags & F_PREFIX_REX) &&
                (hs.flags & F_DISP32) &&
                (hs.flags & F_MODRM) &&
                (hs.opcode == 0x8D))
            {
                relativeValue = (LONG)hs.disp.disp32;
                instructionLength = hs.len;
                break;
            }

            Index += hs.len;

        } while (Index < 256);


        if (relativeValue == 0 || instructionLength == 0)
            return 0;

        //
        // Sanity check.
        //
        tableAddress = (ULONG_PTR)ptrCode + Index + instructionLength + relativeValue;
        if (tableAddress < (ULONG_PTR)hModule ||
            tableAddress >= ((ULONG_PTR)hModule + ImageSize))
        {
            return 0;
        }
    }

    return tableAddress;
}

/*
* SdtpQueryW32GetWin32kApiSetTableOffset
*
* Purpose:
*
* Locate offset for Win32kApiSetTable.
*
*/
ULONG SdtpQueryW32GetWin32kApiSetTableOffset(
    _In_ HMODULE hModule
)
{
    ULONG Index, matchCount, scanBytes, instCount;
    PBYTE ptrCode;
    hde64s hs;

    ptrCode = (PBYTE)GetProcAddress(hModule, "W32GetWin32kApiSetTable");
    if (ptrCode == NULL) {
        return 0;
    }

    Index = 0;
    matchCount = 0;
    scanBytes = (g_NtBuildNumber > NT_WIN11_25H2) ? 64 : 32;
    instCount = (g_NtBuildNumber > NT_WIN11_25H2) ? 2 : 1;

    do {

        hde64_disasm((void*)(ptrCode + Index), &hs);
        if (hs.flags & F_ERROR)
            break;

        // mov rax, [rax+offset]
        if ((hs.len == 7) &&
            (hs.flags & F_PREFIX_REX) &&
            (hs.flags & F_DISP32) &&
            (hs.flags & F_MODRM) &&
            (hs.opcode == 0x8B))
        {
            matchCount += 1;
            if (matchCount >= instCount)
                return hs.disp.disp32;
        }

        Index += hs.len;

    } while (Index < scanBytes);

    return 0;
}

/*
* SdtpQueryWin32kSessionGlobals
*
* Purpose:
*
* Locate address of win32k!gSessionGlobals table.
*
*/
ULONG_PTR SdtpQueryWin32kSessionGlobals(
    _In_ HMODULE hModule,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ImageSize,
    _In_opt_ SYMCONTEXT* SymContext
)
{
    BOOL bFound = FALSE;
    LONG relativeValue = 0;
    ULONG Index, k;
    PBYTE ptrCode;
    ULONG_PTR globalsAddress = 0, instructionLength = 0;
    hde64s hs;

#ifndef _DEBUG
    if (SymContext) {

        kdGetAddressFromSymbolEx(SymContext,
            KVAR_gSessionGlobalSlots,
            ImageBase,
            ImageSize,
            &globalsAddress);
    }
#else
    UNREFERENCED_PARAMETER(SymContext);
    UNREFERENCED_PARAMETER(ImageSize);
#endif

    if (globalsAddress == 0) { //-V547

        ptrCode = (PBYTE)GetProcAddress(hModule, "W32GetSessionState");

        if (ptrCode == NULL) {
            return 0;
        }

        if (g_NtBuildNumber > NT_WIN11_25H2) {

            Index = 0;
            k = 0;

            do {

                hde64_disasm((void*)(ptrCode + Index), &hs);
                if (hs.flags & F_ERROR)
                    break;

                if ((hs.len == 7) &&
                    (hs.flags & F_MODRM) &&
                    (hs.opcode == 0x8B))
                {
                    relativeValue = (LONG)hs.disp.disp32;
                    instructionLength = hs.len;
                    break;
                }

                Index += hs.len;

            } while (Index < 64);
        }

        else {

            //
            // Find W32GetSessionStateForSession.
            //

            Index = 0;
            k = 0;

            do {

                hde64_disasm((void*)(ptrCode + Index), &hs);
                if (hs.flags & F_ERROR)
                    break;

                //      
                // Find W32GetSessionStateForSession call.
                //
                if ((hs.len == 5) &&
                    (hs.flags & F_RELATIVE) &&
                    (hs.opcode == 0xE8))
                {
                    k++;
                }

                if (k > 1) {
                    relativeValue = *(PLONG)(ptrCode + Index + 1);
                    bFound = TRUE;
                    break;
                }

                Index += hs.len;

            } while (Index < 64);

            if (bFound == FALSE || relativeValue == 0) {
                return 0;
            }

            ptrCode = ptrCode + Index + (hs.len) + relativeValue;

            //
            // Find gLowSessionGlobalSlots ref.
            //

            Index = 0;
            instructionLength = 0;
            relativeValue = 0;

            do {

                hde64_disasm((void*)(ptrCode + Index), &hs);
                if (hs.flags & F_ERROR)
                    break;

                if ((hs.len == 7) &&
                    (hs.flags & F_PREFIX_REX) &&
                    (hs.flags & F_DISP32) &&
                    (hs.flags & F_MODRM) &&
                    (hs.opcode == 0x8D))
                {
                    relativeValue = (LONG)hs.disp.disp32;
                    instructionLength = hs.len;
                    break;
                }

                Index += hs.len;

            } while (Index < 64);

        }

        if (relativeValue == 0 || instructionLength == 0)
            return 0;

        globalsAddress = (ULONG_PTR)ptrCode + Index + instructionLength + relativeValue;
        globalsAddress = (ULONG_PTR)ImageBase + globalsAddress - (ULONG_PTR)hModule;

    }

    return globalsAddress;
}

/*
* ApiSetExtractReferenceFromAdapter
*
* Purpose:
*
* Extract apiset reference from adapter code.
*
*/
ULONG_PTR ApiSetExtractReferenceFromAdapter(
    _In_ PBYTE ptrFunction
)
{
    BOOL bFound;
    PBYTE ptrCode = ptrFunction;
    ULONG Index = 0, i;
    LONG Rel = 0;
    hde64s hs;

    ULONG PatternSize;
    PVOID PatternData;

    do {
        hde64_disasm((void*)(ptrCode + Index), &hs);
        if (hs.flags & F_ERROR)
            break;

        if (hs.len == 7) {

            bFound = FALSE;

            for (i = 0; i < RTL_NUMBER_OF(W32kApiSetAdapters); i++) {

                PatternSize = W32kApiSetAdapters[i].Size;
                PatternData = W32kApiSetAdapters[i].Data;

                if (PatternSize == RtlCompareMemory(&ptrCode[Index],
                    PatternData,
                    PatternSize))
                {
                    Rel = *(PLONG)(ptrCode + Index + (hs.len - 4));
                    bFound = TRUE;
                    break;
                }

            }

            if (bFound)
                break;
        }

        Index += hs.len;

    } while (Index < 32);

    if (Rel == 0)
        return 0;

    return (ULONG_PTR)ptrCode + Index + hs.len + Rel;
}

/*
* ApiSetResolveAndLoadModule
*
* Purpose:
*
* Final apiset resolving and loading actual file.
*
* Function return NTSTATUS value and sets ModuleEntry parameter.
*
*/
NTSTATUS ApiSetResolveAndLoadModule(
    _In_ PVOID ApiSetMap,
    _In_ PCUNICODE_STRING ApiSetToResolve,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry
)
{
    NTSTATUS ntStatus;
    UNICODE_STRING usResolvedModule;

    RtlInitEmptyUnicodeString(&usResolvedModule, NULL, 0);

    //
    // Resolve ApiSet.
    //
    ntStatus = NtRawApiSetResolveLibrary(ApiSetMap,
        ApiSetToResolve,
        NULL,
        &usResolvedModule);

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = SdtLoadAndRememberModule(ModulesHead, &usResolvedModule, ModuleEntry, TRUE);

        if (!NT_SUCCESS(ntStatus))
            RtlFreeUnicodeString(&usResolvedModule);
    }

    return ntStatus;
}

/*
* ApiSetResolveWin32kTableEntry
*
* Purpose:
*
* Find entry in Win32kApiSetTable.
*
* Function return STATUS_SUCCESS on success and sets ResolvedEntry parameter.
*
*/
NTSTATUS ApiSetResolveWin32kTableEntry(
    _In_ ULONG_PTR ApiSetTable,
    _In_ ULONG_PTR LookupEntry,
    _In_ ULONG EntrySize,
    _Out_ PVOID* ResolvedEntry
)
{
    NTSTATUS resolveStatus = STATUS_APISET_NOT_PRESENT;
    PW32K_API_SET_TABLE_ENTRY pvTableEntry = (PW32K_API_SET_TABLE_ENTRY)ApiSetTable;
    ULONG cEntries;
    ULONG_PTR entryValue;
    PULONG_PTR pvHostEntries;

    *ResolvedEntry = NULL;

    //
    // Lookup entry in table.
    //
    __try {

        while (pvTableEntry->Host) {

            cEntries = pvTableEntry->Host->HostEntriesCount;
            pvHostEntries = (PULONG_PTR)pvTableEntry->HostEntriesArray;

            //
            // Search inside table host entry array.
            //
            do {

                entryValue = (ULONG_PTR)pvHostEntries;
                pvHostEntries++;

                if (entryValue == LookupEntry) {
                    *ResolvedEntry = (PVOID)pvTableEntry;
                    resolveStatus = STATUS_SUCCESS;
                    break;
                }

            } while (--cEntries);

            pvTableEntry = (PW32K_API_SET_TABLE_ENTRY)RtlOffsetToPointer(pvTableEntry, EntrySize);
        }
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        //
        // Should never be here. Only in case if table structure changed or ApiSetTable address points to invalid data.
        //
        return STATUS_ACCESS_VIOLATION;
    }

    return resolveStatus;
}

/*
* SdtMapModuleFromImportThunkWithResolve
*
* Purpose:
*
* Map module from disk (if it wasn't already mapped), resolve it name through ApiSet if required.
*
*/
NTSTATUS SdtMapModuleFromImportThunkWithResolve(
    _In_ LPCSTR lpModuleName,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry
)
{
    BOOLEAN bNeedApiSetResolve = (g_NtBuildNumber > 18885);
    NTSTATUS ntStatus = STATUS_DLL_NOT_FOUND;
    PVOID pvApiSetMap = NtCurrentPeb()->ApiSetMap;
    UNICODE_STRING usModuleName;

    //
    // Convert module name to UNICODE.
    //
    if (RtlCreateUnicodeStringFromAsciiz(&usModuleName, (PSTR)lpModuleName)) {

        //
        // Check whatever ApiSet resolving required.
        //
        if (bNeedApiSetResolve && pvApiSetMap) {

            ntStatus = ApiSetResolveAndLoadModule(
                pvApiSetMap,
                &usModuleName,
                ModulesHead,
                ModuleEntry);

        }
        else {
            //
            // No ApiSet resolve required, load as usual.
            //
            ntStatus = SdtLoadAndRememberModule(ModulesHead, &usModuleName, ModuleEntry, TRUE);
        }

        if (!NT_SUCCESS(ntStatus))
            RtlFreeUnicodeString(&usModuleName);

    }

    return ntStatus;
}

/*
* SdtResolveFunctionNameFromModuleExport
*
* Purpose:
*
* Resolve routine name (or ordinal) from module export.
*
*/
NTSTATUS SdtResolveFunctionNameFromModuleExport(
    _In_ HMODULE ModuleBase,
    _In_ ULONG_PTR LoadedModuleBase,
    _In_ ULONG_PTR KernelPointer,
    _Out_ LPCSTR* FunctionName,
    _Out_ PUSHORT Ordinal
)
{
    ULONG i, j, ordinalNumber = 0;
    PDWORD funcTable, nameTableBase;
    PUSHORT nameOrdinalTableBase;
    PIMAGE_EXPORT_DIRECTORY pExportDirectory;
    ULONG_PTR fnPtr;
    LPCSTR lpName = NULL;
    ULONG exportSize, exportRva;

    *FunctionName = NULL;
    *Ordinal = 0;
    __try {
        pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(ModuleBase,
            TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &exportSize);

        if (pExportDirectory) {

            nameOrdinalTableBase = (PUSHORT)RtlOffsetToPointer(ModuleBase, pExportDirectory->AddressOfNameOrdinals);
            funcTable = (PDWORD)RtlOffsetToPointer(ModuleBase, pExportDirectory->AddressOfFunctions);
            nameTableBase = (PDWORD)RtlOffsetToPointer(ModuleBase, pExportDirectory->AddressOfNames);
            fnPtr = KernelPointer - LoadedModuleBase;

            for (i = 0; i < pExportDirectory->NumberOfFunctions; i++) {

                ordinalNumber = pExportDirectory->Base + i;
                exportRva = funcTable[i];

                if (exportRva == fnPtr) {

                    for (j = 0; j < pExportDirectory->NumberOfNames; j++) {
                        if (nameOrdinalTableBase[j] == i) {
                            lpName = (LPCSTR)RtlOffsetToPointer(ModuleBase, nameTableBase[j]);
                            *FunctionName = lpName;
                            break;
                        }
                    }

                    *Ordinal = (USHORT)ordinalNumber;
                    return STATUS_SUCCESS;
                }

            }

        }
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }

    return STATUS_OBJECT_NAME_NOT_FOUND;
}

/*
* SdtResolveModuleFromImportThunk
*
* Purpose:
*
* Find a module for shadow table entry in win32k imports.
*
* Function return NTSTATUS value and sets ModuleEntry parameter.
*
*/
NTSTATUS SdtResolveModuleFromImportThunk(
    _In_ PSDT_CONTEXT Context,
    _In_ PBYTE FunctionPtr,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry
)
{
    LPCSTR pszDllName;
    ULONG importSize;
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor, pIID;
    PIMAGE_IMPORT_BY_NAME pImageImportByName;
    PIMAGE_THUNK_DATA pOrigFirstThunk, pFirstThunk, pFuncThunk;

    hde64s hs;
    LONG32 rel;

    __try {
        hde64_disasm(FunctionPtr, &hs);
        if (hs.flags & F_ERROR)
            return STATUS_INTERNAL_ERROR;

        if (!(hs.flags & F_DISP32))
            return STATUS_ILLEGAL_FUNCTION;

        rel = hs.disp.disp32;
        pFuncThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)FunctionPtr + hs.len + rel);

        pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
            Context->KernelModule,
            TRUE,
            IMAGE_DIRECTORY_ENTRY_IMPORT,
            &importSize);

        for (pIID = pImportDescriptor; pIID->Name != 0; pIID++) {

            pOrigFirstThunk = (PIMAGE_THUNK_DATA)RtlOffsetToPointer(Context->KernelModule, pIID->OriginalFirstThunk);
            pFirstThunk = (PIMAGE_THUNK_DATA)RtlOffsetToPointer(Context->KernelModule, pIID->FirstThunk);

            for (; pOrigFirstThunk->u1.AddressOfData; ++pOrigFirstThunk, ++pFirstThunk) {
                pImageImportByName = (PIMAGE_IMPORT_BY_NAME)RtlOffsetToPointer(Context->KernelModule,
                    pOrigFirstThunk->u1.AddressOfData);

                if (pFirstThunk == pFuncThunk) {
                    pszDllName = (LPCSTR)RtlOffsetToPointer(Context->KernelModule, pIID->Name);

                    return SdtMapModuleFromImportThunkWithResolve(
                        pszDllName,
                        ModulesHead,
                        ModuleEntry);

                }
            }
        }
    }
    __except (WOBJ_EXCEPTION_FILTER_LOG) {
        return GetExceptionCode();
    }

    return STATUS_UNSUCCESSFUL;
}

/*
* SdtResolveServiceEntryModule
*
* Purpose:
*
* Find a module for shadow table entry by parsing apisets(if present) and/or forwarders (if present).
*
* Function return NTSTATUS value and sets ModuleEntry parameter.
*
*/
NTSTATUS SdtResolveServiceEntryModule(
    _In_ PSDT_CONTEXT Context,
    _In_ PBYTE FunctionPtr,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry
)
{
    BOOLEAN bWin32kApiSetTableExpected = (g_NtBuildNumber > 18935);
    ULONG entrySize;
    NTSTATUS ntStatus = STATUS_DLL_NOT_FOUND;
    ULONG_PTR entryReference;
    PVOID pvApiSetMap = NtCurrentPeb()->ApiSetMap;
    W32K_API_SET_TABLE_ENTRY* pvApiSetEntry = NULL;
    UNICODE_STRING usApiSetEntry;

    //
    // See if this is new Win32kApiSetTable adapter.
    //
    if (bWin32kApiSetTableExpected && pvApiSetMap) {

        entryReference = ApiSetExtractReferenceFromAdapter(FunctionPtr);
        if (entryReference) {

            if (g_NtBuildNumber >= NT_WINSRV_21H1)
                entrySize = sizeof(W32K_API_SET_TABLE_ENTRY_V2);
            else
                entrySize = sizeof(W32K_API_SET_TABLE_ENTRY);

            ntStatus = ApiSetResolveWin32kTableEntry(
                Context->Win32kApiSetTable,
                entryReference,
                entrySize,
                (PVOID*)&pvApiSetEntry);

            if (!NT_SUCCESS(ntStatus))
                return ntStatus;

            //
            // Host is on the same offset for both V1/V2 versions.
            //
            RtlInitUnicodeString(&usApiSetEntry, pvApiSetEntry->Host->HostName);

            return ApiSetResolveAndLoadModule(
                pvApiSetMap,
                &usApiSetEntry,
                ModulesHead,
                ModuleEntry);

        }
    }

    //
    // Reference not found, search import.
    //

    return SdtResolveModuleFromImportThunk(Context,
        FunctionPtr,
        ModulesHead,
        ModuleEntry);
}

#define W32CALL_APISETTABLE_OFFSET 0
#define W32CALL_HOST_OFFSET        1
#define W32CALL_HOST_ENTRY_OFFSET  2
#define W32CALL_MAX_OFFSET         W32CALL_HOST_ENTRY_OFFSET

/*
* SdtResolveServiceEntryModuleSessionAware
*
* Purpose:
*
* Find a module for shadow table entry.
*
* Function return NTSTATUS value and sets ModuleEntry parameter.
*
*/
NTSTATUS SdtResolveServiceEntryModuleSessionAware(
    _In_ PSDT_CONTEXT Context,
    _In_ PBYTE FunctionPtr,
    _In_ PRTL_PROCESS_MODULES Modules,
    _Inout_ PSDT_FUNCTION_NAME ServiceName,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry
)
{
    BOOL bFound = FALSE;
    NTSTATUS resultStatus = STATUS_UNSUCCESSFUL;
    PCHAR pStr;
    PBYTE ptrCode = FunctionPtr, testPtr;
    ULONG hostOffset = 0, hostEntryOffset = 0;
    ULONG_PTR i, slotAddress, hostAddress = 0, hostEntry = 0, tableAddress = 0, routineAddress;
    PRTL_PROCESS_MODULE_INFORMATION pModule;
    UNICODE_STRING usModuleName;
    hde64s hs;

    ULONG offsets[3];
    ULONG offsetIndex, k;

    LONG rel;

    //
    // First, find offsets block.
    //
    do {


        i = 0;
        k = 0;

        do {

            hde64_disasm(RtlOffsetToPointer(ptrCode, i), &hs);
            if (hs.flags & F_ERROR) {
                resultStatus = STATUS_INTERNAL_ERROR;
                break;
            }

            //
            // Find W32GetSessionStateForSession relative call.
            //
            if ((hs.len == 5) &&
                (hs.flags & F_RELATIVE) &&
                (hs.opcode == 0xE8))
            {
                rel = *(PLONG)(ptrCode + i + 1);
                testPtr = ptrCode + i + (hs.len) + rel;

                if ((ULONG_PTR)testPtr == Context->W32GetSessionStatePtr) { // handle W32GetSessionState call variant.
                    ptrCode = (PBYTE)RtlOffsetToPointer(ptrCode, i + hs.len);
                    bFound = TRUE;
                    break;
                }

                k++; //skip win32k!GetCurrentProcessSessionId
            }

            if (k > 1) {
                ptrCode = (PBYTE)RtlOffsetToPointer(ptrCode, i + hs.len);
                bFound = TRUE;
                break;
            }

            i += hs.len;

        } while (i < 64);

        //
        // Offset block not found, function seems inlined, scan again.
        //
        if (!bFound) {

            i = 0;
            do {

                hde64_disasm(RtlOffsetToPointer(ptrCode, i), &hs);
                if (hs.flags & F_ERROR) {
                    resultStatus = STATUS_INTERNAL_ERROR;
                    break;
                }

                if ((hs.len == 4) &&
                    (hs.flags & F_PREFIX_REX) &&
                    (hs.flags & F_MODRM) &&
                    (hs.opcode == 0x8B))
                {
                    ptrCode = (PBYTE)RtlOffsetToPointer(ptrCode, i + hs.len);
                    bFound = TRUE;
                    break;
                }

                i += hs.len;

            } while (i < 128);

        }

        offsets[W32CALL_APISETTABLE_OFFSET] = 0;
        offsets[W32CALL_HOST_OFFSET] = 0;
        offsets[W32CALL_HOST_ENTRY_OFFSET] = 0;

        //
        // If offsets block has been found, extract offsets.
        //
        if (bFound) {

            offsetIndex = 0;
            i = 0;

            do {

                hde64_disasm(RtlOffsetToPointer(ptrCode, i), &hs);
                if (hs.flags & F_ERROR) {
                    resultStatus = STATUS_INTERNAL_ERROR;
                    break;
                }

                if ((hs.flags & F_PREFIX_REX) &&
                    (hs.flags & F_MODRM) &&
                    (hs.opcode == 0x8B))
                {
                    //
                    // Capture offset
                    //
                    if (hs.flags & F_DISP8)
                        offsets[offsetIndex] = hs.disp.disp8;
                    else if (hs.flags & F_DISP16)
                        offsets[offsetIndex] = hs.disp.disp16;
                    else if (hs.flags & F_DISP32)
                        offsets[offsetIndex] = hs.disp.disp32;
                    else
                        offsets[offsetIndex] = 0;

                    offsetIndex += 1;
                    if (offsetIndex > W32CALL_MAX_OFFSET)
                        break;
                }

                i += hs.len;

            } while (i < 64);

        }

        hostOffset = offsets[W32CALL_HOST_OFFSET];
        hostEntryOffset = offsets[W32CALL_HOST_ENTRY_OFFSET];

        //
        // If offsets not found try extraction from win32k import.
        //
        if (hostOffset == 0) { //-V1051

            resultStatus = SdtResolveModuleFromImportThunk(
                Context,
                FunctionPtr,
                ModulesHead,
                ModuleEntry);

        }
        else {
            //
            // Offsets found and extracted, proceed with resolving.
            //
            if (Context->SessionId == 0 || Context->SessionId > 0xFFFF) {
                resultStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            resultStatus = STATUS_PROCEDURE_NOT_FOUND;

            //
            // Read slot.
            //
            if (g_NtBuildNumber <= NT_WIN11_24H2)
            {
                slotAddress = (ULONG_PTR)RtlOffsetToPointer(Context->W32Globals.v1.gSessionGlobalSlots,
                    (Context->SessionId - 1) * sizeof(ULONG_PTR));
            }
            else {
                slotAddress = (ULONG_PTR)RtlOffsetToPointer(Context->W32Globals.v2.gSessionGlobalSlots,
                    (Context->SessionId - 1) * sizeof(ULONG_PTR));
            }

            if (!kdReadSystemMemory(slotAddress, &tableAddress, sizeof(ULONG_PTR)))
                break;

            //
            // Read table base.
            //
            tableAddress = tableAddress + Context->Win32kApiSetTableOffset;
            if (!kdReadSystemMemory(tableAddress, &hostAddress, sizeof(ULONG_PTR)))
                break;

            //
            // Read host base.
            //
            hostAddress += hostOffset;
            if (!kdReadSystemMemory(hostAddress, &hostEntry, sizeof(ULONG_PTR)))
                break;

            if (hostEntry == 0) {
                resultStatus = STATUS_APISET_NOT_HOSTED;
                break;
            }

            //
            // Read host entry.
            //
            routineAddress = hostEntry + hostEntryOffset;
            if (!kdReadSystemMemory(routineAddress, &routineAddress, sizeof(ULONG_PTR)))
                break;

            if (routineAddress == 0) {
                resultStatus = STATUS_APISET_NOT_PRESENT;
                break;
            }

            pModule = (PRTL_PROCESS_MODULE_INFORMATION)ntsupGetModuleEntryByAddress(Modules, (PVOID)routineAddress);
            if (pModule && pModule->OffsetToFileName < sizeof(pModule->FullPathName)) {

                pStr = (PCHAR)&pModule->FullPathName[pModule->OffsetToFileName];

                if (RtlCreateUnicodeStringFromAsciiz(&usModuleName, pStr)) {
                    resultStatus = SdtLoadAndRememberModule(ModulesHead, &usModuleName, ModuleEntry, TRUE);
                    if (NT_SUCCESS(resultStatus)) {

                        resultStatus = SdtResolveFunctionNameFromModuleExport(ModuleEntry->ImageBase,
                            (ULONG_PTR)pModule->ImageBase,
                            routineAddress,
                            &ServiceName->ExportName,
                            &ServiceName->ExportOrdinal);

                    }
                    else {
                        RtlFreeUnicodeString(&usModuleName);
                    }
                }
                else {
                    resultStatus = STATUS_INTERNAL_ERROR;
                }
            }
            else {
                resultStatus = STATUS_INTERNAL_ERROR;
            }

        }

    } while (FALSE);

    return resultStatus;
}

/*
* SdtWin32kInitializeOnce
*
* Purpose:
*
* Initialize service table lookup variables and data.
*
*/
ULONG SdtWin32kInitializeOnce(
    _In_ PRTL_PROCESS_MODULES pModules,
    _Inout_ PSDT_CONTEXT Context
)
{
    BOOLEAN bNeedApiSetResolve = (g_NtBuildNumber > 18885);
    BOOLEAN bWin32kApiSetTableExpected = (g_NtBuildNumber > 18935);
    ULONG ulResult = 0, schemaVersion;
    ULONG_PTR varAddress;
    PULONG pKernelLimit;
    PRTL_PROCESS_MODULE_INFORMATION pModule;
    HANDLE heapHandle;
    HMODULE hModule;
    SYMCONTEXT* symContext = NULL;
    RESOLVE_INFO resolveInfo;
    WCHAR szModuleFileName[MAX_PATH * 2];

    do {

        if (Context->Initialized)
            return 0;

        Context->ApiSetSessionAware = (g_NtBuildNumber > NT_WIN11_23H2);

        //
        // Find win32k loaded image base and size.
        //
        pModule = (PRTL_PROCESS_MODULE_INFORMATION)ntsupFindModuleEntryByName_U(
            pModules,
            WIN32K_FILENAME);

        if (pModule == NULL) {
            ulResult = ErrShadowWin32kNotFound;
            break;
        }

        Context->KernelBaseAddress = (ULONG_PTR)pModule->ImageBase;
        Context->KernelImageSize = pModule->ImageSize;

        //
        // Query win32u for exports dump.
        //
        hModule = GetModuleHandle(WIN32U_FILENAME);
        if (hModule == NULL) {
            ulResult = ErrShadowWin32uLoadFail;
            break;
        }

        Context->UserModule = hModule;

        //
        // Prepare dedicated heap for exports enumeration.
        //
        heapHandle = supCreateHeap(HEAP_GROWABLE, TRUE);
        if (heapHandle == NULL) {
            ulResult = ErrShadowMemAllocFail;
            break;
        }

        Context->ExportsEnumHeap = heapHandle;

        //
        // Dump syscall exports.
        //
        Context->UserLimit = NtRawEnumSyscallExports(
            heapHandle,
            hModule,
            &Context->UserTable);

        //
        // Load win32k image and load symbols if possible.
        //
        RtlStringCchPrintfSecure(szModuleFileName,
            RTL_NUMBER_OF(szModuleFileName),
            L"%ws\\%ws",
            g_WinObj.szSystemDirectory, WIN32K_FILENAME);

        hModule = LoadLibraryEx(szModuleFileName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL) {
            ulResult = ErrShadowWin32kLoadFail;
            break;
        }
        Context->KernelModule = hModule;

        //
        // Check whatever win32u is compatible with win32k data, compare number of services.
        //
        pKernelLimit = (PULONG)GetProcAddress(hModule, "W32pServiceLimit");
        if (pKernelLimit == NULL) {
            ulResult = ErrShadowW32pServiceLimitNotFound;
            break;
        }
        if (*pKernelLimit != Context->UserLimit) {
            ulResult = ErrShadowWin32uMismatch;
            break;
        }
        Context->KernelLimit = *pKernelLimit;

        //
        // Query win32k!W32pServiceTable, calculate it kernel address.
        //
        RtlSecureZeroMemory(&resolveInfo, sizeof(RESOLVE_INFO));
        if (!NT_SUCCESS(NtRawGetProcAddress(Context->KernelModule, "W32pServiceTable", &resolveInfo))) {
            ulResult = ErrShadowW32pServiceTableNotFound;
            break;
        }

        Context->W32pServiceTableUserBase = (PULONG)resolveInfo.Function;

        Context->W32pServiceTableKernelBase =
            Context->KernelBaseAddress + (ULONG_PTR)resolveInfo.Function - (ULONG_PTR)Context->KernelModule;

        //
        // Find Win32kApiSetTable where needed.
        //
        if (bWin32kApiSetTableExpected) {

            logAdd(EntryTypeInformation, TEXT("Win32kApiSetTable parsing expected"));

            //
            // Query ApiSetMap
            //
            if (bNeedApiSetResolve) {

                schemaVersion = *(ULONG*)NtCurrentPeb()->ApiSetMap;

                //
                // Windows 10+ uses modern ApiSetSchema version, everything else not supported.
                //
                if (schemaVersion != API_SET_SCHEMA_VERSION_V6) {
                    ulResult = ErrShadowApiSetSchemaVerUnknown;
                    break;
                }
            }

            //
            // Create symbol parser context, failure insignificant.
            //
            symContext = SymParserCreate();

            //
            // Load symbols for win32k.sys
            //
            if (symContext)
                supLoadSymbolsForNtImage(symContext, szModuleFileName, hModule, 0);

            //
            // This is win11 next layout.
            //
            if (Context->ApiSetSessionAware) {

                logAdd(EntryTypeInformation, TEXT("Session aware ApiSet parsing expected"));


                Context->W32GetSessionStatePtr = (ULONG_PTR)GetProcAddress(hModule, "W32GetSessionState");
                if (Context->W32GetSessionStatePtr == 0) {
                    ulResult = ErrShadowWin32kGetStateNotFound;
                    break;
                }

                //
                // Read globals.
                //
                varAddress = SdtpQueryWin32kSessionGlobals(hModule,
                    pModule->ImageBase,
                    pModule->ImageSize,
                    symContext);

                if (varAddress == 0) {
                    ulResult = ErrShadowWin32kGlobalsNotFound;
                    break;
                }

                if (g_NtBuildNumber <= NT_WIN11_24H2) {
                    //
                    // gLowSessionGlobalSlots is before any other variables, read as-is
                    //
                    if (!kdReadSystemMemory(varAddress, &Context->W32Globals.v1, sizeof(W32K_GLOBALS))) {
                        ulResult = ErrShadowWin32kGlobalsNotFound;
                        break;
                    }
                }
                else if (g_NtBuildNumber <= NT_WIN11_25H2) {
                    //
                    // gLowSessionGlobalSlots is in the middle of variables, use offset calculation
                    //
                    varAddress -= FIELD_OFFSET(W32K_GLOBALS_V2, gLowSessionGlobalSlots);
                    if (!kdReadSystemMemory(varAddress, &Context->W32Globals.v2, sizeof(W32K_GLOBALS_V2))) {
                        ulResult = ErrShadowWin32kGlobalsNotFound;
                        break;
                    }
                }
                else {
                    //
                    // Unknown case, need investigation and update.
                    //
                    ulResult = ErrShadowWin32kGlobalsNotFound;
                    break;
                }

                //
                // Remember table offset.
                //
                Context->Win32kApiSetTableOffset = SdtpQueryW32GetWin32kApiSetTableOffset(Context->KernelModule);
                if (Context->Win32kApiSetTableOffset == 0) {
                    ulResult = ErrShadowWin32kOffsetNotFound;
                    break;
                }

                Context->SessionId = NtCurrentPeb()->SessionId;

            }
            else {
                //
                // This is old win32k layout.
                // Locate Win32kApiSetTable variable. Failure will result in unresolved apiset adapters.
                //
                Context->Win32kApiSetTable = SdtpQueryWin32kApiSetTable(Context->KernelModule,
                    (PVOID)Context->KernelBaseAddress,
                    Context->KernelImageSize,
                    symContext);

                //
                // This is non critical error.
                //
                if (Context->Win32kApiSetTable == 0) {
                    ulResult = ErrShadowApiSetNotFound;
                }

                if (symContext) {
                    symContext->Parser.UnloadModule(symContext);
                    symContext = NULL;
                }
            }
        }

    } while (FALSE);

    //
    // Cleanup.
    //
    if (symContext) {
        symContext->Parser.UnloadModule(symContext);
        SymParserDestroy(symContext);
    }

    if (ulResult == 0) {

        Context->Initialized = TRUE;

    }
    else {

        if (ulResult != ErrShadowApiSetNotFound) {


            if (Context->KernelModule)
                FreeLibrary(Context->KernelModule);

            if (Context->ExportsEnumHeap)
                supDestroyHeap(Context->ExportsEnumHeap);

            Context->KernelModule = NULL;
            Context->ExportsEnumHeap = NULL;
        }

    }

    return ulResult;
}

/*
* SdtWin32kUninitialize
*
* Purpose:
*
* Cleanup Win32k query context.
*
*/
VOID SdtWin32kUninitialize(
    _In_ PSDT_CONTEXT Context)
{
    if (Context->KernelModule)
        FreeLibrary(Context->KernelModule);

    if (Context->ExportsEnumHeap)
        supDestroyHeap(Context->ExportsEnumHeap);

    RtlSecureZeroMemory(Context, sizeof(SDT_CONTEXT));
}

/*
* SdtLoadAndRememberModule
*
* Purpose:
*
* Remember loaded module to the internal list.
*
*/
NTSTATUS SdtLoadAndRememberModule(
    _In_ PSDT_MODULE_ENTRY Head,
    _In_ PUNICODE_STRING ModuleName,
    _Inout_ PSDT_MODULE_ENTRY Entry,
    _In_ BOOL ModuleNameAllocated
)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HMODULE dllModule;
    PSDT_MODULE_ENTRY nextEntry, mEntry;
    ULONG hashValue;
    ULONG dllChars = IMAGE_FILE_EXECUTABLE_IMAGE; //DONT_RESOLVE_DLL_REFERENCES

    RtlHashUnicodeString(ModuleName, TRUE, HASH_STRING_ALGORITHM_X65599, &hashValue);

    nextEntry = Head->Next;
    while (nextEntry != NULL) {

        mEntry = nextEntry;
        if (mEntry->Hash == hashValue) {
            *Entry = *mEntry;

            //
            // Free duplicate and return success.
            //
            if (ModuleNameAllocated)
                RtlFreeUnicodeString(ModuleName);

            return STATUS_SUCCESS;
        }

        nextEntry = nextEntry->Next;
    }

    mEntry = (PSDT_MODULE_ENTRY)supHeapAlloc(sizeof(SDT_MODULE_ENTRY));

    if (mEntry) {
        ntStatus = LdrLoadDll(NULL, &dllChars, ModuleName, (PVOID*)&dllModule);
        if (NT_SUCCESS(ntStatus)) {
            mEntry->Next = Head->Next;
            mEntry->Hash = hashValue;
            mEntry->ImageBase = dllModule;

            if (ModuleNameAllocated) {
                //
                // Module name memory already allocated.
                //
                mEntry->Name = *ModuleName;
            }
            else {
                //
                // Module name is local, duplicate.
                //
                if (!supDuplicateUnicodeString(NtCurrentPeb()->ProcessHeap, &mEntry->Name, ModuleName)) {
                    LdrUnloadDll((PVOID)dllModule);
                    supHeapFree(mEntry);
                    return STATUS_NO_MEMORY;
                }
            }

            Head->Next = mEntry;
            *Entry = *mEntry;
        }
        else {
#ifdef _DEBUG
            DbgBreakPoint();
#endif
            supHeapFree(mEntry);
            mEntry = NULL;
        }
    }

    return ntStatus;
}

/*
* SdtUnloadRememberedModules
*
* Purpose:
*
* Unload all remembered modules.
*
*/
VOID SdtUnloadRememberedModules(
    _In_ PSDT_MODULE_ENTRY Head
)
{
    PSDT_MODULE_ENTRY nextEntry, mEntry;

    nextEntry = Head->Next;
    while (nextEntry != NULL) {
        mEntry = nextEntry;
        nextEntry = nextEntry->Next;
        LdrUnloadDll((PVOID)mEntry->ImageBase);
        RtlFreeUnicodeString(&mEntry->Name);
        supHeapFree(mEntry);
    }

}

```

`Source/WinObjEx64/sup/w32k.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023 - 2025
*
*  TITLE:       W32K.H
*
*  VERSION:     2.10
*
*  DATE:        03 Oct 2025
*
*  Common header file for the win32k support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define WIN32K_FILENAME     L"win32k.sys"       // base kernel module
#define WIN32U_FILENAME     L"win32u.dll"       // base user module

//
// It is overcomplicated since we have to support multiple variants of what
// MS did to win32k shadow table handling since REDSTONE1.
// 
// 1. Win32k table data change (X2)
// 2. Win32k table entries forwarding
// 3. Win32k ApiSetTable
// 4. Win32k ApiSetTable improvement
// 5. Win32k session aware ApiSets
// 6. Win32kSgd merge into win32k.sys
//

//
// The following structure only valid for deprecated win32ksgd.
//
typedef struct _SGD_GLOBALS {
    PVOID gSessionGlobalSlots;     //pointer to list
    PVOID gpSESSIONSLOTS;          //pointer to list
    LIST_ENTRY gSessionSlotsList;  //gpSESSIONSLOTS is the head
    struct {
        ULONG LowCount;
        ULONG HighCount;
        ULONGLONG TotalCount;
    } gSessionApiSetHostRefCount;
    PVOID gSessionApiSetHostRefCountLock;
    PVOID gLowSessionGlobalSlots;  //pointer to list
    ULONG gAvailableSlots;
} SGD_GLOBALS, *PSGD_GLOBALS;

// Used by 24H2
typedef struct _W32K_GLOBALS {
    PVOID gLowSessionGlobalSlots;  //pointer to list
    ULONG gAvailableSlots;
    ULONG Reserved0;
    PVOID gSessionGlobalSlots;     //pointer to list
    PVOID gpSESSIONSLOTS;          //pointer to list
    LIST_ENTRY gSessionSlotsList;  //gpSESSIONSLOTS is the head
    struct {
        ULONG LowCount;
        ULONG HighCount;
        ULONGLONG TotalCount;
    } gSessionApiSetHostRefCount;
    PVOID gSessionApiSetHostRefCountLock;
    PVOID gSessionProcessLifetimeLock; //W32_PUSH_LOCK
    PVOID gLock; //W32_PUSH_LOCK
} W32K_GLOBALS, *PW32K_GLOBALS;

// Used by 25H2
typedef struct _W32K_GLOBALS_V2 {
    PVOID gSessionGlobalSlots;     //pointer to list
    PVOID gpSESSIONSLOTS;          //pointer to list
    LIST_ENTRY gSessionSlotsList;  //gpSESSIONSLOTS is the head
    struct {
        ULONG LowCount;
        ULONG HighCount;
        ULONGLONG TotalCount;
    } gSessionApiSetHostRefCount;
    PVOID gSessionApiSetHostRefCountLock;
    PVOID gLowSessionGlobalSlots;  //pointer to list
    ULONG gAvailableSlots;
    PVOID gSessionProcessLifetimeLock; //W32_PUSH_LOCK
    PVOID gLock; //W32_PUSH_LOCK
} W32K_GLOBALS_V2, * PWIN32K_GLOBALS_V2;

//
//  ApiSet layout 24H2
//
//  WIN32K!gSessionGlobalSlots:
//
//  +------+
//  | Slot |
//  +------+------+------------+
//  |  0   |  ... |  MaxSlot   |
//  +------+------+------------+
//
//  where
//
//      MaxSlot - is the maximum allocated slot
//
//  slot selection scheme 
//
//      Current process SessionId - 1, i.e. 0 for SessionId 1
// 
// Each slot is a pointer to tagWIN32KSESSIONSTATE opaque structure which
// holds multiple global variables for given session, 
// including Win32kApiSetTable pointer (at +0x88 for 26212 24H2).
// 
// If current session id is zero then apiset will be resolved from 
// WIN32K!gLowSessionGlobalSlots instead.
// 
// Win32kApiSetTable layout is the same as pre Win11.
// 
// Array of host entries each contains another array of apiset table entries.
//
//   See W32K_API_SET_TABLE_ENTRY_V2. 
// 
// The difference between current implementation and what was in win10 pre 24H2
// is that ApiSet data moved to the kernel memory and apisets are now session aware
// which now allows them:
//   1. Further services (session 0) isolation to reduce possible attack surfaces.
//   2. Stop leaking kernel addresses through manual resolve in user mode.
//
// To walk 24H2 table you have to find the following offsets in the kernel table 
// for given entry inside win32k:
// 
//      1. Offset to ApiSet host structure pointer
//      2. Offset in the ApiSet host enties array
//
// Globally you must also find offset to apiset table pointer in tagWIN32KSESSIONSTATE 
// as it can be subject of change.
// 
//

typedef struct _SDT_CONTEXT {
    BOOL Initialized;
    BOOL ApiSetSessionAware;

    ULONG_PTR KernelBaseAddress;            //win32k.sys kernel image base address
    ULONG_PTR KernelImageSize;              //win32k.sys kernel image size

    HANDLE ExportsEnumHeap;                 //heap handle for enum

    HMODULE UserModule;                     //win32u.dll hmodule
    HMODULE KernelModule;                   //win32k.sys hmodule

    PRAW_SYSCALL_ENTRY UserTable;           //win32u syscalls exports dump
    ULONG UserLimit;                        //win32u syscalls count
    ULONG KernelLimit;                      //win32k syscalls count

    ULONG SessionId;                        //current session id
    ULONG Win32kApiSetTableOffset;          //SGD offset to Win32kApiSetTable

    ULONG_PTR Win32kApiSetTable;            //Win32kApiSetTable user address for pre-24H2
    ULONG_PTR W32GetSessionStatePtr;        //Function pointer

    ULONG_PTR W32pServiceTableKernelBase;   //W32pServiceTable calculated kernel address
    PULONG W32pServiceTableUserBase;        //W32pServiceTable user address
    union {
        W32K_GLOBALS v1;                
        W32K_GLOBALS_V2 v2;
    } W32Globals;                           //win32k.sys global variables
} SDT_CONTEXT, * PSDT_CONTEXT;

typedef struct _SDT_FUNCTION_NAME {
    LPCSTR ServiceName;
    LPCSTR ExportName;
    USHORT ExportOrdinal;
} SDT_FUNCTION_NAME, * PSDT_FUNCTION_NAME;

typedef struct _SDT_MODULE_ENTRY {
    struct _SDT_MODULE_ENTRY* Next;
    DWORD Hash;
    HMODULE ImageBase;
    UNICODE_STRING Name;
} SDT_MODULE_ENTRY, * PSDT_MODULE_ENTRY;

NTSTATUS SdtResolveServiceEntryModule(
    _In_ PSDT_CONTEXT Context,
    _In_ PBYTE FunctionPtr,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry);

NTSTATUS SdtResolveServiceEntryModuleSessionAware(
    _In_ PSDT_CONTEXT Context,
    _In_ PBYTE FunctionPtr,
    _In_ PRTL_PROCESS_MODULES Modules,
    _Inout_ PSDT_FUNCTION_NAME ServiceName,
    _In_ PSDT_MODULE_ENTRY ModulesHead,
    _Inout_ PSDT_MODULE_ENTRY ModuleEntry);

ULONG SdtWin32kInitializeOnce(
    _In_ PRTL_PROCESS_MODULES pModules,
    _Inout_ PSDT_CONTEXT Context);

VOID SdtWin32kUninitialize(
    _In_ PSDT_CONTEXT Context);

NTSTATUS SdtLoadAndRememberModule(
    _In_ PSDT_MODULE_ENTRY Head,
    _In_ PUNICODE_STRING ModuleName,
    _Inout_ PSDT_MODULE_ENTRY Entry,
    _In_ BOOL ModuleNameAllocated);

VOID SdtUnloadRememberedModules(
    _In_ PSDT_MODULE_ENTRY Head);

```

`Source/WinObjEx64/sup/wine.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2019 - 2025
*
*  TITLE:       WINE.C
*
*  VERSION:     2.09
*
*  DATE:        13 Aug 2025
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "ntos/ntldr.h"

#define _WINE_DEBUG_MODE
#undef _WINE_DEBUG_MODE

typedef char* (__cdecl* pwine_get_version)(void);

/*
* GetWineVersion
*
* Purpose:
*
* Query Wine version.
*
* N.B. This function bypasses current WineStaging hide exports hack.
*
*/
#ifndef _WINE_DEBUG_MODE
PCHAR GetWineVersion(
    VOID
)
{
    pwine_get_version pfn = NULL;
    HMODULE hmod;
    RESOLVE_INFO rfn;

    hmod = GetModuleHandle(TEXT("ntdll.dll"));
    if (hmod) {

        rfn.ForwarderName = NULL;
        rfn.Function = NULL;
        rfn.ResultType = FunctionCode;

        if (NT_SUCCESS(NtRawGetProcAddress(
            (LPVOID)hmod,
            "wine_get_version",
            &rfn)))
        {
            if (rfn.ResultType == FunctionCode)
                pfn = (pwine_get_version)rfn.Function;
        }

        if (pfn)
            return pfn();
    }
    return NULL;
}
#else
PCHAR GetWineVersion(
    VOID
)
{
    return "10.0";
}
#endif


/*
* IsWine
*
* Purpose:
*
* Query if there is a Wine layer enabled.
*
*/
BOOLEAN IsWine(
    VOID
)
{
    PCHAR lpWine;

    lpWine = GetWineVersion();

    return (lpWine != NULL);
}

```

`Source/WinObjEx64/sup/wine.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2022
*
*  TITLE:       WINE.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Wine/Wine staging support header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

PCHAR GetWineVersion(VOID);
BOOLEAN IsWine(VOID);

```

`Source/WinObjEx64/symparser.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT H.E., 2015 - 2025
*
*  TITLE:       SYMPARSER.C
*
*  VERSION:     1.25
*
*  DATE:        13 Jun 2025
*
*  DbgHelp wrapper for symbols parser support.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*++

 SymGlobalsInit
 +------------------------------------+
 C1 = SymParserCreate()
 C1->LoadModule(A)
 C2 = SymParserCreate()
 C2->LoadModule(B)
 ...
 C2->UnloadModule(B)
 C1->UnloadModule(A)
 ...
 SymParserDestroy(C2);
 SymParserDestroy(C1);
 ...
 +------------------------------------+
 SymGlobalsFree

--*/

#define DEFAULT_SYMPATH     L"Symbols*https://msdl.microsoft.com/download/symbols"
#define DEFAULT_DLL         L"DbgHelp.dll"

typedef struct _SYMGLOBALS {
    BOOL Initialized;
    ULONG Options;
    HANDLE ProcessHandle;
    HMODULE DllHandle;
    DBGHELP_PTRS ApiSet;
    WCHAR szSymbolsPath[MAX_PATH * 2];
} SYMGLOBALS, * PSYMGLOBALS;

static SYMGLOBALS g_SymGlobals;

typedef struct _BasicTypeMapElement {
    SymBasicType BasicType;
    ULONG Length;
    PCWSTR TypeName;
} BasicTypeMapElement, * PBasicTypeMapElement;

// from wbenny's pdbex
static const BasicTypeMapElement BasicTypeMapMSVC[] = {
    { btNoType,     0,      NULL                        },
    { btVoid,       0,      TEXT("void")                },
    { btChar,       1,      TEXT("char")                },
    { btChar8,      1,      TEXT("char8_t")             },
    { btChar16,     2,      TEXT("char16_t")            },
    { btChar32,     4,      TEXT("char32_t")            },
    { btWChar,      2,      TEXT("wchar_t")             },
    { btInt,        1,      TEXT("char")                },
    { btInt,        2,      TEXT("short")               },
    { btInt,        4,      TEXT("int")                 },
    { btInt,        8,      TEXT("__int64")             },
    { btInt,        16,     TEXT("__m128")              }, //SIMD
    { btUInt,       1,      TEXT("unsigned char")       },
    { btUInt,       2,      TEXT("unsigned short")      },
    { btUInt,       4,      TEXT("unsigned int")        },
    { btUInt,       8,      TEXT("unsigned __int64")    },
    { btUInt,       16,     TEXT("__m128")              }, //SIMD
    { btFloat,      4,      TEXT("float")               },
    { btFloat,      8,      TEXT("double")              },
    { btFloat,      10,     TEXT("long double")         },
    { btBCD,        0,      TEXT("BCD")                 },
    { btBool,       0,      TEXT("BOOL")                },
    { btLong,       4,      TEXT("long")                },
    { btULong,      4,      TEXT("unsigned long")       },
    { btCurrency,   0,      NULL                        },
    { btDate,       0,      TEXT("DATE")                },
    { btVariant,    0,      TEXT("VARIANT")             },
    { btComplex,    0,      NULL                        },
    { btBit,        0,      NULL                        },
    { btBSTR,       0,      TEXT("BSTR")                },
    { btHresult,    4,      TEXT("HRESULT")             },
    { btMaxType,    0,      NULL                        }
};

/**
* Find the basic type name string from the type map
*
* @param TypeMap - Type mapping table
* @param BasicType - Basic type to look up
* @param Length - Type size in bytes
* @return Type name string or NULL if not found
*/
PCWSTR SympGetBasicTypeNameString(
    _In_ const BasicTypeMapElement* TypeMap,
    _In_ SymBasicType BasicType,
    _In_ ULONG Length
)
{
    ULONG i;
    for (i = 0; TypeMap[i].BasicType != btMaxType; i++) {
        if (TypeMap[i].BasicType == BasicType) {
            if (TypeMap[i].Length == Length || TypeMap[i].Length == 0) {
                return TypeMap[i].TypeName;
            }
        }
    }
    return NULL;
}

/**
* Get type name string for a basic type
*
* @param BasicType - Basic type to look up
* @param Length - Type size in bytes
* @return Type name string or NULL if not found
*/
PCWSTR SympGetTypeNameString(
    _In_ SymBasicType BasicType,
    _In_ ULONG Length
)
{
    return SympGetBasicTypeNameString(
        BasicTypeMapMSVC,
        BasicType,
        Length);
}

/**
* Register callback for symbol operations
*
* @param Context - Symbol context
* @param CallbackFunction - Callback function pointer
* @param UserContext - User context to pass to callback
* @return TRUE on success, FALSE on failure
*/
BOOL SymParserRegisterCallback(
    _In_ PSYMCONTEXT Context,
    _In_ PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    _In_ ULONG64 UserContext
)
{
    if (!Context || !CallbackFunction)
        return FALSE;

    return Context->DbgHelp.SymRegisterCallbackW64(
        Context->ProcessHandle,
        CallbackFunction,
        UserContext);
}

/**
* Load module for symbol parsing
*
* @param Context - Symbol context
* @param lpModulePath - Module path
* @param BaseOfDll - Base address of module
* @param SizeOfDll - Size of module
* @return TRUE on success, FALSE on failure
*/
BOOL SymParserLoadModule(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR lpModulePath,
    _In_ DWORD64 BaseOfDll,
    _In_ DWORD SizeOfDll
)
{
    DWORD64 moduleBase;

    if (!Context || !lpModulePath)
        return FALSE;

    moduleBase = Context->DbgHelp.SymLoadModuleEx(
        Context->ProcessHandle,
        NULL,
        lpModulePath,
        NULL,
        BaseOfDll,
        SizeOfDll,
        NULL,
        0);

    Context->SymLastError = GetLastError();
    Context->ModuleBase = moduleBase;

    return (moduleBase != 0);
}

/**
* Unload module from symbol context
*
* @param Context - Symbol context
* @return TRUE on success, FALSE on failure
*/
BOOL SymParserUnloadModule(
    _In_ PSYMCONTEXT Context
)
{
    BOOL bStatus;

    if (!Context || Context->ModuleBase == 0)
        return FALSE;

    bStatus = Context->DbgHelp.SymUnloadModule(
        Context->ProcessHandle,
        Context->ModuleBase);

    Context->SymLastError = GetLastError();

    if (bStatus)
        Context->ModuleBase = 0;

    return bStatus;
}

/**
 * Template function for safely retrieving type information
 *
 * @param Context - Symbol context
 * @param TypeIndex - Type index
 * @param GetType - Type of information to retrieve
 * @param OutputValue - Pointer to output value
 * @param Status - Optional output for status
 * @return TRUE if successful, FALSE otherwise
 */
BOOL SympGetTypeInfo(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _In_ IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    _When_(return, _Post_valid_) _Pre_defensive_ PVOID OutputValue,
    _Out_opt_ PBOOL Status
)
{
    BOOL bSuccess = FALSE;

    // Parameter validation
    if (!Context || !OutputValue) {
        if (Status) *Status = FALSE;
        return FALSE;
    }

    // Check if module is loaded
    if (Context->ModuleBase == 0) {
        Context->SymLastError = ERROR_NOT_READY;
        if (Status) *Status = FALSE;
        return FALSE;
    }

    // Check if we have valid function pointer
    if (!Context->DbgHelp.SymGetTypeInfo) {
        Context->SymLastError = ERROR_INVALID_FUNCTION;
        if (Status) *Status = FALSE;
        return FALSE;
    }

    bSuccess = Context->DbgHelp.SymGetTypeInfo(
        Context->ProcessHandle,
        Context->ModuleBase,
        TypeIndex,
        GetType,
        OutputValue);

    Context->SymLastError = GetLastError();

    if (Status)
        *Status = bSuccess;

    return bSuccess;
}


/**
* Get symbol type
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol type
*/
SymBasicType SymParserGetType(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    SymBasicType symType = btNoType;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_TYPE, &symType, Status);

    if (!bSuccess)
        return btNoType;

    return symType;
}

/**
* Get symbol base type
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol base type
*/
SymBasicType SymParserGetBaseType(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    SymBasicType symBaseType = btNoType;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_BASETYPE, &symBaseType, Status);

    if (!bSuccess)
        return btNoType;

    return symBaseType;
}

/**
* Get symbol type ID
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol type ID
*/
ULONG SymParserGetTypeId(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG typeId = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_TYPEID, &typeId, Status);

    if (!bSuccess)
        return 0;

    return typeId;
}

/**
* Get symbol array type ID
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol array type ID
*/
ULONG SymParserGetArrayTypeId(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG typeId = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_ARRAYINDEXTYPEID, &typeId, Status);

    if (!bSuccess)
        return 0;

    return typeId;
}

/**
* Get symbol size
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol size
*/
ULONG64 SymParserGetSize(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG64 symSize = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_LENGTH, &symSize, Status);

    if (!bSuccess)
        return 0;

    return symSize;
}

/**
* Get symbol offset
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol offset
*/
ULONG SymParserGetOffset(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG symOffset = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_OFFSET, &symOffset, Status);

    if (!bSuccess)
        return 0;

    return symOffset;
}

/**
* Get symbol address offset
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol address offset
*/
ULONG SymParserGetAddressOffset(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG symOffset = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_ADDRESSOFFSET, &symOffset, Status);

    if (!bSuccess)
        return 0;

    return symOffset;
}

/**
* Get symbol bit position
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol bit position
*/
ULONG SymParserGetBitPosition(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG bitPosition = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_BITPOSITION, &bitPosition, Status);

    if (!bSuccess)
        return 0;

    return bitPosition;
}

/**
* Get symbol children count
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol children count
*/
ULONG SymParserGetChildrenCount(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG childCount = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_CHILDRENCOUNT, &childCount, Status);

    if (!bSuccess)
        return 0;

    return childCount;
}

/**
* Get symbol tag
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol tag
*/
ULONG SymParserGetTag(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG symTag = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_SYMTAG, &symTag, Status);

    if (!bSuccess)
        return 0;

    return symTag;
}

/**
* Get symbol name
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Symbol name (must be freed with LocalFree)
*/
_Ret_maybenull_ _Post_writable_byte_size_(MAX_SYM_NAME * sizeof(WCHAR))
LPCWSTR SymParserGetName(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    LPCWSTR lpSymbolName = NULL;

    BOOL bStatus = Context->DbgHelp.SymGetTypeInfo(
        Context->ProcessHandle,
        Context->ModuleBase,
        TypeIndex,
        TI_GET_SYMNAME,
        (PVOID)&lpSymbolName);

    Context->SymLastError = GetLastError();

    if (Status)
        *Status = bStatus;

    return lpSymbolName;
}

/**
* Get symbol value
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Value - Output variant value
* @param Status - Optional status output
* @return Variant type
*/
VARTYPE SymParserGetValue(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Inout_ VARIANT * Value,
    _Out_opt_ PBOOL Status
)
{
    VARTYPE varResult;

    if (!Value) {
        if (Status) *Status = FALSE;
        return VT_EMPTY;
    }

    VariantInit(Value);

    BOOL bStatus = Context->DbgHelp.SymGetTypeInfo(
        Context->ProcessHandle,
        Context->ModuleBase,
        TypeIndex,
        TI_GET_VALUE,
        (PVOID)Value);

    varResult = Value->vt;
    Context->SymLastError = GetLastError();

    if (Status)
        *Status = bStatus;

    return varResult;
}

/**
* Get symbol UDT kind
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return UDT kind
*/
SymUdtKind SymParserGetUDTKind(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    SymUdtKind udtKind = UdtInvalid;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_UDTKIND, &udtKind, Status);

    if (!bSuccess)
        return UdtInvalid;

    return udtKind;
}

/**
* Get symbol count
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Count value
*/
ULONG SymParserGetCount(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG ulCount = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_COUNT, &ulCount, Status);

    if (!bSuccess)
        return 0;

    return ulCount;
}

/**
* Get symbol calling convention
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param Status - Optional status output
* @return Calling convention value
*/
ULONG SymParserGetCallingConvention(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status
)
{
    ULONG ulCallingConvention = 0;
    BOOL bSuccess = SympGetTypeInfo(Context, TypeIndex, TI_GET_CALLING_CONVENTION, &ulCallingConvention, Status);

    if (!bSuccess)
        return 0;

    return ulCallingConvention;
}

/**
* Get type name for a symbol
*
* @param Context - Symbol context
* @param TypeIndex - Type index
* @param BaseTypeSize - Optional output for base type size
* @param Status - Optional status output
* @return Type name string (must be freed with LocalFree)
*/
LPCWSTR SymParserGetTypeName(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PUINT64 BaseTypeSize,
    _Out_opt_ PBOOL Status
)
{
    BOOL bResult = FALSE;
    SymUdtKind udtKind;
    ULONG64 nextTypeSize = 0, symSize;
    LPWSTR lpStringCopy;
    LPCWSTR lpSymbolTypeName = NULL, lpTemp = NULL;
    SIZE_T nLen;
    ULONG tagEnum, symType;

    if (BaseTypeSize)
        *BaseTypeSize = 0;

    symSize = Context->Parser.GetSize(Context, TypeIndex, &bResult);
    if (!bResult) {
        if (Status) *Status = FALSE;
        return NULL;
    }

    if (BaseTypeSize)
        *BaseTypeSize = symSize;

    lpSymbolTypeName = Context->Parser.GetName(Context, TypeIndex, &bResult);
    if (lpSymbolTypeName) {
        if (Status) *Status = TRUE;
        return lpSymbolTypeName;
    }

    tagEnum = Context->Parser.GetTag(Context, TypeIndex, &bResult);
    if (!bResult) {
        if (Status) *Status = FALSE;
        return NULL;
    }

    switch (tagEnum) {

        //
        // User defined type.
        //
    case SymTagUDT:

        udtKind = Context->Parser.GetUDTKind(
            Context,
            TypeIndex,
            &bResult);

        if (bResult) {

            switch (udtKind) {
            case UdtClass:
            case UdtInterface:
            case UdtUnion:
                lpSymbolTypeName = Context->Parser.GetName(
                    Context,
                    TypeIndex,
                    &bResult);

                break;

            default:
                lpStringCopy = (LPWSTR)LocalAlloc(LPTR, MAX_SYM_NAME);
                if (lpStringCopy) {
                    _strcpy(lpStringCopy, TEXT("UnknownType"));
                    lpSymbolTypeName = lpStringCopy;
                    bResult = TRUE;
                }

                break;
            }

        }
        break;

        //
        // Type is a pointer, add * to end of the name.
        //
    case SymTagPointerType:

        symType = Context->Parser.GetTypeId(
            Context,
            TypeIndex,
            &bResult);

        if (bResult) {
            lpTemp = Context->Parser.GetTypeName(
                Context,
                symType,
                &nextTypeSize,
                &bResult);

            if (bResult && lpTemp) {
                nLen = _strlen(lpTemp);
                lpStringCopy = (LPWSTR)LocalAlloc(LPTR, (nLen + 2) * sizeof(WCHAR));
                if (lpStringCopy) {
                    _strcpy(lpStringCopy, lpTemp);
                    _strcat(lpStringCopy, L"*");
                    lpSymbolTypeName = lpStringCopy;
                }
                LocalFree((HLOCAL)lpTemp);
            }
        }
        break;

    case SymTagBaseType:

        symType = Context->Parser.GetBaseType(
            Context,
            TypeIndex,
            &bResult);

        if (bResult) {

            //
            // Query basic type.
            // 
            // N.B. Basic type string is local variable make it copy to allocated buffer.
            //
            lpTemp = SympGetTypeNameString(
                (SymBasicType)symType,
                (ULONG)symSize);

            if (lpTemp) {
                nLen = _strlen(lpTemp);
                lpStringCopy = (LPWSTR)LocalAlloc(LPTR, (1 + nLen) * sizeof(WCHAR));
                if (lpStringCopy) {
                    _strcpy(lpStringCopy, lpTemp);
                    lpSymbolTypeName = lpStringCopy;
                }
            }

        }
        break;

    case SymTagArrayType:
    case SymTagTypedef:
    default:
        symType = Context->Parser.GetTypeId(
            Context,
            TypeIndex,
            &bResult);

        if (bResult) {

            lpSymbolTypeName = Context->Parser.GetTypeName(
                Context,
                symType,
                BaseTypeSize,
                &bResult);

        }
        break;
    }

    if (Status)
        *Status = bResult;

    return lpSymbolTypeName;
}

/**
* Look up a symbol address by name
*
* @param Context - Symbol context
* @param SymbolName - Symbol name to look up
* @param Status - Optional status output
* @return Symbol address or 0 on failure
*/
ULONG64 SymParserLookupAddressBySymbol(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR SymbolName,
    _Out_opt_ PBOOL Status
)
{
    BOOL bStatus = FALSE;
    ULONG64 symAddress = 0;
    PSYMBOL_INFO symbolInfo = NULL;

    if (!Context || !SymbolName) {
        if (Status) *Status = FALSE;
        return 0;
    }

    symbolInfo = (PSYMBOL_INFO)supHeapAlloc(sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(WCHAR));
    if (symbolInfo) {
        symbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
        symbolInfo->MaxNameLen = 0; //name is not used

        bStatus = Context->DbgHelp.SymFromName(
            Context->ProcessHandle,
            SymbolName,
            symbolInfo);

        Context->SymLastError = GetLastError();

        if (bStatus)
            symAddress = symbolInfo->Address;

        supHeapFree(symbolInfo);
    }

    if (Status)
        *Status = bStatus;

    return symAddress;
}

/**
* Look up a symbol name by address
*
* @param Context - Symbol context
* @param SymbolAddress - Address to look up
* @param Displacement - Output displacement
* @param SymbolName - Output symbol name pointer (must be freed with LocalFree)
* @param Status - Optional status output
* @return Length of symbol name
*/
ULONG SymParserLookupSymbolByAddress(
    _In_ PSYMCONTEXT Context,
    _In_ DWORD64 SymbolAddress,
    _In_ PDWORD64 Displacement,
    _Inout_ LPWSTR * SymbolName,
    _Out_opt_ PBOOL Status
)
{
    BOOL bStatus = FALSE;
    ULONG nameLength = 0;
    LPWSTR symName = NULL;
    PSYMBOL_INFO symbolInfo = NULL;

    if (!Context || !SymbolName || !Displacement) {
        if (Status) *Status = FALSE;
        return 0;
    }

    *SymbolName = NULL;

    symbolInfo = (PSYMBOL_INFO)supHeapAlloc(
        sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(WCHAR));
    if (symbolInfo) {
        symbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
        symbolInfo->MaxNameLen = MAX_SYM_NAME;

        bStatus = Context->DbgHelp.SymFromAddr(
            Context->ProcessHandle,
            SymbolAddress,
            Displacement,
            symbolInfo);

        Context->SymLastError = GetLastError();

        if (bStatus && symbolInfo->NameLen > 0) {
            symName = (LPWSTR)LocalAlloc(LPTR, MAX_SYM_NAME + 1);
            if (symName) {
                _strncpy(symName, MAX_SYM_NAME, symbolInfo->Name, symbolInfo->NameLen);
                nameLength = (ULONG)_strlen(symName);
                *SymbolName = symName;
            }
        }
        supHeapFree(symbolInfo);
    }

    if (Status)
        *Status = bStatus;

    return nameLength;
}

/**
* Get field offset from a structure
*
* @param Context - Symbol context
* @param SymbolName - Structure name
* @param FieldName - Field name
* @param Status - Optional status output
* @return Field offset or 0 on failure
*/
ULONG SymParserGetFieldOffset(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR SymbolName,
    _In_ LPCWSTR FieldName,
    _Out_opt_ PBOOL Status
)
{
    BOOL bStatus = FALSE;
    ULONG symOffset = 0, i;
    ULONG rootIndex = 0, childCount = 0, childIndex = 0;
    LPCWSTR lpSymbolName = NULL;
    PSYMBOL_INFO rootSymbolInfo = NULL;
    TI_FINDCHILDREN_PARAMS* childrenBuffer = NULL;

    if (!Context || !SymbolName || !FieldName) {
        if (Status) *Status = FALSE;
        return 0;
    }

    rootSymbolInfo = (PSYMBOL_INFO)supHeapAlloc(
        sizeof(SYMBOL_INFO) + (MAX_SYM_NAME * sizeof(WCHAR)));

    if (!rootSymbolInfo) {
        if (Status) *Status = FALSE;
        return 0;
    }

    rootSymbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
    rootSymbolInfo->MaxNameLen = MAX_SYM_NAME;

    bStatus = Context->DbgHelp.SymGetTypeFromName(
        Context->ProcessHandle,
        Context->ModuleBase,
        SymbolName,
        rootSymbolInfo);

    Context->SymLastError = GetLastError();

    if (!bStatus) {
        supHeapFree(rootSymbolInfo);
        if (Status) *Status = FALSE;
        return 0;
    }

    rootIndex = rootSymbolInfo->Index;
    childCount = Context->Parser.GetChildrenCount(
        Context,
        rootIndex,
        &bStatus);

    if (!bStatus || childCount == 0) {
        supHeapFree(rootSymbolInfo);
        if (Status) *Status = FALSE;
        return 0;
    }

    childrenBuffer = (TI_FINDCHILDREN_PARAMS*)supHeapAlloc(
        sizeof(TI_FINDCHILDREN_PARAMS) + childCount * sizeof(ULONG));

    if (!childrenBuffer) {
        supHeapFree(rootSymbolInfo);
        if (Status) *Status = FALSE;
        return 0;
    }

    childrenBuffer->Count = childCount;
    childrenBuffer->Start = 0;

    bStatus = Context->DbgHelp.SymGetTypeInfo(
        Context->ProcessHandle,
        Context->ModuleBase,
        rootIndex,
        TI_FINDCHILDREN,
        childrenBuffer);

    if (!bStatus) {
        supHeapFree(rootSymbolInfo);
        supHeapFree(childrenBuffer);
        if (Status) *Status = FALSE;
        return 0;
    }

    bStatus = FALSE;

    for (i = 0; i < childCount; i++) {
        childIndex = childrenBuffer->ChildId[i];
        lpSymbolName = Context->Parser.GetName(Context, childIndex, NULL);

        if (lpSymbolName) {
            bStatus = (_strcmpi(FieldName, lpSymbolName) == 0);

            if (bStatus) {
                symOffset = Context->Parser.GetOffset(Context, childIndex, NULL);
                LocalFree((HLOCAL)lpSymbolName);
                break;
            }

            LocalFree((HLOCAL)lpSymbolName);
        }
    }

    supHeapFree(rootSymbolInfo);
    supHeapFree(childrenBuffer);

    if (Status)
        *Status = bStatus;

    return symOffset;
}

/**
* Dump complete symbol information including all children
*
* @param Context - Symbol context
* @param SymbolName - Symbol name
* @param Status - Optional status output
* @return Symbol entry structure or NULL on failure (must be freed with supHeapFree)
*/
PSYM_ENTRY SymParserDumpSymbolInformation(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR SymbolName,
    _Out_opt_ PBOOL Status
)
{
    BOOL bStatus = FALSE;
    ULONG rootIndex, childCount, childIndex, typeId, i;
    ULONG cNameUnknown = 0, cTypeUnknown = 0;
    ULONG64 baseTypeSize;
    LPCWSTR lpSymbolName = NULL;
    PSYM_ENTRY dumpEntry = NULL;
    PSYM_CHILD dumpChild = NULL;
    PSYMBOL_INFO rootSymbolInfo = NULL;
    TI_FINDCHILDREN_PARAMS* childrenBuffer;
    TI_FINDCHILDREN_PARAMS* childEntry;
    VARIANT value;
    VARTYPE valueType;

    if (!Context || !SymbolName) {
        if (Status) *Status = FALSE;
        return NULL;
    }

    do {
        rootSymbolInfo = (PSYMBOL_INFO)supHeapAlloc(
            sizeof(SYMBOL_INFO) + (MAX_SYM_NAME * sizeof(WCHAR)));
        if (rootSymbolInfo == NULL)
            break;

        rootSymbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
        rootSymbolInfo->MaxNameLen = MAX_SYM_NAME;

        bStatus = Context->DbgHelp.SymGetTypeFromName(
            Context->ProcessHandle,
            Context->ModuleBase,
            SymbolName,
            rootSymbolInfo);

        if (!bStatus)
            break;

        rootIndex = rootSymbolInfo->Index;

        childCount = Context->Parser.GetChildrenCount(
            Context,
            rootIndex,
            &bStatus);

        if (!bStatus)
            break;

        //
        // Fill result.
        //
        dumpEntry = (PSYM_ENTRY)supHeapAlloc(sizeof(SYM_ENTRY) +
            (sizeof(SYM_CHILD) * childCount));

        if (dumpEntry == NULL)
            break;

        dumpEntry->Size = rootSymbolInfo->Size;
        dumpEntry->Offset = 0;

        _strncpy(dumpEntry->Name,
            RTL_NUMBER_OF(dumpEntry->Name),
            rootSymbolInfo->Name,
            rootSymbolInfo->NameLen);

        if (childCount == 0)
            break;

        childrenBuffer = (TI_FINDCHILDREN_PARAMS*)supHeapAlloc(
            sizeof(TI_FINDCHILDREN_PARAMS) + childCount * sizeof(ULONG));

        if (childrenBuffer) {

            childEntry = &childrenBuffer[0];
            childEntry->Count = childCount;

            bStatus = Context->DbgHelp.SymGetTypeInfo(
                Context->ProcessHandle,
                Context->ModuleBase,
                rootIndex,
                TI_FINDCHILDREN,
                childEntry);

            if (bStatus) {

                dumpEntry->ChildCount = childCount;

                if (childEntry->Start)
                    i = childEntry->Start;
                else
                    i = 0;

                for (; i < childCount; i++) {

                    dumpChild = &dumpEntry->ChildEntries[i];
                    childIndex = childEntry->ChildId[i];

                    typeId = Context->Parser.GetTypeId(Context, childIndex, NULL);

                    dumpChild->Size = Context->Parser.GetSize(
                        Context,
                        typeId,
                        NULL);

                    dumpChild->Offset = Context->Parser.GetOffset(
                        Context,
                        childIndex,
                        NULL);

                    dumpChild->BitPosition = Context->Parser.GetBitPosition(
                        Context,
                        childIndex,
                        &dumpChild->IsBitField);

                    VariantInit(&value);
                    valueType = Context->Parser.GetValue(
                        Context,
                        childIndex,
                        &value,
                        &dumpChild->IsValuePresent);

                    switch (valueType) {
                    case VT_I1:
                        dumpChild->Value = value.cVal;
                        break;
                    case VT_I2:
                        dumpChild->Value = value.iVal;
                        break;
                    case VT_I4:
                    case VT_INT:
                        dumpChild->Value = value.intVal;
                        break;
                    case VT_UINT:
                    case VT_UI4:
                        dumpChild->Value = value.uintVal;
                        break;
                    case VT_UI1:
                        dumpChild->Value = value.bVal;
                        break;
                    case VT_UI2:
                        dumpChild->Value = value.uiVal;
                        break;
                    case VT_UI8:
                        dumpChild->Value = value.ullVal;
                        break;
                    case VT_INT_PTR:
                        dumpChild->Value = (DWORD64)value.pintVal;
                        break;
                    case VT_UINT_PTR:
                        dumpChild->Value = (DWORD64)value.puintVal;
                        break;
                    default:
                        dumpChild->Value = value.ullVal;
                        break;
                    }

                    VariantClear(&value);

                    //
                    // Child name.
                    //
                    lpSymbolName = Context->Parser.GetName(Context, childIndex, NULL);
                    if (lpSymbolName) {
                        _strncpy(dumpChild->Name, MAX_SYM_NAME, lpSymbolName, _strlen(lpSymbolName));
                        LocalFree((HLOCAL)lpSymbolName);
                    }
                    else {
                        RtlStringCchPrintfSecure(dumpChild->Name,
                            MAX_SYM_NAME,
                            TEXT("Unknown%lu"),
                            cNameUnknown++);
                    }

                    //
                    // Child type name.
                    //
                    baseTypeSize = 0;
                    lpSymbolName = Context->Parser.GetTypeName(Context, typeId, &baseTypeSize, NULL);
                    if (lpSymbolName) {
                        _strncpy(dumpChild->TypeName, MAX_SYM_NAME, lpSymbolName, _strlen(lpSymbolName));

                        // Calculate number of elements based on size
                        if (baseTypeSize == 0) {
                            dumpChild->ElementsCount = 1;
                        }
                        else {
                            dumpChild->ElementsCount = dumpChild->Size / baseTypeSize;
                        }

                        LocalFree((HLOCAL)lpSymbolName);
                    }
                    else {
                        RtlStringCchPrintfSecure(dumpChild->TypeName,
                            RTL_NUMBER_OF(dumpChild->TypeName),
                            TEXT("UNKNOWN%lu"),
                            cTypeUnknown++);
                        dumpChild->ElementsCount = 1;
                    }

                }

            }

            supHeapFree(childrenBuffer);
        }


    } while (FALSE);

    if (!bStatus) {
        if (rootSymbolInfo) supHeapFree(rootSymbolInfo);
        if (dumpEntry) {
            supHeapFree(dumpEntry);
            dumpEntry = NULL;
        }
    }

    if (Status)
        *Status = bStatus;

    return dumpEntry;
}

/**
* Initialize function pointers from DbgHelp DLL
*
* @param hDbgHelp - Handle to DbgHelp DLL
* @param Ptrs - Output structure for function pointers
* @return TRUE on success, FALSE on failure
*/
BOOL SympInitPointers(
    _In_ HMODULE hDbgHelp,
    _Inout_ DBGHELP_PTRS * Ptrs
)
{
    UINT i;
    LPCSTR szFuncs[] = {
        "SymSetOptions",
        "SymInitializeW",
        "SymRegisterCallbackW64",
        "SymLoadModuleExW",
        "SymGetTypeInfo",
        "SymFromNameW",
        "SymFromAddrW",
        "SymGetTypeFromNameW",
        "SymUnloadModule64",
        "SymCleanup"
    };

    DWORD64 dwPtrs[sizeof(DBGHELP_PTRS) / sizeof(DWORD64)];

    if (!hDbgHelp || !Ptrs)
        return FALSE;

    RtlSecureZeroMemory(dwPtrs, sizeof(dwPtrs));

    for (i = 0; i < RTL_NUMBER_OF(szFuncs); i++) {
        dwPtrs[i] = (DWORD64)GetProcAddress(hDbgHelp, szFuncs[i]);
        if (dwPtrs[i] == 0) {
            return FALSE;
        }
    }

    RtlCopyMemory(Ptrs, dwPtrs, sizeof(DBGHELP_PTRS));
    return TRUE;
}

/**
* Create a symbol parser context
*
* @return Symbol context or NULL on failure (must be freed with SymParserDestroy)
*/
PSYMCONTEXT SymParserCreate(
    VOID
)
{
    PSYMCONTEXT Context;

    if (g_SymGlobals.Initialized == FALSE) {
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }

    Context = (PSYMCONTEXT)supHeapAlloc(sizeof(SYMCONTEXT));
    if (Context) {

        Context->DbgHelp = g_SymGlobals.ApiSet;
        Context->ProcessHandle = g_SymGlobals.ProcessHandle;
        Context->ModuleBase = 0;

        Context->Parser.GetChildrenCount = (SPGetChildrenCount)SymParserGetChildrenCount;
        Context->Parser.GetAddressOffset = (SPGetAddressOffset)SymParserGetAddressOffset;
        Context->Parser.GetArrayTypeId = (SPGetArrayTypeId)SymParserGetArrayTypeId;
        Context->Parser.GetBaseType = (SPGetBaseType)SymParserGetBaseType;
        Context->Parser.GetBitPosition = (SPGetBitPosition)SymParserGetBitPosition;
        Context->Parser.GetName = (SPGetName)SymParserGetName;
        Context->Parser.GetOffset = (SPGetOffset)SymParserGetOffset;
        Context->Parser.GetSize = (SPGetSize)SymParserGetSize;
        Context->Parser.GetTag = (SPGetTag)SymParserGetTag;
        Context->Parser.GetType = (SPGetType)SymParserGetType;
        Context->Parser.GetTypeId = (SPGetTypeId)SymParserGetTypeId;
        Context->Parser.GetTypeName = (SPGetTypeName)SymParserGetTypeName;
        Context->Parser.GetValue = (SPGetValue)SymParserGetValue;
        Context->Parser.GetCount = (SPGetCount)SymParserGetCount;
        Context->Parser.GetUDTKind = (SPGetUDTKind)SymParserGetUDTKind;
        Context->Parser.GetCallingConvention = (SPGetCallingConvention)SymParserGetCallingConvention;
        Context->Parser.GetFieldOffset = (SPGetFieldOffset)SymParserGetFieldOffset;
        Context->Parser.LoadModule = (SPLoadModule)SymParserLoadModule;
        Context->Parser.UnloadModule = (SPUnloadModule)SymParserUnloadModule;
        Context->Parser.LookupAddressBySymbol = (SPLookupAddressBySymbol)SymParserLookupAddressBySymbol;
        Context->Parser.LookupSymbolByAddress = (SPLookupSymbolByAddress)SymParserLookupSymbolByAddress;
        Context->Parser.DumpSymbolInformation = (SPDumpSymbolInformation)SymParserDumpSymbolInformation;

    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    return Context;
}

/**
* Destroy a symbol parser context and free resources
*
* @param Context - Symbol context to destroy
*/
VOID SymParserDestroy(
    _In_ PSYMCONTEXT Context
)
{
    if (Context) {
        if (Context->ModuleBase != 0)
            SymParserUnloadModule(Context);
        supHeapFree(Context);
    }
}

/**
* Initialize global symbol parser environment
*
* @param SymOptions - Symbol options or 0 for default
* @param ProcessHandle - Process handle or NULL for current process
* @param lpDbgHelpPath - Path to DbgHelp.dll or NULL for default
* @param lpSymbolPath - Symbol path or NULL for default
* @param lpSystemPath - System32 directory
* @param lpTempPath - Temp directory for symbol cache
* @param CallbackFunction - Optional callback function
* @param UserContext - User context for callback
* @return TRUE on success, FALSE on failure
*/
BOOL SymGlobalsInit(
    _In_ DWORD SymOptions,
    _In_opt_ HANDLE ProcessHandle,
    _In_opt_ LPCWSTR lpDbgHelpPath,
    _In_opt_ LPCWSTR lpSymbolPath,
    _In_ LPCWSTR lpSystemPath,
    _In_ LPCWSTR lpTempPath,
    _In_opt_ PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    _In_ ULONG64 UserContext
)
{
    BOOL bResult = FALSE;
    DWORD symOptions;
    HMODULE hDbg = NULL;
    LPWSTR finalDbgHelpPath = NULL;
    WCHAR szDbgHelpPath[MAX_PATH * 2];

    if (!lpSystemPath || !lpTempPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Validate symbols path input length.
    //
    if (_strlen(lpSystemPath) > MAX_PATH || _strlen(lpTempPath) > MAX_PATH) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (lpSymbolPath && _strlen(lpSymbolPath) >= RTL_NUMBER_OF(g_SymGlobals.szSymbolsPath)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlSecureZeroMemory(&g_SymGlobals, sizeof(g_SymGlobals));

    //
    // Prepare path and load dbghelp library.
    //
    if (lpDbgHelpPath) {
        finalDbgHelpPath = (LPWSTR)lpDbgHelpPath;
    }
    else {
        // Construct path from system dir
        RtlSecureZeroMemory(szDbgHelpPath, sizeof(szDbgHelpPath));
        _strncpy(szDbgHelpPath, MAX_PATH, lpSystemPath, _strlen(lpSystemPath));
        supPathAddBackSlash(szDbgHelpPath);
        _strcat(szDbgHelpPath, DEFAULT_DLL);
        finalDbgHelpPath = szDbgHelpPath;
    }

    hDbg = LoadLibraryEx(finalDbgHelpPath, NULL, 0);
    if (hDbg == NULL)
        return FALSE;

    g_SymGlobals.DllHandle = hDbg;

    //
    // Init dbghelp pointers and allocate context.
    //
    if (SympInitPointers(hDbg, &g_SymGlobals.ApiSet)) {

        g_SymGlobals.ProcessHandle = (ProcessHandle == NULL) ?
            NtCurrentProcess() : ProcessHandle;

        if (lpSymbolPath) {
            _strcpy(g_SymGlobals.szSymbolsPath, lpSymbolPath);
        }
        else {

            RtlStringCchPrintfSecure(g_SymGlobals.szSymbolsPath,
                RTL_NUMBER_OF(g_SymGlobals.szSymbolsPath) - 1,
                TEXT("srv*%ws\\%ws"),
                lpTempPath,
                DEFAULT_SYMPATH);

        }

        symOptions = SymOptions;
        if (symOptions == 0) {
            symOptions = SYMOPT_DEFERRED_LOADS |
                SYMOPT_CASE_INSENSITIVE |
                SYMOPT_UNDNAME |
                SYMOPT_AUTO_PUBLICS;
        }

        g_SymGlobals.ApiSet.SymSetOptions(symOptions);
        g_SymGlobals.Options = symOptions;

        bResult = g_SymGlobals.ApiSet.SymInitializeW(
            g_SymGlobals.ProcessHandle,
            g_SymGlobals.szSymbolsPath,
            FALSE);

        if (bResult && CallbackFunction) {

            g_SymGlobals.ApiSet.SymRegisterCallbackW64(
                g_SymGlobals.ProcessHandle,
                CallbackFunction,
                UserContext);

        }

    }
    else {
        SetLastError(ERROR_PROC_NOT_FOUND);
    }

    if (!bResult)
    {
        FreeLibrary(hDbg);
        g_SymGlobals.DllHandle = NULL;
    }

    g_SymGlobals.Initialized = bResult;

    return bResult;
}

/**
* Free global symbol parser resources
*
* @return TRUE on success, FALSE on failure
*/
BOOL SymGlobalsFree()
{
    BOOL bResult = FALSE;

    if (!g_SymGlobals.Initialized)
        return FALSE;

    if (g_SymGlobals.ApiSet.SymCleanup) {
        g_SymGlobals.ApiSet.SymCleanup(g_SymGlobals.ProcessHandle);

        if (g_SymGlobals.DllHandle) {
            bResult = FreeLibrary(g_SymGlobals.DllHandle);
            g_SymGlobals.DllHandle = NULL;
        }
    }

    g_SymGlobals.Initialized = FALSE;
    return bResult;
}

```

`Source/WinObjEx64/symparser.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT H.E., 2015 - 2022
*
*  TITLE:       SYMPARSER.H
*
*  VERSION:     1.18
*
*  DATE:        05 Jun 2022
*
*  Header file of DbgHelp wrapper for symbols parser support.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

// Unicode version of functions
#define DBGHELP_TRANSLATE_TCHAR

// Non-default declarations enabled
#define _NO_CVCONST_H

#include <dbghelp.h>
#pragma comment(lib, "dbghelp.lib")

typedef enum _SymUdtKind {
    UdtStruct,
    UdtClass,
    UdtUnion,
    UdtInterface,
    UdtInvalid = 0xffff
} SymUdtKind;

typedef enum _SymBasicType {
    btNoType = 0,
    btVoid = 1,
    btChar = 2,
    btWChar = 3,
    btInt = 6,
    btUInt = 7,
    btFloat = 8,
    btBCD = 9,
    btBool = 10,
    btLong = 13,
    btULong = 14,
    btCurrency = 25,
    btDate = 26,
    btVariant = 27,
    btComplex = 28,
    btBit = 29,
    btBSTR = 30,
    btHresult = 31,
    btChar16 = 32,
    btChar32 = 33,
    btChar8 = 34,
    btMaxType = 0xffff
} SymBasicType;

typedef struct _SYM_CHILD {
    ULONG Offset;

    BOOL IsBitField;
    ULONG BitPosition;

    BOOL IsValuePresent; //Note, max 8 bytes long value supported
    DWORD64 Value;

    ULONG64 Size;
    ULONG64 ElementsCount;

    WCHAR TypeName[MAX_SYM_NAME];
    WCHAR Name[MAX_SYM_NAME];
} SYM_CHILD, * PSYM_CHILD;

typedef struct _SYM_ENTRY {
    ULONG Offset;
    ULONG ChildCount;

    ULONG64 Size;

    WCHAR Name[MAX_SYM_NAME];
    SYM_CHILD ChildEntries[ANYSIZE_ARRAY];
} SYM_ENTRY, * PSYM_ENTRY;

//
// Prototypes
//

//
// DbgHelp
//
typedef  DWORD(WINAPI* pfnSymSetOptions)(
    _In_ DWORD   SymOptions
    );

typedef BOOL(WINAPI* pfnSymInitializeW)(
    _In_ HANDLE hProcess,
    _In_opt_ PCWSTR UserSearchPath,
    _In_ BOOL fInvadeProcess);

typedef BOOL(WINAPI* pfnSymRegisterCallback64)(
    _In_ HANDLE hProcess,
    _In_ PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    _In_ ULONG64 UserContext);

typedef DWORD64(WINAPI* pfnSymLoadModuleExW)(
    _In_ HANDLE hProcess,
    _In_opt_ HANDLE hFile,
    _In_opt_ PCWSTR ImageName,
    _In_opt_ PCWSTR ModuleName,
    _In_ DWORD64 BaseOfDll,
    _In_ DWORD DllSize,
    _In_opt_ PMODLOAD_DATA Data,
    _In_ DWORD Flags);

typedef BOOL(WINAPI* pfnSymGetTypeInfo)(
    _In_ HANDLE hProcess,
    _In_ DWORD64 ModBase,
    _In_ ULONG TypeId,
    _In_ IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    _Out_ PVOID pInfo);

typedef BOOL(WINAPI* pfnSymFromNameW)(
    _In_ HANDLE hProcess,
    _In_ PCWSTR Name,
    _Inout_ PSYMBOL_INFOW Symbol);

typedef BOOL(WINAPI* pfnSymFromAddrW)(
    _In_ HANDLE hProcess,
    _In_ DWORD64 Address,
    _In_ PDWORD64 Displacement,
    _Inout_ PSYMBOL_INFO Symbol);

typedef BOOL(WINAPI* pfnSymGetTypeFromNameW)(
    _In_ HANDLE hProcess,
    _In_ ULONG64 BaseOfDll,
    _In_ PCWSTR Name,
    _Inout_ PSYMBOL_INFOW Symbol);

typedef BOOL(WINAPI* pfnSymUnloadModule64)(
    _In_ HANDLE hProcess,
    _In_ DWORD64 BaseOfDll);

typedef BOOL(WINAPI* pfnSymCleanup)(
    _In_ HANDLE hProcess);

typedef struct _DBGHELP_PTRS {
    pfnSymSetOptions SymSetOptions;
    pfnSymInitializeW SymInitialize;
    pfnSymRegisterCallback64 SymRegisterCallback64;
    pfnSymLoadModuleExW SymLoadModuleEx;
    pfnSymGetTypeInfo SymGetTypeInfo;
    pfnSymFromNameW SymFromName;
    pfnSymFromAddrW SymFromAddr;
    pfnSymGetTypeFromNameW SymGetTypeFromName;
    pfnSymUnloadModule64 SymUnloadModule;
    pfnSymCleanup SymCleanup;
} DBGHELP_PTRS, * PDBGHELP_PTR;

//
// Symbol Parser
//
typedef struct _SYMCONTEXT* PSYMCONTEXT;

typedef BOOL(WINAPI* SPRegisterCallback)(
    _In_ PSYMCONTEXT Context,
    _In_ PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    _In_ ULONG64 UserContext);

typedef BOOL(WINAPI* SPLoadModule)(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR lpModulePath,
    _In_ DWORD64 BaseOfDll,
    _In_ DWORD SizeOfDll);

typedef BOOL(WINAPI* SPUnloadModule)(
    _In_ PSYMCONTEXT Context);

typedef SymBasicType(WINAPI* SPGetType)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef SymBasicType(WINAPI* SPGetBaseType)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetTypeId)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetArrayTypeId)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG64(WINAPI* SPGetSize)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetOffset)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetAddressOffset)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetBitPosition)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetChildrenCount)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetTag)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef LPCWSTR(WINAPI* SPGetName)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef VARTYPE(WINAPI* SPGetValue)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Inout_ VARIANT* Value,
    _Out_opt_ PBOOL Status);

typedef SymUdtKind(WINAPI* SPGetUDTKind)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetCount)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetCallingConvention)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PBOOL Status);

typedef LPCWSTR(WINAPI* SPGetTypeName)(
    _In_ PSYMCONTEXT Context,
    _In_ ULONG TypeIndex,
    _Out_opt_ PUINT64 BaseTypeSize,
    _Out_opt_ PBOOL Status);

typedef ULONG64(WINAPI* SPLookupAddressBySymbol)(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR SymbolName,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPLookupSymbolByAddress)(
    _In_ PSYMCONTEXT Context,
    _In_ DWORD64 SymbolAddress,
    _In_ PDWORD64 Displacement,
    _Inout_ LPWSTR* SymbolName,
    _Out_opt_ PBOOL Status);

typedef ULONG(WINAPI* SPGetFieldOffset)(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR SymbolName,
    _In_ LPCWSTR FieldName,
    _Out_opt_ PBOOL Status);

typedef PSYM_ENTRY(WINAPI* SPDumpSymbolInformation)(
    _In_ PSYMCONTEXT Context,
    _In_ LPCWSTR SymbolName,
    _Out_opt_ PBOOL Status);

typedef struct _SYMPARSER {
    SPLoadModule LoadModule;
    SPUnloadModule UnloadModule;
    SPGetTag GetTag;
    SPGetSize GetSize;
    SPGetType GetType;
    SPGetName GetName;
    SPGetValue GetValue;
    SPGetCount GetCount;
    SPGetOffset GetOffset;
    SPGetTypeId GetTypeId;
    SPGetUDTKind GetUDTKind;
    SPGetBaseType GetBaseType;
    SPGetTypeName GetTypeName;
    SPGetBitPosition GetBitPosition;
    SPGetFieldOffset GetFieldOffset;
    SPGetArrayTypeId GetArrayTypeId;
    SPGetAddressOffset GetAddressOffset;
    SPGetChildrenCount GetChildrenCount;
    SPGetCallingConvention GetCallingConvention;
    SPDumpSymbolInformation DumpSymbolInformation;
    SPLookupAddressBySymbol LookupAddressBySymbol;
    SPLookupSymbolByAddress LookupSymbolByAddress;
} SYMPARSER, * PSYMPARSER;

typedef struct _SYMCONTEXT {
    DWORD64 ModuleBase;
    HANDLE ProcessHandle;
    DWORD SymLastError;
    DBGHELP_PTRS DbgHelp;
    SYMPARSER Parser;
} SYMCONTEXT, * PSYMCONTEXT;

BOOL SymGlobalsInit(
    _In_ DWORD SymOptions,
    _In_opt_ HANDLE ProcessHandle,
    _In_opt_ LPCWSTR lpDbgHelpPath,
    _In_opt_ LPCWSTR lpSymbolPath,
    _In_ LPCWSTR lpSystemPath,
    _In_ LPCWSTR lpTempPath,
    _In_opt_ PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    _In_ ULONG64 UserContext);

BOOL SymGlobalsFree();

PSYMCONTEXT SymParserCreate(VOID);

VOID SymParserDestroy(
    _In_ PSYMCONTEXT Context);

```

`Source/WinObjEx64/sysinfoDlg.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       SYSINFODLG.C
*
*  VERSION:     2.09
*
*  DATE:        20 Aug 2025
* 
*  System Information Dialog.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

VALUE_DESC CodeIntegrityValuesList[] = {
    { L"CODEINTEGRITY_OPTION_ENABLED", CODEINTEGRITY_OPTION_ENABLED },
    { L"CODEINTEGRITY_OPTION_TESTSIGN", CODEINTEGRITY_OPTION_TESTSIGN },
    { L"CODEINTEGRITY_OPTION_UMCI_ENABLED", CODEINTEGRITY_OPTION_UMCI_ENABLED },
    { L"CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED", CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED },
    { L"CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED", CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED },
    { L"CODEINTEGRITY_OPTION_TEST_BUILD", CODEINTEGRITY_OPTION_TEST_BUILD },
    { L"CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD", CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD },
    { L"CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED", CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED },
    { L"CODEINTEGRITY_OPTION_FLIGHT_BUILD", CODEINTEGRITY_OPTION_FLIGHT_BUILD },
    { L"CODEINTEGRITY_OPTION_FLIGHTING_ENABLED", CODEINTEGRITY_OPTION_FLIGHTING_ENABLED },
    { L"CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED", CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED },
    { L"CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED", CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED },
    { L"CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED", CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED },
    { L"CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED", CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED },
    { L"CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED", CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED },
    { L"CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED", CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED }
};

/*
* AddParameterValue
*
* Purpose:
*
* Add text to the multiline richedit tabbed control.
*
*/
VOID AddParameterValue(
    _In_ HWND OutputWindow,
    _In_ LPCWSTR Parameter,
    _In_ LPCWSTR Value)
{
    CHARFORMAT cfBold, cfNormal;
    CHARRANGE range;
    LONG start, end;

    // Prepare CHARFORMATs for bold and normal text
    RtlSecureZeroMemory(&cfBold, sizeof(cfBold));
    cfBold.cbSize = sizeof(cfBold);
    cfBold.dwMask = CFM_BOLD;
    cfBold.dwEffects = CFE_BOLD;

    RtlSecureZeroMemory(&cfNormal, sizeof(cfNormal));
    cfNormal.cbSize = sizeof(cfNormal);
    cfNormal.dwMask = CFM_BOLD;

    // Move caret to end of text
    range.cpMin = range.cpMax = INT_MAX;
    SendMessage(OutputWindow, EM_EXSETSEL, 0, (LPARAM)&range);

    // Add newline if not the first line
    if (SendMessage(OutputWindow, WM_GETTEXTLENGTH, 0, 0) > 0)
        SendMessage(OutputWindow, EM_REPLACESEL, 0, (LPARAM)L"\r\n");

    // Mark parameter start, insert parameter, mark parameter end
    SendMessage(OutputWindow, EM_EXGETSEL, 0, (LPARAM)&range);
    start = range.cpMin;
    SendMessage(OutputWindow, EM_REPLACESEL, 0, (LPARAM)Parameter);
    SendMessage(OutputWindow, EM_EXGETSEL, 0, (LPARAM)&range);
    end = range.cpMin;

    // Bold only the parameter
    range.cpMin = start;
    range.cpMax = end;
    SendMessage(OutputWindow, EM_EXSETSEL, 0, (LPARAM)&range);
    SendMessage(OutputWindow, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cfBold);

    // Move caret to end and set normal style
    range.cpMin = range.cpMax = INT_MAX;
    SendMessage(OutputWindow, EM_EXSETSEL, 0, (LPARAM)&range);
    SendMessage(OutputWindow, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cfNormal);

    // Insert tab and value as normal
    SendMessage(OutputWindow, EM_REPLACESEL, 0, (LPARAM)L"\t");
    SendMessage(OutputWindow, EM_REPLACESEL, 0, (LPARAM)Value);
}

/*
* AddParameterValue64Hex
*
* Purpose:
*
* Add text to the multiline richedit tabbed control (hex value).
*
*/
VOID AddParameterValue64Hex(
    _In_ HWND OutputWindow,
    _In_ LPWSTR Parameter,
    _In_ ULONG_PTR Value)
{
    WCHAR szBuffer[32];

    szBuffer[0] = L'0';
    szBuffer[1] = L'x';
    szBuffer[2] = 0;
    u64tohex(Value, &szBuffer[2]);
    AddParameterValue(OutputWindow, Parameter, szBuffer);
}

/*
* AddParameterValue32Hex
*
* Purpose:
*
* Add text to the multiline richedit tabbed control (hex value).
*
*/
VOID AddParameterValue32Hex(
    _In_ HWND OutputWindow,
    _In_ LPWSTR Parameter,
    _In_ ULONG Value)
{
    WCHAR szBuffer[16];

    szBuffer[0] = L'0';
    szBuffer[1] = L'x';
    szBuffer[2] = 0;
    ultohex(Value, &szBuffer[2]);
    AddParameterValue(OutputWindow, Parameter, szBuffer);
}

/*
* AddParameterValueUlong
*
* Purpose:
*
* Add text to the multiline richedit tabbed control (ulong value).
*
*/
VOID AddParameterValueUlong(
    _In_ HWND OutputWindow,
    _In_ LPWSTR Parameter,
    _In_ ULONG Value)
{
    WCHAR szBuffer[16];

    szBuffer[0] = 0;
    ultostr(Value, szBuffer);
    AddParameterValue(OutputWindow, Parameter, szBuffer);
}

/*
* AddParameterValueBool
*
* Purpose:
*
* Add text to the multiline richedit tabbed control (bool value).
*
*/
VOID AddParameterValueBool(
    _In_ HWND OutputWindow,
    _In_ LPWSTR Parameter,
    _In_ BOOL Value)
{
    AddParameterValue(OutputWindow, Parameter, 
        (Value) ? TEXT("TRUE") : TEXT("FALSE"));
}

/*
* SysInfoCollectInformation
*
* Purpose:
*
* Build system information list including g_kdctx & g_WinObj data.
*
*/
VOID SysInfoCollectInformation(
    _In_ HWND hwndDlg
)
{
    BOOLEAN bCustomSignersAllowed;
    BOOLEAN bKdEnabled = FALSE, bKdAllowed = FALSE, bKdNotPresent = FALSE;
    LPWSTR lpType;
    NTSTATUS ntStatus;
    ULONG Index, Value, SaveValue;

    PCHAR lpWineVersion;

    WCHAR szBuffer[MAX_PATH * 4], szWineVer[40];
    WCHAR szTemp[MAX_PATH];

    SYSTEM_ISOLATED_USER_MODE_INFORMATION IsolatedUM;
    SYSTEM_CODEINTEGRITY_INFORMATION CodeIntegrity;
    SYSTEM_KERNEL_VA_SHADOW_INFORMATION KernelVaShadow;
    SYSTEM_VSM_PROTECTION_INFORMATION VsmProtectionInfo;
    SYSTEM_INFO SystemInfo;
    union {
        SYSTEM_SPECULATION_CONTROL_INFORMATION v1;
        SYSTEM_SPECULATION_CONTROL_INFORMATION_V2 v2;
    } SpecControlInfo;
    ULONG bytesIO;

    FIRMWARE_TYPE fmType;
    LPWSTR lpFmType;

    HKEY hKey;
    DWORD dwType, cbData, dwValue;

    OBEX_CONFIG* obConfig = supGetParametersBlock();

    PARAFORMAT ParaFormat;
    CHARRANGE CharRange;

    HWND hwndOutput = GetDlgItem(hwndDlg, IDC_GLOBALS);

    size_t Remaining;

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    RtlSecureZeroMemory(szTemp, sizeof(szTemp));

    //
    // Prepare RichEdit.
    //
    SendMessage(hwndOutput, EM_SETEVENTMASK, (WPARAM)0, (LPARAM)0);
    SendMessage(hwndOutput, WM_SETREDRAW, (WPARAM)0, (LPARAM)0);

    RtlSecureZeroMemory(&ParaFormat, sizeof(ParaFormat));
    ParaFormat.cbSize = sizeof(ParaFormat);
    ParaFormat.cTabCount = 1;
    ParaFormat.dwMask = PFM_TABSTOPS;
    ParaFormat.rgxTabs[0] = 3500;
    SendMessage(hwndOutput, EM_SETPARAFORMAT, (WPARAM)0, (LPARAM)&ParaFormat);

    //
    // Collect information.

    //
    //
    // Generic environment information, WinObjEx64 version.
    //
    RtlStringCchPrintfSecure(szBuffer,
        100,
        TEXT("%lu.%lu.%lu"),
        PROGRAM_MAJOR_VERSION,
        PROGRAM_MINOR_VERSION,
        PROGRAM_REVISION_NUMBER);

    AddParameterValue(hwndOutput, TEXT("Windows Object Explorer 64"), szBuffer);

    //
    // OS version.
    //
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    if (g_WinObj.IsWine) {
        lpWineVersion = (PCHAR)GetWineVersion();
        RtlSecureZeroMemory(szWineVer, sizeof(szWineVer));
        if (0 == MultiByteToWideChar(CP_ACP, 0, lpWineVersion, (INT)_strlen_a(lpWineVersion),
            szWineVer, RTL_NUMBER_OF(szWineVer)))
        {
            _strcpy(szWineVer, TEXT("<unknown>"));
        }
        RtlStringCchPrintfSecure(szBuffer, MAX_PATH, TEXT("Wine v%ws, reported as "), szWineVer);
    }

    Remaining = RTL_NUMBER_OF(szBuffer) - _strlen(szBuffer);
    RtlStringCchPrintfSecure(_strend(szBuffer),
        (ULONG)Remaining,
        TEXT("Windows NT %1u.%1u (build %u"),
        g_WinObj.osver.dwMajorVersion,
        g_WinObj.osver.dwMinorVersion,
        g_WinObj.osver.dwBuildNumber);

    if (g_WinObj.osver.szCSDVersion[0]) {
        _strcat(szBuffer, TEXT(", "));
        _strcat(szBuffer, g_WinObj.osver.szCSDVersion);
    }
    _strcat(szBuffer, TEXT(")"));

    AddParameterValue(hwndOutput, TEXT("System.OS"), szBuffer);

    //
    // CPU.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"),
        0,
        KEY_QUERY_VALUE,
        &hKey))
    {
        RtlSecureZeroMemory(szTemp, sizeof(szTemp));
        szBuffer[0] = 0;

        cbData = 128;
        dwType = REG_NONE;
        if (ERROR_SUCCESS == RegQueryValueEx(
            hKey,
            TEXT("Identifier"),
            NULL,
            &dwType,
            (LPBYTE)&szTemp,
            &cbData))
        {
            _strcat(szBuffer, szTemp);
        }

        _strcat(szBuffer, TEXT(", "));

        cbData = 128;
        dwType = REG_NONE;
        if (ERROR_SUCCESS == RegQueryValueEx(
            hKey,
            TEXT("VendorIdentifier"),
            NULL,
            &dwType,
            (LPBYTE)&szTemp,
            &cbData))
        {
            _strcat(szBuffer, szTemp);
        }

        _strcat(szBuffer, TEXT(", "));

        cbData = sizeof(DWORD);
        dwType = REG_NONE;
        dwValue = 0;
        if (ERROR_SUCCESS == RegQueryValueEx(
            hKey,
            TEXT("~MHz"),
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &cbData))
        {
            szTemp[0] = L'~';
            szTemp[1] = 0;
            ultostr(dwValue, &szTemp[1]);
            _strcat(szTemp, TEXT("MHz"));
            _strcat(szBuffer, szTemp);
        }

        AddParameterValue(hwndOutput, TEXT("Environment.Processor"), szBuffer);

        RegCloseKey(hKey);
    }

    GetSystemInfo(&SystemInfo);

    RtlStringCchPrintfSecure(szBuffer,
        MAX_PATH,
        TEXT("%lu, Mask 0x%08lX"),
        SystemInfo.dwNumberOfProcessors,
        SystemInfo.dwActiveProcessorMask);

    AddParameterValue(hwndOutput, TEXT("Environment.NumberOfProcessors"), szBuffer);

    AddParameterValueBool(hwndOutput, TEXT("Internal.IsFullAdmin"), g_kdctx.IsFullAdmin); //admin privileges available
    AddParameterValueBool(hwndOutput, TEXT("Internal.IsSecureBoot"), g_kdctx.IsSecureBoot); //secure boot enabled
    AddParameterValueBool(hwndOutput, TEXT("Internal.IsWine"), g_WinObj.IsWine);
    AddParameterValueBool(hwndOutput, TEXT("Internal.IsDebugPrivAssigned"), g_kdctx.IsDebugPrivAssigned);
    AddParameterValue32Hex(hwndOutput, TEXT("Internal.NameNormalizationSymbol"), (ULONG)g_ObNameNormalizationSymbol);

    if (obConfig) {
        if (obConfig->SymbolsDbgHelpDllValid) {
            AddParameterValue(hwndOutput, TEXT("Parameters.SymbolsDbgHelpDll"), obConfig->szSymbolsDbgHelpDll);
        }
        if (obConfig->SymbolsPathValid) {
            AddParameterValue(hwndOutput, TEXT("Parameters.SymbolsPath"), obConfig->szSymbolsPath);
        }
    }

    AddParameterValueBool(hwndOutput, TEXT("MitigationFlags.ASLRPolicy"), g_kdctx.MitigationFlags.ASLRPolicy);
    AddParameterValueBool(hwndOutput, TEXT("MitigationFlags.DynamicCode"), g_kdctx.MitigationFlags.DynamicCode);
    AddParameterValueBool(hwndOutput, TEXT("MitigationFlags.ExtensionPointDisable"), g_kdctx.MitigationFlags.ExtensionPointDisable);
    AddParameterValueBool(hwndOutput, TEXT("MitigationFlags.ImageLoad"), g_kdctx.MitigationFlags.ImageLoad);
    AddParameterValueBool(hwndOutput, TEXT("MitigationFlags.Signature"), g_kdctx.MitigationFlags.Signature);

    //
    // Helper driver state.
    //
    AddParameterValue32Hex(hwndOutput, TEXT("Driver.LoadStatus"), g_kdctx.DriverContext.LoadStatus);
    AddParameterValue32Hex(hwndOutput, TEXT("Driver.OpenStatus"), g_kdctx.DriverContext.OpenStatus);
    AddParameterValueBool(hwndOutput, TEXT("Driver.IsOurLoad"), g_kdctx.DriverContext.IsOurLoad); //driver was loaded by our program instance

    switch (WDrvGetActiveProviderType()) {
    case wdrvAlice:
        lpType = L"Alice";
        break;
    case wdrvRonova:
        lpType = L"Ronova";
        break;
    case wdrvWinIo:
        lpType = L"WinIo";
        break;
    case wdrvWinObjEx64:
        lpType = L"WinObjEx64";
        break;
    case wdrvMicrosoft:
    default:
        lpType = L"Microsoft";
        break;
    }
    AddParameterValue(hwndOutput, TEXT("Driver.SelectedProvider"), lpType);

    //
    // Ntoskrnl
    //
    AddParameterValue64Hex(hwndOutput, TEXT("Loader.NtOsBase"), (ULONG_PTR)g_kdctx.NtOsBase);
    AddParameterValue64Hex(hwndOutput, TEXT("Loader.NtOsImageMap"), (ULONG_PTR)g_kdctx.NtOsImageMap);//mapped image address
    AddParameterValue32Hex(hwndOutput, TEXT("Loader.NtOsSize"), g_kdctx.NtOsSize);//mapped image size

    //
    // Ntoskrnl symbols
    //
    AddParameterValue64Hex(hwndOutput, TEXT("NtSymContext.ContextBase"), (ULONG_PTR)g_kdctx.NtOsSymContext);
    if (g_kdctx.NtOsSymContext) {
        AddParameterValue64Hex(hwndOutput, TEXT("NtSymContext.ModuleBase"), ((PSYMCONTEXT)g_kdctx.NtOsSymContext)->ModuleBase);
    }

    //
    // Product info
    //
    AddParameterValueBool(hwndOutput, TEXT("System.LTSC"), supIsLongTermServicingWindows());

    //
    // KD state
    //
    bKdEnabled = supIsKdEnabled(&bKdAllowed, &bKdNotPresent);
    AddParameterValueBool(hwndOutput, TEXT("System.KdEnabled"), bKdEnabled);
    AddParameterValueBool(hwndOutput, TEXT("System.KdAllowed"), bKdAllowed);
    AddParameterValueBool(hwndOutput, TEXT("System.KdNotPresent"), bKdNotPresent);

    //
    // Firmware type
    //
    if (g_kdctx.Data) {
        fmType = g_kdctx.Data->FirmwareType;
    }
    else {
        fmType = (FIRMWARE_TYPE)-1;
    }

    switch (fmType) {

    case FirmwareTypeBios:
        lpFmType = TEXT("BIOS");
        break;

    case FirmwareTypeUefi:
        lpFmType = TEXT("UEFI");
        break;

    default:
        lpFmType = TEXT("Unknown");
        break;
    }
    AddParameterValue(hwndOutput, TEXT("System.FirmwareType"), lpFmType);

    //
    // Is OS Disk VHD?
    //
    AddParameterValueBool(hwndOutput, TEXT("System.IsOsDiskVhd"), g_kdctx.IsOsDiskVhd);

    //
    // System ranges
    //
    AddParameterValue64Hex(hwndOutput, TEXT("System.SystemRangeStart"), (ULONG_PTR)g_kdctx.SystemRangeStart);
    AddParameterValue64Hex(hwndOutput, TEXT("System.MinimumUserModeAddress"), (ULONG_PTR)g_kdctx.MinimumUserModeAddress);
    AddParameterValue64Hex(hwndOutput, TEXT("System.MaximumUserModeAddress"), (ULONG_PTR)g_kdctx.MaximumUserModeAddress);

    if (g_kdctx.IsFullAdmin && g_kdctx.Data) {

        //
        // List kldbg data if there is something to show since this data fetched dynamically during usage.
        //
        AddParameterValueBool(hwndOutput, TEXT("System.ObHeaderCookieValid"), g_kdctx.Data->ObHeaderCookie.Valid);
        AddParameterValue32Hex(hwndOutput, TEXT("System.ObHeaderCookie"), g_kdctx.Data->ObHeaderCookie.Value);
        AddParameterValueUlong(hwndOutput, TEXT("System.DirectoryTypeIndex"), g_kdctx.DirectoryTypeIndex);

        if (g_kdctx.DirectoryRootObject)
            AddParameterValue64Hex(hwndOutput, TEXT("System.DirectoryRootObject"), g_kdctx.DirectoryRootObject);

        if (g_kdctx.Data->KeServiceDescriptorTable.Limit)
            AddParameterValueUlong(hwndOutput, TEXT("System.KiServiceLimit"), g_kdctx.Data->KeServiceDescriptorTable.Limit);

        if (g_kdctx.Data->KeServiceDescriptorTable.Base)
            AddParameterValue64Hex(hwndOutput, TEXT("System.KiServiceTableAddress"), (ULONG_PTR)g_kdctx.Data->KeServiceDescriptorTable.Base);

        if (g_kdctx.Data->IopInvalidDeviceRequest)
            AddParameterValue64Hex(hwndOutput, TEXT("System.IopInvalidDeviceRequest"), (ULONG_PTR)g_kdctx.Data->IopInvalidDeviceRequest);

        if (g_kdctx.Data->PrivateNamespaceLookupTable)
            AddParameterValue64Hex(hwndOutput, TEXT("System.PrivateNamespaceLookupTable"), (ULONG_PTR)g_kdctx.Data->PrivateNamespaceLookupTable);

    }
    //
    // List other data.
    //
    if (NT_SUCCESS(supCICustomKernelSignersAllowed(&bCustomSignersAllowed))) {
        AddParameterValueBool(hwndOutput, TEXT("System.CICustomKernelSignersAllowed"), bCustomSignersAllowed);
    }

    AddParameterValueUlong(hwndOutput, TEXT("System.DpiValue"), (ULONG)supGetDPIValue(NULL));

    //
    // CI flags.
    //
    CodeIntegrity.Length = sizeof(CodeIntegrity);
    CodeIntegrity.CodeIntegrityOptions = 0;
    if (NT_SUCCESS(NtQuerySystemInformation(
        SystemCodeIntegrityInformation,
        &CodeIntegrity,
        sizeof(CodeIntegrity),
        &bytesIO)))
    {
        AddParameterValue32Hex(hwndOutput, TEXT("System.CodeIntegrityOptions"), CodeIntegrity.CodeIntegrityOptions);

        if (CodeIntegrity.CodeIntegrityOptions) {

            for (Index = 0; Index < RTL_NUMBER_OF(CodeIntegrityValuesList); Index++) {

                if (CodeIntegrity.CodeIntegrityOptions & CodeIntegrityValuesList[Index].dwValue) {
                    AddParameterValue(
                        hwndOutput,
                        TEXT("System.CodeIntegrityOption"),
                        CodeIntegrityValuesList[Index].lpDescription);
                    CodeIntegrity.CodeIntegrityOptions &= ~CodeIntegrityValuesList[Index].dwValue;
                }
            }

            if (CodeIntegrity.CodeIntegrityOptions) {
                Value = 1;
                SaveValue = CodeIntegrity.CodeIntegrityOptions;
                while (SaveValue) {
                    if (SaveValue & Value) {
                        AddParameterValue32Hex(hwndOutput, TEXT("System.CodeIntegrityOption(unknown)"), Value);
                        SaveValue &= ~Value;
                    }
                    Value *= 2;
                }
            }
        }
    }

    //
    // Kernel VA Shadowing flags.
    //
    KernelVaShadow.Flags = 0;
    if (NT_SUCCESS(NtQuerySystemInformation(
        SystemKernelVaShadowInformation,
        &KernelVaShadow,
        sizeof(KernelVaShadow),
        &bytesIO)))
    {
        AddParameterValue32Hex(hwndOutput, TEXT("System.KvaShadowFlags"), KernelVaShadow.Flags);
    }

    //
    // Speculation Control flags.
    //
    RtlSecureZeroMemory(&SpecControlInfo, sizeof(SpecControlInfo));
    bytesIO = sizeof(SpecControlInfo);
    ntStatus = NtQuerySystemInformation(SystemSpeculationControlInformation, &SpecControlInfo, bytesIO, &bytesIO);
    if (NT_SUCCESS(ntStatus)) {

        if (bytesIO == sizeof(SYSTEM_SPECULATION_CONTROL_INFORMATION)) {
            AddParameterValue32Hex(hwndOutput, TEXT("System.SpeculationControlFlags"), SpecControlInfo.v1.Flags);
        }
        else if (bytesIO == sizeof(SYSTEM_SPECULATION_CONTROL_INFORMATION_V2)) {
            AddParameterValue32Hex(hwndOutput, TEXT("System.SpeculationControlFlags"), SpecControlInfo.v1.Flags);
            AddParameterValue32Hex(hwndOutput, TEXT("System.SpeculationControlFlags2"), SpecControlInfo.v2.Flags2);
        }

    }

    //
    // Isolated UM flags.
    //
    RtlSecureZeroMemory(&IsolatedUM, sizeof(SYSTEM_ISOLATED_USER_MODE_INFORMATION));
    ntStatus = NtQuerySystemInformation(SystemIsolatedUserModeInformation, &IsolatedUM, sizeof(IsolatedUM), &bytesIO);
    if (NT_SUCCESS(ntStatus)) {
        AddParameterValueBool(hwndOutput, TEXT("IUM.SecureKernelRunning"), IsolatedUM.SecureKernelRunning);
        AddParameterValueBool(hwndOutput, TEXT("IUM.HvciEnabled"), IsolatedUM.HvciEnabled);
        AddParameterValueBool(hwndOutput, TEXT("IUM.HvciStrictMode"), IsolatedUM.HvciStrictMode);
        AddParameterValueBool(hwndOutput, TEXT("IUM.DebugEnabled"), IsolatedUM.DebugEnabled);
        AddParameterValueBool(hwndOutput, TEXT("IUM.FirmwarePageProtection"), IsolatedUM.FirmwarePageProtection);
        AddParameterValueBool(hwndOutput, TEXT("IUM.TrustletRunning"), IsolatedUM.TrustletRunning);
        AddParameterValueBool(hwndOutput, TEXT("IUM.HvciDisableAllowed"), IsolatedUM.HvciDisableAllowed);
        AddParameterValueBool(hwndOutput, TEXT("IUM.HardwareEnforcedVbs"), IsolatedUM.HardwareEnforcedVbs);
        AddParameterValueBool(hwndOutput, TEXT("IUM.HardwareEnforcedHvpt"), IsolatedUM.HardwareEnforcedHvpt);
        AddParameterValueBool(hwndOutput, TEXT("IUM.HardwareHvptAvailable"), IsolatedUM.HardwareHvptAvailable);
    }

    //
    // VSM protection flags.
    //
    RtlSecureZeroMemory(&VsmProtectionInfo, sizeof(VsmProtectionInfo));
    if (NT_SUCCESS(NtQuerySystemInformation(
        SystemVsmProtectionInformation,
        &VsmProtectionInfo,
        sizeof(VsmProtectionInfo),
        &bytesIO)))
    {
        AddParameterValueBool(hwndOutput, TEXT("Vsm.DmaProtectionsAvailable"), VsmProtectionInfo.DmaProtectionsAvailable);
        AddParameterValueBool(hwndOutput, TEXT("Vsm.DmaProtectionsInUse"), VsmProtectionInfo.DmaProtectionsInUse);
        AddParameterValueBool(hwndOutput, TEXT("Vsm.HardwareMbecAvailable"), VsmProtectionInfo.HardwareMbecAvailable);
        AddParameterValueBool(hwndOutput, TEXT("Vsm.ApicVirtualizationAvailable"), VsmProtectionInfo.ApicVirtualizationAvailable);
    }

    //
    // Global directories.
    //
    AddParameterValue(hwndOutput, TEXT("System.TempDirectory"), g_WinObj.szTempDirectory);
    AddParameterValue(hwndOutput, TEXT("System.WindowsDirectory"), g_WinObj.szWindowsDirectory);
    AddParameterValue(hwndOutput, TEXT("System.SystemDirectory"), g_WinObj.szSystemDirectory);
    AddParameterValue(hwndOutput, TEXT("System.ProgramDirectory"), g_WinObj.szProgramDirectory);

    //
    // End work with RichEdit.
    //
    SendMessage(hwndOutput, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
    InvalidateRect(hwndOutput, NULL, TRUE);

    SendMessage(hwndOutput, EM_SETEVENTMASK, (WPARAM)0, (LPARAM)ENM_SELCHANGE);

    CharRange.cpMax = 0;
    CharRange.cpMin = 0;
    SendMessage(hwndOutput, EM_EXSETSEL, (WPARAM)0, (LPARAM)&CharRange);

    SetFocus(hwndOutput);
}

/*
* SysInfoCopyToClipboard
*
* Purpose:
*
* Copy text to the clipboard.
*
*/
VOID SysInfoCopyToClipboard(
    _In_ HWND hwndDlg
)
{
    SIZE_T charCount, bufferSize;
    PWCHAR buffer;

    GETTEXTLENGTHEX gtl;
    GETTEXTEX gt;

    HWND hwndControl = GetDlgItem(hwndDlg, IDC_GLOBALS);

    gtl.flags = GTL_USECRLF;
    gtl.codepage = 1200;

    charCount = (SIZE_T)SendMessage(hwndControl, EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0);
    if (charCount) {

        bufferSize = (charCount + 1) * sizeof(WCHAR);

        buffer = (PWCHAR)supHeapAlloc(bufferSize);
        if (buffer) {

            gt.flags = GT_USECRLF;
            gt.cb = (ULONG)bufferSize;

            gt.codepage = 1200;
            gt.lpDefaultChar = NULL;
            gt.lpUsedDefChar = NULL;
            SendMessage(hwndControl, EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)buffer);
            buffer[charCount] = L'\0';
            supClipboardCopy(buffer, bufferSize);

            supHeapFree(buffer);
        }
    }
}

/*
* SysInfoDialogProc
*
* Purpose:
*
* System information dialog window procedure.
*
*/
LRESULT CALLBACK SysInfoDialogProc(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg) {
    case WM_SHOWWINDOW:
        if (LOWORD(wParam)) {
            SysInfoCollectInformation(hwnd);
        }
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_GLOBALS_COPY:
            SysInfoCopyToClipboard(hwnd);
            break;
        case IDCANCEL:
            return EndDialog(hwnd, S_OK);
        }

    }
    return 0;
}

/*
* ShowSysInfoDialog
*
* Purpose:
*
* Prepare and show globals window.
*
*/
VOID ShowSysInfoDialog(
    _In_ HWND hwndParent
)
{
    if (!supRichEdit32Load()) {
        MessageBox(hwndParent, TEXT("Could not load RichEdit library"), NULL, MB_ICONERROR);
        return;
    }

    DialogBoxParam(g_WinObj.hInstance,
        MAKEINTRESOURCE(IDD_DIALOG_GLOBALS),
        hwndParent,
        (DLGPROC)&SysInfoDialogProc,
        (LPARAM)hwndParent);
}

```

`Source/WinObjEx64/tests/ntsup_tests.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026 UGN/HE
*
*  TITLE:       NTSUP_TESTS.C
*
*  VERSION:     2.10
*
*  DATE:        10 Jan 2026
*
*  NTSup test code used while debug.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#define OEMRESOURCE

#include "global.h"
#include "ntos\ntsup.h"
#pragma warning(push)
#pragma warning(disable:28251) //Inconsistent annotation for any intrin, "feature" of the latest MSVC
#pragma warning(disable: 6387) //_Param_(1) could be '0'
#pragma warning(disable: 28159) //GetTickCount
#include <intrin.h>

static ULONG g_FailCount = 0;
static BOOL g_Verbose = TRUE;

#define TEST_ASSERT(expr) do { if (!(expr)) { ++g_FailCount; if (g_Verbose) DbgPrint("ASSERT FAILED: %s (%s:%d)\n", #expr, __FUNCTION__, __LINE__); } } while (0)

PVOID CALLBACK TestAlloc(_In_ SIZE_T NumberOfBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NumberOfBytes);
}

BOOL CALLBACK TestFree(_In_ PVOID Memory)
{
    if (Memory) HeapFree(GetProcessHeap(), 0, Memory);
    return TRUE;
}

PVOID CALLBACK FailAlloc(_In_ SIZE_T NumberOfBytes)
{
    (void)NumberOfBytes;
    return NULL;
}

BOOL ReadFileContent(
    _In_ LPCWSTR FileName,
    _Out_ PBYTE* Buffer,
    _Out_ DWORD* Size
)
{
    HANDLE hFile;
    DWORD fileSize, bytesRead;
    PBYTE data;

    *Buffer = NULL;
    *Size = 0;

    hFile = CreateFile(FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    fileSize = GetFileSize(hFile, NULL);
    if (fileSize == INVALID_FILE_SIZE) {
        CloseHandle(hFile);
        return FALSE;
    }

    data = (PBYTE)ntsupHeapAlloc(fileSize ? fileSize : 1);
    if (data == NULL) {
        CloseHandle(hFile);
        return FALSE;
    }

    bytesRead = 0;
    if (fileSize) {
        if (!ReadFile(hFile, data, fileSize, &bytesRead, NULL) || bytesRead != fileSize) {
            ntsupHeapFree(data);
            CloseHandle(hFile);
            return FALSE;
        }
    }

    CloseHandle(hFile);

    *Buffer = data;
    *Size = fileSize;
    return TRUE;
}

VOID WriteBufferToFile_WriteNewFile(VOID)
{
    WCHAR tempPath[MAX_PATH];
    WCHAR filePath[MAX_PATH];
    NTSTATUS resultStatus;
    SIZE_T written;
    BYTE const data1[] = { 1,2,3,4,5 };
    PBYTE fileData;
    DWORD fileSize;
    ULONG i;

    RtlSecureZeroMemory(tempPath, sizeof(tempPath));
    RtlSecureZeroMemory(filePath, sizeof(filePath));

    GetTempPath(MAX_PATH, tempPath);
    wsprintfW(filePath, L"%sntsup_test_%lu.bin", tempPath, GetTickCount());

    written = ntsupWriteBufferToFile(
        filePath,
        (PVOID)data1,
        sizeof(data1),
        TRUE,
        FALSE,
        &resultStatus);

    TEST_ASSERT(written == sizeof(data1));
    TEST_ASSERT(NT_SUCCESS(resultStatus));

    fileData = NULL;
    fileSize = 0;
    TEST_ASSERT(ReadFileContent(filePath, &fileData, &fileSize));
    if (fileData) {
        TEST_ASSERT(fileSize == sizeof(data1));
        for (i = 0; i < fileSize; i++)
            TEST_ASSERT(fileData[i] == data1[i]);
        ntsupHeapFree(fileData);
    }

    DeleteFile(filePath);
}

VOID WriteBufferToFile_AppendFile(VOID)
{
    WCHAR tempPath[MAX_PATH];
    WCHAR filePath[MAX_PATH];
    NTSTATUS resultStatus;
    SIZE_T written;
    BYTE const data1[] = { 0x10,0x11,0x12 };
    BYTE const data2[] = { 0xAA,0xBB };
    PBYTE fileData;
    DWORD fileSize;
    ULONG i;

    RtlSecureZeroMemory(tempPath, sizeof(tempPath));
    RtlSecureZeroMemory(filePath, sizeof(filePath));

    GetTempPath(MAX_PATH, tempPath);
    wsprintfW(filePath, L"%sntsup_test_append_%lu.bin", tempPath, GetTickCount());

    written = ntsupWriteBufferToFile(
        filePath,
        (PVOID)data1,
        sizeof(data1),
        TRUE,
        FALSE,
        &resultStatus);

    TEST_ASSERT(written == sizeof(data1));
    TEST_ASSERT(NT_SUCCESS(resultStatus));

    written = ntsupWriteBufferToFile(
        filePath,
        (PVOID)data2,
        sizeof(data2),
        TRUE,
        TRUE,
        &resultStatus);

    TEST_ASSERT(written == sizeof(data2));
    TEST_ASSERT(NT_SUCCESS(resultStatus));

    fileData = NULL;
    fileSize = 0;
    TEST_ASSERT(ReadFileContent(filePath, &fileData, &fileSize));
    if (fileData) {
        TEST_ASSERT(fileSize == sizeof(data1) + sizeof(data2));
        for (i = 0; i < sizeof(data1); i++)
            TEST_ASSERT(fileData[i] == data1[i]);
        for (i = 0; i < sizeof(data2); i++)
            TEST_ASSERT(fileData[sizeof(data1) + i] == data2[i]);
        ntsupHeapFree(fileData);
    }

    DeleteFile(filePath);
}

VOID WriteBufferToFile_InvalidPath(VOID)
{
    NTSTATUS resultStatus;
    SIZE_T written;
    BYTE dummy[4] = { 0 };

    written = ntsupWriteBufferToFile(
        L"",
        dummy,
        sizeof(dummy),
        FALSE,
        FALSE,
        &resultStatus);

    TEST_ASSERT(written == 0);
    TEST_ASSERT(!NT_SUCCESS(resultStatus));
}

VOID WriteBufferToFile_ZeroSizeWrite(VOID)
{
    WCHAR tempPath[MAX_PATH];
    WCHAR filePath[MAX_PATH];
    NTSTATUS resultStatus;
    SIZE_T written;
    PBYTE fileData;
    DWORD fileSize;

    RtlSecureZeroMemory(tempPath, sizeof(tempPath));
    RtlSecureZeroMemory(filePath, sizeof(filePath));

    GetTempPath(MAX_PATH, tempPath);
    wsprintfW(filePath, L"%sntsup_test_zero_%lu.bin", tempPath, GetTickCount());

    written = ntsupWriteBufferToFile(
        filePath,
        (PVOID)"",
        0,
        TRUE,
        FALSE,
        &resultStatus);

    TEST_ASSERT(written == 0);
    TEST_ASSERT(NT_SUCCESS(resultStatus) || written == 0); // Accept success with zero write

    fileData = NULL;
    fileSize = 0;
    if (ReadFileContent(filePath, &fileData, &fileSize)) {
        TEST_ASSERT(fileSize == 0);
        if (fileData) ntsupHeapFree(fileData);
    }

    DeleteFile(filePath);
}

VOID FindModuleNameByAddress_ValidModuleName(VOID)
{
    PRTL_PROCESS_MODULES modules;
    ULONG returnLength;
    PRTL_PROCESS_MODULE_INFORMATION modInfo;
    WCHAR nameBuffer[260];
    PVOID foundEntry;
    PVOID testAddress;
    ANSI_STRING ansiExpected;
    UNICODE_STRING usExpected;
    SIZE_T expectedLen;

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesList(&returnLength);
    TEST_ASSERT(modules != NULL);
    if (modules == NULL)
        return;

    if (modules->NumberOfModules == 0) {
        ntsupHeapFree(modules);
        TEST_ASSERT(FALSE);
        return;
    }

    modInfo = &modules->Modules[0];
    testAddress = (PBYTE)modInfo->ImageBase + (modInfo->ImageSize / 2);

    RtlSecureZeroMemory(nameBuffer, sizeof(nameBuffer));

    foundEntry = ntsupFindModuleNameByAddress(
        modules,
        testAddress,
        nameBuffer,
        _countof(nameBuffer));

    TEST_ASSERT(foundEntry != NULL);
    TEST_ASSERT(nameBuffer[0] != 0);

    if (foundEntry) {
        RtlInitString(&ansiExpected,
            (PCSZ)&modInfo->FullPathName[modInfo->OffsetToFileName]);
        usExpected.Buffer = NULL;
        usExpected.Length = usExpected.MaximumLength = 0;
        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&usExpected, &ansiExpected, TRUE))) {
            expectedLen = usExpected.Length / sizeof(WCHAR);
            TEST_ASSERT(_strlen(nameBuffer) <= expectedLen);
            TEST_ASSERT(_strcmp(nameBuffer, usExpected.Buffer) == 0);
            RtlFreeUnicodeString(&usExpected);
        }
    }

    ntsupHeapFree(modules);
}

VOID FindModuleNameByAddress_TruncatedBuffer(VOID)
{
    PRTL_PROCESS_MODULES modules;
    ULONG returnLength;
    PRTL_PROCESS_MODULE_INFORMATION modInfo;
    WCHAR tinyBuffer[4];
    PVOID testAddress;
    PVOID foundEntry;
    SIZE_T lenCaptured;

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesList(&returnLength);
    TEST_ASSERT(modules != NULL);
    if (modules == NULL)
        return;

    if (modules->NumberOfModules == 0) {
        ntsupHeapFree(modules);
        TEST_ASSERT(FALSE);
        return;
    }

    modInfo = &modules->Modules[0];
    testAddress = modInfo->ImageBase;

    RtlSecureZeroMemory(tinyBuffer, sizeof(tinyBuffer));

    foundEntry = ntsupFindModuleNameByAddress(
        modules,
        testAddress,
        tinyBuffer,
        _countof(tinyBuffer));

    TEST_ASSERT(foundEntry != NULL);
    lenCaptured = _strlen(tinyBuffer);
    TEST_ASSERT(lenCaptured <= (_countof(tinyBuffer) - 1));
    TEST_ASSERT(tinyBuffer[_countof(tinyBuffer) - 1] == 0);

    ntsupHeapFree(modules);
}

VOID FindModuleNameByAddress_InvalidAddress(VOID)
{
    PRTL_PROCESS_MODULES modules;
    ULONG returnLength;
    WCHAR buffer[32];
    PVOID foundEntry;

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesList(&returnLength);
    TEST_ASSERT(modules != NULL);
    if (modules == NULL)
        return;

    RtlSecureZeroMemory(buffer, sizeof(buffer));

    foundEntry = ntsupFindModuleNameByAddress(
        modules,
        ULongToPtr(0x1), // very low address, should not belong to system module range
        buffer,
        _countof(buffer));

    TEST_ASSERT(foundEntry == NULL);
    TEST_ASSERT(buffer[0] == 0);

    ntsupHeapFree(modules);
}

VOID FindModuleNameByAddress_InvalidBufferArgs(VOID)
{
    PRTL_PROCESS_MODULES modules;
    ULONG returnLength;
    PRTL_PROCESS_MODULE_INFORMATION modInfo;
    PVOID testAddress;
    PVOID foundEntry;
    WCHAR nameBuffer[8];

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesList(&returnLength);
    TEST_ASSERT(modules != NULL);
    if (modules == NULL)
        return;

    if (modules->NumberOfModules == 0) {
        ntsupHeapFree(modules);
        TEST_ASSERT(FALSE);
        return;
    }

    modInfo = &modules->Modules[0];
    testAddress = modInfo->ImageBase;

    foundEntry = ntsupFindModuleNameByAddress(
        modules,
        testAddress,
        NULL,
        0);
    TEST_ASSERT(foundEntry == NULL);

    RtlSecureZeroMemory(nameBuffer, sizeof(nameBuffer));
    foundEntry = ntsupFindModuleNameByAddress(
        modules,
        testAddress,
        nameBuffer,
        0);
    TEST_ASSERT(foundEntry == NULL);
    TEST_ASSERT(nameBuffer[0] == 0);

    ntsupHeapFree(modules);
}

VOID GetLoadedModulesListEx_BasicList(VOID)
{
    PRTL_PROCESS_MODULES modules;
    ULONG returnLength = 0;
    ULONG count, i;
    BOOLEAN haveNonZero = FALSE;

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesListEx(
        FALSE,
        &returnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);

    TEST_ASSERT(modules != NULL);
    if (modules == NULL)
        return;

    count = modules->NumberOfModules;
    TEST_ASSERT(count > 0);
    TEST_ASSERT(returnLength > 0);

    if (count > 0) {
        TEST_ASSERT(modules->Modules[0].ImageBase != NULL);
        TEST_ASSERT(modules->Modules[0].ImageSize > 0);
    }

    for (i = 0; i < count && i < 32; i++) {
        if (modules->Modules[i].FullPathName[0] != 0) {
            haveNonZero = TRUE;
            break;
        }
    }
    TEST_ASSERT(haveNonZero);

    ntsupHeapFree(modules);
}

VOID GetLoadedModulesListEx_ExtendedList(VOID)
{
    PRTL_PROCESS_MODULES modules;
    ULONG returnLength = 0;

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesListEx(
        TRUE,
        &returnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);

    if (modules == NULL) {
        if (g_Verbose) DbgPrint("Extended module list not available (SystemModuleInformationEx unsupported?) - skipping related assertions.\n");
        return;
    }

    TEST_ASSERT(returnLength > 0);
    TEST_ASSERT(modules->NumberOfModules > 0);
    TEST_ASSERT(modules->Modules[0].ImageBase != NULL);

    ntsupHeapFree(modules);
}

VOID GetLoadedModulesListEx_NullReturnLength(VOID)
{
    PRTL_PROCESS_MODULES modules;

    modules = (PRTL_PROCESS_MODULES)ntsupGetLoadedModulesListEx(
        FALSE,
        NULL,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);

    TEST_ASSERT(modules != NULL);
    if (modules)
        ntsupHeapFree(modules);
}

VOID GetLoadedModulesListEx_AllocFailure(VOID)
{
    PVOID modules;
    ULONG returnLength = 0;

    modules = ntsupGetLoadedModulesListEx(
        FALSE,
        &returnLength,
        (PNTSUPMEMALLOC)FailAlloc,
        (PNTSUPMEMFREE)TestFree);

    TEST_ASSERT(modules == NULL);
    TEST_ASSERT(returnLength == 0);
}

VOID GetSystemInfoEx_SystemProcessInformation(VOID)
{
    PVOID buffer;
    ULONG retLen = 0;
    ULONG safeCheck = 0;
    ULONG bytesWalked = 0;

    buffer = ntsupGetSystemInfoEx(
        SystemProcessInformation,
        &retLen,
        (PNTSUPMEMALLOC)TestAlloc,
        (PNTSUPMEMFREE)TestFree);

    if (buffer == NULL) {
        if (g_Verbose) DbgPrint("SystemProcessInformation unsupported or allocation failed, skipping.\n");
        return;
    }

    TEST_ASSERT(retLen > 0);

    if (retLen > sizeof(SYSTEM_PROCESS_INFORMATION)) {

        PSYSTEM_PROCESS_INFORMATION spi = (PSYSTEM_PROCESS_INFORMATION)buffer;

        while (TRUE) {
            TEST_ASSERT(spi->NextEntryDelta % sizeof(ULONG) == 0);
            bytesWalked += spi->NextEntryDelta;
            safeCheck++;

            if (spi->NextEntryDelta == 0)
                break;

            if (safeCheck > 0x100000) {
                TEST_ASSERT(FALSE);
                break;
            }

            spi = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)spi + spi->NextEntryDelta);
        }
    }

    TestFree(buffer);
}

VOID GetSystemInfoEx_NullReturnLength(VOID)
{
    PVOID buffer;

    buffer = ntsupGetSystemInfoEx(
        SystemBasicInformation,
        NULL,
        (PNTSUPMEMALLOC)TestAlloc,
        (PNTSUPMEMFREE)TestFree);

    TEST_ASSERT(buffer == NULL);
    if (buffer)
        TestFree(buffer);
}

VOID GetSystemInfoEx_AllocFailure(VOID)
{
    PVOID buffer;
    ULONG retLen = 0;

    buffer = ntsupGetSystemInfoEx(
        SystemBasicInformation,
        &retLen,
        (PNTSUPMEMALLOC)FailAlloc,
        (PNTSUPMEMFREE)TestFree);

    TEST_ASSERT(buffer == NULL);
    TEST_ASSERT(retLen == 0);
}

VOID GetSystemInfoEx_InvalidClass(VOID)
{
    PVOID buffer;
    ULONG retLen = 0;

    buffer = ntsupGetSystemInfoEx(
        (SYSTEM_INFORMATION_CLASS)0xFFFFFFFF, //-V1016
        &retLen,
        (PNTSUPMEMALLOC)TestAlloc,
        (PNTSUPMEMFREE)TestFree);

    TEST_ASSERT(buffer == NULL);
    TEST_ASSERT(retLen == 0);
}

VOID HashImageSections_LoadedImage(VOID)
{
    HMODULE hMod;
    PIMAGE_NT_HEADERS nth;
    BYTE hash[NTSUPHASH_SHA256_SIZE];
    NTSTATUS status;
    SIZE_T imageSize;

    hMod = GetModuleHandle(NULL);
    TEST_ASSERT(hMod != NULL);
    if (hMod == NULL) return;

    nth = RtlImageNtHeader(hMod);
    TEST_ASSERT(nth != NULL);
    if (nth == NULL) return;

    imageSize = nth->OptionalHeader.SizeOfImage;
    RtlSecureZeroMemory(hash, sizeof(hash));

    status = ntsupHashImageSections(
        (PVOID)hMod,
        imageSize,
        hash,
        sizeof(hash),
        ImageTypeLoaded);

    TEST_ASSERT(NT_SUCCESS(status));
    if (NT_SUCCESS(status)) {
        SIZE_T i, zeroCount = 0;
        for (i = 0; i < sizeof(hash); i++)
            if (hash[i] == 0) zeroCount++;
        TEST_ASSERT(zeroCount != sizeof(hash));
    }
}

VOID HashImageSections_RawFileMapping(VOID)
{
    WCHAR path[MAX_PATH];
    HANDLE hFile, hMapping;
    LARGE_INTEGER fsz;
    PVOID mapBase;
    BYTE hash[NTSUPHASH_SHA256_SIZE];
    NTSTATUS status;

    RtlSecureZeroMemory(path, sizeof(path));
    if (!GetModuleFileName(NULL, path, MAX_PATH))
        return;

    hFile = CreateFile(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    TEST_ASSERT(hFile != INVALID_HANDLE_VALUE);
    if (hFile == INVALID_HANDLE_VALUE) return;

    fsz.LowPart = GetFileSize(hFile, (LPDWORD)&fsz.HighPart);
    TEST_ASSERT(fsz.QuadPart > 0);

    hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    TEST_ASSERT(hMapping != NULL);
    if (hMapping == NULL) {
        CloseHandle(hFile);
        return;
    }

    mapBase = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    TEST_ASSERT(mapBase != NULL);
    if (mapBase == NULL) {
        CloseHandle(hMapping);
        CloseHandle(hFile);
        return;
    }

    RtlSecureZeroMemory(hash, sizeof(hash));
    status = ntsupHashImageSections(
        mapBase,
        (SIZE_T)fsz.QuadPart,
        hash,
        sizeof(hash),
        ImageTypeRaw);

    TEST_ASSERT(NT_SUCCESS(status));

    UnmapViewOfFile(mapBase);
    CloseHandle(hMapping);
    CloseHandle(hFile);
}

VOID BuildMinimalImage(
    _Out_ PVOID* Buffer,
    _Out_ SIZE_T* BufferSize,
    _In_ BOOL ExecutableSection
)
{
    PBYTE base;
    IMAGE_DOS_HEADER* dos;
    IMAGE_NT_HEADERS64* nth;
    IMAGE_SECTION_HEADER* sh;
    SIZE_T bufSize;
    ULONG optSize;

    bufSize = 0x1000;
    *BufferSize = bufSize;
    base = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufSize);
    *Buffer = base;
    if (base == NULL) return;

    dos = (IMAGE_DOS_HEADER*)base;
    dos->e_magic = IMAGE_DOS_SIGNATURE;
    dos->e_lfanew = 0x80;

    nth = (IMAGE_NT_HEADERS64*)(base + dos->e_lfanew);
    nth->Signature = IMAGE_NT_SIGNATURE;
    nth->FileHeader.Machine = IMAGE_FILE_MACHINE_AMD64;
    nth->FileHeader.NumberOfSections = 1;
    optSize = sizeof(IMAGE_OPTIONAL_HEADER64);
    nth->FileHeader.SizeOfOptionalHeader = (WORD)optSize;
    nth->OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    nth->OptionalHeader.SectionAlignment = 0x200;
    nth->OptionalHeader.FileAlignment = 0x200;
    nth->OptionalHeader.SizeOfImage = (DWORD)bufSize;
    nth->OptionalHeader.SizeOfHeaders = 0x200;

    sh = (IMAGE_SECTION_HEADER*)((PBYTE)&nth->OptionalHeader + optSize);
    RtlCopyMemory(sh->Name, ".data", 5);
    sh->Misc.VirtualSize = 0x100;
    sh->VirtualAddress = 0x200;
    sh->SizeOfRawData = 0x200;
    sh->PointerToRawData = 0x200;
    sh->Characteristics =
        IMAGE_SCN_CNT_INITIALIZED_DATA |
        IMAGE_SCN_MEM_READ |
        (ExecutableSection ? (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE) : 0);
}

VOID HashImageSections_NoExecutableSections(VOID)
{
    PVOID image;
    SIZE_T imageSize;
    BYTE hash[NTSUPHASH_SHA256_SIZE];
    NTSTATUS status;

    image = NULL;
    imageSize = 0;
    BuildMinimalImage(&image, &imageSize, FALSE);
    TEST_ASSERT(image != NULL);
    if (image == NULL) return;

    RtlSecureZeroMemory(hash, sizeof(hash));
    status = ntsupHashImageSections(
        image,
        imageSize,
        hash,
        sizeof(hash),
        ImageTypeLoaded);

    TEST_ASSERT(status == STATUS_NOT_FOUND);

    HeapFree(GetProcessHeap(), 0, image);
}

VOID HashImageSections_ExecutableSectionPresent(VOID)
{
    PVOID image;
    SIZE_T imageSize;
    BYTE hash[NTSUPHASH_SHA256_SIZE];
    NTSTATUS status;

    image = NULL;
    imageSize = 0;
    BuildMinimalImage(&image, &imageSize, TRUE);
    TEST_ASSERT(image != NULL);
    if (image == NULL) return;

    RtlSecureZeroMemory(hash, sizeof(hash));
    status = ntsupHashImageSections(
        image,
        imageSize,
        hash,
        sizeof(hash),
        ImageTypeLoaded);

    TEST_ASSERT(NT_SUCCESS(status));

    HeapFree(GetProcessHeap(), 0, image);
}

VOID HashImageSections_InvalidParams(VOID)
{
    BYTE hash[NTSUPHASH_SHA256_SIZE];
    NTSTATUS status;
    PVOID image;
    SIZE_T imageSize;

    RtlSecureZeroMemory(hash, sizeof(hash));

    status = ntsupHashImageSections(NULL, 100, hash, sizeof(hash), ImageTypeLoaded);
    TEST_ASSERT(status == STATUS_INVALID_PARAMETER);

    status = ntsupHashImageSections(ULongToPtr(0x1), 0, hash, sizeof(hash), ImageTypeLoaded);
    TEST_ASSERT(status == STATUS_INVALID_PARAMETER);

    status = ntsupHashImageSections(ULongToPtr(0x1), 100, hash, 1, ImageTypeLoaded);
    TEST_ASSERT(status == STATUS_BUFFER_TOO_SMALL);

    image = NULL;
    imageSize = 0;
    BuildMinimalImage(&image, &imageSize, TRUE);
    if (image) {
        PIMAGE_NT_HEADERS nth = (PIMAGE_NT_HEADERS)RtlImageNtHeader(image);
        if (nth) {
            SIZE_T smaller = nth->OptionalHeader.SizeOfImage / 2;
            status = ntsupHashImageSections(
                image,
                smaller,
                hash,
                sizeof(hash),
                ImageTypeLoaded);
            TEST_ASSERT(status == STATUS_INVALID_IMAGE_FORMAT);
        }
        HeapFree(GetProcessHeap(), 0, image);
    }
}

VOID Test_WriteBufferToFile()
{
    g_FailCount = 0;
    WriteBufferToFile_WriteNewFile();
    WriteBufferToFile_AppendFile();
    WriteBufferToFile_InvalidPath();
    WriteBufferToFile_ZeroSizeWrite();

    if (g_Verbose) {
        if (g_FailCount == 0)
            DbgPrint("[TEST] ntsupWriteBufferToFile PASSED.\n");
        else
            DbgPrint("[TEST] ntsupWriteBufferToFile %lu tests FAILED.\n", g_FailCount);
    }
}

VOID Test_FindModuleNameByAddress()
{
    g_FailCount = 0;
    FindModuleNameByAddress_ValidModuleName();
    FindModuleNameByAddress_TruncatedBuffer();
    FindModuleNameByAddress_InvalidAddress();
    FindModuleNameByAddress_InvalidBufferArgs();

    if (g_Verbose) {
        if (g_FailCount == 0)
            DbgPrint("[TEST] ntsupFindModuleNameByAddress PASSED.\n");
        else
            DbgPrint("[TST] ntsupFindModuleNameByAddress %lu tests FAILED.\n", g_FailCount);
    }
}

VOID Test_GetLoadedModulesListEx()
{
    g_FailCount = 0;

    GetLoadedModulesListEx_BasicList();
    GetLoadedModulesListEx_ExtendedList();
    GetLoadedModulesListEx_NullReturnLength();
    GetLoadedModulesListEx_AllocFailure();

    if (g_Verbose) {
        if (g_FailCount == 0)
            DbgPrint("[TEST] ntsupGetLoadedModulesListEx PASSED.\n");
        else
            DbgPrint("[TEST] ntsupGetLoadedModulesListEx %lu tests FAILED.\n", g_FailCount);
    }
}

VOID Test_GetSystemInfoEx()
{
    g_FailCount = 0;

    GetSystemInfoEx_SystemProcessInformation();
    GetSystemInfoEx_NullReturnLength();
    GetSystemInfoEx_AllocFailure();
    GetSystemInfoEx_InvalidClass();

    if (g_Verbose) {
        if (g_FailCount == 0)
            DbgPrint("[TEST] ntsupGetSystemInfoEx tests PASSED.\n");
        else
            DbgPrint("[TEST] ntsupGetSystemInfoEx %lu tests FAILED.\n", g_FailCount);
    }
}

VOID Test_HashImageSections()
{
    g_FailCount = 0;

    HashImageSections_LoadedImage();
    HashImageSections_RawFileMapping();
    HashImageSections_NoExecutableSections();
    HashImageSections_ExecutableSectionPresent();
    HashImageSections_InvalidParams();

    if (g_Verbose) {
        if (g_FailCount == 0)
            DbgPrint("[TEST] ntsupHashImageSections tests PASSED.\n");
        else
            DbgPrint("[TEST] ntsupHashImageSections%lu tests FAILED.\n", g_FailCount);
    }
}
#pragma warning(pop)

```

`Source/WinObjEx64/tests/ntsup_tests.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025 UGN/HE
*
*  TITLE:       NTSUP_TESTS.H
*
*  VERSION:     2.09
*
*  DATE:        10 Aug 2025
*
*  Common header file for NTSUP test code.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

VOID Test_WriteBufferToFile();
VOID Test_FindModuleNameByAddress();
VOID Test_GetLoadedModulesListEx();
VOID Test_GetSystemInfoEx();
VOID Test_HashImageSections();

```

`Source/WinObjEx64/tests/testunit.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       TESTUNIT.C
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
*  Test code used while debug.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#define OEMRESOURCE

#include "global.h"
#include "ntos\ntldr.h"
#pragma warning(push)
#pragma warning(disable:28251) //Inconsistent annotation for any intrin, "feature" of the latest MSVC
#include <intrin.h>
#pragma warning(pop)
#include <aclapi.h>
#include "ntsup_tests.h"

HANDLE g_TestNamespace = NULL, g_TestMutex = NULL;
HANDLE g_TestMailslot = NULL;
HANDLE g_TestThread = NULL;
HANDLE g_TestPortThread = NULL;
HANDLE g_PortHandle;
PVOID g_MappedSection = NULL;
HANDLE g_SectionVaTest = NULL;
HANDLE g_ResourceManager = NULL;
HANDLE g_TestJob = NULL;

typedef struct _LPC_USER_MESSAGE {
    PORT_MESSAGE	Header;
    BYTE			Data[128];
} LPC_USER_MESSAGE, * PLPC_USER_MESSAGE;

typedef struct _QUERY_REQUEST {
    ULONG	Data;
} QUERY_REQUEST, * PQUERY_REQUEST;

#define WOBJEX_TEST_PORT L"\\Rpc Control\\WinObjEx_ServiceTestPort48429"

static ULONG g_RegFailCount = 0;
static BOOL  g_RegVerbose = TRUE;

#define REG_TEST_ASSERT(expr) do { \
    if (!(expr)) { \
        ++g_RegFailCount; \
        if (g_RegVerbose) { \
            DbgPrint("ASSERT FAILED: %s (%s:%d)\n", #expr, __FUNCTION__, __LINE__); \
        } \
    } \
} while (0)

static BOOL CreateNestedKey(
    _In_ LPCWSTR SubPath
)
{
    LONG    lRet;
    HKEY    hKey = NULL;
    DWORD   disposition = 0;

    lRet = RegCreateKeyExW(HKEY_CURRENT_USER,
        SubPath,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE | KEY_READ,
        NULL,
        &hKey,
        &disposition);

    if (hKey) RegCloseKey(hKey);
    return (lRet == ERROR_SUCCESS);
}

static BOOL KeyExists(
    _In_ HKEY Root,
    _In_ LPCWSTR SubPath
)
{
    HKEY hKey = NULL;
    LONG lRet;

    lRet = RegOpenKeyExW(Root, SubPath, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return TRUE;
    }
    return FALSE;
}

static BOOL CreateValueUnderKey(
    _In_ LPCWSTR SubPath,
    _In_ LPCWSTR ValueName,
    _In_ LPCWSTR Data
)
{
    HKEY hKey = NULL;
    LONG lRet;
    lRet = RegOpenKeyExW(HKEY_CURRENT_USER, SubPath, 0, KEY_SET_VALUE, &hKey);
    if (lRet != ERROR_SUCCESS) {
        if (!CreateNestedKey(SubPath))
            return FALSE;
        if (RegOpenKeyExW(HKEY_CURRENT_USER, SubPath, 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS)
            return FALSE;
    }
    lRet = RegSetValueExW(hKey, ValueName, 0, REG_SZ, (const BYTE*)Data, (DWORD)((wcslen(Data) + 1) * sizeof(WCHAR)));
    RegCloseKey(hKey);
    return (lRet == ERROR_SUCCESS);
}

static VOID CleanupTestRoot(
    _In_ LPCWSTR RootSubKey
)
{
    supRegDeleteKeyTree(HKEY_CURRENT_USER, (LPWSTR)RootSubKey);
}

/*
 * Test cases
 */

static VOID Test_RegDeleteKeyTree_Simple(VOID)
{
    const WCHAR* root = L"Software\\WinObjEx64Test\\RegTreeTest";
    const WCHAR* deep = L"Software\\WinObjEx64Test\\RegTreeTest\\A\\B\\C";
    BOOL created;
    BOOL removed;
    BOOL exists;

    CleanupTestRoot(root);

    created = CreateNestedKey(deep);
    REG_TEST_ASSERT(created);

    REG_TEST_ASSERT(CreateValueUnderKey(deep, L"v", L"data"));

    removed = supRegDeleteKeyTree(HKEY_CURRENT_USER, (LPWSTR)root);
    REG_TEST_ASSERT(removed);

    exists = KeyExists(HKEY_CURRENT_USER, root);
    REG_TEST_ASSERT(!exists);
}

static VOID Test_RegDeleteKeyTree_NonExistent(VOID)
{
    const WCHAR* root = L"Software\\WinObjEx64Test\\RegTreeTest_NonExist";
    BOOL removed;

    CleanupTestRoot(root);

    removed = supRegDeleteKeyTree(HKEY_CURRENT_USER, (LPWSTR)root);
    REG_TEST_ASSERT(removed);
}

static VOID Test_RegDeleteKeyTree_TrailingSlash(VOID)
{
    const WCHAR* root = L"Software\\WinObjEx64Test\\RegTreeTrail";
    const WCHAR* rootWithSlash = L"Software\\WinObjEx64Test\\RegTreeTrail\\";
    const WCHAR* deep = L"Software\\WinObjEx64Test\\RegTreeTrail\\X\\Y";
    BOOL created;
    BOOL removed;
    BOOL exists;

    CleanupTestRoot(root);

    created = CreateNestedKey(deep);
    REG_TEST_ASSERT(created);
    REG_TEST_ASSERT(CreateValueUnderKey(deep, L"v", L"vdata"));

    removed = supRegDeleteKeyTree(HKEY_CURRENT_USER, (LPWSTR)rootWithSlash);
    REG_TEST_ASSERT(removed);

    exists = KeyExists(HKEY_CURRENT_USER, root);
    REG_TEST_ASSERT(!exists);
}

static VOID Test_RegDeleteKeyTree_DeepNested(VOID)
{
    const WCHAR* base = L"Software\\WinObjEx64Test\\RegTreeDeep";
    WCHAR path[512];
    int i, depth = 20; // deep but within buffer
    BOOL created;
    BOOL removed;
    BOOL exists;

    CleanupTestRoot(base);

    _strcpy(path, base);
    for (i = 0; i < depth; ++i) {
        _strcat(path, L"\\L");
        // add index to ensure unique names if needed
        // append small numeric suffix
        WCHAR numbuf[8];
        RtlStringCchPrintfSecure(numbuf, RTL_NUMBER_OF(numbuf), L"%d", i);
        _strcat(path, numbuf);
    }

    created = CreateNestedKey(path);
    REG_TEST_ASSERT(created);
    REG_TEST_ASSERT(CreateValueUnderKey(path, L"v", L"d"));

    removed = supRegDeleteKeyTree(HKEY_CURRENT_USER, (LPWSTR)base);
    REG_TEST_ASSERT(removed);

    exists = KeyExists(HKEY_CURRENT_USER, base);
    REG_TEST_ASSERT(!exists);
}

VOID Test_RegDeleteKeyTree(VOID)
{
    g_RegFailCount = 0;

    Test_RegDeleteKeyTree_Simple();
    Test_RegDeleteKeyTree_NonExistent();
    Test_RegDeleteKeyTree_TrailingSlash();
    Test_RegDeleteKeyTree_DeepNested();

    if (g_RegVerbose) {
        if (g_RegFailCount == 0) {
            DbgPrint("[TEST] supRegDeleteKeyTree PASSED.\n");
        }
        else {
            DbgPrint("[TEST] supRegDeleteKeyTree %lu tests FAILED.\n", g_RegFailCount);
        }
    }

    // ensure cleanup of any leftover keys
    CleanupTestRoot(L"Software\\WinObjEx64Test\\RegTreeTest");
    CleanupTestRoot(L"Software\\WinObjEx64Test\\RegTreeTrail");
    CleanupTestRoot(L"Software\\WinObjEx64Test\\RegTreeDeep");
    CleanupTestRoot(L"Software\\WinObjEx64Test\\RegTreeTest_NonExist");
}

HANDLE TestGetPortHandle()
{
    return g_PortHandle;
}

typedef NTSTATUS(NTAPI* pfnNtCreateRegistryTransaction)(
    _Out_ PHANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess, //generic + TRANSACTION_*
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ DWORD Flags);

VOID TestRegistryTransaction()
{
    NTSTATUS ntStatus;
    HANDLE hObject;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usName;
    pfnNtCreateRegistryTransaction NtCreateRegistryTransaction;
    HMODULE hNtdll;

    hNtdll = GetModuleHandle(L"ntdll.dll");
    if (hNtdll) {
        NtCreateRegistryTransaction = (pfnNtCreateRegistryTransaction)GetProcAddress(hNtdll, "NtCreateRegistryTransaction");
        if (NtCreateRegistryTransaction != NULL) {
            RtlInitUnicodeString(&usName, L"\\RPC Control\\TestRegTransaction");
            InitializeObjectAttributes(&obja, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);
            ntStatus = NtCreateRegistryTransaction(&hObject, TRANSACTION_ALL_ACCESS, &obja, 0);
            if (NT_SUCCESS(ntStatus)) {
                __nop();
            }
        }
    }
}

VOID TestCreateBogusObjects()
{
    HANDLE        hTimer = NULL, hDirectory = NULL, hObject = NULL;
    LARGE_INTEGER liDueTime;
    LPWSTR lpName;
    SIZE_T l, i;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usName, usObject;

    WCHAR szBuffer[MAX_PATH + 1];

    liDueTime.QuadPart = -1000000000000LL;

    lpName = (LPWSTR)supHeapAlloc(UNICODE_STRING_MAX_BYTES);
    if (lpName) {
        _strcpy(lpName, L"\\BaseNamedObjects\\BogusLongName");
        l = _strlen(lpName);
        for (i = l; i < UNICODE_STRING_MAX_CHARS - l - 1; i++)
            lpName[i] = L't';

        RtlInitUnicodeString(&usName, lpName);
        InitializeObjectAttributes(&obja, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        NtCreateTimer(&hTimer, TIMER_ALL_ACCESS, &obja, NotificationTimer);
        if (hTimer) {
            SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, 0);
        }

        supHeapFree(lpName);
    }

    _strcpy(szBuffer, L"\\BaseNamedObjects\\BogusEmbeddedNull");
    l = _strlen(szBuffer);
    szBuffer[l++] = 0;
    szBuffer[l++] = L't';
    szBuffer[l++] = L'e';
    szBuffer[l++] = L's';
    szBuffer[l++] = L't';

    l *= 2;

    usName.Buffer = szBuffer;
    usName.Length = (USHORT)l;
    usName.MaximumLength = usName.Length + sizeof(UNICODE_NULL);

    InitializeObjectAttributes(&obja, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    NtCreateTimer(&hTimer, TIMER_ALL_ACCESS, &obja, NotificationTimer);
    if (hTimer) SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, 0);

    _strcpy(szBuffer, L"\\RPC Control\\BogusEmbeddedNull");
    l = _strlen(szBuffer);
    szBuffer[l++] = 0;
    szBuffer[l++] = L't';
    szBuffer[l++] = L'e';
    szBuffer[l++] = L's';
    szBuffer[l++] = L't';

    l *= 2;

    usName.Buffer = szBuffer;
    usName.Length = (USHORT)l;
    usName.MaximumLength = usName.Length + sizeof(UNICODE_NULL);
    if (NT_SUCCESS(NtCreateDirectoryObject(&hDirectory, DIRECTORY_ALL_ACCESS, &obja))) {
        RtlInitUnicodeString(&usName, L"SomeTimer");
        obja.RootDirectory = hDirectory;
        if (NT_SUCCESS(NtCreateTimer(&hTimer, TIMER_ALL_ACCESS,
            &obja, NotificationTimer)))
        {
            if (hTimer) SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, 0);
        }
    }

    _strcpy(szBuffer, L"SurpriseDirectory");
    l = _strlen(szBuffer);
    szBuffer[l++] = 0;
    szBuffer[l++] = L't';
    szBuffer[l++] = L'e';
    szBuffer[l++] = L's';
    szBuffer[l++] = L't';
    szBuffer[l++] = 0;
    szBuffer[l++] = L'h';
    szBuffer[l++] = L'a';
    szBuffer[l++] = 0;
    szBuffer[l++] = 0;
    szBuffer[l++] = L'h';
    szBuffer[l++] = L'a';
    l *= 2;

    usName.Buffer = szBuffer;
    usName.Length = (USHORT)l;
    usName.MaximumLength = usName.Length + sizeof(UNICODE_NULL);
    obja.RootDirectory = hDirectory;
    if (NT_SUCCESS(NtCreateDirectoryObject(&hDirectory, DIRECTORY_ALL_ACCESS, &obja))) {
        RtlInitUnicodeString(&usObject, L"SurpriseTimer");
        obja.RootDirectory = hDirectory;
        obja.ObjectName = &usObject;
        if (NT_SUCCESS(NtCreateTimer(&hTimer, TIMER_ALL_ACCESS,
            &obja, NotificationTimer)))
        {
            if (hTimer) SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, 0);

            RtlInitUnicodeString(&usObject, L"\\RPC Control\\TestLink");
            InitializeObjectAttributes(&obja, &usObject, OBJ_CASE_INSENSITIVE, NULL, NULL);

            _strcpy(szBuffer, L"\\RPC Control\\BogusEmbeddedNull");
            l = _strlen(szBuffer);
            szBuffer[l++] = 0;
            szBuffer[l++] = L't';
            szBuffer[l++] = L'e';
            szBuffer[l++] = L's';
            szBuffer[l++] = L't';
            l *= 2;

            usName.Length = (USHORT)l;
            usName.MaximumLength = usName.Length + sizeof(UNICODE_NULL);

            NtCreateSymbolicLinkObject(&hObject, SYMBOLIC_LINK_ALL_ACCESS, &obja, &usName);

        }
    }
}

DWORD WINAPI LPCListener(LPVOID lpThreadParameter)
{
    NTSTATUS Status;
    LPC_USER_MESSAGE UserMessage;
    PQUERY_REQUEST QueryRequest;

    UNICODE_STRING PortName = RTL_CONSTANT_STRING(WOBJEX_TEST_PORT);
    OBJECT_ATTRIBUTES ObjectAttributes;

    HANDLE ConnectPort;

    UNREFERENCED_PARAMETER(lpThreadParameter);

    InitializeObjectAttributes(&ObjectAttributes, &PortName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtCreatePort(&g_PortHandle,
        &ObjectAttributes,
        0,
        sizeof(LPC_USER_MESSAGE),
        0);

    if (!NT_SUCCESS(Status)) {
        ExitThread(0);
    }

    do {

        RtlSecureZeroMemory(&UserMessage, sizeof(UserMessage));
        if (!NT_SUCCESS(NtListenPort(g_PortHandle, &UserMessage.Header)))
            break;

        ConnectPort = NULL;
        if (!NT_SUCCESS(NtAcceptConnectPort(&ConnectPort,
            NULL,
            &UserMessage.Header,
            TRUE,
            NULL,
            NULL)))
        {
            break;
        }

        if (NT_SUCCESS(NtCompleteConnectPort(ConnectPort))) {

            __try {

                RtlSecureZeroMemory(&UserMessage, sizeof(UserMessage));
                NtReplyWaitReceivePort(ConnectPort, NULL, NULL, &UserMessage.Header);

                QueryRequest = (PQUERY_REQUEST)&UserMessage.Data;
                kdDebugPrint("Data=%lx", QueryRequest->Data);
                if (QueryRequest->Data == 1)
                    break;

            }
            __except (WOBJ_EXCEPTION_FILTER_LOG) {
                __nop();
            }

        }

        NtClose(ConnectPort);

    } while (TRUE);

    NtClose(g_PortHandle);

    ExitThread(0);
}

VOID TestApiPort(
    VOID
)
{
    g_TestPortThread = supCreateThread((LPTHREAD_START_ROUTINE)LPCListener, NULL, 0);
}

VOID TestDebugObject(
    VOID
)
{
    HANDLE hObject = NULL;
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    ustr = RTL_CONSTANT_STRING(L"\\BaseNamedObjects\\TestDebugObject");

    InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtCreateDebugObject(&hObject, DEBUG_ALL_ACCESS, &obja, 0);
    if (NT_SUCCESS(status)) {
        __nop();
    }
}

VOID TestMailslot(
    VOID
)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    ustr = RTL_CONSTANT_STRING(L"\\Device\\Mailslot\\TestMailslot");
    IO_STATUS_BLOCK iost;
    LARGE_INTEGER readTimeout;
    PSID pEveryoneSID = NULL, pAdminSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea[2];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

    do {

        //Everyone - GENERIC_READ
        if (!AllocateAndInitializeSid(&SIDAuthWorld, 1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pEveryoneSID)) break;

        RtlSecureZeroMemory(&ea, 2 * sizeof(EXPLICIT_ACCESS));
        ea[0].grfAccessPermissions = GENERIC_READ;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName = (LPTSTR)pEveryoneSID;

        //Admin - GENERIC_ALL
        if (!AllocateAndInitializeSid(&SIDAuthNT, 2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pAdminSID)) break;

        ea[1].grfAccessPermissions = GENERIC_ALL;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance = NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName = (LPTSTR)pAdminSID;

        SetEntriesInAcl(2, ea, NULL, &pACL);

        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,
            SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (pSD == NULL)
            break;

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
            break;

        if (!SetSecurityDescriptorDacl(
            pSD,
            TRUE,
            pACL,
            FALSE))
        {
            break;
        }

        readTimeout.HighPart = 0x7FFFFFFF;
        readTimeout.LowPart = 0xFFFFFFFF;

        InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, pSD);
        status = NtCreateMailslotFile(&g_TestMailslot,
            GENERIC_READ | SYNCHRONIZE | WRITE_DAC,
            &obja,
            &iost,
            FILE_CREATE,
            0,
            0,
            &readTimeout);
        if (NT_SUCCESS(status)) {
            __nop();
        }

    } while (FALSE);

    if (pAdminSID) FreeSid(pAdminSID);
    if (pEveryoneSID) FreeSid(pEveryoneSID);
    if (pSD) LocalFree(pSD);
}

VOID TestPartition(
    VOID
)
{
    HANDLE TargetHandle = NULL;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    ustr = RTL_CONSTANT_STRING(L"\\KernelObjects\\MemoryPartition0");

    if (g_ExtApiSet.NtOpenPartition != NULL) {

        InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);
        g_ExtApiSet.NtOpenPartition(&TargetHandle, MEMORY_PARTITION_QUERY_ACCESS, &obja);

    }
}

VOID TestIoCompletion(
    VOID
)
{
    HANDLE hCompletion = NULL;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    ustr = RTL_CONSTANT_STRING(L"\\BaseNamedObjects\\TestIoCompletion");

    //IoCompletion
    InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    NtCreateIoCompletion(&hCompletion, IO_COMPLETION_ALL_ACCESS, &obja, 100);
}

VOID TestTimer(
    VOID
)
{
    HANDLE        hTimer = NULL;
    LARGE_INTEGER liDueTime;

    liDueTime.QuadPart = -1000000000000LL;

    hTimer = CreateWaitableTimer(NULL, TRUE, L"Global\\TestTimer");
    if (hTimer) {
        SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, 0);
    }
}

VOID TestTransactionResourceManager(
    VOID
)
{
    HANDLE hObject = NULL;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usName;
    GUID tmp;

    InitializeObjectAttributes(&obja, NULL, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(NtCreateTransactionManager(&hObject,
        TRANSACTIONMANAGER_ALL_ACCESS,
        &obja,
        NULL,
        TRANSACTION_MANAGER_VOLATILE,
        0)))
    {
        if (S_OK == CoCreateGuid(&tmp)) {
            RtlInitUnicodeString(&usName, L"\\BaseNamedObjects\\TestRm");
            obja.ObjectName = &usName;
            if (NT_SUCCESS(NtCreateResourceManager(&g_ResourceManager,
                RESOURCEMANAGER_ALL_ACCESS,
                hObject,
                &tmp,
                &obja,
                RESOURCE_MANAGER_VOLATILE,
                NULL)))
            {
                __nop();
            }
        }
    }
}

VOID TestTransaction(
    VOID
)
{
    HANDLE hObject;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    ustr = RTL_CONSTANT_STRING(L"\\BaseNamedObjects\\TestTransaction");

    //TmTx
    InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    NtCreateTransaction(&hObject, TRANSACTION_ALL_ACCESS, &obja, NULL, NULL, 0, 0, 0, NULL, NULL);
}

VOID TestPrivateNamespace(
    VOID
)
{
    DWORD               LastError = 0;
    HANDLE              hBoundaryDescriptor = NULL, hBoundaryDescriptor2 = NULL;
    BYTE                localSID[SECURITY_MAX_SID_SIZE];
    DWORD               cbSID = sizeof(localSID);
    PSID                pLocalAdminSID = &localSID;
    PSID                pMediumILSID = &localSID;
    PSID                pWorldSid = &localSID;
    SECURITY_ATTRIBUTES sa;

    HANDLE hNamespace2, hMutex, hMutex2;

    NTSTATUS Status;

    OBJECT_ATTRIBUTES   obja;
    UNICODE_STRING      pnAlias = RTL_CONSTANT_STRING(L"NamespaceAlias");
    UNICODE_STRING      bdName1 = RTL_CONSTANT_STRING(L"TestBoundaryDescriptor1");
    UNICODE_STRING      bdName2 = RTL_CONSTANT_STRING(L"TestBoundaryDescriptor2");
    UNICODE_STRING      MutexName;

    do {
        RtlSecureZeroMemory(&localSID, sizeof(localSID));
        hBoundaryDescriptor = RtlCreateBoundaryDescriptor(&bdName1, 0);

        if (hBoundaryDescriptor == NULL) {
            break;
        }
        if (!CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, pLocalAdminSID, &cbSID)) {
            break;
        }
        if (!NT_SUCCESS(RtlAddSIDToBoundaryDescriptor(&hBoundaryDescriptor, pLocalAdminSID))) {
            break;
        }
        cbSID = sizeof(localSID);
        if (!CreateWellKnownSid(WinWorldSid, NULL, pWorldSid, &cbSID)) {
            break;
        }
        if (!NT_SUCCESS(RtlAddSIDToBoundaryDescriptor(&hBoundaryDescriptor, pWorldSid))) {
            break;
        }
        cbSID = sizeof(localSID);
        if (!CreateWellKnownSid(WinMediumLabelSid, NULL, pMediumILSID, &cbSID)) {
            break;
        }
        if (!NT_SUCCESS(RtlAddIntegrityLabelToBoundaryDescriptor(&hBoundaryDescriptor, pMediumILSID))) {
            break;
        }

        RtlSecureZeroMemory(&sa, sizeof(sa));
        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
            TEXT("D:(A;;GA;;;BA)"),
            SDDL_REVISION_1,
            &sa.lpSecurityDescriptor,
            NULL))
        {
            break;
        }

        g_TestNamespace = CreatePrivateNamespace(&sa, hBoundaryDescriptor, TEXT("NamespaceAlias"));
        LastError = GetLastError();
        LocalFree(sa.lpSecurityDescriptor);
        RtlDeleteBoundaryDescriptor(hBoundaryDescriptor);
        hBoundaryDescriptor = NULL;

        if (g_TestNamespace == NULL) {
            break;
        }
        g_TestMutex = CreateMutex(NULL, FALSE, TEXT("NamespaceAlias\\TestMutex"));

        //        hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT("NamespaceAlias\\TestMutex"));
          //      if (hMutex) 
            //        CloseHandle(hMutex);


        RtlInitUnicodeString(&MutexName, TEXT("TestMutex"));
        InitializeObjectAttributes(&obja, &MutexName, OBJ_CASE_INSENSITIVE, g_TestNamespace, NULL);

        Status = NtOpenMutant(&hMutex, MUTANT_ALL_ACCESS, &obja);
        if (NT_SUCCESS(Status))
            NtClose(hMutex);

        //SECOND, checking another portion of MSDN bullshit.

        RtlSecureZeroMemory(&localSID, sizeof(localSID));
        hBoundaryDescriptor2 = RtlCreateBoundaryDescriptor(&bdName2, 0);

        if (hBoundaryDescriptor2 == NULL) {
            break;
        }

        cbSID = sizeof(localSID);
        if (!CreateWellKnownSid(WinWorldSid, NULL, pLocalAdminSID, &cbSID)) {
            break;
        }
        /*  if (!NT_SUCCESS(RtlAddSIDToBoundaryDescriptor(&hBoundaryDescriptor2, pLocalAdminSID))) {
              break;
          }*/

        RtlSecureZeroMemory(&sa, sizeof(sa));
        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
            TEXT("D:(A;;GA;;;BA)"),
            SDDL_REVISION_1,
            &sa.lpSecurityDescriptor,
            NULL))
        {
            break;
        }

        InitializeObjectAttributes(&obja, &pnAlias, OBJ_CASE_INSENSITIVE, NULL, sa.lpSecurityDescriptor);

        Status = NtCreatePrivateNamespace(
            &hNamespace2,
            MAXIMUM_ALLOWED,
            &obja,
            hBoundaryDescriptor2);

        //hNamespace2 = CreatePrivateNamespace(&sa, hBoundaryDescriptor2, TEXT("NamespaceAlias"));
        //LastError = GetLastError();
        LocalFree(sa.lpSecurityDescriptor);
        RtlDeleteBoundaryDescriptor(hBoundaryDescriptor2);
        hBoundaryDescriptor2 = NULL;

        if ((!NT_SUCCESS(Status)) || (hNamespace2 == NULL)) {
            break;
        }

        hMutex = CreateMutex(NULL, FALSE, TEXT("NamespaceAlias\\TestMutex"));

        hMutex2 = OpenMutex(MUTEX_ALL_ACCESS, FALSE, L"NamespaceAlias\\TestMutex");
        if (hMutex2) CloseHandle(hMutex2);

    } while (FALSE);

    if (hBoundaryDescriptor) RtlDeleteBoundaryDescriptor(hBoundaryDescriptor);
}

VOID TestException(
    _In_ BOOL bNaked
)
{
    if (bNaked)
        *(PBYTE)(NULL) = 0;
    else {

        __try {
            *(PBYTE)(NULL) = 0;
        }
        __except (WOBJ_EXCEPTION_FILTER_LOG)
        {
            __nop();
        }
    }
}

VOID TestJob()
{
    UINT i;
    WCHAR szBuffer[MAX_PATH + 1];

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    g_TestJob = CreateJobObject(NULL, L"Global\\TestJob");
    if (g_TestJob) {

        for (i = 0; i < 9; i++) {

            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
            ExpandEnvironmentStrings(L"%ComSpec%", szBuffer, MAX_PATH);

            si.cb = sizeof(si);
            GetStartupInfo(&si);

            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_HIDE;

            if (CreateProcess(
                szBuffer,
                NULL,
                NULL,
                NULL,
                FALSE,
                0,
                NULL,
                NULL,
                &si,
                &pi))
            {
                AssignProcessToJobObject(g_TestJob, pi.hProcess);
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
        }
    }
}

VOID TestPsObjectSecurity(
    _In_ BOOL bThread)
{
    DWORD dwErr;
    PACL EmptyDacl;
    HANDLE hObject;

    if (bThread)
        hObject = GetCurrentThread();
    else
        hObject = GetCurrentProcess();

    EmptyDacl = (PACL)supHeapAlloc(sizeof(ACL));
    if (EmptyDacl) {

        if (!InitializeAcl(
            EmptyDacl,
            sizeof(ACL),
            ACL_REVISION))
        {
            dwErr = GetLastError();
        }
        else {

            dwErr = SetSecurityInfo(hObject,
                SE_KERNEL_OBJECT,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                EmptyDacl,
                NULL);
        }

        if (dwErr != ERROR_SUCCESS)
            __nop();

        supHeapFree(EmptyDacl);
    }
}

VOID TestDesktop(
    VOID
)
{
    HANDLE hDesktop;
    DWORD LastError = 0;

    hDesktop = CreateDesktop(TEXT("TestDesktop"), NULL, NULL, 0,
        DESKTOP_CREATEWINDOW | DESKTOP_SWITCHDESKTOP, NULL);

    if (hDesktop == NULL) {
        LastError = GetLastError();
        if (LastError != 0)
            __nop();
    }
}

DWORD WINAPI TokenImpersonationThreadProc(PVOID Parameter)
{

    ULONG i = 0;
    HANDLE hToken;

    UNREFERENCED_PARAMETER(Parameter);

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
        if (!ImpersonateLoggedOnUser(hToken))
            __nop();
        CloseHandle(hToken);
    }

    do {
        Sleep(1000);
        kdDebugPrint("WinObjEx64 test thread, %lu\r\n", GetCurrentThreadId());
        i += 1;
    } while (i < 1000);

    if (!RevertToSelf())
        __nop();
    ExitThread(0);
}

VOID TestThread()
{
    g_TestThread = supCreateThread((LPTHREAD_START_ROUTINE)TokenImpersonationThreadProc, NULL, 0);
}

VOID TestApiSetResolve()
{
    ULONG i;
    PVOID Data = NtCurrentPeb()->ApiSetMap;

    NTSTATUS Status;

    UNICODE_STRING ApiSetLibrary;
    UNICODE_STRING ParentLibrary;
    UNICODE_STRING ResolvedHostLibrary;

    LPWSTR ToResolve[] = {
        L"hui-ms-win-core-app-l1-2-3.dll",
        L"api-ms-win-nevedomaya-ebanaya-hyinua-l1-1-3.dll",
        L"api-ms-win-core-appinit-l1-1-0.dll",
        L"api-ms-win-core-com-private-l1-2-0",
        L"ext-ms-win-fs-clfs-l1-1-0.dll",
        L"ext-ms-win-core-app-package-registration-l1-1-1",
        L"ext-ms-win-shell-ntshrui-l1-1-0.dll",
        NULL,
        L"api-ms-win-core-psapi-l1-1-0.dll",
        L"api-ms-win-core-enclave-l1-1-1.dll",
        L"api-ms-onecoreuap-print-render-l1-1-0.dll",
        L"api-ms-win-deprecated-apis-advapi-l1-1-0.dll",
        L"api-ms-win-core-com-l2-1-1"
    };

    if (Data == NULL) {
        kdDebugPrint("APISET>>ApiSetMap is NULL\r\n");
        return;
    }

    for (i = 0; i < RTL_NUMBER_OF(ToResolve); i++) {

        RtlInitUnicodeString(&ApiSetLibrary, ToResolve[i]);
        RtlInitEmptyUnicodeString(&ResolvedHostLibrary, NULL, 0);

        Status = NtRawApiSetResolveLibrary(Data,
            &ApiSetLibrary,
            NULL,
            &ResolvedHostLibrary);

        if (NT_SUCCESS(Status)) {
            kdDebugPrint("APISET>> %wZ\r\n", &ResolvedHostLibrary);
            RtlFreeUnicodeString(&ResolvedHostLibrary);
        }
        else {
            kdDebugPrint("APISET>> NtRawApiSetResolveLibrary failed 0x%lx for %wZ\r\n", Status, &ApiSetLibrary);
        }
    }

    RtlInitUnicodeString(&ParentLibrary, L"kernel32.dll");
    RtlInitUnicodeString(&ApiSetLibrary, L"api-ms-win-core-processsecurity-l1-1-0.dll");

    Status = NtRawApiSetResolveLibrary(Data,
        &ApiSetLibrary,
        &ParentLibrary,
        &ResolvedHostLibrary);

    if (NT_SUCCESS(Status)) {
        kdDebugPrint("APISET>> Resolved apiset %wZ\r\n", &ResolvedHostLibrary);
        RtlFreeUnicodeString(&ResolvedHostLibrary);
    }
    else {
        kdDebugPrint("NtRawApiSetResolveLibrary failed 0x%lx\r\n", Status);
    }
}

BOOL CALLBACK EnumerateSLValueDescriptorCallback(
    _In_ SL_KMEM_CACHE_VALUE_DESCRIPTOR* CacheDescriptor,
    _In_opt_ PVOID Context
)
{
    WCHAR* EntryName;
    CHAR* EntryType;

    UNREFERENCED_PARAMETER(Context);

    EntryName = (PWCHAR)supHeapAlloc(CacheDescriptor->NameLength + sizeof(WCHAR));
    if (EntryName) {

        RtlCopyMemory(EntryName, CacheDescriptor->Name, CacheDescriptor->NameLength);

        switch (CacheDescriptor->Type) {
        case SL_DATA_SZ:
            EntryType = "SL_DATA_SZ";
            break;
        case SL_DATA_DWORD:
            EntryType = "SL_DATA_DWORD";
            break;
        case SL_DATA_BINARY:
            EntryType = "SL_DATA_BINARY";
            break;
        case SL_DATA_MULTI_SZ:
            EntryType = "SL_DATA_MULTI_SZ";
            break;
        case SL_DATA_SUM:
            EntryType = "SL_DATA_SUM";
            break;

        default:
            EntryType = "Unknown";
        }

        kdDebugPrint("%ws, %s\r\n", EntryName, EntryType);
        supHeapFree(EntryName);

    }
    return FALSE;
}

VOID TestLicenseCache()
{
    PVOID CacheData = supSLCacheRead();
    if (CacheData) {
        supSLCacheEnumerate(CacheData, EnumerateSLValueDescriptorCallback, NULL);
        supHeapFree(CacheData);
    }
}

WCHAR* g_szMapDlls[] = {
    L"\\??\\C:\\build\\temp\\win7pc\\test.dll",
    L"\\systemroot\\system32\\winnsi.dll",
    L"\\systemroot\\system32\\sxssrv.dll",
    L"\\systemroot\\system32\\sppwinob.dll",
    L"\\systemroot\\system32\\Microsoft.Bluetooth.Proxy.dll",
    L"\\systemroot\\system32\\ddp_ps.dll",
    L"\\systemroot\\system32\\BitsProxy.dll",
    L"\\systemroot\\system32\\xboxgipsynthetic.dll" //does not have VERSION_INFO
};

wchar_t* Tstp_filename(const wchar_t* f)
{
    wchar_t* p = (wchar_t*)f;

    if (f == 0)
        return 0;

    while (*f != (wchar_t)0) {
        if (*f == (wchar_t)'\\')
            p = (wchar_t*)f + 1;
        f++;
    }
    return p;
}

VOID TestSectionControlArea()
{
    NTSTATUS ntStatus;

    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING ustr;
    HANDLE sectionHandle;
    SIZE_T commitSize = PAGE_SIZE;
    PVOID baseAddress = NULL;
    LARGE_INTEGER liSectionSize;

    WCHAR szText[] = TEXT("This is text in our VA space");

    RtlInitUnicodeString(&ustr, L"\\BaseNamedObjects\\TestSectionVa");
    InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);

    liSectionSize.QuadPart = commitSize;

    ntStatus = NtCreateSection(&sectionHandle,
        SECTION_ALL_ACCESS,
        &obja,
        &liSectionSize,
        PAGE_READWRITE,
        SEC_COMMIT,
        NULL);

    if (NT_SUCCESS(ntStatus)) {

        if (NT_SUCCESS(NtMapViewOfSection(sectionHandle,
            NtCurrentProcess(),
            &baseAddress,
            0,
            commitSize,
            NULL,
            &commitSize,
            ViewUnmap,
            MEM_TOP_DOWN,
            PAGE_READWRITE)))
        {
            RtlCopyMemory(baseAddress, szText, sizeof(szText));
            g_MappedSection = baseAddress;
            g_SectionVaTest = sectionHandle;
        }
        else {

            NtClose(sectionHandle);
        }
    }
}

VOID TestSectionImage()
{
    OBJECT_ATTRIBUTES obja, dirObja;
    UNICODE_STRING ustr;
    IO_STATUS_BLOCK iost;

    NTSTATUS ntStatus;

    LPWSTR lpFileName;
    HANDLE sectionHandle = NULL, dirHandle = NULL, fileHandle = NULL;

    RtlInitUnicodeString(&ustr, L"\\RPC Control\\TestSectionImage");
    InitializeObjectAttributes(&dirObja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ntStatus = NtCreateDirectoryObject(&dirHandle, DIRECTORY_ALL_ACCESS, &dirObja);

    if (NT_SUCCESS(ntStatus)) {

        dirObja.RootDirectory = dirHandle;

        for (ULONG i = 0; i < RTL_NUMBER_OF(g_szMapDlls); i++) {

            RtlInitUnicodeString(&ustr, g_szMapDlls[i]);
            InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);

            ntStatus = NtOpenFile(&fileHandle,
                SYNCHRONIZE | FILE_EXECUTE,
                &obja,
                &iost,
                FILE_SHARE_READ | FILE_SHARE_DELETE,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

            if (NT_SUCCESS(ntStatus)) {

                lpFileName = (LPWSTR)Tstp_filename(g_szMapDlls[i]);

                RtlInitUnicodeString(&ustr, lpFileName);

                ntStatus = NtCreateSection(&sectionHandle,
                    SECTION_ALL_ACCESS,
                    &dirObja,
                    NULL,
                    PAGE_EXECUTE,
                    SEC_IMAGE,
                    fileHandle);

                if (NT_SUCCESS(ntStatus)) {
                    kdDebugPrint("Mapped\r\n");
                }
            }
        }
    }
}

/*

COMPATIBILITY WARNING:

DOES NOT PRESENT IN WIN7

*/

VOID TestShadowDirectory()
{
    OBJECT_ATTRIBUTES dirObja, obja;
    UNICODE_STRING ustr;
    HANDLE dirHandle, shadowDirHandle, testHandle, testHandle2;
    NTSTATUS ntStatus;

    //
    // Open BaseNamedObjects handle.
    //

    RtlInitUnicodeString(&ustr, L"\\BaseNamedObjects");
    InitializeObjectAttributes(&dirObja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ntStatus = NtOpenDirectoryObject(&shadowDirHandle, DIRECTORY_QUERY | DIRECTORY_TRAVERSE, &dirObja);

    if (NT_SUCCESS(ntStatus)) {

        //
        // Create test object (mutant) in \\BaseNamedObjects.
        //
        RtlInitUnicodeString(&ustr, L"TestObject");
        InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, shadowDirHandle, NULL);
        ntStatus = NtCreateMutant(&testHandle, MUTANT_ALL_ACCESS, &obja, FALSE);
        if (NT_SUCCESS(ntStatus)) {

            //
            // Create BaseNamedObjects\\New directory with shadow set to \\BaseNamedObjects
            //
            RtlInitUnicodeString(&ustr, L"\\BaseNamedObjects\\New");
            ntStatus = NtCreateDirectoryObjectEx(&dirHandle, DIRECTORY_ALL_ACCESS, &dirObja, shadowDirHandle, 0);
            if (NT_SUCCESS(ntStatus)) {

                //
                // Open "TestObject" in \\BaseNamedObjects\\New, 
                // since "New" has shadow set to \\BaseNamedObjects Windows will lookup this object first in shadow.
                //
                RtlInitUnicodeString(&ustr, L"\\BaseNamedObjects\\New\\TestObject");
                obja.RootDirectory = NULL;
                ntStatus = NtOpenMutant(&testHandle2, MUTANT_ALL_ACCESS, &obja);
                if (NT_SUCCESS(ntStatus)) {
                    __nop();
                }
            }
        }
        NtClose(shadowDirHandle);
    }
}

VOID TestAlpcPortOpen()
{
    HANDLE hObject = NULL;
    NTSTATUS ntStatus;
    UNICODE_STRING usName;

    RtlInitUnicodeString(&usName, WOBJEX_TEST_PORT);

    ntStatus = supOpenPortObjectByName(&hObject,
        PORT_ALL_ACCESS,
        &usName);

    if (NT_SUCCESS(ntStatus)) {
        NtClose(hObject);
    }
    else {
        kdDebugPrint("supOpenPortObjectByName failed with NTSTATUS 0x%lX", (ULONG)ntStatus);
    }
}

VOID PreHashTypes()
{
    ObManagerTest();
}

VOID TestSymbols()
{
    BOOL bStatus;
    ULONG dummy, i, j;
    ULONG64 var;
    PSYM_ENTRY pSymEntry;
    PSYMCONTEXT Context;
    PSYMPARSER SymParser;

    LPCWSTR testSymbols[] = {
        L"_POOL_TYPE",
        L"_RTL_USER_PROCESS_PARAMETERS",
        L"_PEB",
        L"INVALID_NOT_EXIST",
        L"_UNICODE_STRING",
        L"_STRING",
        L"_GDI_TEB_BATCH",
        L"_CONTROL_AREA",
        L"_IO_STATUS_BLOCK"
    };

    SYM_CHILD* pSymChild;

    WCHAR* pStrEnd;
    WCHAR* pOutput;

    if (!kdIsSymAvailable((PSYMCONTEXT)g_kdctx.NtOsSymContext))
        return;

    pOutput = (WCHAR*)supHeapAlloc(4 * MAX_SYM_NAME);
    if (pOutput == NULL)
        return;

    Context = (PSYMCONTEXT)g_kdctx.NtOsSymContext;
    if (Context) {

        SymParser = &Context->Parser;

        //
        // Test parser 
        // N.B. This is not fully functional dumper with fancy decorations.
        //

        for (i = 0; i < RTL_NUMBER_OF(testSymbols); i++) {
            pSymEntry = SymParser->DumpSymbolInformation(Context,
                testSymbols[i],
                &bStatus);

            if (pSymEntry == NULL) {
                _strcpy(pOutput, L"\r\n->");
                _strcat(pOutput, testSymbols[i]);
                _strcat(pOutput, L"<- failed to dump\r\n");
                OutputDebugStringW(pOutput);

            }
            else {

                _strcpy(pOutput, TEXT("\r\n"));
                _strcat(pOutput, pSymEntry->Name);
                _strcat(pOutput, TEXT("\r\n"));

                OutputDebugStringW(pOutput);

                for (j = 0; j < pSymEntry->ChildCount; j++) {

                    pOutput[0] = 0;

                    pSymChild = &pSymEntry->ChildEntries[j];

                    RtlStringCchPrintfSecure(&pOutput[0],
                        (MAX_SYM_NAME + 32) * 2,
                        TEXT("/* 0x%04lx: */\t%ws %ws"),
                        pSymChild->Offset,
                        pSymChild->TypeName,
                        pSymChild->Name);

                    pStrEnd = _strend(pOutput);

                    if (pSymChild->ElementsCount > 1) {

                        RtlStringCchPrintfSecure(pStrEnd,
                            32,
                            TEXT("[%llu]"),
                            pSymChild->ElementsCount);

                        pStrEnd = _strend(pOutput);

                    }

                    if (pSymChild->IsValuePresent) {

                        RtlStringCchPrintfSecure(pStrEnd,
                            32,
                            TEXT(" = %llu"),
                            pSymChild->Value);
                        pStrEnd = _strend(pOutput);
                    }

                    _strcat(pStrEnd, TEXT(";"));

                    if (pSymChild->IsBitField) {

                        pStrEnd = _strcat(pStrEnd, TEXT(" /* bit position: "));
                        ultostr(pSymChild->BitPosition, pStrEnd);
                        _strcat(pStrEnd, TEXT(" */"));
                        pStrEnd = _strend(pStrEnd);
                    }

                    _strcat(pStrEnd, TEXT("\r\n"));

                    OutputDebugStringW(pOutput);

                }

                supHeapFree(pSymEntry);
            }
        }

        dummy = SymParser->GetFieldOffset(Context,
            L"_EPROCESS",
            L"UniqueProcessId",
            &bStatus);

        if (bStatus) {

            DbgPrint("sym offset %lx\r\n", dummy);

        }

        var = 0;
        if (kdGetAddressFromSymbol(
            &g_kdctx,
            TEXT("ObHeaderCookie"),
            &var))
        {
            DbgPrint("ObHeaderCookie %p\r\n", (PVOID)var);
        }

    }

    supHeapFree(pOutput);
}

#include <wtsapi32.h>
#pragma comment(lib, "Wtsapi32.lib")

VOID TestSessions()
{
    DWORD sessionsCount, i;
    WTS_SESSION_INFO* pSessions;

    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,
        0,
        1,
        &pSessions,
        &sessionsCount))
    {
        for (i = 0; i < sessionsCount; i++) {
            kdDebugPrint("Session %lu: %ws\n", pSessions[i].SessionId, pSessions[i].pWinStationName);
        }
        WTSFreeMemory(pSessions);
    }
}

VOID TestCmControlVector()
{
    union {
        union {
            CM_SYSTEM_CONTROL_VECTOR_V1* v1;
            CM_SYSTEM_CONTROL_VECTOR_V2* v2;
        } Version;
        PBYTE Ref;
    } CmControlVector;

    SIZE_T size;

    CmControlVector.Ref = (PBYTE)kdQueryCmControlVector(&g_kdctx);

    if (g_NtBuildNumber >= NT_WIN10_REDSTONE4)
        size = sizeof(CM_SYSTEM_CONTROL_VECTOR_V2);
    else
        size = sizeof(CM_SYSTEM_CONTROL_VECTOR_V1);


    while (CmControlVector.Version.v1->KeyPath != NULL) {

        OutputDebugString(CmControlVector.Version.v1->KeyPath);
        OutputDebugString(L"\r\n");
        OutputDebugString(CmControlVector.Version.v1->ValueName);
        OutputDebugString(L"\r\n============\r\n");

        CmControlVector.Ref += size;
    }
}

VOID TestCall()
{
}

VOID TestObCallback()
{
    struct {
        ULONG Value1;
        ULONG Value2;
        HANDLE Pid1;
        HANDLE Pid2;
        BYTE Spare[392];
    } request;

    NTSTATUS ntStatus;
    DWORD procId1 = 3448;

    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\ImfObCallback"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle != INVALID_HANDLE_VALUE) {

        ntStatus = supCallDriver(deviceHandle,
            0x22200C,
            NULL,
            0,
            NULL,
            0);

        if (NT_SUCCESS(ntStatus)) {

            RtlSecureZeroMemory(&request, sizeof(request));
            request.Pid1 = UlongToHandle(procId1);
            request.Pid2 = NULL;

            ntStatus = supCallDriver(deviceHandle,
                0x222008,
                &request,
                sizeof(request),
                NULL,
                0);

        }

        CloseHandle(deviceHandle);
    }
}

VOID TestDefineDosDevice()
{
    DefineDosDevice(DDD_RAW_TARGET_PATH, L"$y$tem", L"\\systemroot\\system32");
    DefineDosDevice(DDD_RAW_TARGET_PATH, L"hfiref0x", L"hfiref0x");
}

VOID TestStart(
    VOID
)
{
    //TestCall();
    //TestRegistryTransaction();
    //TestTransactionResourceManager();
    //TestCreateBogusObjects();
    //TestCmControlVector();
    //TestObCallback();
    //TestSectionControlArea();
    //TestSymbols();
    //TestSectionImage();
    //TestShadowDirectory();
    //TestPsObjectSecurity();
    //TestLicenseCache();
    //TestApiSetResolve();
    //TestDesktop();
    //TestApiPort();
    //TestAlpcPortOpen();
    //TestDebugObject();
    //TestMailslot();
    //TestPartition();
    //TestPrivateNamespace();
    //TestIoCompletion();
    //TestTimer();
    //TestTransaction();
    //TestSessions();
    //TestThread();
    PreHashTypes();
    //TestJob();
    //TestDefineDosDevice();
    Test_WriteBufferToFile();
    Test_FindModuleNameByAddress();
    Test_GetLoadedModulesListEx();
    Test_GetSystemInfoEx();
    Test_HashImageSections();
    //Test_RegDeleteKeyTree();
}

VOID TestStop(
    VOID
)
{
    if (g_TestMutex != NULL) {
        CloseHandle(g_TestMutex);
    }
    if (g_TestNamespace != NULL) {
        ClosePrivateNamespace(g_TestNamespace, PRIVATE_NAMESPACE_FLAG_DESTROY);
    }
    if (g_TestMailslot) {
        NtClose(g_TestMailslot);
    }
    if (g_TestJob) {
        TerminateJobObject(g_TestJob, 0);
        NtClose(g_TestJob);
    }

    if (g_TestThread) {
        TerminateThread(g_TestThread, 0);
        CloseHandle(g_TestThread);
    }
    if (g_TestPortThread) {
        TerminateThread(g_TestPortThread, 0);
        CloseHandle(g_TestPortThread);
    }
    if (g_MappedSection) {
        NtUnmapViewOfSection(NtCurrentProcess(), g_MappedSection);
    }
    if (g_SectionVaTest)
        NtClose(g_SectionVaTest);
}

```

`Source/WinObjEx64/tests/testunit.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2022
*
*  TITLE:       TESTUNIT.H
*
*  VERSION:     2.00
*
*  DATE:        19 Jun 2022
*
*  Common header file for test code.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

VOID TestStart(VOID);
VOID TestStop(VOID);
VOID TestException(_In_ BOOL bNaked);
HANDLE TestGetPortHandle();

#ifdef _DEBUG
#define BeginTests() TestStart()
#define EndTests() TestStop()
#else
#define BeginTests()
#define EndTests()
#endif

```

`Source/WinObjEx64/ui.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2026
*
*  TITLE:       UI.H
*
*  VERSION:     2.10
*
*  DATE:        10 Feb 2026
*
*  Common header file for the user interface.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#define SplitterSize                3
#define SplitterMargin              80

#define DefaultSystemDpi            96

#define SCALE_DPI_VALUE(Value, CurrentDPI) MulDiv(Value, CurrentDPI, DefaultSystemDpi)

#define TreeListDumpObjWndPosX      12
#define TreeListDumpObjWndPosY      20
#define TreeListDumpObjWndScaleSub  3


//
// Main ListView column count
//
#define MAIN_OBJLIST_COLUMN_COUNT 3

typedef	struct _OE_LIST_ITEM {
    struct _OE_LIST_ITEM *Prev;
    HTREEITEM TreeItem;
} OE_LIST_ITEM, *POE_LIST_ITEM;

typedef HWND(WINAPI *pfnHtmlHelpW)(
    _In_opt_ HWND hwndCaller,
    _In_ LPCWSTR pszFile,
    _In_ UINT uCommand,
    _In_ DWORD_PTR dwData
    );

#define PROGRAM_MAJOR_VERSION       2
#define PROGRAM_MINOR_VERSION       1
#define PROGRAM_REVISION_NUMBER     0
#define PROGRAM_BUILD_NUMBER        2602

#ifdef _USE_OWN_DRIVER
#define PROGRAM_NAME            L"Windows Object Explorer 64-bit (Non-public version)"
#else 
#define PROGRAM_NAME            L"Windows Object Explorer 64-bit"
#endif
#define PROGRAM_NAME_AND_TITLE  L"Object Explorer for Windows 7/8/8.1/10/11"
#define WINOBJEX64_WNDCLASS     L"WinObjEx64Class"
#define WINOBJEX64_PSLISTCLASS  L"WinObjEx64PsListClass"

#define T_COPY_OBJECT_NAME      L"Copy Name"
#define T_COPY_OBJECT_NAME_BIN  L"Copy Name (Binary)"

#define T_PROPERTIES            L"Properties...\tEnter"
#define T_GOTOLINKTARGET        L"Go To Link Target\tCtrl+->"
#define T_VIEWSD                L"View Security Descriptor..."
#define T_RUNASADMIN            L"R&un as Administrator"
#define T_RUNASSYSTEM           L"R&un as LocalSystem"
#define T_EXPORTTOFILE          L"Export List"
#define T_JUMPTOFILE            L"Jump to File"
#define T_VIEW_REFRESH          L"Refresh\tF5"
#define T_VIEW_PLUGINS          L"View Plugins"
#define T_EMPTY                 L" "
#define T_MSG_SETTINGS_CHANGE   L"wobjSettingsChange"

#define T_CSV_FILE_FILTER       TEXT("CSV Files\0*.csv\0\0")
#define T_LIST_EXPORT_SUCCESS   TEXT("List export - OK")
#define T_RICHEDIT_LIB          TEXT("RICHED32.DLL")

#define MAX_TEXT_CONVERSION_ULONG64 32

//
// Main menu initialization id's
//

// File
#define IDMM_FILE   0

// View
#define IDMM_VIEW   1

// Object
#define IDMM_OBJECT 2

// Find
#define IDMM_FIND   3

// Extras
#define IDMM_EXTRAS 4

// Help
#define IDMM_HELP   5

typedef struct _TL_SUBITEMS_FIXED {
    ULONG       Count;
    ULONG       ColorFlags;
    COLORREF    BgColor;
    COLORREF    FontColor;
    PVOID       UserParam;
    LPTSTR      CustomTooltip;
    LPTSTR      Text[2];
} TL_SUBITEMS_FIXED, *PTL_SUBITEMS_FIXED;

typedef struct _VALUE_DESC {
    LPWSTR lpDescription;
    DWORD dwValue;
} VALUE_DESC, *PVALUE_DESC;

typedef struct _LVCOLUMNS_DATA {
    LPWSTR Name;
    INT Width;
    INT Format;
    INT ImageIndex;
} LVCOLUMNS_DATA, *PLVCOLUMNS_DATA;

//
// Constants
//
// 
// Display simple "N/A" if no info available
#define T_CannotQuery       TEXT("N/A")
#define T_NotAssigned       T_CannotQuery

// Value is not defined
#define T_None              TEXT("None")
#define T_NoneValue         TEXT("(None)")

// Value is invalid
#define T_Invalid           TEXT("Invalid")
#define T_InvalidValue      TEXT("(Invalid)")

// Display for unknown type value
#define T_UnknownType       TEXT("Unknown Type")

// Display for unknown flag value
#define T_UnknownFlag       TEXT("Unknown Flag")

// Display for unknown process
#define T_UnknownProcess    TEXT("Unknown Process")

// Display for unknown value
#define T_Unknown           TEXT("Unknown")

// Empty string
#define T_EmptyString       TEXT("")

// prop used by sheets
#define T_PROPCONTEXT       TEXT("propContext")

// prop used by prop dialog
#define T_DLGCONTEXT        TEXT("dlgContext")

// prop used by ipc dialogs
#define T_IPCDLGCONTEXT     TEXT("IpcDlgContext")

#define INIT_NO_ERROR               0
#define INIT_ERROR_NOCRT            1
#define INIT_ERROR_NOHEAP           2
#define INIT_ERROR_NOTEMP           3
#define INIT_ERROR_NOWINDIR         4
#define INIT_ERROR_NOSYS32DIR       5
#define INIT_ERROR_NOPROGDIR        6
#define INIT_ERROR_NOCLASS          7
#define INIT_ERROR_NOMAINWND        8
#define INIT_ERROR_NOICCX           9
#define INIT_ERROR_NOLISTWND        10
#define INIT_ERROR_NOTREEWND        11
#define INIT_ERROR_NOTLBARWND       12
#define INIT_ERROR_NOSPLITTERWND    13
#define INIT_ERROR_UNSPECIFIED      14

#define T_WOBJINIT_NOCRT TEXT("Could not initialize CRT, abort")

#define ErrShadowWin32kNotFound             1
#define ErrShadowMemAllocFail               2
#define ErrShadowWin32uLoadFail             3
#define ErrShadowWin32kLoadFail             4
#define ErrShadowApiSetNotFound             5
#define ErrShadowW32pServiceLimitNotFound   6
#define ErrShadowWin32uMismatch             7
#define ErrShadowW32pServiceTableNotFound   8
#define ErrShadowApiSetSchemaVerUnknown     9
#define ErrShadowWin32kGlobalsNotFound      10
#define ErrShadowWin32kOffsetNotFound       11
#define ErrShadowWin32kGetStateNotFound     12

//
// Common Dialog handlers.
//
VOID FindDlgCreate(
    VOID);

VOID ShowSysInfoDialog(
    _In_ HWND hwndParent);

VOID SDViewDialogCreate(
    _In_ WOBJ_OBJECT_TYPE ObjectType);

INT_PTR CALLBACK AboutDialogProc(
    _In_ HWND hwndDlg,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);

VOID ShowStatsDialog(
    VOID);

```

`Source/WinObjEx64_Plugins.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30803.129
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ApiSetView", "Plugins\ApiSetView\ApiSetView.vcxproj", "{72BF2A8F-E7AE-467F-B00F-1C51F1C3D2C8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ExamplePlugin", "Plugins\ExamplePlugin\ExamplePlugin.vcxproj", "{7C10DDD2-E88A-4133-B140-80679BE8AFDD}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ImageScope", "Plugins\ImageScope\ImageScope.vcxproj", "{38D717F0-9152-4B74-8D32-5222373EAB3E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Sonar", "Plugins\Sonar\Sonar.vcxproj", "{91A5250B-99D2-48F9-B649-82D66C9A6396}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{72BF2A8F-E7AE-467F-B00F-1C51F1C3D2C8}.Debug|x64.ActiveCfg = Debug|x64
		{72BF2A8F-E7AE-467F-B00F-1C51F1C3D2C8}.Debug|x64.Build.0 = Debug|x64
		{72BF2A8F-E7AE-467F-B00F-1C51F1C3D2C8}.Release|x64.ActiveCfg = Release|x64
		{72BF2A8F-E7AE-467F-B00F-1C51F1C3D2C8}.Release|x64.Build.0 = Release|x64
		{7C10DDD2-E88A-4133-B140-80679BE8AFDD}.Debug|x64.ActiveCfg = Debug|x64
		{7C10DDD2-E88A-4133-B140-80679BE8AFDD}.Debug|x64.Build.0 = Debug|x64
		{7C10DDD2-E88A-4133-B140-80679BE8AFDD}.Release|x64.ActiveCfg = Release|x64
		{7C10DDD2-E88A-4133-B140-80679BE8AFDD}.Release|x64.Build.0 = Release|x64
		{38D717F0-9152-4B74-8D32-5222373EAB3E}.Debug|x64.ActiveCfg = Debug|x64
		{38D717F0-9152-4B74-8D32-5222373EAB3E}.Debug|x64.Build.0 = Debug|x64
		{38D717F0-9152-4B74-8D32-5222373EAB3E}.Release|x64.ActiveCfg = Release|x64
		{38D717F0-9152-4B74-8D32-5222373EAB3E}.Release|x64.Build.0 = Release|x64
		{91A5250B-99D2-48F9-B649-82D66C9A6396}.Debug|x64.ActiveCfg = Debug|x64
		{91A5250B-99D2-48F9-B649-82D66C9A6396}.Debug|x64.Build.0 = Debug|x64
		{91A5250B-99D2-48F9-B649-82D66C9A6396}.Release|x64.ActiveCfg = Release|x64
		{91A5250B-99D2-48F9-B649-82D66C9A6396}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C0DEFB87-8F58-4650-8008-3113A0E0969F}
	EndGlobalSection
EndGlobal

```

`appveyor.yml`:

```yml
version: 1.0.{build}
branches:
  only:
  - master
skip_tags: true
image: Visual Studio 2022
configuration: Release
platform: x64
shallow_clone: true
clone_folder: c:\projects\winobjex64

build_script:
- cmd: msbuild Source\WinObjEx64.sln /m /verbosity:normal /p:Configuration=Release /p:Platform=x64 /p:PlatformToolset=v143

artifacts:
- path: Source\WinObjEx64\output\x64\Release\bin\WinObjEx64.exe
  name: WinObjEx64

```