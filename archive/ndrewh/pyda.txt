Project Path: arc_ndrewh_pyda_jo8k6ug0

Source Tree:

```txt
arc_ndrewh_pyda_jo8k6ug0
├── CMakeLists.txt
├── Dockerfile
├── LICENSE
├── README.md
├── bin
│   ├── pyda
│   └── pyda-attach
├── docs
│   ├── README.md
│   ├── mkdocs.yml
│   ├── pages
│   │   ├── advanced-usage
│   │   │   ├── attaching.md
│   │   │   └── inline.md
│   │   ├── api
│   │   │   ├── exceptions.md
│   │   │   └── process.md
│   │   ├── getting-started
│   │   │   ├── installation.md
│   │   │   └── quickstart.md
│   │   ├── index.md
│   │   └── quick-reference.md
│   └── requirements.txt
├── examples
│   ├── cmplog.py
│   ├── heap.py
│   ├── ltrace.py
│   ├── ltrace_macos.py
│   ├── ltrace_multithreaded.py
│   ├── resolve_indirect_calls.py
│   ├── simple.py
│   └── strace.py
├── lib
│   └── pyda
│       ├── __init__.py
│       ├── arch.py
│       ├── base.py
│       ├── compiler.py
│       ├── hacks
│       │   ├── gdb.py
│       │   ├── pls_no_signal.py
│       │   ├── pwndbg_compat.py
│       │   └── signal.py
│       ├── proc.py
│       └── tube.py
├── patches
│   ├── dynamorio-10.0.patch
│   ├── dynamorio-11.2.patch
│   ├── dynamorio-bf5c900f575976ba145616b25337e3266ecaea3a-macos.patch
│   ├── make_patches.sh
│   └── wine_tls_fix_11.2.patch
├── pyda_core
│   ├── CMakeLists.txt
│   ├── include
│   │   ├── privload.h
│   │   ├── pyda_compiler.h
│   │   ├── pyda_core.h
│   │   ├── pyda_core_py.h
│   │   ├── pyda_threads.h
│   │   └── pyda_util.h
│   ├── linux
│   │   └── pyda_threads_linux.c
│   ├── macos
│   │   ├── macho.c
│   │   └── pyda_threads_macos.c
│   ├── pyda_compiler.c
│   ├── pyda_core.c
│   ├── pyda_core_py.c
│   ├── pyda_patch_python.c
│   ├── pyda_threads.c
│   ├── pyda_unwind.c
│   └── tool.c
├── pyproject.toml
├── setup.py
└── tests
    ├── builder1.py
    ├── err_hook.py
    ├── err_invalidhook.py
    ├── err_norun.py
    ├── err_thread_entry.py
    ├── eval
    │   ├── malloc1.c
    │   ├── malloc1000.c
    │   ├── malloc100000.c
    │   ├── malloc1000000.c
    │   ├── malloccount_libdebug.py
    │   ├── malloccount_pyda.py
    │   └── run_eval.py
    ├── run_tests.py
    ├── simple.c
    ├── simple2.c
    ├── test_blocking1.py
    ├── test_blocking2.py
    ├── test_blocking3.py
    ├── test_blocking4.py
    ├── test_call.c
    ├── test_call.py
    ├── test_fork.c
    ├── test_hugeio.c
    ├── test_hugeio.py
    ├── test_io.c
    ├── test_io1.py
    ├── test_io2.py
    ├── test_longrunning.c
    ├── test_longrunning_multithread.c
    ├── test_pwntools.py
    ├── test_python_threading.py
    ├── test_regs_x86.py
    ├── test_segv.c
    ├── test_segv.py
    ├── test_syscall.py
    ├── test_thread_blocking.py
    ├── thread_10.c
    ├── thread_1000.c
    └── thread_nojoin.c

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

project(dynamorio_python VERSION 0.4.1)

add_subdirectory(pyda_core)

```

`Dockerfile`:

```
FROM ubuntu:22.04

RUN apt update && DEBIAN_FRONTEND=noninteractive apt install -y wget python3.10-full python3.10-dev build-essential cmake gdbserver gdb tmux zsh git \
      cmake g++ doxygen git zlib1g-dev libunwind-dev libsnappy-dev liblz4-dev \
      build-essential gdb lcov pkg-config \
      curl && \
      rm -rf /var/lib/apt/lists/*

RUN curl -sS https://bootstrap.pypa.io/get-pip.py | python3.10
RUN echo '#!/bin/bash\npython3.10 -m pip "$@"' > /usr/local/bin/pip3 && \
    chmod +x /usr/local/bin/pip3

# Install pwndbg + pwntools
WORKDIR /tmp
RUN git clone https://github.com/pwndbg/pwndbg.git && \
    cd pwndbg && git checkout cada600b0f2be0e2873465f59cc9c4c31425951a && \
    sed -i 's/signal.signal/__import__("pls_no_signal").signal/' pwndbg/__init__.py && \
    pip3 install -e . && \
    pip3 install pwntools

ARG PYDA_DEBUG=0

# install dynamorio
COPY patches/dynamorio-11.2.patch /tmp
COPY patches/wine_tls_fix_11.2.patch /tmp
RUN git clone --recurse-submodules -j4 https://github.com/DynamoRIO/dynamorio.git /opt/dynamorio && cd /opt/dynamorio/ && git checkout release_11.2.0  && \
      cd /opt/dynamorio/ && \
      wget https://github.com/DynamoRIO/dynamorio/commit/f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch && git apply f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch && rm f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch && git submodule update --init && \
      wget https://github.com/DynamoRIO/dynamorio/commit/c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch && git apply c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch && rm c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch && \
      wget https://github.com/DynamoRIO/dynamorio/commit/8c997f483b564f2408553b718a5707e28c9be820.patch && git apply 8c997f483b564f2408553b718a5707e28c9be820.patch && rm 8c997f483b564f2408553b718a5707e28c9be820.patch && \
      wget https://github.com/DynamoRIO/dynamorio/commit/572f3b1484fda1fbc502fad298939756cd72f3ae.patch && git apply 572f3b1484fda1fbc502fad298939756cd72f3ae.patch && rm 572f3b1484fda1fbc502fad298939756cd72f3ae.patch && \
      git apply /tmp/dynamorio-11.2.patch && \
      git apply /tmp/wine_tls_fix_11.2.patch && \
      rm /tmp/*.patch && \
      mkdir /opt/dynamorio-install/ && \
      mkdir build && cd build && bash -c 'cmake -DDEBUG=$([ "$PYDA_DEBUG" == "1" ] && echo "ON" || echo "OFF") -DCMAKE_INSTALL_PREFIX=/opt/dynamorio-install/ -DBUILD_TESTS=OFF -DBUILD_SAMPLES=OFF -DBUILD_CLIENTS=OFF -DBUILD_DOCS=OFF ..' && \
      make -j && make install && \
      rm -rf /opt/dynamorio/ && \
      touch /opt/dynamorio-install/CMakeCache.txt

ENV DYNAMORIO_HOME=/opt/dynamorio-install/
ENV PYTHONPATH=/opt/pyda/lib

COPY ./ /opt/pyda/
WORKDIR /opt/pyda
RUN mkdir build && cd build && \
      bash -c 'CMAKE_PREFIX_PATH=/opt/dynamorio/build/cmake cmake -DCMAKE_BUILD_TYPE=$([ "$PYDA_DEBUG" == "1" ] && echo "Debug" || echo "Release") -DDynamoRIO_DIR=$DYNAMORIO_HOME/cmake ..' && \
      make -j

ENV PATH=$PATH:/opt/pyda/bin
ENV PYDA_TOOL_PATH=/opt/pyda/build/pyda_core/libtool.so

WORKDIR /opt/pyda

ARG PYDA_GEF=0
RUN bash -c 'if [[ "$PYDA_GEF" = "1" ]]; then \
    apt update && apt install -y file; \
    PYTHONPATH= PYTHONHOME= bash -c "$(wget https://raw.githubusercontent.com/hugsy/gef/main/scripts/gef.sh -O -)"; \
    fi'

ARG EVAL=0
RUN bash -c 'if [[ "$EVAL" = "1" ]]; then \
    apt update && apt install -y python3 python3-dev libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg; \
    pip3 install libdebug; \
    fi'


```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Andrew Haberlandt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

CPython available under the PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2,
duplicated below. Dynamorio is available primarily under the BSD
license, duplicated below.

===========================================================================

PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
--------------------------------------------

1. This LICENSE AGREEMENT is between the Python Software Foundation
("PSF"), and the Individual or Organization ("Licensee") accessing and
otherwise using this software ("Python") in source or binary form and
its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python alone or in any derivative version,
provided, however, that PSF's License Agreement and PSF's notice of copyright,
i.e., "Copyright (c) 2001-2024 Python Software Foundation; All Rights Reserved"
are retained in Python alone or in any derivative version prepared by Licensee.

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python.

4. PSF is making Python available to Licensee on an "AS IS"
basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any
relationship of agency, partnership, or joint venture between PSF and
Licensee.  This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote
products or services of Licensee, or any third party.

8. By copying, installing or otherwise using Python, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.

===========================================================================
Primary DynamoRIO License: BSD

All of DynamoRIO except certain portions called out in subsequent sections
on this page is licensed under the following BSD license:

Copyright (c) 2010-2024 Google, Inc. licensed under the terms of the BSD.  All other rights reserved.

Copyright (c) 2000-2009 VMware, Inc. licensed under the terms of the BSD.  All other rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of VMware, Inc. nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

===========================================================================
libelftc License

The drsyms Extension contains libelftc code
(http://elftoolchain.sourceforge.net/) in binary form for obtaining file
and line information from DWARF2 debug information on Linux and
Cygwin/MinGW.  That libelftc code has the following copyright and license:

Copyright (c) 2006-2012 Kai Wang, Joseph Koshy, et al.
Copyright (c) 1990-2005 The Regents of the University of California, et al.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

===========================================================================
Certain Extensions are instead under the LGPL 2.1 License

The drwrap and drutil Extensions, along with Dr. Memory and all of its
libraries in the Dr. Memory Framework (if packaged with DynamoRIO), are
licensed under the LGPL 2.1 License and NOT the BSD license used for the
rest of DynamoRIO.  These Extensions are provided as libraries distinct
from the rest of DynamoRIO.  The details of this license are below:

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation;
version 2.1 of the License, and no later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

===========================================================================
The drsyms Extension is linked with elfutils libraries under the LGPL 3 License

The drsyms Extension on Linux is linked with static libraries from the
elfutils project.  The source code for elfutils is available at
git://sourceware.org/git/elfutils.git.  We choose the LGPL 3 license
(elfutils offers that as a choice) for our use of these libraries.  The
drsyms Extension and the elfutils static libraries are provided as
libraries distinct from the rest of DynamoRIO.  The details of the LGPL 3
license are below:

                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

===========================================================================
The valgrind.h and memcheck.h files in third_party/valgrind/ are also BSD
but with 4 clauses:

  Copyright (C) 2000-2013 Julian Seward.  All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. The origin of this software must not be misrepresented; you must
      not claim that you wrote the original software.  If you use this
      software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   3. Altered source versions must be plainly marked as such, and must
      not be misrepresented as being the original software.

   4. The name of the author may not be used to endorse or promote
      products derived from this software without specific prior written
      permission.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

===========================================================================

```

`README.md`:

```md
Pyda
====

Pyda lets you write dynamic binary analysis tools using Python.

Pyda combines [Dynamorio](https://dynamorio.org)-based instrumentation with a CPython interpreter, allowing you to
"inject" Python code into any x86/ARM64 Linux process, without
going through GDB or ptrace.

Features:
- **Hooks**: Inspect and modify registers
and memory at any instruction.
- **Redirect execution**: Hooks can directly modify the program
counter; for example, to cause a function to return early or to
skip over a tricky branch.
- **Syscall interception**: Syscall pre/post hooks can capture and modify syscall
arguments, and optionally skip the syscall altogether.
- **Package support**: Install and use your favorite packages like
normal using `pip` (e.g. pwntools).
- **Graceful multithreading**: Writing tools for multithreaded programs is easy:
program threads *share* a Python interpreter[*](#multithreading), so you can use globals to
track and aggregate state over several threads (see: [`p.tid`](#api)).


Pyda is a...
- **In-process, scriptable debugger**: Pyda hooks can be used as GDB-style breakpoints
to inspect/modify registers and memory. Several packages (e.g. pwntools) can be used
to look up symbols or parse DWARF info.
- **Reverse engineering tool**: Answer questions like "Where do all these indirect jumps go?" in just a few lines of Python.
- **CTF Tool**: We provide a pwntools-style API for I/O (a Pyda `Process` is actually a pwntools `tube`!), and
new "blocking" APIs like `p.run_until(pc)` which allow you to interleave execution and I/O.

#### Quickstart

Run the `ltrace.py` example on `ls -al`:

```sh
docker run -it ghcr.io/ndrewh/pyda pyda examples/ltrace.py -- ls -al
```

## Example
> [!WARNING]
> This API is not stable and may change. Please provide
> feedback on the API by filing an issue.

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

# Get a handle to the current process
p = process()

# You can use pwnlib to get information about the target ELF
e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

# Define a hook/breakpoint -- this can be at any instruction
def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

# Register the hook
p.hook(e.symbols["main"], main_hook)

# Tell Pyda we are ready to go!
p.run()
```

```
$ pyda examples/simple.py -- ./challenge 
at main, rsp=0x7fff1303f078
return address: 0x7f3c50420d90
```


### More examples
See [examples/](examples/) for additional examples.

- [`ltrace.py`](examples/ltrace.py): Hook all calls to library functions, and print out their arguments
- [`strace.py`](examples/strace.py): Hook all syscalls and print out their arguments
- [`cmplog.py`](examples/cmplog.py): Hook all `cmp` instructions and print out their arguments
- [`resolve_indirect_calls.py`](examples/resolve_indirect_calls.py): dump a list of indirect calls with `objdump`, and then
print out the targets during execution


## Limitations
- Currently Linux/macOS only (please contribute Windows support!)
- Currently X86_64/ARM64 only (please contribute support for other architectures)
- All of the limitations of Dynamorio apply. (The program must be reasonably well behaved. You should assume a sufficiently motivated program can detect whether it is running under Dynamorio.)
- Some state may be shared with the target process; while Dynamorio
attempts to isolate our libc (and other libraries) from the target, OS structures (e.g. fds)
are shared.

## Getting Started

### Installation

Check out the [docs](https://ndrewh.github.io/pyda/getting-started/installation/) for installation instructions.

### API

See the [Quick Reference](https://ndrewh.github.io/pyda/quick-reference).

You can view all of the available APIs in [process.py](https://github.com/ndrewh/pyda/blob/master/lib/pyda/process.py), or [in the docs](https://ndrewh.github.io/pyda/api/process).

### FAQ

**Why should I use this over GDB or other ptrace-based debuggers?** 

Pyda gives you many of the same capabilities as a debugger, with some key differences (which may or may not matter to you):
- You can use whatever Python packages you're already familiar with to manipulate program state (e.g. pwntools)
- Your instrumentation runs in the same process as the program you're debugging -- making it faster if you have
a lot of breakpoints or need to access a lot of data (you're in the same address space!).
- Multithreaded programs do not halt all threads when one thread enters a hook (see: ptrace ["group stop"](https://man7.org/linux/man-pages/man2/ptrace.2.html))
- For advanced users, you can even [inline your instrumentation](https://ndrewh.github.io/pyda/advanced-usage/inline)

**Why should I use this over Frida or other dynamic instrumentation tools?**

These tools are quite similar to Pyda, with mostly ergonomic differences: Pyda tools
are written in Python using a relatively minimal set of [APIs](#api). Pyda relies on the existing Python ecosystem for many features (e.g. ELF parsing).
As a result, Pyda tools are typically shorter and easier to write than equivalent Frida scripts.

However, Pyda is **not** (currently) an adequate replacement for full-fledged dynamic instrumentation
frameworks. We do not provide a fine-grained instrumentation API (e.g.
you cannot insert specific instructions), relying instead on hooks
as the primary unit of instrumentation.

**Can I use `LD_LIBRARY_PATH` on the target?**

Generally, yes. Just
run `pyda` with `LD_LIBRARY_PATH` -- the target uses a normal loader.

**Can I run this tool on itself?**

Probably not. But you ***can*** run the Python interpreter under it.
```
$ pyda <script> -- python3
Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
```

**Can my scripts parse arguments?**

Yes. Script arguments can be passed before
the `--` when running `pyda`. For example:
```sh
pyda script.py --option1 --option2 -- ls
```

Your script can parse these options like normal
with the `argparse` module.

## How it works

Pyda runs as a [Dynamorio](https://dynamorio.org) tool: `pyda` is just a `drrun` wrapper that runs the application under dynamorio with our tool loaded. Technically,
Pyda is "just" a shared object that links against `libPython`---both of which get loaded into the target process by Dynamorio. However, Dynamorio is designed to support
_targets_ which load the same libraries as required by _tools_ (i.e., by including it's own [private loader](https://dynamorio.org/using.html) for tools).
As you might imagine, it gets a bit messy to run CPython under a nonstandard loader,
and we had to include nontrivial patches for both Dynamorio and CPython to make it all work.
There were also issues with the ["Client Transparency"](https://dynamorio.org/transparency.html)
aspects of Dynamorio: in particular, our tool's threads reside in a different process group than the target itself
(despite residing in the same memory space). This causes problems
with certain concurrency primatives (e.g. `sem_init`/`sem_wait`) that rely on threads being in the same process group.

Dynamorio handles many of the nasty low-level details: inserting instrumentation, machine state trasitions to/from hooks, etc. Pyda provides
a CPython extension for registering hooks and proxies machine state modifications to Dynamorio. Pyda itself ends up handling
a lot of edge cases (think: hooks which throw exceptions, hooks which remove themselves, hooks which redirect execution, etc.) and nasty error states,
especially surrounding thread creation and cleanup.

## Contributing

Issues and pull requests are welcome. If reporting an issue with a particular target, please attach the binary.


```

`bin/pyda`:

```
#!/bin/bash

if [[ -z "${PYDA_TOOL_PATH}" ]]; then
    echo "PYDA_TOOL_PATH is not set."
    exit 1
fi

export PYTHONEXECUTABLE=$(which python3)

PYDA_NO_ATTACH=1 ASAN_OPTIONS=$ASAN_OPTIONS:detect_leaks=0 LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PYTHONHOME/lib/ PYDA_SCRIPT=$1 exec $DYNAMORIO_HOME/bin64/drrun -no_reachable_client -vm_size 1G -stack_size 1024K -private_loader -c $PYDA_TOOL_PATH ${@:2}

```

`bin/pyda-attach`:

```
#!/bin/bash

if [[ -z "${PYDA_TOOL_PATH}" ]]; then
    echo "PYDA_TOOL_PATH is not set."
    exit 1
fi

export PYTHONEXECUTABLE=$(which python3)

PYDA_NO_CAPTURE=1 LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PYTHONHOME/lib/ exec $DYNAMORIO_HOME/bin64/drrun -attach $2 -stack_size 1024K -c $PYDA_TOOL_PATH -script $1

```

`docs/README.md`:

```md
# Pyda Documentation

This directory contains the documentation for Pyda, built using [MkDocs](https://www.mkdocs.org/) with the [Material theme](https://squidfunk.github.io/mkdocs-material/).

## Building the Documentation

### Prerequisites

Install the documentation dependencies:

```bash
pip install -r requirements.txt
```

### Local Development

To serve the documentation locally with live reload:

```bash
mkdocs serve
```

This will start a local server at `http://127.0.0.1:8000` where you can preview the documentation. Changes to markdown files will automatically reload the page.

### Building Static Site

To build the static HTML files:

```bash
mkdocs build
```

The built site will be in the `site/` directory.

## Documentation Structure

- `mkdocs.yml` - Main configuration file
- `index.md` - Homepage
- `getting-started/` - Installation and quick start guides
- `api/` - API reference documentation (auto-generated from docstrings)
- `examples/` - Code examples and tutorials

## API Documentation

The API documentation is automatically generated from docstrings in the source code using [mkdocstrings](https://mkdocstrings.github.io/). When you update docstrings in the Python source files, the documentation will automatically reflect those changes.

## GitHub Actions

The documentation is automatically built and deployed via GitHub Actions:

- **Build**: Runs on every push and pull request
- **Deploy**: Automatically deploys to GitHub Pages on pushes to main/master
- **Artifacts**: Creates downloadable zip/tarball archives of the built site

## Contributing

When contributing to the documentation:

1. Test locally with `mkdocs serve`
2. Ensure all links work and code examples are correct
3. Follow the existing style and structure
4. Update docstrings in the source code for API changes

The documentation uses Google-style docstrings. See the existing code for examples. 
```

`docs/mkdocs.yml`:

```yml
site_name: Pyda Documentation
site_description: Dynamic binary analysis tools using Python
site_url: https://ndrewh.github.io/pyda

repo_name: ndrewh/pyda
repo_url: https://github.com/ndrewh/pyda
docs_dir: pages

theme:
  name: material
  palette:
    - scheme: default
      primary: indigo
      accent: indigo
      toggle:
        icon: material/brightness-7
        name: Switch to dark mode
    - scheme: slate
      primary: indigo
      accent: indigo
      toggle:
        icon: material/brightness-4
        name: Switch to light mode
  features:
    - navigation.tabs
    - navigation.sections
    - navigation.top
    - search.highlight
    - search.share
    - content.code.copy

plugins:
  - search
  - mkdocstrings:
      handlers:
        python:
          paths: [../lib/]
          options:
            show_source: true
            show_root_heading: true
            show_root_toc_entry: false
            docstring_style: google
            merge_init_into_class: true
            show_signature_annotations: true

nav:
  - Home: index.md
  - Getting Started:
    - Installation: getting-started/installation.md
    - Quick Start: getting-started/quickstart.md
  - Quick Reference: quick-reference.md
  - Advanced Usage:
    - Attaching to a running process: advanced-usage/attaching.md
    - Inline instrumentation: advanced-usage/inline.md
  - API Reference:
    - Process: api/process.md
    - Exceptions: api/exceptions.md

markdown_extensions:
  - admonition
  - pymdownx.details
  - pymdownx.superfences
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.inlinehilite
  - pymdownx.snippets
  - toc:
      permalink: true 

```

`docs/pages/advanced-usage/attaching.md`:

```md
# Attaching to a running process

`pyda-attach` allows you to attach to an already running process.

!!! info
    `pyda-attach` is currently only supported on Linux.

```bash
pyda-attach <script_path> <pid>
```

!!! warning
    pyda-attach needs permission to attach to the target process via ptrace.

!!! warning
    Due to some internal details of DynamoRIO, `pyda-attach` writes to a temporary file in your $HOME directory.
    **This file must be accessible to the process you are attaching to (even if that process may be running as a different user).**
    
    You may be inclined to run as `sudo` (to ensure the ptrace attach will succeed) but your $HOME may not be accessible
    by the target process when running under `sudo`. In this case, set the $HOME manually to some directory that the target
    can access.


```

`docs/pages/advanced-usage/inline.md`:

```md
# Inline instrumentation

Some hooks can be made into "builder hooks". Builder hooks only run when needed to "build" instrumentation,
and do not actually run for every execution like regular hooks.

Builder hooks must be branchless, and all state modifications must go through `b.load` and `b.store`, or `b.regs.xxx`.

Since builder hooks are not called for every execution, modifying Python globals in your hook
is nonsensical. The `Global` class can be used to wrap any ctypes integral or array type to provide
access to global state.

These hooks have much better performance than normal hooks, since they do not incur
the python calling overhead. Instead, your instrumentation is "compiled" to run inline with the
program's code.

Currently, we do not provide a "select" operation that would allow you to emulate `if` statements. Creative
instrumenters can probably make do without it, but hopefully it will be added eventually.

## Example: Modify a register value

```python3
def lib_hook(p):
    # This function will only be called ~once, even if the instrumentation point
    # is reached thousands of times! Still, the register will be updated every time.
    p.regs.rdi += 1337

p.builder_hook(e.address + 0x1056, lib_hook)
p.run()
```


## Example: Count the number of times a particular pc is reached

```python3
counter = Global(ctypes.c_long(0))

def lib_hook(b):
    counter.val += 1

p.builder_hook(e.address + 0x1056, lib_hook)
p.run()

print(counter.val)
```

## Example: Record register values in a circular buffer

```python3
counter = Global(ctypes.c_long(0))
buf = Global((ctypes.c_long * 0x1000)())

def lib_hook(b):
    counter.val += 1
    buf[counter % 4] = 5

p.builder_hook(e.address + 0x1056, lib_hook)
p.run()

print(buf.val)
```

## Example: Insert arbitrary assembly code

```python3
from pwn import asm

code = asm("nop", arch="amd64")

def lib_hook(b):
    b.raw(code)

p.builder_hook(e.address + 0x1056, lib_hook)
p.run()
```



```

`docs/pages/api/exceptions.md`:

```md
# Exceptions

Pyda defines several custom exceptions for different error conditions:

- **MemoryError**: Raised when memory operations fail
- **ThreadExitError**: Raised when a thread exits while waiting for I/O
- **InvalidStateError**: Raised when operations are performed in invalid states
- **FatalSignalError**: Raised when the target process receives a fatal signal

These exceptions are imported from the `pyda_core` module and provide detailed information about error conditions during analysis. 

```

`docs/pages/api/process.md`:

```md
# Process API

The Process API is the main interface for dynamic analysis with Pyda. It provides methods for hooking execution, intercepting system calls, and manipulating process state.

::: pyda.Process
    options:
      show_root_heading: false
      show_source: false
      members:
        - __init__
        - hook
        - unhook
        - hook_after_call
        - syscall_pre
        - syscall_post
        - set_thread_entry
        - on_module_load
        - read
        - write
        - run
        - run_until
        - run_from_to
        - callable
        - backtrace
        - backtrace_cpp
        - tid

## Memory and Register Interfaces

::: pyda.proc.ProcessRegisters
    options:
      show_root_heading: true
      show_source: false
      members:
        - __init__
        - __getitem__
        - __setitem__
        - has_reg

::: pyda.proc.ProcessMemory
    options:
      show_root_heading: true
      show_source: false
      members:
        - __init__
        - __getitem__

::: pyda.proc.ProcessMaps
    options:
      show_root_heading: true
      show_source: false
      members:
        - __init__
        - __getitem__

::: pyda.proc.Map
    options:
      show_root_heading: true
      show_source: false
      members:
        - base
        - start
        - end
        - executable
        - writable
        - readable 

```

`docs/pages/getting-started/installation.md`:

```md
# Installation

## Docker (Recommended)

The easiest way to get started with Pyda is using Docker.

### Pull the latest release

```bash
docker pull ghcr.io/ndrewh/pyda
```

### Or build it yourself

```bash
docker build -t pyda .
```

!!! note
    The Pyda image is currently based on `ubuntu:22.04` and we leave the default entrypoint as `/bin/bash`

## Experimental pip install (macOS and Linux)

!!! warning
    macOS support is extremely experimental and may not work. See "a note on macOS" below.

Installation with pip may take ~1-2 minutes to complete, as it builds everything from source.

**Pyda currently only supports CPython 3.10.**

```bash
pip install pyda-dbi
```

## Supported Platforms

- **Operating System**: Linux, macOS (experimental)
- **Architecture**: X86_64, ARM64
- **Python**: CPython 3.10

## First use

Once installed, you can verify your installation works by running a simple example:

```bash
# If you used Docker...
docker run -it ghcr.io/ndrewh/pyda pyda examples/ltrace.py -- ls -al

# If you used pip install...
pyda examples/ltrace.py -- ls -al
```

If the installation is successful, you should see ltrace-style output showing library function calls made by the `ls` command.

### A note on macOS

On macOS, certain security mechanisms interfere with Pyda. Pyda (and any other DynamoRIO-based tool) will **silently fail to attach to many code-signed processes**.

- If you just want to try Pyda, try it on something you compiled on your own machine or (if you know what you're doing) resign your target with the `codesign` utility.
- If you want to run system / App Store applications under Pyda, consider disabling SIP. This is completely untested, though.

## Next Steps

Once you have Pyda installed, head over to the [Quick Start](quickstart.md) guide to learn how to write your first analysis tool. 

```

`docs/pages/getting-started/quickstart.md`:

```md
# Quick Start

This guide will walk you through creating your first Pyda analysis tool.

## Basic Usage

Pyda tools follow this pattern:

```bash
pyda <script_path> [script_args] -- <bin_path> [bin_args]
```

The `--` separates your script arguments from the target binary arguments.

## Your First Hook

Let's create a simple tool that hooks the `main` function:

```python title="simple_hook.py"
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

# Get a handle to the current process
p = process()

# Load ELF information
e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

# Define a hook function
def main_hook(p):
    print(f"Entered main function!")
    print(f"RSP: {hex(p.regs.rsp)}")
    print(f"RIP: {hex(p.regs.rip)}")

# Register the hook at main
p.hook(e.symbols["main"], main_hook)

# Start execution
p.run()
```

Run it with:
```bash
pyda simple_hook.py -- /bin/ls
```

## Memory and Register Access

Pyda provides intuitive access to process memory and registers:

```python title="memory_example.py"
from pyda import *

p = process()

def my_hook(p):
    # Read registers
    rax_value = p.regs.rax
    rsp_value = p.regs.rsp
    
    # Read memory
    stack_data = p.read(p.regs.rsp, 16)  # Read 16 bytes from stack
    
    # Using slice notation
    stack_bytes = p.mem[p.regs.rsp:p.regs.rsp+16]
    single_byte = p.mem[p.regs.rsp]
    
    # Write memory
    p.write(0x1000, b"Hello World")
    
    # Write registers
    p.regs.rax = 0x1337
    
    print(f"RAX: {hex(rax_value)}")
    print(f"Stack: {stack_data.hex()}")

# Hook any address
p.hook(0x401000, my_hook)
p.run()
```

## Syscall Hooks

Monitor and intercept system calls:

```python title="syscall_example.py"
from pyda import *

p = process()

def write_pre_hook(p, syscall_num):
    """Called before write() syscall"""
    fd = p.regs.rdi
    buf_addr = p.regs.rsi
    count = p.regs.rdx
    
    if fd == 1:  # stdout
        data = p.read(buf_addr, min(count, 100))  # Read up to 100 bytes
        print(f"About to write to stdout: {data}")

def write_post_hook(p, syscall_num):
    """Called after write() syscall"""
    bytes_written = p.regs.rax
    print(f"Write returned: {bytes_written}")

# Register syscall hooks
p.syscall_pre(1, write_pre_hook)   # 1 = SYS_write
p.syscall_post(1, write_post_hook)

p.run()
```

## Library Function Tracing

Create an `ltrace`-like tool:

```python title="my_ltrace.py"
from pyda import *
from pwnlib.elf.elf import ELF

p = process()
e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def trace_libc_call(func_name):
    def hook(p):
        print(f"Called {func_name}")
        
        # Print some arguments (adjust based on function)
        if func_name in ["printf", "puts"]:
            try:
                str_addr = p.regs.rdi
                string = p.read(str_addr, 50).split(b'\x00')[0]
                print(f"  arg1: {string}")
            except:
                pass
    
    return hook

# Hook common libc functions
libc_functions = ["printf", "puts", "malloc", "free", "strlen"]
for func in libc_functions:
    if func in e.symbols:
        p.hook(e.symbols[func], trace_libc_call(func))

p.run()
```

## Next Steps

Now that you understand the basics, check out the [`Process`](../api/process.md) documentation to explore other APIs.

## Common Patterns

### Safe memory access

```python
def my_hook(p):
    try:
        data = p.read(p.regs.rsi, 10)
        print(f"Data: {data}")
    except MemoryError as e:
        print(f"Could not read from {hex(p.regs.rsi)}")
```

```

`docs/pages/index.md`:

```md
# Pyda Documentation

Pyda lets you write dynamic binary analysis tools using Python.

Pyda combines [DynamoRIO](https://dynamorio.org)-based instrumentation with a CPython interpreter, allowing you to "inject" Python code into any x86/ARM64 Linux process, without going through GDB or ptrace.

## Features

- **Hooks**: Inspect and modify registers and memory at any instruction.
- **Redirect execution**: Hooks can directly modify the program counter; for example, to cause a function to return early or to skip over a tricky branch.
- **Syscall interception**: Syscall pre/post hooks can capture and modify syscall arguments, and optionally skip the syscall altogether.
- **Package support**: Install and use your favorite packages like normal using `pip` (e.g. pwntools).
- **Graceful multithreading**: Writing tools for multithreaded programs is easy: program threads *share* a Python interpreter, so you can use globals to track and aggregate state over several threads.

## What is Pyda?

Pyda is a...

- **In-process, scriptable debugger**: Pyda hooks can be used as GDB-style breakpoints to inspect/modify registers and memory. Several packages (e.g. pwntools) can be used to look up symbols or parse DWARF info.
- **Reverse engineering tool**: Answer questions like "Where do all these indirect jumps go?" in just a few lines of Python.
- **CTF Tool**: We provide a pwntools-style API for I/O (a Pyda `Process` is actually a pwntools `tube`!), and new "blocking" APIs like `p.run_until(pc)` which allow you to interleave execution and I/O.

## Quick Example

```python
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

# Get a handle to the current process
p = process()  # See process() function docs

# You can use pwnlib to get information about the target ELF
e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

# Define a hook/breakpoint -- this can be at any instruction
def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

# Register the hook
p.hook(e.symbols["main"], main_hook)

# Tell Pyda we are ready to go!
p.run()
```

## Getting Started

Ready to start using Pyda? Check out our [installation guide](getting-started/installation.md) and [quick start tutorial](getting-started/quickstart.md).

For detailed API documentation:
- [`process()` function](api/process.md#process-function) - Main entry point for creating Process instances
- [Process API Reference](api/process.md) - Complete API documentation 
```

`docs/pages/quick-reference.md`:

```md
### Read/Modify Memory and Registers

```py
# Read memory
p.read(0x100000, 8) # 8 bytes (bytes)
p.mem[0x100000] # 1 byte (int)
p.mem[0x100000:0x100008] # 8 bytes (bytes)

# Write memory
p.write(0x100000, b"\x00" * 8)
p.mem[0x100000:0x100008] = b"\x00" * 8

# Read registers
p.regs.rax # (int)

# Write registers
p.regs.rax = 0x1337133713371337
```

### Hooks

```py
# Hooks (functions called before executing the instruction at the specified PC)
p.hook(0x100000, lambda p: print(f"rsp={hex(p.regs.rsp)}"))

# New thread events: called when a new thread starts (just before entrypoint)
p.set_thread_entry(lambda p: print(f"tid {p.tid} started")) # Called when a new thread is spawned

# Syscall hooks: called for a specific syscall (specified by the first arg)
# as a pre (before syscall) or post (after syscall) hook.
#
# Pre-syscall hooks can optionally return False to skip the syscall.
# In this case, you are responsible for setting the return value
# (e.g. with p.regs.rax = 0). Returning any value other than False (or not
# returning anything at all) will still run the syscall.
p.syscall_pre(1, lambda p, syscall_num: print(f"write about to be called with {p.regs.rdx} bytes"))
p.syscall_post(1, lambda p, syscall_num: print(f"write called with {p.regs.rdx} bytes"))
```

### Debugger-style "blocking" APIs:

```py
# Resumes the process until completion
p.run()

# Resumes the process until `pc` is reached
p.run_until(pc)

# pwntools tube APIs are overloaded:
# recvuntil(x) resumes the process until it reaches a "write" syscall
# that writes matching data
p.recvuntil(bstr)
```

### Misc

```py
# Get process base
p.maps["libc.so.6"].base # (int)

# Get current thread id (valid in hooks and thread entrypoint)
p.tid # (int), starts from 1
```

```

`docs/requirements.txt`:

```txt
mkdocs>=1.5.0
mkdocs-material>=9.4.0
mkdocstrings[python]>=0.23.0
pymdown-extensions>=10.0.0 
```

`examples/cmplog.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64, u32
import string
import sys
import subprocess
from collections import defaultdict

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def get_cmp(proc):
    p = subprocess.run(f"objdump -M intel -d {proc.exe_path} | grep cmp", shell=True, capture_output=True)

    output = p.stdout.decode()
    cmp_locs = {}
    for l in output.split("\n"):
        if len(l) <= 1:
            continue

        # TODO: memory cmp
        if "QWORD PTR" in l:
            continue

        if ":\t" not in l:
            continue

        cmp_locs[int(l.split(":")[0].strip(), 16)] = l.split()[-1]

    return cmp_locs

cmp_locs_unfiltered = get_cmp(p)
cmp_locs = {}
for (a, v) in cmp_locs_unfiltered.items():
    info = v.split(",")
    if len(info) != 2:
        continue
    if "[" in info[0] or "[" in info[1]:
        continue

    if "0x" in info[0] or "0x" in info[1]:
        continue

    cmp_locs[a] = info

print(f"cmp_locs: {len(cmp_locs)}")

eq_count = 0
neq_count = 0
reg_map = {
    "eax": "rax",
    "ebx": "rbx",
    "ecx": "rcx",
    "edx": "rdx",
    "esi": "rsi",
    "edi": "rdi",
    "ebp": "rbp",
    "esp": "rsp",
    "r8d": "r8",
}

counts_by_pc = defaultdict(int)
good_cmps = defaultdict(int)
def cmp_hook(p):
    global eq_count, neq_count
    info = cmp_locs[p.regs.pc - e.address]

    counts_by_pc[p.regs.pc - e.address] += 1

    reg1 = reg_map.get(info[0], info[0])
    reg2 = reg_map.get(info[1], info[1])
    r1 = p.regs[reg1]
    r2 = p.regs[reg2]
    eq = r1 == r2

    if eq:
        eq_count += 1
    else:
        neq_count += 1

    print(f"cmp @ {hex(p.regs.rip - e.address)} {reg1}={hex(r1)} {reg2}={hex(r2)} {eq}")

for x in cmp_locs:
    p.hook(e.address + x, cmp_hook)

p.run()

```

`examples/heap.py`:

```py
from pwn import *
from pyda import *

import pwndbg # must come after pyda import, i think
from termcolor import colored, cprint

import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc.address = p.maps[libc.path].base

sym_map = {
    libc.symbols["malloc"]: "malloc",
    libc.symbols["free"]: "free",
    libc.symbols["realloc"]: "realloc",
}

# todo: use dwarf to figure out where tcache pointer is in tls?
# print(f"dwarf: {libc.dwarf}")

def heap_hook(p):
    name = sym_map[p.regs.rip]

    print(f"{name}(" + ", ".join([
        f"rdi={hex(p.regs.rdi)}",
    ]) + ")")

def after_heap_hook(p):
    heap = pwndbg.heap.current
    tcachebins = heap.tcachebins()
    if tcachebins is not None:
        for (s, b) in tcachebins.bins.items():
            if len(b.fd_chain) < 2:
                continue
            print(f"tcache {colored(hex(s), 'yellow')}: ", end="")
            print(colored(' -> ', 'yellow').join([hex(x) for x in b.fd_chain]))

        print()
    else:
        print("heap not initialized yet?")
    

for sym in sym_map:
    p.hook(sym, heap_hook)
    p.hook_after_call(sym, after_heap_hook)

p.run()
```

`examples/ltrace.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                return str(data[:data.index(0)])
        except:
            pass
    
    return hex(x)

def lib_hook(p):
    name = plt_map[p.regs.pc]
    print(f"{name}(" + ", ".join([
        f"rdi={guess_arg(p.regs.arg1)}",
        f"rsi={guess_arg(p.regs.arg2)}",
        f"rdx={guess_arg(p.regs.arg3)}",
        f"rcx={guess_arg(p.regs.arg4)}",
    ]) + ")")

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()

```

`examples/ltrace_macos.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
from collections import defaultdict
import string
import sys
import subprocess, re, time

def parse_text_stubs(binary_path: str):
    stubs = {}

    cmd = ["otool", "-Iv", binary_path]
    vaddr_cmd = f"otool -l {binary_path} | grep -A 4 '__TEXT'"
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        result2 = subprocess.run(vaddr_cmd, capture_output=True, text=True, check=True, shell=True)
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Error running otool: {e}")

    output = result.stdout
    stubs_section = False
    symbols = []

    base_addr = None
    for l in result2.stdout.split("\n"):
        parts = l.split()
        if len(parts) >= 2 and parts[0] == "vmaddr":
            base_addr = int(parts[1], 16)
            break

    for line in output.split('\n'):
        if "__TEXT,__stubs" in line:
            stubs_section = True
            continue
        elif "__DATA" in line:  # Stop when we hit the DATA section
            break

        if stubs_section and line.strip():
            # Skip header line
            if "address" in line:
                continue

            # Parse symbol entries
            match = re.match(r"(0x[0-9a-fA-F]+)\s+(\d+)\s+(.+)", line)
            if match:
                address = int(match.group(1), 16) - base_addr
                index = int(match.group(2))
                name = match.group(3)
                stubs[address] = name

    return stubs


p = process()

base = p.maps[p.exe_path].base
plt_map = { addr + base: name for (addr, name) in parse_text_stubs(p.exe_path).items() }

print({ hex(x): y for (x, y) in plt_map.items() })

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')
    return hex(x)

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                return str(data[:data.index(0)])
        except:
            pass

    return hex(x)

counts = defaultdict(int)
def lib_hook(p):
    name = plt_map[p.regs.pc]
    print(f"{name}[tid={p.tid}](" + ", ".join([
        f"rdi={guess_arg(p.regs.arg1)}",
        f"rsi={guess_arg(p.regs.arg2)}",
        f"rdx={guess_arg(p.regs.arg3)}",
        f"rcx={guess_arg(p.regs.arg4)}",
    ]) + ")", flush=True)
    counts[name] += 1

for x in plt_map:
    p.hook(x, lib_hook)

p.run()
print(counts)

```

`examples/ltrace_multithreaded.py`:

```py
# This is basically just ltrace.py but we also print the thread number
# and print a message when threads are created.

from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                return str(data[:data.index(0)])
        except:
            pass
    
    return hex(x)

def lib_hook(p):
    name = plt_map[p.regs.pc]
    print(f"[thread {p.tid}] {name}(" + ", ".join([
        f"arg0={guess_arg(p.regs.arg1)}",
        f"arg1={guess_arg(p.regs.arg2)}",
        f"arg2={guess_arg(p.regs.arg3)}",
        f"arg3={guess_arg(p.regs.arg4)}",
    ]) + ")")

def thread_entry(p):
    print(f"thread_entry for {p.tid}")

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()
```

`examples/resolve_indirect_calls.py`:

```py
from pyda import *
import sys
import subprocess

p = process()

BASE = p.maps[p.exe_path].base

def u64(data):
    return int.from_bytes(data, "little")

def get_calls(proc):
    p = subprocess.run(f"objdump -M intel -d {proc.exe_path} | grep call", shell=True, capture_output=True)

    output = p.stdout.decode()
    call_locs = {}
    ind_call_locs = {}
    for l in output.split("\n"):
        if len(l) <= 1:
            continue
        if "QWORD PTR" in l and l.endswith("]"):
            addr = int(l.split(":")[0].strip(), 16)
            lol = "".join(l.split(":")[1].split("[")[1].split("]")[0])
            if '+' in lol:
                reg, off = lol.split("+", 1)
            else:
                reg, off = lol, "0"

            try:
                off = int(off, 0)
            except:
                continue

            ind_call_locs[addr] = (reg, off)
        elif l.split()[-2] == "call":
            call_locs[int(l.split(":")[0].strip(), 16)] = l.split()[-1]
        
    return call_locs, ind_call_locs


call_locs, ind_call_locs = get_calls(p)

def call_reg(p):
    reg = call_locs[p.regs.rip - BASE]
    rax = p.regs[reg]
    print(f"call {hex(p.regs.rip - BASE)} -> {hex(rax - BASE)}")

def ind_call_print(p):
    addr = p.regs.rip - BASE
    reg, off = ind_call_locs[addr]
    reg_val = p.regs[reg]
    mem_target = reg_val + off
    try:
        mem = p.read(mem_target, 8)
        print(f"indcall {hex(addr)} -> {hex(u64(mem) - BASE)}")
    except Exception as e:
        print(e)
        pass

if BASE != 0:
    for c in call_locs:
        p.hook(BASE + c, call_reg)
    
    for c in ind_call_locs:
        p.hook(BASE + c, ind_call_print)

p.run()
```

`examples/simple.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

p.hook(e.symbols["main"], main_hook)
p.run()
```

`examples/strace.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                if 0 in data:
                    return str(data[:data.index(0)])
                else:
                    return str(data[:20]) + "..."

        except Exception as e:
            pass
    
    return hex(x)

def syscall_pre_hook(p, num):
    print(f"[syscall {num}] (" + ", ".join([
        f"rdi={guess_arg(p.regs.rdi)}",
        f"rsi={guess_arg(p.regs.rsi)}",
        f"rdx={guess_arg(p.regs.rdx)}",
        f"rcx={guess_arg(p.regs.rcx)}",
    ]) + ")")

for snum in range(500):
    p.syscall_pre(snum, syscall_pre_hook)

p.run()
```

`lib/pyda/__init__.py`:

```py
import sys, os
try:
    from .base import *
except ImportError as e:
    # Pyda will not import correctly if not run via the DynamoRIO tool
    sys.stderr.write("[Pyda] You must use the `pyda` script to use pyda. You cannot import pyda directly.\n")
    if "pyda_core" not in str(e):
        raise e

sys.path.append(os.path.join(os.path.dirname(__file__), 'hacks'))

```

`lib/pyda/arch.py`:

```py

from enum import Enum
import platform

ARCH = Enum("Arch", "X86 X86_64 ARM64")

def arch():
    if platform.machine() in ["arm64", "aarch64"]:
        return ARCH.ARM64
    elif platform.machine() in ["x86_64", "AMD64"]:
        return ARCH.X86_64
    elif platform.machine() in ["i386", "i686"]:
        return ARCH.X86
    else:
        raise f"Unrecognized architecture {platform.machine()}"

def gdb_arch():
    return {
        ARCH.X86: "i386",
        ARCH.X86_64: "i386:x86-64",
        ARCH.ARM64: "arm64",
    }[arch()]

def endianness():
    return "little"

def os():
    return "linux"

def ptrsize():
    return 8

```

`lib/pyda/base.py`:

```py
import pyda_core
from pyda_core import MemoryError, ThreadExitError, InvalidStateError, FatalSignalError
from .proc import Process, Map, backtrace_to_str
from . import arch, tube, compiler
import sys, os

INIT = False

def process(**kwargs):
    """Obtain the current `Process` instance.
    
    Args:
        **kwargs: Additional arguments passed to Process constructor.
                 Common options include:
                 - io (bool): Enable I/O capture for pwntools compatibility
        
    Example:
        ```python
        from pyda import *
        
        # Basic usage
        p = process()
        
        # With I/O capture enabled
        p = process(io=True)
        ```
        
    Note:
        This function must be called from within the Pyda environment (i.e., when
        running a script via the `pyda` or `pyda-attach` commands).
    """
    global INIT

    # todo: remove the bogus argument
    proc = Process(pyda_core.process(""), **kwargs)

    if not INIT:
        # by this point, hacks/ is in pythonpath
        import pwndbg_compat

        INIT = True
        if "pwndbg" in sys.modules:
            pwndbg_compat.patch_pwndbg(sys.modules["pwndbg"], proc)

    return proc

def xinfo(addr):
    # print(f"find page: {hex(int(addr))}")
    res = pyda_core.get_module_for_addr(addr)
    # print(f"res: {res}")
    if res is None:
        return None
    path, start, end, perms = res
    return Map(path=path, vaddr=start, size=end - start, perms=perms)

FatalSignalError.__str__ = lambda self: f"Signal {self.args[0]} on Thread {self.args[1]}\nBacktrace:\n{backtrace_to_str(self.args[2])}"

def exit(*args, **kwargs):
    raise RuntimeError("exit")

os._exit = exit
sys.exit = exit

```

`lib/pyda/compiler.py`:

```py
import pyda_core

class Expr:
    # it is NOT legal for user code to call this constructor EVER
    def __init__(self, handle):
        self._handle = handle

    def __add__(self, other):
        other = self.expr_from(other)
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_ADD, self._handle, other._handle))

    def __sub__(self, other):
        other = self.expr_from(other)
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_SUB, self._handle, other._handle))

    def __mul__(self, other):
        other = self.expr_from(other)
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_MUL, self._handle, other._handle))

    def __floordiv__(self, other):
        other = self.expr_from(other)
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_DIV, self._handle, other._handle))

    def __del__(self):
        pyda_core.free_expr(self._handle)

    @staticmethod
    def expr_from(val):
        if isinstance(val, Expr):
            return val
        elif isinstance(val, int):
            return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_CONST, val, 0))
        else:
            raise ValueError(f"Invalid type for expression {type(val)}")


class Builder:
    def __init__(self, handle):
        self._b = handle
        self.regs = BuilderRegisters(handle)

    def load(self, addr):
        addr = Expr.expr_from(addr)
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_LOAD, addr._handle, 0))

    def store(self, addr, value):
        addr = Expr.expr_from(addr)
        value = Expr.expr_from(value)
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_STORE, addr._handle, value._handle))

    def constant(self, value):
        return Expr(pyda_core.expr(pyda_core.EXPR_TYPE_CONST, value, 0))

    def raw(self, insns):
        return Expr(pyda_core.expr_raw(insns))

class BuilderRegisters():
    def __init__(self, b):
        self._b = b

    def __getitem__(self, name):
        val = None
        reg_id = getattr(pyda_core, "REG_"+name.upper(), None)
        if reg_id:
            val = Expr(self._b.get_register(reg_id))

        if val is not None:
            return val

        raise AttributeError(f"Invalid register name '{name}'")

    def __setitem__(self, name, value):
        reg_id = getattr(pyda_core, "REG_"+name.upper(), None)
        if reg_id:
            expr = Expr.expr_from(value)
            self._b.set_register(reg_id, expr._handle)
        else:
            raise AttributeError(f"Invalid register name '{name}'")

    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        if name != "_b":
            self[name] = value
        else:
            super().__setattr__(name, value)

    def has_reg(self, name):
        return hasattr(pyda_core, "REG_"+name.upper())


```

`lib/pyda/hacks/gdb.py`:

```py
from types import SimpleNamespace
import pyda
import pyda_core

# This is a compatibility layer for pwndbg

PARAM_BOOLEAN = 133701
PARAM_ZINTEGER = 133702
PARAM_STRING = 133703
PARAM_ENUM = 133704
PARAM_AUTO_BOOLEAN = 133705
COMMAND_USER = 133706
COMPLETE_EXPRESSION = 133707
PARAM_OPTIONAL_FILENAME = 133708
COMMAND_SUPPORT = 133709
TYPE_CODE_STRUCT = 133710

class Parameter():
    def __init__(self, name, type, cls, seq=None):
        pass

events = SimpleNamespace()

class EventRegistry():
    def connect(self, _):
        pass

    pass

def execute(s, to_string=False, from_tty=False):
    if s == "show language":
        return 'The current source language is "auto; currently c".'
    elif s == "show debug-file-directory":
        return 'The directory where separate debug symbols are searched for is "/usr/lib/debug".'
    elif s == "show pagination":
        return 'State of pagination is off.'
    elif s == "help all":
        return 'there-are-no-command-why-are-you-asking-me -- Why?\n'
    elif s == "show endian":
        return f'The target endianness is set automatically (currently little {pyda.arch.endianness()}).'
    elif s == "show architecture":
        return f"The target architecture is set automatically (currently {pyda.arch.gdb_arch()})",
    elif s == "show osabi":
        return {
            "linux": """The current OS ABI is "auto" (currently "GNU/Linux").
The default OS ABI is "GNU/Linux".
"""
        }[pyda.arch.os()]
    elif s == "info win":
        return "No stack."
    elif s.startswith("set "):
        return "The TUI is not active."
    elif s.startswith("handle "):
        return "The TUI is not active."
    else:
        print(f"Failed command: {s}")
        raise NotImplementedError(f"s={s}")

class Type:
    def __init__(self, sz, signed, float=False):
        self.sz = sz
        self.signed = signed
        self.float = float

    def pointer(self):
        return Pointer(self)

    @property
    def sizeof(self):
        return self.sz

    @property
    def alignof(self):
        return self.sz

    def array(self, n):
        return Array(self, n)

    def __eq__(self, other):
        if not isinstance(other, Type):
            return False

        return (
            self.sz == other.sz
            and self.signed == other.signed
            and self.float == other.float
        )

class Pointer(Type):
    def __init__(self, t):
        super().__init__(8, False)
        self._points_to = t

    def __eq__(self, other):
        if not isinstance(other, Pointer):
            return False

        return self._points_to == other._points_to

class Array(Type):
    def __init__(self, t, n):
        super().__init__(t.sz * n, t.signed)
        self._points_to = t
        self._n = n

    def __eq__(self, other):
        if not isinstance(other, Array):
            return False

        return self._points_to == other._points_to and self._n == other._n

    def target(self):
        return self._points_to

class Value:
    def __init__(self, v):
        self.v = v
        self.type = Type(0, False)

    def cast(self, t):
        v = Value(self.v)
        v.type = t
        return v

    def __int__(self):
        assert not isinstance(self.type, Array)
        assert not self.type.float
        if type(self.v) is int:
            return self.v
        elif type(self.v) is bytes:
            return int.from_bytes(self.v, pyda.arch.endianness())
        else:
            raise NotImplementedError(f"Value: {self.v}")

    def __getitem__(self, idx):
        assert isinstance(self.type, Array), f"type: {self.type.__class__} {Array}"
        assert type(self.v) is bytes
        assert idx < self.type._n

        elementsz = self.type.target().sz
        return Value(self.v[idx * elementsz:(idx + 1) * elementsz]).cast(self.type.target())

class Command():
    def __init__(self, name, command_class, completer_class, prefix=None):
        self.name = name
        self.command_class = command_class
        self.prefix = prefix

class Function():
    def __init__(self, name):
        self.name = name

class Breakpoint():
    def __init__(self):
        pass

class error(BaseException):
    def __init__(self, s):
        self.s = s

    def __str__(self):
        return self.s

MemoryError = pyda.MemoryError

VERSION = "12.1"

def lookup_type(s):
    match s:
        case "char":
            return Type(1, True)
        case "short":
            return Type(2, True)
        case "int":
            return Type(4, True)
        case "long":
            return Type(8, True)
        case "long long":
            return Type(8, True)
        case "unsigned char":
            return Type(1, False)
        case "unsigned short":
            return Type(2, False)
        case "unsigned int":
            return Type(4, False)
        case "unsigned long":
            return Type(8, False)
        case "unsigned long long":
            return Type(8, False)
        case "long double":
            return Type(16, True, float=True)
        case "()" | "void":
            return Type(0, False)
        case _:
            print(f"lookup_type: {s}")
            return None
            # raise NotImplementedError(f"cmd: {s}")


events.exited = EventRegistry()
events.cont = EventRegistry()
events.new_objfile = EventRegistry()
events.stop = EventRegistry()
events.start = EventRegistry()
events.new_thread = EventRegistry()
events.before_prompt = EventRegistry()
events.memory_changed = EventRegistry()
events.register_changed = EventRegistry()

class Thread():
    def __init__(self, tid):
        self.tid = tid

    @property
    def global_num(self):
        return self.tid

class Frame():
    def architecture(self):
        return GdbArch(pyda.arch.gdb_arch())

class GdbArch():
    def __init__(self, s):
        self.s = s

    def name(self):
        return self.s

def newest_frame():
    return Frame()

def selected_thread():
    return Thread(pyda_core.get_current_thread_id())

class types():
    def has_field(t, name):
        return name in t.keys()

```

`lib/pyda/hacks/pls_no_signal.py`:

```py
def signal(x, y):
    pass
```

`lib/pyda/hacks/pwndbg_compat.py`:

```py
import pyda_core
from types import SimpleNamespace
from functools import partial

from pathlib import Path
from pwnlib.elf.elf import ELF
import sys
import importlib

# import our fake gdb module
from gdb import Value, Type
import pyda

class GDBLibInfo():
    def __init__(self):
        pass

    def sharedlibrary_paths(self):
        mods = pyda_core.list_modules()
        return mods

class GDBLibFile():
    def __init__(self):
        pass

    def get_file(self, path, **kwargs):
        p = Path(path)
        if p.is_file():
            return str(p)

        return None


class GDBLibSymbol():
    def __init__(self):
        pass

    def static_linkage_symbol_address(self, name):
        return None

    def address(self, name):
        return None

    def get(self, addr):
        res = pyda_core.get_module_for_addr(int(addr))
        if res[0] != 'unknown':
            print(f"WARN: Symbol lookup not implemented {hex(addr)} {res}")

        return None

def get_glibc_section_address(section):
    for l in pyda_core.list_modules():
        if "libc.so" in l:
            elf = ELF(l)
            off = elf.get_section_by_name(section).header.sh_addr
            addr = pyda_core.get_base(l) + off
            print(f"glibc addr: {hex(addr)}")
            return addr

    return None

class GDBLibMemory():
    def __init__(self, proc):
        self._p = proc

    def is_readable_address(self, addr):
        try:
            self._p.read(addr, 1)
            return True
        except:
            return False

    def poi(self, t, addr):
        v = self._p.read(addr, t.sizeof)
        # print(f"poi: {hex(addr)} => {v.hex()}")
        return Value(v).cast(t)

    def u32(self, addr):
        return int.from_bytes(self._p.read(addr, 4), pyda.arch.endianness())

    def i32(self, addr):
        return int.from_bytes(self._p.read(addr, 4), pyda.arch.endianness(), signed=True)

    def u64(self, addr):
        return int.from_bytes(self._p.read(addr, 8), pyda.arch.endianness())

    def s64(self, addr):
        return int.from_bytes(self._p.read(addr, 8), pyda.arch.endianness(), signed=True)

    def pvoid(self, addr):
        assert pyda.arch.ptrsize() == 8
        return self.u64(addr)

    def peek(self, addr):
        return chr(self._p.read(addr, 1)[0])

    def read(self, addr, size):
        return self._p.read(addr, size)



class Page():
    def __init__(self, map: pyda.Map) -> None:
        self._map = map

    @property
    def end(self):
        return self._map.end

    @property
    def start(self):
        return self._map.start

    def __contains__(self, addr):
        return self._map.start <= addr < self._map.end

    @property
    def objfile(self):
        return self._map.path

    @property
    def execute(self):
        return self._map.executable

    @property
    def rw(self):
        return self._map.readable and self._map.writable

    @property
    def rwx(self):
        return self.rw and self.execute

class GDBLibVMMap():
    def __init__(self, proc):
        pass

    def find(self, addr):
        info = pyda.xinfo(int(addr))
        return Page(info)

    def get(self):
        return []

class GDBLibArch():
    def __init__(self, proc):
        pass

    @property
    def endian(self):
        return pyda.arch.endianness()

    @property
    def ptrsize(self):
        return pyda.arch.ptrsize()

    def __getattr__(self, name):
        print(f"Arch: {name}")
        raise AttributeError(f"Arch: {name}")

def patch_pwndbg(pwndbg, proc):
    patch_gdblib(pwndbg.gdblib, proc)
    patch_glibc(pwndbg.glibc)

    pwndbg.heap.ptmalloc.HeuristicHeap.multithreaded = False

    pwndbg.heap.current = pwndbg.heap.ptmalloc.HeuristicHeap()
    pwndbg.heap.current.is_statically_linked = lambda: False

    pwndbg.heap.current.mp
    # pwndbg.heap.resolve_heap(is_first_run=True)

class GDBLibConfig():
    def __init__(self):
        self._d = {}

    def __getattr__(self, name):
        if name == "_d":
            return super().__getattr__(name)
        elif name in self._d:
            return self._d[name]
        else:
            return 0

    def __setattr__(self, name, value):
        if name == "_d":
            super().__setattr__(name, value)
        else:
            self._d[name] = value

class GDBRegs():
    def __init__(self, proc):
        self._p = proc

    def __getattr__(self, name):
        return self._p.regs[name]

def patch_gdblib(gdblib, proc):
    gdblib.info = GDBLibInfo()
    gdblib.file = GDBLibFile()
    gdblib.symbol = GDBLibSymbol()
    gdblib.config = GDBLibConfig()

    old_mem = gdblib.memory
    gdblib.memory = GDBLibMemory(proc)
    gdblib.memory.string = old_mem.string

    gdblib.vmmap = GDBLibVMMap(proc)
    gdblib.regs = GDBRegs(proc)
    # gdblib.arch = GDBLibArch(proc)

def patch_glibc(glibc):
    glibc.get_data_section_address = partial(get_glibc_section_address, ".data")
    glibc.get_got_section_address = partial(get_glibc_section_address, ".got")

```

`lib/pyda/proc.py`:

```py
from collections import namedtuple, deque
from dataclasses import dataclass
import ctypes
import ctypes.util
from .tube import ProcessTube
from .compiler import Builder
from .arch import arch, ARCH
import pyda_core
import sys

class Process(ProcessTube):
    """
    Obtain a `Process` via the module-level `process` function.

    Example:
        Obtain a `Process` with `process()`.

        ```python
        from pyda import *
        
        # process() returns a Process instance.
        p = process()

        # p.run() starts the process.
        p.run()
        ```
    
    The Process class provides the primary API for instrumenting and analyzing 
    target processes. It allows you to set hooks, intercept system calls, and 
    manipulate process state during execution.
    
    This class extends `ProcessTube`, providing pwntools-compatible I/O operations
    alongside the dynamic analysis capabilities.
    
    Attributes:
        regs (ProcessRegisters): Interface for reading/writing CPU registers
        mem (ProcessMemory): Interface for reading/writing process memory  
        maps (ProcessMaps): Interface for querying memory mappings
        exe_path (str): Path to the main executable being analyzed
        tid (int): Current thread ID (valid during hook execution)
    
    Example:
        Basic usage pattern:
        
        ```python
        from pyda import *
        
        # Get process handle
        p = process()
        
        # Set up hooks
        def my_hook(p):
            print(f"Hit address, RAX={hex(p.regs.rax)}")
            
        p.hook(0x401000, my_hook)
        
        # Start analysis
        p.run()
        ```
    """

    def __init__(self, handle, io=False):
        """The following options can be passed to `process()`:
        
        Args:
            io (bool): Whether to capture I/O for pwntools compatibility.
                      When True, enables recv/send operations.
        """
        self._p = handle

        if io:
            fds = self._p.capture_io()
            super().__init__(fds[0], fds[1])
        else:
            super().__init__(None, None)

        self._hooks = {}
        self._builder_hooks = {}
        self._syscall_pre_hooks = {}
        self._syscall_post_hooks = {}
        self._registered_syscall_pre_hook = False
        self._registered_syscall_post_hook = False
        self._has_run = False

        self.regs = ProcessRegisters(handle)
        self.mem = ProcessMemory(handle)
        self.maps = ProcessMaps(handle)

        self.exe_path = self._p.get_main_module()

    def _hook_dispatch(self, addr):
        """Internal method to dispatch hooks at a given address."""
        for h in self._hooks[addr]:
            h(self)

    def _syscall_pre_hook_dispatch(self, syscall_num):
        """Internal method to dispatch pre-syscall hooks."""
        if syscall_num in self._syscall_pre_hooks:
            results = []
            for h in self._syscall_pre_hooks[syscall_num]:
                results.append(h(self, syscall_num))

            if False in results and True in results:
                raise RuntimeError("Cannot have mixed return values from syscall pre-hooks")
            elif False in results:
                return False
            elif True in results:
                return True

    def _syscall_post_hook_dispatch(self, syscall_num):
        """Internal method to dispatch post-syscall hooks."""
        if syscall_num in self._syscall_post_hooks:
            for h in self._syscall_post_hooks[syscall_num]:
                h(self, syscall_num)

    def hook(self, addr, callback, priority=False, later=False):
        """Register a hook at the specified address.
        
        Hooks are functions called before executing the instruction at the 
        specified program counter.
        
        Note:
            Multiple hooks can be registered at the
            same address and will be called in registration order (unless 
            priority=True).
        
        Args:
            addr (int): Memory address where the hook should be installed
            callback (callable): Function to call when the hook is hit. 
                               Should accept one argument (the Process instance)
            priority (bool): If True, adds this hook before existing hooks
                           at the same address
            later (bool): If True, registers the hook but doesn't install it
                        until the address is reached for the first time
        
        Example:
            ```python
            def main_hook(p):
                print(f"Entered main at {hex(p.regs.rip)}")
                print(f"Stack pointer: {hex(p.regs.rsp)}")
            
            p.hook(0x401234, main_hook)
            ```
        
        """
        assert addr not in self._builder_hooks
        if addr not in self._hooks:
            hook_wrapper = lambda p: self._hook_dispatch(addr)
            self._p.register_hook(addr, hook_wrapper, 0, later)
            self._hooks[addr] = deque([callback])
        else:
            if priority:
                self._hooks[addr].appendleft(callback)
            else:
                self._hooks[addr].append(callback)

    def unhook(self, addr, callback=None, unregister=True):
        """Remove a hook from the specified address.
        
        Args:
            addr (int): Address where the hook is installed
            callback (callable, optional): Specific callback to remove. 
                                         If None, removes all hooks at the address
            unregister (bool): Whether to unregister the hook from DynamoRIO
                             if no callbacks remain
        """
        # TODO: Maybe replace this with some kind of hook disabling mechanism
        # (perhaps optimize for hook_after_call use)
        self._hooks[addr] = deque([c for c in self._hooks[addr] if c != callback])

        if (callback is None or len(self._hooks[addr]) == 0) and unregister:
            del self._hooks[addr]
            del self._builder_hooks[addr]
            self._p.unregister_hook(addr)

    def builder_hook(self, addr, builder, later=False):
        """Register a low-level builder hook at the specified address.
        
        Builder hooks provide access to DynamoRIO's instruction builder,
        allowing for more advanced instrumentation scenarios.
        
        Args:
            addr (int): Address where the builder hook should be installed
            builder (callable): Function that accepts a Builder instance
            later (bool): If True, registers the hook for later installation
        
        Note:
            Only one builder hook can be registered per address. Builder hooks
            and regular hooks are mutually exclusive at the same address.
        """
        if addr in self._builder_hooks:
            raise RuntimeError("Only one builder hook can be registered per address")
        assert addr not in self._hooks

        self._builder_hooks[addr] = builder
        self._p.register_hook(addr, lambda b: builder(Builder(b)), 1, later)

    def hook_after_call(self, addr, callback):
        """Register a hook that fires when a function call returns.
        
        This is a convenience method that hooks a function entry point and
        automatically sets up a hook at the return address.
        
        Args:
            addr (int): Address of the function to hook
            callback (callable): Function to call when the function returns
                               
        Example:
            ```python
            def after_malloc(p):
                ptr = p.regs.rax  # Return value in RAX
                print(f"malloc returned: {hex(ptr)}")
                
            p.hook_after_call(libc.symbols['malloc'], after_malloc)
            ```
        
        Note:
            This assumes x86-64 calling convention where return addresses
            are stored on the stack.
        """
        def call_hook(p):
            retaddr = int.from_bytes(p.read(p.regs.rsp, 8), "little")
            def after_call_hook(p):
                # print(f"after call to {hex(addr)}")
                callback(p)
                self.unhook(retaddr, after_call_hook, unregister=False)
            self.hook(retaddr, after_call_hook)

        self.hook(addr, call_hook, priority=True)

    def syscall_pre(self, syscall_num, callback):
        """Register a pre-syscall hook for the specified system call.
        
        Pre-syscall hooks are called before the system call is executed,
        allowing inspection and modification of arguments. They can also
        prevent the syscall from executing by returning False.
        
        Args:
            syscall_num (int): System call number to hook (e.g. 1 for write)
            callback (callable): Function to call before the syscall.
                               Should accept (process, syscall_num) arguments.
                               Can return False to skip the syscall.
        
        Example:
            ```python
            def block_write(p, syscall_num):
                if p.regs.rdi == 1:  # stdout
                    print("Blocking write to stdout")
                    p.regs.rax = -1  # Set error return value
                    return False  # Skip the syscall
                    
            p.syscall_pre(1, block_write)  # Hook SYS_write
            ```
        
        Raises:
            RuntimeError: If called after the process has started running
        """
        if self._has_run:
            raise RuntimeError("Cannot add syscall hooks after process has started")

        if not self._registered_syscall_pre_hook:
            self._p.set_syscall_pre_hook(lambda p, syscall_num: self._syscall_pre_hook_dispatch(syscall_num))
            self._registered_syscall_pre_hook = True

        if syscall_num not in self._syscall_pre_hooks:
            self._syscall_pre_hooks[syscall_num] = [callback]
        else:
            self._syscall_pre_hooks[syscall_num].append(callback)

    def syscall_post(self, syscall_num, callback):
        """Register a post-syscall hook for the specified system call.
        
        Post-syscall hooks are called after the system call completes,
        allowing inspection of return values and side effects.
        
        Args:
            syscall_num (int): System call number to hook
            callback (callable): Function to call after the syscall.
                               Should accept (process, syscall_num) arguments.
        
        Example:
            ```python
            def log_write_result(p, syscall_num):
                bytes_written = p.regs.rax
                print(f"write() returned {bytes_written}")
                
            p.syscall_post(1, log_write_result)
            ```
        
        Raises:
            RuntimeError: If called after the process has started running
        """
        if self._has_run:
            raise RuntimeError("Cannot add syscall hooks after process has started")

        if not self._registered_syscall_post_hook:
            self._p.set_syscall_post_hook(lambda p, syscall_num: self._syscall_post_hook_dispatch(syscall_num))
            self._registered_syscall_post_hook = True

        if syscall_num not in self._syscall_post_hooks:
            self._syscall_post_hooks[syscall_num] = [callback]
        else:
            self._syscall_post_hooks[syscall_num].append(callback)
    
    def on_module_load(self, callback):
        """Register a callback for when new modules are loaded.
        
        Args:
            callback (callable): Function to call when a module loads.
                               Should accept appropriate arguments from DynamoRIO.
        """
        self._p.set_module_load_hook(callback)

    def set_thread_entry(self, callback):
        """Register a callback for when new threads are created.
        
        Args:
            callback (callable): Function to call when a new thread starts.
                               Should accept one argument (the Process instance).
        
        Example:
            ```python
            def new_thread(p):
                print(f"New thread created: TID {p.tid}")
                
            p.set_thread_entry(new_thread)
            ```
        """
        self._p.set_thread_init_hook(lambda p: callback(self))

    def read(self, addr, size):
        """Read memory from the target process. Returns bytes.
        
        Args:
            addr (int): Memory address to read from
            size (int): Number of bytes to read
            
        Example:
            ```python
            # Read 16 bytes from the stack
            stack_data = p.read(p.regs.rsp, 16)
            ```
        """
        return self._p.read(addr, size)

    def write(self, addr, data):
        """Write data to the target process memory.
        
        Args:
            addr (int): Memory address to write to
            data (bytes): Data to write
            
        Example:
            ```python
            # Write a string to memory
            p.write(0x401000, b"Hello World\\x00")
            ```
        """
        return self._p.write(addr, data)

    def __getattr__(self, name):
        if self.regs.has_reg(name):
            raise AttributeError(f"Invalid attribute '{name}'. Did you mean 'regs.{name}'?")
        else:
            raise AttributeError(f"Invalid attribute '{name}'")

    def __setattr__(self, name, value):
        if not name.startswith("_") and name not in ["timeout", "buffer", "closed", "regs", "mem", "maps", "exe_path"]:
            raise AttributeError(f"Cannot set attribute '{name}'")

        super().__setattr__(name, value)

    def run(self):
        """Start or resume execution of the target process.
        
        This method begins execution and will run until the process exits
        or encounters a blocking condition (like waiting for I/O).
        
        Example:
            ```python
            p = process()
            p.hook(0x401000, my_hook)
            p.run()  # Start execution
            ```
        """
        self._has_run = True
        self._p.run()

    def run_until(self, addr):
        """Run the process until it reaches the specified address.
        
        Args:
            addr (int): Address to run until
            
        Example:
            ```python
            # Run until we hit main
            p.run_until(0x401234)
            print(f"Stopped at main, RAX={hex(p.regs.rax)}")
            ```
        """
        self._has_run = True
        self._p.run_until_pc(addr)

    @property
    def tid(self):
        """Get the current thread ID (starts from 1).
        
        Note:
            This property is only valid during hook execution or when the 
            process is stopped.
        """
        # This returns the thread id of the currently executing thread
        return pyda_core.get_current_thread_id()

    def run_from_to(self, start, end):
        """Jump to a specific address and run until another address is reached.
        
        Args:
            start (int): Address to jump to
            end (int): Address to run until
            
        Note:
            This cannot be used from within hooks.
        """
        self.regs.rip = start
        self.run_until(end)

    def callable(self, addr):
        """Create a callable that executes instrumented target code.
        
        Returns a function that, when called, will execute the function at the 
        specified address with the given arguments, following standard calling conventions.
        
        Args:
            addr (int): Address of the function to call
            
        Example:
            ```python
            # Create a callable for malloc
            malloc = p.callable(libc.symbols['malloc'])
            
            # Call malloc(100) 
            p.run_until(main_addr)  # Establish stack first
            ptr = malloc(100)
            ```
            
        Note:
            - Cannot be used from within hooks
            - Requires the process to have a valid stack
            - Currently supports up to 6 arguments (x86-64 limitation)
        """
        def call(*args):
            if not self._has_run:
                raise RuntimeError("Cannot use callable before first process break (no stack!). Try p.run_until(e.symbols['main']) first")

            self._p.push_state()

            ## BEGIN ARCH-SPECIFIC SETUP
            orig_pc = self.regs.pc

            if arch() in [ARCH.X86_64, ARCH.X86]:
                # Push orig_pc as the return address
                self.regs.rsp &= ~0xf
                self.regs.rsp -= 8
                self.write(self.regs.rsp, orig_pc.to_bytes(8, "little"))

                target_sp = self.regs.rsp + 8
            elif arch() == ARCH.ARM64:
                # Emulate a blr: just update lr
                self.regs.x30 = orig_pc
                # (note that old LR was saved in self._p.push_state())

                target_sp = self.regs.sp

            set_regs_for_call_linux(self, args)

            print(f"current_pc={hex(self.regs.pc)} target={hex(addr)}")
            self.regs.pc = addr

            # This is a bit hacky, but basically
            # we don't actually know that orig_pc is outside
            # of the function, we just know it's a reasonably
            # safe address. You'll get unexpectedly bad perf
            # if your original pc is garbage

            count = 0
            try:
                while True:
                    self.run_until(orig_pc)
                    count += 1

                    if self.regs.sp == target_sp:
                        break
                ## END ARCH-SPECIFIC SETUP

            finally:
                if count > 1:
                    self.warning(f"WARN: Callable should be used from a safe pc not within the callee.")

                self._p.pop_state()

        return call

    def backtrace(self):
        """Get a string representation of the current call stack.
        
        Example:
            ```python
            def crash_hook(p):
                print("Crash detected!")
                print("Backtrace:")
                print(p.backtrace())
            ```
        """
        return backtrace_to_str(self._p.backtrace())

    def backtrace_cpp(self, short=False):
        """Get a C++ demangled backtrace of the current call stack.
        
        Args:
            short (bool): If True, truncate long symbol names
        """
        return backtrace_to_str(self._p.backtrace(), demangle=True, short=short)

def find_any_library(*choices: str) -> str:
    for choice in choices:
        lib = ctypes.util.find_library(choice)
        if lib is not None:
            return lib
    raise LibraryNotFound('Cannot find any of libraries: {}'.format(choices))

try:
    libcxx = find_any_library("stdc++", "c++")
    libcxx = ctypes.CDLL(libcxx)  # On Linux
    cxa_demangle = getattr(libcxx, '__cxa_demangle')
    cxa_demangle.restype = ctypes.c_void_p
except LibraryNotFound:
    libcxx = None

def cxx_demangle(s):
    mangled_name_p = ctypes.c_char_p(s.encode('utf-8'))
    status = ctypes.c_int()
    retval = cxa_demangle(mangled_name_p, None, None, ctypes.pointer(status))

    res = None
    if status.value == 0:
        try:
            res = ctypes.c_char_p(retval).value.decode('utf-8')
        finally:
            pyda_core.free(retval)

    return res

def backtrace_to_str(bt, demangle=False, short=False):
    if demangle:
        if "cxxfilt" not in sys.modules:
            import cxxfilt

        cxxfilt = sys.modules["cxxfilt"]

    s = ""
    for f in bt:
        if demangle and f[3].startswith("_Z"):
            sym = cxx_demangle(f[3])
            if short and len(sym) > 100:
                sym = sym[:50] + "..." + sym[-50:]

            s += f"[{f[1]}+{hex(f[2])}] {sym}\n"
        elif f[2] != 0:
            s += f"[{f[1]}+{hex(f[2])}] {f[3]}\n"
        else:
            s += f"[ip={hex(f[0])}]\n"

    return s

def set_regs_for_call_linux(p, args):
    if len(args) > 6:
        raise NotImplementedError(">6 args not supported yet")

    if arch() == ARCH.X86_64:
        ARGS = [
            pyda_core.REG_RDI,
            pyda_core.REG_RSI,
            pyda_core.REG_RDX,
            pyda_core.REG_RCX,
            pyda_core.REG_R8,
            pyda_core.REG_R9
        ]
    elif arch() == ARCH.ARM64:
        ARGS = [
            pyda_core.REG_X0,
            pyda_core.REG_X1,
            pyda_core.REG_X2,
            pyda_core.REG_X3,
            pyda_core.REG_X4,
            pyda_core.REG_X5
        ]
    else:
        raise NotImplementedError(f"set_regs_for_call_linux not implemented for {arch()}")

    for (reg_id, val) in zip(ARGS, args):
        if type(val) is int:
            p._p.set_register(reg_id, val)
        elif type(val) is bytes:
            ptr = ctypes.cast(ctypes.c_char_p(val), ctypes.c_void_p).value
            p._p.set_register(reg_id, ptr)
        else:
            raise ValueError(f"Invalid argument type {type(val)}")

class ProcessRegisters():
    """Interface for reading and writing CPU registers.
    
    Provides convenient access to CPU registers using both attribute and 
    dictionary-style syntax.
    
    Example:
        ```python
        # Reading registers
        rax_val = p.regs.rax
        rsp_val = p.regs['rsp']
        
        # Writing registers  
        p.regs.rax = 0x1337
        p.regs['rbx'] = 0x2000
        ```
    """
    
    def __init__(self, p):
        self._p = p

    def __getitem__(self, name):
        val = None
        reg_id = getattr(pyda_core, "REG_"+name.upper(), None)
        if reg_id:
            val = self._p.get_register(reg_id)

        if val is not None:
            return val

        raise AttributeError(f"Invalid register name '{name}'")

    def __setitem__(self, name, value):
        reg_id = getattr(pyda_core, "REG_"+name.upper(), None)
        if reg_id:
            self._p.set_register(reg_id, value)
        else:
            raise AttributeError(f"Invalid register name '{name}'")

    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        if name != "_p":
            self[name] = value
        else:
            super().__setattr__(name, value)

    def has_reg(self, name):
        """Check if a register name is valid."""
        return hasattr(pyda_core, "REG_"+name.upper())

class ProcessMemory():
    """Interface for reading and writing process memory.
    
    Provides convenient slice-based access to target process memory.
    
    Example:
        ```python
        # Read single byte
        byte_val = p.mem[0x401000]
        
        # Read range of bytes
        data = p.mem[0x401000:0x401010]  # 16 bytes
        
        # Write data
        p.mem[0x401000:0x401004] = b"\\x41\\x41\\x41\\x41"
        ```
    """
    
    def __init__(self, p):
        self._p = p

    def __getitem__(self, key):
        if type(key) is slice:
            start = key.start
            stop = key.stop
            step = key.step
            if step is not None and step != 1:
                raise ValueError("ProcessMemory: Step must be 1")

            if stop is not None:
                return self._p.read(start, stop - start)
            else:
                return self._p.read(start, 1)[0]

        return self._p.read(key, 1)[0]

class ProcessMaps():
    """Interface for querying process memory mappings.
    
    Example:
        ```python
        # Get base address of main executable
        main_base = p.maps[p.exe_path].base
        
        # Get libc base
        libc_base = p.maps["libc.so.6"].base
        ```
    """
    
    def __init__(self, p):
        self._p = p

    def __getitem__(self, key):
        return Map(vaddr=pyda_core.get_base(key), size=0, path=key, perms=None)


@dataclass
class Map:
    """Represents a memory mapping in the target process."""
    vaddr: int
    size: int
    path: str
    perms: int

    @property
    def base(self):
        """Base address of this mapping."""
        return self.vaddr

    @property
    def start(self):
        """Start address (same as base)."""
        return self.vaddr

    @property
    def end(self):
        """End address of this mapping."""
        return self.base + self.size

    @property
    def executable(self):
        """True if mapping has execute permissions."""
        return self.perms & 1

    @property
    def writable(self):
        """True if mapping has write permissions."""
        return self.perms & 2

    @property
    def readable(self):
        """True if mapping has read permissions."""
        return self.perms & 4



```

`lib/pyda/tube.py`:

```py
from pwnlib.tubes.tube import tube
from pwnlib.context import context
from pwnlib import term
import sys
import os
import pyda_core
import errno
import threading
import select

# todo
class ProcessTube(tube):
    def __init__(self, stdin_fd, stdout_fd, **kwargs):
        super(ProcessTube, self).__init__(**kwargs)

        self.closed = {"recv": False, "send": False}
        if stdin_fd is None or stdout_fd is None:
            self.closed["recv"] = True
            self.closed["send"] = True
            self._captured = False
        else:
            self._captured = True

        self._stdin_fd = stdin_fd
        self._stdout_fd = stdout_fd

        # real_stdin is what is connected to the user's terminal.
        # used for p.interactive() (note: sys.stdin may be buffered
        # even if PYTHONUNBUFFERED)
        self._real_stdin = os.fdopen(sys.stdin.fileno(), 'rb', 0)

    # Overwritten for better usability
    def recvall(self, timeout = None):
        """recvall() -> str

        Receives data until the socket is closed.
        """
        # todo
        raise NotImplementedError("recvall() not implemented")

    def recv_raw(self, numb, *a):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        if self.closed["recv"]:
            raise EOFError

        if len(a) > 0:
            raise NotImplementedError("recv_raw() with flags not implemented")

        while True:
            try:
                data = os.read(self._stdout_fd, numb)
                break
            except IOError as e:
                if e.errno == errno.EAGAIN:
                    # If we're waiting for data, let the program continue
                    try:
                        self._p.run_until_io()
                        continue
                    except Exception as e:
                        raise EOFError

                if e.errno == errno.ETIMEDOUT or 'timed out' in e.strerror:
                    return None
                elif e.errno in (errno.ECONNREFUSED, errno.ECONNRESET):
                    self.shutdown("recv")
                    raise EOFError
                elif e.errno == errno.EINTR:
                    continue
                else:
                    raise

        if not data:
            self.shutdown("recv")
            raise EOFError

        return data

    # TODO: What happens when the pipe fills? This call
    # will indefinitely block?
    def send_raw(self, data):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        if self.closed["send"]:
            raise EOFError

        ptr = 0
        while ptr < len(data):
            try:
                count = os.write(self._stdin_fd, data[ptr:])
                ptr += count
            except IOError as e:
                eof_numbers = (errno.EPIPE, errno.ECONNRESET, errno.ECONNREFUSED)
                if e.errno in eof_numbers or 'Socket is closed' in e.args:
                    self.shutdown("send")
                    raise EOFError
                elif e.errno == errno.EAGAIN:
                    # If we're waiting for data, let the program continue
                    try:
                        self._p.run_until_io()
                        continue
                    except Exception as e:
                        raise EOFError
                else:
                    raise

    def settimeout_raw(self, timeout):
        raise NotImplementedError("settimeout_raw() not implemented")

    def can_recv_raw(self, timeout):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        if self.closed["recv"]:
            return False

        try:
            if timeout is None:
                return select.select([self._stdout_fd], [], []) == ([self._stdout_fd], [], [])

            return select.select([self._stdout_fd], [], [], timeout) == ([self._stdout_fd], [], [])
        except ValueError:
            # Not sure why this isn't caught when testing self.proc.stdout.closed,
            # but it's not.
            #
            #   File "/home/user/pwntools/pwnlib/tubes/process.py", line 112, in can_recv_raw
            #     return select.select([self.proc.stdout], [], [], timeout) == ([self.proc.stdout], [], [])
            # ValueError: I/O operation on closed file
            raise EOFError
        except select.error as v:
            if v.args[0] == errno.EINTR:
                return False

    def connected_raw(self, direction):
        return True

    def close(self):
        pass

    def _close_msg(self):
        self.info('Closed pyda socket')

    def fileno(self):
        self.error("fileno() not implemented")
        return None

    def shutdown_raw(self, direction):
        pass

    # This code is taken from pwnlib.tubes
    def interactive(self, prompt=term.text.bold_red('$') + ' '):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        self.info('Switching to interactive mode')

        go = threading.Event()
        def send_thread():
            from pwnlib.args import term_mode
            os_linesep = os.linesep.encode()
            to_skip = b''
            while not go.is_set():
                if term.term_mode:
                    # note: this case is not tested
                    data = term.readline.readline(prompt = prompt, float = True)
                    if data.endswith(b'\n') and self.newline != b'\n':
                        data = data[:-1] + self.newline
                else:
                    stdin = self._real_stdin
                    while True:
                        can_read = select.select([stdin], [], [], 0.1) == ([stdin], [], [])
                        if can_read:
                            data = stdin.read(1)
                            break
                        elif go.is_set():
                            data = b''
                            break

                    # Keep OS's line separator if NOTERM is set and
                    # the user did not specify a custom newline
                    # even if stdin is a tty.
                    if sys.stdin.isatty() and (
                        term_mode
                        or context.newline != b"\n"
                        or self._newline is not None
                    ):
                        if to_skip:
                            if to_skip[:1] != data:
                                data = os_linesep[: -len(to_skip)] + data
                            else:
                                to_skip = to_skip[1:]
                                if to_skip:
                                    continue
                                data = self.newline
                        # If we observe a prefix of the line separator in a tty,
                        # assume we'll see the rest of it immediately after.
                        # This could stall until the next character is seen if
                        # the line separator is started but never finished, but
                        # that is unlikely to happen in a dynamic tty.
                        elif data and os_linesep.startswith(data):
                            if len(os_linesep) > 1:
                                to_skip = os_linesep[1:]
                                continue
                            data = self.newline
                    else:
                        raise RuntimeError("interactive() called not attached to TTY")

                if data:
                    try:
                        self.send(data)
                    except EOFError:
                        go.set()
                        self.info('Got EOF while sending in interactive')
                else:
                    go.set()

        t = context.Thread(target=send_thread)
        t.daemon = True
        t.start()

        # Recv thread -- must be main thread
        while not go.is_set():
            try:
                cur = self.recv(timeout = 0.05)
                cur = cur.replace(self.newline, b'\n')
                if cur:
                    stdout = sys.stdout
                    if not term.term_mode:
                        stdout = getattr(stdout, 'buffer', stdout)
                    stdout.write(cur)
                    stdout.flush()
            except EOFError:
                self.info('Got EOF while reading in interactive')
                go.set()
                break
            except KeyboardInterrupt:
                self.info('Interrupted')
                go.set()
                break

        while t.is_alive():
            t.join(timeout = 0.1)

```

`patches/dynamorio-10.0.patch`:

```patch
diff --git a/core/heap.c b/core/heap.c
index 8a0c440cf..f596108da 100644
--- a/core/heap.c
+++ b/core/heap.c
@@ -4548,7 +4548,7 @@ common_heap_free(thread_units_t *tu, void *p_void,
 #ifdef DEBUG_MEMORY
         /* ensure we are freeing memory in a proper unit */
         DOCHECK(CHKLVL_DEFAULT, { /* expensive check */
-                                  ASSERT(find_heap_unit(tu, p, size) != NULL);
+                                  ASSERT(find_heap_unit(tu, p, size) != NULL || *(bool*)0);
         });
 #endif
 
diff --git a/core/ir/opnd_shared.c b/core/ir/opnd_shared.c
index 982362e9f..b708d525a 100644
--- a/core/ir/opnd_shared.c
+++ b/core/ir/opnd_shared.c
@@ -2187,7 +2187,7 @@ DR_API
 bool
 reg_get_value_ex(reg_id_t reg, dr_mcontext_t *mc, OUT byte *val)
 {
-#ifdef X86
+#if defined(X86)
     if (reg >= DR_REG_START_MMX && reg <= DR_REG_STOP_MMX) {
         get_mmx_val((uint64 *)val, reg - DR_REG_START_MMX);
     } else if (reg >= DR_REG_START_XMM && reg <= DR_REG_STOP_XMM) {
@@ -2210,6 +2210,13 @@ reg_get_value_ex(reg_id_t reg, dr_mcontext_t *mc, OUT byte *val)
         reg_t regval = reg_get_value(reg, mc);
         *(reg_t *)val = regval;
     }
+#elif defined(AARCH64)
+    if (reg >= DR_REG_Q0 && reg <= DR_REG_Q31) {
+        memcpy(val, &mc->simd[reg - DR_REG_Q0], 16);
+    } else {
+        reg_t regval = reg_get_value(reg, mc);
+        *(reg_t *)val = regval;
+    }
 #else
     CLIENT_ASSERT(false, "NYI i#1551");
 #endif
diff --git a/core/lib/dr_tools.h b/core/lib/dr_tools.h
index efbb1c636..b7ab5d060 100644
--- a/core/lib/dr_tools.h
+++ b/core/lib/dr_tools.h
@@ -2107,6 +2107,11 @@ DR_API
 void
 dr_thread_yield(void);
 
+DR_API
+/** Current thread gives up its time quantum. */
+void
+dr_set_safe_for_sync(bool safe);
+
 /** Flags controlling the behavior of dr_suspend_all_other_threads_ex(). */
 typedef enum {
     /**
diff --git a/core/lib/instrument.c b/core/lib/instrument.c
index 00686214e..f4e7e0e63 100644
--- a/core/lib/instrument.c
+++ b/core/lib/instrument.c
@@ -147,6 +147,9 @@ typedef struct _callback_list_t {
  */
 /*
  */
+
+void print_xmm0(int);
+
 #define FAST_COPY_SIZE 5
 #define call_all_ret(ret, retop, postop, vec, type, ...)                         \
     do {                                                                         \
@@ -4731,6 +4734,18 @@ dr_insert_write_raw_tls(void *drcontext, instrlist_t *ilist, instr_t *where,
         });
 }
 
+DR_API
+void
+dr_set_safe_for_sync(bool safe)
+{
+    dcontext_t *dcontext = get_thread_private_dcontext();
+    CLIENT_ASSERT(!standalone_library, "API not supported in standalone mode");
+    if (IS_CLIENT_THREAD(dcontext))
+        dcontext->client_data->client_thread_safe_for_synch = safe;
+    else
+        dcontext->client_data->at_safe_to_terminate_syscall = safe;
+}
+
 DR_API
 /* Current thread gives up its time quantum. */
 void
diff --git a/core/loader_shared.c b/core/loader_shared.c
index 339805e41..3674912a8 100644
--- a/core/loader_shared.c
+++ b/core/loader_shared.c
@@ -452,6 +452,14 @@ privload_lookup_by_base(app_pc modbase)
     return NULL;
 }
 
+// HACK
+privmod_t* privload_lookup_by_pc_takelock(app_pc pc) {
+    acquire_recursive_lock(&privload_lock);
+    privmod_t *res = privload_lookup_by_pc(pc);
+    release_recursive_lock(&privload_lock);
+    return res;
+}
+
 /* Lookup the private loaded library by base */
 privmod_t *
 privload_lookup_by_pc(app_pc pc)
@@ -925,20 +933,16 @@ loader_allow_unsafe_static_behavior(void)
  */
 #define REDIRECT_HEADER_SHIFTED (1ULL << IF_X64_ELSE(63, 31))
 
-/* This routine allocates memory from DR's global memory pool.  Unlike
- * dr_global_alloc(), however, we store the size of the allocation in
- * the first few bytes so redirect_free() can retrieve it.  We also align
- * to the standard alignment used by most allocators.  This memory
- * is also not guaranteed-reachable.
- */
-void *
-redirect_malloc(size_t size)
-{
+static void *
+private_alloc(size_t alignment, size_t size) {
     void *mem;
+    if (alignment < STANDARD_HEAP_ALIGNMENT) {
+        alignment = STANDARD_HEAP_ALIGNMENT;
+    }
     /* We need extra space to store the size and alignment bit and ensure the returned
      * pointer is aligned.
      */
-    size_t alloc_size = size + sizeof(size_t) + STANDARD_HEAP_ALIGNMENT - HEAP_ALIGNMENT;
+    size_t alloc_size = size + sizeof(size_t) + alignment - HEAP_ALIGNMENT;
     /* Our header is the size itself, with the top bit stolen to indicate alignment. */
     if (TEST(REDIRECT_HEADER_SHIFTED, alloc_size)) {
         /* We do not support the top bit being set as that conflicts with the bit in
@@ -954,15 +958,15 @@ redirect_malloc(size_t size)
         return NULL;
     }
     ptr_uint_t res =
-        ALIGN_FORWARD((ptr_uint_t)mem + sizeof(size_t), STANDARD_HEAP_ALIGNMENT);
+        ALIGN_FORWARD((ptr_uint_t)mem + sizeof(size_t), alignment);
     size_t header = alloc_size;
     ASSERT(HEAP_ALIGNMENT * 2 == STANDARD_HEAP_ALIGNMENT);
     ASSERT(!TEST(REDIRECT_HEADER_SHIFTED, header));
     if (res == (ptr_uint_t)mem + sizeof(size_t)) {
         /* Already aligned. */
-    } else if (res == (ptr_uint_t)mem + sizeof(size_t) * 2) {
-        /* DR's alignment is "odd" for double-pointer so we're adding one pointer. */
+    } else if (res >= (ptr_uint_t)mem + sizeof(size_t) * 2) {
         header |= REDIRECT_HEADER_SHIFTED;
+        *(size_t*)(res - 2 * sizeof(size_t)) = res - 2 * sizeof(size_t) - (ptr_uint_t)mem;
     } else
         ASSERT_NOT_REACHED();
     *((size_t *)(res - sizeof(size_t))) = header;
@@ -970,6 +974,24 @@ redirect_malloc(size_t size)
     return (void *)res;
 }
 
+/* This routine allocates memory from DR's global memory pool.  Unlike
+ * dr_global_alloc(), however, we store the size of the allocation in
+ * the first few bytes so redirect_free() can retrieve it.  We also align
+ * to the standard alignment used by most allocators.  This memory
+ * is also not guaranteed-reachable.
+ */
+void *
+redirect_malloc(size_t size)
+{
+    return private_alloc(STANDARD_HEAP_ALIGNMENT, size);
+}
+
+int
+redirect_posix_memalign(void **memptr, size_t alignment, size_t size) {
+    *memptr = private_alloc(alignment, size);
+    return 0;
+}
+
 /* Returns the underlying DR allocation's size and starting point, given a
  * wrapped-malloc-layer pointer from a client/privlib.
  */
@@ -982,6 +1004,8 @@ redirect_malloc_size_and_start(void *mem, OUT void **start_out)
     if (TEST(REDIRECT_HEADER_SHIFTED, size)) {
         start = size_ptr - 1;
         size &= ~REDIRECT_HEADER_SHIFTED;
+
+        start -= *(size_ptr - 1);
     }
     if (start_out != NULL)
         *start_out = start;
@@ -995,12 +1019,7 @@ redirect_malloc_requested_size(void *mem)
         return 0;
     void *start;
     size_t size = redirect_malloc_size_and_start(mem, &start);
-    size -= sizeof(size_t);
-    if (start != mem) {
-        /* Subtract the extra size for alignment. */
-        size -= sizeof(size_t);
-    }
-    return size;
+    return (size_t)(start + size - mem);
 }
 
 /* This routine allocates memory from DR's global memory pool. Unlike
diff --git a/core/module_shared.h b/core/module_shared.h
index 5499f27e5..ad0c41247 100644
--- a/core/module_shared.h
+++ b/core/module_shared.h
@@ -492,6 +492,9 @@ privload_lookup_by_base(app_pc modbase);
 privmod_t *
 privload_lookup_by_pc(app_pc modbase);
 
+DR_API privmod_t *
+privload_lookup_by_pc_takelock(app_pc modbase);
+
 /* name is assumed to be in immutable persistent storage.
  * a copy of path is made.
  */
@@ -614,6 +617,9 @@ redirect_calloc(size_t nmemb, size_t size);
 void *
 redirect_malloc(size_t size);
 
+int
+redirect_posix_memalign(void **memptr, size_t alignment, size_t size);
+
 void
 redirect_free(void *mem);
 
diff --git a/core/os_shared.h b/core/os_shared.h
index 4e1150109..e5d06c655 100644
--- a/core/os_shared.h
+++ b/core/os_shared.h
@@ -455,7 +455,7 @@ os_page_size(void);
 /* This also tries to set other auxv values. */
 void
 os_page_size_init(const char **env, bool env_followed_by_auxv);
-size_t
+DR_API size_t
 os_minsigstksz(void);
 #endif
 bool
@@ -1200,7 +1200,7 @@ load_private_library(const char *filename, bool reachable);
 bool
 unload_private_library(app_pc modbase);
 /* searches in standard paths instead of requiring abs path */
-app_pc
+DR_API app_pc
 locate_and_load_private_library(const char *name, bool reachable);
 void
 loader_init_prologue(void);
diff --git a/core/synch.c b/core/synch.c
index f5eef1e5c..91f5a16bd 100644
--- a/core/synch.c
+++ b/core/synch.c
@@ -513,6 +513,9 @@ should_suspend_client_thread(dcontext_t *dcontext, thread_synch_state_t desired_
 {
     /* Marking un-suspendable does not apply to cleaning/terminating */
     ASSERT(IS_CLIENT_THREAD(dcontext));
+    if (THREAD_SYNCH_IS_CLEANED(desired_state)) {
+        SYSLOG_INTERNAL_INFO("cleaning client thread " TIDFMT, dcontext->owning_thread);
+    }
     return (THREAD_SYNCH_IS_CLEANED(desired_state) || dcontext->client_data->suspendable);
 }
 
@@ -765,7 +768,7 @@ check_wait_at_safe_spot(dcontext_t *dcontext, thread_synch_permission_t cur_stat
 }
 
 /* adjusts the pending synch count */
-void
+DR_API void
 adjust_wait_at_safe_spot(dcontext_t *dcontext, int amt)
 {
     thread_synch_data_t *tsd = (thread_synch_data_t *)dcontext->synch_field;
@@ -1249,8 +1252,8 @@ synch_with_all_threads(thread_synch_state_t desired_synch_state,
 
     LOG(THREAD, LOG_SYNCH, 1,
         "synch with all threads my id = " SZFMT
-        " Giving %d permission and seeking %d state\n",
-        my_id, cur_state, desired_synch_state);
+        " Giving %d permission and seeking %d state, flags %x\n",
+        my_id, cur_state, desired_synch_state, flags);
 
     /* grab all_threads_synch_lock */
     /* since all_threads synch doesn't give any permissions this is necessary
diff --git a/core/unix/loader.c b/core/unix/loader.c
index 10c4518b0..b27284a8e 100644
--- a/core/unix/loader.c
+++ b/core/unix/loader.c
@@ -158,7 +158,7 @@ privload_locate_and_load(const char *impname, privmod_t *dependent, bool reachab
 static void
 privload_call_lib_func(fp_t func);
 
-static void
+DR_API void
 privload_relocate_mod(privmod_t *mod);
 
 static void
@@ -690,16 +690,16 @@ privload_os_finalize(privmod_t *privmod)
     os_privmod_data_t *opd = (os_privmod_data_t *)privmod->os_privmod_data;
     /* Special handling for standard I/O file descriptors. */
     privmod_stdout = (FILE **)get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_STDOUT_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_STDOUT_NAME, NULL /* symver */, NULL);
     privmod_stdin = (FILE **)get_proc_address_from_os_data(&opd->os_data, opd->load_delta,
-                                                           LIBC_STDIN_NAME, NULL);
+                                                           LIBC_STDIN_NAME, NULL /* symver */, NULL);
     privmod_stderr = (FILE **)get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_STDERR_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_STDERR_NAME, NULL /* symver */, NULL);
     /* i#5133: glibc 2.32+ has ld.so call a hardcoded initializer before calling the
      * regular ELF constructors.
      */
     void (*libc_early_init)(bool) = (void (*)(bool))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_EARLY_INIT_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_EARLY_INIT_NAME, NULL /* symver */, NULL);
     if (libc_early_init == NULL) {
         return;
     }
@@ -712,7 +712,7 @@ privload_os_finalize(privmod_t *privmod)
     /* Do not try to clobber vars unless we have to: get the libc version. */
 #    define LIBC_GET_VERSION_NAME "gnu_get_libc_version"
     const char *(*libc_ver)(void) = (const char *(*)(void))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_GET_VERSION_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_GET_VERSION_NAME, NULL /* symver */, NULL);
     if (libc_ver == NULL)
         return;
     LOG(GLOBAL, LOG_LOADER, 2, "%s: calling %s\n", __FUNCTION__, LIBC_GET_VERSION_NAME);
@@ -727,7 +727,7 @@ privload_os_finalize(privmod_t *privmod)
     }
     os_privmod_data_t *ld_opd = (os_privmod_data_t *)privmod_ld_linux->os_privmod_data;
     byte *glro = get_proc_address_from_os_data(&ld_opd->os_data, ld_opd->load_delta,
-                                               "_rtld_global_ro", NULL);
+                                               "_rtld_global_ro", NULL /* symver */, NULL);
     if (glro == NULL) {
         SYSLOG_INTERNAL_WARNING("glibc 2.34+ i#5437 workaround failed: missed glro");
         return;
@@ -1030,7 +1030,7 @@ get_private_library_address(app_pc modbase, const char *name)
     if (dynamo_heap_initialized) {
         /* opd is initialized */
         os_privmod_data_t *opd = (os_privmod_data_t *)mod->os_privmod_data;
-        res = get_proc_address_from_os_data(&opd->os_data, opd->load_delta, name, NULL);
+        res = get_proc_address_from_os_data(&opd->os_data, opd->load_delta, name, NULL /* symver */, NULL);
         release_recursive_lock(&privload_lock);
         return res;
     } else {
@@ -1050,7 +1050,7 @@ get_private_library_address(app_pc modbase, const char *name)
             release_recursive_lock(&privload_lock);
             return NULL;
         }
-        res = get_proc_address_from_os_data(&os_data, delta, name, NULL);
+        res = get_proc_address_from_os_data(&os_data, delta, name, NULL /* symver */, NULL);
         release_recursive_lock(&privload_lock);
         return res;
     }
@@ -1276,7 +1276,13 @@ privload_relocate_os_privmod_data(os_privmod_data_t *opd, byte *mod_base)
 }
 #endif /* LINUX */
 
-static void
+DR_API void privload_relocate_mod_takelock(privmod_t *mod) {
+    acquire_recursive_lock(&privload_lock);
+    privload_relocate_mod(mod);
+    release_recursive_lock(&privload_lock);
+}
+
+void
 privload_relocate_mod(privmod_t *mod)
 {
 #ifdef LINUX
@@ -1517,6 +1523,7 @@ typedef struct _redirect_import_t {
 static const redirect_import_t redirect_imports[] = {
     { "calloc", (app_pc)redirect_calloc },
     { "malloc", (app_pc)redirect_malloc },
+    { "posix_memalign", (app_pc)redirect_posix_memalign },
     { "free", (app_pc)redirect_free },
     { "realloc", (app_pc)redirect_realloc },
     { "strdup", (app_pc)redirect_strdup },
@@ -1533,8 +1540,8 @@ static const redirect_import_t redirect_imports[] = {
     /* These libc routines can call pthread functions and cause hangs (i#4928) so
      * we use our syscall wrappers instead.
      */
-    { "read", (app_pc)os_read },
-    { "write", (app_pc)os_write },
+    /* { "read", (app_pc)os_read }, */
+    /* { "write", (app_pc)os_write }, */
 #if defined(LINUX) && !defined(ANDROID)
     { "__tls_get_addr", (app_pc)redirect___tls_get_addr },
     { "___tls_get_addr", (app_pc)redirect____tls_get_addr },
@@ -1548,6 +1555,7 @@ static const redirect_import_t redirect_imports[] = {
     { "__gnu_Unwind_Find_exidx", (app_pc)redirect___gnu_Unwind_Find_exidx },
 #    endif
 #endif
+    // { "dlsym", (app_pc)redirect_dlsym },
     { "dlsym", (app_pc)redirect_dlsym },
     /* We need these for clients that don't use libc (i#1747) */
     { "strlen", (app_pc)strlen },
@@ -1569,7 +1577,12 @@ static const redirect_import_t redirect_imports[] = {
     { "memset_chk", (app_pc)memset },
     { "memmove_chk", (app_pc)memmove },
     { "strncpy_chk", (app_pc)strncpy },
+    /* { "__errno_location", (app_pc)__errno_location } */
 };
+
+DR_API redirect_import_t *client_redirect_imports = NULL;
+DR_API int client_redirect_imports_count = 0;
+
 #define REDIRECT_IMPORTS_NUM (sizeof(redirect_imports) / sizeof(redirect_imports[0]))
 
 #ifdef DEBUG
@@ -1599,6 +1612,15 @@ privload_redirect_sym(os_privmod_data_t *opd, ptr_uint_t *r_addr, const char *na
         }
     }
 #endif
+    for (i = 0; i < client_redirect_imports_count; i++) {
+        if (strcmp(client_redirect_imports[i].name, name) == 0) {
+            if (opd->use_app_imports && client_redirect_imports[i].app_func != NULL)
+                *r_addr = (ptr_uint_t)client_redirect_imports[i].app_func;
+            else
+                *r_addr = (ptr_uint_t)client_redirect_imports[i].func;
+            return true;
+        }
+    }
     for (i = 0; i < REDIRECT_IMPORTS_NUM; i++) {
         if (strcmp(redirect_imports[i].name, name) == 0) {
             if (opd->use_app_imports && redirect_imports[i].app_func != NULL)
diff --git a/core/unix/loader_linux.c b/core/unix/loader_linux.c
index 9f5b85152..c63e58717 100644
--- a/core/unix/loader_linux.c
+++ b/core/unix/loader_linux.c
@@ -134,7 +134,7 @@ static size_t client_tls_size = 2 * 4096;
  * good way to guess how big this allocation was.  Instead we use this estimate.
  */
 /* On A32, the pthread is put before tcbhead instead tcbhead being part of pthread */
-static size_t tcb_size = IF_X86_ELSE(IF_X64_ELSE(0x900, 0x490), 0x40);
+static size_t tcb_size = IF_X86_ELSE(IF_X64_ELSE(0xc00, 0x490), 0x40);
 
 /* thread contol block header type from
  * - sysdeps/x86_64/nptl/tls.h
@@ -156,6 +156,8 @@ typedef struct _tcb_head_t {
 
     ptr_uint_t stack_guard;
     ptr_uint_t pointer_guard;
+    unsigned long int unused[2];
+    unsigned int feature_1;
 #elif defined(AARCH64)
     /* FIXME i#1569: This may be wrong! */
     void *dtv;
@@ -305,7 +307,8 @@ privload_copy_tls_block(app_pc priv_tls_base, uint mod_idx)
 void
 privload_mod_tls_primary_thread_init(privmod_t *mod)
 {
-    ASSERT(!dynamo_initialized);
+    // ASSERT(!dynamo_initialized);
+
     /* Copy ELF block for primary thread for use in init funcs (i#2751).
      * We do this after relocs and assume reloc ifuncs don't need this:
      * else we'd have to assume there are no relocs in the TLS blocks.
@@ -330,6 +333,7 @@ privload_tls_init(void *app_tp)
         app_tp);
     dr_tp = heap_mmap(client_tls_alloc_size, MEMPROT_READ | MEMPROT_WRITE,
                       VMM_SPECIAL_MMAP | VMM_PER_THREAD);
+    SYSLOG_INTERNAL_INFO("dr_tp: %p tcb_size: %lx\n", dr_tp, tcb_size);
     ASSERT(APP_LIBC_TLS_SIZE + TLS_PRE_TCB_SIZE + tcb_size <= client_tls_alloc_size);
 #ifdef AARCHXX
     /* GDB reads some pthread members (e.g., pid, tid), so we must make sure
@@ -373,6 +377,7 @@ privload_tls_init(void *app_tp)
     dr_tcb->self = dr_tcb;
     /* i#555: replace app's vsyscall with DR's int0x80 syscall */
     dr_tcb->sysinfo = (ptr_uint_t)client_int_syscall;
+    dr_tcb->feature_1 = 0; // this is currently used to say we don't have Intel CET
 #elif defined(AARCHXX)
     dr_tcb->dtv = NULL;
     dr_tcb->private = NULL;
diff --git a/core/unix/module.h b/core/unix/module.h
index 25616b24c..faa4be373 100644
--- a/core/unix/module.h
+++ b/core/unix/module.h
@@ -83,6 +83,10 @@ typedef struct _os_module_data_t {
     app_pc chain;           /* absolute addr of hash chain table */
     app_pc dynsym;          /* absolute addr of .dynsym */
     app_pc dynstr;          /* absolute addr of .dynstr */
+    app_pc versym;          /* absolute addr of .gnu.version */
+    app_pc verdef;          /* absolute addr of .gnu.version */
+    size_t verdefnum;          /* absolute addr of .gnu.version */
+    app_pc verdefstrtab;          /* absolute addr of .gnu.version */
     size_t dynstr_size;     /* size of .dynstr */
     size_t symentry_size;   /* size of a .dynsym entry */
     bool has_runpath;       /* is DT_RUNPATH present? */
@@ -167,7 +171,7 @@ extern stdfile_t **privmod_stderr;
 extern stdfile_t **privmod_stdin;
 
 /* loader.c */
-app_pc
+DR_API app_pc
 get_private_library_address(app_pc modbase, const char *name);
 
 bool
diff --git a/core/unix/module_elf.c b/core/unix/module_elf.c
index 9ba999c21..b46723900 100644
--- a/core/unix/module_elf.c
+++ b/core/unix/module_elf.c
@@ -283,6 +283,14 @@ module_fill_os_data(ELF_PROGRAM_HEADER_TYPE *prog_hdr, /* PT_DYNAMIC entry */
                         out_data->symentry_size = (size_t)dyn->d_un.d_val;
                     } else if (dyn->d_tag == DT_RUNPATH) {
                         out_data->has_runpath = true;
+                    } else if (dyn->d_tag == DT_VERSYM) {
+                        out_data->versym = elf_dt_abs_addr(dyn, base, sz, view_size,
+                                                          load_delta, at_map, dyn_reloc);
+                    } else if (dyn->d_tag == DT_VERDEF) {
+                        out_data->verdef = elf_dt_abs_addr(dyn, base, sz, view_size,
+                                                          load_delta, at_map, dyn_reloc);
+                    } else if (dyn->d_tag == DT_VERDEFNUM) {
+                        out_data->verdefnum = (size_t)dyn->d_un.d_val;
 #ifndef ANDROID
                     } else if (dyn->d_tag == DT_CHECKSUM) {
                         out_data->checksum = (size_t)dyn->d_un.d_val;
@@ -643,9 +651,17 @@ elf_sym_matches(ELF_SYM_TYPE *sym, char *strtab, const char *name,
 /* The new GNU hash scheme to improve lookup speed.
  * Can't find good doc to reference here.
  */
+
+#define VERSYM_VERSION 0x7fff
+#define VERSYM_HIDDEN 0x8000
+
+// TODO: Right now, this function does not actually deal with symbol versioning.
+// Most of the work is done, to parse symbol versions / definitions in the loaded library
+// but we don't actually return a specific symbol version (we
+// return the default version for now).
 static app_pc
-gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
-                char *strtab, Elf_Symndx *buckets, Elf_Symndx *chain, ELF_ADDR *bitmask,
+gnu_hash_lookup(const char *name, Elf64_Word *symver_hash, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
+                char *strtab, Elf64_Half *symvertab, Elf64_Verdef *verdef, size_t verdefnum, Elf_Symndx *buckets, Elf_Symndx *chain, ELF_ADDR *bitmask,
                 ptr_uint_t bitidx, ptr_uint_t shift, size_t num_buckets,
                 size_t dynstr_size, bool *is_indirect_code)
 {
@@ -678,8 +694,32 @@ gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
                     if (sym->st_value == 0 && ELF_ST_TYPE(sym->st_info) != STT_TLS)
                         continue; /* no value */
                     if (elf_sym_matches(sym, strtab, name, is_indirect_code)) {
-                        res = (app_pc)(symtab[sidx].st_value + load_delta);
-                        break;
+                        if (symvertab) {
+                            Elf64_Half ver = symvertab[sidx];
+                            Elf64_Word verhash = 0;
+                            for (size_t i=0; i<verdefnum; i++) {
+                                // Elf64_Verdaux *vdaux = (Elf64_Verdaux *)((char *)vd + vd->vd_aux);
+                                if (verdef->vd_ndx == (ver & VERSYM_VERSION)) {
+                                    verhash = verdef->vd_hash;
+                                    break;
+                                }
+                                verdef = (Elf64_Verdef *)((char *)verdef + verdef->vd_next);
+                            }
+
+                            if ((ver & VERSYM_HIDDEN) == 0 || ver == VER_NDX_GLOBAL) {
+                                // Default version
+                                res = (app_pc)(symtab[sidx].st_value + load_delta);
+                                LOG(GLOBAL, LOG_LOADER, 2, "%s: found %s default version %hd %d target %d\n", __func__, name, ver, verhash, symver_hash ? *symver_hash : -1);
+                                break;
+                            } else {
+                                // Non-default version
+                                LOG(GLOBAL, LOG_LOADER, 2, "%s: skip %s non-default version %hd %d target %d\n", __func__, name, ver, verhash, symver_hash ? *symver_hash : -1);
+                                if (!res) res = (app_pc)(symtab[sidx].st_value + load_delta);
+                            }
+                        } else {
+                            res = (app_pc)(symtab[sidx].st_value + load_delta);
+                            break;
+                        }
                     }
                 }
             } while (!TEST(1, *harray++));
@@ -693,12 +733,13 @@ gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
  */
 static app_pc
 elf_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
-                char *strtab, Elf_Symndx *buckets, Elf_Symndx *chain, size_t num_buckets,
+                char *strtab, const Elf64_Half* symvertab, Elf_Symndx *buckets, Elf_Symndx *chain, size_t num_buckets,
                 size_t dynstr_size, bool *is_indirect_code)
 {
     Elf_Symndx sidx;
     Elf_Symndx hidx;
     ELF_SYM_TYPE *sym;
+
     app_pc res;
 
     hidx = elf_hash(name);
@@ -726,24 +767,28 @@ elf_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
 /* get the address by using the hashtable information in os_module_data_t */
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t load_delta,
-                              const char *name, OUT bool *is_indirect_code)
+                              const char *name, void *symver, OUT bool *is_indirect_code)
 {
     if (os_data->hashtab != NULL) {
         Elf_Symndx *buckets = (Elf_Symndx *)os_data->buckets;
         Elf_Symndx *chain = (Elf_Symndx *)os_data->chain;
         ELF_SYM_TYPE *symtab = (ELF_SYM_TYPE *)os_data->dynsym;
+        Elf64_Half *vertab = (Elf64_Half *)os_data->versym;
+        Elf64_Verdef *verdef = (Elf64_Verdef *)os_data->verdef;
+        size_t verdefnum = os_data->verdefnum;
+
         char *strtab = (char *)os_data->dynstr;
         size_t num_buckets = os_data->num_buckets;
         if (os_data->hash_is_gnu) {
             /* The new GNU hash scheme */
-            return gnu_hash_lookup(name, load_delta, symtab, strtab, buckets, chain,
+            return gnu_hash_lookup(name, (Elf64_Word*)symver, load_delta, symtab, strtab, vertab, verdef, verdefnum, buckets, chain,
                                    (ELF_ADDR *)os_data->gnu_bitmask,
                                    (ptr_uint_t)os_data->gnu_bitidx,
                                    (ptr_uint_t)os_data->gnu_shift, num_buckets,
                                    os_data->dynstr_size, is_indirect_code);
         } else {
             /* ELF hash scheme */
-            return elf_hash_lookup(name, load_delta, symtab, strtab, buckets, chain,
+            return elf_hash_lookup(name, load_delta, symtab, strtab, vertab, buckets, chain,
                                    num_buckets, os_data->dynstr_size, is_indirect_code);
         }
     }
@@ -763,7 +808,7 @@ get_proc_address_ex(module_base_t lib, const char *name, bool *is_indirect_code
     ma = module_pc_lookup((app_pc)lib);
     if (ma != NULL) {
         res = get_proc_address_from_os_data(
-            &ma->os_data, ma->start - ma->os_data.base_address, name, &is_ifunc);
+            &ma->os_data, ma->start - ma->os_data.base_address, name, NULL /* symver */, &is_ifunc);
         /* XXX: for the case of is_indirect_code being true, should we call
          * the ifunc to get the real symbol location?
          * Current solution is:
@@ -972,6 +1017,8 @@ module_init_os_privmod_data_from_dyn(os_privmod_data_t *opd, ELF_DYNAMIC_ENTRY_T
         case DT_VERNEED: opd->verneed = (app_pc)(dyn->d_un.d_ptr + load_delta); break;
         case DT_VERNEEDNUM: opd->verneednum = dyn->d_un.d_val; break;
         case DT_VERSYM: opd->versym = (ELF_HALF *)(dyn->d_un.d_ptr + load_delta); break;
+        case DT_VERDEF: opd->verdef = (ELF_HALF *)(dyn->d_un.d_ptr + load_delta); break;
+        case DT_VERDEFNUM: opd->verdefnum = dyn->d_un.d_val;; break;
         case DT_RELCOUNT: opd->relcount = dyn->d_un.d_val; break;
         case DT_INIT: opd->init = (fp_t)(dyn->d_un.d_ptr + load_delta); break;
         case DT_FINI: opd->fini = (fp_t)(dyn->d_un.d_ptr + load_delta); break;
@@ -1054,7 +1101,7 @@ module_get_os_privmod_data(app_pc base, size_t size, bool dyn_reloc,
     module_init_os_privmod_data_from_dyn(pd, dyn, load_delta);
     DODEBUG({
         if (get_proc_address_from_os_data(&pd->os_data, pd->load_delta,
-                                          DR_DISALLOW_UNSAFE_STATIC_NAME, NULL) != NULL)
+                                          DR_DISALLOW_UNSAFE_STATIC_NAME, NULL /* symver */, NULL) != NULL)
             disallow_unsafe_static_calls = true;
     });
     pd->use_app_imports = false;
@@ -1099,7 +1146,7 @@ static app_pc
 module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
 {
     app_pc res;
-    const char *name;
+    const char *name, *version;
     privmod_t *mod;
     bool is_ifunc;
     dcontext_t *dcontext = get_thread_private_dcontext();
@@ -1109,9 +1156,11 @@ module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
         return NULL;
 
     name = (char *)pd->os_data.dynstr + sym->st_name;
+    version = NULL;
+    // version = pd->os_data.
     LOG(GLOBAL, LOG_LOADER, 3, "sym lookup for %s from %s\n", name, pd->soname);
     /* check my current module */
-    res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, &is_ifunc);
+    res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, NULL /* symver */, &is_ifunc);
     if (res != NULL) {
         if (is_ifunc) {
             TRY_EXCEPT_ALLOW_NO_DCONTEXT(
@@ -1154,7 +1203,7 @@ module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
             LOG(GLOBAL, LOG_LOADER, 3, "NOT using libpthread's non-pthread symbol\n");
             res = NULL;
         } else {
-            res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name,
+            res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, NULL /* symver */,
                                                 &is_ifunc);
         }
         if (res != NULL) {
diff --git a/core/unix/module_macho.c b/core/unix/module_macho.c
index c3e9286aa..f2b697c42 100644
--- a/core/unix/module_macho.c
+++ b/core/unix/module_macho.c
@@ -357,7 +357,7 @@ read_uleb128(byte *start, byte *max, byte **next_entry OUT)
 
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t load_delta,
-                              const char *name, OUT bool *is_indirect_code)
+                              const char *name, const char *symver, OUT bool *is_indirect_code)
 {
     /* Walk the Mach-O export trie.  We don't support < 10.6 which is when
      * they put this scheme in place.
@@ -477,7 +477,7 @@ get_proc_address_ex(module_base_t lib, const char *name, bool *is_indirect_code
                                                  */
                                                 (ptr_int_t)ma->start
                                                 : ma->start - ma->os_data.base_address,
-                                            name, is_indirect_code);
+                                            name, NULL /* symver */, is_indirect_code);
     }
     os_get_module_info_unlock();
     LOG(GLOBAL, LOG_SYMBOLS, 2, "%s: %s => " PFX "\n", __func__, name, res);
diff --git a/core/unix/module_private.h b/core/unix/module_private.h
index d98df70db..f106ce611 100644
--- a/core/unix/module_private.h
+++ b/core/unix/module_private.h
@@ -72,6 +72,8 @@ struct _os_privmod_data_t {
     int verneednum;
     int relcount;
     ELF_HALF *versym;
+    ELF_HALF *verdef;
+    int verdefnum;
 #else
     /* XXX i#1285: MacOS private loader NYI */
 #endif
@@ -123,7 +125,7 @@ module_get_text_section(app_pc file_map, size_t file_size);
 
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t delta,
-                              const char *name, bool *is_indirect_code OUT);
+                              const char *name, void *symver, bool *is_indirect_code OUT);
 
 bool
 privload_redirect_sym(os_privmod_data_t *opd, ptr_uint_t *r_addr, const char *name);
diff --git a/core/unix/os.c b/core/unix/os.c
index d5133bf16..106d0672a 100644
--- a/core/unix/os.c
+++ b/core/unix/os.c
@@ -3761,8 +3761,13 @@ os_thread_sleep(uint64 milliseconds)
         /* not unusual for client threads to use itimers and have their run
          * routine sleep forever
          */
+
         if (count++ > 3 && !IS_CLIENT_THREAD(get_thread_private_dcontext())) {
-            ASSERT_NOT_REACHED();
+            // ATH: We are hitting this case in release builds, and it seems to be breaking
+            // some stuff. Removed the assert for now -- breaking should be ok because
+            // sleeps are always allowed to return early.
+            //
+            // ASSERT_NOT_REACHED();
             break; /* paranoid */
         }
         req = remain;
@@ -3848,6 +3853,7 @@ os_thread_suspend(thread_record_t *tr)
         if (ksynch_wait(&ostd->suspended, 0, SUSPEND_DEBUG_TIMEOUT_MS) == -ETIMEDOUT) {
             ASSERT_CURIOSITY(false && "failed to suspend thread in 5s");
         }
+        LOG(GLOBAL, LOG_SYNCH, 2, "os_thread_suspend: suspended = %d for thread %d\n", ksynch_get_value(&ostd->suspended), tr->id);
         if (ksynch_get_value(&ostd->suspended) == 0) {
             /* If it still has to wait, give up the cpu. */
             os_thread_yield();
diff --git a/core/unix/os_exports.h b/core/unix/os_exports.h
index c234c265c..304819704 100644
--- a/core/unix/os_exports.h
+++ b/core/unix/os_exports.h
@@ -299,6 +299,7 @@ dynamorio_set_envp(char **envp);
 /* drinjectlib wants the libc version while the core wants the private version */
 #    define getenv our_getenv
 #endif
+DR_API
 char *
 our_getenv(const char *name);
 
diff --git a/core/unix/rseq_linux.c b/core/unix/rseq_linux.c
index 4d3b9e60f..4ce713450 100644
--- a/core/unix/rseq_linux.c
+++ b/core/unix/rseq_linux.c
@@ -253,12 +253,14 @@ rseq_clear_tls_ptr(dcontext_t *dcontext)
 {
     ASSERT(rseq_tls_offset != 0);
     byte *base = get_app_segment_base(LIB_SEG_TLS);
-    struct rseq *app_rseq = (struct rseq *)(base + rseq_tls_offset);
-    /* We're directly writing this in the cache, so we do not bother with safe_read
-     * or safe_write here either.  We already cannot handle rseq adversarial cases.
-     */
-    if (is_dynamo_address((byte *)(ptr_uint_t)app_rseq->rseq_cs))
-        app_rseq->rseq_cs = 0;
+    if (base > 0) {
+        struct rseq *app_rseq = (struct rseq *)(base + rseq_tls_offset);
+        /* We're directly writing this in the cache, so we do not bother with safe_read
+         * or safe_write here either.  We already cannot handle rseq adversarial cases.
+         */
+        if (is_dynamo_address((byte *)(ptr_uint_t)app_rseq->rseq_cs))
+            app_rseq->rseq_cs = 0;
+    }
 }
 
 int
diff --git a/core/unix/signal.c b/core/unix/signal.c
index 0cbc94337..51ef52f80 100644
--- a/core/unix/signal.c
+++ b/core/unix/signal.c
@@ -3193,20 +3193,10 @@ thread_set_self_context(void *cxt)
     ASSERT_NOT_IMPLEMENTED(false); /* PR 405694: can't use regular sigreturn! */
 #endif
     memset(&frame, 0, sizeof(frame));
-#if defined(X86)
-    dcontext_t *dcontext = get_thread_private_dcontext();
-#endif
 #ifdef LINUX
-#    ifdef X86
-    byte *xstate = get_and_initialize_xstate_buffer(dcontext);
-    frame.uc.uc_mcontext.fpstate = &((kernel_xstate_t *)xstate)->fpstate;
-#    endif /* X86 */
     frame.uc.uc_mcontext = *sc;
 #endif
     IF_ARM(ASSERT_NOT_TESTED());
-#if defined(X86)
-    save_fpstate(dcontext, &frame);
-#endif
     /* The kernel calls do_sigaltstack on sys_rt_sigreturn primarily to ensure
      * the frame is ok, but the side effect is we can mess up our own altstack
      * settings if we're not careful.  Having invalid ss_size looks good for
@@ -3295,7 +3285,9 @@ thread_set_self_mcontext(priv_mcontext_t *mc)
     sig_full_cxt_t sc_full;
     sig_full_initialize(&sc_full, &ucxt);
 #if defined(LINUX) && defined(X86)
-    sc_full.sc->fpstate = NULL; /* for mcontext_to_sigcontext */
+    /* for mcontext_to_sigcontext to fill in with saved fp state */
+     sc_full.sc->fpstate = (kernel_fpstate_t *)get_and_initialize_xstate_buffer(
+         get_thread_private_dcontext());
 #endif
     mcontext_to_sigcontext(&sc_full, mc, DR_MC_ALL);
     thread_set_segment_registers(sc_full.sc);

```

`patches/dynamorio-11.2.patch`:

```patch
diff --git a/core/arch/aarch64/proc.c b/core/arch/aarch64/proc.c
index 0c8758229..84a088849 100644
--- a/core/arch/aarch64/proc.c
+++ b/core/arch/aarch64/proc.c
@@ -36,12 +36,45 @@
 #include "arch.h"
 #include "instr.h"
 
+#if defined(MACOS)
+#    include <sys/sysctl.h>
+#endif
+
 static int num_simd_saved;
 static int num_simd_registers;
 static int num_svep_registers;
 static int num_ffr_registers;
 static int num_opmask_registers;
 
+#    define GET_FEAT_REG(FEATURE) (feature_reg_idx_t)((((ushort)FEATURE) & 0x3F00) >> 8)
+#    define GET_FEAT_NIBPOS(FEATURE) ((((ushort)FEATURE) & 0x00F0) >> 4)
+#    define GET_FEAT_VAL(FEATURE) (((ushort)FEATURE) & 0x000F)
+#    define GET_FEAT_NSFLAG(FEATURE) ((((ushort)FEATURE) & 0x8000) >> 15)
+#    define GET_FEAT_EXACT_MATCH(FEATURE) ((((ushort)FEATURE) & 0x4000) >> 14)
+
+void
+proc_set_feature(feature_bit_t feature_bit, bool enable)
+{
+    uint64 *freg_val = cpu_info.features.isa_features;
+    ushort feat_nibble = GET_FEAT_NIBPOS(feature_bit);
+    bool feat_nsflag = GET_FEAT_NSFLAG(feature_bit);
+    uint64 feat_val = GET_FEAT_VAL(feature_bit);
+
+    feature_reg_idx_t feat_reg = GET_FEAT_REG(feature_bit);
+    freg_val += feat_reg;
+
+    /* Clear the current feature state. */
+    *freg_val &= ~(0xFULL << (feat_nibble * 4));
+    if (enable) {
+        /* Write the feature value into the feature nibble. */
+        *freg_val |= feat_val << (feat_nibble * 4);
+    } else if (feat_nsflag) {
+        /* If the not-set flag is 0xF, then that needs manually setting. */
+        *freg_val |= 0xF << (feat_nibble * 4);
+    }
+}
+
+
 #ifndef DR_HOST_NOT_TARGET
 
 #    define NUM_FEATURE_REGISTERS (sizeof(features_t) / sizeof(uint64))
@@ -146,6 +179,33 @@ get_processor_specific_info(void)
     dr_set_vector_length(256);
 #        endif
 }
+#    else /* !defined(MACOS) */
+
+/* On macOS, MRS appears to be restricted. We'll use sysctl's instead. */
+static void
+get_processor_specific_info(void)
+{
+    memset(&cpu_info.features, 0, sizeof(cpu_info.features));
+
+    /* get FEATURE_PTRAUTH from sysctl hw.optional.arm.FEAT_PAuth */
+
+    char buf[32];
+    size_t buflen = 32;
+
+#        define SET_FEAT_FROM_SYSCTL(FEATURE, SYSCTL)                        \
+            if (sysctlbyname(SYSCTL, &buf, &buflen, NULL, 0) == -1) {        \
+                ASSERT_CURIOSITY(false && SYSCTL " sysctl failed");          \
+                SYSLOG_INTERNAL_WARNING("Failed to read " SYSCTL " sysctl"); \
+            } else if (buflen == 4) {                                        \
+                uint32_t val = *(uint32_t *)buf;                             \
+                if (val == 1) {                                              \
+                    proc_set_feature(FEATURE, true);                         \
+                }                                                            \
+            }
+
+    SET_FEAT_FROM_SYSCTL(FEATURE_PAUTH, "hw.optional.arm.FEAT_PAuth");
+    SET_FEAT_FROM_SYSCTL(FEATURE_FPAC, "hw.optional.arm.FEAT_FPAC");
+}
 #    endif
 
 #    define LOG_FEATURE(feature)       \
@@ -172,7 +232,8 @@ proc_init_arch(void)
     }
 
 #ifndef DR_HOST_NOT_TARGET
-#    if !defined(MACOS) // TODO i#5383: Get this working on Mac. */
+#    if !defined(MACOS) || \
+        (defined(MACOS) && defined(AARCH64)) // TODO i#5383: Get this working on Mac. */
     get_processor_specific_info();
 
     DOLOG(1, LOG_TOP, {
@@ -251,34 +312,6 @@ proc_init_arch(void)
 #endif
 }
 
-#define GET_FEAT_REG(FEATURE) (feature_reg_idx_t)((((ushort)FEATURE) & 0x3F00) >> 8)
-#define GET_FEAT_NIBPOS(FEATURE) ((((ushort)FEATURE) & 0x00F0) >> 4)
-#define GET_FEAT_VAL(FEATURE) (((ushort)FEATURE) & 0x000F)
-#define GET_FEAT_NSFLAG(FEATURE) ((((ushort)FEATURE) & 0x8000) >> 15)
-#define GET_FEAT_EXACT_MATCH(FEATURE) ((((ushort)FEATURE) & 0x4000) >> 14)
-
-void
-proc_set_feature(feature_bit_t feature_bit, bool enable)
-{
-    uint64 *freg_val = cpu_info.features.isa_features;
-    ushort feat_nibble = GET_FEAT_NIBPOS(feature_bit);
-    bool feat_nsflag = GET_FEAT_NSFLAG(feature_bit);
-    uint64 feat_val = GET_FEAT_VAL(feature_bit);
-
-    feature_reg_idx_t feat_reg = GET_FEAT_REG(feature_bit);
-    freg_val += feat_reg;
-
-    /* Clear the current feature state. */
-    *freg_val &= ~(0xFULL << (feat_nibble * 4));
-    if (enable) {
-        /* Write the feature value into the feature nibble. */
-        *freg_val |= feat_val << (feat_nibble * 4);
-    } else if (feat_nsflag) {
-        /* If the not-set flag is 0xF, then that needs manually setting. */
-        *freg_val |= 0xF << (feat_nibble * 4);
-    }
-}
-
 void
 enable_all_test_cpu_features()
 {
diff --git a/core/heap.c b/core/heap.c
index 168084a8c..5695b8981 100644
--- a/core/heap.c
+++ b/core/heap.c
@@ -122,7 +122,7 @@ static const uint BLOCK_SIZES[] = {
     sizeof(fragment_t) + sizeof(direct_linkstub_t) +
         sizeof(cbr_fallthrough_linkstub_t), /* 60 dbg / 56 rel */
 #    ifndef DEBUG
-    sizeof(instr_t), /* 72 */
+    sizeof(instr_t),                        /* 72 */
 #    endif
 #endif
     /* we keep this bucket even though only 10% or so of normal bbs
@@ -1955,6 +1955,7 @@ vmh_exit(vm_heap_t *vmh, bool contains_stacks)
                                 : (DYNAMO_OPTION(stack_guard_pages) ? PAGE_SIZE : 0)),
                        DYNAMO_OPTION(vmm_block_size)) /
                    DYNAMO_OPTION(vmm_block_size));
+
         uint unfreed_blocks;
         if (!contains_stacks || standalone_library)
             unfreed_blocks = 0;
diff --git a/core/iox.h b/core/iox.h
index e9f4ee272..c0329c228 100644
--- a/core/iox.h
+++ b/core/iox.h
@@ -706,9 +706,7 @@ TNAME(d_r_vsnprintf)(TCHAR *s, size_t max, const TCHAR *fmt, va_list ap)
             c++;
         } else {
             const TCHAR *cstart = c;
-            int nbytes = 0;
             while (*c && *c != _T('%')) {
-                nbytes++;
                 c++;
             }
             while (cstart < c) {
diff --git a/core/ir/opnd_shared.c b/core/ir/opnd_shared.c
index 11ae3eb0d..c077ffc3a 100644
--- a/core/ir/opnd_shared.c
+++ b/core/ir/opnd_shared.c
@@ -2198,7 +2198,7 @@ DR_API
 bool
 reg_get_value_ex(reg_id_t reg, dr_mcontext_t *mc, DR_PARAM_OUT byte *val)
 {
-#ifdef X86
+#if defined(X86)
     if (reg >= DR_REG_START_MMX && reg <= DR_REG_STOP_MMX) {
         get_mmx_val((uint64 *)val, reg - DR_REG_START_MMX);
     } else if (reg >= DR_REG_START_XMM && reg <= DR_REG_STOP_XMM) {
diff --git a/core/lib/dr_tools.h b/core/lib/dr_tools.h
index 8a56eb772..f016fe93a 100644
--- a/core/lib/dr_tools.h
+++ b/core/lib/dr_tools.h
@@ -2144,6 +2144,11 @@ DR_API
 void
 dr_thread_yield(void);
 
+DR_API
+/** Current thread gives up its time quantum. */
+void
+dr_set_safe_for_sync(bool safe);
+
 /** Flags controlling the behavior of dr_suspend_all_other_threads_ex(). */
 typedef enum {
     /**
diff --git a/core/lib/instrument.c b/core/lib/instrument.c
index 2b7e4be9b..142d48d02 100644
--- a/core/lib/instrument.c
+++ b/core/lib/instrument.c
@@ -148,6 +148,9 @@ typedef struct _callback_list_t {
  */
 /*
  */
+
+void print_xmm0(int);
+
 #define FAST_COPY_SIZE 5
 #define call_all_ret(ret, retop, postop, vec, type, ...)                         \
     do {                                                                         \
@@ -872,7 +875,7 @@ instrument_exit_event(void)
     /* support dr_get_mcontext() from the exit event */
     if (!standalone_library)
         get_thread_private_dcontext()->client_data->mcontext_in_dcontext = true;
-    call_all(exit_callbacks, int (*)(),
+    call_all(exit_callbacks, int (*)(void *),
              /* It seems the compiler is confused if we pass no var args
               * to the call_all macro.  Bogus NULL arg */
              NULL);
@@ -885,13 +888,13 @@ instrument_post_attach_event(void)
         ASSERT(post_attach_callbacks.num == 0);
         return;
     }
-    call_all(post_attach_callbacks, int (*)(), NULL);
+    call_all(post_attach_callbacks, int (*)(void *), NULL);
 }
 
 void
 instrument_pre_detach_event(void)
 {
-    call_all(pre_detach_callbacks, int (*)(), NULL);
+    call_all(pre_detach_callbacks, int (*)(void *), NULL);
 }
 
 void
@@ -1492,7 +1495,7 @@ instrument_fork_init(dcontext_t *dcontext)
 void
 instrument_low_on_memory()
 {
-    call_all(low_on_memory_callbacks, int (*)());
+    call_all(low_on_memory_callbacks, int (*)(void *), NULL);
 }
 
 /* PR 536058: split the exit event from thread cleanup, to provide a
@@ -4747,6 +4750,18 @@ dr_insert_write_raw_tls(void *drcontext, instrlist_t *ilist, instr_t *where,
         });
 }
 
+DR_API
+void
+dr_set_safe_for_sync(bool safe)
+{
+    dcontext_t *dcontext = get_thread_private_dcontext();
+    CLIENT_ASSERT(!standalone_library, "API not supported in standalone mode");
+    if (IS_CLIENT_THREAD(dcontext))
+        dcontext->client_data->client_thread_safe_for_synch = safe;
+    else
+        dcontext->client_data->at_safe_to_terminate_syscall = safe;
+}
+
 DR_API
 /* Current thread gives up its time quantum. */
 void
diff --git a/core/loader_shared.c b/core/loader_shared.c
index 8e7d68fb0..e8b44974b 100644
--- a/core/loader_shared.c
+++ b/core/loader_shared.c
@@ -453,6 +453,14 @@ privload_lookup_by_base(app_pc modbase)
     return NULL;
 }
 
+// HACK
+privmod_t* privload_lookup_by_pc_takelock(app_pc pc) {
+    acquire_recursive_lock(&privload_lock);
+    privmod_t *res = privload_lookup_by_pc(pc);
+    release_recursive_lock(&privload_lock);
+    return res;
+}
+
 /* Lookup the private loaded library by base */
 privmod_t *
 privload_lookup_by_pc(app_pc pc)
@@ -927,20 +935,16 @@ loader_allow_unsafe_static_behavior(void)
  */
 #define REDIRECT_HEADER_SHIFTED (1ULL << IF_X64_ELSE(63, 31))
 
-/* This routine allocates memory from DR's global memory pool.  Unlike
- * dr_global_alloc(), however, we store the size of the allocation in
- * the first few bytes so redirect_free() can retrieve it.  We also align
- * to the standard alignment used by most allocators.  This memory
- * is also not guaranteed-reachable.
- */
-void *
-redirect_malloc(size_t size)
-{
+static void *
+private_alloc(size_t alignment, size_t size) {
     void *mem;
+    if (alignment < STANDARD_HEAP_ALIGNMENT) {
+        alignment = STANDARD_HEAP_ALIGNMENT;
+    }
     /* We need extra space to store the size and alignment bit and ensure the returned
      * pointer is aligned.
      */
-    size_t alloc_size = size + sizeof(size_t) + STANDARD_HEAP_ALIGNMENT - HEAP_ALIGNMENT;
+    size_t alloc_size = size + sizeof(size_t) + alignment - HEAP_ALIGNMENT;
     /* Our header is the size itself, with the top bit stolen to indicate alignment. */
     if (TEST(REDIRECT_HEADER_SHIFTED, alloc_size)) {
         /* We do not support the top bit being set as that conflicts with the bit in
@@ -956,15 +960,15 @@ redirect_malloc(size_t size)
         return NULL;
     }
     ptr_uint_t res =
-        ALIGN_FORWARD((ptr_uint_t)mem + sizeof(size_t), STANDARD_HEAP_ALIGNMENT);
+        ALIGN_FORWARD((ptr_uint_t)mem + sizeof(size_t), alignment);
     size_t header = alloc_size;
     ASSERT(HEAP_ALIGNMENT * 2 == STANDARD_HEAP_ALIGNMENT);
     ASSERT(!TEST(REDIRECT_HEADER_SHIFTED, header));
     if (res == (ptr_uint_t)mem + sizeof(size_t)) {
         /* Already aligned. */
-    } else if (res == (ptr_uint_t)mem + sizeof(size_t) * 2) {
-        /* DR's alignment is "odd" for double-pointer so we're adding one pointer. */
+    } else if (res >= (ptr_uint_t)mem + sizeof(size_t) * 2) {
         header |= REDIRECT_HEADER_SHIFTED;
+        *(size_t*)(res - 2 * sizeof(size_t)) = res - 2 * sizeof(size_t) - (ptr_uint_t)mem;
     } else
         ASSERT_NOT_REACHED();
     *((size_t *)(res - sizeof(size_t))) = header;
@@ -972,6 +976,24 @@ redirect_malloc(size_t size)
     return (void *)res;
 }
 
+/* This routine allocates memory from DR's global memory pool.  Unlike
+ * dr_global_alloc(), however, we store the size of the allocation in
+ * the first few bytes so redirect_free() can retrieve it.  We also align
+ * to the standard alignment used by most allocators.  This memory
+ * is also not guaranteed-reachable.
+ */
+void *
+redirect_malloc(size_t size)
+{
+    return private_alloc(STANDARD_HEAP_ALIGNMENT, size);
+}
+
+int
+redirect_posix_memalign(void **memptr, size_t alignment, size_t size) {
+    *memptr = private_alloc(alignment, size);
+    return 0;
+}
+
 /* Returns the underlying DR allocation's size and starting point, given a
  * wrapped-malloc-layer pointer from a client/privlib.
  */
@@ -984,6 +1006,8 @@ redirect_malloc_size_and_start(void *mem, DR_PARAM_OUT void **start_out)
     if (TEST(REDIRECT_HEADER_SHIFTED, size)) {
         start = size_ptr - 1;
         size &= ~REDIRECT_HEADER_SHIFTED;
+
+        start -= *(size_ptr - 1);
     }
     if (start_out != NULL)
         *start_out = start;
@@ -997,12 +1021,7 @@ redirect_malloc_requested_size(void *mem)
         return 0;
     void *start;
     size_t size = redirect_malloc_size_and_start(mem, &start);
-    size -= sizeof(size_t);
-    if (start != mem) {
-        /* Subtract the extra size for alignment. */
-        size -= sizeof(size_t);
-    }
-    return size;
+    return (size_t)(start + size - mem);
 }
 
 /* This routine allocates memory from DR's global memory pool. Unlike
diff --git a/core/module_shared.h b/core/module_shared.h
index a9f64e23a..c1ba22345 100644
--- a/core/module_shared.h
+++ b/core/module_shared.h
@@ -498,6 +498,9 @@ privload_lookup_by_base(app_pc modbase);
 privmod_t *
 privload_lookup_by_pc(app_pc modbase);
 
+DR_API privmod_t *
+privload_lookup_by_pc_takelock(app_pc modbase);
+
 /* name is assumed to be in immutable persistent storage.
  * a copy of path is made.
  */
@@ -621,6 +624,9 @@ redirect_calloc(size_t nmemb, size_t size);
 void *
 redirect_malloc(size_t size);
 
+int
+redirect_posix_memalign(void **memptr, size_t alignment, size_t size);
+
 void
 redirect_free(void *mem);
 
diff --git a/core/os_shared.h b/core/os_shared.h
index 147fca893..6aad705d9 100644
--- a/core/os_shared.h
+++ b/core/os_shared.h
@@ -462,7 +462,7 @@ os_page_size(void);
 /* This also tries to set other auxv values. */
 void
 os_page_size_init(const char **env, bool env_followed_by_auxv);
-size_t
+DR_API size_t
 os_minsigstksz(void);
 #endif
 bool
@@ -1207,7 +1207,7 @@ load_private_library(const char *filename, bool reachable);
 bool
 unload_private_library(app_pc modbase);
 /* searches in standard paths instead of requiring abs path */
-app_pc
+DR_API app_pc
 locate_and_load_private_library(const char *name, bool reachable);
 void
 loader_init_prologue(void);
diff --git a/core/synch.c b/core/synch.c
index eba8fb5b6..e4b23fd82 100644
--- a/core/synch.c
+++ b/core/synch.c
@@ -517,6 +517,9 @@ should_suspend_client_thread(dcontext_t *dcontext, thread_synch_state_t desired_
 {
     /* Marking un-suspendable does not apply to cleaning/terminating */
     ASSERT(IS_CLIENT_THREAD(dcontext));
+    if (THREAD_SYNCH_IS_CLEANED(desired_state)) {
+        SYSLOG_INTERNAL_INFO("cleaning client thread " TIDFMT, dcontext->owning_thread);
+    }
     return (THREAD_SYNCH_IS_CLEANED(desired_state) || dcontext->client_data->suspendable);
 }
 
@@ -769,7 +772,7 @@ check_wait_at_safe_spot(dcontext_t *dcontext, thread_synch_permission_t cur_stat
 }
 
 /* adjusts the pending synch count */
-void
+DR_API void
 adjust_wait_at_safe_spot(dcontext_t *dcontext, int amt)
 {
     thread_synch_data_t *tsd = (thread_synch_data_t *)dcontext->synch_field;
@@ -1253,8 +1256,8 @@ synch_with_all_threads(thread_synch_state_t desired_synch_state,
 
     LOG(THREAD, LOG_SYNCH, 1,
         "synch with all threads my id = " SZFMT
-        " Giving %d permission and seeking %d state\n",
-        my_id, cur_state, desired_synch_state);
+        " Giving %d permission and seeking %d state, flags %x\n",
+        my_id, cur_state, desired_synch_state, flags);
 
     /* grab all_threads_synch_lock */
     /* since all_threads synch doesn't give any permissions this is necessary
diff --git a/core/unix/loader.c b/core/unix/loader.c
index 308de21a6..29504aa39 100644
--- a/core/unix/loader.c
+++ b/core/unix/loader.c
@@ -165,7 +165,7 @@ privload_locate_and_load(const char *impname, privmod_t *dependent, bool reachab
 static void
 privload_call_lib_func(dcontext_t *dcontext, privmod_t *privmod, fp_t func);
 
-static void
+DR_API void
 privload_relocate_mod(privmod_t *mod);
 
 static void
@@ -698,16 +698,16 @@ privload_os_finalize(privmod_t *privmod)
     os_privmod_data_t *opd = (os_privmod_data_t *)privmod->os_privmod_data;
     /* Special handling for standard I/O file descriptors. */
     privmod_stdout = (FILE **)get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_STDOUT_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_STDOUT_NAME, NULL /* symver */, NULL);
     privmod_stdin = (FILE **)get_proc_address_from_os_data(&opd->os_data, opd->load_delta,
-                                                           LIBC_STDIN_NAME, NULL);
+                                                           LIBC_STDIN_NAME, NULL /* symver */, NULL);
     privmod_stderr = (FILE **)get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_STDERR_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_STDERR_NAME, NULL /* symver */, NULL);
     /* i#5133: glibc 2.32+ has ld.so call a hardcoded initializer before calling the
      * regular ELF constructors.
      */
     void (*libc_early_init)(bool) = (void (*)(bool))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_EARLY_INIT_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_EARLY_INIT_NAME, NULL /* symver */, NULL);
     if (libc_early_init == NULL) {
         return;
     }
@@ -720,7 +720,7 @@ privload_os_finalize(privmod_t *privmod)
     /* Do not try to clobber vars unless we have to: get the libc version. */
 #    define LIBC_GET_VERSION_NAME "gnu_get_libc_version"
     const char *(*libc_ver)(void) = (const char *(*)(void))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_GET_VERSION_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_GET_VERSION_NAME, NULL /* symver */, NULL);
     if (libc_ver == NULL)
         return;
     LOG(GLOBAL, LOG_LOADER, 2, "%s: calling %s\n", __FUNCTION__, LIBC_GET_VERSION_NAME);
@@ -744,7 +744,7 @@ privload_os_finalize(privmod_t *privmod)
     }
     os_privmod_data_t *ld_opd = (os_privmod_data_t *)privmod_ld_linux->os_privmod_data;
     byte *glro = get_proc_address_from_os_data(&ld_opd->os_data, ld_opd->load_delta,
-                                               "_rtld_global_ro", NULL);
+                                               "_rtld_global_ro", NULL /* symver */, NULL);
     if (glro == NULL) {
         SYSLOG_INTERNAL_WARNING("glibc 2.34+ i#5437 workaround failed: missed glro");
         return;
@@ -1110,7 +1110,7 @@ get_private_library_address(app_pc modbase, const char *name)
     if (dynamo_heap_initialized) {
         /* opd is initialized */
         os_privmod_data_t *opd = (os_privmod_data_t *)mod->os_privmod_data;
-        res = get_proc_address_from_os_data(&opd->os_data, opd->load_delta, name, NULL);
+        res = get_proc_address_from_os_data(&opd->os_data, opd->load_delta, name, NULL /* symver */, NULL);
         release_recursive_lock(&privload_lock);
         return res;
     } else {
@@ -1130,7 +1130,7 @@ get_private_library_address(app_pc modbase, const char *name)
             release_recursive_lock(&privload_lock);
             return NULL;
         }
-        res = get_proc_address_from_os_data(&os_data, delta, name, NULL);
+        res = get_proc_address_from_os_data(&os_data, delta, name, NULL /* symver */, NULL);
         release_recursive_lock(&privload_lock);
         return res;
     }
@@ -1362,7 +1362,13 @@ privload_relocate_os_privmod_data(os_privmod_data_t *opd, byte *mod_base)
 }
 #endif /* LINUX */
 
-static void
+DR_API void privload_relocate_mod_takelock(privmod_t *mod) {
+    acquire_recursive_lock(&privload_lock);
+    privload_relocate_mod(mod);
+    release_recursive_lock(&privload_lock);
+}
+
+void
 privload_relocate_mod(privmod_t *mod)
 {
 #ifdef LINUX
@@ -1604,6 +1610,7 @@ typedef struct _redirect_import_t {
 static const redirect_import_t redirect_imports[] = {
     { "calloc", (app_pc)redirect_calloc },
     { "malloc", (app_pc)redirect_malloc },
+    { "posix_memalign", (app_pc)redirect_posix_memalign },
     { "free", (app_pc)redirect_free },
     { "realloc", (app_pc)redirect_realloc },
     { "strdup", (app_pc)redirect_strdup },
@@ -1620,8 +1627,8 @@ static const redirect_import_t redirect_imports[] = {
     /* These libc routines can call pthread functions and cause hangs (i#4928) so
      * we use our syscall wrappers instead.
      */
-    { "read", (app_pc)os_read },
-    { "write", (app_pc)os_write },
+    /* { "read", (app_pc)os_read }, */
+    /* { "write", (app_pc)os_write }, */
 #if defined(LINUX) && !defined(ANDROID)
     { "__tls_get_addr", (app_pc)redirect___tls_get_addr },
     { "___tls_get_addr", (app_pc)redirect____tls_get_addr },
@@ -1635,6 +1642,7 @@ static const redirect_import_t redirect_imports[] = {
     { "__gnu_Unwind_Find_exidx", (app_pc)redirect___gnu_Unwind_Find_exidx },
 #    endif
 #endif
+    // { "dlsym", (app_pc)redirect_dlsym },
     { "dlsym", (app_pc)redirect_dlsym },
     /* We need these for clients that don't use libc (i#1747) */
     { "strlen", (app_pc)strlen },
@@ -1656,7 +1664,12 @@ static const redirect_import_t redirect_imports[] = {
     { "memset_chk", (app_pc)memset },
     { "memmove_chk", (app_pc)memmove },
     { "strncpy_chk", (app_pc)strncpy },
+    /* { "__errno_location", (app_pc)__errno_location } */
 };
+
+DR_API redirect_import_t *client_redirect_imports = NULL;
+DR_API int client_redirect_imports_count = 0;
+
 #define REDIRECT_IMPORTS_NUM (sizeof(redirect_imports) / sizeof(redirect_imports[0]))
 
 #ifdef DEBUG
@@ -1686,6 +1699,15 @@ privload_redirect_sym(os_privmod_data_t *opd, ptr_uint_t *r_addr, const char *na
         }
     }
 #endif
+    for (i = 0; i < client_redirect_imports_count; i++) {
+        if (strcmp(client_redirect_imports[i].name, name) == 0) {
+            if (opd->use_app_imports && client_redirect_imports[i].app_func != NULL)
+                *r_addr = (ptr_uint_t)client_redirect_imports[i].app_func;
+            else
+                *r_addr = (ptr_uint_t)client_redirect_imports[i].func;
+            return true;
+        }
+    }
     for (i = 0; i < REDIRECT_IMPORTS_NUM; i++) {
         if (strcmp(redirect_imports[i].name, name) == 0) {
             if (opd->use_app_imports && redirect_imports[i].app_func != NULL)
diff --git a/core/unix/loader_linux.c b/core/unix/loader_linux.c
index eb307818b..2511e87cb 100644
--- a/core/unix/loader_linux.c
+++ b/core/unix/loader_linux.c
@@ -135,7 +135,7 @@ static size_t client_tls_size = 2 * 4096;
  * good way to guess how big this allocation was.  Instead we use this estimate.
  */
 /* On A32, the pthread is put before tcbhead instead tcbhead being part of pthread */
-static size_t tcb_size = IF_X64_ELSE(0x900, 0x490);
+static size_t tcb_size = IF_X64_ELSE(0xc00, 0x490);
 
 /* thread contol block header type from
  * - sysdeps/x86_64/nptl/tls.h
@@ -157,6 +157,8 @@ typedef struct _tcb_head_t {
 
     ptr_uint_t stack_guard;
     ptr_uint_t pointer_guard;
+    unsigned long int unused[2];
+    unsigned int feature_1;
 #elif defined(AARCH64)
     /* FIXME i#1569: This may be wrong! */
     void *dtv;
@@ -297,7 +299,7 @@ privload_set_pthread_tls_fields(privmod_t *mod, app_pc priv_tls_base)
      */
 #    define PTHREAD_TID_FUNC_NAME "pthread_mutex_consistent"
     void (*tid_using_func)(bool) = (void (*)(bool))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, PTHREAD_TID_FUNC_NAME, NULL);
+        &opd->os_data, opd->load_delta, PTHREAD_TID_FUNC_NAME, NULL, NULL);
     if (tid_using_func == NULL)
         return;
     LOG(GLOBAL, LOG_LOADER, 2, "%s: decoding %s to find tid offset\n", __FUNCTION__,
@@ -415,7 +417,8 @@ privload_copy_tls_block(privmod_t *mod, app_pc priv_tls_base, uint mod_idx)
 void
 privload_mod_tls_primary_thread_init(privmod_t *mod)
 {
-    ASSERT(!dynamo_initialized);
+    // ASSERT(!dynamo_initialized);
+
     /* Copy ELF block for primary thread for use in init funcs (i#2751).
      * We do this after relocs and assume reloc ifuncs don't need this:
      * else we'd have to assume there are no relocs in the TLS blocks.
@@ -440,6 +443,7 @@ privload_tls_init(void *app_tp)
         app_tp);
     dr_tp = heap_mmap(client_tls_alloc_size, MEMPROT_READ | MEMPROT_WRITE,
                       VMM_SPECIAL_MMAP | VMM_PER_THREAD);
+    SYSLOG_INTERNAL_INFO("dr_tp: %p tcb_size: %lx\n", dr_tp, tcb_size);
     ASSERT(APP_LIBC_TLS_SIZE + TLS_PRE_TCB_SIZE + tcb_size <= client_tls_alloc_size);
 #if defined(AARCHXX) || defined(RISCV64)
     /* GDB reads some pthread members (e.g., pid, tid), so we must make sure
@@ -492,6 +496,7 @@ privload_tls_init(void *app_tp)
     dr_tcb->self = dr_tcb;
     /* i#555: replace app's vsyscall with DR's int0x80 syscall */
     dr_tcb->sysinfo = (ptr_uint_t)client_int_syscall;
+    dr_tcb->feature_1 = 0; // this is currently used to say we don't have Intel CET
 #elif defined(AARCHXX) || defined(RISCV64)
     dr_tcb->dtv = NULL;
     dr_tcb->private = NULL;
diff --git a/core/unix/module.h b/core/unix/module.h
index e341325cf..ae7b521af 100644
--- a/core/unix/module.h
+++ b/core/unix/module.h
@@ -83,6 +83,10 @@ typedef struct _os_module_data_t {
     app_pc chain;           /* absolute addr of hash chain table */
     app_pc dynsym;          /* absolute addr of .dynsym */
     app_pc dynstr;          /* absolute addr of .dynstr */
+    app_pc versym;          /* absolute addr of .gnu.version */
+    app_pc verdef;          /* absolute addr of .gnu.version */
+    size_t verdefnum;          /* absolute addr of .gnu.version */
+    app_pc verdefstrtab;          /* absolute addr of .gnu.version */
     size_t dynstr_size;     /* size of .dynstr */
     size_t symentry_size;   /* size of a .dynsym entry */
     bool has_runpath;       /* is DT_RUNPATH present? */
@@ -168,7 +172,7 @@ extern stdfile_t **privmod_stderr;
 extern stdfile_t **privmod_stdin;
 
 /* loader.c */
-app_pc
+DR_API app_pc
 get_private_library_address(app_pc modbase, const char *name);
 
 bool
diff --git a/core/unix/module_elf.c b/core/unix/module_elf.c
index c012461af..fff183482 100644
--- a/core/unix/module_elf.c
+++ b/core/unix/module_elf.c
@@ -283,6 +283,14 @@ module_fill_os_data(ELF_PROGRAM_HEADER_TYPE *prog_hdr, /* PT_DYNAMIC entry */
                         out_data->symentry_size = (size_t)dyn->d_un.d_val;
                     } else if (dyn->d_tag == DT_RUNPATH) {
                         out_data->has_runpath = true;
+                    } else if (dyn->d_tag == DT_VERSYM) {
+                        out_data->versym = elf_dt_abs_addr(dyn, base, sz, view_size,
+                                                          load_delta, at_map, dyn_reloc);
+                    } else if (dyn->d_tag == DT_VERDEF) {
+                        out_data->verdef = elf_dt_abs_addr(dyn, base, sz, view_size,
+                                                          load_delta, at_map, dyn_reloc);
+                    } else if (dyn->d_tag == DT_VERDEFNUM) {
+                        out_data->verdefnum = (size_t)dyn->d_un.d_val;
 #ifndef ANDROID
                     } else if (dyn->d_tag == DT_CHECKSUM) {
                         out_data->checksum = (size_t)dyn->d_un.d_val;
@@ -645,9 +653,17 @@ elf_sym_matches(ELF_SYM_TYPE *sym, char *strtab, const char *name,
 /* The new GNU hash scheme to improve lookup speed.
  * Can't find good doc to reference here.
  */
+
+#define VERSYM_VERSION 0x7fff
+#define VERSYM_HIDDEN 0x8000
+
+// TODO: Right now, this function does not actually deal with symbol versioning.
+// Most of the work is done, to parse symbol versions / definitions in the loaded library
+// but we don't actually return a specific symbol version (we
+// return the default version for now).
 static app_pc
-gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
-                char *strtab, Elf_Symndx *buckets, Elf_Symndx *chain, ELF_ADDR *bitmask,
+gnu_hash_lookup(const char *name, Elf64_Word *symver_hash, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
+                char *strtab, Elf64_Half *symvertab, Elf64_Verdef *verdef, size_t verdefnum, Elf_Symndx *buckets, Elf_Symndx *chain, ELF_ADDR *bitmask,
                 ptr_uint_t bitidx, ptr_uint_t shift, size_t num_buckets,
                 size_t dynstr_size, bool *is_indirect_code)
 {
@@ -680,8 +696,32 @@ gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
                     if (sym->st_value == 0 && ELF_ST_TYPE(sym->st_info) != STT_TLS)
                         continue; /* no value */
                     if (elf_sym_matches(sym, strtab, name, is_indirect_code)) {
-                        res = (app_pc)(symtab[sidx].st_value + load_delta);
-                        break;
+                        if (symvertab) {
+                            Elf64_Half ver = symvertab[sidx];
+                            Elf64_Word verhash = 0;
+                            for (size_t i=0; i<verdefnum; i++) {
+                                // Elf64_Verdaux *vdaux = (Elf64_Verdaux *)((char *)vd + vd->vd_aux);
+                                if (verdef->vd_ndx == (ver & VERSYM_VERSION)) {
+                                    verhash = verdef->vd_hash;
+                                    break;
+                                }
+                                verdef = (Elf64_Verdef *)((char *)verdef + verdef->vd_next);
+                            }
+
+                            if ((ver & VERSYM_HIDDEN) == 0 || ver == VER_NDX_GLOBAL) {
+                                // Default version
+                                res = (app_pc)(symtab[sidx].st_value + load_delta);
+                                LOG(GLOBAL, LOG_LOADER, 2, "%s: found %s default version %hd %d target %d\n", __func__, name, ver, verhash, symver_hash ? *symver_hash : -1);
+                                break;
+                            } else {
+                                // Non-default version
+                                LOG(GLOBAL, LOG_LOADER, 2, "%s: skip %s non-default version %hd %d target %d\n", __func__, name, ver, verhash, symver_hash ? *symver_hash : -1);
+                                if (!res) res = (app_pc)(symtab[sidx].st_value + load_delta);
+                            }
+                        } else {
+                            res = (app_pc)(symtab[sidx].st_value + load_delta);
+                            break;
+                        }
                     }
                 }
             } while (!TEST(1, *harray++));
@@ -695,12 +735,13 @@ gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
  */
 static app_pc
 elf_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
-                char *strtab, Elf_Symndx *buckets, Elf_Symndx *chain, size_t num_buckets,
+                char *strtab, const Elf64_Half* symvertab, Elf_Symndx *buckets, Elf_Symndx *chain, size_t num_buckets,
                 size_t dynstr_size, bool *is_indirect_code)
 {
     Elf_Symndx sidx;
     Elf_Symndx hidx;
     ELF_SYM_TYPE *sym;
+
     app_pc res;
 
     hidx = elf_hash(name);
@@ -728,24 +769,28 @@ elf_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
 /* get the address by using the hashtable information in os_module_data_t */
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t load_delta,
-                              const char *name, DR_PARAM_OUT bool *is_indirect_code)
+                              const char *name, const char *symver, DR_PARAM_OUT bool *is_indirect_code)
 {
     if (os_data->hashtab != NULL) {
         Elf_Symndx *buckets = (Elf_Symndx *)os_data->buckets;
         Elf_Symndx *chain = (Elf_Symndx *)os_data->chain;
         ELF_SYM_TYPE *symtab = (ELF_SYM_TYPE *)os_data->dynsym;
+        Elf64_Half *vertab = (Elf64_Half *)os_data->versym;
+        Elf64_Verdef *verdef = (Elf64_Verdef *)os_data->verdef;
+        size_t verdefnum = os_data->verdefnum;
+
         char *strtab = (char *)os_data->dynstr;
         size_t num_buckets = os_data->num_buckets;
         if (os_data->hash_is_gnu) {
             /* The new GNU hash scheme */
-            return gnu_hash_lookup(name, load_delta, symtab, strtab, buckets, chain,
+            return gnu_hash_lookup(name, (Elf64_Word*)symver, load_delta, symtab, strtab, vertab, verdef, verdefnum, buckets, chain,
                                    (ELF_ADDR *)os_data->gnu_bitmask,
                                    (ptr_uint_t)os_data->gnu_bitidx,
                                    (ptr_uint_t)os_data->gnu_shift, num_buckets,
                                    os_data->dynstr_size, is_indirect_code);
         } else {
             /* ELF hash scheme */
-            return elf_hash_lookup(name, load_delta, symtab, strtab, buckets, chain,
+            return elf_hash_lookup(name, load_delta, symtab, strtab, vertab, buckets, chain,
                                    num_buckets, os_data->dynstr_size, is_indirect_code);
         }
     }
@@ -766,7 +811,7 @@ get_proc_address_ex(module_base_t lib, const char *name,
     ma = module_pc_lookup((app_pc)lib);
     if (ma != NULL) {
         res = get_proc_address_from_os_data(
-            &ma->os_data, ma->start - ma->os_data.base_address, name, &is_ifunc);
+            &ma->os_data, ma->start - ma->os_data.base_address, name, NULL /* symver */, &is_ifunc);
         /* XXX: for the case of is_indirect_code being true, should we call
          * the ifunc to get the real symbol location?
          * Current solution is:
@@ -975,6 +1020,8 @@ module_init_os_privmod_data_from_dyn(os_privmod_data_t *opd, ELF_DYNAMIC_ENTRY_T
         case DT_VERNEED: opd->verneed = (app_pc)(dyn->d_un.d_ptr + load_delta); break;
         case DT_VERNEEDNUM: opd->verneednum = dyn->d_un.d_val; break;
         case DT_VERSYM: opd->versym = (ELF_HALF *)(dyn->d_un.d_ptr + load_delta); break;
+        case DT_VERDEF: opd->verdef = (ELF_HALF *)(dyn->d_un.d_ptr + load_delta); break;
+        case DT_VERDEFNUM: opd->verdefnum = dyn->d_un.d_val;; break;
         case DT_RELCOUNT: opd->relcount = dyn->d_un.d_val; break;
         case DT_INIT: opd->init = (fp_t)(dyn->d_un.d_ptr + load_delta); break;
         case DT_FINI: opd->fini = (fp_t)(dyn->d_un.d_ptr + load_delta); break;
@@ -1057,7 +1104,7 @@ module_get_os_privmod_data(app_pc base, size_t size, bool dyn_reloc,
     module_init_os_privmod_data_from_dyn(pd, dyn, load_delta);
     DODEBUG({
         if (get_proc_address_from_os_data(&pd->os_data, pd->load_delta,
-                                          DR_DISALLOW_UNSAFE_STATIC_NAME, NULL) != NULL)
+                                          DR_DISALLOW_UNSAFE_STATIC_NAME, NULL /* symver */, NULL) != NULL)
             disallow_unsafe_static_calls = true;
     });
     pd->use_app_imports = false;
@@ -1103,7 +1150,7 @@ static app_pc
 module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
 {
     app_pc res;
-    const char *name;
+    const char *name, *version;
     bool is_ifunc;
     dcontext_t *dcontext = get_thread_private_dcontext();
 
@@ -1112,9 +1159,11 @@ module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
         return NULL;
 
     name = (char *)pd->os_data.dynstr + sym->st_name;
+    version = NULL;
+    // version = pd->os_data.
     LOG(GLOBAL, LOG_LOADER, 3, "sym lookup for %s from %s\n", name, pd->soname);
     /* check my current module */
-    res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, &is_ifunc);
+    res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, NULL /* symver */, &is_ifunc);
     if (res != NULL) {
         if (is_ifunc) {
             TRY_EXCEPT_ALLOW_NO_DCONTEXT(
@@ -1167,7 +1216,7 @@ module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
             LOG(GLOBAL, LOG_LOADER, 3, "NOT using libpthread's non-pthread symbol\n");
             res = NULL;
         } else {
-            res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name,
+            res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, NULL /* symver */,
                                                 &is_ifunc);
         }
         if (res != NULL) {
diff --git a/core/unix/module_macho.c b/core/unix/module_macho.c
index dbda64f13..c4fca5b16 100644
--- a/core/unix/module_macho.c
+++ b/core/unix/module_macho.c
@@ -359,7 +359,7 @@ read_uleb128(byte *start, byte *max, byte **next_entry DR_PARAM_OUT)
 
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t load_delta,
-                              const char *name, DR_PARAM_OUT bool *is_indirect_code)
+                              const char *name, const char *symver, DR_PARAM_OUT bool *is_indirect_code)
 {
     /* Walk the Mach-O export trie.  We don't support < 10.6 which is when
      * they put this scheme in place.
@@ -480,7 +480,7 @@ get_proc_address_ex(module_base_t lib, const char *name,
                                                  */
                                                 (ptr_int_t)ma->start
                                                 : ma->start - ma->os_data.base_address,
-                                            name, is_indirect_code);
+                                            name, NULL /* symver */, is_indirect_code);
     }
     os_get_module_info_unlock();
     LOG(GLOBAL, LOG_SYMBOLS, 2, "%s: %s => " PFX "\n", __func__, name, res);
diff --git a/core/unix/module_private.h b/core/unix/module_private.h
index abf142494..aa686f870 100644
--- a/core/unix/module_private.h
+++ b/core/unix/module_private.h
@@ -72,6 +72,8 @@ struct _os_privmod_data_t {
     int verneednum;
     int relcount;
     ELF_HALF *versym;
+    ELF_HALF *verdef;
+    int verdefnum;
 #else
     /* XXX i#1285: MacOS private loader NYI */
 #endif
@@ -123,7 +125,7 @@ module_get_text_section(app_pc file_map, size_t file_size);
 
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t delta,
-                              const char *name, bool *is_indirect_code DR_PARAM_OUT);
+                              const char *name, const char *symver, bool *is_indirect_code DR_PARAM_OUT);
 
 bool
 privload_redirect_sym(os_privmod_data_t *opd, ptr_uint_t *r_addr, const char *name);
diff --git a/core/unix/os.c b/core/unix/os.c
index 9d9becdb1..e11241c6a 100644
--- a/core/unix/os.c
+++ b/core/unix/os.c
@@ -3792,6 +3792,7 @@ os_thread_sleep(uint64 milliseconds)
         /* not unusual for client threads to use itimers and have their run
          * routine sleep forever
          */
+
         if (count++ > 3 && !IS_CLIENT_THREAD(get_thread_private_dcontext())) {
             ASSERT_CURIOSITY_ONCE(
                 false && "os_thread_sleep interrupted by signal more than 3 times.");
@@ -3880,6 +3881,7 @@ os_thread_suspend(thread_record_t *tr)
         if (ksynch_wait(&ostd->suspended, 0, SUSPEND_DEBUG_TIMEOUT_MS) == -ETIMEDOUT) {
             ASSERT_CURIOSITY(false && "failed to suspend thread in 5s");
         }
+        LOG(GLOBAL, LOG_SYNCH, 2, "os_thread_suspend: suspended = %d for thread %d\n", ksynch_get_value(&ostd->suspended), tr->id);
         if (ksynch_get_value(&ostd->suspended) == 0) {
             /* If it still has to wait, give up the cpu. */
             os_thread_yield();
diff --git a/core/unix/os_exports.h b/core/unix/os_exports.h
index 8ff151591..4aa289c75 100644
--- a/core/unix/os_exports.h
+++ b/core/unix/os_exports.h
@@ -309,6 +309,7 @@ dynamorio_set_envp(char **envp);
 /* drinjectlib wants the libc version while the core wants the private version */
 #    define getenv our_getenv
 #endif
+DR_API
 char *
 our_getenv(const char *name);
 
diff --git a/core/unix/preload.c b/core/unix/preload.c
index 934e71546..2b4d65214 100644
--- a/core/unix/preload.c
+++ b/core/unix/preload.c
@@ -137,7 +137,7 @@ take_over(const char *pname)
     return true;
 }
 
-int
+__attribute__((constructor)) int
 #if INIT_BEFORE_LIBC
 _init(int argc, char *arg0, ...)
 {
@@ -167,15 +167,17 @@ _init(int argc, char **argv, char **envp)
 
 #if START_DYNAMO
     pf("ready to start dynamo\n");
+
+    /* i#46: Get env from loader directly. */
+    dynamorio_set_envp(envp);
+
     name = get_application_short_name();
     pf("preload _init: running %s\n", name);
     if (!take_over(name))
         return 0;
-    /* i#46: Get env from loader directly. */
-    dynamorio_set_envp(envp);
-    /* FIXME i#287/PR 546544: now load DYNAMORIO_AUTOINJECT DR .so
-     * and only LD_PRELOAD the preload lib itself
-     */
+        /* FIXME i#287/PR 546544: now load DYNAMORIO_AUTOINJECT DR .so
+         * and only LD_PRELOAD the preload lib itself
+         */
 #    if VERBOSE
     int init =
 #    endif
diff --git a/core/unix/rseq_linux.c b/core/unix/rseq_linux.c
index 08fad6198..0a2d5e450 100644
--- a/core/unix/rseq_linux.c
+++ b/core/unix/rseq_linux.c
@@ -254,12 +254,14 @@ rseq_clear_tls_ptr(dcontext_t *dcontext)
 {
     ASSERT(rseq_tls_offset != 0);
     byte *base = get_app_segment_base(LIB_SEG_TLS);
-    struct rseq *app_rseq = (struct rseq *)(base + rseq_tls_offset);
-    /* We're directly writing this in the cache, so we do not bother with safe_read
-     * or safe_write here either.  We already cannot handle rseq adversarial cases.
-     */
-    if (is_dynamo_address((byte *)(ptr_uint_t)app_rseq->rseq_cs))
-        app_rseq->rseq_cs = 0;
+    if (base > 0) {
+        struct rseq *app_rseq = (struct rseq *)(base + rseq_tls_offset);
+        /* We're directly writing this in the cache, so we do not bother with safe_read
+         * or safe_write here either.  We already cannot handle rseq adversarial cases.
+         */
+        if (is_dynamo_address((byte *)(ptr_uint_t)app_rseq->rseq_cs))
+            app_rseq->rseq_cs = 0;
+    }
 }
 
 int
diff --git a/core/unix/signal_macos.c b/core/unix/signal_macos.c
index db6d1c357..3376811da 100644
--- a/core/unix/signal_macos.c
+++ b/core/unix/signal_macos.c
@@ -157,8 +157,9 @@ sigcontext_to_mcontext_simd(priv_mcontext_t *mc, sig_full_cxt_t *sc_full)
         return;
     mc->fpsr = fpc->__fpsr;
     mc->fpcr = fpc->__fpcr;
-    ASSERT(sizeof(mc->simd) == sizeof(fpc->__v));
-    memcpy(&mc->simd, &fpc->__v, sizeof(mc->simd));
+    for (int i = 0; i < proc_num_simd_registers(); i++) {
+        memcpy(&mc->simd[i], &fpc->__v[i], sizeof(fpc->__v[i]));
+    }
 #elif defined(X86)
     /* We assume that _STRUCT_X86_FLOAT_STATE* matches exactly the first
      * half of _STRUCT_X86_AVX_STATE*, and similarly for AVX and AVX512.
@@ -200,8 +201,9 @@ mcontext_to_sigcontext_simd(sig_full_cxt_t *sc_full, priv_mcontext_t *mc)
         return;
     fpc->__fpsr = mc->fpsr;
     fpc->__fpcr = mc->fpcr;
-    ASSERT(sizeof(mc->simd) == sizeof(fpc->__v));
-    memcpy(&fpc->__v, &mc->simd, sizeof(mc->simd));
+    for (int i = 0; i < proc_num_simd_registers(); i++) {
+        memcpy(&fpc->__v[i], &mc->simd[i], sizeof(fpc->__v[i]));
+    }
 #elif defined(X86)
     sigcontext_t *sc = sc_full->sc;
     int i;
diff --git a/ext/drreg/drreg.h b/ext/drreg/drreg.h
index 2c5e6fc45..ad20896e6 100644
--- a/ext/drreg/drreg.h
+++ b/ext/drreg/drreg.h
@@ -473,6 +473,11 @@ drreg_status_t
 drreg_restore_app_values(void *drcontext, instrlist_t *ilist, instr_t *where, opnd_t opnd,
                          DR_PARAM_INOUT reg_id_t *swap);
 
+DR_EXPORT
+drreg_status_t
+drreg_restore_app_value(void *drcontext, instrlist_t *ilist, instr_t *where,
+                        reg_id_t app_reg, reg_id_t dst_reg, bool stateful);
+
 DR_EXPORT
 /**
  * Restores the spilled value (typically the application value) for
diff --git a/ext/drx/drx.c b/ext/drx/drx.c
index f5b9d25dd..5be4e9d7c 100644
--- a/ext/drx/drx.c
+++ b/ext/drx/drx.c
@@ -71,7 +71,7 @@
 #    define IF_WINDOWS_ELSE(x, y) (y)
 #endif
 
-#if defined(X86) || defined(AARCH64)
+#if (defined(X86) || defined(AARCH64)) && !defined(MACOS)
 #    define PLATFORM_SUPPORTS_SCATTER_GATHER
 #endif
 

```

`patches/dynamorio-bf5c900f575976ba145616b25337e3266ecaea3a-macos.patch`:

```patch
diff --git a/core/lib/instrument.h b/core/lib/instrument.h
index 87972ab9f..8acfa9d7b 100644
--- a/core/lib/instrument.h
+++ b/core/lib/instrument.h
@@ -178,7 +178,7 @@ dr_get_mcontext_priv(dcontext_t *dcontext, dr_mcontext_t *dmc, priv_mcontext_t *
 bool
 dr_modload_hook_exists(void);
 
-void
+DR_API void
 instrument_client_lib_loaded(byte *start, byte *end);
 void
 instrument_client_lib_unloaded(byte *start, byte *end);
diff --git a/ext/drreg/drreg.h b/ext/drreg/drreg.h
index 2c5e6fc45..ad20896e6 100644
--- a/ext/drreg/drreg.h
+++ b/ext/drreg/drreg.h
@@ -473,6 +473,11 @@ drreg_status_t
 drreg_restore_app_values(void *drcontext, instrlist_t *ilist, instr_t *where, opnd_t opnd,
                          DR_PARAM_INOUT reg_id_t *swap);
 
+DR_EXPORT
+drreg_status_t
+drreg_restore_app_value(void *drcontext, instrlist_t *ilist, instr_t *where,
+                        reg_id_t app_reg, reg_id_t dst_reg, bool stateful);
+
 DR_EXPORT
 /**
  * Restores the spilled value (typically the application value) for

```

`patches/make_patches.sh`:

```sh
#!/bin/bash

cd cpython/ && git diff > ../patches/cpython-3.10.12.patch && cd ..
cd dynamorio/ && git diff > ../patches/dynamorio-10.0.patch && cd ..

```

`patches/wine_tls_fix_11.2.patch`:

```patch
commit 629317542fbf68b2cd9d7b54c617c4f8e88559aa
Author: Andrew Haberlandt <andrew.haberlandt@gmail.com>
Date:   Sun Jun 8 17:24:04 2025 +0000

    wine tls fix

diff --git a/core/unix/os.c b/core/unix/os.c
index e11241c6a..42e042fe0 100644
--- a/core/unix/os.c
+++ b/core/unix/os.c
@@ -8235,6 +8235,23 @@ pre_system_call(dcontext_t *dcontext)
         /* we handle arch_prctl in post_syscall */
         dcontext->sys_param0 = sys_param(dcontext, 0);
         dcontext->sys_param1 = sys_param(dcontext, 1);
+
+        if (dcontext->sys_param0 == (SEG_TLS == SEG_GS ? ARCH_SET_GS : ARCH_SET_FS)) {
+            os_local_state_t *os_tls = get_os_tls();
+            /* do_syscall expects dcontext pointer in SEG_TLS:TLS_DCONTEXT_SLOT,
+             * so we avoid do_syscall in this case.
+             */
+            reg_t res = dynamorio_syscall(SYS_arch_prctl, 2, dcontext->sys_param0, dcontext->sys_param1);
+
+            os_tls->app_alt_tls_reg = read_thread_register(SEG_TLS);
+            os_tls->app_alt_tls_base = (void *)dcontext->sys_param1;
+
+            /* set the value back to the value we are actually using */
+            os_set_dr_seg(dcontext, SEG_TLS);
+
+            execute_syscall = false;
+            set_success_return_val(dcontext, res);
+        }
         break;
     }
 #    endif
@@ -9286,6 +9303,9 @@ post_system_call(dcontext_t *dcontext)
 #endif
 #if defined(LINUX) && defined(X86) && defined(X64)
     case SYS_arch_prctl: {
+        LOG(THREAD, LOG_THREADS, 2,
+            "syscall: arch_prctl %d %d => " PFX " success=%d\n", dcontext->sys_param0,
+            dcontext->sys_param1, MCXT_SYSCALL_RES(mc), success);
         if (success && INTERNAL_OPTION(mangle_app_seg)) {
             tls_handle_post_arch_prctl(dcontext, dcontext->sys_param0,
                                        dcontext->sys_param1);
diff --git a/core/unix/tls.h b/core/unix/tls.h
index 201e2fc81..64216fdd4 100644
--- a/core/unix/tls.h
+++ b/core/unix/tls.h
@@ -387,6 +387,8 @@ tls_min_index(void);
 #    if defined(LINUX) && defined(X64)
 void
 tls_handle_post_arch_prctl(dcontext_t *dcontext, int code, reg_t base);
+void
+os_set_dr_seg(dcontext_t *dcontext, reg_id_t seg);
 #    endif
 
 #    if defined(MACOS) && !defined(X64)
diff --git a/core/unix/tls_linux_x86.c b/core/unix/tls_linux_x86.c
index 98e552e5d..b874c6357 100644
--- a/core/unix/tls_linux_x86.c
+++ b/core/unix/tls_linux_x86.c
@@ -860,7 +860,7 @@ tls_min_index(void)
 }
 
 #ifdef X64
-static void
+void
 os_set_dr_seg(dcontext_t *dcontext, reg_id_t seg)
 {
     int res;
@@ -886,17 +886,17 @@ tls_handle_post_arch_prctl(dcontext_t *dcontext, int code, reg_t base)
             if (TLS_REG_LIB == SEG_FS) {
                 os_tls->app_lib_tls_reg = read_thread_register(SEG_FS);
                 os_tls->app_lib_tls_base = (void *)base;
+
+                /* update the app_thread_areas */
+                ostd = (os_thread_data_t *)dcontext->os_field;
+                desc = (our_modify_ldt_t *)ostd->app_thread_areas;
+                desc[FS_TLS].entry_number = tls_min_index() + FS_TLS;
+                dynamorio_syscall(SYS_get_thread_area, 1, &desc[FS_TLS]);
+                /* set it back to the value we are actually using. */
+                os_set_dr_seg(dcontext, SEG_FS);
             } else {
-                os_tls->app_alt_tls_reg = read_thread_register(SEG_FS);
-                os_tls->app_alt_tls_base = (void *)base;
+                /* pre syscall handler handles the TLS_REG == SEG_FS case */
             }
-            /* update the app_thread_areas */
-            ostd = (os_thread_data_t *)dcontext->os_field;
-            desc = (our_modify_ldt_t *)ostd->app_thread_areas;
-            desc[FS_TLS].entry_number = tls_min_index() + FS_TLS;
-            dynamorio_syscall(SYS_get_thread_area, 1, &desc[FS_TLS]);
-            /* set it back to the value we are actually using. */
-            os_set_dr_seg(dcontext, SEG_FS);
         }
         break;
     }
@@ -913,17 +913,17 @@ tls_handle_post_arch_prctl(dcontext_t *dcontext, int code, reg_t base)
         if (TLS_REG_LIB == SEG_GS) {
             os_tls->app_lib_tls_reg = read_thread_register(SEG_GS);
             os_tls->app_lib_tls_base = (void *)base;
+
+            /* update the app_thread_areas */
+            ostd = (os_thread_data_t *)dcontext->os_field;
+            desc = ostd->app_thread_areas;
+            desc[GS_TLS].entry_number = tls_min_index() + GS_TLS;
+            dynamorio_syscall(SYS_get_thread_area, 1, &desc[GS_TLS]);
+            /* set the value back to the value we are actually using */
+            os_set_dr_seg(dcontext, SEG_GS);
         } else {
-            os_tls->app_alt_tls_reg = read_thread_register(SEG_GS);
-            os_tls->app_alt_tls_base = (void *)base;
+            /* pre syscall handler handles the TLS_REG == SEG_GS case */
         }
-        /* update the app_thread_areas */
-        ostd = (os_thread_data_t *)dcontext->os_field;
-        desc = ostd->app_thread_areas;
-        desc[GS_TLS].entry_number = tls_min_index() + GS_TLS;
-        dynamorio_syscall(SYS_get_thread_area, 1, &desc[GS_TLS]);
-        /* set the value back to the value we are actually using */
-        os_set_dr_seg(dcontext, SEG_GS);
         break;
     }
     case ARCH_GET_GS: {
diff --git a/core/vmareas.c b/core/vmareas.c
index ed5075e22..94ab46e19 100644
--- a/core/vmareas.c
+++ b/core/vmareas.c
@@ -6089,7 +6089,7 @@ app_memory_allocation(dcontext_t *dcontext, app_pc base, size_t size, uint prot,
      * during os_walk_address_space().
      */
     if (dynamo_initialized &&
-        !app_memory_pre_alloc(dcontext, base, size, prot, false /*!hint*/,
+        base != NULL && !app_memory_pre_alloc(dcontext, base, size, prot, false /*!hint*/,
                               true /*update*/, image)) {
         /* XXX: We should do better by telling app_memory_protection_change() we
          * can't fail so it should try to handle.  We do not expect this to happen

```

`pyda_core/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

add_compile_definitions(PYDA_VERSION="${CMAKE_PROJECT_VERSION}")

if (APPLE)
  add_library(tool SHARED tool.c pyda_core_py.c pyda_core.c pyda_threads.c pyda_unwind.c pyda_patch_python.c pyda_compiler.c macos/pyda_threads_macos.c macos/macho.c)
else()
  add_library(tool SHARED tool.c pyda_core_py.c pyda_core.c pyda_threads.c pyda_unwind.c pyda_patch_python.c pyda_compiler.c linux/pyda_threads_linux.c)
endif()

find_package(DynamoRIO)
if (NOT DynamoRIO_FOUND)
  message(FATAL_ERROR "DynamoRIO package required to build")
endif(NOT DynamoRIO_FOUND)

find_package(Python3 3.10 EXACT COMPONENTS Development)
if (NOT Python3_FOUND)
  message(FATAL_ERROR "Python required to build")
endif(NOT Python3_FOUND)

if (APPLE)
  target_link_libraries(tool ${Python3_LIBRARIES})
  target_include_directories(tool PRIVATE ${Python3_INCLUDE_DIRS} include/)
else()
  target_link_libraries(tool ${Python3_LIBRARIES} unwind)
  target_include_directories(tool PRIVATE ${LIBUNWIND_INCLUDE_DIRS} ${Python3_INCLUDE_DIRS} include/)
  target_link_directories(tool PRIVATE ${LIBUNWIND_LIBRARY_DIRS})
endif()

target_compile_options(tool PUBLIC -DPYDA_DYNAMORIO_CLIENT -Werror)

configure_DynamoRIO_client(tool)
use_DynamoRIO_extension(tool drmgr)
use_DynamoRIO_extension(tool drcontainers)
use_DynamoRIO_extension(tool drreg)
#use_DynamoRIO_extension(tool drtools)

# the standalone python shared library (no dynamorio linked here)
# add_library(pyda_core SHARED pyda_core_py.c pyda_core.c)
# set_target_properties(pyda_core PROPERTIES PREFIX "")
# target_include_directories(pyda_core PRIVATE ${Python3_INCLUDE_DIRS})
# target_link_libraries(pyda_core ${Python3_LIBRARIES} unwind)

```

`pyda_core/include/privload.h`:

```h

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
app_pc locate_and_load_private_library(const char *name, bool reachable);
app_pc get_private_library_address(void *handle, const char *symbol);

// duplicated from dynamorio
typedef struct _privmod_t {
    app_pc base;
    size_t size;
    const char *name;
    char path[MAXIMUM_PATH];
    uint ref_count;
    bool externally_loaded;
    bool is_client; /* or Extension */
    bool called_proc_entry;
    bool called_proc_exit;
    struct _privmod_t *next;
    struct _privmod_t *prev;
    void *os_privmod_data;
} privmod_t;
privmod_t *privload_lookup_by_pc_takelock(app_pc pc);
void privload_relocate_mod_takelock(privmod_t *mod);

typedef struct _redirect_import_t {
    const char *name;
    app_pc func;
    app_pc app_func; /* Used only for dl_iterate_phdr over app libs, so far. */
} redirect_import_t;

extern redirect_import_t *client_redirect_imports;
extern int client_redirect_imports_count;

```

`pyda_core/include/pyda_compiler.h`:

```h
#ifndef PYDA_COMPILER_H
#define PYDA_COMPILER_H

#include <dr_api.h>
#include "hashtable.h"
#include "drvector.h"
#include <Python.h>

struct Expr {
    unsigned long ty;
    unsigned long op1;
    unsigned long op2;
    int refcount;
};

struct ExprRaw {
    struct Expr base;
    instrlist_t *code;
};

// Expression types
#define EXPR_TYPE_CONST  1
#define EXPR_TYPE_ADD    2
#define EXPR_TYPE_SUB    3
#define EXPR_TYPE_MUL    4
#define EXPR_TYPE_DIV    5
#define EXPR_TYPE_LOAD   6
#define EXPR_TYPE_STORE  7
#define EXPR_TYPE_REG    8
#define EXPR_TYPE_RAW    9

/* a per-thread structure that tracks Expr lifetimes and provides (mutable) access
 * to an abstract register state.
 */
struct ExprBuilder {
    drvector_t exprs; /* Exprs that are live in this thread */
    dr_mcontext_t mc; /* register values (handles to Exprs) */
    drvector_t ops; /* loads, stores, raw insns which must be retained regardless */
};

typedef struct ExprBuilder ExprBuilder;

// Function declarations
ExprBuilder *exprbuilder_init();
void exprbuilder_delete(ExprBuilder *builder);
unsigned long expr_new(ExprBuilder *builder, unsigned long ty, unsigned long op1, unsigned long op2);
unsigned long expr_new_raw(ExprBuilder *builder, const char *buf, size_t size);
void expr_free(ExprBuilder *builder, unsigned long handle);
int exprbuilder_reg_get(ExprBuilder *builder, reg_id_t reg_id, unsigned long *handle);
int exprbuilder_reg_set(ExprBuilder *builder, reg_id_t reg_id, unsigned long handle);
int exprbuilder_compile(ExprBuilder *builder, instrlist_t *bb, instr_t *instr, int expr_handle_start);
void exprbuilder_incref(ExprBuilder *builder, unsigned long handle);



#endif // PYDA_COMPILER_H
```

`pyda_core/include/pyda_core.h`:

```h
#ifndef PYDA_CORE_H
#define PYDA_CORE_H

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#define Py_BUILD_CORE
#include <internal/pycore_condvar.h>
#undef Py_BUILD_CORE

#include <dr_api.h>
#include "hashtable.h"
#include "drvector.h"
#include "pyda_compiler.h"

#define SCRATCH_SLOTS 16


extern int is_dynamorio_running;
typedef struct pyda_hook_s pyda_hook;
typedef struct pyda_thread_s pyda_thread;
typedef struct pyda_process_s pyda_process;

// Since we have multiple threads running, we need to keep track of
// which one is holding the GIL.

struct pyda_hook_s {
    PyObject *py_func;
    unsigned callback_type:2;  // 0 = normal hook, 1 = advanced instrumentation
    unsigned deleted:1; // This is set when the hook has been fully flushed from code cache.
    void *addr;
};

struct pyda_process_s {
    int refcount;

    pyda_thread *main_thread;
    PyObject *thread_init_hook;
    PyObject *syscall_pre_hook;
    PyObject *syscall_post_hook;
    PyObject *module_load_hook;

    PyObject *py_obj;

    pthread_cond_t thread_exit_cond;
    pthread_mutex_t refcount_mutex;

    int stdin_fd, stdout_fd, stderr_fd;

    void* entrypoint;

#ifdef PYDA_DYNAMORIO_CLIENT
    hashtable_t callbacks;
    drvector_t threads;
    drvector_t thread_run_untils; // vec of pcs
    int flush_count;
#endif

};

struct pyda_thread_s {
    unsigned long tid;

    pthread_cond_t resume_cond;
    pthread_cond_t break_cond;
    pthread_mutex_t mutex;

    int python_yielded, app_yielded;
    int python_blocked_on_io;

    pyda_process *proc;

    int rip_updated_in_python;
    int skip_next_hook; // Used when redirecting execution to same PC after a clean-call

    int python_exited; // Did this thread's python thread exit?
    int app_exited; // Did this thread's app thread exit?
    int errored; // Did some Pyda-misuse occur, or did the Python thread throw during a hook?

    int yield_count;
    uint64_t run_until;
    int dirty_run_until;

    int signal; // 0 if no signal, otherwise the signal number

#ifdef PYDA_DYNAMORIO_CLIENT
    dr_mcontext_t cur_context;
    drvector_t context_stack;

    // thread-local list of hooks to be flushed; guarantees that changes go into
    // effect when expected: e.g., when returning from a hook
    drvector_t hook_update_queue;

    // records the last seen proc->flush_count so that we don't return into a stale fragment
    int flush_ts; 
#endif

    ExprBuilder *expr_builder;

    uint64_t scratch_region[SCRATCH_SLOTS];
};

struct pyda_bt_entry {
    char modname[128];
    uint64_t offset;
    char sym_name[512];
    uint64_t ip;
    uint64_t sp;
};


pyda_process* pyda_mk_process();
pyda_thread* pyda_mk_thread(pyda_process*);

void pyda_capture_io(pyda_process *p, int use_pty, int pty_raw);
void pyda_prepare_io(pyda_process *p);

void pyda_process_destroy(pyda_process *p);
void pyda_thread_destroy(pyda_thread *t);
void pyda_thread_destroy_last(pyda_thread *t);

PyObject *pyda_run_until(pyda_thread *, uint64_t addr);

// yield from python to the executable
void pyda_yield(pyda_thread *t);
void pyda_yield_noblock(pyda_thread *t); // used when thread entry hook returns, we don't need to return to python.

// break from the executable to python
void pyda_break(pyda_thread *t);
void pyda_break_noblock(pyda_thread *t); // used when app exits, no need to return to it.

void pyda_initial_break(pyda_thread *t);

// NOTE: GIL should be held for these
void pyda_add_hook(pyda_process *p, uint64_t addr, PyObject *callback, int callback_type, int needs_flush);
void pyda_remove_hook(pyda_process *p, uint64_t addr);
void pyda_set_thread_init_hook(pyda_process *p, PyObject *callback);
void pyda_set_syscall_pre_hook(pyda_process *p, PyObject *callback);
void pyda_set_syscall_post_hook(pyda_process *p, PyObject *callback);
void pyda_set_module_load_hook(pyda_process *p, PyObject *callback);

pyda_hook* pyda_get_callback(pyda_process *p, void* addr);

void* pyda_get_run_until(pyda_thread *t);
void pyda_set_run_until(pyda_thread *t, void *pc);
void pyda_clear_run_until(pyda_thread *t);
int pyda_check_run_until(pyda_process *proc, void *test_pc);

// These can only be called from application threads
int pyda_flush_hooks();
void pyda_hook_cleancall(pyda_hook *cb);
int pyda_hook_syscall(int syscall_num, int is_pre);
void pyda_hook_module_load(const char *module_path);
void pyda_hook_rununtil_reached(void *pc);

int pyda_push_context(pyda_thread *t);
int pyda_pop_context(pyda_thread *t);

int pyda_get_backtrace (pyda_thread *t, drvector_t *res);

void pyda_handle_advanced_hook(instrlist_t *bb, instr_t *instr, pyda_hook *callback);

typedef struct {
    PyObject_HEAD
    struct ExprBuilder *builder;
} PydaExprBuilder;


#ifndef PYDA_DYNAMORIO_CLIENT

#define ABORT_IF_NODYNAMORIO {\
    PyErr_SetString(PyExc_RuntimeError, "This script must be run through the pyda CLI"); \
    return NULL;\
}

#else

#define ABORT_IF_NODYNAMORIO if (!is_dynamorio_running) {\
    PyErr_SetString(PyExc_RuntimeError, "This script must be run through the pyda CLI"); \
    return NULL;\
}

#endif


#endif // PYDA_CORE_H

```

`pyda_core/include/pyda_core_py.h`:

```h
#define PY_SSIZE_T_CLEAN
#include <Python.h>
PyMODINIT_FUNC PyInit_pyda_core(void);

#define PYDA_REG_PC 0xb33f0001
#define PYDA_REG_FSBASE 0xb33f0002
```

`pyda_core/include/pyda_threads.h`:

```h
#include <pthread.h>
extern int g_pyda_tls_idx;
extern int g_pyda_tls_is_python_thread_idx;
int pyda_thread_setspecific(pthread_key_t key, void *val);
void* pyda_thread_getspecific(pthread_key_t key);

int pyda_thread_key_create(pthread_key_t *p2newkey, void *unused);
int pyda_thread_key_delete(pthread_key_t key);
void* pyda_thread_getspecific(pthread_key_t key);
int pyda_thread_setspecific(pthread_key_t key, void *val);
int pyda_cond_init(pthread_cond_t *condvar, const pthread_condattr_t *attr);
int pyda_cond_timedwait(pthread_cond_t *condvar, pthread_mutex_t *mutex, const struct timespec *abstime);
int pyda_cond_signal(pthread_cond_t *condvar);
int pyda_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

void* pyda_dlopen(const char *filename, int flag);
void* pyda_dlsym(void *handle, const char *symbol);
void* pyda_thread_self();
int pyda_thread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
int pyda_thread_detach(pthread_t thread);

void* python_thread_init(void *pyda_thread);
unsigned long pyda_getauxval(unsigned long type);
const char *pyda_getenv(const char *name);

void parse_proc_environ(void);
int pyda_sem_init(void *sem, int pshared, unsigned int value);
// void pyda_sigaltstack(void *a, void *b);
int pyda_sysconf(int num);

```

`pyda_core/include/pyda_util.h`:

```h

#ifndef NDEBUG
#define DEBUG_PRINTF(...) { \
    dr_fprintf(STDERR, __VA_ARGS__); \
    dr_flush_file(STDERR); \
}
#else
#define DEBUG_PRINTF(...)
#endif
```

`pyda_core/linux/pyda_threads_linux.c`:

```c


#define STATIC_DRMGR_ONLY
#include "pyda_threads.h"

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "Python.h"
#include "pyda_util.h"

#include "privload.h"

void* pyda_dlopen(const char *filename, int flag) {
    void *drcontext = dr_get_current_drcontext();
    // DEBUG_PRINTF("pyda_dlopen %s\n", filename);
    // DR_ASSERT(IS_CLIENT_THREAD(drcontext));
    if (filename == NULL) {
        void *retaddr = __builtin_return_address(0);
        privmod_t *mod = privload_lookup_by_pc_takelock(retaddr);
        if (mod != NULL)
            return mod->base;
        else
            return NULL;
    } else {
        return locate_and_load_private_library(filename, true);
    }
}

void* pyda_dlsym(void *handle, const char *symbol) {
    void *drcontext = dr_get_current_drcontext();
    // DEBUG_PRINTF("pyda_dlsym %s\n", symbol);
    // DR_ASSERT(IS_CLIENT_THREAD(drcontext));
    return get_private_library_address(handle, symbol);
}

```

`pyda_core/macos/macho.c`:

```c
#include "pyda_core.h"
#include "pyda_util.h"
/* Courtesy of Claude */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/dyld.h>
#include <mach-o/reloc.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>

#include <mach/mach.h>

#include "privload.h"

// Structure to store section information
struct section_info {
    uint64_t addr;
    uint64_t offset;
    uint64_t size;
    uint32_t reserved1;  // indirect symbol table index
    uint32_t reserved2;  // number of entries
};

void patch_macho(char *path, void *aslr_slide, redirect_import_t *redirects, int num_redirects) {

    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        printf("Failed to open file");
        return;
    }

    struct stat sb;
    if (fstat(fd, &sb) < 0) {
        printf("Failed to get file size");
        close(fd);
        return;
    }

    void *file_data = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (file_data == MAP_FAILED) {
        printf("Failed to map file");
        close(fd);
        return;
    }

    struct mach_header_64 *header = (struct mach_header_64 *)file_data;
    
    if (header->magic != MH_MAGIC_64) {
        printf("Not a 64-bit Mach-O file\n");
        munmap(file_data, sb.st_size);
        close(fd);
        return;
    }


    struct load_command *cmd = (struct load_command *)(header + 1);
    struct symtab_command *symtab = NULL;
    struct section_info la_ptr_section = {0};
    struct dysymtab_command *dysymtab = NULL;

    // First pass: find required commands and sections
    for (uint32_t i = 0; i < header->ncmds; i++) {
        if (cmd->cmd == LC_SYMTAB) {
            symtab = (struct symtab_command *)cmd;
        } 
        else if (cmd->cmd == LC_DYSYMTAB) {
            dysymtab = (struct dysymtab_command *)cmd;
        }
        else if (cmd->cmd == LC_SEGMENT_64) {
            struct segment_command_64 *seg = (struct segment_command_64 *)cmd;
            struct section_64 *sect = (struct section_64 *)((char *)seg + sizeof(struct segment_command_64));
            
            // Look for __la_symbol_ptr section
            for (uint32_t j = 0; j < seg->nsects; j++) {
                if (strcmp(sect[j].sectname, "__la_symbol_ptr") == 0 &&
                    strcmp(sect[j].segname, "__DATA") == 0) {
                    la_ptr_section.addr = sect[j].addr;
                    la_ptr_section.offset = sect[j].offset;
                    la_ptr_section.size = sect[j].size;
                    la_ptr_section.reserved1 = sect[j].reserved1;
                    la_ptr_section.reserved2 = sect[j].size / sizeof(void*);
                    break;
                }
            }
        }
        cmd = (struct load_command *)((char *)cmd + cmd->cmdsize);
    }

    if (!symtab || !dysymtab || !la_ptr_section.size) {
        printf("Required tables not found\n");
        munmap(file_data, sb.st_size);
        close(fd);
        return;
    }

    // Get symbol and string tables
    struct nlist_64 *symtab_start = (struct nlist_64 *)((char *)file_data + symtab->symoff);
    char *strtab = (char *)file_data + symtab->stroff;
    uint32_t *indirect_symtab = (uint32_t *)((char *)file_data + dysymtab->indirectsymoff);

    // Print imported symbols with their lazy pointer addresses
    
    // Iterate through the indirect symbol table entries for the lazy pointer section
    for (uint32_t i = 0; i < la_ptr_section.reserved2; i++) {
        uint32_t indirect_idx = indirect_symtab[la_ptr_section.reserved1 + i];
        
        // Skip special indirect symbol table entries
        if (indirect_idx == INDIRECT_SYMBOL_ABS || 
            indirect_idx == INDIRECT_SYMBOL_LOCAL ||
            indirect_idx == INDIRECT_SYMBOL_ABS) {
            continue;
        }

        struct nlist_64 *sym = &symtab_start[indirect_idx];
        const char *sym_name = strtab + sym->n_un.n_strx;
        uint64_t la_ptr_addr = la_ptr_section.addr + (i * sizeof(void*));
        
        for (int j = 0; j < num_redirects; j++) {
            if (strcmp(&sym_name[1], redirects[j].name) == 0) {
                DEBUG_PRINTF("Redirecting %s\n", sym_name);

                void* table_addr = (void*)(la_ptr_addr + aslr_slide);

                byte *base_pc;
                size_t size;
                uint old_prot;

                if (!dr_query_memory(table_addr, &base_pc, &size, &old_prot)) {
                    printf("Failed to query memory\n");
                    goto done;
                }

                if (!dr_memory_protect((void*)table_addr, sizeof(void*), DR_MEMPROT_READ | DR_MEMPROT_WRITE)) {
                    printf("Failed to change protection\n");
                    goto done;
                }

                *(void**)(la_ptr_addr + aslr_slide) = redirects[j].func;

                if (!dr_memory_protect((void*)table_addr, sizeof(void*), old_prot)) {
                    printf("Failed to change protection\n");
                    goto done;
                }
            }
        }
    }
done:
    munmap(file_data, sb.st_size);
    close(fd);
}
```

`pyda_core/macos/pyda_threads_macos.c`:

```c


#define STATIC_DRMGR_ONLY
#include "pyda_threads.h"

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "Python.h"
#include "pyda_util.h"

#include "privload.h"

#include <dlfcn.h>

void* pyda_dlopen(const char *filename, int flag) {
    /* NYI: private loader */
    return dlopen(filename, flag);
}

void* pyda_dlsym(void *handle, const char *symbol) {
    /* NYI: private loader */
    return dlsym(handle, symbol);
}

```

`pyda_core/pyda_compiler.c`:

```c
#include <stdlib.h>
#include "pyda_compiler.h"
#include "pyda_core.h"
#include "pyda_util.h"
#include "drreg.h"
#include <stddef.h>

static void exprbuilder_commit(ExprBuilder *builder, instrlist_t *bb, instr_t *instr, reg_id_t scratch_ptr_reg);

static int validate_and_increment_refs(ExprBuilder *builder, unsigned long ty, unsigned long op1, unsigned long op2) {
    switch (ty) {
        case EXPR_TYPE_ADD:
        case EXPR_TYPE_SUB:
        case EXPR_TYPE_MUL:
        case EXPR_TYPE_DIV:
        case EXPR_TYPE_STORE:
            if (op2 >= builder->exprs.entries || !builder->exprs.array[op2]) {
                return -1;
            }
            ((struct Expr *)builder->exprs.array[op2])->refcount++;
            // fall through
        case EXPR_TYPE_LOAD:
            if (op1 >= builder->exprs.entries || !builder->exprs.array[op1]) {
                return -1;
            }
            ((struct Expr *)builder->exprs.array[op1])->refcount++;
            break;
        case EXPR_TYPE_CONST:
        case EXPR_TYPE_RAW:
        case EXPR_TYPE_REG:
            // Constants don't have child expressions
            break;
        default:
            dr_fprintf(STDERR, "unimplemented validate_and_increment_refs ty %d\n", ty);
            return -1;
    }
    return 0;
}

unsigned long expr_new_raw(ExprBuilder *builder, const char *buf, size_t size) {
    void *drcontext = dr_get_current_drcontext();
    struct ExprRaw *rexpr = dr_thread_alloc(drcontext, sizeof(struct ExprRaw));
    struct Expr *expr = (struct Expr *)rexpr;

    if (!expr) {
        return (unsigned long)-1;
    }

    expr->ty = EXPR_TYPE_RAW;
    expr->op1 = 0;
    expr->op2 = 0;
    expr->refcount = 2; /* 2 since we add it to the ops array below */

    rexpr->code = instrlist_create(drcontext);

    const char *end = buf + size;
    while (buf < end) {
        instr_t *instr = instr_create(drcontext);
        instr_set_meta(instr);
        buf = (const char *)decode(drcontext, (byte *)buf, instr);
        if (buf == NULL) {
            instr_destroy(drcontext, instr);
            instrlist_clear_and_destroy(drcontext, rexpr->code);
            dr_thread_free(drcontext, expr, sizeof(struct ExprRaw));
            return (unsigned long)-1;
        }
        dr_print_instr(drcontext, STDERR, instr, "");
        instrlist_append(rexpr->code, instr);
    }

    // Add to builder's vector and return the index as handle
    unsigned int idx = builder->exprs.entries;
    drvector_append(&builder->exprs, expr);
    drvector_append(&builder->ops, (void*)(uintptr_t)idx);

    return idx;

}

unsigned long expr_new(ExprBuilder *builder, unsigned long ty, unsigned long op1, unsigned long op2) {
    void *drcontext = dr_get_current_drcontext();
    struct Expr *expr = dr_thread_alloc(drcontext, sizeof(struct Expr));
    if (!expr || ty == EXPR_TYPE_RAW) {
        return (unsigned long)-1;
    }

    if (validate_and_increment_refs(builder, ty, op1, op2) < 0) {
        dr_thread_free(drcontext, expr, sizeof(struct Expr));
        return (unsigned long)-1;
    }

    expr->ty = ty;
    expr->op1 = op1;
    expr->op2 = op2;
    expr->refcount = 1;

    // Add to builder's vector and return the index as handle
    unsigned int idx = builder->exprs.entries;
    drvector_append(&builder->exprs, expr);

    if (ty == EXPR_TYPE_LOAD || ty == EXPR_TYPE_STORE) {
        drvector_append(&builder->ops, (void*)(uintptr_t)idx);
        expr->refcount++;
    }

    return idx;
}

void expr_free(ExprBuilder *builder, unsigned long handle) {
    void *drcontext = dr_get_current_drcontext();
    if (handle >= builder->exprs.entries) return;
    
    struct Expr *expr = builder->exprs.array[handle];
    if (!expr) {
        dr_fprintf(STDERR, "expr_free: invalid handle %lu\n", handle);
        return;
    }
    
    expr->refcount--;
    if (expr->refcount > 0) return;

    // Recursively free operands based on expression type
    switch (expr->ty) {
        case EXPR_TYPE_ADD:
        case EXPR_TYPE_SUB:
        case EXPR_TYPE_MUL:
        case EXPR_TYPE_DIV:
        case EXPR_TYPE_STORE:
            expr_free(builder, expr->op2);
            // fall through
        case EXPR_TYPE_LOAD:
            expr_free(builder, expr->op1);
            break;
        case EXPR_TYPE_CONST:
        case EXPR_TYPE_REG:
            // Constants don't have child expressions to free
            break;
        case EXPR_TYPE_RAW:
            if (((struct ExprRaw *)expr)->code != NULL) {
                instrlist_clear_and_destroy(drcontext, ((struct ExprRaw *)expr)->code);
                ((struct ExprRaw *)expr)->code = NULL;
            }
            break;
        default:
            dr_fprintf(STDERR, "expr_free: invalid expression type %lu\n", expr->ty);
            break;
    }

    if (expr->ty == EXPR_TYPE_RAW) {
        dr_thread_free(drcontext, expr, sizeof(struct ExprRaw));
    } else {
        dr_thread_free(drcontext, expr, sizeof(struct Expr));
    }
    builder->exprs.array[handle] = NULL;
}

ExprBuilder *exprbuilder_init() {
    ExprBuilder *builder = dr_thread_alloc(dr_get_current_drcontext(), sizeof(ExprBuilder));
    if (!builder) {
        dr_fprintf(STDERR, "Failed to allocate ExprBuilder\n");
        return NULL;
    }
    drvector_init(&builder->exprs, 0, true, NULL);
    drvector_init(&builder->ops, 0, true, NULL);
    memset(&builder->mc, 0xff, sizeof(dr_mcontext_t));
    builder->mc.size = sizeof(dr_mcontext_t);
    builder->mc.flags = DR_MC_ALL;
    return builder;
}

void exprbuilder_delete(ExprBuilder *builder) {
    for (uint i = 0; i < builder->ops.entries; i++) {
        expr_free(builder, (unsigned long)builder->ops.array[i]);
    }

    // Check for leaked expressions
    for (uint i = 0; i < builder->exprs.entries; i++) {
        struct Expr *expr = builder->exprs.array[i];
        if (expr) {
            dr_fprintf(STDERR, "Warning: expression %u leaked (refcount: %d)\n", i, expr->refcount);
            expr_free(builder, i);
        }
    }

    drvector_delete(&builder->exprs);
    drvector_delete(&builder->ops);
}

int exprbuilder_reg_get(ExprBuilder *builder, reg_id_t reg_id, unsigned long *handle) {
    reg_t idx;
    if (!reg_get_value_ex(reg_id, &builder->mc, (uint8_t*)&idx)) return 0;

    // Validate that the stored index points to a valid expression
    if (idx >= builder->exprs.entries || !builder->exprs.array[idx]) {
        return 0;
    }

    *handle = (unsigned long)idx;
    return 1;
}

void exprbuilder_incref(ExprBuilder *builder, unsigned long handle) {
    // note: unchecked
    struct Expr *expr = builder->exprs.array[handle];
    expr->refcount++;
}

int exprbuilder_reg_set(ExprBuilder *builder, reg_id_t reg_id, unsigned long handle) {
    // Validate that we're setting a valid expression handle
    if (handle >= builder->exprs.entries || !builder->exprs.array[handle]) {
        return 0;
    }

    // Decref on the old handle, if applicable
    reg_t old_handle;
    if (!reg_get_value_ex(reg_id, &builder->mc, (uint8_t*)&old_handle)) return 0;
    if (old_handle < builder->exprs.entries && builder->exprs.array[handle]) {
        expr_free(builder, (unsigned long)old_handle);
    }

    reg_t new_handle = handle;
    reg_set_value_ex(reg_id, &builder->mc, (uint8_t*)&new_handle);
    exprbuilder_incref(builder, handle);
    return 1;
}

extern int g_pyda_tls_idx;

int exprbuilder_compile(ExprBuilder *builder, instrlist_t *bb, instr_t *instr, int expr_handle_start) {
    void *drcontext = dr_get_current_drcontext();
    instr_t *new_instr;
    reg_id_t reg, scratch_ptr_reg;
    reg_id_t op1_reg, op2_reg;

    if (builder->exprs.entries > SCRATCH_SLOTS) {
        dr_fprintf(STDERR, "Register allocation is not yet implemented");
        return 0;
    }

    if (expr_handle_start >= builder->exprs.entries) {
        return 1;
    }

    // Reserve a register for accessing TLS
    if (drreg_reserve_register(drcontext, bb, instr, NULL, &scratch_ptr_reg) != DRREG_SUCCESS) {
        dr_fprintf(STDERR, "Failed to reserve scratch register\n");
        return 0;
    }

    // Reserve registers for operands
    if (drreg_reserve_register(drcontext, bb, instr, NULL, &op1_reg) != DRREG_SUCCESS) {
        dr_fprintf(STDERR, "Failed to reserve op1 register\n");
        return 0;
    }

    if (drreg_reserve_register(drcontext, bb, instr, NULL, &op2_reg) != DRREG_SUCCESS) {
        dr_fprintf(STDERR, "Failed to reserve op2 register\n");
        return 0;
    }

    if (!drmgr_insert_read_tls_field(drcontext, g_pyda_tls_idx, bb, instr, scratch_ptr_reg)) {
        dr_fprintf(STDERR, "Failed to read TLS field\n");
        return 0;
    }

    opnd_t scratch_base = opnd_create_reg(scratch_ptr_reg);

    // Add offsetof(pyda_thread, scratch_region) to the base address
    new_instr = XINST_CREATE_add(drcontext, scratch_base, opnd_create_immed_int(offsetof(pyda_thread, scratch_region), OPSZ_8));
    instrlist_meta_preinsert(bb, instr, new_instr);

    // Use the scratch region for each expression
    for (unsigned long i = expr_handle_start; i < builder->exprs.entries; i++) {
        struct Expr *expr = builder->exprs.array[i];
        if (!expr) continue;

        if (expr->ty == EXPR_TYPE_RAW) {
            // Unreserve the registers
            drreg_unreserve_register(drcontext, bb, instr, op1_reg);
            drreg_unreserve_register(drcontext, bb, instr, op2_reg);
            drreg_restore_app_value(drcontext, bb, instr, op1_reg, op1_reg, false);
            drreg_restore_app_value(drcontext, bb, instr, op2_reg, op2_reg, false);

            // Commit the current abstract register state
            exprbuilder_commit(builder, bb, instr, scratch_ptr_reg);

            drreg_unreserve_register(drcontext, bb, instr, scratch_ptr_reg);
            drreg_restore_app_value(drcontext, bb, instr, scratch_ptr_reg, scratch_ptr_reg, false);

            // Emit the raw instructions
            if (((struct ExprRaw *)expr)->code == NULL) {
                dr_fprintf(STDERR, "exprbuilder_compiler: raw expr re-ruse is not supported\n");
                dr_abort();
            }

            instrlist_meta_preinsert(bb, instr, instrlist_first(((struct ExprRaw *)expr)->code));
            instrlist_init(((struct ExprRaw *)expr)->code);
            instrlist_destroy(drcontext, ((struct ExprRaw *)expr)->code);
            ((struct ExprRaw *)expr)->code = NULL;

            // Continue
            return exprbuilder_compile(builder, bb, instr, i + 1);
        }

        if (expr->ty != EXPR_TYPE_CONST && expr->ty != EXPR_TYPE_REG) {
            new_instr = XINST_CREATE_load(drcontext, opnd_create_reg(op1_reg), opnd_create_base_disp(scratch_ptr_reg, DR_REG_NULL, 0, 8 * expr->op1, OPSZ_8));
            instrlist_meta_preinsert(bb, instr, new_instr);
        }

        if (expr->ty != EXPR_TYPE_CONST && expr->ty != EXPR_TYPE_REG && expr->ty != EXPR_TYPE_LOAD) {
            new_instr = XINST_CREATE_load(drcontext, opnd_create_reg(op2_reg), opnd_create_base_disp(scratch_ptr_reg, DR_REG_NULL, 0, 8 * expr->op2, OPSZ_8));
            instrlist_meta_preinsert(bb, instr, new_instr);
        }

        // Compute the expression and store the result in the scratch region
        // XXX: We should check that none of these touch flags
        switch (expr->ty) {
            case EXPR_TYPE_CONST:
                // new_instr = XINST_CREATE_load_int(drcontext, opnd_create_reg(op1_reg), opnd_create_immed_int(expr->op1, OPSZ_8));
                // instrlist_meta_preinsert(bb, instr, new_instr);
                instrlist_insert_mov_immed_ptrsz(drcontext, expr->op1, opnd_create_reg(op1_reg), bb, instr, NULL, NULL);
                break;
            case EXPR_TYPE_ADD:
                new_instr = XINST_CREATE_add(drcontext, opnd_create_reg(op1_reg), opnd_create_reg(op2_reg));
                instrlist_meta_preinsert(bb, instr, new_instr);
                break;
            case EXPR_TYPE_SUB:
                new_instr = XINST_CREATE_sub(drcontext, opnd_create_reg(op1_reg), opnd_create_reg(op2_reg));
                instrlist_meta_preinsert(bb, instr, new_instr);
                break;
            case EXPR_TYPE_MUL:
#if defined(X86)
                new_instr = INSTR_CREATE_imul(drcontext, opnd_create_reg(op1_reg), opnd_create_reg(op2_reg));
#elif defined(AARCH64)
                new_instr = instr_create_1dst_3src(drcontext, OP_madd, opnd_create_reg(op1_reg), opnd_create_reg(op1_reg), opnd_create_reg(op2_reg), opnd_create_reg(DR_REG_XZR));
#else
    #error "Unsupported architecture"
#endif
                instrlist_meta_preinsert(bb, instr, new_instr);
                break;
            /*
            case EXPR_TYPE_DIV:
#if defined(X86)
                new_instr = INSTR_CREATE_div(drcontext, opnd_create_reg(op1_reg), opnd_create_reg(op2_reg));
#elif defined(AARCH64)
                new_instr = instr_create_1dst_2src(drcontext, OP_sdiv, opnd_create_reg(op1_reg), opnd_create_reg(op1_reg), opnd_create_reg(op2_reg));
#else
    #error "Unsupported architecture"
#endif
                instrlist_meta_preinsert(bb, instr, new_instr);
                break;
            */
            case EXPR_TYPE_LOAD:
                new_instr = XINST_CREATE_load(drcontext, opnd_create_reg(op1_reg), opnd_create_base_disp(op1_reg, DR_REG_NULL, 0, 0, OPSZ_8));
                instrlist_meta_preinsert(bb, instr, new_instr);
                break;
            case EXPR_TYPE_STORE:
                new_instr = XINST_CREATE_store(drcontext, opnd_create_base_disp(op1_reg, DR_REG_NULL, 0, 0, OPSZ_8), opnd_create_reg(op2_reg));
                instrlist_meta_preinsert(bb, instr, new_instr);
                break;
            case EXPR_TYPE_REG:
                if (opnd_is_pc(opnd_create_reg(expr->op1))) {
                    dr_fprintf(STDERR, "exprbuilder_compile: PC is probably not what you want to read here!\n");
                }

                if (reg_is_stolen(expr->op1)) {
                    dr_insert_get_stolen_reg_value(drcontext, bb, instr, op1_reg);
                } else if (expr->op1 == op1_reg || expr->op1 == op2_reg || expr->op1 == scratch_ptr_reg) {
                    /* mov is not sufficient. the register has been brorowed. */
                    drreg_restore_app_value(drcontext, bb, instr, expr->op1, op1_reg, false);
#if defined(AARCH64)
                } else if (expr->op1 == DR_REG_SP) {
                    dr_fprintf(STDERR, "exprbuilder_compile: add sp\n");
                    new_instr = INSTR_CREATE_add_shift(drcontext, opnd_create_reg(op1_reg), opnd_create_reg(DR_REG_SP), OPND_CREATE_INT(0), OPND_CREATE_LSL(), OPND_CREATE_INT(0));
                    instrlist_meta_preinsert(bb, instr, new_instr);
#endif
                } else {
                    new_instr = XINST_CREATE_move(drcontext, opnd_create_reg(op1_reg), opnd_create_reg(expr->op1));
                    instrlist_meta_preinsert(bb, instr, new_instr);
                }
                break;
            default:
                dr_fprintf(STDERR, "exprbuilder_compile: unknown expression type %lu\n", expr->ty);
                break;
        }

        if (expr->ty != EXPR_TYPE_STORE) {
            new_instr = XINST_CREATE_store(drcontext, opnd_create_base_disp(scratch_ptr_reg, DR_REG_NULL, 0, 8 * i, OPSZ_8), opnd_create_reg(op1_reg));
            instrlist_meta_preinsert(bb, instr, new_instr);
       }
    }

    // Unreserve the register
    drreg_unreserve_register(drcontext, bb, instr, op1_reg);
    drreg_unreserve_register(drcontext, bb, instr, op2_reg);
    drreg_restore_app_value(drcontext, bb, instr, op1_reg, op1_reg, false);
    drreg_restore_app_value(drcontext, bb, instr, op2_reg, op2_reg, false);

    exprbuilder_commit(builder, bb, instr, scratch_ptr_reg);

    drreg_unreserve_register(drcontext, bb, instr, scratch_ptr_reg);
    drreg_restore_app_value(drcontext, bb, instr, scratch_ptr_reg, scratch_ptr_reg, false);

    return 1;
}

static bool handle_is_reg(ExprBuilder *builder, unsigned long handle, reg_id_t reg) {
    if (handle >= builder->exprs.entries || !builder->exprs.array[handle]) {
        return 0;
    }
    return (
        handle < builder->exprs.entries
        && builder->exprs.array[handle]
        && ((struct Expr *)builder->exprs.array[handle])->ty == EXPR_TYPE_REG
        && ((struct Expr *)builder->exprs.array[handle])->op1 == reg
    );
}

static void exprbuilder_commit(ExprBuilder *builder, instrlist_t *bb, instr_t *instr, reg_id_t scratch_ptr_reg) {
    void *drcontext = dr_get_current_drcontext();
    // Move final values into registers
    for (reg_id_t reg = DR_REG_START_GPR; reg <= DR_REG_STOP_GPR; reg++) {
        unsigned long handle;
        if (exprbuilder_reg_get(builder, reg, &handle)) {
            if (handle_is_reg(builder, handle, reg)) {
                expr_free(builder, handle);
                return;
            }

            if (reg == scratch_ptr_reg) {
                dr_fprintf(STDERR, "exprbuilder_compile: INTERNAL ERROR register %lu is scratch\n", reg);
                dr_abort();
            }

            if (opnd_is_pc(opnd_create_reg(reg))) {
                dr_fprintf(STDERR, "exprbuilder_compile: You cannot modify PC in exprbuilder\n");
                dr_abort();
            }

            DEBUG_PRINTF("exprbuilder_compile: moving final value %d into register %s\n", handle, get_register_name(reg));
            if (reg_is_stolen(reg)) {
                DEBUG_PRINTF("exprbuilder_compile: writing to stolen register %d\n", reg);
                reg_id_t tmp_reg;

                // We need to reserve a register to put the value in so we can call dr_insert_set_stolen_reg_value
                if (drreg_reserve_register(drcontext, bb, instr, NULL, &tmp_reg) != DRREG_SUCCESS) {
                    dr_fprintf(STDERR, "Failed to reserve scratch register\n");
                }

                // Load into the reserved register
                instr_t *load_instr = XINST_CREATE_load(drcontext, opnd_create_reg(tmp_reg), opnd_create_base_disp(scratch_ptr_reg, DR_REG_NULL, 0, 8 * handle, OPSZ_8));
                instrlist_meta_preinsert(bb, instr, load_instr);

                // Set the stolen reg value to the reserved register
                dr_insert_set_stolen_reg_value(drcontext, bb, instr, tmp_reg);
                drreg_unreserve_register(drcontext, bb, instr, tmp_reg);
                if (drreg_restore_all(drcontext, bb, instr) != DRREG_SUCCESS) {
                    dr_fprintf(STDERR, "Failed to drreg_restore_all\n");
                    dr_abort();
                }
            } else {
                // TODO: SP does not work here
                instr_t *load_instr = XINST_CREATE_load(drcontext, opnd_create_reg(reg), opnd_create_base_disp(scratch_ptr_reg, DR_REG_NULL, 0, 8 * handle, OPSZ_8));
                instrlist_meta_preinsert(bb, instr, load_instr);
            }
            expr_free(builder, handle);
        }
    }
}

```

`pyda_core/pyda_core.c`:

```c
#include "pyda_core.h"
#include "pyda_threads.h"
#include "pyda_util.h"
#include <fcntl.h>

#if defined(LINUX)
#include <pty.h>
#include <sys/syscall.h>
#elif defined(MACOS)
#include <util.h>
/* TODO: fix test_io for macos, it probably doesn't work... */
#define SYS_read 0
#define SYS_write 1
#endif

#define CONTEXT_STACK_LIMIT 10

#ifndef PYDA_DYNAMORIO_CLIENT

pyda_process* pyda_mk_process() {
    // TODO: We might be able to use this to fork and launch the process
    // (in which the entire python file will be reparsed...)
    ABORT_IF_NODYNAMORIO;
}

#else
#include "dr_api.h"

static void free_hook_step1(void *data) {
    // Must hold GIL
    pyda_hook *hook = (pyda_hook*)data;
    Py_DECREF(hook->py_func);
    hook->py_func = NULL;
}

static void free_hook_step2(void *data) {
    // no GIL required
    dr_global_free(data, sizeof(pyda_hook));
}

static void thread_prepare_for_python_entry(PyGILState_STATE *gstate, pyda_thread *t, void* pc);
static void thread_prepare_for_python_return(pyda_thread *t, void* hook_addr);


pyda_process* pyda_mk_process() {
    ABORT_IF_NODYNAMORIO;

    pyda_process *proc = dr_global_alloc(sizeof(pyda_process));
    proc->refcount = 0; // xxx: will be incremented to 1 by first pyda_mk_thread
    proc->flush_count = 0;
    drvector_init(&proc->threads, 0, true, NULL);
    drvector_init(&proc->thread_run_untils, 0, true, NULL);

    proc->main_thread = pyda_mk_thread(proc);
    hashtable_init_ex(&proc->callbacks, 4, HASH_INTPTR, false, false, NULL, NULL, NULL);

    proc->thread_init_hook = NULL;
    proc->syscall_pre_hook = NULL;
    proc->syscall_post_hook = NULL;
    proc->module_load_hook = NULL;
    proc->py_obj = NULL;

    // Setup locks, etc.
    pthread_condattr_t condattr;
    int ret;
    pthread_condattr_init(&condattr);

#ifdef LINUX
    if ((ret = pthread_condattr_setpshared(&condattr, PTHREAD_PROCESS_SHARED))) {
        dr_fprintf(STDERR, "pthread_condattr_setpshared failed: %d\n", ret);
        dr_abort();
    }
#endif // LINUX
    if ((ret = pthread_cond_init(&proc->thread_exit_cond, &condattr))) {
        dr_fprintf(STDERR, "pthread_cond_init failed %d\n", ret);
        dr_abort();
    }

    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);

#ifdef LINUX
    if ((ret = pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED))) {
        dr_fprintf(STDERR, "pthread_mutexattr_setpshared failed %d\n", ret);
        dr_abort();
    }
#endif

    if ((ret = pthread_mutex_init(&proc->refcount_mutex, &attr))) {
        dr_fprintf(STDERR, "pthread_mutex_init failed %d\n", ret);
        dr_abort();
    }

    // Setup I/O
    proc->stdin_fd = -1;
    proc->stdout_fd = -1;
    proc->stderr_fd = -1;

    // TODO: also need to modify dynamorio printing functions
    // as they use raw fd 0/1/2
    return proc;
}

extern file_t our_stderr;

void pyda_capture_io(pyda_process *proc, int use_pty, int pty_raw) {
    if (use_pty) {
        int master, slave;

        if (openpty(&master, &slave, NULL, NULL, NULL)) {
            // Failed to open TTY
            DEBUG_PRINTF("Failed to open TTY err %s\n", strerror(errno));
            use_pty = false;
        } else {
            dup2(slave, 0);
            dup2(slave, 1);
            dup2(slave, 2);
            proc->stdin_fd = dup(master);
            proc->stdout_fd = dup(master);
            proc->stderr_fd = dup(master);

            // Modify tty attributes
            struct termios tmios;
            if (tcgetattr(master, &tmios)) {
                DEBUG_PRINTF("Failed to get termios\n");
            } else {
                if (pty_raw)
                    cfmakeraw(&tmios);

                // Always: no echo
                tmios.c_lflag &= ~(ECHO);

                if (tcsetattr(master, TCSANOW, &tmios)) {
                    DEBUG_PRINTF("Failed to set termios\n");
                }
            }
        }
    }

    if (!use_pty) { // We were asked not to use a pty, or pty init failed
        int pipe1[2], pipe2[2], pipe3[2];
        if (pipe(pipe1) || pipe(pipe2) || pipe(pipe3)) {
            dr_fprintf(STDERR, "Failed to create pipes\n");
            dr_abort();
        }

        // Try to make a larger pipe (1M)
#ifdef LINUX
        if (fcntl(pipe1[0], F_SETPIPE_SZ, 1024*1024) || fcntl(pipe2[0], F_SETPIPE_SZ, 1024*1024) || fcntl(pipe3[0], F_SETPIPE_SZ, 1024*1024)) {
            DEBUG_PRINTF("Failed to set pipe size to 1M\n");
        }
#endif

        dup2(pipe1[0], 0);
        dup2(pipe2[1], 1);
        dup2(pipe3[1], 2);

        proc->stdin_fd = pipe1[1];
        proc->stdout_fd = pipe2[0];
        proc->stderr_fd = pipe3[0];
    }

    // nonblocking
    if (fcntl(proc->stdout_fd, F_SETFL, O_NONBLOCK) || fcntl(proc->stderr_fd, F_SETFL, O_NONBLOCK) || fcntl(proc->stdin_fd, F_SETFL, O_NONBLOCK)) {
        dr_fprintf(STDERR, "Failed to set stdio to nonblocking\n");
        dr_abort();
    }
}

// NOTE: This is called from thread_init_event on the main app thread
void pyda_prepare_io(pyda_process *proc) {
    // This sets up three new FDs for Pyda to
    // direct its output to. We set stdin/out/err to
    // the new FDs here, which occurs prior to Python startup
    //
    // Thus, Python will also use these new fds by default.

    int orig_in = dup(0);
    int orig_out = dup(1);
    int orig_err = dup(2);

    stdin = fdopen(orig_in, "r");
    stdout = fdopen(orig_out, "w");
    stderr = fdopen(orig_err, "w");

    our_stderr = orig_err;
}

static void free_context(void *ptr) {
    dr_global_free(ptr, sizeof(dr_mcontext_t));
}

pyda_thread* pyda_mk_thread(pyda_process *proc) {
    ABORT_IF_NODYNAMORIO;

    pyda_thread *thread = dr_global_alloc(sizeof(pyda_thread));
    pthread_condattr_t condattr;
    pthread_condattr_init(&condattr);
    int ret;

#ifdef LINUX
    if ((ret = pthread_condattr_setpshared(&condattr, PTHREAD_PROCESS_SHARED))) {
        dr_fprintf(STDERR, "pthread_condattr_setpshared failed: %d\n", ret);
        dr_abort();
    }
#endif // LINUX
    if ((ret = pthread_cond_init(&thread->resume_cond, &condattr))) {
        dr_fprintf(STDERR, "pthread_cond_init failed %d\n", ret);
        dr_abort();
    }

    if (pthread_cond_init(&thread->break_cond, &condattr)) {
        dr_fprintf(STDERR, "pthread_cond_init failed\n");
        dr_abort();
    }

    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
#ifdef LINUX
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
#endif
    pthread_mutex_init(&thread->mutex, &attr);

    // Start with it locked...
    pthread_mutex_lock(&thread->mutex);

    thread->python_yielded = 0;
    thread->app_yielded = 0;
    thread->proc = proc;

    dr_atomic_add32_return_sum(&thread->proc->refcount, 1);

    thread->yield_count = 0;

    static volatile int tid = 0;
    thread->tid = dr_atomic_add32_return_sum(&tid, 1);
    thread->rip_updated_in_python = 0;
    thread->skip_next_hook = 0;
    thread->python_exited = 0;
    thread->app_exited = 0;
    thread->errored = 0;
    thread->python_blocked_on_io = 0;
    thread->run_until = 0;
    thread->signal = 0;
    thread->dirty_run_until = 0;
    thread->flush_ts = proc->flush_count;

    drvector_init(&thread->context_stack, 0, true, free_context);
    drvector_init(&thread->hook_update_queue, 0, true, NULL);

    drvector_append(&proc->threads, thread);
    drvector_append(&proc->thread_run_untils, NULL);

    thread->expr_builder = NULL;

    memset(thread->scratch_region, 0xef, sizeof(thread->scratch_region));

    // PyErr_SetString(PyExc_RuntimeError, "OK");
    return thread;
}

void pyda_process_destroy(pyda_process *p) {
    // We must be holding the GIL lock so we can drop the refs
    if (PyGILState_Check()) {
        DEBUG_PRINTF("pyda_process_destroy already holds GIL.")
    }
    PyGILState_STATE gstate = PyGILState_Ensure();

    DEBUG_PRINTF("pyda_process_destroy\n");
    if (p->thread_init_hook)
        Py_DECREF(p->thread_init_hook);

    p->thread_init_hook = NULL;

    if (p->syscall_pre_hook)
        Py_DECREF(p->syscall_pre_hook);

    p->syscall_pre_hook = NULL;

    if (p->syscall_post_hook)
        Py_DECREF(p->syscall_post_hook);

    p->syscall_post_hook = NULL;

    if (p->module_load_hook)
        Py_DECREF(p->module_load_hook);

    p->module_load_hook = NULL;

    hashtable_delete(&p->callbacks);
    drvector_delete(&p->threads);
    drvector_delete(&p->thread_run_untils);

    dr_global_free(p, sizeof(pyda_process));

    PyGILState_Release(gstate);
}

void pyda_thread_destroy(pyda_thread *t) {
    DEBUG_PRINTF("pyda_thread_destroy for idx %d\n", t->tid);
    pthread_mutex_lock(&t->proc->refcount_mutex);

    int new_refcount = dr_atomic_add32_return_sum(&t->proc->refcount, -1);
    if (new_refcount == 0) {
        pyda_process_destroy(t->proc);
    } else {
        pthread_cond_signal(&t->proc->thread_exit_cond);
        pthread_mutex_unlock(&t->proc->refcount_mutex);
    }

    drvector_delete(&t->context_stack);
    drvector_delete(&t->hook_update_queue);

    dr_global_free(t, sizeof(pyda_thread));
}

void pyda_thread_destroy_last(pyda_thread *t) {
    // wait for this thread to be the final thread
    pthread_mutex_lock(&t->proc->refcount_mutex);
    while (t->proc->refcount > 1)
        pthread_cond_wait(&t->proc->thread_exit_cond, &t->proc->refcount_mutex);

    DEBUG_PRINTF("pyda_thread_destroy_last unblock\n")
    pthread_mutex_unlock(&t->proc->refcount_mutex);
    pyda_thread_destroy(t);
}

void pyda_yield_noblock(pyda_thread *t) {
    t->python_yielded = 1;
    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->resume_cond);
    pthread_mutex_unlock(&t->mutex);
}

// yield from python to the executable
void pyda_yield(pyda_thread *t) {
    t->python_yielded = 1;
    t->yield_count++;

    // here we wait for the executable to signal

    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->resume_cond);

    while (!t->app_yielded)
        pthread_cond_wait(&t->break_cond, &t->mutex);

    t->app_yielded = 0;
    pthread_mutex_unlock(&t->mutex);

}

void pyda_break_noblock(pyda_thread *t) {
    t->app_yielded = 1;
    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->break_cond);
    pthread_mutex_unlock(&t->mutex);
}

// yield from the executable back to python
void pyda_break(pyda_thread *t) {
    t->app_yielded = 1;

    // Hack to tell dynamorio that dr_flush_region on another thread is OK
    // here -- this is not REALLY safe per the docs but we use
    // dr_redirect_execution so we *should* always return to a valid fragment...
    // dr_mark_safe_to_suspend(dr_get_current_drcontext(), true);

    // here we wait for the python to signal
    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->break_cond);

    while (!t->python_yielded)
        pthread_cond_wait(&t->resume_cond, &t->mutex);

    // dr_mark_safe_to_suspend(dr_get_current_drcontext(), false);

    t->python_yielded = 0;
    pthread_mutex_unlock(&t->mutex);
}

void pyda_initial_break(pyda_thread *t) {
    // lock is already held
    while (!t->python_yielded)
        pthread_cond_wait(&t->resume_cond, &t->mutex);

    t->python_yielded = 0;
    pthread_mutex_unlock(&t->mutex);
}

PyObject *pyda_run_until(pyda_thread *proc, uint64_t addr) {
    DEBUG_PRINTF("run_until: %llx\n", addr);
    return NULL;
}

void pyda_add_hook(pyda_process *p, uint64_t addr, PyObject *callback, int callback_type, int needs_flush) {
    pyda_hook *cb = dr_global_alloc(sizeof(pyda_hook));
    cb->py_func = callback;
    cb->callback_type = callback_type;
    cb->addr = (void*)addr;
    cb->deleted = 0;

    Py_INCREF(callback);
    DEBUG_PRINTF("pyda_add_hook %p %p for %llx (type=%d)\n", cb, cb->py_func, addr, callback_type);

    if (!hashtable_add(&p->callbacks, (void*)addr, cb)) {
        dr_global_free(cb, sizeof(pyda_hook));
        dr_fprintf(STDERR, "Failed to add hook at %p\n", (void*)addr);
        dr_abort();
    }

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);

    if (needs_flush)
        drvector_append(&t->hook_update_queue, (void*)cb);
}

void pyda_remove_hook(pyda_process *p, uint64_t addr) {
    // note: GIL is held here...
    pyda_hook *cb = pyda_get_callback(p, (void*)addr);
    if (cb) {
        hashtable_remove(&p->callbacks, (void*)addr);
        pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);

        if (dr_memory_is_readable((app_pc)addr, 1))
            drvector_append(&t->hook_update_queue, (void*)cb);

        // Here, we decref the python function and NULL it out.
        // But we can't free it yet (there are still refs in the code
        // cache).
        free_hook_step1(cb);
    }
}

void pyda_set_thread_init_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->thread_init_hook)
        Py_DECREF(p->thread_init_hook);

    p->thread_init_hook = callback;
    Py_INCREF(callback);
}

void pyda_set_syscall_pre_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->syscall_pre_hook)
        Py_DECREF(p->syscall_pre_hook);

    p->syscall_pre_hook = callback;
    Py_INCREF(callback);
}

void pyda_set_syscall_post_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->syscall_post_hook)
        Py_DECREF(p->syscall_post_hook);

    p->syscall_post_hook = callback;
    Py_INCREF(callback);
}

void pyda_set_module_load_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->module_load_hook)
        Py_DECREF(p->module_load_hook);

    p->module_load_hook = callback;
    Py_INCREF(callback);
}

int pyda_flush_hooks() {
    void *drcontext = dr_get_current_drcontext();
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    pyda_process *p = t->proc;

    int flushed = 0;
    if (t->dirty_run_until) {
        void *run_until = pyda_get_run_until(t);
        if (run_until) dr_flush_region((void*)run_until, 1);
        t->dirty_run_until = 0;
        flushed = 1;
    }

    if (t->hook_update_queue.entries) {
        flushed = 1;

        // Copy to temporary, alternate storage so we don't hold the lock
        // (note: hook_update_queue is only shared between one python/app thread pair)
        // XXX: The copy doesn't make a lot of sense anymore, we don't call dr_mark_safe_to_suspend anywhere?
        int entry_count = t->hook_update_queue.entries;
        void **tmp = dr_thread_alloc(drcontext, sizeof(void*) * entry_count);
        if (!tmp) {
            dr_fprintf(STDERR, "dr_thread_alloc failed");
            dr_abort();
        }
        memcpy(tmp, t->hook_update_queue.array, sizeof(void*) * entry_count);
        t->hook_update_queue.entries = 0;

        // Flush added/removed hooks
        for (int i=0; i<entry_count; i++) {
            pyda_hook *hook = (pyda_hook*)tmp[i];

            if (hook->deleted) {
                tmp[i] = NULL; // Ensure we do not double-flush or double-free.
                continue;
            }

            void *addr = hook->addr;
            DEBUG_PRINTF("dr_flush_region: %llx\n", addr);
            dr_flush_region(addr, 1);
            DEBUG_PRINTF("dr_flush_region end %llx\n", addr);

            if (hook->py_func == NULL) {
                // This hook was removed; Now that the hook refs are finally removed from code cache,
                // we can free the pyda_hook. Here we mark ->deleted
                // so that we don't try to free it again. This can occur if hook is added/removed
                // without flushing.
                hook->deleted = 1;
            }

            // race lol
            p->flush_count++;
        }

        for (int i=0; i<entry_count; i++) {
            pyda_hook *hook = (pyda_hook*)tmp[i];
            if (hook && hook->deleted) {
                // Free the hook itself.
                free_hook_step2(hook);
            }
        }

        dr_thread_free(drcontext, tmp, sizeof(void*) * entry_count);
    }

    if (t->flush_ts != p->flush_count) {
        // Require that dr_redirect_execution is used, since another thread may have flushed
        // us during the dr_mark_safe_to_suspend section in thread_prepare_for_python_entry
        //
        // note: I think right now other threads cannot flush us
        flushed = 1;
        t->flush_ts = p->flush_count;
    }


    return flushed;
}
pyda_hook* pyda_get_callback(pyda_process *p, void* addr) {
    pyda_hook *cb = (void*)hashtable_lookup(&p->callbacks, addr);
    return cb;  // Return callback regardless of type, let caller handle type checking
}

void *pyda_get_run_until(pyda_thread *t) {
    return (void*)t->run_until;
}

void pyda_set_run_until(pyda_thread *t, void *pc) {
    t->run_until = (uint64_t)pc;
    t->dirty_run_until = 1;
    drvector_set_entry(&t->proc->thread_run_untils, t->tid-1, pc);
    // NOTE: Will be flushed by pyda_break callers. Don't need to flush here.
}

void pyda_clear_run_until(pyda_thread *t) {
    uint64_t run_until = t->run_until;
    t->run_until = 0;
    t->dirty_run_until = 1;
    drvector_set_entry(&t->proc->thread_run_untils, t->tid-1, NULL);

    if (run_until)
        dr_flush_region((void*)run_until, 1);
}

int pyda_check_run_until(pyda_process *proc, void *test_pc) {
    // Unlocked for performance.
    for (int i=0; i<proc->thread_run_untils.entries; i++) {
        if (test_pc == proc->thread_run_untils.array[i]) return 1;
    }
    return 0;
}

static void thread_prepare_for_python_entry(PyGILState_STATE *gstate, pyda_thread *t, void* pc) {
    if (gstate) {
        // HACK: dr_mark_safe_to_suspend is not allowed in a cleancall, per the docs.
        // We sortof get away with this because we check later to see if any flushes
        // occurred during this period, and force a dr_redirect_execution if they did.
        t->flush_ts = t->proc->flush_count;

        // dr_mark_safe_to_suspend(dr_get_current_drcontext(), true);
        *gstate = PyGILState_Ensure();
        // dr_mark_safe_to_suspend(dr_get_current_drcontext(), false);
    }

    void *drcontext = dr_get_current_drcontext();
    t->cur_context.size = sizeof(dr_mcontext_t);
    t->cur_context.flags = DR_MC_ALL; // dr_redirect_execution requires it
    dr_get_mcontext(drcontext, &t->cur_context);

    if (pc)
        t->cur_context.pc = (app_pc)pc;

    t->rip_updated_in_python = 0;
}

// NOTE: This is called without the GIL held!
static void thread_prepare_for_python_return(pyda_thread *t, void* hook_addr) {
    void *drcontext = dr_get_current_drcontext();

    // Syscall hooks are not allowed to modify PC and we not allow modifying hooks
    if (!hook_addr) {
        if (t->rip_updated_in_python) {
            dr_fprintf(STDERR, "\n[Pyda] ERROR: Syscall hooks are not allowed to modify PC. Skipping future hooks.\n");
            dr_flush_file(STDERR);
            t->errored = 1;
        }
        dr_set_mcontext(drcontext, &t->cur_context);
        if (t->hook_update_queue.entries > 0) {
            dr_fprintf(STDERR, "\n[Pyda] WARN: Hooks should not be modified in a syscall. This is UB, continuing.\n");
        }
        return;
    }

    if (t->cur_context.pc == (app_pc)hook_addr && t->rip_updated_in_python) {
        dr_fprintf(STDERR, "\n[Pyda] ERROR: Hook updated RIP to the same address. This is UB. Skipping future hooks.\n");
        dr_flush_file(STDERR);
        t->errored = 1;
    }

    if (pyda_flush_hooks() || t->rip_updated_in_python) {
        // NOTE: We are not holding any locks here... it's possible that some other thread will remove the hook we're executing right
        // now... the "best we can do for now" to avoid infinite loop is to detect that we are returning to the same spot,
        // and to skip the hook the next time.
        if (t->cur_context.pc == hook_addr && (pyda_get_callback(t->proc, hook_addr) || pyda_get_run_until(t) == hook_addr)) {
            t->skip_next_hook = 1;
            dr_flush_file(STDERR);
        }
        // we need to call dr_redirect_execution
        dr_redirect_execution(&t->cur_context);
    } else {
        dr_set_mcontext(drcontext, &t->cur_context);
    }
}

void pyda_hook_cleancall(pyda_hook *cb) {
    PyGILState_STATE gstate;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);

    if (t->skip_next_hook) {
        t->skip_next_hook = 0;
        return;
    }

    if (t->errored) return;

    DEBUG_PRINTF("cleancall %p %p %p tid=%d\n", cb->addr, cb->py_func, t, dr_get_thread_id(dr_get_current_drcontext()));
    thread_prepare_for_python_entry(&gstate, t, cb->addr);
    DEBUG_PRINTF("cleancall LOCKED %p %p %p\n", cb->addr, cb->py_func, t);

    if (cb->py_func) { // Can be NULL if hook was already removed, but hasn't been flushed from code cache yet.
        PyObject *result = PyObject_CallFunctionObjArgs(cb->py_func, t->proc->py_obj, NULL);

        if (result == NULL) {
            dr_fprintf(STDERR, "\n[Pyda] ERROR: Hook call failed. Skipping future hooks on thread %d\n", t->tid);

            dr_flush_file(STDERR);
            t->errored = 1;
            PyErr_Print();
            dr_fprintf(STDERR, "\n");
            // dr_abort();
            if (getenv("PYDA_ABORT_ON_ERROR") && getenv("PYDA_ABORT_ON_ERROR")[0] == '1') {
                dr_fprintf(STDERR, "\n[Pyda] ABORTING (will crash now)\n");
                *(int*)(1) = 1;
            }
        } else {
            Py_DECREF(result);
        }

        DEBUG_PRINTF("cleancall ret %p %p %p\n", cb, cb->py_func, t);
    }

    PyGILState_Release(gstate);

    // If this also happens to be the run_until target for this thread,
    // we deal with that here (instead of inserting two hooks)
    if (!t->python_exited && cb->addr == pyda_get_run_until(t)) {
        // It is UB to modify PC in a hook that is also the run_until target
        if (t->rip_updated_in_python) {
            dr_fprintf(STDERR, "\n[Pyda] ERROR: Hook updated RIP, but run_until target is hit. This is UB. Continuing.");
            dr_flush_file(STDERR);
            t->errored = 1;
        }

        // Clear the run_until flag and flush the block
        pyda_clear_run_until(t);

        // Wait for Python to yield back to us
        pyda_break(t);
    }

    thread_prepare_for_python_return(t, cb->addr); // MAY NOT RETURN
}

int pyda_hook_syscall(int syscall_num, int is_pre) {
    PyGILState_STATE gstate;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t->errored) return 1;

    if (is_pre == 0 && (syscall_num == SYS_read || syscall_num == SYS_write) && t->python_blocked_on_io) { // read/write
        t->python_blocked_on_io = 0;
        thread_prepare_for_python_entry(NULL, t, NULL);
        pyda_break(t);
        thread_prepare_for_python_return(t, NULL); // (note: guaranteed to return)

        if (t->errored) return 1;
    }

    PyObject *hook = (is_pre ? t->proc->syscall_pre_hook : t->proc->syscall_post_hook);
    if (!hook) return 1;

    thread_prepare_for_python_entry(&gstate, t, NULL);

    DEBUG_PRINTF("syscall %d pre %d\n", syscall_num, is_pre);

    int should_run = 1;

    PyObject *syscall_num_obj = PyLong_FromLong(syscall_num);
    PyObject *result = PyObject_CallFunctionObjArgs(hook, t->proc->py_obj, syscall_num_obj, NULL);

    Py_DECREF(syscall_num_obj);

    if (result == NULL) {
        dr_fprintf(STDERR, "\n[Pyda] ERROR: Syscall hook call failed. Skipping future hooks on thread %d\n", t->tid);
        dr_flush_file(STDERR);
        t->errored = 1;
        PyErr_Print();
        dr_fprintf(STDERR, "\n");
    } else if (is_pre && PyBool_Check(result)) {
        // Should run
        should_run = PyObject_IsTrue(result);
        DEBUG_PRINTF("syscall pre_hook returned %d\n", should_run);
    } else {
        Py_DECREF(result);
        DEBUG_PRINTF("syscall hook returned non-bool\n");
    }

    DEBUG_PRINTF("syscall ret %d pre %d\n", syscall_num, is_pre);
    PyGILState_Release(gstate);
    thread_prepare_for_python_return(t, NULL);

    return should_run;
}

void pyda_hook_module_load(const char *module_path) {
    PyGILState_STATE gstate;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t->errored) return;

    PyObject *hook = t->proc->module_load_hook;
    if (!hook) return;

    thread_prepare_for_python_entry(&gstate, t, NULL);

    DEBUG_PRINTF("module_load %s\n", module_path);

    PyObject *module_path_obj = PyUnicode_FromString(module_path);
    PyObject *result = PyObject_CallFunctionObjArgs(hook, t->proc->py_obj, module_path_obj, NULL);

    Py_DECREF(module_path_obj);

    if (result == NULL) {
        dr_fprintf(STDERR, "\n[Pyda] ERROR: Module load hook call failed. Skipping future hooks on thread %d\n", t->tid);
        dr_flush_file(STDERR);
        t->errored = 1;
        PyErr_Print();
        dr_fprintf(STDERR, "\n");
    } else {
        Py_DECREF(result);
    }

    DEBUG_PRINTF("module_load ret %s\n", module_path);
    PyGILState_Release(gstate);
    thread_prepare_for_python_return(t, NULL);
}

void pyda_hook_rununtil_reached(void *pc) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t->errored || t->python_exited) return;
    if (t->skip_next_hook) {
        t->skip_next_hook = 0;
        return;
    }

    if (pyda_get_run_until(t) == pc) {
        thread_prepare_for_python_entry(NULL, t, pc);

        // Clear the run_until flag and flush the block
        pyda_clear_run_until(t);

        // Wait for Python to yield back to us
        pyda_break(t);
        thread_prepare_for_python_return(t, pc); // MAY NOT RETURN
    } else {
        // This can actually happen in two cases:
        // 1. The code cache entry was not flushed (BUG in Pyda!) after a run_until
        // 2. Another thread set this run_until hook (This is fine.)
        DEBUG_PRINTF("STALE run_until reached: %llx\n", pc);
    }
}

int pyda_push_context(pyda_thread *t) {
    if (t->context_stack.entries >= CONTEXT_STACK_LIMIT) return 0; // arbitrary limit

    dr_mcontext_t *new = dr_global_alloc(sizeof(dr_mcontext_t));
    memcpy(new, &t->cur_context, sizeof(dr_mcontext_t));
    drvector_append(&t->context_stack, new);
    return 1;
}

int pyda_pop_context(pyda_thread *t) {
    drvector_lock(&t->context_stack);
    if (t->context_stack.entries == 0) return 0;
    t->context_stack.entries--;
    memcpy(&t->cur_context, t->context_stack.array[t->context_stack.entries], sizeof(dr_mcontext_t));
    free_context(t->context_stack.array[t->context_stack.entries]);
    drvector_unlock(&t->context_stack);
    return 1;
}

extern PyTypeObject PydaExprBuilder_Type;

void pyda_handle_advanced_hook(instrlist_t *bb, instr_t *instr, pyda_hook *callback) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    
    // Initialize expression builder
    t->expr_builder = exprbuilder_init();

    // Create Python wrapper for builder
    PyGILState_STATE gstate = PyGILState_Ensure();
    
    PydaExprBuilder *py_builder = PyObject_New(PydaExprBuilder, &PydaExprBuilder_Type);
    if (!py_builder) {
        PyErr_Print();
        goto cleanup;
    }
    py_builder->builder = t->expr_builder;

    // Call the Python callback
    PyObject *result = PyObject_CallFunctionObjArgs(callback->py_func, py_builder, NULL);
    if (result) {
        Py_DECREF(result);
    } else {
        dr_fprintf(STDERR, "Error in advanced hook at %p\n", callback->addr);
        PyErr_Print();
    }

    Py_DECREF(py_builder);

    exprbuilder_compile(t->expr_builder, bb, instr, 0);
    DEBUG_PRINTF("Compiled advanced hook at %p\n", callback->addr);

cleanup:
    // Cleanup
    exprbuilder_delete(t->expr_builder);
    t->expr_builder = NULL;
    
    PyGILState_Release(gstate);
}

#endif

```

`pyda_core/pyda_core_py.c`:

```c
#include "pyda_core_py.h"
#include "pyda_core.h"
#include "pyda_threads.h"
#include "pyda_util.h"

#ifdef PYDA_DYNAMORIO_CLIENT
#include "dr_api.h"
#endif

int is_dynamorio_running = 0;

typedef struct {
    PyObject_HEAD
    pyda_thread *main_thread; // main thread
} PydaProcess;

static PyObject* pyda_core_process(PyObject *self, PyObject *args, PyObject *kwargs);
static PyObject* pyda_core_free(PyObject *self, PyObject *args, PyObject *kwargs);
static PyObject *pyda_list_modules(PyObject *self, PyObject *noarg);
static PyObject *pyda_get_base(PyObject *self, PyObject *args);
static PyObject *pyda_get_module_for_addr(PyObject *self, PyObject *args);
static PyObject *pyda_get_current_thread_id(PyObject *self, PyObject *noarg);
static PyObject *pyda_core_expr(PyObject *self, PyObject *args, PyObject *kwargs);
static PyObject *pyda_core_expr_raw(PyObject *self, PyObject *args, PyObject *kwargs);
static PyObject *pyda_core_free_expr(PyObject *self, PyObject *args, PyObject *kwargs);

static void PydaProcess_dealloc(PydaProcess *self);
static PyObject *PydaProcess_run(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_run_until_io(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_run_until_pc(PyObject *self, PyObject *arg);
static PyObject *PydaProcess_exited(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_capture_io(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_register_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_unregister_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_thread_init_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_get_register(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_register(PyObject *self, PyObject *args);
static PyObject *PydaProcess_read(PyObject *self, PyObject *args);
static PyObject *PydaProcess_write(PyObject *self, PyObject *args);
static PyObject *PydaProcess_get_main_module(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_syscall_filter(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_syscall_pre_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_syscall_post_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_module_load_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_push_state(PyObject *self, PyObject *args);
static PyObject *PydaProcess_pop_state(PyObject *self, PyObject *args);
static PyObject *PydaProcess_backtrace(PyObject *self, PyObject *noarg);

static void PydaExprBuilder_dealloc(PydaExprBuilder *self);
static PyObject *PydaExprBuilder_get_register(PyObject *self, PyObject *args);
static PyObject *PydaExprBuilder_set_register(PyObject *self, PyObject *args);


static PyMethodDef PydaGlobalMethods[] = {
    {"process",  (PyCFunction)pyda_core_process, METH_KEYWORDS | METH_VARARGS,
     "Start a process."},
    {"list_modules",  (PyCFunction)pyda_list_modules, METH_NOARGS,
     "List all the modules."},
    {"get_base",  (PyCFunction)pyda_get_base, METH_VARARGS,
     "Get base address for module"},
    {"get_module_for_addr",  (PyCFunction)pyda_get_module_for_addr, METH_VARARGS,
     "Get module info for addr"},
    {"get_current_thread_id",  (PyCFunction)pyda_get_current_thread_id, METH_NOARGS,
     "Get current thread id, numbered from 1"},
    {"free",  (PyCFunction)pyda_core_free, METH_KEYWORDS | METH_VARARGS,
     "Call into the allocator used by the rest of the tool."},
    {"expr",  (PyCFunction)pyda_core_expr, METH_KEYWORDS | METH_VARARGS,
     "Create a new expression. May be abstract (e.g. representing a register value) or concrete (e.g. representing an integer constant)."},
    {"expr_raw",  (PyCFunction)pyda_core_expr_raw, METH_KEYWORDS | METH_VARARGS,
     "Create a new raw (assembly) expression."},
    {"free_expr",  (PyCFunction)pyda_core_free_expr, METH_KEYWORDS | METH_VARARGS,
     "Free an expression and its children if refcount reaches 0."},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef pyda_module = {
    PyModuleDef_HEAD_INIT,
    "pyda_core",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    PydaGlobalMethods
};

static PyObject *MemoryError;
static PyObject *ThreadExitError;
static PyObject *InvalidStateError;
static PyObject *FatalSignalError;

static PyMethodDef PydaExprBuilder_methods[] = {
    {"get_register", (PyCFunction)PydaExprBuilder_get_register, METH_VARARGS,
     "Get a register value"},
    {"set_register", (PyCFunction)PydaExprBuilder_set_register, METH_VARARGS,
     "Set a register to an expression"},
    {NULL}  /* Sentinel */
};

PyTypeObject PydaExprBuilder_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "pyda_core.ExprBuilder",
    .tp_doc = "Expression Builder object",
    .tp_basicsize = sizeof(PydaExprBuilder),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = PyType_GenericNew,
    .tp_dealloc = (destructor)PydaExprBuilder_dealloc,
    .tp_methods = PydaExprBuilder_methods,
};

static PyMethodDef PydaProcessMethods[] = {
    {"run",  PydaProcess_run, METH_NOARGS, "Run"},
    {"run_until_pc",  PydaProcess_run_until_pc, METH_VARARGS, "Run until PC is reached"},
    {"run_until_io",  PydaProcess_run_until_io, METH_NOARGS, "Run until IO syscall"},
    {"capture_io", PydaProcess_capture_io, METH_NOARGS, "Capture IO -- returns IO fds"},
    {"register_hook",  PydaProcess_register_hook, METH_VARARGS, "Register a hook"},
    {"unregister_hook",  PydaProcess_unregister_hook, METH_VARARGS, "Un-register a hook"},
    {"set_thread_init_hook",  PydaProcess_set_thread_init_hook, METH_VARARGS, "Register thread init hook"},
    {"get_register",  PydaProcess_get_register, METH_VARARGS, "Get a specific register"},
    {"set_register",  PydaProcess_set_register, METH_VARARGS, "Set a specific register"},
    {"get_main_module",  PydaProcess_get_main_module, METH_VARARGS, "Get name of main module"},
    {"read",  PydaProcess_read, METH_VARARGS, "Read memory"},
    {"write",  PydaProcess_write, METH_VARARGS, "Write memory"},
    {"exited",  PydaProcess_exited, METH_NOARGS, "Check if thread has exited"},
    // {"set_syscall_filter",  PydaProcess_set_syscall_filter, METH_VARARGS, "Set list of syscalls to call hooks on"},
    {"set_syscall_pre_hook",  PydaProcess_set_syscall_pre_hook, METH_VARARGS, "Register syscall pre hook"},
    {"set_syscall_post_hook",  PydaProcess_set_syscall_post_hook, METH_VARARGS, "Register syscall post hook"},
    {"set_module_load_hook",  PydaProcess_set_module_load_hook, METH_VARARGS, "Register module load hook"},
    {"push_state",  PydaProcess_push_state, METH_VARARGS, "Push register state (thread-local)"},
    {"pop_state",  PydaProcess_pop_state, METH_VARARGS, "Pop register state (thread-local)"},
    {"backtrace", PydaProcess_backtrace, METH_NOARGS, "Returns backtrace (array of tuples)"},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static PyTypeObject PydaProcess_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(PydaProcess),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = PyType_GenericNew,
    .tp_dealloc = (destructor)PydaProcess_dealloc,
    .tp_methods = PydaProcessMethods,
};

static void register_exception(PyObject *mod, PyObject **target, const char *fullname, const char *name) {
    *target = PyErr_NewException(fullname, NULL, NULL);
    Py_XINCREF(*target);
    if (PyModule_AddObject(mod, name, *target) < 0) {
        Py_XDECREF(*target);
        Py_CLEAR(*target);
    }
}

PyMODINIT_FUNC
PyInit_pyda_core(void) {
    PyObject *m = PyModule_Create(&pyda_module);

    register_exception(m, &MemoryError, "pyda.MemoryError", "MemoryError");
    register_exception(m, &ThreadExitError, "pyda.ThreadExitError", "ThreadExitError");
    register_exception(m, &InvalidStateError, "pyda.InvalidStateError", "InvalidStateError");
    register_exception(m, &FatalSignalError, "pyda.FatalSignalError", "FatalSignalError");

#if defined(X86)
    PyModule_AddIntConstant(m, "REG_RAX", DR_REG_RAX);
    PyModule_AddIntConstant(m, "REG_RBX", DR_REG_RBX);
    PyModule_AddIntConstant(m, "REG_RCX", DR_REG_RCX);
    PyModule_AddIntConstant(m, "REG_RDX", DR_REG_RDX);
    PyModule_AddIntConstant(m, "REG_RSI", DR_REG_RSI);
    PyModule_AddIntConstant(m, "REG_RDI", DR_REG_RDI);
    PyModule_AddIntConstant(m, "REG_RBP", DR_REG_RBP);
    PyModule_AddIntConstant(m, "REG_RSP", DR_REG_RSP);
    PyModule_AddIntConstant(m, "REG_R8", DR_REG_R8);
    PyModule_AddIntConstant(m, "REG_R9", DR_REG_R9);
    PyModule_AddIntConstant(m, "REG_R10", DR_REG_R10);
    PyModule_AddIntConstant(m, "REG_R11", DR_REG_R11);
    PyModule_AddIntConstant(m, "REG_R12", DR_REG_R12);
    PyModule_AddIntConstant(m, "REG_R13", DR_REG_R13);
    PyModule_AddIntConstant(m, "REG_R14", DR_REG_R14);
    PyModule_AddIntConstant(m, "REG_R15", DR_REG_R15);
    PyModule_AddIntConstant(m, "REG_RIP", PYDA_REG_PC);
    PyModule_AddIntConstant(m, "REG_PC", PYDA_REG_PC); // alias
    PyModule_AddIntConstant(m, "REG_SP", DR_REG_RSP); // alias
    PyModule_AddIntConstant(m, "REG_FSBASE", PYDA_REG_FSBASE);
    PyModule_AddIntConstant(m, "REG_XMM0", DR_REG_XMM0);
    PyModule_AddIntConstant(m, "REG_XMM1", DR_REG_XMM1);
    PyModule_AddIntConstant(m, "REG_XMM2", DR_REG_XMM2);
    PyModule_AddIntConstant(m, "REG_XMM3", DR_REG_XMM3);
    PyModule_AddIntConstant(m, "REG_XMM4", DR_REG_XMM4);
    PyModule_AddIntConstant(m, "REG_XMM5", DR_REG_XMM5);
    PyModule_AddIntConstant(m, "REG_XMM6", DR_REG_XMM6);
    PyModule_AddIntConstant(m, "REG_XMM7", DR_REG_XMM7);
    PyModule_AddIntConstant(m, "REG_ARG1", DR_REG_RDI);
    PyModule_AddIntConstant(m, "REG_ARG2", DR_REG_RSI);
    PyModule_AddIntConstant(m, "REG_ARG3", DR_REG_RDX);
    PyModule_AddIntConstant(m, "REG_ARG4", DR_REG_RCX);
    PyModule_AddIntConstant(m, "REG_ARG5", DR_REG_R8);
    PyModule_AddIntConstant(m, "REG_ARG6", DR_REG_R9);
#elif defined(AARCH64)
    PyModule_AddIntConstant(m, "REG_X0", DR_REG_X0);
    PyModule_AddIntConstant(m, "REG_X1", DR_REG_X1);
    PyModule_AddIntConstant(m, "REG_X2", DR_REG_X2);
    PyModule_AddIntConstant(m, "REG_X3", DR_REG_X3);
    PyModule_AddIntConstant(m, "REG_X4", DR_REG_X4);
    PyModule_AddIntConstant(m, "REG_X5", DR_REG_X5);
    PyModule_AddIntConstant(m, "REG_X6", DR_REG_X6);
    PyModule_AddIntConstant(m, "REG_X7", DR_REG_X7);
    PyModule_AddIntConstant(m, "REG_X8", DR_REG_X8);
    PyModule_AddIntConstant(m, "REG_X9", DR_REG_X9);
    PyModule_AddIntConstant(m, "REG_X10", DR_REG_X10);
    PyModule_AddIntConstant(m, "REG_X11", DR_REG_X11);
    PyModule_AddIntConstant(m, "REG_X12", DR_REG_X12);
    PyModule_AddIntConstant(m, "REG_X13", DR_REG_X13);
    PyModule_AddIntConstant(m, "REG_X14", DR_REG_X14);
    PyModule_AddIntConstant(m, "REG_X15", DR_REG_X15);
    PyModule_AddIntConstant(m, "REG_X16", DR_REG_X16);
    PyModule_AddIntConstant(m, "REG_X17", DR_REG_X17);
    PyModule_AddIntConstant(m, "REG_X18", DR_REG_X18);
    PyModule_AddIntConstant(m, "REG_X19", DR_REG_X19);
    PyModule_AddIntConstant(m, "REG_X20", DR_REG_X20);
    PyModule_AddIntConstant(m, "REG_X21", DR_REG_X21);
    PyModule_AddIntConstant(m, "REG_X22", DR_REG_X22);
    PyModule_AddIntConstant(m, "REG_X23", DR_REG_X23);
    PyModule_AddIntConstant(m, "REG_X24", DR_REG_X24);
    PyModule_AddIntConstant(m, "REG_X25", DR_REG_X25);
    PyModule_AddIntConstant(m, "REG_X26", DR_REG_X26);
    PyModule_AddIntConstant(m, "REG_X27", DR_REG_X27);
    PyModule_AddIntConstant(m, "REG_X28", DR_REG_X28);
    PyModule_AddIntConstant(m, "REG_X29", DR_REG_X29);
    PyModule_AddIntConstant(m, "REG_X30", DR_REG_X30);
    PyModule_AddIntConstant(m, "REG_SP", DR_REG_SP); // alias
    PyModule_AddIntConstant(m, "REG_PC", PYDA_REG_PC);
    PyModule_AddIntConstant(m, "REG_ARG1", DR_REG_R0);
    PyModule_AddIntConstant(m, "REG_ARG2", DR_REG_R1);
    PyModule_AddIntConstant(m, "REG_ARG3", DR_REG_R2);
    PyModule_AddIntConstant(m, "REG_ARG4", DR_REG_R3);
    PyModule_AddIntConstant(m, "REG_ARG5", DR_REG_R4);
    PyModule_AddIntConstant(m, "REG_ARG6", DR_REG_R5);
#endif

    // Add expression type constants
    PyModule_AddIntConstant(m, "EXPR_TYPE_CONST", EXPR_TYPE_CONST);
    PyModule_AddIntConstant(m, "EXPR_TYPE_ADD", EXPR_TYPE_ADD);
    PyModule_AddIntConstant(m, "EXPR_TYPE_SUB", EXPR_TYPE_SUB);
    PyModule_AddIntConstant(m, "EXPR_TYPE_MUL", EXPR_TYPE_MUL);
    PyModule_AddIntConstant(m, "EXPR_TYPE_DIV", EXPR_TYPE_DIV);
    PyModule_AddIntConstant(m, "EXPR_TYPE_LOAD", EXPR_TYPE_LOAD);
    PyModule_AddIntConstant(m, "EXPR_TYPE_STORE", EXPR_TYPE_STORE);

    // Initialize ExprBuilder type
    if (PyType_Ready(&PydaExprBuilder_Type) < 0)
        return NULL;

    if (PyType_Ready(&PydaProcess_Type) < 0)
        return NULL;

    return m;
}

static PyObject *
pyda_core_process(PyObject *self, PyObject *args, PyObject *kwargs) {
    ABORT_IF_NODYNAMORIO;

    const char *name;
    PydaProcess *result = NULL;

    Py_buffer bin_path;

    static char *kwlist[] = {"name", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s*", kwlist, &bin_path))
        return NULL;

    *(char*)(bin_path.buf + bin_path.len) = '\0';

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t != t->proc->main_thread) {
        PyErr_SetString(PyExc_RuntimeError, "Only the main thread is currently allowed to call process().");
        return NULL;
    }

    if (t->proc->py_obj) {
        PyErr_SetString(PyExc_RuntimeError, "You may only call process() once");
        return NULL;
    }

    result = PyObject_NEW(PydaProcess, &PydaProcess_Type);
    if (result != NULL)
        result->main_thread = t;

    t->proc->py_obj = (PyObject*)result;

    PyBuffer_Release(&bin_path);
    return (PyObject*)result;
}

/* This is a hack (note this calls the private allocator, separate from the one used by the app running under Dyanmorio) */
static PyObject *
pyda_core_free(PyObject *self, PyObject *args, PyObject *kwargs) {
    unsigned long addr;
    if (!PyArg_ParseTuple(args, "K", &addr))
        return NULL;

    free((void*)addr);

    Py_INCREF(Py_None);
    return Py_None;
}
static int check_valid_thread(pyda_thread *t) {
    if (!t) {
        PyErr_SetString(PyExc_RuntimeError, "Threads created with Python threading APIs cannot use Pyda APIs");
        return 1;
    }
    return 0;
}

static int check_python_thread(pyda_thread *t) {
    if (pyda_thread_getspecific(g_pyda_tls_is_python_thread_idx) != (void*)1) {
        PyErr_SetString(InvalidStateError, ".run()/.run_until() cannot be called from hooks.");
        return 1;
    }
    return 0;
}

static int check_exited(pyda_thread *t) {
    if (check_valid_thread(t)) return 1;
    if (t->app_exited) {
        PyErr_SetString(InvalidStateError, "Thread has already exited; cannot be resumed");
        return 1;
    }
    return 0;
}
static int check_signal(pyda_thread *t) {
    if (t->signal) {
        PyObject *tuple = PyTuple_New(3);
        PyTuple_SetItem(tuple, 0, PyLong_FromLong(t->signal));
        PyTuple_SetItem(tuple, 1, PyLong_FromLong(t->tid));
        PyTuple_SetItem(tuple, 2, PydaProcess_backtrace(NULL, NULL));
        PyErr_SetObject(FatalSignalError, tuple);
        return 1;
    }
    return 0;
}


static PyObject *
PydaProcess_run(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_python_thread(t)) return NULL;
    if (check_exited(t)) return NULL;

    Py_BEGIN_ALLOW_THREADS
    pyda_yield(t);
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("yield returned\n");
#endif // PYDA_DYNAMORIO_CLIENT
    Py_END_ALLOW_THREADS

    if (check_signal(t)) return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_run_until_io(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_python_thread(t)) return NULL;
    if (check_exited(t)) return NULL;

    t->python_blocked_on_io = 1;


    // todo: assert that this thread is like, actually blocked

    Py_BEGIN_ALLOW_THREADS
    pyda_yield(t);
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("yield after io returned\n");
#endif // PYDA_DYNAMORIO_CLIENT
    Py_END_ALLOW_THREADS

    if (t->app_exited) {
        PyErr_SetString(ThreadExitError, "Thread exited while Pyda was waiting on I/O.");
        return NULL;
    }

    if (check_signal(t)) return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_capture_io(PyObject* self, PyObject *noarg) {
    PydaProcess *p = (PydaProcess*)self;
    pyda_process *proc = p->main_thread->proc;

    if (!getenv("PYDA_NO_CAPTURE") || getenv("PYDA_NO_CAPTURE")[0] != '1') {
        int no_pty = (getenv("PYDA_NO_PTY") && getenv("PYDA_NO_PTY")[0] == '1');
        int no_raw = (getenv("PYDA_NO_RAW") && getenv("PYDA_NO_RAW")[0] == '1');
        pyda_capture_io(proc, !no_pty, !no_raw);
    }

    if (proc->stdin_fd == -1) {
        PyErr_SetString(PyExc_RuntimeError, "IO was not captured");
        return NULL;
    }

    PyObject *list = PyList_New(0);
    PyList_Append(list, PyLong_FromLong(proc->stdin_fd));
    PyList_Append(list, PyLong_FromLong(proc->stdout_fd));
    PyList_Append(list, PyLong_FromLong(proc->stderr_fd));

    return list;
}

static PyObject *
PydaProcess_backtrace(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    drvector_t backtrace;

    int ret = pyda_get_backtrace(t, &backtrace);

    PyObject *list = PyList_New(0);
    for (int i=0; i<backtrace.entries; i++) {
        struct pyda_bt_entry *e = backtrace.array[i];

        PyObject *tuple = PyTuple_New(4);
        PyTuple_SetItem(tuple, 0, PyLong_FromLong(e->ip));
        PyTuple_SetItem(tuple, 1, PyUnicode_FromString(e->modname));
        PyTuple_SetItem(tuple, 2, PyLong_FromLong(e->offset));
        PyTuple_SetItem(tuple, 3, PyUnicode_FromString(e->sym_name));
        PyList_Append(list, tuple);
    }

    drvector_delete(&backtrace);

    if (ret) {
        Py_DECREF(list);
        PyErr_SetString(PyExc_RuntimeError, "Could not generate backtrace");
        return NULL;
    }

    return list;
}

static PyObject *
PydaProcess_run_until_pc(PyObject* self, PyObject *args) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_python_thread(t)) return NULL;
    if (check_exited(t)) return NULL;

    unsigned long addr;
    if (!PyArg_ParseTuple(args, "K", &addr))
        return NULL;

    pyda_set_run_until(t, (void*)addr);

    Py_BEGIN_ALLOW_THREADS
    pyda_yield(t);
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("yield returned\n");
#endif // PYDA_DYNAMORIO_CLIENT
    Py_END_ALLOW_THREADS

    if (t->app_exited) {
        PyErr_SetString(ThreadExitError, "Thread exited before reaching run_until target.");
        return NULL;
    }

    if (check_signal(t)) return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_exited(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;
    if (t->app_exited) {
        Py_INCREF(Py_True);
        return Py_True;
    }
    Py_INCREF(Py_False);
    return Py_False;
}

static PyObject *
pyda_list_modules(PyObject* self, PyObject *noarg) {
#ifdef PYDA_DYNAMORIO_CLIENT
    PyObject *list = PyList_New(0);
    dr_module_iterator_t *iter = dr_module_iterator_start();
    while (dr_module_iterator_hasnext(iter)) {
        module_data_t *mod = dr_module_iterator_next(iter);
        PyList_Append(list, PyUnicode_FromString(mod->full_path));
    }
    dr_module_iterator_stop(iter);
    return list;
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
pyda_get_current_thread_id(PyObject* self, PyObject *noarg) {
#ifdef PYDA_DYNAMORIO_CLIENT
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;
    int tid = t->tid;
    return PyLong_FromLong(tid);
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static void
PydaProcess_dealloc(PydaProcess *self)
{
    Py_TYPE(self)->tp_free((PyObject *) self);
}

static PyObject *
PydaProcess_get_register(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    unsigned long long reg_id;

    if (!PyArg_ParseTuple(args, "K", &reg_id))
        return NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    // DEBUG_PRINTF("get_register: %s\n", regname);
    dr_mcontext_t *mc = &t->cur_context;

    // TODO: Fix... copilot wrote this. Surely we can write
    // a macro...

    if (reg_id == PYDA_REG_PC) {
        return PyLong_FromUnsignedLong((unsigned long)mc->pc);
    } else if (reg_id == PYDA_REG_FSBASE) {
        return PyLong_FromUnsignedLong((unsigned long)dr_get_tls_field(dr_get_current_drcontext()));
    }

    opnd_size_t sz = reg_get_size(reg_id);
    if (!(sz == OPSZ_4 || sz == OPSZ_8 || sz == OPSZ_16 || sz == OPSZ_32)) {
        PyErr_SetString(PyExc_RuntimeError, "Unsupported register size");
        return NULL;
    }

    uint64_t val[4] = {0};
    reg_get_value_ex(reg_id, mc, (uint8_t*)&val);

    if (sz == OPSZ_8) {
        // fast path
        return PyLong_FromUnsignedLong(val[0]);
    }

    // Convert to decimal string
    char buf[64];
    if (snprintf(buf, sizeof(buf), "0x%" PRIx64 "%" PRIx64, val[1], val[0]) >= sizeof(buf)) {
        PyErr_SetString(PyExc_RuntimeError, "Internal error: reg buffer too small");
        return NULL;
    }

    PyObject *ret = PyLong_FromString(buf, NULL, 16);
    if (!ret) {
        PyErr_SetString(PyExc_RuntimeError, "Internal error: failed to convert string to long");
        return NULL;
    }

    return ret;

#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_set_register(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    unsigned long long reg_id;
    PyObject *val;

    if (!PyArg_ParseTuple(args, "KO", &reg_id, &val))
        return NULL;

    if (!PyLong_Check(val)) {
        PyErr_SetString(PyExc_RuntimeError, "Value must be an integer");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    // DEBUG_PRINTF("get_register: %s\n", regname);
    dr_mcontext_t *mc = &t->cur_context;

    uint64_t raw[4] = {0};
    _PyLong_AsByteArray((PyLongObject *)val, (unsigned char*)&raw, sizeof(raw), 1, 0);

    DEBUG_PRINTF("set_register: %llx %llx\n", reg_id, raw[0]);

    if (reg_id == PYDA_REG_PC) {
        mc->pc = (void*)raw[0];
        t->rip_updated_in_python = 1;
    } else {
        if (!reg_set_value_ex(reg_id, mc, (uint8_t*)&raw)) {
            PyErr_SetString(PyExc_RuntimeError, "Failed to set register");
            return NULL;
        }
    }


#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_register_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    unsigned long long addr;
    PyObject *callback;
    unsigned long long callback_type;
    bool later;

    if (!PyArg_ParseTuple(args, "KO!Kb", &addr, &PyFunction_Type, &callback, &callback_type, &later))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 1) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take one argument");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("register_hook: %llx\n", addr);

    int readable = dr_memory_is_readable((app_pc)addr, 1);
    if (!later && !readable) {
        char buf[100];
        snprintf(buf, sizeof(buf), "Hooked PC %" PRIxPTR " is invalid; try later=True if this will be mapped later.", (uintptr_t)addr);
        PyErr_SetString(PyExc_RuntimeError, buf);
        return NULL;
    }

    // 0 is a regular hook, 1 is a advanced "builder" hook
    if (callback_type != 0 && callback_type != 1) {
        PyErr_SetString(PyExc_RuntimeError, "Invalid callback type");
        return NULL;
    }

    pyda_add_hook(p->main_thread->proc, addr, callback, callback_type, readable);

#endif // PYDA_DYNAMORIO_CLIENT
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_set_thread_init_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 1) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take one argument");
        return NULL;
    }
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_thread_init_hook\n");
#endif

    // note: pyda_set_thread_init_hook calls incref
    pyda_set_thread_init_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
PydaProcess_set_syscall_pre_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 2) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take two arguments");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_syscall_pre_hook\n");
#endif

    // note: pyda_set_syscall_pre_hook calls incref
    pyda_set_syscall_pre_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
PydaProcess_set_syscall_post_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 2) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take two arguments");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_syscall_post_hook\n");
#endif

    // note: pyda_set_syscall_pre_hook calls incref
    pyda_set_syscall_post_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_set_module_load_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 2) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take two arguments (process, module_path)");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_module_load_hook\n");
#endif

    // note: pyda_set_module_load_hook calls incref
    pyda_set_module_load_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_unregister_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    unsigned long long addr;

    if (!PyArg_ParseTuple(args, "K", &addr)) {
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("unregister_hook: %llx\n", addr);
#endif // PYDA_DYNAMORIO_CLIENT
    pyda_remove_hook(p->main_thread->proc, addr);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_get_main_module(PyObject *self, PyObject *args) {
    const char *name;

    if (!PyArg_ParseTuple(args, ""))
        return NULL;

    PyObject *result = NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    module_data_t *mod = dr_get_main_module();

    if (!mod) {
        PyErr_SetString(PyExc_RuntimeError, "Module not found");
        return NULL;
    }

    // Return a string with the name of the main module
    result = PyUnicode_FromString(mod->full_path);
#else
    PyErr_SetString(PyExc_RuntimeError, "Not implemented outside of dynamorio");
    return NULL;
#endif

    return (PyObject*)result;
}


static PyObject *
pyda_get_base(PyObject *self, PyObject *args) {
    const char *name;

    Py_buffer bin_path;

    if (!PyArg_ParseTuple(args, "s*", &bin_path))
        return NULL;

    *(char*)(bin_path.buf + bin_path.len) = '\0';

    PyObject *result = NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    dr_module_iterator_t *iter = dr_module_iterator_start();
    while (dr_module_iterator_hasnext(iter)) {
        module_data_t *mod = dr_module_iterator_next(iter);
        if (strstr(mod->full_path, bin_path.buf)) {
            // Return the base address as python number
            result = PyLong_FromUnsignedLong((unsigned long)mod->start);
            break;
        }
    }

    if (!result) {
        PyErr_SetString(PyExc_RuntimeError, "Module not found");
        return NULL;
    }
#else
    PyErr_SetString(PyExc_RuntimeError, "Not implemented outside of dynamorio");
    return NULL;
#endif
    PyBuffer_Release(&bin_path);

    return (PyObject*)result;
}

static PyObject *
pyda_get_module_for_addr(PyObject *self, PyObject *args) {
    unsigned long addr;
    if (!PyArg_ParseTuple(args, "K", &addr))
        return NULL;

    PyObject *result = NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    unsigned char *base;
    size_t size;
    unsigned int prot;
    unsigned long perms = 0;
    if (dr_query_memory((void*)addr, &base, &size, &prot)) {
        if (prot & DR_MEMPROT_READ) {
            perms |= 4;
        }
        if (prot & DR_MEMPROT_WRITE) {
            perms |= 2;
        }
        if (prot & DR_MEMPROT_EXEC) {
            perms |= 1;
        }
    }

    result = PyList_New(0);
    module_data_t *mod = dr_lookup_module((void*)addr);
    if (mod) {
        PyList_Append(result, PyUnicode_FromString(mod->full_path));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)mod->start));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)mod->end));
        PyList_Append(result, PyLong_FromUnsignedLong(perms));

        dr_free_module_data(mod);
        return result;
    } else {
        PyList_Append(result, PyUnicode_FromString("unknown"));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)base));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)base + size));
        PyList_Append(result, PyLong_FromUnsignedLong(perms));
        return result;
    }

#else
    PyErr_SetString(PyExc_RuntimeError, "Not implemented outside of dynamorio");
    return NULL;
#endif

    Py_INCREF(Py_None);
    return Py_None;
}


static PyObject *
PydaProcess_read(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;


    unsigned long addr;
    unsigned long count;
    if (!PyArg_ParseTuple(args, "KK", &addr, &count))
        return NULL;

    if (count > 0x1000000) {
        PyErr_SetString(PyExc_RuntimeError, "Unreasonable read size");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    // DEBUG_PRINTF("read: %lx %lx\n", addr, count);
    void *buf = malloc(count);
    int success = dr_safe_read((void*)addr, count, buf, NULL);
    if (!success) {
        PyErr_SetString(MemoryError, "Failed to read memory");
        free(buf);
        return NULL;
    }
    PyObject *result = PyBytes_FromStringAndSize(buf, count);
    free(buf);
    return result;
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}


static PyObject *
PydaProcess_write(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;


    unsigned long addr;
    const char *data;
    Py_ssize_t len;
    if (!PyArg_ParseTuple(args, "Ks#", &addr, &data, &len))
        return NULL;

    if (len > 0x1000000) {
        PyErr_SetString(PyExc_RuntimeError, "Unreasonable write size");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("write: %lx %lx\n", addr, len);
    int success = dr_safe_write((void*)addr, len, data, NULL);
    if (!success) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to write memory");
        return NULL;
    }
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_push_state(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    // NOTE: Before we entered python, we saved the state (see: calls to dr_get_mcontext)
    if (!pyda_push_context(t)) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to push state");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_pop_state(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    if (!pyda_pop_context(t)) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to pop state");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
pyda_core_expr(PyObject *self, PyObject *args, PyObject *kwargs) {
    unsigned long expr_type, op1, op2;
    if (!PyArg_ParseTuple(args, "KKK", &expr_type, &op1, &op2))
        return NULL;

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;

    if (t->expr_builder == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "Expression builder not initialized");
        return NULL;
    }

    unsigned long handle = expr_new(t->expr_builder, expr_type, op1, op2);
    if (handle == (unsigned long)-1) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to create expression");
        return NULL;
    }

    return PyLong_FromUnsignedLong(handle);
}


static PyObject *
pyda_core_expr_raw(PyObject *self, PyObject *args, PyObject *kwargs) {
    const char *data;
    Py_ssize_t len;
    if (!PyArg_ParseTuple(args, "s#", &data, &len))
        return NULL;

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;

    if (t->expr_builder == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "Expression builder not initialized");
        return NULL;
    }

    unsigned long handle = expr_new_raw(t->expr_builder, data, len);
    if (handle == (unsigned long)-1) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to create raw expression");
        return NULL;
    }

    return PyLong_FromUnsignedLong(handle);
}

static PyObject *
pyda_core_free_expr(PyObject *self, PyObject *args, PyObject *kwargs) {
    unsigned long handle;
    if (!PyArg_ParseTuple(args, "K", &handle))
        return NULL;

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;

    if (t->expr_builder == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "Expression builder not initialized");
        return NULL;
    }

    expr_free(t->expr_builder, handle);

    Py_INCREF(Py_None);
    return Py_None;
}

static void
PydaExprBuilder_dealloc(PydaExprBuilder *self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PydaExprBuilder_get_register(PyObject *self, PyObject *args) {
    PydaExprBuilder *builder = (PydaExprBuilder*)self;
    unsigned long reg_id;
    if (!PyArg_ParseTuple(args, "K", &reg_id))
        return NULL;

    unsigned long handle;
    if (!exprbuilder_reg_get(builder->builder, reg_id, &handle)) {
        handle = expr_new(builder->builder, EXPR_TYPE_REG, reg_id, 0);
        if (handle == (unsigned long)-1 || !exprbuilder_reg_set(builder->builder, reg_id, handle)) {
            PyErr_SetString(PyExc_RuntimeError, "Failed to get register value");
            return NULL;
        }
    } else {
        exprbuilder_incref(builder->builder, handle);
    }

    return PyLong_FromUnsignedLong(handle);
}

static PyObject *
PydaExprBuilder_set_register(PyObject *self, PyObject *args) {
    PydaExprBuilder *builder = (PydaExprBuilder*)self;
    unsigned long reg_id;
    unsigned long handle;
    if (!PyArg_ParseTuple(args, "KK", &reg_id, &handle))
        return NULL;

    if (!exprbuilder_reg_set(builder->builder, reg_id, handle)) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to set register value");
        return NULL;
    }

    Py_RETURN_NONE;
}

```

`pyda_core/pyda_patch_python.c`:

```c

#include "pyda_core.h"
#include "pyda_threads.h"
#ifdef PYDA_DYNAMORIO_CLIENT

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "privload.h"

static redirect_import_t python_redirect_imports[] = {
    { "pthread_key_create", (app_pc)pyda_thread_key_create },
    { "pthread_key_delete", (app_pc)pyda_thread_key_delete },
    { "pthread_getspecific", (app_pc)pyda_thread_getspecific },
    { "pthread_setspecific", (app_pc)pyda_thread_setspecific },
#ifndef MACOS
    { "pthread_cond_init", (app_pc)pyda_cond_init },
    { "pthread_cond_timedwait", (app_pc)pyda_cond_timedwait },
    { "pthread_cond_signal", (app_pc)pyda_cond_signal },
    { "pthread_mutex_init", (app_pc)pyda_mutex_init },
#endif
    { "pthread_self", (app_pc)pyda_thread_self },
    { "pthread_create", (app_pc)pyda_thread_create },
    { "pthread_detach", (app_pc)pyda_thread_detach },
    { "dlopen", (app_pc)pyda_dlopen },
    { "dlsym", (app_pc)pyda_dlsym },
#ifdef LINUX
    { "getauxval", (app_pc)pyda_getauxval },
    /* { "sigaltstack", (app_pc)pyda_sigaltstack }, */
    { "sysconf", (app_pc)pyda_sysconf },
#endif
    { "getenv", (app_pc)pyda_getenv },
    { "sem_init", (app_pc)pyda_sem_init }
};

#ifdef MACOS
extern void patch_macho(char *path, void *lib_base, redirect_import_t *redirects, int num_redirects);

// in dynamorio
extern void instrument_client_lib_loaded(void *start, void *end);
#endif

#define NUM_NEW_IMPORTS (sizeof(python_redirect_imports) / sizeof(redirect_import_t))
void patch_python() {
#ifdef LINUX
    client_redirect_imports = python_redirect_imports;
    client_redirect_imports_count = NUM_NEW_IMPORTS;
    privmod_t *mod = privload_lookup_by_pc_takelock((app_pc)&PyRun_SimpleString);
    privload_relocate_mod_takelock(mod);
#elif defined(MACOS)
    /* No private loader, so we just find the module and patch... */

    dr_module_iterator_t *iter = dr_module_iterator_start();
    while (dr_module_iterator_hasnext(iter)) {
        module_data_t *mod = dr_module_iterator_next(iter);
        if (strstr(mod->full_path, "libpython") != NULL) {
            void *lib_base = (void*)mod->start;
            patch_macho(mod->full_path, lib_base, python_redirect_imports, NUM_NEW_IMPORTS);
            instrument_client_lib_loaded(mod->start, mod->end);
            break;
        }
    }
    dr_module_iterator_stop(iter);

#endif
}
#endif

```

`pyda_core/pyda_threads.c`:

```c
// We use this so that we have dr_set_tls_field
#define STATIC_DRMGR_ONLY
#include "pyda_threads.h"

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "Python.h"
#include "pyda_util.h"

#ifdef LINUX
#include <sys/auxv.h>
#endif

#ifdef UNIX
#include <semaphore.h>
#include <unistd.h>
#endif

// These are used by python as shims to dynamorio-safe pthread functions

int pyda_thread_setspecific(pthread_key_t key, void *val);

int pyda_thread_key_create(pthread_key_t *p2newkey, void *unused) {
    int field = drmgr_register_tls_field();
    DR_ASSERT(field != -1);
    DEBUG_PRINTF("pthread_thread_key_create %d\n", field);
    *p2newkey = (pthread_key_t)field;
    pyda_thread_setspecific(field, 0);
    return 0;
}
int pyda_thread_key_delete(pthread_key_t key) {
    // nop
    return 0;
}
void* pyda_thread_getspecific(pthread_key_t key) {
    void *drcontext = dr_get_current_drcontext();
    void* result =  drmgr_get_tls_field(drcontext, (int)key);
    // DEBUG_PRINTF("pthread_thread_key_getspecific %d result %lx\n", key, (unsigned long)result);
    return result;
}
int pyda_thread_setspecific(pthread_key_t key, void *val) {
    void *drcontext = dr_get_current_drcontext();
    bool result = drmgr_set_tls_field(drcontext, (int)key, val);
    // DEBUG_PRINTF("pthread_thread_key_setspecific %d val %lx result %d\n", key, (unsigned long)val, result);
    return result != 1;
}

int pyda_cond_init(pthread_cond_t *condvar, const pthread_condattr_t *attr) {
    // DEBUG_PRINTF("pthread_cond_init %p\n", condvar);
    int res;
    if (attr) {
#ifdef LINUX
        pthread_condattr_setpshared((pthread_condattr_t*)attr, PTHREAD_PROCESS_SHARED);
#endif
        res = pthread_cond_init(condvar, attr);
    } else {
        pthread_condattr_t attr2;
        pthread_condattr_init(&attr2);
#ifdef LINUX
        pthread_condattr_setpshared(&attr2, PTHREAD_PROCESS_SHARED);
#endif
        res = pthread_cond_init(condvar, &attr2);
        pthread_condattr_destroy(&attr2);
    }

    return res;
}
int pyda_cond_timedwait(pthread_cond_t *condvar, pthread_mutex_t *mutex, const struct timespec *abstime) {
    // DEBUG_PRINTF("pthread_cond_timedwait %p %p ids %d\n", condvar, mutex, getpid());
    int result = pthread_cond_timedwait(condvar, mutex, abstime);
    return result;
}
int pyda_cond_signal(pthread_cond_t *condvar) {
    // DEBUG_PRINTF("pthread_cond_signal %p ids %d\n", condvar, getpid());
    return pthread_cond_signal(condvar);
}

int pyda_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr) {
    // DEBUG_PRINTF("pthread_mutex_init %p\n", mutex);
    int res;
    if (attr) {
#ifdef LINUX
        pthread_mutexattr_setpshared((pthread_mutexattr_t*)attr, PTHREAD_PROCESS_SHARED);
#endif
        res = pthread_mutex_init(mutex, attr);
    } else {
        pthread_mutexattr_t attr2;
        pthread_mutexattr_init(&attr2);
#ifdef LINUX
        pthread_mutexattr_setpshared(&attr2, PTHREAD_PROCESS_SHARED);
#endif
        res = pthread_mutex_init(mutex, &attr2);
        pthread_mutexattr_destroy(&attr2);
    }

    return res;
}

void* pyda_thread_self() {
    // XXX: We *could* try to return our pyda-specific tid -- but there
    // are technically two threads with that tid!! (Python and App).
    // If we returned the same ID for two python threads,
    // it seems likely it would break things.
    //
    // Instead, we are just going to return the dynamorio thread id
    return (void*)(uintptr_t)dr_get_thread_id(dr_get_current_drcontext());
}

extern void __ctype_init();
void* python_thread_init(void *pyda_thread) {
#ifdef LINUX
    __ctype_init();
#endif

    void *drcontext = dr_get_current_drcontext();
    void *tls = dr_thread_alloc(drcontext, sizeof(void*) * 130);
    memset(tls, 0, sizeof(void*) * 130);
    dr_set_tls_field(drcontext, (void *)tls);

    dr_client_thread_set_suspendable(false);
    pyda_thread_setspecific(g_pyda_tls_idx, (void*)pyda_thread);
    pyda_thread_setspecific(g_pyda_tls_is_python_thread_idx, (void*)1);
    return tls;
}

struct thread_start {
    void *(*start_routine) (void *);
    void *arg;
    // void *pyda_thread;
};

static void client_thread_init(void *arg) {
    struct thread_start *ts = (struct thread_start*)arg;
    void *tls = python_thread_init(NULL);
    ts->start_routine(ts->arg);
    DEBUG_PRINTF("start_routine returned\n");
    dr_client_thread_set_suspendable(true);
    dr_thread_free(dr_get_current_drcontext(), tls, sizeof(void*) * 130);
    dr_global_free(ts, sizeof(struct thread_start));
}

int pyda_thread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg) {
    DEBUG_PRINTF("pthread_create %p %p %p %p\n", thread, attr, start_routine, arg);

    struct thread_start *ts = dr_global_alloc(sizeof(struct thread_start));
    ts->start_routine = start_routine;
    ts->arg = arg;
    // ts->pyda_thread = pyda_thread_getspecific(g_pyda_tls_idx);
    dr_create_client_thread(client_thread_init, ts);
    *thread = (pthread_t)0x13371337;
    return 0;
}

int pyda_thread_detach(pthread_t thread) {
    // nop
    DEBUG_PRINTF("pthread_detach %p\n", thread);
    return 0;
}

#ifdef LINUX

extern size_t os_minsigstksz(void);
unsigned long pyda_getauxval(unsigned long type) {
    DEBUG_PRINTF("getauxval %lx\n", type);
    if (type == AT_MINSIGSTKSZ) {
        return os_minsigstksz();
    }
    return getauxval(type);
}

#endif

int pyda_attach_mode;

extern const char *our_getenv(const char *name);
const char *pyda_getenv(const char *name) {
    // Dynamorio does not have the correct ENV in attach mode.
    DEBUG_PRINTF("getenv2 %s=%s\n", name, getenv(name));
    return getenv(name);
}

void parse_proc_environ() {
    FILE *f = fopen("/proc/self/environ", "r");
    if (!f) {
        DEBUG_PRINTF("Failed to open /proc/self/environ\n");
        return;
    }

    // /proc/self/environ is a NULL-separated list of strings
    // each of the form KEY=VALUE

    // We store the new environment in attach_env
    // and we will use that in the attach mode.

    char buf[4096];
    size_t len = fread(buf, 1, sizeof(buf), f);
    fclose(f);

    if (len == sizeof(buf)) {
        DEBUG_PRINTF("Warning: /proc/self/environ too large\n");
    }

    char *key = buf;
    while (key < buf + len) {
        char *k = strtok(key, "=");
        char *v = key + strlen(k) + 1;
        DEBUG_PRINTF("setenv %s=%s\n", k, v);
        setenv(k, v, 0);
        key = v + strlen(v) + 1;
    }

}

/* void pyda_sigaltstack(void *a, void *b) { */
/*     DEBUG_PRINTF("sigaltstack %p %p\n", a, b); */
/* } */

int pyda_sysconf(int num) {
    /* DEBUG_PRINTF("sysconf %d\n", num); */
#ifdef LINUX
    if (num == _SC_SIGSTKSZ) {
        DEBUG_PRINTF("sigconf(_SC_SIGSTKSZ)\n");
        return os_minsigstksz();
    }
#endif
    return sysconf(num);
}

#ifdef UNIX
int pyda_sem_init(void *sem, int pshared, unsigned int value) {
    /* DEBUG_PRINTF("sem_init %p %d %d\n", sem, pshared, value); */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    return sem_init(sem, 1, value);
#pragma GCC diagnostic pop
}
#endif

```

`pyda_core/pyda_unwind.c`:

```c
#include "pyda_core.h"
#define UNW_LOCAL_ONLY
#include <libunwind.h>
#include <sys/ucontext.h>

static void free_bt_entry(void *ptr) {
    dr_global_free(ptr, sizeof(struct pyda_bt_entry));
}

int pyda_get_backtrace (pyda_thread *t, drvector_t *res) {
  unw_cursor_t cursor; unw_context_t uc;
  unw_word_t ip, sp;

  unw_getcontext(&uc);
  ucontext_t *uc2 = (ucontext_t *) &uc;

#if defined(LINUX)
#if defined(__x86_64__)
  uc2->uc_mcontext.gregs[REG_RIP] = (uintptr_t)t->cur_context.pc;
  uc2->uc_mcontext.gregs[REG_RSP] = t->cur_context.rsp;
  uc2->uc_mcontext.gregs[REG_RBP] = t->cur_context.rbp;
  uc2->uc_mcontext.gregs[REG_RDI] = t->cur_context.rdi;
  uc2->uc_mcontext.gregs[REG_RSI] = t->cur_context.rsi;
  uc2->uc_mcontext.gregs[REG_RDX] = t->cur_context.rdx;
  uc2->uc_mcontext.gregs[REG_RCX] = t->cur_context.rcx;
  uc2->uc_mcontext.gregs[REG_R8] = t->cur_context.r8;
  uc2->uc_mcontext.gregs[REG_R9] = t->cur_context.r8;
#elif defined(AARCH64)
  uc2->uc_mcontext.pc = (uintptr_t)t->cur_context.pc;
  uc2->uc_mcontext.regs[0] = t->cur_context.r0;
  uc2->uc_mcontext.regs[1] = t->cur_context.r1;
  uc2->uc_mcontext.regs[2] = t->cur_context.r2;
  uc2->uc_mcontext.regs[3] = t->cur_context.r3;
  uc2->uc_mcontext.regs[4] = t->cur_context.r4;
  uc2->uc_mcontext.regs[5] = t->cur_context.r5;
  uc2->uc_mcontext.regs[6] = t->cur_context.r6;
  uc2->uc_mcontext.regs[7] = t->cur_context.r7;
  uc2->uc_mcontext.sp = t->cur_context.sp;
  uc2->uc_mcontext.regs[30] = t->cur_context.lr;
#else
#error "Unsupported architecture"
#endif

#elif defined(MACOS) /* continuation of defined(LINUX) */
#if defined(__x86_64__)
  uc2->uc_mcontext->__ss.__rip = (uintptr_t)t->cur_context.pc;
  uc2->uc_mcontext->__ss.__rsp = t->cur_context.rsp;
  uc2->uc_mcontext->__ss.__rbp = t->cur_context.rbp;
  uc2->uc_mcontext->__ss.__rdi = t->cur_context.rdi;
  uc2->uc_mcontext->__ss.__rsi = t->cur_context.rsi;
  uc2->uc_mcontext->__ss.__rdx = t->cur_context.rdx;
  uc2->uc_mcontext->__ss.__rcx = t->cur_context.rcx;
  uc2->uc_mcontext->__ss.__r8 = t->cur_context.r8;
  uc2->uc_mcontext->__ss.__r9 = t->cur_context.r8;
#elif defined(AARCH64)
  uc2->uc_mcontext->__ss.__pc = (uintptr_t)t->cur_context.pc;
  uc2->uc_mcontext->__ss.__x[0] = t->cur_context.r0;
  uc2->uc_mcontext->__ss.__x[1] = t->cur_context.r1;
  uc2->uc_mcontext->__ss.__x[2] = t->cur_context.r2;
  uc2->uc_mcontext->__ss.__x[3] = t->cur_context.r3;
  uc2->uc_mcontext->__ss.__x[4] = t->cur_context.r4;
  uc2->uc_mcontext->__ss.__x[5] = t->cur_context.r5;
  uc2->uc_mcontext->__ss.__x[6] = t->cur_context.r6;
  uc2->uc_mcontext->__ss.__x[7] = t->cur_context.r7;
  uc2->uc_mcontext->__ss.__sp = t->cur_context.sp;
  uc2->uc_mcontext->__ss.__lr = t->cur_context.lr;
#else
#error "Unsupported architecture"
#endif

#endif /* end of defined(MACOS) */

  unw_init_local(&cursor, &uc);

  drvector_init(res, 0, true, free_bt_entry);

  do {
    struct pyda_bt_entry *e = dr_global_alloc(sizeof(struct pyda_bt_entry));

    char sym[512];
    unw_word_t offset;

    unw_get_reg(&cursor, UNW_REG_IP, &ip);
    unw_get_reg(&cursor, UNW_REG_SP, &sp);

    module_data_t *mod = dr_lookup_module((void*)ip);

    if (mod) {
        char *modname = strrchr(mod->full_path, '/');
        if (modname) {
            modname++;
        } else {
            modname = mod->full_path;
        }

        snprintf(e->modname, sizeof(e->modname), "%s", modname);
        e->offset = (uint64_t)ip - (uint64_t)mod->start;
    } else {
        e->modname[0] = 0;
        e->offset = 0;
    }

    if (unw_get_proc_name(&cursor, sym, sizeof(sym), &offset) == 0) {
        snprintf(e->sym_name, sizeof(e->sym_name), "%s", sym);
    } else {
        e->sym_name[0] = 0;
    }

    e->ip = ip;
    e->sp = sp;

    drvector_append(res, e);
  } while (unw_step(&cursor) > 0);

  return 0;
}


```

`pyda_core/tool.c`:

```c

// We use this so that we have dr_set_tls_field
#define STATIC_DRMGR_ONLY

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "drreg.h"
#include "Python.h"
#include "pyda_util.h"

#include <signal.h>

#include "pyda_core_py.h"
#include "pyda_core.h"
#include "pyda_threads.h"

extern void __ctype_init();

void python_init();
void python_main_thread(void*);
void python_aux_thread(void*);
void module_load_event(void *drcontext, const module_data_t *mod, bool loaded);
void thread_init_event(void *drcontext);
void thread_exit_event(void *drcontext);
static void thread_entrypoint_break();

void patch_python();

static dr_emit_flags_t event_analysis(void *drcontext, void *tag, instrlist_t *bb, char for_trace,
                  char translating, void **user_data);
static dr_emit_flags_t
event_insert(void *drcontext, void *tag, instrlist_t *bb, instr_t *instr,
                 bool for_trace, bool translating, void *user_data);

static bool filter_syscall_event(void *drcontext, int sysnum);
static bool pre_syscall_event(void *drcontext, int sysnum);
static void post_syscall_event(void *drcontext, int sysnum);
static dr_signal_action_t signal_event(void *drcontext, dr_siginfo_t *siginfo);
static void fork_event(void *drcontext);
static void event_attach_post(void);


extern int is_dynamorio_running;
extern int pyda_attach_mode;

int is_python_init;

int g_pyda_tls_idx;
int g_pyda_tls_is_python_thread_idx;
client_id_t pyda_client_id;

DR_EXPORT void
dr_client_main(client_id_t id, int argc, const char *argv[])
{
    dr_set_client_name("Pyda",
                       "https://github.com/ndrewh/pyda");

    pyda_client_id = id;

    drreg_options_t ops = { sizeof(ops), 0 /*no slots needed*/, true /* conservative */};
    if (!drmgr_init() || drreg_init(&ops) != DRREG_SUCCESS) {
        dr_fprintf(STDERR, "pyda: error in drmgr or drreg initialization\n");
        dr_abort();
    }


    is_dynamorio_running = 1;

    /* make it easy to tell, by looking at log file, which client executed */
    DEBUG_PRINTF("Client 'pyda' initializing\n");

    // Dynamically patch python
    patch_python();

    // dr_set_process_exit_behavior(DR_EXIT_MULTI_THREAD | DR_EXIT_SKIP_THREAD_EXIT);

    // python_init();
    // dr_create_client_thread(python_thread, NULL);
    drmgr_register_thread_init_event(thread_init_event);
    drmgr_register_thread_exit_event(thread_exit_event);

    drmgr_register_module_load_event(module_load_event);
    drmgr_register_bb_instrumentation_event(event_analysis,
                                            event_insert,
                                            NULL);

    drmgr_register_pre_syscall_event(pre_syscall_event);
    drmgr_register_post_syscall_event(post_syscall_event);
    dr_register_filter_syscall_event(filter_syscall_event);
    dr_register_post_attach_event(event_attach_post);

    drmgr_register_signal_event(signal_event);
    dr_register_fork_init_event(fork_event);
    dr_request_synchronized_exit();

    g_pyda_tls_idx = drmgr_register_tls_field();
    g_pyda_tls_is_python_thread_idx = drmgr_register_tls_field();
}

void module_load_event(void *drcontext, const module_data_t *mod, bool loaded) {
    DEBUG_PRINTF("module_load_event: %s\n", mod->full_path);
    
    if (loaded) {
        pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
        pyda_hook_module_load(mod->full_path);
    }
}

void thread_init_event(void *drcontext) {
    DEBUG_PRINTF("thread_init_event\n");
    module_data_t *main_mod = dr_get_main_module();

    if (!main_mod) {
        DEBUG_PRINTF("main_mod is NULL\n");
        return;
    }

    // Make a thread structure
    static pyda_process *global_proc = NULL;
    pyda_thread *t;
    if (!global_proc) {
        global_proc = pyda_mk_process();

        pyda_prepare_io(global_proc);
        t = global_proc->main_thread;
        if (!getenv("PYTHONPATH")) {
            parse_proc_environ();
        }
    } else {
        t = pyda_mk_thread(global_proc);
    }

    DEBUG_PRINTF("thread_init_event %p thread %d\n", (void*)t, dr_get_thread_id(drcontext));

    // WARN: This must use drcontext passed in.
    drmgr_set_tls_field(drcontext, g_pyda_tls_idx, (void*)t);
    drmgr_set_tls_field(drcontext, g_pyda_tls_is_python_thread_idx, (void*)0);

    // some init that python requires(?)
#ifdef LINUX
    __ctype_init();
#endif

    if (global_proc->main_thread->python_exited) {
        t->errored = 1;
    }

    // Every thread has its own corresponding python thread
    if (t == global_proc->main_thread) {
        dr_create_client_thread(python_main_thread, t);
    } else {
        dr_create_client_thread(python_aux_thread, t);
    }

    // Store the first pc, we will intrument it to call break
    if (t == global_proc->main_thread) {
        t->proc->entrypoint = (void*)main_mod->entry_point;

        if (!getenv("PYDA_NO_ATTACH")) {
            pyda_attach_mode = 1;
            // In attach mode, the entrypoint will never be reached,
            // so we release the lock now
            DEBUG_PRINTF("PYDA_NO_ATTACH is not set, assuming attach mode\n")
            pthread_mutex_unlock(&t->mutex);
        }
    } else {
        DEBUG_PRINTF("aux thread initial break\n");
        pyda_initial_break(t);
        DEBUG_PRINTF("aux thread initial break end\n");
    }
    DEBUG_PRINTF("thread_init_event end: %p\n", (void*)t);
}

void thread_exit_event(void *drcontext) {
    pyda_thread *t = drmgr_get_tls_field(drcontext, g_pyda_tls_idx);

    DEBUG_PRINTF("thread_exit_event: %p thread id %d\n", t, dr_get_thread_id(drcontext));
    t->app_exited = 1;

    pyda_break_noblock(t);
    /* dr_fprintf(STDERR, "pyda_break\n"); */
}

static const char *script_name;

static void get_python_args(int *o_argc, const char ***o_argv) {
    int argc;
    const char **argv;
    const char **new_argv;

    dr_get_option_array(pyda_client_id, &argc, &argv);

    if (argc >= 3 && strcmp(argv[1], "-script") == 0) {
        script_name = strdup(argv[2]);
        argc -= 2;

        // Copy to new memory
        new_argv = dr_global_alloc(sizeof(const char*) * (argc + 1));
        for (int i=0; i<argc; i++) {
            new_argv[i] = strdup(argv[i+2]);
        }

        new_argv[argc] = NULL;
        new_argv[0] = strdup(argv[0]);

        // Shift out the two "-script X" arguments
        DEBUG_PRINTF("Using script from command line: %s\n", script_name);
    } else {
        script_name = getenv("PYDA_SCRIPT");

        // Copy to new memory
        new_argv = dr_global_alloc(sizeof(const char*) * (argc + 1));
        for (int i=0; i<argc; i++) {
            new_argv[i] = strdup(argv[i]);
        }
        new_argv[argc] = NULL;
    }

    *o_argc = argc;
    *o_argv = new_argv;
}

void python_init() {
    static bool is_init = false;
    if (is_init) return;
    is_init = true;

    DEBUG_PRINTF("python_init\n");
    // sleep(10);
    /* Add the pyda_core module */
    if (PyImport_AppendInittab("pyda_core", PyInit_pyda_core) == -1) {
        fprintf(stderr, "Error: could not extend in-built modules table\n");
        exit(1);
    }

#ifndef MACOS
    wchar_t *program = Py_DecodeLocale("python3", NULL);
    if (program == NULL) {
        DEBUG_PRINTF("Fatal error: cannot decode argv[0]\n");
        exit(1);
    }

    Py_SetProgramName(program);
#endif // macOS uses PYTHONEXECUTABLE

    PyConfig config;
    PyConfig_InitPythonConfig(&config);

    int argc;
    const char **argv;
    get_python_args(&argc, &argv);
    PyConfig_SetBytesArgv(&config, argc, (char * const *)argv);
    config.parse_argv = 0;

    // Output is much happier if we don't buffer.
    config.buffered_stdio = 0;

    Py_InitializeFromConfig(&config);

    DEBUG_PRINTF("python_init2\n");

#ifndef NDEBUG
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();

    // Check that the python interpreter is functional
    PyRun_SimpleString("from time import time,ctime\n"
                       "print('You are running Pyda v" PYDA_VERSION ".');\n"
    );
    DEBUG_PRINTF("python_init3\n");
    PyGILState_Release(gstate);
#endif
}

static dr_emit_flags_t
event_analysis(void *drcontext, void *tag, instrlist_t *bb, bool for_trace,
                  bool translating, void **user_data)
{
    return DR_EMIT_DEFAULT;
}
static dr_emit_flags_t
event_insert(void *drcontext, void *tag, instrlist_t *bb, instr_t *instr,
                 bool for_trace, bool translating, void *user_data)
{
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    pyda_hook *callback;

    // XXX: I don't think this is safe, since the thread that updates
    // the code cache may not be the executing thread.
    //
#if defined(X86)
    dr_cleancall_save_t save_flags = DR_CLEANCALL_READS_APP_CONTEXT | DR_CLEANCALL_WRITES_APP_CONTEXT | DR_CLEANCALL_SAVE_FLOAT;
#elif defined(AARCH64)
    dr_cleancall_save_t save_flags = DR_CLEANCALL_READS_APP_CONTEXT | DR_CLEANCALL_WRITES_APP_CONTEXT;
#else
    #error "Unsupported arch"
#endif

    if (instr_is_app(instr)) {
        if (instr_get_app_pc(instr) == t->proc->entrypoint) {
            DEBUG_PRINTF("** Found Entrypoint\n");
            dr_insert_clean_call_ex(drcontext, bb, instr, (void *)thread_entrypoint_break,
                            save_flags, 0);
        } else if ((callback = pyda_get_callback(t->proc, instr_get_app_pc(instr)))) {
            DEBUG_PRINTF("installing hook at %p\n", instr_get_app_pc(instr));
            if (callback->callback_type == 0) {
                dr_insert_clean_call_ex(drcontext, bb, instr, (void *)pyda_hook_cleancall,
                                save_flags /* save flags */, 1, OPND_CREATE_INTPTR(callback));
            } else if (callback->callback_type == 1) {
                pyda_handle_advanced_hook(bb, instr, callback);
            }
        } else if (pyda_check_run_until(t->proc, instr_get_app_pc(instr))) {
            DEBUG_PRINTF("installing run_until hook at %p\n", instr_get_app_pc(instr));
            dr_insert_clean_call_ex(drcontext, bb, instr, (void *)pyda_hook_rununtil_reached,
                            save_flags /* save flags */, 1, OPND_CREATE_INTPTR(instr_get_app_pc(instr)));
        }
    }
    return DR_EMIT_DEFAULT;
}

static bool filter_syscall_event(void *drcontext, int sysnum) {
    // TODO: Check the list of desired syscalls
    return true;
}

static bool pre_syscall_event(void *drcontext, int sysnum) {
    if (drcontext != dr_get_current_drcontext()) {
        DEBUG_PRINTF("pre_syscall_event: drcontext mismatch\n");
        return true;
    }
    return pyda_hook_syscall(sysnum, 1);
}

static void post_syscall_event(void *drcontext, int sysnum) {
    if (drcontext != dr_get_current_drcontext()) {
        DEBUG_PRINTF("post_syscall_event: drcontext mismatch\n");
    }
    pyda_hook_syscall(sysnum, 0);
}

static dr_signal_action_t signal_event(void *drcontext, dr_siginfo_t *siginfo) {
    pyda_thread *t = drmgr_get_tls_field(drcontext, g_pyda_tls_idx);

    DEBUG_PRINTF("signal_event tid=%d: %d\n", t->tid, siginfo->sig);

    int sig = siginfo->sig;

    // We only care about signals that indicate crashes. We only care if the python thread
    // is still running (We need to have someone to raise the exception to!)
    // Perhaps unexpectedly, we also only care if the process has not blocked the signal.
    // This prevents us from handling signals before the application is ready for them (e.g.,
    // because it is holding the GIL. We will still handle them before the app gets them,
    // since dynamorio will call the handler a second time.)
    if ((sig == SIGSEGV || sig == SIGBUS || sig == SIGILL || sig == SIGABRT) && !siginfo->blocked) {
        if (!t->python_exited) {
            memcpy(&t->cur_context, siginfo->mcontext, sizeof(dr_mcontext_t));
            t->signal = sig;

            // Clear any previous run_until hooks: they are now invalid
            // since we are throwing.
            if (t->run_until)
                pyda_clear_run_until(t);

            // Raise an exception in Python +
            // Wait for Python to yield back to us
            pyda_break(t);

            if (!t->python_exited) {
                // Flushing is actually allowed in signal event handlers.
                // This updates run_until handlers, updated hooks, etc.
                pyda_flush_hooks();

                // Copy the state back to the siginfo
                memcpy(siginfo->mcontext, &t->cur_context, sizeof(dr_mcontext_t));

                t->signal = 0;

                return DR_SIGNAL_REDIRECT;
            }
            //
            // If Python exited (e.g. by not catching the FatalSignalError), we allow this
            // to fall through and deliver the signal anyway
            //
            dr_fprintf(STDERR, "[Pyda] Script did not handle FatalSignalError. Delivering signal %d.\n", sig);
        } else {
            dr_fprintf(STDERR, "[Pyda] ERROR: Signal %d received after Python exited/died. Add p.run() to receive the signal as an exception.\n", sig);
        }
    }

    return DR_SIGNAL_DELIVER;
}
static void fork_event(void *drcontext) {
    // This is called on the NEW fork, which doesn't have any parallel Python threads anymore.
    // TODO: How do we make sure that important locks aren't held at fork time when we have multiple threads?
    pyda_thread *t = drmgr_get_tls_field(drcontext, g_pyda_tls_idx);
    DEBUG_PRINTF("[Pyda] fork_init\n");

    pyda_process *p = t->proc;

    // Flush deleted hooks
    drvector_lock(&p->threads);
    for (int i=0; i<p->threads.entries; i++) {
        dr_flush_file(STDERR);
        if (p->threads.array[i] != t) pyda_thread_destroy(p->threads.array[i]);
    }
    p->threads.entries = 1;
    p->threads.array[0] = t;
    drvector_unlock(&p->threads);

    // For now, we just mark the current thread as exited, which just means we won't
    // try to yield to it in signal handlers or if we reach the last run_until hook.
    //
    // In the future, we could setup a new parallel Python thread that enters some
    // "fork handler" as the entrypoint or whatever

    t->python_exited = 1;
    p->main_thread = t;
}

static void event_attach_post() {
    if (!pyda_attach_mode) {
        dr_fprintf(STDERR, "Internal error: PYDA_NO_ATTACH is set but attach callback used\n");
        dr_abort();
        return;
    }

    DEBUG_PRINTF("event_attach_post on tid %d\n", dr_get_thread_id(dr_get_current_drcontext()));

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    DEBUG_PRINTF("[PYDA] Main thread (attached) is %ld\n", t->tid);

    if (t->proc->main_thread != t) {
        dr_fprintf(STDERR, "[Pyda] ERROR: Dynamorio is not running on the main thread. This is probably a bug.\n");
        dr_abort();
    }

    pthread_mutex_lock(&t->mutex); // we intentionally released the mutex based on `pyda_attach_mode`
    pyda_initial_break(t); // wait for the script to call p.run()

    // XXX: Not clear if this is legal to call here. If it is, we should note that we don't
    // have to redirect execution, because we aren't actually in translated code yet!
    /* pyda_flush_hooks(); */

    DEBUG_PRINTF("entrypoint end (attach)\n");
}

static void thread_entrypoint_break() {
    DEBUG_PRINTF("entrypoint (break)\n");

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    DEBUG_PRINTF("[PYDA] Main thread at entrypiont %ld\n", t->tid);

    pyda_initial_break(t);
    DEBUG_PRINTF("entrypoint break end\n");
    if (pyda_flush_hooks()) {
        DEBUG_PRINTF("entrypoint: flush hooks\n");

        // We may have flushed the current fragment, so we have to call
        // dr_redirect_execution instead of returning.
        dr_mcontext_t mc;
        mc.size = sizeof(mc);
        mc.flags = DR_MC_ALL;
        dr_get_mcontext(dr_get_current_drcontext(), &mc);
        mc.pc = t->proc->entrypoint;
        t->proc->entrypoint = 0; // avoid breaking a second time
        dr_flush_region((void*)mc.pc, 1);
        dr_redirect_execution(&mc);
    }
    DEBUG_PRINTF("entrypoint (break end)\n");
}

void drmgr_thread_init_event(void*);

void python_main_thread(void *arg) {
    pyda_thread *t = arg;
    void *drcontext = dr_get_current_drcontext();
    void *tls = python_thread_init(t);

    python_init();

    if (!PyGILState_Check()) {
        dr_fprintf(STDERR, "[Pyda] Error: GIL expected\n");
        dr_abort();
    }

    DEBUG_PRINTF("Running script...\n");
    /* sleep(10); */

    if (!script_name) {
        dr_fprintf(STDERR, "[Pyda] Error: Script not specified\n");
        goto python_exit;
    }

    FILE *f = fopen(script_name, "r");
    if (!f) {
        dr_fprintf(STDERR, "[Pyda] Error: could not open %s\n", script_name);
        goto python_exit;
    }

    // The thread will be holding the lock until
    // it reaches the "initial" breakpoint
    pthread_mutex_lock(&t->mutex);
    pthread_mutex_unlock(&t->mutex);

    // This is a good place to put a sleep to attach GDB
    // if testing out the attach mode
    // sleep(15);

    if (PyRun_SimpleFile(f, script_name) == -1) {
        // python exception
        dr_fprintf(STDERR, "[Pyda] Script raised exception, see above.\n");
    }

    fclose(f);

python_exit:
    DEBUG_PRINTF("Script exited...\n");
    t->python_exited = 1;
    t->errored = 1;

    DEBUG_PRINTF("After script exit, GIL status %d\n", PyGILState_Check());

    Py_BEGIN_ALLOW_THREADS;

    if (!t->app_exited) {
        if (!t->signal)
            dr_fprintf(STDERR, "[Pyda] ERROR: Did you forget to call p.run()?\n");

        DEBUG_PRINTF("Implicit pyda_yield start\n");
        pyda_yield(t); // unblock (note: blocking)
        DEBUG_PRINTF("Implicit pyda_yield finished\n");
    }

    // This call will block until the main thread is the last.
    DEBUG_PRINTF("python_main_thread destroy\n");
    pyda_thread_destroy_last(t);
    DEBUG_PRINTF("python_main_thread destroy done\n");

    DEBUG_PRINTF("Py_FinalizeEx in thread %d\n", dr_get_thread_id(drcontext));

    Py_END_ALLOW_THREADS;

    if (Py_FinalizeEx() < 0) {
        DEBUG_PRINTF("WARN: Python finalization failed\n");
    }

    DEBUG_PRINTF("Py_FinalizeEx done\n");

    dr_thread_free(drcontext, tls, sizeof(void*) * 130);
    DEBUG_PRINTF("python_main_thread return\n");
}

void python_aux_thread(void *arg) {
    pyda_thread *t = arg;
    void *drcontext = dr_get_current_drcontext();
    void *tls = python_thread_init(t);

    DEBUG_PRINTF("python_aux_thread id %d\n", dr_get_thread_id(drcontext));

    // Wait for the main script to reach the first yield (so there is time to set thread_init_hook in the attach case)
    pthread_mutex_lock(&t->proc->main_thread->mutex);
    while (!t->proc->main_thread->yield_count)
        pthread_cond_wait(&t->proc->main_thread->resume_cond, &t->proc->main_thread->mutex);
    pthread_mutex_unlock(&t->proc->main_thread->mutex);

    DEBUG_PRINTF("python_aux_thread enter id %d\n", dr_get_thread_id(drcontext));

    // Acquire the GIL so this thread can call the thread entrypoint
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();

    // We just call the thread init hook, if one exists
    if (t->proc->thread_init_hook && !t->errored) {
        DEBUG_PRINTF("Calling thread_init_hook\n");
        PyObject *result = PyObject_CallFunctionObjArgs(t->proc->thread_init_hook, t->proc->py_obj, NULL);
        if (result == NULL) {
            PyErr_Print();
            dr_fprintf(STDERR, "[Pyda] ERROR: Thread entry hook failed. Continuing.\n");
            // dr_abort();
        }
    }

    PyGILState_Release(gstate);

    // dr_client_thread_set_suspendable(true);

    DEBUG_PRINTF("python_aux_thread 4\n");

    t->python_exited = 1;

    if (!t->app_exited) {
        pyda_yield(t);
        DEBUG_PRINTF("Implicit pyda_yield finished\n");
    }

    pyda_thread_destroy(t);

    DEBUG_PRINTF("python_aux_thread 5\n");
    dr_thread_free(drcontext, tls, sizeof(void*) * 130);
    DEBUG_PRINTF("python_aux_thread 6\n");
}

```

`pyproject.toml`:

```toml
[project]
requires-python = ">=3.10,<3.11"
dynamic = ["version"]
name = "pyda-dbi"

[build-system]
requires = [
    "setuptools>=64",
    "cmake>=3.18",
    "setuptools-scm>=8",
]
build-backend = "setuptools.build_meta"

[tool.setuptools_scm]


```

`setup.py`:

```py
# translated from Dockerfile courtesy of Claude
import os
import sys
import subprocess
import shutil
import tempfile
from setuptools import setup, Extension, Command
from setuptools.command.install import install
from setuptools.command.develop import develop
from setuptools.command.install_scripts import install_scripts
from setuptools.command.build_ext import build_ext
import multiprocessing
import platform
import site
from urllib.request import urlretrieve

def dynamorio_tag_and_patch():
    if "macOS" in platform.platform():
        return ("bf5c900f575976ba145616b25337e3266ecaea3a", "patches/dynamorio-bf5c900f575976ba145616b25337e3266ecaea3a-macos.patch")
    else:
        return ("release_11.2.0", "patches/dynamorio-11.2.patch")

# Utility functions
def run_command(command, cwd=None, env=None):
    print(f"Running {' '.join(command)}")
    subprocess.check_call(command, cwd=cwd, env=env)

def download_and_extract(url, extract_dir):
    import tarfile

    filename = url.split('/')[-1]
    urlretrieve(url, filename)

    with tarfile.open(filename) as tar:
        tar.extractall(path=extract_dir)

    os.remove(filename)

class CustomBuildCommand(build_ext):
    def run(self):
        # Create temporary build directory
        build_temp_dir = tempfile.TemporaryDirectory()
        build_temp = build_temp_dir.name
        # build_temp = os.path.join(self.build_lib, "pyda_install")
        # os.makedirs(build_temp, exist_ok=True)
        try:
            # Set up paths
            dynamorio_install_dir = os.path.join(self.build_temp, 'dynamorio_install')
            libunwind_install_dir = os.path.join(self.build_temp, 'libunwind_install')

            os.makedirs(dynamorio_install_dir, exist_ok=True)
            os.makedirs(libunwind_install_dir, exist_ok=True)

            # Build libunwind
            if "Linux" in platform.platform():
                libunwind_dir = os.path.join(build_temp, 'libunwind')
                os.makedirs(libunwind_dir, exist_ok=True)
                download_and_extract(
                    'https://github.com/libunwind/libunwind/releases/download/v1.8.1/libunwind-1.8.1.tar.gz',
                    libunwind_dir
                )
                libunwind_build_dir = os.path.join(libunwind_dir, 'libunwind-1.8.1')
                run_command(['./configure', f'--prefix={os.path.abspath(libunwind_install_dir)}'], cwd=libunwind_build_dir)
                run_command(['make', f'-j{multiprocessing.cpu_count()}'], cwd=libunwind_build_dir)
                run_command(['make', 'install'], cwd=libunwind_build_dir)

            # Build DynamoRIO
            dynamorio_dir = os.path.join(build_temp, 'dynamorio')
            run_command([
                'git', 'clone', '--recurse-submodules', '-j4',
                'https://github.com/DynamoRIO/dynamorio.git',
                dynamorio_dir
            ])

            dyn_tag, dyn_patch = dynamorio_tag_and_patch()
            run_command(['git', 'checkout', dyn_tag], cwd=dynamorio_dir)

            # Apply DynamoRIO patch if it exists
            patch_path = os.path.abspath(dyn_patch)
            if os.path.exists(patch_path):
                run_command(['git', 'apply', patch_path], cwd=dynamorio_dir)

            if "macOS" not in platform.platform():
                # TODO: update to a newer version that doesn't require backward-porting these patches
                urlretrieve('https://github.com/DynamoRIO/dynamorio/commit/f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch', os.path.join(dynamorio_dir, 'f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch'))
                urlretrieve('https://github.com/DynamoRIO/dynamorio/commit/c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch', os.path.join(dynamorio_dir, 'c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch'))
                urlretrieve('https://github.com/DynamoRIO/dynamorio/commit/8c997f483b564f2408553b718a5707e28c9be820.patch', os.path.join(dynamorio_dir, '8c997f483b564f2408553b718a5707e28c9be820.patch'))
                urlretrieve('https://github.com/DynamoRIO/dynamorio/commit/572f3b1484fda1fbc502fad298939756cd72f3ae.patch', os.path.join(dynamorio_dir, '572f3b1484fda1fbc502fad298939756cd72f3ae.patch'))

                run_command(["bash", "-c", "git apply f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch && rm f1b67a4b0cf0a13314d500dd3aaefe9869597021.patch && git submodule update --init"], cwd=dynamorio_dir)
                run_command(["bash", "-c", "git apply c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch && rm c46d736f308e6e734bd0477f7b8a2dcbefb155d3.patch"], cwd=dynamorio_dir)
                run_command(["bash", "-c", "git apply 8c997f483b564f2408553b718a5707e28c9be820.patch && rm 8c997f483b564f2408553b718a5707e28c9be820.patch"], cwd=dynamorio_dir)
                run_command(["bash", "-c", "git apply 572f3b1484fda1fbc502fad298939756cd72f3ae.patch && rm 572f3b1484fda1fbc502fad298939756cd72f3ae.patch"], cwd=dynamorio_dir)

            # Build DynamoRIO
            dynamorio_build_dir = os.path.join(dynamorio_dir, 'build')
            os.makedirs(dynamorio_build_dir, exist_ok=True)

            debug_mode = os.environ.get('PYDA_DEBUG', '0') == '1'
            cmake_debug = 'ON' if debug_mode else 'OFF'
            build_type = 'Debug' if debug_mode else 'Release'

            run_command([
                'cmake',
                f'-DDEBUG={cmake_debug}',
                '-DBUILD_TESTS=OFF',
                '-DBUILD_SAMPLES=OFF',
                '-DBUILD_CLIENTS=OFF',
                '-DBUILD_DOCS=OFF',
                f'-DCMAKE_INSTALL_PREFIX={os.path.abspath(dynamorio_install_dir)}',
                '..'
            ], cwd=dynamorio_build_dir)
            run_command(['make', f'-j{multiprocessing.cpu_count()}'], cwd=dynamorio_build_dir)
            run_command(['make', 'install'], cwd=dynamorio_build_dir)

            print(f"exe: {sys.executable}")
            print(f"path: {sys.path}")

            # Set environment variables for the final build
            build_env = os.environ.copy()
            build_env.update({
                'DYNAMORIO_HOME': os.path.abspath(dynamorio_install_dir),
                # 'PYTHONHOME': os.path.abspath(python_install_dir),
                # 'PYTHONPATH': f"{os.path.abspath(os.path.join(python_install_dir, 'lib', 'python3.10'))}:{os.path.join(os.getcwd(), 'lib')}"
            })

            # Build the main project
            project_build_dir = os.path.join(self.build_temp, 'build')
            os.makedirs(project_build_dir, exist_ok=True)

            src_dir = os.path.dirname(os.path.abspath(__file__))

            python_home = build_env.get("VIRTUAL_ENV", None)

            cmake_args = [
                'cmake',
                f'-DCMAKE_BUILD_TYPE={build_type}',
                f'-DDynamoRIO_DIR={os.path.abspath(os.path.join(dynamorio_install_dir, "cmake"))}',
                f'-DPython3_EXECUTABLE={sys.executable}',
            ] + ([f'-DPython3_ROOT_DIR={python_home}'] if python_home is not None else []) + ([
                    f'-DLIBUNWIND_INCLUDE_DIRS={os.path.abspath(os.path.join(libunwind_install_dir, "include"))}',
                    f'-DLIBUNWIND_LIBRARY_DIRS={os.path.abspath(os.path.join(libunwind_install_dir, "lib"))}',
                ] if "Linux" in platform.platform() else []) + [
                src_dir
            ]
            run_command(cmake_args, cwd=project_build_dir, env=build_env)

            run_command(['make', f'-j{multiprocessing.cpu_count()}'], cwd=project_build_dir)
            run_command(['rm', '-rf', os.path.abspath(dynamorio_build_dir)])

            # After building, copy artifacts to package directory
            package_dir = os.path.join(self.build_lib, 'pyda')
            os.makedirs(package_dir, exist_ok=True)

            with open(os.path.join(dynamorio_install_dir, "CMakeCache.txt"), 'w') as f:
                pass

            # Copy DynamoRIO installation
            dynamorio_dest = os.path.join(package_dir, 'dynamorio')
            scripts_dest = os.path.join(package_dir, 'scripts')
            os.makedirs(scripts_dest, exist_ok=True)

            shutil.copytree(dynamorio_install_dir, dynamorio_dest, dirs_exist_ok=True)

            # Copy the built tool library
            if "macOS" in platform.platform():
                tool_src = os.path.join(project_build_dir, 'pyda_core', 'libtool.dylib')
                tool_dest = os.path.join(package_dir, 'libtool.dylib')
            else:
                tool_src = os.path.join(project_build_dir, 'pyda_core', 'libtool.so')
                tool_dest = os.path.join(package_dir, 'libtool.so')

            shutil.copy2(tool_src, tool_dest)
            shutil.copy2(os.path.join(src_dir, "bin", "pyda"), scripts_dest)
            shutil.copy2(os.path.join(src_dir, "bin", "pyda-attach"), scripts_dest)

        finally:
            build_temp_dir.cleanup()
            pass

# Custom install command that runs our build command first
class CustomInstallCommand(install):
    def run(self):
        install.run(self)
        prepend_env = f"""
BASE=$(python3 -c "from importlib.resources import files; print(files('pyda'))" 2>/dev/null)
export DYNAMORIO_HOME=$BASE/dynamorio/
"""
#export PYTHONPATH={':'.join(site.getsitepackages())}

        if "macOS" in platform.platform():
            pyda_tool_path = 'libtool.dylib'
        else:
            pyda_tool_path = 'libtool.so'

        prepend_env += f"export PYDA_TOOL_PATH=$BASE/{pyda_tool_path}\n"

        # Copy and modify the bin scripts to the appropriate location
        bin_dir = self.install_scripts
        src_dir = os.path.join(self.build_lib, "pyda", "scripts")
        os.makedirs(bin_dir, exist_ok=True)

        # Copy and modify pyda script
        with open(os.path.join(src_dir, 'pyda'), 'r') as f:
            pyda_content = f.read()

        # Insert the environment variables after the shebang line
        pyda_lines = pyda_content.splitlines()
        modified_pyda = pyda_lines[0] + '\n\n' + prepend_env + '\n'.join(pyda_lines[1:])

        with open(os.path.join(bin_dir, 'pyda'), 'w') as f:
            f.write(modified_pyda)

        # Copy and modify pyda-attach script
        with open(os.path.join(src_dir, 'pyda-attach'), 'r') as f:
            pyda_attach_content = f.read()

        # Insert the environment variables after the shebang line
        pyda_attach_lines = pyda_attach_content.splitlines()
        modified_pyda_attach = pyda_attach_lines[0] + '\n\n' + prepend_env + '\n'.join(pyda_attach_lines[1:])

        with open(os.path.join(bin_dir, 'pyda-attach'), 'w') as f:
            f.write(modified_pyda_attach)

        os.chmod(os.path.join(bin_dir, "pyda"), 0o775)
        os.chmod(os.path.join(bin_dir, "pyda-attach"), 0o775)

# Custom develop command that runs our build command first
class CustomDevelopCommand(develop):
    def run(self):
        develop.run(self)

setup(
    name='pyda-dbi',
    description='Pyda is a Python library for writing dynamic analysis tools',
    author='Andrew Haberlandt',
    author_email='your.email@example.com',
    cmdclass={
        'build_ext': CustomBuildCommand,
        'install': CustomInstallCommand,
        'develop': CustomDevelopCommand,
    },
    package_dir={"pyda": "lib/pyda"},
    packages=["pyda"],
    package_data={
        'pyda': [
            'dynamorio/**/*',
            'libtool.so',
            'libtool.dylib',
        ],
    },
    include_package_data=True,
    python_requires='>=3.0',
    install_requires=[
        # Add your Python package dependencies here
    ],
    scripts=[],
    ext_modules=[Extension("dummy", sources=[])],
)


```

`tests/builder1.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }
def lib_hook(p):
    p.regs.arg2 += 1337

p.builder_hook(e.plt["printf"], lib_hook)

p.run()

```

`tests/err_hook.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def lib_hook(p):
    global counter
    name = plt_map[p.regs.pc]
    print(f"[thread {p.tid}] {name}")

    counter += 1
    if counter == 1000:
        jsdkfjdsaklfadska

def thread_entry(p):
    print(f"thread_entry for {p.tid}")

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()
```

`tests/err_invalidhook.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

counter = 0
def lib_hook(p):
    global counter
    counter += 1

p.hook(0x1337133713371337, lib_hook)
p.run()
```

`tests/err_norun.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def lib_hook(p):
    global counter
    name = plt_map[p.regs.pc]
    print(f"[thread {p.tid}] {name}")

    counter += 1
    if counter == 1000:
        jsdkfjdsaklfadska

def thread_entry(p):
    print(f"thread_entry for {p.tid}")

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

```

`tests/err_thread_entry.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def lib_hook(p):
    name = plt_map[p.regs.pc]
    print(f"[thread {p.tid}] {name}")

def thread_entry(p):
    global counter
    print(f"thread_entry for {p.tid}")

    counter += 1
    if counter == 2:
        jsdkfjdsaklfadska

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()

```

`tests/eval/malloc1.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<1; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloc1000.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<1000; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloc100000.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<100000; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloc1000000.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<1000000; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloccount_libdebug.py`:

```py
from libdebug import debugger
from pwnlib.elf.elf import ELF
from pathlib import Path
import sys

bin_path = Path(sys.argv[1])
d = debugger(str(bin_path.resolve()))
r = d.run()

e = ELF(bin_path)

counter = 0
def malloc_counter(t, bp):
    global counter
    counter += 1

d.breakpoint(e.plt["malloc"], callback=malloc_counter, file=bin_path.name)
d.cont()
d.wait()

print(f"malloc count: {counter}")
print("pass")

```

`tests/eval/malloccount_pyda.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

counter = 0
def malloc_counter(p):
    global counter
    counter += 1

p.hook(e.plt["malloc"], malloc_counter)
p.run()

print(f"malloc count: {counter}")
print("pass")

```

`tests/eval/run_eval.py`:

```py
import subprocess
from dataclasses import dataclass
from typing import Optional, Callable
from pathlib import Path
from tempfile import TemporaryDirectory
import os
import time

from argparse import ArgumentParser

@dataclass
class ExpectedResult:
    retcode: Optional[int] = None

    # checker(stdout, stderr) -> bool
    checkers: list[Callable[[bytes, bytes], bool]] = list

@dataclass
class RunOpts:
    no_pty: bool = False

def output_checker(stdout: bytes, stderr: bytes) -> bool:
    try:
        if stdout:
            stdout.decode()

        if stderr:
            stderr.decode()
    except:
        return False

    return True

def no_warnings_or_errors(stdout: bytes, stderr: bytes) -> bool:
    return b"[Pyda]" not in stderr and b"WARNING:" not in stderr

TESTS = [
    ("test_malloc_1", "malloc1.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
    ("test_malloc_1000", "malloc1000.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
    ("test_malloc_100000", "malloc100000.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
    ("test_malloc_1000000", "malloc1000000.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
]

def main():
    ap = ArgumentParser()
    ap.add_argument("--test", help="Run a specific test", default=None)
    ap.add_argument("--debug", help="Enable debug output", action="store_true")
    ap.add_argument("--ntrials", default=5, type=int)
    args = ap.parse_args()

    if args.test is None:
        res = True
        for (name, c_file, pyda_file, libdebug_file, run_opts, expected_result) in TESTS:
            res &= run_test(c_file, pyda_file, libdebug_file, run_opts, expected_result, name, args.debug, args.ntrials)
    else:
        test = next((t for t in TESTS if t[0] == args.test), None)
        if test is None:
            print(f"Test {args.test} not found")
            exit(1)

        name, c_file, pyda_file, libdebug_file, run_opts, expected_result = test
        res = run_test(c_file, pyda_file, libdebug_file, run_opts, expected_result, name, args.debug, args.ntrials)

    if not res:
        exit(1)

def run_pyda(c_exe_path, pyda_script_path, env, expected_result, test_name, debug):
    def run():
        cmd = f"pyda {pyda_script_path.resolve()} -- {c_exe_path.resolve()}"
        return subprocess.run(cmd, env=env, stdin=subprocess.DEVNULL, shell=True, timeout=60, capture_output=True)

    return run_tool(run, test_name, expected_result, debug)

def run_libdebug(c_exe_path, libdebug_script_path, env, expected_result, test_name, debug):
    def run():
        return subprocess.run(f"python3 {libdebug_script_path.resolve()} {c_exe_path.resolve()}", env=env, stdin=subprocess.DEVNULL, shell=True, timeout=60, capture_output=True)

    return run_tool(run, test_name, expected_result, debug)

def run_tool(run_cmd, test_name, expected_result, debug):
    result_str = ""

    t1, t2 = None, None
    try:
        t1 = time.time()
        result = run_cmd()
        t2 = time.time()

        stdout = result.stdout
        stderr = result.stderr
    except subprocess.TimeoutExpired as err:
        result_str += "  Timeout occurred. Did the test hang?\n"

        result = None
        stdout = err.stdout
        stderr = err.stderr


    if result:
        # Check the retcode
        if expected_result.retcode is not None:
            if result.returncode != expected_result.retcode:
                result_str += f"  Expected return code {expected_result.retcode}, got {result.returncode}\n"

    # Unconditionally check the output
    for (i, checker) in enumerate(expected_result.checkers):
        checker_res = False
        try:
            checker_res = checker(stdout, stderr)
        except:
            pass

        if not checker_res:
            result_str += f"  Checker {i} failed\n"

    res_time = None
    if t1 is not None and t2 is not None:
        res_time = t2 - t1

    if len(result_str) > 0:
        print(f"[FAIL] {test_name}")
        print(result_str)
    if debug:
        if stdout:
            print(stdout.decode())
        if stderr:
            print(stderr.decode())

    else:
        print(f"[OK] {test_name}")

    return result_str, res_time


def run_test(c_file, pyda_file, libdebug_file, run_opts, expected_result, test_name, debug, ntrials):
    # Compile to temporary directory
    with TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        c_path = Path(c_file)
        pyda_path = Path(pyda_file)
        libdebug_path = Path(libdebug_file)

        c_exe = tmpdir / c_path.stem
        compile_res = subprocess.run(['gcc', '-o', c_exe, c_path], capture_output=True)
        if compile_res.returncode != 0:
            print(f"Failed to compile {c_file}")
            print(compile_res.stderr)
            raise RuntimeError("Failed to compile test")

        env = os.environ.copy()
        if run_opts.no_pty:
            env["PYDA_NO_PTY"] = "1"

        for trial in range(ntrials):
            pyda_result, pyda_time = run_pyda(c_exe, pyda_path, env, expected_result, test_name, debug)
            libdebug_result, libdebug_time = run_libdebug(c_exe, libdebug_path, env, expected_result, test_name, debug)
            print(f"Pyda time: {pyda_time}")
            print(f"libdebug time: {libdebug_time}")

            if len(pyda_result) > 0 or len(libdebug_result) > 0:
                return False

        return True


if __name__ == '__main__':
    main()

```

`tests/run_tests.py`:

```py
import subprocess
from dataclasses import dataclass
from typing import Optional, Callable
from pathlib import Path
from tempfile import TemporaryDirectory
import os, time, platform

from argparse import ArgumentParser
from dataclasses import field
@dataclass
class ExpectedResult:
    retcode: Optional[int] = None

    # checker(stdout, stderr) -> bool
    checkers: list[Callable[[bytes, bytes], bool]] = list

    hang: bool = False

@dataclass
class RunOpts:
    no_pty: bool = False
    attach: bool = False
    supported_arches: list[str] = field(default_factory=lambda: ["AMD64", "x86_64", "aarch64", "arm64"])
    supported_platforms: list[str] = field(default_factory=lambda: ["Linux"])
    ci: bool = True

    def no_arm64(self):
        self.supported_arches.remove("aarch64")
        self.supported_arches.remove("arm64")
        return self

def output_checker(stdout: bytes, stderr: bytes) -> bool:
    try:
        if stdout:
            stdout.decode()

        if stderr:
            stderr.decode()
    except:
        return False
    
    return True

def no_warnings_or_errors(stdout: bytes, stderr: bytes) -> bool:
    return b"[Pyda]" not in stderr and b"WARNING:" not in stderr

TESTS = [
    # tests whether we can handle a large number of threads with concurrent hooks
    ("threads_concurrent_hooks", "thread_1000.c", "../examples/ltrace_multithreaded.py", RunOpts().no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"malloc") == 20000,
            lambda o, e: o.count(b"free") == 20000,
            lambda o, e: all((o.count(f"[thread {i}]".encode('utf-8')) == 40 for i in range(2, 1002))),
        ]
    )),

    # tests whether we can handle a large number of threads that do not get waited on
    ("threads_nojoin", "thread_nojoin.c", "../examples/ltrace_multithreaded.py", RunOpts().no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"malloc") > 15000,
            lambda o, e: o.count(b"free") > 15000,
            lambda o, e: all((o.count(f"[thread {i}]".encode('utf-8')) == 40 for i in range(2, 100))),
        ]
    )),

    # hook throws an exception
    ("err_hook_throw", "thread_1000.c", "err_hook.py", RunOpts().no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # thread entry hook throws an exception
    ("err_thread_entry_throw", "thread_10.c", "err_thread_entry.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # XXX: This is broken in the actions runner for some reason, can't repro locally (#xxx)
    ("err_thread_entry_throw_1000", "thread_1000.c", "err_thread_entry.py", RunOpts(ci=False).no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # tests whether we can handle a simple syscall hook
    ("syscall_hooks", "simple.c", "test_syscall.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pre syscall") == o.count(b"post syscall") + 1, # (+1 for exit)
            lambda o, e: o.index(b"pre syscall") < o.index(b"post syscall"),
        ]
    )),

    # tests tid is correct in syscall hooks
    ("syscall_hooks_multithread", "thread_10.c", "test_syscall.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: all((o.count(f"[tid {i}]".encode('utf-8')) > 1 for i in range(1, 10))) or print(o),
        ]
    )),

    # user fails to call p.run()
    ("err_norun", "thread_10.c", "err_norun.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    ("err_norun_1000", "thread_1000.c", "err_norun.py", RunOpts(ci=False).no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # test register read/write
    ("test_regs_x86", "simple.c", "test_regs_x86.py", RunOpts().no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"success") == 1,
        ]
    )),

    # test "blocking" I/O
    ("test_io1", "test_io.c", "test_io1.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"hello") == 0,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    # test "blocking" I/O
    ("test_io2", "test_io.c", "test_io2.py", RunOpts(), ExpectedResult(
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
            lambda o, e: e.count(b"RuntimeError: I/O must be explicitly captured using process(io=True)") == 1,
            lambda o, e: o.count(b"hello there") == 1,
            lambda o, e: o.count(b"goodbye") == 1,
        ]
    )),

    # test "blocking" run_until
    ("test_blocking1", "simple.c", "test_blocking1.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_blocking2", "simple.c", "test_blocking2.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_blocking3", "simple.c", "test_blocking3.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR: Did you forget to call p.run()?") == 1,
        ]
    )),

    ("test_blocking4", "simple.c", "test_blocking4.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
            lambda o, e: e.count(b"Hook call failed") == 1,
            lambda o, e: e.count(b"InvalidStateError") == 1,
        ]
    )),

    # test "blocking" i/o with a giant write
    ("test_hugeio", "test_hugeio.c", "test_hugeio.py", RunOpts(no_pty=True, ci=False), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_call", "test_call.c", "test_call.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_thread_blocking", "thread_10.c", "test_thread_blocking.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: all((o.count(f"[thread {i}]".encode('utf-8')) == 20 for i in range(2, 12))),
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_segv", "test_segv.c", "test_segv.py", RunOpts().no_arm64(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"test_segv") == 8,
            lambda o, e: o.count(b"] main") == 3,
            lambda o, e: o.count(b"] segfault") == 4,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_python_threading", "simple.c", "test_python_threading.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
            lambda o, e: o.count(b"thread start\n") == 1,
            lambda o, e: o.count(b"thread end\n") == 1,
        ]
    )),

    ("err_invalidhook", "simple.c", "err_invalidhook.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"RuntimeError: Hooked PC 1337133713371337 is invalid;") == 1,
        ]
    )),

    ("test_pwntools", "simple.c", "test_pwntools.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_fork", "test_fork.c", "../examples/ltrace_multithreaded.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"child status 0") == 1,
        ]
    )),

    ("test_attach", "test_longrunning.c", "../examples/ltrace_multithreaded.py", RunOpts(attach=True), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"[thread 1] sleep") in range(5, 12),
        ]
    )),

    ("test_attach_multithread", "test_longrunning_multithread.c", "../examples/ltrace_multithreaded.py", RunOpts(attach=True), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pthread_join") in [9, 10], # first call may happen before attach
            lambda o, e: o.count(b"snprintf") == 10,
            lambda o, e: all((o.count(f"[thread {i}] gettimeofday".encode('utf-8')) in range(5, 12) for i in range(2, 12))),
            lambda o, e: all((o.count(f"thread_entry for {i}".encode('utf-8')) == 1 for i in range(2, 12))),
        ]
    )),

    # test inline instrumentation compiler
    ("test_compiler1", "simple2.c", "builder1.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: all(o.count(f"hello {i}".encode('utf-8')) == 1 for i in range(1337, 1347)),
        ]
    )),
]

def main():
    ap = ArgumentParser()
    ap.add_argument("--test", help="Run a specific test", default=None)
    ap.add_argument("--debug", help="Enable debug output", action="store_true")
    ap.add_argument("--ntrials", default=5, type=int)
    ap.add_argument("--ci", help="Run in CI mode", action="store_true")
    args = ap.parse_args()

    if args.test is None:
        res = True
        for (name, c_file, python_file, run_opts, expected_result) in TESTS:
            if run_opts.supported_arches is not None and platform.machine() not in run_opts.supported_arches:
                print(f"Skipping test {name} because it is not supported on {platform.machine()}")
            elif run_opts.supported_platforms is not None and platform.system() not in run_opts.supported_platforms:
                print(f"Skipping test {name} because it is not supported on {platform.system()}")
            elif not run_opts.ci and args.ci:
                print(f"Skipping test {name} because it is not supported in CI")
            else:
                res &= run_test(c_file, python_file, run_opts, expected_result, name, args.debug, args.ntrials)
    else:
        test = next((t for t in TESTS if t[0] == args.test), None)
        if test is None:
            print(f"Test {args.test} not found")
            exit(1)
        
        name, c_file, python_file, run_opts, expected_result = test
        res = run_test(c_file, python_file, run_opts, expected_result, name, args.debug, args.ntrials)

    if not res:
        exit(1)

TIMEOUT = 30
def run_test(c_file, python_file, run_opts, expected_result, test_name, debug, ntrials):
    # Compile to temporary directory
    with TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        c_path = Path(c_file)
        p_path = Path(python_file)

        c_exe = tmpdir / c_path.stem
        compile_res = subprocess.run(['gcc', '-o', c_exe, c_path, '-lpthread'], capture_output=True)
        if compile_res.returncode != 0:
            print(f"Failed to compile {c_file}")
            print(compile_res.stderr)
            raise RuntimeError("Failed to compile test")

        env = os.environ.copy()
        if run_opts.no_pty:
            env["PYDA_NO_PTY"] = "1"

        env["TERM"] = "linux"

        for trial in range(ntrials):
            result_str = ""
            try:
                if not run_opts.attach:
                    result = subprocess.Popen(f"pyda {p_path.resolve()} -- {c_exe.resolve()}", env=env, stdin=subprocess.DEVNULL, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    stdout, stderr = result.communicate(timeout=TIMEOUT)
                else:
                    # Attach mode: Launch the process and then attach to it
                    proc = subprocess.Popen([c_exe.resolve()], env=env, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    time.sleep(2)
                    result = subprocess.Popen(f"pyda-attach {p_path.resolve()} {proc.pid}", env=env, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)

                    stdout, stderr = proc.communicate(timeout=TIMEOUT)
                    result.wait(timeout=TIMEOUT)

                if expected_result.hang:
                    result_str += "  Expected test to hang, but it did not\n"
            except subprocess.TimeoutExpired as err:
                if not expected_result.hang:
                    result_str += "  Timeout occurred. Did the test hang?\n"

                result.kill()
                if run_opts.attach:
                    proc.kill()
            
                result = None
                stdout = err.stdout
                stderr = err.stderr

            if result:
                # Check the retcode
                if expected_result.retcode is not None:
                    if result.returncode != expected_result.retcode:
                        result_str += f"  Expected return code {expected_result.retcode}, got {result.returncode}\n"

            # Unconditionally check the output
            for (i, checker) in enumerate(expected_result.checkers):
                checker_res = False
                try:
                    checker_res = checker(stdout, stderr)
                except:
                    pass
                
                if not checker_res:
                    result_str += f"  Checker {i} failed\n"


            if len(result_str) > 0:
                print(f"[FAIL] {test_name} ({python_file} {c_file})")
                print(result_str)
                if debug:
                    if stdout:
                        print(stdout.decode())
                    if stderr:
                        print(stderr.decode())

                return False
            else:
                print(f"[OK] {test_name} ({python_file} {c_file})")

        return True


if __name__ == '__main__':
    main()

```

`tests/simple.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

int main(int argc, char** argv) {
    printf("start\n");
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    printf("end\n");
}
```

`tests/simple2.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

int main(int argc, char** argv) {
    printf("start\n");
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
        printf("hello %d\n", i);
    }
    printf("end\n");
}

```

`tests/test_blocking1.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter2 = 0
try:
    while True:
        p.run_until(e.plt["malloc"])
        counter2 += 1
except ThreadExitError:
    pass

assert counter2 == 20, f"{counter2}"
print("pass")
```

`tests/test_blocking2.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def malloc_hook(p):
    global counter
    print(f"malloc({p.regs.arg1})")
    counter += 1

p.hook(e.plt["malloc"], malloc_hook)

counter2 = 0
try:
    while True:
        p.run_until(e.plt["malloc"])
        counter2 += 1
except ThreadExitError:
    pass

assert counter == counter2
print("pass")

```

`tests/test_blocking3.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter2 = 0
p.run_until(e.plt["malloc"])
p.run_until(e.plt["malloc"])
p.run_until(e.plt["malloc"])
p.run_until(e.plt["malloc"])

# NOTE: p.run() is not called -- process should finish and print an error
```

`tests/test_blocking4.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def malloc_hook(p):
    global counter
    print(f"malloc({p.regs.arg1})")
    counter += 1
    p.run_until(0x1337133713371337)

p.hook(e.plt["malloc"], malloc_hook)

counter2 = 0
try:
    while True:
        p.run_until(e.plt["malloc"])
        counter2 += 1
except ThreadExitError:
    pass

assert counter == counter2
print("pass")

```

`tests/test_call.c`:

```c

int lol(char *arg1, int arg2) {
    printf("lol %s %d\n", arg1, arg2);
}

int main() {
    printf("here1\n");
    printf("here2\n");
}
```

`tests/test_call.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import time

p = process(io=True)

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

p.run_until(e.symbols["main"])

lol = p.callable(e.symbols["lol"])
st1 = b"abcd"
st2 = b"A" * 0x400

lol(st1, 1337)
p.recvuntil(b"lol abcd 1337")
lol(st2, 1338)
p.recvuntil(b"lol " + b"A" * 0x400 + b" 1338")
lol(st1, 1339)
p.recvuntil(b"lol abcd 1339")
lol(st1, 1340)
p.recvuntil(b"lol abcd 1340")
p.run()
print("pass")
```

`tests/test_fork.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void child_main() {
    printf("child\n");
}

void parent_main() {
    printf("parent\n");
}

int main(int argc, char** argv) {
    printf("start\n");
    int f = fork();
    if (f == 0) {
        // child
        child_main();
    } else if (f > 0) {
        // parent
        parent_main();

        int status;
        waitpid(f, &status, 0);
        printf("child status %d\n", status);
    } else {
        printf("error\n");
    }
    printf("end\n");
}

```

`tests/test_hugeio.c`:

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    printf("hello there. please enter your name:\n");
    char *name = malloc(100000000); // 100M
    int res = fread(name, 1, 100000000, stdin);
    if (res != 100000000) {
        printf("error reading name\n");
        return 1;
    }
    printf("hello, %s\n", name);
    free(name);
    printf("goodbye\n");
}
```

`tests/test_hugeio.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import time
import platform

def triple():
    if platform.machine() == "aarch64":
        return "aarch64-linux-gnu"
    elif platform.machine() == "x86_64":
        return "x86_64-linux-gnu"
    else:
        raise RuntimeError(f"Unsupported architecture: {platform.machine()}")

def fix_buffering(p):
    libc = ELF(f"/lib/{triple()}/libc.so.6")
    libc.address = p.maps[libc.path].base

    stdin = u64(p.read(libc.symbols["stdin"], 8))
    stdout = u64(p.read(libc.symbols["stdout"], 8))
    stderr = u64(p.read(libc.symbols["stderr"], 8))
    p.callable(libc.symbols["setvbuf"])(stdin, 0, 2, 0)
    p.callable(libc.symbols["setvbuf"])(stdout, 0, 2, 0)
    p.callable(libc.symbols["setvbuf"])(stderr, 0, 2, 0)

p = process(io=True)

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

p.run_until(e.symbols["main"])
fix_buffering(p)

p.recvuntil(b"please enter your name:")
p.sendline(b"A" * 100000000)
p.recvline()
line = p.recvline()
expected = b"hello, " + b"A" * 100000000 + b"\n"
assert line == expected, f"bad {len(line)} {len(expected)}"

p.run()
print("pass")
```

`tests/test_io.c`:

```c
#include <stdio.h>
int main() {
    printf("hello there. please enter your name:\n");
    char name[100] = "tmp";
    scanf("%s", name);
    printf("hello, %s\n", name);

    int age;
    printf("please enter your age:\n");
    scanf("%d", &age);
    printf("hello %s, you are %d years old\n", name, age);
    printf("goodbye\n");
}

```

`tests/test_io1.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process(io=True)

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    print(f"at main, sp={hex(p.regs.sp)}")

p.hook(e.symbols["main"], main_hook)

p.recvuntil(b"please enter your name:")
p.sendline("andrew")
p.recvuntil("please enter your age:")
p.sendline("21")
p.recvline()
line = p.recvline()
assert line == b"hello andrew, you are 21 years old\n", line
p.run()
print("pass")
```

`tests/test_io2.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    print(f"at main, sp={hex(p.regs.sp)}")

p.hook(e.symbols["main"], main_hook)

p.recvuntil(b"please enter your name:")
p.sendline("andrew")
p.recvuntil("please enter your age:")
p.sendline("21")
p.recvline()
line = p.recvline()
assert line == b"hello andrew, you are 21 years old\n", line
p.run()
print("pass")

```

`tests/test_longrunning.c`:

```c

#include <unistd.h>
#include <sys/time.h>

unsigned long timems() {
  struct timeval start;
  gettimeofday(&start, NULL);
  return (start.tv_sec * 1000000 + start.tv_usec) / 1000;
}
int main() {
    printf("Hello from long running test\n");

    unsigned long start = timems();
    while (timems() - start < 10000) {
        sleep(1);
    }

    char *buf = malloc(100);
    snprintf(buf, 100, "Finished longrunning test\n");
    printf("%s", buf);
}

```

`tests/test_longrunning_multithread.c`:

```c

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <stdint.h>
#include <pthread.h>

unsigned long timems() {
  struct timeval start;
  gettimeofday(&start, NULL);
  return (start.tv_sec * 1000000 + start.tv_usec) / 1000;
}

void* thread(void *tid) {
    unsigned int t = (unsigned int)(unsigned long)tid;
    printf("Hello from long running test %u\n", t);
    unsigned long start = timems();
    while (timems() - start < 10000) {
        sleep(1);
    }
    char *buf = malloc(100);
    snprintf(buf, 100, "Finished longrunning test %u\n", t);
    printf("%s", buf);
    return NULL;
}

int main() {
    pthread_t threads[10];
    for (int i=0; i<10; i++) {
        pthread_create(&threads[i], 0, thread, (void*)(uintptr_t)i);
    }

    for (int i=0; i<10; i++) {
        void *ret;
        pthread_join(threads[i], &ret);
    }


}

```

`tests/test_pwntools.py`:

```py
from pwn import *
from pyda import *

p = process(io=True)
p.run()
print("pass")
```

`tests/test_python_threading.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import time
from threading import Thread

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def thread():
    print("thread start")
    time.sleep(1)
    print("thread end")

t = Thread(target=thread)
t.start()

time.sleep(3)
p.run()
time.sleep(3)
print("pass")

```

`tests/test_regs_x86.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    # get all the registers
    print(f"reg rax: {hex(p.regs.rax)}")
    print(f"reg rbx: {hex(p.regs.rbx)}")
    print(f"reg rcx: {hex(p.regs.rcx)}")
    print(f"reg rdx: {hex(p.regs.rdx)}")
    print(f"reg rsi: {hex(p.regs.rsi)}")
    print(f"reg rdi: {hex(p.regs.rdi)}")
    print(f"reg rbp: {hex(p.regs.rbp)}")
    print(f"reg rsp: {hex(p.regs.rsp)}")
    print(f"reg rip: {hex(p.regs.pc)}")
    print(f"reg pc: {hex(p.regs.pc)}")
    print(f"reg r8: {hex(p.regs.r8)}")
    print(f"reg r9: {hex(p.regs.r9)}")
    print(f"reg r10: {hex(p.regs.r10)}")
    print(f"reg r11: {hex(p.regs.r11)}")
    print(f"reg r12: {hex(p.regs.r12)}")
    print(f"reg r13: {hex(p.regs.r13)}")
    print(f"reg r14: {hex(p.regs.r14)}")
    print(f"reg r15: {hex(p.regs.r15)}")
    print(f"reg xmm0: {hex(p.regs.xmm0)}")
    print(f"reg xmm1: {hex(p.regs.xmm1)}")
    print(f"reg xmm2: {hex(p.regs.xmm2)}")
    print(f"reg xmm3: {hex(p.regs.xmm3)}")
    print(f"reg xmm4: {hex(p.regs.xmm4)}")
    print(f"reg xmm5: {hex(p.regs.xmm5)}")
    print(f"reg xmm6: {hex(p.regs.xmm6)}")
    print(f"reg xmm7: {hex(p.regs.xmm7)}")
    print(f"reg fsbase: {hex(p.regs.fsbase)}")

    assert p.regs.pc == p.regs.pc
    assert p.regs.pc != 0

    # try round-trip
    p.regs.rax = 0xdeadbeef
    assert p.regs.rax == 0xdeadbeef

    p.regs.xmm0 = 0xdeadbeefdeadbeefdeadbeefdeadbeef
    assert p.regs.xmm0 == 0xdeadbeefdeadbeefdeadbeefdeadbeef

    print("success")



p.hook(e.symbols["main"], main_hook)
p.run()
```

`tests/test_segv.c`:

```c
#include <stdio.h>

void segfault() {
    *(volatile int*)0 = 0;
}

int main() {
    printf("Hello, World!\n");
    segfault();
    return 0;
}
```

`tests/test_segv.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

excepted = False
try:
    p.run()
except FatalSignalError as err:
    assert err.args[0] is not None
    excepted = True
    
    print(err)

assert excepted

print("Exception 1")

# Now, after the exception, redirect execution to main again
p.regs.pc = e.symbols["main"]
excepted = False
try:
    p.run()
except FatalSignalError as err:
    assert err.args[0] is not None
    excepted = True

    print(err)

assert excepted

print("Exception 2")

# Finally, let's try calling out to the function as a callable
excepted = False
try:
    p.callable(e.symbols["segfault"])()
except FatalSignalError as err:
    assert err.args[0] is not None
    excepted = True

    print(err)

assert excepted

print("Exception 3")

p.regs.rsp += 0x18
p.regs.pc = e.symbols["main"] + 0x26
p.run()
print("pass")
```

`tests/test_syscall.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, platform

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                if 0 in data:
                    return str(data[:data.index(0)])
                else:
                    return str(data[:20]) + "..."

        except Exception as e:
            pass

    return hex(x)

def syscall_pre_hook_x86(p, num):
    print(f"[tid {p.tid}] [pre syscall {num}] (" + ", ".join([
        f"rdi={guess_arg(p.regs.rdi)}",
        f"rsi={guess_arg(p.regs.rsi)}",
        f"rdx={guess_arg(p.regs.rdx)}",
        f"rcx={guess_arg(p.regs.rcx)}",
    ]) + ")")

def syscall_pre_hook_arm64(p, num):
    print(f"[tid {p.tid}] [pre syscall {num}] (" + ", ".join([
        f"x0={guess_arg(p.regs.x0)}",
        f"x1={guess_arg(p.regs.x1)}",
        f"x2={guess_arg(p.regs.x2)}",
        f"x3={guess_arg(p.regs.x3)}",
    ]) + ")")

def syscall_post_hook(p, num):
    print(f"[tid {p.tid}] [post syscall {num}]")

syscall_pre_hook = syscall_pre_hook_arm64 if platform.machine() == "aarch64" else syscall_pre_hook_x86

for snum in range(500):
    p.syscall_pre(snum, syscall_pre_hook)

for snum in range(500):
    p.syscall_post(snum, syscall_post_hook)

p.run()

```

`tests/test_thread_blocking.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
from pwnlib.util.fiddling import hexdump
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def thread_entry(p):
    print("Thread entry")
    try:
        while True:
            p.run_until(e.symbols["malloc"])
            print(f"[thread {p.tid}] malloc")
    except ThreadExitError:
        print("thread exit error")
        pass

p.set_thread_entry(thread_entry)
p.run()
print("pass")
```

`tests/thread_10.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREAD 10

void* thread(void* arg) {
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
}
int main(int argc, char** argv) {
    pthread_t threads[NTHREAD];
    for (int i=0; i<NTHREAD; i++) {
        pthread_create(&threads[i], 0, thread, 0);
    }

    for (int i=0; i<NTHREAD; i++) {
        void *ret;
        pthread_join(threads[i], &ret);
    }

    // thread(NULL);
    return 0;
}
```

`tests/thread_1000.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREAD 1000

void* thread(void* arg) {
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
}
int main(int argc, char** argv) {
    pthread_t threads[NTHREAD];
    for (int i=0; i<NTHREAD; i++) {
        pthread_create(&threads[i], 0, thread, 0);
    }

    for (int i=0; i<NTHREAD; i++) {
        void *ret;
        pthread_join(threads[i], &ret);
    }

    // thread(NULL);
    return 0;
}
```

`tests/thread_nojoin.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREAD 1000

void* thread(void* arg) {
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
}
int main(int argc, char** argv) {
    pthread_t threads[NTHREAD];
    for (int i=0; i<NTHREAD; i++) {
        pthread_create(&threads[i], 0, thread, 0);
    }

    // thread(NULL);
    return 0;
}
```