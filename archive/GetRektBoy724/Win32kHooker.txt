Project Path: arc_GetRektBoy724_Win32kHooker_2jfsb43p

Source Tree:

```txt
arc_GetRektBoy724_Win32kHooker_2jfsb43p
├── README.md
├── Win32kHooker
│   ├── Hde64
│   │   ├── hde64.cpp
│   │   ├── hde64.h
│   │   ├── pstdint.h
│   │   └── table64.h
│   ├── Win32kHooker.inf
│   ├── Win32kHooker.vcxproj
│   ├── Win32kHooker.vcxproj.filters
│   ├── global.h
│   ├── hooker.cpp
│   ├── hooker.h
│   ├── main.cpp
│   └── utils.cpp
└── Win32kHooker.sln

```

`README.md`:

```md
# Win32kHooker

Win32kHooker is a Windows Kernel Driver that demonstrates how to locate and hook functions within `win32k.sys`.

Because `win32k.sys` is a session-space driver, it is not mapped into the system address space of every process. This driver overcomes this limitation by locating a GUI-capable process (e.g., `winlogon.exe`) and attaching to its address space to safely modify `win32k` memory.

## Mechanism

1.  **Process Identification**: Scans active processes to find `winlogon.exe`, which guarantees `win32k.sys` mapping.
2.  **Context Attachment**: Uses `KeStackAttachProcess` to switch the thread context to the target process.
3.  **Address Resolution**:
    *   Resolves the `W32GetSessionState` export.
    *   Locates `NtGdiBitBlt` by verifying syscall numbers in `win32u.dll` and the shadow SSDT.
4.  **Hook Implementation**: Utilizes the Hde64 disassembler to locate internal dispatch pointers within the target function and performs a pointer swap.

## Technical Distinction

This project addresses architectural changes in modern Windows versions compared to older `win32k` implementations.

*   **Legacy vs. Modern Storage**: Older versions of `win32k.sys` typically stored function pointers in global variables within the `.data` section. Newer versions, however, have moved these pointers into opaque session state structures.
*   **Dynamic Resolution**: Consequently, simple global pattern scans are no longer sufficient. This driver resolves the hook target relative to `W32GetSessionState`. It uses runtime disassembly to parse the `NtGdiBitBlt` instruction stream, dynamically extracting the exact offsets needed to traverse these opaque structures and locate the function pointer.

## Build Requirements

*   Visual Studio 2019 or later
*   Windows Driver Kit (WDK)

## Usage

1.  Enable test signing on the target machine:
    ```bash
    bcdedit /set testsigning on
    ```
2.  Build the solution in **Release/x64** configuration.
3.  Install and start the driver using the Service Control Manager:
    ```bash
    sc create Win32kHooker type= kernel binPath= "C:\path\to\Win32kHooker.sys"
    sc start Win32kHooker
    ```
4.  View hook output using a kernel debugger or DebugView.

```

`Win32kHooker.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36202.13 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Win32kHooker", "Win32kHooker\Win32kHooker.vcxproj", "{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Debug|ARM64.Build.0 = Debug|ARM64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Debug|x64.ActiveCfg = Debug|x64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Debug|x64.Build.0 = Debug|x64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Debug|x64.Deploy.0 = Debug|x64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Release|ARM64.ActiveCfg = Release|ARM64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Release|ARM64.Build.0 = Release|ARM64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Release|ARM64.Deploy.0 = Release|ARM64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Release|x64.ActiveCfg = Release|x64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Release|x64.Build.0 = Release|x64
		{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D46BAD28-F600-4303-BA7E-09443BBD5563}
	EndGlobalSection
EndGlobal

```

`Win32kHooker/Hde64/hde64.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */
 
 #include <ntifs.h>
 #include <ntdef.h>
 #include <ntddk.h>
 #include <wdm.h>
 #include <ntstatus.h>
 #include <ntimage.h>
 #include <ntstrsafe.h>
 #include <intrin.h>
 #include <intsafe.h>
 #include <evntrace.h>
 #include <wmistr.h>

#if defined(_M_X64) || defined(__x86_64__)
#pragma warning(push, 0)
#pragma warning(disable: 4701 4706 26451)

#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void* code, hde64s* hs)
{
	uint8_t x, c, * p = (uint8_t*)code, cflags, opcode, pref = 0;
	uint8_t* ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
	uint8_t op64 = 0;

	// Avoid using memset to reduce the footprint.
	memset(hs, 0, sizeof(hde64s));

	for (x = 16; x; x--)
		switch (c = *p++) {
		case 0xf3:
			hs->p_rep = c;
			pref |= PRE_F3;
			break;
		case 0xf2:
			hs->p_rep = c;
			pref |= PRE_F2;
			break;
		case 0xf0:
			hs->p_lock = c;
			pref |= PRE_LOCK;
			break;
		case 0x26: case 0x2e: case 0x36:
		case 0x3e: case 0x64: case 0x65:
			hs->p_seg = c;
			pref |= PRE_SEG;
			break;
		case 0x66:
			hs->p_66 = c;
			pref |= PRE_66;
			break;
		case 0x67:
			hs->p_67 = c;
			pref |= PRE_67;
			break;
		default:
			goto pref_done;
		}
pref_done:

	hs->flags = (uint32_t)pref << 23;

	if (!pref)
		pref |= PRE_NONE;

	if ((c & 0xf0) == 0x40) {
		hs->flags |= F_PREFIX_REX;
		if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
			op64++;
		hs->rex_r = (c & 7) >> 2;
		hs->rex_x = (c & 3) >> 1;
		hs->rex_b = c & 1;
		if (((c = *p++) & 0xf0) == 0x40) {
			opcode = c;
			goto error_opcode;
		}
	}

	if ((hs->opcode = c) == 0x0f) {
		hs->opcode2 = c = *p++;
		ht += DELTA_OPCODES;
	}
	else if (c >= 0xa0 && c <= 0xa3) {
		op64++;
		if (pref & PRE_67)
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = ht[ht[opcode / 4] + (opcode % 4)];

	if (cflags == C_ERROR) {
	error_opcode:
		hs->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ((opcode & -3) == 0x24)
			cflags++;
	}

	x = 0;
	if (cflags & C_GROUP) {
		uint16_t t;
		t = *(uint16_t*)(ht + (cflags & 0x7f));
		cflags = (uint8_t)t;
		x = (uint8_t)(t >> 8);
	}

	if (hs->opcode2) {
		ht = hde64_table + DELTA_PREFIXES;
		if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
			hs->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if (cflags & C_MODRM) {
		hs->flags |= F_MODRM;
		hs->modrm = c = *p++;
		hs->modrm_mod = m_mod = c >> 6;
		hs->modrm_rm = m_rm = c & 7;
		hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

		if (x && ((x << m_reg) & 0x80))
			hs->flags |= F_ERROR | F_ERROR_OPCODE;

		if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
			uint8_t t = opcode - 0xd9;
			if (m_mod == 3) {
				ht = hde64_table + DELTA_FPU_MODRM + t * 8;
				t = ht[m_reg] << m_rm;
			}
			else {
				ht = hde64_table + DELTA_FPU_REG;
				t = ht[t] << m_reg;
			}
			if (t & 0x80)
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if (pref & PRE_LOCK) {
			if (m_mod == 3) {
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			}
			else {
				uint8_t* table_end, op = opcode;
				if (hs->opcode2) {
					ht = hde64_table + DELTA_OP2_LOCK_OK;
					table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else {
					ht = hde64_table + DELTA_OP_LOCK_OK;
					table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}
				for (; ht != table_end; ht++)
					if (*ht++ == op) {
						if (!((*ht << m_reg) & 0x80))
							goto no_lock_error;
						else
							break;
					}
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			no_lock_error:
				;
			}
		}

		if (hs->opcode2) {
			switch (opcode) {
			case 0x20: case 0x22:
				m_mod = 3;
				if (m_reg > 4 || m_reg == 1)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x21: case 0x23:
				m_mod = 3;
				if (m_reg == 4 || m_reg == 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}
		else {
			switch (opcode) {
			case 0x8c:
				if (m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x8e:
				if (m_reg == 1 || m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}

		if (m_mod == 3) {
			uint8_t* table_end;
			if (hs->opcode2) {
				ht = hde64_table + DELTA_OP2_ONLY_MEM;
				table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
			}
			else {
				ht = hde64_table + DELTA_OP_ONLY_MEM;
				table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}
			for (; ht != table_end; ht += 2)
				if (*ht++ == opcode) {
					if (*ht++ & pref && !((*ht << m_reg) & 0x80))
						goto error_operand;
					else
						break;
				}
			goto no_error_operand;
		}
		else if (hs->opcode2) {
			switch (opcode) {
			case 0x50: case 0xd7: case 0xf7:
				if (pref & (PRE_NONE | PRE_66))
					goto error_operand;
				break;
			case 0xd6:
				if (pref & (PRE_F2 | PRE_F3))
					goto error_operand;
				break;
			case 0xc5:
				goto error_operand;
			}
			goto no_error_operand;
		}
		else
			goto no_error_operand;

	error_operand:
		hs->flags |= F_ERROR | F_ERROR_OPERAND;
	no_error_operand:

		c = *p++;
		if (m_reg <= 1) {
			if (opcode == 0xf6)
				cflags |= C_IMM8;
			else if (opcode == 0xf7)
				cflags |= C_IMM_P66;
		}

		switch (m_mod) {
		case 0:
			if (pref & PRE_67) {
				if (m_rm == 6)
					disp_size = 2;
			}
			else
				if (m_rm == 5)
					disp_size = 4;
			break;
		case 1:
			disp_size = 1;
			break;
		case 2:
			disp_size = 2;
			if (!(pref & PRE_67))
				disp_size <<= 1;
		}

		if (m_mod != 3 && m_rm == 4) {
			hs->flags |= F_SIB;
			p++;
			hs->sib = c;
			hs->sib_scale = c >> 6;
			hs->sib_index = (c & 0x3f) >> 3;
			if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
				disp_size = 4;
		}

		p--;
		switch (disp_size) {
		case 1:
			hs->flags |= F_DISP8;
			hs->disp.disp8 = *p;
			break;
		case 2:
			hs->flags |= F_DISP16;
			hs->disp.disp16 = *(uint16_t*)p;
			break;
		case 4:
			hs->flags |= F_DISP32;
			hs->disp.disp32 = *(uint32_t*)p;
		}
		p += disp_size;
	}
	else if (pref & PRE_LOCK)
		hs->flags |= F_ERROR | F_ERROR_LOCK;

	if (cflags & C_IMM_P66) {
		if (cflags & C_REL32) {
			if (pref & PRE_66) {
				hs->flags |= F_IMM16 | F_RELATIVE;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if (op64) {
			hs->flags |= F_IMM64;
			hs->imm.imm64 = *(uint64_t*)p;
			p += 8;
		}
		else if (!(pref & PRE_66)) {
			hs->flags |= F_IMM32;
			hs->imm.imm32 = *(uint32_t*)p;
			p += 4;
		}
		else
			goto imm16_ok;
	}

	if (cflags & C_IMM16) {
	imm16_ok:
		hs->flags |= F_IMM16;
		hs->imm.imm16 = *(uint16_t*)p;
		p += 2;
	}
	if (cflags & C_IMM8) {
		hs->flags |= F_IMM8;
		hs->imm.imm8 = *p++;
	}

	if (cflags & C_REL32) {
	rel32_ok:
		hs->flags |= F_IMM32 | F_RELATIVE;
		hs->imm.imm32 = *(uint32_t*)p;
		p += 4;
	}
	else if (cflags & C_REL8) {
		hs->flags |= F_IMM8 | F_RELATIVE;
		hs->imm.imm8 = *p++;
	}

disasm_done:

	if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15) {
		hs->flags |= F_ERROR | F_ERROR_LENGTH;
		hs->len = 15;
	}

	return (unsigned int)hs->len;
}

#pragma warning(pop)
#endif // defined(_M_X64) || defined(__x86_64__)
```

`Win32kHooker/Hde64/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`Win32kHooker/Hde64/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`Win32kHooker/Hde64/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`Win32kHooker/Win32kHooker.inf`:

```inf
;
; Win32kHooker.inf
;

[Version]
Signature   = "$WINDOWS NT$"
Class       = System ; TODO: specify appropriate Class
ClassGuid   = {4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider    = %ManufacturerName%
CatalogFile = Win32kHooker.cat
DriverVer   = ; TODO: set DriverVer in stampinf property pages
PnpLockdown = 1

[DestinationDirs]
DefaultDestDir = 13

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Win32kHooker.sys = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName% = Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299

[Standard.NT$ARCH$.10.0...16299]
%Win32kHooker.DeviceDesc% = Win32kHooker_Device, Root\Win32kHooker ; TODO: edit hw-id

[Win32kHooker_Device.NT]
CopyFiles = File_Copy

[File_Copy]
Win32kHooker.sys

;-------------- Service installation
[Win32kHooker_Device.NT.Services]
AddService = Win32kHooker,%SPSVCINST_ASSOCSERVICE%, Win32kHooker_Service_Inst

; -------------- Win32kHooker driver install sections
[Win32kHooker_Service_Inst]
DisplayName    = %Win32kHooker.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %13%\Win32kHooker.sys

[Win32kHooker_Device.NT.Wdf]
KmdfService = Win32kHooker, Win32kHooker_wdfsect

[Win32kHooker_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE = 0x00000002
ManufacturerName = "<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "Win32kHooker Installation Disk"
Win32kHooker.DeviceDesc = "Win32kHooker Device"
Win32kHooker.SVCDESC = "Win32kHooker Service"

```

`Win32kHooker/Win32kHooker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2B251D21-CA03-B91D-BC46-A25D39CCA6A9}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>Win32kHooker</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalDependencies>win32k.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>Disabled</Optimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Win32kHooker.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Hde64\hde64.cpp" />
    <ClCompile Include="hooker.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.h" />
    <ClInclude Include="Hde64\hde64.h" />
    <ClInclude Include="Hde64\pstdint.h" />
    <ClInclude Include="Hde64\table64.h" />
    <ClInclude Include="hooker.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Win32kHooker/Win32kHooker.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Header Files\HDE64">
      <UniqueIdentifier>{ee788284-cd2d-4aef-8958-40d84f9394a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\HDE64">
      <UniqueIdentifier>{05c98265-4de5-43e3-acc0-13c466374a14}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Win32kHooker.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooker.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hde64\hde64.cpp">
      <Filter>Source Files\HDE64</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooker.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hde64\hde64.h">
      <Filter>Header Files\HDE64</Filter>
    </ClInclude>
    <ClInclude Include="Hde64\pstdint.h">
      <Filter>Header Files\HDE64</Filter>
    </ClInclude>
    <ClInclude Include="Hde64\table64.h">
      <Filter>Header Files\HDE64</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Win32kHooker/global.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntdef.h>
#include <ntddk.h>
#include <wdm.h>
#include <ntstatus.h>
#include <ntimage.h>
#include <ntstrsafe.h>
#include <intrin.h>
#include <intsafe.h>
#include <windef.h>

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
    PVOID Unknown1;
    PVOID Unknown2;
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT NameLength;
    USHORT LoadCount;
    USHORT PathLength;
    CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG ulModuleCount;
    SYSTEM_MODULE_INFORMATION_ENTRY Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;                      // The address of the previous item plus the value in the NextEntryOffset member. For the last item in the array, NextEntryOffset is 0.
    ULONG NumberOfThreads;                      // The NumberOfThreads member contains the number of threads in the process.
    ULONGLONG WorkingSetPrivateSize;            // The total private memory that a process currently has allocated and is physically resident in memory. // since VISTA
    ULONG HardFaultCount;                       // The total number of hard faults for data from disk rather than from in-memory pages. // since WIN7
    ULONG NumberOfThreadsHighWatermark;         // The peak number of threads that were running at any given point in time, indicative of potential performance bottlenecks related to thread management.
    ULONGLONG CycleTime;                        // The sum of the cycle time of all threads in the process.
    LARGE_INTEGER CreateTime;                   // Number of 100-nanosecond intervals since the creation time of the process. Not updated during system timezone changes.
    LARGE_INTEGER UserTime;                     // Number of 100-nanosecond intervals the process has executed in user mode.
    LARGE_INTEGER KernelTime;                   // Number of 100-nanosecond intervals the process has executed in kernel mode.
    UNICODE_STRING ImageName;                   // The file name of the executable image.
    KPRIORITY BasePriority;                     // The starting priority of the process.
    HANDLE UniqueProcessId;                     // The identifier of the process.
    HANDLE InheritedFromUniqueProcessId;        // The identifier of the process that created this process. Not updated and incorrectly refers to processes with recycled identifiers.
    ULONG HandleCount;                          // The current number of open handles used by the process.
    ULONG SessionId;                            // The identifier of the Remote Desktop Services session under which the specified process is running.
    ULONG_PTR UniqueProcessKey;                 // since VISTA (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;                     // The peak size, in bytes, of the virtual memory used by the process.
    SIZE_T VirtualSize;                         // The current size, in bytes, of virtual memory used by the process.
    ULONG PageFaultCount;                       // The total number of page faults for data that is not currently in memory. The value wraps around to zero on average 24 hours.
    SIZE_T PeakWorkingSetSize;                  // The peak size, in kilobytes, of the working set of the process.
    SIZE_T WorkingSetSize;                      // The number of pages visible to the process in physical memory. These pages are resident and available for use without triggering a page fault.
    SIZE_T QuotaPeakPagedPoolUsage;             // The peak quota charged to the process for pool usage, in bytes.
    SIZE_T QuotaPagedPoolUsage;                 // The quota charged to the process for paged pool usage, in bytes.
    SIZE_T QuotaPeakNonPagedPoolUsage;          // The peak quota charged to the process for nonpaged pool usage, in bytes.
    SIZE_T QuotaNonPagedPoolUsage;              // The current quota charged to the process for nonpaged pool usage.
    SIZE_T PagefileUsage;                       // The total number of bytes of page file storage in use by the process.
    SIZE_T PeakPagefileUsage;                   // The maximum number of bytes of page-file storage used by the process.
    SIZE_T PrivatePageCount;                    // The number of memory pages allocated for the use by the process.
    LARGE_INTEGER ReadOperationCount;           // The total number of read operations performed.
    LARGE_INTEGER WriteOperationCount;          // The total number of write operations performed.
    LARGE_INTEGER OtherOperationCount;          // The total number of I/O operations performed other than read and write operations.
    LARGE_INTEGER ReadTransferCount;            // The total number of bytes read during a read operation.
    LARGE_INTEGER WriteTransferCount;           // The total number of bytes written during a write operation.
    LARGE_INTEGER OtherTransferCount;           // The total number of bytes transferred during operations other than read and write operations.
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

extern "C" {

    NTSTATUS NTAPI ZwQuerySystemInformation(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        PVOID SystemInformation,
        ULONG SystemInformationLength,
        PULONG ReturnLength
    );
}

PVOID GetModuleBase(const char* moduleName, PULONG moduleSize);
PVOID MapModuleFromKnownDll(PCWSTR dllName);
PVOID GetExportAddress(PVOID moduleBase, LPCSTR functionName);
PVOID GetWin32kSdtAddress();
bool GetWin32kSyscallNumber(PCSTR functionName, PDWORD syscallNumber);
PVOID GetWin32kSyscallRoutine(PVOID win32ksdt, LPCSTR syscallName, DWORD syscallNumber);
PVOID FindPattern(
    PVOID address,
    SIZE_T size,
    const char* pattern,
    const char* mask
);
PEPROCESS FindGUIProcess();
```

`Win32kHooker/hooker.cpp`:

```cpp
#include "hooker.h"

NtGdiBitBltPtr OriginalNtGdiBitBlt = NULL;
PVOID NtGdiBitBltPtrAddress = NULL;
PEPROCESS GuiProcess = NULL;

fptrW32GetSessionState GetW32GetSessionStateAddr() {
	PVOID win32kBase = GetModuleBase("win32k.sys", NULL);
	if (!win32kBase) {
		return nullptr;
	}
	PVOID pW32pGetSessionState = GetExportAddress(win32kBase, "W32GetSessionState");
	if (!pW32pGetSessionState) {
		return nullptr;
	}
	return (fptrW32GetSessionState)(pW32pGetSessionState);
}

PVOID GetSessionState() {
	fptrW32GetSessionState GetSessionState = (fptrW32GetSessionState)(GetW32GetSessionStateAddr());

	if (!GetSessionState) {
		return nullptr;
	}

	// attach to GUI process
	KAPC_STATE apcState = { 0 };
	KeStackAttachProcess(GuiProcess, &apcState);
	PVOID output = GetSessionState();
	KeUnstackDetachProcess(&apcState);

	return output;
}

BOOL ResolveWin32kDataPtr(LPCSTR functionName, PDWORD64 DataPtrAddr, PDWORD64 FuncPtr) {
	PVOID Win32kSdt = GetWin32kSdtAddress();
	if (!Win32kSdt) {
		return FALSE;
	}
	PBYTE pFunction = (PBYTE)GetWin32kSyscallRoutine(Win32kSdt, functionName, 0);
	if (!pFunction) {
		return FALSE;
	}
	PVOID SessionStateAddr = GetSessionState();
	if (!SessionStateAddr) {
		return FALSE;
	}
	
#define IS_MOV_DEREF(hs) \
    ((hs).opcode == 0x8B && \
    ((hs).flags & F_MODRM) && \
    (((hs).modrm & 0xC0) != 0xC0))

    // Extract: Check Flag 32 -> return disp32; Else check Flag 8 -> return sign_extended(disp8); Else 0
#define GET_DISP(hs) \
    (((hs).flags & F_DISP32) ? (int32_t)(hs).disp.disp32 : \
    (((hs).flags & F_DISP8)  ? (int32_t)(int8_t)(hs).disp.disp8 : 0))

	// pattern scanning
	//PBYTE DataPtr = (PBYTE)FindPattern(pFunction, 0x50, "\xe8\x00\x00\x00\x00\x4c\x8b\x90\x00\x00\x00\x00\x49\x8b\x82\x00\x00\x00\x00\x48\x8b\x40\x00", "x????xxx????xxx????xxx?");
	hde64s hs{};
    uint8_t* current = pFunction;
    uint8_t* end = current + 0x50;
	DWORD foundOffsets[3] = { 0 };
	BOOL found = FALSE;
	
    while (current < end) {
        unsigned int len = hde64_disasm(current, &hs);
        if (hs.flags & F_ERROR) {
            current++;
            continue;
        }

        // 1. Check for CALL (0xE8)
        if (hs.opcode == 0xE8) {

            uint8_t* scanner = current + len;
            hde64s hs_next;

            int32_t temp_offsets[3] = { 0 };
            bool sequence_match = true;

            // 2. Check for 3 consecutive MOV instructions with dereferences
            for (int i = 0; i < 3; i++) {
                hde64_disasm(scanner, &hs_next);

                if (IS_MOV_DEREF(hs_next)) {
                    foundOffsets[i] = GET_DISP(hs_next);
                    scanner += hs_next.len;
                }
                else {
                    sequence_match = false;
                    break;
                }
            }

            // 3. Check for TEST (0x85)
            if (sequence_match) {
                hde64_disasm(scanner, &hs_next);
                if (hs_next.opcode == 0x85) {
					found = TRUE;
					break;
				}
				else {
					// reset foundOffsets
					memset(foundOffsets, 0, sizeof(foundOffsets));
				}
            }
        }

        current += len;
    }

#undef IS_MOV_DEREF
#undef GET_DISP

	if (DataPtrAddr) *DataPtrAddr = (*(PDWORD64)(*(PDWORD64)((DWORD64)SessionStateAddr + foundOffsets[0]) + foundOffsets[1]) + foundOffsets[2]);
	if (FuncPtr) *FuncPtr = (DWORD64)(*(PDWORD64)(*(PDWORD64)(*(PDWORD64)((DWORD64)SessionStateAddr + foundOffsets[0]) + foundOffsets[1]) + foundOffsets[2]));

	return found;
}

BOOL HookedNtGdiBitBlt(
	HDC hdcDst,
	INT x,
	INT y,
	INT cx,
	INT cy,
	HDC hdcSrc,
	INT xSrc,
	INT ySrc,
	DWORD rop4,
	DWORD crBackColor,
	FLONG fl
) {
	DbgPrintEx(0, 0, "[*] NtGdiBitBlt hook function called!\n");
	// Call the original function
	return OriginalNtGdiBitBlt(
		hdcDst,
		x,
		y,
		cx,
		cy,
		hdcSrc,
		xSrc,
		ySrc,
		rop4,
		crBackColor,
		fl
	);
}

BOOL InitializeHooker() {
	GuiProcess = FindGUIProcess();
	if (!GuiProcess) {
		DbgPrintEx(0, 0, "[-] Failed to find GUI process!\n");
		return FALSE;
	}
	DWORD64 pSessionState = (DWORD64)GetSessionState();
	if (!pSessionState) {
		DbgPrintEx(0, 0, "[-] Failed to get Session State address!\n");
		return FALSE;
	}

	if (!ResolveWin32kDataPtr("NtGdiBitBlt", (PDWORD64)&NtGdiBitBltPtrAddress, (PDWORD64)&OriginalNtGdiBitBlt)) {
		DbgPrintEx(0, 0, "[-] Failed to resolve NtGdiBitBlt pointer!\n");
		return FALSE;
	}

	DbgPrintEx(0, 0, "[+] Data pointer address : 0x%p, NtGdiBitBlt function pointer address : 0x%p. Hooking...\n", NtGdiBitBltPtrAddress, OriginalNtGdiBitBlt);

	*(PDWORD64)NtGdiBitBltPtrAddress = (DWORD64)HookedNtGdiBitBlt;

	DbgPrintEx(0, 0, "[+] NtGdiBitBlt hooked successfully!\n");
	
	return TRUE;
}

BOOL RemoveHooker() {
	if (NtGdiBitBltPtrAddress && OriginalNtGdiBitBlt) {
		*(PDWORD64)NtGdiBitBltPtrAddress = (DWORD64)OriginalNtGdiBitBlt;
		DbgPrintEx(0, 0, "[+] NtGdiBitBlt hook removed successfully!\n");
		return TRUE;
	}
	return FALSE;
}
```

`Win32kHooker/hooker.h`:

```h
#pragma once
#include "global.h"
#include "Hde64/hde64.h"

typedef PVOID(NTAPI* fptrW32GetSessionState)();
typedef BOOL(NTAPI* NtGdiBitBltPtr)(HDC hdcDst, INT x, INT y, INT cx, INT cy, HDC hdcSrc, INT xSrc, INT ySrc, DWORD rop4, DWORD crBackColor, FLONG fl);

extern NtGdiBitBltPtr OriginalNtGdiBitBlt;
extern PVOID NtGdiBitBltPtrAddress;
extern PEPROCESS GuiProcess;

BOOL HookedNtGdiBitBlt(
	HDC hdcDst,
	INT x,
	INT y,
	INT cx,
	INT cy,
	HDC hdcSrc,
	INT xSrc,
	INT ySrc,
	DWORD rop4,
	DWORD crBackColor,
	FLONG fl
);

fptrW32GetSessionState GetW32GetSessionStateAddr();
PVOID GetSessionState();
BOOL ResolveWin32kDataPtr(LPCSTR functionName, PDWORD64 DataPtrAddr, PDWORD64 FuncPtr);
BOOL InitializeHooker();
BOOL RemoveHooker();
```

`Win32kHooker/main.cpp`:

```cpp
#include "hooker.h"

extern "C" VOID DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject
) {
    UNREFERENCED_PARAMETER(DriverObject);
    RemoveHooker();
}

extern "C" NTSTATUS DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
) {
    UNREFERENCED_PARAMETER(RegistryPath);

	DriverObject->DriverUnload = DriverUnload;

    InitializeHooker();
	return STATUS_UNSUCCESSFUL;
}
```

`Win32kHooker/utils.cpp`:

```cpp
#include "global.h"

PVOID GetModuleBase(const char* moduleName, PULONG moduleSize = nullptr) {
    if (!moduleName) {
        return nullptr;
    }

    ULONG bufferSize = 0;
    NTSTATUS status = ZwQuerySystemInformation(
        SystemModuleInformation,
        &bufferSize,
        0,
        &bufferSize
    );

    if (bufferSize == 0) {
        return nullptr;
    }

    auto* moduleInfo = static_cast<SYSTEM_MODULE_INFORMATION*>(
        ExAllocatePool2(POOL_FLAG_NON_PAGED, bufferSize, 'w32h')
        );

    if (!moduleInfo) {
        return nullptr;
    }

    status = ZwQuerySystemInformation(
        SystemModuleInformation,
        moduleInfo,
        bufferSize,
        nullptr
    );

    PVOID moduleBase = nullptr;

    if (NT_SUCCESS(status)) {
        for (ULONG i = 0; i < moduleInfo->ulModuleCount; i++) {
            const auto* entry = &moduleInfo->Modules[i];

            if (strstr(entry->ImageName, moduleName)) {
                moduleBase = entry->Base;
                if (moduleSize) {
                    *moduleSize = entry->Size;
                }
                break;
            }
        }
    }

    ExFreePoolWithTag(moduleInfo, 'w32h');
    return moduleBase;
}


PVOID MapModuleFromKnownDll(PCWSTR dllName) {
    if (!dllName) {
        return nullptr;
    }

    constexpr WCHAR kKnownDllsPrefix[] = L"\\KnownDlls\\";
    WCHAR fullPath[MAX_PATH]{};

    wcscpy_s(fullPath, kKnownDllsPrefix);
    wcscat_s(fullPath, dllName);

    UNICODE_STRING uniStr{};
    RtlInitUnicodeString(&uniStr, fullPath);

    OBJECT_ATTRIBUTES objAttr{};
    InitializeObjectAttributes(
        &objAttr,
        &uniStr,
        OBJ_CASE_INSENSITIVE,
        nullptr,
        nullptr
    );

    HANDLE hSection = nullptr;
    NTSTATUS status = ZwOpenSection(
        &hSection,
        SECTION_MAP_READ | SECTION_MAP_EXECUTE,
        &objAttr
    );

    if (!NT_SUCCESS(status) || !hSection) {
        return nullptr;
    }

    PVOID moduleBase = nullptr;
    SIZE_T viewSize = 0;

    status = ZwMapViewOfSection(
        hSection,
        reinterpret_cast<HANDLE>(-1),
        &moduleBase,
        0,
        viewSize,
        nullptr,
        &viewSize,
        ViewUnmap,
        0,
        PAGE_READONLY
    );

    ZwClose(hSection);

    if (!NT_SUCCESS(status)) {
        return nullptr;
    }

    return moduleBase;
}

PVOID GetExportAddress(PVOID moduleBase, LPCSTR functionName) {
    if (!moduleBase || !functionName) {
        return nullptr;
    }

    const auto* dosHeader = static_cast<PIMAGE_DOS_HEADER>(moduleBase);
    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return nullptr;
    }

    const SIZE_T moduleBaseAddr = reinterpret_cast<SIZE_T>(moduleBase);
    const SIZE_T peHeaderOffset = static_cast<SIZE_T>(
        *reinterpret_cast<PDWORD>(moduleBaseAddr + 0x3C)
        );

    const SIZE_T optHeaderAddr = moduleBaseAddr + peHeaderOffset + 0x18;
    const WORD magic = *reinterpret_cast<PWORD>(optHeaderAddr);

    SIZE_T dataDirectoryAddr = 0;
    if (magic == 0x10B) { // PE32
        dataDirectoryAddr = optHeaderAddr + 0x60;
    }
    else if (magic == 0x20B) { // PE32+
        dataDirectoryAddr = optHeaderAddr + 0x70;
    }
    else {
        return nullptr;
    }

    const SIZE_T exportRva = static_cast<SIZE_T>(
        *reinterpret_cast<PDWORD>(dataDirectoryAddr)
        );
    const SIZE_T exportBase = moduleBaseAddr + exportRva;

    const DWORD ordinalBase = *reinterpret_cast<PDWORD>(exportBase + 0x10);
    const DWORD numberOfNames = *reinterpret_cast<PDWORD>(exportBase + 0x18);
    const SIZE_T functionsRva = static_cast<SIZE_T>(
        *reinterpret_cast<PDWORD>(exportBase + 0x1C)
        );
    const SIZE_T namesRva = static_cast<SIZE_T>(
        *reinterpret_cast<PDWORD>(exportBase + 0x20)
        );
    const SIZE_T ordinalsRva = static_cast<SIZE_T>(
        *reinterpret_cast<PDWORD>(exportBase + 0x24)
        );

    for (DWORD i = 0; i < numberOfNames; i++) {
        const SIZE_T nameRvaAddr = moduleBaseAddr + namesRva + (static_cast<SIZE_T>(i) * 4);
        const SIZE_T functionNameRva = static_cast<SIZE_T>(
            *reinterpret_cast<PDWORD>(nameRvaAddr)
            );
        const auto* currentName = reinterpret_cast<PCHAR>(moduleBaseAddr + functionNameRva);

        if (strcmp(currentName, functionName) == 0) {
            const SIZE_T ordinalAddr = moduleBaseAddr + ordinalsRva + (static_cast<SIZE_T>(i) * 2);
            const WORD functionOrdinal = *reinterpret_cast<PWORD>(ordinalAddr) +
                static_cast<WORD>(ordinalBase);

            const SIZE_T functionRvaAddr = moduleBaseAddr + functionsRva +
                (static_cast<SIZE_T>(4) * (functionOrdinal - ordinalBase));
            const SIZE_T functionRva = static_cast<SIZE_T>(
                *reinterpret_cast<PDWORD>(functionRvaAddr)
                );

            return reinterpret_cast<PVOID>(moduleBaseAddr + functionRva);
        }
    }

    return nullptr;
}

PVOID GetWin32kSdtAddress() {
    PVOID win32kAddr = GetModuleBase("win32k.sys");
    return GetExportAddress(win32kAddr, "W32pServiceTable");
}

bool GetWin32kSyscallNumber(PCSTR functionName, PDWORD syscallNumber) {
    if (!functionName || !syscallNumber) {
        return false;
    }

    if (_strnicmp(functionName, "Nt", 2)) {
        return false;
    }

    PVOID ntdllBase = MapModuleFromKnownDll(L"win32u.dll");
    if (!ntdllBase) {
        return false;
    }

    PVOID functionAddr = GetExportAddress(ntdllBase, functionName);
    if (!functionAddr) {
        ZwUnmapViewOfSection(reinterpret_cast<HANDLE>(-1), ntdllBase);
        return false;
    }

    // Check for "mov eax, imm32" instruction (B8 XX XX XX XX)
    constexpr UCHAR kMovEaxOpcode = 0xB8;
    constexpr size_t kMovEaxOpcodeOffset = 3;
    constexpr size_t kSyscallNumberOffset = 4;

    const auto* functionBytes = static_cast<PUCHAR>(functionAddr);
    if (functionBytes[kMovEaxOpcodeOffset] == kMovEaxOpcode) {
        *syscallNumber = *reinterpret_cast<PDWORD>(
            reinterpret_cast<SIZE_T>(functionAddr) + kSyscallNumberOffset
            );
        ZwUnmapViewOfSection(reinterpret_cast<HANDLE>(-1), ntdllBase);
        return true;
    }

    ZwUnmapViewOfSection(reinterpret_cast<HANDLE>(-1), ntdllBase);
    return false;
}

PVOID GetWin32kSyscallRoutine(PVOID win32ksdt, LPCSTR syscallName, DWORD syscallNumber) {
    // Validate inputs
    if (syscallName) {
        if (_strnicmp(syscallName, "Nt", 2)) {
            return nullptr;
        }

        // If name provided but no number, resolve number
        if (!syscallNumber) {
            if (!GetWin32kSyscallNumber(syscallName, &syscallNumber)) {
                return nullptr;
            }
        }
    }

    LONG routineOffset = *(PLONG)((DWORD64)win32ksdt + ((syscallNumber & 0xFFF) * 4));

    return (PVOID)((LONGLONG)win32ksdt + ((LONGLONG)((DWORD)routineOffset >> 4) | 0xFFFFFFFFF0000000));
}

bool PatternCheck(const char* data, const char* pattern, const char* mask) {
    size_t length = strlen(mask);

    for (size_t i = 0; i < length; i++) {
        if (mask[i] == '?') {
            continue;
        }
        if (data[i] != pattern[i]) {
            return false;
        }
    }

    return true;
}

PVOID FindPattern(
    PVOID address,
    SIZE_T size,
    const char* pattern,
    const char* mask
) {
    if (!address || !pattern || !mask) {
        return nullptr;
    }

    SIZE_T maskLength = strlen(mask);
    if (size < maskLength) {
        return nullptr;
    }

    size -= maskLength;

    for (SIZE_T i = 0; i < size; i++) {
        if (PatternCheck((const char*)((ULONG_PTR)address + i), pattern, mask)) {
            return (PVOID)((ULONG_PTR)address + i);
        }
    }

    return nullptr;
}

PEPROCESS FindGUIProcess() {
    NTSTATUS status;
    PVOID buffer = NULL;
    ULONG bufferSize = 0;
    PEPROCESS hProcess = NULL;

    // 1. Initial size estimate (e.g., 64KB). 
    // It will likely be too small, but the loop handles re-allocation.
    bufferSize = 64 * 1024;

    while (TRUE) {
        // Allocate from PagedPool (Processes info is safe in PagedPool at PASSIVE_LEVEL)
        buffer = ExAllocatePool2(POOL_FLAG_PAGED, bufferSize, 'Proc');
        if (!buffer) {
            return NULL;
        }

        // Query the process list
        ULONG requiredSize = 0;
        status = ZwQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &requiredSize);

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            // Buffer too small, free and try again with the required size + margin
            ExFreePool(buffer);
            bufferSize = requiredSize + (4 * 1024); // Add 4k padding for safety as processes change rapidly
        }
        else {
            // Success or fatal error
            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        if (buffer) ExFreePool(buffer);
        return NULL;
    }

    // 2. Iterate the list
    PSYSTEM_PROCESS_INFORMATION pInfo = (PSYSTEM_PROCESS_INFORMATION)buffer;
    UNICODE_STRING targetName;
    RtlInitUnicodeString(&targetName, L"winlogon.exe");

    while (TRUE) {
        // Check if ImageName matches "explorer.exe"
        // Note: ImageName can be NULL for System Idle Process
        if (pInfo->ImageName.Buffer && RtlEqualUnicodeString(&pInfo->ImageName, &targetName, TRUE)) {

            // Found it! Get the PEPROCESS from the PID.
            // PsLookupProcessByProcessId increments the reference count automatically.
            status = PsLookupProcessByProcessId(pInfo->UniqueProcessId, &hProcess);
            if (NT_SUCCESS(status)) {
                // Break the loop, we have our object.
                // If you want a specific session's explorer, check pInfo->SessionId here.
                break;
            }
        }

        // Move to next entry
        if (pInfo->NextEntryOffset == 0) break;
        pInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)pInfo + pInfo->NextEntryOffset);
    }

    // 3. Cleanup
    ExFreePool(buffer);

    return hProcess; // Returns NULL if not found, or a valid PEPROCESS pointer
}
```