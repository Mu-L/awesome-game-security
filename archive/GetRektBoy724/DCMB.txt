Project Path: arc_GetRektBoy724_DCMB_c86rphbg

Source Tree:

```txt
arc_GetRektBoy724_DCMB_c86rphbg
├── DCMB
│   ├── DCMB.LOG
│   ├── DCMB.inf
│   ├── DCMB.sln
│   ├── DCMB.vcxproj
│   ├── DCMB.vcxproj.filters
│   ├── dcmb.c
│   ├── dcmb.h
│   ├── main.c
│   ├── main.h
│   ├── minifilters.c
│   └── minifilters.h
└── README.md

```

`DCMB/DCMB.LOG`:

```LOG
00000001	0.00000000	DCMB said Hello from the kernel!	
00000002	0.00003970	[DCMB] Kernel base address : 0xFFFFF80340E00000	
00000003	0.00004280	[DCMB] Load image callback array address : 0xFFFFF80341AEC020	
00000004	0.00006000	   [DCMB] Load Image : WdFilter.sys+0x4e260 = 0xFFFFF8034577E260	
00000005	0.00007350	   [DCMB] Load Image : ahcache.sys+0x1eb20 = 0xFFFFF803473BEB20	
00000006	0.00008640	   [DCMB] Load Image : MpKslDrv.sys+0xbf40 = 0xFFFFF803556EBF40	
00000007	0.00008920	[DCMB] Process creation callback array address : 0xFFFFF80341AEC420	
00000008	0.00010400	   [DCMB] Process Creation : ntoskrnl.exe+0x35c050 = 0xFFFFF8034115C050	
00000009	0.00011700	   [DCMB] Process Creation : cng.sys+0x6dd0 = 0xFFFFF80344EF6DD0	
00000010	0.00012980	   [DCMB] Process Creation : WdFilter.sys+0x4d7b0 = 0xFFFFF8034577D7B0	
00000011	0.00014260	   [DCMB] Process Creation : ksecdd.sys+0x1ba40 = 0xFFFFF8033F81BA40	
00000012	0.00016440	   [DCMB] Process Creation : tcpip.sys+0x4cc0 = 0xFFFFF80345D44CC0	
00000013	0.00017800	   [DCMB] Process Creation : iorate.sys+0xd930 = 0xFFFFF803462DD930	
00000014	0.00019070	   [DCMB] Process Creation : CI.dll+0x7de20 = 0xFFFFF80344E7DE20	
00000015	0.00020350	   [DCMB] Process Creation : dxgkrnl.sys+0x66a0 = 0xFFFFF803468066A0	
00000016	0.00021640	   [DCMB] Process Creation : peauth.sys+0x43ce0 = 0xFFFFF80354EA3CE0	
00000017	0.00022930	   [DCMB] Process Creation : MpKslDrv.sys+0xc150 = 0xFFFFF803556EC150	
00000018	0.00023110	[DCMB] Thread creation callback array address : 0xFFFFF80341AEC220	
00000019	0.00024530	   [DCMB] Thread Creation : WdFilter.sys+0x4f040 = 0xFFFFF8034577F040	
00000020	0.00025810	   [DCMB] Thread Creation : WdFilter.sys+0x4eda0 = 0xFFFFF8034577EDA0	
00000021	0.00027200	   [DCMB] Thread Creation : mmcss.sys+0x1060 = 0xFFFFF80354E11060	
00000022	0.00028710	   [DCMB] Thread Creation : MpKslDrv.sys+0xbff0 = 0xFFFFF803556EBFF0	
00000023	0.00030020	   [DCMB] Thread Creation : MpKslDrv.sys+0xc0a0 = 0xFFFFF803556EC0A0	
00000024	0.00030340	[DCMB] Registry RW callback list head address : 0xFFFFF80341A482A0	
00000025	0.00032830	   [DCMB] Registry Read/Write : WdFilter.sys+0x3d910 = 0xFFFFF8034576D910	
00000026	0.00034120	   [DCMB] Registry Read/Write : ntoskrnl.exe+0x5cc3d0 = 0xFFFFF803413CC3D0	
00000027	0.00052670	[DCMB] PsProcessType object callback list address : 0xFFFFC20846C9A188	
00000028	0.00083500	[DCMB] PsThreadType object callback list address : 0xFFFFC20846CB4F48	
00000029	27.07218170	DCMB said Goodbye!	
00000030	41.38167953	DCMB said Hello from the kernel!	
00000031	41.38172150	[DCMB] Kernel base address : 0xFFFFF80340E00000	
00000032	41.38172531	[DCMB] Load image callback array address : 0xFFFFF80341AEC020	
00000033	41.38174057	   [DCMB] Load Image : WdFilter.sys+0x4e260 = 0xFFFFF8034577E260	
00000034	41.38175201	   [DCMB] Load Image : ahcache.sys+0x1eb20 = 0xFFFFF803473BEB20	
00000035	41.38176727	   [DCMB] Load Image : MpKslDrv.sys+0xbf40 = 0xFFFFF803556EBF40	
00000036	41.38177109	[DCMB] Process creation callback array address : 0xFFFFF80341AEC420	
00000037	41.38178253	   [DCMB] Process Creation : ntoskrnl.exe+0x35c050 = 0xFFFFF8034115C050	
00000038	41.38179398	   [DCMB] Process Creation : cng.sys+0x6dd0 = 0xFFFFF80344EF6DD0	
00000039	41.38180923	   [DCMB] Process Creation : WdFilter.sys+0x4d7b0 = 0xFFFFF8034577D7B0	
00000040	41.38181686	   [DCMB] Process Creation : ksecdd.sys+0x1ba40 = 0xFFFFF8033F81BA40	
00000041	41.38183212	   [DCMB] Process Creation : tcpip.sys+0x4cc0 = 0xFFFFF80345D44CC0	
00000042	41.38184357	   [DCMB] Process Creation : iorate.sys+0xd930 = 0xFFFFF803462DD930	
00000043	41.38185501	   [DCMB] Process Creation : CI.dll+0x7de20 = 0xFFFFF80344E7DE20	
00000044	41.38187027	   [DCMB] Process Creation : dxgkrnl.sys+0x66a0 = 0xFFFFF803468066A0	
00000045	41.38188171	   [DCMB] Process Creation : peauth.sys+0x43ce0 = 0xFFFFF80354EA3CE0	
00000046	41.38189316	   [DCMB] Process Creation : MpKslDrv.sys+0xc150 = 0xFFFFF803556EC150	
00000047	41.38189316	[DCMB] Thread creation callback array address : 0xFFFFF80341AEC220	
00000048	41.38190842	   [DCMB] Thread Creation : WdFilter.sys+0x4f040 = 0xFFFFF8034577F040	
00000049	41.38191986	   [DCMB] Thread Creation : WdFilter.sys+0x4eda0 = 0xFFFFF8034577EDA0	
00000050	41.38193130	   [DCMB] Thread Creation : mmcss.sys+0x1060 = 0xFFFFF80354E11060	
00000051	41.38194656	   [DCMB] Thread Creation : MpKslDrv.sys+0xbff0 = 0xFFFFF803556EBFF0	
00000052	41.38195801	   [DCMB] Thread Creation : MpKslDrv.sys+0xc0a0 = 0xFFFFF803556EC0A0	
00000053	41.38196182	[DCMB] Registry RW callback list head address : 0xFFFFF80341A482A0	
00000054	41.38198853	   [DCMB] Registry Read/Write : WdFilter.sys+0x3d910 = 0xFFFFF8034576D910	
00000055	41.38199997	   [DCMB] Registry Read/Write : ntoskrnl.exe+0x5cc3d0 = 0xFFFFF803413CC3D0	
00000056	41.38224792	[DCMB] PsProcessType object callback list address : 0xFFFFC20846C9A188	
00000057	41.38260651	[DCMB] PsThreadType object callback list address : 0xFFFFC20846CB4F48	

```

`DCMB/DCMB.inf`:

```inf
;
; DCMB.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=DCMB.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
DCMB_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
DCMB.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%DCMB.DeviceDesc%=DCMB_Device, Root\DCMB ; TODO: edit hw-id

[DCMB_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
DCMB.sys

;-------------- Service installation
[DCMB_Device.NT.Services]
AddService = DCMB,%SPSVCINST_ASSOCSERVICE%, DCMB_Service_Inst

; -------------- DCMB driver install sections
[DCMB_Service_Inst]
DisplayName    = %DCMB.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\DCMB.sys

;
;--- DCMB_Device Coinstaller installation ------
;

[DCMB_Device.NT.CoInstallers]
AddReg=DCMB_Device_CoInstaller_AddReg
CopyFiles=DCMB_Device_CoInstaller_CopyFiles

[DCMB_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[DCMB_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[DCMB_Device.NT.Wdf]
KmdfService =  DCMB, DCMB_wdfsect
[DCMB_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "DCMB Installation Disk"
DCMB.DeviceDesc = "DCMB Device"
DCMB.SVCDESC = "DCMB Service"

```

`DCMB/DCMB.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DCMB", "DCMB.vcxproj", "{4219D039-E160-44B6-8E76-35AC6D4EACF3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Debug|ARM64.Build.0 = Debug|ARM64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Debug|x64.ActiveCfg = Debug|x64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Debug|x64.Build.0 = Debug|x64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Debug|x64.Deploy.0 = Debug|x64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Release|ARM64.ActiveCfg = Release|ARM64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Release|ARM64.Build.0 = Release|ARM64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Release|ARM64.Deploy.0 = Release|ARM64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Release|x64.ActiveCfg = Release|x64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Release|x64.Build.0 = Release|x64
		{4219D039-E160-44B6-8E76-35AC6D4EACF3}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7574EAD9-800E-47E6-A8E5-99595B1A62DF}
	EndGlobalSection
EndGlobal

```

`DCMB/DCMB.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4219D039-E160-44B6-8E76-35AC6D4EACF3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>DCMB</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
    <Link>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="DCMB.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dcmb.h" />
    <ClInclude Include="main.h" />
    <ClInclude Include="minifilters.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dcmb.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="minifilters.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DCMB/DCMB.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DCMB.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dcmb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minifilters.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dcmb.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minifilters.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DCMB/dcmb.c`:

```c
#include "dcmb.h"

PCHAR DcmbGetBaseNameFromFullName(PCHAR FullName) {
	SIZE_T FullNameLength = strlen(FullName);

	for (SIZE_T i = FullNameLength; i > 0; i--) {
		if (*(FullName + i) == '\\') {
			return FullName + i + 1;
		}
	}

	return NULL;
}

DWORD64 DcmbGetKernelBase() {
	PRTL_PROCESS_MODULES ModuleInformation = NULL;
	NTSTATUS result;
	ULONG SizeNeeded;
	SIZE_T InfoRegionSize;
	DWORD64 output = 0;
	PROTOTYPE_ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;
	UNICODE_STRING ZWQSIName;

	RtlInitUnicodeString(&ZWQSIName, L"ZwQuerySystemInformation");
	ZwQuerySystemInformation = (PROTOTYPE_ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&ZWQSIName);

	// get info size
	result = ZwQuerySystemInformation(0x0B, NULL, 0, &SizeNeeded);
	if (result != 0xC0000004) {
		return output;
	}
	InfoRegionSize = SizeNeeded;

	// get info
	while (result == 0xC0000004) {
		InfoRegionSize += 0x1000;
		ModuleInformation = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPoolNx, InfoRegionSize);
		if (ModuleInformation == NULL) {
			return output;
		}

		result = ZwQuerySystemInformation(0x0B, (PVOID)ModuleInformation, (ULONG)InfoRegionSize, &SizeNeeded);
		if (result == 0xC0000004) {
			ExFreePool((PVOID)ModuleInformation);
			ModuleInformation = NULL;
		}
	}

	if (!NT_SUCCESS(result)) {
		return output;
	}

	output = (DWORD64)ModuleInformation->Modules[0].ImageBase;

	// free pool
	ExFreePool((PVOID)ModuleInformation);

	return output;
}

DWORD64 DcmbGetRoutineFromSSDT(DWORD64 KernelBase, WORD FuncIndex) {
	DWORD64 KiServiceTableAddr = 0;
	DWORD64 KeRemoveSystemServiceTableAddr = 0;
	DWORD64 KeServiceDescriptorTableFilterAddr = 0;
	DWORD RoutineOffset = 0;
	UNICODE_STRING KeRemoveSystemServiceTableName;

	RtlInitUnicodeString(&KeRemoveSystemServiceTableName, L"KeRemoveSystemServiceTable");
	KeRemoveSystemServiceTableAddr = (DWORD64)MmGetSystemRoutineAddress(&KeRemoveSystemServiceTableName);
	if (!KeRemoveSystemServiceTableAddr)
		return 0;

	// search for LEA instruction
	for (int i = 0; i < 300; i++) {
		if ((*(PBYTE)(KeRemoveSystemServiceTableAddr + i) == 0x48 || *(PBYTE)(KeRemoveSystemServiceTableAddr + i) == 0x4C) && *(PBYTE)(KeRemoveSystemServiceTableAddr + i + 1) == 0x8D) {
			DWORD KeServiceDescriptorTableFilterOffset = *(PDWORD)(KeRemoveSystemServiceTableAddr + i + 3);
			KeServiceDescriptorTableFilterAddr = KeRemoveSystemServiceTableAddr + i + 7 + KeServiceDescriptorTableFilterOffset;
			break;
		}
	}

	if (!KeServiceDescriptorTableFilterAddr)
		return 0;

	KiServiceTableAddr = *(PDWORD64)(KeServiceDescriptorTableFilterAddr);
	if (!KiServiceTableAddr)
		return 0;

	RoutineOffset = *(PDWORD)(KiServiceTableAddr + (FuncIndex * 4));
	if (!RoutineOffset)
		return 0;

	return (KiServiceTableAddr + (RoutineOffset >> 4));
}

WORD DcmbGetRoutineSyscallIndex(LPCSTR RoutineName) {
	NTSTATUS result = 0;
	HANDLE SectionHandle = NULL;
	UNICODE_STRING SectionName;
	OBJECT_ATTRIBUTES ObjectAttr;
	PVOID SectionBaseAddr = NULL;
	SIZE_T ViewSize = 0;
	PVOID RoutineAddr = NULL;
	WORD OutputRoutineSyscallIndex = 0;

	RtlInitUnicodeString(&SectionName, L"\\KnownDlls\\ntdll.dll");
	InitializeObjectAttributes(&ObjectAttr, &SectionName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	result = ZwOpenSection(&SectionHandle, SECTION_MAP_EXECUTE | SECTION_MAP_READ, &ObjectAttr);
	if (!NT_SUCCESS(result)) {
		return 0;
	}

	result = ZwMapViewOfSection(SectionHandle, (HANDLE)(-1), &SectionBaseAddr, 0, 0, NULL, &ViewSize, ViewUnmap, 0, PAGE_READONLY);
	if (!NT_SUCCESS(result)) {
		ZwClose(SectionHandle);
		return 0;
	}

	// parse the PE header
	PVOID OptHeader = (PVOID)((SIZE_T)SectionBaseAddr + *((PDWORD)((SIZE_T)SectionBaseAddr + 0x3c)) + 0x18);
	WORD Magic = *((PWORD)OptHeader);
	PVOID DataDirectory = NULL;
	if (Magic == 0x10b) { // 32 bit 
		DataDirectory = (PVOID)((SIZE_T)OptHeader + 0x60);
	}
	else if (Magic == 0x20b) { // 64 bit
		DataDirectory = (PVOID)((SIZE_T)OptHeader + 0x70);
	}
	else {
		return 0;
	}

	// parse the export header
	DWORD ExportRVA = *((PDWORD)DataDirectory);
	DWORD OrdinalBase = *((PDWORD)((SIZE_T)SectionBaseAddr + ExportRVA + 0x10));
	DWORD NumberOfNames = *((PDWORD)((SIZE_T)SectionBaseAddr + ExportRVA + 0x18));
	DWORD FunctionsRVA = *((PDWORD)((SIZE_T)SectionBaseAddr + ExportRVA + 0x1C));
	DWORD NamesRVA = *((PDWORD)((SIZE_T)SectionBaseAddr + ExportRVA + 0x20));
	DWORD OrdinalsRVA = *((PDWORD)((SIZE_T)SectionBaseAddr + ExportRVA + 0x24));

	for (DWORD i = 0; i < NumberOfNames; i++) {
		DWORD FunctionNameRVA = *((PDWORD)((SIZE_T)SectionBaseAddr + NamesRVA + (i * 4)));
		PCHAR FunctionName = (PCHAR)((SIZE_T)SectionBaseAddr + FunctionNameRVA);

		if (strcmp(FunctionName, (PCHAR)RoutineName) == 0) {
			WORD FunctionOrdinal = *((PWORD)((SIZE_T)SectionBaseAddr + OrdinalsRVA + (i * 2))) + (WORD)OrdinalBase;
			DWORD FunctionRVA = *((PDWORD)((SIZE_T)SectionBaseAddr + FunctionsRVA + (4 * (FunctionOrdinal - OrdinalBase))));
			RoutineAddr = (PVOID)((SIZE_T)SectionBaseAddr + FunctionRVA);
		}
	}

	if (!RoutineAddr)
		return 0;

	OutputRoutineSyscallIndex = (*((PBYTE)RoutineAddr + 5) << 8) | *((PBYTE)RoutineAddr + 4);

	ZwUnmapViewOfSection((HANDLE)(-1), SectionBaseAddr);
	ZwClose(SectionHandle);

	return OutputRoutineSyscallIndex;
}

DWORD64 DcmbGetNotifyRoutineArray(DWORD64 KernelBase, DCMB_CALLBACK_TYPE CallbackType) {
	DWORD64 NotifyRoutineAddr = 0;
	DWORD64 PspNotifyRoutineAddr = 0;
	DWORD64 PspNotifyRoutineArrayAddr = 0;
	UNICODE_STRING NotifyRoutineName;

	switch (CallbackType) {
		case LoadImageCallback: {
			RtlInitUnicodeString(&NotifyRoutineName, L"PsSetLoadImageNotifyRoutine");
			NotifyRoutineAddr = MmGetSystemRoutineAddress(&NotifyRoutineName);
			break;
		}

		case ProcessCreationCallback: {
			RtlInitUnicodeString(&NotifyRoutineName, L"PsSetCreateProcessNotifyRoutine");
			NotifyRoutineAddr = MmGetSystemRoutineAddress(&NotifyRoutineName);
			break;
		}

		case ThreadCreationCallback: {
			RtlInitUnicodeString(&NotifyRoutineName, L"PsSetCreateThreadNotifyRoutine");
			NotifyRoutineAddr = MmGetSystemRoutineAddress(&NotifyRoutineName);
			break;
		}

		case ProcessObjectCreationCallback: {
			WORD RoutineSyscallIndex = DcmbGetRoutineSyscallIndex("NtSuspendProcess");
			if (!RoutineSyscallIndex) break;

			NotifyRoutineAddr = DcmbGetRoutineFromSSDT(KernelBase, RoutineSyscallIndex);
			break;
		}

		case ThreadObjectCreationCallback: {
			WORD RoutineSyscallIndex = DcmbGetRoutineSyscallIndex("NtSuspendThread");
			if (!RoutineSyscallIndex) break;

			NotifyRoutineAddr = DcmbGetRoutineFromSSDT(KernelBase, RoutineSyscallIndex);
			break;
		}

		case RegistryCallback: {
			RtlInitUnicodeString(&NotifyRoutineName, L"CmRegisterCallback");
			NotifyRoutineAddr = MmGetSystemRoutineAddress(&NotifyRoutineName);
			break;
		}

		case DriverVerificationCallback: {
			RtlInitUnicodeString(&NotifyRoutineName, L"SeRegisterImageVerificationCallback");
			NotifyRoutineAddr = MmGetSystemRoutineAddress(&NotifyRoutineName);
			break;
		}

		default: {
			break;
		}
	}

	if (!NotifyRoutineAddr) {
		return 0;
	}

	//DbgPrintEx(0, 0, "CmRegisterCallback = 0x%p", NotifyRoutineAddr);

	// check for CALL or JMP instruction
	if (CallbackType == ProcessObjectCreationCallback || CallbackType == ThreadObjectCreationCallback) {
		RtlInitUnicodeString(&NotifyRoutineName, L"ObReferenceObjectByHandle");
		DWORD64 ObReferenceObjectByHandleAddr = (DWORD64)MmGetSystemRoutineAddress(&NotifyRoutineName);
		RtlInitUnicodeString(&NotifyRoutineName, L"ObReferenceObjectByHandleWithTag");
		DWORD64 ObReferenceObjectByHandleWithTagAddr = (DWORD64)MmGetSystemRoutineAddress(&NotifyRoutineName);
		DWORD64 ObpReferenceObjectByHandleWithTagAddr = 0;
		if (ObReferenceObjectByHandleWithTagAddr) {
			// get ObpReferenceObjectByHandleWithTag address
			for (int i = 0; i < 100; i++) {
				if (*(PBYTE)(ObReferenceObjectByHandleWithTagAddr + i) == 0xE8) {
					ObpReferenceObjectByHandleWithTagAddr = ObReferenceObjectByHandleWithTagAddr + i + 5 + *(PLONG)(ObReferenceObjectByHandleWithTagAddr + i + 1);
					break;
				}
			}
		}
		LONG ObReferenceObjectByHandleOffset = 0;
		LONG ObReferenceObjectByHandleWithTagOffset = 0;
		LONG ObpReferenceObjectByHandleWithTagOffset = 0;

		for (int i = 0; i < 200; i++) {
			// check if ObReferenceObjectByHandle is exist, if it is then calculate the offset
			if (ObReferenceObjectByHandleAddr) ObReferenceObjectByHandleOffset = ObReferenceObjectByHandleAddr - (NotifyRoutineAddr + i + 5);

			// check if ObReferenceObjectByHandleWithTag is exist, if it is then calculate the offset
			if (ObReferenceObjectByHandleWithTagAddr) ObReferenceObjectByHandleWithTagOffset = ObReferenceObjectByHandleWithTagAddr - (NotifyRoutineAddr + i + 5);

			// check if ObpReferenceObjectByHandleWithTag is exist, if it is then calculate the offset
			if (ObpReferenceObjectByHandleWithTagAddr) ObpReferenceObjectByHandleWithTagOffset = ObpReferenceObjectByHandleWithTagAddr - (NotifyRoutineAddr + i + 5);

			// check if the offset is valid with our calculation
			if (*(PBYTE)(NotifyRoutineAddr + i) == 0xE8 && (*(PLONG)(NotifyRoutineAddr + i + 1) == ObReferenceObjectByHandleOffset || *(PLONG)(NotifyRoutineAddr + i + 1) == ObReferenceObjectByHandleWithTagOffset || *(PLONG)(NotifyRoutineAddr + i + 1) == ObpReferenceObjectByHandleWithTagOffset)) {
				PspNotifyRoutineAddr = NotifyRoutineAddr + i;
				break;
			}
		}
	}
	else if (CallbackType == DriverVerificationCallback) {
		PspNotifyRoutineAddr = NotifyRoutineAddr;
	}
	else {
		for (int i = 0; i < 200; i++) {
			if (*(PBYTE)(NotifyRoutineAddr + i) == 0xE9 || *(PBYTE)(NotifyRoutineAddr + i) == 0xE8) {
				LONG PspNotifyRoutineOffset = *(PLONG)(NotifyRoutineAddr + i + 1);
				PspNotifyRoutineAddr = NotifyRoutineAddr + i + 5 + PspNotifyRoutineOffset;
				break;
			}
		}
	}

	if (!PspNotifyRoutineAddr) {
		return 0;
	}

	//DbgPrintEx(0, 0, "PspNotifyRoutineAddr = 0x%p", PspNotifyRoutineAddr);

	if (CallbackType == RegistryCallback) {
		// we scan for last INT 3 instruction (0xCC)
		DWORD64 CmpInsertCallbackInListByAltitudeAddr = 0;
		for (int i = 0; i < 1024; i++) {
			if (*(PBYTE)(PspNotifyRoutineAddr + i) == 0xCC) {
				while (*(PBYTE)(PspNotifyRoutineAddr + i) == 0xCC) i++;
				CmpInsertCallbackInListByAltitudeAddr = PspNotifyRoutineAddr + i;
				break;
			}
		}

		// start searching LEA instruction
		for (int i = 0; i < 300; i++) {
			if ((*(PBYTE)(CmpInsertCallbackInListByAltitudeAddr + i) == 0x4C) && *(PBYTE)(CmpInsertCallbackInListByAltitudeAddr + i + 1) == 0x8D) {
				LONG PspNotifyRoutineArrayOffset = *(PLONG)(CmpInsertCallbackInListByAltitudeAddr + i + 3);
				PspNotifyRoutineArrayAddr = CmpInsertCallbackInListByAltitudeAddr + i + 7 + PspNotifyRoutineArrayOffset;
				break;
			}
		}
	}
	else if (CallbackType == ProcessObjectCreationCallback || CallbackType == ThreadObjectCreationCallback) {
		// we scan for MOV instruction, backwards
		for (int i = 0; i < 50; i++) {
			if ((*(PBYTE)(PspNotifyRoutineAddr - i) == 0x48 || *(PBYTE)(PspNotifyRoutineAddr - i) == 0x4C) && *(PBYTE)(PspNotifyRoutineAddr - i + 1) == 0x8B) {
				LONG PspNotifyRoutineArrayOffset = *(PLONG)(PspNotifyRoutineAddr - i + 3);
				PspNotifyRoutineArrayAddr = PspNotifyRoutineAddr - i + 7 + PspNotifyRoutineArrayOffset;
				PspNotifyRoutineArrayAddr = *(PDWORD64)(PspNotifyRoutineArrayAddr)+0xc8;
				break;
			}
		}
	}
	else if (CallbackType == DriverVerificationCallback) {
		// we scan for MOV instruction, forwards
		for (int i = 0; i < 50; i++) {
			if (*(PBYTE)(PspNotifyRoutineAddr + i) == 0x48 && *(PBYTE)(PspNotifyRoutineAddr + i + 1) == 0x8B) {
				LONG PspNotifyRoutineArrayOffset = *(PLONG)(PspNotifyRoutineAddr + i + 3);
				PspNotifyRoutineArrayAddr = PspNotifyRoutineAddr + i + 7 + PspNotifyRoutineArrayOffset;
				break;
			}
		}
	}
	else {
		// check for LEA instruction
		for (int i = 0; i < 300; i++) {
			if ((*(PBYTE)(PspNotifyRoutineAddr + i) == 0x48 || *(PBYTE)(PspNotifyRoutineAddr + i) == 0x4C) && *(PBYTE)(PspNotifyRoutineAddr + i + 1) == 0x8D) {
				LONG PspNotifyRoutineArrayOffset = *(PLONG)(PspNotifyRoutineAddr + i + 3);
				PspNotifyRoutineArrayAddr = PspNotifyRoutineAddr + i + 7 + PspNotifyRoutineArrayOffset;
				break;
			}
		}
	}

	return PspNotifyRoutineArrayAddr;
}

BOOL DcmbEnumerateDriver(DWORD64 CallbackAddress, PCHAR* DriverFound, PDWORD64 FoundDriverBase) {
	PRTL_PROCESS_MODULES ModuleInformation = NULL;
	NTSTATUS result;
	ULONG SizeNeeded;
	SIZE_T InfoRegionSize;
	BOOL output = FALSE;
	PROTOTYPE_ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;
	UNICODE_STRING ZWQSIName;

	RtlInitUnicodeString(&ZWQSIName, L"ZwQuerySystemInformation");
	ZwQuerySystemInformation = (PROTOTYPE_ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&ZWQSIName);

	// get info size
	result = ZwQuerySystemInformation(0x0B, NULL, 0, &SizeNeeded);
	if (result != 0xC0000004) {
		return output;
	}
	InfoRegionSize = SizeNeeded;

	// get info
	while (result == 0xC0000004) {
		InfoRegionSize += 0x1000;
		ModuleInformation = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPoolNx, InfoRegionSize);
		if (ModuleInformation == NULL) {
			return output;
		}

		result = ZwQuerySystemInformation(0x0B, (PVOID)ModuleInformation, (ULONG)InfoRegionSize, &SizeNeeded);
		if (!NT_SUCCESS(result)) {
			ExFreePool((PVOID)ModuleInformation);
			ModuleInformation = NULL;
		}
	}

	if (!NT_SUCCESS(result)) {
		return output;
	}

	// enumerate through the drivers
	for (DWORD i = 0; i < ModuleInformation->NumberOfModules; i++) {
		// check if callback address falls into the memmory range of the driver 
		if (((DWORD64)ModuleInformation->Modules[i].ImageBase < CallbackAddress) && (CallbackAddress < ((DWORD64)ModuleInformation->Modules[i].ImageBase + ModuleInformation->Modules[i].ImageSize))) {
			*DriverFound = ModuleInformation->Modules[i].FullPathName;
			*FoundDriverBase = ModuleInformation->Modules[i].ImageBase;
			output = TRUE;
		}
	}

	// free the pool
	ExFreePool((PVOID)ModuleInformation);

	return output;
}

void DcmbEnumerateCallbacks(DCMB_CALLBACK_TYPE CallbackType, DWORD64 KernelBase) {
	DWORD64 CallbackArrayAddr = 0;
	if (!(CallbackArrayAddr = DcmbGetNotifyRoutineArray(KernelBase, CallbackType))) return;

	if (CallbackType == RegistryCallback) {
		PREGISTRY_CALLBACK_ITEM CurrentRegistryCallback = (PREGISTRY_CALLBACK_ITEM)CallbackArrayAddr;

		while (TRUE) {
			DWORD64 CurrentCallbackAddress = CurrentRegistryCallback->Function;

			PCHAR DriverPath = NULL;
			DWORD64 DriverBase = 0;
			if (DcmbEnumerateDriver(CurrentCallbackAddress, &DriverPath, &DriverBase)) {
				DbgPrintEx(0, 0, "   [DCMB] Registry Read/Write : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), CurrentCallbackAddress - DriverBase, CurrentCallbackAddress);
			}

			if ((PVOID)CurrentRegistryCallback->Item.Flink == (PVOID)CallbackArrayAddr)
				break;

			CurrentRegistryCallback = (PREGISTRY_CALLBACK_ITEM)CurrentRegistryCallback->Item.Flink;
		}
	}
	else if (CallbackType == ProcessObjectCreationCallback || CallbackType == ThreadObjectCreationCallback) {
		POB_CALLBACK_ENTRY CurrentObjectCallbackEntryItem = (POB_CALLBACK_ENTRY)CallbackArrayAddr;

		do {
			PCHAR DriverPath = NULL;
			DWORD64 DriverBase = 0;
			if (DcmbEnumerateDriver((DWORD64)CurrentObjectCallbackEntryItem->PostOperation, &DriverPath, &DriverBase)) {
				if (CallbackType == ProcessObjectCreationCallback) {
					DbgPrintEx(0, 0, "   [DCMB] Process Object Post-Creation : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), (DWORD64)CurrentObjectCallbackEntryItem->PostOperation - DriverBase, (DWORD64)CurrentObjectCallbackEntryItem->PostOperation);
				}
				else {
					DbgPrintEx(0, 0, "   [DCMB] Thread Object Post-Creation : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), (DWORD64)CurrentObjectCallbackEntryItem->PostOperation - DriverBase, (DWORD64)CurrentObjectCallbackEntryItem->PostOperation);
				}
			}

			if (DcmbEnumerateDriver((DWORD64)CurrentObjectCallbackEntryItem->PreOperation, &DriverPath, &DriverBase)) {
				if (CallbackType == ProcessObjectCreationCallback) {
					DbgPrintEx(0, 0, "   [DCMB] Process Object Pre-Creation : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), (DWORD64)CurrentObjectCallbackEntryItem->PreOperation - DriverBase, (DWORD64)CurrentObjectCallbackEntryItem->PreOperation);
				}
				else {
					DbgPrintEx(0, 0, "   [DCMB] Thread Object Pre-Creation : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), (DWORD64)CurrentObjectCallbackEntryItem->PreOperation - DriverBase, (DWORD64)CurrentObjectCallbackEntryItem->PreOperation);
				}
			}
			CurrentObjectCallbackEntryItem = (POB_CALLBACK_ENTRY)CurrentObjectCallbackEntryItem->CallbackList.Flink;
		} while ((DWORD64)CurrentObjectCallbackEntryItem->CallbackList.Flink != (DWORD64)CallbackArrayAddr);
	}
	else if (CallbackType == DriverVerificationCallback) {
		PCALLBACK_OBJECT DriverVerificationCallbackObject = *(PDWORD64)(CallbackArrayAddr);
		PCALLBACK_REGISTRATION CurrentCallback = (PCALLBACK_REGISTRATION)DriverVerificationCallbackObject->RegisteredCallbacks.Flink;

		while (CurrentCallback != (PCALLBACK_OBJECT)&DriverVerificationCallbackObject->RegisteredCallbacks) {
			PCHAR DriverPath = NULL;
			DWORD64 DriverBase = 0;
			if (DcmbEnumerateDriver(CurrentCallback->CallbackFunction, &DriverPath, &DriverBase)) {
				DbgPrintEx(0, 0, "   [DCMB] Driver verification : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), (DWORD64)CurrentCallback->CallbackFunction - DriverBase, (PVOID)CurrentCallback->CallbackFunction);
			}

			CurrentCallback = CurrentCallback->Link.Flink;
		}
	}
	else {
		for (int i = 0; i < 64; i++) {
			DWORD64 CurrentCallback = *(PDWORD64)(CallbackArrayAddr + (i * 8));

			// skip null entries
			if (CurrentCallback == 0)
				continue;

			DWORD64 CurrentCallbackAddress = *(PDWORD64)(CurrentCallback &= ~(1ULL << 3) + 0x1);
			//DWORD64 CurrentCallbackAddress = *(PDWORD64)(CurrentCallback & 0xfffffffffffffff8);

			// do some checks
			PCHAR DriverPath = NULL;
			DWORD64 DriverBase = 0;
			if (DcmbEnumerateDriver(CurrentCallbackAddress, &DriverPath, &DriverBase)) {
				if (CallbackType == ProcessCreationCallback) {
					DbgPrintEx(0, 0, "   [DCMB] Process Creation : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), CurrentCallbackAddress - DriverBase, CurrentCallbackAddress);
				}
				else if (CallbackType == ThreadCreationCallback) {
					DbgPrintEx(0, 0, "   [DCMB] Thread Creation : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), CurrentCallbackAddress - DriverBase, CurrentCallbackAddress);
				}
				else {
					DbgPrintEx(0, 0, "   [DCMB] Load Image : %s+0x%x = 0x%p\n", DcmbGetBaseNameFromFullName(DriverPath), CurrentCallbackAddress - DriverBase, CurrentCallbackAddress);
				}
			}
		}
	}
}

```

`DCMB/dcmb.h`:

```h
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <minwindef.h>
#include <intrin.h>
#include <ntddndis.h>
#include <strsafe.h>
#include <ntifs.h>
#include <fltKernel.h>
#pragma once

typedef enum _DCMB_CALLBACK_TYPE {
	LoadImageCallback,
	ProcessCreationCallback,
	ThreadCreationCallback,
	ProcessObjectCreationCallback,
	ThreadObjectCreationCallback,
	RegistryCallback,
    DriverVerificationCallback
} DCMB_CALLBACK_TYPE;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45,
    SystemCodeIntegrityInformation = 103,
    SystemPolicyInformation = 134,
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    ULONG Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    CHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    PVOID ExceptionTable;
    ULONG ExceptionTableSize;
    PVOID GpValue;
    PNON_PAGED_DEBUG_INFO NonPagedDebugInfo;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Unused5;
    PVOID SectionPointer;
    ULONG CheckSum;
    PVOID LoadedImports;
    PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

typedef struct _REGISTRY_CALLBACK_ITEM
{
    LIST_ENTRY Item;
    DWORD64 Unknown1[2];
    DWORD64 Context;
    DWORD64 Function;
    UNICODE_STRING Altitude;
    DWORD64 Unknown2[2];
} REGISTRY_CALLBACK_ITEM, * PREGISTRY_CALLBACK_ITEM;

typedef struct OB_CALLBACK_ENTRY_t {
    LIST_ENTRY CallbackList; // linked element tied to _OBJECT_TYPE.CallbackList
    OB_OPERATION Operations; // bitfield : 1 for Creations, 2 for Duplications
    BOOL Enabled;            // self-explanatory
    struct OB_CALLBACK_t* Entry;      // points to the structure in which it is included
    POBJECT_TYPE ObjectType; // points to the object type affected by the callback
    POB_PRE_OPERATION_CALLBACK PreOperation;      // callback function called before each handle operation
    POB_POST_OPERATION_CALLBACK PostOperation;     // callback function called after each handle operation
    KSPIN_LOCK Lock;         // lock object used for synchronization
} OB_CALLBACK_ENTRY, * POB_CALLBACK_ENTRY;

typedef struct _CALLBACK_OBJECT
{
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    UCHAR reserved[3];
} CALLBACK_OBJECT;

typedef struct _CALLBACK_REGISTRATION
{
    LIST_ENTRY Link;
    PCALLBACK_OBJECT CallbackObject;
    PCALLBACK_FUNCTION CallbackFunction;
    PVOID CallbackContext;
    ULONG Busy;
    BOOLEAN UnregisterWaiting;
} CALLBACK_REGISTRATION, * PCALLBACK_REGISTRATION;

typedef NTSTATUS(NTAPI* PROTOTYPE_ZWQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS info, PVOID infoinout, ULONG len, PULONG retLen);

PCHAR DcmbGetBaseNameFromFullName(PCHAR FullName);
DWORD64 DcmbGetKernelBase();
DWORD64 DcmbGetRoutineFromSSDT(DWORD64 KernelBase, WORD FuncIndex);
WORD DcmbGetRoutineSyscallIndex(LPCSTR RoutineName);
DWORD64 DcmbGetNotifyRoutineArray(DWORD64 KernelBase, DCMB_CALLBACK_TYPE CallbackType);
BOOL DcmbEnumerateDriver(DWORD64 CallbackAddress, PCHAR* DriverFound, PDWORD64 FoundDriverBase);
void DcmbEnumerateCallbacks(DCMB_CALLBACK_TYPE CallbackType, DWORD64 KernelBase);

```

`DCMB/main.c`:

```c
#include "main.h"
#include <memory.h>

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) {
	//pDriverObject->DriverUnload = UnloadDriver;

	DbgPrintEx(0, 0, "DCMB said Hello from the kernel!\n");

	try {
		DWORD64 Kernelbase = DcmbGetKernelBase();

		if (!Kernelbase)
			return STATUS_SUCCESS;

		DbgPrintEx(0, 0, "[DCMB] Kernel base address : 0x%p\n", Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] Load image callback array address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, LoadImageCallback));
		DcmbEnumerateCallbacks(LoadImageCallback, Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] Process creation callback array address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, ProcessCreationCallback));
		DcmbEnumerateCallbacks(ProcessCreationCallback, Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] Thread creation callback array address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, ThreadCreationCallback));
		DcmbEnumerateCallbacks(ThreadCreationCallback, Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] Registry RW callback list head address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, RegistryCallback));
		DcmbEnumerateCallbacks(RegistryCallback, Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] PsProcessType object callback list address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, ProcessObjectCreationCallback));
		DcmbEnumerateCallbacks(ProcessObjectCreationCallback, Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] PsThreadType object callback list address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, ThreadObjectCreationCallback));
		DcmbEnumerateCallbacks(ThreadObjectCreationCallback, Kernelbase);

		DbgPrintEx(0, 0, "[DCMB] Driver verification callback array address : 0x%p\n", (PVOID)DcmbGetNotifyRoutineArray(Kernelbase, DriverVerificationCallback));
		DcmbEnumerateCallbacks(DriverVerificationCallback, Kernelbase);

		DcmbEnumerateFilters();

		DbgPrintEx(0, 0, "DCMB exiting gracefully... Goodbye!");
		return STATUS_UNSUCCESSFUL;
	}except(EXCEPTION_EXECUTE_HANDLER) {
		DbgPrintEx(0, 0, "DCMB main exception handler triggered!");
		return STATUS_UNHANDLED_EXCEPTION;
	}
}

NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject) {

	DbgPrintEx(0, 0, "DCMB said Goodbye!\n");

	return STATUS_SUCCESS;
}
```

`DCMB/main.h`:

```h
#include "dcmb.h"
#include "minifilters.h"
#pragma once

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath);
NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject);

```

`DCMB/minifilters.c`:

```c
#include "minifilters.h"

BOOL DcmbValidatePotentialCallbackNodes(PCALLBACK_NODE PotentialCallbackNode, PFLT_INSTANCE FltInstance, DWORD64 DriverStartAddr, DWORD64 DriverSize) {
	if (PotentialCallbackNode->Instance != FltInstance) return FALSE;
	if (PotentialCallbackNode->PreOperation) {
		if (!((DWORD64)PotentialCallbackNode->PreOperation > DriverStartAddr && (DWORD64)PotentialCallbackNode->PreOperation < (DriverStartAddr + DriverSize))) {
			return FALSE;
		}
	}
	if (PotentialCallbackNode->PostOperation) {
		if (!((DWORD64)PotentialCallbackNode->PostOperation > DriverStartAddr && (DWORD64)PotentialCallbackNode->PostOperation < (DriverStartAddr + DriverSize))) {
			return FALSE;
		}
	}

	if (!PotentialCallbackNode->PreOperation && !PotentialCallbackNode->PostOperation) return FALSE;

	return TRUE;
	/* take the range of the driver instead of enumerating the driver every validation
	return ((PotentialCallbackNode->Instance == FltInstance) &&
		(DWORD64)PotentialCallbackNode->PreOperation > DriverStartAddr &&
		(DWORD64)PotentialCallbackNode->PreOperation < (DriverStartAddr + DriverSize) &&
		(DWORD64)PotentialCallbackNode->PostOperation > DriverStartAddr &&
		(DWORD64)PotentialCallbackNode->PostOperation < (DriverStartAddr + DriverSize));*/
}

BOOL DcmbReadMemorySafe(PVOID TargetAddress, PVOID AllocatedBuffer, SIZE_T LengthToRead) {
	PHYSICAL_ADDRESS PhysicalAddr = MmGetPhysicalAddress(TargetAddress);
	if (PhysicalAddr.QuadPart) {
		PVOID NewVirtualAddr = MmMapIoSpace(PhysicalAddr, LengthToRead, MmNonCached);
		if (NewVirtualAddr) {
			for (SIZE_T i = 0; i < LengthToRead; i++) {
				*(PBYTE)((DWORD64)AllocatedBuffer + i) = *(PBYTE)((DWORD64)NewVirtualAddr + i);
			}
			MmUnmapIoSpace(NewVirtualAddr, LengthToRead);
			return TRUE;
		}
	}
	return FALSE;
}

BOOL DcmbEnumFilterInstances(PFLT_FILTER TargetFilter, PFLT_INSTANCE** InstanceListOutput, PULONG InstanceCount) {
	NTSTATUS result = STATUS_UNSUCCESSFUL;
	BOOL output = FALSE;
	PFLT_INSTANCE* InstanceListBuffer = NULL;
	ULONG NumberOfInstanceReturned = 0;
	ULONG InstanceListBufferSize = 0;

	result = FltEnumerateInstances(NULL, TargetFilter, InstanceListBuffer, InstanceListBufferSize, &NumberOfInstanceReturned);
	if (result != STATUS_BUFFER_TOO_SMALL) {
		return output; // FltEnumerateInstances result is unexpected
	}

	while (result == STATUS_BUFFER_TOO_SMALL) {
		InstanceListBufferSize += 0x1000;
		InstanceListBuffer = (PFLT_INSTANCE*)ExAllocatePool(NonPagedPoolNx, InstanceListBufferSize);
		if (!InstanceListBuffer)
			return output;

		result = FltEnumerateInstances(NULL, TargetFilter, InstanceListBuffer, InstanceListBufferSize, &NumberOfInstanceReturned);
		if (!NT_SUCCESS(result)) {
			ExFreePool((PVOID)InstanceListBuffer);
			InstanceListBuffer = NULL;
		}
		else {
			output = TRUE;
		}
	}

	*InstanceListOutput = InstanceListBuffer;
	*InstanceCount = NumberOfInstanceReturned;

	return output;
}

BOOL DcmbEnumerateFilters() {
	NTSTATUS result = STATUS_UNSUCCESSFUL;
	BOOL output = FALSE;
	PFLT_FILTER* FilterListBuffer = NULL;
	ULONG NumberOfFiltersReturned = 0;
	ULONG FilterListBufferSize = 0;
	WCHAR FilterNameBuffer[256] = { 0 };
	WCHAR FilterAltitudeBuffer[256] = { 0 };

	result = FltEnumerateFilters(FilterListBuffer, FilterListBufferSize, &NumberOfFiltersReturned);
	if (result != STATUS_BUFFER_TOO_SMALL) {
		return output; // result is not expected
	}

	while (result == STATUS_BUFFER_TOO_SMALL) {
		FilterListBufferSize += 0x1000;
		FilterListBuffer = (PFLT_FILTER*)ExAllocatePool(NonPagedPoolNx, FilterListBufferSize);
		if (!FilterListBuffer)
			return output;

		result = FltEnumerateFilters(FilterListBuffer, FilterListBufferSize, &NumberOfFiltersReturned);
		if (!NT_SUCCESS(result)) {
			ExFreePool((PVOID)FilterListBuffer);
			FilterListBuffer = NULL;
		}
	}

	if (!NT_SUCCESS(result))
		return output;


	// get the filters info
	for (ULONG i = 0; i < NumberOfFiltersReturned; i++) {
		PFLT_FILTER CurrentFilter = *(PFLT_FILTER*)((DWORD64)FilterListBuffer + (i * sizeof(PFLT_FILTER)));
		PFILTER_AGGREGATE_BASIC_INFORMATION FilterBasicInfoBuffer = NULL;
		ULONG FilterBasicInfoReturnedSize = 0;
		ULONG FilterBasicInfoSize = 0;
		PFLT_INSTANCE* InstanceListBase = NULL;
		ULONG InstanceCount = 0;

		result = FltGetFilterInformation(CurrentFilter, FilterAggregateBasicInformation, FilterBasicInfoBuffer, FilterBasicInfoSize, &FilterBasicInfoReturnedSize);
		if (result != STATUS_BUFFER_TOO_SMALL) {
			continue;
		}

		while (result == STATUS_BUFFER_TOO_SMALL) {
			FilterBasicInfoSize += 0x1000;
			FilterBasicInfoBuffer = (PFILTER_AGGREGATE_BASIC_INFORMATION)ExAllocatePool(NonPagedPoolNx, FilterBasicInfoSize);
			if (!FilterBasicInfoBuffer)
				break;

			result = FltGetFilterInformation(CurrentFilter, FilterAggregateBasicInformation, FilterBasicInfoBuffer, FilterBasicInfoSize, &FilterBasicInfoReturnedSize);
			if (!NT_SUCCESS(result)) {
				ExFreePool((PVOID)FilterBasicInfoBuffer);
				FilterBasicInfoBuffer = NULL;
			}
		}

		if (!NT_SUCCESS(result))
			continue;

		PWCHAR FilterNameAddr = (PWCHAR)((DWORD64)FilterBasicInfoBuffer + FilterBasicInfoBuffer->Type.MiniFilter.FilterNameBufferOffset);
		PWCHAR FilterAltitudeAddr = (PWCHAR)((DWORD64)FilterBasicInfoBuffer + FilterBasicInfoBuffer->Type.MiniFilter.FilterAltitudeBufferOffset);

		if (FilterBasicInfoBuffer->Type.MiniFilter.FilterNameLength < 256)
			memcpy(FilterNameBuffer, FilterNameAddr, FilterBasicInfoBuffer->Type.MiniFilter.FilterNameLength);
		else {
			memcpy(FilterNameBuffer, FilterNameAddr, 252 * sizeof(WCHAR));
			memcpy(FilterNameBuffer + 252, L"...", 3 * sizeof(WCHAR));
		}

		memcpy(FilterAltitudeBuffer, FilterAltitudeAddr, FilterBasicInfoBuffer->Type.MiniFilter.FilterAltitudeLength);

		// prints filter name
		DbgPrintEx(0, 0, "[DCMB] Found minifilter %ws with altitude %ws!\n", FilterNameBuffer, FilterAltitudeBuffer);

		// free filter basic info pool
		ExFreePool((PVOID)FilterBasicInfoBuffer);

		// null filter name buffer and filter altitude buffer
		memset(FilterNameBuffer, 0x00, 256 * sizeof(WCHAR));
		memset(FilterAltitudeBuffer, 0x00, 256 * sizeof(WCHAR));

		// enum filter instances
		if (!DcmbEnumFilterInstances(CurrentFilter, &InstanceListBase, &InstanceCount)) continue;

		// enum callbacks
		if (!DcmbEnumInstancesCallbacks(InstanceListBase, InstanceCount, FALSE)) {
			ExFreePool(InstanceListBase);
			continue;
		}
		else continue;
	}

	// free filter list pool
	ExFreePool((PVOID)FilterListBuffer);

	return output;
}

BOOL DcmbEnumInstancesCallbacks(PFLT_INSTANCE* InstanceListBase, ULONG InstanceCount, BOOL Verbose) {
	BOOL output = TRUE;
	PRTL_PROCESS_MODULES ModuleInformation = NULL;
	NTSTATUS result;
	ULONG SizeNeeded;
	SIZE_T InfoRegionSize;
	PROTOTYPE_ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;
	UNICODE_STRING ZWQSIName;
	int PreOpsCallbackCount = 0;
	int PostOpsCallbackCount = 0;

	RtlInitUnicodeString(&ZWQSIName, L"ZwQuerySystemInformation");
	ZwQuerySystemInformation = (PROTOTYPE_ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&ZWQSIName);

	// get system module info size
	result = ZwQuerySystemInformation(0x0B, NULL, 0, &SizeNeeded);
	if (result != 0xC0000004) {
		return output;
	}
	InfoRegionSize = SizeNeeded;

	// get system module info
	while (result == 0xC0000004) {
		InfoRegionSize += 0x1000;
		ModuleInformation = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPoolNx, InfoRegionSize);
		if (ModuleInformation == NULL) {
			return output;
		}

		result = ZwQuerySystemInformation(0x0B, (PVOID)ModuleInformation, (ULONG)InfoRegionSize, &SizeNeeded);
		if (!NT_SUCCESS(result)) {
			ExFreePool((PVOID)ModuleInformation);
			ModuleInformation = NULL;
		}
	}

	if (!NT_SUCCESS(result)) {
		return output;
	}

	// go through the instances
	for (ULONG i = 0; i < InstanceCount; i++) {
		PCALLBACK_NODE TargetCallbackNode = NULL;
		PFLT_INSTANCE CurrentInstance = *(PFLT_INSTANCE*)((DWORD64)InstanceListBase + (i * sizeof(PFLT_INSTANCE)));

		//fpDbgPrintEx(0, 0, "Checking instance %i...", i);

		// copy instance memory
		PFLT_INSTANCE CurrentInstanceVA = ExAllocatePool(NonPagedPoolNx, 0x230);
		if (!DcmbReadMemorySafe((PVOID)CurrentInstance, (PVOID)CurrentInstanceVA, 0x230)) {
			ExFreePool((PVOID)CurrentInstanceVA);
			break;
		}

		// scan for our callback node
		for (DWORD x = 0; x < 0x230; x++) {
			DWORD64 PotentialPointer = *(PDWORD64)((DWORD64)CurrentInstanceVA + x);
			PCALLBACK_NODE PotentialNode = (PCALLBACK_NODE)PotentialPointer;

			if (MmIsAddressValid((PVOID)PotentialPointer)) {
				try {
					for (DWORD i = 0; i < ModuleInformation->NumberOfModules; i++) {
						// check if callback address falls into the memmory range of the driver 
						if (DcmbValidatePotentialCallbackNodes(PotentialNode,
							CurrentInstance, (DWORD64)ModuleInformation->Modules[i].ImageBase,
							ModuleInformation->Modules[i].ImageSize)) {
							TargetCallbackNode = PotentialNode;

							//DbgPrintEx(0, 0, "   Instance : 0x%p, TargetCallbackNode : 0x%p\n", CurrentInstance, TargetCallbackNode);

							if (TargetCallbackNode->PreOperation) {
								PreOpsCallbackCount++;

								if (Verbose) DbgPrintEx(0, 0, "   [DCMB] Found minifilter pre-operation callback : %s+0x%x = 0x%p\n",
									DcmbGetBaseNameFromFullName(ModuleInformation->Modules[i].FullPathName),
									(DWORD64)TargetCallbackNode->PreOperation - (DWORD64)ModuleInformation->Modules[i].ImageBase,
									TargetCallbackNode->PreOperation);
							}

							if (TargetCallbackNode->PostOperation) {
								PostOpsCallbackCount++;
								
								if (Verbose) DbgPrintEx(0, 0, "   [DCMB] Found minifilter post-operation callback : %s+0x%x = 0x%p\n",
									DcmbGetBaseNameFromFullName(ModuleInformation->Modules[i].FullPathName),
									(DWORD64)TargetCallbackNode->PostOperation - (DWORD64)ModuleInformation->Modules[i].ImageBase,
									TargetCallbackNode->PostOperation);
							}

							break;
						}
					}
				}except(EXCEPTION_EXECUTE_HANDLER) {}
			}
		}

		/*if (TargetCallbackNode) {
			// check if there is other callback
			PCALLBACK_NODE CurrentCallbackNode = TargetCallbackNode;
			while ((DWORD64)CurrentCallbackNode->CallbackLinks.Flink != (DWORD64)TargetCallbackNode) {
				try {
					CurrentCallbackNode = (PCALLBACK_NODE)CurrentCallbackNode->CallbackLinks.Flink;

					for (DWORD i = 0; i < ModuleInformation->NumberOfModules; i++) {
						// check if callback address falls into the memmory range of the driver 
						if (DcmbValidatePotentialCallbackNodes(CurrentCallbackNode,
							CurrentInstance, (DWORD64)ModuleInformation->Modules[i].ImageBase,
							ModuleInformation->Modules[i].ImageSize)) {
							
							//DbgPrintEx(0, 0, "Instance : 0x%p, CurrentCallbackNode : 0x%p\n", CurrentInstance, CurrentCallbackNode);
							if (TargetCallbackNode->PreOperation) {
								PreOpsCallbackCount++;

								if (Verbose) DbgPrintEx(0, 0, "   [DCMB] Found minifilter pre-operation callback : %s+0x%x = 0x%p\n",
									DcmbGetBaseNameFromFullName(ModuleInformation->Modules[i].FullPathName),
									(DWORD64)TargetCallbackNode->PreOperation - (DWORD64)ModuleInformation->Modules[i].ImageBase,
									TargetCallbackNode->PreOperation);
							}

							if (TargetCallbackNode->PostOperation) {
								PostOpsCallbackCount++;

								if (Verbose) DbgPrintEx(0, 0, "   [DCMB] Found minifilter post-operation callback : %s+0x%x = 0x%p\n",
									DcmbGetBaseNameFromFullName(ModuleInformation->Modules[i].FullPathName),
									(DWORD64)TargetCallbackNode->PostOperation - (DWORD64)ModuleInformation->Modules[i].ImageBase,
									TargetCallbackNode->PostOperation);
							}
						}
					}
				}except(EXCEPTION_EXECUTE_HANDLER) {
					break;
				}
			}
		}*/

		// free instance mem pool
		ExFreePool((PVOID)CurrentInstanceVA);
	}

	// free the pool
	ExFreePool((PVOID)ModuleInformation);

	DbgPrintEx(0, 0, "   [DCMB] %i pre-ops callback and %i post-ops callback enumerated.\n", PreOpsCallbackCount, PostOpsCallbackCount);

	return TRUE;
}
```

`DCMB/minifilters.h`:

```h
#pragma once
#include "dcmb.h"


typedef struct _CALLBACK_NODE
{
    LIST_ENTRY CallbackLinks;
    PFLT_INSTANCE Instance;
    union {
        PVOID PreOperation;
        PVOID GenerateFileName;
        PVOID NormalizeNameComponent;
        PVOID NormalizeNameComponentEx;
    };
    union {
        PVOID NormalizeContextCleanup;
        PVOID PostOperation;
    };
    DWORD64 Flags;
    //...
} CALLBACK_NODE, * PCALLBACK_NODE;

BOOL DcmbEnumerateFilters();
BOOL DcmbEnumFilterInstances(PFLT_FILTER TargetFilter, PFLT_INSTANCE** InstanceListOutput, PULONG InstanceCount);
BOOL DcmbValidatePotentialCallbackNodes(PCALLBACK_NODE PotentialCallbackNode, PFLT_INSTANCE FltInstance, DWORD64 DriverStartAddr, DWORD64 DriverSize);
BOOL DcmbReadMemorySafe(PVOID TargetAddress, PVOID AllocatedBuffer, SIZE_T LengthToRead);
BOOL DcmbEnumInstancesCallbacks(PFLT_INSTANCE* InstanceListBase, ULONG InstanceCount, BOOL Verbose);
```

`README.md`:

```md
# DCMB - Dont Call Me Back
*"I really want to remove AC/AV/EDR's kernel callback, but i dont like working with offsets and/or signature"*. Well, not anymore! DCMB will help you to find those callbacks dynamically. DCMB's objective is to **find** kernel callback list/array **without** using signatures or offset **across multiple Windows version**. This project is not intended to being integrated to your project, instead you should learn the logics thats used on this project. Contributions and bug reports are really appreciated!

# Supported Callback
- Process Creation Callback (Returns PspCreateProcessNotifyRoutine array address)
- Thread Creation Callback (Returns PspCreateThreadNotifyRoutine array address)
- Image Load Callback (Returns PspLoadImageNotifyRoutine array address)
- Registry RW Callback (Returns CallbackListHead doubly linked list address)
- Object Creation Callback (Both Process and Thread object) (Returns PsProcessType's and PsThreadType's CallbackList linked list address)
- Driver/Image VerificationCallback (Returns ExCbSeImageVerificationDriverInfo callback object address)
- Minifilter callbacks

# Usage
Compile the Release version, enable test signing mode, load it, and view the results through DebugView
![image](https://github.com/GetRektBoy724/DCMB/assets/41237415/1de047b9-a6dc-40e3-b380-1b1d73025174)

```