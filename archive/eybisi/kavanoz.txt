Project Path: arc_eybisi_kavanoz_qckp02wg

Source Tree:

```txt
arc_eybisi_kavanoz_qckp02wg
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ assets
â”‚   â”œâ”€â”€ demo.tape
â”‚   â””â”€â”€ unpack.gif
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ src
â”‚   â””â”€â”€ kavanoz
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ core.py
â”‚       â”œâ”€â”€ debug_utils.py
â”‚       â”œâ”€â”€ loader
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ androidnativeemu
â”‚       â”‚   â”œâ”€â”€ appsealing.py
â”‚       â”‚   â”œâ”€â”€ coper.py
â”‚       â”‚   â”œâ”€â”€ crocodilus.py
â”‚       â”‚   â”œâ”€â”€ kangapack.py
â”‚       â”‚   â”œâ”€â”€ moqhao.py
â”‚       â”‚   â”œâ”€â”€ multidex.py
â”‚       â”‚   â”œâ”€â”€ multidex_header.py
â”‚       â”‚   â”œâ”€â”€ old_rc4.py
â”‚       â”‚   â”œâ”€â”€ pronlocker.py
â”‚       â”‚   â”œâ”€â”€ rc4.py
â”‚       â”‚   â”œâ”€â”€ sesdex.py
â”‚       â”‚   â”œâ”€â”€ simple.py
â”‚       â”‚   â”œâ”€â”€ simple_aes.py
â”‚       â”‚   â”œâ”€â”€ simple_xor.py
â”‚       â”‚   â”œâ”€â”€ simple_xor_zlib.py
â”‚       â”‚   â”œâ”€â”€ simply_xor2.py
â”‚       â”‚   â””â”€â”€ subapp.py
â”‚       â”œâ”€â”€ plugin_loader.py
â”‚       â”œâ”€â”€ smali_regexes.py
â”‚       â”œâ”€â”€ unpack_plugin.py
â”‚       â””â”€â”€ utils.py
â””â”€â”€ tests
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ test.py
    â””â”€â”€ test_apk
        â”œâ”€â”€ coper.apk
        â”œâ”€â”€ coper2.apk
        â”œâ”€â”€ coper2_0.apk
        â”œâ”€â”€ coper2_1.apk
        â”œâ”€â”€ coper3_2.apk
        â”œâ”€â”€ crocodilus.apk
        â”œâ”€â”€ default_dex_protector.apk
        â”œâ”€â”€ dexprotector.apk
        â”œâ”€â”€ inflate.apk
        â”œâ”€â”€ inflate2.apk
        â”œâ”€â”€ kangapack.apk
        â”œâ”€â”€ loader_rc4_key_0.apk
        â”œâ”€â”€ loader_rc4_multiple_stage.apk
        â”œâ”€â”€ loader_rc4_second_key_0.apk
        â”œâ”€â”€ loader_rc4_static_key_in_key_class.apk
        â”œâ”€â”€ moqhao.apk
        â”œâ”€â”€ multidex_without_header.apk
        â”œâ”€â”€ multiple_rc4_init.apk
        â”œâ”€â”€ pronlocker.apk
        â”œâ”€â”€ protect_key_chines_manifest_without_zlib.apk
        â”œâ”€â”€ protect_key_chines_manifest_without_zlib2.apk
        â”œâ”€â”€ sesdex.apk
        â”œâ”€â”€ simple_first_100_byte.apk
        â”œâ”€â”€ simple_skip4_zlib_base64.apk
        â”œâ”€â”€ simple_xor2.apk
        â”œâ”€â”€ simple_xor_zlib_base64.apk
        â”œâ”€â”€ simpleaes.apk
        â”œâ”€â”€ simplexor.apk
        â””â”€â”€ subapp.apk

```

`LICENSE`:

```
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ðŸ«™ kavanoz ðŸ«™ 
![](https://img.shields.io/github/license/eybisi/kavanoz)
![](https://img.shields.io/github/stars/eybisi/kavanoz)
![](https://img.shields.io/github/issues-closed/eybisi/kavanoz.svg)
![](https://img.shields.io/github/issues-pr-closed/eybisi/kavanoz.svg)

Kavanoz (jar in turkish) is a tool to statically unpack common android banker malware. 
Do you ever wanted to get payload from packed malware without running android emulator ? Me neither :) But here is a tool anyway.

![](assets/unpack.gif)

### :eyes: Installation

```
pip install kavanoz
```

To install from source, clone the repository and do an editable install with -e. Which means if you edit or add new plugins to the project it will be used without reinstalling.

```
git clone https://github.com/eybisi/kavanoz.git
cd kavanoz
pip install -e .
```

### :zap: Usage

from cmdline
```bash
kavanoz /tmp/filepath
```
You can use `-vvv` parameter to print verbose logs. (useful for debugging plugins)

as python library
```py
from kavanoz.core import Kavanoz
from kavanoz import utils

utils.set_log("DEBUG")
k = Kavanoz(apk_path="tests/test_apk/coper.apk")
for plugin_result in k.get_plugin_results():
    if plugin_result["status"] == "success":
        print("Unpacked")
        print(plugin_result)
        break
```

### :snake: Scripts:

- [rc4.py](src/kavanoz/loader/rc4.py) Generic rc4 encrypted asset file. Script covers multiple versions.
- [old_rc4.py](src/kavanoz/loader/old_rc4.py) Another Generic rc4 encrypted asset file.
- [subapp.py](src/kavanozloader/subapp.py) Decryption of file with key derived from Manifest file ProtectKey variable
- [multidex.py](src/kavanoz/loader/multidex.py) Multidex like loader with inflated packed file. (zlib compression)
- [coper.py](src/kavanoz/loader/coper.py) Extract rc4 key from native lib with emulation (AndroidNativeEmu)
- [moqhao.py](src/kavanozloader/moqhao.py) Emulation for moqhau unpacking.
- [sesdex.py](src/kavanoz/loader/sesdex.py)
- [simple_aes.py](src/kavanoz/loader/simple_aes.py)
- [simple_xor.py](src/kavanoz/loader/simple_xor.py)
- [simple_xor2.py](src/kavanoz/loader/simple_xor2.py)
- [simple_xor_zlib.py](src/kavanoz/loader/simple_xor_zlib.py)
- [subapp.py](src/kavanoz/loader/subapp.py) Decrypt asset with package name


### :gear: Development

Make sure to install kavanoz as editable (with -e). To add new plugins just create new file in loader folder. Extend Unpacker class from unpack_plugin.py file. Define start_decrypt function with your implementation. 
```py
def start_decrypt(self, apk_object: APK, dexes: "list[DEX]"):
```

Add following function to make early exit from plugin. 
```py
def lazy_check(self,apk_object:APK, dexes: "list[DEX]"):
```

If extraction is successful assign self.decrypted_payload_path with extracted file path.
You can use helper functions from unpacker class:
- get_array_data
- get_smali
- find_method(class_name,method_name,descriptor="")
- check_and_write_file(file_data) : checks file has dex, zip and zlib headers and writes unpacked dex with name : "external-{m[:8]}.dex"

Make sure to run `python -m unittest` before opening a PR. In order to get test apk files, use `git lfs pull` command.

### :book: Tips

- self.dexes hold dex objects. You can get class with `dex.get_class(smali_annotation_of_class)`.
- You can use get_smali function and give target method obj to get smali represantation of target method. Then apply some regex to get data from smali. There are lots of defined regexs in [smali_regexes.py](src/kavanoz/smali_regexes.py) file to lookup. 
- Most of the time packers use file from asset folder. You can get files with `self.apk_object.get_files()` 
- Most of the time packers use Application class to start unpacking sequence. Use `application = self.apk_object.get_attribute_value("application", "name")` to get application class defined in manifest file. 

### Thanks:
[apkdetect.com](https://apkdetect.com) for unique samples to work with. 


```

`assets/demo.tape`:

```tape
Output unpack.gif
Set Shell zsh
Sleep 1s
Type "kavanoz coper.apk"
Enter
Sleep 1s
Type "kavanoz inflate.apk"
Enter
Sleep 4.5s
Type "kavanoz loader_rc4_key_0.apk"
Enter
Sleep 2.5s
Type "kavanoz multiple_rc4_init.apk"
Enter
Sleep 3s


```

`pyproject.toml`:

```toml
[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "kavanoz"
version = "0.0.6"
keywords = ["android","malware","unpacking","packer"]
license = {text="MIT License"}
readme = "README.md"
description = "Unpacking framework for common android malware"
dynamic = ["dependencies"]
authors = [
  {email = "eybisii@gmail.com"},
  {name = "Ahmet Bilal Can"}
]
maintainers = [
  {name = "Ahmet Bilal Can", email = "eybisii@gmail.com"}
]
[tool.setuptools.dynamic]
dependencies = {file = ['requirements.txt']}
[project.scripts]
kavanoz = "kavanoz.core:cli"
[tool.setuptools.packages.find]
# All the following settings are optional:
where = ["src"]  # ["."] by default
include = ["*"]  # ["*"] by default
namespaces = true  # true by default
[tool.setuptools.package-data]
kavanoz = ["loader/androidnativeemu/libc.so"]

```

`requirements.txt`:

```txt
androguard>=4.0.1
apkInspector>=1.2.1
androidemu>=0.0.4
arc4>=0.3.0
halo>=0.0.31
lief>=0.16.3
loguru>=0.7.2
pycryptodome>=3.19.1

```

`src/kavanoz/core.py`:

```py
from androguard.core.apk import APK
from androguard.core.dex import DEX
from androguard import util
from kavanoz.unpack_plugin import Unpacker
from kavanoz import plugin_loader, utils
from kavanoz.utils import InterceptHandler
from loguru import logger
import logging
import time
import kavanoz.loader
import click
import sys
from halo import Halo


logger.disable("androguard")

class Kavanoz:
    def __init__(
        self,
        apk_path: str | None = None,
        apk_object=None,
        output_dir: str | None = None,
    ):
        self.output_dir = output_dir
        mod_logger = logging.getLogger("androidemu")
        mod_logger.handlers = [InterceptHandler(level=logging.CRITICAL)]
        mod_logger.propagate = False
        s = time.time()
        if apk_object:
            self.apk_object = apk_object
        elif apk_path:
            self.apk_object = APK(apk_path)

        # load plugins
        self.plugins = [
            subplug
            for plugin in filter(None, plugin_loader.get_plugins())
            for subplug in plugin
        ]
        e = time.time()
        logger.info(f"Androguard took : {e-s} seconds")
        s = time.time()
        self.dexes = [DEX(dex) for dex in self.apk_object.get_all_dex()]
        e = time.time()
        logger.info(f"Androguard dvm took : {e-s} seconds")

    def get_plugin_results(self):
        for plugin in self.plugins:
            p = plugin(self.apk_object, self.dexes, output_dir=self.output_dir)
            yield p.main()

    def is_packed(self):
        p = Unpacker(
            "test",
            "test",
            apk_object=self.apk_object,
            dexes=self.dexes,
            output_dir=self.output_dir,
        )
        return p.is_packed()


@click.command()
@click.argument("filename", type=click.Path(exists=True))
@click.option(
    "--output-dir",
    "-o",
    type=click.Path(exists=True),
    default=".",
    help="Output directory path",
)
@click.option("-v", "--verbose", count=True)
def cli(filename, output_dir, verbose):
    logger.remove()
    if verbose > 0:
        if verbose > 3:
            verbose = 3
        logger.add(sys.stderr, level=40-verbose*10)
    spinner = Halo(text="Extracting apk/dex information", spinner="star")
    spinner.start()
    k = Kavanoz(filename, output_dir=output_dir)
    spinner.stop()
    spinner.start()
    if not k.is_packed():
        spinner.warn("Sample is not packed")
    for res in k.get_plugin_results():
        spinner.text = f'Plugin {res["tag"]} is running'
        spinner.start()
        if res["status"] == "success":
            m = f"""Plugin tag : {res['tag']} 
Plugin description : {res['name']} 
Output file : {res['output_file']} """
            spinner.text_color = "green"
            spinner.stop_and_persist("âœ¨", "Unpacked successfully!")
            print(m)
            break
    else:
        spinner.stop_and_persist("âŒ", "Cannot unpack")

```

`src/kavanoz/debug_utils.py`:

```py
import logging

from unicorn.arm_const import *

logger = logging.getLogger(__name__)


def hook_code(uc, address, size, user_data):
    instruction = uc.mem_read(address, size)
    instruction_str = "".join("{:02x} ".format(x) for x in instruction)

    logger.debug(
        "# Tracing instruction at 0x%x, instruction size = 0x%x, instruction = %s"
        % (address, size, instruction_str)
    )

    if instruction == b"\x00\x00\x00\x00":
        logger.error("Uh oh, we messed up.")
        uc.emu_stop()


def hook_block(uc, address, size, user_data):
    instruction = uc.mem_read(address, size)
    instruction_str = "".join("{:02x} ".format(x) for x in instruction)

    logger.debug(
        "# Block at 0x%x, instruction size = 0x%x, instruction = %s"
        % (address, size, instruction_str)
    )


def hook_unmapped(uc, access, address, length, value, context):
    pc = uc.reg_read(UC_ARM_REG_PC)

    logger.debug(
        "mem unmapped: pc: %x access: %x address: %x length: %x value: %x"
        % (pc, access, address, length, value)
    )
    uc.emu_stop()
    return True


def hook_mem_write(uc, access, address, size, value, user_data):
    pc = uc.reg_read(UC_ARM_REG_PC)
    logger.debug(
        ">>> Memory WRITE at 0x%x, data size = %u, data value = 0x%x, pc: %x"
        % (address, size, value, pc)
    )


def hook_mem_read(uc, access, address, size, value, user_data):
    pc = uc.reg_read(UC_ARM_REG_PC)
    data = uc.mem_read(address, size)
    logger.debug(
        ">>> Memory READ at 0x%x, data size = %u, pc: %x, data value = 0x%s"
        % (address, size, pc, data.hex())
    )


def hook_interrupt(uc, intno, data):
    logger.debug(">>> Triggering interrupt %d" % intno)
    return

```

`src/kavanoz/loader/appsealing.py`:

```py
from androguard.core.apk import APK
from androguard.core.dex import DEX
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderAppsealing(Unpacker):
    def __init__(self, apk_obj: APK, dexes, output_dir):
        super().__init__(
            "loader.appsealing", "Appsealing unpacker", apk_obj, dexes, output_dir
        )

    def lazy_check(self, apk_object, dvms):
        for f in self.apk_object.get_files():
            if "assets/AppSealing" in f:
                return True

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Not implemented yet")
        return

```

`src/kavanoz/loader/coper.py`:

```py
from androguard.core.apk import APK
from androguard.core.axml import ARSCParser, ARSCResType
from androguard.core.dex import DEX
from androidemu.emulator import Emulator
from androidemu.utils.memory_helpers import read_utf8
from unicorn.unicorn_const import UC_HOOK_MEM_READ_UNMAPPED, UC_HOOK_MEM_UNMAPPED

from unicorn import UC_HOOK_CODE
import unicorn
from unicorn.arm_const import *
import lief
from arc4 import ARC4
from kavanoz.unpack_plugin import Unpacker
import os


class LoaderCoper(Unpacker):
    def __init__(self, apk_obj, dvms, output_dir):
        super().__init__(
            "loader.coper", "Unpacker for coper", apk_obj, dvms, output_dir
        )

    def lazy_check(self, apk_object: APK, dvms: list[DEX]) -> bool:
        arm32_native_libs = [
            filename
            for filename in self.apk_object.get_files()
            if filename.startswith("lib/armeabi-v7a")
        ]
        if len(arm32_native_libs) >= 5:
            self.logger.info(
                "Found more than 5 native libs, this is probably NOT a coper"
            )
            return False
        else:
            self.logger.info("Found less than 5 native libs, this is probably a coper")
            return True

    def start_decrypt(self, native_lib: str = ""):
        arm32_native_libs = [
            filename
            for filename in self.apk_object.get_files()
            if filename.startswith("lib/armeabi-v7a")
        ]
        if len(arm32_native_libs) == 0:
            self.logger.info("No native lib ðŸ˜”")
            return
        if len(arm32_native_libs) != 1:
            self.logger.info("Not sure this is copper but continue anyway")

        for arm32_lib in arm32_native_libs:
            self.logger.info(f"Trying to decrypt with {arm32_lib}")
            if self.decrypt_library(arm32_lib):
                return

    def decrypt_library(self, native_lib: str) -> bool:
        fname = native_lib.split("/")[-1]
        with open(fname, "wb") as fp:
            fp.write(self.apk_object.get_file(native_lib))
        self.target_lib = fname
        # Show loaded modules.
        self.resolved_strings = []
        if not self.init_lib():
            return
        self.logger.info("Loaded modules:")
        if not self.setup_hook():
            self.logger.info("Failed to setup hooks maybe no srtcat symbol ?")
            self.logger.info("Trying to find strings in stack")
        # self.emulator.mu.hook_add(UC_HOOK_CODE, self.hook_debug_print)
        self.emulator.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED, self.hook_unmapped_read)

        try:
            self.emulator.call_symbol(self.target_module, self.target_function.name)
        except Exception as e:
            self.logger.info(f"Exception while calling symbol: {e}")
            if len(self.resolved_strings) == 0:
                self.logger.info("No strings found")
                return
        self.logger.info(f"Androidemu extracted rc4 key: {self.resolved_strings[0]}")
        if self.decrypt_files(self.resolved_strings[0]):
            self.logger.info("Decryption successful")
            os.remove(self.target_lib)
            return True
        else:
            # Now this can be because dex\n035 is added after decryption of thhe file. We can also get file name from resolved strings.
            if len(self.resolved_strings) == 2 and self.apk_object.get_package() in self.resolved_strings[1]:
                # This is tricky part. Sometimes :raw points to different point from resources.arsc/raw..
                # But instead we can search .../raw/filename in all files
                enc_filename = self.resolved_strings[1].split(":")[1]
                self.logger.debug(f"Looking for file : {enc_filename}")
                for f in self.apk_object.get_files():
                    if enc_filename in f:
                        if self.decrypt_file(self.resolved_strings[0],f):
                            os.remove(self.target_lib)
                            return True
                    else:
                        # Here we go...
                        # I dont know this is obfuscation or something else with androguard library
                        # We need to manually find mapping of res/somefile with raw/targetfile by parsing resources.arsc
                        arsc_file = self.apk_object.get_file("resources.arsc")
                        arsc_parser = ARSCParser(arsc_file)
                        # Find item <ARSCResType(start=0x3e0, id=0x2, flags=0x0, entryCount=2, entriesStart=0x5c, mResId=0x7f020000, table:raw)>
                        # then next item will be rids of raw files [(0, 2130837504), (16, 2130837505)]
                        items = arsc_parser.get_items(package_name=self.apk_object.get_package())
                        for i in range(len(items)):
                            if type(items[i]) ==  ARSCResType:
                                # Found res type
                                if items[i].get_type() == "raw":
                                    # Found raw type
                                    # items[i+1] hold list of resource ids of raw type files
                                    rids = [x[1] for x in items[i+1]]
                                    self.logger.debug(f"Found rids : {rids}")
                                    for rid in rids:
                                        curr_res_config = arsc_parser.get_resolved_res_configs(rid=rid)
                                        xml_name = arsc_parser.get_resource_xml_name(r_id=rid)
                                        if enc_filename in xml_name and len(curr_res_config) > 0:
                                            curr_res_file_name = curr_res_config[0][1]
                                            if self.decrypt_file(self.resolved_strings[0],curr_res_file_name):
                                                os.remove(self.target_lib)
                                                return True

                        return False
        os.remove(self.target_lib)
        return False

    def decrypt_files(self, rc4key: str):
        for filepath in self.apk_object.get_files():
            fd = self.apk_object.get_file(filepath)
            dede = ARC4(rc4key.encode("utf-8"))
            dec = dede.decrypt(fd)
            if self.check_and_write_file(dec):
                return True
        return False

    def decrypt_file(self,rc4key:str, filename:str):
        fd = self.apk_object.get_file(filename)
        arc4 = ARC4(rc4key.encode("utf-8"))
        dec = arc4.decrypt(fd)
        dec = b"dex\n035" + dec
        if self.check_and_write_file(dec):
            return True
        return False


    def init_lib(self):
        target_ELF = lief.ELF.parse(self.target_lib)
        java_exports = [
            jf for jf in target_ELF.exported_functions if jf.name.startswith("Java_")
        ]
        if len(java_exports) == 0:
            return False
        if len(java_exports) > 1:
            self.logger.info("Not sure this is copper but continue anyway")

        self.target_function = java_exports[0]
        # Configure logging

        # Initialize emulator
        self.emulator = Emulator(vfp_inst_set=True)
        libc_path = os.path.join(os.path.dirname(__file__), "androidnativeemu/libc.so")
        self.emulator.load_library(libc_path, do_init=False)
        self.target_module = self.emulator.load_library(self.target_lib, do_init=False)
        return True

    def hook_debug_print(self, uc, address, size, user_data):
        instruction = uc.mem_read(address, size)
        instruction_str = "".join("{:02x} ".format(x) for x in instruction)

        print(
            "# Tracing instruction at 0x%x, instruction size = 0x%x, instruction = %s"
            % (address, size, instruction_str)
        )

    def hook_unmapped_read(self, uc, access, address, size, value, user_data):
        # Read stack and print it byte per byte
        self.logger.debug("Trying to read from address : %x" % address)
        sp = uc.reg_read(UC_ARM_REG_SP)
        bp = uc.reg_read(UC_ARM_REG_R11)
        self.logger.debug(f"Stack pointer: {hex(sp)}, Base pointer: {hex(bp)}")

        # Problem here is we don't know the size of the stack data
        # If we read too much we will get unmapped memory error
        # But we can extract stack size from function prologue

        stack_size = self.extract_stack_size_from_function_prologue(
            self.emulator.uc, self.target_function, self.target_lib_base
        )
        if stack_size == 0:
            return
        stack_data = uc.mem_read(sp, stack_size)
        # Stack data contains list of strings ends with \x00 but there are also
        # filler \x00 bytes in between them. We need to split them.
        stack_data = stack_data.split(b"\x00")
        # Filter out empty strings
        stack_data = [x for x in stack_data if x != b""]
        # Decode strings
        stack_data = [x for x in stack_data]
        self.logger.debug(f"Stack data: {stack_data}")
        self.resolved_strings.append(stack_data[-1].decode("utf-8"))
        # Print stack

    def setup_hook(self):
        for module in self.emulator.modules:
            if module.filename == self.target_lib:
                self.logger.info("[0x%x] %s" % (module.base, module.filename))
                self.target_lib_base = module.base
                # emulator.mu.hook_add(
                # UC_HOOK_CODE,
                # hook_code,
                # begin=module.base + java_func_obj.address,
                # end=module.base + java_func_obj.address + (0x2198 - 0x1FC1),
                # )
                strncat = module.find_symbol("__strncat_chk")
                if strncat == None:
                    self.logger.info("No strncat symbol ðŸ˜”")

                    self.logger.info("maybe octo2 ?")
                    unpack_dynlib = module.find_symbol("_ZN8WrpClass13unpack_dynlibEv")
                    if unpack_dynlib == None:
                        self.logger.info("No unpack_dynlib symbol ðŸ˜”")
                        return False
                    self.logger.debug(f"{hex(unpack_dynlib.address)} unpack_dynlib addr")
                    replace_loader = module.find_symbol("_ZN8WrpClass14replace_loaderEb")

                    self.emulator.uc.hook_add(
                        UC_HOOK_CODE,
                        self.hook_unpack_dynlib,
                        begin=unpack_dynlib.address,
                        end=unpack_dynlib.address + 1,
                        user_data=replace_loader.address,
                    )
                    return False
                self.logger.debug(f"{hex(strncat.address)} strcat_chk addr")
                self.emulator.uc.hook_add(
                    UC_HOOK_CODE,
                    self.hook_strncat,
                    begin=strncat.address,
                    end=strncat.address + 1,
                )
                self.emulator.uc.hook_add(UC_HOOK_MEM_UNMAPPED, self.hook_mem_read)
                self.emulator.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED, self.hook_mem_read)
                return True
        return False

    def hook_mem_read(self, uc, access, address, size, value, user_data):
        pc = uc.reg_read(UC_ARM_REG_PC)
        data = uc.mem_read(address, size)
        self.logger.debug(
            ">>> Memory READ at 0x%x, data size = %u, pc: %x, data value = 0x%s"
            % (address, size, pc, data.hex())
        )

    def hook_strncat(self, uc: unicorn.unicorn.Uc, address, size, user_data):
        # print(f"current strncat hook addr : {hex(address)}")
        r0 = uc.reg_read(UC_ARM_REG_R0)
        # print(f"current strncat hook r0 : {hex(r0)}")
        r1 = uc.reg_read(UC_ARM_REG_R1)
        max_size = uc.reg_read(UC_ARM_REG_R2)
        # print(f"current strncat hook r1 : {hex(r1)}")
        cur_key = read_utf8(uc, r0)
        added = read_utf8(uc, r1)
        final_str = cur_key + added
        if len(final_str) == max_size - 1:
            self.logger.debug(f"current strncat hook final_str : {final_str}")
            self.resolved_strings.append(final_str)
            if len(self.resolved_strings) > 10:
                self.emulator.uc.emu_stop()

    def hook_unpack_dynlib(self, uc: unicorn.unicorn.Uc, address, size, user_data):

        self.logger.debug("unpack_dynlib triggered : %x" % address)
        sp = uc.reg_read(UC_ARM_REG_SP)
        self.logger.debug(f"Stack pointer: {hex(sp)}")
        # Problem here is we don't know the size of the stack data, we can go back calle function
        # and read prologue to extract stack size

        # Get stack size from replace_loader

        should_be_subw = uc.mem_read(
            user_data - 1 + 8, 0x4
        )
        if should_be_subw[1] != 0xb0:
            self.logger.debug("Bad instruction to find stack size")
            return 0
        # a6b0 -> read 0xa6 &= 0x7f
        stack_size = (should_be_subw[0] & 0x7f ) << 2

        self.logger.debug(f"Found stack size at replace_loader : {stack_size}")
        stack_data = uc.mem_read(sp, stack_size+12)
        # Stack data contains list of strings ends with \x00 but there are also
        # filler \x00 bytes in between them. We need to split them.
        stack_data = stack_data.split(b"\x00")
        # Filter out empty strings
        stack_data = [x for x in stack_data if x != b""]
        # Decode strings
        stack_data = [x for x in stack_data]
        self.logger.debug(f"Stack data: {stack_data}")
        # Some sanity checks
        if len(stack_data) > 5:
            # example stack strings:
            # - Q3DCe5ZIFftphISZwNpNYy4vA1Qvyyjt
            # - replace_loader
            # - 7a1bc825b313fd55
            # - b313fd551c1f219b
            # - com.handedfastee5
            # - com.handedfastee5:raw/kyndwjzbyg0
            # get rc4 key
            self.resolved_strings.append(stack_data[-1].decode("utf-8"))
            # walk backward and find raw file
            stack_data.reverse()
            for i in range(0,len(stack_data),2):
                if stack_data[i] in stack_data[i+1]:
                    # we found the file
                    self.logger.debug(f'RC4 encrypted file name : {stack_data[i+1].decode("utf-8")}')
                    self.resolved_strings.append(stack_data[i+1].decode("utf-8"))
                    break


            self.emulator.uc.emu_stop()

    def extract_stack_size_from_function_prologue(
        self, uc, target_function, target_lib_base
    ) -> int:
        # 00001ee8  f0b5       push    {r4, r5, r6, r7, lr} {var_4} {__saved_r7} {__saved_r6} {__saved_r5} {__saved_r4}
        # 00001eea  03af       add     r7, sp, #0xc {__saved_r7}
        # 00001eec  2de9000f   push    {r8, r9, r10, r11} {__saved_r11} {__saved_r10} {__saved_r9} {__saved_r8}
        # 00001ef0  adf2144d   subw    sp, sp, #0x414

        # We need 4th instruction, if its sub/subw with parameters sp,sp then get the value
        # of the last parameter
        # F it just read bytes
        # -1 is for thumb mode
        should_be_subw = uc.mem_read(
            target_lib_base + target_function.value - 1 + 8, 0x4
        )
        if should_be_subw[0] != 0xAD:
            return 0
        # adf2144d -> read 0x14 and 0x4d bytes -> convert it to 0x414

        stack_size = should_be_subw[2] | (((should_be_subw[3] & 0xF0) >> 4) << 8)
        self.logger.info(f"Stack size must be {hex(stack_size)}")
        return stack_size

    # def hook_code(self,uc: unicorn.unicorn.Uc, address, size, user_data):
    # global rc4_key
    # if address == coper_base + java_func_obj.address + (0x2198 - 0x1FC1):
    # sp = uc.reg_read(UC_ARM_REG_SP)
    # rc4_key = read_utf8(uc, sp + 0x46F)

    # print(
    # "# Tracing instruction at 0x%x, instruction size = 0x%x, instruction = %s"
    # % (address, size, instruction_str)
    # )
    # if instruction[0] == 0xA0 and instruction[1] == 0x47 and len(instruction) == 2:
    # r1 = uc.reg_read(UC_ARM_REG_R1)
    # print(r1)
    # print(uc.mem_read(r1, 1))

```

`src/kavanoz/loader/crocodilus.py`:

```py
from Crypto.Cipher import AES

from androguard.core.apk import APK
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import unpad_pkcs5


class LoaderCrocodilus(Unpacker):
    """
    Read asset files. Try to decrypt with AES; key [32:48] iv [48:64], size [64:72], data [72:]
    """

    def __init__(self, apk_obj: APK, dvms, output_dir):
        super().__init__(
            "loader.Crocodilus", "Unpacker for crocodilus", apk_obj, dvms, output_dir
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt for Crocodilus")
        self.decrypted_payload_path = None
        self.brute_assets()

    def brute_assets(self):
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            if "assets/" in filepath:
                f = self.apk_object.get_file(filepath)
                if self.solve_encryption(f):
                    self.logger.info(
                        f"Decryption finished! {self.decrypted_payload_path}, found it in {filepath}"
                    )

    def solve_encryption(self, file_data):
        if len(file_data) < 72:
            return
        aes_key = file_data[32:48]
        aes_iv = file_data[48:64]
        aes_size = file_data[64:72]
        aes_data = file_data[72:]
        if len(aes_data) % 16 != 0:
            return
        aes_size = int.from_bytes(aes_size, "big")
        cipher = AES.new(aes_key, AES.MODE_CBC, aes_iv)
        dec_data = cipher.decrypt(aes_data)
        try:
            dec_data = unpad_pkcs5(dec_data)
        except ValueError:
            # self.logger.error("Unpadding failed")
            return
        if len(dec_data) != aes_size:
            return
        if self.check_and_write_file(dec_data):
            return True
        else:
            return False

```

`src/kavanoz/loader/kangapack.py`:

```py
from androguard.core.apk import APK
from kavanoz.unpack_plugin import Unpacker
from Crypto.Cipher import AES
from kavanoz.unpack_plugin import Unpacker
import lief


class LoaderKangaPack(Unpacker):
    """
    ref: https://cryptax.medium.com/inside-kangapack-the-kangaroo-packer-with-native-decryption-3e7e054679c4
    encrypted file is appended to end of classes.dex
    aes decryption key/iv is in native library used with openssl evp api, keys are exported
    """

    def __init__(self, apk_obj, dvms, output_dir):
        super().__init__(
            "loader.kangapack", "Unpacker for kangapack", apk_obj, dvms, output_dir
        )

    def start_decrypt(self, native_lib: str = ""):
        # Get encrypted payload
        classes_dex = lief.DEX.parse(list(self.apk_object.get_dex()))
        dex_headers = classes_dex.header
        link_off, link_size = dex_headers.link
        enc_offset = 0
        if link_off == 0 and link_size == 0:
            off, size = dex_headers.data
            if dex_headers.file_size > off + size:
                enc_offset = off + size
        if enc_offset == 0:
            return

        enc_payload = self.apk_object.get_dex()[enc_offset:]
        payload_size = enc_payload[len(enc_payload) - 4 :]
        enc_payload = enc_payload[: len(enc_payload) - 4]
        native_libs = [
            filename
            for filename in self.apk_object.get_files()
            if filename.startswith("lib/arm64-v8a/libapk")
        ]
        if len(native_libs) == 0:
            self.logger.info("No native lib ðŸ˜”")
            return
        if len(native_libs) != 1:
            self.logger.info("Not sure this is kangapack but continue anyway")

        fname = native_libs[0].split("/")[-1]
        self.target_lib = fname
        elf_bin = lief.ELF.parse(
            list(self.apk_object.get_file(f"lib/arm64-v8a/{self.target_lib}"))
        )
        for sym in elf_bin.exported_symbols:
            if sym.name == "AES_SECRET_KEY":
                rel = elf_bin.get_relocation(sym.value)
                # get lots of bytes then split by null byte :(
                str_arr = elf_bin.get_content_from_virtual_address(rel.addend, 40)
                str_arr = str_arr.tolist()
                an = str_arr[: str_arr.index(0)]
                secret_key = "".join(chr(x) for x in an).encode()
                iv = secret_key
                cipher = AES.new(secret_key, AES.MODE_CBC, iv)
                decrypted = cipher.decrypt(enc_payload)
                if self.check_and_write_file(decrypted):
                    self.logger.info(f"Decrypted dex with key {secret_key}")
                    return True
        return False

    def lazy_check(self, apk_object: APK, dvms: "list[DEX]") -> bool:
        dex_bytes = apk_object.get_dex()
        if len(dex_bytes) > 0:
            try:
                classes_dex = lief.DEX.parse(list(dex_bytes))
            except Exception as e:
                # print(e)
                return False
            dex_headers = classes_dex.header
            link_off, link_size = dex_headers.link

            if link_off == 0 and link_size == 0:
                off, size = dex_headers.data
                if dex_headers.file_size > off + size:
                    return True
        return False

```

`src/kavanoz/loader/moqhao.py`:

```py
from androguard.core.apk import APK
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderMoqhao(Unpacker):
    """
    Read asset files. Try to decrypt with : file[11] is xor key to decrypt file[12:]
    """

    def __init__(self, apk_obj: APK, dvms, output_dir):
        super().__init__(
            "loader.moqhao", "Unpacker for moqhao", apk_obj, dvms, output_dir
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        self.decrypted_payload_path = None
        self.brute_assets()

    def brute_assets(self):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            if "assets/" in filepath:
                f = self.apk_object.get_file(filepath)
                if self.solve_encryption(f):
                    self.logger.info(
                        f"Decryption finished! {self.decrypted_payload_path}"
                    )
                else:
                    if self.solve_encryption_native(f):
                        self.logger.info(
                            f"Decryption finished! {self.decrypted_payload_path}"
                        )

    def lazy_check(self, apk_obj, dvms) -> bool:
        file_list = apk_obj.get_files()
        one_asset = any("assets/" in x for x in file_list)
        native_lib = any("lib/" in x for x in file_list)
        return one_asset and native_lib

    def solve_encryption(self, file_data):
        if len(file_data) < 12:
            return
        first_12 = file_data[:12]
        xor_key = first_12[11].to_bytes(1, "little")
        xord_data = xor(file_data[12:], xor_key)
        if self.check_and_write_file(xord_data):
            return True
        else:
            return False

    def solve_encryption_native(self, file_data):
        if len(file_data) < 24:
            return
        first_12 = file_data[:24]
        xor_key = first_12[16].to_bytes(1, "little")
        xord_data = xor(file_data[24:], xor_key)
        if self.check_and_write_file(xord_data):
            return True
        else:
            return False

```

`src/kavanoz/loader/multidex.py`:

```py
from androguard.core.apk import APK
import zlib
from androguard.core.dex import DEX, EncodedMethod
import re
import ctypes
import string
from kavanoz import utils
from kavanoz.unpack_plugin import Unpacker


def unsigned_rshift(val, n):
    unsigned_integer = val % 0x100000000
    return unsigned_integer >> n


def unsigned_lshift(val, n):
    unsigned_integer = val % 0x100000000
    return unsigned_integer << n


class LoaderMultidex(Unpacker):
    ProtectKey = ""

    def __init__(self, apk_obj, dexes, output_dir):
        super().__init__(
            "loader.multidex",
            "Unpacker for multidex variants",
            apk_obj,
            dexes,
            output_dir,
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        z = self.apk_object.get_android_manifest_xml()
        if z != None:
            f = z.find("application")
            childs = f.getchildren()
            self.ProtectKey = None
            for child in childs:
                if child.tag == "meta-data":
                    if (
                        child.attrib["{http://schemas.android.com/apk/res/android}name"]
                        == "ProtectKey"
                    ):
                        self.ProtectKey = child.attrib[
                            "{http://schemas.android.com/apk/res/android}value"
                        ]
                        self.logger.info(f"Found protect key {self.ProtectKey}")
            if self.ProtectKey != None:
                if self.find_decrypt_protect_arrays():
                    self.logger.info("Found key in manifest/xor")
                    return

        self.decrypted_payload_path = None
        zip_functions = self.find_zip_function()
        for zip_function in zip_functions:
            _function, dvm = zip_function
            variable = self.extract_variable_from_zip(_function, dvm)
            if variable is not None:
                key = self.find_clinit_target_variable(variable)
                if key is not None:
                    if self.brute_assets(key):
                        if self.is_really_unpacked():
                            self.logger.info("fully unpacked")
                        else:
                            self.logger.info("not fully unpacked")
                        return
        else:
            self.logger.info("Cannot find zip function")
            self.logger.info("Second plan for zipper")
            r = self.second_plan()
            if r is not None:
                self.logger.info("Second plan worked")
                self.logger.info(f"{r}")
                return
            else:
                self.logger.info("Second plan failed")
                self.third_plan()
        is_default = self.default_dex_protector()
        if is_default != None:
            for key in is_default:
                self.logger.info(f"Trying default dex protector key {key}")
                if self.brute_assets(key):
                    if self.is_really_unpacked():
                        self.logger.info("fully unpacked")
                    else:
                        self.logger.info("not fully unpacked")
                    return

    def third_plan(self):
        """
        public class ldhgedudr {
            public static void fslstmkpgcrup(InputStream input, OutputStream output) throws Exception {
                InflaterInputStream is = new InflaterInputStream(input);
                InflaterOutputStream os = new InflaterOutputStream(output);
                swtj(is, os);
                os.close();
                is.close();
            }

            private static void swtj(InputStream inputStream, OutputStream outputStream) throws Exception {
                char[] key = rtpgi.kphimwvplfd.toCharArray();
        """
        input_initials = self.find_input_output_stream()
        for input_initial in input_initials:
            if input_initial is not None:
                self.logger.info("Found input output stream")
                _function, dvm = input_initial
                self.logger.info(f"{_function}")
                key = self.extract_variable_for_third_plan(_function, dvm)
                if key is not None:
                    key = utils.unescape_unicode(key)
                    self.logger.info(f"Found key : {key}")
                    if self.brute_assets(key):
                        if self.is_really_unpacked():
                            self.logger.info("fully unpacked")
                        else:
                            self.logger.info("not fully unpacked")
                        return

        return None

    def extract_variable_for_third_plan(self, target_method: EncodedMethod, dvm):
        smali_str = self.get_smali(target_method)
        """
        0059925c: 6200 9e53               0000: sget-object         v0, Lwhg/wwtgweg/mtgmdloqs/tduk/rtpgi;->kphimwvplfd:Ljava/lang/String; # field@539e
        00599260: 6e10 5099 0000          0002: invoke-virtual      {v0}, Ljava/lang/String;->toCharArray()[C # method@9950
        00599266: 0c00                    0005: move-result-object  v0
        """
        match = re.findall(
            r"sget-object [vp]\d+, (L[^;]+;->[^\(]+) Ljava/lang/String;\s+"
            r"invoke-virtual {?[vp]\d+}?, Ljava/lang/String;->toCharArray\(\)\[C",
            smali_str,
        )
        if len(match) == 0:
            self.logger.info(
                f"Unable to extract variable from {target_method.get_name()}"
            )
            self.logger.info("Exiting ...")
            return None
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
            key_variable = match[0].split("->")[1]
            key_class = match[0].split("->")[0]
            method = self.find_method(key_class, "<clinit>")
            if method:
                smali_str = self.get_smali(method)
                # 0059a656: 1a00 7884               0039: const-string        v0, "ææœæžæ€æ•ææ›æŸæŸæ‡ææ•æ‘æ€æœæŠæƒæƒæ‘æ•æ†æ›æ„æ€æ²æƒæƒ" # string@8478
                # 0059a65a: 7120 b897 1000          003b: invoke-static       {v0, v1}, Lehl/vlnirvo/rwipgpued/dnhwp/fstmjrrront;->hfuojgtnouejrq(Ljava/lang/String;, I)Ljava/lang/String; # method@97b8
                key_variable = re.findall(
                    r"const-string [vp]\d+, \"(.*)\"\s+"
                    f"sput-object v0, {match[0]} Ljava/lang/String;",
                    smali_str,
                )
                if len(key_variable) == 1:
                    self.logger.info(
                        f"Found key variable from zip class <clinit> {key_variable[0]}"
                    )

                    return key_variable[0]
                else:
                    self.logger.info("Not found key variable from clinit")
                    self.logger.info(f"{smali_str}")
                    return None
            else:
                self.logger.info(
                    f"Not found <clinit> method for class {target_method.class_name}"
                )
                return None
        else:
            self.logger.info("Something is wrong .. ðŸ¤”")
            self.logger.info("Found multiple ?? : {match}")
            return None

    def default_dex_protector(self):
        target_class = self.find_class_in_dvms(
            "Landroid/support/dexpro/utils/DexCrypto;"
        )
        str_decrypt_keys = set()
        if target_class != None:
            self.logger.info("Found default dex protector class")
            # Find static field with name "KEY"
            for field in target_class.get_fields():
                rc4_string_variable = None
                if field.get_descriptor() != "Ljava/lang/String;":
                    continue
                if field.get_init_value() != None and field.get_init_value != "":
                    self.logger.info(
                        f"Found static key : {field.get_init_value().get_value()}"
                    )
                    static_rc4_string = field.get_init_value().get_value()
                    if static_rc4_string != None:
                        str_decrypt_keys.add(static_rc4_string)
                else:
                    if (
                        "0x0" == field.get_access_flags_string()
                        or "protected final" == field.get_access_flags_string()
                        or "" == field.get_access_flags_string()
                    ):
                        rc4_string_variable = field.get_name()

        # Find ProxyApplication
        # application = self.apk_object.get_attribute_value("application", "name")
        application_smali = self.find_main_application()
        target_method = self.find_method(application_smali, "<init>")
        self.logger.info(
            f"Found application class : {application_smali} target_method : {target_method}"
        )
        if target_method == None:
            self.logger.info("Unable to find target_method class")
            return
        smali_str = self.get_smali(target_method)

        # const-string v0, '4743504252544340435744245230474050425254'
        # invoke-static v0, Landroid/support/dexpro/utils/DexCrypto;->ab(Ljava/lang/String;)Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v1, Lxyz/magicph/dexpro/ProxyApplication;->protectKey Ljava/lang/String
        # const-string v0, "4743504252544340435744245230474050425254"
        # invoke-static v0, Landroid/support/dexpro/utils/DexCrypto;->ab(Ljava/lang/String;)Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v1, Lxyz/magicph/dexpro/ProxyApplication;->protectKey Ljava/lang/String;
        # Get const string from smali_str
        key_variable = re.findall(
            r"const-string(?:/jumbo)? [vp]\d+, \"(.*)\"\s+"
            r"invoke-static [vp]\d+, Landroid/support/dexpro/utils/DexCrypto;->[^\(]+\(Ljava/lang/String;\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            r"iput-object [vp]\d+, [vp]\d+, L[^;]+;->protectKey Ljava/lang/String",
            smali_str,
        )
        r = set()
        if len(key_variable) == 1:
            self.logger.info(
                f"Found key variable from zip class <clinit> {key_variable[0]}"
            )
            x = bytes.fromhex(key_variable[0])
            for s in str_decrypt_keys:
                file_dec_key = utils.xor(x, s.encode())
                r.add(file_dec_key)

        # return set of file_Dec_key
        return r

    def second_plan(self):
        application_smali = self.find_main_application()
        target_method = self.find_method(application_smali, "<init>")

        if target_method == None:
            return None
        smali_str = self.get_smali(target_method)
        """
        sget-object v0, Lb;->f:Ljava/lang/String;
        invoke-static {v0}, Lc;->b(Ljava/lang/String;)Ljava/lang/String;
        move-result-object v0
        """
        match = re.findall(
            r"sget-object [vp]\d+, (L[^;]+;->[^ ]+) Ljava/lang/String;\s+"
            r"invoke-static {?[vp]\d+}?, L[^;]+;->[^\(]+\(Ljava/lang/String;\)Ljava/lang/String",
            smali_str,
        )
        for matched_field in match:
            key = self.find_clinit_target_variable(matched_field)
            key = utils.unescape_unicode(key)

            if key != None:
                xor_k = 0x6033
                tmp_key = "".join(chr(xor_k ^ ord(c)) for c in key)
                self.logger.info(f"Is this a key ??? {tmp_key}")
                if tmp_key is not None:
                    if all(c in string.printable for c in tmp_key):
                        asset_list = self.apk_object.get_files()
                        for filepath in asset_list:
                            f = self.apk_object.get_file(filepath)
                            if self.solve_encryption(
                                f, tmp_key
                            ) or self.solve_encryption2(f, tmp_key):
                                return True
                    else:
                        return False

        return None

    def find_zip_function(self):
        target_methods = []
        target_method = None
        for d in self.dexes:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor()
                        == "(Ljava/util/zip/ZipFile; Ljava/util/zip/ZipEntry; Ljava/io/File; Ljava/lang/String;)V"
                    ):
                        self.logger.info("Found method")
                        target_method = m
                        target_methods.append((target_method,d))
        return target_methods

    def find_input_output_stream(self):
        target_method = None
        target_method_and_dvms = []
        for d in self.dexes:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor()
                        == "(Ljava/io/InputStream; Ljava/io/OutputStream;)V" or m.get_descriptor() == "(Ljava/lang/String; Ljava/io/InputStream; Ljava/io/OutputStream;)V"
                    ):
                        if m.access_flags & 0x2 == 0x2:
                            self.logger.info("Found method with private access")

                            target_method = m
                            target_method_and_dvms.append((target_method, d))
        return target_method_and_dvms

    def find_decrypt_protect_arrays(self):
        for d in self.dexes:
            for c in d.get_classes():
                for m in c.get_methods():
                    if m.get_descriptor() == "(I)[C":
                        self.logger.info(
                            f"Found decrypt protect arrays method {m.get_name()}"
                        )
                        smali_str = self.get_smali(m)
                        """
                        const/16 v6, 11
                        const/4 v5, 3
                        const/4 v4, 2
                        const/4 v3, 1
                        const/4 v2, 0
                        if-eqz v7, +1d6h
                        if-eq v7, v3, +1c8h
                        if-eq v7, v4, +1bdh
                        if-eq v7, v5, +005h
                        new-array v0, v2, [C
                        return-object v0
                        const/16 v0, 75
                        oto/16 -1b5
                        new-array v0, v3, [C
                        const/16 v1, 24627
                        int-to-char v1, v1
                        aput-char v1, v0, v2
                        goto/16 -1be
                        new-array v0, v4, [C
                        const/16 v1, 12293
                        aput-char v1, v0, v2
                        const/16 v1, 12294
                        aput-char v1, v0, v3
                        goto/16 -1ca
                    """
                        match = re.findall(
                            r"new-array [vp]\d+, [vp]\d+, \[C\s+"
                            r"const/16 [vp]\d+, (-?\d+)\s+"
                            r"int-to-char [vp]\d+, [vp]\d+\s+"
                            r"aput-char [vp]\d+, [vp]\d+, [vp]\d+\s+"
                            r"goto/16 -?[a-f0-9]+h\s+",
                            smali_str,
                        )
                        for m in match:
                            try:
                                xor_k = int(m)
                            except:
                                self.logger.info("bad match", m)
                                continue
                            if self.ProtectKey != None:
                                tmp_key = "".join(
                                    chr(xor_k ^ ord(c)) for c in self.ProtectKey
                                )
                                if self.brute_assets(tmp_key):
                                    self.logger.info("Decrypted from manifest")
                                    return True
                            else:
                                self.logger.info("no protect key found in manifest..")
                        else:
                            # new-array v0, v0, [C
                            # const/16 v1, 24627
                            # aput-char v1, v0, v2
                            # goto -fh
                            # Or we can extract data from fill-array-data
                            match = re.findall(
                                r"new-array [vp]\d+, [vp]\d+, \[C\s+"
                                r"const/16 [vp]\d+, (-?\d+)\s+"
                                r"aput-char [vp]\d+, [vp]\d+, [vp]\d+\s+"
                                r"goto -?[a-f0-9]+h\s+",
                                smali_str,
                            )
                            for m in match:
                                try:
                                    xor_k = int(m)
                                    print(xor_k)
                                except:
                                    self.logger.info("bad match", m)
                                    continue
                                if self.ProtectKey != None:
                                    tmp_key = "".join(
                                        chr(xor_k ^ ord(c)) for c in self.ProtectKey
                                    )
                                    if self.brute_assets(tmp_key):
                                        self.logger.info("Decrypted from manifest")
                                        return True
                                else:
                                    self.logger.info(
                                        "no protect key found in manifest.."
                                    )
                            return False

    def extract_variable_from_zip(self, target_method: EncodedMethod, dvm):
        smali_str = self.get_smali(target_method)
        """
        5 invoke-virtual v3, v0, Ljava/util/zip/ZipOutputStream;->putNextEntry(Ljava/util/zip/ZipEntry;)V
        6 sget-object v0, Lcom/icecream/sandwich/c;->l Ljava/lang/String;
        7 new-instance v4, Ljava/util/zip/InflaterInputStream;
        """
        match = re.findall(
            r"invoke-virtual [vp]\d+, [vp]\d+, [vp]\d+, Ljava/util/zip/ZipEntry;->setTime\(J\)V\s+"
            r"invoke-virtual {?[vp]\d+, [vp]\d+}?, L[^;]+;->[^\(]+\(Ljava/util/zip/ZipEntry;\)V\s+"
            r"sget-object [vp]\d+, (L[^;]+;->[^\(]+) Ljava/lang/String;\s+",
            smali_str,
        )
        if len(match) == 0:
            self.logger.info(
                f"Unable to extract variable from {target_method}"
            )
            self.logger.info("Exiting ...")
            return None
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
            method = self.find_method(target_method.class_name, "<clinit>")
            if method:
                smali_str = self.get_smali(method)
                key_variable = re.findall(
                    r"sget-object [vp]\d+, (L[^;]+;->[^\s]+) Ljava/lang/String;\s+"
                    f"sput-object v0, {match[0]} Ljava/lang/String;",
                    smali_str,
                )
                if len(key_variable) == 1:
                    self.logger.info(
                        f"Found key variable from zip class <clinit> {key_variable[0]}"
                    )
                    return key_variable[0]
                else:
                    self.logger.info("Not found key variable from clinit")
                    return None
        else:
            self.logger.info("Something is wrong .. ðŸ¤”")
            self.logger.info("Found multiple ?? : {match}")
            return None

    def for_fun(self, variable_string):
        variable_class, variable_field = variable_string.split("->")
        key_class = self.find_class_in_dvms(variable_class)
        if key_class == None:
            self.logger.info(f"No key class found {key_class}")
            return None

        self.logger.info(f"Key class found ! {key_class}")
        key_clinit = self.find_method(variable_class, "<clinit>")
        if key_clinit is not None:
            smali_str = self.get_smali(key_clinit)
            # self.logger.info(smali_str)
            match = re.findall(
                r"const-string [vp]\d+, \"(.*)\"\s+" rf"sput-object [vp]\d+, .*\s+",
                smali_str,
            )
            for m in match:
                xor_k = 0x6033
                tmp_key = "".join(chr(xor_k ^ ord(c)) for c in m)
                self.logger.info(f"zaa??? {tmp_key}")

    def find_clinit_target_variable(self, variable_string):
        variable_class, variable_field = variable_string.split("->")
        key_class = self.find_class_in_dvms(variable_class)
        if key_class == None:
            self.logger.info(f"No key class found {key_class}")
            return None

        self.logger.info(f"Key class found ! {key_class}")
        key_clinit = self.find_method(variable_class, "<clinit>")
        if key_clinit is not None:
            smali_str = self.get_smali(key_clinit)
            # self.logger.info(smali_str)
            match = re.findall(
                r"const-string [vp]\d+, \"(.*)\"\s+"
                rf"sput-object [vp]\d+, {variable_string} Ljava/lang/String;",
                smali_str,
            )
            if len(match) == 0:
                self.logger.info(
                    f"Cannot find string definition in clinit for target variable {variable_string}"
                )
                # If its using apkprotecttor, we can try some other method
                match = re.findall(
                    r"const-string(?:/jumbo)? [vp]\d+, \"(.*)\"\s+"
                    r"invoke-static [vp]\d+, [vp]\d+, L[^;]+;->[^\(]+\(Ljava\/lang\/String; I\)Ljava\/lang\/String;\s+"
                    r"move-result-object [vp]\d+\s+"
                    rf"sput-object [vp]\d+, {variable_string} Ljava/lang/String;",
                    smali_str,
                )
                if len(match) == 0:
                    match = re.findall(
                        r"const-string(?:/jumbo)? [vp]\d+, \"(.*)\"\s+"
                        r"invoke-static [vp]\d+, L[^;]+;->[^\(]+\(Ljava\/lang\/String;\)Ljava\/lang\/String;\s+"
                        r"move-result-object [vp]\d+\s+"
                        rf"sput-object [vp]\d+, {variable_string} Ljava/lang/String;",
                        smali_str,
                    )

                if len(match) == 1:
                    xor_k = 0x6033
                    tmp_key = "".join(chr(xor_k ^ ord(c)) for c in match[0])
                    self.logger.info(f"Is this a key ??? {tmp_key}")
                    return tmp_key
            if len(match) == 1:
                self.logger.info(f"Found key !  {match[0]}")
                return match[0]
            else:
                self.logger.info(f"Multiple key ? {match}")
        if key_clinit is None:
            self.logger.info(f"No clinit for {variable_class}")
        return None

    def brute_assets(self, key: str):
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.solve_encryption(f, key) or self.solve_encryption2(f, key):
                self.logger.info("Decryption finished!!")
                return self.decrypted_payload_path
        return None

    def solve_encryption2(self, file_data, key):
        if len(file_data) < 8 or len(key) < 12:
            return False

        if file_data[0] == 0x78 and file_data[1] == 0x9C:
            try:
                encrypted = zlib.decompress(file_data)
            except Exception as e:
                self.logger.error(e)
                return False
        else:
            encrypted = file_data

        iArr = []  # 2
        iArr2 = []  # 4
        iArr3 = [None] * 27  # 27
        iArr4 = []  # 3
        if type(key) == str:
            key = [ord(x) for x in key]
        iArr = [key[8] | (key[9] << 16), key[11] << 16 | key[10]]
        iArr2.extend(
            [
                key[0] | (key[1] << 16),
                key[2] | (key[3] << 16),
                key[4] | (key[5] << 16),
                key[6] | (key[7] << 16),
            ]
        )
        iArr3[0] = iArr2[0]
        iArr4.extend([iArr2[1], iArr2[2], iArr2[3]])
        i2 = iArr2[0]
        i = 0
        while i < 26:
            i3 = i % 3
            iArr4[i3] = (
                (
                    (unsigned_rshift(ctypes.c_int32(iArr4[i3]).value, 8))
                    | ctypes.c_int32((iArr4[i3]) << 24).value
                )
                + i2
            ) ^ i
            i2 = (
                ctypes.c_int32(i2 << 3).value
                | (unsigned_rshift(ctypes.c_int32(i2).value, 29))
            ) ^ ctypes.c_int32(iArr4[i3]).value
            i += 1
            iArr3[i] = i2

        decrypted_bytes = bytearray()
        # self.logger.info(f"{iArr3}")
        z = 0
        for b in encrypted:
            if z % 8 == 0:
                h0 = iArr[0]
                h1 = iArr[1]
                for k in iArr3:
                    tmp0 = ((unsigned_rshift(h1, 8) | (h1 << 24) & 0xFFFFFFFF) + h0) ^ k
                    tmp1 = ((h0 << 3) & 0xFFFFFFFF | unsigned_rshift(h0, 29)) ^ tmp0
                    h0 = tmp1 & 0xFFFFFFFF
                    h1 = tmp0 & 0xFFFFFFFF
                iArr[0] = h0
                iArr[1] = h1
            b ^= iArr[int((z % 8) / 4)] >> (8 * (z % 4)) & 0xFF
            if (z == 0 and b != 0x78) or (z == 1 and b != 0x9C):
                return False
            z += 1
            decrypted_bytes.append(b)
        if self.check_and_write_file(decrypted_bytes):
            self.logger.info("Found in second algo finished")
            return True
        return False

    def solve_encryption(self, file_data: bytes, key: str):
        if len(file_data) < 8 or len(key) < 12:
            return False
        if file_data[0] == 0x78 and file_data[1] == 0x9C:
            try:
                encrypted = zlib.decompress(file_data)
            except Exception as e:
                self.logger.error(e)
                return False
        else:
            encrypted = file_data
        decrypted_bytes = bytearray()
        indexes = [0, 0, 0, 0, 1, 1, 1, 1]
        bits = [0, 8, 16, 24]
        if type(key) == str:
            c = [ord(x) for x in key]
        else:
            c = key
        poolArr = [(c[9] << 16) | c[8], (c[11] << 16) | c[10]]
        check_0 = (poolArr[indexes[0]]) >> bits[0] & 0xFF ^ encrypted[0]
        check_1 = (poolArr[indexes[0]]) >> bits[0] & 0xFF ^ encrypted[1]
        if check_0 != 0x78 and check_1 != 0x9C:
            return False
        for i, b in enumerate(encrypted):
            b ^= (poolArr[indexes[i % 8]]) >> bits[i % 4] & 0xFF
            decrypted_bytes.append(b)

        if self.check_and_write_file(decrypted_bytes):
            self.logger.info("Found in first algo")
            return True
        else:
            return False

```

`src/kavanoz/loader/multidex_header.py`:

```py
from androguard.core.apk import APK
from androguard.core.dex import DEX
from kavanoz.unpack_plugin import Unpacker
import struct


class LoaderMultidexHeader(Unpacker):
    def __init__(self, apk_obj: APK, dvms, output_dir):
        super().__init__(
            "loader.multidex.header", "Unpacker for multidex", apk_obj, dvms, output_dir
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        self.decrypted_payload_path = None
        self.brute_assets()

    def brute_assets(self):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.read_size_append_dex(f):
                self.logger.info("Decryption finished! unpacked.dex")
                return self.decrypted_payload_path
        return None

    def read_size_append_dex(self, file_data):
        # dex_header_size_off = 0x20
        if len(file_data) <= 0x20 - 3 + 4:
            return
        size = struct.unpack("<I", file_data[0x20 - 3 : 0x20 - 3 + 4])[0]
        if len(file_data) + 3 != size:
            return
        file_data = b"dex" + file_data
        if self.check_and_write_file(file_data):
            return True
        return False

```

`src/kavanoz/loader/old_rc4.py`:

```py
from androguard.core.apk import APK
from androguard.core.dex import DEX
import re
from arc4 import ARC4
from kavanoz.unpack_plugin import Unpacker


class LoaderOldRc4(Unpacker):
    def __init__(self, apk_obj, dvms, output_dir):
        super().__init__(
            "loader.rc4.v2",
            "Unpacker old rc4 based variants",
            apk_obj,
            dvms,
            output_dir,
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        self.decrypted_payload_path = None
        application_oncreate = self.find_application_oncreate()
        if not application_oncreate:
            return
        rc4_caller = self.find_caller_rc4_init(application_oncreate)
        if not rc4_caller:
            return
        rc4_inits = self.get_rc4_init_from_caller(rc4_caller)
        for rc4_init in rc4_inits:
            rc4_keys = self.get_rc4_key(rc4_init)
            for rc4_key in rc4_keys:
                x = self.brute_assets(rc4_key)
                if x != None:
                    return

    def get_rc4_key(self, rc4_init_function):
        klass_name, method_name = rc4_init_function.split("->")
        m = self.find_method(klass_name, method_name, descriptor="()V")
        if m:
            self.logger.info(m.get_name())
            array_data = self.get_array_data(m)
            if len(array_data) > 1:
                self.logger.info("Found multiple array data, might be wrong function")
            return array_data
        return []

    def get_rc4_init_from_caller(self, class_func_str) -> list:
        klass_name, method_name = class_func_str.split("->")
        m = self.find_method(klass_name, method_name, "(Landroid/app/Application;)V")
        if m == None:
            return []
        self.logger.info("Found rc4 init method")
        """
        public void xVKoMuDKBel(Application application) {
            yQuzIA();

        invoke-direct v11, Lcom/tnmwagts/rmorecegr/MPqJcHURCv;->yQuzIA()V
        """
        smali_str = self.get_smali(m)
        # find functions without parameters.
        match = re.findall(r"invoke-direct [vp]\d+, (L[^;]+;->[^\s]+)\(\)V", smali_str)
        if len(match) == 0:
            self.logger.info("Unable to extract variable from target_method")
            self.logger.info("Exiting ...")
            return []
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
        else:
            self.logger.info("Found multiple functions to call rc4_init ðŸ¤”")
        return match
        return []

    def find_application_oncreate(self):
        application_smali = self.find_main_application()
        return self.find_method(application_smali, "onCreate")

    def find_caller_rc4_init(self, target_method):
        """
        invoke-virtual v2, v6, Lcom/tnmwagts/rmorecegr/MPqJcHURCv;->xVKoMuDKBel(Landroid/app/Application;)V
        """
        smali_str = self.get_smali(target_method)
        match = re.findall(
            r"invoke-virtual [vp]\d+, [vp]\d+, (L[^;]+;->[^\s]+)\(Landroid/app/Application;\)V\s+",
            smali_str,
        )
        if len(match) == 0:
            self.logger.info("Unable to extract variable from target_method")
            self.logger.info("Exiting ...")
            return None
        if len(match) == 1:
            self.logger.info(f"Found variable ! : {match[0]}")
            return match[0]
        else:
            self.logger.info("Something is wrong .. ðŸ¤”")
            self.logger.info("Found multiple ?? : {match}")
            return None

    def brute_assets(self, key: bytes):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.solve_encryption(f, key, filepath):
                self.logger.info(f"Decryption finished! {self.decrypted_payload_path}")
                return self.decrypted_payload_path
        self.logger.info(f"No valid file found for {key}")
        return None

    def solve_encryption(self, file_data, key: bytes, filepath: str):
        arc4 = ARC4(bytes(key))
        filesize = int.from_bytes(file_data[0:4], byteorder="little")
        if filesize > len(file_data):
            return False
        decrypted = arc4.decrypt(file_data[4:])
        decrypted = decrypted[:filesize]
        if self.check_and_write_file(decrypted):
            return True
        return False

```

`src/kavanoz/loader/pronlocker.py`:

```py
import re
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


# const/16 v0, 0xc
# new-array v0, v0, [B
# fill-array-data v0, :array_8
# return-object v0
byte_array_function = (
    r"const/16 [vp]\d+, \d+\s+"
    r"new-array [vp]\d+, [vp]\d+, \[B\s+"
    r"fill-array-data [vp]\d+.*\s+"
    r"return-object [vp]\d+"
)


class LoaderPr0nLocker(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dexes, output_dir):
        super().__init__(
            "loader.pr0nlocker",
            "Unpacker for pr0nlocker",
            apk_object,
            dexes,
            output_dir,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(bytes(self.xor_key))

    def find_xor_key(self):
        """There is distinct string decryption function in the code takes float and string as input
        and returns string as output. We can find the string decryption function and then find the
        byte array function that is used to decrypt the asset files. We can then find the byte array
        data and use it as xor key to decrypt the asset files.
        """

        found_str_decryptor = False
        str_decryptor_class = None
        for d in self.dexes:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor()
                        == "(Ljava/lang/Float; Ljava/lang/String;)Ljava/lang/String;"
                    ):
                        found_str_decryptor = True
                        str_decryptor_class = c

        if not found_str_decryptor or str_decryptor_class is None:
            return None

        for m in str_decryptor_class.get_methods():
            if m.get_descriptor() == "()[B":
                self.logger.info("Found byte array function")
                smali = self.get_smali(m)
                match = re.findall(byte_array_function, smali)
                if match:
                    self.logger.info("Found byte array function")
                    array_data = self.get_array_data(m)
                    return array_data[0]
        return None

    def decrypt_files(self, xor_key: bytes):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            # Assets have 4 files, 1 html,1 json config, 2 dex
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                self.logger.info("Found encrypted file: %s", filepath)
                self.logger.info(
                    "Writing decrypted file to: %s", self.decrypted_payload_path
                )
            else:
                try:
                    decrypted = dec.decode("utf-8")
                    if decrypted.startswith("<!DOCTYPE html>"):
                        self.logger.info("Found html file:")
                        calculated_name = self.calculate_name(dec)
                        calculated_name = calculated_name.replace(".dex", ".html")
                        self.logger.info(
                            "Writing decrypted file to: %s", calculated_name
                        )
                        with open(calculated_name, "w") as f:
                            f.write(decrypted)
                    else:
                        self.logger.info("Found config file:")
                        calculated_name = self.calculate_name(dec)
                        calculated_name = calculated_name.replace(".dex", ".json")
                        self.logger.info(
                            "Writing decrypted file to: %s", calculated_name
                        )
                        with open(calculated_name, "w") as f:
                            f.write(decrypted)

                except:
                    pass
        return False

```

`src/kavanoz/loader/rc4.py`:

```py
from datetime import datetime
from androguard.core.apk import APK
from arc4 import ARC4
from androguard.core.dex import DEX
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
import string


class LoaderRc4(Unpacker):
    regex_class = Regexs()
    rc4_string_var = ""
    first_inner = []
    second_inner = []
    byte_array_data = []
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms, output_dir):
        super().__init__(
            "loader.rc4.v1", "Unpacker rc4 based variants", apk_object, dvms, output_dir
        )

    def start_decrypt(self):
        self.second_inner_regex = self.regex_class.get_second_inner_regex()
        self.first_encryption_route = self.regex_class.get_encrytion_route_regex()
        self.key_class_regex = self.regex_class.get_key_class_regex()
        self.logger.info("Starting to decrypt")
        self.attach_class = self.find_attach_class()
        if self.attach_class is None:
            return

        all_possible_rc4_keys = self.find_rc4_keys_from_attach_class(self.attach_class)
        self.logger.info(f"all possible keys : {all_possible_rc4_keys}")
        if all_possible_rc4_keys:
            if self.decrypt_files(all_possible_rc4_keys):
                # More stages
                if not self.is_really_unpacked():
                    if self.bruteforce_all_strings():
                        self.logger.info("Multiple stage is decrypted")
        else:
            if self.bruteforce_all_strings():
                self.logger.info("Multiple stage is decrypted")

    def bruteforce_all_strings(self):
        if not self.is_really_unpacked():
            all_possible_rc4_keys = list(
                filter(
                    lambda x: x != None,
                    self.find_all_strings(self.dexes[-1]),
                )
            )
            if self.decrypt_files(all_possible_rc4_keys):
                return self.bruteforce_all_strings()
            else:
                return False
        else:
            return True

    def find_attach_class(self):
        application_smali = self.find_main_application()
        target_method = self.find_method(application_smali, "attachBaseContext")
        return target_method

    def find_application_init(self):
        application_smali = self.find_main_application()
        target_method = self.find_method(application_smali, "<init>")
        return target_method

    def find_rc4_keys_from_attach_class(self, target_method):
        smali_str = self.get_smali(target_method)
        match = self.first_encryption_route.findall(smali_str)
        if len(match) == 0:
            self.logger.info(f"Unable to extract variable from {target_method}")
            self.logger.info("Exiting ...")

        if len(match) == 1:
            # self.logger.info(f'HMM : {match[0]}')
            method = self.find_method(target_method.get_class_name(), match[0])
            if method == None:
                return
            smali_str = self.get_smali(method)
            # self.logger.info(smali_str)
            key_class = self.key_class_regex.findall(smali_str)
            if len(key_class) != 1:
                return
            self.logger.info(f"Key class : {key_class[0]}")
            klass = self.find_class_in_dvms(key_class[0][2])
            if klass == None:
                return
            return self.find_rc4_keys_from_klass_fields(klass)

    def find_all_strings(self, dvm: DEX) -> set:
        all_rc4_keys = set()
        for klass in dvm.get_classes():
            # all_rc4_keys.update(self.find_rc4_keys_from_klass_fields(klass))
            all_rc4_keys.update(self.find_rc4_keys_from_static_methods(klass))
        return all_rc4_keys

    def find_all_strings_from_application_class(self, dvm: DEX) -> set:
        application_smali = self.find_main_application()
        klass = self.find_class_in_dvms(application_smali)
        all_rc4_keys = set()
        all_rc4_keys.update(self.find_rc4_keys_from_klass_fields(klass))
        return all_rc4_keys

    def find_rc4_keys_from_static_methods(self, klass) -> set:
        all_possible_rc4_keys = set()
        for method in klass.get_methods():
            if (
                "static" in method.get_access_flags_string()
                and "Ljava/lang/String;" in method.get_descriptor()
            ):
                res = self.generate_rc4_keys_from_method(method)
                if len(res) > 0:
                    all_possible_rc4_keys.update(res)
        return all_possible_rc4_keys

    def find_rc4_keys_from_klass_fields(self, klass) -> set:
        all_possible_rc4_keys = set()
        for field in klass.get_fields():
            rc4_string_variable = None
            if field.get_descriptor() != "Ljava/lang/String;":
                continue
            if field.get_init_value() != None and field.get_init_value != "":
                self.logger.info(
                    f"Found static key : {field.get_init_value().get_value()}"
                )
                static_rc4_string = field.get_init_value().get_value()
                r = set()
                r.add(static_rc4_string.encode())
                return r
            else:
                if (
                    "0x0" == field.get_access_flags_string()
                    or "protected final" == field.get_access_flags_string()
                    or "" == field.get_access_flags_string()
                ):
                    rc4_string_variable = field.get_name()
            if rc4_string_variable is not None:
                self.regex_class.set_first_inner_regex(rc4_string_variable)
                all_possible_rc4_keys.update(self.get_key_from_init(klass))
        return all_possible_rc4_keys

    def get_key_from_init(self, klass) -> set:
        """
        String field is calculated with two inner functions.
        Example :
            - String SAsDiYdEsXlNsTnXkKoYoSmZp = derivetrouble(new String[98]);
            - static String derivetrouble(String[] strArray) {
                return leaveangry();
              }
            - public static String leaveangry() {
                    byte[] bArr = {11, 63, 45, 21};
                    byte[] bArr2 = new byte[4];
                    byte[] bArr3 = {79};
                    while (i8 < 4) {
                        bArr2[i8] = (byte) (bArr[i8] ^ bArr3[i8 % 1]);
                        i8++;
                    }
                    return new String(bArr2);
                }
        We try to find second inner function that generates rc4 key
        """
        possible_rc4_keys = set()
        string_gen_0 = []
        klass_name = klass.get_name()
        init_method = self.find_method(klass_name, "<init>")
        if not init_method:
            return possible_rc4_keys
        smali_str = self.get_smali(init_method)
        for key, regex in self.regex_class.get_first_inner_regexs().items():
            string_gen_0 = regex.findall(smali_str)
            if string_gen_0:
                break
        if string_gen_0:
            self.logger.info(f"First inner function: {string_gen_0[0]}")
            string_gen_1 = []
            # Find function that uses first found function
            first_method = self.find_method(klass_name, string_gen_0[0])
            if not first_method:
                return possible_rc4_keys
            smali_str = self.get_smali(first_method)
            string_gen_1 = self.second_inner_regex.findall(smali_str)
            if not string_gen_1:
                self.logger.info(
                    f"Unable to extract second inner function from {first_method.get_name()}"
                )
                self.logger.info("Checking if we are already in the last function")
                rc4_keys = self.generate_rc4_keys_from_method(first_method)
                possible_rc4_keys.update(rc4_keys)

            else:
                self.logger.info(f"Second inner function: {string_gen_1[0]}")
                if string_gen_1:
                    second_method = self.find_method(klass_name, string_gen_1[0])
                    if second_method:
                        rc4_keys = self.generate_rc4_keys_from_method(second_method)
                        possible_rc4_keys.update(rc4_keys)
        else:
            self.logger.info("Unable to extract first inner function")

        return possible_rc4_keys

    def generate_rc4_keys_from_method(self, method) -> set:
        """
        Extract array data from target method. Generaly packer generates rc4 key from two array data.
        Or defines constant string.
        First regex captures string,
        """
        # self.logger.info(self.get_smali(method))
        smali = self.get_smali(method)
        match = re.findall(
            r"const-string [vp]\d+, \'(.*?)\'\s+" r"return-object [vp]\d+", smali
        )
        if len(match) == 1:
            self.logger.info(match)
            # self.decrypt_files([match[0]])
            r = set()
            k = match[0]
            if type(k) is bytes or type(k) is str:
                r.add(k)
                return r

        arrays_in_method = self.get_array_data(method)
        if len(arrays_in_method) < 2:
            return set()
        if len(arrays_in_method) > 2:
            self.logger.info(
                f"We have {len(self.byte_array_data)} byte arrays, so gonna brute force little bit"
            )
        if len(arrays_in_method) == 2:
            self.logger.info(
                f"RC4 key generators : {arrays_in_method[0]} - {arrays_in_method[1]}"
            )
        rc4_keys = self.get_all_rc4_keys(arrays_in_method)
        return rc4_keys

    def decrypt_files(self, rc4key):
        for filepath in self.apk_object.get_files():
            if filepath.endswith(".json"):
                fd = self.apk_object.get_file(filepath)
                for rc4k in rc4key:
                    if len(rc4k) > 0:
                        dede = ARC4(rc4k)
                        dec = dede.decrypt(fd[:8])
                        if self.check_header(dec):
                            dede = ARC4(rc4k)
                            dec = dede.decrypt(fd)
                            if self.check_and_write_file(dec):
                                self.logger.info(
                                    f"Decrypted dex is from {filepath} with key {rc4k}"
                                )
                                return True
        return False

    def get_all_rc4_keys(self, keys: list) -> set:
        rc4_key = set()
        if len(keys) > 2:
            # combinartion of keys
            comb = combinations(keys, 2)
            rc4_key = set()
            for k in comb:
                rc4_key.add(self.generate_rc4_key(k[0], k[1], True))
            for k in keys:
                rc4_key.add(bytes(k))
        else:
            rc4_key.add(self.generate_rc4_key(keys[0], keys[1]))
            rc4_key.add(self.generate_rc4_key(keys[0], keys[1], True))
        return rc4_key

    def generate_rc4_key(self, key0, key1, without_arrange=False):
        big_key = key0 if len(key0) > len(key1) else key1
        smol_key = key0 if len(key0) < len(key1) else key1
        rc4_key = bytearray()
        for i in range(len(big_key)):
            zz = big_key[i] ^ smol_key[i % len(smol_key)]
            rc4_key.append(zz)

        if without_arrange:
            rc4_key = bytearray()
            for i in range(len(key0)):
                rc4_key.append(key0[i] ^ key1[i % len(key1)])
            return bytes(rc4_key)
        return bytes(rc4_key)

```

`src/kavanoz/loader/sesdex.py`:

```py
from datetime import datetime
from androguard.core.apk import APK
from arc4 import ARC4
from androguard.core.dex import DEX
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
from kavanoz.utils import xor


"""
invoke-virtual v8, v2, Ljava/io/InputStream;->read([B)I
const-string v5, 'bhMIAdCgBYYOymrlRp'
invoke-virtual v5, Ljava/lang/String;->getBytes()[B
move-result-object v5
invoke-static v2, v5, Lorvbreo/ycmgmee;->ZowuWxil([B [B)[B
move-result-object v2
invoke-virtual v8, Ljava/io/InputStream;->close()V
"""

find_xor_key = (
    r"invoke-virtual [vp]\d+, [vp]\d+, L[^;]+;->read\(\[B\)I\s+"
    r"const-string [vp]\d+, \"(.*)\"\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->getBytes\(\)+\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-static [vp]\d+, [vp]\d+, L[^;]+;->([^\(]+)\(\[B \[B\)\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->close\(\)V\s+"
)

find_second_xor_key = (
    r"const-string [vp]\d+, \"(.*)\"\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->getBytes\(\)+\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-static [vp]\d+, [vp]\d+, L[^;]+;->([^\(]+)\(\[B \[B\)\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, [vp]\d+, L[^;]+;->write\(\[B\)V\s+"
)


class LoaderSesdex(Unpacker):
    regex_class = Regexs()
    rc4_string_var = ""
    first_inner = []
    second_inner = []
    byte_array_data = []
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms, output_dir):
        super().__init__(
            "loader.sesdex",
            "Unpacker for unknown adware malware",
            apk_object,
            dvms,
            output_dir,
        )

    def start_decrypt(self):
        self.second_inner_regex = self.regex_class.get_second_inner_regex()
        self.first_encryption_route = self.regex_class.get_encrytion_route_regex()
        self.key_class_regex = self.regex_class.get_key_class_regex()
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(self.xor_key)

        for filepath in self.apk_object.get_files():
            second_xor_key = self.find_second_xor_key()
            if second_xor_key:
                self.decrypt_files(second_xor_key)

    def find_xor_key(self):
        application_smali = self.find_main_application()
        target_method = self.find_method_re(
            application_smali, ".*", "(Ljava/io/InputStream;)Ljava/io/File;"
        )
        if target_method == None:
            return
        sm = self.get_smali(target_method)
        if "ses.dex" not in sm:
            return
        m = re.findall(find_xor_key, sm)
        if len(m) == 1:
            return bytes(m[0][0].encode("utf-8"))
        else:
            return None

    def find_second_xor_key(self):
        if self.decrypted_payload_path == None:
            return
        with open(self.decrypted_payload_path, "rb") as fp:
            d = fp.read()
            dvm = DEX(d)
            for c in dvm.get_classes():
                if c.get_superclassname() == "Landroid/app/Application;":
                    for m in c.get_methods():
                        if m.get_name() == "onCreate":
                            sm = self.get_smali(m)
                            matches = re.findall(find_second_xor_key, sm)
                            if matches:
                                return matches[0][0].encode("utf-8")

    def decrypt_files(self, xor_key):
        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simple.py`:

```py
from androguard.core.apk import APK
from androguard.core.dex import DEX
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderSimple(Unpacker):
    def __init__(self, apk_obj: APK, dvms, output_dir):
        super().__init__(
            "loader.simple", "Simple methods to unpack", apk_obj, dvms, output_dir
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        package_name = self.apk_object.get_package()
        self.decrypted_payload_path = None
        if package_name != None:
            if self.brute_assets(package_name):
                return

    def brute_assets(self, key: str):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.try_one_byte_xor(f):
                return self.decrypted_payload_path
        return None

    def try_one_byte_xor(self, file_data):
        for k in range(1, 256):
            xored_data = xor(file_data[:16], k.to_bytes(1, "little"))
            if not self.check_header(xored_data):
                continue
            self.logger.info(f"Found single byte xor key : {k}")
            if self.check_obfuse():
                xored_data = xor(file_data[:100], k.to_bytes(1, "little"))
                xored_data += file_data[100:]
            else:
                xored_data = xor(file_data, k.to_bytes(1, "little"))
            if self.check_and_write_file(xored_data):
                return True
        return False

    def check_obfuse(self) -> bool:
        # Check if obfuse.NPStringFog class exists
        # If so, xor only first 100 bytes of the file
        res = self.find_class_in_dvms("Lobfuse/NPStringFog;")
        if res:
            self.logger.info("Found obfuse.NPStringFog class")
            return True
        self.logger.info("obfuse.NPStringFog class not found")
        return False

```

`src/kavanoz/loader/simple_aes.py`:

```py
from Crypto.Cipher import AES
import base64
from datetime import datetime
from androguard.core.apk import APK
from arc4 import ARC4
from androguard.core.dex import DEX
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
from kavanoz.utils import xor

"""
invoke-direct v2, v0, v3, Ljava/io/File;-><init>(Ljava/io/File; Ljava/lang/String;)V
invoke-direct v7, v8, v1, v2, Lbtewtslyl/vmcdkpllfzrvt/u5a48eebb7c1d4;->a(Landroid/content/Context; Ljava/lang/String; Ljava/io/File;)Z
new-instance v3, Ldalvik/system/DexClassLoader;
"""
find_aes_function = (
    r"invoke-direct [vp]\d+, [vp]\d+, [vp]\d+, Ljava/io/File;-><init>\(Ljava/io/File; Ljava/lang/String;\)V\s+"
    r"invoke-direct [vp]\d+, [vp]\d+, [vp]\d+, [vp]\d+, (L[^;]+;->[^\(]+)\(Landroid/content/Context; Ljava/lang/String; Ljava/io/File;\)Z\s+"
    r"new-instance [vp]\d+, Ldalvik/system/DexClassLoader;"
)
"""
new-instance v2, Ljavax/crypto/CipherInputStream;
const-string v3, '7RHkUDPB5fGL4NLPDuehSRjnxYGr0I7KmsqAUwLT1sk='
invoke-direct v4, v3, Lbtewtslyl/vmcdkpllfzrvt/u5a48eebb7c1d4;->a(Ljava/lang/String;)Ljavax/crypto/Cipher;
move-result-object v3
"""

find_aes_key = (
    r"new-instance [vp]\d+, Ljavax/crypto/CipherInputStream;\s+"
    r"const-string [vp]\d+, \"(.*)\"\s+"
    r"invoke-direct [vp]\d+, [vp]\d+, L[^;]+;->[^\(]+\(Ljava/lang/String;\)Ljavax/crypto/Cipher;\s+"
    r"move-result-object [vp]\d+"
)


class LoaderSimpleAes(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms, output_dir):
        super().__init__(
            "loader.simpleaes",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
            output_dir,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.aes_key = self.find_aes_key()
        if self.aes_key is None:
            return
        self.decrypt_files(self.aes_key)

    def find_aes_key(self):
        asset_filenames = [
            x.replace("assets/", "")
            for x in self.apk_object.get_files()
            if x.startswith("assets/")
        ]
        for d in self.dexes:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor() == "(Landroid/content/Context;)V"
                        and m.get_name() == "<init>"
                    ):
                        m_smali = self.get_smali(m)

                        for fname in asset_filenames:
                            if fname in m_smali:
                                self.logger.info("Found method")
                                target_method = m
                                m = re.findall(find_aes_function, m_smali)
                                if len(m) == 0:
                                    continue
                                klass, method = m[0].split("->")
                                target_method = self.find_method(
                                    klass,
                                    method,
                                    "(Landroid/content/Context; Ljava/lang/String; Ljava/io/File;)Z",
                                )
                                if target_method:
                                    aes_key = re.findall(
                                        find_aes_key, self.get_smali(target_method)
                                    )
                                    if aes_key:
                                        return aes_key[0]

        return None

    def decrypt_files(self, aes_key):
        try:
            kk = base64.b64decode(aes_key)
        except Exception as e:
            self.logger.error(e)
            return

        key = kk[:16]
        iv = kk[16:32]
        ai = AES.new(key, AES.MODE_CBC, iv)
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = ai.decrypt(fd)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simple_xor.py`:

```py
import re
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor

"""
invoke-direct v10, v14, v15, Ljava/lang/Long;-><init>(J)V
const/4 v9, 0
array-length v13, v4
if-ge v9, v13, +03fh
aget-byte v13, v4, v9
const-string v14, "pAinaTuyPSZcNjEbewHmUaUiFLzjnb"
invoke-virtual v14, Ljava/lang/String;->getBytes()[B
move-result-object v14
invoke-virtual v10, Ljava/lang/Long;->longValue()J
move-result-wide v16
move-wide/from16 v0, v16
long-to-int v15, v0
aget-byte v14, v14, v15
xor-int/2addr v13, v14
int-to-byte v13, v13
aput-byte v13, v8, v9
"""

find_xor_key = (
    r"const/4 [vp]\d+, 0\s+"
    r"array-length [vp]\d+, [vp]\d+\s+"
    r"if-ge [vp]\d+, [vp]\d+, \+03fh\s+"
    r"aget-byte [vp]\d+, [vp]\d+, [vp]\d+\s+"
    r"const-string [vp]\d+, \"(.*)\"\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->getBytes\(\)+\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, L[^;]+;->longValue\(\)J\s+"
)


class LoaderSimpleXor(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms, output_dir):
        super().__init__(
            "loader.simplexor",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
            output_dir,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(self.xor_key)

    def find_xor_key(self):
        application_smali = self.find_main_application()
        target_method = self.find_method(application_smali, "attachBaseContext")
        if target_method == None:
            return
        sm = self.get_smali(target_method)
        m = re.findall(find_xor_key, sm)
        if len(m) == 1:
            return bytes(m[0].encode("utf-8"))
        else:
            return

    def decrypt_files(self, xor_key):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simple_xor_zlib.py`:

```py
import base64
import re
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor
import zlib


class LoaderSimpleXorZlib(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms, output_dir):
        super().__init__(
            "loader.simplexor",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
            output_dir,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.decrypt_files()

    def decrypt_files(self):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not filepath.startswith("assets"):
                continue
            fd = self.apk_object.get_file(filepath)
            if len(fd) < 8:
                return False
            if fd[4] == 0x78 and fd[5] == 0x9C:
                try:
                    dec = zlib.decompress(fd[4:])
                except Exception as e:
                    self.logger.error(e)
                    return False
            else:
                xor_k = fd[4]
                zlib_d = fd[5:]
                dec = xor(zlib_d, xor_k.to_bytes(1, "little"))
                if dec[:2] != b"\x78\x01":
                    return
                try:
                    dec = zlib.decompress(dec)
                except Exception as e:
                    self.logger.error(e)
                    return

            try:
                dec = base64.b64decode(dec)
            except Exception as e:
                self.logger.error(e)
                return
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/simply_xor2.py`:

```py
from datetime import datetime
from androguard.core.apk import APK
from arc4 import ARC4
from androguard.core.dex import DEX
import re
from itertools import combinations
from kavanoz.unpack_plugin import Unpacker
from kavanoz.smali_regexes import Regexs
from kavanoz.utils import xor

"""
array-length v0, v3
new-array v0, v0, [B
const/4 v1, 0
array-length v2, v3
if-ge v1, v2, +c
aget-byte v2, v3, v1
xor-int/lit8 v2, v2, -43
int-to-byte v2, v2
aput-byte v2, v0, v1
add-int/lit8 v1, v1, 1
goto -c
return-object v0
"""

find_xor_key = r"xor-int/lit8 [vp]\d+, [vp]\d+, (-?\d+)"
"""
invoke-virtual v0, v2, Ljava/io/InputStream;->read([B)I
invoke-virtual v0, Ljava/io/InputStream;->close()V
invoke-static v2, Lcom/squareup/leakcanary/gutG;->XdB([B)[B
move-result-object v0
invoke-virtual v6, v0, Ljava/io/FileOutputStream;->write([B)V
invoke-virtual v6, Ljava/io/FileOutputStream;->close()V
"""
find_xor_function = (
    r"invoke-virtual [vp]\d+, [vp]\d+, Ljava/io/InputStream;->read\(\[B\)I\s+"
    r"invoke-virtual [vp]\d+, Ljava/io/InputStream;->close\(\)V\s+"
    r"invoke-static [vp]\d+, (L[^;]+;->[^\(]+)\(\[B\)\[B\s+"
    r"move-result-object [vp]\d+\s+"
    r"invoke-virtual [vp]\d+, [vp]\d+, Ljava/io/FileOutputStream;->write\(\[B\)V\s+"
)


class LoaderSimpleXor2(Unpacker):
    decrypted_payload_path = None

    def __init__(self, apk_object, dvms, output_dir):
        super().__init__(
            "loader.simplexor2",
            "Unpacker for multiple simple unpackers",
            apk_object,
            dvms,
            output_dir,
        )

    def start_decrypt(self):
        self.logger.info("Starting to decrypt")
        self.xor_key = self.find_xor_key()
        if self.xor_key is None:
            return
        self.decrypt_files(self.xor_key)

    def find_xor_key(self):
        asset_filenames = [
            x.replace("assets/", "")
            for x in self.apk_object.get_files()
            if x.startswith("assets/")
        ]
        for d in self.dexes:
            for c in d.get_classes():
                for m in c.get_methods():
                    if (
                        m.get_descriptor()
                        == "(Landroid/content/Context;)Ljava/io/File;"
                    ):
                        m_smali = self.get_smali(m)
                        for fname in asset_filenames:
                            if fname in m_smali:
                                matches = re.findall("[a-f0-9]+\.dex", m_smali)
                                if len(matches) == 0:
                                    self.logger.info("no match")
                                    return
                                self.logger.info("Found method")
                                target_method = m
                                m = re.findall(find_xor_function, m_smali)
                                klass, method = m[0].split("->")
                                target_method = self.find_method(klass, method)
                                if target_method:
                                    xor_key = re.findall(
                                        find_xor_key, self.get_smali(target_method)
                                    )
                                    if xor_key:
                                        n = int(xor_key[0])
                                        n = n & 0xFF
                                        self.logger.info(f"Found single xor key : {n}")
                                        return n.to_bytes(1, "little")
        return None

    def decrypt_files(self, xor_key):
        if self.decrypted_payload_path == None:
            out_file = "unpacked.dex"
        else:
            index = re.findall(r"\d+", self.decrypted_payload_path)
            if index:
                ii = int(index[0])
                out_file = f"unpacked{ii+1}.dex"
            else:
                out_file = "unpacked1.dex"

        for filepath in self.apk_object.get_files():
            if not (filepath.startswith("assets") or filepath.startswith("res")):
                continue
            fd = self.apk_object.get_file(filepath)
            dec = xor(fd, xor_key)
            if self.check_and_write_file(dec):
                return True
        return False

```

`src/kavanoz/loader/subapp.py`:

```py
from androguard.core.apk import APK
from androguard.core.dex import DEX
from kavanoz.unpack_plugin import Unpacker
from kavanoz.utils import xor


class LoaderSubapp(Unpacker):
    def __init__(self, apk_obj: APK, dvms, output_dir):
        super().__init__(
            "loader.subapp",
            "Unpacker for chinese packer1, Beingyi",
            apk_obj,
            dvms,
            output_dir,
        )

    def start_decrypt(self, native_lib: str = ""):
        self.logger.info("Starting to decrypt")
        package_name = self.apk_object.get_package()
        self.decrypted_payload_path = None
        if package_name != None:
            self.brute_assets(package_name)

    def brute_assets(self, key: str):
        self.logger.info("Starting brute-force")
        asset_list = self.apk_object.get_files()
        for filepath in asset_list:
            f = self.apk_object.get_file(filepath)
            if self.solve_encryption(f, key):
                self.logger.info("Decryption finished! unpacked.dex")
                return self.decrypted_payload_path
        return None

    def solve_encryption(self, file_data, key):
        if len(key) < 3 or len(file_data) < 3:
            return False
        xored_h = file_data[0] ^ key[0].encode("utf-8")[0]
        xored_h2 = file_data[1] ^ key[1].encode("utf-8")[0]
        xored_h3 = file_data[2] ^ key[2].encode("utf-8")[0]
        if xored_h != ord("d") or xored_h2 != ord("e") or xored_h3 != ord("x"):
            return False
        xored_data = xor(file_data, key.encode("utf-8"))
        if self.check_and_write_file(xored_data):
            return True
        return False

```

`src/kavanoz/plugin_loader.py`:

```py
import sys
import pkgutil
import importlib
from pathlib import Path
from kavanoz.unpack_plugin import Unpacker

PLUGIN_DIRECTORY = Path(__file__).parent / "loader"
BLACKLISTED_KEYS = (
    "__name__",
    "__doc__",
    "__package__",
    "__loader__",
    "__spec__",
    "__file__",
    "__cached__",
    "__builtins__",
)


def dicover_plugins(path: Path):
    posix_path = PLUGIN_DIRECTORY.as_posix()
    if posix_path not in sys.path:
        sys.path.append(posix_path)

    iter_from = [posix_path]
    for finder, name, ispkg in pkgutil.iter_modules(iter_from):
        yield name


def import_plugin(module_name: str) -> list[Unpacker]:
    module = importlib.import_module(module_name)
    module_dict = module.__dict__

    check_in = None

    if "__all__" in module_dict:
        check_in = {
            key: module_dict[key]
            for key in module_dict["__all__"]
            if key in module_dict
        }
    else:
        check_in = {
            key: val for key, val in module_dict.items() if key not in BLACKLISTED_KEYS
        }

    valid_items = [
        mod
        for inner_module_name in check_in
        if (mod := module_dict[inner_module_name])
        and inner_module_name.startswith("Loader")
        and issubclass(mod, Unpacker)
    ]

    if not valid_items:
        del sys.modules[module_name]
        return None
    else:
        return valid_items


def get_plugins():
    for plugin in dicover_plugins(PLUGIN_DIRECTORY):
        yield import_plugin(plugin)

```

`src/kavanoz/smali_regexes.py`:

```py
import re


class Regexs:
    def __init__(self):
        self.first_inner_regex = {}

    def set_first_inner_regex(self, rc4_string_var: str):
        # invoke-static v0, Lcom/huge/dragon/DEdEoXwGgUxOmDnIdQiBhAeDwDbFbByQwQfQtYuWk;->meattool(B)Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lcom/huge/dragon/DEdEoXwGgUxOmDnIdQiBhAeDwDbFbByQwQfQtYuWk;->XZkYqPfMoCcNtMzDiIpGaYlRuDjFeZfMtPcSq Ljava/lang/String;

        first_inner_1 = (
            rf"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\([a-zA-Z0-9;/]+\)Ljava/lang/String;\s+"
            "move-result-object [vp]\d+\s+"
            f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        # invoke-static Lsquare/ivory/purchase/YKxOcNuRkOlYhOySzZjCsYqLcJkYuUlJdTfTqMeMgXuOnUzEjNiSs;->antiquehello()Ljava/lang/StringBuilder;
        # move-result-object v0
        # invoke-static v0, Ljava/lang/String;->valueOf(Ljava/lang/Object;)Ljava/lang/String;

        first_inner_2 = (
            r"invoke-static L[^;]+;->([^\(]+)\(\w*\)+Ljava/lang/StringBuilder;\s+"
            r"move-result-object [vp]\d+\s+"
            r"invoke-static [vp]\d+, Ljava/lang/String;->valueOf\(Ljava/lang/Object;\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        first_inner_6 = (
            r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\w*\)+Ljava/lang/StringBuilder;\s+"
            r"move-result-object [vp]\d+\s+"
            r"invoke-static [vp]\d+, Ljava/lang/String;->valueOf\(Ljava/lang/Object;\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )
        first_inner_9 = (
            r"invoke-static L[^;]+;->([^\(]+)\(\)+Ljava/lang/StringBuilder;\s+"
            r"move-result-object [vp]\d+\s+"
            r"invoke-virtual [vp]\d+, Ljava/lang/StringBuilder;->toString\(\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )
        # invoke-static Lcom/marine/build/NKlIyWrPrYoKzZyRtDsOnKnJtNkNcEoOePzLtNg;->dressraccoon()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lcom/marine/build/NKlIyWrPrYoKzZyRtDsOnKnJtNkNcEoOePzLtNg;->QFxOwNaMaJqTgNdOhOc Ljava/lang/String;

        first_inner_3 = (
            "invoke-static L[^;]+;->([^\(]+)\(\w*\)Ljava\/lang\/String;\s+"
            "move-result-object [vp]\d+\s+"
            f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        first_inner_7 = (
            "invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Ljava/lang/String;\)Ljava\/lang\/String;\s+"
            "move-result-object [vp]\d+\s+"
            f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )
        first_inner_10 = (
            r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\[I\)Ljava\/lang\/String;\s+"
            "move-result-object [vp]\d+\s+"
            f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        # invoke-static {v0}, Lcom/frog/assault/ZQwAlNnFmAdZiOe;->corespy([Ljava/lang/String;)Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, p0, Lcom/frog/assault/ZQwAlNnFmAdZiOe;->OPxNlTsOuSiJtOg:Ljava/lang/String;
        first_inner_11 = (
            r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(\[Ljava/lang/String;\)Ljava\/lang\/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )
        # invoke-static v0, Ljknl/bgdfdntrwerlfwaxohrcyamosg/rathpswbuyyukhdihs/Qreunionscience;->symbolraise(Ljava/lang/Boolean;)Ljava/lang/StringBuffer;
        # move-result-object v0
        # invoke-virtual v0, Ljava/lang/StringBuffer;->toString()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v4, Ljknl/bgdfdntrwerlfwaxohrcyamosg/rathpswbuyyukhdihs/Qreunionscience;->Salterrail Ljava/lang/String;
        first_inner_4 = (
            r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Ljava/lang/Object\)Ljava/lang/StringBuffer;\s+"
            r"move-result-object [vp]\d+\s+"
            r"invoke-virtual [vp]\d+, Ljava/lang/StringBuffer;->toString\(\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        # invoke-static Lrecall/promote/hidden/IYmMtEjAhYyTpQz;->incomeagain()Ljava/lang/StringBuffer;
        # move-result-object v0
        # invoke-virtual v0, Ljava/lang/StringBuffer;->toString()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lrecall/promote/hidden/IYmMtEjAhYyTpQz;->QOlUeNyKnHtWmHdEnUs Ljava/lang/String;

        first_inner_5 = (
            r"invoke-static L[^;]+;->([^\(]+)\(\)Ljava/lang/StringBuffer;\s+"
            r"move-result-object [vp]\d+\s+"
            r"invoke-virtual [vp]\d+, Ljava/lang/StringBuffer;->toString\(\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )
        # invoke-static v0, Lpousozuqamiyngkkoczbahranxo/efcwgecwerpfesmilxxmkco/tpqbn/Pwrongmatch;->trialalert(Z)Ljava/lang/StringBuilder;
        # move-result-object v0
        # invoke-virtual v0, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v4, Lpousozuqamiyngkkoczbahranxo/efcwgecwerpfesmilxxmkco/tpqbn/Pwrongmatch;->Qtwintattoo Ljava/lang/String;

        first_inner_8 = (
            r"invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Z\)Ljava/lang/StringBuilder;\s+"
            r"move-result-object [vp]\d+\s+"
            r"invoke-virtual [vp]\d+, Ljava/lang/StringBuilder;->toString\(\)Ljava/lang/String;\s+"
            r"move-result-object [vp]\d+\s+"
            rf"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )
        # invoke-static v0, Lcom/chuckle/define/QXqAuXjWzGjAnCiYyKoKp;->censusasset(Ljava/lang/StringBuilder;)Ljava/lang/String;
        # move-result-object v0
        # iput-object v0, v3, Lcom/chuckle/define/QXqAuXjWzGjAnCiYyKoKp;->TKiLpUsQmOtFqOoEoYjKpCxGeHjFeMlAoQfQuJmRdOwFwLw Ljava/lang/String;

        first_inner_12 = (
            "invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Ljava/lang/StringBuilder;\)Ljava/lang/String;\s+"
            "move-result-object [vp]\d+\s+"
            f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        # 001e56f2: 7110 af2f 0000          005b: invoke-static       {v0}, Lcom/chuckle/sunset/IGlYqYmEaEdKmJiYhUxMyOpKlTrHi;->praiseload(Ljava/io/FileDescriptor;)[C # method@2faf
        # 001e56f8: 0c00                    005e: move-result-object  v0
        # 001e56fa: 7110 8a47 0000          005f: invoke-static       {v0}, Ljava/lang/String;->valueOf([C)Ljava/lang/String; # method@478a
        # 001e5700: 0c00                    0062: move-result-object  v0
        # 001e5702: 5b10 2614               0063: iput-object         v0, v1, Lcom/chuckle/sunset/IGlYqYmEaEdKmJiYhUxMyOpKlTrHi;->dDybYjxWbGQoGcmLQGyU_818756:Ljava/lang/String; # field@1426
        first_inner_13 = (
            "invoke-static [vp]\d+, L[^;]+;->([^\(]+)\(Ljava/io/FileDescriptor;\)\[C\s+"
            "move-result-object [vp]\d+\s+"
            "invoke-static [vp]\d+, Ljava/lang/String;->valueOf\(\[C\)Ljava/lang/String;\s+"
            "move-result-object [vp]\d+\s+"
            f"iput-object [vp]\d+, [vp]\d+, L[^;]+;->{rc4_string_var} Ljava/lang/String;"
        )

        self.first_inner_regex["first_variant"] = re.compile(first_inner_1)
        self.first_inner_regex["second_variant"] = re.compile(first_inner_2)
        self.first_inner_regex["third_variant"] = re.compile(first_inner_3)
        self.first_inner_regex["fourth_variant"] = re.compile(first_inner_4)
        self.first_inner_regex["fifth_variant"] = re.compile(first_inner_5)
        self.first_inner_regex["six_variant"] = re.compile(first_inner_6)
        self.first_inner_regex["seven_variant"] = re.compile(first_inner_7)
        self.first_inner_regex["eight_variant"] = re.compile(first_inner_8)
        self.first_inner_regex["nine_variant"] = re.compile(first_inner_9)
        self.first_inner_regex["ten_variant"] = re.compile(first_inner_10)
        self.first_inner_regex["eleven_variant"] = re.compile(first_inner_11)
        self.first_inner_regex["12"] = re.compile(first_inner_12)
        self.first_inner_regex["13"] = re.compile(first_inner_13)

    def get_first_inner_regexs(self) -> dict:
        return self.first_inner_regex

    @staticmethod
    def get_encrytion_route_regex() -> re:
        first_encrytion_route = (
            "invoke-virtual [vp]\d+, [vp]\d+, L[^\s]+;->([^\s]+)\(Ljava/lang/String;\)Z"
        )
        return re.compile(first_encrytion_route)

    @staticmethod
    def get_key_class_regex() -> re:
        """
        iput-object v0, v4, Lsolve/expect/water/DWcJrLbBhZuZeQxRsByOgHrOgEwAb;->PTuCuGcNoJqKpAnWyFoNfHoSj Landroid/content/Context;
        iget-object v0, v4, Lsolve/expect/water/DWcJrLbBhZuZeQxRsByOgHrOgEwAb;->PTuCuGcNoJqKpAnWyFoNfHoSj Landroid/content/Context;
        iget-object v1, v4, Lsolve/expect/water/DWcJrLbBhZuZeQxRsByOgHrOgEwAb;->HLcJdEiQiGcGpHyIwXrTiXuQiLqIaRgGt Ljava/lang/String;
        invoke-static v5, v0, v1, Lsolve/expect/water/GKfMeQmSxLkSzNmFoUhBxJrOjAiRsAyGbThJnQhOkNiRuIxUf;->shrugbalcony(Ljava/lang/String; Landroid/content/Context; Ljava/lang/String;)Z
        move-result v5
        return v5
        """
        key_class_regex = (
            r"invoke-(virtual|static) ([vp]\d+, ){3,4}(L[^\(]+;)->[^\(]+\(Ljava/lang/String; Landroid/content/Context; Ljava/lang/String;\)Z\s+"
            r"move-result [vp]\d+\s+"
            r"return [vp]\d+"
        )
        return re.compile(key_class_regex)

    @staticmethod
    def get_second_inner_regex():
        second_inner = "invoke-static L[^\(]+;->([^\(]+)\(\)Ljava/lang/String;"
        return re.compile(second_inner)

```

`src/kavanoz/unpack_plugin.py`:

```py
from androguard.core.apk import APK
import re
from androguard.core.dex import DEX, EncodedMethod, ClassDefItem
import time
import io
import zipfile
import hashlib
import zlib
from kavanoz.utils import dex_headers, pkzip_headers, zlib_headers
from loguru import logger
import os


class Unpacker:
    tag = "DefaultUnpackPlugin"
    name = "DefaultUnpackName"

    def __init__(
        self,
        tag: str,
        name: str,
        apk_object: APK,
        dexes: list[DEX],
        output_dir,
    ):
        """Default unpacking plugin"""
        self.tag = tag
        self.name = name
        self.decrypted_payload_path = None
        self.logger = logger
        self.apk_object = apk_object
        self.dexes = list(filter(self.filter_dvms, dexes))
        if output_dir:
            self.output_dir = output_dir
        else:
            self.output_dir = os.getcwd()

    @staticmethod
    def filter_dvms(dvm):
        if dvm.classes == None:
            return False
        return True

    def is_packed(self) -> bool:
        """Checks if apk is packed by checking components defined in AndroidManifest.xml is present in dex

        :returns ispacked: Is apk packed
        :rtype:bool
        """
        ispacked = False
        not_found_counter = 0
        act_serv_recv = (
            self.apk_object.get_activities()
            + self.apk_object.get_receivers()
            + self.apk_object.get_services()
        )
        for component in act_serv_recv:
            if component:
                for dex in self.dexes:
                    try:
                        dex_classes = dex.get_classes_names()
                    except Exception as e:
                        continue
                    clas_name = "L" + component.replace(".", "/") + ";"
                    if clas_name in dex_classes:
                        break
                else:
                    not_found_counter += 1
        if len(act_serv_recv) == 0:
            return False
        score = not_found_counter / len(act_serv_recv)
        self.logger.info(f"Packed : Score : {score}")
        if score > 0.80:
            ispacked = True
        elif score == 0.0:
            ispacked = False
        else:
            # Lets check if MainActivity is present
            res = self.apk_object.get_main_activity()
            if res:
                for dex in self.dexes:
                    try:
                        dex_classes = dex.get_classes_names()
                    except Exception as e:
                        continue
                    clas_name = "L" + res.replace(".", "/") + ";"
                    if clas_name in dex_classes:
                        break
                else:
                    ispacked = True
        return ispacked

    def is_really_unpacked(self) -> bool:
        """Adds decrypted dex file as dvm and checks if its still packed or not"""
        if not self.decrypted_payload_path:
            return False
        # add last dvm
        with open(self.decrypted_payload_path, "rb") as fp:
            self.dexes.append(DEX(fp.read()))
        return not self.is_packed()

    def get_tag(self) -> str:
        return self.tag

    def get_name(self) -> str:
        return self.name

    def __str__(self):
        return f"Name: {self.name}\nTag: {self.tag}"

    @staticmethod
    def get_smali(target_method: EncodedMethod) -> str:
        """
        Get smali represantation of target_method
        """
        smali_str = ""
        for ins in target_method.get_instructions():
            smali_str += f"{ins.get_name()} {ins.get_output()}\n"
        return smali_str

    @staticmethod
    def get_array_data(target_method: EncodedMethod) -> list:
        """
        Get array data from target_method. This is done via parsing instructions
        """
        barrays = []
        for ins in target_method.get_instructions():
            if ins.get_name() == "fill-array-data-payload":
                # androguard bug
                # 00 03 01 00 07 00 00 00 5e 5a 6a 71 5e 6c 74 00
                # Following code has wrong data, it retusn 0c,00 instead of 0c 00 00
                # 00 03 01 00 02 00 00 00 0c 00
                # ins.get_data also return with \x00 appended, we dont need that
                raw_data = list(ins.get_raw())
                # print(ins.get_raw())
                # print(ins.get_hex())
                # print(ins.get_data())
                data_size = raw_data[4]
                barray = bytearray(raw_data[8 : 8 + data_size])
                barrays.append(barray)
        return barrays

    def find_main_application(self) -> str:
        """
        Find main application class name from AndroidManifest.xml
        If application tag is not present, find first class that extends Application
        :returns application_smali: Application class name in smali format
        """
        application_smali = None
        application = self.apk_object.get_attribute_value("application", "name")
        if application == None:
            for d in self.dexes:
                for c in d.get_classes():
                    if c.get_superclassname() == "Landroid/app/Application;":
                        application_smali = c.get_name()
                        break
        else:
            application_smali = "L" + application.replace(".", "/") + ";"
        return application_smali

    def find_method(
        self, klass_name: str, method_name: str, descriptor: str = ""
    ) -> EncodedMethod:
        """
        Find method in dvms via class name and method name. Descriptor is optional
        :returns EncodedMethod of found method
        """
        for dvm in self.dexes:
            c = dvm.get_class(klass_name)
            if c != None:
                methods = c.get_methods()
                for method in methods:
                    if method.get_name() == method_name:
                        if descriptor == "":
                            return method
                        else:
                            if method.get_descriptor() == descriptor:
                                return method
        return None

    def find_method_re(
        self, klass_name: str, method_name: str, descriptor: str = ""
    ) -> EncodedMethod:
        for dvm in self.dexes:
            c = dvm.get_class(klass_name)
            if c != None:
                methods = c.get_methods()
                for method in methods:
                    if len(re.findall(method_name, method.get_name())) > 1:
                        if descriptor == "":
                            return method
                        else:
                            if method.get_descriptor() == descriptor:
                                return method
        return None

    def find_class_in_dvms(self, klass_name: str) -> ClassDefItem:
        """Search class name in dvms and return first instance"""
        for dvm in self.dexes:
            c = dvm.get_class(klass_name)
            if c != None:
                return c
        return None

    @staticmethod
    def find_method_in_class_m(klass, method_name):
        """Find method in klass instance."""
        methods = klass.get_methods()
        for method in methods:
            if method.get_name() == method_name:
                return method
        return None

    def lazy_check(self, apk_object: APK, dvms: "list[DEX]") -> bool:
        """Check if this plugin should run. This method shouldn't be heavy."""
        return True

    def calculate_name(self, file_data) -> str:
        """Calculate external dex file name from file data by taking md5 hash of it"""
        m = hashlib.md5(file_data).hexdigest()
        return f"external-{m[:8]}.dex"

    def check_header(self, fd) -> bool:
        """Check if given data contains dex/pkzip/zlib headers"""
        if len(fd) > 7 and fd[:8] in dex_headers:
            return True
        elif len(fd) > 3 and fd[:4] in pkzip_headers:
            return True
        elif len(fd) > 1 and fd[:2] in zlib_headers:
            return True
        return False

    def check_and_write_file(self, dec) -> bool:
        """
        Check headers and write extracted dex to output_dir, if output_dir is empty save to current path. ZIP/Zlib streams is decompressed and first instance of dex file is written.
        """
        if dec[:8] in dex_headers:
            self.decrypted_payload_path = os.path.join(
                self.output_dir, self.calculate_name(dec)
            )
            self.logger.success(
                f"Decryption successful! Output dex : {self.decrypted_payload_path}"
            )
            with open(self.decrypted_payload_path, "wb") as fp:
                fp.write(dec)
            return True
        elif dec[:4] in pkzip_headers:
            self.logger.success(f"Decryption successful!\t Found zip file")
            with zipfile.ZipFile(io.BytesIO(dec), "r") as drop:
                for file in drop.filelist:
                    with drop.open(file.filename) as f:
                        zip_files_ex = f.read(8)
                        f.seek(0)
                        if zip_files_ex in dex_headers:
                            self.logger.info(
                                f"Extracting dex from zip file. Output dex : {self.decrypted_payload_path}"
                            )
                            file_data = f.read()
                            self.decrypted_payload_path = os.path.join(
                                self.output_dir, self.calculate_name(dec)
                            )
                            with open(self.decrypted_payload_path, "wb") as fp:
                                fp.write(file_data)
                            return True
        elif dec[:2] in zlib_headers:
            try:
                decrypted = zlib.decompress(dec)
            except Exception as e:
                self.logger.error(e)
                return False
            if decrypted[:8] in dex_headers:
                self.decrypted_payload_path = os.path.join(
                    self.output_dir, self.calculate_name(decrypted)
                )
                self.logger.success(f"Decryption successful!\t Found zlib file")
                with open(self.decrypted_payload_path, "wb") as fp:
                    fp.write(decrypted)
                return True
        return False

    def main(self, native_lib: str = "") -> dict:
        """
        Starting point for each plugin. Calls lazy_check then starts start_decrypt. Returns dict of result that contains status, output_file, plugin name and plugin tag
        """
        start_time = time.time()

        result = {}
        result["name"] = self.get_name()
        result["tag"] = self.get_tag()
        if not self.lazy_check(self.apk_object, self.dexes):
            result["status"] = "success" if self.get_status() else "fail"
            return result
        # try:
        o = self.start_decrypt()
        # except Exception as e:
        #    result["error"] = str(e)
        #    result["status"] = "error"
        #    return result

        result["status"] = "success" if self.get_status() else "fail"
        if self.get_status():
            result["output_file"] = self.get_path()
        end_time = time.time()

        self.logger.info(f"total analysis time = {end_time-start_time}")
        return result

    def get_status(self) -> bool:
        """
        Get decryption status by checking decrypted_payload_path
        """
        return self.decrypted_payload_path != None

    def get_path(self) -> str:
        """
        Get decrypted_payload_path
        """
        return self.decrypted_payload_path

    def start_decrypt(self):
        """
        Start decryption routine. This should be overwritten
        """
        pass

```

`src/kavanoz/utils.py`:

```py
from itertools import cycle
from loguru import logger
import logging
import sys
import re
from typing import cast


def xor(var: bytes, key: bytes) -> bytes:
    return bytes(a ^ b for a, b in zip(var, cycle(key)))

def unpad_pkcs5(data: bytes) -> bytes:
    """
    Unpads the data using the PKCS5 padding scheme.
    """
    pad_len = data[-1]
    if pad_len > 16:
        raise ValueError("Invalid padding length")
    return data[:-pad_len]

dex_headers = [
    b"dex\n035\x00",
    b"dex\n036\x00",
    b"dex\n037\x00",
    b"dex\n038\x00",
    b"dex\n039\x00",
    b"dey\n035\x00",
    b"dey\n036\x00",
    b"dey\n037\x00",
    b"dey\n038\x00",
]

pkzip_headers = [
    b"PK\x03\x04",
    b"PK\x05\x06",
    b"PK\x07\x08",
]

zlib_headers = [
    b"\x78\x01",
    b"\x78\x9c",
    b"\x78\x5e",
    b"\x78\xda",
    b"\x78\x20",
    b"\x78\x7d",
    b"\x78\xbb",
    b"\x78\xf9",
]


class MyFilter:
    def __init__(self, level):
        self.level = level

    def __call__(self, record):
        levelno = logger.level(self.level).no
        return record["level"].no >= levelno


def set_log(level):
    """
    Sets the log for loguru based on the level being passed.
    The possible values are TRACE, DEBUG, INFO, SUCCESS, WARNING, ERROR, CRITICAL
    """
    logger.remove(0)
    my_filter = MyFilter(level)
    logger.add(sys.stderr, filter=my_filter, level=0)


def unescape_unicode(str):
    codepoint = re.compile(r"(\\u[0-9a-fA-F]{4})")

    def replace(match):
        return chr(int(match.group(1)[2:], 16))

    return codepoint.sub(replace, str)


class InterceptHandler(logging.Handler):
    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
            level = logger.level(record.levelname).name
        except ValueError:
            level = record.levelno

        # Find caller from where originated the logged message.
        frame, depth = sys._getframe(6), 6
        while frame and frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back
            depth += 1

        logger.opt(depth=depth, exception=record.exc_info).log(
        level, record.getMessage()
        )

```

`tests/test.py`:

```py
import unittest
import os
import logging
from loguru import logger
from kavanoz.utils import InterceptHandler

logging.basicConfig(handlers=[InterceptHandler()], level=0, force=True)
# logging.getLogger().setLevel(logging.INFO)
# logging.getLogger("androguard").setLevel(logging.CRITICAL)
logger.remove()


from kavanoz.loader.multidex import LoaderMultidex
from kavanoz.loader.rc4 import LoaderRc4
from kavanoz.loader.subapp import LoaderSubapp
from kavanoz.loader.moqhao import LoaderMoqhao
from kavanoz.loader.coper import LoaderCoper
from kavanoz.loader.sesdex import LoaderSesdex
from kavanoz.loader.multidex_header import LoaderMultidexHeader
from kavanoz.loader.simple_xor import LoaderSimpleXor
from kavanoz.loader.simply_xor2 import LoaderSimpleXor2
from kavanoz.loader.simple_xor_zlib import LoaderSimpleXorZlib
from kavanoz.loader.simple_aes import LoaderSimpleAes
from kavanoz.loader.pronlocker import LoaderPr0nLocker
from kavanoz.loader.crocodilus import LoaderCrocodilus
from androguard.core.apk import APK
from kavanoz.loader.kangapack import LoaderKangaPack
from androguard.core.dex import DEX


class TestAllLoaders(unittest.TestCase):
    def test_rc4(self):
        """
        Test that it can sum a list of integers
        """

        filename = os.path.join(
            os.path.dirname(__file__),
            "./test_apk/loader_rc4_static_key_in_key_class.apk",
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/loader_rc4_second_key_0.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/loader_rc4_key_0.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/loader_rc4_multiple_stage.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderRc4(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

    def test_inflate(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/inflate.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderMultidex(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

        filename = os.path.join(os.path.dirname(__file__), "./test_apk/inflate2.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderMultidex(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/default_dex_protector.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderMultidex(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

    def test_inflate_second(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(
            os.path.dirname(__file__),
            "./test_apk/protect_key_chines_manifest_without_zlib.apk",
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderMultidex(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

    def test_subapp(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/subapp.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        rc4 = LoaderSubapp(apk_object, dvms, output_dir=None)
        res = rc4.main()
        assert res["status"] == "success"
        if rc4.decrypted_payload_path:
            os.remove(rc4.decrypted_payload_path)

    def test_moqhao(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/moqhao.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        moqhao = LoaderMoqhao(apk_object, dvms, output_dir=None)
        res = moqhao.main()
        assert res["status"] == "success"
        if moqhao.decrypted_payload_path:
            os.remove(moqhao.decrypted_payload_path)

    def test_coper(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/coper.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        coper = LoaderCoper(apk_object, dvms, output_dir=None)
        res = coper.main()
        assert res["status"] == "success"
        if coper.decrypted_payload_path:
            os.remove(coper.decrypted_payload_path)

    def test_coper2(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/coper2_0.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        coper = LoaderCoper(apk_object, dvms, output_dir=None)
        res = coper.main()
        assert res["status"] == "success"
        if coper.decrypted_payload_path:
            os.remove(coper.decrypted_payload_path)

        filename = os.path.join(os.path.dirname(__file__), "./test_apk/coper2_1.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        coper = LoaderCoper(apk_object, dvms, output_dir=None)
        res = coper.main()
        assert res["status"] == "success"
        if coper.decrypted_payload_path:
            os.remove(coper.decrypted_payload_path)


        filename = os.path.join(os.path.dirname(__file__), "./test_apk/coper3_2.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        coper = LoaderCoper(apk_object, dvms, output_dir=None)
        res = coper.main()
        assert res["status"] == "success"
        if coper.decrypted_payload_path:
            os.remove(coper.decrypted_payload_path)

    def test_sesdex(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/sesdex.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        sesdex = LoaderSesdex(apk_object, dvms, output_dir=None)
        res = sesdex.main()
        assert res["status"] == "success"
        if sesdex.decrypted_payload_path:
            os.remove(sesdex.decrypted_payload_path)

    def test_multidex_header(self):
        """
        Test that it can sum a list of integers
        """

        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/multidex_without_header.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        mwheader = LoaderMultidexHeader(apk_object, dvms, output_dir=None)
        res = mwheader.main()
        assert res["status"] == "success"
        if mwheader.decrypted_payload_path:
            os.remove(mwheader.decrypted_payload_path)

    def test_simple_xor(self):
        """
        Test that it can sum a list of integers
        """

        filename = os.path.join(os.path.dirname(__file__), "./test_apk/simplexor.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        sxorzlib = LoaderSimpleXor(apk_object, dvms, output_dir=None)
        res = sxorzlib.main()
        assert res["status"] == "success"
        if sxorzlib.decrypted_payload_path:
            os.remove(sxorzlib.decrypted_payload_path)

    def test_simple_xor2(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/simple_xor2.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        sxor2 = LoaderSimpleXor2(apk_object, dvms, output_dir=None)
        res = sxor2.main()
        assert res["status"] == "success"
        if sxor2.decrypted_payload_path:
            os.remove(sxor2.decrypted_payload_path)

    def test_simple_xor_zlib(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/simple_xor_zlib_base64.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        sxorzlib = LoaderSimpleXorZlib(apk_object, dvms, output_dir=None)
        res = sxorzlib.main()
        assert res["status"] == "success"
        if sxorzlib.decrypted_payload_path:
            os.remove(sxorzlib.decrypted_payload_path)
        filename = os.path.join(
            os.path.dirname(__file__), "./test_apk/simple_skip4_zlib_base64.apk"
        )
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        sxorzlib = LoaderSimpleXorZlib(apk_object, dvms, output_dir=None)
        res = sxorzlib.main()
        assert res["status"] == "success"
        if sxorzlib.decrypted_payload_path:
            os.remove(sxorzlib.decrypted_payload_path)

    def test_simple_aes(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/simpleaes.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        saes = LoaderSimpleAes(apk_object, dvms, output_dir=None)
        res = saes.main()
        assert res["status"] == "success"
        if saes.decrypted_payload_path:
            os.remove(saes.decrypted_payload_path)

    def test_kangapack(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/kangapack.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        skanga = LoaderKangaPack(apk_object, dvms, output_dir=None)
        res = skanga.main()
        assert res["status"] == "success"
        if skanga.decrypted_payload_path:
            os.remove(skanga.decrypted_payload_path)

    def test_pronlocker(self):
        """
        Test that it can sum a list of integers
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/pronlocker.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        spron = LoaderPr0nLocker(apk_object, dvms, output_dir=None)
        res = spron.main()
        assert res["status"] == "success"
        if spron.decrypted_payload_path:
            os.remove(spron.decrypted_payload_path)

    def test_crocodilus(self):
        """
        Test crocodilus loader
        """
        filename = os.path.join(os.path.dirname(__file__), "./test_apk/crocodilus.apk")
        apk_object = APK(filename)
        dvms = [DEX(dex) for dex in apk_object.get_all_dex()]
        spron = LoaderCrocodilus(apk_object, dvms, output_dir=None)
        res = spron.main()
        assert res["status"] == "success"
        if spron.decrypted_payload_path:
            os.remove(spron.decrypted_payload_path)


if __name__ == "__main__":
    unittest.main()

```