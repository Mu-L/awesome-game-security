Project Path: arc_Pusty_BinaryNinjaPlugins_msq6m02u

Source Tree:

```txt
arc_Pusty_BinaryNinjaPlugins_msq6m02u
├── LICENCE
├── README.md
├── binary-h8300
│   ├── __init__.py
│   ├── h8300.py
│   ├── h8300dis.py
│   ├── h8300lift.py
│   └── plugin.json
├── binary-jvm
│   ├── __init__.py
│   ├── jvm.py
│   └── plugin.json
├── binary-xtensa
│   ├── XTENSAArch.py
│   ├── XTENSADIS.py
│   ├── __init__.py
│   └── plugin.json
└── docs
    ├── boolFunction.PNG
    ├── patching.PNG
    ├── strings.PNG
    ├── variables.PNG
    └── xtensa-graph.png

```

`LICENCE`:

```
Copyright (c) 2021 Pusty

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

```

`README.md`:

```md
# Binary Ninja Plugins


----------


## binary-jvm

binary-jvm is a plugin for Binary Ninja providing functionality to analyze Java Class files and disassemble the code within them.
It also provides the functionality to NOP out instructions, change branch conditions or even assemble full instructions (that don't require additional meta data) at a given position.

For using this plugin just drop the binary-jvm folder into your plugin folder.


![boolFunction](/docs/boolFunction.PNG)
![strings](/docs/strings.PNG)
![variables](/docs/variables.PNG)
![patching](/docs/patching.PNG)


## binary-h8300 


binary-h8300 is a plugin for Binary Ninja providing functionality to analyze, disassemble and lift (lifting works but has bugs in it that I will hopefully fix later TM) H8/300 binaries.
Implemented decoding and behavior based on the Renesas H8/300H Software Manual

For using this plugin just drop the binary-h8300 folder into your plugin folder.

## binary-xtensa (Outdated)

*I personally have no need for this right now or in the near future and am not aware of anybody using it - there are also alternative binary ninja plugins for it so I'll probably not further work on this*

binary-xtensa is a plugin for Binary Ninja providing functionality to analyze and disassemble the code within Xtensa ELF Files.
Implemented decoding based on https://0x04.net/~mwk/doc/xtensa.pdf

For using this plugin just drop the binary-xtensa folder into your plugin folder.


![xtensa-graph](/docs/xtensa-graph.png)


```

`binary-h8300/__init__.py`:

```py
from .h8300 import *
```

`binary-h8300/h8300.py`:

```py
import struct
import traceback
import os
import math

from binaryninja import *
from types import *

from .h8300dis import *
from .h8300lift import InstructionIL 
            
# https://www.renesas.com/us/en/document/mah/h8300h-series-software-manual?language=en&r=1052456



def decode_instruction(data, addr):
        if len(data) < 2:
            return None, None, None
            
        
        inst, size, match = tryToParse(data) # in h8300dis
        
        if inst == None:
            return None, None, None
            
        return inst, size, match
        
        
def regFrom(reg, size):
    reg_str = "???"
    if size == 8:
        if((reg&0x8) == 0):
            reg_str = "r"+str(reg&7)+"h"
        else:
            reg_str = "r"+str(reg&7)+"l"
    elif size == 16:
        if((reg&0x8) == 0):
            reg_str = "r"+str(reg&7)
        else:
            reg_str = "e"+str(reg&7)
    elif size == 32:
        reg_str = "er"+str(reg)
    return reg_str
    
def signOffset(off, size):
    if size == 8:
        off = off & 0xFF
        return off | (-(off & 0x80))
    elif size == 16:
        off = off & 0xFFFF
        return off | (-(off & 0x8000))
    elif size == 24:
        off = off & 0xFFFFFF
        return off | (-(off & 0x800000))
    elif size == 32:
        off = off & 0xFFFFFFFF
        return off | (-(off & 0x80000000))
    return off

class H8300(Architecture):

    name = 'H8/300'
    
    address_size = 3
    default_int_size = 1
    instr_alignment = 1
    max_instr_length = 10
    
    endianness = Endianness.BigEndian

    # register related stuff
    regs = {
    
        # main registers
        'er0': RegisterInfo('er0', 4),
        'er1': RegisterInfo('er1', 4),
        'er2': RegisterInfo('er2', 4),
        'er3': RegisterInfo('er3', 4),
        'er4': RegisterInfo('er4', 4),
        'er5': RegisterInfo('er5', 4),
        'er6': RegisterInfo('er6', 4),
        'er7': RegisterInfo('er7', 4),
        
        # upper 16 
        
        'e0': RegisterInfo('er0', 2, 2),
        'e1': RegisterInfo('er1', 2, 2),
        'e2': RegisterInfo('er2', 2, 2),
        'e3': RegisterInfo('er3', 2, 2),
        'e4': RegisterInfo('er4', 2, 2),
        'e5': RegisterInfo('er5', 2, 2),
        'e6': RegisterInfo('er6', 2, 2),
        'e7': RegisterInfo('er7', 2, 2),
        
        # lower 16 
        
        'r0': RegisterInfo('er0', 2, 0),
        'r1': RegisterInfo('er1', 2, 0),
        'r2': RegisterInfo('er2', 2, 0),
        'r3': RegisterInfo('er3', 2, 0),
        'r4': RegisterInfo('er4', 2, 0),
        'r5': RegisterInfo('er5', 2, 0),
        'r6': RegisterInfo('er6', 2, 0),
        'r7': RegisterInfo('er7', 2, 0),
        
        # upper 8 of the lower 16
        'r0h': RegisterInfo('er0', 1, 1),
        'r1h': RegisterInfo('er1', 1, 1),
        'r2h': RegisterInfo('er2', 1, 1),
        'r3h': RegisterInfo('er3', 1, 1),
        'r4h': RegisterInfo('er4', 1, 1),
        'r5h': RegisterInfo('er5', 1, 1),
        'r6h': RegisterInfo('er6', 1, 1),
        'r7h': RegisterInfo('er7', 1, 1),
        
        
        # lower 8 
        'r0l': RegisterInfo('er0', 1, 0),
        'r1l': RegisterInfo('er1', 1, 0),
        'r2l': RegisterInfo('er2', 1, 0),
        'r3l': RegisterInfo('er3', 1, 0),
        'r4l': RegisterInfo('er4', 1, 0),
        'r5l': RegisterInfo('er5', 1, 0),
        'r6l': RegisterInfo('er6', 1, 0),
        'r7l': RegisterInfo('er7', 1, 0),
        
        # program counter
        'pc': RegisterInfo('pc', 4),
        
        # flag register
        'ccr': RegisterInfo('ccr', 1),

    }

    stack_pointer = "er7"
    # Interrupt flag, User bit or interrupt mask bit
    # Half-carry flag, Negative flag
    # Zero flag, Overflow flag, Carry flag
    flags = ['i', 'u', 'h', 'u2', 'n', 'z', 'v', 'c']

    flag_roles = {
        'i': FlagRole.SpecialFlagRole,
        'u': FlagRole.SpecialFlagRole,
        'u2': FlagRole.SpecialFlagRole,
        
        'n': FlagRole.NegativeSignFlagRole,
        'z': FlagRole.ZeroFlagRole,
        'h': FlagRole.HalfCarryFlagRole,
        'v': FlagRole.OverflowFlagRole,
        'c': FlagRole.CarryFlagRole
    }
    
    flag_write_types = ['none', '*', 'c', 'z']
    flags_written_by_flag_write_type = {
        'none': [],
        '*': ['h', 'n', 'z', 'v', 'c'],
        'c': ['c'],
        'z': ['z'],
    }
    
    flags_required_for_flag_condition = {
        LowLevelILFlagCondition.LLFC_UGT: ['c', 'z'], # hi
        LowLevelILFlagCondition.LLFC_ULE: ['c', 'z'], # ls
        LowLevelILFlagCondition.LLFC_UGE: ['c'], # cs
        LowLevelILFlagCondition.LLFC_ULT: ['c'], # cs
        LowLevelILFlagCondition.LLFC_NE:  ['z'], # ne
        LowLevelILFlagCondition.LLFC_E:   ['z'], # eq
        LowLevelILFlagCondition.LLFC_NO:  ['v'], # vc
        LowLevelILFlagCondition.LLFC_O:   ['v'], # vs
        LowLevelILFlagCondition.LLFC_POS: ['n'], # pl
        LowLevelILFlagCondition.LLFC_NEG: ['n'], # mi
        LowLevelILFlagCondition.LLFC_SGE: ['n', 'v'], # ge
        LowLevelILFlagCondition.LLFC_SLT: ['n', 'v'], # lt
        LowLevelILFlagCondition.LLFC_SGT: ['n', 'v', 'z'], # gt
        LowLevelILFlagCondition.LLFC_SLE: ['n', 'v', 'z'], # le
    }
    
    
    """
    semantic_flag_classes = ['class_bitstuff']

    semantic_flag_groups = ['group_e', 'group_ne', 'group_lt']
    
    flags_required_for_semantic_flag_group = {
        'group_lt': ['c'],
        'group_e': ['z'],
        'group_ne': ['z']
    }
    
    flag_conditions_for_semantic_flag_group = {
        #'group_e': {None: LowLevelILFlagCondition.LLFC_E},
        #'group_ne': {None: LowLevelILFlagCondition.LLFC_NE}
    }

    # MAP (condition x class) -> flags
    def get_flags_required_for_flag_condition(self, cond, sem_class):
        #LogDebug('incoming cond: %s, incoming sem_class: %s' % (str(cond), str(sem_class)))

        if sem_class == None:
            lookup = {
                # Z, zero flag for == and !=
                LowLevelILFlagCondition.LLFC_E: ['z'],
                LowLevelILFlagCondition.LLFC_NE: ['z'],
                LowLevelILFlagCondition.LLFC_NEG: ['n'],
                LowLevelILFlagCondition.LLFC_UGE: ['c'],
                LowLevelILFlagCondition.LLFC_ULT: ['c']
            }

            if cond in lookup:
                return lookup[cond]

        return []    
    """


    def get_instruction_info(self, data, addr):
    
        inst, size, match = decode_instruction(data, addr)
        
        if inst == None:
            return None
            
        result = InstructionInfo()
        result.length = size
        
        instName = inst[0].split(" ")[0]
        
        JMP_NAMES = ["BHI", "BLS", "BHS", "BLO", "BNE", "BEQ", "BVC", "BPL", "BMI", "BGE", "BLT", "BGT", "BLE" ] # BF never branches
        # "BSR"
        # JMP, JSR

        if not ((instName in JMP_NAMES) or instName == "BT" or instName == "BSR" or instName == "JMP" or instName == "JSR" or instName == "RTS" or instName == "RTE"):
            return result
            
        if instName == "RTE":
            # EXCEPTION RETURN
            result.add_branch(BranchType.FunctionReturn)
        
        if instName == "RTS":
            # RETURN
            result.add_branch(BranchType.FunctionReturn)
            
        if instName == "BT":
            # UNCONDITIONAL JUMP
            for l in inst[2]:
                if l[0] == TYPE_PCOFFSET:
                    result.add_branch(BranchType.UnconditionalBranch, addr + size + signOffset(match[l[2]], l[1]))
        
        
            
        if instName in JMP_NAMES:
            # CONDITIONAL BRANCH
            for l in inst[2]:
                if l[0] == TYPE_PCOFFSET:
                    result.add_branch(BranchType.TrueBranch, addr + size + signOffset(match[l[2]], l[1]))
            result.add_branch(BranchType.FalseBranch, addr + size)


        if instName == "BSR":
            # DIRECT CALL
            for l in inst[2]:
                if l[0] == TYPE_PCOFFSET:
                    result.add_branch(BranchType.CallDestination, addr + size + signOffset(match[l[2]], l[1]))
            
        if instName == "JMP":
            if inst[2][0][0] == TYPE_ABS:
                result.add_branch(BranchType.UnconditionalBranch, match[inst[2][0][3]])
            else:
                # UNCONDITIONAL JUMP TO REGISTER OR DOUBLE MEMORY LOOKUP
                result.add_branch(BranchType.IndirectBranch)    
            
        if instName == "JSR":
            if inst[2][0][0] == TYPE_ABS:
                result.add_branch(BranchType.CallDestination, match[inst[2][0][3]])
            else:
                # UNCONDITIONAL CALL TO REGISTER OR DOUBLE MEMORY LOOKUP
                result.add_branch(BranchType.IndirectBranch)    
            
            
            
        """


        if obj.name in ["CALL0", "CALL4", "CALL8", "CALL12"]:
            # DIRECT CALL
            for l in obj.prop["format"]:
                if l[0] == "TYPE_LABEL":
                    result.add_branch(BranchType.CallDestination, l[1])

        if obj.name in ["JX"]:
            # UNCONDITIONAL JUMP TO REGISTER
            result.add_branch(BranchType.IndirectBranch)    
        """
            
        return result
        

        
    def get_instruction_text(self, data, addr):
        inst, size, match = decode_instruction(data, addr)
        
        if inst == None:
            return None
            
        result = []

        instName = inst[0].split(" ")[0]
        result.append(InstructionTextToken( InstructionTextTokenType.InstructionToken, instName))
        
        """
        TYPE_ATREG = "atreg" # size, access size, offset / '+' / '-' / None, letter
        TYPE_OFFSET = "offset" # size, letter
        TYPE_PCOFFSET = "pcoffset" # size
        """
        
        parIndex = 0
        for l in inst[2]:
            if parIndex > 0:
                result.append(InstructionTextToken(InstructionTextTokenType.TextToken, ','))
            result.append(InstructionTextToken(InstructionTextTokenType.TextToken, ' '))
            
            if l[0] == TYPE_IMM:
                result.append(InstructionTextToken(InstructionTextTokenType.TextToken, '#'))
                result.append(InstructionTextToken(InstructionTextTokenType.IntegerToken, hex(match[l[2]]), match[l[2]]))
            elif l[0] == TYPE_CONST:
                result.append(InstructionTextToken(InstructionTextTokenType.TextToken, '#'))
                result.append(InstructionTextToken(InstructionTextTokenType.IntegerToken, hex(l[1]), l[1]))
            elif l[0] == TYPE_REGCCR:
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "ccr"))
            elif l[0] == TYPE_ABS:
                absAddr = match[l[3]]
                result.append(InstructionTextToken(InstructionTextTokenType.BeginMemoryOperandToken, '@'))
                result.append(InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, hex(absAddr), absAddr))
                result.append(InstructionTextToken(InstructionTextTokenType.EndMemoryOperandToken, ''))
            elif l[0] == TYPE_ATABS:
                absAddr = match[l[3]]
                result.append(InstructionTextToken(InstructionTextTokenType.BeginMemoryOperandToken, '@@'))
                result.append(InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, hex(absAddr), absAddr))
                result.append(InstructionTextToken(InstructionTextTokenType.EndMemoryOperandToken, ''))
            elif l[0] == TYPE_ATREG:
                reg = match[l[4]]
                regStr = regFrom(reg, l[1])
                
                if l[3] == None or l[3] == '-' or l[3] == '+':

                    result.append(InstructionTextToken(InstructionTextTokenType.BeginMemoryOperandToken, '@'))
                    if l[3] == '-':
                        result.append(InstructionTextToken(InstructionTextTokenType.TextToken, '-'))
                    result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, regStr))
                    if l[3] == '+':
                        result.append(InstructionTextToken(InstructionTextTokenType.TextToken, '+'))
                    result.append(InstructionTextToken(InstructionTextTokenType.EndMemoryOperandToken, ''))
                else:
                    offset = signOffset(match[l[3][2]], l[3][1])
                    
                    result.append(InstructionTextToken(InstructionTextTokenType.BeginMemoryOperandToken, '@('))
                    result.append(InstructionTextToken(InstructionTextTokenType.IntegerToken, hex(offset), offset))
                    result.append(InstructionTextToken(InstructionTextTokenType.TextToken, ','))
                    result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, regStr))
                    result.append(InstructionTextToken(InstructionTextTokenType.EndMemoryOperandToken, ')'))
   
            elif l[0] == TYPE_REG:
                reg = match[l[2]]
                regStr = regFrom(reg, l[1])
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, regStr))
            elif l[0] == TYPE_PCOFFSET:
                pcOffset = signOffset(match[l[2]], l[1])
                result.append(InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, hex(addr+pcOffset+size), addr+pcOffset+size))
            #    
            parIndex = parIndex + 1
            
        return result, size
  
    
    def get_flag_write_low_level_il(self, op, size, write_type, flag, operands, il):
        return Architecture.get_flag_write_low_level_il(self, op, size, write_type, flag, operands, il)
        
        

    def get_instruction_low_level_il(self, data, addr, il):
        if len(data) < 2: return None
        inst, size, match = decode_instruction(data, addr)
        if inst == None: return None

        instName = inst[0].split(" ")[0]
        
        args = []
        
        for l in inst[2]:
            if l[0] == TYPE_IMM:
                args.append((TYPE_IMM, math.ceil(l[1]/8), match[l[2]]))
            elif l[0] == TYPE_CONST:
                args.append((TYPE_CONST, l[1]))
            elif l[0] == TYPE_REGCCR:
                args.append((TYPE_REGCCR))
            elif l[0] == TYPE_ABS:
                args.append((TYPE_ABS, math.ceil(l[1]/8), math.ceil(l[2]/8), match[l[3]]))
            elif l[0] == TYPE_ATABS:
                args.append((TYPE_ATABS, math.ceil(l[1]/8), math.ceil(l[2]/8), match[l[3]]))
            elif l[0] == TYPE_ATREG:
                r = regFrom(match[l[4]], l[1])
                sizeO = math.ceil(l[1]/8)
                sizeA = math.ceil(l[2]/8)
                if l[3] == None or l[3] == '-' or l[3] == '+':
                    if l[3] == '-':
                        args.append((TYPE_ATREG, sizeO, sizeA, "-", r))
                    elif l[3] == '+':
                        args.append((TYPE_ATREG, sizeO, sizeA, "+", r))
                    else:
                        args.append((TYPE_ATREG, sizeO, sizeA, "@", r))
                else:
                    args.append((TYPE_ATREG, sizeO, sizeA, "offset", r, signOffset(match[l[3][2]], l[3][1])))
            elif l[0] == TYPE_REG:
                args.append((TYPE_REG, math.ceil(l[1]/8), regFrom(match[l[2]], l[1])))
            elif l[0] == TYPE_PCOFFSET:
                args.append((TYPE_PCOFFSET, math.ceil(l[1]/8), addr+signOffset(match[l[2]], l[1])+size, addr+size))
        
        if InstructionIL.get(instName) is not None:
            instLifted = InstructionIL[instName](il, args)
            if isinstance(instLifted, list):
                for i in instLifted:
                    if isinstance(i, LambdaType):
                        i(il, args)
                    else:    
                        il.append(i)
            elif instLifted is not None:
                il.append(instLifted)
        else:
            il.append(il.unimplemented())
        

        return size
        
H8300.register()

```

`binary-h8300/h8300dis.py`:

```py
"""
instructions = [
("add.b", "#xx:8, Rd",  [(8, "rd"), "imm"]),
("add.b", "Rs, Rd",     [(0, 8), ("rs", "rd")]),
("add.w", "#xx:16, Rd", [(7, 9), (1, "rd"), "imm", "imm"]),
("add.w", "Rs, Rd",     [(0, 9), ("rs", "rd")]),
("add.l", "#xx:32, ERd", [(7, 0xA), (1, (0, "erd")), "imm", "imm", "imm", "imm"]),
("add.l", "Rs, ERd",     [(0, 0xA), ((1, "ers"), (0, "erd"))]),
("adds", "#1, ERd",      [(0, 0xB), (0, (0, "erd"))],
("adds", "#2, ERd",      [(0, 0xB), (8, (0, "erd"))],
("adds", "#4, ERd",      [(0, 0xB), (9, (0, "erd"))],
("addx", "#xx:8, Rd",    [(9, "rd"), "imm"]),
("addx", "Rs, Rd",       [(0, 0xE), ("rs", "rd"]),
("and.b", "#xx:8, Rd",    [(0xE, "rd"), "imm"]),
("and.b", "Rs, Rd",       [(1, 6), ("rs", "rd"]),
("and.w", "#xx:16, Rd", [(7, 9), (6, "rd"), "imm", "imm"]),
("and.w", "Rs, Rd",     [(6, 6), ("rs", "rd")]),
("and.l", "#xx:32, ERd", [(7, 0xA), (6, (0, "erd")), "imm", "imm", "imm", "imm"]),
("and.l", "Rs, ERd",     [(0, 1), (0xF, 0), (6, 6), ((0, "ers"), (0, "erd"))]),
("andc", "#xx:8, CCR",  [(0, 6), "imm"]),
("band", "#xx:3.Rd", [ (7, 6), ((0, "imm"), "rd") ]),
("band", "#xx:3.@ERd", [ (7, 0xC), ((0, "erd"), 0), (7,6), ((0, "imm"), 0) ]),
("band", "#xx:3.@aa:8", [ (7, 0xE), "abs", (7, 6), ((0, "imm"), 0) ]),
("bt", "d:8",  [(4, 0), "disp"]),
("bt", "d:16", [(5, 8), (0, 0), "disp", "disp"]),
("bf", "d:8",  [(4, 1), "disp"]),
("bf", "d:16", [(5, 8), (1, 0), "disp", "disp"]),
("bhi", "d:8",  [(4, 2), "disp"]),
("bhi", "d:16", [(5, 8), (2, 0), "disp", "disp"]),
("bls", "d:8",  [(4, 3), "disp"]),
("bls", "d:16", [(5, 8), (3, 0), "disp", "disp"]),
("bhs", "d:8",  [(4, 4), "disp"]),
("bhs", "d:16", [(5, 8), (4, 0), "disp", "disp"]),
("blo", "d:8",  [(4, 5), "disp"]),
("blo", "d:16", [(5, 8), (5, 0), "disp", "disp"]),
("bne", "d:8",  [(4, 6), "disp"]),
("bne", "d:16", [(5, 8), (6, 0), "disp", "disp"]),
("beq", "d:8",  [(4, 7), "disp"]),
("beq", "d:16", [(5, 8), (7, 0), "disp", "disp"]),
("bvc", "d:8",  [(4, 8), "disp"]),
("bvc", "d:16", [(5, 8), (8, 0), "disp", "disp"]),
("bvs", "d:8",  [(4, 9), "disp"]),
("bvs", "d:16", [(5, 8), (9, 0), "disp", "disp"]),
("bpl", "d:8",  [(4, 10), "disp"]),
("bpl", "d:16", [(5, 8), (10, 0), "disp", "disp"]),
("bmi", "d:8",  [(4, 11), "disp"]),
("bmi", "d:16", [(5, 8), (11, 0), "disp", "disp"]),
("bge", "d:8",  [(4, 12), "disp"]),
("bge", "d:16", [(5, 8), (12, 0), "disp", "disp"]),
("blt", "d:8",  [(4, 13), "disp"]),
("blt", "d:16", [(5, 8), (13, 0), "disp", "disp"]),
("bgt", "d:8",  [(4, 14), "disp"]),
("bgt", "d:16", [(5, 8), (14, 0), "disp", "disp"]),
("ble", "d:8",  [(4, 15), "disp"]),
("ble", "d:16", [(5, 8), (15, 0), "disp", "disp"]),
]
"""

"""
formatImmedate8    = "ooooddddiiiiiiii"
formatImmedate16   = "01111001ooooddddiiiiiiiiiiiiiiii"
formatImmedate32   = "01111010oooo0dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"
formatRegister8    = "oooooooossssdddd"
formatRegister16   = "oooooooossssdddd"
formatRegister32   = "oooooooo1sss0ddd"
formatAdds         = "00001011oooo0ddd"
formatAnd32        = "00000001111100000110oooo0sss0ddd"
formatOnlyImm8     = "ooooooooiiiiiiii"
formatBitR8        = "oooooooobiiidddd"
formatBitR32       = "oooooooo0ddd0000ppppppppbiii0000"
formatBitAbs       = "ooooooooaaaaaaaappppppppbiii0000"
formatBitRR32      = "oooooooo0ddd0000ppppppppnnnn0000"
formatBitRAbs      = "ooooooooaaaaaaaappppppppnnnn0000"
formatOnlyImm16    = "ooooooooppppppppiiiiiiiiiiiiiiii"
formatOnlyRd       = "ooooooooppppdddd"
formatNop          = "oooooooopppppppp"

FORMAT_IMMEDIATE8  = 0
FORMAT_IMMEDIATE16 = 1
FORMAT_IMMEDIATE32 = 2
FORMAT_REGISTER8   = 3
FORMAT_REGISTER16  = 4
FORMAT_REGISTER32  = 5
FORMAT_ADDS        = 6
FORMAT_AND32       = 7
FORMAT_ONLY_IMM8   = 8
FORMAT_BITS_R8     = 9
FORMAT_BITS_R32    = 10
FORMAT_BITS_ABS    = 11
FORMAT_BITS_RR32   = 12
FORMAT_BITS_RABS   = 13
FORMAT_ONLY_IMM16  = 14
FORMAT_ONLY_RD     = 15
FORMAT_NOP         = 16

insts = [
("add.b", [(FORMAT_IMMEDIATE8, 0x8, "ADD.B #xx:8,Rd"), (FORMAT_REGISTER8, 0x08, "ADD.B Rs,Rd")]),
("add.w", [(FORMAT_IMMEDIATE16, 0x1, "ADD.W #xx:16,Rd"), (FORMAT_REGISTER16, 0x09, "ADD.W Rs,Rd")]),
("add.l", [(FORMAT_IMMEDIATE32, 0x1, "ADD.L #xx:32,ERd"), (FORMAT_REGISTER32, 0x0A, "ADD.L ERs,ERd")]),
("adds",  [(FORMAT_ADDS, 0x0, "ADDS #1,ERd"), (FORMAT_ADDS, 0x8, "ADDS #2,ERd"), (FORMAT_ADDS, 0x9, "ADDS #4,ERd")]),
("addx",  [(FORMAT_IMMEDIATE8, 0x9, "ADDX #xx:8,Rd"), (FORMAT_REGISTER8, 0x0E, "ADDX Rs,Rd")]),
("and.b", [(FORMAT_IMMEDIATE8, 0xE, "AND.B #xx:8,Rd"), (FORMAT_REGISTER8, 0x16, "AND.B Rs,Rd")]),
("and.w", [(FORMAT_IMMEDIATE16, 0x6, "AND.W #xx:16,Rd"), (FORMAT_REGISTER16, 0x66, "AND.W Rs,Rd")]),
("and.l", [(FORMAT_IMMEDIATE32, 0x6, "AND.L #xx:32,ERd"), (FORMAT_AND32, 0x6, "AND.L ERs,ERd")]),
("andc",  [(FORMAT_ONLY_IMM8, 0x6, "ANDC #xx:8,CCR")]),
("band",  [(FORMAT_BITS_R8, 0x76, "BAND #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7C, "BAND #xx:3,@ERd", 0x76, 0), (FORMAT_BITS_ABS, 0x7E, "BAND #xx:3,@aa:8", 0x76, 0)]),
("bt",     [(FORMAT_ONLY_IMM8, 0x40, "BT d:8"), (FORMAT_ONLY_IMM16, 0x58, "BT d:16", 0x00)]),
("bf",     [(FORMAT_ONLY_IMM8, 0x41, "BF d:8"), (FORMAT_ONLY_IMM16, 0x58, "BF d:16", 0x10)]),
("bhi",    [(FORMAT_ONLY_IMM8, 0x42, "BHI d:8"), (FORMAT_ONLY_IMM16, 0x58, "BHI d:16", 0x20)]),
("bls",    [(FORMAT_ONLY_IMM8, 0x43, "BLS d:8"), (FORMAT_ONLY_IMM16, 0x58, "BLS d:16", 0x30)]),
("bhs",    [(FORMAT_ONLY_IMM8, 0x44, "BHS d:8"), (FORMAT_ONLY_IMM16, 0x58, "BHS d:16", 0x40)]),
("blo",    [(FORMAT_ONLY_IMM8, 0x45, "BLO d:8"), (FORMAT_ONLY_IMM16, 0x58, "BLO d:16", 0x50)]),
("bne",    [(FORMAT_ONLY_IMM8, 0x46, "BNE d:8"), (FORMAT_ONLY_IMM16, 0x58, "BNE d:16", 0x60)]),
("beq",    [(FORMAT_ONLY_IMM8, 0x47, "BEQ d:8"), (FORMAT_ONLY_IMM16, 0x58, "BEQ d:16", 0x70)]),
("bvc",    [(FORMAT_ONLY_IMM8, 0x48, "BVC d:8"), (FORMAT_ONLY_IMM16, 0x58, "BVC d:16", 0x80)]),
("bvs" ,   [(FORMAT_ONLY_IMM8, 0x49, "BVS d:8"), (FORMAT_ONLY_IMM16, 0x58, "BVS d:16", 0x90)]),
("bpl" ,   [(FORMAT_ONLY_IMM8, 0x4A, "BPL d:8"), (FORMAT_ONLY_IMM16, 0x58, "BPL d:16", 0xA0)]),
("bmi",    [(FORMAT_ONLY_IMM8, 0x4B, "BMI d:8"), (FORMAT_ONLY_IMM16, 0x58, "BMI d:16", 0xB0)]),
("bge",    [(FORMAT_ONLY_IMM8, 0x4C, "BGE d:8"), (FORMAT_ONLY_IMM16, 0x58, "BGE d:16", 0xC0)]),
("blt" ,   [(FORMAT_ONLY_IMM8, 0x4D, "BLT d:8"), (FORMAT_ONLY_IMM16, 0x58, "BLT d:16", 0xD0)]),
("bgt",    [(FORMAT_ONLY_IMM8, 0x4E, "BGT d:8"), (FORMAT_ONLY_IMM16, 0x58, "BGT d:16", 0xE0)]),
("ble",    [(FORMAT_ONLY_IMM8, 0x4F, "BLE d:8"), (FORMAT_ONLY_IMM16, 0x58, "BLE d:16", 0xF0)]),
("bclr",  [(FORMAT_BITS_R8, 0x72, "BCLR #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7D, "BCLR #xx:3,@ERd", 0x72, 0), (FORMAT_BITS_ABS, 0x7F, "BCLR #xx:3,@aa:8", 0x72, 0),
 (FORMAT_REGISTER8, 0x62, "BCLR Rs,Rd"), (FORMAT_BITS_RR32, 0x7D, "BCLR Rn,@ERd", 0x62), (FORMAT_BITS_RABS, 0x7F, "BCLR Rn,@aa:8", 0x62)]),
("biand",  [(FORMAT_BITS_R8, 0x76, "BIAND #xx:3,Rd", 1), (FORMAT_BITS_R32, 0x7C, "BIAND #xx:3,@ERd", 0x76, 1), (FORMAT_BITS_ABS, 0x7E, "BIAND #xx:3,@aa:8", 0x76, 1)]),
("bild",  [(FORMAT_BITS_R8, 0x77, "BILD #xx:3,Rd", 1), (FORMAT_BITS_R32, 0x7C, "BILD #xx:3,@ERd", 0x77, 1), (FORMAT_BITS_ABS, 0x7E, "BILD #xx:3,@aa:8", 0x77, 1)]),
("bior",  [(FORMAT_BITS_R8, 0x74, "BIOR #xx:3,Rd", 1), (FORMAT_BITS_R32, 0x7C, "BIOR #xx:3,@ERd", 0x74, 1), (FORMAT_BITS_ABS, 0x7E, "BIOR #xx:3,@aa:8", 0x74, 1)]),
("bist",  [(FORMAT_BITS_R8, 0x67, "BIST #xx:3,Rd", 1), (FORMAT_BITS_R32, 0x7D, "BIST #xx:3,@ERd", 0x67, 1), (FORMAT_BITS_ABS, 0x7F, "BIST #xx:3,@aa:8", 0x67, 1)]),
("bixor",  [(FORMAT_BITS_R8, 0x75, "BIXOR #xx:3,Rd", 1), (FORMAT_BITS_R32, 0x7C, "BIXOR #xx:3,@ERd", 0x75, 1), (FORMAT_BITS_ABS, 0x7E, "BIXOR #xx:3,@aa:8", 0x75, 1)]),
("bld",  [(FORMAT_BITS_R8, 0x77, "BLD #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7C, "BLD #xx:3,@ERd", 0x77, 0), (FORMAT_BITS_ABS, 0x7E, "BLD #xx:3,@aa:8", 0x77, 0)]),
("bnot",  [(FORMAT_BITS_R8, 0x71, "BNOT #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7D, "BNOT #xx:3,@ERd", 0x71, 0), (FORMAT_BITS_ABS, 0x7F, "BNOT #xx:3,@aa:8", 0x71, 0),
 (FORMAT_REGISTER8, 0x61, "BNOT Rs,Rd"), (FORMAT_BITS_RR32, 0x7D, "BNOT Rn,@ERd", 0x61), (FORMAT_BITS_RABS, 0x7F, "BNOT Rn,@aa:8", 0x61)]),
("bor",  [(FORMAT_BITS_R8, 0x74, "BOR #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7C, "BOR #xx:3,@ERd", 0x74, 0), (FORMAT_BITS_ABS, 0x7E, "BIOR #xx:3,@aa:8", 0x74, 0)]),
("bset",  [(FORMAT_BITS_R8, 0x70, "BSET #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7D, "BSET #xx:3,@ERd", 0x70, 0), (FORMAT_BITS_ABS, 0x7F, "BSET #xx:3,@aa:8", 0x70, 0),
 (FORMAT_REGISTER8, 0x60, "BSET Rs,Rd"), (FORMAT_BITS_RR32, 0x7D, "BSET Rn,@ERd", 0x60), (FORMAT_BITS_RABS, 0x7F, "BSET Rn,@aa:8", 0x60)]),
("bsr",  [(FORMAT_ONLY_IMM8, 0x55, "BSR d:8"), (FORMAT_ONLY_IMM16, 0x5C, "BSR d:16", 0x00)]),
("bst",  [(FORMAT_BITS_R8, 0x67, "BST #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7D, "BST #xx:3,@ERd", 0x67, 0), (FORMAT_BITS_ABS, 0x7F, "BST #xx:3,@aa:8", 0x67, 0)]),
("btst",  [(FORMAT_BITS_R8, 0x73, "BTST #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7C, "BTST #xx:3,@ERd", 0x73, 0), (FORMAT_BITS_ABS, 0x7E, "BTST #xx:3,@aa:8", 0x73, 0),
 (FORMAT_REGISTER8, 0x63, "BTST Rs,Rd"), (FORMAT_BITS_RR32, 0x7C, "BTST Rn,@ERd", 0x63), (FORMAT_BITS_RABS, 0x7E, "BTST Rn,@aa:8", 0x63)]),
("bxor",  [(FORMAT_BITS_R8, 0x75, "BXOR #xx:3,Rd", 0), (FORMAT_BITS_R32, 0x7C, "BXOR #xx:3,@ERd", 0x75, 0), (FORMAT_BITS_ABS, 0x7E, "BXOR #xx:3,@aa:8", 0x75, 0)]),
("cmp.b", [(FORMAT_IMMEDIATE8, 0xA, "CMP.B #xx:8,Rd"), (FORMAT_REGISTER8, 0x1C, "CMP.B Rs,Rd")]),
("cmp.w", [(FORMAT_IMMEDIATE16, 0x2, "CMP.W #xx:16,Rd"), (FORMAT_REGISTER16, 0x1D, "CMP.W Rs,Rd")]),
("cmp.l", [(FORMAT_IMMEDIATE32, 0x2, "CMP.L #xx:32,ERd"), (FORMAT_REGISTER32, 0x1F, "CMP.L ERs,ERd")]),
("daa",   [(FORMAT_ONLY_RD, 0x0F, "DAA Rd", 0)]),
("das",   [(FORMAT_ONLY_RD, 0x1F, "DAS Rd", 0)]),
("dec.b",   [(FORMAT_ONLY_RD, 0x1A, "DEC.B Rd", 0)]),
("dec.w",   [(FORMAT_ONLY_RD, 0x1B, "DEC.W #1,Rd", 0x5), (FORMAT_ONLY_RD, 0x1B, "DEC.W #2,Rd", 0xD)]),
("dec.l",   [(FORMAT_ONLY_RD, 0x1B, "DEC.L #1,ERd", 0x7), (FORMAT_ONLY_RD, 0x1B, "DEC.L #2,ERd", 0xF)]),

#AND.L ERs,ERd L 0 1 F 0 6 6 0 ers 0 erd
#DIVXS.B Rs,Rd B 0 1 D 0 5 1 rs rd

("divxu",   [(FORMAT_REGISTER16, 0x51, "DIVXU.B Rs,Rd"), (FORMAT_REGISTER16, 0x53, "DIVXU.W Rs,ERd")]),
# eepmov
("exts.w",   [(FORMAT_ONLY_RD, 0x17, "EXTS.W Rd", 0x0D)]),
("exts.l",   [(FORMAT_ONLY_RD, 0x17, "EXTS.L ERd", 0x0F)]),
("extu.w",   [(FORMAT_ONLY_RD, 0x17, "EXTU.W Rd", 0x05)]),
("extu.l",   [(FORMAT_ONLY_RD, 0x17, "EXTU.L ERd", 0x07)]),
("inc.b",   [(FORMAT_ONLY_RD, 0x0A, "INC.B Rd", 0)]),
("inc.w",   [(FORMAT_ONLY_RD, 0x0B, "INC.W #1,Rd", 0x5), (FORMAT_ONLY_RD, 0x0B, "INC.W #2,Rd", 0xD)]),
("inc.l",   [(FORMAT_ONLY_RD, 0x0B, "INC.L #1,ERd", 0x7), (FORMAT_ONLY_RD, 0x0B, "INC.L #2,ERd", 0xF)]),

("mulxu",   [(FORMAT_REGISTER16, 0x50, "MULXU.B Rs,Rd"), (FORMAT_REGISTER16, 0x52, "MULXU.W Rs,ERd")]),
("neg.b",   [(FORMAT_ONLY_RD, 0x17, "NEG.B Rd", 0x08)]),
("neg.w",   [(FORMAT_ONLY_RD, 0x17, "NEG.W Rd", 0x09)]),
("neg.l",   [(FORMAT_ONLY_RD, 0x17, "NEG.L ERd", 0x0B)]),
("nop",     [(FORMAT_NOP,     0x00, "NOP", 0x00)]), 
("not.b",   [(FORMAT_ONLY_RD, 0x17, "NOT.B Rd", 0x00)]),
("not.w",   [(FORMAT_ONLY_RD, 0x17, "NOT.W Rd", 0x01)]),
("not.l",   [(FORMAT_ONLY_RD, 0x17, "NOT.L ERd", 0x03)]),
("or.b", [(FORMAT_IMMEDIATE8, 0xC, "OR.B #xx:8,Rd"), (FORMAT_REGISTER8, 0x14, "OR.B Rs,Rd")]),
("or.w", [(FORMAT_IMMEDIATE16, 0x4, "OR.W #xx:16,Rd"), (FORMAT_REGISTER16, 0x64, "OR.W Rs,Rd")]),
("or.l", [(FORMAT_IMMEDIATE32, 0x4, "OR.L #xx:32,ERd"), (FORMAT_AND32, 0x4, "OR.L ERs,ERd")]),
("orc",  [(FORMAT_ONLY_IMM8, 0x4, "ORC #xx:8,CCR")]),
#("pop.w",   [(FORMAT_ONLY_RD, 0x6D, "POP.W Rd", 0x07)]),
#("pop.l",   [(FORMAT_ONLY_RD, 0x17, "POP.L ERd", 0x03)]),
#("push.w",   [(FORMAT_ONLY_RD, 0x6D, "PUSH.W Rd", 0x0F)]),
#("push.l",   [(FORMAT_ONLY_RD, 0x17, "PUSH.L ERd", 0x03)]),
("rotl.b",   [(FORMAT_ONLY_RD, 0x12, "ROTL.B Rd", 0x08)]),
("rotl.w",   [(FORMAT_ONLY_RD, 0x12, "ROTL.W Rd", 0x09)]),
("rotl.l",   [(FORMAT_ONLY_RD, 0x12, "ROTL.L ERd", 0x0B)]),
("rotr.b",   [(FORMAT_ONLY_RD, 0x13, "ROTR.B Rd", 0x08)]),
("rotr.w",   [(FORMAT_ONLY_RD, 0x13, "ROTR.W Rd", 0x09)]),
("rotr.l",   [(FORMAT_ONLY_RD, 0x13, "ROTR.L ERd", 0x0B)]),
("rotxl.b",   [(FORMAT_ONLY_RD, 0x12, "ROTXL.B Rd", 0x00)]),
("rotxl.w",   [(FORMAT_ONLY_RD, 0x12, "ROTXL.W Rd", 0x01)]),
("rotxl.l",   [(FORMAT_ONLY_RD, 0x12, "ROTXL.L ERd", 0x03)]),
("rotxr.b",   [(FORMAT_ONLY_RD, 0x13, "ROTXR.B Rd", 0x00)]),
("rotxr.w",   [(FORMAT_ONLY_RD, 0x13, "ROTXR.W Rd", 0x01)]),
("rotxr.l",   [(FORMAT_ONLY_RD, 0x13, "ROTXR.L ERd", 0x03)]),
("rte",     [(FORMAT_NOP,     0x56, "RTE", 0x70)]), 
("rts",     [(FORMAT_NOP,     0x54, "RTS", 0x70)]), 
("shal.b",   [(FORMAT_ONLY_RD, 0x10, "SHAL.B Rd", 0x08)]),
("shal.w",   [(FORMAT_ONLY_RD, 0x10, "SHAL.W Rd", 0x09)]),
("shal.l",   [(FORMAT_ONLY_RD, 0x10, "SHAL.L ERd", 0x0B)]),
("shar.b",   [(FORMAT_ONLY_RD, 0x11, "SHAR.B Rd", 0x08)]),
("shar.w",   [(FORMAT_ONLY_RD, 0x11, "SHAR.W Rd", 0x09)]),
("shar.l",   [(FORMAT_ONLY_RD, 0x11, "SHAR.L ERd", 0x0B)]),
("shll.b",   [(FORMAT_ONLY_RD, 0x10, "SHLL.B Rd", 0x00)]),
("shll.w",   [(FORMAT_ONLY_RD, 0x10, "SHLL.W Rd", 0x01)]),
("shll.l",   [(FORMAT_ONLY_RD, 0x10, "SHLL.L ERd", 0x03)]),
("shlr.b",   [(FORMAT_ONLY_RD, 0x11, "SHLR.B Rd", 0x00)]),
("shlr.w",   [(FORMAT_ONLY_RD, 0x11, "SHLR.W Rd", 0x01)]),
("shlr.l",   [(FORMAT_ONLY_RD, 0x11, "SHLR.L ERd", 0x03)]),
("sleep",     [(FORMAT_NOP,     0x01, "SLEEP", 0x80)]), 
#stc
("sub.b", [(FORMAT_REGISTER8, 0x18, "SUB.B Rs,Rd")]),
("sub.w", [(FORMAT_IMMEDIATE16, 0x3, "SUB.W #xx:16,Rd"), (FORMAT_REGISTER16, 0x19, "SUB.W Rs,Rd")]),
("sub.l", [(FORMAT_IMMEDIATE32, 0x3, "SUB.L #xx:32,ERd"), (FORMAT_REGISTER32, 0x1A, "SUB.L ERs,ERd")]),
("subs.l",   [(FORMAT_ONLY_RD, 0x1B, "SUBS #1,ERd", 0x00), (FORMAT_ONLY_RD, 0x1B, "SUBS #2,ERd", 0x08), (FORMAT_ONLY_RD, 0x1B, "SUBS #4,ERd", 0x09)]),
("subx",  [(FORMAT_IMMEDIATE8, 0xB, "SUBX #xx:8,Rd"), (FORMAT_REGISTER8, 0x1E, "SUBX Rs,Rd")]),
("trapa", [(FORMAT_ONLY_IMM8, 0x57, "TRAPA #x:2")]),
("xor.b", [(FORMAT_IMMEDIATE8, 0xD, "XOR.B #xx:8,Rd"), (FORMAT_REGISTER8, 0x15, "XOR.B Rs,Rd")]),
("xor.w", [(FORMAT_IMMEDIATE16, 0x5, "XOR.W #xx:16,Rd"), (FORMAT_REGISTER16, 0x65, "XOR.W Rs,Rd")]),
("xor.l", [(FORMAT_IMMEDIATE32, 0x5, "XOR.L #xx:32,ERd"), (FORMAT_AND32, 0x5, "XOR.L ERs,ERd")]),
("xorc",  [(FORMAT_ONLY_IMM8, 0x5, "XORC #xx:8,CCR")])
] 

def applyPar(inp, cha, num):

    maxbitlen = inp.count(cha)
    
    if num >= 2**maxbitlen:
        print("ERROR MAX BITLEN",inp, cha, num)
        exit(0)
        
    j = 0
    for i in range(len(inp)):
        if inp[i] == cha:
            inp[i] = str((num >> (maxbitlen-1-j))&1)
            j = j + 1
        
    
convInst = []

for inst in insts:
    for fmt in inst[1]:
        typ = fmt[0]
        #print(fmt, typ)
        pattern = ""
        if typ == FORMAT_IMMEDIATE8:
            pattern = list(formatImmedate8)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_IMMEDIATE16:
            pattern = list(formatImmedate16)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_IMMEDIATE32:
            pattern = list(formatImmedate32)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_REGISTER8:
            pattern = list(formatRegister8)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_REGISTER16:
            pattern = list(formatRegister16)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_REGISTER32:
            pattern = list(formatRegister32)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_ADDS:
            pattern = list(formatAdds)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_AND32:
            pattern = list(formatAnd32)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_ONLY_IMM8:
            pattern = list(formatOnlyImm8)
            applyPar(pattern, "o", fmt[1])
        elif typ == FORMAT_BITS_R8:
            pattern = list(formatBitR8)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "b", fmt[3])
        elif typ == FORMAT_BITS_R32:
            pattern = list(formatBitR32)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
            applyPar(pattern, "b", fmt[4])
        elif typ == FORMAT_BITS_ABS:
            pattern = list(formatBitAbs)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
            applyPar(pattern, "b", fmt[4])
        elif typ == FORMAT_BITS_RR32:
            pattern = list(formatBitRR32)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
        elif typ == FORMAT_BITS_RABS:
            pattern = list(formatBitRAbs)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
        elif typ == FORMAT_ONLY_IMM16:
            pattern = list(formatOnlyImm16)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
        elif typ == FORMAT_ONLY_RD:
            pattern = list(formatOnlyRd)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
        elif typ == FORMAT_NOP:
            pattern = list(formatNop)
            applyPar(pattern, "o", fmt[1])
            applyPar(pattern, "p", fmt[3])
        else:
            print("????")
            
        #print(str((fmt[2], ''.join(pattern)))+", ")
        convInst.append((fmt[2], ''.join(pattern)))
            
"""

TYPE_IMM  = "imm" # size, letter
TYPE_REG    = "reg" # size, letter
TYPE_CONST = "const" # const
TYPE_ABS  = "abs" # size, access size, letter
TYPE_REGCCR = "regCCR" #
TYPE_ATABS = "atmem" # size, access size, letter
TYPE_ATREG = "atreg" # size, access size, offset / '+' / '-' / None, letter
TYPE_OFFSET = "offset" # size, letter
TYPE_PCOFFSET = "pcoffset" # size, letter

convInst = [
('ADD.B #xx:8,Rd', '1000ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('ADD.B Rs,Rd', '00001000ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('ADD.W #xx:16,Rd', '011110010001ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('ADD.W Rs,Rd', '00001001ssssdddd', [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('ADD.L #xx:32,ERd', '0111101000010dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('ADD.L ERs,ERd', '000010101sss0ddd', [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('ADDS #1,ERd', '0000101100000ddd', [(TYPE_CONST, 1), (TYPE_REG, 32, 'd')]),
('ADDS #2,ERd', '0000101110000ddd', [(TYPE_CONST, 2), (TYPE_REG, 32, 'd')]),
('ADDS #4,ERd', '0000101110010ddd', [(TYPE_CONST, 4), (TYPE_REG, 32, 'd')]),
('ADDX #xx:8,Rd', '1001ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('ADDX Rs,Rd', '00001110ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('AND.B #xx:8,Rd', '1110ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('AND.B Rs,Rd', '00010110ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('AND.W #xx:16,Rd', '011110010110ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('AND.W Rs,Rd', '01100110ssssdddd' , [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('AND.L #xx:32,ERd', '0111101001100dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('AND.L ERs,ERd', '0000000111110000011001100sss0ddd' , [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('ANDC #xx:8,CCR', '00000110iiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REGCCR)]),
('BAND #xx:3,Rd', '011101100iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BAND #xx:3,@ERd', '011111000ddd0000011101100iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BAND #xx:3,@aa:8', '01111110aaaaaaaa011101100iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BT o:8', '01000000oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BT o:16', '0101100000000000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BF o:8', '01000001oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BF o:16', '0101100000010000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BHI o:8', '01000010oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BHI o:16', '0101100000100000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BLS o:8', '01000011oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BLS o:16', '0101100000110000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BHS o:8', '01000100oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BHS o:16', '0101100001000000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BLO o:8', '01000101oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BLO o:16', '0101100001010000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BNE o:8', '01000110oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BNE o:16', '0101100001100000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BEQ o:8', '01000111oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BEQ o:16', '0101100001110000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BVC o:8', '01001000oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BVC o:16', '0101100010000000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BVS o:8', '01001001oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BVS o:16', '0101100010010000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BPL o:8', '01001010oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BPL o:16', '0101100010100000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BMI o:8', '01001011oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BMI o:16', '0101100010110000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BGE o:8', '01001100oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BGE o:16', '0101100011000000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BLT o:8', '01001101oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BLT o:16', '0101100011010000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BGT o:8', '01001110oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BGT o:16', '0101100011100000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BLE o:8', '01001111oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BLE o:16', '0101100011110000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BCLR #xx:3,Rd', '011100100iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BCLR #xx:3,@ERd', '011111010ddd0000011100100iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BCLR #xx:3,@aa:8', '01111111aaaaaaaa011100100iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BCLR Rs,Rd', '01100010ssssdddd',  [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('BCLR Rn,@ERd', '011111010ddd000001100010nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ATREG, 32, 8, None,'d')]),
('BCLR Rn,@aa:8', '01111111aaaaaaaa01100010nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ABS, 8, 8, 'd')]),
('BIAND #xx:3,Rd', '011101101iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BIAND #xx:3,@ERd', '011111000ddd0000011101101iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BIAND #xx:3,@aa:8', '01111110aaaaaaaa011101101iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BILD #xx:3,Rd', '011101111iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BILD #xx:3,@ERd', '011111000ddd0000011101111iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BILD #xx:3,@aa:8', '01111110aaaaaaaa011101111iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BIOR #xx:3,Rd', '011101001iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BIOR #xx:3,@ERd', '011111000ddd0000011101001iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BIOR #xx:3,@aa:8', '01111110aaaaaaaa011101001iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BIST #xx:3,Rd', '011001111iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BIST #xx:3,@ERd', '011111010ddd0000011001111iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BIST #xx:3,@aa:8', '01111111aaaaaaaa011001111iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BIXOR #xx:3,Rd', '011101011iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BIXOR #xx:3,@ERd', '011111000ddd0000011101011iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BIXOR #xx:3,@aa:8', '01111110aaaaaaaa011101011iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BLD #xx:3,Rd', '011101110iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BLD #xx:3,@ERd', '011111000ddd0000011101110iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BLD #xx:3,@aa:8', '01111110aaaaaaaa011101110iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BNOT #xx:3,Rd', '011100010iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BNOT #xx:3,@ERd', '011111010ddd0000011100010iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BNOT #xx:3,@aa:8', '01111111aaaaaaaa011100010iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BNOT Rs,Rd', '01100001ssssdddd',  [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('BNOT Rn,@ERd', '011111010ddd000001100001nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BNOT Rn,@aa:8', '01111111aaaaaaaa01100001nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ABS, 8, 8, 'd')]),
('BOR #xx:3,Rd', '011101000iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BOR #xx:3,@ERd', '011111000ddd0000011101000iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BIOR #xx:3,@aa:8', '01111110aaaaaaaa011101000iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BSET #xx:3,Rd', '011100000iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BSET #xx:3,@ERd', '011111010ddd0000011100000iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BSET #xx:3,@aa:8', '01111111aaaaaaaa011100000iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BSET Rs,Rd', '01100000ssssdddd',  [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('BSET Rn,@ERd', '011111010ddd000001100000nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BSET Rn,@aa:8', '01111111aaaaaaaa01100000nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ABS, 8, 8, 'd')]),
('BSR o:8', '01010101oooooooo', [(TYPE_PCOFFSET, 8, 'o')]),
('BSR o:16', '0101110000000000oooooooooooooooo', [(TYPE_PCOFFSET, 16, 'o')]),
('BST #xx:3,Rd', '011001110iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BST #xx:3,@ERd', '011111010ddd0000011001110iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BST #xx:3,@aa:8', '01111111aaaaaaaa011001110iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BTST #xx:3,Rd', '011100110iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BTST #xx:3,@ERd', '011111000ddd0000011100110iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BTST #xx:3,@aa:8', '01111110aaaaaaaa011100110iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('BTST Rs,Rd', '01100011ssssdddd',  [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('BTST Rn,@ERd', '011111000ddd000001100011nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BTST Rn,@aa:8', '01111110aaaaaaaa01100011nnnn0000',  [(TYPE_REG, 8, 'n'), (TYPE_ABS, 8, 8, 'd')]),
('BXOR #xx:3,Rd', '011101010iiidddd', [(TYPE_IMM, 3, 'i'), (TYPE_REG, 8, 'd')]),
('BXOR #xx:3,@ERd', '011111000ddd0000011101010iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ATREG, 32, 8, None, 'd')]),
('BXOR #xx:3,@aa:8', '01111110aaaaaaaa011101010iii0000', [(TYPE_IMM, 3, 'i'), (TYPE_ABS, 8, 8, 'a')]),
('CMP.B #xx:8,Rd', '1010ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('CMP.B Rs,Rd', '00011100ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('CMP.W #xx:16,Rd', '011110010010ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('CMP.W Rs,Rd', '00011101ssssdddd' , [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('CMP.L #xx:32,ERd', '0111101000100dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('CMP.L ERs,ERd', '000111111sss0ddd', [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('DAA Rd', '000011110000dddd', [(TYPE_REG, 8, 'd')]),
('DAS Rd', '000111110000dddd', [(TYPE_REG, 8, 'd')]),
('DEC.B Rd', '000110100000dddd', [(TYPE_REG, 8, 'd')]),
('DEC.W #1,Rd', '000110110101dddd', [(TYPE_CONST, 1), (TYPE_REG, 16, 'd')]),
('DEC.W #2,Rd', '000110111101dddd', [(TYPE_CONST, 2), (TYPE_REG, 16, 'd')]),
('DEC.L #1,ERd', '0001101101110ddd', [(TYPE_CONST, 1), (TYPE_REG, 32, 'd')]),
('DEC.L #2,ERd', '0001101111110ddd', [(TYPE_CONST, 2), (TYPE_REG, 32, 'd')]),
('DIVXS.B Rs,Rd',  '000000011101000001010001ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 16, 'd')]),
('DIVXS.W Rs,ERd', '000000011101000001010011ssss0ddd', [(TYPE_REG, 16, 's'), (TYPE_REG, 32, 'd')]),
('DIVXU.B Rs,ERd', '01010001ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 16, 'd')]),
('DIVXU.W Rs,ERd', '01010011ssss0ddd', [(TYPE_REG, 16, 's'), (TYPE_REG, 32, 'd')]),
('EEPMOV.B', '01111011010111000101100110001111', []),
('EEPMOV.W', '01111011110101000101100110001111', []),
('EXTS.W Rd', '000101111101dddd', [(TYPE_REG, 16, 'd')]),
('EXTS.L ERd', '0001011111110ddd', [(TYPE_REG, 32, 'd')]),
('EXTU.W Rd', '000101110101dddd', [(TYPE_REG, 16, 'd')]),
('EXTU.L ERd', '0001011101110ddd', [(TYPE_REG, 32, 'd')]),
('INC.B Rd', '000010100000dddd', [(TYPE_REG, 8, 'd')]),
('INC.W #1,Rd', '000010110101dddd', [(TYPE_CONST, 1), (TYPE_REG, 16, 'd')]),
('INC.W #2,Rd', '000010111101dddd', [(TYPE_CONST, 2), (TYPE_REG, 16, 'd')]),
('INC.L #1,ERd', '0000101101110ddd', [(TYPE_CONST, 1), (TYPE_REG, 32, 'd')]),
('INC.L #2,ERd', '0000101111110ddd', [(TYPE_CONST, 2), (TYPE_REG, 32, 'd')]),
('JMP @ERn',   '010110010nnn0000', [(TYPE_ATREG, 32, 0, None, 'n')]),
('JMP @aa:24', '01011010aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_ABS, 24, 0, 'a')]),
('JMP @@aa:8', '01011011aaaaaaaa', [(TYPE_ATABS, 8, 16, 'a')]),
('JSR @ERn',   '010111010nnn0000', [(TYPE_ATREG, 32, 0, None, 'n')]),
('JSR @aa:24', '01011110aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_ABS, 24, 0, 'a')]),
('JSR @@aa:8', '01011111aaaaaaaa', [(TYPE_ATABS, 8, 16, 'a')]),
('LDC #xx:8,CCR',  '00000111iiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REGCCR)]),
('LDC Rs,CCR',     '000000110000ssss', [(TYPE_REG, 8, 's'), (TYPE_REGCCR)]),
('LDC @ERs,CCR',          '0000000101000000011010010sss0000', [(TYPE_ATREG, 32, 16, None, 's'), (TYPE_REGCCR)]),
('LDC @(o:16,ERs),CCR',   '0000000101000000011011110sss0000oooooooooooooooo', [(TYPE_ATREG, 32, 16, (TYPE_OFFSET, 16, 'o'), 's'), (TYPE_REGCCR)]),
('LDC @(o:24,ERs),CCR',   '0000000101000000011110000sss0000011010110010000000000000oooooooooooooooooooooooo', [(TYPE_ATREG, 32, 16, (TYPE_OFFSET, 24, 'o'), 's'), (TYPE_REGCCR)]),
('LDC @ERs+,CCR',         '0000000101000000011011010sss0000', [(TYPE_ATREG, 32, 16, '+', 's'), (TYPE_REGCCR)]),
('LDC @aa:16,CCR',        '00000001010000000110101100000000aaaaaaaaaaaaaaaa', [(TYPE_ABS, 16, 16, 'a'), (TYPE_REGCCR)]),
('LDC @aa:24,CCR',        '0000000101000000011010110010000000000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_ABS, 24, 16, 'a'), (TYPE_REGCCR)]),
('MOV.B #xx:8,Rd',  '1111ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('MOV.B Rs,Rd',     '00001100ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('MOV.B @ERs,Rd',   '011010000sssdddd', [(TYPE_ATREG, 32, 8, None, 's'), (TYPE_REG, 8, 'd')]),
('MOV.B @(o:16,ERs),Rd',   '011011100sssddddoooooooooooooooo', [(TYPE_ATREG, 32, 8, (TYPE_OFFSET, 16, 'o'), 's'), (TYPE_REG, 8, 'd')]),
('MOV.B @(o:24,ERs),Rd',   '011110000sss0000011010100010dddd00000000oooooooooooooooooooooooo', [(TYPE_ATREG, 32, 8, (TYPE_OFFSET, 24, 'o'), 's'), (TYPE_REG, 8, 'd')]),
('MOV.B @ERs+,Rd',     '011011000sssdddd', [(TYPE_ATREG, 32, 8, '+', 's'), (TYPE_REG, 8, 'd')]),
('MOV.B @aa:8,Rd',  '0010ddddaaaaaaaa', [(TYPE_ABS, 8, 8, 'a'), (TYPE_REG, 8, 'd')]),
('MOV.B @aa:16,Rd',  '011010100000ddddaaaaaaaaaaaaaaaa', [(TYPE_ABS, 16, 8, 'a'), (TYPE_REG, 8, 'd')]),
('MOV.B @aa:24,Rd',  '011010100010dddd00000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_ABS, 24, 8, 'a'), (TYPE_REG, 8, 'd')]),
('MOV.B Rs,@ERd',  '011010001dddssss', [(TYPE_REG, 8, 's'), (TYPE_ATREG, 32, 8, None, 'd')]),
('MOV.B Rs,@(o:16,ERd)',  '011011101dddssssoooooooooooooooo', [(TYPE_REG, 8, 's'), (TYPE_ATREG, 32, 8, (TYPE_OFFSET, 16, 'o'), 'd')]),
('MOV.B Rs,@(o:24,ERd)',  '011110000ddd0000011010101010ssss00000000oooooooooooooooooooooooo', [(TYPE_REG, 8, 's'), (TYPE_ATREG, 32, 8, (TYPE_OFFSET, 24, 'o'), 'd')]),
('MOV.B Rs,@–ERd',  '011011001dddssss', [(TYPE_REG, 8, 's'), (TYPE_ATREG, 32, 8, '-', 'd')]),
('MOV.B Rs,@aa:8',  '0011ssssaaaaaaaa', [(TYPE_REG, 8, 's'), (TYPE_ABS, 8, 8, 'a')]),
('MOV.B Rs,@aa:16',  '011010101000ssssaaaaaaaaaaaaaaaa', [(TYPE_REG, 8, 's'), (TYPE_ABS, 16, 8, 'a')]),
('MOV.B Rs,@aa:24',  '011010101010ssss00000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_REG, 8, 's'), (TYPE_ABS, 24, 8, 'a')]),
('MOV.W #xx:16,Rd',  '011110010000ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('MOV.W Rs,Rd',      '00001101ssssdddd' , [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('MOV.W @ERs,Rd',    '011010010sssdddd', [(TYPE_ATREG, 32, 16, None, 's'), (TYPE_REG, 16, 'd')]),
('MOV.W @(o:16,ERs),Rd',    '011011110sssddddoooooooooooooooo', [(TYPE_ATREG, 32, 16, (TYPE_OFFSET, 16, 'o'), 's'), (TYPE_REG, 16, 'd')]),
('MOV.W @(o:24,ERs),Rd',    '011110000sss0000011010110010dddd00000000oooooooooooooooooooooooo', [(TYPE_ATREG, 32, 16, (TYPE_OFFSET, 24, 'o'), 's'), (TYPE_REG, 16, 'd')]),
('MOV.W @ERs+,Rd',    '011011010sssdddd', [(TYPE_ATREG, 32, 16, '+', 's'), (TYPE_REG, 16, 'd')]),
('MOV.W @aa:16,Rd',   '011010110000ddddaaaaaaaaaaaaaaaa', [(TYPE_ABS, 16, 16, 'a'), (TYPE_REG, 16, 'd')]),
('MOV.W @aa:24,Rd',   '011010110010dddd00000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_ABS, 24, 16, 'a'), (TYPE_REG, 16, 'd')]),
('MOV.W Rs,@ERd',    '011010011dddssss', [(TYPE_REG, 16, 's'), (TYPE_ATREG, 32, 16, None, 'd')]),
('MOV.W Rs,@(o:16,ERd)',  '011011111dddssssoooooooooooooooo', [(TYPE_REG, 16, 's'), (TYPE_ATREG, 32, 16, (TYPE_OFFSET, 16, 'o'), 'd')]),
('MOV.W Rs,@(o:24,ERd)',  '011110001ddd0000011010111010ssss00000000oooooooooooooooooooooooo', [(TYPE_REG, 16, 's'), (TYPE_ATREG, 32, 16, (TYPE_OFFSET, 24, 'o'), 'd')]),
('MOV.W Rs,@–ERd',    '011011011dddssss', [(TYPE_REG, 16, 's'), (TYPE_ATREG, 32, 16, '-', 'd')]),
('MOV.W Rs,@aa:16',    '011010111000ssssaaaaaaaaaaaaaaaa', [(TYPE_REG, 16, 's'), (TYPE_ABS, 16, 16, 'a')]),
('MOV.W Rs,@aa:24',    '011010111010ssss00000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_REG, 16, 's'), (TYPE_ABS, 24, 16, 'a')]),
('MOV.L #xx:32,Rd',    '0111101000000dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('MOV.L ERs,ERd',      '000011111sss0ddd', [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('MOV.L @ERs,ERd',         '0000000100000000011010010sss0ddd', [(TYPE_ATREG, 32, 32, None, 's'), (TYPE_REG, 32, 'd')]),
('MOV.L @(o:16,ERs),ERd',  '0000000100000000011011110sss0dddoooooooooooooooo', [(TYPE_ATREG, 32, 32, (TYPE_OFFSET, 16, 'o'), 's'), (TYPE_REG, 32, 'd')]),
('MOV.L @(o:24,ERs),ERd',  '0000000100000000011110000sss00000110101100100ddd00000000oooooooooooooooooooooooo', [(TYPE_ATREG, 32, 32, (TYPE_OFFSET, 24, 'o'), 's'), (TYPE_REG, 32, 'd')]),
('MOV.L @ERs+,ERd',        '0000000100000000011011010sss0ddd', [(TYPE_ATREG, 32, 32, '+', 's'), (TYPE_REG, 32, 'd')]),
('MOV.L @aa:16,ERd',       '00000001000000000110101100000dddaaaaaaaaaaaaaaaa', [(TYPE_ABS, 16, 32, 'a'), (TYPE_REG, 32, 'd')]),
('MOV.L @aa:24,ERd',       '00000001000000000110101100100ddd00000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_ABS, 24, 32, 'a'), (TYPE_REG, 32, 'd')]),
('MOV.L ERs,@ERd',         '0000000100000000011010011ddd0sss', [(TYPE_REG, 32, 's'), (TYPE_ATREG, 32, 32, None, 'd')]),
('MOV.L ERs,@(o:16,ERd)',  '0000000100000000011011111ddd0sssoooooooooooooooo', [(TYPE_REG, 32, 's'), (TYPE_ATREG, 32, 32, (TYPE_OFFSET, 16, 'o'), 'd')]),
('MOV.L ERs,@(o:24,ERd)',  '0000000100000000011110000ddd00000110101110100sss00000000oooooooooooooooooooooooo', [(TYPE_REG, 32, 's'), (TYPE_ATREG, 32, 32, (TYPE_OFFSET, 24, 'o'), 'd')]),
('MOV.L ERs,@–ERd',        '0000000100000000011011011ddd0sss', [(TYPE_REG, 32, 's'), (TYPE_ATREG, 32, 32, '-', 'd')]),
('MOV.L ERs,@aa:16',       '00000001000000000110101110000sssaaaaaaaaaaaaaaaa', [(TYPE_REG, 32, 's'), (TYPE_ABS, 16, 32, 'a')]),
('MOV.L ERs,@aa:24',       '00000001000000000110101110100sss00000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_REG, 32, 's'), (TYPE_ABS, 24, 32, 'a')]),
('MOVFPE @aa:16,Rd',  '011010100100ddddaaaaaaaaaaaaaaaa', [(TYPE_ABS, 16, 8, 'a'), (TYPE_REG, 8, 'd')]),
('MOVTPE Rs,@aa:16',  '011010101100ssssaaaaaaaaaaaaaaaa', [(TYPE_REG, 8, 's'), (TYPE_ABS, 16, 8, 'a')]),
('MULXS.B Rs,Rd',  '000000011100000001010000ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 16, 'd')]),
('MULXS.W Rs,ERd', '000000011100000001010010ssss0ddd', [(TYPE_REG, 16, 's'), (TYPE_REG, 32, 'd')]),
('MULXU.B Rs,Rd', '01010000ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 16, 'd')]),
('MULXU.W Rs,ERd', '01010010ssss0ddd', [(TYPE_REG, 16, 's'), (TYPE_REG, 32, 'd')]),
('NEG.B Rd', '000101111000dddd', [(TYPE_REG, 8, 'd')]),
('NEG.W Rd', '000101111001dddd', [(TYPE_REG, 16, 'd')]),
('NEG.L ERd', '0001011110110ddd', [(TYPE_REG, 32, 'd')]),
('NOP', '0000000000000000', []),
('NOT.B Rd', '000101110000dddd', [(TYPE_REG, 8, 'd')]),
('NOT.W Rd', '000101110001dddd', [(TYPE_REG, 16, 'd')]),
('NOT.L ERd', '0001011100110ddd', [(TYPE_REG, 32, 'd')]),
('OR.B #xx:8,Rd', '1100ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('OR.B Rs,Rd', '00010100ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('OR.W #xx:16,Rd', '011110010100ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('OR.W Rs,Rd', '01100100ssssdddd' , [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('OR.L #xx:32,ERd', '0111101001000dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('OR.L ERs,ERd', '0000000111110000011001000sss0ddd', [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('ORC #xx:8,CCR', '00000100iiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REGCCR)]),
('ROTL.B Rd', '000100101000dddd', [(TYPE_REG, 8, 'd')]),
('ROTL.W Rd', '000100101001dddd', [(TYPE_REG, 16, 'd')]),
('ROTL.L ERd', '0001001010110ddd', [(TYPE_REG, 32, 'd')]),
('ROTR.B Rd', '000100111000dddd', [(TYPE_REG, 8, 'd')]),
('ROTR.W Rd', '000100111001dddd', [(TYPE_REG, 16, 'd')]),
('ROTR.L ERd', '0001001110110ddd', [(TYPE_REG, 32, 'd')]),
('ROTXL.B Rd', '000100100000dddd', [(TYPE_REG, 8, 'd')]),
('ROTXL.W Rd', '000100100001dddd', [(TYPE_REG, 16, 'd')]),
('ROTXL.L ERd', '0001001000110ddd', [(TYPE_REG, 32, 'd')]),
('ROTXR.B Rd', '000100110000dddd', [(TYPE_REG, 8, 'd')]),
('ROTXR.W Rd', '000100110001dddd', [(TYPE_REG, 16, 'd')]),
('ROTXR.L ERd', '0001001100110ddd', [(TYPE_REG, 32, 'd')]),
('RTE', '0101011001110000', []),
('RTS', '0101010001110000', []),
('SHAL.B Rd', '000100001000dddd', [(TYPE_REG, 8, 'd')]),
('SHAL.W Rd', '000100001001dddd', [(TYPE_REG, 16, 'd')]),
('SHAL.L ERd', '0001000010110ddd', [(TYPE_REG, 32, 'd')]),
('SHAR.B Rd', '000100011000dddd', [(TYPE_REG, 8, 'd')]),
('SHAR.W Rd', '000100011001dddd', [(TYPE_REG, 16, 'd')]),
('SHAR.L ERd', '0001000110110ddd', [(TYPE_REG, 32, 'd')]),
('SHLL.B Rd', '000100000000dddd', [(TYPE_REG, 8, 'd')]),
('SHLL.W Rd', '000100000001dddd', [(TYPE_REG, 16, 'd')]),
('SHLL.L ERd', '0001000000110ddd', [(TYPE_REG, 32, 'd')]),
('SHLR.B Rd', '000100010000dddd', [(TYPE_REG, 8, 'd')]),
('SHLR.W Rd', '000100010001dddd', [(TYPE_REG, 16, 'd')]),
('SHLR.L ERd', '0001000100110ddd', [(TYPE_REG, 32, 'd')]),
('STC CCR,Rd',   '000000100000dddd', [(TYPE_REGCCR), (TYPE_REG, 8, 'd')]),
('STC CCR,@ERd',        '0000000101000000011010011ddd0000', [(TYPE_REGCCR), (TYPE_ATREG, 32, 16, None, 'd')]),
('STC CCR,@(o:16,ERd)', '0000000101000000011011111ddd0000oooooooooooooooo', [(TYPE_REGCCR), (TYPE_ATREG, 32, 16, (TYPE_OFFSET, 16, 'o'), 'd')]),
('STC CCR,@(o:24,ERd)', '0000000101000000011110000ddd0000011010111010000000000000oooooooooooooooooooooooo', [(TYPE_REGCCR), (TYPE_ATREG, 32, 16, (TYPE_OFFSET, 24, 'o'), 'd')]),
('STC CCR,@–ERd',       '0000000101000000011011011ddd0000', [(TYPE_REGCCR), (TYPE_ATREG, 32, 16, '-', 'd')]),
('STC CCR,@aa:16',       '00000001010000000110101110000000aaaaaaaaaaaaaaaa', [(TYPE_REGCCR), (TYPE_ABS, 16, 16, 'a')]),
('STC CCR,@aa:24',      '0000000101000000011010111010000000000000aaaaaaaaaaaaaaaaaaaaaaaa', [(TYPE_REGCCR), (TYPE_ABS, 24, 16, 'a')]),
('SLEEP', '0000000110000000', []),
('SUB.B Rs,Rd', '00011000ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('SUB.W #xx:16,Rd', '011110010011ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('SUB.W Rs,Rd', '00011001ssssdddd' , [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('SUB.L #xx:32,ERd', '0111101000110dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('SUB.L ERs,ERd', '000110101sss0ddd', [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('SUBS #1,ERd', '0001101100000ddd', [(TYPE_CONST, 1), (TYPE_REG, 32, 'd')]),
('SUBS #2,ERd', '0001101110000ddd', [(TYPE_CONST, 1), (TYPE_REG, 32, 'd')]),
('SUBS #4,ERd', '0001101110010ddd', [(TYPE_CONST, 1), (TYPE_REG, 32, 'd')]),
('SUBX #xx:8,Rd', '1011ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('SUBX Rs,Rd', '00011110ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('TRAPA #x:2', '0101011100ii0000', [(TYPE_IMM, 2, 'i')]),
('XOR.B #xx:8,Rd', '1101ddddiiiiiiii', [(TYPE_IMM, 8, 'i'), (TYPE_REG, 8, 'd')]),
('XOR.B Rs,Rd', '00010101ssssdddd', [(TYPE_REG, 8, 's'), (TYPE_REG, 8, 'd')]),
('XOR.W #xx:16,Rd', '011110010101ddddiiiiiiiiiiiiiiii', [(TYPE_IMM, 16, 'i'), (TYPE_REG, 16, 'd')]),
('XOR.W Rs,Rd', '01100101ssssdddd' , [(TYPE_REG, 16, 's'), (TYPE_REG, 16, 'd')]),
('XOR.L #xx:32,ERd', '0111101001010dddiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii', [(TYPE_IMM, 32, 'i'), (TYPE_REG, 32, 'd')]),
('XOR.L ERs,ERd', '0000000111110000011001010sss0ddd', [(TYPE_REG, 32, 's'), (TYPE_REG, 32, 'd')]),
('XORC #xx:8,CCR', '00000101iiiiiiii' , [(TYPE_IMM, 8, 'i'), (TYPE_REGCCR)]),
]


def tryToParse2(data, inst):
    match = {}
    bi = 0
    if len(data) < len(inst[1])//8: return None, 0
    for p in inst[1]:
        bit = (data[bi//8]>>(7-(bi%8)))&1
        if p == "1":
            if bit == 0:
                return None, 0
        elif p == "0": 
            if bit == 1:
                return None, 0
        else:
            if p in match:
                match[p] = (match[p]<<1) | bit
            else:
                match[p] = bit
        bi = bi + 1
    return (match, len(inst[1])//8)
    
def applyParsed(match, inst):
    r = inst[0]
    if "s" in match:
        r = r.replace("s", str(match["s"]))
    if "d" in match:
        r = r.replace("d", str(match["d"]))
    if "n" in match:
        r = r.replace("n", str(match["n"]))
    if "i" in match:
        r = r.replace("xx", str(match["i"]))
    if "a" in match:
        r = r.replace("aa", str(match["a"]))
    return r


def tryToParse(data):
    for inst in convInst:
        m, size = tryToParse2(data, inst)
        if m != None:
            return (inst, size, m)
    return (None, None, None)
```

`binary-h8300/h8300lift.py`:

```py
from binaryninja import *
from .h8300dis import *

def R(il, arg):
    if arg[0] == TYPE_IMM:
        return il.const(arg[1], arg[2])
    elif arg[0] == TYPE_CONST:
        return il.const(4, arg[1])
    elif arg[0] == TYPE_REGCCR:
        return il.reg(1, "ccr")
    elif arg[0] == TYPE_ABS:
        return il.const(arg[1], arg[3])
    elif arg[0] == TYPE_ATABS:
        return il.load(arg[2], il.const(arg[1], arg[3]))
    elif arg[0] == TYPE_ATREG:
        reg = il.reg(arg[1], arg[4])
        if arg[3] == "@":
            return il.load(arg[2], reg)
        elif arg[3] == "+":
            il.append(il.set_reg(arg[1], arg[4], il.add(arg[1], reg, il.const(arg[1], arg[1]))))
            return il.load(arg[2], il.sub(arg[1], reg, il.const(arg[1], arg[1])) )
        elif arg[3] == "-":
            il.append(il.set_reg(arg[1], arg[4], il.sub(arg[1], reg, il.const(arg[1], arg[1]))))
            return il.load(arg[2], reg)
        elif arg[3] == "offset":
            offset = il.const(3, arg[5])
            return il.load(arg[2], il.add(3, reg, offset))
        else:
            return il.undefined()
            
    elif arg[0] == TYPE_REG:
        return il.reg(arg[1], arg[2])
    elif arg[0] == TYPE_PCOFFSET:
        return il.const(3, arg[2])
        

def W(il, arg, value):
    if arg[0] == TYPE_IMM:
        il.append(il.undefined())
    elif arg[0] == TYPE_CONST:
        il.append(il.undefined())
    elif arg[0] == TYPE_REGCCR:
        il.append(il.set_reg(1, "ccr", value))
    elif arg[0] == TYPE_ABS:
        il.append(il.store(arg[2], R(il, arg), value))
    elif arg[0] == TYPE_ATABS:
        il.append(il.undefined())
    elif arg[0] == TYPE_ATREG:
        reg = il.reg(arg[1], arg[4])
        if arg[3] == "@":
            il.append(il.store(arg[2], reg, value))
        elif arg[3] == "+":
            il.append(il.store(arg[2], reg, value))
            il.append(il.set_reg(arg[1], arg[4], il.add(arg[1], reg, il.const(arg[1], arg[1]))))
        elif arg[3] == "-":
            il.append(il.set_reg(arg[1], arg[4], il.sub(arg[1], reg, il.const(arg[1], arg[1]))))
            il.append(il.store(arg[2], reg, value))
        elif arg[3] == "offset":
            offset = il.const(3, arg[5])
            il.append(il.store(arg[2], il.add(3, reg, offset), value))
        else:
            il.append(il.undefined())
    elif arg[0] == TYPE_REG:
        il.append(il.set_reg(arg[1], arg[2], value))
    elif arg[0] == TYPE_PCOFFSET:
        il.append(il.undefined())
        
        
#def inst_ANDB(self, data, addr, il, inst, size, match):
#    il.append(self.parToILWrite(il, inst[2][1], match, il.and_expr(1, self.parToILRead(il, inst[2][1], match), self.parToILRead(il, inst[2][0], match))))


def CCJ(il, args, cond):
    arg = args[0]
    if arg[0] != TYPE_PCOFFSET:
        return il.unimplemented()
        
    t = il.get_label_for_address(Architecture['H8/300'], arg[2])
    f = il.get_label_for_address(Architecture['H8/300'], arg[3])
    
    condition = il.unimplemented()
    
    if cond == "HI":
        condition = il.not_expr(0, il.or_expr(0, il.flag('c'), il.flag('z')))
    elif cond == "LS":
        condition = il.or_expr(0, il.flag('c'), il.flag('z'))
    elif cond == "HS":
        condition = il.not_expr(0, il.flag('c'))
    elif cond == "LO":
        condition = il.flag('c')
    elif cond == "NE":
        condition = il.not_expr(0, il.flag('z'))
    elif cond == "EQ":
        condition = il.flag('z')
    elif cond == "VC":
        condition = il.not_expr(0, il.flag('v'))
    elif cond == "VS":
        condition = il.flag('v')
    elif cond == "PL":
        condition = il.not_expr(0, il.flag('n'))
    elif cond == "MI":
        condition = il.flag('n')
    elif cond == "GE":
        condition = il.not_expr(0, il.xor_expr(0, il.flag('n'), il.flag('v')))
    elif cond == "LT":
        condition = il.xor_expr(0, il.flag('n'), il.flag('v'))
    elif cond == "GT":
        condition = il.not_expr(0, il.or_expr(0, il.flag('z'), il.xor_expr(0, il.flag('n'), il.flag('v'))))
    elif cond == "LE":
        condition = il.or_expr(0, il.flag('z'), il.xor_expr(0, il.flag('n'), il.flag('v')))
    
    if t and f:
        il.append(il.if_expr(condition, t, f))
        return
        

    if t:
        tmp = il.goto(t)
    else:
        tmp = il.jump(il.const_pointer(3, arg[2]))
        
    t = LowLevelILLabel()
    f = LowLevelILLabel()
        
    il.append(il.if_expr(condition, t, f))
    il.mark_label(t)
    il.append(tmp)
    il.mark_label(f)
    
def BOP(il, args, op):
    c = il.flag('c')
    tb = il.test_bit(4, R(il, args[1]), R(il, args[0]))
    res = c

    if op == "OR":
        res = il.or_expr(0, c, tb)
    elif op == "IOR":
        res = il.or_expr(0, c, il.not_expr(0,tb))
    elif op == "LD":
        res = tb
    elif op == "ILD":
        res = il.not_expr(0,tb)
    elif op == "IXOR":
        res = il.xor_expr(0, c, il.not_expr(0, tb))
    elif op == "XOR":
        res = il.xor_expr(0, c, tb)
    elif op == "IAND":
        res = il.and_expr(0, c, il.not_expr(0, tb))
    elif op == "AND":
        res = il.and_expr(0, c, tb)
    return il.set_flag('c', res)
    
def BSET(il, args, op):
    
    mask = il.shift_left(4, il.const(4, 1), R(il, args[0]))
    val = R(il, args[1])
    valMask = il.and_expr(4, val, il.not_expr(4, mask))
    valBit = il.and_expr(4, val, mask)
    carry = il.zero_extend(4, il.flag('c'))
    carryL = il.shift_left(4, il.const(4, 1), carry)
    carryI = il.zero_extend(4, il.not_expr(0, il.flag('c')))
    carryIL = il.shift_left(4, il.const(4, 1), carryI)
    
    res = val
    
    if op == "CLR":
        res = valMask
    elif op == "SET":
        res = il.or_expr(4, val, mask)
    elif op == "ST":
        res = il.or_expr(4, valMask, carryL)
    elif op == "IST":
        res = il.or_expr(4, valMask, carryIL)
    elif op == "NOT":
        res = il.or_expr(4, valMask, il.and_expr(4, il.not_expr(4, valBit), mask))
    
    return W(il, args[1], res)
    
InstructionIL = {
    "ADD.B": lambda il, args: W(il, args[1], il.add(1, R(il, args[1]), R(il, args[0]), flags='*')),
    "ADD.W": lambda il, args: W(il, args[1], il.add(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "ADD.L": lambda il, args: W(il, args[1], il.add(4, R(il, args[1]), R(il, args[0]), flags='*')),
    "ADDS": lambda il, args: W(il, args[1], il.add(4, R(il, args[1]), R(il, args[0]))),
    "ADDX": lambda il, args: W(il, args[1], il.add_carry(1, R(il, args[1]), R(il, args[0]), il.flag('c'), flags='*')),
    "AND.B": lambda il, args: W(il, args[1], il.and_expr(1, R(il, args[1]), R(il, args[0]), flags='*')),
    "AND.W": lambda il, args: W(il, args[1], il.and_expr(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "AND.L": lambda il, args: W(il, args[1], il.and_expr(4, R(il, args[1]), R(il, args[0]), flags='*')),
    # ANDC
    "BIAND": lambda il, args: BOP(il, args, 'AND'),
    "BT":   lambda il, args: il.jump(il.const_pointer(3, args[0][2])),
    "BF":   lambda il, args: il.nop(),
    "BHI":   lambda il, args: CCJ(il, args, 'HI'),
    "BLS":   lambda il, args: CCJ(il, args, 'LS'),
    "BHS":   lambda il, args: CCJ(il, args, 'HS'),
    "BLO":   lambda il, args: CCJ(il, args, 'LO'),
    "BNE":   lambda il, args: CCJ(il, args, 'NE'),
    "BEQ":   lambda il, args: CCJ(il, args, 'EQ'),
    "BVC":   lambda il, args: CCJ(il, args, 'VC'),
    "BVS":   lambda il, args: CCJ(il, args, 'VS'),
    "BPL":   lambda il, args: CCJ(il, args, 'PL'),
    "BMI":   lambda il, args: CCJ(il, args, 'MI'),
    "BGE":   lambda il, args: CCJ(il, args, 'GE'),
    "BLT":   lambda il, args: CCJ(il, args, 'LT'),
    "BGT":   lambda il, args: CCJ(il, args, 'GT'),
    "BLE":   lambda il, args: CCJ(il, args, 'LE'),
    "BCLR": lambda il, args: BSET(il, args, 'CLR'),
    "BIAND":   lambda il, args: BOP(il, args, 'IAND'),
    "BILD":   lambda il, args: BOP(il, args, 'ILD'),
    "BIOR":   lambda il, args: BOP(il, args, 'IOR'),
    "BIST": lambda il, args: BSET(il, args, 'IST'),
    "BIXOR":   lambda il, args: BOP(il, args, 'IXOR'),
    "BLD":   lambda il, args: BOP(il, args, 'LD'),
    "BNOT": lambda il, args: BSET(il, args, 'NOT'),
    "BOR":   lambda il, args: BOP(il, args, 'OR'),
    "BSET":  lambda il, args: BSET(il, args, 'SET'),
    "BSR":   lambda il, args: il.call(R(il, args[0])),
    "BST": lambda il, args: BSET(il, args, 'ST'),
    "BTST": lambda il, args: il.set_flag('z', il.test_bit(4, R(il, args[1]), R(il, args[0]))),
    "BXOR":   lambda il, args: BOP(il, args, 'XOR'),
    "CMP.B": lambda il, args: il.sub(1, R(il, args[1]), R(il, args[0]), flags='*'),
    "CMP.W": lambda il, args: il.sub(2, R(il, args[1]), R(il, args[0]), flags='*'),
    "CMP.L": lambda il, args: il.sub(4, R(il, args[1]), R(il, args[0]), flags='*'),
    # DAA
    # DAS
    "DEC.B": lambda il, args:  W(il,  args[0], il.sub(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "DEC.W": lambda il, args:  W(il, args[1], il.sub(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "DEC.L": lambda il, args:  W(il, args[1], il.sub(4, R(il, args[1]), R(il, args[0]), flags='*')),
    "DIVXS.B": lambda il, args:  W(il, args[1], 
        il.or_expr(2, 
            il.shift_left(2,
                il.zero_extend(2, il.mod_signed(1, il.low_part(1, R(il, args[1])), R(il, args[0]))),
                il.const(2, 8)
            ),
            il.div_signed(1, il.low_part(1, R(il, args[1])), R(il, args[0]), flags='*')
        )
    ),
    "DIVXS.W": lambda il, args:  W(il, args[1], 
        il.or_expr(4, 
            il.shift_left(4,
                il.zero_extend(4, il.mod_signed(2, il.low_part(2, R(il, args[1])), R(il, args[0]))),
                il.const(4, 8)
            ),
            il.div_signed(2, il.low_part(2, R(il, args[1])), R(il, args[0]), flags='*')
        )
    ),
    "DIVXU.B": lambda il, args:  W(il, args[1], 
        il.or_expr(2, 
            il.shift_left(2,
                il.zero_extend(2, il.mod_unsigned(1, il.low_part(1, R(il, args[1])), R(il, args[0]))),
                il.const(2, 8)
            ),
            il.div_unsigned(1, il.low_part(1, R(il, args[1])), R(il, args[0]), flags='*')
        )
    ),
    "DIVXU.W": lambda il, args:  W(il, args[1], 
        il.or_expr(4, 
            il.shift_left(4,
                il.zero_extend(4, il.mod_unsigned(2, il.low_part(2, R(il, args[1])), R(il, args[0]))),
                il.const(4, 8)
            ),
            il.div_unsigned(2, il.low_part(2, R(il, args[1])), R(il, args[0]), flags='*')
        )
    ),
    # EEPMOV
    "EXTS.W": lambda il, args: W(il, args[0], il.sign_extend(2, il.low_part(1, R(il, args[0])))),
    "EXTS.L": lambda il, args: W(il, args[0], il.sign_extend(4, il.low_part(2, R(il, args[0])))),
    "EXTU.W": lambda il, args: W(il, args[0], il.zero_extend(2, il.low_part(1, R(il, args[0])))),
    "EXTU.L": lambda il, args: W(il, args[0], il.zero_extend(4, il.low_part(2, R(il, args[0])))),
    "INC.B": lambda il, args:  W(il,  args[0], il.add(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "INC.W": lambda il, args:  W(il, args[1], il.add(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "INC.L": lambda il, args:  W(il, args[1], il.add(4, R(il, args[1]), R(il, args[0]), flags='*')),
    "JMP":   lambda il, args: il.jump(R(il, args[0])),
    "JSR":   lambda il, args: il.call(R(il, args[0])),
    # LDC
    "MOV.B": lambda il, args: W(il, args[1], R(il, args[0])),
    "MOV.W": lambda il, args: W(il, args[1], R(il, args[0])),
    "MOV.L": lambda il, args: W(il, args[1], R(il, args[0])),
    # MOVFPE
    # MOVTPE
    "MULXS.B": lambda il, args:  W(il, args[1], il.mult(2, il.sign_extend(2, il.low_part(1, R(il, args[1]))), il.sign_extend(2, R(il, args[0])), flags='*')),
    "MULXS.W": lambda il, args:  W(il, args[1], il.mult(4, il.sign_extend(4, il.low_part(2, R(il, args[1]))), il.sign_extend(4, R(il, args[0])), flags='*')),
    "MULXU.B": lambda il, args:  W(il, args[1], il.mult(2, il.zero_extend(2, il.low_part(1, R(il, args[1]))), il.zero_extend(2, R(il, args[0])), flags='*')),
    "MULXU.W": lambda il, args:  W(il, args[1], il.mult(4, il.zero_extend(4, il.low_part(2, R(il, args[1]))), il.zero_extend(4, R(il, args[0])), flags='*')),
    "NEG.B": lambda il, args: W(il, args[0], il.neg_expr(1, R(il, args[0]), flags='*')),
    "NEG.W": lambda il, args: W(il, args[0], il.neg_expr(2, R(il, args[0]), flags='*')),
    "NEG.L": lambda il, args: W(il, args[0], il.neg_expr(4, R(il, args[0]), flags='*')),
    "NOP":   lambda il, args: il.nop(),
    "NOT.B": lambda il, args: W(il, args[0], il.not_expr(1, R(il, args[0]), flags='*')),
    "NOT.W": lambda il, args: W(il, args[0], il.not_expr(2, R(il, args[0]), flags='*')),
    "NOT.L": lambda il, args: W(il, args[0], il.not_expr(4, R(il, args[0]), flags='*')),
    "OR.B": lambda il, args: W(il, args[1], il.or_expr(1, R(il, args[1]), R(il, args[0]), flags='*')),
    "OR.W": lambda il, args: W(il, args[1], il.or_expr(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "OR.L": lambda il, args: W(il, args[1], il.or_expr(4, R(il, args[1]), R(il, args[0]), flags='*')),
    # ORC
    "ROTL.B": lambda il, args: W(il, args[0], il.rotate_left(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "ROTL.W": lambda il, args: W(il, args[0], il.rotate_left(2, R(il, args[0]), il.const(2, 1), flags='*')),
    "ROTL.L": lambda il, args: W(il, args[0], il.rotate_left(4, R(il, args[0]), il.const(4, 1), flags='*')),
    "ROTR.B": lambda il, args: W(il, args[0], il.rotate_right(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "ROTR.W": lambda il, args: W(il, args[0], il.rotate_right(2, R(il, args[0]), il.const(2, 1), flags='*')),
    "ROTR.L": lambda il, args: W(il, args[0], il.rotate_right(4, R(il, args[0]), il.const(4, 1), flags='*')),
    "ROTXL.B": lambda il, args: W(il, args[0], il.rotate_left_carry(1, R(il, args[0]), il.const(1, 1), il.flag('c'), flags='*')),
    "ROTXL.W": lambda il, args: W(il, args[0], il.rotate_left_carry(2, R(il, args[0]), il.const(2, 1), il.flag('c'),flags='*')),
    "ROTXL.L": lambda il, args: W(il, args[0], il.rotate_left_carry(4, R(il, args[0]), il.const(4, 1), il.flag('c'),flags='*')),
    "ROTXR.B": lambda il, args: W(il, args[0], il.rotate_right_carry(1, R(il, args[0]), il.const(1, 1), il.flag('c'),flags='*')),
    "ROTXR.W": lambda il, args: W(il, args[0], il.rotate_right_carry(2, R(il, args[0]), il.const(2, 1), il.flag('c'),flags='*')),
    "ROTXR.L": lambda il, args: W(il, args[0], il.rotate_right_carry(4, R(il, args[0]), il.const(4, 1), il.flag('c'),flags='*')),
    # RTE
    "RTS":  lambda il, args: il.ret(il.pop(4)),
    "SHAL.B": lambda il, args: W(il, args[0], il.shift_left(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "SHAL.W": lambda il, args: W(il, args[0], il.shift_left(2, R(il, args[0]), il.const(2, 1), flags='*')),
    "SHAL.L": lambda il, args: W(il, args[0], il.shift_left(4, R(il, args[0]), il.const(4, 1), flags='*')),
    "SHAR.B": lambda il, args: W(il, args[0], il.arith_shift_right(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "SHAR.W": lambda il, args: W(il, args[0], il.arith_shift_right(2, R(il, args[0]), il.const(2, 1), flags='*')),
    "SHAR.L": lambda il, args: W(il, args[0], il.arith_shift_right(4, R(il, args[0]), il.const(4, 1), flags='*')),
    "SHLL.B": lambda il, args: W(il, args[0], il.shift_left(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "SHLL.W": lambda il, args: W(il, args[0], il.shift_left(2, R(il, args[0]), il.const(2, 1), flags='*')),
    "SHLL.L": lambda il, args: W(il, args[0], il.shift_left(4, R(il, args[0]), il.const(4, 1), flags='*')),
    "SHLR.B": lambda il, args: W(il, args[0], il.logical_shift_right(1, R(il, args[0]), il.const(1, 1), flags='*')),
    "SHLR.W": lambda il, args: W(il, args[0], il.logical_shift_right(2, R(il, args[0]), il.const(2, 1), flags='*')),
    "SHLR.L": lambda il, args: W(il, args[0], il.logical_shift_right(4, R(il, args[0]), il.const(4, 1), flags='*')),
    "SLEEP":  lambda il, args: il.unimplemented(), # special sleep behavior
    # STC
    "SUB.B": lambda il, args: W(il, args[1], il.sub(1, R(il, args[1]), R(il, args[0]), flags='*')),
    "SUB.W": lambda il, args: W(il, args[1], il.sub(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "SUB.L": lambda il, args: W(il, args[1], il.sub(4, R(il, args[1]), R(il, args[0]), flags='*')),
    "SUBS":  lambda il, args: W(il, args[1], il.sub(4, R(il, args[1]), R(il, args[0]))),
    "SUBX":  lambda il, args: W(il, args[1], il.sub_borrow(4, R(il, args[1]), R(il, args[0]), il.flag('c'), flags='*')),
    "TRAPA": lambda il, args: il.unimplemented(),
    "XOR.B": lambda il, args: W(il, args[1], il.xor_expr(1, R(il, args[1]), R(il, args[0]), flags='*')),
    "XOR.W": lambda il, args: W(il, args[1], il.xor_expr(2, R(il, args[1]), R(il, args[0]), flags='*')),
    "XOR.L": lambda il, args: W(il, args[1], il.xor_expr(4, R(il, args[1]), R(il, args[0]), flags='*')),
    # XORC


}



```

`binary-h8300/plugin.json`:

```json
{
    "plugin": {
        "name": "H8/300 Plugin",
        "type": ["architecture"],
        "api": "python3",
        "description": "H8/300 Architecture",
        "license": {
            "name": "BSD-0-clause"
        },
        "version": "1.0",
        "author": "Pusty"
    }
}
```

`binary-jvm/__init__.py`:

```py
from .jvm import *
```

`binary-jvm/jvm.py`:

```py
import struct
import traceback
import os

from binaryninja import *
from types import *
            
InstructionNames = [
'nop', 'aconst_null', 'iconst_m1', 'iconst_0', 'iconst_1', 'iconst_2', 'iconst_3', 'iconst_4', 
'iconst_5', 'lconst_0', 'lconst_1', 'fconst_0', 'fconst_1', 'fconst_2', 'dconst_0', 'dconst_1', 
'bipush', 'sipush', 'ldc', 'ldc_w', 'ldc2_w', 'iload', 'lload', 'fload', 
'dload', 'aload', 'iload_0', 'iload_1', 'iload_2', 'iload_3', 'lload_0', 'lload_1', 
'lload_2', 'lload_3', 'fload_0', 'fload_1', 'fload_2', 'fload_3', 'dload_0', 'dload_1', 
'dload_2', 'dload_3', 'aload_0', 'aload_1', 'aload_2', 'aload_3', 'iaload', 'laload', 
'faload', 'daload', 'aaload', 'baload', 'caload', 'saload', 'istore', 'lstore', 
'fstore', 'dstore', 'astore', 'istore_0', 'istore_1', 'istore_2', 'istore_3', 'lstore_0', 
'lstore_1', 'lstore_2', 'lstore_3', 'fstore_0', 'fstore_1', 'fstore_2', 'fstore_3', 'dstore_0', 
'dstore_1', 'dstore_2', 'dstore_3', 'astore_0', 'astore_1', 'astore_2', 'astore_3', 'iastore', 
'lastore', 'fastore', 'dastore', 'aastore', 'bastore', 'castore', 'sastore', 'pop', 
'pop2', 'dup', 'dup_x1', 'dup_x2', 'dup2', 'dup2_x1', 'dup2_x2', 'swap', 
'iadd', 'ladd', 'fadd', 'dadd', 'isub', 'lsub', 'fsub', 'dsub', 
'imul', 'lmul', 'fmul', 'dmul', 'idiv', 'ldiv', 'fdiv', 'ddiv', 
'irem', 'lrem', 'frem', 'drem', 'ineg', 'lneg', 'fneg', 'dneg', 
'ishl', 'lshl', 'ishr', 'lshr', 'iushr', 'lushr', 'iand', 'land', 
'ior', 'lor', 'ixor', 'lxor', 'iinc', 'i2l', 'i2f', 'i2d', 
'l2i', 'l2f', 'l2d', 'f2i', 'f2l', 'f2d', 'd2i', 'd2l', 
'd2f', 'i2b', 'i2c', 'i2s', 'lcmp', 'fcmpl', 'fcmpg', 'dcmpl', 
'dcmpg', 'ifeq', 'ifne', 'iflt', 'ifge', 'ifgt', 'ifle', 'if_icmpeq', 
'if_icmpne', 'if_icmplt', 'if_icmpge', 'if_icmpgt', 'if_icmple', 'if_acmpeq', 'if_acmpne', 'goto', 
'jsr', 'ret', 'tableswitch', 'lookupswitch', 'ireturn', 'lreturn', 'freturn', 'dreturn', 
'areturn', 'return', 'getstatic', 'putstatic', 'getfield', 'putfield', 'invokevirtual', 'invokespecial', 
'invokestatic', 'invokeinterface', 'invokedynamic', 'new', 'newarray', 'anewarray', 'arraylength', 'athrow', 
'checkcast', 'instanceof', 'monitorenter', 'monitorexit', 'wide', 'multianewarray', 'ifnull', 'ifnonnull', 
'goto_w', 'jsr_w', None, None, None, None, None, None, 
None, None, None, None, None, None, None, None, 
None, None, None, None, None, None, None, None, 
None, None, None, None, None, None, None, None, 
None, None, None, None, None, None, None, None, 
None, None, None, None, None, None, None, None, 
None, None, None, None, None, None, None, None]


PSEUDOMEMORY_PRIMITIVES = 0xE0000000 #Pointer to not existing memory containing symbols with names of the primitives these fields represent
PSEUDOMEMORY_TABLE      = 0xF0000000 #Pointer to not existing memory containing symbols with string content of contant table entries

InstructionLengths = [0,1,2,1,2,2,12,8,2,4,4,1,3,3,4,1]

TYPE_NONE   = 0
TYPE_BYTE   = 1
TYPE_2BYTE  = 2
TYPE_INDEX  = 3
TYPE_IINC   = 4
TYPE_2BRANCH = 5
TYPE_TABLESWITCH = 6
TYPE_LOOKUPSWITCH = 7
TYPE_2INDEX = 8
TYPE_INTERFACE = 9
TYPE_DYNAMIC = 10
TYPE_ATYPE = 11
TYPE_WIDE = 12
TYPE_MULTIARRAY = 13
TYPE_4BRANCH = 14
TYPE_LDC = 15

InstructionFormat = [
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_BYTE, TYPE_2BYTE, TYPE_LDC, TYPE_2INDEX, TYPE_2INDEX, TYPE_INDEX, TYPE_INDEX, TYPE_INDEX, 
TYPE_INDEX, TYPE_INDEX, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_INDEX, TYPE_INDEX, 
TYPE_INDEX, TYPE_INDEX, TYPE_INDEX, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_IINC, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_2BRANCH ,TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, 
TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, TYPE_2BRANCH, 
TYPE_2BRANCH, TYPE_INDEX, TYPE_TABLESWITCH, TYPE_LOOKUPSWITCH, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_2INDEX, TYPE_2INDEX, TYPE_2INDEX, TYPE_2INDEX, TYPE_2INDEX, TYPE_2INDEX, 
TYPE_2INDEX, TYPE_INTERFACE, TYPE_DYNAMIC, TYPE_2INDEX, TYPE_ATYPE, TYPE_2INDEX, TYPE_NONE, TYPE_NONE, 
TYPE_2INDEX, TYPE_2INDEX, TYPE_NONE, TYPE_NONE, TYPE_WIDE, TYPE_MULTIARRAY, TYPE_2BRANCH, TYPE_2BRANCH, 
TYPE_4BRANCH, TYPE_4BRANCH, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, 
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE,
TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE, TYPE_NONE]


ADDR_SIZE = 4
STACK_ADDR = 0x8000
def getPoolEntry(il, value):
    return il.load(4, il.const_pointer(4, value+PSEUDOMEMORY_TABLE))
    

def loadLocal(il, index, size):
    if size == 8:
        return il.unimplemented() #il.or_expr(8, il.load(4, il.const_pointer(STACK_ADDR+index*4)), il.logical_shift_right(8, il.load(4, il.const_pointer(STACK_ADDR+(index+1)*4)), il.const(8, 32)))
        
    local = il.load(size, il.const_pointer(ADDR_SIZE, STACK_ADDR+index*4))
    if size != 4:
        local = il.zero_extend(4, local)
    return il.push(4, local)
    
def storeLocal(il, index, size):
    if size == 8:
        return il.unimplemented()
        
    valueExp = il.pop(4)
    if size != 4:
        valueExp = il.low_part(size, valueExp)
        
    return il.store(size, il.const_pointer(ADDR_SIZE, STACK_ADDR+index*4), valueExp)

def loadArray(il, size):
    if size == 8:
        return il.unimplemented()
        
    arrvar = il.load(size, il.add(ADDR_SIZE, il.pop(ADDR_SIZE), il.mult(ADDR_SIZE, il.pop(4), il.const(ADDR_SIZE, size))))
    if size != 4:
        arrvar = il.zero_extend(4, arrvar)
        
    return il.push(4, arrvar)

def storeArray(il, size):
    if size == 8:
        return il.unimplemented()
        
    arrayPop = il.pop(ADDR_SIZE)
    indexPop = il.pop(4)
    valuePop = il.pop(4) # stack is in 4 byte chunks
    
    if size != 4:
        valueExp = il.low_part(size, valueExp)
    
    writeback = il.store(size, il.add(ADDR_SIZE, arrayPop, il.mult(ADDR_SIZE, il.pop(4), il.const(ADDR_SIZE, size))), valuePop)
    return [arrayPop, indexPop, valuePop, writeback]
    
def compareOperation(il, size, operation, operand):
    cmp_op = operation(size, il.pop(size), il.pop(size))
    f = LowLevelILLabel()
    if_op = il.if_expr(cmp_op, il.get_label_for_address(Architecture["JVM"], il[il.const_pointer(ADDR_SIZE, operand)].constant),  f)
    return [if_op, lambda il, operand: il.mark_label(f)]
    
InstructionIL = {
    "nop":         lambda il, operand: il.nop(),
    "aconst_null": lambda il, operand: il.push(4, il.const(4,0)),
    "iconst_m1":   lambda il, operand: il.push(4, il.const(4,-1)),
    "iconst_0":    lambda il, operand: il.push(4, il.const(4,0)),
    "iconst_1":    lambda il, operand: il.push(4, il.const(4,1)),
    "iconst_2":    lambda il, operand: il.push(4, il.const(4,2)),
    "iconst_3":    lambda il, operand: il.push(4, il.const(4,3)),
    "iconst_4":    lambda il, operand: il.push(4, il.const(4,4)),
    "iconst_5":    lambda il, operand: il.push(4, il.const(4,5)),
    "lconst_0":    lambda il, operand: il.push(8, il.const(8,0)),
    "lconst_1":    lambda il, operand: il.push(8, il.const(8,1)),
    "fconst_0":    lambda il, operand: il.push(4, il.float_const_single(0.0)),
    "fconst_1":    lambda il, operand: il.push(4, il.float_const_single(1.0)),
    "fconst_2":    lambda il, operand: il.push(4, il.float_const_single(2.0)),
    "dconst_0":    lambda il, operand: il.push(8, il.float_const_double(0.0)),
    "dconst_1":    lambda il, operand: il.push(8, il.float_const_double(1.0)),
    "bipush":      lambda il, operand: il.push(4, il.const(4,operand)),
    "sipush":      lambda il, operand: il.push(4, il.const(4,operand)),
    "ldc":         lambda il, operand: il.push(4, getPoolEntry(il,operand)),
    "ldc_w":       lambda il, operand: il.push(4, getPoolEntry(il,operand)),
    "ldc2_w":      lambda il, operand: [il.push(4, getPoolEntry(il,operand+1)),il.push(4, getPoolEntry(il,operand))],
    "iload":       lambda il, operand: loadLocal(il,operand,4),
    "lload":       lambda il, operand: loadLocal(il,operand,8),
    "fload":       lambda il, operand: loadLocal(il,operand,4),
    "dload":       lambda il, operand: loadLocal(il,operand,8),
    "aload":       lambda il, operand: loadLocal(il,operand,ADDR_SIZE),
    "iload_0":     lambda il, operand: InstructionIL["iload"](il, 0),
    "iload_1":     lambda il, operand: InstructionIL["iload"](il, 1),
    "iload_2":     lambda il, operand: InstructionIL["iload"](il, 2),
    "iload_3":     lambda il, operand: InstructionIL["iload"](il, 3),
    "lload_0":     lambda il, operand: InstructionIL["lload"](il, 0),
    "lload_1":     lambda il, operand: InstructionIL["lload"](il, 2),
    "lload_2":     lambda il, operand: InstructionIL["lload"](il, 4),
    "lload_3":     lambda il, operand: InstructionIL["lload"](il, 8),
    "fload_0":     lambda il, operand: InstructionIL["fload"](il, 0),
    "fload_1":     lambda il, operand: InstructionIL["fload"](il, 1),
    "fload_2":     lambda il, operand: InstructionIL["fload"](il, 2),
    "fload_3":     lambda il, operand: InstructionIL["fload"](il, 3),
    "dload_0":     lambda il, operand: InstructionIL["dload"](il, 0),
    "dload_1":     lambda il, operand: InstructionIL["dload"](il, 2),
    "dload_2":     lambda il, operand: InstructionIL["dload"](il, 4),
    "dload_3":     lambda il, operand: InstructionIL["dload"](il, 8),
    "aload_0":     lambda il, operand: InstructionIL["aload"](il, 0),
    "aload_1":     lambda il, operand: InstructionIL["aload"](il, 1),
    "aload_2":     lambda il, operand: InstructionIL["aload"](il, 2),
    "aload_3":     lambda il, operand: InstructionIL["aload"](il, 3),
    "iaload":      lambda il, operand: loadArray(il, 4),
    "laload":      lambda il, operand: loadArray(il, 8),
    "faload":      lambda il, operand: loadArray(il, 4),
    "daload":      lambda il, operand: loadArray(il, 8),
    "aaload":      lambda il, operand: loadArray(il, ADDR_SIZE),
    "baload":      lambda il, operand: loadArray(il, 1),
    "caload":      lambda il, operand: loadArray(il, 2),
    "saload":      lambda il, operand: loadArray(il, 2),
    "istore":      lambda il, operand: storeLocal(il, operand, 4),
    "lstore":      lambda il, operand: storeLocal(il, operand, 8),
    "fstore":      lambda il, operand: storeLocal(il, operand, 4),
    "dstore":      lambda il, operand: storeLocal(il, operand, 8),
    "astore":      lambda il, operand: storeLocal(il, operand, ADDR_SIZE),
    "istore_0":    lambda il, operand: InstructionIL["istore"](il, 0),
    "istore_1":    lambda il, operand: InstructionIL["istore"](il, 1),
    "istore_2":    lambda il, operand: InstructionIL["istore"](il, 2),
    "istore_3":    lambda il, operand: InstructionIL["istore"](il, 3),
    "lstore_0":    lambda il, operand: InstructionIL["lstore"](il, 0),
    "lstore_1":    lambda il, operand: InstructionIL["lstore"](il, 2),
    "lstore_2":    lambda il, operand: InstructionIL["lstore"](il, 4),
    "lstore_3":    lambda il, operand: InstructionIL["lstore"](il, 6),
    "fstore_0":    lambda il, operand: InstructionIL["fstore"](il, 0),
    "fstore_1":    lambda il, operand: InstructionIL["fstore"](il, 1),
    "fstore_2":    lambda il, operand: InstructionIL["fstore"](il, 2),
    "fstore_3":    lambda il, operand: InstructionIL["fstore"](il, 3),
    "dstore_0":    lambda il, operand: InstructionIL["dstore"](il, 0),
    "dstore_1":    lambda il, operand: InstructionIL["dstore"](il, 2),
    "dstore_2":    lambda il, operand: InstructionIL["dstore"](il, 4),
    "dstore_3":    lambda il, operand: InstructionIL["dstore"](il, 6),
    "astore_0":    lambda il, operand: InstructionIL["astore"](il, 0),
    "astore_1":    lambda il, operand: InstructionIL["astore"](il, 1),
    "astore_2":    lambda il, operand: InstructionIL["astore"](il, 2),
    "astore_3":    lambda il, operand: InstructionIL["astore"](il, 3),
    "iastore":     lambda il, operand: storeArray(il, 4),
    "lastore":     lambda il, operand: storeArray(il, 8),
    "fastore":     lambda il, operand: storeArray(il, 4),
    "dastore":     lambda il, operand: storeArray(il, 8),
    "aastore":     lambda il, operand: storeArray(il, ADDR_SIZE),
    "bastore":     lambda il, operand: storeArray(il, 1),
    "castore":     lambda il, operand: storeArray(il, 2),
    "sastore":     lambda il, operand: storeArray(il, 2),
    "pop":         lambda il, operand: il.pop(4),
    "pop2":        lambda il, operand: il.pop(8),
    "dup":         lambda il, operand: (lambda x: [il.push(4, x), il.push(4, x)])(il.pop(4)),
    # these may be the wrong way around >__>
    "dup_x1":      lambda il, operand: (lambda value2, value1: [il.push(4, value1), il.push(4, value2), il.push(4, value1)])(il.pop(4), il.pop(4)),
    "dup_x2":      lambda il, operand: (lambda value3, value2, value1: [il.push(4,value1),il.push(4,value3), il.push(4,value2), il.push(4,value1)])(il.pop(4),il.pop(4), il.pop(4)),
    "dup2":        lambda il, operand: (lambda value1: [il.push(8,value1), il.push(8,value1)])(il.pop(8)),
    "dup2_x1":     lambda il, operand: (lambda value3, value1: [il.push(8,value1), il.push(4,value3), il.push(8,value1)])(il.pop(4), il.pop(8)),
    "dup2_x2":     lambda il, operand: (lambda value4, value1: [il.push(8, value1), il.push(8,value4), il.push(8,value1)])(il.pop(8), il.pop(8)),
    "swap":        lambda il, operand: (lambda value2, value1: [il.push(4,value1), il.push(4,value2)])(il.pop(4), il.pop(4)),
    
    "iadd":        lambda il, operand: il.push(4, il.add(4, il.pop(4), il.pop(4))),
    "ladd":        lambda il, operand: il.push(8, il.add(8, il.pop(8), il.pop(8))),
    "fadd":        lambda il, operand: il.push(4, il.float_add(4, il.pop(4), il.pop(4))),
    "dadd":        lambda il, operand: il.push(8, il.float_add(8, il.pop(8), il.pop(8))),
    "isub":        lambda il, operand: il.push(4, il.sub(4, il.pop(4), il.pop(4))),
    "lsub":        lambda il, operand: il.push(8, il.sub(8, il.pop(8), il.pop(8))),
    "fsub":        lambda il, operand: il.push(4, il.float_sub(4, il.pop(4), il.pop(4))),
    "dsub":        lambda il, operand: il.push(8, il.float_sub(8, il.pop(8), il.pop(8))),
    "imul":        lambda il, operand: il.push(4, il.mult(4, il.pop(4), il.pop(4))),
    "lmul":        lambda il, operand: il.push(8, il.mult(8, il.pop(8), il.pop(8))),
    "fmul":        lambda il, operand: il.push(4, il.float_mult(4, il.pop(4), il.pop(4))),
    "dmul":        lambda il, operand: il.push(8, il.float_mult(8, il.pop(8), il.pop(8))),
    "idiv":        lambda il, operand: il.push(4, il.div(4, il.pop(4), il.pop(4))),
    "ldiv":        lambda il, operand: il.push(8, il.div(8, il.pop(8), il.pop(8))),
    "fdiv":        lambda il, operand: il.push(4, il.float_div(4, il.pop(4), il.pop(4))),
    "ddiv":        lambda il, operand: il.push(8, il.float_div(8, il.pop(8), il.pop(8))),
    
    # is this mod_signed and mod_double_prec_signed?
    "irem":        lambda il, operand: il.push(4, il.mod_signed(4, il.pop(4), il.pop(4))),
    "lrem":        lambda il, operand: il.push(8, il.mod_signed(8, il.pop(8), il.pop(8))),
    "frem":        lambda il, operand: il.push(4, il.mod_double_prec_signed(4, il.pop(4), il.pop(4))),
    "drem":        lambda il, operand: il.push(8, il.mod_double_prec_signed(8, il.pop(8), il.pop(8))),
    
    "ineg":        lambda il, operand: il.push(4, il.neg_expr(4, il.pop(4), il.pop(4))),
    "lneg":        lambda il, operand: il.push(8, il.neg_expr(8, il.pop(8), il.pop(8))),
    "fneg":        lambda il, operand: il.push(4, il.float_neg(4, il.pop(4), il.pop(4))),
    "dneg":        lambda il, operand: il.push(8, il.float_neg(8, il.pop(8), il.pop(8))),
    "ishl":        lambda il, operand: il.push(4, il.shift_left(4, il.pop(4), il.pop(4))),
    "lshl":        lambda il, operand: il.push(8, il.shift_left(8, il.pop(8), il.pop(8))),
    "ishr":        lambda il, operand: il.push(4, il.arith_shift_right(4, il.pop(4), il.pop(4))),
    "lshr":        lambda il, operand: il.push(8, il.arith_shift_right(8, il.pop(8), il.pop(8))),
    "iushr":       lambda il, operand: il.push(4, il.logical_shift_right(4, il.pop(4), il.pop(4))),
    "lushr":       lambda il, operand: il.push(8, il.logical_shift_right(8, il.pop(8), il.pop(8))),
    "iand":        lambda il, operand: il.push(4, il.and_expr(4, il.pop(4), il.pop(4))),
    "land":        lambda il, operand: il.push(8, il.and_expr(8, il.pop(8), il.pop(8))),
    "ior":         lambda il, operand: il.push(8, il.or_expr(8, il.pop(8), il.pop(8))),
    "lor":         lambda il, operand: il.push(8, il.or_expr(8, il.pop(8), il.pop(8))),
    "ixor":        lambda il, operand: il.push(8, il.xor_expr(8, il.pop(8), il.pop(8))),
    "lxor":        lambda il, operand: il.push(8, il.xor_expr(8, il.pop(8), il.pop(8))),
    "i2l":         lambda il, operand: il.push(8, il.sign_extend(8, il.pop(4))),
    "i2f":         lambda il, operand: il.push(4, il.int_to_float(4, il.pop(4))),
    "i2d":         lambda il, operand: il.push(8, il.int_to_float(8, il.pop(4))),
    "l2i":         lambda il, operand: il.push(4, il.low_part(4, il.pop(8))),
    "l2f":         lambda il, operand: il.push(4, il.int_to_float(4, il.pop(8))),
    "l2d":         lambda il, operand: il.push(8, il.int_to_float(8, il.pop(8))),
    "f2i":         lambda il, operand: il.push(4, il.float_to_int(4, il.pop(4))),
    "f2l":         lambda il, operand: il.push(8, il.float_to_int(8, il.pop(4))),
    "f2d":         lambda il, operand: il.push(8, il.float_convert(8, il.pop(4))),
    "d2i":         lambda il, operand: il.push(4, il.float_to_int(4, il.pop(8))),
    "d2l":         lambda il, operand: il.push(8, il.float_to_int(8, il.pop(8))),
    "d2f":         lambda il, operand: il.push(4, il.float_convert(4, il.pop(8))),
    "i2b":         lambda il, operand: il.push(4, il.sign_extend(4, il.low_part(1, il.pop(4)))),
    "i2c":         lambda il, operand: il.push(4, il.sign_extend(4, il.low_part(2, il.pop(4)))),
    "i2s":         lambda il, operand: il.push(4, il.sign_extend(4, il.low_part(2, il.pop(4)))),
    "iinc":        lambda il, operand: [loadLocal(il,operand[0],4), il.push(4, il.add(4, il.pop(4), il.const(4, operand[1]))), storeLocal(il, operand[0], 4)],
    #il.load(4, il.const_pointer(ADDR_SIZE, STACK_ADDR+operand[0]*4)),
    
    
    #
    # 94 - 9f
    
    "if_icmpne":   lambda il, operand: compareOperation(il, 4, il.compare_not_equal, operand),
    "if_icmpge":   lambda il, operand: compareOperation(il, 4, il.compare_signed_greater_equal, operand),
    
    
    "goto":        lambda il, operand: il.jump(il.const_pointer(ADDR_SIZE, operand)),
    
    "ireturn":        lambda il, operand: [il.no_ret()],
    
}


OperandTokens = [
	lambda self,value: [],    # TYPE_NONE
	lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "%d" % value)],  # TYPE_BYTE
	lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "%d" % value)],  # TYPE_2BYTE
	lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "var_%d" % value)],  # TYPE_INDEX
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "var_%d" % value[0]), InstructionTextToken(InstructionTextTokenType.OperandSeparatorToken, ", "), InstructionTextToken(InstructionTextTokenType.IntegerToken, "%d" % value[1])],  # TYPE_IINC
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, "0x%.2x" % value, value)],  # TYPE_2BRANCH
    lambda self,value: [],  # TYPE_TABLESWITCH
    lambda self,value: [],  # TYPE_LOOKUPSWITCH
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "Pool@%d" % value, value+PSEUDOMEMORY_TABLE)],  # TYPE_2INDEX
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "Pool@%d" % value[0],value[0]+PSEUDOMEMORY_TABLE)],  # TYPE_INTERFACE
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "Pool@%d" % value[0],value[0]+PSEUDOMEMORY_TABLE)],  # TYPE_DYNAMIC
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "A@0x%.2x" % value,value+PSEUDOMEMORY_PRIMITIVES)],  # TYPE_ATYPE
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.TextToken, "%s " % InstructionNames[value[0]]), InstructionTextToken(InstructionTextTokenType.IntegerToken, "var_%d" % value[1])] if len(value) == 2 else [InstructionTextToken(InstructionTextTokenType.TextToken, "%s " % InstructionNames[value[0]]), InstructionTextToken(InstructionTextTokenType.IntegerToken, "var_@%d" % value[1]), InstructionTextToken(InstructionTextTokenType.OperandSeparatorToken, ", "), InstructionTextToken(InstructionTextTokenType.IntegerToken, "%d" % value[2])],  # TYPE_WIDE
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "Pool@%d" % value[0],value[0]+PSEUDOMEMORY_TABLE), InstructionTextToken(InstructionTextTokenType.OperandSeparatorToken, ", "), InstructionTextToken(InstructionTextTokenType.IntegerToken, "$%.1x" % value[1])],  # TYPE_MULTIARRAY
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, "0x%.4x" % value, value)],   # TYPE_4BRANCH
    lambda self,value: [InstructionTextToken(InstructionTextTokenType.IntegerToken, "Pool@%d" % value,value+PSEUDOMEMORY_TABLE)]  # TYPE_LDC
]

def decode_instruction(data, addr):
        if len(data) < 1:
            return None, None, None, None
        opcode = data[0]
        instr = InstructionNames[opcode]
        if instr is None:
            return None, None, None, None

        operand = InstructionFormat[opcode]
        length = 1 + InstructionLengths[operand]
        if len(data) < length:
            return None, None, None, None

        if operand == TYPE_NONE:
            value = None
        elif operand == TYPE_BYTE:
            value = struct.unpack(">b", data[1:2])[0]
        elif operand == TYPE_2BYTE:
            value = struct.unpack(">h", data[1:3])[0]
        elif operand == TYPE_INDEX:
            value = struct.unpack(">B", data[1:2])[0]
        elif operand == TYPE_LDC:
            value = struct.unpack(">B", data[1:2])[0]
        elif operand == TYPE_2INDEX:
            value = struct.unpack(">H", data[1:3])[0]
        elif operand == TYPE_IINC:
            value = struct.unpack(">Bb", data[1:3])
        elif operand == TYPE_2BRANCH:
            value = addr+struct.unpack(">h", data[1:3])[0]
        elif operand == TYPE_4BRANCH:
            value = addr+struct.unpack(">i", data[1:5])[0]
        elif operand == TYPE_TABLESWITCH:
            padding = 4-((addr+1)%4)
            default,lowbyte,highbyte = struct.unpack(">iII", data[1+padding:13+padding])
            default += addr
            offsets = []
            length = (padding+12+1+(highbyte-lowbyte+1)*4)
            if len(data) < length:
                return None, None, None, length
            for i in range(highbyte-lowbyte+1):
                offsets.append((lowbyte+i, addr+struct.unpack(">i", data[13+i*4+padding:17+i*4+padding])[0]))
            value = (default,lowbyte, highbyte, offsets)
        elif operand == TYPE_LOOKUPSWITCH:
            padding = 4-((addr+1)%4)
   
            default,npairs = struct.unpack(">iI", data[1+padding:9+padding])
            default += addr
            offsets = []
            length = (padding+8+1+npairs*8)
            if len(data) < length:
                return None, None, None, length
            for i in range(npairs):
                offsets.append((struct.unpack(">I", data[9+i*8+padding:13+i*8+padding])[0], addr+struct.unpack(">i", data[13+i*8+padding:17+i*8+padding])[0]))
            value = (default,npairs,offsets)
        elif operand == TYPE_INTERFACE:
            index = struct.unpack(">H", data[1:3])[0]
            real_addr = index
            value = (real_addr, index)
        elif operand == TYPE_DYNAMIC:
            index = struct.unpack(">H", data[1:3])[0]
            real_addr = index
            value = (real_addr, index)
        elif operand == TYPE_ATYPE:
            value = struct.unpack(">B", data[1:2])[0]
        elif operand == TYPE_WIDE:
            op2 = data[1]
            if op2 == 0x84: #iinc
                length = 5
                if len(data) < length:
                    return None, None, None, length
                value = struct.unpack(">BHh", data[1:6])
            else:
                value = struct.unpack(">BH", data[1:4])
        elif operand == TYPE_MULTIARRAY:
            value = struct.unpack(">HB", data[1:4])
        else:
            value = None
        return instr, operand, length, value
        
class JVM(Architecture):
    
    name = "JVM"
    address_size = ADDR_SIZE
    default_int_size = 4
    max_instr_length = 255
    regs = { "s": RegisterInfo("s", 4) }
    stack_pointer = "s"
    endianness = Endianness.BigEndian

    def get_instruction_info(self, data, addr):
        instr, operand, length, value = decode_instruction(data, addr)
        if instr is None:
            return None

        result = InstructionInfo()
        result.length = length
        if instr in ["jsr", "jsr_w","goto","goto_w"]:
            result.add_branch(BranchType.UnconditionalBranch, value)
        elif instr in ["invokestatic","invokedynamic"]:
            #result.add_branch(BranchType.CallDestination, value[0])
            pass
        elif instr in ["invokevirtual", "invokespecial"]:
#           result.add_branch(BranchType.IndirectBranch)
            pass
        elif instr == "invokeinterface":
 #           result.add_branch(BranchType.IndirectBranch)
            pass
        elif instr == "tableswitch":
            result.add_branch(BranchType.IndirectBranch)
            #result.add_branch(BranchType.FalseBranch, value[0])
            #for p in value[3]:
            #    result.add_branch(BranchType.UnconditionalBranch, p[1])
        elif instr == "lookupswitch":
            result.add_branch(BranchType.IndirectBranch)
            #result.add_branch(BranchType.FalseBranch, value[0])
            #for p in value[2]:
            #    result.add_branch(BranchType.UnconditionalBranch, p[1])
        elif instr in ["ret", "ireturn","lreturn","freturn","dreturn","areturn","return"]:
            result.add_branch(BranchType.FunctionReturn)
        elif instr in ["ifnull", "ifnonnull","if_acmpne","if_acmpeq","if_icmple","if_icmpgt","if_icmpge","if_icmplt","if_icmpne","if_icmpeq","ifle","ifgt","ifge","iflt","ifne","ifeq"]:
            result.add_branch(BranchType.TrueBranch, value)
            result.add_branch(BranchType.FalseBranch, addr + length)
            
        return result

    def get_instruction_text(self, data, addr):
        instr, operand, length, value = decode_instruction(data, addr)
        if instr is None:
            return None
        tokens = []
        tokens.append(InstructionTextToken(InstructionTextTokenType.TextToken, "%-14s " % instr))
        tokens += OperandTokens[operand](self,value)
        return tokens, length
        
    def get_instruction_low_level_il(self, data, addr, il):
        instr, operand, length, value = decode_instruction(data, addr)
        if instr is None:
            return None
            
        if InstructionIL.get(instr) is not None:
            inst = InstructionIL[instr](il, value)
            if isinstance(inst, list):
                for i in inst:
                    if isinstance(i, LambdaType):
                        i(il, value)
                    else:    
                        il.append(i)
            elif inst is not None:
                il.append(inst)
        else:
            il.append(il.unimplemented())
            
        return length
        
    def convert_to_nop(self, data, addr):
        instr, operand, length, value = decode_instruction(data, addr)
        if instr == None:
            return None
        if instr.startswith("if_"):
            return "\x58" + ("\x00" * (len(data)-1)) #pop2
        elif instr.startswith("if"):
            return "\x57" + ("\x00" * (len(data)-1)) #pop
        return "\x00" * len(data)

    def is_jump(self,data, addr):
        instr, operand, length, value = decode_instruction(data, addr)
        if instr != None and "if" in instr:
            return True
        return False
        
    def is_never_branch_patch_available(self, data, addr):
        return self.is_jump(data, addr) or data[0] == "\xc8" or data[0] == "\xc9" or data[0] == "\xa7" or data[0] == "\xa8"
        
    def is_invert_branch_patch_available(self, data, addr):
        return self.is_jump(data, addr)
        
    def is_always_branch_patch_available(self, data, addr):
        return self.is_jump(data, addr)
        
    def invert_branch(self, data, addr):
        if data[0] == "\xa5": return "\xa6"+data[1:] #if_acmpeq -> if_acmpne
        if data[0] == "\xa6": return "\xa5"+data[1:] #if_acmpne -> if_acmpeq
        if data[0] == "\x9f": return "\xa0"+data[1:] #if_icmpeq -> if_icmpne
        if data[0] == "\xa2": return "\xa1"+data[1:] #if_icmpge -> if_icmplt
        if data[0] == "\xa3": return "\xa4"+data[1:] #if_icmpgt -> if_icmple
        if data[0] == "\xa4": return "\xa3"+data[1:] #if_icmple -> if_icmpgt
        if data[0] == "\xa1": return "\xa2"+data[1:] #if_icmplt -> if_icmpge
        if data[0] == "\xa0": return "\x9f"+data[1:] #if_icmpne -> if_icmpeq
        if data[0] == "\x99": return "\x9a"+data[1:] #ifeq      -> ifne
        if data[0] == "\x9c": return "\x9b"+data[1:] #ifge      -> iflt
        if data[0] == "\x9d": return "\x9e"+data[1:] #ifgt      -> ifle
        if data[0] == "\x9e": return "\x9d"+data[1:] #ifle      -> ifgt
        if data[0] == "\x9b": return "\x9c"+data[1:] #iflt      -> ifge
        if data[0] == "\x9a": return "\x99"+data[1:] #ifne      -> ifeq
        if data[0] == "\xc7": return "\xc6"+data[1:] #ifnotnull -> ifnull
        if data[0] == "\xc6": return "\xc7"+data[1:] #ifnull    -> ifnotnull
        return None
        
    #beaware, considering this doesn't remove the last push and will most likely will lead to stack corruption!
    def always_branch(self, data, addr):
        return "\xa7"+data[1:] #goto
        
    def appendPacked(self, format, s, sub=0, mode=0):
        try:
            value = 0
            if s.startswith("0x") or s.startswith("0X"):
                value = int(s,16)
            elif s.endswith("h") or s.endswith("H"):
                value = int(s[:-1],16)
            elif any(c.isalpha() for c in s): 
                value = int(s,16)
            else:
                value = int(s)
            value -= sub
            if mode == 1:
                value &= 0x0FFFFFF
            return struct.pack(format, value)
        except Exception as e:
            print(e)
            return None
        
    def assemble(self, code, addr=0):
        instr = code.replace('\n',";").replace(','," ").split(';')
        for i in range(len(instr)): instr[i] = (" ".join(instr[i].split())).lower().split(" ")   
        data = []
        for inst in instr:
            if len(inst) < 1: continue
            if len(inst[0]) < 1: continue
            instIndex = -1
            for i,names in enumerate(InstructionNames):
                if inst[0] == names:
                    instIndex = i
                    break
            if inst[0] == "db":
                parameter = self.appendPacked(">B",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
                continue
            elif inst[0] == "dw":
                parameter = self.appendPacked(">H",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
                continue
            elif inst[0] == "dd":
                parameter = self.appendPacked(">I",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
                continue
            elif inst[0] == "dq":
                parameter = self.appendPacked(">Q",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
                continue
            
            if instIndex == -1:
                return None
            if InstructionFormat[instIndex] == TYPE_NONE: 
                data.append(chr(instIndex))
            elif InstructionFormat[instIndex] == TYPE_BYTE and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">b",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_2BYTE and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">h",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
            elif (InstructionFormat[instIndex] == TYPE_INDEX or InstructionFormat[instIndex] == TYPE_LDC) and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">B",inst[1], mode=1)
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_2INDEX and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">H",inst[1], mode=1)
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_IINC and len(inst) >= 3: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">B",inst[1])
                if parameter != None: data.append(parameter)
                else:                 return None
                parameter = self.appendPacked(">b",inst[2])
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_2BRANCH and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">h",inst[1], sub=addr)
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_4BRANCH and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">i",inst[1], sub=addr)
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_INTERFACE and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">H",inst[1], mode=1)
                if parameter != None: data.append(parameter)
                else:                 return None
                data.append("\x00") #count
                data.append("\x00")
            elif InstructionFormat[instIndex] == TYPE_DYNAMIC and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">H",inst[1], mode=1)
                if parameter != None: data.append(parameter)
                else:                 return None
                data.append("\x00")
                data.append("\x00")
            elif InstructionFormat[instIndex] == TYPE_ATYPE and len(inst) >= 2: 
                data.append(chr(instIndex))
                parameter = self.appendPacked(">B",inst[1], mode=1)
                if parameter != None: data.append(parameter)
                else:                 return None
            elif InstructionFormat[instIndex] == TYPE_MULTIARRAY  and len(inst) >= 3:
                data.append(chr(instIndex))
                parameter = self.appendPacked(">H",inst[1], mode=1)
                if parameter != None: data.append(parameter)
                else:                 return None
                parameter = self.appendPacked(">B",inst[2])
                if parameter != None: data.append(parameter)
                else:                 return None
            else: 
                return None
        
        if len(data) == 0: return None
        
        data = (''.join(data), '')
        return data

        
#super class for all jvm structures
class JVMStructure():
    def __init__(self, cR):
        self.classReader = cR
        self.structure = TypeBuilder.structure() # a binary ninja structure
        self.structure.packed = True # don't align structure
        self.itype      = None
        
    """
    def resultingType(self):
        if self.type == None:
            self.type = Type.structure_type(self.structure)
        return self.type
    """
        
    def resultingType(self):
        if self.itype == None:
            oid = str(self.__class__.__name__)
            self.itype = Type.structure_type(self.structure)
            pos = 0
            while True: # loop all possible structre names until one is free or equal to the current one
                if pos == 0:
                    id = oid
                else:
                    id = oid+"("+str(pos)+")"       
                alr = self.classReader.view.get_type_by_name(id)   
                if(alr != None):
                    if(self.itype == alr or (self.itype.structure != None and alr.structure != None and str(self.itype.structure().members) == str(alr.structure().members))):
                        break
                    else:
                        pos += 1
                        continue
                else:
                    self.classReader.view.define_type(Type.generate_auto_type_id("source", id), id, self.itype)
                    break
            self.itype = Type.named_type_from_type(id, self.itype)
        return  self.itype
        
    def readByte(self, name=''):
        self.structure.append(Type.int(1,False,"u1"),name)
        return self.classReader.readByte()
        
    def readArray(self, amount, name='', aType = Type.int(1,False)):
        value = ""
        self.structure.append(Type.array(aType,amount),name)
        for i in range(amount):
            value += chr(self.classReader.readByte())
        return value
        
    def readShort(self, name=''):
        self.structure.append(Type.int(2,False,"u2"),name)
        return self.classReader.readShort()   
        
    def readInt(self, name=''):
        self.structure.append(Type.int(4,False,"u4"),name)
        return self.classReader.readInt()
        
    def readLong(self, name=''):
        self.structure.append(Type.int(8,False,"u8"),name)
        return self.classReader.readLong()
        
    def readFloat(self, name=''):
        self.structure.append(Type.float(4,False),name)
        return self.classReader.readFloat()
        
    def readDouble(self, name=''):
        self.structure.append(Type.float(8,False),name)
        return self.classReader.readDouble()
        
    def readStruct(self, obj, name=''):
        self.structure.append(obj.resultingType(),name)
        return obj
        
    def readUTF(self, name=''):
        tname = ''
        if len(name) > 0:
            tname = name + "_len"
        length = self.readShort(tname)
        if len(name) > 0:
            tname = name + "_data"
        return self.readArray(length, tname, aType = self.classReader.charType) # I would prefer Type.char()
        
UTF_8 = 1
INTEGER = 3
FLOAT = 4
LONG = 5
DOUBLE = 6
CLASS_REFERENCE = 7
STRING_REFERENCE = 8
FIELD_REFERENCE = 9
METHOD_REFERENCE = 10
INTERFACE_REFERENCE = 11
NAME_AND_TYPE = 12
METHOD_HANDLE = 15
METHOD_TYPE = 16
INVOKE_DYNAMIC = 18
class JVMConstantPool(JVMStructure):
    
    def __init__(self, r, size):
        JVMStructure.__init__(self, r)
        self.poolSize = size
        self.classReader.constantPool = self
        self.read()
    
    def getTagSize(self, tag):
        if(tag == UTF_8): return -1
        if(tag == INTEGER): return 4
        if(tag == FLOAT): return 4
        if(tag == LONG): return 8
        if(tag == DOUBLE): return 8
        if(tag == CLASS_REFERENCE): return 2
        if(tag == STRING_REFERENCE): return 2
        if(tag == FIELD_REFERENCE): return 4
        if(tag == METHOD_REFERENCE): return 4
        if(tag == INTERFACE_REFERENCE): return 4
        if(tag == NAME_AND_TYPE): return 4
        if(tag == METHOD_HANDLE): return 3
        if(tag == METHOD_TYPE): return 2
        if(tag == INVOKE_DYNAMIC): return 4
        return 0
        
    def getTagName(self, tag):
        if(tag == UTF_8): return "UTF_8"
        if(tag == INTEGER): return "INTEGER"
        if(tag == FLOAT): return "FLOAT"
        if(tag == LONG): return "LONG"
        if(tag == DOUBLE): return "DOUBLE"
        if(tag == CLASS_REFERENCE): return "CLASS_REFERENCE"
        if(tag == STRING_REFERENCE): return "STRING_REFERENCE"
        if(tag == FIELD_REFERENCE): return "FIELD_REFERENCE"
        if(tag == METHOD_REFERENCE): return "METHOD_REFERENCE"
        if(tag == INTERFACE_REFERENCE): return "INTERFACE_REFERENCE"
        if(tag == NAME_AND_TYPE): return "NAME_AND_TYPE"
        if(tag == METHOD_HANDLE): return "METHOD_HANDLE"
        if(tag == METHOD_TYPE): return "METHOD_TYPE"
        if(tag == INVOKE_DYNAMIC): return "INVOKE_DYNAMIC"
        return None
    
    def read(self):
        self.poolContent = [None]*self.poolSize
        self.poolLocation = [0]*self.poolSize
        i = 0
        while i<self.poolSize-1:
            entryName = "constant_pool["+str(i+1)+"]"
            self.poolLocation[i+1] = self.classReader.index()
            tag = self.classReader.readByte() #self.readByte(entryName+"_tag")
            self.classReader.idx -= 1
            size = self.getTagSize(tag)
            if size == 0:
                print("Exception: Error Reading Constant Pool ("+str(tag)+")")
                return
            if  (tag == UTF_8):   self.poolContent[i+1] = self.readStruct(JVMUTF8Info(self.classReader),entryName)
            elif(tag == INTEGER): self.poolContent[i+1] = self.readStruct(JVMIntegerInfo(self.classReader),entryName)
            elif(tag == FLOAT):   self.poolContent[i+1] = self.readStruct(JVMFloatInfo(self.classReader),entryName)
            elif(tag == LONG):    
                self.poolContent[i+1] = self.readStruct(JVMLongInfo(self.classReader),entryName)
                i += 1
            elif(tag == DOUBLE): 
                self.poolContent[i+1] = self.readStruct(JVMDoubleInfo(self.classReader),entryName)
                i += 1
            elif(tag == CLASS_REFERENCE):     self.poolContent[i+1]    = self.readStruct(JVMClassReference(self.classReader),entryName)
            elif(tag == STRING_REFERENCE):    self.poolContent[i+1]    = self.readStruct(JVMStringReference(self.classReader),entryName)
            elif(tag == FIELD_REFERENCE):     self.poolContent[i+1]    = self.readStruct(JVMFieldReference(self.classReader),entryName)
            elif(tag == METHOD_REFERENCE):    self.poolContent[i+1]    = self.readStruct(JVMMethodReference(self.classReader),entryName)
            elif(tag == INTERFACE_REFERENCE): self.poolContent[i+1]    = self.readStruct(JVMInterfaceMethodReference(self.classReader),entryName)
            elif(tag == NAME_AND_TYPE):       self.poolContent[i+1]    = self.readStruct(JVMNameAndTypeDescriptor(self.classReader),entryName)
            elif(tag == METHOD_HANDLE):       self.poolContent[i+1]    = self.readStruct(JVMMethodHandle(self.classReader),entryName)
            elif(tag == METHOD_TYPE):         self.poolContent[i+1]    = self.readStruct(JVMMethodType(self.classReader),entryName)
            elif(tag == INVOKE_DYNAMIC):      self.poolContent[i+1]    = self.readStruct(JVMInvokeDynamic(self.classReader),entryName)                                                              
            i += 1

    def get(self, index):
        return self.poolContent[index&0xFFFF]
  
class JVMUTF8Info(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.value = self.readUTF("value")
        
    def __str__(self):
        return self.value
        
class JVMIntegerInfo(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.value = self.readInt("value")
        
    def __str__(self):
        return str(self.value)
     
class JVMFloatInfo(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.value = self.readFloat("value")
        
    def __str__(self):
        return str(self.value)
     
class JVMLongInfo(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.value = self.readLong("value")
        
    def __str__(self):
        return str(self.value)

     
class JVMDoubleInfo(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.value = self.readDouble("value")
        
    def __str__(self):
        return str(self.value)
      
class JVMClassReference(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.index = self.readShort("index")
        
    def __str__(self):
        return str(self.poolContent.get(self.index))
        
class JVMStringReference(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.index = self.readShort("index")
        
    def __str__(self):
        return '"'+str(self.poolContent.get(self.index))+'"'
        
class JVMFieldReference(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.classReference   = self.readShort("classReference")
        self.nameAndType      = self.readShort("nameAndType")
        
    def __str__(self):
        return str(self.poolContent.get(self.classReference))+"."+str(self.poolContent.get(self.nameAndType))
    
class JVMMethodReference(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.classReference   = self.readShort("classReference")
        self.nameAndType      = self.readShort("nameAndType")
        
    def __str__(self):
        return str(self.poolContent.get(self.classReference))+"."+str(self.poolContent.get(self.nameAndType))
        
class JVMInterfaceMethodReference(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.classReference   = self.readShort("classReference")
        self.nameAndType      = self.readShort("nameAndType")
        
    def __str__(self):
        return str(self.poolContent.get(self.classReference))+"."+str(self.poolContent.get(self.nameAndType))
        
class JVMNameAndTypeDescriptor(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.identifier            = self.readShort("identifier")
        self.encodedTypeDescriptor = self.readShort("encodedTypeDescriptor")
        
    def __str__(self):
        return str(self.poolContent.get(self.identifier))#+"("+str(self.poolContent[self.encodedTypeDescriptor])+")"
        
class JVMMethodHandle(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.kind  = self.readShort("kind")
        self.index = self.readShort("index")
        
    def __str__(self):
        try:
            return str(self.poolContent.get(self.index))
        except Exception:
            return "==Error Parsing=="
        
class JVMMethodType(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.index = self.readShort("index")
        
    def __str__(self):
        try:
            return str(self.poolContent.get(self.index))
        except Exception:
            return "==Error Parsing=="

class JVMInvokeDynamic(JVMStructure):

    def __init__(self,r):
        JVMStructure.__init__(self, r)
        self.poolContent = self.classReader.constantPool
        self.read()
        
    def read(self):
        self.tag   = self.readByte("tag")
        self.bootstrap = self.readShort("bootstrap")
        self.nat = self.readShort("nat")         
        
    def __str__(self):
        #try:
            #str(self.poolContent[self.nat])
            tpl = self.classReader.getBootstrap(self.bootstrap)
            mtd = self.poolContent.get(tpl[0])
            pars = [str(self.poolContent.get(tpl[2][i])) for i in range(tpl[1])]
            if str(mtd) == "java/lang/invoke/LambdaMetafactory.metafactory": #probably not a good idea to work with the serialized version here, doesn't really matter though
                return str(mtd)+" "+pars[1]
            else:
                return str(mtd)+" "+str(pars)
        #except Exception:
        #    return "==Error Parsing=="
        
class JVMFieldInfo(JVMStructure):
        
    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
        
    def read(self):
        self.access_flags = self.readShort("access_flags")
        self.name_index   = self.readShort("name_index")
        self.descriptor_index = self.readShort("descriptor_index")
        self.attributes_count = self.readShort("attributes_count")
        self.attributes = [None]*self.attributes_count
        for i in range(self.attributes_count):
            self.attributes[i] = self.readStruct(JVMAttributeInfo(self.classReader), "attribute["+str(i)+"]")
            
class JVMMethodInfo(JVMStructure):

    def __init__(self, r, ind):
        JVMStructure.__init__(self, r)
        self.index = ind
        self.read()
        
    def read(self):
        self.access_flags = self.readShort("access_flags")
        self.name_index   = self.readShort("name_index")
        self.descriptor_index = self.readShort("descriptor_index")
        self.attributes_count = self.readShort("attributes_count")
        self.attributes = [None]*self.attributes_count
        self.code_attribute = None
        for i in range(self.attributes_count):
            self.attributes[i] = self.readStruct(JVMAttributeInfo(self.classReader),"attribute["+str(i)+"]")
            if self.attributes[i].attributeType == "Code":
                self.code_attribute = self.attributes[i]
             
        # register as method if method info has code
        if self.code_attribute != None:
            start_address = self.code_attribute.attribute.start_address
            end_address = self.code_attribute.attribute.end_address
            name = str(self.classReader.constantPool.poolContent[self.name_index])
            if name in self.classReader.registeredMethodList:
                orig_name = name
                posfix = 1
                name = orig_name+"("+str(posfix)+")"
                while name in self.classReader.registeredMethodList:
                    posfix += 1
                    name = orig_name+"("+str(posfix)+")"
            self.classReader.registeredMethodList.append(name)
            self.classReader.view.add_auto_segment(0x1000000+0x100000*self.index, end_address-start_address, start_address, end_address-start_address, SegmentFlag.SegmentReadable |  SegmentFlag.SegmentExecutable)
            self.classReader.view.add_function(0x1000000+0x100000*self.index) #register function
            self.classReader.view.define_auto_symbol(Symbol(SymbolType.FunctionSymbol, 0x1000000+0x100000*self.index, name))            
            

class JVMAttributeInfo(JVMStructure):
    
    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.attribute_name_index = self.readShort("attribute_name_index")
        self.attribute_length   = self.readInt("attribute_length")
        self.attributeType = str(self.classReader.constantPool.get(self.attribute_name_index))
        self.attribute            = None 
        if self.attributeType == "Code":
            self.attribute = self.readStruct(JVMCodeAttribute(self.classReader),"attribute")
        elif self.attributeType == "BootstrapMethods":
            self.attribute = self.readStruct(JVMBootstrapMethods(self.classReader),"attribute")
        elif self.attributeType == "ConstantValue":
            self.attribute = self.readStruct(JVMConstantValueAttribute(self.classReader),"attribute")
        elif self.attributeType == "Exceptions":
            self.attribute = self.readStruct(JVMExceptionsAttribute(self.classReader),"attribute")
        elif self.attributeType == "InnerClasses":
            self.attribute = self.readStruct(JVMInnerClassesAttribute(self.classReader),"attribute")
        elif self.attributeType == "EnclosingMethod":
            self.attribute = self.readStruct(JVMEnclosingMethodAttribute(self.classReader),"attribute")
        elif self.attributeType == "Synthetic":
            self.attribute = self.readStruct(JVMSyntheticAttribute(self.classReader),"attribute")
        elif self.attributeType == "Signature":
            self.attribute = self.readStruct(JVMSignatureAttribute(self.classReader),"attribute")
        elif self.attributeType == "SourceFile":
            self.attribute = self.readStruct(JVMSourceFileAttribute(self.classReader),"attribute")
        elif self.attributeType == "LineNumberTable":
            self.attribute = self.readStruct(JVMLineNumberTableAttribute(self.classReader),"attribute")
        elif self.attributeType == "LocalVariableTable":
            self.attribute = self.readStruct(JVMLocalVariableTableAttribute(self.classReader),"attribute")
        elif self.attributeType == "Deprecated":
            self.attribute = self.readStruct(JVMDeprecatedAttribute(self.classReader),"attribute")
        else:
            self.readArray(self.attribute_length, "attribute")
 
class JVMDeprecatedAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        pass
        
class JVMLocalVariableTypeTableAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.local_variable_type_table_length  = self.readShort("local_variable_type_table_length")
        self.local_variable_type_table = []
        for i in range(self.local_variable_type_table_length):
            self.local_variable_type_table.append([self.readShort("start_pc["+str(i)+"]"),self.readShort("length["+str(i)+"]"),self.readShort("name_index["+str(i)+"]"),self.readShort("signature_index["+str(i)+"]"),self.readShort("index["+str(i)+"]")])
 
class JVMLocalVariableTableAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.local_variable_table_length  = self.readShort("local_variable_table_length")
        self.local_variable_table = []
        for i in range(self.local_variable_table_length):
            self.local_variable_table.append([self.readShort("start_pc["+str(i)+"]"),self.readShort("length["+str(i)+"]"),self.readShort("name_index["+str(i)+"]"),self.readShort("descriptor_index["+str(i)+"]"),self.readShort("index["+str(i)+"]")])
  
class JVMLineNumberTableAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.line_number_table_length  = self.readShort("line_number_table_length")
        self.line_number_table = []
        for i in range(self.line_number_table_length):
            self.line_number_table.append([self.readShort("start_pc["+str(i)+"]"),self.readShort("line_number["+str(i)+"]")])

#SourceDebugExtension 
 
class JVMSourceFileAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.sourcefile_index  = self.readShort("sourcefile_index")
        
 
class JVMSignatureAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.signature_index  = self.readShort("signature_index")
        
 
class JVMSyntheticAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        pass
 
class JVMEnclosingMethodAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.class_index  = self.readShort("class_index")
        self.method_index = self.readShort("method_index")
        
class JVMInnerClassesAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.number_of_classes = self.readShort("number_of_classes")
        self.classes = []
        for i in range(self.number_of_classes):
            self.classes.append([self.readShort("inner_class_info_index["+str(i)+"]"),self.readShort("outer_class_info_index["+str(i)+"]"),self.readShort("inner_name_index["+str(i)+"]"),self.readShort("inner_class_access_flags["+str(i)+"]")])
            
class JVMExceptionsAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.number_of_exceptions = self.readShort("number_of_exceptions")
        self.exception_index_table = []
        for i in range(self.number_of_exceptions):
            self.exception_index_table.append(self.readShort("exception_index_table["+str(i)+"]"))
        
class JVMConstantValueAttribute(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.constantvalue_index  = self.readShort("constantvalue_index")
        
        
class JVMCodeAttribute(JVMStructure):
    
    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
    
    def read(self):
        self.max_stack = self.readShort("max_stack")
        self.max_locals = self.readShort("max_locals")
        self.code_length = self.readInt("code_length")
        self.start_address = self.classReader.index()
        self.code = self.readArray(self.code_length,"code")
        self.end_address = self.classReader.index()
        self.exception_table_length = self.readShort("exception_table_length")
        self.exception_table = []
        for i in range(self.exception_table_length):
            # TODO Exception structure
            self.exception_table.append((self.readShort("start_pc["+str(i)+"]"),self.readShort("end_pc["+str(i)+"]"),self.readShort("handler_pc["+str(i)+"]"),self.readShort("catch_type["+str(i)+"]")))
        self.attributes_count = self.readShort("attributes_count")
        self.attributes = []
        for i in range(self.attributes_count):
            self.attributes.append(self.readStruct(JVMAttributeInfo(self.classReader),"attribute["+str(i)+"]"))

class JVMBootstrapMethods(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
        
    def read(self):
        self.num_bootstrap_methods = self.readShort("num_bootstrap_methods")
        self.bootstrap_methods = []
        for i in range(self.num_bootstrap_methods):
            bootstrap_method_ref = self.readShort("bootstrap_method_ref["+str(i)+"]")
            num_bootstrap_arguments = self.readShort("num_bootstrap_arguments["+str(i)+"]")
            bootstrap_arguments = []
            for j in range(num_bootstrap_arguments):
                bootstrap_arguments.append(self.readShort("bootstrap_arguments["+str(j)+"]"))
            self.bootstrap_methods.append([bootstrap_method_ref,num_bootstrap_arguments,bootstrap_arguments])
            
class JVMClassStructure(JVMStructure):

    def __init__(self, r):
        JVMStructure.__init__(self, r)
        self.read()
        
    def read(self):
        self.magic           = self.readInt("magic")
        self.minor_version   = self.readShort("minor_version")
        self.major_version   = self.readShort("major_version")
        self.constant_pool_count = self.readShort("constant_pool_count")
        self.constantPool    = self.readStruct(JVMConstantPool(self.classReader, self.constant_pool_count), "constantPool")
        self.access_flags    = self.readShort("access_flags")
        self.this_class      = self.readShort("this_class")
        self.super_class     = self.readShort("super_class")
        self.interface_count = self.readShort("interface_count")
        self.interfaces      = []
        for i in range(self.interface_count):
            self.interfaces.append(self.readShort("interface["+str(i)+"]"))
        self.fields_count = self.readShort("fields_count")
        self.fields          = []
        for i in range(self.fields_count):
            self.fields.append(self.readStruct(JVMFieldInfo(self.classReader),"field["+str(i)+"]"))
        self.methods_count = self.readShort("methods_count")
        self.methods         = []
        for i in range(self.methods_count):
            self.methods.append(self.readStruct(JVMMethodInfo(self.classReader, i),"method["+str(i)+"]"))
        self.attributes_count = self.readShort("attributes_count")
        self.attributes      = []
        for i in range(self.attributes_count):
            attr = self.readStruct(JVMAttributeInfo(self.classReader),"attribute["+str(i)+"]")
            self.attributes.append(attr)
            if attr.attributeType == "BootstrapMethods":
                self.classReader.setBootstrap(attr)
        
        
class JVMClassReader():
    def __init__(self,vi,da):
        self.view = vi
        self.data = da
        self.idx = 0    
        self.classStruct = None
        self.constantPool = None
        self.bootstrap_attribute = None
        self.registeredMethodList = []
    def reset(self):
        self.idx = 0
    def readLong(self):
        value = struct.unpack(">Q", self.data.read(self.idx,8))[0]
        self.idx += 8
        return value
    def readDouble(self):
        value = struct.unpack(">d", self.data.read(self.idx,8))[0]
        self.idx += 8
        return value
    def readFloat(self):
        value = struct.unpack(">f", self.data.read(self.idx,4))[0]
        self.idx += 4
        return value
    def readInt(self):
        value = struct.unpack(">I", self.data.read(self.idx,4))[0]
        self.idx += 4
        return value
    def readShort(self):
        value = struct.unpack(">H", self.data.read(self.idx,2))[0]
        self.idx += 2
        return value
    def readByte(self):
        value = struct.unpack("B", self.data.read(self.idx,1))[0]
        self.idx += 1
        return value
    def index(self):
        return self.idx
        
    #This is some special Dynamic Invocation code
    def setBootstrap(self,attr):
        self.bootstrap_attribute = attr
      
    def getBootstrap(self,index):
        if self.bootstrap_attribute == None: return None
        return self.bootstrap_attribute.attribute.bootstrap_methods[index]

def completeUpdateWhenDone(self):
    for f in self.view.functions:
        analyze_tables(self.view, f)
        analyze_references(self.view, f)
        
class UpdateReferences(BinaryDataNotification):
    def function_updated(self,view, func):
        analyze_references(view, func)
        pass
        
def analyze_references(view, dispatcher):
    table_constantpool = []
    table_primitives = []
    find_poolRef = []
    find_primRef = []
    for i, name in enumerate(InstructionNames):
        if InstructionFormat[i] == TYPE_LDC:
            find_poolRef.append(name)
        if InstructionFormat[i] == TYPE_2INDEX:
            find_poolRef.append(name)
        if InstructionFormat[i] == TYPE_INTERFACE:
            find_poolRef.append(name)
        if InstructionFormat[i] == TYPE_DYNAMIC:
            find_poolRef.append(name)
        if InstructionFormat[i] == TYPE_ATYPE:
            find_primRef.append(name)
        if InstructionFormat[i] == TYPE_MULTIARRAY:
            find_poolRef.append(name)  
            
    for token,addr in dispatcher.instructions:
        if len(token) == 0: continue
        t = str(token[0]).strip()
        if t in find_poolRef:
            table_constantpool.append(addr)
        elif t in find_primRef:
            table_primitives.append(addr)
                
    for addr in table_constantpool:
        decoded = decode_instruction(view.read(addr, 10), addr)
        value = decoded[3]
        if type(value) == type([]): value = value[0]
        if type(value) == type((0,0)): value = value[0]
        if dispatcher.get_int_display_type(addr,value+PSEUDOMEMORY_TABLE,0) != IntegerDisplayType.PointerDisplayType:
            dispatcher.set_int_display_type(addr,value+PSEUDOMEMORY_TABLE,0,IntegerDisplayType.PointerDisplayType)
            
    for addr in table_primitives:
        decoded = decode_instruction(view.read(addr, 10), addr)
        value = decoded[3]
        if type(value) == type([]): value = value[0]
        if type(value) == type((0,0)): value = value[0]
        if dispatcher.get_int_display_type(addr,value+PSEUDOMEMORY_PRIMITIVES,0) != IntegerDisplayType.PointerDisplayType:
            dispatcher.set_int_display_type(addr,value+PSEUDOMEMORY_PRIMITIVES,0,IntegerDisplayType.PointerDisplayType)
        
            
def analyze_tables(view, dispatcher):
    table_jumps = []
    
    for token,addr in dispatcher.instructions:
        if ('lookupswitch' in str(token[0]) or 'tableswitch' in str(token[0])):
            table_jumps.append(addr)
            
    for addr in table_jumps:
        #if len(dispatcher.get_indirect_branches_at(addr)) != 0:
        #    continue
        data = view.read(addr, 128)
        decoded = decode_instruction(data, addr)
        if decoded[0] == None:
            data = view.read(addr, decoded[3])
            decoded = decode_instruction(data, addr)
        if decoded[0] == "lookupswitch":
            pair_array = 2
        elif decoded[0] == "tableswitch":
            pair_array = 3
            
        value = decoded[3]
        branches = []
        for p in value[pair_array]:
            branches.append((view.arch,p[1]))
        branches.append((view.arch, value[0]))
        dispatcher.set_user_indirect_branches(addr, branches)
        
        #Do comments later as they update the binary
        dispatcher.set_comment_at(value[0], "Default Branch")
        for p in value[pair_array]:
            ad = ""
            if p[1] == value[0]:
                ad = " [Default Branch]"
            dispatcher.set_comment_at(p[1], "Branch Condition: "+str(p[0])+ad)
    
class ClassView(BinaryView):
    name = "JVM Class"
    long_name = "JVM Class Format"

    def __init__(self, data):
        BinaryView.__init__(self, parent_view = data, file_metadata = data.file)
        self.platform = Architecture['JVM'].standalone_platform
        
    @classmethod
    def is_valid_for_data(self, data):
        hdr = data.read(0, 6)
        if len(hdr) < 4:
            return False
        if struct.unpack(">I", hdr[0:4])[0] != 0xCAFEBABE:
            return False
        return True

    def init(self):
        try:
            self.cR = JVMClassReader(self,self.parent_view)
            
            self.cR.charType = self.parse_type_string("char")[0] # for some reason in my binary ninja version Type.char() is not accessable
            
            classStruct = JVMClassStructure(self.cR) # read class structure and add symbols
            self.cR.classStruct = classStruct
           
            self.define_data_var(0,  classStruct.resultingType())
                
            
            self.add_auto_segment(0, self.cR.index(), 0, self.cR.index(), SegmentFlag.SegmentReadable)
            self.add_auto_section("<data>",0, self.cR.index(), SectionSemantics.ReadOnlyCodeSectionSemantics)
            
            for i in range(len(self.cR.constantPool.poolContent)):
                content = self.cR.constantPool.poolContent[i]
                t = SymbolType.DataSymbol
                if ("instance" in str(type(content))) or ("jvm" in str(type(content))):
                    if content.__class__ == JVMMethodReference or content.__class__ == JVMInterfaceMethodReference or content.__class__ == JVMInvokeDynamic:
                        t = SymbolType.ImportAddressSymbol
                    elif content.__class__ == JVMStringReference:
                        t = SymbolType.DataSymbol
                    elif content.__class__ == JVMUTF8Info:
                        t = SymbolType.DataSymbol
                elif "str" in str(type(content)):
                    t = SymbolType.DataSymbol
               
                if t == SymbolType.ImportAddressSymbol:
                    self.define_user_symbol(Symbol(t, i+PSEUDOMEMORY_TABLE, str(content), full_name=str(content)))
                else:
                    self.define_user_symbol(Symbol(t, i+PSEUDOMEMORY_TABLE, str(content), full_name="pool_"+str(i)))
                
            primitive_names = ["Not Used","Not Used","Not Used","Not Used","Boolean","Char","Float","Double","Byte","Short","Int","Long"]
            for i in range(4,12):
                self.define_user_symbol(Symbol(SymbolType.DataSymbol, i+PSEUDOMEMORY_PRIMITIVES, primitive_names[i], full_name="primitive_"+str(i)))
                
            self.add_analysis_completion_event(completeUpdateWhenDone)
            self.register_notification(UpdateReferences())
            
            return True
        except:
            print(traceback.format_exc())
            return False
        
    def perform_is_executable(self):
        return True

    def perform_get_entry_point(self):
        return 0x10000000
        


JVM.register()
ClassView.register()

```

`binary-jvm/plugin.json`:

```json
{
    "plugin": {
        "name": "Java Bytecode Disassembler",
        "type": ["architecture", "binaryview"],
        "api": "python2",
        "description": "Java Bytecode Architecture + Java Class File Binaryview",
        "license": {
            "name": "BSD-0-clause"
        },
        "version": "1.0",
        "author": "Pusty"
    }
}
```

`binary-xtensa/XTENSAArch.py`:

```py
#!/usr/bin/env python

import re

from binaryninja.log import log_info
from binaryninja.architecture import Architecture
from binaryninja.function import RegisterInfo, InstructionInfo, InstructionTextToken
from binaryninja.enums import InstructionTextTokenType, BranchType, FlagRole


from .XTENSADIS import *

class XTENSA(Architecture):
    name = 'XTENSA'

    address_size = 4
    default_int_size = 4
    instr_alignment = 3
    max_instr_length = 3

    # register related stuff
    regs = {
        # main registers
        'a0': RegisterInfo('a0', 4),
        'a1': RegisterInfo('a1', 4),
        'a2': RegisterInfo('a2', 4),
        'a3': RegisterInfo('a3', 4),
        'a4': RegisterInfo('a4', 4),
        'a5': RegisterInfo('a5', 4),
        'a6': RegisterInfo('a6', 4),
        'a7': RegisterInfo('a7', 4),
        'a8': RegisterInfo('a8', 4),
        'a9': RegisterInfo('a9', 4),
        'a10': RegisterInfo('a10', 4),
        'a11': RegisterInfo('a11', 4),
        'a12': RegisterInfo('a12', 4),
        'a13': RegisterInfo('a13', 4),
        'a14': RegisterInfo('a14', 4),
        'a15': RegisterInfo('a15', 4),

        # program counter
        'pc': RegisterInfo('pc', 4),

        # special status
        'sar': RegisterInfo('sar', 4)
    }

    stack_pointer = "a1"

#------------------------------------------------------------------------------
# CFG building
#------------------------------------------------------------------------------

    def get_instruction_info(self, data, addr):
        if len(data) < 2 or len(data) > 3: return None
        obj = decode(data, addr)
        if obj.name == "UNKNOWN": return None
        result = InstructionInfo()
        result.length = obj.len
        
        if obj.name in ["RET", "RET.N"]:
            # RETURN
            result.add_branch(BranchType.FunctionReturn)
            
        if obj.name in ["BALL", "BNALL", "BANY", "BNONE", "BBC", "BBCI", "BBS", "BBSI", "BEQ", "BEQI", "BEQZ", "BNE", "BNEI", "BNEZ", "BGE", "BGEI", "BGEU", "BGEUI", "BGEZ", "BLT", "BLTI", "BLTU", "BLTUI", "BLTZ"]:
            # CONDITIONAL BRANCH
            for l in obj.prop["format"]:
                if l[0] == "TYPE_LABEL":
                    result.add_branch(BranchType.TrueBranch, l[1])
            result.add_branch(BranchType.FalseBranch, addr + obj.len)

        if obj.name in ["J"]:
            # UNCONDITIONAL JUMP
            for l in obj.prop["format"]:
                if l[0] == "TYPE_LABEL":
                    result.add_branch(BranchType.UnconditionalBranch, l[1])
            
        if obj.name in ["CALL0", "CALL4", "CALL8", "CALL12"]:
            # DIRECT CALL
            for l in obj.prop["format"]:
                if l[0] == "TYPE_LABEL":
                    result.add_branch(BranchType.CallDestination, l[1])

        if obj.name in ["JX"]:
            # UNCONDITIONAL JUMP TO REGISTER
            result.add_branch(BranchType.IndirectBranch)    
            
        #if obj.name in ["CALLX0", "CALLX4", "CALLX8", "CALLX12"]:
            # CALL TO REGISTER
        #    result.add_branch(BranchType.IndirectBranch)   
        
        return result
        
        
        
        

    def get_instruction_text(self, data, addr):
        if len(data) < 2 or len(data) > 3: return None
        obj = decode(data, addr)
        if obj.name == "UNKNOWN": return None
        result = []
        result.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, obj.name))
        
        li = obj.prop["format"]
        for i in range(len(li)):
            result.append(InstructionTextToken(InstructionTextTokenType.OperandSeparatorToken, ' '))
            l = li[i]
            if l[0] == "TYPE_REG":
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "a"+str(l[1])))
            elif l[0] == "TYPE_FREG":
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "f"+str(l[1])))    
            elif l[0] == "TYPE_BREG":
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "b"+str(l[1])))    
            elif l[0] == "TYPE_SREG":
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "s"+str(l[1])))    
            elif l[0] == "TYPE_UREG":
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "u"+str(l[1])))    
            elif l[0] == "TYPE_MREG":
                result.append(InstructionTextToken(InstructionTextTokenType.RegisterToken, "m"+str(l[1]))) 
            elif l[0] == "TYPE_IMM":
                result.append(InstructionTextToken(InstructionTextTokenType.IntegerToken, str(l[1]), l[1])) 
            elif l[0] == "TYPE_LABEL":
                result.append(InstructionTextToken(InstructionTextTokenType.CodeRelativeAddressToken, '0x%08x' % (l[1]), l[1]))  # PossibleAddressToken?
                
            if i < len(li)-1:
                result.append(InstructionTextToken(InstructionTextTokenType.OperandSeparatorToken, ','))
        
        return result, obj.len
        
    def get_flag_write_low_level_il(self, op, size, write_type, flag, operands, il):
        return Architecture.get_flag_write_low_level_il(self, op, size, write_type, flag, operands, il)

    def get_instruction_low_level_il(self, data, addr, il):
        if len(data) < 2 or len(data) > 3: return None
        obj = decode(data, addr)
        if obj.name == "UNKNOWN": return None
        il.append(il.unimplemented())
        return obj.len

```

`binary-xtensa/XTENSADIS.py`:

```py
import struct

class XTENSA_INSTRUCTION():
    name = "UNKNOWN"
    len  = 3
    
instructions = """
ABS              RRR   0110 0000 rrrr 0001 tttt 0000 ABS ar, at
ABS.S            RRR   1111 1010 rrrr ssss 0001 0000 ABS.S fr, fs
ADD              RRR   1000 0000 rrrr ssss tttt 0000 ADD ar, as, at
ADD.N            RRRN            rrrr ssss tttt 1010 ADD.N ar, as, at
ADD.S            RRR   0000 1010 rrrr ssss tttt 0000 ADD.S fr, fs, ft
ADDI             RRI8  iiii iiii 1100 ssss tttt 0010 ADDI at, as, -128..127
ADDI.N           RRRN            rrrr ssss tttt 1011 ADDI.N ar, as, imm
ADDMI            RRI8  iiii iiii 1101 ssss tttt 0010 ADDMI at, as, -32768..32512
ADDX2            RRR   1001 0000 rrrr ssss tttt 0000 ADDX2 ar, as, at
ADDX4            RRR   1010 0000 rrrr ssss tttt 0000 ADDX4 ar, as, at
ADDX8            RRR   1011 0000 rrrr ssss tttt 0000 ADDDX ar, as, at
ALL4             RRR   0000 0000 1001 ssss tttt 0000 ALL4 bt, bs
ALL8             RRR   0000 0000 1011 ssss tttt 0000 ALL8 bt, bs
AND              RRR   0001 0000 rrrr ssss tttt 0000 AND ar, as, at
ANDB             RRR   0000 0010 rrrr ssss tttt 0000 ANDB br, bs, bt
ANDBC            RRR   0001 0010 rrrr ssss tttt 0000 ANDBC br, bs, bt
ANY4             RRR   0000 0000 1000 ssss tttt 0000 ANY4 bt, bs
ANY8             RRR   0000 0000 1010 ssss tttt 0000 ANY8 bt, bs
BALL             RRI8  iiii iiii 0100 ssss tttt 0111 BALL as, at, label
BANY             RRI8  iiii iiii 1000 ssss tttt 0111 BANY as, at, label
BBC              RRI8  iiii iiii 0101 ssss tttt 0111 BBC as, at, label
BBCI             RRI8  iiii iiii 011b ssss bbbb 0111 BBCI as, 0..31, label
BBS              RRI8  iiii iiii 1101 ssss tttt 0111 BBS as, at, label
BBSI             RRI8  iiii iiii 111b ssss bbbb 0111 BBSI as, 0..31, label
BEQ              RRI8  iiii iiii 0001 ssss tttt 0111 BEQ as, at, label
BEQI             RRI8  iiii iiii rrrr ssss 0010 0110 BEQI as, imm, label
BEQZ             RRI12 iiii iiii iiii ssss 0001 0110 BEQZ as, label
BEQZ.N           R16             iiii ssss 10ii 1100 BEQZ.N as, label
BF               RRI8  iiii iiii 0000 ssss 0111 0110 BF bs, label
BGE              RRI8  iiii iiii 1010 ssss tttt 0111 BGE as, at, label
BGEI             BRI8  iiii iiii rrrr ssss 1110 0110 BGEI as, imm, label
BGEU             RRI8  iiii iiii 1011 ssss tttt 0111 BGEU as, at, label
BGEUI            BRI8  iiii iiii rrrr ssss 1111 0110 BGEUI as, imm, label
BLT              RRI8  iiii iiii 0010 ssss tttt 0111 BLT as, at, label
BLTI             BRI8  iiii iiii rrrr ssss 1010 0110 BLTI as, imm, label
BLTU             RRI8  iiii iiii 0011 ssss tttt 0111 BLTU as, at, label
BLTUI            BRI8  iiii iiii rrrr ssss 1011 0110 BLTUI as, imm, label
BLTZ             BRI12 iiii iiii iiii ssss 1001 0110 BLTZ as, label
BNALL            RRI8  iiii iiii 1100 ssss tttt 0111 BNALL as, at, label
BNE              RRI8  iiii iiii 1001 ssss tttt 0111 BNE as, at, label
BNEI             BRI8  iiii iiii rrrr ssss 0110 0110 BNEI as, imm, label
BNEZ             BRI12 iiii iiii iiii ssss 0101 0110 BNEZ as, label
BNEZ.N           RI6             iiii ssss 11ii 1100 BNEZ.N as, label
BNONE            RRI8  iiii iiii 0000 ssss tttt 0111 BNONE as, at, label
BREAK            RRR   0000 0000 0100 ssss tttt 0000 BREAK 0..15, 0..15
BREAK.N          RRRN            1111 ssss 0010 1101 BREAK.N 0..15
BT               RRI8  iiii iiii 0001 ssss 0111 0110 BT bs, label
CALL0            CALL  oooo oooo oooo oooo oo00 0101 CALL0 label
CALL4            CALL  oooo oooo oooo oooo oo01 0101 CALL4 label
CALL8            CALL  oooo oooo oooo oooo oo10 0101 CALL8 label
CALL12           CALL  oooo oooo oooo oooo oo11 0101 CALL12 label
CALLX0           CALLX 0000 0000 0000 ssss 1100 0000 CALLX0 as
CALLX4           CALLX 0000 0000 0000 ssss 1101 0000 CALLX4 as
CALLX8           CALLX 0000 0000 0000 ssss 1110 0000 CALLX8 as
CALLX12          CALLX 0000 0000 0000 ssss 1111 0000 CALLX12 as
CEIL.S           RRR   1011 1010 rrrr ssss tttt 0000 CEIL.S ar, fs, 0..15
CLAMPS           RRR   0011 0011 rrrr ssss tttt 0000 CLAMPS ar, as, 7..22
DHI              RRI8  iiii iiii 0111 ssss 0110 0010 DHI as, 0..1020
DHU              RRI4  iiii 0010 0111 ssss 1000 0010 DHU as, 0..240
DHWB             RRI8  iiii iiii 0111 ssss 0100 0010 DHWB as, 0..1020
DHWBI            RRI8  iiii iiii 0111 ssss 0101 0010 DHWBI as, 0..1020
DII              RRI8  iiii iiii 0111 ssss 0111 0010 DII as, 0..1020
DIU              RRI4  iiii 0011 0111 ssss 1000 0010 DIU as, 0..240
DIWB             RRI4  iiii 0100 0111 ssss 1000 0010 DIWB as, 0..240
DIWBI            RRi4  iiii 0101 0111 ssss 1000 0010 DIWBI as, 0..240
DPFL             RRI4  iiii 0000 0111 ssss 1000 0010 DPFL as, 0..240
DPFR             RRI8  iiii iiii 0111 ssss 0000 0010 DPFR as, 0..1020
DPFRO            RRI8  iiii iiii 0111 ssss 0010 0010 DPFRO as, 0..1020
DPFW             RRI8  iiii iiii 0111 ssss 0001 0010 DPFW as, 0..1020
DPFWO            RRI8  iiii iiii 0111 ssss 0011 0010 DPFWO as, 0..1020
DSYNC            RRR   0000 0000 0010 0000 0011 0000 DSYNC
ENTRY            BRI12 iiii iiii iiii ssss 0011 0110 ENTRY as, 0..32760
ESYNC            RRR   0000 0000 0010 0000 0010 0000 ESYNC
EXCW             RRR   0000 0000 0010 0000 1000 0000 EXCW
EXTUI            RRR   pppp 010i rrrr iiii tttt 0000 EXTUI ar, at, shiftimm, maskimm
EXTW             RRR   0000 0000 0010 0000 1101 0000 EXTW
FLOAT.S          RRR   1100 1010 rrrr ssss tttt 0000 FLOAT.S fr, as, 0..15
FLOOR.S          RRR   1010 1010 rrrr ssss tttt 0000 FLOOR.S ar, fs, 0..15
IDTLB            RRR   0101 0000 1100 ssss 0000 0000 IDTLB as
IHI              RRI8  iiii iiii 0111 ssss 1110 0010 IHI as, 0..1020
IHU              RRI4  iiii 0010 0111 ssss 1101 0010 IHU as, 0..240
III              RRI8  iiii iiii 0111 ssss 1111 0010 III as, 0..1020
IITLB            RRR   0101 0000 0100 ssss 0000 0000 IITLB as
IIU              RRI4  iiii 0011 0111 ssss 1101 0010 IIU as, 0..240
ILL              CALLX 0000 0000 0000 0000 0000 0000 ILL
ILL.N            RRRN            1111 0000 0110 1101 ILL.N
IPF              RRI8  iiii iiii 0111 ssss 1100 0010 IPF as, 0..1020
IPFL             RRI4  iiii 0000 0111 ssss 1101 0010 IPFL as, 0..240
ISYNC            RRR   0000 0000 0010 0000 0000 0000 ISYNC
J                CALL  oooo oooo oooo oooo oo00 0110 J label
JX               CALLX 0000 0000 0000 ssss 1010 0000 JX as
L8UI             RRI8  iiii iiii 0000 ssss tttt 0010 L8UI at, as, 0..255
L16SI            RRI8  iiii iiii 1001 ssss tttt 0010 L16SI at, as, 0..510
L16UI            RRI8  iiii iiii 0001 ssss tttt 0010 L16UI at, as, 0..510
L32AI            RRI8  iiii iiii 1011 ssss tttt 0010 L32AI at, as, 0..1020
L32E             RRI4  0000 1001 rrrr ssss tttt 0000 L32E at, as, -64..-4
L32I             RRI8  iiii iiii 0010 ssss tttt 0010 L32I at, as, 0..1020
L32I.N           RRRN            iiii ssss tttt 1000 L32I.N at, as, 0..60
L32R             R16   iiii iiii iiii iiii tttt 0001 L32R at, label
LDCT             RRR   1111 0001 1000 ssss tttt 0000 LDCT at, as
LDDEC            RRR   1001 0000 00ww ssss 0000 0100 LDDEC mw, as
LDINC            RRR   1000 0000 00ww ssss 0000 0100 LDINC mw, as
LICT             RRR   1111 0001 0000 ssss tttt 0000 LICT at, as
LICW             RRR   1111 0001 0010 ssss tttt 0000 LICW at, as
LOOP             RRI8  iiii iiii 1000 ssss 0111 0110 LOOP as, label
LOOPGTZ          RRI8  iiii iiii 1010 ssss 0111 0110 LOOPGTZ as, label
LOOPNEZ          RRI8  iiii iiii 1001 ssss 0111 0110 LOOPNEZ as ,label
LSI              RRI8  iiii iiii 0000 ssss tttt 0011 LSI ft, as, 0..1020
LSIU             RRI8  iiii iiii 1000 ssss tttt 0011 LSIU ft, as, 0,..1020
LSX              RRR   0000 1000 rrrr ssss tttt 0000 LSX fr, as, at
LSXU             RRR   0001 1000 rrrr ssss tttt 0000 LSXU fr, as, at
MADD.S           RRR   0100 1010 rrrr ssss tttt 0000 MADD.S fr, fs, ft
MAX              RRR   0101 0011 rrrr ssss tttt 0000 MAX ar, as, at
MAXU             RRR   0111 0011 rrrr ssss tttt 0000 MAXU ar, as, at
MEMW             RRR   0000 0000 0010 0000 1100 0000 MEMW
MIN              RRR   0100 0011 rrrr ssss tttt 0000 MIN ar, as, at
MINU             RRR   0110 0011 rrrr ssss tttt 0000 MINU ar, as, at
MOV.N            RRRN            0000 ssss tttt 1101 MOV.N at, as
MOV.S            RRR   1111 1010 rrrr ssss 0000 0000 MOV.S fr, fs
MOVEQZ           RRR   1000 0011 rrrr ssss tttt 0000 MOVEQZ ar, as ,at
MOVEQZ.S         RRR   1000 1011 rrrr ssss tttt 0000 MOVEQZ.S fr, fs, at
MOVF             RRR   1100 0011 rrrr ssss tttt 0000 MOVF ar, as, bt
MOVF.S           RRR   1100 1011 rrrr ssss tttt 0000 MOVF.S fr, fs, bt
MOVGEZ           RRR   1011 0011 rrrr ssss tttt 0000 MOVGEZ ar, as, at
MOVGEZ.S         RRR   1011 1011 rrrr ssss tttt 0000 MOVGEZ.S fr, fs, at
MOVI             RRI8  iiii iiii 1010 iiii tttt 0010 MOVI at, -2048..2047
MOVI.N           RI7             iiii ssss 0iii 1100 MOVI.N as, -32..95
MOVLTZ           RRR   1010 0011 rrrr ssss tttt 0000 MOVLTZ ar, as, at
MOVLTZ.S         RRR   1010 1011 rrrr ssss tttt 0000 MOVLTZ.S fr, fs, at
MOVNEZ           RRR   1001 0011 rrrr ssss tttt 0000 MOVNEZ ar, as, at
MOVNEZ.S         RRR   1001 1011 rrrr ssss tttt 0000 MOVNEZ.S fr, fs, at
MOVSP            RRR   0000 0000 0001 ssss tttt 0000 MOVSP at, as
MOVT             RRR   1101 0011 rrrr ssss tttt 0000 MOVT ar, as, bt
MOVT.S           RRR   1101 1011 rrrr ssss tttt 0000 MOVT.S fr, fs, bt
MSUB.S           RRR   0101 1010 rrrr ssss tttt 0000 MSUB.S fr, fs, ft
MUL.AA.LL        RRR   0111 0100 0000 ssss tttt 0100 MUL.AA.LL as, at
MUL.AA.HL        RRR   0111 0101 0000 ssss tttt 0100 MUL.AA.HL as, at
MUL.AA.LH        RRR   0111 0110 0000 ssss tttt 0100 MUL.AA.LH as, at
MUL.AA.HH        RRR   0111 0111 0000 ssss tttt 0100 MUL.AA.HH as, at
MUL.AD.LL        RRR   0011 0100 0000 ssss 0y00 0100 MUL.AD.LL as, my
MUL.AD.HL        RRR   0011 0101 0000 ssss 0y00 0100 MUL.AD.HL as, my
MUL.AD.LH        RRR   0011 0110 0000 ssss 0y00 0100 MUL.AD.LH as, my
MUL.AD.HH        RRR   0011 0111 0000 ssss 0y00 0100 MUL.AD.HH as, my
MUL.DA.LL        RRR   0110 0100 0x00 0000 tttt 0100 MUL.DA.LL mx, at
MUL.DA.HL        RRR   0110 0101 0x00 0000 tttt 0100 MUL.DA.HL mx, at
MUL.DA.LH        RRR   0110 0110 0x00 0000 tttt 0100 MUL.DA.LH mx, at
MUL.DA.HH        RRR   0110 0111 0x00 0000 tttt 0100 MUL.DA.HH mx, at
MUL.DD.LL        RRR   0010 0100 0x00 0000 0y00 0100 MUL.DD.LL mx, my
MUL.DD.HL        RRR   0010 0101 0x00 0000 0y00 0100 MUL.DD.HL mx, my
MUL.DD.LH        RRR   0010 0110 0x00 0000 0y00 0100 MUL.DD.LH mx, my
MUL.DD.HH        RRR   0010 0111 0x00 0000 0y00 0100 MUL.DD.HH mx, my
MUL.S            RRR   0010 1010 rrrr ssss tttt 0000 MUL.S fr, fs, ft
MUL16S           RRR   1101 0001 rrrr ssss tttt 0000 MUL16S ar, as, at
MUL16U           RRR   1100 0001 rrrr ssss tttt 0000 MUL16U ar, as, at
MULA.AA.LL       RRR   0111 1000 0000 ssss tttt 0100 MULA.AA.LL as, at
MULA.AA.HL       RRR   0111 1001 0000 ssss tttt 0100 MULA.AA.HL as, at
MULA.AA.LH       RRR   0111 1010 0000 ssss tttt 0100 MULA.AA.LH as, at
MULA.AA.HH       RRR   0111 1011 0000 ssss tttt 0100 MULA.AA.HH as, at
MULA.AD.LL       RRR   0011 1000 0000 ssss 0y00 0100 MULA.AD.LL as, my
MULA.AD.HL       RRR   0011 1001 0000 ssss 0y00 0100 MULA.AD.HL as, my
MULA.AD.LH       RRR   0011 1010 0000 ssss 0y00 0100 MULA.AD.LH as, my
MULA.AD.HH       RRR   0011 1011 0000 ssss 0y00 0100 MULA.AD.HH as, my
MULA.DA.LL       RRR   0110 1000 0x00 0000 tttt 0100 MULA.DA.LL mx, at
MULA.DA.HL       RRR   0110 1001 0x00 0000 tttt 0100 MULA.DA.HL mx, at
MULA.DA.LH       RRR   0110 1010 0x00 0000 tttt 0100 MULA.DA.LH mx, at
MULA.DA.HH       RRR   0110 1011 0x00 0000 tttt 0100 MULA.DA.HH mx, at
MULA.DA.LL.LDDEC RRR   0101 1000 0xww ssss tttt 0100 MULA.DA.LL.LDDEC mw, as, mx, at
MULA.DA.HL.LDDEC RRR   0101 1001 0xww ssss tttt 0100 MULA.DA.HL.LDDEC mw, as, mx, at
MULA.DA.LH.LDDEC RRR   0101 1010 0xww ssss tttt 0100 MULA.DA.LH.LDDEC mw, as, mx, at
MULA.DA.HH.LDDEC RRR   0101 1011 0xww ssss tttt 0100 MULA.DA.HH.LDDEC mw, as, mx, at
MULA.DA.LL.LDINC RRR   0100 1000 0xww ssss tttt 0100 MULA.DA.LL.LDINC mw, as, mx, at
MULA.DA.HL.LDINC RRR   0100 1001 0xww ssss tttt 0100 MULA.DA.HL.LDINC mw, as, mx, at
MULA.DA.LH.LDINC RRR   0100 1010 0xww ssss tttt 0100 MULA.DA.LH.LDINC mw, as, mx, at
MULA.DA.HH.LDINC RRR   0100 1011 0xww ssss tttt 0100 MULA.DA.HH.LDINC mw, as, mx, at
MULA.DD.LL       RRR   0010 1000 0x00 0000 0y00 0100 MULA.DD.LL mx, my
MULA.DD.HL       RRR   0010 1001 0x00 0000 0y00 0100 MULA.DD.HL mx, my
MULA.DD.LH       RRR   0010 1010 0x00 0000 0y00 0100 MULA.DD.LH mx, my
MULA.DD.HH       RRR   0010 1011 0x00 0000 0y00 0100 MULA.DD.HH mx, my
MULA.DD.LL.LDDEC RRR   0001 1000 0xww ssss 0y00 0100 MULA.DD.LL.LDDEC mw, as, mx, my
MULA.DD.HL.LDDEC RRR   0001 1001 0xww ssss 0y00 0100 MULA.DD.HL.LDDEC mw, as, mx, my
MULA.DD.LH.LDDEC RRR   0001 1010 0xww ssss 0y00 0100 MULA.DD.LH.LDDEC mw, as, mx, my
MULA.DD.HH.LDDEC RRR   0101 1011 0xww ssss 0y00 0100 MULA.DD.HH.LDDEC mw, as, mx, my
MULA.DD.LL.LDINC RRR   0000 1000 0xww ssss 0y00 0100 MULA.DD.LL.LDINC mw, as, mx, my
MULA.DD.HL.LDINC RRR   0000 1001 0xww ssss 0y00 0100 MULA.DD.HL.LDINC mw, as, mx, my
MULA.DD.LH.LDINC RRR   0000 1010 0xww ssss 0y00 0100 MULA.DD.LH.LDINC mw, as, mx, my
MULA.DD.HH.LDINC RRR   0100 1011 0xww ssss 0y00 0100 MULA.DD.HH.LDINC mw, as, mx, my
MULL             RRR   1000 0010 rrrr ssss tttt 0000 MULL ar, as, at
MULS.AA.LL       RRR   0111 1100 0000 ssss tttt 0100 MULS.AA.LL as, at
MULS.AA.HL       RRR   0111 1101 0000 ssss tttt 0100 MULS.AA.HL as, at
MULS.AA.LH       RRR   0111 1110 0000 ssss tttt 0100 MULS.AA.LH as, at
MULS.AA.HH       RRR   0111 1111 0000 ssss tttt 0100 MULS.AA.HH as, at	
MULS.AD.LL       RRR   0011 1100 0000 ssss 0y00 0100 MULS.AD.LL as, my
MULS.AD.HL       RRR   0011 1101 0000 ssss 0y00 0100 MULS.AD.HL as, my
MULS.AD.LH       RRR   0011 1110 0000 ssss 0y00 0100 MULS.AD.LH as, my
MULS.AD.HH       RRR   0011 1111 0000 ssss 0y00 0100 MULS.AD.HH as, my
MULS.DA.LL       RRR   0110 1100 0x00 0000 tttt 0100 MULS.DA.LL mx, at
MULS.DA.HL       RRR   0110 1101 0x00 0000 tttt 0100 MULS.DA.HL mx, at
MULS.DA.LH       RRR   0110 1110 0x00 0000 tttt 0100 MULS.DA.LH mx, at
MULS.DA.HH       RRR   0110 1111 0x00 0000 tttt 0100 MULS.DA.HH mx, at
MULS.DD.LL       RRR   0010 1100 0x00 0000 0y00 0100 MULS.DD.LL mx, my
MULS.DD.HL       RRR   0010 1101 0x00 0000 0y00 0100 MULS.DD.HL mx, my
MULS.DD.LH       RRR   0010 1110 0x00 0000 0y00 0100 MULS.DD.LH mx, my
MULS.DD.HH       RRR   0010 1111 0x00 0000 0y00 0100 MULS.DD.HH mx, my
MULSH            RRR   1011 0010 rrrr ssss tttt 0000 MULSH ar, as, at
MULUH            RRR   1010 0010 rrrr ssss tttt 0000 MULUH ar, as, at
NEG              RRR   0110 0000 rrrr 0000 tttt 0000 NEG ar, at
NEG.S            RRR   1111 1010 rrrr ssss 0110 0000 NEG.S fr, fs
NOP              RRR   0000 0000 0010 0000 1111 0000 NOP
NOP.N            RRRN            1111 0000 0011 1101 NOP.N
NSA              RRR   0100 0000 1110 ssss tttt 0000 NSA at, as
NSAU             RRR   0100 0000 1111 ssss tttt 0000 NSAU at, as
OEQ.S            RRR   0010 1011 rrrr ssss tttt 0000 OEQ.S br, fs, ft
OLE.S            RRR   0110 1011 rrrr ssss tttt 0000 OLE.S br, fs, ft
OLT.S            RRR   0100 1011 rrrr ssss tttt 0000 OLT.S br, fs, ft
OR               RRR   0010 0000 rrrr ssss tttt 0000 OR ar, as, at
ORB              RRR   0010 0010 rrrr ssss tttt 0000 ORB br, bs, bt
ORBC             RRR   0011 0010 rrrr ssss tttt 0000 ORBC br, bs, bt
PDTLB            RRR   0101 0000 1101 ssss tttt 0000 PDTLB at, as
PITLB            RRR   0101 0000 0101 ssss tttt 0000 PITLB at, as
QUOS             RRR   1101 0010 rrrr ssss tttt 0000 QUOS ar, as, at
QUOU             RRR   1100 0010 rrrr ssss tttt 0000 QUOU ar, as, at
RDTLB0           RRR   0101 0000 1011 ssss tttt 0000 RDTLB0 at, as
RDTLB1           RRR   0101 0000 1111 ssss tttt 0000 RDTLB1 at, as
REMS             RRR   1111 0010 rrrr ssss tttt 0000 REMS ar, as, at
RER              RRR   0100 0000 0110 ssss tttt 0000 RER at, as
RET              CALLX 0000 0000 0000 0000 1000 0000 RET
RET.N            RRRN            1111 0000 0000 1101 RET.N
RETW             CALLX 0000 0000 0000 0000 1001 0000 RETW
RETW.N           RRRN            1111 0000 0001 1101 RETW.N
RFDD             RRR   1111 0001 1110 000s 0001 0000 RFDD
RFDE             RRR   0000 0000 0011 0010 0000 0000 RFDE
RFDO             RRR   1111 0001 1110 0000 0000 0000 RFDO
RFE              RRR   0000 0000 0011 0000 0000 0000 RFE
RFI              RRR   0000 0000 0011 llll 0001 0000 RFI 0..15
RFME             RRR   0000 0000 0011 0000 0010 0000 RFME
RFR              RRR   1111 1010 rrrr ssss 0100 0000 RFR
RFUE             RRR   0000 0000 0011 0001 0000 0000 RFUE
RFWO             RRR   0000 0000 0011 0100 0000 0000 RFWO
RFWU             RRR   0000 0000 0011 0101 0000 0000 RFWU
RITLB0           RRR   0101 0000 0011 ssss tttt 0000 RITLB0 at, as
RITLB1           RRR   0101 0000 0111 ssss tttt 0000 RITLB1 at, as
ROTW             RRR   0100 0000 1000 0000 iiii 0000 ROTW -8..7
ROUND.S          RRR   1000 1010 rrrr ssss tttt 0000 ROUND.S
RSIL             RRR   0000 0000 0110 iiii tttt 0000 RSIL at, 0..15
RSR              RSR   0000 0011 iiii iiii tttt 0000 RSR at, sr
RSYNC            RRR   0000 0000 0010 0000 0001 0000 RSYNC
RUR              RRR   1110 0011 rrrr ssss tttt 0000 RUR ar, ur
S8I              RRI8  iiii iiii 0100 ssss tttt 0010 S8I at, as, 0..255
S16I             RRI8  iiii iiii 0101 ssss tttt 0010 S16I at, as, 0..510
S32C1I           RRI8  iiii iiii 1110 ssss tttt 0010 S32C1I at, as, 0..1020
S32E             RRI4  0100 1001 rrrr ssss tttt 0000 S32E at, as, -64..-4
S32I             RRI8  iiii iiii 0110 ssss tttt 0010 S32I at, as, 0..1020
S32I.N           RRRN            iiii ssss tttt 1001 S32I.N at, as, 0..60
S32RI            RRI8  iiii iiii 1111 ssss tttt 0010 S32RI at, as, 0..1020
SDCT             RRR   1111 0001 1001 ssss tttt 0000 SDCT at, as
SEXT             RRR   0010 0011 rrrr ssss tttt 0000 SEXT ar, as, 7..22
SICT             RRR   1111 0001 0001 ssss tttt 0000 SICT at, as
SICW             RRR   1111 0001 0011 ssss tttt 0000 SICW at, as
SIMCALL          RRR   0000 0000 0101 0001 0000 0000 SIMCALL
SLL              RRR   1010 0001 rrrr ssss 0000 0000 SLL ar, as
SLLI             RRR   000i 0001 rrrr ssss iiii 0000 SLLI ar, as, 1..31
SRA              RRR   1011 0001 rrrr 0000 tttt 0000 SRA ar, at
SRAI             RRR   001i 0001 rrrr iiii tttt 0000 SRAI ar, at, 0..31
SRC              RRR   1000 0001 rrrr ssss tttt 0000 SRC ar, as, at
SRL              RRR   1001 0001 rrrr 0000 tttt 0000 SRL ar, at
SRLI             RRR   0100 0001 rrrr iiii tttt 0000 SRLI ar, at, 0..15
SSA8B            RRR   0100 0000 0011 ssss 0000 0000 SSA8B as
SSA8L            RRR   0100 0000 0010 ssss 0000 0000 SSA8L as
SSAI             RRR   0100 0000 0100 iiii 000i 0000 SSAI 0..31
SSI              RRI8  iiii iiii 0100 ssss tttt 0011 SSI ft, as, 0..1020
SSIU             RRI8  iiii iiii 1100 ssss tttt 0011 SSIU ft, as, 0..1020
SSL              RRR   0100 0000 0001 ssss 0000 0000 SSL as
SSR              RRR   0100 0000 0000 ssss 0000 0000 SSR as
SSX              RRR   0100 1000 rrrr ssss tttt 0000 SSX fr, as, at
SSXU             RRR   0101 1000 rrrr ssss tttt 0000 SSXU fr, as, at
SUB              RRR   1100 0000 rrrr ssss tttt 0000 SUB ar, as, at
SUB.S            RRR   0001 1010 rrrr ssss tttt 0000 SUB.S fr, fs, ft
SUBX2            RRR   1101 0000 rrrr ssss tttt 0000 SUBX2 ar, as, at
SUBX4            RRR   1110 0000 rrrr ssss tttt 0000 SUBX4 ar, as, at
SUBX8            RRR   1111 0000 rrrr ssss tttt 0000 SUBX8 ar, as, at
SYSCALL          RRR   0000 0000 0101 0000 0000 0000 SYSCALL
TRUNC.S          RRR   1001 1010 rrrr ssss tttt 0000 TRUNC.S ar, fs, 0..15
UEQ.S            RRR   0011 1011 rrrr ssss tttt 0000 UEQ.S br, fs, ft
UFLOAT.S         RRR   1101 1010 rrrr ssss tttt 0000 UFLOAT.S fr, as, 0..15
ULE.S            RRR   0111 1011 rrrr ssss tttt 0000 ULE.S br, fs, ft
ULT.S            RRR   0101 1011 rrrr ssss tttt 0000 ULT.S br, fs, ft
UMUL.AA.LL       RRR   0111 0000 0000 ssss tttt 0100 UMUL.AA.LL as, at
UMUL.AA.HL       RRR   0111 0001 0000 ssss tttt 0100 UMUL.AA.HL as, at
UMUL.AA.LH       RRR   0111 0010 0000 ssss tttt 0100 UMUL.AA.LH as, at
UMUL.AA.HH       RRR   0111 0011 0000 ssss tttt 0100 UMUL.AA.HH as, at
UN.S             RRR   0001 1011 rrrr ssss tttt 0000 UN.S br, fs, ft
UTRUNC.S         RRR   1110 1010 rrrr ssss tttt 0000 UTRUNC.S ar, fs, 0..15
WAITI            RRR   0000 0000 0111 iiii 0000 0000 WAITI 0..15
WDTLB            RRR   0101 0000 1110 ssss tttt 0000 WDTLB at, as
WER              RRR   0100 0000 0111 ssss tttt 0000 WER at, as
WFR              RRR   1111 1010 rrrr ssss 0101 0000 WFR fr, as
WITLB            RRR   0101 0000 0110 ssss tttt 0000 WITLB at, as
WSR              RSR   0001 0011 iiii iiii tttt 0000 WSR at, sr
WUR              RSR   1111 0011 iiii iiii tttt 0000 WUR at, ur
XOR              RRR   0011 0000 rrrr ssss tttt 0000 XOR ar, as, at
XORB             RRR   0100 0010 rrrr ssss tttt 0000 XORB br, bs, bt
XSR              RSR   0110 0001 iiii iiii tttt 0000 XSR at, sr
"""

def parse():
    parsed = []
    lines = instructions.split("\n")
    for line in lines:
        if line.strip() == "": continue
        parsed.append(parseLine(line))
    return parsed
        
def parseLine(line):
    name = line[0:16].strip()
    encoding = line[16:23].strip()
    
    code = line[23:53].strip()
    display = line[53:].strip()
    
    enc = code.replace(" ", "")
    
    encP = list(enc)
    for i in range(len(encP)):
        if encP[i] == '1':
            encP[i] = '1'
        else:
            encP[i] = '0'
    maskP = int(''.join(encP),2)
    
    encN = list(enc)
    for i in range(len(encN)):
        if encN[i] == '0':
            encN[i] = '1'
        else:
            encN[i] = '0'
    maskN = int(''.join(encN),2)
    lenE = len(enc)/8
    
    return (name, encoding, code, display, (lenE, maskP, maskN))

#print("...")
partsedInstructions = parse()


def getInstruction(data, l):
    if l >= 3:
        t = struct.unpack(">BBB", data[0:3])
        return (t[0]&0xFF) | ((t[1]&0xFF)<<8) | ((t[2]&0xFF)<<16)
    if l >= 2:
        t = struct.unpack(">BB", data[0:2])
        return (t[0]&0xFF) | ((t[1]&0xFF)<<8)
    return -1
    
    
def tryToParse2(data, bEnc, parsed):
    if bEnc&parsed[4][1] != parsed[4][1]: return False
    if (~bEnc)&parsed[4][2] != parsed[4][2]: return False
    #print(hex(bEnc))
    return True

def tryToParse(data, parsed):
    if parsed[4][0] > len(data): return False
    bEnc = getInstruction(data, parsed[4][0])
    return tryToParse2(data, bEnc, parsed)
    
TYPE_REG = "TYPE_REG"
TYPE_FREG = "TYPE_FREG"
TYPE_BREG = "TYPE_BREG"
TYPE_SREG = "TYPE_SREG"
TYPE_UREG = "TYPE_UREG"
TYPE_MREG = "TYPE_MREG"
TYPE_IMM = "TYPE_IMM"
TYPE_LABEL = "TYPE_LABEL"

def getSignedNumber(number, bitLength):
    mask = (2 ** bitLength) - 1
    if number & (1 << (bitLength - 1)):
        return number | ~mask
    else:
        return number & mask
    
printFormat = {
        "ABS": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["t"])],
        "ABS.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["t"])],
        "ADD": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ADD.N": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ADD.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "ADDI": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, getSignedNumber(m["i"], 8))],
        "ADDI.N": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_IMM, (-1 if m["t"] == 0 else  m["t"]))],
        "ADDMI": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, getSignedNumber(m["i"], 8)<<8)],
        "ADDX2": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ADDX4": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ADDX8": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ALL4": lambda m: [(TYPE_BREG, m["t"]), (TYPE_BREG, m["s"])],
        "ALL8": lambda m: [(TYPE_BREG, m["t"]), (TYPE_BREG, m["s"])],
        "AND": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ANDB": lambda m: [(TYPE_BREG, m["r"]), (TYPE_BREG, m["s"]), (TYPE_BREG, m["t"])],
        "ANDBC": lambda m: [(TYPE_BREG, m["r"]), (TYPE_BREG, m["s"]), (TYPE_BREG, m["t"])],
        "ANY4": lambda m: [(TYPE_BREG, m["t"]), (TYPE_BREG, m["s"])],
        "ANY8": lambda m: [(TYPE_BREG, m["t"]), (TYPE_BREG, m["s"])],
        "BALL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BANY": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BBC": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BBCI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["b"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BBS": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BBSI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["b"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BEQ": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BEQI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["r"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BEQZ": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],12)+4)],
        "BEQZ.N": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+m["i"]+4)],
        "BF": lambda m: [(TYPE_BREG, m["s"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BGE": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BGEI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["r"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BGEU": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BGEUI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["r"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BLT": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BLTI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["r"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BLTU": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BLTUI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["r"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BLTZ": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],12)+4)],
        "BNALL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BNE": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BNEI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["r"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BNEZ": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],12)+4)],
        "BNEZ.N": lambda m: [(TYPE_REG, m["s"]),(TYPE_LABEL, m["addr"]+m["i"]+4)],
        "BNONE": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "BREAK": lambda m: [(TYPE_IMM, m["s"]), (TYPE_IMM, m["t"])],
        "BREAK.N": lambda m: [(TYPE_IMM, m["s"])],
        "BT": lambda m: [(TYPE_BREG, m["s"]), (TYPE_LABEL, m["addr"]+getSignedNumber(m["i"],8)+4)],
        "CALL0": lambda m: [(TYPE_LABEL, ((m["addr"]>>2)+getSignedNumber(m["o"],18)+1)<<2)],
        "CALL4": lambda m: [(TYPE_LABEL, ((m["addr"]>>2)+getSignedNumber(m["o"],18)+1)<<2)],
        "CALL8": lambda m: [(TYPE_LABEL, ((m["addr"]>>2)+getSignedNumber(m["o"],18)+1)<<2)],
        "CALL12": lambda m: [(TYPE_LABEL, ((m["addr"]>>2)+getSignedNumber(m["o"],18)+1)<<2)],
        "CALLX0": lambda m: [(TYPE_REG, m["s"])],
        "CALLX4": lambda m: [(TYPE_REG, m["s"])],
        "CALLX8": lambda m: [(TYPE_REG, m["s"])],
        "CALLX12": lambda m: [(TYPE_REG, m["s"])],
        "CEIL.S": lambda m: [(TYPE_REG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_IMM, m["t"])],
        "CLAMPS": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["t"]+7)],
        "DHI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DHU": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "DHWB": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DHWBI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DII": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DIU": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "DIWB": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "DIWBI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "DPFL": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "DPFR": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DPFRO": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DPFW": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DPFWO": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "DSYNC": lambda m: [],
        "ENTRY": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<3)],
        "ESYNC": lambda m: [], 
        "EXCW": lambda m: [], 
        "EXTUI": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["t"]),(TYPE_IMM, m["i"]),(TYPE_IMM, m["p"])], 
        "EXTW": lambda m: [], 
        "FLOAT.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["t"]+7)],
        "FLOOR.S": lambda m: [(TYPE_REG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_IMM, m["t"]+7)],
        "IDTLB": lambda m: [(TYPE_REG, m["s"])],
        "IHI": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "IHU": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "III": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "IITLB": lambda m: [(TYPE_REG, m["s"])],
        "IIU": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "ILL": lambda m: [],
        "ILL.N": lambda m: [],
        "IPF": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "IPFL": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<4)],
        "ISYNC": lambda m: [],
        "J": lambda m: [(TYPE_LABEL, m["addr"]+getSignedNumber(m["o"],18)+4)],
        "JX": lambda m: [(TYPE_REG, m["s"])],
        "L8UI": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"])],
        "L16SI": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<1)],
        "L16UI": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<1)],
        "L32AI": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "L32E": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, -4*(m["r"]+1))],
        "L32I": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "L32I.N": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
       # "L32R": lambda m: [(TYPE_REG, m["t"]), (TYPE_LABEL,  ((m["addr"]+3)&0xFFFFFFFC) + (getSignedNumber(m["i"], 16)<<2))],
        "L32R": lambda m: [(TYPE_REG, m["t"]), (TYPE_LABEL, ((m["addr"]+3+(getSignedNumber(m["i"], 16)<<2))&0xfffffffc if getSignedNumber(m["i"], 16) < 0 else (((m["addr"]+3+(getSignedNumber(m["i"], 16)<<2))-0x40000)&0xfffffffc)))],
        "LDCT": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "LDDEC": lambda m: [(TYPE_MREG, m["w"]), (TYPE_REG, m["s"])],
        "LDINC": lambda m: [(TYPE_MREG, m["w"]), (TYPE_REG, m["s"])],
        "LICT": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "LICW": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "LOOP": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+m["i"]+4)],
        "LOOPGTZ": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+m["i"]+4)],
        "LOOPNEZ": lambda m: [(TYPE_REG, m["s"]), (TYPE_LABEL, m["addr"]+m["i"]+4)],
        "LSI": lambda m: [(TYPE_FREG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "LSIU": lambda m: [(TYPE_FREG, m["t"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "LSX": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "LSXU": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MADD.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MAX": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MAXU": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MEMW": lambda m: [],
        "MIN": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MINU": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MOV.N": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "MOV.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"])],
        "MOVEQZ": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MOVEQZ.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MOVF": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_BREG, m["t"])],
        "MOVF.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_BREG, m["t"])],
        "MOVGEZ": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MOVGEZ.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MOVI": lambda m: [(TYPE_REG, m["t"]), (TYPE_IMM, getSignedNumber(m["i"], 12))],
        "MOVI.N": lambda m: [(TYPE_REG, m["s"]), (TYPE_IMM, getSignedNumber((m["i"] | (0x80 if ((m["i"]&0x40)!=0) and ((m["i"]&0x20)!=0) else 0)), 8))], # 7bit positve bias
        "MOVLTZ": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MOVLTZ.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MOVNEZ": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MOVNEZ.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MOVSP": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "MOVT": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_BREG, m["t"])],
        "MOVT.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_BREG, m["t"])],
        "MSUB.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MUL.AD.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MUL.AD.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MUL.AD.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MUL.AD.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MUL.AD.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MUL.AD.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MUL.AD.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MUL.AD.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MUL.DA.LL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MUL.DA.HL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MUL.DA.LH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MUL.DA.HH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MUL.DD.LL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MUL.DD.HL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MUL.DD.LH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MUL.DD.HH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MUL.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "MUL16S": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MUL16U": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULA.AA.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULA.AA.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULA.AA.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULA.AA.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULA.AD.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULA.AD.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULA.AD.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULA.AD.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULA.DA.LL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.HL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.LH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.HH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.LL.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.HL.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.LH.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.HH.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.LL.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.HL.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.LH.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DA.HH.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULA.DD.LL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.HL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.LH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.HH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.LL.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.HL.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.LH.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.HH.LDDEC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.LL.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.HL.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.LH.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULA.DD.HH.LDINC": lambda m: [(TYPE_MREG, m["w"]),(TYPE_REG, m["s"]), (TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULL": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULS.AA.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULS.AA.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULS.AA.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULS.AA.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULS.AD.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULS.AD.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULS.AD.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULS.AD.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_MREG, m["y"])],
        "MULS.DA.LL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULS.DA.HL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULS.DA.LH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULS.DA.HH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_REG, m["t"])],
        "MULS.DD.LL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULS.DD.HL": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULS.DD.LH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULS.DD.HH": lambda m: [(TYPE_MREG, m["x"]), (TYPE_MREG, m["y"])],
        "MULSH": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "MULUH": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "NEG": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["t"])],
        "NEG.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"])],
        "NOP": lambda m: [],
        "NOP.N": lambda m: [],
        "NSA": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "NSAU": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "OEQ.S": lambda m: [(TYPE_BREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "OLE.S": lambda m: [(TYPE_BREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "OLT.S": lambda m: [(TYPE_BREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "OR": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "ORB": lambda m: [(TYPE_BREG, m["r"]), (TYPE_BREG, m["s"]), (TYPE_BREG, m["t"])],
        "ORBC": lambda m: [(TYPE_BREG, m["r"]), (TYPE_BREG, m["s"]), (TYPE_BREG, m["t"])],
        "PDTLB": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "PITLB": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "QUOS": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "QUOU": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "RDTLB0": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "RDTLB1": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "REMS": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "RER": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "RET": lambda m: [],
        "RET.N": lambda m: [],
        "RETW": lambda m: [],
        "RETW.N": lambda m: [],
        "RFDD": lambda m: [],
        "RFDE": lambda m: [],
        "RFDO": lambda m: [],
        "RFE": lambda m: [],
        "RFI": lambda m: [(TYPE_IMM, m["l"])],
        "RFME": lambda m: [],
        "RFR": lambda m: [],
        "RFUE": lambda m: [],
        "RFWO": lambda m: [],
        "RFWU": lambda m: [],
        "RITLB0": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"])],
        "RITLB1": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"])],
        "ROTW": lambda m: [(TYPE_IMM, getSignedNumber(m["i"],4))],
        "ROUND.S": lambda m: [],
        "RSIL": lambda m: [(TYPE_REG, m["t"]),(TYPE_IMM, m["i"])],
        "RSR": lambda m: [(TYPE_REG, m["t"]),(TYPE_SREG, m["i"])],
        "RSYNC": lambda m: [],
        "RUR": lambda m: [(TYPE_REG, m["r"]),(TYPE_UREG, 16*m["s"]+m["t"])],
        "S8I": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"])],
        "S16I": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<1)],
        "S32C1I": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "S32E": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, -4*(m["r"]+1))],
        "S32I": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "S32I.N": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "S32RI": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"]<<2)],
        "SDCT": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"])],
        "SEXT": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["t"]+7)],
        "SICT": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"])],
        "SICW": lambda m: [(TYPE_REG, m["t"]),(TYPE_REG, m["s"])],
        "SIMCALL": lambda m: [],
        "SLL": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["s"])],
        "SLLI": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["s"]), (TYPE_IMM, m["i"])],
        "SRA": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["t"])],
        "SRAI": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["t"]), (TYPE_IMM, m["i"])],
        "SRC": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["s"]),(TYPE_REG, m["t"])],
        "SRL": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["t"])],
        "SRLI": lambda m: [(TYPE_REG, m["r"]),(TYPE_REG, m["t"]), (TYPE_IMM, m["i"])],
        "SSA8B": lambda m: [(TYPE_REG, m["s"])],
        "SSA8L": lambda m: [(TYPE_REG, m["s"])],
        "SSAI": lambda m: [(TYPE_IMM, m["i"])],
        "SSI": lambda m: [(TYPE_FREG, m["t"]),(TYPE_REG, m["s"]),(TYPE_IMM, m["i"]<<2)],
        "SSIU": lambda m: [(TYPE_FREG, m["t"]),(TYPE_REG, m["s"]),(TYPE_IMM, m["i"]<<2)],
        "SSL": lambda m: [(TYPE_REG, m["s"])],
        "SSR": lambda m: [(TYPE_REG, m["s"])],
        "SSX": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "SSXU": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "SUB": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "SUB.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "SUBX2": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "SUBX4": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "SUBX8": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "SYSCALL": lambda m: [],
        "TRUNC.S": lambda m: [(TYPE_REG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_IMM, m["t"])],
        "UEQ.S": lambda m: [(TYPE_BREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "UFLOAT.S": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"]), (TYPE_IMM, m["t"])],
        "ULE.S": lambda m: [(TYPE_BREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "ULT.S": lambda m: [(TYPE_BREG, m["r"]), (TYPE_FREG, m["s"]), (TYPE_FREG, m["t"])],
        "UMUL.AA.LL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "UMUL.AA.HL": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "UMUL.AA.LH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "UMUL.AA.HH": lambda m: [(TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "UN.S": lambda m: [(TYPE_BREG, m["r"]),(TYPE_FREG, m["s"]),(TYPE_FREG, m["t"])],
        "UTRUNC.S": lambda m: [(TYPE_REG, m["r"]),(TYPE_FREG, m["s"]),(TYPE_IMM, m["t"])],
        "WAITI": lambda m: [(TYPE_IMM, m["i"])],
        "WDTLB": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "WER": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "WFR": lambda m: [(TYPE_FREG, m["r"]), (TYPE_REG, m["s"])],
        "WITLB": lambda m: [(TYPE_REG, m["t"]), (TYPE_REG, m["s"])],
        "WSR": lambda m: [(TYPE_REG, m["t"]), (TYPE_SREG, m["i"])],
        "WUR": lambda m: [(TYPE_REG, m["t"]), (TYPE_UREG, m["i"])],
        "XOR": lambda m: [(TYPE_REG, m["r"]), (TYPE_REG, m["s"]), (TYPE_REG, m["t"])],
        "XORB": lambda m: [(TYPE_BREG, m["r"]), (TYPE_BREG, m["s"]), (TYPE_BREG, m["t"])],
        "XSR": lambda m: [(TYPE_REG, m["t"]), (TYPE_SREG, m["i"])],
}
    
    
"""
.text:401001B0
.text:401001B0 Cache_Read_Enable_New:                  ; CODE XREF: .text:40100452
.text:401001B0                                         ; .text:loc_401006AC ...
.text:401001B0                 addi           , a1, a1, 0xF0
.text:401001B3                 s32i.n         , a0, a1, 0
.text:401001B5                 l32r           , a0, off_401001A8
.text:401001B8                 l8ui           , a0, a0, 0
.text:401001BB                 beqz.n         , a0, loc_401001CF
.text:401001BD ; ---------------------------------------------------------------------------
.text:401001BD                 bnei           , a0, 1, loc_401001DB
.text:401001C0 ; ---------------------------------------------------------------------------
.text:401001C0                 movi.n         , a2, 1
.text:401001C2                 movi.n         , a3, 0
.text:401001C4                 movi.n         , a4, 1
.text:401001C6                 l32r           , a0, dword_401001AC
.text:401001C9                 callx0         , a0
.text:401001CC ; ---------------------------------------------------------------------------
.text:401001CC                 j              , loc_401001DB
.text:401001CF ; ---------------------------------------------------------------------------
.text:401001CF
.text:401001CF loc_401001CF:                           ; CODE XREF: Cache_Read_Enable_New+B
.text:401001CF                 movi.n         , a2, 0
.text:401001D1                 movi.n         , a3, 0
.text:401001D3                 movi.n         , a4, 1
.text:401001D5                 l32r           , a0, dword_401001AC
.text:401001D8                 callx0         , a0
.text:401001DB ; ---------------------------------------------------------------------------
.text:401001DB
.text:401001DB loc_401001DB:                           ; CODE XREF: Cache_Read_Enable_New+D
.text:401001DB                                         ; Cache_Read_Enable_New+1C
.text:401001DB                 l32i.n         , a0, a1, 0
.text:401001DD                 addi           , a1, a1, 0x10
.text:401001E0                 ret.n
.text:401001E0 ; End of function Cache_Read_Enable_New
"""
    
    

def getEnc(data):
    for pI in partsedInstructions:
        if tryToParse(data, pI): return pI
    return None
    
    
    
    
def decodeEnc(data, addr=0):
    pI = getEnc(data)
    if pI == None: return None
    
    bEnc = getInstruction(data, pI[4][0])
    m = {}
    enc = pI[2].replace(" ", "")
    for i in range(len(enc)):
        if enc[i] != '0' and enc[i] != '1':
            v = ((bEnc >> ((8*pI[4][0]-1)-i))&1)
            if enc[i] in m:
                m[enc[i]] = (m[enc[i]] << 1) | v
            else:
                m[enc[i]] =  v
    m["name"] = pI[0]
    m["type"] = pI[1]
    m["len"]  = pI[4][0]
    m["addr"] = addr
    
    if pI[0] in printFormat:
        m["format"] = printFormat[pI[0]](m)
    else:
        m["format"] = []
        
    #print(m)
    
    return m
    
#print(decodeEnc("\x12\xc1\xf0"))
#print(decodeEnc("\x20\xe7\x13"))

def decode(data, addr):
    obj = XTENSA_INSTRUCTION()
    inst = decodeEnc(data, addr)
    if inst != None:
        obj.name = inst["name"]
        obj.len  = inst["len"]
        obj.prop = inst
    return obj
```

`binary-xtensa/__init__.py`:

```py
import binaryninja

from .XTENSAArch import XTENSA
XTENSA.register()


# built-in view
EM_XTENSA = 94
binaryninja.BinaryViewType['ELF'].register_arch(EM_XTENSA, binaryninja.enums.Endianness.LittleEndian, binaryninja.Architecture['XTENSA'])
```

`binary-xtensa/plugin.json`:

```json
{
    "plugin": {
        "name": "XTensa Disassembler",
        "type": ["architecture"],
        "api": "python2",
        "description": "XTensa Disassembler for ELF Files",
        "license": {
            "name": "BSD-0-clause"
        },
        "version": "1.0",
        "author": "Pusty"
    }
}
```